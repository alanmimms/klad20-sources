%TITLE 'STIRS TESTS FOR M8622 (CRA) BOARD'

MODULE MSCRAT	(
		LANGUAGE(BLISS36)
		) =

BEGIN

!
!			  COPYRIGHT (C) 1979 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.  
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
!
! ABSTRACT:
!
!	THIS MODULE CONTAIN THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
!	(STIRS) DIAGNOSTIC FOR THE M8622 (CRA) BOARD.  IT ALSO CONTAINS SEVERAL
!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
!	'MSCRAD' MODULES TO PRODUCE THE 'MSCRA.EXE' FILE.
!
! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
!
! AUTHOR: RICH MURATORI	, CREATION DATE: 23-MAY-79
!
! MODIFIED BY:
!
!	RICH MURATORI, 23-MAY-79; VERSION 0.1
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	SPEC_DIALOGUE: NOVALUE,		!SPECIAL USER DIALOGUE
	SPEC_PRT,			!SPECIAL FEATURE PRINTING
	SPEC_ASK: NOVALUE,		!SPECIAL FEATURE QUESTIONS
	TEST_INIT: NOVALUE,		!INITIALIZATION ROUTINE
	CLEAR_CRAM: NOVALUE,		!CLEAR CRAM BITS IN CRAM LOC 0
	RESET_CRAM: NOVALUE,		!DO A 'CRA/M RESET'
	WRITE_CRAM: NOVALUE,		!WRITE 12 BITS OF DATA INTO CRAM
	CLK_DATA: NOVALUE,		!CLOCKS 12 BITS OF DATA TO CRA BOARD
	READ_DATA,			!READS 12 BITS OF DATA FROM CRA BOARD
	READ_SBR,			!READS KS10 SUBROUTINE STACK RETURN ADDR
	EC_BITS,			!READS 96 BITS OF CRAM DATA
	TST1 : NOVALUE,			!READING DIAG MUX WITH DIAG FN = 7
	TST2 : NOVALUE,			!WRITING AND READING KS10 BUS BITS
	TST3 : NOVALUE,			!WRITING AND READING CRAM BITS 0-11
	TST4 : NOVALUE,			!WRITING AND READING CRAM BITS 12-23
	TST5 : NOVALUE,			!WRITING AND READING CRAM BITS 24-35A
	TST6 : NOVALUE,			!WRITING AND READING CRAM BITS 24-35B
	TST7 : NOVALUE,			!RESETTING OF CRAM BITS 0-11
	TST8 : NOVALUE,			!RESETTING OF CRAM BITS 12-23
	TST9 : NOVALUE,			!RESETTING OF CRAM BITS 24-35 A&B
	TST10 : NOVALUE,		!SETTING NEXT CRAM ADDR USING DIAG ADR
	TST11 : NOVALUE,		!'CURR LOC' CLOCKING
	TST12 : NOVALUE,		!SETTING NEXT CRAM ADDR USING J FIELD
	TST13 : NOVALUE,		!BITS 0-35 TEST FOR ALL CRAM LOCS
	TST14 : NOVALUE,		!CRAM ADDRESS DRIVERS
	TST15 : NOVALUE,		!'SBR RET' CLOCKING
	TST16 : NOVALUE,		!'SBR RET' BIT TEST
	TST17 : NOVALUE,		!SETTING NXT CRAM ADR USING 'SBR RET'
	TST18 : NOVALUE,		!SUBROUTINE STACK
	TST19 : NOVALUE,		!'STACK RESET'
	TST20 : NOVALUE,		!NICOND DISPATCH
	TST21 : NOVALUE,		!'SKIP 10' WITH 'TRAP CYCLE' INPUT
	TST22 : NOVALUE,		!CONSOLE EXEC MODE SKIPPING
	TST23 : NOVALUE,		!'NOT CONTINUE' SKIPPING
	TST24 : NOVALUE,		!'NOT 1 MSEC TIMER' SKIPPING
	TST25 : NOVALUE,		!'NOT I/O LATCH' SKIPPING
	TST26 : NOVALUE,		!'AD EQ 0' SKIPPING
	TST27 : NOVALUE,		!'SC SIGN BIT' SKIPPING
	TST28 : NOVALUE,		!'DPM3 SCAD 00' DISPATCHING
	TST29 : NOVALUE,		!'DPE5 FLAG QR 37' DISPATCHING
	TST30 : NOVALUE,		!'DPM6 MEMORY CYCLE' DISPATCHING
	TST31 : NOVALUE,		!BYTE DISPATCHING
	TST32 : NOVALUE,		!EFFECTIVE ADDRESS MODE DISPATCHING
	TST33 : NOVALUE,		!DROM DISPATCHING
	TST34 : NOVALUE,		!'AREAD' DISPATCHING
	TST35 : NOVALUE,		!PAGE FAIL DISPATCHING TO 7777
	TST36 : NOVALUE,		!'SKIP 40' SKIPPING
	TST37 : NOVALUE,		!'SKIP 20' SKIPPING
	TST38 : NOVALUE,		!'CRA2 RETURN' SIGNAL ASSERTION
	TST39 : NOVALUE,		!'SPEC/CONSOLE' SIGNAL ASSERTION
	TST40 : NOVALUE;		!CRAM PARITY DETECTION NETWORK
!
! INCLUDE FILES:
!

REQUIRE 'REGBIT.R36';				!8080 I/O REGISTER BIT DEFINITIONS
REQUIRE 'KSU.R36';				!KS10 MICROCODE MACROS
REQUIRE 'CSLMAC.R36';				!'CSL' INTERFACE MACROS
REQUIRE 'STIRSD.R36';				!LINKAGE TO 'MSSTRC' DEFINITIONS

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

GLOBAL LITERAL
	TEST_VERSION = 1,			!VERSION NUMBER FOR THIS MODULE
	TEST_EDIT = 1;				!EDIT NUMBER FOR THIS MODULE

GLOBAL BIND
	MSGFIL = UPLIT(%SIXBIT 'MSCRA',%SIXBIT 'MSG'),
	PRGNAM = UPLIT(%ASCIZ 'KS10 STIMULUS-RESPONSE DIAGNOSTIC FOR THE M8622/CRA BOARD');


!
! OWN STORAGE:
!

!
! EXTERNAL REFERENCES:
!


GLOBAL ROUTINE SPEC_DIALOGUE: NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!
!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PERFORM ANY
!	SPECIAL USER DIALOGUE BEFORE THE ACTIVATED FEATURES ARE LISTED.
!	SINCE THIS TEST MODULE HAS NO SPECIAL DIALOGUE, THIS ROUTINE IS NUL.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
	BEGIN
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

GLOBAL ROUTINE SPEC_PRT =

!++
! FUNCTIONAL DESCRIPTION
!
!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PRINT ANY SPECIAL
!	PROGRAM FEATURES WHICH MAY BE ACTIVATED.  SINCE THIS TEST MODULE HAS NO
!	SPECIAL FEATURES, THE ROUTINE IS NUL.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
	BEGIN
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

GLOBAL ROUTINE SPEC_ASK: NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!
!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO ASK THE USER IF
!	HE/SHE WISHES TO ACTIVATE FEATURES WHICH ARE PECULIAR TO THIS TEST
!	MODULE.  SINCE THIS MODULE HAS NO SPECIAL FEATURES, THE ROUTINE IS NUL.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
	BEGIN
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

GLOBAL ROUTINE TEST_INIT: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE INITIALIZES THE KS10 HARDWARE BEFORE ANY TESTING IS DONE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	EXECUTES SEVERAL 8080 COMMAND STRINGS TO WHICH INITIALIZE THE KS10
!	HARDWARE.
!
!--
	BEGIN
	BIND
		UC_PTR = PLIT(U_J(0) U_SPEC_MEMCLR U);

	RPT_ERR_FLAG = 0;		!SET FLAG TO NOT REPORT 8080 CMD ERRORS
	PE(0);				!TURN OFF 8080 PARITY DETECTION
	SC_0();				!TURN OFF SOFT CRAM ERR RECOVERY
	LOADUC(0,UC_PTR);		!LOAD MEM CLR INSTR
	CP_NOSS(3);			!EXECUTE INSTR TO CLEAR PAGE FAULT
	CLEAR_CRAM();			!CLEAR CRAM BITS IN LOC 0
	CP_NOSS(1);			!CLOCK ZERO ADDR INTO CURR LOC
	WRT204(7);			!RESET STACK, DP, AND CRAM LATCHES
	WRT204(0);
	DM(31,0);			!CLEAR KEEP ALIVE AND STATUS WORD SO 8080
					! WON'T TRY TO REBOOT IF TESTS GENERATE
					! A 'HALTED' MESSAGE.

	WRT114(0);			!MAKE SURE BUS CONTROL BITS ARE
	WRT115(0);			!CLEARED IN I/O BUFFERS
	SEND_NUL();			!FORCE SENDING OF COMMAND LINE

	CHK_ERR_MSG(PAR_ERR);		!CHECK IN CASE 'PE (1)' IS STUCK
	END;

ROUTINE CLEAR_CRAM: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE DOES A MASTER RESET OF THE KS10 AND DEPOSITS ALL ZEROS
!	INTO LOCATION 0 OF THE CRAM.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	DOES A MASTER RESET OF THE KS10 AND DEPOSITS 0 INTO CRAM LOC 0.
!
!--
	BEGIN
	BIND
		DC_0 = UPLIT(%ASCIZ 'LC0,DC0');	!CMD STRING TO DEPOSIT ZEROS

	MR();				!DO A KS10 MASTER RESET
	SEND_LINE(DC_0,0);		!INSURE CRAM BITS ARE CLEARED
	END;

ROUTINE RESET_CRAM: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE IS CALLED TO TOGGLE THE 'CRA/M RESET' SIGNAL IN THE
!	KS10.  THIS CLEARS THE CRAM CONTROL BITS LATCHES.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	CONCATENATES A COMMAND STRING TO ASSERT AND NEGATE THE 'CRA/M RESET'
!	BIT IN 8080 REGISTER 204 ONTO THE CUMULATIVE COMMAND LINE.
!
!--
	BEGIN
	WRT204(CRAM_RESET);			!ASSERT CRA/M RESET
	WRT204(0);				!THEN NEGATE IT
	END;

ROUTINE WRITE_CRAM(DIAG_FN,DATA): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE WRITES THE SPECIFIED DATA INTO A 12-BIT FIELD OF THE
!	KS10 CRAM AS DETERMINED BY THE 'DIAG_FN' PARAMETER.  THE LOCATION
!	WHICH GETS WRITTEN INTO WILL BE WHICHEVER ONE WAS LAST REFERENCED BY
!	AN 'LC' OR 'EC' COMMAND.
!
! FORMAL PARAMETERS:
!
!	DIAG_FN		= DIAGNOSTIC FUNCTION CODE - 0 THRU 7
!	DATA		= 12 BITS OF DATA TO BE WRITTEN INTO CRAM
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	WRITES SPECIFIED DATA INTO SPECIFIED FIELD OF KS10 CRAM.
!
!--
	BEGIN
	CLK_DATA(.DATA);		!CLOCK DATA TO CRA BOARD
	WRT205(.DIAG_FN);		!SET DIAG FN
	WRT204(CRAM_WRT);		!WRITE DATA INTO CRAM
	WRT204(0);			!CLEAR WRITE BIT
	END;

ROUTINE CLK_DATA(DATA): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE CLOCKS THE SPECIFIED 12-BIT DATA INTO THE CRA BOARD
!	TRANSCEIVERS.
!
! FORMAL PARAMETERS:
!
!	DATA		= 12-BIT DATA
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	CLOCKS 12 BITS OF DATA INTO THE CRA BOARD TRANSCEIVERS.
!
!--
	BEGIN
	WRT103(.DATA AND %O'377');	!WRITE BITS 28-35 TO REG 103
	WRT105((.DATA AND %O'7400')^-8); !WRITE BITS 24-27 TO REG 105
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA BOARD TRANSCEIVERS
	END;

ROUTINE READ_DATA =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE READS 12 BITS OF DATA FROM THE CRA BOARD DIAGNOSTIC MUX.
!	THE MUX SELECT INPUTS WILL BE DETERMINED BY THE LAST 'LF' COMMAND
!	WHICH LOADS THE DIAGNOSTIC FUNCTION CODE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	12 BIT DATA READ FROM THE CRA BOARD MUX.
!
! SIDE EFFECTS:
!
!	READS 12 BITS OF DATA FROM CRA BOARD MUX.
!
!--
	BEGIN
	LOCAL
		TEMP;
	WRT210(BUS_REQ + CRA_T_CLK + CLOSE_LATCH);  !READ CRA BOARD DATA INTO TRANSCEIVERS
	TEMP = RD_1 AND %O'17';		!GET BITS 24-27
	RETURN (.TEMP^8 OR RD_0);	!RETURN BITS 24-35
	END;

ROUTINE READ_SBR =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE READS THE SUBROUTINE RETURN ADDRESS FROM THE KS10 SUBROUTINE
!	STACK.  IT DOES THIS BY EXECUTING AN 'EJ' COMMAND AND RETURNING THE
!	'SBR' PORTION OF THE RESPONSE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	12 BIT SUBROUTINE RETURN ADDRESS
!
! SIDE EFFECTS:
!
!	EXECUTES AN 'EJ' COMMAND.
!
!--
	BEGIN
	RETURN .(EJ() + 3);		!EXECUTE 'EJ' CMD AND RETURN 'SBR'
	END;

ROUTINE EC_BITS(ADDR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE READS THE SPECIFIED KS10 CRAM ADDRESS AND RETURNS A POINTER
!	TO THE 96-BIT DATA.  TO DO THIS IT EXECUTES AN 'EC' COMMAND.
!
! FORMAL PARAMETERS:
!
!	ADDR		= CRAM ADDRESS TO BE READ
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	POINTER TO 3-WORD BUFFER CONTAINING THE 96-BIT CRAM DATA
!
!	POINTER -> CRAM BITS 0-35
!		   CRAM BITS 36-71
!		   CRAM BITS 72-95
!
! SIDE EFFECTS:
!
!	EXECUTES AN 'EC' COMMAND.
!
!--
	BEGIN
	LOCAL
		TEMP,
		PTR;
	OWN
		EC_BUF: VECTOR[3];	!BUFFER TO RETURN 96-BIT DATA

	PTR = EC(.ADDR);		!PERFORM AN EC CMD
	TEMP = .(.PTR + 3);		!GET WORD WITH BITS 0-23 RIGHT ADJUSTED
	EC_BUF[0] = .TEMP^12;		!LEFT ADJUST BITS 0-23 IN WORD 0 OF BUFFER
	TEMP = .(.PTR + 2);		!GET WORD WITH BITS 24-59
	EC_BUF[0] = .EC_BUF[0] OR ((.TEMP^-24) AND %O'7777'); !ADD BITS 24-35 RIGHT ADJUSTED
	EC_BUF[1] = (.TEMP AND %O'77777777')^12; !LEFT ADJUST BITS 36-59
	TEMP = .(.PTR + 1);		!GET WORD WITH BITS 60-95
	EC_BUF[1] = .EC_BUF[1] OR ((.TEMP^-24) AND %O'7777'); !ADD BITS 60-71 RIGHT ADJUSTED
	EC_BUF[2] = .TEMP AND %O'77777777';	!PUT BITS 72-95 IN WORD 3 OF BUFFER
	RETURN EC_BUF;		!RETURN POINTER TO BUFFER
	END;

GLOBAL ROUTINE TST1: NOVALUE =

!THIS TEST CHECKS THAT READING FROM THE CRA BOARD WITH DIAG FN = 7
!YIELDS ALL ZEROS.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR205,DR7,LR210,DR111,RP');
	LOCAL
		ACTUAL;

	DO (0) WHILE
BLOCK1:	BEGIN

	WRT205(7);			!SET DIAG FN TO READ ZERO
	ACTUAL = READ_DATA();		!READ DATA FROM CRA BOARD
	IF .ACTUAL NEQ 0		!DID WE GET BACK ZEROS?
	THEN
ERBLK1:		BEGIN
		ERMCA(1,0,.ACTUAL,4); !NO, REPORT ERROR
		INCR J FROM 0 TO 11 BY 1 DO
			IF .ACTUAL EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;
		FAILURE(2);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRT 205/7	- SET DIAG FN = 7 TO READ BACK ZEROS.
!*	WRT 210/111	- CLOCK DATA FROM CRA BOARD TO CSL BOARD USING
!*			  'CRA T CLK ENABLE'.
!*RESPONSE:
!*	DATA READ BACK WAS NOT ALL ZEROS.
	IF FLP_CHK(1,FLP_PTR)		!GO CHECK FOR FAST ERROR LOOPING
!]ERROR 1
!]DMX7 BUSBUF XCVRS NTWK
!]ERROR 2
!]DFN7 NTWK
	THEN
		LEAVE BLOCK1 WITH 1;
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST2: NOVALUE =

!THIS TEST CHECKS THAT DATA CAN BE WRITTEN TO AND READ FROM THE CRA
!BOARD.  A DATA PATTERN IS CLOCKED INTO THE CRA BOARD TRANSCEIVERS THEN
!IT IS READ BACK USING DIAG FN 11.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR11,LR210,DR111,RP');
	OWN
		DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
	LOCAL
		ERFLG,
		DISCREP,
		CORRECT,
		ACTUAL;

	ERFLG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:	BEGIN

	CLK_DATA(.CORRECT);		!CLOCK DATA TO CRA BOARD
	WRT205(%O'11');			!SET DIAG FN TO READ BUS BITS
	ACTUAL = READ_DATA();		!READ DATA FROM CRA BOARD
	IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
	THEN
ERBLK1:		BEGIN
		ERFLG = -1;		!SET ERROR FLAG
		ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!CHECK IF A GROUP OF 4 BITS ARE INCORRECT

		INCR J FROM 0 TO 8 BY 4 DO
			IF (.DISCREP AND (NOT %O'17'^.J)) EQL 0
			THEN
				BEGIN
				FAILURE(2);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;
! IF WE GET THIS FAR THE WHOLE WORD MUST HAVE BEEN IN ERROR.

		FAILURE(3);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRT 103/DATA	- WRITE DATA PATTERN INTO CSL I/O BUFFER
!*	WRT 105/DATA
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 205/11	- SET DIAG FN = 11 TO READ BACK BUS DATA BITS.
!*	WRT 210/111	- CLOCK DATA FROM CRA BOARD TO CSL BOARD USING
!*			  'CRA T CLK ENABLE'.
!*RESPONSE:
!*	DATA READ BACK WAS NOT WHAT WAS WRITTEN TO CRA BOARD.
!]ERROR 1
!]XCVRS BUSBUF DMX11 NTWK
!]ERROR 2
!]XCVRS BUSBUF NTWK
!]ERROR 3
!]TCLKC DFN11 NTWK
	IF FLP_CHK(1,FLP_PTR)		!GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;
	IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
	THEN
		NOERR(1);
!]NO ERROR 1
!]XCVRS BUSBUF DMX11 TCLKC DFN11 NTWK

	END;

GLOBAL ROUTINE TST3: NOVALUE =

!THIS TEST CHECKS THAT BITS 0-11 CAN BE WRITTEN INTO AND READ BACK FROM
!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR204,DR40,DR0,LR206,DR2,LR210,DR111,RP');
	OWN
		DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
	LOCAL
		ERFLG,
		DISCREP,
		CORRECT,
		ACTUAL;

	ERFLG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);			!SET CRAM ADDRESS TO ZERO
	WRITE_CRAM(0,.CORRECT);		!WRITE PATTERN TO CRAM BITS 0-11
	WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 0-11
	IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
	THEN
ERBLK1:		BEGIN
		ERFLG = -1;		!SET ERROR FLAG
		ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(.J+1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!CHECK IF UPPER OR LOWER 6 BITS ARE INCORRECT.

		INCR J FROM 0 TO 1 BY 1 DO
			IF .DISCREP EQL %O'77'^(.J*6)
			THEN
				BEGIN
				FAILURE(13+.J);
				LEAVE ERBLK1;
				END;
		IF .ACTUAL EQL 0		!IF ACTUAL IS ALL ZEROS
		THEN
			BEGIN
			FAILURE(15);		!THEN, 'RESET' MUST BE STUCK
			LEAVE ERBLK1;
			END;

! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.

		FAILURE(16);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/0	- SET DIAG FN = 0 TO ACCESS CRAM BITS 0-11
!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
!*	WRT 105/DATA
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 0-11.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 210/111	- CLOCK CRAM BITS 0-11 TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 0-11 WERE NOT READ BACK AS THEY WERE WRITTEN.
!]ERROR 1
!]DMX0 CRM0_11 CREG2 NTWK
!]ERROR 2
!]DMX0 CRM0_10 CREG2 NTWK
!]ERROR 3
!]DMX0 CRM0_9 CREG2 NTWK
!]ERROR 4
!]DMX0 CRM0_8 CREG2 NTWK
!]ERROR 5
!]DMX0 CRM0_7 CREG2 NTWK
!]ERROR 6
!]DMX0 CRM0_6 CREG2 NTWK
!]ERROR 7
!]DMX0 CRM0_5 CREG1 NTWK
!]ERROR 8
!]DMX0 CRM0_4 CREG1 NTWK
!]ERROR 9
!]DMX0 CRM0_3 CREG1 NTWK
!]ERROR 10
!]DMX0 CRM0_2 CREG1 NTWK
!]ERROR 11
!]DMX0 CRM0_1 CREG1 NTWK
!]ERROR 12
!]DMX0 CRM0_0 CREG1 NTWK
!]ERROR 13
!]CREG1 CWRT0_5 NTWK
!]ERROR 14
!]CREG2 CWRT6_11 NTWK
!]ERROR 15
!]DFN0 CLKE CLKEN RESET NTWK
!]ERROR 16
!]DFN0 NTWK
	IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	END;
	IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
	THEN
		NOERR(1);
!]NO ERROR 1
!]DMX0 CWRT0_5 CWRT6_11 CLKE CLKEN DFN0 NTWK

	CLEAR_CRAM();			!ZERO CRAM LOC 0
	END;

GLOBAL ROUTINE TST4: NOVALUE =

!THIS TEST CHECKS THAT BITS 12-23 CAN BE WRITTEN INTO AND READ BACK FROM
!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR205,DR4,LR210,DR111,RP');
	OWN
		DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
	LOCAL
		ERFLG,
		DISCREP,
		CORRECT,
		ACTUAL;

	ERFLG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);			!SET CRAM ADDRESS TO ZERO
	WRITE_CRAM(1,.CORRECT);		!WRITE PATTERN TO CRAM BITS 12-23
	WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
	WRT205(4);			!SET DIAG FN TO READ BACK BITS 12-23
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 12-23
	IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
	THEN
ERBLK1:		BEGIN
		ERFLG = -1;		!SET ERROR FLAG
		ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(.J+1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.

		INCR J FROM 0 TO 5 BY 1 DO
			IF .DISCREP EQL %O'101'^.J
			THEN
				BEGIN
				FAILURE(13+.J);		!THEN BITS 12-17 ARE WRONG
				LEAVE ERBLK1;
				END;

!CHECK FOR ERROR IN UPPER OR LOWER 6 BITS, BUT NOT BOTH.

		INCR J FROM 0 TO 1 BY 1 DO
			IF .DISCREP EQL %O'77'^(.J*6)
			THEN
				BEGIN
				FAILURE(19+.J);
				LEAVE ERBLK1;
				END;

!CHECK FOR DISCREPANCY PATTERNS WHICH INDICATE CLOCK FAULTS

		INCR J FROM 0 TO 1 BY 1 DO
			IF .DISCREP EQL %O'707'^(.J*6)
			THEN
				BEGIN
				FAILURE(21+.J);		!THEN BITS 12-17 ARE WRONG
				LEAVE ERBLK1;
				END;

		IF .ACTUAL EQL 0		!IF ACTUAL IS ALL ZEROS
		THEN
			BEGIN
			FAILURE(23);		!THEN, 'RESET' MUST BE STUCK
			LEAVE ERBLK1;
			END;

! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.

		FAILURE(24);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/1	- SET DIAG FN = 1 TO ACCESS CRAM BITS 12-23
!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
!*	WRT 105/DATA
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 12-23.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 205/4	- SET DIAG FN = 4 TO READ CRAM BITS 12-23.
!*	WRT 210/111	- CLOCK CRAM BITS 12-23 TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 12-23 WERE NOT READ BACK AS THEY WERE WRITTEN.
!]ERROR 1
!]DMX4 CRM0_23 CREG8 NTWK
!]ERROR 2
!]DMX4 CRM0_22 CREG7 NTWK
!]ERROR 3
!]DMX4 CRM0_21 CREG6 NTWK
!]ERROR 4
!]DMX4 CRM0_20 CREG5 NTWK
!]ERROR 5
!]DMX4 CRM0_19 CREG4 NTWK
!]ERROR 6
!]DMX4 CRM0_18 CREG3 NTWK
!]ERROR 7
!]DMX4 CRM0_17 CREG8 NTWK
!]ERROR 8
!]DMX4 CRM0_16 CREG7 NTWK
!]ERROR 9
!]DMX4 CRM0_15 CREG6 NTWK
!]ERROR 10
!]DMX4 CRM0_14 CREG5 NTWK
!]ERROR 11
!]DMX4 CRM0_13 CREG4 NTWK
!]ERROR 12
!]DMX4 CRM0_12 CREG3 NTWK
!]ERROR 13
!]CREG8 NTWK
!]ERROR 14
!]CREG7 NTWK
!]ERROR 15
!]CREG6 NTWK
!]ERROR 16
!]CREG5 NTWK
!]ERROR 17
!]CREG4 NTWK
!]ERROR 18
!]CREG3 NTWK
!]ERROR 19
!]CWRT12_17 NTWK
!]ERROR 20
!]CWRT18_23 NTWK
!]ERROR 21
!]CLKJ SYNCH NTWK
!]ERROR 22
!]CLKH SYNCH NTWK
!]ERROR 23
!]SYNCH DFN1 DFN4 RESET NTWK
!]ERROR 24
!]DFN1 DFN4 NTWK
	IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	END;
	IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
	THEN
		NOERR(1);
!]NO ERROR 1
!]DFN1 DMX4 DFN4 CLKJ SYNCH CLKH SYNCH CWRT18_23 CWRT12_17 NTWK

	CLEAR_CRAM();			!ZERO CRAM LOC 0
	END;

GLOBAL ROUTINE TST5: NOVALUE =

!THIS TEST CHECKS THAT BITS 24-35A CAN BE WRITTEN INTO AND READ BACK FROM
!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR205,DR5,LR210,DR111,RP');
	OWN
		DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
	LOCAL
		ERFLG,
		DISCREP,
		CORRECT,
		ACTUAL;

	ERFLG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);			!SET CRAM ADDRESS TO ZERO
	WRITE_CRAM(2,.CORRECT);		!WRITE PATTERN TO CRAM BITS 24-35
	WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
	WRT205(5);			!SET DIAG FN TO READ BACK BITS 24-35A
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35A
	IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
	THEN
ERBLK1:		BEGIN
		ERFLG = -1;		!SET ERROR FLAG
		ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(.J+1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!CHECK FOR ERROR IN UPPER OR LOWER 6 BITS, BUT NOT BOTH.

		INCR J FROM 0 TO 1 BY 1 DO
			IF .DISCREP EQL %O'77'^(.J*6)
			THEN
				BEGIN
				FAILURE(13+.J);
				LEAVE ERBLK1;
				END;


		IF .ACTUAL EQL 0		!IF ACTUAL IS ALL ZEROS
		THEN
			BEGIN
			FAILURE(15);		!THEN, 'RESET' MUST BE STUCK
			LEAVE ERBLK1;
			END;
! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.

		FAILURE(16);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/2	- SET DIAG FN = 2 TO WRITE CRAM BITS 24-35A
!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
!*	WRT 105/DATA
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 24-35A.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 205/5	- SET DIAG FN = 5 TO READ CRAM BITS 24-35A.
!*	WRT 210/111	- CLOCK CRAM BITS 24-35A TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 24-35A WERE NOT READ BACK AS THEY WERE WRITTEN.
!]ERROR 1
!]DMX5 CRM0_35 CREG8 NTWK
!]ERROR 2
!]DMX5 CRM0_34 CREG7 NTWK
!]ERROR 3
!]DMX5 CRM0_33 CREG6 NTWK
!]ERROR 4
!]DMX5 CRM0_32 CREG5 NTWK
!]ERROR 5
!]DMX5 CRM0_31 CREG4 NTWK
!]ERROR 6
!]DMX5 CRM0_30 CREG3 NTWK
!]ERROR 7
!]DMX5 CRM0_29 CREG8 NTWK
!]ERROR 8
!]DMX5 CRM0_28 CREG7 NTWK
!]ERROR 9
!]DMX5 CRM0_27 CREG6 NTWK
!]ERROR 10
!]DMX5 CRM0_26 CREG5 NTWK
!]ERROR 11
!]DMX5 CRM0_25 CREG4 NTWK
!]ERROR 12
!]DMX5 CRM0_24 CREG3 NTWK
!]ERROR 13
!]CWRT24_29 NTWK
!]ERROR 14
!]CWRT30_35 NTWK
!]ERROR 15
!]SYNCH RESET DFN2 DFN5 NTWK
!]ERROR 16
!]DFN2 DFN5 NTWK
	IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	END;
	IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
	THEN
		NOERR(1);
!]NO ERROR 1
!]DFN2 DFN5 DMX5 CWRT24_29 CWRT30_35 NTWK

	CLEAR_CRAM();			!ZERO CRAM LOC 0
	END;

GLOBAL ROUTINE TST6: NOVALUE =

!THIS TEST CHECKS THAT BITS 24-35B CAN BE WRITTEN INTO AND READ BACK FROM
!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR205,DR6,LR210,DR111,RP');
	OWN
		DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
	LOCAL
		ERFLG,
		DISCREP,
		CORRECT,
		ACTUAL;

	ERFLG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);			!SET CRAM ADDRESS TO ZERO
	WRITE_CRAM(2,.CORRECT);		!WRITE PATTERN TO CRAM BITS 24-35
	WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
	WRT205(6);			!SET DIAG FN TO READ BACK BITS 24-35B
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35B
	IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
	THEN
ERBLK1:		BEGIN
		ERFLG = -1;		!SET ERROR FLAG
		ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(.J+1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.

		FAILURE(13);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/2	- SET DIAG FN = 2 TO WRITE CRAM BITS 24-35B
!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
!*	WRT 105/DATA
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 24-35B.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 205/6	- SET DIAG FN = 6 TO READ CRAM BITS 24-35B.
!*	WRT 210/111	- CLOCK CRAM BITS 24-35B TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 24-35B WERE NOT READ BACK AS THEY WERE WRITTEN.
!]ERROR 1
!]DMX6 CRM0_35 CREG8 NTWK
!]ERROR 2
!]DMX6 CRM0_34 CREG7 NTWK
!]ERROR 3
!]DMX6 CRM0_33 CREG6 NTWK
!]ERROR 4
!]DMX6 CRM0_32 CREG5 NTWK
!]ERROR 5
!]DMX6 CRM0_31 CREG4 NTWK
!]ERROR 6
!]DMX6 CRM0_30 CREG3 NTWK
!]ERROR 7
!]DMX6 CRM0_29 CREG8 NTWK
!]ERROR 8
!]DMX6 CRM0_28 CREG7 NTWK
!]ERROR 9
!]DMX6 CRM0_27 CREG6 NTWK
!]ERROR 10
!]DMX6 CRM0_26 CREG5 NTWK
!]ERROR 11
!]DMX6 CRM0_25 CREG4 NTWK
!]ERROR 12
!]DMX6 CRM0_24 CREG3 NTWK
!]ERROR 13
!]DFN2 DFN6 NTWK
	IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	END;
	IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
	THEN
		NOERR(1);
!]NO ERROR 1
!]DFN2 DFN6 DMX6 NTWK

	CLEAR_CRAM();			!ZERO CRAM LOC 0
	END;

GLOBAL ROUTINE TST7: NOVALUE =

!THIS TEST CHECKS THAT THE 'CRA/M RESET' SIGNAL NEGATES BITS 0-11 IN
!THE CRAM REGISTER.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR210,DR111,RP');
	LOCAL
		ACTUAL;

	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(0);			!SET CRAM ADDRESS TO ZERO
	WRITE_CRAM(0,%O'7777');		!WRITE ONES TO CRAM BITS 0-11
	WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
	WRT204(CRAM_RESET);		!ASSERT 'CRA/M RESET'
	WRT204(0);			!NEGATE IT
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 0-11
	IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
	THEN
ERBLK1:		BEGIN
		ERMCA(1,0,.ACTUAL,4); !THEN REPORT IT
		IF (.ACTUAL AND %O'77') EQL 0	!IF BITS 6-11 ARE ZERO,
		THEN
			BEGIN
			FAILURE(1);		!THEN 0-5 DIDN'T CLEAR
			LEAVE ERBLK1;
			END;
		IF (.ACTUAL AND %O'7700') EQL 0	!IF BITS 0-5 ARE ZERO,
		THEN
			BEGIN
			FAILURE(2);		!THEN 6-11 DIDN'T CLEAR
			LEAVE ERBLK1;
			END;

!IF WE GET THIS FAR ASSUME WHOLE WORD DID NOT CLEAR

		FAILURE(3);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/0	- SET DIAG FN = 0 TO ACCESS CRAM BITS 0-11
!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
!*	WRT 105/17
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 0-11.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
!*	WRT 204/0	- NEGATE IT.
!*	WRT 210/111	- CLOCK CRAM BITS 0-11 TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 0-11 WERE NOT NEGATED BY 'CRA/M RESET'.
!]ERROR 1
!]DMX0 CREG1 NTWK
!]ERROR 2
!]DMX0 CREG2 NTWK
!]ERROR 3
!]DMX0 RESET NTWK
	IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;

	CLEAR_CRAM();			!ZERO CRAM LOC 0
	END;

GLOBAL ROUTINE TST8: NOVALUE =

!THIS TEST CHECKS THAT THE 'CRA/M RESET' SIGNAL NEGATES BITS 12-23 IN
!THE CRAM REGISTER.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR205,DR4,LR210,DR111,RP');
	LOCAL
		ACTUAL;

	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(0);			!SET CRAM ADDRESS TO ZERO
	WRITE_CRAM(1,%O'7777');		!WRITE ONES TO CRAM BITS 12-23
	WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
	WRT204(CRAM_RESET);		!ASSERT 'CRA/M RESET'
	WRT204(0);			!NEGATE IT
	WRT205(4);			!SET DIAG FN TO READ BITS 12-23
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 12-23
	IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
	THEN
ERBLK1:		BEGIN
		ERMCA(1,0,.ACTUAL,4); !THEN REPORT IT

!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.

		INCR J FROM 0 TO 5 BY 1 DO
			IF (.ACTUAL AND (%O'101'^.J)) EQL 0
			THEN
				BEGIN
				FAILURE(1+.J);		!THEN BITS 12-17 ARE WRONG
				LEAVE ERBLK1;
				END;

!IF WE GET THIS FAR THE WHOLE WORD DIDN'T CLEAR

		FAILURE(7);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/1	- SET DIAG FN = 1 TO ACCESS CRAM BITS 12-23
!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
!*	WRT 105/17
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 12-23.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
!*	WRT 204/0	- NEGATE IT.
!*	WRT 205/4	-SET DIAG FN = 4 TO READ CRAM BITS 12-23
!*	WRT 210/111	- CLOCK CRAM BITS 12-23 TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 12-23 WERE NOT NEGATED BY 'CRA/M RESET'.
!]ERROR 1
!]DMX4 CREG8 NTWK
!]ERROR 2
!]DMX4 CREG7 NTWK
!]ERROR 3
!]DMX4 CREG6 NTWK
!]ERROR 4
!]DMX4 CREG5 NTWK
!]ERROR 5
!]DMX4 CREG4 NTWK
!]ERROR 6
!]DMX4 CREG3 NTWK
!]ERROR 7
!]RESET NTWK
	IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;

	CLEAR_CRAM();			!ZERO CRAM LOC 0
	END;

GLOBAL ROUTINE TST9: NOVALUE =

!THIS TEST CHECKS THAT THE 'CRA/M RESET' SIGNAL NEGATES BITS 24-35 A&B IN
!THE CRAM REGISTER.

	BEGIN
	LABEL BLOCK1,ERBLK1,ERBLK2;
	BIND
		FLP_PTR1 = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR205,DR5,LR210,DR111,RP'),
		FLP_PTR2 = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR205,DR6,LR210,DR111,RP');
	LOCAL
		ACTUAL;

	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(0);			!SET CRAM ADDRESS TO ZERO
	WRITE_CRAM(2,%O'7777');		!WRITE ONES TO CRAM BITS 24-35A
	WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
	WRT204(CRAM_RESET);		!ASSERT 'CRA/M RESET'
	WRT204(0);			!NEGATE IT
	WRT205(5);			!SET DIAG FN TO READ BITS 24-35A
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35A
	IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
	THEN
ERBLK1:		BEGIN
		ERMCA(1,0,.ACTUAL,4); !THEN REPORT IT

!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.

		INCR J FROM 0 TO 5 BY 1 DO
			IF (.ACTUAL AND (%O'101'^.J)) EQL 0
			THEN
				BEGIN
				FAILURE(1+.J);		!THEN BITS 12-17 ARE WRONG
				LEAVE ERBLK1;
				END;

!IF WE GET THIS FAR THE WHOLE WORD DIDN'T CLEAR

		FAILURE(7);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/2	- SET DIAG FN = 2 TO ACCESS CRAM BITS 24-35A
!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
!*	WRT 105/17
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 24-35A.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
!*	WRT 204/0	- NEGATE IT.
!*	WRT 205/5	- SET DIAG FN = 5 TO READ CRAM BITS 24-35A
!*	WRT 210/111	- CLOCK CRAM BITS 24-35A TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 24-35A WERE NOT NEGATED BY 'CRA/M RESET'.
!]ERROR 1
!]DMX5 CREG8 NTWK
!]ERROR 2
!]DMX5 CREG7 NTWK
!]ERROR 3
!]DMX5 CREG6 NTWK
!]ERROR 4
!]DMX5 CREG5 NTWK
!]ERROR 5
!]DMX5 CREG4 NTWK
!]ERROR 6
!]DMX5 CREG3 NTWK
!]ERROR 7
!]RESET NTWK
	IF FLP_CHK(1,FLP_PTR1)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT205(6);			!SET DIAG FN TO READ BITS 24-35B
	ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35B
	IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
	THEN
ERBLK2:		BEGIN
		ERMCA(2,0,.ACTUAL,4); !THEN REPORT IT

!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.

		INCR J FROM 0 TO 5 BY 1 DO
			IF (.ACTUAL AND (%O'101'^.J)) EQL 0
			THEN
				BEGIN
				FAILURE(8+.J);		!THEN BITS 12-17 ARE WRONG
				LEAVE ERBLK2;
				END;

!IF WE GET THIS FAR THE WHOLE WORD DIDN'T CLEAR

		FAILURE(14);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	SET CRAM ADDRESS TO ZERO
!*	WRT 205/2	- SET DIAG FN = 2 TO ACCESS CRAM BITS 24-35B
!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
!*	WRT 105/17
!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
!*			  'CRA R CLK'.
!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
!*	WRT 204/0	- BITS 24-35B.
!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
!*			  LATCHES.
!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
!*	WRT 204/0	- NEGATE IT.
!*	WRT 205/6	- SET DIAG FN = 6 TO READ CRAM BITS 24-35B
!*	WRT 210/111	- CLOCK CRAM BITS 24-35B TO CSL BOARD.
!*RESPONSE:
!*	CRAM BITS 24-35B WERE NOT NEGATED BY 'CRA/M RESET'.
!]ERROR 8
!]DMX6 CREG8 NTWK
!]ERROR 9
!]DMX6 CREG7 NTWK
!]ERROR 10
!]DMX6 CREG6 NTWK
!]ERROR 11
!]DMX6 CREG5 NTWK
!]ERROR 12
!]DMX6 CREG4 NTWK
!]ERROR 13
!]DMX6 CREG3 NTWK
!]ERROR 14
!]RESET NTWK
	IF FLP_CHK(2,FLP_PTR2)		! GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	CLEAR_CRAM();			!ZERO CRAM LOC 0
	END;

GLOBAL ROUTINE TST10: NOVALUE =

!THIS TEST CHECKS THAT THE CRAM ADDRESS CAN BE SET USING THE 'DIAG ADR'.
!THE CRAM REGISTER IS NEGATED USING 'CRA/M RESET'. THIS SELECTS THE
!DIAG ADR INPUTS TO THE DISPATCH MUXS.  THEN THE DIAG ADR REGISTER IS
!LOADED WITH A DATA PATTERN.  THIS PATTERN SHOULD FEED THROUGH THE
!MUXS AND BE READ BACK AS THE NEXT CRAM ADDRESS.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'X12525,LR205,DR1,LR210,DR111,RP',
				%ASCIZ 'X15252,LR205,DR1,LR210,DR111,RP');
	MAP
		FLP_PTR: VECTOR;
	LOCAL
		ERFLG,
		DISCREP,
		ACTUAL,
		TST_ADR;
	OWN
		ADR: VECTOR[2] INITIAL (%O'2525',%O'5252');

	ERFLG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	TST_ADR = .ADR[.I];		!GET TEST ADDR TO USE
	DO (0) WHILE
BLOCK1:	BEGIN
	SETNXT(.TST_ADR);			!LOAD THE TST ADR INTO THE DIAG ADDR REG
	WRT205(1);			!SET THE DIAG FN TO READ NEXT CRAM ADDR
	ACTUAL = READ_DATA();		!READ THE NEXT CRAM ADDR
	IF .ACTUAL NEQ .TST_ADR		!IF NXT CRAM ADDR IS NOT CORRECT
	THEN
ERBLK1:		BEGIN
		ERMCAS(1,.TST_ADR,.ACTUAL,4,TST_ADR); !THEN REPORT IT
		ERFLG = 1;		!SET ERROR FLAG
		DISCREP = .ACTUAL XOR .TST_ADR; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(.J+1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!CHECK IF A GROUP OF 4 BITS ARE INCORRECT

		INCR J FROM 0 TO 2 BY 1 DO
			IF (.DISCREP AND (NOT %O'17'^(.J*4))) EQL 0
			THEN
				BEGIN
				FAILURE(13+.J);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!IF ADDR IS ALL ONES THEN 'PAGE FAIL' MUST BE ASSERTED.

		IF (.ACTUAL EQL %O'1777') OR
		   ((.ACTUAL AND %O'7760') EQL %O'7760') OR
		   ((.ACTUAL AND %O'17') EQL %O'17')
		THEN
			BEGIN
			FAILURE(16);		!DO FAULT ISOLATION
			LEAVE ERBLK1;
			END;

! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.

		FAILURE(17);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	X1 \O0		- THIS EXECUTES AN 8080 SUBROUTINE WHICH:
!*				CLEARS THE CRAM REGISTER,
!*				LOADS THE DIAG ADR = \O0.
!*	WRT 205/1	- SET DIAG FN = 1 TO READ NEXT CRAM ADDR
!*	WRT 210/111	- READ THE NEXT CRAM ADDR
!*RESPONSE:
!*	THE NEXT CRAM ADDR IS NOT WHAT WAS WRITTEN AS 'DIAG ADR'.
!]ERROR 1
!]DADR3 AMX11_00 DMX1 SKIP10 NTWK
!]ERROR 2
!]DADR3 AMX10_00 DMX1 NTWK
!]ERROR 3
!]DADR3 AMX9_00 DMX1 NTWK
!]ERROR 4
!]DADR3 AMX8_00 DMX1 NTWK
!]ERROR 5
!]DADR2 AMX7_00 DMX1 NTWK
!]ERROR 6
!]DADR2 AMX6_00 DMX1 NTWK
!]ERROR 7
!]DADR2 AMX5_00 DMX1 NTWK
!]ERROR 8
!]DADR2 AMX4_00 DMX1 NTWK
!]ERROR 9
!]DADR1 AMX3_00 DMX1 NTWK
!]ERROR 10
!]DADR1 AMX2_00 DMX1 NTWK
!]ERROR 11
!]DADR1 AMX1_00 DMX1 NTWK
!]ERROR 12
!]DADR1 AMX0_00 DMX1 NTWK
!]ERROR 13
!]DADR3 NTWK
!]ERROR 14
!]DADR2 NTWK
!]ERROR 15
!]DADR1 NTWK
!]ERROR 16
!]PFBUF NTWK
!]ERROR 17
!]DADR AMX DFN1 NTWK
!]NO ERROR 1
!]DADR DADR1 DADR2 DADR3 AMX_00 DMX1 DFN1 NTWK
	IF FLP_CHK(1,FLP_PTR[.I])	!GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	END;
	IF .ERFLG EQL 0		!IF WE HAD NO ERRORS THEN
	THEN
		NOERR(1);	!DO FAULT ISOLATION

	END;

GLOBAL ROUTINE TST11: NOVALUE =

!THIS TEST CHECKS THAT THE 'CURRENT ADDR' REGISTER GETS CLOCKED
!CORRECTLY.  A TEST ADDRESS IS LOADED INTO NEXT CRAM ADDRESS. THEN A
!CPU CLOCK PULSE IS GIVEN WHICH SHOULD CLOCK THE NEXT CRAM ADDR INTO
!THE CURRENT ADDR.  THE CURRENT ADDR IS THEN READ BACK VIA DIAG FN 3.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ 'X16314,LR206,DR2,LR205,DR3,X10,LR210,DR111,RP',
				%ASCIZ 'X11463,LR206,DR2,LR205,DR3,X10,LR210,DR111,RP');
	MAP
		FLP_PTR: VECTOR;
	LOCAL
		ERFLG,
		DISCREP,
		ACTUAL,
		TST_ADR;
	OWN
		ADR: VECTOR[2] INITIAL (%O'6314',%O'1463');

	ERFLG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	TST_ADR = .ADR[.I];		!GET TEST ADDR TO USE
	DO (0) WHILE
BLOCK1:	BEGIN
	SETNXT(.TST_ADR);			!LOAD THE TST ADR INTO THE DIAG ADDR REG
	WRT206(SINGLE_CLK);		!CLOCK NEXT ADDR INTO CURR ADDR
	WRT205(3);			!SET THE DIAG FN TO READ CURRENT CRAM ADDR
	SETNXT(0);				!SET NXT ADDR=0 SO FAULT IN DIAG
					!MUX SELECTION WILL BE DETECTABLE
	ACTUAL = READ_DATA();		!READ THE CURRENT CRAM ADDR
	IF .ACTUAL NEQ .TST_ADR		!IF CURR ADDR IS NOT CORRECT
	THEN
ERBLK1:		BEGIN
		ERFLG = -1;		!SET ERROR FLAG
		ERMCAS(1,.TST_ADR,.ACTUAL,4,TST_ADR); !THEN REPORT IT
		DISCREP = .ACTUAL XOR .TST_ADR; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(.J+1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!CHECK IF A GROUP OF 4 BITS ARE INCORRECT

		INCR J FROM 0 TO 2 BY 1 DO
			IF (.DISCREP AND (NOT %O'17'^(.J*4))) EQL 0
			THEN
				BEGIN
				FAILURE(13+.J);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.

		FAILURE(13);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	X1 \O0		- THIS EXECUTES AN 8080 SUBROUTINE WHICH:
!*				CLEARS THE CRAM REGISTER,
!*				LOADS THE DIAG ADR = \O0.
!*	WRT 206/2	- CLOCK NEXT ADDR INTO CURRENT ADDR
!*	WRT 205/3	- SET DIAG FN = 3 TO READ CURR LOC
!*	X1 0		- THIS EXECUTES AN 8080 SUBROUTINE WHICH:
!*				CLEARS THE CRAM REGISTER,
!*				LOADS THE DIAG ADR = 0.
!*	WRT 210/111	- READ THE CURR LOC
!*RESPONSE:
!*	'CURR LOC' DID NOT GET LOADED CORRECTLY.
!]ERROR 1
!]DADR3 CLOC3 AMX11_00 DMX3 SKIP10 NTWK
!]ERROR 2
!]DADR3 CLOC3 AMX10_00 DMX3 NTWK
!]ERROR 3
!]DADR3 CLOC3 AMX9_00 DMX3 NTWK
!]ERROR 4
!]DADR3 CLOC3 AMX8_00 DMX3 NTWK
!]ERROR 5
!]DADR2 CLOC2 AMX7_00 DMX3 NTWK
!]ERROR 6
!]DADR2 CLOC2 AMX6_00 DMX3 NTWK
!]ERROR 7
!]DADR2 CLOC2 AMX5_00 DMX3 NTWK
!]ERROR 8
!]DADR2 CLOC2 AMX4_00 DMX3 NTWK
!]ERROR 9
!]DADR1 CLOC1 AMX3_00 DMX3 NTWK
!]ERROR 10
!]DADR1 CLOC1 AMX2_00 DMX3 NTWK
!]ERROR 11
!]DADR1 CLOC1 AMX1_00 DMX3 NTWK
!]ERROR 12
!]DADR1 CLOC1 AMX0_00 DMX3 NTWK
!]ERROR 13
!]CLKF CLKEN DADR3 CLOC3 NTWK
!]ERROR 14
!]CLKD CLKEN DADR2 CLOC2 NTWK
!]ERROR 15
!]CLKE CLKEN DADR1 CLOC1 NTWK
!]ERROR 16
!]DFN3 NTWK
	IF FLP_CHK(1,FLP_PTR[.I])	!GO CHECK FOR FAST ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	END;
	IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
	THEN
		NOERR(1);
!]NO ERROR 1
!]DADR1 DADR2 DADR3 AMX_00 DMX3 CLOC1 CLOC2 CLOC3 DFN3 NTWK

	END;

GLOBAL ROUTINE TST12: NOVALUE =

!THIS TEST CHECKS THAT THE J FIELD OF THE MICRO-INSTRUCTION CAN BE
!GATED CORRECTLY THRU THE CRAM ADDRESS MUXS TO PRODUCE THE NEXT CRAM
!ADDRESS.  CRAM LOCATION 0 IS LOADED WITH A MICRO-INSTR WHICH HAS A J
!FIELD OF 1 WITH NO DISPATCHING OR SKIPPING.  THIS INSTRUCTION IS
!EXECUTED AND THE NEXT CRAM ADDRESS IS CHECKED FOR A 1.  THIS IS
!REPEATED FOR NEXT ADDRESSES OF 2,4,8,10,20,40,100,200,400.

	BEGIN
	LOCAL
		PTR,
		CORRECT,
		ACTUAL;
	BIND
		TEST_PAT = PLIT(-1,-1,-1),
		UC_PTR = PLIT(U_J(0) U);
	MAP
		PTR: REF VECTOR;
	LABEL BLOCK1;

	LOADUC(0,UC_PTR);
	INCR I FROM 0 TO 11 BY 1 DO
	BEGIN
	CORRECT = 1^.I;			!COMPUTE NEXT ADDR TO BE USED
	LOADUC(.CORRECT,TEST_PAT);	!WRITE -1 TO CORRECT LOCATION
	DO (0) WHILE
BLOCK1:	BEGIN

	LC(0);				!SET CRAM ADDR TO ZERO
	MOD_FLD(0,.CORRECT);		!MODIFY J FIELD TO TEST ADDR
	ACTUAL = STEP_U_NEXT(1);		!GIVE PULSE AND READ NXT ADDR
	IF .ACTUAL NEQ .CORRECT		!IS NEXT ADDR = J FIELD?
	THEN
		ERRCAS(.I+1,1,.CORRECT,.ACTUAL,4,CORRECT); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD CRAM LOCATION ZERO WITH MICRO-INSTR WITH J FIELD = \O0.
!*	CP 1	- GIVE A CLOCK PULSE TO GATE THE J FIELD THRU THE CRAM
!*		  ADDRESS MUXS.
!*RESPONSE:
!*	THE J FIELD DID NOT BECOME THE NEXT CRAM ADDRESS.
!]ERROR 1
!]AMX11 SKIP10 NTWK
!]ERROR 2
!]AMX10 NTWK
!]ERROR 3
!]AMX9 NTWK
!]ERROR 4
!]AMX8 NTWK
!]ERROR 5
!]AMX6_7 NTWK
!]ERROR 6
!]AMX6_7 NTWK
!]ERROR 7
!]AMX4_5 NTWK
!]ERROR 8
!]AMX4_5 NTWK
!]ERROR 9
!]AMX2_3 NTWK
!]ERROR 10
!]AMX2_3 NTWK
!]ERROR 11
!]AMX0_1 NTWK
!]ERROR 12
!]AMX0_1 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CP(1);			!CLOCK CRAM BITS AT 'NEXT ADDR' LOCATION INTO REGISTER
	PTR = EC_BITS(-1);	!READ BACK THOSE BITS
	ACTUAL = .PTR[1];	!GET BITS 36-71
	IF .ACTUAL NEQ -1	!ARE ALL BITS ONES AS THEY SHOULD BE?
	THEN
		ERRCAS(.I+13,2,-1,.ACTUAL,12,CORRECT);	!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD CRAM LOCATION \O0 WITH ALL ONES.
!*	LOAD CRAM LOCATION ZERO WITH MICRO-INSTR WITH J FIELD = \O0.
!*	CP 1	- GIVE A CLOCK PULSE TO GATE THE J FIELD THRU THE CRAM
!*		  ADDRESS MUXS.
!*	CP 1	- GIVE ANOTHER PULSE TO CLOCK CRAM BITS FROM LOCATION
!*		  \O0 INTO THE CRAM BIT REGISTER.
!*	EC	- READ BACK THOSE BITS
!*RESPONSE:
!*	BITS 36-71 WERE NOT READ BACK AS ONES.  THIS IMPLIES THAT THE
!*	NEXT ADDRESS BITS WHICH GO TO THE 'CRM' BOARD (CRA1 ADR 00-11)
!*	ARE NOT CORRECT, I.E., NOT EQUAL TO \O0.  THEREFORE, THE CRAM
!*	BITS READ BACK WERE FROM A DIFFERENT LOCATION.
!]ERROR 13
!]AMX11 SKIP10 NTWK
!]ERROR 14
!]AMX10 NTWK
!]ERROR 15
!]AMX9 NTWK
!]ERROR 16
!]AMX8 NTWK
!]ERROR 17
!]AMX6_7 NTWK
!]ERROR 18
!]AMX6_7 NTWK
!]ERROR 19
!]AMX4_5 NTWK
!]ERROR 20
!]AMX4_5 NTWK
!]ERROR 21
!]AMX2_3 NTWK
!]ERROR 22
!]AMX2_3 NTWK
!]ERROR 23
!]AMX0_1 NTWK
!]ERROR 24
!]AMX0_1 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

	END;

GLOBAL ROUTINE TST13: NOVALUE =

!THIS TEST CHECKS THAT ONES AND ZEROS CAN BE WRITTEN INTO AND READ FROM
!BITS 0-35 OF EACH CRAM LOCATION.

	BEGIN
	LABEL BLOCK1,ERBLK1,ERBLK2;
	LOCAL
		DISCREP,
		ADDR,
		PTR,
		ACTUAL;
	BIND
		UC_PTR1 = PLIT(0,0,0),
		UC_PTR2 = PLIT(-1,-1,-1);

	LC(0);			!SET CRAM ADDRESS TO 0
	PTR = WR_CRAM(0);	!GO WRITE ZEROS TO EACH LOC AND CHECK IT
	ACTUAL = .(.PTR + 1);	!GET ACTUAL DATA
	ADDR = .(.PTR);		!GET CRAM ADDRESS
	IF .ACTUAL NEQ 0	!IF ACTUAL NOT EQUAL TO ZERO, HAD ERROR
	THEN
ERBLK1:		BEGIN
		ERMCAS(1,0,.ACTUAL,12,ADDR);	!REPORT ERROR
		INCR I FROM 0 TO 35 BY 1 DO
			IF .ACTUAL EQL 1^.I	!CHECK FOR SINGLE BIT ERROR
			THEN
				BEGIN
				FAILURE(.I+1);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!IF WE GET THIS FAR IT IS A MULTIPLE BIT ERROR, SO JUST CALL OUT ALL
!CRAM CHIPS.

		FAILURE(37);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRITE ZEROS TO BITS 0-35 OF CRAM LOCATION \O0.
!*RESPONSE:
!*	NON-ZERO DATA WAS READ BACK FROM LOCATION \O0.
!]ERROR 1
!]CRAM35 NTWK
!]ERROR 2
!]CRAM34 NTWK
!]ERROR 3
!]CRAM33 NTWK
!]ERROR 4
!]CRAM32 NTWK
!]ERROR 5
!]CRAM31 NTWK
!]ERROR 6
!]CRAM30 NTWK
!]ERROR 7
!]CRAM29 NTWK
!]ERROR 8
!]CRAM28 NTWK
!]ERROR 9
!]CRAM27 NTWK
!]ERROR 10
!]CRAM26 NTWK
!]ERROR 11
!]CRAM25 NTWK
!]ERROR 12
!]CRAM24 NTWK
!]ERROR 13
!]CRAM23 NTWK
!]ERROR 14
!]CRAM22 NTWK
!]ERROR 15
!]CRAM21 NTWK
!]ERROR 16
!]CRAM20 NTWK
!]ERROR 17
!]CRAM19 NTWK
!]ERROR 18
!]CRAM18 NTWK
!]ERROR 19
!]CRAM17 NTWK
!]ERROR 20
!]CRAM16 NTWK
!]ERROR 21
!]CRAM15 NTWK
!]ERROR 22
!]CRAM14 NTWK
!]ERROR 23
!]CRAM13 NTWK
!]ERROR 24
!]CRAM12 NTWK
!]ERROR 25
!]CRAM11 NTWK
!]ERROR 26
!]CRAM10 NTWK
!]ERROR 27
!]CRAM9 NTWK
!]ERROR 28
!]CRAM8 NTWK
!]ERROR 29
!]CRAM7 NTWK
!]ERROR 30
!]CRAM6 NTWK
!]ERROR 31
!]CRAM5 NTWK
!]ERROR 32
!]CRAM4 NTWK
!]ERROR 33
!]CRAM3 NTWK
!]ERROR 34
!]CRAM2 NTWK
!]ERROR 35
!]CRAM1 NTWK
!]ERROR 36
!]CRAM0 NTWK
!]ERROR 37
!]CRAM NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		WHILE 1 DO
		BEGIN
		LOADUC(.ADDR,UC_PTR1);	!WRITE ZEROS TO CRAM
		EC(.ADDR);		!READ THEM BACK
		END;

	LC(0);			!SET CRAM ADDRESS TO 0
	PTR = WR_CRAM(-1);	!GO WRITE ONES TO EACH LOC AND CHECK IT
	ACTUAL = .(.PTR + 1);	!GET ACTUAL DATA
	ADDR = .(.PTR);		!GET CRAM ADDRESS
	IF .ACTUAL NEQ -1	!IF ACTUAL NOT EQUAL TO ONES, HAD ERROR
	THEN
ERBLK2:		BEGIN
		ERMCAS(1,-1,.ACTUAL,12,ADDR);	!REPORT ERROR
		DISCREP = .ACTUAL XOR -1;	!COMPUTE DISCREPANCIES
		INCR I FROM 0 TO 35 BY 1 DO
			IF .DISCREP EQL 1^.I	!CHECK FOR SINGLE BIT ERROR
			THEN
				BEGIN
				FAILURE(.I+1);	!DO FAULT ISOLATION
				LEAVE ERBLK2;
				END;

!IF WE GET THIS FAR IT IS A MULTIPLE BIT ERROR, SO JUST CALL OUT ALL
!CRAM CHIPS.

		FAILURE(37);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRITE ONES TO BITS 0-35 OF CRAM LOCATION \O0.
!*RESPONSE:
!*	DATA WHICH WAS NOT ALL ONES WAS READ BACK FROM LOCATION \O0.
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		WHILE 1 DO
		BEGIN
		LOADUC(.ADDR,UC_PTR2);	!WRITE ZEROS TO CRAM
		EC(.ADDR);		!READ THEM BACK
		END;

	END;

GLOBAL ROUTINE TST14: NOVALUE =

!THIS TEST CHECKS THAT THE ADDRESSING LOGIC FOR THE CRAM WORKS
!CORRECTLY.

	BEGIN
	LABEL BLOCK1;
	BIND
		ONES = PLIT(-1,-1,-1),
		ZEROS = PLIT(0,0,0);
	LOCAL
		BITS,
		ACTUAL,
		PTR,
		OTHER_ADR;
	MAP
		PTR: REF VECTOR;

	DO (0) WHILE
BLOCK1:	BEGIN

	INCR I FROM 0 TO 10 BY 1 DO
		BEGIN
		OTHER_ADR = 1^.I;		!COMPUTE OTHER ADDR
		LOADUC(0,ZEROS);	!WRITE ALL ZEROS INTO TEST ADDR
		LOADUC(.OTHER_ADR,ONES); !WRITE ONES INTO OTHER ADDR
		PTR = EC_BITS(0);	!READ BACK CONTENTS OF TEST ADDR
		ACTUAL = .PTR[0];	!GET BITS 0-35
		IF .ACTUAL NEQ 0	!CHECK THAT TEST ADDR STAYED ZEROS
		THEN
			ERRCAS(.I+1,1,0,.ACTUAL,12,OTHER_ADR); !REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRITE ZEROS INTO BITS 0-35 OF CRAM LOCATION 0.
!*	WRITE ONES INTO BITS 0-35 OF CRAM LOCATION \O0.
!*RESPONSE:
!*	BITS 0-35 READ BACK FROM LOCATION 0 ARE NOT ALL ZEROS.  THIS
!*	IMPLIES THAT WRITING INTO LOCATION \O0 REALLY WROTE INTO
!*	LOCATION 0, OR VICE-VERSA.
!]ERROR 1
!]CADR11 NTWK
!]ERROR 2
!]CADR10 NTWK
!]ERROR 3
!]CADR9 NTWK
!]ERROR 4
!]CADR8 NTWK
!]ERROR 5
!]CADR7 NTWK
!]ERROR 6
!]CADR6 NTWK
!]ERROR 7
!]CADR5 NTWK
!]ERROR 8
!]CADR4 NTWK
!]ERROR 9
!]CADR3 NTWK
!]ERROR 10
!]CADR2 NTWK
!]ERROR 11
!]CADR1 NTWK
		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
		THEN
			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

		IF (.PTR[1] NEQ 0) OR		!ARE BITS 36-71 ZEROS
		   (.PTR[2] NEQ 0)		!ARE BITS 72-95 ZEROS
		THEN
			ERRCAS(.I+12,2,ZEROS,.PTR + 1,20,OTHER_ADR); !NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	WRITE ZEROS INTO BITS 36-95 OF CRAM LOCATION 0.
!*	WRITE ONES INTO BITS 36-95 OF CRAM LOCATION \O0.
!*RESPONSE:
!*	BITS 36-95 READ BACK FROM LOCATION 0 ARE NOT ALL ZEROS.  THIS
!*	IMPLIES THAT WRITING INTO LOCATION \O0 REALLY WROTE INTO
!*	LOCATION 0, OR VICE-VERSA.
!]ERROR 12
!]AMX11 SKIP10 NTWK
!]ERROR 13
!]AMX10 NTWK
!]ERROR 14
!]AMX9 NTWK
!]ERROR 15
!]AMX8 NTWK
!]ERROR 16
!]AMX6_7 NTWK
!]ERROR 17
!]AMX6_7 NTWK
!]ERROR 18
!]AMX4_5 NTWK
!]ERROR 19
!]AMX4_5 NTWK
!]ERROR 20
!]AMX2_3 NTWK
!]ERROR 21
!]AMX2_3 NTWK
!]ERROR 22
!]AMX0_1 NTWK
!]ERROR 23
!]AMX0_1 NTWK
	IF LOOP_CHK(2)			!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
		END;
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST15: NOVALUE =

!THIS TEST CHECKS THAT THE SUBROUTINE RETURN ADDRESS, 'SBR RET', DOES
!NOT GET WRITTEN IF NO 'CALL' IS MADE.
!A DATA PATTERN IS LOADED INTO THE NEXT CRAM ADDRESS AND A SINGLE CLOCK
!PULSE IS GENERATED.  THIS CLOCKS THE ADDRESS INTO 'CURR LOC' AND WRITES
!IT INTO THE SUBROUTINE STACK. THEN ANOTHER CLOCK PULSE IS GENERATED.
!SINCE 'CALL OR RETURN' IS NOT ASSERTED, THE 'SBR RET' LATCHES SHOULD
!NOT GET CLOCKED WITH THE DATA PATTERN FROM THE STACK.

	BEGIN
	LABEL BLOCK1;
	LOCAL
		ADDR,
		CORRECT,
		ACTUAL;
	BIND
		UC_PTR = PLIT( U_J(0) U);

	DO (0) WHILE
BLOCK1:	BEGIN

	CORRECT = READ_SBR();		!SET CORRECT = 'SBR RET'
	ADDR = NOT .CORRECT;		!SET TEST ADDR = COMPLEMENT OF THAT
	CLEAR_CRAM();			!MAKE SURE CRAM BITS ARE ZERO
	LOADUC(.ADDR,UC_PTR);		!LOAD NOP MICRO-INSTR INTO ADDR
	CP(2);				!CLOCK ADDR INTO 'CURR LOC'
	ACTUAL = READ_SBR();		!READ 'SBR RET'
	IF .ACTUAL NEQ .CORRECT		!'SBR RET' SHOULDN'T HAVE CHANGED
	THEN
		ERRCAS(1,1,.CORRECT,.ACTUAL,4,ADDR);
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM ADDRESS = THE COMPLEMENT OF THE PRESENT VALUE OF
!*		'SBR RET'.
!*	GENERATE 2 CPU CLOCK PULSES - THE FIRST WILL CLOCK THE CRAM
!*		ADDRESS INTO 'CURR LOC' AND INTO THE STACK.  SINCE
!*		'CALL OR RETURN' SHOULD BE NEGATED, THE 2ND PULSE
!*		SHOULD NOT CLOCK THE ADDRESS INTO 'SBR RET'.
!*RESPONSE:
!*	THE VALUE OF 'SBR RET' CHANGED.
!]ERROR 1
!]PFBUF RTN CALLRTN NTWK
	IF LOOP_CHK(1)			!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST16: NOVALUE =

! THIS TEST CHECKS THAT ADDRESSES CAN BE CLOCKED FROM THE 'CURR LOC'
! LATCHES THRU THE SUBROUTINE STACK AND INTO THE 'SBR RET' LATCHES.  THE
! CRAM LOCATION CORRESPONDING TO THE TEST PATTERN ADDRESS IS LOADED WITH
! A CALL INSTRUCTION.  THE NEXT ADDRESS IS THEN SET TO BE THAT ADDRESS.
! TWO CLOCK PULSES ARE GENERATED.  THE FIRST WILL CLOCKED THE ADDRESS
! INTO 'CURR LOC'.  THE 2ND WILL DO THE CALL AND CLOCKED THE ADDRESS
! INTO 'SBR RET'.

	BEGIN
	OWN
		ADR_TAB: VECTOR[4] INITIAL(%O'4210',%O'2104',%O'1042',%O'0421');
	BIND
		UC_PTR = PLIT(U_CALL U);
	LOCAL
		DISCREP,
		CORRECT,
		ACTUAL;
	LABEL BLOCK1,ERBLK1;

	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .ADR_TAB[.I];
	DO (0) WHILE
BLOCK1:	BEGIN

	LOADUC(.CORRECT,UC_PTR);	!LOAD CALL INSTR AT TEST ADDR
	CP(2);				!GIVE 2 CLK PULSES
	ACTUAL = READ_SBR();		!READ 'SBR RET' VALUE
	IF .ACTUAL NEQ .CORRECT		!DID ADDR GET LATCHED INTO 'SBR RET'?
	THEN
ERBLK1:		BEGIN
		ERMCAS(1,.CORRECT,.ACTUAL,4,CORRECT); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE((.J+4) MOD 4);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!IF WE GET THIS FAR, THE WHOLE WORD IS INCORRECT.

		FAILURE(4);
		END
	ELSE
		NOERR(1);
!*MESSAGE 1
!*STIMULUS:
!*	LOAD CRAM ADDR \O0 WITH A CALL MICROINSTRUCTION.
!*	CP 2	- THE FIRST CLOCK PULSE WILL CLOCK THE CRAM ADDR INTO
!*		  'CURR LOC' AND THE CALL MICRO-INSTR INTO THE LATCHES.
!*		  THE 2ND PULSE SHOULD EXECUTE THE CALL MICRO-INSTR.
!*		  THIS SHOULD CLOCK THE 'CURR LOC' CONTENTS THRU THE
!*		  SUBROUTINE STACK RAM AND INTO THE 'SBR RET' LATCHES.
!*RESPONSE:
!*	THE VALUE CLOCKED INTO 'SBR RET' IS NOT EQUAL TO THE ORIGINAL
!*	CRAM ADDR.
!]ERROR 1
!]CLOC3 STACK3 DMX2 SBRET3 NTWK
!]ERROR 2
!]CLOC2 STACK2 DMX2 SBRET2 NTWK
!]ERROR 3
!]CLOC1 STACK1 DMX2 SBRET1 NTWK
!]ERROR 4
!]STKWRT FRSTCYC SYNCH TCLKB DFN2 CLKD CLKEN CALLRTN NTWK
!]NO ERROR 1
!]SBRET1 SBRET2 SBRET3 STKWRT CLKD CLKEN FRSTCYC SYNCH TCLKB NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

	END;

GLOBAL ROUTINE TST17: NOVALUE =

!THIS TEST CHECKS THAT THE 'SBR RET' ADDRESS CAN BE GATED CORRECTLY THRU
!THE CRAM ADDRESS MUXS.  A TEST CRAM ADDRESS IS LOADED WITH A CALL
!MICROINSTRUCTION TO ANOTHER CRAM ADDRESS.  THAT ADDRESS IS LOADED WITH
!A RETURN MICROINSTRUCTION.  TWO CLOCK PULSES ARE GIVEN.  THE 2ND SHOULD
!CLOCK THE RETURN ADDRESS INTO 'SBR RET' AND THE RETURN MICROINSTR INTO
!THE CONTROL LATCHES.  THIS WILL SELECT THE 'SBR RET' INPUTS TO THE CRAM
!ADDR MUXS.  SINCE THE DIAG ADDRESS WILL BE THE SAME VALUE AS THE 'SBR
!RET' SHOULD BE, TO AVOID MASKING A MUX SELECT FAULT, THE DIAG ADDR IS
!CHENGED BEFORE READING BACK THE NEXT CRAM ADDR VALUE.

	BEGIN
	OWN
		ADR_TAB: VECTOR[2] INITIAL(%O'7777',0);
	BIND
		UC_PTR1 = PLIT(U_CALL U_J(707) U),
		UC_PTR2 = PLIT(U_DISP_RETURN U);
	LOCAL
		DISCREP,
		CORRECT,
		ACTUAL;
	LABEL BLOCK1,ERBLK1;

	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .ADR_TAB[.I];
	DO (0) WHILE
BLOCK1:	BEGIN

	LOADUC(%O'707',UC_PTR2);	!LOAD RETURN INSTR
	LOADUC(.CORRECT,UC_PTR1);	!LOAD CALL INSTR AT TEST ADDR
	CP(2);				!GIVE 2 CLK PULSES
	CLK_DATA(NOT .CORRECT);		!SET DIAG ADDR TO COMP OF EXPECTED
	WRT204(CRAM_ADR_LD);		!LOAD DIAG ADR
	WRT204(0);
	ACTUAL = EX_NXT;		!READ NEXT CRAM ADDR
	IF .ACTUAL NEQ .CORRECT		!DID ADDR GATE THRU TO CRAM ADDR?
	THEN
ERBLK1:		BEGIN
		ERMCAS(1,.CORRECT,.ACTUAL,4,CORRECT); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
			THEN
				BEGIN
				FAILURE(.J +1);	!GO DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!IF WE GET THIS FAR, THE WHOLE WORD IS INCORRECT.

		FAILURE(13);
		END
	ELSE
		NOERR(1);
!*MESSAGE 1
!*STIMULUS:
!*	LOAD CRAM ADDR \O0 WITH A CALL MICROINSTRUCTION.
!*	LOAD CRAM ADDR 707 WITH RETURN MICROINSTRUCTION.
!*	CP 2	- THE FIRST CLOCK PULSE WILL CLOCK THE CRAM ADDR INTO
!*		  'CURR LOC' AND THE CALL MICRO-INSTR INTO THE LATCHES.
!*		  THE 2ND PULSE SHOULD EXECUTE THE CALL MICRO-INSTR.
!*		  THIS SHOULD CLOCK THE 'CURR LOC' CONTENTS THRU THE
!*		  SUBROUTINE STACK RAM AND INTO THE 'SBR RET' LATCHES.
!*		  IT WILL ALSO LATCH THE RETURN MICRO-INSTR WHICH IN
!*		  TURN WILL SELECT THE 'SBR RET' INPUTS TO THE CRAM
!*		  ADDR MUXS.
!*RESPONSE:
!*	THE NEXT CRAM ADDR IS NOT EQUAL TO THE 'SBR RET' ADDRESS.
!]ERROR 1
!]AMX11 SKIP10 SBRET1 STACK1 NTWK
!]ERROR 2
!]AMX10 SBRET1 STACK1 NTWK
!]ERROR 3
!]AMX9 SBRET1 STACK1 NTWK
!]ERROR 4
!]AMX8 SBRET1 STACK1 NTWK
!]ERROR 5
!]AMX6_7 SBRET2 STACK2 NTWK
!]ERROR 6
!]AMX6_7 SBRET2 STACK2 NTWK
!]ERROR 7
!]AMX4_5 SBRET2 STACK2 NTWK
!]ERROR 8
!]AMX4_5 SBRET2 STACK2 NTWK
!]ERROR 9
!]AMX2_3 SBRET1 STACK3 NTWK
!]ERROR 10
!]AMX2_3 SBRET1 STACK3 NTWK
!]ERROR 11
!]AMX0_1 SBRET1 STACK3 NTWK
!]ERROR 12
!]AMX0_1 SBRET1 STACK3 NTWK
!]ERROR 13
!]CLKD CLKEN CALLRTN STKWRT FRSTCYC SYNCH TCLKB NTWK
!]NO ERROR 1
!]CLKD CLKEN STKWRT FRSTCYC SYNCH TCLKB SBRET1 SBRET2 SBRET3 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

	END;

GLOBAL ROUTINE TST18: NOVALUE =

!THIS TEST CHECKS THAT THE SUBROUTINE STACK WORKS CORRECTLY. IT EXECUTES
!15 MICRO-INSTRUCTIONS WHICH DO SUBROUTINE CALLS, THEN EXECUTES 15
!INSTRS WHICH DO RETURNS.  AFTER EACH RETURN, THE NEXT CRAM ADDR IS
!CHECKED FOR CORRECTNESS.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		UC_PTR = PLIT(U_J(2) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(4) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(6) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(10) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(12) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(14) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(16) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(20) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(22) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(24) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(26) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(30) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(32) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(34) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(36) U_CALL U,
				U_J(1) U_DISP_RETURN U,
				U_J(1) U_DISP_RETURN U);
	LOCAL
		DISCREP,
		NUMCLKS,
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICRO-INSTRS
	WRT204(STK_RESET);		!RESET STACK
	WRT204(0);
	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(0);
	CP(15);			!EXECUTE ALL THE CALL INSTRS
	DECR I FROM 29 TO 1 BY 2 DO 
	BEGIN
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE RETURN AND READ NEXT ADDR
	IF .ACTUAL NEQ .I		!ARE WE AT CORRECT RETURN ADDR?
	THEN
ERBLK1:		BEGIN
		NUMCLKS = (31-.I)/2;	!COMPUTE # OF RETURN CLK PULSES
		ERMCAS(1,.I,.ACTUAL,4,NUMCLKS);	!NO, REPORT ERROR
		DISCREP = .ACTUAL XOR .I;	!COMPUTE DISCREPANCIES

!CHECK IF A GROUP OF 4 BITS ARE INCORRECT

		INCR J FROM 0 TO 2 BY 1 DO
			IF (.DISCREP AND (NOT %O'17'^(.J*4))) EQL 0
			THEN
				BEGIN
				FAILURE(1+.J);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;

!IF WE GET THIS FAR THE WHOLE WORD IS WRONG

		FAILURE(4);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRUCTIONS STARTING AT LOCATION 0 WHICH WILL
!*		EXECUTE 15 'CALLS' FROM EVEN LOCATIONS, I.E., FROM 0 TO
!*		2 TO 4 TO 6 ETC.  LOCATION 36 AND ALL ODD LOCATIONS UP
!*		TO THAT CONTAIN 'RETURNS' WITH A J FIELD OF 1.
!*	X1 0	- SET CRAM ADDRESS TO 0.
!*	CP 15	- EXECUTE THE 15 CALL INSTRUCTIONS.
!*	CP \O0	- EXECUTE \O0 RETURN INSTRUCTIONS.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS IS NOT CORRECT.
!]ERROR 1
!]RTN CALLRTN STKADR STACK3 TCLKB STKRST PFBUF NTWK
!]ERROR 2
!]RTN CALLRTN STKADR STACK2 TCLKB STKRST PFBUF NTWK
!]ERROR 3
!]RTN CALLRTN STKADR STACK1 TCLKB STKRST PFBUF NTWK
!]ERROR 4
!]STKADR RTN CALLRTN TCLKB STKRST PFBUF NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	END;
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST19: NOVALUE =

!THIS TEST CHECKS THAT THE SUBROUTINE STACK POINTER GETS RESET WHEN
!A 'STACK RESET' IS DONE.

! A MICROINSTRUCTION AT LOCATION ZERO JUMPS TO LOCATION 2.  FROM
! LOCATION 2, A CALL IS EXECUTED TO LOCATION 4.  THERE A CALL IS
! EXECUTED TO LOCATION 6.  THEN A 'STACK RESET' IS DONE AND A RETURN
! INSTRUCTION IS EXECUTED.  THIS RETURN SHOULD GO TO LOCATION 2 INSTEAD
! OF 4.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_J(2) U,
				U,
				U_J(4) U_CALL U,
				U,
				U_J(6) U_CALL U,
				U,
				 U_DISP_RETURN U);
	LOCAL
		ACTUAL;

	WRT204(STK_RESET);		!DO A STACK RESET
	WRT204(0);
	LOADUC(0,UC_PTR);	!LOAD MICRO-INSTRS
	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(0);
	CP(3);			!EXECUTE ALL THE CALL INSTRS
	WRT204(STK_RESET);		!DO A STACK RESET
	WRT204(0);
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE RETURN AND READ NEXT ADDR
	IF .ACTUAL NEQ 2		!ARE WE AT CORRECT RETURN ADDR?
	THEN
		ERRCA(1,2,.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRUCTIONS TO JUMP FROM 0 TO 2, DO A CALL FROM 2 TO
!*		4, DO A CALL FROM 4 TO 6, AND DO A RETURN FROM 6.
!*	X1 0	- SET THE CRAM ADDRESS TO ZERO.
!*	CP 3	- THREE CLOCK PULSES EXECUTE THE CALL INSTRS AT LOCS 2
!*		  AND 4.
!*	WRT 204/2	- DO A STACK RESET.
!*	WRT 204/0
!*	CP 1	- EXECUTE THE RETURN INSTR AT LOC 6.  AFTER THE STACK
!*		  RESET, THIS SHOULD CAUSE THE NEXT CRAM ADDR TO BE 2
!*		  INSTEAD OF 4.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS AFTER EXECUTING THE RETURN IS NOT 2.
!]ERROR 1
!]STKRST PFBUF CALLRTN RTN STKADR STACK NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;

	END;

GLOBAL ROUTINE TST20: NOVALUE =

!THIS TEST CHECKS THAT THE NICOND DISPATCH LOGIC WORKS CORRECTLY.

	BEGIN
	LABEL
		BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
		ERBLK1,ERBLK2,ERBLK3,ERBLK4,ERBLK5;
	BIND
		UC_PTR = PLIT( U_J(3770) U_DISP_NICOND U),
		UC_PTR1 = PLIT(U_J(1) U_N(20000) U_SPEC_APR_EN U_DBUS_DBM U_ALU_OR U_RSRC_D0 U,
				U_J(2) U_N(1000) U_SPEC_FLAGS U,
				U_J(3770) U_DISP_NICOND U),
		UC_PTR2 = PLIT(U_J(2) U_N(2000) U_SPEC_FLAGS U),
		UC_PTR3 = PLIT(U_J(2) U_N(3000) U_SPEC_FLAGS U);
	LOCAL
		DISCREP,
		ERFLG,
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICRO-INSTR
	ERFLG = 0;		!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:	BEGIN

	TP(0);			!TURN OFF TRAP ENABLES
	WRT212(RUN);		!ASSERT 'RUN' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'RUN'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE NICOND DISP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3777'		!DID WE DISPATCH CORRECTLY?
	THEN
ERBLK1:		BEGIN
		ERFLG = 1;	!SET ERROR FLAG
		ERMCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3777'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 2 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);
				LEAVE ERBLK1;
				END;
		FAILURE(4);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO DO A NICOND DISPATCH TO 377X.
!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
!*			  'DPE9 TRAP 1,2 AND 3'.
!*	WRT 212/4	- ASSERT 'RUN' PRE-FLOP
!*	CP 1		- GIVE A CLOCK PULSE TO ASSERT 'RUN'.
!*	X1 0		- SET NEXT CRAM ADDR TO 0.
!*	CP 1		- EXECUTE THE NICOND DISPATCH.  WITH ALL TRAPS
!*			  NEGATED AND 'RUN' ASSERTED, 'CRA2 NICOND 9, 10
!*			  AND 11' SHOULD ALL BE ASSERTED.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3777.
!]ERROR 1
!]NIC_ENC AMX11 NTWK
!]ERROR 2
!]NIC_ENC AMX10 NTWK
!]ERROR 3
!]NIC_ENC AMX9 NTWK
!]ERROR 4
!]NIC_ENC NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT212(0);		!NEGATE 'RUN' PRE-FLOP
	WRT100(RESET);		!ASSERT 'RESET' TO NEGATE 'RUN'
	WRT100(0);
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE NICOND DISP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3775'		!DID WE DISPATCH CORRECTLY?
	THEN
ERBLK2:		BEGIN
		ERFLG = 1;	!SET ERROR FLAG
		ERMCA(2,%O'3775',.ACTUAL,4);	!NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3775'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 2 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);
				LEAVE ERBLK2;
				END;
		FAILURE(4);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO DO A NICOND DISPATCH TO 377X.
!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
!*			  'DPE9 TRAP 1,2 AND 3'.
!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
!*	WRT 100/0	- NEGATE 'RESET'
!*	X1 0		- SET NEXT CRAM ADDR TO 0.
!*	CP 1		- EXECUTE THE NICOND DISPATCH.  WITH ALL TRAPS
!*			  NEGATED AND 'RUN' NEGATED, 'CRA2 NICOND 9
!*			  AND 11' SHOULD ALL BE ASSERTED AND 'CRA2
!*			  NICOND 10' SHOULD BE NEGATED.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3775.
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK3:	BEGIN

	TP(1);			!ASSERT 'CSL4 TRAP EN'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(3);	!EXECUTE NICOND DISP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3773'		!DID WE DISPATCH CORRECTLY?
	THEN
ERBLK3:		BEGIN
		ERFLG = 1;	!SET ERROR FLAG
		ERMCA(3,%O'3773',.ACTUAL,4);	!NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3773'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 2 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);
				LEAVE ERBLK3;
				END;
		FAILURE(4);
		END;
!*MESSAGE 3
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1' AND DO A NICOND DISPATCH
!*		TO 377X.
!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
!*	WRT 100/0	- NEGATE 'RESET'
!*	X1 0		- SET NEXT CRAM ADDR TO 0.
!*	CP 3		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
!*			  'DPE9 TRAP 1'.  THE 3RD INSTR DOES A NICOND
!*			  DISPATCH TO LOCATION 377X. WITH 'TRAP 1'
!*			 ASSERTED, 'CRA2 NICOND 9-11' SHOULD BE = 3.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3773.
	IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(1,UC_PTR2);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK4:	BEGIN

	TP(1);			!ASSERT 'CSL4 TRAP EN'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(3);	!EXECUTE NICOND DISP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3772'		!DID WE DISPATCH CORRECTLY?
	THEN
ERBLK4:		BEGIN
		ERFLG = 1;	!SET ERROR FLAG
		ERMCA(4,%O'3772',.ACTUAL,4);	!NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3772'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 2 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+5);
				LEAVE ERBLK4;
				END;
		FAILURE(4);
		END;
!*MESSAGE 4
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 2' AND DO A NICOND DISPATCH
!*		TO 377X.
!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
!*	WRT 100/0	- NEGATE 'RESET'
!*	X1 0		- SET NEXT CRAM ADDR TO 0.
!*	CP 3		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
!*			  'DPE9 TRAP 2'.  THE 3RD INSTR DOES A NICOND
!*			  DISPATCH TO LOCATION 377X. WITH 'TRAP 2'
!*			 ASSERTED, 'CRA2 NICOND 9-11' SHOULD BE = 2.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3772.
!]ERROR 5
!]SKIP10 NIC_ENC AMX11 NTWK
!]ERROR 6
!]NIC_ENC AMX10 NTWK
!]ERROR 7
!]NIC_ENC AMX9 NTWK
	IF LOOP_CHK(4)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(1,UC_PTR3);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK5:	BEGIN

	TP(1);			!ASSERT 'CSL4 TRAP EN'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(3);	!EXECUTE NICOND DISP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3771'		!DID WE DISPATCH CORRECTLY?
	THEN
ERBLK5:		BEGIN
		ERFLG = 1;	!SET ERROR FLAG
		ERMCA(5,%O'3771',.ACTUAL,4);	!NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3771'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 2 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);
				LEAVE ERBLK5;
				END;
		FAILURE(4);
		END;
!*MESSAGE 5
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1 AND 2' AND DO A NICOND
!*		DISPATCH TO 377X.
!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
!*	WRT 100/0	- NEGATE 'RESET'
!*	X1 0		- SET NEXT CRAM ADDR TO 0.
!*	CP 3		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
!*			  'DPE9 TRAP 1 AND 2'.  THE 3RD INSTR DOES A
!*			  NICOND DISPATCH TO LOCATION 377X.  WITH
!*			  'TRAP 1 AND 2' ASSERTED, 'CRA2 NICOND 9-11'
!*			  SHOULD BE = 1.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3771.
	IF LOOP_CHK(5)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	IF .ERFLG EQL 0		!IF WE DIDN'T HAVE ANY ERRORS THEN
	THEN
		NOERR(1);	!DO SOME FAULT ISOLATION
!]NO ERROR 1
!]NIC_ENC NTWK
	END;

GLOBAL ROUTINE TST21: NOVALUE =

!THIS TEST CHECKS THAT NEXT CRAM ADDRESS SKIPPING WORKS CORRECTLY WHEN
!A 'SKIP 10' IS EXECUTED WHICH SELECTS THE 'TRAP CYCLE' INPUT.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_N(20000) U_SPEC_APR_EN U_DBUS_DBM U_ALU_OR U_RSRC_D0 U,
				U_J(2) U_N(1000) U_SPEC_FLAGS U,
				U_J(3) U_SPEC_NICOND U,
				U_J(3776) U_SKIP_TRAP_CYC U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICRO-INSTR
	DO (0) WHILE
BLOCK1:	BEGIN

	TP(1);			!ASSERT 'CSL4 TRAP EN'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(4);	!EXECUTE NICOND SKIP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3777'		!DID WE SKIP CORRECTLY?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1' AND DO A TRAP CYCLE SKIP
!*		TO 3776.
!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
!*	X1 0		- SET NEXT CRAM ADDR TO 0.
!*	CP 4		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
!*			  'DPE9 TRAP 1'.  THE 3RD INSTR ASSERTS 'SPEC/
!*			  NICOND' WHICH SHOULD ASSERT 'TRAP CYCLE'.
!*			  THE 4TH INSTR DOES A TRAP CYCLE SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID NOT SKIP TO 3777.
!]ERROR 1
!]NIC_ENC TRPCYC SKIP10 AMX11 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:	BEGIN
	TP(0);			!TURN OFF TRAP ENABLES
	SET_C(2);		!SET CRAM ADDR TO 2
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE TRAP CYCLE SKIP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3776'		!DID WE DISPATCH CORRECTLY?
	THEN
		ERRCA(2,%O'3776',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO ASSERT 'SPEC/NICOND' AND DO A TRAP CYCLE
!*		SKIP TO 3776.
!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
!*			  'DPE9 TRAP 1,2 AND 3'.
!*	X1 3		- SET NEXT CRAM ADDR TO 3.
!*	CP 2		- THE 1ST INSTR WILL ASSERT 'SPEC/NICOND'. WITH
!*			  ALL TRAPS NEGATED, 'NICOND 9' IS ASSERTED. SO
!*			  'TRAP CYCLE' WILL BE NEGATED. WITH 'TRAP
!*			  CYCLE' NEGATED, THE 2ND INSTR WHICH DOES A
!*			  TRAP CYCLE SKIP, SHOULD NOT SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID SKIP TO 3777.
!]ERROR 2
!]NIC_ENC TRPCYC SKIP10 AMX11 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST22: NOVALUE =

!THIS TEST CHECKS THAT THE CONSOLE EXECUTE MODE SKIPPING WORKS
!CORRECTLY, I.E., SKIP FIELD = 64.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_EXECUTE U);
	LOCAL
		ERFLG,
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	ERFLG = 0;	!INIT ERROR FLAG
	WRT212(EXECUTE);	!ASSERT 'EXECUTE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'EXECUTE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		BEGIN
		ERFLG = 1;	!SET ERROR FLAG
		ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
!*	WRT 212/2	- ASSERT 'EXECUTE' PRE-FLOP
!*	CP 1		- ASSERT 'EXECUTE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 1
!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF .ERFLG EQL 0
	THEN
		BEGIN
		WRT100(RESET);		!NEGATE 'EXECUTE'
		WRT100(0);
		ACTUAL = EX_NXT;	!GET NEXT ADDR
		IF .ACTUAL NEQ %O'3777'
		THEN
			BEGIN
			ERFLG = 1;
			ERRCA(2,%O'3777',.ACTUAL,4);
			END;
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
!*	WRT 212/2	- ASSERT 'EXECUTE' PRE-FLOP
!*	CP 1		- ASSERT 'EXECUTE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP. THIS WILL CAUSE
!*			  THE NEXT CRAM ADDR TO BECOME 3777.
!*	WRT 100/200	- ASSERT 'RESET' ON THE CSL BOARD. THIS WILL 
!*			  NEGATE 'CSL4 EXECUTE'.  BUT WITH 'CRA2 DISP &
!*			  SKIP EN' NEGATED, THE NEXT ADDR SHOULD NOT
!*			  CHANGE.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS CHANGED FROM 3777. THIS IMPLIES THAT
!*	'CRA2 DISP & SKIP EN' IS STUCK ASSERTED.
!]ERROR 2
!]DSP_SKP_EN SYNCH FRSTCYC NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:	BEGIN

	WRT212(0);		!NEGATE 'EXECUTE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'EXECUTE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		BEGIN
		ERFLG = 1;
		ERRCA(3,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
		END;
!*MESSAGE 3
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
!*	WRT 212/0	- NEGATE 'EXECUTE' PRE-FLOP
!*	CP 1		- NEGATE 'EXECUTE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
!]ERROR 3
!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	IF .ERFLG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]DSP_SKP_EN SYNCH TCLKB NTWK

	END;

GLOBAL ROUTINE TST23: NOVALUE =

!THIS TEST CHECKS THAT THE 'NOT CONTINUE' SKIPPING WORKS
!CORRECTLY, I.E., SKIP FIELD = 66.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_CONTINUE U);
	LOCAL
		ERFLG,
		ACTUAL;

	ERFLG = 0;		!INIT ERROR FLAG
	LOADUC(0,UC_PTR);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	WRT212(CONTINUE);	!ASSERT 'CONTINUE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'CONTINUE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		BEGIN
		ERFLG = 1;
		ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
!*	WRT 212/2	- ASSERT 'CONTINUE' PRE-FLOP
!*	CP 1		- ASSERT 'CONTINUE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP. SINCE
!*			  'CONTINUE' IS ASSERTED, NO SKIP SHOULD OCCUR.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
!]ERROR 1
!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:	BEGIN

	WRT212(0);		!NEGATE 'CONTINUE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'CONTINUE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		BEGIN
		ERFLG = 1;
		ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
!*	WRT 212/0	- NEGATE 'CONTINUE' PRE-FLOP
!*	CP 1		- NEGATE 'CONTINUE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP.  SINCE
!*			  'CONTINUE' IS NEGATED, WE SHOULD SKIP TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 2
!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	IF .ERFLG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]DSP_SKP_EN TCLKB SYNCH NTWK

	END;

GLOBAL ROUTINE TST24: NOVALUE =

!THIS TEST CHECKS THAT THE 'NOT 1 MSEC TIMER' SKIPPING WORKS
!CORRECTLY, I.E., SKIP FIELD = 66.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_1_MS U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	WRT100(EN_1MS);		!ENABLE 1 MSEC TIME-OUT
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
!*	WRT 100/4	- ENABLE 1 MSEC TIMER. THIS SHOULD CAUSE 'DPMC
!*			  1 MSEC' TO ASSERT.
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP. SINCE
!*			  '1 MSEC' IS ASSERTED, NO SKIP SHOULD OCCUR.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
!]ERROR 1
!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:	BEGIN

	WRT100(0);		!NEGATE '1 MSEC TIMER' ENABLE
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
!*	WRT 100/0	- NEGATE '1 MSEC TIMER' ENABLE. THIS SHOULD
!*			  CAUSE 'DPMC 1 MSEC' TO NEGATE.
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP.  SINCE
!*			  '1 MSEC' IS NEGATED, WE SHOULD SKIP TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 2
!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST25: NOVALUE =

!THIS TEST CHECKS THAT THE 'NOT I/O LATCH' SKIPPING WORKS
!CORRECTLY, I.E., SKIP FIELD = 65.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_IO_BUSY U),
		UC_PTR1 = PLIT(U_J(1) U_SPEC_CLRIOLAT U,
				U_J(3776) U_SKIP_IO_BUSY U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	WRT115(IO_DATA);	!SET 'I/O DATA CYCLE' IN CSL BUFFER
	WRT210(BUS_REQ + XMIT_ADR);	!PUT IT ON BUS
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT I/O LATCH' SKIP.
!*	WRT 115/2	- ASSERT 'I/O DATA CYCLE' IN CSL I/O BUFFER.
!*	WRT 210/140	- GATE 'I/O DATA CYCLE' ONTO KS10 BUS. THIS
!*			  SHOULD ASSERT 'CRA2 I/O LATCH'.
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT I/O LATCH SKIP. SINCE
!*			  'I/O LATCH' IS ASSERTED, NO SKIP SHOULD OCCUR.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
!]ERROR 1
!]IOLTCH SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	WRT115(IO_DATA);	!SET 'I/O DATA CYCLE' IN CSL BUFFER
	WRT210(BUS_REQ + XMIT_ADR);	!PUT IT ON BUS
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO CLEAR 'I/O LATCH' AND TO EXECUTE A 'NOT
!*		I/O LATCH' SKIP.
!*	WRT 115/2	- ASSERT 'I/O DATA CYCLE' IN CSL I/O BUFFER.
!*	WRT 210/140	- GATE 'I/O DATA CYCLE' ONTO KS10 BUS. THIS
!*			  SHOULD ASSERT 'CRA2 I/O LATCH'.
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 2		- THE 1ST INSTR DOES A 'SPEC/CLR I/O LATCH'.
!*			  THIS SHOULD CLEAR 'I/O LATCH'. THE 2ND INSTR
!*			  EXECUTES THE NOT CONTINUE SKIP.  SINCE
!*			  'I/O LATCH' IS NEGATED,WE SHOULD SKIP TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 2
!]SPEC10 IOLTCH SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST26: NOVALUE =

!THIS TEST CHECKS THAT THE 'AD EQ 0' SKIPPING WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_ADEQ0 U),
		UC_PTR1 = PLIT(U_J(3776) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_DEST_PASS U_SKIP_ADEQ0 U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO DO 'AD EQ 0' SKIP TO LOCATION 3776.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE INSTR WHICH ASSERTS 'DPEA AD=0' AND DOES
!*		  A 'AD EQ 0' SKIP (SKIP FIELD = 62).
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 1
!]SKIP10 AMX11 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3776',.ACTUAL,4); !YES, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO DO 'AD EQ 0' SKIP TO LOCATION 3776.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE INSTR WHICH NEGATES 'DPEA AD=0' AND DOES
!*		  A 'AD EQ 0' SKIP (SKIP FIELD = 62).
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
!]ERROR 2
!]SKIP10 AMX11 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST27: NOVALUE =

!THIS TEST CHECKS THAT THE 'SC SIGN BIT' SKIPPING WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_LOADSC U_SCADA_SN U_SN(1000) U_SCAD_A U,
				U_J(3776) U_SKIP_SC U),
		UC_PTR1 = PLIT(U_J(1) U_LOADSC U_SCADA_SN U_SN(0) U_SCAD_A U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE SC SIGN BIT SKIP
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO ASSERT 'DPM4 SC SIGN' AND TO DO 'SC SIGN
!*		BIT' SKIP TO LOCATION 3776.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	- THE FIRST INSTR SHOULD SETUP FOR THE ASSERTION OF
!*		  'DPM SC SIGN'.  THE 2ND INSTR WILL ASSERT IT AND DO A
!*		  SKIP BASED ON THAT ASSERTION.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 1
!]SKIP10 AMX11 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE SC SIGN BIT SKIP
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3776',.ACTUAL,4); !YES, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO NEGATE 'DPM4 SC SIGN' AND TO DO 'SC SIGN
!*		BIT' SKIP TO LOCATION 3776.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	- THE FIRST INSTR SHOULD SETUP FOR THE NEGATION OF
!*		  'DPM SC SIGN'.  THE 2ND INSTR WILL NEGATE IT AND DO A
!*		  SKIP BASED ON THAT NEGATION.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
!]ERROR 2
!]SKIP10 AMX11 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST28: NOVALUE =

!THIS TEST CHECKS THAT DISPATCHING ON 'DPM3 SCAD 00' WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3775) U_SCADA_SN U_SN(1000) U_SCAD_A U_DISP_SCAD0 U),
		UC_PTR1 = PLIT(U_J(3775) U_SCADA_SN U_SN(0) U_SCAD_A U_DISP_SCAD0 U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SCAD 0 DISPATCH
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO ASSERT 'DPM3 SCAD 00' AND DO A SCAD 00
!*		DISPATCH (67) TO 3775.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE THE MICRO-INSTR.  WITH 'SCAD 00' ASSERTED, THE
!*		  NEXT CRAM ADDRESS SHOULD DISPATCH TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
!]ERROR 1
!]AMX10 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SCAD 0 DISPATCH
	IF .ACTUAL NEQ %O'3775'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3775',.ACTUAL,4); !YES, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO NEGATE 'DPM3 SCAD 00' AND DO A SCAD 00
!*		DISPATCH (67) TO 3775.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE THE MICRO-INSTR.  WITH 'SCAD 00' NEGATED, THE
!*		  NEXT CRAM ADDRESS SHOULD DISPATCH TO 3775.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3775.
!]ERROR 2
!]AMX10 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST29: NOVALUE =

!THIS TEST CHECKS THAT DISPATCHING ON 'DPE5 FLAG QR 37' WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_N(777777) U_DBUS_DBM U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U,
				U_J(2) U_DEST_Q_DIV2 U,
				U_J(3) U_DEST_Q_DIV2 U,
				U_J(4) U_DEST_Q_DIV2 U,
				U_J(3773) U_DISP_MUL U),
		UC_PTR1 = PLIT(U_J(1) U_DEST_Q_AD U,
				U_J(2) U_DEST_Q_DIV2 U,
				U_J(3773) U_DISP_MUL U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(5);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO ASSERT 'DPE5 FLAG QR 37' THEN DO A
!*		'MULTIPLY' DISPATCH (62) TO 3773.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 5	- THE FIRST INSTR LOADS ONES INTO THE Q REGISTER.
!*		  THE NEXT 3 INSTRS SHIFT THE Q REG RIGHT AND ASSERT
!*		  'DPE1-2 QR 37'.  THE LAST INSTR ASSERTS 'DPE5 FLAG
!*		  QR 37' AND DOES THE 'MULTIPLY' DISPATCH WHICH SHOULD
!*		  GO TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
!]ERROR 1
!]AMX9 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(3);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3773'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3773',.ACTUAL,4); !YES, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO NEGATE 'DPE5 FLAG QR 37' THEN DO A
!*		'MULTIPLY' DISPATCH (62) TO 3773.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 3	- THE FIRST INSTR LOADS A ZERO INTO BIT 37 OF THE Q
!*		  REGISTER. THE NEXT INSTR SHIFTS THE Q REG RIGHT AND
!*		  NEGATES 'DPE1-2 QR 37'.  THE LAST INSTR NEGATES
!*		  'DPE5 FLAG QR 37' AND DOES A MULTIPLY DISPATCH WHICH
!*		  SHOULD GO TO 3773.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3773.
!]ERROR 2
!]AMX9 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST30: NOVALUE =

!THIS TEST CHECKS THAT DISPATCHING ON 'DPM6 MEMORY CYCLE' WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
				U_J(2) U_N(40002) U_MEM U,
				U_J(3767) U_DISP_NICOND U),
		UC_PTR1 = PLIT(U_J(1) U_SPEC_MEMCLR U,
				U_J(3767) U_DISP_NICOND U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(3);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO ASSERT 'DPM6 MEMORY CYCLE' THEN DO A
!*		'NICOND' DISPATCH (64) TO 3767.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 3	- THE FIRST INSTR CLEARS ANY LEFT OVER PAGE FAULTS.
!*		  THE 2ND INSTR STARTS A MEMORY CYCLE. THE 3RD INSTR
!*		  ASSERTS 'DPM6 MEMORY CYCLE' AND DOES A NICOND DISPATCH
!*		  WHICH SHOULD GO TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
!]ERROR 1
!]AMX8 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3767'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3767',.ACTUAL,4); !YES, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO NEGATE 'DPM6 MEMORY CYCLE' THEN DO A
!*		'NICOND' DISPATCH (64) TO 3767.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	- THE FIRST INSTR DOES A SPEC/MEMORY CLEAR.THE 2ND INSTR
!*		  NEGATES 'DPM6 MEMORY CYCLE' AND DOES A NICOND DISPATCH
!*		  WHICH SHOULD GO TO 3767.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3767.
!]ERROR 2
!]AMX8 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST31: NOVALUE =

!THIS TEST CHECKS THAT 'BYTE' DISPATCHING WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2,ERBLK1,ERBLK2;
	BIND
		UC_PTR = PLIT(U_J(3770) U_N(10700) U_DBUS_DBM U_ALU_OR U_LSRC_D0 U_DISP_BYTE U),
		UC_PTR1 = PLIT(U_J(3770) U_DISP_BYTE U);
	LOCAL
		DISCREP,
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
	THEN
ERBLK1:		BEGIN
		ERMCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3777'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 2 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);
				LEAVE ERBLK1;
				END;
		FAILURE(4);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO ASSERT 'DPE5 BYTE DISP 9,10,11' AND DO A
!*		BYTE DISPATCH TO 3770.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE THE MICRO-INSTR TO ASSERT THE 'BYTE DISP' BITS
!*		  AND DO A BYTE DISPATCH WHICH SHOULD GO TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
!]ERROR 1
!]AMX11 NTWK
!]ERROR 2
!]AMX10 NTWK
!]ERROR 3
!]AMX9 NTWK
!]ERROR 4
!]AMX9 AMX10 AMX11 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3770'		!DID WE TAKE SKIP?
	THEN
ERBLK2:		BEGIN
		ERMCA(2,%O'3770',.ACTUAL,4); !YES, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3770'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 2 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+5);
				LEAVE ERBLK2;
				END;
		FAILURE(4);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO NEGATE 'DPE5 BYTE DISP 9,10,11' AND DO A
!*		BYTE DISPATCH TO 3770.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE THE MICRO-INSTR TO NEGATE THE 'BYTE DISP' BITS
!*		  AND DO A BYTE DISPATCH WHICH SHOULD GO TO 3770.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3770.
!]ERROR 5
!]SKIP10 AMX11 NTWK
!]ERROR 6
!]AMX10 NTWK
!]ERROR 7
!]AMX9 NTWK
!]ERROR 8
!]AMX9 AMX10 AMX11 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST32: NOVALUE =

!THIS TEST CHECKS THAT 'EFFECTIVE ADDRESS MODE' DISPATCHING WORKS
!CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2,ERBLK1,ERBLK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_LDINST U_N(20) U_DBUS_DBM U,
				U_J(3760) U_DISP_EAMODE U),
		UC_PTR1 = PLIT(U_J(1) U_SPEC_LDINST U_N(254017) U_DBUS_DBM U,
				U_J(3760) U_DISP_EAMODE U);
	LOCAL
		DISCREP,
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE DISPATCH?
	THEN
ERBLK1:		BEGIN
		ERMCA(1,%O'3776',.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3776'; !COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 3 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);
				LEAVE ERBLK1;
				END;
		FAILURE(5);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO SETUP THE 3 EA MODE DISPATCH SIGNALS AND DO
!*		AN 'EA MODE' DISPATCH TO 3760.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
!*		  AND XR LOAD.  THE 2ND INSTR NEGATES 'DPEA JRST,0' AND
!*		  ASSERTS 'DPEA XR=0' AND 'DPEA INDIRECT' THEN DOES AN
!*		  EA MODE DISPATCH WHICH SHOULD GO TO 3776.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3776.
!]ERROR 1
!]SKIP10 AMX11 NTWK
!]ERROR 2
!]AMX10 NTWK
!]ERROR 3
!]AMX9 NTWK
!]ERROR 4
!]AMX8 NTWK
!]ERROR 5
!]AMX8 AMX9 AMX10 AMX11 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'3760'		!DID WE TAKE SKIP?
	THEN
ERBLK2:		BEGIN
		ERMCA(2,%O'3760',.ACTUAL,4); !YES, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'3760';
		INCR J FROM 0 TO 3 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);
				LEAVE ERBLK2;
				END;
		FAILURE(5);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO SETUP THE 3 EA MODE DISPATCH SIGNALS AND DO
!*		AN 'EA MODE' DISPATCH TO 3760.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
!*		  AND XR LOAD.  THE 2ND INSTR ASSERTS 'DPEA JRST,0' AND
!*		  NEGATES 'DPEA XR=0' AND 'DPEA INDIRECT' THEN DOES AN
!*		  EA MODE DISPATCH WHICH SHOULD GO TO 3760.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3760.
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST33: NOVALUE =

!THIS TEST CHECKS THAT 'DROM' DISPATCHING WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2,ERBLK1,ERBLK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_LDINST U_N(702740) U_DBUS_DBM U,
				U_J(0) U_DISP_DROM U),
		UC_PTR1 = PLIT(U_J(1) U_SPEC_LDINST U_N(600000) U_DBUS_DBM U,
				U_J(0) U_DISP_DROM U);
	LOCAL
		DISCREP,
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'1777'		!DID WE TAKE DISPATCH?
	THEN
ERBLK1:		BEGIN
		ERMCA(1,%O'1777',.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'1777';	!COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;
		FAILURE(13);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO SELECT DROM LOCATION WITH 'DROM J 00-03'
!*		EQUAL TO ONES AND 'AC DISP' ASSERTED.  ALSO, ASSERT
!*		'AC 09' TO 'AC 12'.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
!*		  AND XR LOAD. THE 2ND INSTR LOADS THE IR WITH 702,
!*		  SELECTING A DROM LOCATION WITH 'DROM J 00-03' = 1S AND
!*		  'AC DISP' ASSERTED.  WITH THE AC FIELD ALL ONES, THE
!*		  DROM DISPATCH THEN SHOULD GO TO 1777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1777.
!]ERROR 1
!]AMX11 NTWK
!]ERROR 2
!]AMX10 NTWK
!]ERROR 3
!]AMX9 NTWK
!]ERROR 4
!]AMX8 NTWK
!]ERROR 5
!]AMX6_7 NTWK
!]ERROR 6
!]AMX6_7 NTWK
!]ERROR 7
!]AMX4_5 NTWK
!]ERROR 8
!]AMX4_5 NTWK
!]ERROR 9
!]AMX2_3 NTWK
!]ERROR 10
!]AMX2_3 NTWK
!]ERROR 11
!]AMX0_1 NTWK
!]ERROR 12
!]AMX0_1 NTWK
!]ERROR 13
!]AMX NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'1400'		!DID WE TAKE SKIP?
	THEN
ERBLK2:		BEGIN
		ERMCA(2,%O'1400',.ACTUAL,4); !YES, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'1400';	!COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);	!DO FAULT ISOLATION
				LEAVE ERBLK2;
				END;
		FAILURE(13);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO CAUSE A DROM DISPATCH FROM A DROM LOACTION
!*		WHICH HAS 'DROM 00-07' = 0 AND 'AC DISP' NEGATED.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
!*		  AND XR LOAD.  THE 2ND INSTR LOADS THE IR WITH 600,
!*		  SELECTING A DROM LOCATION WITH 'DROM 00-07' = 0. THE
!*		  DROM DISPATCH SHOULD THEN GO TO 1400.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1400.
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST34: NOVALUE =

!THIS TEST CHECKS THAT 'AREAD' DISPATCHING WORKS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,ERBLK1,ERBLK2,ERBLK3;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_LDINST U_N(110000) U_DBUS_DBM U,
				U_J(17) U_DISP_AREAD U),
		UC_PTR1 = PLIT(U_J(1) U_SPEC_LDINST U_N(324000) U_DBUS_DBM U,
				U_J(17) U_DISP_AREAD U),
		UC_PTR2 = PLIT(U_J(1) U_SPEC_LDINST U_N(221000) U_DBUS_DBM U,
				U_J(17) U_DISP_AREAD U);
	LOCAL
		DISCREP,
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'57'		!DID WE TAKE DISPATCH?
	THEN
ERBLK1:		BEGIN
		ERMCA(1,%O'57',.ACTUAL,4); !NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'57';	!COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 7 BY 1 DO
			IF .DISCREP EQL %O'20'^.J
			THEN
				BEGIN
				FAILURE(.J+1);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;
		FAILURE(9);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO SELECT DROM LOCATION WITH 'DROM A=J' = 0
!*		THEN DO AN 'AREAD' DISPATCH.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
!*		  AND XR LOAD. THE 2ND INSTR LOADS THE IR WITH 110,
!*		  SELECTING A DROM LOCATION WITH 'DROM A=J' NEGATED.
!*		  WITH THE J FIELD = 17, THE AREAD DISPATCH SHOULD THEN
!*		  GO TO 57.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 57.
!]ERROR 1
!]AMX6_7 AREAD NTWK
!]ERROR 2
!]AMX6_7 AREAD NTWK
!]ERROR 3
!]AMX4_5 AREAD NTWK
!]ERROR 4
!]AMX4_5 AREAD NTWK
!]ERROR 5
!]AMX2_3 AREAD NTWK
!]ERROR 6
!]AMX2_3 AREAD NTWK
!]ERROR 7
!]AMX0_1 AREAD NTWK
!]ERROR 8
!]AMX0_1 AREAD NTWK
!]ERROR 9
!]AREAD NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR1);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK2:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'1537'		!DID WE TAKE SKIP?
	THEN
ERBLK2:		BEGIN
		ERMCA(2,%O'1537',.ACTUAL,4); !YES, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'1537';	!COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 7 BY 1 DO
			IF .DISCREP EQL %O'20'^.J
			THEN
				BEGIN
				FAILURE(.J+1);	!DO FAULT ISOLATION
				LEAVE ERBLK2;
				END;
		FAILURE(9);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO CAUSE AN 'AREAD' DISPATCH FROM A DROM
!*		LOACTION WHICH HAS 'DROM A=J' ASSERTED AND 'DROM 00-
!*		03' = 5.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
!*		  AND XR LOAD.  THE 2ND INSTR LOADS THE IR WITH 324,
!*		  SELECTING A DROM LOCATION WITH 'DROM 00-03' = 5 AND
!*		  'DROM A=J' ASSERTED.  WITH THE J FIELD = 17, THE
!*		  DROM DISPATCH SHOULD THEN GO TO 1537.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1537.
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	LOADUC(0,UC_PTR2);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK3:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
	IF .ACTUAL NEQ %O'1657'		!DID WE TAKE SKIP?
	THEN
ERBLK3:		BEGIN
		ERMCA(3,%O'1657',.ACTUAL,4); !YES, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'1657';	!COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 7 BY 1 DO
			IF .DISCREP EQL %O'20'^.J
			THEN
				BEGIN
				FAILURE(.J+1);	!DO FAULT ISOLATION
				LEAVE ERBLK3;
				END;
		FAILURE(9);
		END;
!*MESSAGE 3
!*STIMULUS:
!*	LOAD MICRO-INSTR TO CAUSE AN 'AREAD' DISPATCH FROM A DROM
!*		LOACTION WHICH HAS 'DROM A=J' ASSERTED AND 'DROM 00-
!*		03' = 12.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
!*		  AND XR LOAD.  THE 2ND INSTR LOADS THE IR WITH 221,
!*		  SELECTING A DROM LOCATION WITH 'DROM 00-03' = 12 AND
!*		  'DROM A=J' ASSERTED.  WITH THE J FIELD = 17, THE
!*		  DROM DISPATCH SHOULD THEN GO TO 1657.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1657.
	IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST35: NOVALUE =

!THIS TEST CHECKS THAT A PAGE FAIL CAUSES A DISPATCH TO CRAM ADDR 7777.
!IT ALSO VERIFIES THAT THAT DISPATCH IS REALLY DONE AS A SUBROUTINE
!CALL.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
				U_J(2) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
				U_J(3) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
				U_J(4) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(403010) U_SPEC_LDPAGE U,
				U_J(5) U,
				U_J(6) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(432012) U,
				U_J(0) U_MEM U_N(2) U),
		UC_PTR1 = PLIT(U_J(0) U_SPEC_MEMCLR U_DISP_RETURN U),
		UC_PTR2 = PLIT(U_J(0) U_SPEC_MEMCLR U);
	LOCAL
		DISCREP,
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICROCODE FOR PAGE FAIL
	LOAD_U(7777,UC_PTR1);	!LOAD RETURN INSTR
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(7);	!GENERATE PAGE FAIL
	IF .ACTUAL NEQ %O'7777'		!DID WE TRAP?
	THEN
ERBLK1:		BEGIN
		ERMCA(1,%O'7777',.ACTUAL,4);	!NO, REPORT ERROR
		DISCREP = .ACTUAL XOR %O'7777';	!COMPUTE DISCREPANCIES
		INCR J FROM 0 TO 11 BY 1 DO
			IF .DISCREP EQL 1^.J
			THEN
				BEGIN
				FAILURE(.J+1);	!DO FAULT ISOLATION
				LEAVE ERBLK1;
				END;
		FAILURE(13);
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP TO ADDR 7777.
!*	X1 0		- SET CRAM ADDR = 0.
!*	CP 7 	- THE FIRST 5 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD TRAP
!*		  THE CRAM ADDR TO 7777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT TRAP TO 7777.
!]ERROR 1
!]AMX11 NTWK
!]ERROR 2
!]AMX10 NTWK
!]ERROR 3
!]AMX9 NTWK
!]ERROR 4
!]AMX8 NTWK
!]ERROR 5
!]AMX6_7 NTWK
!]ERROR 6
!]AMX6_7 NTWK
!]ERROR 7
!]AMX4_5 NTWK
!]ERROR 8
!]AMX4_5 NTWK
!]ERROR 9
!]AMX2_3 NTWK
!]ERROR 10
!]AMX2_3 NTWK
!]ERROR 11
!]AMX0_1 NTWK
!]ERROR 12
!]AMX0_1 NTWK
!]ERROR 13
!]PFBUF NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	ACTUAL = STEP_U_NEXT(1);	!EXECUTE THE RETRUN INSTR
	IF .ACTUAL NEQ 6		!DID WE RETURN OKAY?
	THEN
		BEGIN
		ERMCA(2,6,.ACTUAL,4);	!NO, REPORT ERROR
		FAILURE(14);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP TO ADDR 7777 AND
!*		THEN DO A RETURN FROM THERE.
!*	X1 0	- SET CRAM ADDRESS = 0.
!*	CP 7	- CAUSE THE PAGE FAIL AND TRAP TO ADDRESS 7777.
!*	CP 1	- EXECUTE THE RETURN INSTR THERE.  IF THE PAGE FAIL TRAP
!*		  WORKED CORRECTLY, IT WOULD HAVE DONE A PUSH ONTO THE
!*		  STACK. THEN THE RETURN WILL GO TO ADDR 6.
!*RESPONSE:
!*	THE RETURN INSTR AT 7777 DID NOT GO TO ADDR 6.
!]ERROR 14
!]PFBUF STKADR CALLRTN NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	LOADUC(0,UC_PTR2);	!LOAD MEM CLR INSTR
	CP_NOSS(3);		!EXECUTE INSTR TO CLEAR PAGE FAULT

	END;

GLOBAL ROUTINE TST36: NOVALUE =

!THIS TEST CHECKS THAT THE 'SKIP 40' INPUT TO THE NEXT ADDR MUX CAN BE
!ASSERTED AND CAUSES A SKIP.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_ADLEQ0 U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO DO 'ADL = 0' SKIP TO LOCATION 3776.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE INSTR WHICH ASSERTS 'DPE1 ADL=0' AND DOES
!*		  A 'ADL EQ 0' SKIP (SKIP FIELD = 32).
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 1
!]AMX11 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST37: NOVALUE =

!THIS TEST CHECKS THAT THE 'SKIP 20' INPUT TO THE NEXT ADDR MUX CAN BE
!ASSERTED AND CAUSES A SKIP.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_DP0 U_N(777777) U_DBUS_DBM U_ALU_OR U_LSRC_D0 U);
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);		!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:	BEGIN

	SET_C(0);		!SET CRAM ADDR = 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO DO 'ADL SIGN' SKIP TO LOCATION 3776.
!*	X1 0	- SET CRAM ADDR TO 0
!*	CP 1	- EXECUTE INSTR WHICH ASSERTS 'DPE1 ADL SIGN' AND DOES
!*		  A 'ADL SIGN' SKIP (SKIP FIELD = 52).
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
!]ERROR 1
!]AMX11 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST38: NOVALUE =

!THIS TEST CHECKS THAT THE 'CRA2 RETURN' SIGNAL GETS ASSERTED ONLY WHEN
!IT IS SUPPOSED TO, I.E., WHEN 'CRA6 DISP SEL 1A' IS ASSERTED AND
!'CRA6 DISP SEL 2A' AND 'CRA6 DISP EN 20' ARE NEGATED.  THIS OCCURS WHEN
!THE DISPATCH FIELDS ARE EQUAL TO 41.
!TO DO THE TEST A 'CALL' IS DONE FROM LOCATION 0 TO LOCATION 1.  FROM
!LOCATION 1 A 'CALL' IS MADE TO LOCATION 2.  AT LOCATION 2 A DISPATCH OF
!'71' IS DONE WITH A J FIELD OF 3.  THIS DISPATCH SHOULD NOT AFFECT THE
!NEXT ADDRESS BUT IF THERE IS A FAULT 'CRA2 RETURN' WILL GET ASSERTED.
!IN THAT CASE, THE SUBROUTINE STACK WILL BE DECREMENTED.  AFTER EXECUTE
!THE INSTRUCTION AT LOCATION 3, THE STACK WILL CONTAIN 0 INSTEAD OF THE
!CORRECT VALUE OF 1.  THIS IS REPEATED TWICE MORE WITH LOCATION 2 HAVING
!DISPATCH FIELDS OF 50 AND 53.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_J(1) U_CALL U,
				U_J(2) U_CALL U,
				U,
				U_J(4) U);
	OWN
		DISP_TAB: VECTOR[3] INITIAL (%O'71', %O'50', %O'53'),
		PTR_TAB: VECTOR[3] INITIAL (PLIT(U_J(3) U_DISP(%O'71') U),
					PLIT(U_J(3) U_DISP(%O'50') U),
					PLIT(U_J(3) U_DISP(%O'53') U));
	LOCAL
		ACTUAL;

	LOADUC(0,UC_PTR);	!LOAD MICROCODE
	INCR I FROM 0 TO 2 BY 1 DO
	BEGIN
	LOADUC(2,.PTR_TAB[.I]);	!LOAD DISPATCH INSTR
	DO (0) WHILE
BLOCK1:	BEGIN

	WRT204(STK_RESET);		!RESET STACK PTR
	WRT204(0);
	SET_C(0);		!SET CRAM ADDR = 0
	CP(4);			!EXECUTE BAD DISPATCH
	ACTUAL = READ_SBR();		!READ 'SBR RET'
	IF .ACTUAL NEQ 1		!DID 'CRA2 RETURN' ASSERT?
	THEN
		ERRCAS(1,1,1,.ACTUAL,4,DISP_TAB[.I]); !YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO DO 2 'CALLS' AND A DISPATCH '\O0'.
!*	WRT 204/2	- DO A STACK RESET
!*	WRT 204/0
!*	X1 0		- SET  CRAM ADDRESS = 0.
!*	CP 4		- THIS FIRST INSTR DOES A CALL TO LOCATION 1.
!*			  THE 2ND INSTR DOES A CALL TO LOCATION 2. THIS
!*			  SHOULD PUT A 1 AT THE TOP OF THE STACK. THE
!*			  3RD INSTR HAS A DISPATCH FIELD OF \O0 WHICH
!*			  SHOULD DO NOTHING.  THE 4TH INSTR IS JUST
!*			  EXECUTED TO CLOCK THE 'SBR RET' REGISTER. THE
!*			  'SBR RET' SHOULD CONTAIN A 1.
!*RESPONSE:
!*	THE 'SBR RET' DOES NOT CONTAIN A 1. THIS IMPLIES THAT THE
!*	INSTR AT LOC 2 WITH DISPATCH FIELD \O0 INCORRECTLY ASSERTED
!*	'CRA2 RETURN' THUS CAUSING THE STACK TO GET DECREMENTED.
!]ERROR 1
!]RTN NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

	END;

GLOBAL ROUTINE TST39: NOVALUE =

!THIS TEST CHECKS THAT THE 'SPEC/CONSOLE' SIGNAL GETS GENERATED
!CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_N U_N(10) U),
		UC_PTR1 = PLIT(U_J(1) U_N(10) U);

	LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
	DO (0) WHILE
BLOCK1:	BEGIN

	WRT100(RESET);		!DO A RESET
	WRT100(0);
	SET_C(0);		!SET CRAM ADDR = 0
	WRT212(4);				!ASSERT 1ST STAGE FLOP
	CP(2);			!GIVE 2 CLK PULSES
	IF (RD_300 AND RUN_1 ) NEQ 0		!DID 'RUN (1)' NEGATE?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO ASSERT 'SPEC/CONSOLE' AND 'CRM2 # 14B'.
!*	ASSERT AND NEGATE 'RESET'
!*	X1 0		- SET CRAM ADDR = 0.
!*	WRT 212/4	- ASSERT  'RUN' PRE-FLOP
!*	CP 2		- THE 1ST CLOCK PULSE WILL EXECUTE THE MICRO-
!*			  INSTR TO ASSERT 'CRA2 SPEC/CONSOLE' AND 'CRM2
!*			  # 14B'.  THIS WILL NEGATE THE 'RUN' PRE-FLOP.
!*			  AT THE SAME TIME THE 'RUN' FLOP WILL BE
!*			  ASSERTED.  THE 2ND PULSE WILL CLOCK THE
!*			  NEGATED OUTPUT OF THE PRE-FLOP INTO THE 'RUN'
!*			  FLOP, THUS NEGATING 'RUN'.
!*RESPONSE:
!*	'RUN (1)' DID NOT NEGATE. THIS IMPLIES THAT 'CRA2 SPEC/CONSOLE'
!*	DID NOT ASSERT.
!]ERROR 1
!]SPEC10 NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;

	LOAD_U(0,UC_PTR1);			!LOAD CRAM BITS
	DO (0) WHILE
BLOCK2:	BEGIN

	WRT100(RESET);		!DO A RESET
	WRT100(0);
	SET_C(0);		!SET CRAM ADDR = 0
	WRT212(4);				!ASSERT 1ST STAGE FLOP
	CP(2);			!GIVE 2 CLK PULSES
	IF (RD_300 AND RUN_1 ) EQL 0		!DID 'RUN (1)' NEGATE?
	THEN
		ERR(2);		!YES, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO NEGATE 'SPEC/CONSOLE' AND ASSERT
!*		'CRM2 # 14B'.
!*	ASSERT AND NEGATE 'RESET'
!*	X1 0		- SET CRAM ADDR = 0.
!*	WRT 212/4	- ASSERT  'RUN' PRE-FLOP
!*	CP 2		- THE 1ST CLOCK PULSE WILL EXECUTE THE MICRO-
!*			  INSTR TO NEGATE 'CRA2 SPEC/CONSOLE' AND
!*			  ASSERT 'CRM2 # 14B'.  THIS SHOULD NOT NEGATE
!*			  THE 'RUN' PRE-FLOP.  AT THE SAME TIME THE
!*			  'RUN' FLOP WILL BE ASSERTED.  THE 2ND PULSE
!*			  WILL CLOCK THE STILL ASSERTED OUTPUT OF THE
!*			  PRE-FLOP INTO THE 'RUN' FLOP, THUS LEAVING
!*			  'RUN' ASSERTED.
!*RESPONSE:
!*	'RUN (1)' NEGATED. THIS IMPLIES THAT 'CRA2 SPEC/CONSOLE'
!*	ASSERTED WHEN IT SHOULDN'T HAVE.
!]ERROR 2
!]SPEC10 NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;

	END;

GLOBAL ROUTINE TST40: NOVALUE =

!THIS TEST CHECKS THAT THE PARITY DETECTION NETWORK FUNCTIONS CORRECTLY.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	LOCAL
		ERFLG;
	OWN
		EVEN_PAR_TBL: VECTOR[16] INITIAL( %O'0',
						  %O'400040000000',
						  %O'200020000000',
						  %O'001000000010',
						  %O'000400000004',
						  %O'000151030303',
						  %O'000152030303',
						  %O'000153010303',
						  %O'000153020303',
						  %O'000153030103',
						  %O'000153030203',
						  %O'000153030301',
						  %O'000153030302',
						  %O'776737777777',
						  %O'777367777777',
						  %O'777727777777'),
		ODD_PAR_TBL: VECTOR[29] INITIAL(  %O'100010400000',
						  %O'040004200000',
						  %O'020000104000',
						  %O'010000042000',
						  %O'004000001040',
						  %O'002000000420',
						  %O'000200000000',
						  %O'000100000000',
						  %O'000000000020',
						  %O'000000000004',
						  %O'000002000000',
						  %O'000001000000',
						  %O'000000020000',
						  %O'000000010000',
						  %O'000000000200',
						  %O'000000000100',
						  %O'000000000002',
						  %O'000000000001',
						  %O'000153030303',
						  %O'377727777777',
						  %O'577753777777',
						  %O'677777277777',
						  %O'737777537777',
						  %O'757777772777',
						  %O'767777775377',
						  %O'773777777727',
						  %O'775777777753',
						  %O'777577777777',
						  %O'777677777777');
	ERFLG = 0;		!INIT ERROR FLAG
	LCA(0);			!SET CRAM ADDR = 0
	INCR I FROM 0 TO 15 BY 1 DO
	BEGIN
	DO (0) WHILE
BLOCK1:	BEGIN

	DC_035(.EVEN_PAR_TBL[.I]);	!LOAD PATTERN INTO CRAM
	CP(1);				!CLOCK CRAM BITS INTO REGISTER
	IF (RD_100 AND CRA_PE) EQL 0	!DID CRA PARITY ERROR ASSERT?
	THEN
		BEGIN
		ERRS(1,1,EVEN_PAR_TBL[.I]);	!YES, REPORT ERROR
		ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LC 0			- SET CRAM ADDR = 0
!*	DC \O000000000000000000000  - DEPOSIT TEST PATTERN INTO
!*				  BITS 0-35 OF CRAM.  THIS SHOULD YIELD
!*				  VALID EVEN PARITY.
!*RESPONSE:
!*	'CRA PARITY ERR' ASSERTED ON THE CSL BOARD.
!]ERROR 1
!]PARNET NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	IF .ERFLG NEQ 0
	THEN
		RETURN;
	END;

	LCA(0);			!SET CRAM ADDR = 0
	INCR I FROM 0 TO 28 BY 1 DO
	BEGIN
	DO (0) WHILE
BLOCK2:	BEGIN

	DC_035(.ODD_PAR_TBL[.I]);	!LOAD PATTERN INTO CRAM
	CP(1);				!CLOCK CRAM BITS INTO REGISTER
	IF (RD_100 AND CRA_PE) NEQ 0	!DID CRA PARITY ERROR ASSERT?
	THEN
		BEGIN
		ERRS(2,2,ODD_PAR_TBL[.I]);	!NO, REPORT ERROR
		ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LC 0			- SET CRAM ADDR = 0
!*	DC \O000000000000000000000  - DEPOSIT TEST PATTERN INTO
!*				  BITS 0-35 OF CRAM.  THIS SHOULD YIELD
!*				  INVALID ODD PARITY.
!*RESPONSE:
!*	'CRA PARITY ERR' DID NOT ASSERT ON THE CSL BOARD.
!]ERROR 2
!]PARNET NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	IF .ERFLG NEQ 0
	THEN
		RETURN;
	END;

	END;
END
ELUDOM
 