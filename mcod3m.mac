	SUBTTL	CHANNEL BUS INTERFACE TEST - PART 2

DEFTST	MCODE3
	TEST	175,TEST MICROBUS INIT DURING CHANNEL MODE XFER
;*TEST THAT A MICROBUS INIT CLEARS "DATA REQ DLY" AND "SLVE REQ".
;*LOOP ENABLE IS SET FOR THIS TEST.

;*SET "CHANNEL MODE" THEN "HIGH SPEED".
;*SET "SRV IN" TO SET "DATA REQ DLY" AND "SLVE REQ".
;*DO A MICROBUS UNIT.
;*CHECK THAT "DATA REQ DLY" AND "SLVE REQ" ARE CLEARED.

	GOSUB	INITL			;DO A MICROBUS INIT
INIT1:	LDBR	LOOPEN+CHANL		;SET LLOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN+DIHISP+CHANL	;SET "HIGH SPEED"
	MOVB	CSR1
	GOSUB	DEVWR			;SET DATA TO DEVICE
	GOSUB	DPINIT			;DO A DATA PATH INIT
	GOSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	GOSUB	INITL			;DO A MICROBUS INIT
	GOSUB	RDRDLY			;READ "NOT DATA REQ DLY"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	INIT1,"DATA REQ DLY" DIDN'T CLEAR AFTER MICROBUS INIT
	GOSUB	RDSLRQ			;READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	INIT1,"SLVE REQ" DIDN'T CLEAR AFTER MICROBUS INIT
	REPEAT	TST

	TEST	176,TEST SCRATCH PAD (SP) ADDRESS COUNTER
;*VERIFY THAT THE SP ADR COUNTER DECREMENTS CORRECTLY WHEN
;*	(1) REGISTER 10 (SP DATA) IS LOADED, OR
;*	(2) A "CLK BOR" PULSE IS GENERATED.
;*SP ENABLE AND CHANNEL MODE ARE SET FOR THESE TESTS.

;*LOAD SP ADDR WITH TEST DATA.
;*PERFORM A LOAD TO REG 10.
;*CHECK THAT SP ADDR IS DECREMENTED.
;*REPEAT FOR TEST DATA (17-0).
;*LOOP ENABLE IS NOT SET FOR THIS TEST.

	LDBR	SPEN+CHANL		;SET SP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	17			;SET TEST DATA AND LOOP CNT -1
	MOVB	AC1
	LDBR	16			;SET EXPECTED DATA
	MOVB	AC2
SPADLP:	MOV	AC1,BR
	MOVB	SPADR			;LOAD TEST DATA
	MOVB	SPDALO			;LOAD REG 10
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ DEC'D SP ADDR.
	LDBR	17			;SETUP MASK FOR SP ADDR BITS
	LANDBR	AC0			;ISOLATE SP ADDR BITS
	LANDB	AC2,MEM			;PUT MASKED EXPECTED DATA INTO MEMORY
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF DEC'D DATA OKAY
	ERRORM	SPADLP,SP ADDR COUNTER DIDN'T DECREMENT CORRECTLY,
DIAG LOADED SP ADDR WITH "CORRECT"+1 THEN LOADED REG 10
	DECR	AC2			;DEC CORRECT DATA
	DECR	AC1			;DEC TEST DATA AND LOOP CNT
	JMPZ	.+2			;JUMP IF DONE
	JMP	SPADLP			;ELSE, CONTINUE

;*LOAD SP ADDR WITH TEST DATA.
;*GENERATE A "CLK BOR" PULSE BY PULSING "DATA REQ".
;*CHECK THAT SP ADDR IS DECREMENTED.
;*LOOP ENABLE IS SET FOR THIS TEST.

SPAD1:	LDBR	SPEN+LOOPEN+CHANL	;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	10			;LOAD SP ADDR WITH TEST DATA
	MOVB	SPADR
	LDBR	SRVINL			;SET "SRV IN" TO GEN "DATA REQ"
	MOVB	TOR1
	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ DEC'D SP ADDR.
	LDMEM	7			;SETUP CORRECT DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF DEC'D DATA OKAY
	ERRORM	SPAD1, SP ADDR COUNTER DIDN'T DECREMENT CORRECTLY,
DIAG LOAD SP ADDR WITH 10 THEN TOGGLED "DATA REQ"
;*CLEAR "SP EN".
;*DO A LOAD TO REG 10.
;*CHECK THAT SP ADDR COUNTER DID NOT DECREMENT.

SPAD2:	LDBR	CHANL			;CLEAR "SP ENABLE"
	MOVB	CSR1
	LDMEM	17			;LOAD SP ADDR
	MOVMEM	SPADR
	MOVB	SPDALO			;WRITE REG 10 TO CLK SP ADDR CTR
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ SP ADDR BITS
	LANDMR	AC0			;ISOLATE THEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF SP ADDR DIDN'T DEC
	ERROR	SPAD2,SP ADDR COUNTER DECREMENTED WITH "SP EN" CLEARED
	REPEAT	TST

	TEST	177,TEST BORLO AND BUS0 PARITY NETWORKS
;*TEST THE PROPER GENERATION OF BORLO PARITY AND THE PROPER DETECTION
;*OF BUS0 PARITY.
;*LOOP ENABLE IS SET FOR THIS TEST.
;*THE DATA PATTERNS USED WERE SPECIFICALLY DESIGNED TO TEST THE 74S280 CHIP.

;*CLEAR "EVEN PAR".
;*LOAD BORLO WITH AN EVEN PARITY DATA PATTERN.
;*CHECK THAT "BOR P0" IS NOT SET.
;*CHECK THAT "BUS0 ODD PAR" IS SET.
;*REPEAT FOR 4 DIFFERENT PATTERNS.

	LDMAR	0			;CLEAR MAR
	LDMEM	1			;SET ADDITIONAL PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDBR	LOOPEN+EVPAR		;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	3			;SET LOOP CNT MINUS 1
	MOVB	AC1
	LDMAR	EPATS			;SET MAR TO DATA PATTERN ADDR.
PARLP1:	MOVMEM	BORLO			;LOAD DATA PATTERN
	GOSUB	SETDAT			;GO SETUP PRINT DATA
	GOSUB	RDBRP0			;READ "BOR P0"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	PARLP1,<"BOR P0" SET WITH "EVEN PAR" CLEARED AND BORLO
LOADED WITH EVEN PARITY DATA>,,PNT
	GOSUB	RDB0OD			;READ "BUS0 ODD PAR"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	PARLP1,"BUS0 ODD PAR" DID NOT SET,
DIAG LOOPED EVEN PARITY BORLO DATA INTO CBI BITS WITH "BOR P0" CLEARED,PNT
	DECR	AC1,I			;DEC LOOP CNT AND INC PATTERN ADDR.
	JMPZ	.+2			;JUMP IF DONE
	JMP	PARLP1			;ELSE, CONTINUE

;*SET "EVEN PAR".
;*LOAD BORLO WITH AN EVEN PARITY DATA PATTERN.
;*CHECK THAT "BOR P0" IS SET.
;*CHECK THAT "BUS0 ODD PAR" IS NOT SET.
;*REPEAT FOR 4 DIFFERENT PATTERNS.

	LDBR	LOOPEN			;SET "EVEN PAR"
	MOVB	CSR1
	LDBR	3			;SET LOOP CNT MINUS 1
	MOVB	AC1
	LDMAR	OPATS			;SET MAR TO DATA PATTERN ADDR.
PARLP2:	MOVMEM	BORLO			;LOAD DATA PATTERN
	GOSUB	SETDAT			;GO SETUP PRINT DATA
	GOSUB	RDBRP0			;READ "BOR P0"
	JMPB0	.+2			;JUMP IF SET,SHOULD BE
	ERROR	PARLP2,<"BOR P0" DIDN'T SET WITH "EVEN PAR" SET AND BORLO
LOADED WITH EVEN PARITY DATA>,,PNT
	GOSUB	RDB0OD			;READ "BUS0 ODD PAR"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	PARLP2,"BUS0 ODD PAR" SET WHEN IT SHOULDN'T HAVE,
DIAG LOOPED EVEN PARITY BORLO DATA INTO CBI BITS WITH "BOR P0" SET,PNT
	DECR	AC1,I			;DEC LOOP CNT AND INC PATTERN ADDR.
	JMPZ	.+2			;JUMP IF DONE
	JMP	PARLP2			;ELSE, CONTINUE
	REPEAT	TST
	TEST	178,TEST "BUS0 PE FLAG"
;*TEST THAT "BUS0 PE FLAG" IS SET WHEN "BUS0 ODD PAR" IS CLEARED AND
;*	(1) REG 7 IS READ, OR
;*	(2) "CHK BUS IN PAR" IS GENERATED.
;*VERIFY THAT IT STAYS SET AND IS CLEARED ONLY BY A MICROBUS INIT OR
;*WRITING BIT 1 OF REG 0.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "EVEN PAR", THIS CAUSES "BUS0 ODD PAR" TO CLEAR
;*READ REG 7.
;*CHECK THAT "BUS0 PE FLAG" IS SET.

	LDBR	CLRFLG			;CLEAR FLAGS
	MOVB	CSR0
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	DATI	CBILO			;READ REG 7
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "BUS0 PE FLAG"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"BUS0 PE FLAG" DIDN'T SET,
DIAG CLEARED "BUS0 ODD PAR" THEN READ REG 7
;*CHECK THAT IT CAUSES AN INTERRUPT.

	JMPI	ZRTN			;JUMP IF INTERRUPT OCCUR
	JMPZ	.+2			;JUMP IF INTERRUPT JUMP TAKEN
	ERROR	TST,"BUS0 PE FLAG" DIDN'T CAUSE AN INTERRUPT
;*SET "EVEN PAR" TO SET "BUS0 ODD PAR".
;*READ REG 7.
;*CHECK THAT "BUS0 PE FLAG" STAYED SET.

	LDBR	LOOPEN+EVPAR		;SET "EVEN PAR"
	MOVB	CSR1
	DATI	CBILO			;READ REG 7
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "BUS0 PE FLAG"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT STAYED SET
	ERROR	TST,"BUS0 PE FLAG" DIDN'T STAY SET,
DIAG SET "BUS0 PE FLAG" THEN SET "BUS0 ODD PAR" AND READ REG 7

;*DO A MICROBUS INIT.
;*CHECK THAT "BUS0 PE FLAG" CLEARS.

B0PE1:	GOSUB	INITL			;DO A MICROBUS INIT
	DATI	CSR0,BR			;READ "BUS0 PE FLAG"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY.
	ERROR	TST,"BUS0 PE FLAG" DIDN'T CLEAR AFTER MICROBUS INIT
;*CLEAR "EVEN PAR" AND "DATA TO DEV".
;*SET "CHANNEL MODE" AND "HIGH SPEED".
;*SET "SRV IN" TO GENERATE "CHK BUS IN PAR".
;*CHECK THAT "BUS0 PE FLAG" IS SET.

B0PE2:	LDBR	LOOPEN+CHANL		;CLEAR "EVEN PAR" AND SET "CHANNEL MODE"
	MOVB	CSR1
	LDBR	LOOPEN+CHANL+DIHISP	;SET "HIGH SPEED"
	MOVB	CSR1
	GOSUB	DEVRD			;CLEAR "DATA TO DEV"
	LDBR	SRVINL			;SET AND CLEAR "SRV IN"
	MOVB	TOR1
	LDBR	0
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "BUS0 PE FLAG"
	SHR				;RIGHT ADJUST IT.
	JMPB0	.+2			;JUMP IF SET
	ERROR	B0PE1,"BUS0 PE FLAG" DIDN'T SET,
DIAG CLEARED "BUS0 ODD PAR" THEN SET "DATA REQ" WITH "DATA TO DEVICE" CLEARED
;*WRITE BIT 1 OF REG 0
;*CHECK THAT "BUS0 PE FLAG" CLEARS.

B0PE3:	LDBR	CLRFLG			;ATTEMPT TO CLEAR "BUS0 PE FLAG"
	MOVB	CSR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "BUS0 PE FLAG"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	B0PE2,"BUS0 PE FLAG" DIDN'T CLEAR WHEN BIT 1 OF REG 0 WAS WRITTEN
;*SET "DATA TO DEVICE" TO INHIBIT "CHK BUS IN PAR".
;*SET "SRV IN".
;*CHECK THAT "BUS0 PE FLAG" DOES NOT SET.

	GOSUB	DEVWR			;SET "DATA TO DEV"
	LDBR	SRVINL			;SET AND CLEAR "SRV IN"
	MOVB	TOR1
	LDBR	0
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "BUS0 PE FLAG"
	SHR				;RIGHT ADJUST IT.
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	B0PE3,"CHK BUS IN PAR" SET WITH "DATA TO DEVICE" SET,
DIAG SET "SRV IN" AND "BUS0 PE FLAG" GOT SET
	REPEAT	TST


	TEST	179,TEST "DP PE" AND "DP PE FLAG"
;*TEST THE "DP PE" PARITY DETECTING NETWORK BY CLOCKING DATA PATTERNS
;*FROM THE BORLO REG INTO THE DRLO REG AND ONTO THE SLAVE DATA LINES.
;*ALSO, CHECK THAT "DP PE FLAG" SETS WHEN "DP PE" IS SET AND
;*"SLVE REQ" IS CLEARED.  VERIFY THAT IT STAYS SET AND IS CLEARED
;*BY WRITING BIT 1 OF REG 0.

;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "DATA TO DEV" AND "EVEN PAR".
;*SET CHANNEL MODE AND HIGH SPEED.
;*LOAD ALL 1'S INTO BORLO.
;*SET "SRV IN" TO GENERATE "CLK DR BYTE 0" PULSE WHICH
;*CLOCKS CBI (ALL ZERO INCLUDING PARITY) INTO THE DRLO REG.
;*CHECK THAT "DP PE" IS SET.

	GOSUB	INITL			;DO A MICROBUS INIT
	LDMEM	2			;SETUP ADDITIONAL PNT ROUTINE NUMBER
	GOSUB	SETPNT
	GOSUB	DEVRD			;CLEAR "DATA TO DEV"
	LDBR	-1			;LOAD ALL 1'S INTO BORLO, CAUSES
	MOVB	BORLO			;CBI TO BE ALL ZEROS, INCLUDING PARITY
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN+DIHISP+CHANL	;SET "HIGH SPEED"
	MOVB	CSR1
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	GOSUB	RDDPPE			;READ "DP PE"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"DP PE" DIDN'T SET,
DIAG CLOCKED ALL ZEROS (INCLUDING PARITY) INTO DRLO WITH "DATA TO DEV" CLEARED
;*CLEAR "SLVE REQ".
;*CHECK THE "DP PE FLAG" SETS

	MOVB	CLSLRQ			;CLEAR "SLVE REQ"
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "DP PE FLAG"
	SHR				;MOVE IT TO BIT 4
	JMPB4	.+2			;JMP IF SET, SHOULD BE
	ERROR	TST,"DP PE FLAG" DIDN'T SET,
DIAG SET "DP PE" THEN SET AND CLEARED "SLVE REQ"
;*CHECK THAT "DP PE FLAG" CAUSED AN INTERRUPT.

	JMPI	ZRTN			;JUMP IF INTERRUPT OCCURRED
	JMPZ	.+2			;JUMP IF INTERRUPT JUMP WAS TAKEN
	ERROR	TST,"DP PE FLAG" DID NOT CAUSE INTERRUPT
;*CLEAR "SRV IN".
;*SET "EVEN PAR".
;*LOAD BORLO WITH ALL 0'S.
;*SET "SRV IN" TO GENERATE "CLK DR BYTE 0" PULSE WHICH
;*CLOCKS CBI (ALL 1'S INCLUDING PARITY) INTO DR REG.
;*CHECK THAT "DP PE" IS CLEARED.

	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	LDBR	LOOPEN+DIHISP+CHANL+EVPAR	;SET EV PAR
	MOVB	CSR1
	LDBR	0			;LOAD ALL 0'S INTO BORLO
	MOVB	BORLO
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	GOSUB	RDDPPE			;READ "DP PE"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DP PE" SET WHEN IT SHOULDN'T HAVE,
DIAG CLOCKED ALL ONES (INCLUDING PARITY) INTO DRLO WITH "DATA TO DEV" CLEARED
;*CLEAR "SLVE REQ".
;*CHECK THAT "DP PE FLAG" STAYS SET.

	MOVB	CLSLRQ			;CLEAR "SLVE REQ"
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "DP PE FLAG"
	SHR				;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF STILL SET
	ERROR	TST,"DP PE FLAG" DIDN'T STAY SET,
DIAG SET "DP PE FLAG" THEN CLEARED "DP PE" AND SET AND CLEARED "SLVE REQ"
;*WRITE BIT 1 OF REG 0.
;*CHECK THAT "DP PE FLAG" CLEARS.


	LDBR	CLRFLG			;WRITE BIT 1 OF REG 0
	MOVB	CSR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "DP PE FLAG"
	SHR				;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DP PE FLAG" DIDN'T CLEAR WHEN BIT 1 OF REG 0 WAS WRITTEN
;*CLOCK FLOATING ONES AND FLOATING ZEROS PATTERNS INTO DR.
;*CHECK THAT "DP PE" DOES NOT SET.

	LDBR	^D15			;SET LOOP CNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR FOR FLOAT PATTERNS
DPPELP:	MOVMEM	BORLO			;LOAD BORLO WITH PATTERN
	MOVB	CLKDRL			;CLOCK DRLO
	NOP				;DELAY BEFORE DOING DATI
	DATI	DRLO,AC0		;READ DRLO DATA FOR PRINTOUT
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC0,BR			;STORE DRLO DATA
	MOVB	MPGP12
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	GOSUB	RDDPPE			;READ "DP PE"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	DPPELP,"DP PE" SET WHEN IT SHOULDN'T HAVE,
DIAG CLOCKED ODD PARITY DATA INTO DRLO WITH "DATA TO DEV" CLEARED,PNT
	DECR	AC1,I			;DEC LOOP CNT AND INC PAT ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	DPPELP			;ELSE, CONTINUE

	GOSUB	INITL
	REPEAT	TST
	TEST	180,TEST WRITING AND READING SP RAM (REG 10)
;*TEST WRITING AND READING EACH SP RAM LOCATION.
;*WRITE AND READ ONES, ZEROS, FLOATING ZEROS AND FLOATING ONES PATTERNS.

;*LOAD THE SP ADDR.
;*WRITE THE RAM LOCATION WITH THE PATTERN.
;*RELOAD THE SP ADDR.
;*READ THE RAM CONTENTS BACK COMPLEMENTED IN REG 7 BY SETTING "SRV IN".
;*THIS PULSES "DATA REQ" WHICH IN TURN GENERATES "CLK BOR".
;*LOOP ENABLE, SP ENABLE, AND CHANNEL MODE ARE SET.

	LDMAR	0			;CLEAR MAR
	LDMEM	3			;SETUP ADDITIONAL PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDBR	SPEN+CHANL+LOOPEN	;SET SP EN AND LOOP ENABLE
	MOVB	CSR1			;AND CHANNEL MODE
	LDBR	^D15			;SETUP OUTER LOOP COUNT FOR ADDRESSES
	MOVB	AC1
NXTLOC:	LDBR	^D17			;SETUP INNER LOOP COUNT FOR PATTERNS
	MOVB	AC2
	LDMAR	PATS			;SET MAR FOR FIRST PATTERN
FLT10:	MOV	AC1,BR			;WRITE RAM ADDRESS
	MOVB	SPADR
	LDBR	0			;SETUP COMPLEMENT OF PATTERN IN
	MOVB	AC3
	LORCM	AC3,BR			;BR THEN
	MOVB	SPDALO			;WRITE PATTERN INTO RAM
	MOV	AC1,BR			;RESTORE SP ADDR
	MOVB	SPADR
	LDBR	SRVINL			;SET "SRV IN".  THIS SETS
	MOVB	TOR1			;"DATA REQ",WHICH CLOCKS RAM DATA TO BORLO
	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CBILO,AC0		;READ COMPLEMENTED RAM DATA FROM REG 10
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC1,BR			;PUT RAM ADDR IN BR AND
	MOVB	MPGP12			;STORE IT FOR PRINTOUT
	MOVMEM	MPGP14			;STORE CORRECT FOR PRINTOUT
	MOV	AC0,BR			;PUT ACTUAL IN BR AND
	MOVB	MPGP15			;STORE IT FOR PRINTOUT
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	OSM	AC0			;COMPARE WITH EXPECTED PATTERN
	JMPZ	.+2			;JUMP IF CORRECT
	ERROR	FLT10,DATA PATTERN ERROR,,PNT
	DECR	AC2,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF ALL DONE WITH THIS LOC
	JMP	FLT10			;ELSE, CONTINUE
	DECR	AC1			;DEC OUTER LOOP COUNT
	JMPZ	.+2			;JUMP IF DONE WITH RAM
	JMP	NXTLOC			;ELSE, CONTINUE WITH NEXT LOC

	REPEAT	TST
	TEST	181,TEST SP RAM ADDRESSING
;*WRITE ZEROS TO A TEST ADDRESS.
;*WRITE ONES TO A DIFFERENT "OTHER" ADDRESS.
;*READ BACK THE COMPLEMENTED CONTENTS OF THE TEST ADDRESS AND CHECK THAT
;*IT IS ALL ONES (ACTUAL CONTENTS STILL ZEROS).
;*LOOP ENABLE AND "SP EN" ARE SET FOR THIS TEST.

;*THE SET OF "TEST" AND "OTHER" ADDRESSES IS (0,1,2,4,10).

	LDMAR	0			;CLEAR MAR
	LDMEM	4			;SETUP ADDITIONAL PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDBR	SPEN+CHANL+LOOPEN	;SET LOOP ENABLE, SP EN AND
	MOVB	CSR1			;CHAN MODE
	LDBR	RAMADR-1		;SET "TEST ADDR" TABLE ADDR - 1
	MOVB	AC3			;SAVE IT IN AC3
RMADRO:	INCR	AC3			;INC "TEST ADDR" ADDR
	MOV	AC3,MAR			;LET MEMORY POINT TO TEST ADDR
	MOVMEM	AC1			;GET TEST ADDR
	JMPZ	RMDONE			;ALL ONES ADDR MARKS END OF TABLE
	LDBR	RAMADR			;SETUP "OTHER ADDR" ADDR
	MOVB	AC2
RMADRI:	MOV	AC2,MAR			;LET MEMORY POINT TO OTHER ADDR
	OSM	AC1			;CHECK IF OTHER ADDR = TEST ADDR
	JMPZ	.+2			;JUMP IF YES
	JMP	.+2			;ELSE, DON'T INC ADDR
	INCR	AC2,I			;INC 'OTHER ADDR' ADDR
	MOVMEM				;CHECK FOR END OF TABLE
	JMPZ	RMADRO			;JUMP IF AT END
	MOV	AC1,BR			;PUT TEST ADDR IN BR
	MOVB	SPADR			;SET SP ADDR TO TEST ADDR
	LDBR	0			;WRITE ZEROS TO TEST ADDR LOC
	MOVB	SPDALO
	MOVMEM	SPADR			;SET SP ADDR TO OTHER ADDR
	LDBR	-1			;WRITE ONES TO OTHER ADDR
	MOVB	SPDALO
	MOV	AC1,BR			;GET TEST ADDR AGAIN
	MOVB	SPADR			;SET SP ADDR TO TEST ADDR
	LDBR	SRVINL			;SET "SRV IN" TO
	MOVB	TOR1			;READ DATA FROM RAM
	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CBILO,AC0		;READ COMPLEMENTED LOOPED BACK RAM DATA
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP13			;STORE "OTHER ADDR" FOR PRINTOUT
	MOV	AC1,BR			;STORE "TEST ADDR" FOR PRINTOUT
	MOVB	MPGP12
	MOV	AC0,BR			;STORE CHANGED DATA FOR PRINTOUT
	MOVB	MPGP14
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	MOV	AC0			;TEST FOR ALL ONES DATA
	JMPZ	.+2			;JUMP IF TEST ADDR UNCHANGED
	ERROR	RMADRI,SP RAM ADDRESSING ERROR,,PNT
	INCR	AC2			;INC "OTHER ADDR" ADDR
	JMP	RMADRI

RMDONE:	REPEAT	TST
	TEST	182,TEST "CLK BOR" GENERATION
;*CHECK THAT "CLK BOR" IS NOT GENERATED IF "SP EN" IS CLEARED.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*LOAD ALL ZEROS INTO BORLO
;*LOAD SP RAM WITH ALL ONES.
;*SET "SRV IN" TO GENERATE "DATA REQ".
;*CHECK THAT BORLO STILL CONTAINS ZEROS (USING CBI LOOPING).

	LDBR	0			;LOAD ALL ZEROS INTO BORLO
	MOVB CSR1			;CLEAR STATUS REG
	MOVB	BORLO
	MOVB	SPADR			;SET SP ADDR TO ZERO
	LDMEM	-1			;LOAD SP RAM WITH ALL ONES
	MOVMEM	SPDALO
	LDBR	LOOPEN+CHANL		;SET LOOPEN ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN+CHANL+DIHISP	;SET HIGH SPEED
	MOVB	CSR1
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CBILO,AC0		;READ COMPLEMENTED BORLO
	OSM	AC0			;CHECK IF CHANGED
	JMPZ	.+2			;JUMP IF NOT
	ERRORM	TST,"CLK BOR" WAS GENERATED WITH "SP EN" CLEARED,
BORLO CONTENTS CHANGED WHEN DIAG GENERATED "DATA REQ"
	REPEAT	TST
	TEST	183,TEST 370 MODE CONTROL UNIT INITIALIZATION
;*SIMULATE A 370 MODE CONTROL UNIT INITIALIZATION SEQUENCE WITH
;*"DATA TO DEVICE" CLEARED.  CHECK THAT THE CORRECT SIGNALS ARE GENERATED
;*AT THE APPROPRIATE TIMES.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "DATA TO DEVICE".
;*LOAD THE DR REG 0 WITH ZEROS.
;*LOAD THE BORLO REG WITH A DIFFERENT PATTERN.
;*SET HIGH SPEED.
;*CHECK THAT "CU INIT", "DIS SLVE REQ", "ST DATA REQ", "DATA REQ DLY",
;*"DR READY", AND "TO DAT OUT" ARE ALL SET.
;*CHECK THAT "SLVE REQ" IS NOT SET.

	GOSUB	INITL			;DO A MICROBUS INIT
	GOSUB	DEVRD			;CLEAR "DATA TO DEV"
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	LOOPEN+DIHISP		;SET HIGH SPEED
	MOVB	CSR1
	GOSUB	LOADDR			;LOAD DRLO WITH ZEROS
	GOSUB	DEVWR			;SET DATA TO DEVICE
	GOSUB	DPINIT			;DO A DATA PATH INIT
	GOSUB	DEVRD			;CLEAR DATA TO DEVICE
	GOSUB	RDCUIN			;GO READ "CU INIT"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"CU INIT" DID NOT SET,
<DIAG CLEARED "CHANNEL MODE", "DATA TO DEV", AND "CU RUN">
	GOSUB	RDDSRQ			;GO READ "NOT DIS SLVE REQ"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DIS SLVE REQ" DID NOT SET,
DIAG CLEARED "CHANNEL MODE" THEN SET "DIAG HIGH SPEED"
	GOSUB	RDSDRQ			;GO READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"ST DATA REQ" DID NOT SET,
DIAG CLEARED "CHANNEL MODE" THEN SET "DIAG HIGH SPEED"
	GOSUB	RDRDLY			;GO READ "NOT DATA REQ DLY"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"DATA REQ DLY" DID NOT SET,
DIAG CLEARED "CHANNEL MODE" THEN SET "DIAG HIGH SPEED"
	GOSUB	RDRRDY			;GO READ "DR READY"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"DR READY" DID NOT SET,
DIAG SET "DATA REQ" WITH "DIS SLVE REQ" ASSERTED
	GOSUB	RDSLRQ			;GO READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF IT SET,SHOULDN'T HAVE
	JMP	.+2			;ELSE,OKAY
	ERROR	TST,"SLVE REQ" SET WITH "DIS SLVE REQ" SET,
DIAG CLEARED "CHANNEL MODE" THEN SET "DIAG HIGH SPEED"
	DATI	TOR1,BR			;READ "TO DAT OUT"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"TO DAT OUT" DID NOT SET,
DIAG CLEARED "CHANNEL MODE" THEN SET "DIAG HIGH SPEED"
;*SET "DAT IN".
;*CHECK THAT "CU RUN" AND "SLVE REQ" ARE SET.
;*CHECK THAT "TO DAT OUT", "CU INIT", "DIS SLVE REQ", AND "DR READY" ARE CLEARED.
;*ALSO, CHECK THAT THE DR REG 0 GOT CLOCKED ("CLK DR BYTE 0" WAS GENERATED).

	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	GOSUB	RDCUIN			;GO READ "CU INIT"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"CU INIT" DID NOT CLEAR,
DIAG SET "DIAG HIGH SPEED" THEN SET "DAT IN"
	DATI	SPADR,AC0		;READ "CU RUN"
	SHL	AC0,BR			;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF IT SET OKAY
	ERROR	TST,"CU RUN" DID NOT SET,
DIAG SET "DIAG HIGH SPEED" THEN SET "DAT IN"
	GOSUB	RDDSRQ			;GO READ "NOT DIS SLVE REQ"
	JMPB0	.+2			;JUMP IF IT SET,
	ERROR	TST,"DIS SLVE REQ" DID NOT CLEAR,
DIAG SET "DIS SLVE REQ" THEN SET "CU RUN"
	GOSUB	RDRRDY			;GO READ "DR READY"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DR READY" DID NOT CLEAR,
DIAG SET "DIAG HIGH SPEED" THEN SET "DAT IN"
	GOSUB	RDSLRQ			;GO READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF IT SET,SHOULD HAVE
	ERROR	TST,"SLVE REQ" DIDN'T SET,
DIAG SET "DIAG HIGH SPEED" THEN SET "DAT IN"
	DATI	TOR1,BR			;READ "TO DAT OUT"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"TO DAT OUT" DID NOT CLEAR,
DIAG SET "DIAG HIGH SPEED" THEN SET "DAT IN"
	DATI	DRLO,AC0		;READ DR REG 0
	JMPZ	.+2			;JUMP IF IT GOT CLOCKED
	ERROR	TST,"DRLO" DIDN'T GET CLOCKED,
DIAG SET "DIAG HIGH SPEED" THEN SET "DAT IN"
;*CLEAR "DAT IN" AND SET "DIAG SLVE ACK".
;*CHECK THAT "TO SRV OUT" GETS SET.

	LDBR	0			;CLEAR "DAT IN"
	MOVB	TOR1
	LDBR	DISACK			;SET "DIAG SLVE ACK"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF IT SET OKAY
	ERROR	TST,"TO SRV OUT" DID NOT SET,
<DIAG SET "DIAG HIGH SPEED",
SET AND CLEARED "DAT IN",
THEN SET "DIAG SLVE ACK">
;*SET "SRV IN".
;*CHECK THAT "TO SRV OUT" IS CLEARED.

	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"TO SRV OUT" DID NOT CLEAR,
DIAG SET "TO SRV OUT" THEN SET "SRV IN"
;*CLEAR "SRV IN" AND SET "DIAG SLVE ACK".
;*CHECK THAT "TO DAT OUT" SETS.

	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	LDBR	DISACK			;SET "DIAG SLVE ACK"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO DAT OUT"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET OKAY
	ERROR	TST,"TO DAT OUT" DID NOT SET,
<DIAG SET "DIAG HIGH SPEED",
SET AND CLEARED "DAT IN",
SET "DIAG SLVE ACK",
SET AND CLEARED "SRV IN",
THEN SET "DIAG SLVE ACK" AGAIN>
	REPEAT	TST
	TEST	184,TEST 360 MODE CONTROL UNIT INITIALIZATION
;*SIMULATE A 360 MODE CONTROL UNIT INITIALIZATION SEQUENCE WITH
;*"DATA TO DEVICE" SET.  CHECK THAT THE CORRECT SIGNALS ARE GENERATED
;*AT THE APPROPRIATE TIMES.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*SET "DATA TO DEVICE".
;*SET "360 MODE" AND HIGH SPEED.
;*CHECK THAT "ST DATA REQ" IS SET.
;*AND THAT "DIS SLVE REQ" IS CLEARED.

	GOSUB	INITL			;DO A MICROBUS INIT
	GOSUB	DEVWR			;SET "DATA TO DEVICE"
	GOSUB	DPINIT			;DO A DATA PATH INIT
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	LOOPEN+MOD360+DIHISP	;SET LOOP ENABLE, 360 MODE, AND
	MOVB	CSR1			;HIGH SPEED
	GOSUB	RDDSRQ			;GO READ "NOT DIS SLVE REQ"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"DIS SLVE REQ" SET WITH "DATA TO DEV" SET
	GOSUB	RDSDRQ			;GO READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"ST DATA REQ" DID NOT SET,
<DIAG SET "360 MODE" AND CLEARED "CHANNEL MODE" THEN
SET "DIAG HIGH SPEED">
;*SET "DIAG SLVE ACK".
;*CHECK THAT "TO SRV OUT" IS SET.

	LDBR	DISACK			;SET "DIAG SLVE ACK"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"TO SRV OUT" DID NOT SET,
<DIAG SET "360 MODE" AND CLEARED "CHANNEL MODE" THEN
SET "DIAG HIGH SPEED" AND "DIAG SLVE ACK">
;*SET AND CLEAR "SRV IN".
;*SET "DIAG SLVE ACK".
;*CHECK THAT "TO SRV OUT" IS SET AGAIN.

	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	LDBR	DISACK			;SET "DIAG SLVE ACK"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"TO SRV OUT" DID NOT SET A 2ND TIME,
<DIAG SET "DIAG HIGH SPEED",
SET "DIAG SLVE ACK",
SET AND CLEARED "SRV IN",
THEN SET "DIAG SLVE ACK" AGAIN>
	REPEAT	TST
	JUMP	NXTBNK			;JUMP TO NEXT BANK OF CRAM
	.LOC	2000
NXTBNK:
	TEST	185,TEST CONTROL UNIT TERMINATION
;*SIMULATE A CONTROL UNIT TERMINATION SEQUENCE TO CHECK THAT SETTING
;*"STA IN" AND "DR READY" CLEARS "CU RUN".
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "DATA TO DEVICE".
;*SET HIGH HIGH SPEED.
;*SET AND CLEAR "DAT IN" TO SET "CU RUN".
;*SET "DIAG SLVE ACK" TO SET "DR READY".
;*SET "STA IN".
;*CHECK THAT "CU RUN" IS CLEARED.

	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	DEVRD			;CLEAR "DATA TO DEVICE"
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	LOOPEN+DIHISP		;SET LOOP ENABLE AND HIGH SPEED
	MOVB	CSR1
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	LDBR	0			;CLEAR "DAT IN"
	MOVB	TOR1
	LDBR	DISACK			;SET "DIAG SLVE ACK"
	MOVB	TOR1
	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ "CU RUN"
	SHL	AC0,BR			;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE,OKAY
	ERROR	TST,"CU RUN" DID NOT CLEAR,
DIAG SET "CU RUN" THEN SET "DR READY" AND "STA IN"
;*PERFORM ANOTHER SEQUENCE TO TEST THAT CLEARING "DATA REQ DLY"
;*WITH "SLVE END XFER" SET CLEARS "CU RUN" BUT DOES NOT SET "END XFER".
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "DATA TO DEVICE".
;*SET HIGH SPEED.
;*SET AND CLEAR "DAT IN".
;*SET "STA IN" (SETS "SLVE END XFER").
;*SET "SRV IN" (CLEARS "DATA REQ DLY").
;*CHECK THAT "CU RUN" AND "END XFER" ARE CLEARED.

CUTRM1:	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	DEVRD			;CLEAR "DATA TO DEVICE"
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	LOOPEN+DIHISP		;SET LOOP ENABLE AND HIGH SPEED
	MOVB	CSR1
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	LDBR	0			;CLEAR "DAT IN"
	MOVB	TOR1
	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ "CU RUN"
	SHL	AC0,BR			;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE,OKAY
	ERROR	CUTRM1,"CU RUN" DID NOT CLEAR,
<DIAG SET "CU RUN" THEN SET "SLVE END XFER" AND
CLEARED "DATA REQ DLY">
	DATI	CSR0,BR			;READ "END XFER"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	CUTRM1,"END XFER" SET WITH CHAN MODE CLEARED,
DIAG SET "SLVE END XFER" THEN CLEARED "DATA REQ DLY"
	REPEAT	TST
	TEST	186,TEST MICROBUS INIT DURING CONTROL UNIT INITIALIZATION
;*SET "CU INIT" THEN DO A MICROBUS INIT.
;*CHECK THAT "CU INIT" GETS CLEARED.

	JMPSUB	INITL			;DO A MICROBUS INIT
CUINT1:	LDBR	DIHISP			;SET HIGH SPEED
	MOVB	CSR1
	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	RDCUIN			;GO READ "CU INIT"
	JMPB0	.+2			;JUMP IF STIIL SET
	JMP	.+2			;ELSE, OKAY
	ERROR	CUINT1,"CU INIT" DIDN'T CLEAR AFTER MICROBUS INIT
;*SET "CU RUN" THEN DO A MICROBUS INIT.
;*CHECK THAT "CU RUN" CLEARS.

CUINT2:	LDBR	LOOPEN+DIHISP		;SET LOOP ENABLE AND HIGH SPEED
	MOVB	CSR1
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	JMPSUB	INITL			;DO A MICROBUS INIT
	DATI	SPADR,AC0		;READ "CU RUN"
	SHL	AC0,BR			;MOVE IT TO BIT 4
	JMPB0	.+2			;JUMP IF STILL SET
	JMP	.+2			;ELSE, OKAY
	ERROR	CUINT2,"CU RUN" DIDN'T CLEAR AFTER A MICROBUS INIT
	REPEAT	TST
	TEST	187,TEST "EN SRV/DAT OUT"
;*TEST THAT "EN SRV/DAT OUT" SETS WHEN AND ONLY WHEN "END XFER" AND
;*"SUP DAT" ARE CLEARED.  THIS IMPLICITLY TESTS THAT "SUP DAT" SETS
;*AND CLEARS CORRECTLY.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*DO A MICROBUS INIT.
;*CHECK THAT "EN SRV/DAT OUT" IS SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	JMPSUB	RDENSD			;GO READ "EN SRV/DAT OUT"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"EN SRV/DAT OUT" DID NOT SET AFTER A MICROBUS INIT
;*SET HIGH SPEED (SETS "CU INIT").
;*SET AND CLEAR "DAT IN" (SETS "CU RUN").
;*SET "DIAG SLVE ACK".
;*SET "REQ IN".
;*SET "SRV IN" (SETS "SUP DAT").
;*CHECK THAT "EN SRV/DAT OUT" CLEARS.

	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	LOOPEN+DIHISP		;SET LOOP ENABLE AND HIGH SPEED
	MOVB	CSR1
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	LDBR	DISACK			;CLEAR "DAT IN" AND SET "DIAG SLVE ACK"
	MOVB	TOR1
	LDBR	REQINL			;SET "REQ IN"
	MOVB	TOR1
	LDBR	REQINL+SRVINL		;SET "SRV IN"
	MOVB	TOR1
	JMPSUB	RDENSD			;GO READ "EN SRV/DAT OUT"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"EN SRV/DAT OUT" DIDN'T CLEAR,
DIAG SET "SUP DAT" BY CLEARING "DATA REQ DLY" WITH "REQ IN" SET
;*CLEAR "REQ IN" (CLEARS "SUP DAT").
;*CHECK THAT "EN SRV/DAT OUT" SETS.

	LDBR	SRVINL			;CLEAR "REQ IN"
	MOVB	TOR1
	JMPSUB	RDENSD			;READ "EN SRV/DAT OUT"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"EN SRV/DAT OUT" DIDN'T SET,
DIAG CLEARED "REQ IN" WITH "END XFER" CLEARED
;*CHECK THAT CLEARING "CU RUN" CLEARS "SUP DAT" AND SETS "EN SRV/DAT OUT".
;*SET "SUP DAT".
;*SET "DR READY" AND "STA IN" (CLEARS "CU RUN").
;*CHECK THAT "EN SRV/DAT OUT" IS SET.

ESDO1:	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	LOOPEN+DIHISP		;SET LOOP ENABLE AND HIGH SPEED
	MOVB	CSR1
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	LDBR	DISACK			;CLEAR "DAT IN" AND SET "DIAG SLVE ACK"
	MOVB	TOR1
	LDBR	REQINL			;SET "REQ IN"
	MOVB	TOR1
	LDBR	REQINL+SRVINL		;SET "SRV IN"
	MOVB	TOR1
	LDBR	DISACK+REQINL		;CLEAR "SRV IN" AND SET "DIAG SLVE ACK"
	MOVB	TOR1
	LDBR	STAINL			;SET "STA IN" TO CLEAR "CU RUN"
	MOVB	TOR0
	JMPSUB	RDENSD			;READ "EN SRV/DAT OUT"
	JMPB0	.+2			;JUMP IF SET
	ERROR	ESDO1,"EN SRV/DAT OUT" DIDN'T SET,
DIAG CLEARED "CU RUN" WITH "END XFER" CLEARED
;*CHECK THAT "EN SRV/DAT OUT" DOES NOT SET WHEN "END XFER" IS SET.
;*SET CHANNEL MODE AND HIGH SPEED.
;*SET "SRV IN".
;*SET "STA IN" (SETS "SLVE END XFER").

;*CLEAR "SRV IN" (CLEARS "DATA REQ DLY" AND SETS "END XFER").
;*CHECK THAT "EN SRV/DAT OUT" IS NOT SET.

ESDO2:	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN+CHANL+DIHISP	;SET HIGH SPEED
	MOVB	CSR1
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	JMPSUB	RDENSD			;GO READ "EN SRV/DAT OUT"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	ESDO2,"EN SRV/DAT OUT" SET WITH "END XFER" SET
	REPEAT	TST
	TEST	188,TEST "SYS RST"
;*TEST THAT "SYS RST" SETS WHEN AND ONLY WHEN "OPL IN" AND "REQ IN" ARE
;*CLEARED AND "CU RESET EN" IS SET.  CHECK THAT "SYS RST" CAUSES AN INTERRUPT AND
;*IS CLEARED BY SETTING CHAN MODE OR CLEARING "CU RESET EN".
;*LOOP ENABLE IS SET FOR THIS TEST.

;* DO A MICROBUS INIT.
;*SET LOOP ENABLE.
;*CHECK THAT "SYS RST" IS SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
SYRST1:	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	CURSEN			;SET "CU RESET EN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SYS RST"
	SHR				;RIGHT ADJUST IT
	SHR
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"SYS RST" DID NOT SET WITH "OPL IN" AND "REQ IN" CLEARED
;*CHECK THAT AN INTERRUPT OCCURRED.

	JMPI	ZRTNH			;JUMP IF INTERRUPT PRESENT
	JMPZ	.+2			;JUMP IF INTERRUPT JUMP WAS TAKEN
	ERROR	TST,"SYS RST" DID NOT CAUSE AN INTERRUPT
;*SET CHAN MODE.
;*SET "OPL IN" AND "REQ IN" TO PREVENT RESETTING.
;*CLEAR CHAN MODE TO ALLOW READING OF "SYS RST".
;*CHECK THAT "SYS RST" IS CLEARED.

	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	OPLINL			;SET "OPL IN"
	MOVB	TOR0
	LDBR	REQINL+CURSEN		;SET "REQ IN"
	MOVB	TOR1
	LDBR	LOOPEN			;CLEAR CHAN MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SYS RST"
	SHR				;RIGHT ADJUST IT
	SHR
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SYRST1,SETTING "CHAN MODE" DID NOT CLEAR "SYS RST"
;*SET "SYS RST" AGAIN.
;*CLEAR "CU RESET EN".
;*CHECK THAT "SYS RST" IS CLEARED.

SYRST2:	LDBR	CURSEN			;CLEAR "REQ IN"
	MOVB	TOR1
	LDBR	0			;CLEAR "OPL IN"
	MOVB	TOR0
	LDBR	0			;CLEAR "CU RESET EN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SYS RST"
	SHR				;RIGHT ADJUST IT
	SHR
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SYRST2,CLEARING "CU RESET EN" DIDN'T CLEAR "SYS RST"
;*CLEAR "REQ IN" AND SET "OPL IN".
;*SET AND CLEAR "CHANNEL MODE".
;*CHECK THAT "SYS RST" IS CLEARED.

	LDBR	CURSEN			;CLEAR "REQ IN"
	MOVB	TOR1
	LDBR	OPLINL			;SET "OPL IN"
	MOVB	TOR0
SYRST3:	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SYS RST"
	SHR				;RIGHT ADJUST IT
	SHR
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SYRST3,"SYS RST" SET WITH "OPL IN" SET,
DIAG SET "OPL IN" THEN SET AND CLEARED "CHANNEL MODE"
;*CLEAR "OPL IN" AND SET "REQ IN".
;*SET AND CLEAR CHANNEL MODE.
;*CHECK THAT "SYS RST" IS CLEARED.

	LDBR	0			;CLEAR	"OPL IN"
	MOVB	TOR0
	LDBR	REQINL+CURSEN		;SET "REQ IN"
	MOVB	TOR1
SYRST4:	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SYS RST"
	SHR				;RIGHT ADJUST IT
	SHR
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SYRST4,"SYS RST" SET WITH "REQ IN" SET,
DIAG SET "REQ IN" THEN SET AND CLEARED "CHANNEL MODE"
	REPEAT	TST
	TEST	189,TEST "SEL RST"
;*TEST THAT "SEL RST" SETS WHEN AND ONLY WHEN "REQ IN" AND
;*"OPL OUT" ARE SET AND "OPL IN" IS CLEARED.  CHECK THAT "SEL RST" CAUSES
;*AN INTERRUPT AND IS CLEARED BY DOING A MICROBUS INIT, SETTING CHAN MODE,
;*OR CLEARING "CU RESET EN".
;*LOOP ENABLE IS SET FOR THIS TEST.

;*DO A MICROBUS INIT.
;*SET LOOP ENABLE.
;*SET "OPL OUT" AND "REQ IN" AND "CU RESET EN".
;*CHECK THAT "SEL RST" IS SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
SLRST1:	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	OPLOUT+REQINL		;SET "OPL OUT" AND "REQ IN"
	MOVB	TOR1
	LDBR	OPLOUT+REQINL+CURSEN	;SET "CU RESET EN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SEL RST"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"SEL RST" DID NOT SET,
DIAG SET "OPL OUT" AND "REQ IN" AND CLEARED "OPL IN"
;*CHECK THAT AN INTERRUPT OCCURRED.

	JMPI	ZRTNH			;JUMP IF INTERRUPT PRESENT
	JMPZ	.+2			;JUMP IF INTERRUPT JUMP WAS TAKEN
	ERROR	TST,"SEL RST" DID NOT CAUSE AN INTERRUPT
;*DO A MICROBUS INIT.
;*CHECK THAT "SEL RST" IS CLEARED.

	JMPSUB	INITL			;DO A MICROBUS INIT
	DATI	SPADR,BR		;READ "SEL RST"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SLRST1,MICROBUS INIT DIDN'T CLEAR "SEL RST"
;*SET "SEL RST" AGAIN.
;*SET AND CLEAR CHAN MODE.
;*CHECK THAT "SEL RST" IS CLEARED.

SLRST2:	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	OPLOUT+REQINL+CURSEN	;SET "OPL OUT" AND "REQ IN"
	MOVB	TOR1
	LDBR	CURSEN			;CLEAR "OPL IN" AND "REQ IN"
	MOVB	TOR1
	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHAN MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SEL RST"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SLRST2,SETTING "CHAN MODE" DIDN'T CLEAR "SEL RST"
;*SET "SEL RST" AGAIN.
;*CLEAR "CU RESET EN".
;*CHECK THAT "SEL RST" IS CLEARED.

SLRST3:	LDBR	OPLOUT+REQINL+CURSEN	;SET "OPL OUT" AND "REQ IN"
	MOVB	TOR1
	LDBR	OPLOUT+REQINL		;CLEAR "CU RESET EN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SEL RST"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SLRST3,CLEARING "CU RESET EN" DIDN'T CLEAR "SEL RST"
;*CLEAR "OPL OUT".
;*SET AND CLEAR CHANNEL MODE.
;*CHECK THAT "SEL RST" IS CLEARED.

	LDBR	REQINL+CURSEN		;CLEAR "OPL OUT"
	MOVB	TOR1
SLRST4:	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SEL RST"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SLRST4,"SEL RST" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "OPL OUT" THEN SET AND CLEARED "CHANNEL MODE"
;*SET "OPL OUT".
;*CLEAR "REQ IN".
;*SET AND CLEAR CHANNEL MODE.
;*CHECK THAT "SEL RST" IS CLEARED.

	LDBR	OPLOUT+CURSEN		;SET "OPL OUT" AND CLEAR "REQ IN"
	MOVB	TOR1
SLRST5:	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SEL RST"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SLRST5,"SEL RST" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "REQ IN" THEN SET AND CLEARED "CHANNEL MODE"
;*SET "REQ IN".
;*SET "OPL IN".
;*SET AND CLEAR CHANNEL MODE.
;*CHECK THAT "SEL RST" IS CLEARED.

	LDBR	OPLOUT+REQINL+CURSEN	;SET "REQ IN"
	MOVB	TOR1
	LDBR	OPLINL			;SET "OPL IN"
	MOVB	TOR0
SLRST6:	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "SEL RST"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SLRST6,"SEL RST" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "OPL IN" THEN SET AND CLEARED "CHANNEL MODE"
	REPEAT	TST
	TEST	190,TEST "HALT IO"
;*TEST THAT "HALT IO" SETS WHEN AND ONLY WHEN "ADR IN" AND "OPL OUT" ARE
;*SET, "TO HLD OUT" IS CLEARED, AND "CU RESET EN" IS SET.  CHECK THAT
;*"HALT IO" CAUSES AN INTERRUPT AND IS CLEARED BY DOING A MICROBUS INIT,
;*SETTING CHAN MODE, OR CLEARING CU RESET EN.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*DO A MICROBUS INIT.
;*SET LOOP ENABLE AND "CU RESET EN".
;*SET "ADR IN" AND "OPL OUT".
;*CHECK THAT "HALT IO" IS SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
HLTIO1:	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	ADRINL			;SET "ADR IN"
	MOVB	TOR0
	LDBR	OPLOUT			;SET "OPL OUT"
	MOVB	TOR1
	LDBR	OPLOUT+CURSEN		;SET "CU RESET EN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "HALT IO"
	JMPB0	.+2			;JUMP IF IT IS SET
	ERROR	TST,"HALT IO" DID NOT SET,
DIAG SET "ADR IN" AND "OPL OUT" AND CLEARED "TO HLD OUT"
;*CHECK THAT AN INTERRUPT OCCURRED.

	JMPI	ZRTNH			;JUMP IF INTERRUPT PRESENT
	JMPZ	.+2			;JUMP IF INTERRUPT JUMP WAS TAKEN
	ERROR	TST,"HALT IO" DID NOT CAUSE AN INTERRUPT
;*DO A MICROBUS INIT.
;*CHECK THAT "HALT IO" IS CLEARED.

	JMPSUB	INITL			;DO A MICROBUS INIT
	DATI	SPADR,BR		;READ "HALT IO"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	HLTIO1,MICROBUS INIT DIDN'T CLEAR "HALT IO"
;*SET "HALT IO" AGAIN.
;*SET AND CLEAR CHAN MODE.
;*CHECK THAT "HALT IO" IS CLEARED.

HLTIO2:	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	ADRINL			;SET "ADR IN"
	MOVB	TOR0
	LDBR	OPLOUT+CURSEN		;SET "OPL OUT"
	MOVB	TOR1
	LDBR	0			;CLEAR "ADR IN"
	MOVB	TOR0
	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHAN MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "HALT IO"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	HLTIO2,SETTING "CHAN MODE" DIDN'T CLEAR "HALT IO"
;*SET "HALT IO" AGAIN.
;*CLEAR "CU RESET EN".
;*CHECK THAT "HALT IO" IS CLEARED.

HLTIO3:	LDBR	ADRINL			;SET "ADR IN"
	MOVB	TOR0
	LDBR	OPLOUT+CURSEN		;SET "OPL OUT"
	MOVB	TOR1
	LDBR	OPLOUT			;CLEAR "CU RESET EN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "HALT IO"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	HLTIO3,CLEARING "CU RESET EN" DIDN'T CLEAR "HALT IO"
;*SET "TO HLD OUT".
;*SET AND CLEAR CHANNEL MODE.
;*CHECK THAT "HALT IO" IS CLEARED.

HLTIO4:	LDBR	ADRINL+TOHOUT		;SET "TO HLD OUT"
	MOVB	TOR0
	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "HALT IO"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	HLTIO4,"HALT IO" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "TO HLD OUT" THEN SET AND CLEARED "CHANNEL MODE"
;*CLEAR "TO HLD OUT".
;*CLEAR "ADR IN".
;*SET AND CLEAR CHANNEL MODE.
;*CHECK THAT "HALT IO" IS CLEARED.

HLTIO5:	LDBR	0			;CLEAR "ARD IN" AND "TO HLD OUT"
	MOVB	TOR0
	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "HALT IO"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	HLTIO5,"HALT IO" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "ADR IN" THEN SET AND CLEARED "CHANNEL MODE"
;*SET "ADR IN".
;*CLEAR "OPL OUT".
;*SET AND CLEAR CHANNEL MODE.
;*CHECK THAT "HALT IO" IS CLEARED.

	LDBR	ADRINL			;SET "ADR IN"
	MOVB	TOR0
HLTIO6:	LDBR	CURSEN			;CLEAR "OPL OUT"
	MOVB	TOR1
	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,BR		;READ "HALT IO"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	HLTIO6,"HALT IO" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "OPL OUT" THEN SET AND CLEARED "CHANNEL MODE"
	REPEAT	TST
	TEST	191,TEST REGISTER 16 (CUSTAT)
;*TEST WRITING AND READING BITS 2-0 OF REG 16.
;*LOOP ENABLE IS NOT SET FOR THIS TEST.
;*THE "CHAN MODE" BIT MUST BE CLEAR TO ALLOW READING OF THESE BITS.
;*"CU RESET EN" IS SET FOR THIS TEST.
;*SET "OPL IN" TO CLEAR PRESETTING OF "SYS RST".
;*LOOP ENABLE IS SET FOR THIS TEST.

;*WRITE ZEROS TO BITS 2-0.
;*CHECK THAT BITS 2-0 ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDBR	LOOPEN			;CLEAR "CHAN MODE"
	MOVB	CSR1
	LDBR	CURSEN			;SET "CU RESET EN"
	MOVB	TOR1
	LDBR	OPLINL			;SET "OPL IN"
	MOVB	TOR0
	LDMEM	0			;WRITE ZEROS INTO BITS 2-0 OF REG 16
	MOVMEM	CUSTAT
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ BACK BITS IN REG 5
	LDBR	7			;SETUP BIT MASK FOR THE BITS
	LANDBR	AC0			;ISOLATE THE BITS
	OSM	AC0			;CHECK IF ALL ZEROS
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO BITS 2-0 OF REG 16
;*WRITE ONES TO BITS 2-0 OF REG 16.
;*CHECK THAT BITS 2-0 OF REG 5 ARE ONES.

REG16A:	LDMEM	7			;SETUP BIT MASK FOR BITS
	MOVMEM	CUSTAT			;WRITE ONES INTO BITS
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ REG 5
	LANDMR	AC0			;ISOLATE BITS
	OSM	AC0			;CHECK IF ALL ONES
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG16A,CAN NOT WRITE ALL ONES TO BITS 2-0 OF REG 16
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO BITS 2-0 OF REG 16.
;*READ BACK BITS 2-0 OF REG 5 FOR THE PATTERN.

	LDBR	^D5			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZG			;SET MAR TO FIRST PATTERN
FLT16:	MOVMEM	CUSTAT			;WRITE PATTERN TO BITS 2-0 OF REG 16
	NOP				;DELAY BEFORE DOING DATI
	DATI	SPADR,AC0		;READ REG 5
	LDBR	7			;SETUP BIT MASK FOR BITS
	LANDBR	AC0			;ISOLATE BITS
	OSM	AC0			;CHECK FOR CORRECT PATTERN
	JMPZ	.+2			;JUMP IF CORRECT PATTERN
	ERRORM	FLT16,FLOATING ZEROS/ONES FAILED,
DIAG WROTE BITS 2-0 OF REG 16
	DECR	AC1,I			;DEC LOOP COUNT AND INC MAR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT16			;ELSE,CONTINUE

	REPEAT	TST
	TEST	192,TEST CONTROL UNIT SELECT LOGIC
;*TEST THAT "SLVE SEL" SETS WHEN AND ONLY WHEN "REC SEL FF" SETS WITH
;*"SLVE SEL DATA" ASSERTED.  THIS IMPLICITLY TESTS THE PROPER OPERATION
;*OF "REC SEL FF" AND "SERV REQ" SIGNALS.
;*ALSO, TEST THAT "SLVE SEL" CLEARS WHEN BIT 0 OF REG 0 IS WRITTEN.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "TO HLD OUT" TO INSURE "TRA SEL FF" CLEARS.
;*DO A MICROBUS INIT.
;*SET "SUP OUT", "SEL IN", AND "TO HLD OUT".
;*CHECK THAT "SLVE SEL" IS SET.

	LDBR	0			;CLEAR "TO HLD OUT"
	MOVB	TOR0
	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	SUPOUT			;SET "SUP OUT"
	MOVB	TOR1
	LDBR	SELINL+TOHOUT		;SET "TO HLD OUT" AND "SEL IN"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"SLVE SEL" DID NOT SET,
<DIAG SET "SUP OUT" AND CLEARED "ADR IN" THEN
SET "SEL IN" AND "TO HLD OUT">
;*CLEAR "SLVE SEL".
;*CHECK THAT "SLVE SEL" IS CLEARED.

SLVSL2:	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"SLVE SEL" DIDN'T CLEAR WHEN BIT 0 OF REG 0 WAS WRITTEN
;*CLEAR THEN SET "SEL IN".
;*CHECK THAT "SLVE SEL" DOES NOT SET (I.E., "REC SEL FF" DIDN'T TOGGLE).

	LDBR	TOHOUT			;CLEAR "SEL IN"
	MOVB	TOR0
	LDBR	TOHOUT+SELINL		;SET "SEL IN"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	SLVSL2,"SLVE SEL" SET WHEN IT SHOULDN'T HAVE,
<DIAG SET "SLVE SEL DATA" AND "REC SEL FF",
CLEARED "SLVE SEL",
THEN CLEARED AND SET "SEL IN">
;*CLEAR "SLVE SEL".
;*CLEAR THEN SET "TO HLD OUT" ("REC SEL FF" SHOULD TOGGLE).
;*CHECK THAT "SLVE SEL" IS SET.

SLVSL3:	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
SLVSL1:	LDBR	SELINL			;CLEAR "TO HLD OUT"
	MOVB	TOR0
	LDBR	TOHOUT+SELINL		;SET "TO HLD OUT"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	SLVSL3,"SLVE SEL" DID NOT SET,
DIAG CLEARED "SLVE SEL" THEN TOGGLED "TO HLD OUT"
;*CLEAR "TO HLD OUT".
;*DO A MICROBUS INIT.
;*CHECK THAT "SLVE SEL" CLEARED.

	LDBR	0			;CLEAR "TO HLD OUT"
	MOVB	TOR0
	JMPSUB	INITL			;DO A MICROBUS INIT
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	SLVSL1,MICROBUS INIT DIDN'T CLEAR "SLVE SEL"
;*SET "ADR IN", "SUP OUT", AND "SEL IN".
;*SET "TO HLD OUT" (SETS "REC SEL FF").
;*CHECK THAT "SLVE SEL" DOES NOT SET.

SLVSL4:	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	SUPOUT			;SET "SUP OUT"
	MOVB	TOR1
	LDBR	ADRINL+SELINL		;SET "ADR IN" AND CLEAR "TO HLD OUT"
	MOVB	TOR0
	LDBR	ADRINL+SELINL+TOHOUT	;SET "TO HLD OUT"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	SLVSL4,"SLVE SEL" SET WITH "ADR IN" SET,
DIAG SET "REC SEL FF"
;*CLEAR "ADR IN".
;*CLEAR "SLVE SEL".
;*CLEAR "SUP OUT".
;*CLEAR THEN SET "TO HLD OUT".
;*CHECK THAT "SLVE SEL" DOESN'T SET.

SLVSL5:	LDBR	SELINL			;CLEAR "ADR IN" AND "TO HLD OUT"
	MOVB	TOR0
	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
	LDBR	0			;CLEAR "SUP OUT"
	MOVB	TOR1
	LDBR	SELINL+TOHOUT		;SET "TO HLD OUT"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	SLVSL5,"SLVE SEL" SET WITH "SUP OUT" CLEARED,
DIAG TOGGLED "REC SEL FF"
	LDBR	0			;CLEAR "TO HLD OUT"
	MOVB	TOR0
	REPEAT	TST
	TEST	193,TEST "TRA SEL FF"
;*TEST THAT "TRA SEL FF" SETS WHEN AND ONLY WHEN "REC SEL FF" IS SET
;*AND "SLVE SEL DATA" AND "SLVE SEL"" ARE NEGATED.  ALSO, CHECK THAT
;*IT CLEARS ONLY WHEN "REC SEL FF" CLEARS.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "TO HLD OUT".
;*DO A MICROBUS INIT.
;*SET "SEL IN" AND "TO HLD OUT" (SETS "REC SEL FF").
;*CHECK THAT "TRA SEL FF" IS SET.

	LDBR	0			;CLEAR "TO HLD OUT"
	MOVB	TOR0
	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	SELINL+TOHOUT		;SET "SEL IN" AND "TO HLD OUT"
	MOVB	TOR0
	JMPSUB	RDTSFF			;GO READ "TRA SEL FF"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"TRA SEL FF" DID NOT SET,
DIAG CLEARED "SLVE SEL" AND "SLVE SEL DATA" AND SET "REC SEL FF"
;*SET "SUP OUT" (ASSERTS "SLVE SEL DATA").
;*CHECK THAT "TRA SEL FF" IS STILL SET.

	LDBR	SUPOUT			;SET "SUP OUT"
	MOVB	TOR1
	JMPSUB	RDTSFF			;GO READ "TRA SEL FF"
	JMPB0	.+2			;JUMP IF STILL SET
	ERROR	TST,"TRA SEL FF" DID NOT STAY SET,
DIAG SET "TRA SEL FF" THEN ASSERTED "SLVE SEL DATA"
;*CLEAR "SUP OUT".
;*CLEAR "TO HLD OUT" (CLEARS "REC SEL FF").
;*CHECK THAT "TRA SEL FF" CLEARS.

	LDBR	0			;CLEAR "SUP OUT"
	MOVB	TOR1
	LDBR	SELINL			;CLEAR "TO HLD OUT"
	MOVB	TOR0
	JMPSUB	RDTSFF			;GO READ "TRA SEL FF"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2
	ERROR	TST,"TRA SEL FF" DIDN'T CLEAR WHEN "TO HLD OUT" CLEARED
;*CHECK THAT "TRA SEL FF" DOES NOT SET WHEN "SLVE SEL" IS SET.
;*SET "SUP OUT" (ASSERTS "SLVE SEL DATA").
;*SET "SEL IN" AND "TO HLD OUT" (SETS "REC SEL FF" AND "SLVE SEL").
;*CLEAR "SUP OUT" (NEGATES "SLVE SEL DATA").
;*CHECK THAT "TRA SEL FF" IS NOT SET.

TSFF1:	LDBR	0			;CLEAR "SEL IN" AND "TO HLD OUT"
	MOVB	TOR0
	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
	LDBR	SUPOUT			;SET "SUP OUT"
	MOVB	TOR1
	LDBR	SELINL+TOHOUT		;SET "REC SEL FF"
	MOVB	TOR0
	LDBR	0			;CLEAR "SUP OUT"
	MOVB	TOR1
	JMPSUB	RDTSFF			;GO READ "TRA SEL FF"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TSFF1,"TRA SEL FF" SET WITH "SLVE SEL" SET,
DIAG SET "REC SEL FF" AND "SLVE SEL" THEN NEGATED "SLVE SEL DATA"
	LDBR	0			;CLEAR "TO HLD OUT"
	MOVB	TOR0
	REPEAT	TST
	TEST	194,TEST CONTROL UNIT ADDRESS COMPARISION LOGIC
;*DETERMINE THE ADDRESS(ES) WHICH THE CONTROL UNIT LOGIC WILL RESPOND TO,
;*I.E., THOSE ADDRESSES WHICH RESULT IN "SLVE SEL" GETTING SET.
;*ALSO, CHECK THAT "SLVE SEL" DOES NOT SET IF "BUS0 ODD PAR" IS CLEARED OR
;*IF "ADR IN" IS NOT SET.

;*SET "ADR IN".
;*INPUT ADDRESS 0 INTO CBI BITS WITH GOOD PARITY.
;*SET "REC SEL FF".
;*CHECK IF "SLVE SEL" IS SET.
;*KEEP INCREMENTING THE ADDRESS UNTIL "SLVE SEL" SETS.
;*IF IT DOESN'T SET FOR ALL ADDRESSES, REPORT AN ERROR.

	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN+EVPAR		;SET LOOP ENABLE AND "EVEN PAR", SO
	MOVB	CSR1			;CBI PARITY IS ODD
	LDBR	ADRINL			;SET "ADR IN"
	MOVB	TOR0
	LDBR	0			;INIT ADDRESS TO ZERO
	MOVB	AC1
CUADLP:	LDBR	ADRINL+SELINL		;SET "ADR IN" AND "SEL IN" AND
	MOVB	TOR0			;CLEAR "TO HLD OUT"
	LDBR	0			;SETUP ZERO REG TO COMPLEMENT ADDRESS
	MOVB	AC2
	MOV	AC1,BR			;MOVE ADDR TO BR
	LORCB	AC2,BR			;COMPLEMENT IT
	MOVB	BORLO			;LOAD IT INTO BORLO
	LDBR	ADRINL+SELINL+TOHOUT	;SET "TO HLD OUT"
	MOVB	TOR0
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	LOWADR			;JUMP IF IT SET
	INCR	AC1			;INC ADDRESS
	JMPC	.+2			;JUMP IF ALL ADDRESSES TESTED
	JMP	CUADLP			;ELSE, CONTINUE
	ERROR	TST,"SLVE SEL" DIDN'T SET FOR ALL ADDRESSES
;*AFTER FINDING THE LOWEST RESPONDING ADDRESS, DETERMINE WHICH BITS
;*ARE DON'T CARE.  TO DO THIS, COMPLEMENT EACH BIT IN THE LOWEST ADDRESS,
;*ONE AT A TIME, AND CHECK IF THE LOGIC RESPONDS TO THESE ADDRESSES.
;*SEND THE HOST THE LOWEST ADDRESS PLUS A MASK OF THE "DON'T CARE" BITS.
;*FROM THIS THE HOST CAN DISPLAY THE SET OF ADDRESSES WHICH THE LOGIC IS
;*SETUP TO RESPOND TO.

LOWADR:	LDBR	1			;INITIALIZE "DON'T CARE" BIT COMPLEMENTOR
	MOVB	AC2
	LDBR	0			;INITIALIZE "DON'T CARE" MASK
	MOVB	AC0
	LDBR	7			;SETUP LOOP CNT MINUS 1
	MOVB	AC3
	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
DCLP:	LDBR	ADRINL+SELINL		;CLEAR "TO HLD OUT"
	MOVB	TOR0
	MOV	AC1,BR			;MOVE LOW ADDR TO BR
	LXORB	AC2,BR			;XOR ADDR WITH "DON'T CARE" BIT
	LDMEM	0			;SETUP ZERO REG TO DO COMPLEMENT
	MOVMEM	AC4
	LORCB	AC4,BR			;COMPLEMENT NEW ADDRESS
	MOVB	BORLO			;LOAD INTO BORLO
	LDBR	ADRINL+SELINL+TOHOUT	;SET "TO HLD OUT"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	ADMTCH			;JUMP IF IT SET (RESPONDED TO ADDR)
NXBIT:	SHLR	AC2			;SHIFT "DON'T CARE" BIT
	DECR	AC3			;DEC LOOP CNT
	JMPZ	ADDONE			;JUMP IF DONE
	JMP	DCLP			;ELSE, CONTINUE

ADMTCH:	MOV	AC2,BR			;MOVE "DON'T CARE" BIT TO BR
	LORBR	AC0			;ADD THIS TO MASK
	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
	JMP	NXBIT			;GO ON TO NEXT BIT

ADDONE:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC1,BR			;GET LOW ADDR
	MOVB	MPGP12			;STORE FOR PRINTOUT
	MOV	AC0,BR			;GET MASK
	MOVB	MPGP13			;STORE FOR PRINTOUT
	LDBR	33			;SELECT CHAN BUS INTERFACE
	MOVB	IOSEL
	SNDADR				;SEND CU ADDR INFO TO HOST

;*SET ADDRESS TO LOW ADDRESS
;*CLEAR "ADR IN".
;*TOGGLE "REC SEL FF".
;*CHECK THAT "SLVE SEL" DOES NOT SET.

ADSTP:	LDBR	0			;SETUP TO DO COMPLEMENT
	MOVB	AC4
	MOV	AC1,BR			;MOVE ADDR TO BR
	LORCB	AC4,BR			;COMPLEMENT LOW ADDR
	MOVB	BORLO			;LOAD IT IN BORLO
CUADR1:	LDBR	SELINL			;CLEAR "TO HLD OUT" AND "ADR IN"
	MOVB	TOR0
	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
	LDBR	SELINL+TOHOUT		;SET "TO HLD OUT"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	CUADR1,"SLVE SEL" SET WITH "ADR IN" AND "SUP OUT" CLEARED
;*SET "ADR IN".
;*CLEAR "EVEN PAR" TO CAUSE CBI PARITY ERROR.
;*TOGGLE "REC SEL FF".
;*CHECK THAT "SLVE SEL" DOES NOT SET.

	LDBR	LOOPEN			;CLEAR "EVEN PAR"
	MOVB	CSR1
CUADR2:	LDBR	SELINL+ADRINL		;CLEAR "TO HLD OUT" AND SET "ADR IN"
	MOVB	TOR0
	LDBR	CSLVSL			;CLEAR "SLVE SEL"
	MOVB	CSR0
	LDBR	ADRINL+SELINL+TOHOUT	;SET "TO HLD OUT"
	MOVB	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "SLVE SEL"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	CUADR2,"SLVE SEL" SET WITH "BUS0 ODD PAR" CLEARED
	REPEAT	TST
	TEST	195,TEST MK PE FLAG
;*READ REG 7.
;*CHECK THAT "MK PE FLAG" IS NOT SET.

	LDBR	CLRFLG			;CLEAR ALL FLAGS
	MOVB	CSR0
	DATI	CBILO			;READ REG 7
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,AC0		;READ REG 0
	SHL	AC0,BR			;MOVE "MK PE FLAG" TO BIT 4
	JMPB4	.+2			;JUMP IF IT SET,SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"MK PE FLAG" SET WHEN DIAG READ REG 7
	REPEAT	TST
	TEST	196,TEST "BUS1 PE FLAG"
;*READ REGISTER 13 TO MAKE SURE IT DOES NOT SET "BUS1 PE FLAG" IN
;*REGISTER 0.

	LDBR	CLRFLG			;CLEAR ALL FLAGS
	MOVB	CSR0
	DATI	CBIHI			;READ REG 13
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,AC0		;READ REG 0
	SHR				;RIGHT ADJUST "BUS1 PE FLAG" BIT
	SHR
	JMPB0	.+2			;JUMP IF IT SET INCORRECTLY
	JMP	.+2			;ELSE, RESULTS OKAY
	ERROR	TST,"BUS1 PE FLAG" SET WHEN DIAG READ REG 13
	REPEAT TST
	JMP	END			;JUMP AROUND SUBROUTINES

ZRTNH:	RETURN	-1

INITL:	LDBR	INIT+33			;SET INIT
	MOVB	IOSEL
	LDBR	33			;CLR INIT & SELECT CB
	MOVB	IOSEL
	LDMAR	0			;PUT MEMORY ADDRESS TO 0
	LDMEM	0			;CLR MEMORY LOC. 0
	RETURN

;"WAIT" IS USED TO WAIT APPROX 20 MS.  IT CONSISTS OF AN INNER WAIT LOOP
;OF APPROX 960 NSEC AND AN OUTER LOOP OF APPROX 200 USEC.
WAIT:	LDBR	^D100			;SET OUTER LOOP WAIT COUNT
	MOVB	AC0
WAITO:	LDBR	^D207			;SET INNER LOOP WAIT COUNT
	MOVB	AC1
WAITI:	DECR	AC1			;DEC INNER LOOP COUNT
	JMPZ	.+2			;JUMP IF INNER LOOP TIMED OUT
	JMP	WAITI			;ELSE, CONTINUE
	DECR	AC0			;DEC OUTER LOOP COUNT
	JMPZ	.+2			;JUMP IF OUTER LOOP TIMED OUT
	JMP	WAITO			;ELSE CONTINUE
	RETURN

LOADDR:	LDBR	-1			;LOAD ONES INTO BORLO
	MOVB	BORLO
	MOVB	CLKDRL			;LOAD ZEROS INTO DRLO
	LDBR	0			;LOAD ZEROS INTO BORLO
	MOVB	BORLO
	RETURN


DEVRD:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;SETUP FOR A DEVICE READ
	MOVB	MPSCR1
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN

DEVWR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	DTD			;SETUP FOR A DEVICE WRITE
	MOVB	MPSCR1
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN

SETPNT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP6			;STORE ADDITIONAL PNT ROUTINE NUMBER
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN

SETDAT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP12			;STORE DATA FOR PRINTOUT
	LDBR	33			;SELECT CHAN BUS INTERFACE
	MOVB	IOSEL
	RETURN

RDBRP0:	LDBR	0			;SET "BOR P0" INDEX
	MOVB	SPADR
	JMP	RDIT

RDB0OD:	LDBR	2			;SET "BUS0 ODD PAR" INDEX
	MOVB	SPADR
	JMP	RDIT

RDSEX:	LDBR	3			;SET "SLVE END XFER" INDEX
	MOVB	SPADR
	JMP	RDIT

RDTSFF:	LDBR	4			;SET "TRA SEL FF" INDEX
	MOVB	SPADR
	JMP	RDIT

RDAMK1:	LDBR	5			;SET "ALLOW MK 1 OUT" INDEX
	MOVB	SPADR
	JMP	RDIT

RDODDE:	LDBR	6			;SET "ODD END" INDEX
	MOVB	SPADR
	JMP	RDIT

RD2BYT:	LDBR	7			;SET "2ND BYTE" INDEX
	MOVB	SPADR
	JMP	RDIT

RDRRDY:	LDBR	10			;SET "DR READY" INDEX
	MOVB	SPADR
	JMP	RDIT

RDSLRQ:	LDBR	11			;SET "SLVE REQ" INDEX
	MOVB	SPADR
	JMP	RDIT

RDRDLY:	LDBR	12			;SET "DATA RDY DLY" INDEX
	MOVB	SPADR
	JMP	RDIT

RDCUIN:	LDBR	13			;SET "CU INIT" INDEX
	MOVB	SPADR
	JMP	RDIT

RDENSD:	LDBR	14			;SET "EN SRV/DAT OUT" INDEX
	MOVB	SPADR
	JMP	RDIT

RDSDRQ:	LDBR	15			;SET "ST DATA REQ" INDEX
	MOVB	SPADR
	JMP	RDIT

RDDSRQ:	LDBR	16			;SET "NOT DIS SLVE REQ" INDEX
	MOVB	SPADR
	JMP	RDIT

RDDPPE:	LDBR	17			;SET "DP PE" INDEX
	MOVB	SPADR
	JMP	RDIT

RDIT:	DATI	TOR1,BR			;READ REG 3
	SHR				;RIGHT ADJUST DIAG MUX BIT
	SHR
	RETURN

DPINIT:	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	MOVB	HSDPIN
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN
END:	.ECRAM
.MEM
	0
PATS:	-1
	0
FLTZ:	376
	375
	373
	367
	357
	337
	277
	177
FLTO:	1
	2
	4
	10
	20
	40
	100
	200
FLTZA:	374
	371
	365
	355
	335
	235
	135
	1
	4
	10
	20
	40
	100
	200
FLTZB:	372
	371
	363
	353
	333
	273
	173
	1
	2
	10
	20
	40
	100
	200
FLTZC:	340
	320
	260
	160
	20
	40
	100
	200
FLTZD:	360
	350
	330
	270
	170
	10
	20
	40
	100
	200
FLTZE:	16
	15
	13
	7
	1
	2
	4
	10
FLTZF:	334
	332
	326
	316
	236
	136
	2
	4
	10
	20
	100
	200
FLTZG:	6
	5
	3
	1
	2
	4
EPATS:	11
	102
	220
	366
OPATS:	44
	157
	275
	333
RAMADR:	0
	1
	2
	4
	10
	-1
.END
