SUBTTL	*SUBRTN* PROGRAM SUBROUTINE INITIALIZATION, V73G, NOV 12, 1973

$PGMIN:	MOVEM	0,$ACA0#
	SETOM	USER#
	TLNN	0,USERF		;USER MODE ?
	SETZM	USER		;EXEC MODE
	SKIPN	MONFLG		;DIAG MON, SPECIAL USER MODE ?
	SETZM	USER		;YES, TREAT I/O AS EXEC
	SKIPE	USER		;EXEC ?
	JRST	.+5		;NO
	CONO	PI,010000	;CLEAR PI SYSTEM
	CONO	APR,200000	;CLEAR I/O
	HLRZ	JOBSA		;RESET JOB FIRST FREE TO
	MOVEM	JOBFF		;END OF LOW SEGMENT
	SKIPE	USER		;USER ?
	CALLI	0		;YES, CLEAR USER I/O
	JRST	2,@.+1		;CLEAR PC FLAGS
	XWD	0,.+1
	MOVE	CONSW
	MOVEM	$SVCSW#		;SAVE PREVIOUS SWITCHES
	SETZM	CONSW#		;CLEAR SWITCH REGISTER
	SETZM	$SWFLG#		;DISALLOW SWITCHES TILL INITED
	JSP	$CPUTP		;DETERMINE CPU TYPE
	XLIST
	IFDEF	PSHLST,<LIST
	MOVE	P,PLIST		;INIT PUSH POINTER
	MOVEI	0,$PSHER
	PUSH	P,0		;SET ERR FOR EXCESSIVE POP'S>
	XLIST
	IFDEF	PRINT,<LIST
	JSP	$PNTIN		;INIT PRINT SUBROUTINE>
	XLIST
	IFDEF	TYPIN,<LIST
	JSP	$TYPIN		;INIT TTY INPUT SUBROUTINE>
	XLIST
	IFDEF	TOGGLE,<LIST
	JSP	$SWTIN		;INIT SWITCH INPUT SUBROUTINE>
	XLIST
	IFDEF	UUOS,<LIST
	JSP	$UUOIN		;INIT UUO SUBROUTINE>
	XLIST
	IFDEF	MEMMAP,<LIST
	JSP	$MEMMP		;MAP MEMORY >
	XLIST
	IFDEF	INTRPT,<LIST
	JSP	$ITRIN		;INIT INTERRUPT SUBROUTINE>
	LIST
	SETOM	$ONETM		;SET ONE TIME FLAG
	JRST	@$ACA0		;EXIT
;DETERMINE PROCESSOR TYPE

$CPUTP:	MOVEM	0,$ACB0#
	SETOM	KAIFLG#		;KAIFLG =0, KA10; =-1, KI10
	JFCL	17,.+1
	JRST	.+1
	JFCL	1,$PDP6		;PDP-6 HAS PC CHANGE FLAG, TREAT AS KA10
	MOVNI	0,1		;KA10, KI10 DO NOT
	AOBJN	0,.+1		;CARRY INTO BIT 17 DETERMINES CP
	SKIPE	0		;KI10 IF (AC) = 0,,0
$PDP6:	SETZM	KAIFLG		;KA10 IF (AC) = 1,,0
	JRST	@$ACB0

;SUBROUTINE ERROR HALT

$ERHL1:	MOVEM	0,$ERH0#	;SAVE AC0
	PNTNM			;PRINT PROGRAM NAME
	MOVEI	[ASCIZ/
ERROR HALT AT /]
	PNTALF
	MOVE	$ERHLT
	SOS
	PNT6F
	MOVE	0,$ERH0
	SKIPN	USER		;USER MODE ?
	JRST	.+3
	EXIT	1,
	JRST	@$ERHLT
	SKIPL	MONCTL		;UNDER MONITOR CONTROL ?
	HALT	@$ERHLT		;NO
	SWITCH
	TLNN	0,ERSTOP	;HALT ON ERROR SWITCH SET ?
	JRST	@RETURN
	MOVE	0,$ERH0
	HALT	@$ERHLT

	XLIST
	IFDEF	PSHLST,<LIST
;PUSH DOWN LIST EXCESSIVE POPJ ROUTINE

$PSHER:	MOVEI	[ASCIZ/
**********
PUSHDOWN LIST UNDERFLOW ERROR/]
	PNTALF
	FATAL>
	LIST
;PRINT PROGRAM NAME IF NOT STAND-ALONE

$PNTNM:	MOVEM	0,$ACPN0#
	SKIPL	MONCTL		;DIAG MON / SYS EXER ?
	JRST	@$ACPN0		;NO
	MOVEI	PGMNAM
	PNTAL			;PRINT PROGRAM NAME
	MOVE	0,PNTSPC
	MOVEM	0,$SVPSP#	;SAVE PRINT SPACE CONTROL
	SETZM	PNTSPC
	MOVEI	[ASCIZ/VERSION /]
	PNTAL
	HLRZ	JOBVER
	PNT3			;PRINT MCN LEVEL
	MOVEI	PERIOD
	PNTA
	HRRZ	JOBVER
	PNT3			;PRINT DEC VERSION
	MOVEI	CRLF2
	PNTA
	MOVE	0,$SVPSP
	MOVEM	0,PNTSPC	;RESTORE SPACE CONTROL
	JRST	@$ACPN0

;FATAL PROGRAM ERROR HALT

$FATL1:	MOVEM	0,$FATL0#
	PNTNM
	MOVEI	[ASCIZ/
FATAL PROGRAM ERROR AT /]
	PNTALF
	MOVE	$FATAL
	SOS
	PNT6F
	SKIPE	USER
	EXIT			;USER - RELEASE, RESET & EXIT
	SKIPL	MONCTL		;EXEC - DIAGNOSTIC MONITOR ?
	HALT	BEGIN		;NO
	SWITCH
	TLNN	ERSTOP		;YES, STOP ON ERROR ?
	JRST	@RETURN		;NO, BACK TO DIAG MONITOR
	HALT	BEGIN
	XLIST
	IFNDEF	TOGGLE,<LIST
$SWTCH:	MOVEM	0,$SACA0#
	MOVE	0,SWTEXR	;USE "SWTEXR" AS SWITCHES
	MOVEM	0,CONSW
	JRST	@$SACA0		>
	XLIST
	IFDEF	INTRPT,<LISTSUBTTL	*SUBRTN* INTERRUPT HANDLING SUBROUTINE, V73G, NOV 12, 1973

;INITIALIZE FOR INTERRUPTS AND TRAPPING.

$ITRIN:	MOVEM	0,$ACB0#
	SKIPE	USER		;PROCESSOR IN USER MODE?
	JRST	$ITRUS		;YES
	SKIPN	KAIFLG
	JRST	$KA10
	JRST	$KI10

	IFNDEF	USRASB,<
$ITRUS:	HALT	.	>

	IFNDEF	EXCASB,<
$KA10:	HALT	.
$KI10:	HALT	.	>

	IFDEF	EXCASB,<
	IFNDEF	KA10,<
$KA10:	HALT	.	>
	IFNDEF	KI10,<
$KI10:	HALT	.	>>

$PDOVU:	MOVEI	[ASCIZ/
PUSHDOWN OVERFLOW/]
	JRST	$ITR1A

$MPVU:	MOVEI	[ASCIZ/
MEMORY PROTECTION VIOLATION/]
	JRST	$ITR1A

$NXMU:	MOVEI	[ASCIZ/
NON-EXISTANT MEMORY/]
	JRST	$ITR1A

$PARER:	MOVEI	[ASCIZ/
MEMORY PARITY ERROR/]
	JRST	$ITR1A

	XLIST
	IFDEF	USRASB,<LIST
;USER MODE INITIALIZATION

$ITRUS:	MOVEI	ITRUSR		;SETUP USER APR TRAPPING
	MOVEM	JOBAPR
	MOVEI	PDLOVU!MPVU!NXMU!PARU
	APRENB			;ENABLE PROCESSOR TRAPS
	JRST	@$ACB0

;USER MODE INTERRUPTS

ITRUSR:	MOVE	JOBTPC
	MOVEM	ITRCH1		;SAVE TRAPPED ADDRESS
	MOVE	JOBCNI
	MOVEM	$SVAPR		;SAVE CAUSE
	SETZM	$SVPI
	TRNE	PARU
$UPAR:	JRST	$PARER		;PARITY ERROR
	TRNE	PDLOVU
$UPDL:	JRST	$PDOVU		;PUSHDOWN OVERFLOW
	TRNE	MPVU
$UMPV:	JRST	$MPVU		;MEMORY PROTECTION VIOLATION
	TRNE	NXMU
$UNXM:	JRST	$NXMU		;NON-X-MEMORY
$USRHL:	JRST	.+1		;TO HANDLE OTHERS, PLACE TRANSFER HERE
	JRST	$ITRHL+1	;ERROR >

	LIST
;COMMON INTERRUPT HANDLERS

$ITRHL:	JRST	.+1		;TO HANDLE OTHERS, PLACE TRANSFER HERE
	MOVEI	[ASCIZ/
ERROR INTERRUPT/]
	JRST	$ITR1A

;PRINT CAUSE AND OTHER PERTINENT INFO

$ITR1A:	MOVEM	0,$ITAC0#
	PNTNM
	MOVE	0,$ITAC0
	SKIPE	0
	PNTALF			;PRINT CAUSE
	MOVEI	[ASCIZ/
APR            PI             FLAGS  PC      PROG
/]
	PNTALF
	MOVE	$SVAPR#
	PNTHWF			;PRINT APR CONI BITS
	MOVEI	SPACE
	PNTAF
	MOVE	$SVPI#
	PNTHWF			;PRINT PI CONI BITS
	MOVEI	SPACE
	PNTAF
	MOVE	ITRCH1
	SOS
	PNTHWF			;PRINT FLAGS, PC
	IFDEF	PSHLST,<
	MOVEI	SPACE
	PNTAF
	HRRZ	0,(P)
	SOS
	PNT6F			;PRINT LAST PUSHJ ENTRY>
	MOVEI	CRLF2
	PNTAF
$ITRX1:	JRST	.+1		;TO ADD ROUTINE, PLACE TRANSFER HERE
	FATAL

	XLIST
	IFDEF	EXCASB,<LIST
;COMMON INTERRUPT ROUTINE

$ITRC1:	MOVEM	0,$ACC0#
	CONI	APR,$SVAPR	;SAVE APR SYSTEM
	CONI	PI,$SVPI	;SAVE PI SYSTEM
	SKIPN	KAIFLG
	IFNDEF	KA10,<FATAL>	IFDEF	KA10,<JRST $KAITR> ;KA10
	IFNDEF	KI10,<FATAL>	IFDEF	KI10,<JRST $KIITR> ;KI10

;RESTORE PROCESSOR ON RESTART
RESRT1:	SKIPN	$PWRF		;DID POWER FAIL WORK?
	JRST	$PWRFL		;NO
	SKIPN	KAIFLG
	IFNDEF	KA10,<JRST $PWRFL>
	IFDEF	KA10,<JRST $KARST>
	IFNDEF	KI10,<JRST $PWRFL>
	IFDEF	KI10,<JRST $KIRST>

$RSTCM:	HRRZM	1,$SVPI
	HRRZM	3,$SVAPR
	MOVEI	[ASCIZ/
POWER FAIL RESTART
/]
	PNTALF
	SETZM	$PWRF#
$RSRTX:	JRST	.+1		;TO ADD ROUTINE, PLACE TRANSFER HERE
	CONO	APR,CLKCLR	;CLEAR CLOCK
	CONSO	APR,CLK		;WAIT FOR IT TO SET
	JRST	.-1		;WHEN SET - CLEAR - GIVES 17MS
	CONO	APR,CLKCLR	;TO EXIT INTERRUPT ROUTINE
	CONO	APR,@$SVAPR	;RESET APR SYSTEM
	CONO	PI,@$SVPI	;RESET PI SYSTEM
	MOVS	[1,,POWER+1]	;RESTORE AC'S
	BLT	17
	MOVE	0,POWER
$RSRTY:	JRST	.+1		;TO ADD ROUTINE, PLACE TRANSFER HERE
	JRSTF	@$PWRST

$PWRFL:	PGMINT
	MOVEI	[ASCIZ/
POWER INTERRUPT FAILED
/]
	PNTALF
	HALT	BEGIN

	XLIST
	IFDEF	KA10,<LIST
;KA10 INTERRUPT ROUTINE

$KAITR:	CONSO	PI,APWRFL	;POWER FAILURE?
	JRST	$KAIT1		;NO
	MOVE	0,[1,,POWER+1]	;YES, SAVE PROCESSOR STATE AND HALT
	BLT	POWER+17
	MOVE	$ACC0
	MOVEM	POWER
	MOVE	ITRCH1
	MOVEM	$PWRST#
	SETOM	$PWRF
	HALT	BEGIN

$KAIT1:	CONSZ	PI,APARER
$KAPAR:	JRST	$PARER		;PARITY ERROR
	CONSZ	APR,APDLOV
$KAPDL:	JRST	$PDOVU		;PUSHDOWN OVERFLOW
	CONSZ	APR,AMPV
$KAMPV:	JRST	$MPVU		;MEMORY PROTECTION VIOLATION
	CONSZ	APR,ANXM
$KANXM:	JRST	$NXMU		;NON-X-MEMORY
	JRST	$ITRHL		;REST COMMON

;KA10 POWER FAIL RESTART

$KARST:	CONO	APR,$KAINT
	CONO	PI,PWFCLR!PARCLR!PARDIS!PICLR!CHNOFF!PIOFF
	MOVE	3,$SVAPR
	TRZ	3,775550	;CLEAR MISC APR BITS
	MOVE	1,$SVPI
	TRZ	1,777400	;CLEAR MISC PI BITS
	MOVE	2,$SVPI
	TRNE	2,APAREN	;WAS PARITY ENABLED
	TRO	1,PARENB	;YES
	TRO	1,CHNON		;SET PI CHANNEL ON BIT
	JRST	$RSTCM		;REST COMMON

;KA10 INTERRUPT INITIALIZATION

$KAINT=APDCLR!IOCLR!AABCLR!AMPCLR!ANXCLR!CLKDIS!CLKCLR!AFODIS!AFOCLR!AOVDIS!AOVCLR

$KA10:	MOVE	[JSR ITRCH1]
	MOVEM	42		;SETUP INTERRUPT TRAP
	MOVEM	44
	MOVEM	46
	MOVEM	50
	MOVEM	52
	MOVEM	54
	MOVEM	56
	CONO	APR,$KAINT
	CONO	PI,PARCLR!PARDIS!PICLR!CHNOFF!PIOFF
	SETZM	$PWRF
$KA10A:	CONO	APR,AAPRC1	;ASSIGN CHANNEL 1
$KA10B:	CONO	PI,PARENB!CHNON!PION!PICHN1
	JRST	@$ACB0
>
	XLIST
	IFDEF	KI10,<LIST
;KI10 INTERRUPT ROUTINE

$KIITR:	CONSO	APR,IPWRFL	;POWER FAILURE?
	JRST	$KIIT1		;NO
	MOVE	[1,,POWER+1]
	BLT	POWER+17
	MOVE	$ACC0
	MOVEM	POWER
	MOVE	ITRCH1
	MOVEM	$PWRST#
	DATAI	PAG,$SVPAG#
	MOVE	[JRST PFSTRT]	;SET POWER FAIL TRAP
	MOVEM	70
	CONO	PI,PWFCLR	;CLEAR POWER FAIL
	CONO	APR,10000	;SET AUTO RESTART
	SETOM	$PWRF
	HALT	BEGIN

$KIIT1:	CONSZ	APR,IPARER
$KIPAR:	JRST	$PARER		;PARITY ERROR
	CONSZ	APR,INXM
$KINXM:	JRST	$NXMU		;NON-X-MEMORY
	JRST	$ITRHL		;REST COMMON

;KI10 TRAP ROUTINE

$PDLOV:	MOVE	PDLOV		;SAVE TRAPPED ADDRESS
	MOVEM	ITRCH1
	CONI	APR,$SVAPR
	CONI	PI,$SVPI
	JRST	$PDOVU

$PGFL:	MOVE	PGFAIL		;SAVE FAILED ADDRESS
	AOS			;BECAUSE INTERRUPT ERROR SOS'S
	MOVEM	ITRCH1
	CONI	APR,$SVAPR
	CONI	PI,$SVPI
	MOVEI	[ASCIZ/
PAGE FAIL TRAP ERROR
PAGE FAIL WORD- /]
	PNTALF
	MOVE	EXCPFW
	PNTHWF
	SETZM	0
	JRST	$ITR1A
;KI10 TRAP 3 ROUTINE

$TRP3:	MOVE	TRAP3
	MOVEM	ITRCH1
	CONI	APR,$SVAPR
	CONI	PI,$SVPI
	MOVEI	[ASCIZ/
TRAP 3 ERROR/]
	JRST	$ITR1A

;MONITOR UUO ERROR ROUTINE

MUUOER:	MOVE	MUUOPC
	MOVEM	ITRCH1
	CONI	APR,$SVAPR
	CONI	PI,$SVPI
	MOVEI	[ASCIZ/
MONITOR UUO ERROR
MUUO= /]
	PNTALF
	MOVE	MUUO
	PNTHWF			;PRINT MUUO
	SETZM	0
	JRST	$ITR1A
;KI10 POWER FAIL RESTART

$KIRST:	CONO	APR,IOCLR!ITMDIS!IASRTC!CLKDIS!CLKCLR!IIOPFC!INXCLR
	CONO	PI,PWFCLR!PARCLR!PARDIS!IRQCLR!PICLR!CHNOFF!PIOFF
	CONO	PAG,0
	DATAO	APR,[IMGNOF,,ISPDOF]
	MOVE	0,$SVPAG
	TLO	0,LDUSRB
	TRO	0,LDEXCB
	DATAO	PAG,0		;RESET PAG SYSTEM
	MOVE	1,$SVPI
	TRZ	1,777400	;CLEAR MISC PI BITS
	TRO	1,CHNON		;SET PI CHANNEL ON BIT
	MOVE	2,$SVAPR
	TRNE	2,IPAREN	;WAS PARITY ENABLED?
	TRO	1,PARENB	;YES
	MOVE	3,2
	TRZ	3,720700	;CLEAR MISC APR BITS
	TRNE	2,ITMOEN	;WAS TIME OUT ENABLED?
	TRO	3,ITMSET!ITMENB ;YES
	SETZM	$SWFLG#		;USE SAVED SW'S TILL RESTARTED
	JRST	$RSTCM		;REST COMMON

;KI10 INTERRUPT AND TRAP INITIALIZATION

$KI10:	MOVE	[JSR ITRCH1]
	MOVEM	42		;SETUP INTERRUPT TRAP
	MOVEM	44
	MOVEM	46
	MOVEM	50
	MOVEM	52
	MOVEM	54
	MOVEM	56
	MOVE	[JSR PGFAIL]
	MOVEM	PGFTRP		;SETUP PAGE FAIL TRAP
	MOVSI	(JFCL)
	MOVEM	AROVTP		;SETUP ARITHMETIC TRAP
	MOVE	[JSR PDLOV]
	MOVEM	PDOVTP		;SETUP PDL OV TRAP
	MOVE	[JSR TRAP3]
	MOVEM	TRP3TP		;SETUP TRAP 3
	MOVEI	MUUOER
	MOVEM	KNTRP		;SETUP MUUO AS ERROR
	MOVEM	KTRP
	MOVEM	SNTRP
	MOVEM	STRP
	MOVEM	CNTRP
	MOVEM	CTRP
	MOVEM	PNTRP
	MOVEM	PTRP
	CONO	PI,PWFCLR!PARCLR!PARDIS!IRQCLR!PICLR!CHNOFF!PIOFF
	SKIPL	MONCTL		;DIAGNOSTIC MONITOR?
	CONO	APR,IOCLR!ITMDIS!IASRTC!CLKDIS!CLKCLR!IIOPFC!INXCLR
	SKIPGE	MONCTL		;YES
	CONO	APR,IOCLR!CLKDIS!CLKCLR!INXCLR
	CONO	PAG,0
	SKIPL	MONCTL
	DATAO	APR,[IMGNOF,,ISPDOF]
	SKIPE	MONFLG
	DATAO	PAG,[LDUSRB,,LDEXCB!TRPENB]
$KI10A:	CONO	APR,IAPRE1	;ERROR CHANNEL 1
$KI10B:	CONO	PI,PARENB!CHNON!PION!PICHN1
	JRST	@$ACB0

>>>
	XLIST
	IFDEF	KIMRGN,<LIST
SUBTTL	*SUBRTN* KI10 MARGIN PRINTOUT ROUTINE, V73G, NOV 12, 1973

$PNTMG:	MOVEM	0,$PMG0#
	SKIPN	MARGIN		;ANY MARGIN SETTING ?
	JRST	@$PMG0		;NO
	MOVEM	1,$PMG1#
	MOVEI	[ASCIZ/
MARGIN WORD = /]
	PNTAL
	MOVE	0,MARGIN
	PNTHW			;PRINT MARGIN WORD
	MOVE	MARGIN
	TRNN	0,37		;ANY MARGIN VOLTAGE SETTING ?
	JRST	$PTMG1		;NO
	MOVEI	[ASCIZ/, BAY /]
	PNTAL
	HLRZ	1,MARGIN
	LSH	1,-4
	ANDI	1,1
	MOVEI	"1"(1)
	PNTCHR			;PRINT BAY
	MOVEI	[ASCIZ/ ROW /]
	PNTAL
	HLRZ	1,MARGIN
	ANDI	1,17
	MOVEI	$ROW(1)
	PNTA
	MOVEI	[ASCIZ/ = /]
	PNTAL
	MOVE	MARGIN		;GET MARGIN VALUE
	ANDI	77
	SUBI	31		;COMPUTE DIFFERENCE FROM 5 VOLTS
	IMULI	^D21		; X 21MV PER STEP
	MOVN			;NEGATE FOR PROPER DIRECTION
	ADDI	^D5000		;ADD 5000 MVOLTS
	PNTDEC			;PRINT MARGIN VOLTAGE
	MOVEI	[ASCIZ/ MVOLTS/]
	PNTAL
$PTMG1:	MOVE	1,MARGIN	;SPEED MARGINS ?
	MOVEI	[ASCIZ/ , SPEED MARGINS
/]
	TRNN	1,ISPDON
	MOVEI	CRLF
	PNTAL
	MOVE	1,$PMG1
	JRST	@$PMG0
;ROW PRINTOUT CONSTANTS

$ROW:	ASCII	/A/
	ASCII	/B/
	ASCII	/C/
	ASCII	/D/
	ASCII	/E/
	ASCII	/F/
	ASCII	/H/
	ASCII	/J/
	ASCII	/K/
	ASCII	/L/
	ASCII	/M/
	ASCII	/N/
	ASCII	/P/
	ASCII	/R/
	ASCII	/S/
	ASCII	/T/
	0
>
	XLIST
	IFDEF	MEMMAP,<LIST
SUBTTL	*SUBRTN* MEMORY MAPPING SUBROUTINE, V73H, DEC 5, 1973
 
;DETERMINE MEMORY SIZE AND PRINT MEMORY MAP

$MEMMP:	MOVEM	0,$ACB0
	SKIPN	USER		;EXEC MODE ?
	IFNDEF	EXCASB,<FATAL>
	IFDEF	EXCASB,<
	JRST	$MEMEX		;YES >
	IFNDEF	USRASB,<FATAL>
	IFDEF	USRASB,<
$USRMP:	SETZM	MEMSIZ		;USER MEMORY STARTS AT 0
	HRRZ	JOBREL		;GET HIGHEST REL ADR
	MOVEM	MEMSIZ+1	;SAVE AS MEMORY SIZE
	SETOM	MEMSIZ+2	;FLAG END OF MEMSIZ TABLE
	SETZM	MAPNEW
	MOVEI	2,1		;FLAG PMAP FOR ONLY 1 SEG
	JRST	$PMAP		;GO PRINT	>
	XLIST
	IFDEF	EXCASB,<LIST
;EXEC MODE MEMORY MAPPING

$MEMEX:	SETZM	MEMSIZ		;CLEAR MAP STORAGE
	MOVE	[MEMSIZ,,MEMSIZ+1]
	BLT	MEMSIZ+^D40
	SKIPN	KAIFLG
	IFNDEF	KA10,<FATAL>
	IFDEF	KA10,<
	JRST	$MPOL1		;KA10, MAP 0-256K >
	IFNDEF	KI10,<FATAL>
	XLIST
	IFDEF	KI10,<LIST
	IFNDEF	INHPAG,<INHPAG==0>

$MEMKI:	MOVEI	0,77777
	SKIPN	MONFLG		;SPECIAL USER MODE ?
	JRST	$MPOL1+1	;YES, USE UPMP & ONLY 32K
	MOVEI	0,337777
	MOVE	1,CONSW
	TDNE	1,[INHPAG]	;PAGING INHIBITED ?
	JRST	$MPOL1+1	;YES, USE UNPAGED MEM, 0-112K

	MOVSI	1,-20		;SETUP EXEC-PER-PROCESS MAP
	MOVE	[740336,,740337]
	ADD	[2,,2]		;SO 112K-128K POINTS TO ITSELF
	MOVEM	400(1)		;VIRTUAL = PHYSICAL
	AOBJN	1,.-2
	MOVSI	(JFCL)		;SETUP ARITHMETIC TRAP
	MOVEM	421		;JUST IN CASE
	SKIPE	MAPNEW
	JRST	$MPNEW		;USE 4096K MAPPING
	JRST	$MPOLD		;USE 256K MAPPING >
	LIST
;MEMORY MAPPING CONTROL
;MAP 4096K, 256K, 112K OR 32K SPECIAL USER

	XLIST
	IFDEF	KI10,<LIST
$MPNEW:	MOVE	1,JOBFF		;USE FIRST FREE UP TEMP
	MOVEI	16,^D31		;4096K IS 32 128K CHUNKS
	MOVE	0,16
	MAPSET			;SET PAGE MAP FOR 128K CHUNK
	MOVE	[400000,,777777]
	MAPCNK			;MAP 128K-256K VIRTUAL
	SOJGE	16,.-4		;COMPLETED 4096K ?
	JRST	$MPCMB		;YES, COMBINE POINTERS

$MPOLD:	MOVSI	1,-200		;128K-256K VIRTUAL POINTS
	MOVE	[740376,,740377] ;TO PHYSICAL 128K-256K
	ADD	[2,,2]		;AND MEMORY ENDS AT 256K
	MOVEM	200(1)
	AOBJN	1,.-2
	DATAO	PAG,[LDEXCB!TRPENB] >
	LIST
$MPOL1:	MOVEI	0,777777	;MAP 0-256K
	MOVE	1,JOBFF		;USE FIRST FREE UP TEMP
	SETZM	MAPNEW		;DIRECT ADDRESSING ONLY
	MAPCNK			;MAP CHUNK
	JRST	$MPCMB		;COMBINE POINTERS

;COMBINE CHUNKS PUTTING POINTERS IN MEMSIZ TABLE

$MPCMB:	SETZM	2		;SETUP MEMSIZ TABLE POINTER
	SUBI	1,1		;DECREMENT TEMP POINTER
	MOVE	(1)		;GET LOWEST ADR OF LOWEST CHUNK
	CAIE	0,0		;SHOULD BE 0 AS THATS WHERE
	FATAL			;MEMORY STARTS
	MOVEM	MEMSIZ(2)	;PUT IN MEMSIZ TABLE
	ADDI	2,1
$MPCM1:	SUBI	1,1
	CAIG	1,@JOBFF	;COMBINED ALL CHUNK POINTERS ?
	JRST	$MPCM2		;YES
	MOVE	(1)		;GET CHUNK END ADDRESS
	MOVE	3,-1(1)		;GET NEXT CHUNK START ADR
	MOVE	4,0		;INC END ADR
	ADDI	4,1		;IF END & START NOW EQUAL
	CAMN	3,4		;IT IS A CONTINUOUS CHUNK
	SOJA	1,$MPCM1
	MOVEM	0,MEMSIZ(2)	;IF NOT =, SAVE CHUNK END ADR
	CAIL	2,^D38		;HAVE WE FILLED MEMSIZ TABLE ?
	JRST	$MPCMX		;YES, IGNORE REST OF CHUNKS
	ADDI	2,1
	MOVEM	3,MEMSIZ(2)	;AND NEXT CHUNK START ADR
	SOJA	1,$MPCM1-1
;	"MAPCNK"
;MEMORY CHUNK MAPPER

$MPCN1:	MOVEM	2,$ACMP1#
	MOVEM	3,$ACMP2#
	MOVEM	4,$ACMP3#
	HRRZ	2,0		;ADDRESSER
	HLRZ	3,0		;BOTTOM OF CHUNK ADDRESS
	CONI	PI,$MSPI#
	CONO	PI,PIOFF	;TURN OFF INTERRUPTS
	CONI	APR,$MSAPR#
	CAMG	2,3		;END GREATER THAN START ?
	FATAL			;NO
	MOVEI	4,ANXM
	SKIPE	KAIFLG		;SET KA/KI NXM BITS
	MOVEI	4,INXM

$M1:	CONO	APR,(4)		;NON-X-MEMORY MAP
	CAM	(2)		;INTERLEAVE MAP
	CAM	-1(2)		;IF NON-X-MEM FROM ANY 4-WAY INTERLEAVE
	CAM	-2(2)		;MARK ALL NON-X
	CAM	-3(2)
	CONSO	APR,(4)		;NON-X-MEMORY ?
	JRST	$M5		;NO
	CONO	APR,(4)
$M2:	SUBI	2,1000		;STEP DOWN A PAGE
	CAIL	2,(3)		;MEMORY CHUNK DONE ?
	JRST	$M1		;NO
	HRRZ	3,$MSAPR
	SKIPN	KAIFLG
	TRZ	3,775550	;KA10
	SKIPE	KAIFLG
	TRZ	3,720700	;KI10
	CONO	APR,(3)		;RESET APR
	MOVE	3,$MSPI
	TRNE	3,PION		;IF INTERRUPTS WERE ON
	CONO	PI,PION		;TURN BACK ON
	MOVE	2,$ACMP1
	MOVE	3,$ACMP2
	MOVE	4,$ACMP3
	JRST	@$MPCNK

$M3:	CAM	(2)		;EXISTANT MEMORY MAPPER
	CAM	-1(2)
	CAM	-2(2)
	CAM	-3(2)
	CONSZ	APR,(4)		;EXISTANT ?
	AOJA	2,$M6		;NO
$M4:	SUBI	2,1000		;YES, STEP DOWN A PAGE
	CAIL	2,(3)		;BELOW START ADDRESS ?
	JRST	$M3		;NO
	AOJA	2,$M7		;YES, THIS CHUNK DONE
;SAVE POINTERS TO TOP AND BOTTOM OF EXISTANT CHUNKS
;TEMPORY STORAGE POINTER IN AC1
;VIRTUAL ADDRESS IN AC0
;"MAPADR" CONVERTS TO ACTUAL PHYSICAL ADDRESS

$M5:	MOVE	0,2		;TOP OF EXISTANT CHUNK
	MAPADR			;CONVERT VIRTUAL TO PHYSICAL
	FATAL
	MOVEM	(1)		;SAVE IN TEMP
	AOJA	1,$M3		;GO MAP EXISTANT CHUNK

$M6:	MOVE	0,2		;BOTTOM OF EXISTANT CHUNK
	MAPADR
	FATAL
	MOVEM	(1)
	ADDI	1,1
	SOJA	2,$M1		;GO MAP NON-X CHUNK

$M7:	MOVE	0,2		;BOTTOM OF REQUESTED CHUNK
	MAPADR
	FATAL
	MOVEM	(1)
	AOJA	1,$M2+3		;RESTORE AC'S AND RETURN

;LAST PORTION OF COMBINE CHUNK POINTERS

$MPCM2:	MOVE	(1)
	MOVEM	MEMSIZ(2)	;SAVE LAST ADR OF LAST CHUNK
	SETOM	MEMSIZ+1(2)	;FLAG END OF TABLE
	JRST	$PMAP

$MPCMX:	SETOM	MEMSIZ+1(2)
	MOVEI	[ASCIZ/
MAP ERROR, TOO MANY SEGMENTS FOR MAP TABLE
/]
	PNTALF
	JRST	$PMAP

	XLIST
	IFDEF	KI10,<LIST
;	"MAPSET"
;SETUP KI10 PAGE MAP FOR VIRTUAL TO PHYSICAL ADDRESS TRANSLATION
;ARGUMENTS PASSED IN AC0
;NEG - CLEAR PAGE MAP
;0-37 - MAP CORRESPONDING 128K SEGMENT

$MPSE1:	SKIPE	USER
	JRST	@$MPSET
	MOVEM	1,$ACMP4#
	JUMPGE	0,$MPSE2	;ARG NEG ?
	SETZM	200		;YES, CLEAR PAGE MAP
	MOVE	0,[200,,201]
	BLT	0,377

$MPSE3:	SKIPE	KAIFLG
	DATAO	PAG,[LDEXCB!TRPENB] ;CLEAR ASSOC MEMORY
	MOVE	1,$ACMP4
	JRST	@$MPSET

$MPSE2:	CAIL	0,40		;ARG 0-37 ?
	FATAL			;NO, FATAL ERROR
	IMULI	0,400		;COMPUTE PHYSICAL RELOCATION
	TRO	0,740000	;SET A,P,W,S BITS
	HRL	0,0		;MAKE BOTH HALVES SAME
	ADDI	0,1		;RIGHT HALF ODD PAGE
	MOVSI	1,-200		;128K IN PAGE MAP
	MOVEM	200(1)		;PUT RELOCATION DATA IN PAGE MAP
	ADD	[2,,2]		;BUMP FOR NEXT ENTRY
	AOBJN	1,.-2
	JRST	$MPSE3		;CLEAR ASSOC MEMORY & EXIT
>>
	LIST
;	"MEMSEG"
;## MAPNEW = -1 ##
;SETS UP TO 128K SEGMENT IN PAGE MAP
;ARGUMENTS	0-37 - MAP CORRESPONDING 128K SEGMENT
;		GT 37  - MAP USING PHYSICAL ADDRESS
;RETURNED IN AC0
;	0 - NO MEMORY AVAILABLE
;	HIGHEST VIRTUAL ADDRESS
;	  BIT 0 SET IF NON-CONSECUTIVE CORE WAS COMBINED
;PAGE MAP SET UP SO VIRTUAL ADDRESS 400000 AND UP POINTS
;TO MEMORY REQUESTED.
;RETURNS +2

$MSEG1:	MOVEM	1,$ACMP5#	;AC1 = TEMP STORAGE POINTER
	MOVEM	2,$ACMP6#	;AC2 = MAP STORAGE POINTER
	MOVEM	3,$ACMP7#	;AC3 = CHUNK START ADR
	MOVEM	4,$ACMP8#	;AC4 = CHUNK END ADR
	MOVEM 	5,$ACMP9#	;AC5 = PAGE COUNTER
	SETZB	5,$MNCON#
	TLNE	0,777760	;VALID ARGUMENT ?
	FATAL			;NO
	SKIPE	USER
	JRST	$MSUSR		;USER MODE
	SKIPN	MAPNEW
	JRST	$MSKA		;DIRECT ADDRESSING ONLY
	MOVE	2,[POINT 18,200]
	CAIL	0,40
	JRST	$MSEGP		;ARG IS FOR PHYSICAL CORE

;SETUP MAP FOR REQUESTED 128K SEGMENT

$MSEGV:	MOVE	1,MEMLOW
	MAPSET			;SETUP MAP FOR REQ SEGMENT
	MOVE	[400000,,777777]
	MAPCNK			;MAP THAT SEGMENT

$MSGV1:	CAIG	1,@MEMLOW
	JRST	$MSEG3		;NO CORE IN THIS 128K SEGMENT
	SETZM	200		;CLEAR PAGE MAP
	MOVE	[200,,201]
	BLT	0,377
$MSGV2:	SUBI	1,1
	MOVE	3,(1)		;GET CHUNK START ADDRESS
	JUMPN	3,.+2		;IF CHUNK ADR IS ZERO
	MOVE	3,MEMLOW	;USE EVEN BREAK ABOVE JOBFF
	SUBI	1,1
	MOVE	4,(1)		;GET CHUNK END ADDRESS
	CAMG	4,3		;END GREATER THAN START ?
	FATAL			;NO
	SUB	4,3		;END - START = SIZE OF CHUNK
	ADDI	4,1
	TRNE	4,777		;CHUNK SHOULD BE EVEN # OF PAGES
	FATAL
	LSH	4,-^D9		;COMPUTE # OF PAGES
	ADD	5,4		;KEEP COUNT
	LSH	3,-^D9
	TRO	3,740000	;CREATE RELOCATION DATA
	SOJL	4,.+4
	IDPB	3,2		;PUT IN PAGE MAP
	ADDI	3,1		;INCREMENT RELOCATION DATA
	JRST	.-3

	CAIN	1,@MEMLOW	;ANY MORE CHUNKS IN THIS 128K ?
	JRST	$MSEG2		;NO
	SETOM	$MNCON		;YES, NON-CONSECUTIVE CHUNKS
	JRST	$MSGV2		;PACK INTO VIRTUAL

$MSEG2:	IMULI	5,1000		;CONVERT # OF PAGES INTO
	ADDI	5,377777	;HIGHEST VIRTUAL ADDRESS
	SKIPE	$MNCON		;WERE CHUNKS COMBINED ?
	TLO	5,400000	;YES, SET BIT 0 AS FLAG

$MSEG3:	MOVE	0,5		;AC0 = HIGHEST VIRTUAL ADDRESS
	MOVE	1,$ACMP5	;OR 0 - NO CORE
	MOVE	2,$ACMP6	;BIT 0 SET IF VIRTUAL IS
	MOVE	3,$ACMP7	;NON-CONSECUTIVE
	MOVE	4,$ACMP8
	MOVE	5,$ACMP9
	SKIPN	MAPNEW
	JRST	@$MSEG
	DATAO	PAG,[LDEXCB!TRPENB] ;CLEAR ASSOC MEMORY
	AOS	$MSEG
	JRST	@$MSEG		;RETURN +2
;PHYSICAL CORE ASSIGNMENT

$MSEGP:	MOVE	1,0
	TRZ	1,777		;MAKE PHYSICAL EVEN PAGE
	SETZ	4,
	MOVE	MEMSIZ(4)	;GET START ADDRESS
	JUMPL	$MSEG3		;IF END OF TABLE, NO CORE
	CAMGE	1,0		;PHY = OR GT START ?
	JRST	$MSEG3		;NO, NO CORE
	MOVE	MEMSIZ+1(4)	;GET END ADDRESS
	ADDI	4,2
	CAML	1,0		;PHY GT END ?
	JRST	.-7		;YES, TRY NEXT CHUNK

	SKIPN	MAPNEW
	JRST	$MSKAP+3	;DIRECT ADDRESSING
	SUB	0,1		;COMPUTE # OF PAGES
	ADDI	0,1
	LSH	0,-^D9
	CAILE	0,^D256		;MORE THAN 128K WORTH ?
	MOVEI	0,^D256		;YES, LIMIT AT 128K
	MOVEM	0,3		;AC3 = MAP FILL COUNTER
	MOVEM	0,5		;KEEP COUNT OF # OF PAGES
	SETZM	200		;CLEAR PAGE MAP
	MOVE	[200,,201]
	BLT	0,377
	MOVE	0,1
	LSH	0,-^D9		;CREATE RELOCATION DATA
	TRO	0,740000
	SOJL	3,$MSEG2
	IDPB	0,2		;PUT DATA IN PAGE MAP
	ADDI	0,1		;INCREMENT RELOCATION DATA
	JRST	.-3
;	"MEMSEG"
;## MAPNEW = 0 ##
;ARGUMENTS 0-10 - SETUP CORRESPONDING CHUNK FROM MEMSIZ TABLE
;		   11-37 RETURN 0, MAXIMUM OF 8 CHUNKS IN 256K
;	           USER MODE, 1-37 ALWAYS RETURNS 0
;	  GT 37 - RETURNS MEMORY AT PHYSICAL ADDRESS
;RETURNED IN AC0
;	0 - NO MEMORY AVAILABLE
;	START ADDRESS,,END ADDRESS
;RETURNS +1

$MSKA:	CAIL	0,40
	JRST	$MSKAP		;DIRECT PHYSICAL CORE
	CAIL	^D9
	JRST	$MSEG3		;NO MEMORY 11-37
	MOVE	1,0
	LSH	1,1		;DOUBLE, 2 ENTRIES PER
	MOVE	0,MEMSIZ(1)	;GET START ADDRESS
	JUMPL	0,$MSEG3	;NO MEMORY
	MOVE	2,MEMSIZ+1(1)	;GET END ADDRESS
	JUMPE	2,$MSEG3	;NO MEMORY
	JUMPN	0,.+2		;IF START ADDRESS IS 0
	MOVE	0,MEMLOW	;USE 'MEMLOW'
	CAMG	2,0		;END GREATER THAN START ?
	FATAL			;NO
	MOVE	5,2		;SETUP START ADR,,END ADR
	HRL	5,0
	JRST	$MSEG3

$MSKAP:	CAILE	0,777000	;REQUEST FOR OVER 256K ?
	JRST	$MSEG3		;YES, NO MEMORY
	JRST	$MSEGP		;DO PHYSICAL SETUP

	MOVE	5,0		;1 = PHY ADR, 0 = END ADR
	HRL	5,1		;  START ADR,,END ADR
	JRST	$MSEG3

$MSUSR:	JUMPE	0,$MSKA		;USER MODE, SEGMENT 0 ONLY
	CAIL	0,40		;IF 1-37 NO MEMORY
	JRST	$MSKAP		;PHY, DO DIRECT PHYSICAL
	JRST	$MSEG3
;	"MEMZRO"
;ZERO'S MEMORY FROM MEMLOW UP TO MAXIMUM
;MAPNEW = 0, DIRECT MEMORY ZERO
;	 -1, 4096K KI10 PAGED MEMORY ZERO

$MZRO:	MOVEM	0,$MZROA#
	MOVEM	1,$MZROB#
	MOVEM	2,$MZROC#
	SKIPN	MAPNEW		;4096K PAGED OR DIRECT ZERO ?
	JRST	$MZRO2		;DIRECT
	IFDEF	KI10,<
$MZRO1:	SETO	2,		;PAGED ZERO
	ADDI	2,1
	CAILE	2,37
	JRST	$MZROX		;DONE
	MOVE	0,2
	MEMSEG			;SETUP MEMORY SEGMENT
	FATAL
	JUMPE	0,$MZRO1+1	;NO MEMORY THIS SEGMENT
	TLZ	0,400000	;DON'T CARE IF COMBINED
	SETZM	400000
	MOVE	1,[400000,,400001]
	BLT	1,@0		;ZERO VIRTUAL
	JRST	$MZRO1+1
>
$MZRO2:	SETZ	2,		;DIRECT MEMORY ZERO
	MOVE	0,MEMLOW	;START ADDRESS
	CAML	0,MEMSIZ+1
	JRST	$MZROX
	JRST	.+3
	MOVE	0,MEMSIZ(2)	;SEGMENT START ADDRESS
	JUMPL	0,$MZROX	;DONE
	SETZM	@0
	HRLS			;CREATE BLT POINTER
	ADDI	1
	BLT	0,@MEMSIZ+1(2)	;ZERO DIRECT
	ADDI	2,2
	JRST	$MZRO2+5

$MZROX:	MOVE	2,$MZROC
	MOVE	1,$MZROB
	JRST	@$MZROA
;	"MAPADR"
;CONVERT VIRTUAL ADDRESS TO PHYSICAL ADDRESS
;VIRTUAL ADDRESS IN AC0
;PHYSICAL ADDRESS RETURNED IN AC0
;SKIP RETURN IS NORMAL
;NON-SKIP RETURN IS KI10 PAGE INACCESSIBLE

$MPAD1:	MOVEM	1,$ACMP0#
	HRRZ	1,0		;18 BIT VIRTUAL ADR IN AC1
	CAIG	1,17		;ACCUMULATOR ADDRESS ?
	JRST	$MPAD3-1	;YES
	SKIPN	KAIFLG		;DETERMINE PROCESSOR
	JRST	$MPAD2		;KA10
	MAP	0,(1)		;KI10, GET RELOCATION DATA
	TRNE	0,400000	;PAGE FAILURE ?
	JRST	$MPAD4		;YES, SEE IF VALID ANYWAY
$MPAD5:	TRZ	0,760000	;CLEAR P,W,S, NO MATCH BITS
	LSH	0,^D9		;HI-ORDER 13 FROM MAP
	ANDI	1,777		;LOW-ORDER 9 FROM VIRTUAL
	OR	0,1		;COMBINE
	AOS	$MPADR		;SKIP RETURN
$MPAD3:	MOVE	1,$ACMP0
	JRST	@$MPADR

$MPAD4:	TRNE	0,20000		;PAGE FAILURE, ALSO NO MATCH ?
	JRST	$MPAD3		;YES, ERROR RETURN
	JRST	$MPAD5		;MATCH, RELOCATION VALID

$MPAD2:	MOVE	0,1		;KA10
	SKIPN	USER		;IN USER MODE ?
	JRST	$MPAD3-1	;NO, VIRTUAL IS PHYSICAL ADR
	HRROI	1		;RELOCATION TABLE
	CALLI	41		;GETTAB
	SETZ			;ERROR
	HRRZ			;RELOCATION ONLY
	ADD	0,1		;RELOC + VIRTUAL = PHYSICAL
	JRST	$MPAD3-1
;PRINT MEMORY MAP

$PMAP:	SETZ	4,
	SKIPL	MONCTL		;UNDER DIAGNOSTIC MONITOR ?
	JRST	$PMAP3		;NO
	SKIPE	USER		;USER MODE ?
	JRST	$PMAP1		;YES
	HLRZ	MONCTL		;FIRST PASS ?
	CAIE	-1
	JRST	$PMAP1		;NO
$PMAP3:	SKIPN	$ONETM		;FIRST TIME ?
	SETO	4,		;YES, SET FLAG FOR PRINTING
$PMAP1:	JUMPE	4,$PMAPL-1
	MOVEI	[ASCIZ?
MEMORY MAP =
FROM     TO      	SIZE/K?]
	PNTAL
	CAIN	2,1		;IF (2) = 1, ONLY ONE SEGMENT
	JRST	.+3
	MOVEI	[ASCIZ?	START ADR/K?]
	PNTAL
	MOVEI	CRLF
	PNTAL
	SETZB	3,5
$PMAPL:	SKIPGE	MEMSIZ(3)	;GET MAP COORDINATES
	JRST	$PMAP4
	JUMPE	4,.+7
	MOVE	MEMSIZ(3)
	PNTADR			;PRINT START ADDRESS
	MOVE	MEMSIZ+1(3)
	PNTADR			;PRINT END ADDRESS
	MOVEI	TAB
	PNTA
	MOVE	MEMSIZ+1(3)
	ADDI	0,1
	SUB	MEMSIZ(3)
	IDIVI	^D1024
	ADD	5,0
	JUMPE	4,$PMAP5
	PNTDEC			;PRINT DECIMAL SIZE
	CAIN	2,1
	JRST	.+6
	MOVEI	TAB
	PNTA
	MOVE	MEMSIZ(3)
	IDIVI	^D1024
	PNTDEC			;PRINT START ADR IN K
	MOVEI	CRLF
	PNTAL
$PMAP5:	ADDI	3,2
	JRST	$PMAPL		;GET NEXT IF ANY
$PMAP4:	MOVEM	5,MEMTOT	;SAVE TOTAL # OF K
	HRRZ	JOBFF		;SETUP LOWEST USABLE
	ADDI	1000		;MEMORY ADDRESS
	TRZ	777		;EVEN BREAK ABOVE JOBFF
	MOVEM	MEMLOW
	JUMPE	4,@$ACB0
	CAIN	2,1
	JRST	.+7
	MOVEI	[ASCIZ?TOTAL MEMORY/K = ?]
	PNTAL
	MOVE	MEMTOT
	PNTDEC
	MOVEI	CRLF
	PNTA
	MOVEI	CRLF
	PNTA
	JRST	@$ACB0
>
	XLIST
	IFDEF	MODDVC,<LIST
SUBTTL	*SUBRTN* DEVICE CODE CHANGE SUBROUTINE, V73G, NOV 12, 1973

$MODDV:	MOVEM	0,$MODDA#
	SWITCH
	TDNN	0,[MODDVC]	;DEVICE CODE CHANGE SELECTED ?
	JRST	@$MODDA		;NO
	MOVEM	1,$MODDB#
	MOVEM	2,$MODDC#
	MOVEM	3,$MODDD#
$MODD1:	MOVEI	[ASCIZ/
CHANGE DEVICE CODES,/]
	PNTALF
	TTIYES
	JRST	$MODDX		;NO MORE CHANGES
$MODD3:	MOVEI	[ASCIZ/
DEVICE CODE TO BE CHANGED - /]
	PNTALF
	JSP	3,$MODD2	;GET OLD DEVICE CODE
	JRST	.-3		;NO RESPONSE
	MOVEM	0,$MDVCO#
	MOVEI	[ASCIZ/NEW DEVICE CODE - /]
	PNTALF
	JSP	3,$MODD2	;GET NEW DEVICE CODE
	JRST	.-3		;NO RESPONSE
	MOVEM	0,$MDVCN#
	MOVEI	[ASCIZ/
CHANGING FROM DEVICE CODE /]
	PNTALF
	MOVE	1,$MDVCO	;OLD CODE
	JSP	3,$MDSRC	;GET CODE OUT OF LIST
	MOVEI	[ASCIZ/TO DEVICE CODE /]
	PNTALF
	MOVE	1,$MDVCN	;GET NEW CODE FROM LIST
	JSP	3,$MDSRC
	MOVEI	[ASCIZ/
VALID CHANGE,/]
	PNTALF
	TTIYES
	JRST	$MODD1		;TRY ANOTHER
	MOVE	2,[MODDVL-MODDVU,,MODDVL]
	MOVE	1,$MDVCN
	LDB	0,[POINT 10,(2),9] ;GET IOT & DEVICE CODE
	CAMN	0,$MDVCO	;IS IT REQUESTED ONE ?
	DPB	1,[POINT 10,(2),9] ;YES, MAKE NEW
	AOBJN	2,.-3
	JRST	$MODD1
$MODDX:	MOVE	3,$MODDD
	MOVE	2,$MODDC	;EXIT
	MOVE	1,$MODDB
	JRST	@$MODDA
$MODD2:	TTIOCT
	JRST	@3
	TRNE	0,3		;MUST END IN 0 OR 4
	JRST	$MODER		;ERROR!
	CAIG	0,774		;IS DEVICE CODE IN PROPER RANGE
	CAIGE	0,14
	JRST	$MODER		;ERROR, 14 TO 774 ONLY
	CAIE	0,100
	CAIN	0,104
	JRST	$MODER
	CAIN	0,120		;CTY, PTR & PTP MAY NOT CHANGE!
	JRST	$MODER
	TRO	0,7000		;INSERT IOT CODE
	LSH	0,-2		;POSITION
	AOS	3		;RETURN +2
	JRST	@3

$MDSRC:	LSH	1,2		;POSITION FOR COMPARE
	TRZ	1,7000		;MASK IOT
	MOVE	2,[-$MDEND,,$MDLST]
	LDB	[POINT 9,(2),35] ;EXTRACT CODE FROM LIST
	CAMN	0,1		;IS THIS THE ONE?
	JRST	.+7		;YES!
	AOBJN	2,.-3
	MOVE	0,1
	PNT3F
	MOVEI	CRLF
	PNTALF
	JRST	@3
	MOVE	0,(2)
	TRZ	0,777		;MASK CODE
	PNTSXF
	JRST	.-6

$MODER:	MOVEI	[ASCIZ/
DEVICE CODE ERROR,
14 TO 774 (ENDING IN 0 OR 4) ONLY AND NOT CTY, PTR OR PTP
/]
	PNTALF
	JRST	$MODD3
>
	XLIST
	IFDEF	UUOS,<LIST
SUBTTL	*SUBRTN* UUO HANDLING SUBROUTINE, V73G, NOV 12, 1973

$UORTN:	SKIPE	$UOREC#		;A RECURSIVE UUO ?
	JRST	$UUOER		;YES, ILLEGAL
	SETOM	$UOREC		;SET DOING UUO FLAG
	MOVEM	0,$UOAC0#	;SAVE AC0
	MOVE	UUORTN
	MOVEM	$SVUPC#
	MOVE	JOBUUO
	MOVEM	$SVUUO#
	LSH	-^D27
	CAILE	37		;UUO IN CORRECT RANGE ?
	JRST	$UUOER		;NO
	ADD	[JRST @UUODIS]
	MOVEM	$UUOGO
	MOVE	$UOAC0
	IFDEF	PSHLST,<
	PUSH	P,UUORTN	;MAKE RECURSIVE
	SETZM	$UOREC	>
	JRST	$UUOGO

;UUO EXIT ROUTINE

UUOSKP:	AOS	UUORTN		;SKIP RETURN, +2
	IFDEF	PSHLST,<
	AOS	(P)	>

UUOEXT:	SETZM	$UOREC		;CLEAR DOING UUO FLAG
	IFDEF	PSHLST,<
	RTN		>
	JRST	2,@UUORTN	;RESTORE FLAGS AND EXIT
;ILLEGAL OR UNCODED UUO ROUTINE

$UUOER:	PNTNM
	MOVEI	[ASCIZ/
ILLEGAL UUO EXECUTED
UUO            FLAGS      PC    PROG
/]
	PNTALF			;PRINT HEADER
	MOVE	$SVUUO
	PNTHWF			;PRINT UUO
	MOVEI	SPACE
	PNTAF
	MOVE	$SVUPC
	SOS
	PNTHWF			;PRINT FLAGS, PC
	IFDEF	PSHLST,<
	MOVEI	SPACE
	PNTAF
	HRRZ	0,(P)
	SUBI	0,1
	PNT6F			;PRINT LAST PUSHJ ENTRY>
	MOVEI	CRLF2
	PNTAF
$UORTX:	JRST	.+1		;TO ADD ROUTINE, PLACE JRST HERE
	FATAL
;UUO DISPATCH TABLE

UUODIS:	$UUOER			;ILL UUO, 0
	IFDEF LUUO1,<LUUO1>	IFNDEF LUUO1,<$UUOER>	;UUO 1
	IFDEF LUUO2,<LUUO2>	IFNDEF LUUO2,<$UUOER>	;UUO 2
	IFDEF LUUO3,<LUUO3>	IFNDEF LUUO3,<$UUOER>	;UUO 3
	IFDEF LUUO4,<LUUO4>	IFNDEF LUUO4,<$UUOER>	;UUO 4
	IFDEF LUUO5,<LUUO5>	IFNDEF LUUO5,<$UUOER>	;UUO 5
	IFDEF LUUO6,<LUUO6>	IFNDEF LUUO6,<$UUOER>	;UUO 6
	IFDEF LUUO7,<LUUO7>	IFNDEF LUUO7,<$UUOER>	;UUO 7
	IFDEF LUUO10,<LUUO10>	IFNDEF LUUO10,<$UUOER>	;UUO 10
	IFDEF LUUO11,<LUUO11>	IFNDEF LUUO11,<$UUOER>	;UUO 11
	IFDEF LUUO12,<LUUO12>	IFNDEF LUUO12,<$UUOER>	;UUO 12
	IFDEF LUUO13,<LUUO13>	IFNDEF LUUO13,<$UUOER>	;UUO 13
	IFDEF LUUO14,<LUUO14>	IFNDEF LUUO14,<$UUOER>	;UUO 14
	IFDEF LUUO15,<LUUO15>	IFNDEF LUUO15,<$UUOER>	;UUO 15
	IFDEF LUUO16,<LUUO16>	IFNDEF LUUO16,<$UUOER>	;UUO 16
	IFDEF LUUO17,<LUUO17>	IFNDEF LUUO17,<$UUOER>	;UUO 17
	IFDEF LUUO20,<LUUO20>	IFNDEF LUUO20,<$UUOER>	;UUO 20
	IFDEF LUUO21,<LUUO21>	IFNDEF LUUO21,<$UUOER>	;UUO 21
	IFDEF LUUO22,<LUUO22>	IFNDEF LUUO22,<$UUOER>	;UUO 22
	IFDEF LUUO23,<LUUO23>	IFNDEF LUUO23,<$UUOER>	;UUO 23
	IFDEF LUUO24,<LUUO24>	IFNDEF LUUO24,<$UUOER>	;UUO 24
	IFDEF LUUO25,<LUUO25>	IFNDEF LUUO25,<$UUOER>	;UUO 25
	IFDEF LUUO26,<LUUO26>	IFNDEF LUUO26,<$UUOER>	;UUO 26
	IFDEF LUUO27,<LUUO27>	IFNDEF LUUO27,<$UUOER>	;UUO 27
	IFDEF LUUO30,<LUUO30>	IFNDEF LUUO30,<$UUOER>	;UUO 30
	IFDEF LUUO31,<LUUO31>	IFNDEF LUUO31,<$UUOER>	;UUO 31
	IFDEF LUUO32,<LUUO32>	IFNDEF LUUO32,<$UUOER>	;UUO 32
	IFDEF LUUO33,<LUUO33>	IFNDEF LUUO33,<$UUOER>	;UUO 33
	IFDEF LUUO34,<LUUO34>	IFNDEF LUUO34,<$UUOER>	;UUO 34
	IFDEF LUUO35,<LUUO35>	IFNDEF LUUO35,<$UUOER>	;UUO 35
	IFDEF LUUO36,<LUUO36>	IFNDEF LUUO36,<$UUOER>	;UUO 36
	IFDEF LUUO37,<LUUO37>	IFNDEF LUUO37,<$UUOER>	;UUO 37


;UUO INITIALIZATION

$UUOIN:	MOVEM	0,$ACB0
	MOVE	[JSR	UUORTN]
	MOVEM	JOB41		;SETUP UUO TRAP
	SETZM	$UOREC
	JRST	@$ACB0

>

	XLIST
	IFDEF	TOGGLE,<LIST
SUBTTL	*SUBRTN* CONSOLE DATA SWITCH INPUT SUBROUTINE, V73G, NOV 12, 1973

;INPUT CONSOLE SWITCHES IN EXEC MODE OR IN USER MODE IF NON-TTY SWITCH CONTROL

$SWTCH:	MOVEM	0,$SACA0#
	SKIPN	$SWFLG		;BEEN INITED ?
	JRST	$SWUSR+4	;NOT YET
	SKIPE	USER		;EXEC MODE ?
	JRST	$SWUSR		;NO, USER MODE INPUT
	DATAI	0,0		;EXEC MODE,READ SWITCHES
	SKIPGE	MONCTL		;MONITR CONTROL ?
	HRR	0,MONCTL	;YES, USE PRESTORED RH SWITCHES
	MOVEM	0,CONSW		;SAVE
	JRST	@$SACA0

$SWUSR:	SKIPE	$USWTF#		;USER MODE, TTY SWITCH CONTROL ?
	JRST	.+3		;YES, RETURN
	CALLI	20		;READ CONSOLE DATA SWITCHES
	MOVEM	0,CONSW		;SAVE
	MOVE	0,CONSW
	JRST	@$SACA0

;SWITCH INITIALIZATION ROUTINE

$SWTIN:	MOVEM	0,$ACB0#
	SETZM	$USWTF#		;CLEAR TTY CONTROL FLAG
	SKIPN	USER		;USER MODE ?
	JRST	$SWIN1		;NO, EXEC MODE
	IFNDEF	USRASB,<FATAL >
	IFDEF	USRASB,<JRST $SWINT >

$SWIN1:	SETOM	$SWFLG		;SET INITED FLAG
	SWITCH
	TLNN	PNTLPT		;PRINT ON LPT/LOGICAL DEVICE ?
	JRST	@$ACB0		;NO
	MOVEI	.+3
	MOVEM	$ACPN0
	JRST	$PNTNM+3	;PRINT PROGRAM NAME
	MOVEI	[ASCIZ/
DATA SWITCHES = /]
	PNTAL
	MOVE	CONSW
	PNTHW			;PRINT PRESENT SWITCH SETTINGS
	MOVEI	CRLF2
	PNTA
	JRST	@$ACB0

	XLIST
	IFDEF	USRASB,<LIST
;SWITCH USER MODE INITIALIZATION ROUTINE

$SWINT:	SKIPGE	MONCTL		;SYS EXERCISER MODE ?
	JRST	$SWIN2		;YES
$SW1:	MOVEI	[ASCIZ/
TELETYPE SWITCH CONTROL ? - 0,S,Y OR N <CR> - /]
	PNTALF			;ASK FOR SWITCH CONTROL MODE
	TTICHR
	JRST	$SW1
	LSH	0,7		;POSITION 1ST CHAR
	MOVEM	$SW#
	TTICHR
	JRST	$SW1
	OR	0,$SW
	MOVEM	0,$SW
	CAIN	0,14015		;"0" (CR)
	JRST	$SW5
	CAIN	0,24615		;"S" (CR)
	JRST	$SW6
	CAIN	0,26215		;"Y" (CR)
	JRST	$SW2
	CAIN	0,23415		;"N" (CR)
	JRST	$SWIN1
	CLRBFI			;ERROR, CLEAR TYPE-IN BUFFER
	JRST	$SW1

$SW6:	MOVE	0,$SVCSW	;"S", USE PREVIOUSLY SET SWITCHES
	JRST	$SW4

$SW2:	MOVEI	[ASCIZ/
SPECIFY LH SWITCHES IN OCTAL - /]
	PNTALF
	TTIOCT			;INPUT 6 OCTALS
	JRST	$SW2		;ERROR
	HRLZM	0,$SW#		;MOVE LH WORD TO SW
$SW3:	MOVEI	[ASCIZ/SPECIFY RH SWITCHES IN OCTAL - /]
	PNTALF
	TTIOCT			;INPUT 6 OCTALS
	JRST	$SW3		;ERROR
	HLL	0,$SW		;GET LH SWITCHES
$SW4:	MOVEM	0,CONSW		;SAVE SWITCHES IN CONSW
$SW5:	SETOM	$USWTF		;SET TTY INPUT SWITCH FLAG
	JRST	$SWIN1

$SWIN2:	MOVE	0,SWTEXR	;GET SYS EXER SWITCHES
	JRST	$SW4
>>
	XLIST
	IFDEF	TYPIN,<LIST
SUBTTL	*SUBRTN* TELETYPE INPUT SUBROUTINE, V74A, FEB 7, 1974
;CARRIAGE RETURN OR COMMA TERMINATES OCTAL, DECIMAL, OR CONVERT TYPE-IN.
;CHARACTER OR NUMBER RETURNED IN AC0.
;OPERATOR WAIT TIME (OPTIME) INITIALIZED
;AS NUMBER OF SECONDS OF WAIT TIME IN EXEC MODE.
;CALL SEQUENCE IS AS FOLLOWS:
;	JSP	NAME
;	NO/ERROR RESPONSE RETURN
;	NORMAL RESPONSE RETURN
;$OPTLK =	INPUT ANY CHARACTER
;$YESNO =	ASK QUESTION, CORRECT RESPONSE Y
;$NOYES =	ASK QUESTION, CORRECT RESPONSE N
;$TPOCT =	INPUT UP TO 12 OCTALS
;$TPDEC =	INPUT UP TO 11 DECIMALS
;$TPCNV =	INPUT UP TO 9 CONVERT'S
;$TTLK  =	KEYBOARD CHECK, INPUT ANY CHARACTER
;$TALTM =	KEYBOARD, ALT-MODE CHECK

;TELETYPE INPUT INITIALIZATION

$TYPIN:	MOVEM	0,$ACB0
	MOVEI	^D180
	MOVEM	OPTIME#		;INIT OPERATOR WAIT TIME AS 180 SEC.
	JRST	@$ACB0

;TELETYPE KEYBOARD CHECK ROUTINE
;CHECKS FOR ANY KEY STRUCK, RETURNS IMMEDIATELY
;RETURNS +1 IF NO TYPEIN, RETURNS +2 IF CHAR TYPED

$TTLK:	MOVEM	0,$TACA0
	SETZ	0,
	SKIPN	USER		;EXEC MODE ?
	JRST	$HEAR+3		;YES, GO CHECK AND INPUT
	SKIPGE	MONCTL		;NO CHECK IF MONITOR
	JRST	@$TACA0
$TTLK1:	INCHRS	$TTCHR
	JRST	@$TACA0		;NO CHAR
	JRST	$TTUSR+1	;CHAR WAS TYPED

;TELETYPE ALT-MODE CHECK ROUTINE

$TALTM:	MOVEM	0,$TALT0#
	TTLOOK
	JRST	$TALT1+1	;NO TYPE-IN
	CAIE	175
	CAIN	176
	JRST	$TALT1		;ALT-MODE
	CAIE	33
	JRST	.+2
$TALT1:	AOS	$TALT0		;ALT-MODE, RETURN + 2
	JRST	@$TALT0
;TELETYPE INPUT OPERATOR RESPONSE ROUTINE
;ALLOWS WAIT OF N SECONDS FOR TYPE-IN

$OPTLK:	MOVEM	0,$TACB0#
	MOVEM	4,$TACB4#	;SAVE AC
	MOVE	4,OPTIME	;MOVE WAIT COUNT INTO AC
	IMULI	4,147400	;1 SEC FUDGE FACTOR
	SOJLE	4,.+4		;WAITED TOO LONG YET ?
	JSP	$HEAR		;NO, INPUT FROM TTY
	JRST	.-2		;NO RESPONSE, REPEAT
	AOS	$TACB0		;CHAR TYPED, RETURN +2
	MOVEM	4,$TWCNT#	;SAVE THE TTY WAIT COUNT
	MOVE	4,$TACB4
	JRST	@$TACB0

;TELETYPE INPUT CHARACTER ROUTINE

$HEAR:	MOVEM	0,$TACA0#
	SKIPE	USER		;EXEC MODE ?
	JRST	$TTUSR		;NO..USER MODE INPUT
	IFDEF	EXCASB,<
	CONSO	TTY,40		;KEY BEEN STRUCK
	JRST	@$TACA0		;NO
	DATAI	TTY,0		;INPUT CHAR
	MOVEM	0,$TTCHR#	;SAVE ACTUAL CHARACTER
	TTYOUT			;ECHO
	AOS	$CARCT
	ANDI	0,177
	CAIN	0,003		;IS IT ^C ?
	JRST	$HEAR1		;YES, TERMINATE 
	CAIE	0,15		;IS IT CR ?
	JRST	$TTUSR+1	;NO
	SETZM	$CARCT
	MOVEI	0,12
	TTYOUT			;YES, ECHO LF >
	JRST	$TTUSR+1
;CHARACTER RETURNED IN AC0 IS UPPER CASE
;ACTUAL CHARACTER IN $TTCHR

$TTUSR:	INCHRW	$TTCHR#		;INPUT TTY, USER MODE
	MOVE	0,$TTCHR	;GET ACTUAL CHARACTER
	ANDI	0,177		;CLEAR PARITY BIT
	CAIL	0,"A"+40	;CONVERT TO UPPER CASE
	CAILE	0,"Z"+40
	JRST	.+2
	SUBI	0,40
	MOVEM	0,$CHRIN#	;SAVE CHARACTER
	CAIE	0,15		;IS IT CR ?
	JRST	$HEAR3		;NO
	SKIPE	USER		;USER MODE ?
	INCHRW			;YES, GET RID OF LF
	MOVE	0,CONSW
	TLNN	0,PNTLPT	;LPT/LOGICAL DEVICE OUTPUT ?
	JRST	$HEAR2		;NO
	MOVEI	CRLF
	PNTA			;YES, SEND INPUT TO IT
$HEAR2:	MOVE	0,$CHRIN	;PUT INPUT CHAR IN AC0
	AOS	$TACA0		;SKIP RETURN
	JRST	@$TACA0

$HEAR3:	MOVE	0,CONSW
	TLNN	0,PNTLPT
	JRST	$HEAR2
	MOVE	0,$CHRIN
	PNTCHR			;SEND CHAR TO LPT/LOGICAL DEV
	JRST	$HEAR2

	IFDEF	EXCASB,<
$HEAR1:	MOVEI	0,$HEAR+1	;CONTROL C, SAVE ENTRY TO 
	MOVEM	0,JOBOPC	;TTY ROUTINE FOR RESTART
	JRST	@CNTLC		;TERMINATE  >
;YES/NO TYPE-IN ROUTINE
;ACCEPTS Y OR N
;FOR YESNO, Y IS SKIP RETURN, N OR NO RESPONSE IS DIRECT RETURN
;FOR NOYES, N IS SKIP RETURN, Y OR NO RESPONSE IS DIRECT RETURN
;'Y OR N <CR> - ' ASKED UPON ENTRY

$NOYES:	MOVEM	0,$TACC0#
	MOVEI	0,1		;INIT FOR N ANSWER
	JRST	.+3
$YESNO:	MOVEM	0,$TACC0
	MOVEI	0,0		;INIT FOR Y ANSWER
	MOVEM	1,$TACC1#
	MOVEM	2,$TACC2#
	MOVE	2,0
$YN1:	MOVEI	[ASCIZ/ Y OR N <CR> - /]
	PNTALF			;ASK ?
	TTICHR			;INPUT FROM TTY
	JRST	$YN2		;NO RESPONSE
	CAIE	0,"Y"		;IS IT A 'Y' ?
	CAIN	0,"N"		;OR AN 'N' ?
	JRST	.+2		;YES
	JRST	$YN3		;NEITHER, ERROR
	MOVE	1,0
	LSH	1,7		;POSITION 1ST CHAR
	TTICHR
	JRST	$YN2		;NO RESPONSE
	OR	1,0		;MERGE 2ND CHAR
	CAMN	1,$YN4(2)	;COMPARE FOR REQUESTED
	JRST	.+4		;YES, RETURN +2
	CAMN	1,$YN4+1(2)	;COMPARE FOR OPPOSITE
	JRST	.+3		;YES, RETURN +1
	JRST	$YN3		;ERROR, REPEAT
	AOS	$TACC0		;YES, RETURN +2
$YN2:	MOVE	2,$TACC2
	MOVE	0,1
	MOVE	1,$TACC1
	JRST	@$TACC0

$YN3:	SKIPE	USER
	CLRBFI			;IF USER, CLEAR TYPE-IN BUFFER
	MOVEI	CRLF
	PNTAF
	JRST	$YN1

$YN4:	EXP	26215		;'Y' (CR)
	EXP	23415		;'N' (CR)
	EXP	26215		;'Y' (CR)
;OCTAL-DECIMAL-CONVERT TYPE-IN ROUTINE
;ACCEPTS 0 TO 12 OCTALS, 0 TO 11 DECIMALS, 0 TO 9 CONVERT CHARACTERS
;NUMBER RETURNED IN AC0.

$TPCNV:	MOVEM	0,$TACD0#
	MOVEI	2		;SET INDEX TO CONVERT
	JRST	.+6
$TPDEC:	MOVEM	0,$TACD0
	MOVEI	1		;SET INDEX TO DECIMAL
	JRST	.+3
$TPOCT:	MOVEM	0,$TACD0
	MOVEI	0		;SET INDEX TO OCTAL
	MOVEM	1,$TACD1#	;SAVE AC'S
	MOVEM	2,$TACD2#
	MOVEM	3,$TACD3#
	MOVE	3,0
	SETZB	1,2		;CLEAR DATA REG, CHAR COUNTER
	SETZM	$TYPNB#		;CLEAR ERR NUMBER
	SETZM	$NEGF#		;CLEAR NEGATE FLAG
	SETZM	$CNVD#		;CLEAR DECIMAL CONVERT FLAG

;INPUT AND COMPUTE NUMBER

$TYPLP:	TTICHR			;INPUT FROM TTY
	JRST	$TPERR		;NO RESPONSE, GO TO ERROR EXIT
	CAIN	0,"-"		;IS IT MINUS ?
	JRST	$NEGX		;YES
	CAIN	0,"."		;IS IT PERIOD ?
	JRST	$CNVX		;YES
	CAIN	0,15		;IS IT CR ?
	JRST	$TPEXT		;YES
	CAIN	0,","		;IS IT COMMA ?
	JRST	$TPEXT		;YES
	CAIL	0,"0"		;A VALID DIGIT ?
	XCT	$TPCK(3)
	JRST	$TPERR		;NO
	AOS	2		;INCREMENT CHARACTER COUNTER
	XCT	$TPMUL(3)	;MULT BY OCTAL/DECIMAL BASE, SHIFT CONVERT
	SUBI	60		;ADD IN NEW CHAR
	ADD	1,0
	JRST	$TYPLP		;REPEAT TILL CR OR COMMA
;CHECK FOR PROPER AMOUNT OF CHARACTERS

$TPEXT:	XCT	$TPNBR(3)	;PROPER NUMBER OF CHARACTERS
	JRST	$TPERR		;NO
	CAIN	3,2		;CONVERT ?
	JRST	$CNVX1		;YES
$TPEX1:	MOVE	3,$TACD3	;RESTORE AC'S
	MOVE	2,$TACD2
	MOVE	0,1		;PUT NUMBER IN AC0
	SKIPE	$NEGF		;NEGATE ?
	MOVN	0,1		;YES
	MOVE	1,$TACD1
	AOS	$TACD0
	JRST	@$TACD0		;RETURN +2

$TPERR:	MOVE	3,$TACD3	;ERROR EXIT
	MOVE	2,$TACD2
	MOVEM	1,$TYPNB	;SAVE NUMBER
	MOVE	1,$TACD1
	JRST	@$TACD0

;NUMBER COMPUTING CONSTANTS

$TPCK:	CAILE	0,"7"		;OCTAL NUMBER CHECK
	CAILE	0,"9"		;DECIMAL NUMBER CHECK
	CAILE	0,"9"		;CONVERT NUMBER CHECK
$TPMUL:	LSH	1,3		;OCTAL BASE SHIFT
	IMULI	1,^D10		;DECIMAL BASE MULTIPLIER
	LSH	1,4		;CONVERT SHIFT
$TPNBR:	CAILE	2,^D12		;ACCEPT UP TO 12 OCTALS
	CAILE	2,^D11		;ACCEPT UP TO 11 DECIMALS
	CAILE	2,^D9		;ACCEPT UP TO 9 CONVERT
$NEGX:	SKIPE	2		;1ST CHAR ?
	JRST	$TPERR		;NO, ERROR
	SETOM	$NEGF		;YES, SET NEGATE FLAG
	JRST	$TYPLP		;GET NEXT CHAR

$CNVX:	CAIE	3,2		;PERIOD, IN CONVERT ?
	JRST	$TPERR		;NO, ERROR
	SETOM	$CNVD		;YES, SET DECIMAL FLAG
	JRST	$TYPLP		;GET NEXT CHAR

;CONVERT CONVERSION ROUTINE

$CNVX1:	MOVEI	2,^D9		;NINE DIGITS
	SETZM	0
	SKIPE	$CNVD		;OCTAL OR DECIMAL ?
	JRST	$CNVX2		;DECIMAL
	TDNE	1,[421042104210]	;OCTAL
	JRST	$TPERR		;OCTAL ERROR, 8 OR 9 INPUT
	LSH	1,1		;SQUEEZE OUT 4TH BIT
	LSHC	0,3		;COMPACT INTO OCTAL
	SOJN	2,.-2		;COMPLETED ?
	MOVE	1,0
	JRST	$TPEX1

$CNVX2:	SETZM	3		;DECIMAL
	SETZM	0
	IMULI	3,^D10		;MULTIPLY BY DECIMAL BASE
	LSHC	0,4		;UNPACK NEXT DIGIT
	ADD	3,0		;ADD IN
	SOJN	2,.-4		;COMPLETED ?
	MOVE	1,3
	JRST	$TPEX1
>
	XLIST
	IFDEF	SIXIN,<LIST
SUBTTL	*SUBRTN* SIXBIT TYPE-IN SUBROUTINE, V73G, NOV 12, 1973

;TELETYPE SIXBIT INPUT ROUTINE
;INPUTS UP TO SIX CHARACTERS, TERMINATES WITH A CR OR COMMA.
;SIXBIT WORD RETURNED IN AC0

$TSIXB:	MOVEM	0,$TSX0#
	MOVEM	1,$TSX1#
	MOVEM	2,$TSX2#
	MOVE	2,[POINT 6,1]
	MOVEI	1,0
$TSXB1:	TTICHR
	JRST	$TSXB3		;NO RESPONSE
	CAIN	0,15
	JRST	$TSXB2		;CR, TERMINATE
	CAIN	0,","
	JRST	$TSXB2		;COMMA, TERMINATE
	CAIL	0,"0"
	CAILE	0,"Z"
	JRST	$TSXB3		;ERROR
	CAILE	0,"9"
	CAIL	0,"A"
	JRST	.+2		;ALPHA-NUMERIC
	JRST	$TSXB3		;ERROR
	TRC	0,40		;CONVERT TO SIX-BIT
	TRNE	1,77
	JRST	$TSXB3		;TOO MANY CHAR'S
	IDPB	0,2		;PUT INTO WORD
	JRST	$TSXB1		;REPEAT

$TSXB2:	AOS	$TSX0		;RETURN + 2

$TSXB3:	MOVE	0,1		;SIXBIT WORD IN AC0
	MOVE	1,$TSX1
	MOVE	2,$TSX2
	JRST	@$TSX0
>
	XLIST
	IFDEF	SIXOUT,<LIST
SUBTTL	*SUBRTN* SIXBIT PRINT SUBROUTINE, V73G, NOV 12, 1973

;PRINTS SIXBIT WORD IN AC0
;NORMAL PRINTOUT

$PSIX1:	MOVEM	1,$PTSX1#
	MOVE	1,0		;PUT SIXBIT WORD IN AC1
	MOVEI	0,0
	LSHC	0,6		;GET NEXT CHAR INTO AC0
	ADDI	0,40		;CONVERT TO ASCII
	PNTCHR
	JUMPN	1,.-4		;LOOP TILL ALL PRINTED
	MOVE	1,$PTSX1
	JRST	@$PNTSX

;FORCED PRINTOUT

$PSX1F:	MOVEM	1,$PTSX1#
	MOVE	1,0		;PUT SIXBIT WORD IN AC1
	MOVEI	0,0
	LSHC	0,6		;GET NEXT CHAR INTO AC0
	ADDI	0,40		;CONVERT TO ASCII
	PNTCHF
	JUMPN	1,.-4		;LOOP TILL ALL PRINTED
	MOVE	1,$PTSX1
	JRST	@$PTSXF

>
	XLIST
	IFDEF	DFASB,<LIST
SUBTTL	*SUBRTN* DF10 CONTROL WORD PRINT SUBROUTINE, V73G, NOV 12, 1973

;PRINTS WORD IN AC0
;DF22F = 0, ######  ######  ,18 BIT DF10
;       -1, ##### ########  ,22 BIT DF10

$PNTC1:	MOVEM	1,$PTCA#
	MOVEI	1,0		;NORMAL PRINTOUT
	MOVEM	2,$PTCB#
	MOVE	2,0
	SKIPN	DF22F#		;22 OR 18 BIT DF10 ?
	JRST	$PNTC2
	LSH	0,-^D21		;NEW 22 BIT DF10
	TRZ	0,1
	JUMPN	1,[PNT5F
		JRST .+2]
	PNT5			;PRINT WORD COUNT, 14 BITS
	MOVE	0,2
	TLZ	0,777760
	JUMPN	1,[PNTADF
		JRST .+2]
	PNTADR			;PRINT ADDRESS, 22 BITS
$PNTC3:	MOVE	2,$PTCB
	MOVE	1,$PTCA
	JRST	@$PNTCW		;EXIT

$PNTC2:	HLRZ			;18 BIT DF10
	JUMPN	1,[PNT6F
		JRST .+2]
	PNT6			;PRINT WORD COUNT, 18 BITS
	MOVEI	40
	JUMPN	1,[PNTCHF
		JRST .+2]
	PNTCHR			;EXTRA SPACE
	HRRZ	0,2
	JUMPN	1,[PNT6F
		JRST .+2]
	PNT6			;PRINT ADDRESS, 18 BITS
	JRST	$PNTC3

$PTC1F:	MOVEM	1,$PTCA		;FORCED PRINTOUT
	MOVE	1,$PNTCF
	MOVEM	1,$PNTCW	;SETUP RETURN
	MOVEI	1,1		;FORCED PRINT INDEX
	JRST	$PNTC1+2	;REST AS ABOVE
>
	XLIST
	IFDEF	PRINT,<LIST
SUBTTL	*SUBRTN* PRINT SUBROUTINE, V74A, JUNE 11, 1974

;THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
;TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:

;	MOVEI	NAME
;	PNTA		;OR PNTAF

CRLF:	ASCII/
/

CRLF2:	ASCII/

/

COMMA:	ASCII/,/

PERIOD:	ASCII/./

SPACE:	ASCII/ /

TAB:	ASCII/	/

MINUS:
HYPEN:	ASCII/-/

PLUS:	ASCII/+/

AST:	ASCII/*/

ATSIN:	ASCII/@/

LFP:	ASCII/(/

RTP:	ASCII/)/

BELL:	BYTE (7) 007

QUEST:	ASCII/?/

SLASH:	ASCII!/!

DOLLAR:	ASCII/$/

;PRINT SUBROUTINE INITIALIZATION
;INITIALIZES CONTROL WORDS, AND TTY IF IN USER MODE

$PNTIN:	MOVEM	0,$ACB0#
	SETZM	$INTDF#		;CLEAR DEVICE DEFAULT FLAG
	SETZM	$DVOFF#		;CLEAR DEVICE INITED FLAG
	SETZM	PDISF#		;CLEAR PRINT DISABLED FLAG
	SETZM	$PTINH#		;CLEAR PRINT 'TYPE-IN INHIBIT' FLAG
	SETZM	PNTINH#		;ALLOW EXEC PRINT TYPE IN INHIBIT
	SETZM	PNTFLG#		;CLEAR IN PRINT FLAG
	SETOM	PNTSPC#		;SET PRINT SPACE FLAG
	MOVNI	0,^D5000	;SET PRINT ENABLE TO 5000 LINES
	MOVEM	0,PNTENB
	IFDEF	EXCASB,<
	SETZM	TTYFIL#		;ALLOW EXEC FILLERS
	SETZM	$CRLF#		;ALLOW FREE CR/LF
	SETZM	$TABF#		;ALLOW TAB CONVERSION
	SETZM	$FFF#		;ALLOW FORM FEED CONVERSION
	SETZM	$VTF#		;ALLOW VERTICAL TAB CONVERSION
	SKIPN	USER		;EXEC MODE ?
	JRST	$TYSPD		;YES, COMPUTE CTY BAUD RATE >
$PNTIX:	MOVEI	REENTR		;SETUP REENTER ADDRESS
	MOVEM	JOBREN
	SKIPGE	MONCTL		;MONITR CONTROL ?
	JRST	@$ACB0		;YES, DON'T PRINT TITLE
	SKIPE	$ONETM#		;FIRST TIME
	JRST	@$ACB0		;NO
	MOVE	$ACB0
	MOVEM	$ACPN0
	JRST	$PNTNM+3	;PRINT PROGRAM NAME

$PNTIB:	SKIPE	PDISF#		;FIRST TIME PRINT DISABLED
	JRST	$PRNTX		;NO
	SETOM	PDISF
	MOVEM	1,$PACA1	;SAVE AC'S
	MOVEM	2,$PACA2
	MOVEM	3,$PACA3
	MOVEM	4,$PACA4
	MOVEM	5,$PACA5
	SETOM	$PNTTY
	MOVEI	[ASCIZ/
**********
EXCEEDED ALLOWED PRINTOUTS, ONLY FORCED PRINTOUTS FROM THIS POINT
**********
/]
	JRST	$ASCPN-1	;PRINT ASCII
;PRINT SUBROUTINE ENTRY & PRINT MODE DETERMINATION

$PNTIF:	SETOM	PNTFLG		;SET IN PRINT FLAG
	MOVEM	0,$PACA0#	;FORCE PRINTOUT
	MOVE	0,$PRNTF
	MOVEM	0,$PRINT
	SETOM	$PNTTY#
	JRST	$PNTIA
$PNTIT:	SETOM	PNTFLG		;SET IN PRINT FLAG
	MOVEM	0,$PACA0	;SAVE AC 0
	SETZM	$PNTTY
	SKIPL	PNTENB#
	JRST	$PNTIB		;DON'T PRINT OVER 5000(10) LINES
	SWITCH			;READ DATA SWITCHES
	TLNN	0,NOPNT		;NO PRINT SWITCH SET
	JRST	.+3
	MOVE	0,$PACA0
	JRST	$PRNTX

;DETERMINE PRINT MODE

$PNTIA:	MOVEM	1,$PACA1#	;SAVE AC1.
	MOVEM	2,$PACA2#	;SAVE AC2.
	MOVEM	3,$PACA3#	;SAVE AC3.
	MOVEM	4,$PACA4#	;SAVE AC4.
	MOVEM	5,$PACA5#	;SAVE AC5.
	MOVE	0,$PACA0	;RESTORE AC0
	SETZM	$PNT#		;CLEAR PRINT HALF WORDS FLAG
	MOVE	1,$PRINT	;MOVE C(JSR+1) INTO AC1.
	MOVE	2,-1(1)		;MOVE THE JSR INTO AC2.
	ROT	2,15		;GET X
	ANDI	2,17		;OUT OF THE JSR.
	CAIN	2,17		;X=17?
	JRST	$ASCPN-1	;YES. PRINT MORE THAN 1 WORD.
	JUMPE	2,$ASCPN	;X=0? YES. GO PRINT 1 WORD.
	CAIN	2,15		;X=15?
	JRST	$DECPN		;YES, PRINT DECIMALS
	CAIN	2,16		;X=16?
	JRST	$DECSP		;YES, PRINT DECIMALS, LEADING SPACES
	CAIN	2,13		;X=13?
	JRST	$PNTI3		;YES, PRINT OCTALS, 6 SP 6
	CAIN	2,12		;X=12?
	JRST	$CHRPN		;YES, PRINT CHARACTER
;OCTAL PRINTOUT ROUTINE
;PRINTS NUMBER IN AC0

$PNTI1:	MOVE	3,2		;MOVE X INTO AC3.
	ROT	0,-3		;ROT OCTAL NUM 3 PLACES
	SOJN	3,.-1		;X AMOUNT OF TIMES.
$PNTI2:	MOVEI	1,6		;PUT 6 INTO AC1 SO THAT
	ROTC	0,3		;C(AC1) AFTER THE ROTC WILL BE 60
	JSP	3,$TOUT		;PLUS NUMBER TO BE PRINTED..GO PNT NUM.
	SOJN	2,$PNTI2	;SUB 1 FROM X...PRINT UNTIL X=0.
	MOVEM	1,$PNTSV#	;SAVE NUMBER
	SKIPN	PNTSPC
	JRST	.+3
	MOVEI	1,40		;AT THIS POINT WE HAVE PRINTED
	JSP	3,$TOUT		;X AMOUNT OF NUMBER(S) AND NOW A SPACE.
	SKIPN	$PNT#		; PRINT 6 SP 6 FLAG SET?
	JRST	$PNTI4		;NO, EXIT
	MOVE	1,$PNTSV	;RESTORE NUMBER
	MOVEI	2,6		;SETUP FOR 2ND HALF
	SETZM	$PNT		;CLEAR PRINT SPACE FLAG
	JRST	$PNTI2		;PRINT REST OF NUMBER

$PNTI3:	MOVEI	3,14		;SETUP FOR LH WORD
	MOVEI	2,6		;SETUP FOR FIRST HALF
	SETOM	$PNT		;SET PRINT 6 SP 6 FLAG
	SETOM	PNTSPC
	JRST	$PNTI1+1	;PRINT FIRST HALF NUMBER

;PRINT ROUTINE EXIT

$PNTI4:	SETZM	$PNTTY
	MOVE	0,$PACA0	;RESTORE AC0.
	MOVE	1,$PACA1	;RESTORE AC1.
	MOVE	2,$PACA2	;RESTORE AC2.
	MOVE	3,$PACA3	;RESTORE AC3.
	MOVE	4,$PACA4	;RESTORE AC4.
	MOVE	5,$PACA5	;RESTORE AC5.
$PRNTX:	SETZM	PNTFLG		;CLEAR IN PRINT FLAG
	JRST	@$PRINT		;RETURN.

;CHARACTER PRINTOUT ROUTINE
;PRINTS CHAR IN LOWER 7 BITS OF AC0

$CHRPN:	ANDI	0,177		;STRIP CHAR TO 7 BITS
	MOVE	1,0
	JSP	3,$TOUT		;PRINT A CHARACTER
	JRST	$PNTI4		;LEAVE
;ASCII PRINTOUT ROUTINE
;PRINTS ASCII WHOSE ADDRESS IS IN AC0

	SETOM	$PNT#		;SET PRINT MORE THAN 1 WORD FLAG.
$ASCPN:	MOVEM	0,$POINT#	;SAVE ADDRESS OF ASCII MESSAGE.
$ASCP1:	MOVEI	2,5		;5 = NUM OF ASCII CHAR. IN A WORD.
	MOVE	0,@$POINT	;C(AC0) = FIRST WORD OF ASCII MESS.
$ASCP2:	SETZ	1,		;CLEAR AC1.
	ROTC	0,7		;C(AC1) = CHAR TO BE PRINTED.
	JUMPE	1,$PNTI4	;CHAR = 0?..NO MORE CHAR..LEAVE.
	JSP	3,$TOUT		;PRINT A CHAR.
	SOJN	2,$ASCP2	;PNT ALL CHAR FROM THIS WORD?
	AOS	$POINT		;YES. INC TO GET NEXT WORD.
	SKIPN	$PNT		;PNT MORE THAN ONE CHAR FLAG SET?
	JRST	$PNTI4		;NO..LEAVE.
	JRST	$ASCP1		;YES...RETURN TO PNT NEXT WORD.

;DECIMAL PRINTOUT ROUTINE
;PRINTS NUMBER IN AC0

$DECSP:	SETOM	$PNT		;SET LEADING SPACES PRINT CONTROL
$DECPN:	MOVEM	17,$PAC17#	;SAVE AC17
	MOVE	17,$PLST	;SETUP PUSH LIST
	PUSHJ	17,$RADIX	;GO TO DECIMAL-ASCII CONVERSION
	MOVE	17,$PAC17	;RESTORE AC17
	JRST	$PNTI4

$RADIX:	MOVEI	2,^D10		;SETUP DIGIT COUNTER
	LSHC	0,-^D35		;SHIFT RIGHT 35 BITS INTO AC1
	LSH	1,-1		;VACATE AC1 SIGN BIT
$DCCMP:	DIVI	0,^D10		;DIVIDE DOUBLE LENGTH INTERGER BY 10
	HRLM	1,(17)		;SAVE DIGIT
	SOS	2		;COUNT DIGIT
	JUMPE	0,$LDSPS	;ALL DIGITS FORMED?
	PUSHJ	17,$RADIX+1	;NO, COMPUTE NEXT ONE
$DECP1:	HLRZ	1,(17)		;YES, RETRIEVE DIGIT
	ADDI	1,60		;CONVERT TO ASCII
	JSP	3,$TOUT		;TYPE-OUT
	POPJ	17,		;GET NEXT/EXIT

$LDSPS:	SKIPN	$PNT		;LEADING SPACES PRINT SET?
	JRST	$DECP1		;NO
$DCSPS:	SOJL	2,$DECP1	;SPACES COMPLETE ?
	MOVEI	1,40		;NO, PRINT LEADING SPACE
	JSP	3,$TOUT
	JRST	.-3		;CHECK FOR NEXT
$TOUT:	MOVEM	0,$PACB0#	;SAVE AC0.
	MOVEM	1,$PNTYC#	;SAVE CHARACTER
	SKIPE	USER
	JRST	$TOUTB		;USER MODE
	XLIST
	IFDEF	EXCASB,<LIST
	SKIPE	PNTINH		;INHIBIT INPUT CHECKS ?
	JRST	$TOUTB		;YES
	CONSO	TTY,40		;KEY STRUCK ?
	JRST	$TOUTB		;NO
	DATAI	TTY,0
	ANDI	0,177
	CAIN	0,003		;IS IT ^C ?
	JRST	$TUTX2		;YES, TERMINATE
	IFDEF	ALTGO,<
	JSP	4,$TUTX1	;GO CHECK IF ALT-MODE
	JRST	.+2		;NO
	JRST	$TUTX3		;YES, GO TO USER'S ROUTINE >
	MOVEI	0,136
	TTYOUT			;^
	MOVEI	0,117
	TTYOUT			;O
	SETOM	$PTINH
	JRST	$TOUTB >

	XLIST
	IFDEF	USRASB,<LIST
;USER MODE LF & CR FILLERS

$USRFC:	CAIE	1,15		;CR ?
	JRST	$TOUTA		;NO
	MOVE	5,USRCRF	;SEND FILLERS FOR CR
	JRST	.+4		;DEPENDING ON 'USRCRF'
$USRFL:	CAIE	1,12		;LF ?
	JRST	$TOUTA		;NO
	MOVE	5,USRLFF	;SEND FILLERS FOR LF
	SOJL	5,$TOUTA	;DEPENDING ON 'USRLFF'
	MOVEI	1,001		;^A
	JSP	4,$TOUT2
	JRST	.-3 >

	LIST
$TOUTB:	MOVE	CONSW
	AOS	$CARCT#		;INC CHAR CNTR.
	CAIN	1,7		;CHAR A BELL ?
	SETZM	$PTINH		;YES, CLEAR PRINT INHIBIT
	CAIE	1,15		;CHAR A CR?
	JRST	.+4		;NO
	SETZM	$PTINH
	AOS	PNTENB		;COUNT LINES, TILL NO MORE
	SETZM	$CARCT		;CLR CHAR CNTR.
	CAIN	1,12		;IS CHAR A LF?
	SETZM	$CARCT		;YES. CLR CHAR CNTR.
	SKIPE	$PNTTY
	JRST	.+3		;DON'T CHECK NON-PNT SW IF FORCED PRINTOUT
	TLNE	0,NOPNT		;IS NON PNT SWITCH ON?
	JRST	(3)		;YES. RETURN.
	SKIPN	USER		;EXEC MODE ?
	JRST	$TOUTC		;YES
	IFDEF	USRASB,<
	JSP	4,$TOUT2	;SEND CHARACTER
	SKIPE	USRLFF#		;NEED USER LF FILLERS ?
	JRST	$USRFL		;YES
	SKIPE	USRCRF#		;NEED USER CR FILLERS ?
	JRST	$USRFC		;YES	>
$TOUTA:	MOVE	0,$PACB0	;RESTORE AC0
	JRST	(3)		;RETURN


	IFDEF	EXCASB,<
	IFDEF	ALTGO,<
$TUTX1:	MOVEM	4,$TALT0
	JRST	$TALTM+3	>
	MOVEM	0,JOBOPC	;2-TERMINATED IN JOBOPC
	JRST	@CNTLC		;3-TERMINATE
$TUTX2:	JSP	0,.-2		;1-SAVE PC WHERE
	JRST	$TOUTB		;4-HERE IF CONTINUED
	IFDEF	ALTGO,<
	MOVEM	0,JOBOPC	;2-TERMINATED IN JOBOPC
	JRST	@ALTMGO		;3-TERMINATE
$TUTX3:	JSP	0,.-2		;1-SAVE PC WHERE
	JRST	$TOUTB		;4-HERE IF CONTINUED	>>
	IFNDEF	EXCASB,<$TOUTC:	FATAL
	$TYOU1:	FATAL	>
	IFNDEF	USRASB,<$TOUT2:	FATAL	>
	XLIST
	IFDEF	EXCASB,<LIST
;EXEC MODE CHARACTER OUTPUT

$TOUTC:	TLNE	0,PNTLPT	;PRINT ON LINE PRINTER ?
	JRST	$TOUT1		;YES
$PNTY1:	SKIPE	$PTINH		;TYPE-IN INHIBIT ?
	JRST	$TOUTA		;YES
	SKIPE	$CRLF		;WANT FREE CRLF ?
	JRST	$PNTY2		;NO
	CAIN	1,7		;BELL, NO FREE CRLF'S
	JRST	$PNTY2
	MOVE	1,$CARCT	;GET CHAR COUNTER
	CAIG	1,^D72		;DONE FULL LINE, 72 CHARS ?
	JRST	$PNTY2		;NO
	MOVEI	0,15
	TTYOUT			;CR
	MOVEI	0,12
	TTYOUT			;LF
	SETZM	$CARCT		;CLEAR CHAR COUNTER
$PNTY2:	MOVE	0,$PNTYC	;RESTORE CHAR
	SKIPE	$TABF		;TAB CONV INHIBITED ?
	JRST	.+3
	CAIN	0,11		;IS CHAR A TAB?
	JRST	$TABS		;YES. TURN TAB INTO SPACES.
	SKIPE	$FFF		;FORM FEED CONV INHIBITED ?
	JRST	.+3
	CAIN	0,14		;IS CHAR A FF ?
	JRST	$FFEED		;YES, SUBSTITUTE 8 LF'S
	SKIPE	$VTF		;VERT TAB CONV INHIBITED ?
	JRST	.+3
	CAIN	0,13		;IS CHAR A VT ?
	JRST	$VTAB		;YES, SUBSTITUTE 4 LF'S
	TTYOUT			;PRINT A CHAR.
	JRST	$TOUTA
;EXEC MODE LPT OUTPUT

$TOUT1:	CAIN	1,7		;NO BELLS TO LPT
	JRST	$PNTY1
	LSH	1,1		;C(AC1) HAS TO BE LEFT JUSTIFIED.
	ANDI	1,376		;CLEAR PARITY BIT
	DATAO	LPT,1		;PRINT CHAR ONTO LPT.
	MOVEI	1,^D<<1000*500>/7>		;ABOUT 500 MS.
	CONSO	LPT,100		;LPT DONE?
	SOJG	1,.-1		;NO.
	JUMPG	1,.+4		;IF LPT HUNG, CLEAR LPT PRINT
	MOVE	0,CONSW		;FOR THIS PRINT ENTRY
	TLZ	0,PNTLPT
	MOVEM	0,CONSW
	SKIPN	$PNTTY		;SKIP IF MSG ALSO FORCED TO TTY
	JUMPG	1,$TOUTA	;RETURN IF LPT NOT HUNG, ELSE ALL TO TTY
	MOVE	1,$PNTYC
	JRST	$PNTY1

;TELETYPE TABS CONVERSION

$TABS:	SOS	1,$CARCT	;PUT CHAR CNT - 1 TAB INTO AC1.
	SUBI	1,10		;DIVIDE
	JUMPGE	1,.-1		;BY 10.
	MOVN	1,1		;C(AC1) NOW = NO. OF SPACES TO PNT.
$TABS1:	MOVEI	0,40
	TTYOUT			;SEND A SPACE.
	AOS	$CARCT		;INCREMENT CHAR CNTR.
	SOJG	1,$TABS1	;DECREMENT SPACES CNTR.
	JRST	$TOUTA		;RETURN.

;TELETYPE FF & VT CONVERSION

$VTAB:	MOVEI	1,4
	SKIPA

$FFEED:	MOVEI	1,^D8
	MOVEI	0,12
	TTYOUT			;SEND LF'S
	SOJG	1,$FFEED+1
	JRST	$TOUTA
;EXEC CONSOLE TTY OUTPUT

$TYOU1:	MOVEM	0,$TYAC0#
	MOVEM	1,$TYAC1#
	MOVEM	2,$TYAC2#
	ANDI	0,177		;STRIP TO 7 BITS
	MOVE	1,0		;PUT CHAR IN AC1
	SETZ	2,		;CLEAR AC2..USE AS BIT CNTR.
	ANDI	1,-1(1)		;THIS WILL CLEAR 1 BIT AT A TIME.
	SKIPE	1		;ALL THE BITS?
	AOJA	2,.-2		;NO. RETURN TO DO ANDI AGAIN.
	TRNN	2,1		;BIT CNTR ODD?
	TRC	0,200		;COMP HI ORDER BIT..EVEN PAR.
	DATAO	TTY,0		;SEND CHAR TO TTY
	CONSO	TTY,10		;WAIT TILL DONE
	JRST	.-1
	SKIPE	TTYFIL		;FILLERS INHIBITED ?
	JRST	$TYOU3		;YES

$TYOU2:	CAIN	0,12
	JRST	$TYFLF		;LF, DO FILLERS
	CAIN	0,215
	JRST	$TYFCR		;CR, DO FILLERS
	CAIN	0,207		;BELL, DO FILLERS
	JRST	$TYFBL
$TYOU3:	MOVE	0,$TYAC0
	MOVE	1,$TYAC1	;DONE, RESTORE AC'S
	MOVE	2,$TYAC2
	JRST	@$TYOUT		;EXIT
;CONSOLE TTY FILLER ROUTINE

$TYFCR:	DATAO	TTY,0		;ALWAYS GIVE 1 EXTRA CR
	CONSO	TTY,10
	JRST	.-1
	MOVE	1,TTYSPD	;DETERMINE FILLERS REQUIRED
	SETZM	2		;FOR CR
	CAIN	1,2
	MOVEI	2,^D9		;LA30, REQ 9 FILLERS @ 300 BAUD
$TYFC1:	CAIN	1,5
	MOVEI	2,4		;4 FILLERS @ 2400 BAUD
	CAIN	1,4
	MOVEI	2,2		;2 FILLERS @ 1200 BAUD
	CAIN	1,3
	MOVEI	2,1		;1 FILLER @ 600 BAUD

$TYFLX:	SOJL	2,$TYOU3
	MOVEI	0,0		;USE 000 AS FILLER
	DATAO	TTY,0
	CONSO	TTY,10
	JRST	.-1
	JRST	$TYFLX

$TYFLF:	MOVE	1,TTYSPD	;DETERMINE FILLERS REQ FOR LF
	SETZM	2
	JRST	$TYFC1		;FILLERS AS CR EXCEPT FOR 300 BAUD

$TYFBL:	MOVEI	2,2		;DO 2 FILLERS FOR THE BELL
	JRST	$TYFLX
;EXEC CONSOLE TTY BAUD RATE DETERMINATION

$TYSPD:	SKIPE	$ONETM
	JRST	$PNTIX		;DO ONLY FIRST TIME
	SKIPGE	MONCTL		;UNDER DIAG MONITOR ?
	JRST	$TYMON		;YES
$TYMN1:	DATAI	APR,0		;GET SWITCHES
	MOVEI	1,60
	TLNE	0,CYCL50	;50 OR 60 CYCLES ?
	MOVEI	1,50
	CONO	APR,1000	;CLEAR AND WAIT FOR CLOCK
	CONSO	APR,1000
	JRST	.-1
	CONO	APR,1000
	SETZM	0
$TYSP1:	DATAO	TTY,[377]	;COUNT # OF CHARS SENT IN 1 SEC
	AOS	0
$TYSP2:	CONSO	TTY,10
	JRST	$TYSP3
	JRST	$TYSP1
$TYSP3:	CONSO	APR,1000
	JRST	$TYSP2
	CONO	APR,1000
	SOJGE	1,$TYSP2

$TYSP4:	CONSO	TTY,10		;WAIT TILL TTY GETS DONE
	JRST	.-1
	MOVEI	1,5		;5 = 2400 BAUD
	CAIG	0,^D122
	SOS	1		;4 = 1200 BAUD
	CAIG	0,^D62
	SOS	1		;3 = 600 BAUD
	CAIG	0,^D32
	SOS	1		;2 = 300 BAUD
	CAIG	0,^D16
	SOS	1		;1 = 150 BAUD
	CAIG	0,^D12
	SOS	1		;0 = 110 BAUD
$TYMN2:	MOVEM	1,TTYSPD#	;SAVE TTY SPEED
	JRST	$PNTIX

$TYMON:	MOVE	1,1017		;DIAG MON, GET TTY SPEED
	JUMPL	1,$TYMN1	;IS IT A PROPER VALUE ?
	CAILE	1,^D10		;MUST BE BETWEEN 0-10
	JRST	$TYMN1		;OTHERWISE COMPUTE OWN
	JRST	$TYMN2		;OK - SAVE AS TTY SPEED
>
	XLIST
	IFDEF	USRASB,<LIST
;USER MODE TELETYPE OUTPUT

$TOUT2:	MOVEM	4,$PACC4#
	MOVE	0,CONSW
	TLNE	0,PNTLPT	;IS LPT PRINT SWITCH UP ?
	JRST	$TOUT3		;YES, GO PRINT ON LOGICAL DEVICE
	DROPDV			;CLOSE DEV IF SWITCH CHANGED
$TOUT6:	MOVE	0,$CARCT
	CAIN	0,1		;FIRST CHAR IN LINE ?
	JRST	$TOUT4		;YES
$TOUT5:	OUTCHR	1
	JRST	@$PACC4		;GO RESTORE AC0 AND RETURN

$TOUT4:	SKIPL	MONCTL		;SYSTEM EXERCISER
	JRST	$TOUT5		;NO
	OUTSTR	QUEST		;PRECEDE LINE WITH ?
	JRST	$TOUT5

;USER MODE LOGICAL DEVICE OUTPUT

$TOUT3:	SKIPN	$DVOFF		;DEVICE BEEN INITED YET ?
	JSP	$INTDV		;NO, GO DO IT
	JSP	$PUTCR		;GO OUTPUT CHAR
	IFDEF	DSKUPD,<
	CAIN	1,12		;LF ?
	JSP	$ITDV1		;UPDATE, SETUP FOR INPUT/OUTPUT >
	SKIPN	$PNTTY		;SKIP IF MESSAGE ALSO FORCED TO TTY
	JRST	@$PACC4
	JRST	$TOUT6

;OUTPUT TO LOGICAL DEVICE

$PUTCR:	MOVEM	0,$PACC0#
	SKIPE	$DVTTY#		;IF DEVICE IS TTY
	JRST	$PUTBF		;EMPTY AFTER EACH CHAR
	SOSG	$OBUF+2		;INCREMENT BYTE COUNT
	JRST	$PUTBF		;NO MORE ROOM, OR FIRST CALL AFTER INIT
$PTNXT:	IDPB	1,$OBUF+1	;STORE CHAR IN AC1
	JRST	@$PACC0		;RETURN
$PUTBF:	OUT	$DEVCH,		;CALL MONITOR TO EMPTY BUFFER
	JRST	$PTNXT
;LOGICAL DEVICE INITIALIZATION, PHY DEV ASSIGNED AT RUN TIME

$INTDV:	MOVEM	0,$PACD0#
	SETZM	$UPDTF#
	MOVE	0,PNTEXT
	MOVEM	0,$OUTEX
	MOVE	0,PNTNAM	;SETUP LOGICAL OUTPUT FILE NAME
	MOVEM	0,$OUTNM
	IFDEF	DSKUPD,<
	MOVEM	$INNM		;SETUP LOGICAL FILE INPUT NAME
	MOVE	0,PNTEXT
	MOVEM	0,$INEXT	>
	INIT	$DEVCH,0	;ASCII MODE, DEV CHANNEL
	SIXBIT	/DEV/		;LOGICAL DEVICE, LPT,DSK,DTAX
	XWD	$OBUF,		;OUTPUT ONLY
	JRST	$INTD1		;DEV NOT AVAIL, DEFAULT TO DISK
$INTD2:	OUTBUF	$DEVCH,1	;SETUP OUTPUT BUFFER
	ENTER	$DEVCH,$OUTNM	;INIT OUTPUT FILE
	JRST	$OERR2		;NO DIR ROOM, ERROR
	SETOM	$DVOFF		;SET DEVICE INITED FLAG
	SETZM	$DVTTY
	MOVEI	0,$DEVCH
	DEVCHR
	TLNE	0,10
	SETOM	$DVTTY		;DEVICE IS TTY
	IFDEF	DSKUPD,<
	MOVEI	0,$DEVCH
	DEVCHR			;GET DEVICE CHARACTERISTICS
	TLC	0,200007
	TLNE	0,776737	;IS DEVICE A DSK ?
	JRST	@$PACD0		;NO
	SETOM	$UPDTF		;YES	>
	JRST	@$PACD0

$INTD1:	SKIPN	$INTDF		;FIRST DEFAULT INIT ?
	OUTSTR	[ASCIZ/
**********
USING 'DSK' PRINT FILE
**********
/]
	SETOM	$INTDF
	INIT	$DEVCH,0
	SIXBIT	/DSK/
	XWD	$OBUF,
	JRST	$OERR1
	JRST	$INTD2
;USER MODE CLOSE FILE

$DRPDV:	MOVEM	0,$PACE0#
	SKIPN	$DVOFF		;DEVICE INITED?
	JRST	@$PACE0		;RETURN
	CLOSE	$DEVCH,		;CLOSE FILE
	STATZ	$DEVCH,740000	;RECHECK FINAL ERROR BITS
	OUTSTR	[ASCIZ/
**********
ERROR DURING PRINT CLOSE FILE
**********
/]
	RELEAS	$DEVCH,		;RELINQUISH DEVICE, WRITE DIRECTORY
	SETZM	$DVOFF
	JRST	@$PACE0 

$OUTER:	OUTSTR	[ASCIZ/
**********
ERROR DURING PRINT OUTPUT
**********
/]
	EXIT	1,		;ERROR, QUIT
	JRST	BEGIN

$OERR1:	OUTSTR	[ASCIZ/
LOGICAL DEVICE 'DEV' NOT ASSIGNED/]
	JRST	$OUTER

$OERR2:	OUTSTR	[ASCIZ/
NO DIRECTORY ROOM/]
	JRST	$OUTER

	XLIST
	IFDEF	DSKUPD,<LIST
;UPDATE, REINIT FOR INPUT & OUTPUT (ONLY IF DSK)

$ITDV1:	MOVEM	0,$PACG0#
	SKIPN	$UPDTF
	JRST	@$PACG0
	DROPDV
	INIT	$DVCH1,0
	SIXBIT	/DEV/
	$IBUF
	JRST	$ITDV2		;DEV NOT ASSGND/AVAIL, USE DSK
$ITDV3:	INBUF	$DVCH1,1
	LOOKUP	$DVCH1,$INNM
	JRST	$OERR3
	JSP	$INTDV		;REINIT OUTPUT FILE
	JSP	$GETCR		;INPUT/OUTPUT TILL EOF
	JSP	$PUTCR
	JRST	.-2		;CONT FROM HERE ON EOF
$INEOF:	SETOM	$DVOFF
	JRST	@$PACG0

$ITDV2:	INIT	$DVCH1,0
	SIXBIT	/DSK/
	$IBUF
	JRST	$OERR1
	JRST	$ITDV3

$GETCR:	MOVEM	$PACF0#
$GETNX:	SOSLE	$IBUF+2		;DECREMENT BYTE COUNT
	JRST	$GETOK
	IN	$DVCH1,		;GET NEXT BUFFER
	JRST	$GETOK
	STATZ	$DVCH1,740000
	JRST	$OERR4		;ERROR
	JRST	$INEOF		;ASSUME END-OF-FILE

$GETOK:	ILDB	1,$IBUF+1	;GET CHARACTER FROM BUFFER
	JUMPN	1,@$PACF0	;RETURN IF NOT NULL
	JRST	$GETNX		;IGNORE NULL, GET NEXT CHAR

$OERR3:	OUTSTR	[ASCIZ?
UPDATE LOOKUP/ENTER FAILURE?]
	JRST	$OUTER

$OERR4:	OUTSTR	[ASCIZ/
UPDATE INPUT ERROR/]
	JRST	$OUTER
>>>
	LIST
   