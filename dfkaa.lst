DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAAT	MAC	11-Nov-24 11:49		*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, SEPT 18,1979

     1					;DFKAA
     2
     3
     4			000000		MCNVER==0
     5			000002		DECVER==2
     6
     7						XLIST
     8						LIST
     9						LALL
    10
    11						NAME	\MCNVER,\DECVER^
    12
    13					TITLE	DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2
    14					^
    15
    16					;TEST DESIGNED FOR INITIAL DEBUGGING OF PROCESSOR HARDWARE
    17					;AND TO DETECT (SOLID) FAILURES IN THE FIELD.
    18
    19					;COPYRIGHT 1975,1977
    20					;DIGITAL EQUIPMENT CORPORATION
    21					;MARLBORO, MASS. 01752
    22
    23					;JOHN R. KIRCHOFF
    24
    25	000137					LOC	137
    26	000137	000000	000002			MCNVER,,DECVER
    27
    28						NOSYM
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAAT	MAC	11-Nov-24 11:49		DIAGNOSTIC PARAMETERS

    29					SUBTTL	DIAGNOSTIC PARAMETERS
    30
    31					;PARAMETER DEFINITIONS
    32
    33			000001		EXCASB==1
    34			000001		USRASB==1
    35			000001		KI10==1
    36			000001		KL10==1
    37			000001		KL10P0==1
    38			000001		PGMEND==1
    39			030000		MODDVL==BEGIN
    40			030000		MODDVU==BEGIN
    41
    42					;FLAG DEFINITIONS
    43
    44			010000		USERF=10000		;USER MODE FLAG
    45
    46
    47					;MACROS
    48
    49					; STOP - USED FOR SCOPE LOOP, IF INSTRUCTION FAILS, CHANGE (JUMPA .+1)
    50					;	 TO A (JUMPA .-X) TO CYCLE ON FAILING INSTRUCTION
    51
    52					DEFINE	STOP	(A)<
    53						HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
    54						JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
    55									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
    56									;IN THE SUBTEST) TO LOOP ON ERROR>
    57
    58					; SFLAG - USED TO CLEAR ALL FLAGS THEN TO SET SELECTED FLAG
    59
    60					DEFINE	SFLAG	(A)<
    61						MOVSI	1,A
    62						JFCL	17,.+1	;RESET ALL FLAGS
    63						JRST	2,.+1(1)		;SET A FLAG>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAAT	MAC	11-Nov-24 11:49		DIAGNOSTIC PARAMETERS

    64					;SPECIAL FEATURE PARAMETERS
    65
    66			030742		SADR1=STARTA
    67			030742		SADR2=STARTA
    68			030742		SADR3=STARTA
    69			030742		SADR4=STARTA
    70		254000	030742		SADR5=JRST STARTA
    71		254000	030742		SADR6=JRST STARTA
    72		254000	030742		SADR7=JRST STARTA
    73		254000	030742		SADR8=JRST STARTA
    74		254000	030742		SADR9=JRST STARTA
    75		254000	030742		SADR10=JRST STARTA
    76		254000	030742		SADR11=JRST STARTA
    77
    78			000000		PAREA0=0
    79			000000		PAREA1=0
    80			000000		PAREA2=0
    81		444653	414100		PAREA3=SIXBIT/DFKAA/
    82		645560	000000		PAREA4=SIXBIT/TMP/
    83			000000		PAREA5=0
    84			000000		PAREA6=0
    85			001000		ITERAT==1000
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
PARAM	KLM	13-Jan-89 12:02		*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, SEPT 18,1979

    86					SUBTTL	*PARAM*	CONSOLE DATA SWITCH ASSIGNMENTS, SEPT 18,1979
    87
    88					DEFINE	S,<; *********************************************************************>
    89
    90					; **********************************************************************
    91					;*DATA SWITCHES (READ FROM CONSOLE IN EXEC MODE OR TYPED IN IN USER MODE)
    92					;*LEFT HALF SWITCHES ARE PRE-ASSIGNED FOR SUBROUTINE PACKAGE USE
    93					;*AND CONTROL LOOPING, PRINTING (TTY OR OTHER DEVICE) AND MISC. FUNCTIONS
    94					; **********************************************************************
    95
    96			400000		ABORT==	400000			;ABORT PROGRAM ON PASS COMPLETION
    97			200000		RSTART==200000			;RESTART TEST, PRINT TOTALS
    98			100000		TOTALS==100000			;PRINT TOTALS, CONTINUE
    99
   100			040000		NOPNT==	040000			;INHIBIT ALL PRINT/TYPE OUT (EXCEPT FORCED)
   101			020000		PNTLPT==020000			;PRINT ALL DATA ON LPT (LOGICAL DEVICE, USER MODE)
   102			010000		DING==	010000			;RING BELL ON ERROR
   103
   104			004000		LOOPER==004000			;ENTER EXERCISE/CHECK LOOP ON ERROR
   105			002000		ERSTOP==002000			;HALT ON TEST ERROR
   106			001000		PALERS==001000			;PRINT ALL ERRORS
   107
   108			000400		RELIAB==000400			;RELIABILITY MODE
   109			000200		TXTINH==000200			;INHIBIT ERROR TEXT
   110			000100		INHPAG==000100			;INHIBIT PAGING
   111
   112			000040		MODDVC==000040			;MODIFY DEVICE CODE
   113			000020		INHCSH==000020			;INHIBIT CACHE
   114			000010		OPRSEL==000010			;OPERATOR SELECTION
   115
   116			000004		CHAIN==	000004			;CHAIN CONTROL SWITCH
   117
   118			000002		KAHZ50==000002			;KA10 50 HERTZ POWER
   119
   120									;SWITCH 17 RESERVED !!!
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
PARAM	KLM	13-Jan-89 12:02		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, SEPT 18,1979

   121					SUBTTL	*PARAM* PROGRAM/SUBROUTINE PARAMETERS, SEPT 18,1979
   122
   123					; **********************************************************************
   124					;*SPECIAL SUBPROGRAM LINKAGES
   125					; **********************************************************************
   126
   127			027772		FSELNK=	27772	;FILE SELECT LINK
   128			027773		FRDLNK=	27773	;FILE READ LINK
   129			027774		LDLNK=	27774	;LOAD LINKAGE ADDRESS
   130			027775		DDTLNK=	27775	;DDT LINKAGE ADDRESS
   131			027776		MODLNK=	27776	;OPERATIONAL MODE CHECK LINKAGE ADDRESS
   132			027777		SUBLNK=	27777	;SUBROUTINE LINKAGE ADDRESS
   133
   134					; **********************************************************************
   135					;*SPECIAL SUBROUTINE FATAL HALTS
   136					;*USED TO REPORT ERRORS THAT CAUSE THE SUBROUTINES TO BE UNUSABLE
   137					; **********************************************************************
   138
   139					;ADDRESS   TAG	REASON
   140					;---------------------
   141
   142					; 1010 	NOEXEC	;PROGRAM NOT CODED FOR EXEC MODE OPERATION
   143					; 1011  PLERR	;FATAL PUSH LIST POINTER ERROR
   144					; 1012  PLERR1	;INITIAL PUSH LIST POINTER ERROR
   145					; 1013  MUOERR	;MUUO WITH LUUO HANDLER WIPED OUT
   146					; 1014  DTEBER	;DTE20 INTERRUPT WITHOUT DOORBELL
   147					; 1015  DTECER	;DTE20 CLOCK INTERRUPT WITHOUT FLAG SET
   148					; 1016  CPIERR	;CPU INITIALIZATION ERROR
   149					; 1017  EOPERR	;END OF PROGRAM ERROR
   150					; 1020  LUOERR	;INTERRUPT WITH LUUO HANDLER WIPED OUT
   151
   152					; **********************************************************************
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
PARAM	KLM	13-Jan-89 12:02		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, SEPT 18,1979

   153					; **********************************************************************
   154					;OPERATOR DEFINITIONS (NON-UUO'S)
   155					; **********************************************************************
   156
   157		260740	000000		OPDEF	GO	[PUSHJ	P,]	;SUBROUTINE CALL
   158		263740	000000		OPDEF	RTN	[POPJ	P,]	;SUBROUTINE RETURN 
   159		261740	000000		OPDEF	PUT	[PUSH	P,]	;PUT DATA ON PUSH LIST
   160		262740	000000		OPDEF	GET	[POP	P,]	;GET DATA FROM PUSH LIST 
   161		254000	000000		OPDEF	PJRST	[JRST	]	;JRST TO ROUTINE THAT RTN'S
   162		254200	000000		OPDEF	HALT	[JRST	4,]	;DEFINITION FOR DDT
   163		254100	000000		OPDEF	JRSTF	[JRST	2,]	;DEFINITION FOR DDT
   164		254500	000000		OPDEF	JEN	[JRST	12,]	;DEFINITION FOR DDT
   165
   166					; **********************************************************************
   167					;SUBROUTINE INITIALIZATION CALL
   168					; **********************************************************************
   169
   170		265000	030011		OPDEF	PGMINT	[JSP	0,SBINIT]	;SUBROUTINE INITIALIZATION
   171
   172					; **********************************************************************
   173					;HALTING UUO'S (A MORE GRACEFUL HALT THAN SIMPLY USING THE HALT INSTRUCTION).
   174					; **********************************************************************
   175
   176		037640	000004		OPDEF	FATAL	[37B8!15B12!4]	;FATAL PROGRAMMING HALT
   177		037600	000004		OPDEF	ERRHLT	[37B8!14B12!4]	;PROGRAM ERROR HALT
   178
   179					; **********************************************************************
   180					;TERMINAL INPUT UUO'S
   181					;ALWAYS COME FROM THE CONSOLE TERMINAL IN EXEC MODE OR THE
   182					;CONTROLLING TERMINAL (REAL TERMINAL OR PTY) IN USER MODE.
   183					; **********************************************************************
   184
   185		037000	000003		OPDEF	TTICHR 	[37B8!0B12!3]	;TTY, INPUT ANY CHARACTER
   186		037040	000003		OPDEF	TTIYES	[37B8!1B12!3]	;TTY, NORMAL RETURN Y
   187		037100	000003		OPDEF	TTINO	[37B8!2B12!3]	;TTY, NORMAL RETURN N
   188		037140	000003		OPDEF	TTIOCT	[37B8!3B12!3]	;TTY, INPUT OCTAL WORD
   189		037200	000003		OPDEF	TTIDEC	[37B8!4B12!3]	;TTY, INPUT DECIMAL WORD
   190		037240	000003		OPDEF	TTICNV	[37B8!5B12!3]	;TTY, INPUT CONVERTABLE WORD
   191		037300	000003		OPDEF	TTLOOK	[37B8!6B12!3]	;TTY, KEYBOARD CHECK
   192		037340	000003		OPDEF	TTALTM	[37B8!7B12!3]	;TTY, ALT-MODE CHECK
   193		037400	000003		OPDEF	TTSIXB	[37B8!10B12!3]	;TTY, INPUT SIXBIT WORD
   194		037440	000003		OPDEF	TTYINP	[37B8!11B12!3]	;TTY, IMAGE MODE INPUT
   195		037500	000003		OPDEF	TTICLR	[37B8!12B12!3]	;TTY, CLEAR INPUT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
PARAM	KLM	13-Jan-89 12:02		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, SEPT 18,1979

   196					;TERMINAL OUTPUT UUO'S.
   197
   198		037000	000000		OPDEF	PNTA	[37B8!0B12!0]	;PRINT ASCII WORD
   199		037000	000001		OPDEF	PNTAF	[37B8!0B12!1]	;PRINT ASCII WORD FORCED
   200		037740	000000		OPDEF	PNTAL	[37B8!17B12!0]	;PRINT ASCIZ LINE
   201		037740	000001		OPDEF	PNTALF	[37B8!17B12!1]	;PRINT ASCIZ LINE FORCED
   202		037600	000003		OPDEF	PSIXL	[37B8!14B12!3]	;PRINT SIXBIT'Z LINE
   203		037640	000003		OPDEF	PSIXLF	[37B8!15B12!3]	;PRINT SIXBIT'Z LINE FORCED
   204		037000	000000		OPDEF	PNTMSG	[37B8!0B12!0]	;PRINT MESSAGE IMMEDIATE
   205		037040	000000		OPDEF	PNTMSF	[37B8!1B12!0]	;PRINT MESSAGE IMMEDIATE FORCED
   206		037100	000000		OPDEF	PSIXM	[37B8!2B12!0]	;PRINT SIXBIT'Z MSG IMMEDIATE
   207		037200	000000		OPDEF	PSIXMF	[37B8!4B12!0]	;PRINT SIXBIT'Z MSG IMM FORCED
   208		037000	000000		OPDEF	PNTCI	[37B8!0B12!0]	;PRINT CHARACTER IMMEDIATE
   209		037040	000000		OPDEF	PNTCIF	[37B8!1B12!0]	;PRINT CHARACTER IMMEDIATE FORCED
   210		037500	000000		OPDEF	PNTCHR	[37B8!12B12!0]	;PRINT CHARACTER
   211		037500	000001		OPDEF	PNTCHF	[37B8!12B12!1]	;PRINT CHARACTER FORCED
   212		037040	000000		OPDEF	PNT1	[37B8!1B12!0]	;PRINT ONE OCTAL DIGIT
   213		037040	000001		OPDEF	PNT1F	[37B8!1B12!1]	;PRINT 1 OCTAL DIGIT FORCED	
   214		037100	000000		OPDEF	PNT2	[37B8!2B12!0]	;PRINT TWO OCTAL DIGITS
   215		037100	000001		OPDEF	PNT2F	[37B8!2B12!1]	;PRINT 2 OCTAL DIGITS FORCED	
   216		037140	000000		OPDEF	PNT3	[37B8!3B12!0]	;PRINT THREE OCTAL DIGITS
   217		037140	000001		OPDEF	PNT3F	[37B8!3B12!1]	;PRINT THREE OCTAL DIGITS FORCED	
   218		037200	000000		OPDEF	PNT4	[37B8!4B12!0]	;PRINT FOUR OCTAL DIGITS
   219		037200	000001		OPDEF	PNT4F	[37B8!4B12!1]	;PRINT FOUR OCTAL DIGITS FORCED
   220		037240	000000		OPDEF	PNT5	[37B8!5B12!0]	;PRINT FIVE OCTAL DIGITS
   221		037240	000001		OPDEF	PNT5F	[37B8!5B12!1]	;PRINT FIVE OCTAL DIGITS FORCED
   222		037300	000000		OPDEF	PNT6	[37B8!6B12!0]	;PRINT SIX OCTAL DIGITS
   223		037300	000001		OPDEF	PNT6F	[37B8!6B12!1]	;PRINT SIX OCTAL DIGITS FORCED
   224		037340	000000		OPDEF	PNT7	[37B8!7B12!0]	;PRINT 7 OCTAL DIGITS
   225		037340	000001		OPDEF	PNT7F	[37B8!7B12!1]	;PRINT 7 OCTAL DIGITS FORCED
   226		037440	000000		OPDEF	PNT11	[37B8!11B12!0]	;PRINT 11 OCTAL DIGITS
   227		037440	000001		OPDEF	PNT11F	[37B8!11B12!1]	;PRINT 11 OCTAL DIGITS FORCED.
   228		037400	000000		OPDEF	PNTADR	[37B8!10B12!0]	;PRINT PHYSICAL ADDRESS
   229		037400	000001		OPDEF	PNTADF	[37B8!10B12!1]	;PRINT PHYSICAL ADDRESS FORCED
   230		037600	000000		OPDEF	PNTOCT  [37B8!14B12!0]	;PRINT FULL WORD OCTAL
   231		037600	000001		OPDEF	PNTOTF	[37B8!14B12!1]	;PRINT FULL WORD OCTAL FORCED
   232		037540	000000		OPDEF	PNTHW	[37B8!13B12!0]	;PRINT OCTAL HALF WORDS, 6 SP 6
   233		037540	000001		OPDEF	PNTHWF	[37B8!13B12!1]	;PRINT OCTAL HALF WORDS, 6 SP 6 FORCED
   234		037700	000003		OPDEF	PNTOCS	[37B8!16B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S
   235		037740	000003		OPDEF	PNTOCF	[37B8!17B12!3]	;PRINT OCTAL, SUPPRESS LEADING 0'S FORCED
   236		037640	000000		OPDEF	PNTDEC	[37B8!15B12!0]	;PRINT DECIMAL, SUPRESS LEADING 0'S
   237		037640	000001		OPDEF	PNTDCF	[37B8!15B12!1]	;PRINT DECIMAL, SUPRESS LEADING 0'S FORCED
   238		037700	000000		OPDEF	PNTDS	[37B8!16B12!0]	;PRINT DECIMAL, SPACES FOR LD 0'S
   239		037700	000001		OPDEF	PNTDSF	[37B8!16B12!1]	;PRINT DECIMAL, SPACES FOR LD 0'S FORCED
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
PARAM	KLM	13-Jan-89 12:02		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, SEPT 18,1979

   240		037200	000002		OPDEF	PNTNM	[37B8!4B12!2]	;PRINT PROGRAM NAME
   241		037000	000002		OPDEF	PNTSIX	[37B8!0B12!2]	;PRINT SIXBIT WORD
   242		037040	000002		OPDEF	PNTSXF	[37B8!1B12!2]	;PRINT SIXBIT WORD FORCED
   243		037240	000002		OPDEF	DROPDV	[37B8!5B12!2]	;CLOSE LOGICAL FILE, USER MODE
   244		037100	000002		OPDEF	PNTCW	[37B8!2B12!2]	;PRINT DF10 CONTROL WORD
   245		037140	000002		OPDEF	PNTCWF	[37B8!3B12!2]	;PRINT DF10 CONTROL WORD FORCED
   246		037000	030242		OPDEF	PCRL	[37B8!0B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED
   247		037040	030242		OPDEF	PCRLF	[37B8!1B12!CRLF] ;PRINT CARRIAGE RETURN/LINE FEED FORCED
   248		037000	000040		OPDEF	PSP	[37B8!0B12!40]	;PRINT SPACE
   249		037040	000040		OPDEF	PSPF	[37B8!1B12!40]	;PRINT SPACE FORCED
   250		037000	030243		OPDEF	PCRL2	[37B8!0B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE)
   251		037040	030243		OPDEF	PCRL2F	[37B8!1B12!CRLF2] ;PRINT CARRIAGE RETURN/LINE FEED (TWICE) FORCED
   252		037040	000007		OPDEF	PBELL	[37B8!1B12!7]	;PRINT TTY BELL
   253
   254		037040	000026		OPDEF	PFORCE	[37B8!1B12!26]	;PRINT FORCE, CONTROL O OVERRIDE
   255
   256					DEFINE	PMSG	(ARG),<
   257						PSIXM	[SIXBIT\ARG'_\]>
   258
   259					DEFINE	PMSGF	(ARG),<
   260						PSIXMF	[SIXBIT\ARG'_\]>
   261
   262					;SIXBTZ -- MACRO TO GENERATE SIXBIT DATA FOR PRINTING
   263					;	CONSERVES CORE OVER ASCIZ
   264
   265					DEFINE	SIXBTZ	(ARG),<	[SIXBIT\ARG'_\]>
   266
   267					;CONSOLE SWITCH INPUT UUO.
   268					;READS CONSOLE SWITCHES IF IN EXEC MODE OR ASKS FOR THEM IF
   269					; USER MODE.
   270
   271		037400	000002		OPDEF	SWITCH	[37B8!10B12!2]	;INPUT CONSOLE SWITCHES
   272
   273					;CLOCK INITIALIZATION UUO - TO SET DESIRED CLOCK OPERATION
   274					;EITHER IGNORE CLOCK, ONLY LET IT TICK OR CAUSE INTERRUPT TO OCCUR.
   275
   276		037540	000004		OPDEF	CLOKOP	[37B8!13B12!4]	;CLOCK OPERATION UUO - PDP-11 CLOCK
   277		037200	000004		OPDEF	MTROP	[37B8!4B12!4]	;CLOCK OPERATION UUO - DK20 METER
   278
   279					;KL10 ONLY CACHE OPERATION UUO'S
   280
   281		037040	000004		OPDEF	CINVAL	[37B8!1B12!4]	;CACHE INVALIDATE
   282		037100	000004		OPDEF	CFLUSH	[37B8!2B12!4]	;CACHE FLUSH
   283		037140	000004		OPDEF	CWRTBI	[37B8!3B12!4]	;CACHE WRITE-BACK & INVALIDATE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
PARAM	KLM	13-Jan-89 12:02		*PARAM* PROGRAM/SUBROUTINE PARAMETERS, SEPT 18,1979

   284					;END OF PASS/PROGRAM UUOS
   285
   286					;PERFORMS THE END OF PASS FUNCTIONS. INCREMENT PASS COUNT,
   287					;DECREMENT ITERATION COUNT, CHECK IF FINISHED WITH THIS PROGRAM ETC.
   288
   289		037500	000004		OPDEF	ENDUUO	[37B8!12B12!4]	;UUO TO DISPLAY LIGHTS
   290		037700	000004		OPDEF	EOPUUO	[37B8!16B12!4]	;END OF PROGRAM UUO
   291
   292					;MEMORY MANAGEMENT UUO'S
   293					;UUO'S TO PERFORM VARIOUS MEMORY FUNCTIONS. MAPPING, ZEROING, PAGING,
   294					;ADDRESS CONVERSION, ETC...
   295
   296		037000	000004		OPDEF	MAPMEM	[37B8!0B12!4]	;MAP MEMORY
   297		037500	000002		OPDEF	MEMZRO	[37B8!12B12!2]	;ZERO MEMORY
   298		037440	000002		OPDEF	MEMSEG	[37B8!11B12!2]	;SETUP MEMORY SEGMENT
   299		037540	000002		OPDEF	MAPADR	[37B8!13B12!2]	;VIRTUAL TO PHYSICAL ADR CONVERT
   300		037640	000002		OPDEF	MAPCNK	[37B8!15B12!2]	;MAP MEMORY CHUNK
   301		037600	000002		OPDEF	MAPSET	[37B8!14B12!2]	;SET KI10 EXEC PAGE MAP
   302		037740	000002		OPDEF	MAPPNT	[37B8!17B12!2]	;PRINT MEMORY MAP
   303
   304					;DEVICE CODE MODIFICATION UUO
   305					;ALLOWS THE MODIFICATION OF IOT'S TO ONE DEVICE TO BE CHANGED TO
   306					;IOT'S TO A DIFFERENT DEVICE CODE.
   307
   308		037340	000002		OPDEF	MODPCU	[37B8!7B12!2]	;MODIFY PERHIPERAL CODE, USER
   309		037300	000002		OPDEF	MODPCP	[37B8!6B12!2]	;MODIFY PERHIPERAL CODE, PROGRAM
   310
   311						IFNDEF	MODDVL,<MODDVL==BEGIN>
   312						IFNDEF	MODDVU,<MODDVU==BEGIN>
   313
   314					;"DIAMON" FILE SELECTION AND READ UUOS
   315
   316		037240	000004		OPDEF	FSELECT	[37B8!5B12!4]	;FILE SELECTION
   317		037300	000004		OPDEF	FREAD	[37B8!6B12!4]	;FILE READ - ASCII DATA
   318		037340	000004		OPDEF	FRD36	[37B8!7B12!4]	;FILE READ - 36 BIT DATA
   319		037400	000004		OPDEF	FRD8	[37B8!10B12!4]	;FILE READ - 8 BIT DATA
   320
   321					;KI10 ONLY UUO FOR PRINTING MARGIN VALUES
   322
   323		037700	000002		OPDEF	PNTMGN	[37B8!16B12!2]	;PRINT MARGIN VALUE
   324
   325						XLIST
   326					IFNDEF	KLOLD,<LIST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
PARAM	KLM	13-Jan-89 12:02		ERROR HANDLING UUO DEFINITIONS, SEPT 18,1979

   327					SUBTTL	ERROR HANDLING UUO DEFINITIONS, SEPT 18,1979
   328
   329					; **********************************************************************
   330					;ERROR HANDLER PARAMETERS
   331					; **********************************************************************
   332
   333		036000	000000		OPDEF	ERUUO	[36B8]		;ERROR CALL UUO
   334		035000	000000		OPDEF	ERLOOP	[35B8]		;ERROR LOOP, CHECKS PC,REPT,REPT1,ERROR
   335		035040	000000		OPDEF	ERLP1	[35B8!1B12]	;ERROR LOOP IF PC'S MATCH
   336		035100	000000		OPDEF	ERLP2	[35B8!2B12]	;ERROR LOOP IF ANY ERROR
   337		034000	000000		OPDEF	REPTUO	[34B8]		;REPEAT LOOP UUO
   338
   339					;THE ERROR HANDLER MACROS
   340
   341					;A MACRO TO REPORT AN ERROR AND LOOP
   342
   343						DEFINE	ERROR	(ADR,FORMAT,CORECT,ACTUAL,F,D,ERR)<
   344												SALL
   345						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   346							   CORECT,,ACTUAL
   347							   [SIXBIT\D'_\],,ERR]
   348												XALL
   349						ERLOOP	ADR		;IF ERROR, LOOP TO ADR
   350					>
   351
   352					;A MACRO TO REPORT AN ERROR AND NOT LOOP
   353
   354						DEFINE	ERROR1	(FORMAT,CORECT,ACTUAL,F,D,ERR)<
   355												SALL
   356						ERUUO	FORMAT,[T,,[SIXBIT\F'_\]
   357							   CORECT,,ACTUAL
   358							   [SIXBIT\D'_\],,ERR]
   359												XALL>
   360
   361					>;END OF KLOLD CONDITIONAL
   362
   363						XLIST
   364						LIST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   365					SUBTTL	*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979
   366
   367	030000					LOC	30000
   368
   369					; **********************************************************************
   370					;PROGRAM STARTING ADDRESSES
   371					;THESE ADDRESSES CALL VARIOUS SPECIAL START ROUTINES AND OR OPTIONS
   372					;NORMAL START ADDRESS IS 30000 ALL OTHERS ARE SPECIAL. INVOKED BECAUSE
   373					;OF END OF PASS, POWER FAILURE, DDT START, RE-ENTERING(TYPICALLY USER
   374					;MODE), OR ANY NUMBER OF SPECIAL FEATURE TESTS.
   375					; **********************************************************************
   376
   377	030000	254 00 1 00 027776 	BEGIN:	JRST	@MODLNK		;STAND-ALONE START
   378	030001	254 00 0 00 030712 	$START:	JRST	START		;MODE CHECK STARTING ADDRESS
   379
   380	030002	254 00 1 00 027774 	DIAGMN:	JRST	@LDLNK		;DIAGNOSTIC MONITOR START
   381
   382	030003	254 00 1 00 027774 	SYSEXR:	JRST	@LDLNK		;SYSTEM EXERCISER START
   383
   384	030004	254 00 0 00 030742 	SFSTRT:	JRST	SADR1		;SPECIAL FEATURE START
   385
   386	030005	254 00 0 00 030742 	PFSTRT:	JRST	SADR2		;POWER FAIL RESTART
   387
   388	030006	254 00 0 00 030742 	REENTR:	JRST	SADR3		;REENTER START(USUALLY USER MODE ONLY)
   389
   390	030007				SRTDDT:				;COMMONLY MISTAKEN NAME FOR "DDTSRT"
   391	030007	254 00 1 00 027775 	DDTSRT:	JRST	@DDTLNK		;DDT START
   392
   393	030010	254 00 0 00 030742 	BEGIN1:	JRST	STARTA		;LOOP START(END OF PASS COMES HERE)
   394	030011	254 00 1 00 027777 	SBINIT:	JRST	@SUBLNK		;PMGINT LINKAGE
   395	030012	000000	000000		RETURN:	0			;RETURN ADDRESS STORAGE
   396
   397	030013	254000	030742		START1:	SADR7			;OPTIONAL STARTING ADR/INSTRUCTIONS
   398	030014	254000	030742		START2:	SADR8			; "
   399	030015	254000	030742		START3:	SADR9			; "
   400	030016	254000	030742		START4:	SADR10			; "
   401	030017	254000	030742		START5:	SADR11			; "
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   402					; **********************************************************************
   403					;PROGRAM FIXED PARAMETER AREA
   404					; **********************************************************************
   405
   406	030020	444653	414100		PNTNAM:	PAREA3		;SIXBIT PROGRAM NAME
   407	030021	645560	000000		PNTEXT:	PAREA4		;SIXBIT PROGRAM EXTENSION
   408	030022	000000	000000		RANDBS:	PAREA1		;RANDOM BASE NUMBER
   409	030023	000000	000000		SWTEXR:	PAREA2		;SYSTEM EXERCISER SWITCHES
   410	030024	000000	001000		ITRCNT:	ITERAT		;PROGRAM ITERATIONS
   411	030025	000000	030725		$PNAME:	PGMNAM		;POINTER TO PROGRAMS NAME
   412	030026	000000	000002		$PVER:	MCNVER,,DECVER	;MCN & DEC VERSION LEVEL
   413	030027	000000	030000		$MODVL:	MODDVL		;DEVICE CODE CHANGE LOWER LIMIT
   414	030030	000000	030000		$MODVU:	MODDVU		;DEVICE CODE CHANGE UPPER LIMIT
   415	030031	777777	777777		$EMODE:	IFNDEF EXCASB,<0> IFDEF EXCASB,<-1>	;EXEC ALLOWED
   416	030032	777777	777777		$UMODE:	IFNDEF USRASB,<0> IFDEF USRASB,<-1>	;USER ALLOWED
   417	030033	000000	000000		$DSKUP:	IFNDEF DSKUPD,<0> IFDEF DSKUPD,<-1>	;DISK UPDATE MODE
   418	030034	000000	000000		$MMAP:	IFNDEF MEMMAP,<0> IFDEF MEMMAP,<-1>	;ALLOW MEMORY RTNS
   419	030035	000000	000000		PAREA7:	PAREA5		;OPTIONAL PARAMETER
   420	030036	000000	000000		PAREA8:	PAREA6		;OPTIONAL PARAMETER
   421
   422					; **********************************************************************
   423					;PROGRAM VARIABLE PARAMETER AREA
   424					; **********************************************************************
   425
   426	030037	000000	000000		USER:	0		; 0 = EXEC, -1 = USER MODE FLAG
   427	030040	000000	000000		KAIFLG:	0		;PROCESSOR TYPE, 0 = KA10, -1 = KI10
   428	030041	000000	000000		KLFLG:	0		;PROCESSOR TYPE, 0 = KA/KI, -1 = KL10
   429	030042	777777	777777		MONFLG:	-1		;DIAG MONITOR SPECIAL USER FLAG
   430	030043	000000	000000		MONCTL:	0		;DIAG MON/SYS EXR FLAG
   431	030044	000000	000000		MONTEN:	0		;-1= LOADED BY 10
   432	030045	000000	000000		CLOCKF:	0		;CLOCK TICKED FLAG
   433	030046	000000	000000		CONSW:	0		;CONSOLE SWITCH SETTINGS
   434	030047	000000	000000		PASCNT:	0		;PROGRAM PASS COUNT
   435	030050	000000	000000		RUNFLG:	0		;PROGRAM RUN FLAG
   436	030051	000000	000000		TESTPC:	0		;SUBTEST PC
   437	030052	000000	000000		ERRPC:	0		;ERROR PC
   438	030053	000000	000000		ERRTLS:	0		;ERROR TOTALS
   439	030054	000000	000000		TICKS:	0		;PROGRAM RUNNING TIME
   440	030055	000000	000000		MARGIN:	0		;KI10 MARGIN WORD VALUE
   441	030056	000000	000000		$ONETM:	0		;SUBROUTINE INITIALIZATION FLAG
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   442					; **********************************************************************
   443					;SPECIAL PROGRAM DISPATCH ADDRESSES
   444					; **********************************************************************
   445
   446	030057	037 12 0 00 000004 	BEGEND:	ENDUUO		;END OF PASS
   447	030060	254 00 0 00 030010 	$BEND1:	JRST	BEGIN1	;KEEP RUNNING PROGRAM
   448	030061	037 16 0 00 000004 	$BEND2:	EOPUUO		;END OF PROGRAM - NO RETURN
   449	030062	254000	030742		CNTLC:	SADR5		;CONTROL C XFER ADDRESS
   450	030063	254000	030742		ALTMGO:	SADR6		;ALTMODE XFER ADDRESS
   451	030064				CPOPJ1:			;SKIP RETURN
   452	030064	350 00 0 17 000000 	UUOSKP:	AOS	(P)	;SKIP RETURN FROM UUO
   453	030065				CPOPJ:			;NON-SKIP REGULAR RETURN
   454	030065	263 17 0 00 000000 	UUOEXT:	RTN		;UUO RETURN
   455	030066	255 00 0 00 000000 	UUORTN:	JFCL		;ADDITIONAL USERS UUO ROUTINE
   456	030067	255 00 0 00 000000 	$UORTX:	JFCL		;ADDITIONAL UUO LINKAGE
   457	030070	255 00 0 00 000000 	$UUOER:	JFCL		;INITED AS (JRST $UOERX)
   458	030071	255 00 0 00 000000 	$ITRHL:	JFCL		;ADDITIONAL INTERRUPT LINKAGE
   459	030072	255 00 0 00 000000 	$ITRX1:	JFCL		; "
   460	030073	255 00 0 00 000000 	$USRHL:	JFCL		; "
   461	030074	255 00 0 00 000000 	$RSRTX:	JFCL		;ADDITIONAL POWER FAIL LINKAGE
   462	030075	255 00 0 00 000000 	$RSRTY:	JFCL		; "
   463	030076	255 00 0 00 000000 	RESRT1:	JFCL		; INITED AS (JRST RESRTX)
   464	030077	255 00 0 00 000000 	RESRT2:	JFCL		; "
   465	030100	255 00 0 00 000000 	$PARER:	JFCL		;ADDITIONAL PARITY ERROR LINKAGE
   466	030101	255 00 0 00 000000 	ERMORE:	JFCL		;ADDITIONAL ERROR HANDLER LINKAGE
   467	030102	254 04 0 00 030102 		HALT	.	;IMPROPER TRANSFER HALT
   468
   469	030103	000000	000000		$PSHER:	0		;INITED AS (JRST PSHERR)
   470	030104	000000	000000		ITRCH1:	0		;PC & FLAGS OF CURRENT INTERRUPT
   471	030105	000000	000000			0		;INITED AS (JRST $ITRC1)
   472
   473					; **********************************************************************
   474					;PROCESSOR CONTROL STORAGE
   475					; **********************************************************************
   476
   477	030106	000000	000000		$ACC0:	0		;INTERRUPT SAVED AC0
   478	030107	000000	000000		$SVPI:	0		;INTERRUPT SAVED PI
   479	030110	000000	000000		$SVAPR:	0		;INTERRUPT SAVED APR
   480	030111	000000	000000		$SVPAG:	0		;INTERRUPT SAVED PAG (DATAI)
   481	030112	000000	000000		$SPAG1:	0		;INTERRUPT SAVED PAG (CONI)
   482
   483	030113	000000	000000		$SVUUO:	0		;CURRENT USERS UUO
   484	030114	000000	000000		$SVUPC:	0		;PC OF CURRENT USERS UUO
   485
   486	030115	000000	000000		REPTU:	0		;REPEAT UUO ITERATIONS
   487	030116	000000	000000		SCOPE:	0		;ERROR HANDLER SCOPE LOOP FLAG
   488	030117	000000	000000		%CORFLG:0		; " CORRECT FLAG
   489	030120	000000	000000		%COREC:	0		; " CORRECT DATA
   490	030121	000000	000000		%ACTFL:	0		; " ACTUAL FLAG
   491	030122	000000	000000		%ACTUL:	0		; " ACTUAL DATA
   492	030123	000000	000000		%DISCR:	0		; " DISCREPENCY DATA
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   493					; **********************************************************************
   494					;UUO DISPATCH TABLE
   495					; **********************************************************************
   496						XLIST
   497						LIST
   498	030124	030070	030070		UUODIS:	LUUO1,,$UUOER
   499	030125	030070	030070			LUUO3,,LUUO2
   500	030126	030070	030070			LUUO5,,LUUO4
   501	030127	030070	030070			LUUO7,,LUUO6
   502	030130	030070	030070			LUUO11,,LUUO10
   503	030131	030070	030070			LUUO13,,LUUO12
   504	030132	030070	030070			LUUO15,,LUUO14
   505	030133	030070	030070			LUUO17,,LUUO16
   506	030134	030070	030070			LUUO21,,LUUO20
   507	030135	030070	030070			LUUO23,,LUUO22
   508	030136	030070	030070			LUUO25,,LUUO24
   509	030137	030070	030070			LUUO27,,LUUO26
   510	030140	030070	030070			LUUO31,,LUUO30
   511	030141	030070	030070			LUUO33,,LUUO32
   512
   513					; **********************************************************************
   514					;MEMORY MANAGMENT STORAGE
   515					; **********************************************************************
   516
   517	030142	000000	000000		DF22F:	0		;DF10 CONTROL FLAG, 0 = 18, -1 = 22 BIT
   518	030143	000000	000000		MAPNEW:	0		;MEMORY MAPPING CONTROL FLAG, -1 = 4096K MAPPING
   519	030144	000000	000000		MEMTOT:	0		;TOTAL MEMORY SIZE IN K (1024.)
   520	030145	000000	000000		MEMLOW:	0		;LOWEST USABLE MEMORY
   521	030146				MEMSIZ:	BLOCK ^D41	;MEMORY SEGMENT POINTER TABLE
   522
   523					; **********************************************************************
   524					;PRINT CONTROL STORAGE
   525					; **********************************************************************
   526
   527	030217	000000	000000		PNTFLG:	0		;PRINT FLAG, -1 WHILE IN PRINT ROUTINE
   528	030220	000000	000000		PNTENB:	0		;PRINT ENABLE
   529	030221	000000	000000		PDISF:	0		;PRINT DISABLED FLAG
   530	030222	000000	000000		PNTINH:	0		;INHIBIT PRINT INPUT CHECKS
   531	030223	000000	000000		PNTSPC:	0		;PRINT SPACE CONTROL
   532	030224	000000	000000		OPTIME:	0		;TYPE-IN WAIT TIME
   533	030225	000000	000000		$TWCNT:	0		;TIME WAITED
   534	030226	000000	000000		$DVOFF:	0		;LOGICAL DEVICE INITED FLAG
   535	030227	000000	000000		TTYFIL:	0		;TTY EXEC FILLERS FLAG
   536	030230	000000	000000		TTYSPD:	0		;TTY EXEC BAUD RATE
   537	030231	000000	000000		$TTCHR:	0		;ACTUAL TYPED IN CHAR
   538	030232	000000	000000		$CHRIN:	0		;UPPER CASED & PARITY STRIPPED CHAR
   539	030233	000000	000000		$TYPNB:	0		;TYPED IN NUMBER
   540	030234	000000	000000		$CRLF:	0		;FREE CR/LF FLAG
   541	030235	000000	000000		$TABF:	0		;TAB CONVERSION FLAG
   542	030236	000000	000000		$FFF:	0		;FORM FEED CONVERSION FLAG
   543	030237	000000	000000		$VTF:	0		;VERTICAL TAB CONVERSION FLAG
   544	030240	000000	000000		USRLFF:	0		;USER LF FILLERS
   545	030241	000000	000000		USRCRF:	0		;USER CR FILLERS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   546					; **********************************************************************
   547					;THE FOLLOWING MISCELLANEOUS PRINT CHARACTERS ARE INCLUDED
   548					;TO FACILITATE PRINTING AND ARE CALLED AS FOLLOWS:
   549					;	MOVEI	NAME
   550					;	PNTA		;OR PNTAF
   551					; **********************************************************************
   552
   553	030242				CRLF:	ASCII/
   554	030242	015 012 000 000 000 	/
   555	030243				CRLF2:	ASCII/
   556
   557	030243	015 012 015 012 000 	/
   558	030244	054 000 000 000 000 	COMMA:	ASCII/,/
   559	030245	056 000 000 000 000 	PERIOD:	ASCII/./
   560	030246	040 000 000 000 000 	SPACE:	ASCII/ /
   561	030247	011 000 000 000 000 	TAB:	ASCII/	/
   562	030250				MINUS:
   563	030250	055 000 000 000 000 	HYPEN:	ASCII/-/
   564	030251	053 000 000 000 000 	PLUS:	ASCII/+/
   565	030252	052 000 000 000 000 	AST:	ASCII/*/
   566	030253	100 000 000 000 000 	ATSIN:	ASCII/@/
   567	030254	050 000 000 000 000 	LFP:	ASCII/(/
   568	030255	051 000 000 000 000 	RTP:	ASCII/)/
   569	030256	007 0000000000 		BELL:	BYTE (7) 007
   570	030257	077 000 000 000 000 	QUEST:	ASCII/?/
   571	030260	057 000 000 000 000 	SLASH:	ASCII!/!
   572	030261	044 000 000 000 000 	DOLLAR:	ASCII/$/
   573	030262	000000	000012		RADIX:	^D10			;DECIMAL PRINT RADIX
   574	030263	000000	000040		RADLSP:	40			;DECIMAL PRINT LEADING CHAR
   575	030264	000000	000012		RADLSC:	^D10			;DECIMAL PRINT LEADING CHAR COUNT
   576
   577					; **********************************************************************
   578					;USER MODE OUTPUT FILE INFORMATION
   579					; **********************************************************************
   580
   581	030265				$OBUF:	BLOCK	3		;LOGICAL FILE OUTPUT BUFFER HEADER
   582	030270	60 62 51 56 64 00 	$OUTNM:	SIXBIT	/PRINT/		;FILE NAME
   583	030271	60 56 64 00 00 00 	$OUTEX:	SIXBIT	/PNT/		;FILE NAME EXTENSION
   584	030272					BLOCK	2
   585
   586					; **********************************************************************
   587					;DISK UPDATE MODE FILE INFORMATION
   588					; **********************************************************************
   589
   590	030274				$IBUF:	BLOCK	3
   591	030277	60 62 51 56 64 00 	$INNM:	SIXBIT	/PRINT/
   592	030300	60 56 64 00 00 00 	$INEXT:	SIXBIT	/PNT/
   593	030301					BLOCK	2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   594					; **********************************************************************
   595					;PUSHDOWN LIST CONTROL INFORMATION
   596					; **********************************************************************
   597
   598	030303	777577	030303		PLIST:	PLIST-PLISTE,,PLIST
   599	030304				PLISTS:	BLOCK	200
   600	030504	000000	000000		PLISTE:	0		;END OF PUSHDOWN LIST
   601
   602					; **********************************************************************
   603					;POWER LINE CLOCK FREQUENCY FLAG
   604					; **********************************************************************
   605
   606	030505	000000	000000		CYCL60:	0	;0 = 60, -1 = 50 CYCLE
   607
   608					; **********************************************************************
   609					;KL10 CACHE CONTROL FLAGS
   610					; **********************************************************************
   611
   612	030506	000000	000000		CSHFLG:	0	;ALLOW CACHE IF 0
   613	030507	000000	000000		CSHMEM:	0	;CACHE MEMORY SEGMENTS IF 0
   614
   615					; **********************************************************************
   616					;NUMBER INPUT DIGIT FLAG
   617					; **********************************************************************
   618
   619	030510	000000	000000		TTNBRF:	0	;-1 IF ANY DIGIT TYPED
   620
   621					; **********************************************************************
   622					;KL10 & KI10 "INHPAG" SWITCH PAGING PREVENTION
   623					; **********************************************************************
   624
   625	030511	000000	000000		PVPAGI:	0	;IF NON-ZERO, OVERRIDE "INHPAG" SWITCH ACTION
   626
   627					; **********************************************************************
   628					;ERROR REPORTING ROUTINE ADDITIONAL USERS CONTROL INSTRUCTIONS
   629					; **********************************************************************
   630
   631	030512	000000	000000		%ERHI1:	0	;IF NON-ZERO, XCT'D AT START OF %ERUUO
   632	030513	000000	000000		%ERHI2:	0	;IF NON-ZERO, XCT'D AT END OF %ERUUO
   633	030514	000000	000000		%ERHI3:	0	;IF NON-ZERO, XCT'D AFTER "PC" OF %ERUUO
   634
   635					; **********************************************************************
   636					;SPECIAL USERS UUO INTERCEPT INSTRUCTION
   637					; **********************************************************************
   638
   639	030515	000000	000000		$$UUO:	0	;IF NON-ZERO, XCT'D AT START OF $UORTN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   640					; **********************************************************************
   641					;USER MODE MONITOR TYPE FLAG
   642					; **********************************************************************
   643
   644	030516	000000	000000		MONTYP:	0	;0 = TOPS10, -1 = TOPS20
   645
   646					;*********************************************************************^
   647					;*KL10 PROCESSOR TYPE FLAG, 0=P0, 1=BBD NEW, 2=BBD OLD
   648					;*********************************************************************^
   649
   650	030517	000000	000000		KLTYP:	0
   651
   652					; **********************************************************************
   653					;SPECIAL USERS MUUO INTERCEPT INSTRUCTION
   654					; **********************************************************************
   655
   656	030520	000000	000000		$$MUUO:	0	;IF NON-ZERO, XCT'D AT START OF MUUOER
   657
   658					; **********************************************************************
   659					;SPECIAL USERS USER MODE OUTPUT ERROR INTERCEPT INSTUCTION
   660					; **********************************************************************
   661
   662	030521	000000	000000		$$OUTER:0	;IF NON-ZERO, XCT'D AT END OF USER MODE ERROR
   663
   664					; **********************************************************************
   665					;"SWITCH" CALL USAGE CONTROL
   666					; **********************************************************************
   667
   668	030522	000000	000000		$$TOGGLE:0	;IF NON-ZERO, USE C(CONSW) FOR SWITCHES
   669
   670					; **********************************************************************
   671					;SPECIAL USERS ALTMODE SWITCH CALL INTERCEPT INSTRUCTIONS
   672					; **********************************************************************
   673
   674	030523	000000	000000		$$TAX1:	0	;IF NON-ZERO, XCT'D AT START OF ALTMODE SWITCH CALL
   675	030524	000000	000000		$$TAX2:	0	;IF NON-ZERO, XCT'D AT END OF ALTMODE SWITCH CALL
   676
   677					; **********************************************************************
   678					;SM10 (KS-10) PROCESSOR TYPE FLAG
   679					; **********************************************************************
   680
   681	030525	000000	000000		SM10:	0	;IF -1 THIS IS A KS-10
   682
   683					; **********************************************************************
   684					;RIGHT HALF SWITCHES PROMPT TABLE ADDRESS
   685					; **********************************************************************
   686
   687	030526	000000	000000		SWPTAB:	0	;0 = NO PROMPT, ADR = ADR OF SIXBIT PROMPT TABLE
   688
   689					; **********************************************************************
   690					;SPECIAL FUTURE EXPANSION ROOM
   691					; **********************************************************************
   692
   693					; **********************************************************************
   694					;END OF FIXED STORAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-1
FIXED	KLM	26-Mar-96 10:07		*FIXED* FIXED CONTROL AND DISPATCH STORAGE, SEPT 18,1979

   695					; **********************************************************************
   696
   697	030577					LOC	30577
   698	030577	000000	000000		ENDFIX:	0		;END OF FIXED STORAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
SPCCPU	KLM	13-Jan-89 11:46		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76

   699					SUBTTL	*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76
   700
   701					;NEW DEFINITIONS USED BY THE KL10 SUBROUTINE PACKAGE
   702
   703			000000		AC0=	0
   704			030000		DIAGNOS=30000		;PDP-10 DIAGNOSTIC START ADDRESS
   705			010000		DDT=	10000		;PDP-10 DDT START ADDRESS
   706			020000		DIAMON=	20000		;PDP-10 DIAMON LOADER START ADDRESS
   707			020000		DONG11=	1B22		;11 DOORBELL (FROM THE 10)
   708
   709					;DTE20 DEVICE CODES
   710
   711			000200		DTE==	200		;DTE0
   712			000204		DTE0==	204
   713			000204		DTE1==	204
   714			000210		DTE2==	210
   715			000214		DTE3==	214
   716
   717					;KL10 EPT COMMUNICATION AREA
   718
   719			000440		$STD=	440		;PDP-10 DIAGNOSTIC START ADDRESS
   720			000441		$DDT=	441		;PDP-10 DDT START ADDRESS
   721			000442		$STL=	442		;PDP-10 LOADER START ADDRESS
   722			000443		$STM=	443		;PDP-10 MONITOR START ADDRESS
   723
   724			000444		$DTFLG=	444		;DTE20 OPERATION COMPLETE FLAG
   725			000445		$DTCLK=	445		;DTE20 CLOCK INTERRUPT FLAG
   726			000446		$DTCI=	446		;DTE20 CLOCK INTERRUPT INSTRUCTION
   727			000447		$DTT11=	447		;DTE20 10 TO 11 ARGUMENT
   728			000450		$DTF11=	450		;DTE20 11 TO 10 ARGUMENT
   729			000451		$DTCMD=	451		;DTE20 TO 11 COMMAND WORD
   730			000452		$DTSEQ=	452		;DTE20 OPERATION SEQUENCE NUMBER
   731			000453		$DTOPR=	453		;DTE20 OPERATIONAL DTE #
   732			000454		$DTCHR=	454		;DTE20 LAST TYPED CHARACTER
   733			000455		$DTMTD=	455		;DTE20 MONITOR TTY OUTPUT COMPLETE FLAG
   734			000456		$DTMTI=	456		;DTE20 MONITOR TTY INPUT FLAG
   735
   736			000457		$DTSWR=	457		;DTE20 CONSOLE SWITCH REGISTER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
SPCCPU	KLM	13-Jan-89 11:46		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76

   737					;SPECIAL "FIXED" REASSIGNMENTS
   738
   739			030600			$$LOC=.			;SAVE CURRENT LOCATION
   740
   741	030000					LOC	30000
   742	030000	254 00 0 00 030600 	$$BEGIN:JRST	$$START		;SETUP SPECIAL START
   743	030001	254 00 0 00 030600 		JRST	$$START		;"DIAMON" CHAIN START ADDRESS
   744
   745	000440					LOC	440
   746	000440	254 00 0 00 030000 	$STD:	JRST	BEGIN		;SETUP FOR "STD"
   747	000443					LOC	443
   748	000443	254 00 0 00 030636 	$STM:	JRST	$SPEC		;SIMPLE RUN CONTROL
   749
   750	030057					LOC	30057
   751	030057	254 00 0 00 030641 	$BEGEND:JRST	$SPBEND		;SETUP SPECIAL "BEGEND"
   752
   753					;SPECIAL MUUO, TRAP & PAGE FAIL SETUP
   754
   755	000420					LOC	420
   756	000420	254 04 0 00 000420 	$$420:	HALT	.		;KI10 PAGE FAIL
   757	000421	255 00 0 00 000000 	$$421:	JFCL			;OVERFLOW
   758	000422	254 04 0 00 000422 	$$422:	HALT	.		;PUSHDOWN OVERFLOW
   759	000423	254 04 0 00 000423 	$$423:	HALT	.		;TRAP 3
   760	000424	000000	000000		$$424:	0			;MMUO
   761	000425	000000	000000		$$425:	0			;MMUO PC
   762	000426	000000	000000		$$426:	0			;KI10-PAGE FAIL, KL10-PROCESS CONTEXT
   763	000427	254 04 0 00 000427 	$$427:	HALT	.
   764	000430	000000	000427		$$430:	427			;MMUO NEW PC'S
   765	000431	000000	000427		$$431:	427
   766	000432	000000	000427		$$432:	427
   767	000433	000000	000427		$$433:	427
   768	000434	000000	000427		$$434:	427
   769	000435	000000	000427		$$435:	427
   770	000436	000000	000427		$$436:	427
   771	000437	000000	000427		$$437:	427
   772
   773	000500					LOC	500
   774	000500	000000	000000		$$500:	0			;KL10 PAGE FAIL WORD
   775	000501	000000	000000		$$501:	0			;KL10 PAGE FAIL PC
   776	000502	000000	000503		$$502:	503			;KL10 PAGE FAIL NEW PC
   777	000503	254 04 0 00 000503 	$$503:	HALT	.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
SPCCPU	KLM	13-Jan-89 11:46		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76

   778	030600					LOC	$$LOC		;RESET CURRENT LOCATION
   779
   780					;SPECIAL STARTUP SEQUENCE
   781
   782	030600	402 00 0 00 030037 	$$START:SETZM	USER
   783	030601	265 00 0 00 030602 		JSP	0,.+1		;IN USER MODE ?
   784	030602	603 00 0 00 010000 		TLNE	0,USERF
   785	030603	476 00 0 00 030037 		SETOM	USER		;YES, SET CONTROL WORD
   786	030604	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
   787	030605	402 00 0 00 030037 		SETZM	USER		;YES, RUN AS EXEC
   788	030606	332 00 0 00 030037 		SKIPE	USER
   789	030607	254 00 0 00 030712 		JRST	START		;USER MODE, DON'T NEED CPU TYPE
   790
   791	030610	336 00 0 00 030044 	$STKIL:	SKIPN	MONTEN		;LOADED BY "DIAMON" ?
   792	030611	476 00 0 00 030024 		SETOM	ITRCNT		;NO, RUN FOREVER
   793	030612	402 00 0 00 030517 		SETZM	KLTYP
   794	030613	402 00 0 00 030041 		SETZM	KLFLG		;ASSUME KI10
   795	030614	200 01 0 00 070251 		MOVE	1,[1,,1]
   796	030615	251 01 0 00 000001 		BLT	1,1		;HOPE THIS WORKS
   797	030616	316 01 0 00 070251 		CAMN	1,[1,,1]	;IF AC NE 1,,1 AFTER BLT, KL10
   798	030617	254 00 0 00 030712 		JRST	START		;KI10, NO ADDITIONAL SETUP
   799
   800	030620	7 000 20 0 00 010040 	$STKL:	CONO	APR,10040	;SET BBD NOT BIT
   801	030621	7 000 24 0 00 000000 		CONI	APR,0
   802	030622	7 000 20 0 00 020040 		CONO	APR,20040	;CLEAR BBD NOT BIT
   803	030623	606 00 0 00 000040 		TRNN	0,40		;IF SET, KL10
   804	030624	350 00 0 00 030517 		AOS	KLTYP		;IF NOT, BBD
   805	030625	402 00 0 00 000444 		SETZM	$DTFLG
   806	030626	402 00 0 00 000445 		SETZM	$DTCLK
   807	030627	200 00 0 00 000453 		MOVE	$DTOPR		;GET DTE #
   808	030630	436 00 0 00 030670 		ORM	$$DTE0		;INSERT IN DTE I/O INSTS
   809	030631	436 00 0 00 030672 		ORM	$$DTE1
   810	030632	436 00 0 00 030704 		ORM	$$DTE2
   811	030633	436 00 0 00 030706 		ORM	$$DTE3
   812	030634	476 00 0 00 030041 		SETOM	KLFLG		;SET KL10 CONTROL FLAG
   813	030635	254 00 0 00 030712 		JRST	START
   814
   815	030636	200 00 0 00 070252 	$SPEC:	MOVE	[JRST STARTA]	;SIMPLE RUN CONTROL
   816	030637	202 00 0 00 030643 		MOVEM	$SPB1
   817	030640	254 00 0 00 030712 		JRST	START
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
SPCCPU	KLM	13-Jan-89 11:46		*SPCCPU* SPECIAL BASIC CPU PROCESSOR CONTROL, 26-FEB-76

   818					;SPECIAL "BEGEND" ROUTINE
   819
   820	030641	350 00 0 00 030047 	$SPBEND:AOS	PASCNT		;INCREMENT PASS COUNT
   821	030642	370 00 0 00 030024 		SOS	ITRCNT		;DECREMENT ITERATION COUNT
   822	030643	336 00 0 00 030037 	$SPB1:	SKIPN	USER
   823	030644	254 00 0 00 030652 		JRST	$SPBEX		;EXEC MODE
   824
   825	030645	332 00 0 00 030024 	$SPBUS:	SKIPE	ITRCNT		;USER MODE, COMPLETED ?
   826	030646	254 00 0 00 030742 		JRST	STARTA		;NO, KEEP RUNNING
   827	030647	336 00 0 00 030044 		SKIPN	MONTEN		;DONE, LOADED BY "DIAMON" ?
   828	030650	047 00 0 00 000012 		EXIT			;NO, RETURN TO MONITOR
   829	030651	254 00 1 00 030012 		JRST	@RETURN		;YES, RETURN TO "DIAMON"
   830
   831	030652	332 00 0 00 030041 	$SPBEX:	SKIPE	KLFLG
   832	030653	254 00 0 00 030660 		JRST	$SPBKL		;KL10 & EXEC
   833	030654	7 004 14 0 00 030024 		DATAO	PI,ITRCNT	;KI10 & EXEC, DISPLAY ITER COUNT
   834	030655	332 00 0 00 030024 		SKIPE	ITRCNT
   835	030656	254 00 0 00 030742 		JRST	STARTA		;NOT COMPLETED YET
   836	030657	254 00 1 00 030012 		JRST	@RETURN		;DONE
   837
   838	030660	336 00 0 00 030024 	$SPBKL:	SKIPN	ITRCNT
   839	030661	254 00 0 00 030676 		JRST	$SPKLD		;KL10, EXEC & COMPLETED
   840
   841	030662	335 00 0 00 030043 		SKIPGE	MONCTL
   842	030663	254 00 0 00 030742 		JRST	STARTA		;"DIAMON" CONTROL
   843	030664	201 00 0 00 000404 		MOVEI	0,404		;NOTIFY PDP-11 OF END OF PASS
   844	030665	202 00 0 00 000451 		MOVEM	0,$DTCMD
   845	030666	402 00 0 00 000444 		SETZM	$DTFLG
   846	030667	336 00 0 00 030517 		SKIPN	KLTYP
   847	030670	7 200 20 0 00 020000 	$$DTE0:	CONO	DTE,DONG11
   848	030671	332 00 0 00 030517 		SKIPE	KLTYP
   849	030672	7 200 20 0 00 010000 	$$DTE1:	CONO	DTE,10000
   850	030673	336 00 0 00 000444 		SKIPN	$DTFLG		;WAIT TILL 11 RESPONDS
   851	030674	254 00 0 00 030673 		JRST	.-1
   852	030675	254 00 0 00 030742 		JRST	STARTA		;KEEP RUNNING
   853
   854					;SPECIAL KL10 COMPLETED ROUTINE
   855
   856	030676	332 00 0 00 030044 	$SPKLD:	SKIPE	MONTEN
   857	030677	254 00 1 00 030012 		JRST	@RETURN		;LOADED BY "DIAMON"
   858
   859	030700	201 00 0 00 000403 		MOVEI	0,403		;NOTIFY PDP-11 OF COMPLETION
   860	030701	202 00 0 00 000451 		MOVEM	0,$DTCMD
   861	030702	402 00 0 00 000444 		SETZM	$DTFLG
   862	030703	336 00 0 00 030517 		SKIPN	KLTYP
   863	030704	7 200 20 0 00 020000 	$$DTE2:	CONO	DTE,DONG11
   864	030705	332 00 0 00 030517 		SKIPE	KLTYP
   865	030706	7 200 20 0 00 010000 	$$DTE3:	CONO	DTE,10000
   866	030707	336 00 0 00 000444 		SKIPN	$DTFLG		;SHOULD NEVER HAPPEN
   867	030710	254 00 0 00 030707 		JRST	.-1		;11 NEVER RETURNS ON END OF PROGRAM
   868	030711	254 04 0 00 030000 		HALT	BEGIN		;IF IT DOES, HALT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA1	MAC	13-Jan-89 10:22		DIAGNOSTIC SECTION

   869					SUBTTL	DIAGNOSTIC SECTION
   870
   871	030712	402 00 0 00 030037 	START:	SETZM	USER#		;CLEAR USER CONTROL WORD
   872	030713	265 00 0 00 030714 		JSP	0,.+1		;GET FLAGS
   873	030714	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE?
   874	030715	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
   875	030716	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE?
   876	030717	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
   877	030720	336 00 0 00 030037 		SKIPN	USER
   878	030721	254 00 0 00 030742 		JRST	STARTA
   879	030722	331 00 0 00 030043 		SKIPL	MONCTL
   880	030723	051 03 0 00 030725 		TTCALL	3,PGMNAM
   881	030724	254 00 0 00 030742 		JRST	STARTA
   882
   883	030725				PGMNAM:	ASCIZ/
   884	030725	015 012 104 105 103 	DECSYSTEM10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) [DFKAA]
   885	030726	123 131 123 124 105 
   886	030727	115 061 060 040 113 
   887	030730	114 061 060 040 102 
   888	030731	101 123 111 103 040 
   889	030732	111 116 123 124 122 
   890	030733	125 103 124 111 117 
   891	030734	116 040 104 111 101 
   892	030735	107 116 117 123 124 
   893	030736	111 103 040 050 061 
   894	030737	051 040 133 104 106 
   895	030740	113 101 101 135 015 
   896	030741	012 000 000 000 000 	/
   897
   898					;BASIC INSTRUCTION TEST (1)
   899					;THE TEST IS DESIGNED FOR INITIAL DEBUGGING OF
   900					;PROCESSOR HARDWARE AND TO DETECT (SOLID) FAILURES
   901					;IN THE FIELD.
   902
   903
   904	030742	254 00 0 00 030743 	STARTA:	JRST	.+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

   905					SUBTTL	TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS
   906
   907					;NOTE: AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT IT IS THE TESTED
   908					;INSTRUCTION.
   909					;**********
   910
   911					;THIS TEST VERIFIES THAT SKIPA ALWAYS SKIPS THE NEXT INSTRUCTION
   912
   913			030743		A00=.
   914	030743	334 00 0 00 000000 	A12500:	SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   915	030744	254 04 0 00 000000 		HALT			;IF PROGRAM HALTS, SKIPA DID NOT SKIP
   916
   917					;IF PROGRAM HANGS UP ON SKIPA INSTRUCTION, CHECK AB PC EN [ABC], AB PC F/F [ABC],
   918					;AB PC B [ABC OR AB], AB PC (FETCH) EN [ABC], IR SKIPS [IR3], IR SKIPX [IR1],
   919					;IR 3XX [IR1], IR BITS 00 - 08 [IR1], F CYC ACT EN C [FI], FT6 F/F [F2],
   920					;PC CLOCK EN [PCC],  ET2 J F/F [E], PC CLK (ET2) EN [PCC], ADZ COND P [ADZ] AND
   921					;ADZ COND R [ADZ], PC CLOCK A [PCC], PC CLOCK B [PCC]
   922
   923					;IF PROGRAM HALTED ON HALT INSTRUCTION, CHECK ST1 COND [ST2]
   924
   925					;**********
   926
   927					;THIS TEST VERIFIES THAT JUMP NEVER JUMPS
   928
   929	030745	320 00 0 00 030746 	A15000:	JUMP	.+1		;*JUMP SHOULD NEVER JUMP
   930	030746	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
   931	030747	254 04 0 00 000000 		HALT			;HALT IF JUMP FAILS
   932
   933					;IF PROGRAM HANGS UP ON JUMP .+1 INSTRUCTION, THE JUMP INSTRUCTION
   934					;MAY HAVE FAILED.  CHECK ST1 COND [ST2], ST INST FET ST1 EN [ST2], ET2 D F/F [E],
   935					;IR JUMPS [IR1], IR JUMPX [IR1]
   936
   937					;**********
   938					;THIS TEST VERIFIES THAT JUMP NEVER JUMPS
   939
   940	030750	320 00 0 00 030752 	A15100:	JUMP	.+2		;*JUMP SHOULD NEVER JUMP
   941	030751	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMP IS SUCCESSFUL
   942	030752	254 04 0 00 000000 		HALT			;HALT IF JUMP FAILS
   943
   944					;AB PC EN [ABC]
   945
   946					;**********
   947
   948					;THIS TEST VERIFIES THAT JUMPA .+1 ALWAYS JUMPS TO THE NEXT INSTRUCTION
   949
   950	030753	324 00 0 00 030754 	A12700:	JUMPA	.+1		;*JUMPA .+1 SHOULD NEVER JUMP
   951	030754	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF JUMPA IS SUCCESSFUL
   952	030755	254 04 0 00 000000 		HALT			;HALT IF JUMPA .+1 FAILED
   953
   954					;**********
   955
   956					;THIS TEST VERIFIES THAT JUMPA JUMPS TO THE LOCATION SPECIFIED BY E WHEN E=.+2
   957
   958	030756	324 00 0 00 030760 	A12600:	JUMPA	.+2		;*JUMPA .+2 SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   959	030757	254 04 0 00 000000 		HALT			;PROGRAM HALTS HERE IF JUMPA .+2 FAILS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

   960
   961					;ST1 COND [ST2]
   962
   963					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

   964					;THIS TEST VERIFIES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
   965					;INSTRUCTION.
   966					;THE MOVE [0] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.
   967
   968	030760	200 00 0 00 070253 	A100:	MOVE	[0]		;PRESET LOCATION 0 TO ALL ZEROS
   969	030761	334 00 0 00 000000 		SKIPA			;*SKIPA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION
   970						STOP^
   971	030762	254 04 0 00 030763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   972	030763	324 00 0 00 030764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   973									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   974									;IN THE SUBTEST) TO LOOP ON ERROR^
   975
   976					;**********
   977					;THIS TEST INSURES THAT SKIPA IS DATA INDEPENDENT.  HENCE, IT ALWAYS SKIPS THE NEXT
   978					;INSTRUCTION.
   979					;THE MOVE [-1] INSTRUCTION IS USED TO TEST THE DATA INDEPENDENCE OF SKIPA.
   980
   981	030764	200 00 0 00 070254 	A200:	MOVE	[-1]		;PRESET LOCATION 0 TO ALL ONES
   982	030765	334 00 0 00 000000 		SKIPA			;*SKIPA SKOULD ALWAYS SKIP THE NEXT INSTRUCTION
   983						STOP^
   984	030766	254 04 0 00 030767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   985	030767	324 00 0 00 030770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
   986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
   987									;IN THE SUBTEST) TO LOOP ON ERROR^
   988
   989					;COND P [ADZ]
   990
   991					;**********
   992					;THIS TEST VERIFIES THAT SKIPGE SKIPS THE NEXT INSTRUCTION WHEN C(E)
   993					;IS ALL ZEROS.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH ALL ZEROS.
   994
   995	030770	200 00 0 00 070253 	A300:	MOVE	[0]		;PRESET E TO ALL ZEROS
   996	030771	335 00 0 00 000000 		SKIPGE			;*SKIPGE SHOULD SKIP THE NEXT INSTRUCTION
   997						STOP^
   998	030772	254 04 0 00 030773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
   999	030773	324 00 0 00 030774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1000									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1001									;IN THE SUBTEST) TO LOOP ON ERROR^
  1002
  1003					;COND R [ADZ], AD00 S-A-1, AD AR + EN [ADAP], AD LT AR + EN [ADAP],
  1004					;AD RT AR + EN [ADAP], AD AR + EN C [ADAP], F CYC ACT EN A [F1]
  1005
  1006					;**********
  1007
  1008					;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, SKIP NEVER SKIPS.  IT ALWAYS
  1009					;CONTINUES ON TO THE NEXT INSTRUCTION.
  1010
  1011	030774	200 00 0 00 070254 	A400:	MOVE	[-1]		;PRESET E TO ALL ONES
  1012	030775	330 00 0 00 000000 		SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
  1013	030776	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1014						STOP^
  1015	030777	254 04 0 00 031000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1016	031000	324 00 0 00 031001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1017									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1018									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1019
  1020					;PC CHANGE [PCC], PC CHANGE A [PCC], SEE MEMORY CONTROL DWGS [MC1-4]
  1021
  1022					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1023					;THIS TEST VERIFIES THAT SKIPGE WILL NOT SKIP THE NEXT INSTRUCTION WHEN C(E) IS
  1024					;NEGATIVE.  THE MOVE INSTRUCTION LOADS E WITH -1, A NEGATIVE NUMBER.
  1025
  1026	031001	200 00 0 00 070254 	A500:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NEGATIVE NUMBER
  1027	031002	335 00 0 00 000000 		SKIPGE			;*SKIPGE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1028	031003	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1029						STOP^
  1030	031004	254 04 0 00 031005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1031	031005	324 00 0 00 031006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1033									;IN THE SUBTEST) TO LOOP ON ERROR^
  1034
  1035					;IF MOVE INSTRUCTION FAILED, CHECK MOVX-: FCE [F1], -IR XXXI [IR1], -IR XXXM [IR1], 
  1036					;IR HWTFWT [IR3], IR FWT [IR2], IR2XX [IR1]
  1037
  1038					;IF SKIPGE FAILED, CHECK SKIPX: FCE [F1]
  1039
  1040					;**********
  1041
  1042					;THIS TEST VERIFIES THAT SKIPN WILL NOT SKIP THE NEXT INSTRUCTION WHEN
  1043					;C(E) IS ZERO.  THE MOVE INSTRUCTION  LOADS E WITH ALL ZEROS.
  1044
  1045	031006	200 00 0 00 070253 	A600:	MOVE	[0]		;PRESET E WITH ALL ZEROS
  1046	031007	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD NOT SKIP THE NEXT INSTRUCTION
  1047	031010	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1048						STOP^
  1049	031011	254 04 0 00 031012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1050	031012	324 00 0 00 031013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1051									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1052									;IN THE SUBTEST) TO LOOP ON ERROR^
  1053
  1054					;**********
  1055
  1056					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
  1057					;THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS
  1058					;E WITH -1, A NON-ZERO NUMBER.
  1059
  1060	031013	200 00 0 00 070254 	A700:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
  1061	031014	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1062						STOP^
  1063	031015	254 04 0 00 031016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1064	031016	324 00 0 00 031017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1065									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1066									;IN THE SUBTEST) TO LOOP ON ERROR^
  1067
  1068					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1069					;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD NOT
  1070					;SKIP THE NEXT INSTRUCTION WHEN C(E) IS NON-ZERO.  THE MOVE INSTRUCTION LOADS E
  1071					;WITH -1, A NON-ZERO NUMBER.
  1072
  1073	031017	200 00 0 00 070254 	A1000:	MOVE	[-1]		;PRESET E WITH ALL ONES, A NON-ZERO NUMBER
  1074	031020	332 00 0 00 000000 		SKIPE			;*SKIPE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1075	031021	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1076						STOP^
  1077	031022	254 04 0 00 031023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1078	031023	324 00 0 00 031024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1079									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1080									;IN THE SUBTEST) TO LOOP ON ERROR^
  1081
  1082					;**********
  1083
  1084					;THIS TEST VERIFIES THAT SKIPE IS DATA DEPENDENT.  HENCE, IT SHOULD SKIP
  1085					;THE NEXT INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS ALL
  1086					;ZEROS INTO E.
  1087
  1088	031024	200 00 0 00 070253 	A1100:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1089	031025	332 00 0 00 000000 		SKIPE			;*SKIPE SHOULD SKIP THE NEXT INSTRUCTION
  1090						STOP^
  1091	031026	254 04 0 00 031027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1092	031027	324 00 0 00 031030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1093									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1094									;IN THE SUBTEST) TO LOOP ON ERROR^
  1095
  1096					;**********
  1097
  1098					;THIS TEST VERIFIES THAT SKIP IS DATA INDEPENDENT.  HENCE, IT NEVER SKIPS.  IT ALWAYS
  1099					;CONTINUES ON TO THE NEXT INSTRUCTION.
  1100
  1101	031030	200 00 0 00 070253 	A1200:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1102	031031	330 00 0 00 000000 		SKIP			;*SKIP SHOULD NEVER SKIP THE NEXT INSTRUCTION
  1103	031032	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1104						STOP^
  1105	031033	254 04 0 00 031034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1106	031034	324 00 0 00 031035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1107									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1108									;IN THE SUBTEST) TO LOOP ON ERROR^
  1109
  1110					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1111					;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1112					;INSTRUCTION WHEN C(E) IS NOT NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD
  1113					;E WITH ALL ZEROS, A NON-NEGATIVE NUMBER.
  1114
  1115	031035	200 00 0 00 070253 	A1300:	MOVE	[0]		;PRESET E T0 ZERO, A NON-NEGATIVE NUMBER
  1116	031036	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
  1117	031037	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1118						STOP^
  1119	031040	254 04 0 00 031041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1120	031041	324 00 0 00 031042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1121									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1122									;IN THE SUBTEST) TO LOOP ON ERROR^
  1123
  1124					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1125					;THIS TEST VERIFIES THAT SKIPL IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1126					;INSTRUCTION WHEN C(E) IS NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH -1,
  1127					;A NEGATIVE NUMBER.
  1128
  1129	031042	200 00 0 00 070254 	A1400:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
  1130	031043	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD SKIP THE NEXT INSTRUCTION
  1131						STOP^
  1132	031044	254 04 0 00 031045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1133	031045	324 00 0 00 031046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1134									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1135									;IN THE SUBTEST) TO LOOP ON ERROR^
  1136
  1137					;**********
  1138
  1139					;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1140					;INSTRUCTION WHEN C(E) IS GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO LOAD
  1141					;E WITH A NON-ZERO POSITIVE NUMBER.
  1142
  1143	031046	200 00 0 00 070255 	A1500:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-ZERO POSITIVE NUMBER
  1144	031047	337 00 0 00 000000 		SKIPG			;*SKIPG SHOULD SKIP THE NEXT INSTRUCTION
  1145						STOP^
  1146	031050	254 04 0 00 031051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1147	031051	324 00 0 00 031052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1148									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1149									;IN THE SUBTEST) TO LOOP ON ERROR^
  1150
  1151					;**********
  1152
  1153					;THIS TEST VERIFIES THAT SKIPG IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1154					;INSTRUCTION WHEN C(E) IS NOT GREATER THAN ZERO.  THE MOVE INSTRUCTION IS USED TO
  1155					;LOAD E WITH -1, A NUMBER NOT GREATER THAN ZERO.
  1156
  1157	031052	200 00 0 00 070254 	A1600:	MOVE	[-1]		;PRESET E TO -1, A NEGATIVE NUMBER
  1158	031053	337 00 0 00 000000 		SKIPG			;*SKIPG SHOULD NOT SKIP THE NEXT INSTRUCTION
  1159	031054	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1160						STOP^
  1161	031055	254 04 0 00 031056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1162	031056	324 00 0 00 031057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1163									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1164									;IN THE SUBTEST) TO LOOP ON ERROR^
  1165
  1166					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1167					;THIS TEST VERIFIES THAT SKIPL IS DATA  DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1168					;INSTRUCTION WHEN C(E) IS NON-NEGATIVE.  THE MOVE INSTRUCTION IS USED TO LOAD E WITH
  1169					;377777777777, A NON-NEGATIVE NUMBER.
  1170
  1171	031057	200 00 0 00 070255 	A1700:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A NON-NEGATIVE NUMBER
  1172	031060	331 00 0 00 000000 		SKIPL			;*SKIPL SHOULD NOT SKIP THE NEXT INSTRUCTION
  1173	031061	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1174						STOP^
  1175	031062	254 04 0 00 031063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1176	031063	324 00 0 00 031064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1178									;IN THE SUBTEST) TO LOOP ON ERROR^
  1179
  1180					;**********
  1181
  1182					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1183					;INSTRUCTION WHEN C(E) IS ZERO.  THE MOVE INSTRUCTION LOADS E WITH ALL ZEROS.
  1184
  1185	031064	200 00 0 00 070253 	A2000:	MOVE	[0]		;PRESET E TO ALL ZEROS
  1186	031065	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
  1187						STOP^
  1188	031066	254 04 0 00 031067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1189	031067	324 00 0 00 031070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1191									;IN THE SUBTEST) TO LOOP ON ERROR^
  1192
  1193					;**********
  1194
  1195					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1196					;INSTRUCTION WHEN E CONTAINS A NEGATIVE NUMBER.  THE MOVE INSTRUCTION IS USED TO LOAD
  1197					;E WITH 400000000000, A NEGATIVE NUMBER.
  1198
  1199	031070	200 00 0 00 070256 	A2100:	MOVE	[XWD 400000,0]	;PRESET E TO 400000000000, A NEGATIVE NUMBER.
  1200	031071	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD SKIP THE NEXT INSTRUCTION
  1201						STOP^
  1202	031072	254 04 0 00 031073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1203	031073	324 00 0 00 031074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1204									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1205									;IN THE SUBTEST) TO LOOP ON ERROR^
  1206
  1207					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1208					;THIS TEST VERIFIES THAT SKIPLE IS DATA DEPENDENT.  HENCE, IT WILL NOT SKIP THE NEXT
  1209					;INSTRUCTION WHEN E CONTAINS A POSITIVE NUMBER.  THE MOVE INSTRUCTION LOADS
  1210					;E WITH 377777777777, A POSITIVE NUMBER.
  1211
  1212	031074	200 00 0 00 070255 	A2200:	MOVE	[XWD 377777,-1]	;PRESET E TO 377777777777, A POSITIVE NUMBER
  1213	031075	333 00 0 00 000000 		SKIPLE			;*SKIPLE SHOULD NOT SKIP THE NEXT INSTRUCTION
  1214	031076	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSES
  1215						STOP^
  1216	031077	254 04 0 00 031100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1217	031100	324 00 0 00 031101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1218									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1219									;IN THE SUBTEST) TO LOOP ON ERROR^
  1220
  1221					;*********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1222					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1223					;INSTRUCTION ;WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1224					;LOAD 777000000000, A NON-ZERO NUMBER INTO E.
  1225
  1226	031101	200 00 0 00 070257 	A2300:	MOVE	[XWD 777000,0]	;PRESET E WITH 777000000000, A NON-ZERO NUMBER
  1227	031102	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1228						STOP^
  1229	031103	254 04 0 00 031104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1230	031104	324 00 0 00 031105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1232									;IN THE SUBTEST) TO LOOP ON ERROR^
  1233
  1234					;**********
  1235
  1236					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1237					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1238					;LOAD A NON-ZERO NUMBER, 377000000 INTO E.
  1239
  1240	031105	200 00 0 00 070260 	A2400:	MOVE	[XWD 377,0]	;PRESET E TO 377000000, A NON ZERO NUMBER
  1241	031106	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1242						STOP^
  1243	031107	254 04 0 00 031110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1244	031110	324 00 0 00 031111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1245									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1246									;IN THE SUBTEST) TO LOOP ON ERROR^
  1247
  1248					;**********
  1249
  1250					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1251					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1252					;LOAD E WITH A NON-ZERO NUMBER, 177000.
  1253
  1254	031111	200 00 0 00 070261 	A2500:	MOVE	[177000]	;PRESET E WITH 177000, A NON ZERO NUMBER
  1255	031112	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1256						STOP^
  1257	031113	254 04 0 00 031114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1258	031114	324 00 0 00 031115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1259									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1260									;IN THE SUBTEST) TO LOOP ON ERROR^
  1261
  1262					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1263					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1264					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1265					;LOAD 777, A NON-ZERO NUMBER INTO E.
  1266
  1267	031115	200 00 0 00 070262 	A2600:	MOVE	[777]		;PRESET E WITH 777, A NON-ZERO NUMBER
  1268	031116	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1269						STOP^
  1270	031117	254 04 0 00 031120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1271	031120	324 00 0 00 031121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1273									;IN THE SUBTEST) TO LOOP ON ERROR^
  1274
  1275					;**********
  1276
  1277					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1278					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1279					;LOAD E WITH 600000, A NON-ZERO NUMBER.
  1280
  1281	031121	200 00 0 00 070263 	A2700:	MOVE	[600000]	;PRESET E WITK 600000, A NON-ZERO NUMBER
  1282	031122	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1283						STOP^
  1284	031123	254 04 0 00 031124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1285	031124	324 00 0 00 031125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1287									;IN THE SUBTEST) TO LOOP ON ERROR^
  1288
  1289					;**********
  1290
  1291					;THIS TEST VERIFIES THAT SKIPN IS DATA DEPENDENT.  HENCE, IT WILL SKIP THE NEXT
  1292					;INSTRUCTION WHEN E CONTAINS A NON-ZERO NUMBER.  THE MOVE INSTRUCTION IS USED TO
  1293					;LOAD E WITH 400000000, A NON-ZERO NUMBER.
  1294
  1295	031125	200 00 0 00 070264 	A3000:	MOVE	[XWD 400,000]	;PRESET E WITH 400000000, A NON-ZERO NUMBER
  1296	031126	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1297						STOP^
  1298	031127	254 04 0 00 031130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1299	031130	324 00 0 00 031131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1300									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1301									;IN THE SUBTEST) TO LOOP ON ERROR^
  1302
  1303					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1304			003100		SN=3100
  1305			000000			ZZ=0
  1306
  1307					A3100:	REPEAT	^D36,
  1308					<;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1309					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1310					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1311					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1312					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1313					
  1314					SN=SN+1
  1315						ZZ=ZZ+ZZ
  1316						IFE	ZZ,<ZZ=1>
  1317						MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1318						SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1319						STOP
  1320					
  1321					;**********
  1322					>
  1323					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1324					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1325					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1326					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1327					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1328
  1329			003101		SN=SN+1
  1330			000000			ZZ=ZZ+ZZ
  1331			000001			IFE	ZZ,<ZZ=1>
  1332	031131	200 00 0 00 070265 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1333	031132	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1334						STOP^
  1335	031133	254 04 0 00 031134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1336	031134	324 00 0 00 031135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1338									;IN THE SUBTEST) TO LOOP ON ERROR^
  1339
  1340					;**********
  1341
  1342					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1343					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1344					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1345					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1346					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1347
  1348			003102		SN=SN+1
  1349			000002			ZZ=ZZ+ZZ
  1350						IFE	ZZ,<ZZ=1>
  1351	031135	200 00 0 00 070266 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1352	031136	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1353						STOP^
  1354	031137	254 04 0 00 031140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1355	031140	324 00 0 00 031141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1357									;IN THE SUBTEST) TO LOOP ON ERROR^
  1358
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1359					;**********
  1360
  1361					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1362					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1363					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1364					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1365					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1366
  1367			003103		SN=SN+1
  1368			000004			ZZ=ZZ+ZZ
  1369						IFE	ZZ,<ZZ=1>
  1370	031141	200 00 0 00 070267 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1371	031142	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1372						STOP^
  1373	031143	254 04 0 00 031144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1374	031144	324 00 0 00 031145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1375									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1376									;IN THE SUBTEST) TO LOOP ON ERROR^
  1377
  1378					;**********
  1379
  1380					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1381					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1382					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1383					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1384					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1385
  1386			003104		SN=SN+1
  1387			000010			ZZ=ZZ+ZZ
  1388						IFE	ZZ,<ZZ=1>
  1389	031145	200 00 0 00 070270 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1390	031146	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1391						STOP^
  1392	031147	254 04 0 00 031150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1393	031150	324 00 0 00 031151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1394									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1395									;IN THE SUBTEST) TO LOOP ON ERROR^
  1396
  1397					;**********
  1398
  1399					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1400					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1401					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1402					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1403					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1404
  1405			003105		SN=SN+1
  1406			000020			ZZ=ZZ+ZZ
  1407						IFE	ZZ,<ZZ=1>
  1408	031151	200 00 0 00 070271 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1409	031152	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1410						STOP^
  1411	031153	254 04 0 00 031154 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1412	031154	324 00 0 00 031155 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1413									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1414									;IN THE SUBTEST) TO LOOP ON ERROR^
  1415
  1416					;**********
  1417
  1418					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1419					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1420					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1421					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1422					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1423
  1424			003106		SN=SN+1
  1425			000040			ZZ=ZZ+ZZ
  1426						IFE	ZZ,<ZZ=1>
  1427	031155	200 00 0 00 070272 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1428	031156	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1429						STOP^
  1430	031157	254 04 0 00 031160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1431	031160	324 00 0 00 031161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1433									;IN THE SUBTEST) TO LOOP ON ERROR^
  1434
  1435					;**********
  1436
  1437					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1438					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1439					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1440					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1441					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1442
  1443			003107		SN=SN+1
  1444			000100			ZZ=ZZ+ZZ
  1445						IFE	ZZ,<ZZ=1>
  1446	031161	200 00 0 00 070273 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1447	031162	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1448						STOP^
  1449	031163	254 04 0 00 031164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1450	031164	324 00 0 00 031165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1452									;IN THE SUBTEST) TO LOOP ON ERROR^
  1453
  1454					;**********
  1455
  1456					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1457					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1458					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1459					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1460					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1461
  1462			003110		SN=SN+1
  1463			000200			ZZ=ZZ+ZZ
  1464						IFE	ZZ,<ZZ=1>
  1465	031165	200 00 0 00 070274 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1466	031166	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1467						STOP^
  1468	031167	254 04 0 00 031170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1469	031170	324 00 0 00 031171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1470									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1471									;IN THE SUBTEST) TO LOOP ON ERROR^
  1472
  1473					;**********
  1474
  1475					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1476					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1477					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1478					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1479					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1480
  1481			003111		SN=SN+1
  1482			000400			ZZ=ZZ+ZZ
  1483						IFE	ZZ,<ZZ=1>
  1484	031171	200 00 0 00 070275 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1485	031172	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1486						STOP^
  1487	031173	254 04 0 00 031174 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1488	031174	324 00 0 00 031175 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1489									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1490									;IN THE SUBTEST) TO LOOP ON ERROR^
  1491
  1492					;**********
  1493
  1494					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1495					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1496					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1497					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1498					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1499
  1500			003112		SN=SN+1
  1501			001000			ZZ=ZZ+ZZ
  1502						IFE	ZZ,<ZZ=1>
  1503	031175	200 00 0 00 070276 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1504	031176	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1505						STOP^
  1506	031177	254 04 0 00 031200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1507	031200	324 00 0 00 031201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1508									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1509									;IN THE SUBTEST) TO LOOP ON ERROR^
  1510
  1511					;**********
  1512
  1513					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1514					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1515					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1516					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1517					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1518
  1519			003113		SN=SN+1
  1520			002000			ZZ=ZZ+ZZ
  1521						IFE	ZZ,<ZZ=1>
  1522	031201	200 00 0 00 070277 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1523	031202	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1524						STOP^
  1525	031203	254 04 0 00 031204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1526	031204	324 00 0 00 031205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1527									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1528									;IN THE SUBTEST) TO LOOP ON ERROR^
  1529
  1530					;**********
  1531
  1532					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1533					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1534					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1535					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1536					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1537
  1538			003114		SN=SN+1
  1539			004000			ZZ=ZZ+ZZ
  1540						IFE	ZZ,<ZZ=1>
  1541	031205	200 00 0 00 070300 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1542	031206	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1543						STOP^
  1544	031207	254 04 0 00 031210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1545	031210	324 00 0 00 031211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1546									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1547									;IN THE SUBTEST) TO LOOP ON ERROR^
  1548
  1549					;**********
  1550
  1551					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1552					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1553					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1554					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1555					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1556
  1557			003115		SN=SN+1
  1558			010000			ZZ=ZZ+ZZ
  1559						IFE	ZZ,<ZZ=1>
  1560	031211	200 00 0 00 070301 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1561	031212	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1562						STOP^
  1563	031213	254 04 0 00 031214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1564	031214	324 00 0 00 031215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1565									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1566									;IN THE SUBTEST) TO LOOP ON ERROR^
  1567
  1568					;**********
  1569
  1570					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1571					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1572					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1573					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1574					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1575
  1576			003116		SN=SN+1
  1577			020000			ZZ=ZZ+ZZ
  1578						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1579	031215	200 00 0 00 070302 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1580	031216	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1581						STOP^
  1582	031217	254 04 0 00 031220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1583	031220	324 00 0 00 031221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1585									;IN THE SUBTEST) TO LOOP ON ERROR^
  1586
  1587					;**********
  1588
  1589					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1590					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1591					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1592					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1593					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1594
  1595			003117		SN=SN+1
  1596			040000			ZZ=ZZ+ZZ
  1597						IFE	ZZ,<ZZ=1>
  1598	031221	200 00 0 00 070303 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1599	031222	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1600						STOP^
  1601	031223	254 04 0 00 031224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1602	031224	324 00 0 00 031225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1603									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1604									;IN THE SUBTEST) TO LOOP ON ERROR^
  1605
  1606					;**********
  1607
  1608					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1609					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1610					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1611					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1612					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1613
  1614			003120		SN=SN+1
  1615			100000			ZZ=ZZ+ZZ
  1616						IFE	ZZ,<ZZ=1>
  1617	031225	200 00 0 00 070304 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1618	031226	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1619						STOP^
  1620	031227	254 04 0 00 031230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1621	031230	324 00 0 00 031231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1623									;IN THE SUBTEST) TO LOOP ON ERROR^
  1624
  1625					;**********
  1626
  1627					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1628					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1629					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1630					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1631					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1632
  1633			003121		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1634			200000			ZZ=ZZ+ZZ
  1635						IFE	ZZ,<ZZ=1>
  1636	031231	200 00 0 00 070305 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1637	031232	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1638						STOP^
  1639	031233	254 04 0 00 031234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1640	031234	324 00 0 00 031235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1642									;IN THE SUBTEST) TO LOOP ON ERROR^
  1643
  1644					;**********
  1645
  1646					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1647					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1648					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1649					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1650					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1651
  1652			003122		SN=SN+1
  1653			400000			ZZ=ZZ+ZZ
  1654						IFE	ZZ,<ZZ=1>
  1655	031235	200 00 0 00 070306 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1656	031236	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1657						STOP^
  1658	031237	254 04 0 00 031240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1659	031240	324 00 0 00 031241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1661									;IN THE SUBTEST) TO LOOP ON ERROR^
  1662
  1663					;**********
  1664
  1665					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1666					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1667					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1668					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1669					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1670
  1671			003123		SN=SN+1
  1672		000001	000000			ZZ=ZZ+ZZ
  1673						IFE	ZZ,<ZZ=1>
  1674	031241	200 00 0 00 070307 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1675	031242	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1676						STOP^
  1677	031243	254 04 0 00 031244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1678	031244	324 00 0 00 031245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1680									;IN THE SUBTEST) TO LOOP ON ERROR^
  1681
  1682					;**********
  1683
  1684					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1685					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1686					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1687					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1688					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1689
  1690			003124		SN=SN+1
  1691		000002	000000			ZZ=ZZ+ZZ
  1692						IFE	ZZ,<ZZ=1>
  1693	031245	200 00 0 00 070310 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1694	031246	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1695						STOP^
  1696	031247	254 04 0 00 031250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1697	031250	324 00 0 00 031251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1698									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1699									;IN THE SUBTEST) TO LOOP ON ERROR^
  1700
  1701					;**********
  1702
  1703					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1704					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1705					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1706					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1707					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1708
  1709			003125		SN=SN+1
  1710		000004	000000			ZZ=ZZ+ZZ
  1711						IFE	ZZ,<ZZ=1>
  1712	031251	200 00 0 00 070311 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1713	031252	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1714						STOP^
  1715	031253	254 04 0 00 031254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1716	031254	324 00 0 00 031255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1717									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1718									;IN THE SUBTEST) TO LOOP ON ERROR^
  1719
  1720					;**********
  1721
  1722					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1723					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1724					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1725					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1726					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1727
  1728			003126		SN=SN+1
  1729		000010	000000			ZZ=ZZ+ZZ
  1730						IFE	ZZ,<ZZ=1>
  1731	031255	200 00 0 00 070312 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1732	031256	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1733						STOP^
  1734	031257	254 04 0 00 031260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1735	031260	324 00 0 00 031261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1736									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1737									;IN THE SUBTEST) TO LOOP ON ERROR^
  1738
  1739					;**********
  1740
  1741					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1742					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1743					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1744					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1745					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1746
  1747			003127		SN=SN+1
  1748		000020	000000			ZZ=ZZ+ZZ
  1749						IFE	ZZ,<ZZ=1>
  1750	031261	200 00 0 00 070313 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1751	031262	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1752						STOP^
  1753	031263	254 04 0 00 031264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1754	031264	324 00 0 00 031265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1756									;IN THE SUBTEST) TO LOOP ON ERROR^
  1757
  1758					;**********
  1759
  1760					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1761					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1762					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1763					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1764					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1765
  1766			003130		SN=SN+1
  1767		000040	000000			ZZ=ZZ+ZZ
  1768						IFE	ZZ,<ZZ=1>
  1769	031265	200 00 0 00 070314 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1770	031266	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1771						STOP^
  1772	031267	254 04 0 00 031270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1773	031270	324 00 0 00 031271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1774									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1775									;IN THE SUBTEST) TO LOOP ON ERROR^
  1776
  1777					;**********
  1778
  1779					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1780					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1781					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1782					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1783					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1784
  1785			003131		SN=SN+1
  1786		000100	000000			ZZ=ZZ+ZZ
  1787						IFE	ZZ,<ZZ=1>
  1788	031271	200 00 0 00 070315 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1789	031272	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1790						STOP^
  1791	031273	254 04 0 00 031274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1792	031274	324 00 0 00 031275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1793									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1794									;IN THE SUBTEST) TO LOOP ON ERROR^
  1795
  1796					;**********
  1797
  1798					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1799					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1800					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1801					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1802					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1803
  1804			003132		SN=SN+1
  1805		000200	000000			ZZ=ZZ+ZZ
  1806						IFE	ZZ,<ZZ=1>
  1807	031275	200 00 0 00 070316 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1808	031276	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1809						STOP^
  1810	031277	254 04 0 00 031300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1811	031300	324 00 0 00 031301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1812									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1813									;IN THE SUBTEST) TO LOOP ON ERROR^
  1814
  1815					;**********
  1816
  1817					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1818					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1819					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1820					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1821					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1822
  1823			003133		SN=SN+1
  1824		000400	000000			ZZ=ZZ+ZZ
  1825						IFE	ZZ,<ZZ=1>
  1826	031301	200 00 0 00 070264 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1827	031302	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1828						STOP^
  1829	031303	254 04 0 00 031304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1830	031304	324 00 0 00 031305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1832									;IN THE SUBTEST) TO LOOP ON ERROR^
  1833
  1834					;**********
  1835
  1836					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1837					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1838					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1839					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1840					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1841
  1842			003134		SN=SN+1
  1843		001000	000000			ZZ=ZZ+ZZ
  1844						IFE	ZZ,<ZZ=1>
  1845	031305	200 00 0 00 070317 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1846	031306	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1847						STOP^
  1848	031307	254 04 0 00 031310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1849	031310	324 00 0 00 031311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1851									;IN THE SUBTEST) TO LOOP ON ERROR^
  1852
  1853					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1854
  1855					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1856					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1857					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1858					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1859					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1860
  1861			003135		SN=SN+1
  1862		002000	000000			ZZ=ZZ+ZZ
  1863						IFE	ZZ,<ZZ=1>
  1864	031311	200 00 0 00 070320 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1865	031312	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1866						STOP^
  1867	031313	254 04 0 00 031314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1868	031314	324 00 0 00 031315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1869									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1870									;IN THE SUBTEST) TO LOOP ON ERROR^
  1871
  1872					;**********
  1873
  1874					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1875					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1876					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1877					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1878					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1879
  1880			003136		SN=SN+1
  1881		004000	000000			ZZ=ZZ+ZZ
  1882						IFE	ZZ,<ZZ=1>
  1883	031315	200 00 0 00 070321 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1884	031316	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1885						STOP^
  1886	031317	254 04 0 00 031320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1887	031320	324 00 0 00 031321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1888									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1889									;IN THE SUBTEST) TO LOOP ON ERROR^
  1890
  1891					;**********
  1892
  1893					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1894					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1895					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1896					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1897					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1898
  1899			003137		SN=SN+1
  1900		010000	000000			ZZ=ZZ+ZZ
  1901						IFE	ZZ,<ZZ=1>
  1902	031321	200 00 0 00 070322 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1903	031322	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1904						STOP^
  1905	031323	254 04 0 00 031324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1906	031324	324 00 0 00 031325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1907									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1908									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1909
  1910					;**********
  1911
  1912					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1913					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1914					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1915					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1916					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1917
  1918			003140		SN=SN+1
  1919		020000	000000			ZZ=ZZ+ZZ
  1920						IFE	ZZ,<ZZ=1>
  1921	031325	200 00 0 00 070323 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1922	031326	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1923						STOP^
  1924	031327	254 04 0 00 031330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1925	031330	324 00 0 00 031331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1927									;IN THE SUBTEST) TO LOOP ON ERROR^
  1928
  1929					;**********
  1930
  1931					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1932					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1933					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1934					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1935					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1936
  1937			003141		SN=SN+1
  1938		040000	000000			ZZ=ZZ+ZZ
  1939						IFE	ZZ,<ZZ=1>
  1940	031331	200 00 0 00 070324 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1941	031332	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1942						STOP^
  1943	031333	254 04 0 00 031334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1944	031334	324 00 0 00 031335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1945									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1946									;IN THE SUBTEST) TO LOOP ON ERROR^
  1947
  1948					;**********
  1949
  1950					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1951					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1952					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1953					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1954					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1955
  1956			003142		SN=SN+1
  1957		100000	000000			ZZ=ZZ+ZZ
  1958						IFE	ZZ,<ZZ=1>
  1959	031335	200 00 0 00 070325 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1960	031336	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1961						STOP^
  1962	031337	254 04 0 00 031340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1963	031340	324 00 0 00 031341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF JUMP, JUMPA AND SKIPX INSTRUCTIONS

  1964									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1965									;IN THE SUBTEST) TO LOOP ON ERROR^
  1966
  1967					;**********
  1968
  1969					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1970					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1971					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1972					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1973					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1974
  1975			003143		SN=SN+1
  1976		200000	000000			ZZ=ZZ+ZZ
  1977						IFE	ZZ,<ZZ=1>
  1978	031341	200 00 0 00 070326 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1979	031342	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1980						STOP^
  1981	031343	254 04 0 00 031344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  1982	031344	324 00 0 00 031345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  1983									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  1984									;IN THE SUBTEST) TO LOOP ON ERROR^
  1985
  1986					;**********
  1987
  1988					;THIS TEST VERIFIES THAT SKIPN IS SENSITIVE TO A ONE IN EVERY BIT POSITION.  THIS TEST
  1989					;IS REPEATED 36 TIMES.  EACH TIME A WORD OF ALL ZEROS EXCEPT FOR A ONE IN ONE
  1990					;BIT POSITION IS MOVED INTO E.  THEN SKIPN IS EXECUTED.  THIS TEST ALSO
  1991					;CHECKS ADDER GATING.  IF THIS TEST FAILS, CHECK C(E).
  1992					;IF C(E)=0, MOVE FAILED; OTHERWISE SKIPN FAILED.
  1993
  1994			003144		SN=SN+1
  1995		400000	000000			ZZ=ZZ+ZZ
  1996						IFE	ZZ,<ZZ=1>
  1997	031345	200 00 0 00 070256 		MOVE	[ZZ]		;MOVE THE CURRENT VALUE OF ZZ INTO E. ZZ IS NON-ZERO
  1998	031346	336 00 0 00 000000 		SKIPN			;*SKIPN SHOULD SKIP THE NEXT INSTRUCTION
  1999						STOP^
  2000	031347	254 04 0 00 031350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2001	031350	324 00 0 00 031351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2002									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2003									;IN THE SUBTEST) TO LOOP ON ERROR^
  2004
  2005					;**********
  2006
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

  2007					SUBTTL	TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS
  2008
  2009					;THIS TEST VERIFIES THAT MOVEI LOADS E INTO THE AC.  SKIPG IS USED TO CHECK THAT
  2010					;THE AC WAS INDEED MODIFIED BY MOVEI.
  2011
  2012	031351	201 00 0 00 070254 	A3200:	MOVEI	[-1]		;*MOVEI SHOULD LOAD A POSITIVE NUMBER INTO AC0
  2013	031352	337 00 0 00 000000 		SKIPG			;SKIP HALT INSTRUCTION IF MOVEI LOADED AC CORRECTLY
  2014						STOP^
  2015	031353	254 04 0 00 031354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2016	031354	324 00 0 00 031355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2017									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2018									;IN THE SUBTEST) TO LOOP ON ERROR^
  2019
  2020					;IF PROGRAM HANGS UP ON MOVEI INSTRUCTION, CHECK AD FM +EN [ADFP], AD FM + EN A [ADFP],
  2021					;AD FM + F/F [ADFP], F CYC ACT EN C [F1]
  2022
  2023					;**********
  2024
  2025					;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE DATA IN E AND NOT SENSITIVE TO
  2026					;THE DATA IN THE AC.  HENCE, SKIPL WILL SKIP THE NEXT INSTRUCTION ONLY IF
  2027					;C(E) IS LESS THAN ZERO.  E IS SET TO -1, A NEGATIVE NUMBER; AND
  2028					;THE AC IS SET TO 0 IN THIS TEST.  THEREFORE SKIPL SHOULD SKIP.
  2029
  2030	031355	200 00 0 00 070253 	A3300:	MOVE	[0]		;SET THE AC TO ALL ZEROS
  2031	031356	331 00 0 00 070254 		SKIPL	[-1]		;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
  2032						STOP^
  2033	031357	254 04 0 00 031360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2034	031360	324 00 0 00 031361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2035									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2036									;IN THE SUBTEST) TO LOOP ON ERROR^
  2037
  2038					;**********
  2039
  2040					;THIS TEST VERIFIES THAT SKIPL IS SENSITIVE TO THE SIGN BIT IN E.  SKIPL SHOULD
  2041					;SKIP THE NEXT INSTRUCTION WHEN AND ONLY WHEN THE SIGN BIT IS SET.  IN THIS
  2042					;TEST, C(AC) IS PRESET TO ALL ZEROS, THEN SKIPL IS EXECUTED WITH C(E)=400000,,0.
  2043					;A FAILURE UCCURS IF SKIPL DOES NOT SKIP.
  2044
  2045	031361	200 00 0 00 070253 	A13100:	MOVE	[0]		;SET THE AC TO ALL ZEROS
  2046	031362	331 00 0 00 070256 		SKIPL	[400000,,0]	;*SKIPL SHOULD SKIP BECAUSE C(E) IS NEGATIVE
  2047						STOP^
  2048	031363	254 04 0 00 031364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2049	031364	324 00 0 00 031365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2051									;IN THE SUBTEST) TO LOOP ON ERROR^
  2052
  2053					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA1	MAC	13-Jan-89 10:22		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

  2054					;THIS TEST VERIFIES THAT THE CAM INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
  2055					;INITIALLY LOADED WITH ALL ZEROS; THEN CAM IS EXECUTED WITH C(E) NON-ZERO.
  2056					;THE AC IS THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.
  2057
  2058	031365	200 00 0 00 070253 	A3400:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
  2059	031366	310 00 0 00 070327 		CAM	[1234]		;*CAM SHOULD NOT MODIFY THE AC
  2060	031367	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION SERVES AS A NO-OP.
  2061									;IT IS A PROGRAM FILLER IN CASE CAM SKIPS.)
  2062	031370	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC WAS NOT MODIFIED BY CAM
  2063						STOP^
  2064	031371	254 04 0 00 031372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2065	031372	324 00 0 00 031373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2066									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2067									;IN THE SUBTEST) TO LOOP ON ERROR^
  2068
  2069					;IF TEST HANGS ON CAM INSTRUCTION, AB PC EN [ABC], AB PC (FETCH) EN [ABC],
  2070					;IR CAXX [IR3]
  2071
  2072					;IF TEST LOOPS ON CAM INSTRUCTION, MC INSTR FETCH EN [MC1], MC INST FET ET2 EN [MC1],
  2073					;ET2 J F/F [E], IR CAXX [IR3]
  2074
  2075					;IF TEST HALTS AT HALT INSTRUCTION, SAC INH [ST2], IR CAXX [IR3], IR CAMX [IR1]
  2076
  2077					;**********
  2078
  2079					;THIS TEST VERIFIES THAT THE CAI INSTRUCTION DOES NOT MODIFY C(AC).  THE AC IS
  2080					;INITIALLY LOADED WITH ALL ZEROS; THEN CAI IS EXECUTED WITH E NON-ZERO.  THE AC IS
  2081					;THEN CHECKED FOR ALL ZEROS.  THIS TEST FAILS IF THE AC WAS MODIFIED BY CAM.
  2082
  2083	031373	200 00 0 00 070253 	A3500:	MOVE	[0]		;PRESET THE AC TO ALL ZEROS
  2084	031374	300 00 0 00 070327 		CAI	[1234]		;*CAI SHOULD NOT MODIFY THE AC
  2085	031375	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A PROGRAM FILLER
  2086									;IN CASE CAI MODIFIES THE AC.  IT SERVES AS A NO-OP)
  2087	031376	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF CAI DID NOT MODIFY THE AC
  2088						STOP^
  2089	031377	254 04 0 00 031400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2090	031400	324 00 0 00 031401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2092									;IN THE SUBTEST) TO LOOP ON ERROR^
  2093
  2094					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA1	MAC	13-Jan-89 10:22		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

  2095					;THIS TEST VERIFIES THAT CAI DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
  2096					;SPECIFIED BY THE CAI INSTRUCTION.
  2097					;THIS IS THE FIRST TEST THAT USES AN AC OTHER THAN AC0.
  2098					;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAI INSTRUCTION IS EXECUTED WITH
  2099					;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.
  2100
  2101	031401	200 00 0 00 070253 	A3600:	MOVE	[0]		;LOAD AC0 WITH ALL ZEROS
  2102	031402	300 17 0 00 070327 		CAI	17,[1234]	;*CAI SHOULD NOT MODIFY AC0
  2103	031403	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2104									;CAI SKIPS THE NEXT INSTRUCTION.  IT ACTS AS A NO-OP)
  2105	031404	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
  2106						STOP^
  2107	031405	254 04 0 00 031406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2108	031406	324 00 0 00 031407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2109									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2110									;IN THE SUBTEST) TO LOOP ON ERROR^
  2111
  2112					;**********
  2113
  2114					;THIS TEST VERIFIES THAT CAM DOES NOT MODIFY C(AC0) WHEN AN AC OTHER THAN AC0 IS
  2115					;SPECIFIED BY THE CAM INSTRUCTION.
  2116					;FIRST, AC0 IS LOADED WITH ALL ZEROS; THEN, THE CAM INSTRUCTION IS EXECUTED WITH
  2117					;A NON-ZERO E.  AC 0 IS THEN TESTED F0R ALL ZEROS.
  2118
  2119	031407	200 00 0 00 070253 	A3700:	MOVE	[0]		;PRESET C(AC0) TO ALL ZEROS
  2120	031410	310 17 0 00 070327 		CAM	17,[1234]	;*CAM SHOULD NOT MODIFY AC0
  2121	031411	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2122									;CAM SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
  2123	031412	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY CAM
  2124						STOP^
  2125	031413	254 04 0 00 031414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2126	031414	324 00 0 00 031415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2128									;IN THE SUBTEST) TO LOOP ON ERROR^
  2129
  2130					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA1	MAC	13-Jan-89 10:22		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

  2131					;THIS TEST VERIFIES THAT MOVE WILL PLACE C(E) INTO THE AC.  AC, E AND C(E) ARE NON-ZERO
  2132					;IN THIS TEST.  THIS TEST PASSES IF  FINAL C(AC) OF THE MOVE INSTRUCTION IS NON-ZERO.
  2133
  2134	031415	200 01 0 00 070253 	A4500:	MOVE	1,[0]		;LOAD THE AC WITH ALL ZEROS
  2135	031416	200 01 0 00 070254 		MOVE	1,[-1]		;*MOVE SHOULD PLACE ALL ONES IN THE AC
  2136	031417	336 00 0 00 000001 		SKIPN	1		;SKIP HALT INSTRUCTION IF MOVE MODIFIED THE AC
  2137						STOP^
  2138	031420	254 04 0 00 031421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2139	031421	324 00 0 00 031422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2140									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2141									;IN THE SUBTEST) TO LOOP ON ERROR^
  2142
  2143					;**********
  2144
  2145					;THIS TEST VERIFIES THAT THE MOVE INSTRUCTION WILL PLACE C(E) INTO THE AC.
  2146					;AC, E ARE NON-ZERO AND C(E)=0.
  2147					;THIS TEST FAILS IF THE FINAL C(AC) IS NOT EQUAL TO ZERO, THE ORIGINAL C(E)
  2148
  2149	031422	200 01 0 00 070253 	A4600:	MOVE	1,[0]		;*PLACE ALL ZEROS INTO THE AC
  2150	031423	332 00 0 00 000001 		SKIPE	1		;SKIP HALT INSTRUCTION IF MOVE PLACED ALL ZEROS INTO AC
  2151						STOP^
  2152	031424	254 04 0 00 031425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2153	031425	324 00 0 00 031426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2155									;IN THE SUBTEST) TO LOOP ON ERROR^
  2156
  2157					;IF JUMP .+1 OF PREVIOUS TEST FAILED, CHECK JUMPS: AD FM + EN [ADFP], IR JUMPS [IR1],
  2158					;IR JUMPX [IR1], AR AD EN [ARMA], AR AD EN A [ARMA], AR LT AD EN A [ARMA],
  2159					;AR LT ADD EN B [ARMA], AR RT AD EN A [ARMA],
  2160					;AR RT AD EN B [ARMA], AR A CLK INPUT [ARMA],
  2161					;ET2 C F/F [E], AR AD ET2 EN [ARMA], AR AD BR (ET2) B [ARMA]
  2162
  2163					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA1	MAC	13-Jan-89 10:22		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

  2164					;THIS TEST VERIFIES THAT SOS DOES NOT MODIFY C(AC) WHEN THE AC IS AC0.
  2165					;FIRST, AC0 IS LOADED WITH ALL ZEROS AND E IS LOADED WITH A POSITIVE NUMBER;
  2166					;THEN, SOS IS EXECUTED.  SOS SHOULD SUBTRACT ONE FROM C((E)
  2167					;AND EXECUTE THE NEXT INSTRUCTION.  IT SHOULD NOT MODIFY AC0.
  2168					;THE TEST PASSES IF AC0 WAS NOT MODIFIED.
  2169
  2170	031426	200 00 0 00 070253 	A4000:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2171	031427	200 07 0 00 070327 		MOVE	7,[1234]	;PRESET E WITH A POSITIVE NUMBER
  2172	031430	370 00 0 00 000007 		SOS	7		;*SOS SHOULD NOT MODIFY C(AC0)
  2173	031431	200 00 0 00 000000 		MOVE			;MOVE C(0) INTO 0 (THIS INSTRUCTION IS A FILLER IN CASE
  2174									;SOS SKIPS THE NEXT INSTRUCTION.  IT SERVES AS A NO-OP)
  2175	031432	332 00 0 00 000000 		SKIPE			;SKIP THE HALT INSTRUCTION IF C(AC0) WAS NOT MODIFIED
  2176						STOP^
  2177	031433	254 04 0 00 031434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2178	031434	324 00 0 00 031435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2180									;IN THE SUBTEST) TO LOOP ON ERROR^
  2181
  2182					;**********
  2183			004100		SN=4100
  2184			000000			AC=0
  2185
  2186					A4100:	REPEAT	4,		
  2187					<;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2188					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2189					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2190					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2191					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2192					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2193					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2194					
  2195					SN=SN+1
  2196						AC=AC+AC
  2197						IFE	AC,<AC=1>
  2198						MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2199						MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2200						SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2201						SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2202						STOP
  2203						SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2204						STOP
  2205					
  2206					;**********
  2207					>
  2208					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2209					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2210					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2211					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2212					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2213					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2214					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2215
  2216			004101		SN=SN+1
  2217			000000			AC=AC+AC
  2218			000001			IFE	AC,<AC=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

  2219	031435	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2220	031436	200 01 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2221	031437	330 01 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2222	031440	336 00 0 00 000001 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2223						STOP^
  2224	031441	254 04 0 00 031442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2225	031442	324 00 0 00 031443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2226									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2227									;IN THE SUBTEST) TO LOOP ON ERROR^
  2228	031443	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2229						STOP^
  2230	031444	254 04 0 00 031445 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2231	031445	324 00 0 00 031446 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2232									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2233									;IN THE SUBTEST) TO LOOP ON ERROR^
  2234
  2235					;**********
  2236
  2237					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2238					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2239					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2240					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2241					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2242					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2243					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2244
  2245			004102		SN=SN+1
  2246			000002			AC=AC+AC
  2247						IFE	AC,<AC=1>
  2248	031446	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2249	031447	200 02 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2250	031450	330 02 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2251	031451	336 00 0 00 000002 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2252						STOP^
  2253	031452	254 04 0 00 031453 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2254	031453	324 00 0 00 031454 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2256									;IN THE SUBTEST) TO LOOP ON ERROR^
  2257	031454	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2258						STOP^
  2259	031455	254 04 0 00 031456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2260	031456	324 00 0 00 031457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2262									;IN THE SUBTEST) TO LOOP ON ERROR^
  2263
  2264					;**********
  2265
  2266					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2267					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2268					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2269					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2270					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2271					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2272					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2273
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF MOVE, SKIP AND COMPARE INSTRUCTIONS

  2274			004103		SN=SN+1
  2275			000004			AC=AC+AC
  2276						IFE	AC,<AC=1>
  2277	031457	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2278	031460	200 04 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2279	031461	330 04 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2280	031462	336 00 0 00 000004 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2281						STOP^
  2282	031463	254 04 0 00 031464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2283	031464	324 00 0 00 031465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2284									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2285									;IN THE SUBTEST) TO LOOP ON ERROR^
  2286	031465	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2287						STOP^
  2288	031466	254 04 0 00 031467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2289	031467	324 00 0 00 031470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2290									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2291									;IN THE SUBTEST) TO LOOP ON ERROR^
  2292
  2293					;**********
  2294
  2295					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL PLACE THE CONTENTS OF E INTO THE AC
  2296					;WHEN THE AC IS NOT AC0. THIS TEST IS PERFORMED FOR AC1, AC2, AC4 AND AC10.
  2297					;FIRST, THE AC IS LOADED WITH ALL ZEROS;  THEN, THE SKIP INSTRUCTION IS EXECUTED
  2298					;WITH AC1, AC2, AC4 OR AC10.  C(E) IS EQUAL TO -1.  THE SKIP INSTRUCTION SHOULD CAUSE
  2299					;THE AC TO CONTAIN -1.  THE AC IS THEN CHECKED FOR
  2300					;NON-ZERO CONTENTS.  THE TEST FAILS IF C(AC)=0.
  2301					;THIS TEST ALSO VERIFIES THAT 'SKIP AC,[-1]' DOES NOT CLOBBER AC0.
  2302
  2303			004104		SN=SN+1
  2304			000010			AC=AC+AC
  2305						IFE	AC,<AC=1>
  2306	031470	200 00 0 00 070253 		MOVE	0,[0]		;PRESET AC0 TO ALL ZEROS
  2307	031471	200 10 0 00 070253 		MOVE	AC,[0]		;PRESET THE AC TO ALL ZEROS
  2308	031472	330 10 0 00 070254 		SKIP	AC,[-1]		;*SKIP SHOULD PLACE -1 INTO THE AC
  2309	031473	336 00 0 00 000010 		SKIPN	AC		;SKIP THE HALT INSTRUCTION IF THE AC IS NON-ZERO
  2310						STOP^
  2311	031474	254 04 0 00 031475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2312	031475	324 00 0 00 031476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2314									;IN THE SUBTEST) TO LOOP ON ERROR^
  2315	031476	332 00 0 00 000000 		SKIPE	0		;VERIFY THAT AC0 DID NOT GET CLOBBERED BY SKIP
  2316						STOP^
  2317	031477	254 04 0 00 031500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2318	031500	324 00 0 00 031501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2319									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2320									;IN THE SUBTEST) TO LOOP ON ERROR^
  2321
  2322					;**********
  2323
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2324					SUBTTL	TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS
  2325
  2326					;THIS TEST VERIFIES THAT THE SKIP INSTRUCTION WILL NOT MODIFY THE CONTENTS OF AC0.
  2327					;FIRST, AC0 IS LOADED WITH ALL ZEROS;  THEN,
  2328					;THE SKIP INSTRUCTION IS EXECUTED WITH C(E)=-1 AND AC0.  AC0 IS THEN TESTED FOR ALL
  2329					;ZEROS.  THE TEST FAILS IF AC0 WAS MODIFIED BY THE SKIP INSTRUCTION.
  2330
  2331	031501	200 00 0 00 070253 	A4200:	MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2332	031502	330 00 0 00 070254 		SKIP	[-1]		;*SKIP SHOULD NOT MODIFY AC0
  2333	031503	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS NOT MODIFIED BY SKIP
  2334						STOP^
  2335	031504	254 04 0 00 031505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2336	031505	324 00 0 00 031506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2338									;IN THE SUBTEST) TO LOOP ON ERROR^
  2339
  2340					;AC=0: SAC INH, IR BIT 9, 10, 11 OR 12 S-A-1
  2341
  2342					;**********
  2343
  2344					;THIS TEST VERIFIES THAT MOVSS DOES NOT MODIFY C(AC0) WHEN AC0 IS SPECIFIED AS THE AC.
  2345					;FIRST, E IS LOADED WITH ALL ONES AND THE AC (AC0)
  2346					;IS LOADED WITH ALL ZEROS; THEN, MOVSS IS EXECUTED.  MOVSS SHOULD NOT MODIFY AC0.
  2347					;AC0 IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED BY MOVSS.
  2348
  2349	031506	200 07 0 00 070254 	A4300:	MOVE	7,[-1]		;LOAD E OF THE MOVSS INSTRUCTION WITH ALL ONES
  2350	031507	200 00 0 00 070253 		MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2351	031510	207 00 0 00 000007 		MOVSS	7		;*MOVSS SHOULD NOT MODIFY AC0
  2352	031511	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC0 WAS INTACT
  2353						STOP^
  2354	031512	254 04 0 00 031513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2355	031513	324 00 0 00 031514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2357									;IN THE SUBTEST) TO LOOP ON ERROR^
  2358
  2359					;MOVX & AC=0: SAC INH [ST2], IR XXXS [IR1]
  2360
  2361					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2362					;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY C(AC0) WHEN AC0 IS THE SPECIFIED AC.
  2363					;FIRST, E IS LOADED WITH ALL ONES AND AC0 IS LOADED WITH ALL ZEROS;
  2364					;THEN, HRRS IS EXECUTED WITH AC=AC0.  AC0 IS THEN CHECKED FOR ALL ZEROS.
  2365					;IF AC0 WAS MODIFIED BY THE HRRS INSTRUCTION, THE TEST FAIL.
  2366
  2367	031514	200 07 0 00 070254 	A4400:	MOVE	7,[-1]		;PRESET E OF THE HRRS INSTRUCTION TO ALL ONES
  2368	031515	200 00 0 00 070253 		MOVE	[0]		;PRESET AC0 TO ALL ZEROS
  2369	031516	543 00 0 00 000007 		HRRS	7		;*HRRS SHOULD NOT MODIFY THE AC WHEN THE AC IS AC0
  2370	031517	332 00 0 00 000000 		SKIPE			;SKIP THE HALT INSTRUCTION IF AC0 WAS INTACT
  2371						STOP^
  2372	031520	254 04 0 00 031521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2373	031521	324 00 0 00 031522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2375									;IN THE SUBTEST) TO LOOP ON ERROR^
  2376
  2377					;(HXXXS&AC=0): SAC INH [ST2], IR HWTFWT [IR3], IR XXXS [IR1], IR HWT [IR1],
  2378					;IR BITS S-A-1
  2379
  2380					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2381					;THIS TEST VERIFIES THAT THE JUMP INSTRUCTION DOES NOT MODIFY C(AC).
  2382					;THE AC IS FIRST LOADED WITH ALL ZEROS;
  2383					;THEN JUMP .+1 IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT IT WAS NOT MODIFIED
  2384					;BY JUMP.  THE TEST FAILS IF THE AC WAS MODIFIED
  2385
  2386	031522	200 00 0 00 070253 	A4700:	MOVE	[0]		; PRESET THE AC TO ALL ZEROS
  2387	031523	320 00 0 00 031524 		JUMP	.+1		;*JUMP SHOULD NOT MODIFY THE AC
  2388	031524	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF AC WAS INTACT
  2389						STOP^
  2390	031525	254 04 0 00 031526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2391	031526	324 00 0 00 031527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2392									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2393									;IN THE SUBTEST) TO LOOP ON ERROR^
  2394
  2395					;**********
  2396
  2397					;THIS TEST VERIFIES THAT MOVS WILL NOT PICK UP ANY ONES WHEN SWAPPING A WORD
  2398					;OF ALL ZEROS.  FIRST, E IS LOADED WITH A WORD OF ALL ZEROS;
  2399					;THEN, MOVS IS EXECUTED.  THE AC IS THEN CHECKED TO INSURE THAT THE RESULT DOES NOT
  2400					;CONTAIN ANY ONES.
  2401
  2402	031527	200 00 0 00 070253 	A5000:	MOVE	[0]		;PRESET E WITH ALL ZEROS
  2403	031530	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH AN AC 0F ALL ZEROS
  2404	031531	332 00 0 00 000000 		SKIPE			;SKIP HALT INSTRUCTION IF C(AC)=0
  2405						STOP^
  2406	031532	254 04 0 00 031533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2407	031533	324 00 0 00 031534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2409									;IN THE SUBTEST) TO LOOP ON ERROR^
  2410
  2411					;**********
  2412
  2413					;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
  2414					;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
  2415					;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO RESULT.
  2416					;IF C(AC)=0, THE TEST FAILS.
  2417
  2418	031534	200 00 0 00 070330 	A5100:	MOVE	[XWD 0,-1]	;LOAD E WITH A NON-ZERO VALUE
  2419	031535	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT IN C(AC) NON-ZERO
  2420	031536	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
  2421						STOP^
  2422	031537	254 04 0 00 031540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2423	031540	324 00 0 00 031541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2424									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2425									;IN THE SUBTEST) TO LOOP ON ERROR^
  2426
  2427					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2428					;THIS TEST VERIFIES THAT A MOVS EXECUTED ON AN E CONTAINING A NON-ZERO NUMBER
  2429					;RESULTS IN A NON-ZERO NUMBER IN THE AC.  FIRST A NON-ZERO WORD
  2430					;IS LOADED INTO E; THEN, MOVS IS EXECUTED.  THE AC IS CHECKED FOR A NON-ZERO
  2431					;RESULT.  IF C(AC)=0, THE TEST FAILS.
  2432
  2433	031541	200 00 0 00 070331 	A5200:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH A NON-ZERO NUMBER
  2434	031542	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH C(AC) NON-ZERO
  2435	031543	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF C(AC) OF MOVS IS NON-ZERO
  2436						STOP^
  2437	031544	254 04 0 00 031545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2438	031545	324 00 0 00 031546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2439									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2440									;IN THE SUBTEST) TO LOOP ON ERROR^
  2441
  2442					;**********
  2443
  2444					;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 188 OF E
  2445					;AND STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-0.  FIRST, A WORD
  2446					;WITH BIT 0 SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS
  2447					;IS EXECUTED.  THE AC IS THEN CHECKED FOR A 0 IN BIT 0, WHICH IS THE
  2448					;CORRECT RESULT.
  2449
  2450	031546	200 00 0 00 070331 	A5300:	MOVE	[XWD -1,0]	;LOAD E OF MOVS WITH 777777000000
  2451	031547	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH AC BIT 0 EQUAL TO 0
  2452	031550	337 00 0 00 000000 		SKIPG			;SKIP HALT INSTRUCTION IF BIT 0 OF AC IS 0
  2453						STOP^
  2454	031551	254 04 0 00 031552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2455	031552	324 00 0 00 031553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2457									;IN THE SUBTEST) TO LOOP ON ERROR^
  2458
  2459					;MOVSX: AR SWAP [ARMB], AR LT AR RT A [ARMB], AR LT AR RT B [ARMB],
  2460					;AR RT AR LT A [ARMB], AR RT AR LT B [ARMB], ET2 A F/F [E], IR MOVSX [IR1],
  2461					;IR MOV(E,S)X [IR1]
  2462
  2463					;**********
  2464
  2465					;THIS TEST VERIFIES THAT THE MOVS INSTRUCTION SWAPS BITS 0 AND 18 OF E AND
  2466					;STORES THEM IN THE AC UNLESS AR BIT 0 IS S-A-1.  FIRST, A WORD WITH BIT 0
  2467					;SET TO A ONE AND BIT 18 CLEARED IS LOADED INTO E.  THEN, MOVS IS EXECUTED.
  2468					;THE AC IS CHECKED FOR A ZERO IN BIT ZERO, WHICH IS THE CORRECT RESULT.
  2469
  2470	031553	200 00 0 00 070330 	A5400:	MOVE	[XWD 0,-1]	;LOAD E OF MOVS WITH 777777
  2471	031554	204 00 0 00 000000 		MOVS			;*MOVS SHOULD RESULT WITH BIT 0 OF THE AC SET
  2472	031555	331 00 0 00 000000 		SKIPL			;PASS IF AC BIT 0 IS SET
  2473						STOP^
  2474	031556	254 04 0 00 031557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2475	031557	324 00 0 00 031560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2476									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2477									;IN THE SUBTEST) TO LOOP ON ERROR^
  2478
  2479					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2480			005500		SN=5500
  2481			000000			ZZ=0
  2482
  2483					A5500:	REPEAT	^D18,
  2484					<;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2485					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2486					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2487					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2488					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2489					SN=SN+1
  2490						ZZ=ZZ+ZZ
  2491						IFE	ZZ,<ZZ=1>
  2492						MOVE	[0]		;CLEAR AC
  2493						MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2494						SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2495						STOP
  2496					
  2497					;**********
  2498					>
  2499					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2500					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2501					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2502					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2503					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2504			005501		SN=SN+1
  2505			000000			ZZ=ZZ+ZZ
  2506			000001			IFE	ZZ,<ZZ=1>
  2507	031560	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2508	031561	204 00 0 00 070265 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2509	031562	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2510						STOP^
  2511	031563	254 04 0 00 031564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2512	031564	324 00 0 00 031565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2513									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2514									;IN THE SUBTEST) TO LOOP ON ERROR^
  2515
  2516					;**********
  2517
  2518					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2519					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2520					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2521					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2522					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2523			005502		SN=SN+1
  2524			000002			ZZ=ZZ+ZZ
  2525						IFE	ZZ,<ZZ=1>
  2526	031565	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2527	031566	204 00 0 00 070266 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2528	031567	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2529						STOP^
  2530	031570	254 04 0 00 031571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2531	031571	324 00 0 00 031572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2533									;IN THE SUBTEST) TO LOOP ON ERROR^
  2534
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2535					;**********
  2536
  2537					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2538					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2539					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2540					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2541					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2542			005503		SN=SN+1
  2543			000004			ZZ=ZZ+ZZ
  2544						IFE	ZZ,<ZZ=1>
  2545	031572	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2546	031573	204 00 0 00 070267 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2547	031574	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2548						STOP^
  2549	031575	254 04 0 00 031576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2550	031576	324 00 0 00 031577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2552									;IN THE SUBTEST) TO LOOP ON ERROR^
  2553
  2554					;**********
  2555
  2556					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2557					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2558					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2559					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2560					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2561			005504		SN=SN+1
  2562			000010			ZZ=ZZ+ZZ
  2563						IFE	ZZ,<ZZ=1>
  2564	031577	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2565	031600	204 00 0 00 070270 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2566	031601	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2567						STOP^
  2568	031602	254 04 0 00 031603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2569	031603	324 00 0 00 031604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2571									;IN THE SUBTEST) TO LOOP ON ERROR^
  2572
  2573					;**********
  2574
  2575					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2576					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2577					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2578					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2579					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2580			005505		SN=SN+1
  2581			000020			ZZ=ZZ+ZZ
  2582						IFE	ZZ,<ZZ=1>
  2583	031604	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2584	031605	204 00 0 00 070271 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2585	031606	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2586						STOP^
  2587	031607	254 04 0 00 031610 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2588	031610	324 00 0 00 031611 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2589									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2590									;IN THE SUBTEST) TO LOOP ON ERROR^
  2591
  2592					;**********
  2593
  2594					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2595					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2596					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2597					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2598					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2599			005506		SN=SN+1
  2600			000040			ZZ=ZZ+ZZ
  2601						IFE	ZZ,<ZZ=1>
  2602	031611	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2603	031612	204 00 0 00 070272 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2604	031613	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2605						STOP^
  2606	031614	254 04 0 00 031615 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2607	031615	324 00 0 00 031616 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2608									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2609									;IN THE SUBTEST) TO LOOP ON ERROR^
  2610
  2611					;**********
  2612
  2613					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2614					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2615					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2616					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2617					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2618			005507		SN=SN+1
  2619			000100			ZZ=ZZ+ZZ
  2620						IFE	ZZ,<ZZ=1>
  2621	031616	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2622	031617	204 00 0 00 070273 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2623	031620	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2624						STOP^
  2625	031621	254 04 0 00 031622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2626	031622	324 00 0 00 031623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2627									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2628									;IN THE SUBTEST) TO LOOP ON ERROR^
  2629
  2630					;**********
  2631
  2632					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2633					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2634					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2635					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2636					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2637			005510		SN=SN+1
  2638			000200			ZZ=ZZ+ZZ
  2639						IFE	ZZ,<ZZ=1>
  2640	031623	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2641	031624	204 00 0 00 070274 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2642	031625	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2643						STOP^
  2644	031626	254 04 0 00 031627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2645	031627	324 00 0 00 031630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2646									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2647									;IN THE SUBTEST) TO LOOP ON ERROR^
  2648
  2649					;**********
  2650
  2651					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2652					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2653					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2654					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2655					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2656			005511		SN=SN+1
  2657			000400			ZZ=ZZ+ZZ
  2658						IFE	ZZ,<ZZ=1>
  2659	031630	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2660	031631	204 00 0 00 070275 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2661	031632	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2662						STOP^
  2663	031633	254 04 0 00 031634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2664	031634	324 00 0 00 031635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2665									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2666									;IN THE SUBTEST) TO LOOP ON ERROR^
  2667
  2668					;**********
  2669
  2670					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2671					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2672					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2673					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2674					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2675			005512		SN=SN+1
  2676			001000			ZZ=ZZ+ZZ
  2677						IFE	ZZ,<ZZ=1>
  2678	031635	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2679	031636	204 00 0 00 070276 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2680	031637	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2681						STOP^
  2682	031640	254 04 0 00 031641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2683	031641	324 00 0 00 031642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2685									;IN THE SUBTEST) TO LOOP ON ERROR^
  2686
  2687					;**********
  2688
  2689					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2690					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2691					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2692					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2693					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2694			005513		SN=SN+1
  2695			002000			ZZ=ZZ+ZZ
  2696						IFE	ZZ,<ZZ=1>
  2697	031642	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2698	031643	204 00 0 00 070277 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2699	031644	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2700						STOP^
  2701	031645	254 04 0 00 031646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2702	031646	324 00 0 00 031647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2703									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2704									;IN THE SUBTEST) TO LOOP ON ERROR^
  2705
  2706					;**********
  2707
  2708					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2709					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2710					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2711					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2712					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2713			005514		SN=SN+1
  2714			004000			ZZ=ZZ+ZZ
  2715						IFE	ZZ,<ZZ=1>
  2716	031647	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2717	031650	204 00 0 00 070300 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2718	031651	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2719						STOP^
  2720	031652	254 04 0 00 031653 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2721	031653	324 00 0 00 031654 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2722									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2723									;IN THE SUBTEST) TO LOOP ON ERROR^
  2724
  2725					;**********
  2726
  2727					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2728					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2729					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2730					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2731					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2732			005515		SN=SN+1
  2733			010000			ZZ=ZZ+ZZ
  2734						IFE	ZZ,<ZZ=1>
  2735	031654	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2736	031655	204 00 0 00 070301 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2737	031656	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2738						STOP^
  2739	031657	254 04 0 00 031660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2740	031660	324 00 0 00 031661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2741									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2742									;IN THE SUBTEST) TO LOOP ON ERROR^
  2743
  2744					;**********
  2745
  2746					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2747					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2748					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2749					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2750					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2751			005516		SN=SN+1
  2752			020000			ZZ=ZZ+ZZ
  2753						IFE	ZZ,<ZZ=1>
  2754	031661	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2755	031662	204 00 0 00 070302 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2756	031663	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2757						STOP^
  2758	031664	254 04 0 00 031665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2759	031665	324 00 0 00 031666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2760									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2761									;IN THE SUBTEST) TO LOOP ON ERROR^
  2762
  2763					;**********
  2764
  2765					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2766					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2767					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2768					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2769					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2770			005517		SN=SN+1
  2771			040000			ZZ=ZZ+ZZ
  2772						IFE	ZZ,<ZZ=1>
  2773	031666	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2774	031667	204 00 0 00 070303 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2775	031670	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2776						STOP^
  2777	031671	254 04 0 00 031672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2778	031672	324 00 0 00 031673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2779									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2780									;IN THE SUBTEST) TO LOOP ON ERROR^
  2781
  2782					;**********
  2783
  2784					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2785					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2786					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2787					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2788					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2789			005520		SN=SN+1
  2790			100000			ZZ=ZZ+ZZ
  2791						IFE	ZZ,<ZZ=1>
  2792	031673	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2793	031674	204 00 0 00 070304 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2794	031675	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2795						STOP^
  2796	031676	254 04 0 00 031677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2797	031677	324 00 0 00 031700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2798									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2799									;IN THE SUBTEST) TO LOOP ON ERROR^
  2800
  2801					;**********
  2802
  2803					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2804					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2805					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2806					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2807					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2808			005521		SN=SN+1
  2809			200000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2810						IFE	ZZ,<ZZ=1>
  2811	031700	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2812	031701	204 00 0 00 070305 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2813	031702	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2814						STOP^
  2815	031703	254 04 0 00 031704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2816	031704	324 00 0 00 031705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2818									;IN THE SUBTEST) TO LOOP ON ERROR^
  2819
  2820					;**********
  2821
  2822					;THIS TEST VERIFIES THAT AR LT INPUT IS FUNCTIONING.  A WORD OF ALL ZER0S,
  2823					;EXCEPT FOR ONE ONE IN THE RIGHT HALF IS SWAPPED.
  2824					;THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES
  2825					;IF C(AC) IS NON-ZERO. THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT
  2826					;OF THE LEFT HALF OF THE AC IS TESTED WITH A 1.
  2827			005522		SN=SN+1
  2828			400000			ZZ=ZZ+ZZ
  2829						IFE	ZZ,<ZZ=1>
  2830	031705	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2831	031706	204 00 0 00 070306 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2832	031707	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2833						STOP^
  2834	031710	254 04 0 00 031711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2835	031711	324 00 0 00 031712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2836									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2837									;IN THE SUBTEST) TO LOOP ON ERROR^
  2838
  2839					;**********
  2840
  2841			005600		SN=5600
  2842
  2843					A5600:	REPEAT	^D18,
  2844					<;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2845					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2846					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2847					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2848					;HALF OF THE AC IS TESTED WITH A 1.
  2849					
  2850					SN=SN+1
  2851						ZZ=ZZ+ZZ
  2852						MOVE	[0]		;CLEAR AC
  2853						MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2854						SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2855						STOP
  2856					
  2857					;**********
  2858					>
  2859					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2860					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2861					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2862					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2863					;HALF OF THE AC IS TESTED WITH A 1.
  2864
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2865			005601		SN=SN+1
  2866		000001	000000			ZZ=ZZ+ZZ
  2867	031712	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2868	031713	204 00 0 00 070307 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2869	031714	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2870						STOP^
  2871	031715	254 04 0 00 031716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2872	031716	324 00 0 00 031717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2873									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2874									;IN THE SUBTEST) TO LOOP ON ERROR^
  2875
  2876					;**********
  2877
  2878					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2879					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2880					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2881					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2882					;HALF OF THE AC IS TESTED WITH A 1.
  2883
  2884			005602		SN=SN+1
  2885		000002	000000			ZZ=ZZ+ZZ
  2886	031717	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2887	031720	204 00 0 00 070310 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2888	031721	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2889						STOP^
  2890	031722	254 04 0 00 031723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2891	031723	324 00 0 00 031724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2893									;IN THE SUBTEST) TO LOOP ON ERROR^
  2894
  2895					;**********
  2896
  2897					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2898					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2899					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2900					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2901					;HALF OF THE AC IS TESTED WITH A 1.
  2902
  2903			005603		SN=SN+1
  2904		000004	000000			ZZ=ZZ+ZZ
  2905	031724	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2906	031725	204 00 0 00 070311 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2907	031726	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2908						STOP^
  2909	031727	254 04 0 00 031730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2910	031730	324 00 0 00 031731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2911									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2912									;IN THE SUBTEST) TO LOOP ON ERROR^
  2913
  2914					;**********
  2915
  2916					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2917					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2918					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2919					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2920					;HALF OF THE AC IS TESTED WITH A 1.
  2921
  2922			005604		SN=SN+1
  2923		000010	000000			ZZ=ZZ+ZZ
  2924	031731	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2925	031732	204 00 0 00 070312 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2926	031733	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2927						STOP^
  2928	031734	254 04 0 00 031735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2929	031735	324 00 0 00 031736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2930									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2931									;IN THE SUBTEST) TO LOOP ON ERROR^
  2932
  2933					;**********
  2934
  2935					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2936					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2937					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2938					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2939					;HALF OF THE AC IS TESTED WITH A 1.
  2940
  2941			005605		SN=SN+1
  2942		000020	000000			ZZ=ZZ+ZZ
  2943	031736	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2944	031737	204 00 0 00 070313 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2945	031740	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2946						STOP^
  2947	031741	254 04 0 00 031742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2948	031742	324 00 0 00 031743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2950									;IN THE SUBTEST) TO LOOP ON ERROR^
  2951
  2952					;**********
  2953
  2954					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2955					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2956					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2957					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2958					;HALF OF THE AC IS TESTED WITH A 1.
  2959
  2960			005606		SN=SN+1
  2961		000040	000000			ZZ=ZZ+ZZ
  2962	031743	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2963	031744	204 00 0 00 070314 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2964	031745	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2965						STOP^
  2966	031746	254 04 0 00 031747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2967	031747	324 00 0 00 031750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2968									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2969									;IN THE SUBTEST) TO LOOP ON ERROR^
  2970
  2971					;**********
  2972
  2973					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2974					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  2975					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2976					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2977					;HALF OF THE AC IS TESTED WITH A 1.
  2978
  2979			005607		SN=SN+1
  2980		000100	000000			ZZ=ZZ+ZZ
  2981	031750	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  2982	031751	204 00 0 00 070315 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  2983	031752	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  2984						STOP^
  2985	031753	254 04 0 00 031754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  2986	031754	324 00 0 00 031755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  2987									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  2988									;IN THE SUBTEST) TO LOOP ON ERROR^
  2989
  2990					;**********
  2991
  2992					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  2993					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  2994					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  2995					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  2996					;HALF OF THE AC IS TESTED WITH A 1.
  2997
  2998			005610		SN=SN+1
  2999		000200	000000			ZZ=ZZ+ZZ
  3000	031755	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3001	031756	204 00 0 00 070316 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3002	031757	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3003						STOP^
  3004	031760	254 04 0 00 031761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3005	031761	324 00 0 00 031762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3007									;IN THE SUBTEST) TO LOOP ON ERROR^
  3008
  3009					;**********
  3010
  3011					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3012					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3013					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3014					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3015					;HALF OF THE AC IS TESTED WITH A 1.
  3016
  3017			005611		SN=SN+1
  3018		000400	000000			ZZ=ZZ+ZZ
  3019	031762	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3020	031763	204 00 0 00 070264 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3021	031764	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3022						STOP^
  3023	031765	254 04 0 00 031766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3024	031766	324 00 0 00 031767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3026									;IN THE SUBTEST) TO LOOP ON ERROR^
  3027
  3028					;**********
  3029
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  3030					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3031					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3032					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3033					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3034					;HALF OF THE AC IS TESTED WITH A 1.
  3035
  3036			005612		SN=SN+1
  3037		001000	000000			ZZ=ZZ+ZZ
  3038	031767	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3039	031770	204 00 0 00 070317 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3040	031771	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3041						STOP^
  3042	031772	254 04 0 00 031773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3043	031773	324 00 0 00 031774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3044									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3045									;IN THE SUBTEST) TO LOOP ON ERROR^
  3046
  3047					;**********
  3048
  3049					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3050					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3051					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3052					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3053					;HALF OF THE AC IS TESTED WITH A 1.
  3054
  3055			005613		SN=SN+1
  3056		002000	000000			ZZ=ZZ+ZZ
  3057	031774	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3058	031775	204 00 0 00 070320 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3059	031776	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3060						STOP^
  3061	031777	254 04 0 00 032000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3062	032000	324 00 0 00 032001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3063									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3064									;IN THE SUBTEST) TO LOOP ON ERROR^
  3065
  3066					;**********
  3067
  3068					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3069					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3070					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3071					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3072					;HALF OF THE AC IS TESTED WITH A 1.
  3073
  3074			005614		SN=SN+1
  3075		004000	000000			ZZ=ZZ+ZZ
  3076	032001	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3077	032002	204 00 0 00 070321 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3078	032003	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3079						STOP^
  3080	032004	254 04 0 00 032005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3081	032005	324 00 0 00 032006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3082									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3083									;IN THE SUBTEST) TO LOOP ON ERROR^
  3084
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  3085					;**********
  3086
  3087					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3088					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3089					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3090					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3091					;HALF OF THE AC IS TESTED WITH A 1.
  3092
  3093			005615		SN=SN+1
  3094		010000	000000			ZZ=ZZ+ZZ
  3095	032006	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3096	032007	204 00 0 00 070322 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3097	032010	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3098						STOP^
  3099	032011	254 04 0 00 032012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3100	032012	324 00 0 00 032013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3101									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3102									;IN THE SUBTEST) TO LOOP ON ERROR^
  3103
  3104					;**********
  3105
  3106					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3107					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3108					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3109					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3110					;HALF OF THE AC IS TESTED WITH A 1.
  3111
  3112			005616		SN=SN+1
  3113		020000	000000			ZZ=ZZ+ZZ
  3114	032013	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3115	032014	204 00 0 00 070323 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3116	032015	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3117						STOP^
  3118	032016	254 04 0 00 032017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3119	032017	324 00 0 00 032020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3120									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3121									;IN THE SUBTEST) TO LOOP ON ERROR^
  3122
  3123					;**********
  3124
  3125					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3126					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3127					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3128					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3129					;HALF OF THE AC IS TESTED WITH A 1.
  3130
  3131			005617		SN=SN+1
  3132		040000	000000			ZZ=ZZ+ZZ
  3133	032020	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3134	032021	204 00 0 00 070324 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3135	032022	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3136						STOP^
  3137	032023	254 04 0 00 032024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3138	032024	324 00 0 00 032025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3139									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  3140									;IN THE SUBTEST) TO LOOP ON ERROR^
  3141
  3142					;**********
  3143
  3144					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3145					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3146					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3147					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3148					;HALF OF THE AC IS TESTED WITH A 1.
  3149
  3150			005620		SN=SN+1
  3151		100000	000000			ZZ=ZZ+ZZ
  3152	032025	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3153	032026	204 00 0 00 070325 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3154	032027	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3155						STOP^
  3156	032030	254 04 0 00 032031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3157	032031	324 00 0 00 032032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3158									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3159									;IN THE SUBTEST) TO LOOP ON ERROR^
  3160
  3161					;**********
  3162
  3163					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3164					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3165					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3166					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3167					;HALF OF THE AC IS TESTED WITH A 1.
  3168
  3169			005621		SN=SN+1
  3170		200000	000000			ZZ=ZZ+ZZ
  3171	032032	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3172	032033	204 00 0 00 070326 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3173	032034	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3174						STOP^
  3175	032035	254 04 0 00 032036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3176	032036	324 00 0 00 032037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3178									;IN THE SUBTEST) TO LOOP ON ERROR^
  3179
  3180					;**********
  3181
  3182					;THIS TEST VERIFIES THAT AR RT INPUT IS FUNCTIONING.  A WORD OF ALL
  3183					;ZEROS, EXCEPT FOR ONE ONE IN THE LEFT HALF IS SWAPPED.  THE AC IS
  3184					;CHECKED FOR ITS CONTENTS NON-ZERO.  THE TEST PASSES IF C(AC) IS
  3185					;NON-ZERO.  THIS TEST IS REPEATED 18 TIMES SO THAT EACH BIT OF THE RIGHT
  3186					;HALF OF THE AC IS TESTED WITH A 1.
  3187
  3188			005622		SN=SN+1
  3189		400000	000000			ZZ=ZZ+ZZ
  3190	032037	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  3191	032040	204 00 0 00 070256 		MOVS	[ZZ]		;*MOVS SHOULD RESULT WITH A NON-ZERO WORD IN THE AC
  3192	032041	336 00 0 00 000000 		SKIPN			;SKIP HALT INSTRUCTION IF SET BIT IS NOT LOST IN SWAP.
  3193						STOP^
  3194	032042	254 04 0 00 032043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF SKIP, FULL WORD TRANSFER AND HALF WORD TRANSFER INSTRUCTIONS

  3195	032043	324 00 0 00 032044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3196									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3197									;IN THE SUBTEST) TO LOOP ON ERROR^
  3198
  3199					;**********
  3200
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3201					SUBTTL	TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)
  3202
  3203					;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET
  3204					;TO ZERO; THEN, SETM IS EXECUTED WITH ALL ONES IN E.  BIT 0 OF THE AC
  3205					;IS THEN CHECKED FOR A 1.
  3206
  3207	032044	200 00 0 00 070253 	A5700:	MOVE	[0]		;PRELOAD AC WITH ALL ZEROS
  3208	032045	414 00 0 00 070254 		SETM	[-1]		;*SETM SHOULD LOAD AC WITH ALL ONES
  3209	032046	331 00 0 00 000000 		SKIPL			;PASS TEST IF AC BIT 0 IS A ONE
  3210						STOP^
  3211	032047	254 04 0 00 032050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3212	032050	324 00 0 00 032051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3213									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3214									;IN THE SUBTEST) TO LOOP ON ERROR^
  3215					;FCE [F1], IR BOOLE [IR1], IRXX(0,5,12,17) [IR2]
  3216
  3217					;**********
  3218
  3219					;THIS TEST VERIFIES THAT SETM LOADS AC FROM E.  THE AC IS FIRST SET TO
  3220					;ALL ONES; THEN, SETM IS EXECUTED WITH ALL ZEROS IN E.  THE AC IS CHECKED
  3221					;FOR ALL ZEROS
  3222
  3223	032051	200 00 0 00 070254 	A6000:	MOVE	[-1]		;PRESET AC TO ALL ONES
  3224	032052	414 00 0 00 070253 		SETM	[0]		;*SETM SHOULD LOAD AC WITH ALL ONES
  3225	032053	332 00 0 00 000000 		SKIPE			;PASSES TEST IF C(AC) = 0
  3226						STOP^
  3227	032054	254 04 0 00 032055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3228	032055	324 00 0 00 032056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3229									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3230									;IN THE SUBTEST) TO LOOP ON ERROR^
  3231
  3232					;AD AR + EN [ADAP], AD AR + EN C[ADAP],
  3233					;F CYC ACT EN A[F1], IR BOOLE AD A +F[IR2],
  3234					;IR BOOLE [IR1], IRXX(1-3,6,11,15,16) [IR2]
  3235
  3236					;**********
  3237
  3238					;THIS TEST VERIFIES THAT SETZ LOADS TH AC WITH ALL ZEROS.  FIRST, A WORD
  3239					;OF ALL ZEROS IS LOADED INTO THE AC VIA A MOVE INSTC. THEN, SETZ IS
  3240					;EXECUTED.  THE AC IS CHECKED FOR ALL ZEROS.
  3241					;IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.
  3242
  3243	032056	200 00 0 00 070253 	A6100:	MOVE	[0]		;RESET AC TO ALL ZEROS
  3244	032057	400 00 0 00 000000 		SETZ			;*SETZ SHOULD CLEAR THE AC
  3245	032060	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3246						STOP^
  3247	032061	254 04 0 00 032062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3248	032062	324 00 0 00 032063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3249									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3250									;IN THE SUBTEST) TO LOOP ON ERROR^
  3251
  3252					;AD MASK GEN EN [ADC1], AD MASK GEN F/F'S [ADC1]
  3253					;AD MASK EN B; F CYC ACT EN B[F1]; IRXX00 [IR1];
  3254					;IR BOOLE [IR1]
  3255
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3256					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3257					;THIS TEST VERIFIES THAT SETZ LOADS THE AC WITH ALL ZEROS.  FIRST,
  3258					;THE AC IS SET TO ALL ONES; THEN, SETZ IS EXECUTED.  THE AC IS THEN
  3259					;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET, THE TEST FAILS.
  3260
  3261	032063	200 00 0 00 070254 	A6200:	MOVE	[-1]		;PRESET AC TO ALL ONES
  3262	032064	400 00 0 00 032064 		SETZ	.		;*SETZ SHOULD CLEAR THE AC
  3263	032065	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3264						STOP^
  3265	032066	254 04 0 00 032067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3266	032067	324 00 0 00 032070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3267									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3268									;IN THE SUBTEST) TO LOOP ON ERROR^
  3269
  3270					;AR AD EN [ARMA], AR AD ET2 EN [ARMA], IR BOOLE [IR]
  3271
  3272					;**********
  3273
  3274					;THIS TEST VERIFIES THAT THE AND INSTRUCTION OPERATING ON AN AC
  3275					;CONTAINING ALL ZEROS AND AN E CONTAINING ALL ZEROS RESULTS IN AN AC
  3276					;OF ALL ZEROS.  THE AC AND E ARE THE SAME IN THIS TEST.
  3277					;AC, E ARE LOADED WITH ZEROS; THEN, AND IS EXECUTED.  THE AC IS THEN
  3278					;CHECKED FOR ALL ZEROS.  IF ANY BITS IN THE AC ARE SET BY THE AND INSTRUCTION,
  3279					;THE TEST FAILS.
  3280
  3281
  3282	032070	200 00 0 00 070253 	A6300:	MOVE	[0]		;PRESET AC, E TO ALL ZEROS
  3283	032071	404 00 0 00 000000 		AND			;*AND SHOULD RESULT IN C(AC) = 0
  3284	032072	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) = 0
  3285						STOP^
  3286	032073	254 04 0 00 032074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3287	032074	324 00 0 00 032075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3288									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3289									;IN THE SUBTEST) TO LOOP ON ERROR^
  3290
  3291					;**********
  3292			006400		SN=6400
  3293			000000			ZZ=0
  3294
  3295					A6400:	REPEAT	^D36,
  3296					<;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3297					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3298					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3299					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3300					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3301					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3302					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3303					
  3304					SN=SN+1
  3305						ZZ=ZZ+ZZ
  3306						IFE	ZZ,<ZZ=1>
  3307						SETZ			;PRESET E TO ALL ZEROS
  3308						MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3309									;WHERE X VARIES FROM 0 THRU 35
  3310						AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3311						SKIPE	1		;FAIL IF C(AC) NON-ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3312						STOP
  3313						SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3314						STOP
  3315					;**********
  3316					>
  3317					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3318					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3319					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3320					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3321					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3322					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3323					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3324
  3325			006401		SN=SN+1
  3326			000000			ZZ=ZZ+ZZ
  3327			000001			IFE	ZZ,<ZZ=1>
  3328	032075	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3329	032076	200 01 0 00 070265 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3330									;WHERE X VARIES FROM 0 THRU 35
  3331	032077	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3332	032100	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3333						STOP^
  3334	032101	254 04 0 00 032102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3335	032102	324 00 0 00 032103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3336									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3337									;IN THE SUBTEST) TO LOOP ON ERROR^
  3338	032103	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3339						STOP^
  3340	032104	254 04 0 00 032105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3341	032105	324 00 0 00 032106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3342									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3343									;IN THE SUBTEST) TO LOOP ON ERROR^
  3344					;**********
  3345
  3346					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3347					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3348					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3349					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3350					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3351					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3352					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3353
  3354			006402		SN=SN+1
  3355			000002			ZZ=ZZ+ZZ
  3356						IFE	ZZ,<ZZ=1>
  3357	032106	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3358	032107	200 01 0 00 070266 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3359									;WHERE X VARIES FROM 0 THRU 35
  3360	032110	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3361	032111	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3362						STOP^
  3363	032112	254 04 0 00 032113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3364	032113	324 00 0 00 032114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3365									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3366									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3367	032114	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3368						STOP^
  3369	032115	254 04 0 00 032116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3370	032116	324 00 0 00 032117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3371									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3372									;IN THE SUBTEST) TO LOOP ON ERROR^
  3373					;**********
  3374
  3375					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3376					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3377					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3378					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3379					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3380					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3381					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3382
  3383			006403		SN=SN+1
  3384			000004			ZZ=ZZ+ZZ
  3385						IFE	ZZ,<ZZ=1>
  3386	032117	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3387	032120	200 01 0 00 070267 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3388									;WHERE X VARIES FROM 0 THRU 35
  3389	032121	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3390	032122	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3391						STOP^
  3392	032123	254 04 0 00 032124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3393	032124	324 00 0 00 032125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3394									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3395									;IN THE SUBTEST) TO LOOP ON ERROR^
  3396	032125	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3397						STOP^
  3398	032126	254 04 0 00 032127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3399	032127	324 00 0 00 032130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3401									;IN THE SUBTEST) TO LOOP ON ERROR^
  3402					;**********
  3403
  3404					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3405					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3406					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3407					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3408					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3409					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3410					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3411
  3412			006404		SN=SN+1
  3413			000010			ZZ=ZZ+ZZ
  3414						IFE	ZZ,<ZZ=1>
  3415	032130	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3416	032131	200 01 0 00 070270 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3417									;WHERE X VARIES FROM 0 THRU 35
  3418	032132	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3419	032133	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3420						STOP^
  3421	032134	254 04 0 00 032135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3422	032135	324 00 0 00 032136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3423									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3424									;IN THE SUBTEST) TO LOOP ON ERROR^
  3425	032136	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3426						STOP^
  3427	032137	254 04 0 00 032140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3428	032140	324 00 0 00 032141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3429									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3430									;IN THE SUBTEST) TO LOOP ON ERROR^
  3431					;**********
  3432
  3433					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3434					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3435					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3436					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3437					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3438					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3439					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3440
  3441			006405		SN=SN+1
  3442			000020			ZZ=ZZ+ZZ
  3443						IFE	ZZ,<ZZ=1>
  3444	032141	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3445	032142	200 01 0 00 070271 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3446									;WHERE X VARIES FROM 0 THRU 35
  3447	032143	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3448	032144	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3449						STOP^
  3450	032145	254 04 0 00 032146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3451	032146	324 00 0 00 032147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3453									;IN THE SUBTEST) TO LOOP ON ERROR^
  3454	032147	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3455						STOP^
  3456	032150	254 04 0 00 032151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3457	032151	324 00 0 00 032152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3458									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3459									;IN THE SUBTEST) TO LOOP ON ERROR^
  3460					;**********
  3461
  3462					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3463					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3464					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3465					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3466					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3467					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3468					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3469
  3470			006406		SN=SN+1
  3471			000040			ZZ=ZZ+ZZ
  3472						IFE	ZZ,<ZZ=1>
  3473	032152	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3474	032153	200 01 0 00 070272 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3475									;WHERE X VARIES FROM 0 THRU 35
  3476	032154	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3477	032155	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3478						STOP^
  3479	032156	254 04 0 00 032157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3480	032157	324 00 0 00 032160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3481									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3482									;IN THE SUBTEST) TO LOOP ON ERROR^
  3483	032160	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3484						STOP^
  3485	032161	254 04 0 00 032162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3486	032162	324 00 0 00 032163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3487									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3488									;IN THE SUBTEST) TO LOOP ON ERROR^
  3489					;**********
  3490
  3491					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3492					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3493					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3494					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3495					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3496					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3497					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3498
  3499			006407		SN=SN+1
  3500			000100			ZZ=ZZ+ZZ
  3501						IFE	ZZ,<ZZ=1>
  3502	032163	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3503	032164	200 01 0 00 070273 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3504									;WHERE X VARIES FROM 0 THRU 35
  3505	032165	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3506	032166	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3507						STOP^
  3508	032167	254 04 0 00 032170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3509	032170	324 00 0 00 032171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3511									;IN THE SUBTEST) TO LOOP ON ERROR^
  3512	032171	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3513						STOP^
  3514	032172	254 04 0 00 032173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3515	032173	324 00 0 00 032174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3517									;IN THE SUBTEST) TO LOOP ON ERROR^
  3518					;**********
  3519
  3520					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3521					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3522					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3523					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3524					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3525					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3526					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3527
  3528			006410		SN=SN+1
  3529			000200			ZZ=ZZ+ZZ
  3530						IFE	ZZ,<ZZ=1>
  3531	032174	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3532	032175	200 01 0 00 070274 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3533									;WHERE X VARIES FROM 0 THRU 35
  3534	032176	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3535	032177	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3536						STOP^
  3537	032200	254 04 0 00 032201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3538	032201	324 00 0 00 032202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3539									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3540									;IN THE SUBTEST) TO LOOP ON ERROR^
  3541	032202	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3542						STOP^
  3543	032203	254 04 0 00 032204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3544	032204	324 00 0 00 032205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3545									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3546									;IN THE SUBTEST) TO LOOP ON ERROR^
  3547					;**********
  3548
  3549					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3550					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3551					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3552					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3553					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3554					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3555					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3556
  3557			006411		SN=SN+1
  3558			000400			ZZ=ZZ+ZZ
  3559						IFE	ZZ,<ZZ=1>
  3560	032205	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3561	032206	200 01 0 00 070275 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3562									;WHERE X VARIES FROM 0 THRU 35
  3563	032207	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3564	032210	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3565						STOP^
  3566	032211	254 04 0 00 032212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3567	032212	324 00 0 00 032213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3569									;IN THE SUBTEST) TO LOOP ON ERROR^
  3570	032213	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3571						STOP^
  3572	032214	254 04 0 00 032215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3573	032215	324 00 0 00 032216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3574									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3575									;IN THE SUBTEST) TO LOOP ON ERROR^
  3576					;**********
  3577
  3578					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3579					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3580					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3581					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3582					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3583					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3584					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3585
  3586			006412		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3587			001000			ZZ=ZZ+ZZ
  3588						IFE	ZZ,<ZZ=1>
  3589	032216	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3590	032217	200 01 0 00 070276 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3591									;WHERE X VARIES FROM 0 THRU 35
  3592	032220	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3593	032221	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3594						STOP^
  3595	032222	254 04 0 00 032223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3596	032223	324 00 0 00 032224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3598									;IN THE SUBTEST) TO LOOP ON ERROR^
  3599	032224	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3600						STOP^
  3601	032225	254 04 0 00 032226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3602	032226	324 00 0 00 032227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3603									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3604									;IN THE SUBTEST) TO LOOP ON ERROR^
  3605					;**********
  3606
  3607					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3608					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3609					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3610					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3611					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3612					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3613					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3614
  3615			006413		SN=SN+1
  3616			002000			ZZ=ZZ+ZZ
  3617						IFE	ZZ,<ZZ=1>
  3618	032227	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3619	032230	200 01 0 00 070277 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3620									;WHERE X VARIES FROM 0 THRU 35
  3621	032231	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3622	032232	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3623						STOP^
  3624	032233	254 04 0 00 032234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3625	032234	324 00 0 00 032235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3627									;IN THE SUBTEST) TO LOOP ON ERROR^
  3628	032235	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3629						STOP^
  3630	032236	254 04 0 00 032237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3631	032237	324 00 0 00 032240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3632									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3633									;IN THE SUBTEST) TO LOOP ON ERROR^
  3634					;**********
  3635
  3636					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3637					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3638					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3639					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3640					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3641					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3642					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3643
  3644			006414		SN=SN+1
  3645			004000			ZZ=ZZ+ZZ
  3646						IFE	ZZ,<ZZ=1>
  3647	032240	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3648	032241	200 01 0 00 070300 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3649									;WHERE X VARIES FROM 0 THRU 35
  3650	032242	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3651	032243	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3652						STOP^
  3653	032244	254 04 0 00 032245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3654	032245	324 00 0 00 032246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3656									;IN THE SUBTEST) TO LOOP ON ERROR^
  3657	032246	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3658						STOP^
  3659	032247	254 04 0 00 032250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3660	032250	324 00 0 00 032251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3661									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3662									;IN THE SUBTEST) TO LOOP ON ERROR^
  3663					;**********
  3664
  3665					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3666					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3667					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3668					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3669					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3670					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3671					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3672
  3673			006415		SN=SN+1
  3674			010000			ZZ=ZZ+ZZ
  3675						IFE	ZZ,<ZZ=1>
  3676	032251	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3677	032252	200 01 0 00 070301 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3678									;WHERE X VARIES FROM 0 THRU 35
  3679	032253	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3680	032254	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3681						STOP^
  3682	032255	254 04 0 00 032256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3683	032256	324 00 0 00 032257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3685									;IN THE SUBTEST) TO LOOP ON ERROR^
  3686	032257	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3687						STOP^
  3688	032260	254 04 0 00 032261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3689	032261	324 00 0 00 032262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3691									;IN THE SUBTEST) TO LOOP ON ERROR^
  3692					;**********
  3693
  3694					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3695					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3696					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3697					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3698					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3699					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3700					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3701
  3702			006416		SN=SN+1
  3703			020000			ZZ=ZZ+ZZ
  3704						IFE	ZZ,<ZZ=1>
  3705	032262	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3706	032263	200 01 0 00 070302 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3707									;WHERE X VARIES FROM 0 THRU 35
  3708	032264	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3709	032265	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3710						STOP^
  3711	032266	254 04 0 00 032267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3712	032267	324 00 0 00 032270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3713									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3714									;IN THE SUBTEST) TO LOOP ON ERROR^
  3715	032270	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3716						STOP^
  3717	032271	254 04 0 00 032272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3718	032272	324 00 0 00 032273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3720									;IN THE SUBTEST) TO LOOP ON ERROR^
  3721					;**********
  3722
  3723					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3724					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3725					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3726					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3727					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3728					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3729					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3730
  3731			006417		SN=SN+1
  3732			040000			ZZ=ZZ+ZZ
  3733						IFE	ZZ,<ZZ=1>
  3734	032273	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3735	032274	200 01 0 00 070303 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3736									;WHERE X VARIES FROM 0 THRU 35
  3737	032275	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3738	032276	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3739						STOP^
  3740	032277	254 04 0 00 032300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3741	032300	324 00 0 00 032301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3742									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3743									;IN THE SUBTEST) TO LOOP ON ERROR^
  3744	032301	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3745						STOP^
  3746	032302	254 04 0 00 032303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3747	032303	324 00 0 00 032304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3748									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3749									;IN THE SUBTEST) TO LOOP ON ERROR^
  3750					;**********
  3751
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3752					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3753					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3754					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3755					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3756					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3757					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3758					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3759
  3760			006420		SN=SN+1
  3761			100000			ZZ=ZZ+ZZ
  3762						IFE	ZZ,<ZZ=1>
  3763	032304	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3764	032305	200 01 0 00 070304 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3765									;WHERE X VARIES FROM 0 THRU 35
  3766	032306	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3767	032307	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3768						STOP^
  3769	032310	254 04 0 00 032311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3770	032311	324 00 0 00 032312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3771									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3772									;IN THE SUBTEST) TO LOOP ON ERROR^
  3773	032312	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3774						STOP^
  3775	032313	254 04 0 00 032314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3776	032314	324 00 0 00 032315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3777									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3778									;IN THE SUBTEST) TO LOOP ON ERROR^
  3779					;**********
  3780
  3781					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3782					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3783					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3784					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3785					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3786					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3787					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3788
  3789			006421		SN=SN+1
  3790			200000			ZZ=ZZ+ZZ
  3791						IFE	ZZ,<ZZ=1>
  3792	032315	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3793	032316	200 01 0 00 070305 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3794									;WHERE X VARIES FROM 0 THRU 35
  3795	032317	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3796	032320	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3797						STOP^
  3798	032321	254 04 0 00 032322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3799	032322	324 00 0 00 032323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3800									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3801									;IN THE SUBTEST) TO LOOP ON ERROR^
  3802	032323	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3803						STOP^
  3804	032324	254 04 0 00 032325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3805	032325	324 00 0 00 032326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3807									;IN THE SUBTEST) TO LOOP ON ERROR^
  3808					;**********
  3809
  3810					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3811					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3812					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3813					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3814					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3815					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3816					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3817
  3818			006422		SN=SN+1
  3819			400000			ZZ=ZZ+ZZ
  3820						IFE	ZZ,<ZZ=1>
  3821	032326	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3822	032327	200 01 0 00 070306 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3823									;WHERE X VARIES FROM 0 THRU 35
  3824	032330	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3825	032331	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3826						STOP^
  3827	032332	254 04 0 00 032333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3828	032333	324 00 0 00 032334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3829									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3830									;IN THE SUBTEST) TO LOOP ON ERROR^
  3831	032334	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3832						STOP^
  3833	032335	254 04 0 00 032336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3834	032336	324 00 0 00 032337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3835									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3836									;IN THE SUBTEST) TO LOOP ON ERROR^
  3837					;**********
  3838
  3839					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3840					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3841					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3842					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3843					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3844					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3845					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3846
  3847			006423		SN=SN+1
  3848		000001	000000			ZZ=ZZ+ZZ
  3849						IFE	ZZ,<ZZ=1>
  3850	032337	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3851	032340	200 01 0 00 070307 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3852									;WHERE X VARIES FROM 0 THRU 35
  3853	032341	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3854	032342	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3855						STOP^
  3856	032343	254 04 0 00 032344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3857	032344	324 00 0 00 032345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3859									;IN THE SUBTEST) TO LOOP ON ERROR^
  3860	032345	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3861						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3862	032346	254 04 0 00 032347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3863	032347	324 00 0 00 032350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3864									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3865									;IN THE SUBTEST) TO LOOP ON ERROR^
  3866					;**********
  3867
  3868					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3869					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3870					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3871					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3872					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3873					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3874					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3875
  3876			006424		SN=SN+1
  3877		000002	000000			ZZ=ZZ+ZZ
  3878						IFE	ZZ,<ZZ=1>
  3879	032350	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3880	032351	200 01 0 00 070310 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3881									;WHERE X VARIES FROM 0 THRU 35
  3882	032352	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3883	032353	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3884						STOP^
  3885	032354	254 04 0 00 032355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3886	032355	324 00 0 00 032356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3887									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3888									;IN THE SUBTEST) TO LOOP ON ERROR^
  3889	032356	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3890						STOP^
  3891	032357	254 04 0 00 032360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3892	032360	324 00 0 00 032361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3894									;IN THE SUBTEST) TO LOOP ON ERROR^
  3895					;**********
  3896
  3897					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3898					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3899					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3900					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3901					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3902					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3903					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3904
  3905			006425		SN=SN+1
  3906		000004	000000			ZZ=ZZ+ZZ
  3907						IFE	ZZ,<ZZ=1>
  3908	032361	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3909	032362	200 01 0 00 070311 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3910									;WHERE X VARIES FROM 0 THRU 35
  3911	032363	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3912	032364	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3913						STOP^
  3914	032365	254 04 0 00 032366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3915	032366	324 00 0 00 032367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3916									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3917									;IN THE SUBTEST) TO LOOP ON ERROR^
  3918	032367	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3919						STOP^
  3920	032370	254 04 0 00 032371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3921	032371	324 00 0 00 032372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3922									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3923									;IN THE SUBTEST) TO LOOP ON ERROR^
  3924					;**********
  3925
  3926					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3927					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3928					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3929					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3930					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3931					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3932					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3933
  3934			006426		SN=SN+1
  3935		000010	000000			ZZ=ZZ+ZZ
  3936						IFE	ZZ,<ZZ=1>
  3937	032372	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3938	032373	200 01 0 00 070312 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3939									;WHERE X VARIES FROM 0 THRU 35
  3940	032374	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3941	032375	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3942						STOP^
  3943	032376	254 04 0 00 032377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3944	032377	324 00 0 00 032400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3945									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3946									;IN THE SUBTEST) TO LOOP ON ERROR^
  3947	032400	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3948						STOP^
  3949	032401	254 04 0 00 032402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3950	032402	324 00 0 00 032403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3952									;IN THE SUBTEST) TO LOOP ON ERROR^
  3953					;**********
  3954
  3955					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3956					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3957					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3958					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3959					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3960					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3961					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3962
  3963			006427		SN=SN+1
  3964		000020	000000			ZZ=ZZ+ZZ
  3965						IFE	ZZ,<ZZ=1>
  3966	032403	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3967	032404	200 01 0 00 070313 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3968									;WHERE X VARIES FROM 0 THRU 35
  3969	032405	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3970	032406	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  3971						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  3972	032407	254 04 0 00 032410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3973	032410	324 00 0 00 032411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3974									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3975									;IN THE SUBTEST) TO LOOP ON ERROR^
  3976	032411	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  3977						STOP^
  3978	032412	254 04 0 00 032413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  3979	032413	324 00 0 00 032414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  3980									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  3981									;IN THE SUBTEST) TO LOOP ON ERROR^
  3982					;**********
  3983
  3984					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  3985					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  3986					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  3987					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  3988					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  3989					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  3990					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  3991
  3992			006430		SN=SN+1
  3993		000040	000000			ZZ=ZZ+ZZ
  3994						IFE	ZZ,<ZZ=1>
  3995	032414	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  3996	032415	200 01 0 00 070314 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  3997									;WHERE X VARIES FROM 0 THRU 35
  3998	032416	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  3999	032417	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4000						STOP^
  4001	032420	254 04 0 00 032421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4002	032421	324 00 0 00 032422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4004									;IN THE SUBTEST) TO LOOP ON ERROR^
  4005	032422	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4006						STOP^
  4007	032423	254 04 0 00 032424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4008	032424	324 00 0 00 032425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4009									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4010									;IN THE SUBTEST) TO LOOP ON ERROR^
  4011					;**********
  4012
  4013					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4014					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4015					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4016					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4017					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4018					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4019					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4020
  4021			006431		SN=SN+1
  4022		000100	000000			ZZ=ZZ+ZZ
  4023						IFE	ZZ,<ZZ=1>
  4024	032425	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4025	032426	200 01 0 00 070315 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4026									;WHERE X VARIES FROM 0 THRU 35
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-14
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4027	032427	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4028	032430	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4029						STOP^
  4030	032431	254 04 0 00 032432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4031	032432	324 00 0 00 032433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4033									;IN THE SUBTEST) TO LOOP ON ERROR^
  4034	032433	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4035						STOP^
  4036	032434	254 04 0 00 032435 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4037	032435	324 00 0 00 032436 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4038									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4039									;IN THE SUBTEST) TO LOOP ON ERROR^
  4040					;**********
  4041
  4042					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4043					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4044					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4045					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4046					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4047					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4048					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4049
  4050			006432		SN=SN+1
  4051		000200	000000			ZZ=ZZ+ZZ
  4052						IFE	ZZ,<ZZ=1>
  4053	032436	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4054	032437	200 01 0 00 070316 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4055									;WHERE X VARIES FROM 0 THRU 35
  4056	032440	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4057	032441	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4058						STOP^
  4059	032442	254 04 0 00 032443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4060	032443	324 00 0 00 032444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4061									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4062									;IN THE SUBTEST) TO LOOP ON ERROR^
  4063	032444	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4064						STOP^
  4065	032445	254 04 0 00 032446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4066	032446	324 00 0 00 032447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4068									;IN THE SUBTEST) TO LOOP ON ERROR^
  4069					;**********
  4070
  4071					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4072					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4073					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4074					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4075					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4076					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4077					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4078
  4079			006433		SN=SN+1
  4080		000400	000000			ZZ=ZZ+ZZ
  4081						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-15
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4082	032447	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4083	032450	200 01 0 00 070264 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4084									;WHERE X VARIES FROM 0 THRU 35
  4085	032451	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4086	032452	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4087						STOP^
  4088	032453	254 04 0 00 032454 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4089	032454	324 00 0 00 032455 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4091									;IN THE SUBTEST) TO LOOP ON ERROR^
  4092	032455	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4093						STOP^
  4094	032456	254 04 0 00 032457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4095	032457	324 00 0 00 032460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4096									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4097									;IN THE SUBTEST) TO LOOP ON ERROR^
  4098					;**********
  4099
  4100					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4101					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4102					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4103					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4104					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4105					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4106					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4107
  4108			006434		SN=SN+1
  4109		001000	000000			ZZ=ZZ+ZZ
  4110						IFE	ZZ,<ZZ=1>
  4111	032460	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4112	032461	200 01 0 00 070317 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4113									;WHERE X VARIES FROM 0 THRU 35
  4114	032462	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4115	032463	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4116						STOP^
  4117	032464	254 04 0 00 032465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4118	032465	324 00 0 00 032466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4120									;IN THE SUBTEST) TO LOOP ON ERROR^
  4121	032466	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4122						STOP^
  4123	032467	254 04 0 00 032470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4124	032470	324 00 0 00 032471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4125									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4126									;IN THE SUBTEST) TO LOOP ON ERROR^
  4127					;**********
  4128
  4129					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4130					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4131					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4132					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4133					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4134					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4135					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4136
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-16
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4137			006435		SN=SN+1
  4138		002000	000000			ZZ=ZZ+ZZ
  4139						IFE	ZZ,<ZZ=1>
  4140	032471	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4141	032472	200 01 0 00 070320 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4142									;WHERE X VARIES FROM 0 THRU 35
  4143	032473	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4144	032474	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4145						STOP^
  4146	032475	254 04 0 00 032476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4147	032476	324 00 0 00 032477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4148									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4149									;IN THE SUBTEST) TO LOOP ON ERROR^
  4150	032477	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4151						STOP^
  4152	032500	254 04 0 00 032501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4153	032501	324 00 0 00 032502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4155									;IN THE SUBTEST) TO LOOP ON ERROR^
  4156					;**********
  4157
  4158					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4159					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4160					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4161					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4162					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4163					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4164					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4165
  4166			006436		SN=SN+1
  4167		004000	000000			ZZ=ZZ+ZZ
  4168						IFE	ZZ,<ZZ=1>
  4169	032502	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4170	032503	200 01 0 00 070321 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4171									;WHERE X VARIES FROM 0 THRU 35
  4172	032504	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4173	032505	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4174						STOP^
  4175	032506	254 04 0 00 032507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4176	032507	324 00 0 00 032510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4178									;IN THE SUBTEST) TO LOOP ON ERROR^
  4179	032510	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4180						STOP^
  4181	032511	254 04 0 00 032512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4182	032512	324 00 0 00 032513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4183									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4184									;IN THE SUBTEST) TO LOOP ON ERROR^
  4185					;**********
  4186
  4187					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4188					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4189					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4190					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4191					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-17
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4192					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4193					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4194
  4195			006437		SN=SN+1
  4196		010000	000000			ZZ=ZZ+ZZ
  4197						IFE	ZZ,<ZZ=1>
  4198	032513	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4199	032514	200 01 0 00 070322 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4200									;WHERE X VARIES FROM 0 THRU 35
  4201	032515	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4202	032516	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4203						STOP^
  4204	032517	254 04 0 00 032520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4205	032520	324 00 0 00 032521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4206									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4207									;IN THE SUBTEST) TO LOOP ON ERROR^
  4208	032521	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4209						STOP^
  4210	032522	254 04 0 00 032523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4211	032523	324 00 0 00 032524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4212									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4213									;IN THE SUBTEST) TO LOOP ON ERROR^
  4214					;**********
  4215
  4216					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4217					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4218					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4219					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4220					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4221					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4222					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4223
  4224			006440		SN=SN+1
  4225		020000	000000			ZZ=ZZ+ZZ
  4226						IFE	ZZ,<ZZ=1>
  4227	032524	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4228	032525	200 01 0 00 070323 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4229									;WHERE X VARIES FROM 0 THRU 35
  4230	032526	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4231	032527	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4232						STOP^
  4233	032530	254 04 0 00 032531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4234	032531	324 00 0 00 032532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4235									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4236									;IN THE SUBTEST) TO LOOP ON ERROR^
  4237	032532	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4238						STOP^
  4239	032533	254 04 0 00 032534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4240	032534	324 00 0 00 032535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4241									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4242									;IN THE SUBTEST) TO LOOP ON ERROR^
  4243					;**********
  4244
  4245					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4246					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-18
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4247					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4248					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4249					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4250					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4251					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4252
  4253			006441		SN=SN+1
  4254		040000	000000			ZZ=ZZ+ZZ
  4255						IFE	ZZ,<ZZ=1>
  4256	032535	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4257	032536	200 01 0 00 070324 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4258									;WHERE X VARIES FROM 0 THRU 35
  4259	032537	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4260	032540	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4261						STOP^
  4262	032541	254 04 0 00 032542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4263	032542	324 00 0 00 032543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4265									;IN THE SUBTEST) TO LOOP ON ERROR^
  4266	032543	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4267						STOP^
  4268	032544	254 04 0 00 032545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4269	032545	324 00 0 00 032546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4270									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4271									;IN THE SUBTEST) TO LOOP ON ERROR^
  4272					;**********
  4273
  4274					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4275					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4276					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4277					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4278					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4279					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4280					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4281
  4282			006442		SN=SN+1
  4283		100000	000000			ZZ=ZZ+ZZ
  4284						IFE	ZZ,<ZZ=1>
  4285	032546	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4286	032547	200 01 0 00 070325 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4287									;WHERE X VARIES FROM 0 THRU 35
  4288	032550	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4289	032551	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4290						STOP^
  4291	032552	254 04 0 00 032553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4292	032553	324 00 0 00 032554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4293									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4294									;IN THE SUBTEST) TO LOOP ON ERROR^
  4295	032554	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4296						STOP^
  4297	032555	254 04 0 00 032556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4298	032556	324 00 0 00 032557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4299									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4300									;IN THE SUBTEST) TO LOOP ON ERROR^
  4301					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-19
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4302
  4303					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4304					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4305					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4306					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4307					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4308					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4309					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4310
  4311			006443		SN=SN+1
  4312		200000	000000			ZZ=ZZ+ZZ
  4313						IFE	ZZ,<ZZ=1>
  4314	032557	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4315	032560	200 01 0 00 070326 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4316									;WHERE X VARIES FROM 0 THRU 35
  4317	032561	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4318	032562	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4319						STOP^
  4320	032563	254 04 0 00 032564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4321	032564	324 00 0 00 032565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4323									;IN THE SUBTEST) TO LOOP ON ERROR^
  4324	032565	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4325						STOP^
  4326	032566	254 04 0 00 032567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4327	032567	324 00 0 00 032570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4328									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4329									;IN THE SUBTEST) TO LOOP ON ERROR^
  4330					;**********
  4331
  4332					;THIS TEST VERIFIES THAT IF ONE OF THE OPERANDS OF THE AND INSTRUCTION
  4333					;IS ZERO, THE RESULT WILL BE ZERO.  THIS TEST IS REPEATED 36 TIMES WITH
  4334					;ALL ZEROS IN THE AC EXCEPT FOR ONE ONE IN BIT X
  4335					;WHERE X TAKES ON INTEGER VALUES 0 THRU 35.  E CONTAINS ALL ZEROS.
  4336					;THE RESULT SHOULD BE ALL ZEROS IN THE AC.  IF C(AC) IS NON-ZERO,
  4337					;'AND' FAILED.  C(0) IS ALSO CHECKED FOR ALL ZEROS.  IF C(0) IS
  4338					;NON-ZERO, AC0 WAS CLOBBERED BY 'AND'.
  4339
  4340			006444		SN=SN+1
  4341		400000	000000			ZZ=ZZ+ZZ
  4342						IFE	ZZ,<ZZ=1>
  4343	032570	400 00 0 00 000000 		SETZ			;PRESET E TO ALL ZEROS
  4344	032571	200 01 0 00 070256 		MOVE	1,[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN BIT X
  4345									;WHERE X VARIES FROM 0 THRU 35
  4346	032572	404 01 0 00 000000 		AND	1,0		;*AND SHOULD RESULT IN C(AC) = 0
  4347	032573	332 00 0 00 000001 		SKIPE	1		;FAIL IF C(AC) NON-ZERO
  4348						STOP^
  4349	032574	254 04 0 00 032575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4350	032575	324 00 0 00 032576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4351									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4352									;IN THE SUBTEST) TO LOOP ON ERROR^
  4353	032576	332 00 0 00 000000 		SKIPE	0		;FAIL IF C(0) IS NON-ZERO
  4354						STOP^
  4355	032577	254 04 0 00 032600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4356	032600	324 00 0 00 032601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-20
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4357									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4358									;IN THE SUBTEST) TO LOOP ON ERROR^
  4359					;**********
  4360
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4361			006500		SN=6500
  4362			000000			ZZ=0
  4363
  4364					A6500:	REPEAT	^D36,
  4365					<;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4366					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4367					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4368					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4369					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4370					SN=SN+1
  4371						ZZ=ZZ+ZZ
  4372						IFE	ZZ,<ZZ=1>
  4373						MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4374						AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4375									;POSITION WITH ITSELF SHOULD RESULT WITH
  4376									;C(AC) NONZERO
  4377						SKIPN			;PASS TEST IF C(AC) NONZERO
  4378						STOP
  4379					
  4380					;**********
  4381					>
  4382					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4383					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4384					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4385					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4386					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4387			006501		SN=SN+1
  4388			000000			ZZ=ZZ+ZZ
  4389			000001			IFE	ZZ,<ZZ=1>
  4390	032601	200 00 0 00 070265 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4391	032602	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4392									;POSITION WITH ITSELF SHOULD RESULT WITH
  4393									;C(AC) NONZERO
  4394	032603	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4395						STOP^
  4396	032604	254 04 0 00 032605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4397	032605	324 00 0 00 032606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4398									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4399									;IN THE SUBTEST) TO LOOP ON ERROR^
  4400
  4401					;**********
  4402
  4403					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4404					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4405					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4406					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4407					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4408			006502		SN=SN+1
  4409			000002			ZZ=ZZ+ZZ
  4410						IFE	ZZ,<ZZ=1>
  4411	032606	200 00 0 00 070266 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4412	032607	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4413									;POSITION WITH ITSELF SHOULD RESULT WITH
  4414									;C(AC) NONZERO
  4415	032610	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4416						STOP^
  4417	032611	254 04 0 00 032612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4418	032612	324 00 0 00 032613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4419									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4420									;IN THE SUBTEST) TO LOOP ON ERROR^
  4421
  4422					;**********
  4423
  4424					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4425					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4426					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4427					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4428					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4429			006503		SN=SN+1
  4430			000004			ZZ=ZZ+ZZ
  4431						IFE	ZZ,<ZZ=1>
  4432	032613	200 00 0 00 070267 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4433	032614	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4434									;POSITION WITH ITSELF SHOULD RESULT WITH
  4435									;C(AC) NONZERO
  4436	032615	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4437						STOP^
  4438	032616	254 04 0 00 032617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4439	032617	324 00 0 00 032620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4441									;IN THE SUBTEST) TO LOOP ON ERROR^
  4442
  4443					;**********
  4444
  4445					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4446					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4447					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4448					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4449					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4450			006504		SN=SN+1
  4451			000010			ZZ=ZZ+ZZ
  4452						IFE	ZZ,<ZZ=1>
  4453	032620	200 00 0 00 070270 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4454	032621	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4455									;POSITION WITH ITSELF SHOULD RESULT WITH
  4456									;C(AC) NONZERO
  4457	032622	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4458						STOP^
  4459	032623	254 04 0 00 032624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4460	032624	324 00 0 00 032625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4461									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4462									;IN THE SUBTEST) TO LOOP ON ERROR^
  4463
  4464					;**********
  4465
  4466					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4467					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4468					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4469					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4470					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4471			006505		SN=SN+1
  4472			000020			ZZ=ZZ+ZZ
  4473						IFE	ZZ,<ZZ=1>
  4474	032625	200 00 0 00 070271 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4475	032626	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4476									;POSITION WITH ITSELF SHOULD RESULT WITH
  4477									;C(AC) NONZERO
  4478	032627	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4479						STOP^
  4480	032630	254 04 0 00 032631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4481	032631	324 00 0 00 032632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4482									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4483									;IN THE SUBTEST) TO LOOP ON ERROR^
  4484
  4485					;**********
  4486
  4487					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4488					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4489					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4490					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4491					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4492			006506		SN=SN+1
  4493			000040			ZZ=ZZ+ZZ
  4494						IFE	ZZ,<ZZ=1>
  4495	032632	200 00 0 00 070272 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4496	032633	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4497									;POSITION WITH ITSELF SHOULD RESULT WITH
  4498									;C(AC) NONZERO
  4499	032634	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4500						STOP^
  4501	032635	254 04 0 00 032636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4502	032636	324 00 0 00 032637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4503									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4504									;IN THE SUBTEST) TO LOOP ON ERROR^
  4505
  4506					;**********
  4507
  4508					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4509					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4510					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4511					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4512					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4513			006507		SN=SN+1
  4514			000100			ZZ=ZZ+ZZ
  4515						IFE	ZZ,<ZZ=1>
  4516	032637	200 00 0 00 070273 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4517	032640	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4518									;POSITION WITH ITSELF SHOULD RESULT WITH
  4519									;C(AC) NONZERO
  4520	032641	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4521						STOP^
  4522	032642	254 04 0 00 032643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4523	032643	324 00 0 00 032644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4524									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4525									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4526
  4527					;**********
  4528
  4529					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4530					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4531					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4532					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4533					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4534			006510		SN=SN+1
  4535			000200			ZZ=ZZ+ZZ
  4536						IFE	ZZ,<ZZ=1>
  4537	032644	200 00 0 00 070274 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4538	032645	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4539									;POSITION WITH ITSELF SHOULD RESULT WITH
  4540									;C(AC) NONZERO
  4541	032646	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4542						STOP^
  4543	032647	254 04 0 00 032650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4544	032650	324 00 0 00 032651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4545									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4546									;IN THE SUBTEST) TO LOOP ON ERROR^
  4547
  4548					;**********
  4549
  4550					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4551					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4552					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4553					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4554					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4555			006511		SN=SN+1
  4556			000400			ZZ=ZZ+ZZ
  4557						IFE	ZZ,<ZZ=1>
  4558	032651	200 00 0 00 070275 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4559	032652	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4560									;POSITION WITH ITSELF SHOULD RESULT WITH
  4561									;C(AC) NONZERO
  4562	032653	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4563						STOP^
  4564	032654	254 04 0 00 032655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4565	032655	324 00 0 00 032656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4567									;IN THE SUBTEST) TO LOOP ON ERROR^
  4568
  4569					;**********
  4570
  4571					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4572					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4573					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4574					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4575					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4576			006512		SN=SN+1
  4577			001000			ZZ=ZZ+ZZ
  4578						IFE	ZZ,<ZZ=1>
  4579	032656	200 00 0 00 070276 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4580	032657	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4581									;POSITION WITH ITSELF SHOULD RESULT WITH
  4582									;C(AC) NONZERO
  4583	032660	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4584						STOP^
  4585	032661	254 04 0 00 032662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4586	032662	324 00 0 00 032663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4587									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4588									;IN THE SUBTEST) TO LOOP ON ERROR^
  4589
  4590					;**********
  4591
  4592					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4593					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4594					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4595					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4596					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4597			006513		SN=SN+1
  4598			002000			ZZ=ZZ+ZZ
  4599						IFE	ZZ,<ZZ=1>
  4600	032663	200 00 0 00 070277 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4601	032664	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4602									;POSITION WITH ITSELF SHOULD RESULT WITH
  4603									;C(AC) NONZERO
  4604	032665	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4605						STOP^
  4606	032666	254 04 0 00 032667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4607	032667	324 00 0 00 032670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4608									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4609									;IN THE SUBTEST) TO LOOP ON ERROR^
  4610
  4611					;**********
  4612
  4613					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4614					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4615					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4616					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4617					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4618			006514		SN=SN+1
  4619			004000			ZZ=ZZ+ZZ
  4620						IFE	ZZ,<ZZ=1>
  4621	032670	200 00 0 00 070300 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4622	032671	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4623									;POSITION WITH ITSELF SHOULD RESULT WITH
  4624									;C(AC) NONZERO
  4625	032672	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4626						STOP^
  4627	032673	254 04 0 00 032674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4628	032674	324 00 0 00 032675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4629									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4630									;IN THE SUBTEST) TO LOOP ON ERROR^
  4631
  4632					;**********
  4633
  4634					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4635					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4636					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4637					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4638					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4639			006515		SN=SN+1
  4640			010000			ZZ=ZZ+ZZ
  4641						IFE	ZZ,<ZZ=1>
  4642	032675	200 00 0 00 070301 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4643	032676	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4644									;POSITION WITH ITSELF SHOULD RESULT WITH
  4645									;C(AC) NONZERO
  4646	032677	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4647						STOP^
  4648	032700	254 04 0 00 032701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4649	032701	324 00 0 00 032702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4650									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4651									;IN THE SUBTEST) TO LOOP ON ERROR^
  4652
  4653					;**********
  4654
  4655					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4656					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4657					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4658					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4659					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4660			006516		SN=SN+1
  4661			020000			ZZ=ZZ+ZZ
  4662						IFE	ZZ,<ZZ=1>
  4663	032702	200 00 0 00 070302 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4664	032703	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4665									;POSITION WITH ITSELF SHOULD RESULT WITH
  4666									;C(AC) NONZERO
  4667	032704	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4668						STOP^
  4669	032705	254 04 0 00 032706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4670	032706	324 00 0 00 032707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4671									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4672									;IN THE SUBTEST) TO LOOP ON ERROR^
  4673
  4674					;**********
  4675
  4676					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4677					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4678					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4679					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4680					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4681			006517		SN=SN+1
  4682			040000			ZZ=ZZ+ZZ
  4683						IFE	ZZ,<ZZ=1>
  4684	032707	200 00 0 00 070303 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4685	032710	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4686									;POSITION WITH ITSELF SHOULD RESULT WITH
  4687									;C(AC) NONZERO
  4688	032711	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4689						STOP^
  4690	032712	254 04 0 00 032713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4691	032713	324 00 0 00 032714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4692									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4693									;IN THE SUBTEST) TO LOOP ON ERROR^
  4694
  4695					;**********
  4696
  4697					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4698					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4699					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4700					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4701					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4702			006520		SN=SN+1
  4703			100000			ZZ=ZZ+ZZ
  4704						IFE	ZZ,<ZZ=1>
  4705	032714	200 00 0 00 070304 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4706	032715	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4707									;POSITION WITH ITSELF SHOULD RESULT WITH
  4708									;C(AC) NONZERO
  4709	032716	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4710						STOP^
  4711	032717	254 04 0 00 032720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4712	032720	324 00 0 00 032721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4713									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4714									;IN THE SUBTEST) TO LOOP ON ERROR^
  4715
  4716					;**********
  4717
  4718					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4719					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4720					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4721					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4722					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4723			006521		SN=SN+1
  4724			200000			ZZ=ZZ+ZZ
  4725						IFE	ZZ,<ZZ=1>
  4726	032721	200 00 0 00 070305 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4727	032722	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4728									;POSITION WITH ITSELF SHOULD RESULT WITH
  4729									;C(AC) NONZERO
  4730	032723	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4731						STOP^
  4732	032724	254 04 0 00 032725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4733	032725	324 00 0 00 032726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4734									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4735									;IN THE SUBTEST) TO LOOP ON ERROR^
  4736
  4737					;**********
  4738
  4739					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4740					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4741					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4742					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4743					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4744			006522		SN=SN+1
  4745			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4746						IFE	ZZ,<ZZ=1>
  4747	032726	200 00 0 00 070306 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4748	032727	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4749									;POSITION WITH ITSELF SHOULD RESULT WITH
  4750									;C(AC) NONZERO
  4751	032730	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4752						STOP^
  4753	032731	254 04 0 00 032732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4754	032732	324 00 0 00 032733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4756									;IN THE SUBTEST) TO LOOP ON ERROR^
  4757
  4758					;**********
  4759
  4760					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4761					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4762					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4763					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4764					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4765			006523		SN=SN+1
  4766		000001	000000			ZZ=ZZ+ZZ
  4767						IFE	ZZ,<ZZ=1>
  4768	032733	200 00 0 00 070307 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4769	032734	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4770									;POSITION WITH ITSELF SHOULD RESULT WITH
  4771									;C(AC) NONZERO
  4772	032735	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4773						STOP^
  4774	032736	254 04 0 00 032737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4775	032737	324 00 0 00 032740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4776									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4777									;IN THE SUBTEST) TO LOOP ON ERROR^
  4778
  4779					;**********
  4780
  4781					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4782					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4783					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4784					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4785					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4786			006524		SN=SN+1
  4787		000002	000000			ZZ=ZZ+ZZ
  4788						IFE	ZZ,<ZZ=1>
  4789	032740	200 00 0 00 070310 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4790	032741	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4791									;POSITION WITH ITSELF SHOULD RESULT WITH
  4792									;C(AC) NONZERO
  4793	032742	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4794						STOP^
  4795	032743	254 04 0 00 032744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4796	032744	324 00 0 00 032745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4798									;IN THE SUBTEST) TO LOOP ON ERROR^
  4799
  4800					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4801
  4802					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4803					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4804					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4805					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4806					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4807			006525		SN=SN+1
  4808		000004	000000			ZZ=ZZ+ZZ
  4809						IFE	ZZ,<ZZ=1>
  4810	032745	200 00 0 00 070311 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4811	032746	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4812									;POSITION WITH ITSELF SHOULD RESULT WITH
  4813									;C(AC) NONZERO
  4814	032747	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4815						STOP^
  4816	032750	254 04 0 00 032751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4817	032751	324 00 0 00 032752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4818									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4819									;IN THE SUBTEST) TO LOOP ON ERROR^
  4820
  4821					;**********
  4822
  4823					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4824					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4825					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4826					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4827					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4828			006526		SN=SN+1
  4829		000010	000000			ZZ=ZZ+ZZ
  4830						IFE	ZZ,<ZZ=1>
  4831	032752	200 00 0 00 070312 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4832	032753	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4833									;POSITION WITH ITSELF SHOULD RESULT WITH
  4834									;C(AC) NONZERO
  4835	032754	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4836						STOP^
  4837	032755	254 04 0 00 032756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4838	032756	324 00 0 00 032757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4840									;IN THE SUBTEST) TO LOOP ON ERROR^
  4841
  4842					;**********
  4843
  4844					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4845					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4846					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4847					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4848					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4849			006527		SN=SN+1
  4850		000020	000000			ZZ=ZZ+ZZ
  4851						IFE	ZZ,<ZZ=1>
  4852	032757	200 00 0 00 070313 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4853	032760	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4854									;POSITION WITH ITSELF SHOULD RESULT WITH
  4855									;C(AC) NONZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4856	032761	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4857						STOP^
  4858	032762	254 04 0 00 032763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4859	032763	324 00 0 00 032764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4861									;IN THE SUBTEST) TO LOOP ON ERROR^
  4862
  4863					;**********
  4864
  4865					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4866					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4867					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4868					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4869					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4870			006530		SN=SN+1
  4871		000040	000000			ZZ=ZZ+ZZ
  4872						IFE	ZZ,<ZZ=1>
  4873	032764	200 00 0 00 070314 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4874	032765	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4875									;POSITION WITH ITSELF SHOULD RESULT WITH
  4876									;C(AC) NONZERO
  4877	032766	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4878						STOP^
  4879	032767	254 04 0 00 032770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4880	032770	324 00 0 00 032771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4882									;IN THE SUBTEST) TO LOOP ON ERROR^
  4883
  4884					;**********
  4885
  4886					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4887					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4888					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4889					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4890					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4891			006531		SN=SN+1
  4892		000100	000000			ZZ=ZZ+ZZ
  4893						IFE	ZZ,<ZZ=1>
  4894	032771	200 00 0 00 070315 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4895	032772	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4896									;POSITION WITH ITSELF SHOULD RESULT WITH
  4897									;C(AC) NONZERO
  4898	032773	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4899						STOP^
  4900	032774	254 04 0 00 032775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4901	032775	324 00 0 00 032776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4902									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4903									;IN THE SUBTEST) TO LOOP ON ERROR^
  4904
  4905					;**********
  4906
  4907					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4908					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4909					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4910					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4911					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4912			006532		SN=SN+1
  4913		000200	000000			ZZ=ZZ+ZZ
  4914						IFE	ZZ,<ZZ=1>
  4915	032776	200 00 0 00 070316 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4916	032777	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4917									;POSITION WITH ITSELF SHOULD RESULT WITH
  4918									;C(AC) NONZERO
  4919	033000	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4920						STOP^
  4921	033001	254 04 0 00 033002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4922	033002	324 00 0 00 033003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4923									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4924									;IN THE SUBTEST) TO LOOP ON ERROR^
  4925
  4926					;**********
  4927
  4928					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4929					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4930					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4931					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4932					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4933			006533		SN=SN+1
  4934		000400	000000			ZZ=ZZ+ZZ
  4935						IFE	ZZ,<ZZ=1>
  4936	033003	200 00 0 00 070264 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4937	033004	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4938									;POSITION WITH ITSELF SHOULD RESULT WITH
  4939									;C(AC) NONZERO
  4940	033005	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4941						STOP^
  4942	033006	254 04 0 00 033007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4943	033007	324 00 0 00 033010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4945									;IN THE SUBTEST) TO LOOP ON ERROR^
  4946
  4947					;**********
  4948
  4949					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4950					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4951					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4952					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4953					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4954			006534		SN=SN+1
  4955		001000	000000			ZZ=ZZ+ZZ
  4956						IFE	ZZ,<ZZ=1>
  4957	033010	200 00 0 00 070317 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4958	033011	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4959									;POSITION WITH ITSELF SHOULD RESULT WITH
  4960									;C(AC) NONZERO
  4961	033012	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4962						STOP^
  4963	033013	254 04 0 00 033014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4964	033014	324 00 0 00 033015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4965									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  4966									;IN THE SUBTEST) TO LOOP ON ERROR^
  4967
  4968					;**********
  4969
  4970					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4971					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4972					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4973					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4974					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4975			006535		SN=SN+1
  4976		002000	000000			ZZ=ZZ+ZZ
  4977						IFE	ZZ,<ZZ=1>
  4978	033015	200 00 0 00 070320 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  4979	033016	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  4980									;POSITION WITH ITSELF SHOULD RESULT WITH
  4981									;C(AC) NONZERO
  4982	033017	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  4983						STOP^
  4984	033020	254 04 0 00 033021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  4985	033021	324 00 0 00 033022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  4986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  4987									;IN THE SUBTEST) TO LOOP ON ERROR^
  4988
  4989					;**********
  4990
  4991					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  4992					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  4993					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  4994					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  4995					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  4996			006536		SN=SN+1
  4997		004000	000000			ZZ=ZZ+ZZ
  4998						IFE	ZZ,<ZZ=1>
  4999	033022	200 00 0 00 070321 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5000	033023	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5001									;POSITION WITH ITSELF SHOULD RESULT WITH
  5002									;C(AC) NONZERO
  5003	033024	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5004						STOP^
  5005	033025	254 04 0 00 033026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5006	033026	324 00 0 00 033027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5008									;IN THE SUBTEST) TO LOOP ON ERROR^
  5009
  5010					;**********
  5011
  5012					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5013					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5014					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5015					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5016					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5017			006537		SN=SN+1
  5018		010000	000000			ZZ=ZZ+ZZ
  5019						IFE	ZZ,<ZZ=1>
  5020	033027	200 00 0 00 070322 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5021	033030	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5022									;POSITION WITH ITSELF SHOULD RESULT WITH
  5023									;C(AC) NONZERO
  5024	033031	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5025						STOP^
  5026	033032	254 04 0 00 033033 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5027	033033	324 00 0 00 033034 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5028									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5029									;IN THE SUBTEST) TO LOOP ON ERROR^
  5030
  5031					;**********
  5032
  5033					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5034					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5035					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5036					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5037					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5038			006540		SN=SN+1
  5039		020000	000000			ZZ=ZZ+ZZ
  5040						IFE	ZZ,<ZZ=1>
  5041	033034	200 00 0 00 070323 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5042	033035	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5043									;POSITION WITH ITSELF SHOULD RESULT WITH
  5044									;C(AC) NONZERO
  5045	033036	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5046						STOP^
  5047	033037	254 04 0 00 033040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5048	033040	324 00 0 00 033041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5049									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5050									;IN THE SUBTEST) TO LOOP ON ERROR^
  5051
  5052					;**********
  5053
  5054					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5055					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5056					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5057					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5058					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5059			006541		SN=SN+1
  5060		040000	000000			ZZ=ZZ+ZZ
  5061						IFE	ZZ,<ZZ=1>
  5062	033041	200 00 0 00 070324 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5063	033042	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5064									;POSITION WITH ITSELF SHOULD RESULT WITH
  5065									;C(AC) NONZERO
  5066	033043	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5067						STOP^
  5068	033044	254 04 0 00 033045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5069	033045	324 00 0 00 033046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5070									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5071									;IN THE SUBTEST) TO LOOP ON ERROR^
  5072
  5073					;**********
  5074
  5075					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5076					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5077					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5078					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5079					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5080			006542		SN=SN+1
  5081		100000	000000			ZZ=ZZ+ZZ
  5082						IFE	ZZ,<ZZ=1>
  5083	033046	200 00 0 00 070325 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5084	033047	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5085									;POSITION WITH ITSELF SHOULD RESULT WITH
  5086									;C(AC) NONZERO
  5087	033050	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5088						STOP^
  5089	033051	254 04 0 00 033052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5090	033052	324 00 0 00 033053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5092									;IN THE SUBTEST) TO LOOP ON ERROR^
  5093
  5094					;**********
  5095
  5096					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5097					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5098					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5099					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5100					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5101			006543		SN=SN+1
  5102		200000	000000			ZZ=ZZ+ZZ
  5103						IFE	ZZ,<ZZ=1>
  5104	033053	200 00 0 00 070326 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5105	033054	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5106									;POSITION WITH ITSELF SHOULD RESULT WITH
  5107									;C(AC) NONZERO
  5108	033055	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5109						STOP^
  5110	033056	254 04 0 00 033057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5111	033057	324 00 0 00 033060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5112									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5113									;IN THE SUBTEST) TO LOOP ON ERROR^
  5114
  5115					;**********
  5116
  5117					;THIS TEST VERIFIES THAT THE RESULT OF A WORD ANDED WITH ITSELF
  5118					;SHOULD BE THAT SAME WORD.  A WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE
  5119					;IN ONLY ONE BIT IS ANDED WITH ITSELF.  THE AC IS THEN CHECKED FOR ITS
  5120					;CONTENTS NONZERO.  IF C(AC)=0, THE 'AND' INSTRUCTION FAILED.  THIS TEST IS REPEATED
  5121					;36 TIMES TO CHECK EACH BIT INDIVIDUALLY.
  5122			006544		SN=SN+1
  5123		400000	000000			ZZ=ZZ+ZZ
  5124						IFE	ZZ,<ZZ=1>
  5125	033060	200 00 0 00 070256 		MOVE	[ZZ]		;LOAD AC WITH ALL ZEROS EXCEPT FOR A ONE IN ONE BIT
  5126	033061	404 00 0 00 000000 		AND			;*AND OF WORD CONTAINING A ONE IN ONE BIT
  5127									;POSITION WITH ITSELF SHOULD RESULT WITH
  5128									;C(AC) NONZERO
  5129	033062	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NONZERO
  5130						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-14
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5131	033063	254 04 0 00 033064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5132	033064	324 00 0 00 033065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5133									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5134									;IN THE SUBTEST) TO LOOP ON ERROR^
  5135
  5136					;**********
  5137
  5138					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE
  5139					;C(AC)=0 AND C(E)=0 AND E OUTSIDE OF THE AC RANGE IS ALL ZEROS IN THE AC.
  5140					;FIRST, THE AC IS CLEARED; THEN, THE C(AC) IS ANDED WITH C(E) WHEN
  5141					;E GREATER THAN 20 AND C(E)=0. THE RESULT SHOULD BE C(AC)=0.
  5142					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5143
  5144	033065	200 00 0 00 070253 	A6600:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  5145	033066	404 00 0 00 070253 		AND	[0]		;*AND OF TWO WORDS OF ALL ZEROS
  5146									;SHOULD RESULT IN C(AC)=0
  5147	033067	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5148						STOP^
  5149	033070	254 04 0 00 033071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5150	033071	324 00 0 00 033072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5151									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5152									;IN THE SUBTEST) TO LOOP ON ERROR^
  5153
  5154					;**********
  5155
  5156					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(AC)=0
  5157					;AND C(E) IS ALL ONES IS AN AC CONTAINING ALL ZEROS.  FIRST, THE AC IS
  5158					;CLEARED; THEN THE C(AC) IS ANDED WITH AN E CONTAINING ALL ONES, WHERE
  5159					;E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
  5160					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5161
  5162	033072	200 00 0 00 070253 	A6700:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  5163	033073	404 00 0 00 070254 		AND	[-1]		;*AND OF TWO WORDS WHERE C(AC)=0 SHOULD RESULT IN C(AC)=0
  5164	033074	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5165						STOP^
  5166	033075	254 04 0 00 033076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5167	033076	324 00 0 00 033077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5168									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5169									;IN THE SUBTEST) TO LOOP ON ERROR^
  5170
  5171					;AD FM+EN [ADFP],AD FM+EN A [ADFP],
  5172					;F CYC ACT EN C [F1],IR BOOLE AD FM+F [IR2],
  5173					;IR BOOLE [IR1],IRXX(1,4,5,11,13,16) [IR2]
  5174
  5175					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5176					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E)=0
  5177					;AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ZEROS. FIRST, THE
  5178					;AC IS SET TO ALL ONES; THEN, THE AC IS ANDED WITH AN E CONTAINING ALL
  5179					;ZEROS, WHERE E IS BEYOND THE AC RANGE.  THE RESULT SHOULD BE C(AC)=0.
  5180					;IF C(AC) IS NON-ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5181
  5182	033077	200 00 0 00 070254 	A7000:	MOVE	[-1]		;PRESET AC TO ALL ONES
  5183	033100	404 00 0 00 070253 		AND	[0]		;*AND OF TWO WORDS WHERE C(E)=0 SHOULD RESULT IN C(AC)=0
  5184	033101	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  5185						STOP^
  5186	033102	254 04 0 00 033103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5187	033103	324 00 0 00 033104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5188									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5189									;IN THE SUBTEST) TO LOOP ON ERROR^
  5190
  5191					;**********
  5192
  5193					;THIS TEST VERIFIES THAT THE RESULT OF THE AND INSTRUCTION WHERE C(E) IS
  5194					;ALL ONES AND C(AC) IS ALL ONES IS AN AC CONTAINING ALL ONES.  FIRST, THE
  5195					;AC IS SET TO ALL ONES; THEN, C(AC) IS ANDED WITH AN E CONTAINING ALL
  5196					;ONES.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5197					;IF C(AC) IS ZERO, 'AND' FAILED WITH THE MEMORY OPERAND.
  5198
  5199	033104	200 00 0 00 070254 	A7100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
  5200	033105	404 00 0 00 070254 		AND	[-1]		;*AND OF TWO WORDS OF ALL ONES SHOULD
  5201									;RESULT IN C(AC)=ALL ONES
  5202	033106	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON ZERO
  5203						STOP^
  5204	033107	254 04 0 00 033110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5205	033110	324 00 0 00 033111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5206									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5207									;IN THE SUBTEST) TO LOOP ON ERROR^
  5208
  5209					;**********
  5210
  5211					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE 
  5212					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHERE CONTENTS IS NON-ZERO.
  5213					;FIRST, THE AC IS CLEARED, THEN, XOR IS EXECUTED WHERE C(E) IS NON-ZERO.
  5214					;THE AC IS THEN CHECKED FOR NON-ZERO CONTENTS.
  5215	033111	200 00 0 00 070253 	A7200:	MOVE	[0]		;CLEAR AC
  5216	033112	430 00 0 00 070332 		XOR	[707070707070]	;*XOR WITH C(AC)=0 AND C(E)=7070707070 SHOULD
  5217									;RESTULT IN C(AC)=707070707070
  5218	033113	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5219						STOP^
  5220	033114	254 04 0 00 033115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5221	033115	324 00 0 00 033116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5223									;IN THE SUBTEST) TO LOOP ON ERROR^
  5224
  5225					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5226			007300		SN=7300
  5227			000000			ZZ=0
  5228
  5229					A7300:	REPEAT	^D36,
  5230					<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5231					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5232					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5233					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5234					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5235					SN=SN+1
  5236						ZZ=ZZ+ZZ
  5237						IFE	ZZ,<ZZ=1>
  5238						MOVE	[0]		;CLEAR AC
  5239						XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5240									;RESULT IN C(AC) NONZERO
  5241						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5242						STOP
  5243					
  5244					;**********
  5245					>
  5246					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5247					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5248					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5249					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5250					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5251			007301		SN=SN+1
  5252			000000			ZZ=ZZ+ZZ
  5253			000001			IFE	ZZ,<ZZ=1>
  5254	033116	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5255	033117	430 00 0 00 070265 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5256									;RESULT IN C(AC) NONZERO
  5257	033120	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5258						STOP^
  5259	033121	254 04 0 00 033122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5260	033122	324 00 0 00 033123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5262									;IN THE SUBTEST) TO LOOP ON ERROR^
  5263
  5264					;**********
  5265
  5266					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5267					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5268					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5269					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5270					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5271			007302		SN=SN+1
  5272			000002			ZZ=ZZ+ZZ
  5273						IFE	ZZ,<ZZ=1>
  5274	033123	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5275	033124	430 00 0 00 070266 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5276									;RESULT IN C(AC) NONZERO
  5277	033125	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5278						STOP^
  5279	033126	254 04 0 00 033127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5280	033127	324 00 0 00 033130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5281									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5282									;IN THE SUBTEST) TO LOOP ON ERROR^
  5283
  5284					;**********
  5285
  5286					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5287					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5288					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5289					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5290					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5291			007303		SN=SN+1
  5292			000004			ZZ=ZZ+ZZ
  5293						IFE	ZZ,<ZZ=1>
  5294	033130	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5295	033131	430 00 0 00 070267 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5296									;RESULT IN C(AC) NONZERO
  5297	033132	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5298						STOP^
  5299	033133	254 04 0 00 033134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5300	033134	324 00 0 00 033135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5301									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5302									;IN THE SUBTEST) TO LOOP ON ERROR^
  5303
  5304					;**********
  5305
  5306					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5307					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5308					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5309					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5310					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5311			007304		SN=SN+1
  5312			000010			ZZ=ZZ+ZZ
  5313						IFE	ZZ,<ZZ=1>
  5314	033135	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5315	033136	430 00 0 00 070270 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5316									;RESULT IN C(AC) NONZERO
  5317	033137	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5318						STOP^
  5319	033140	254 04 0 00 033141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5320	033141	324 00 0 00 033142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5321									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5322									;IN THE SUBTEST) TO LOOP ON ERROR^
  5323
  5324					;**********
  5325
  5326					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5327					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5328					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5329					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5330					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5331			007305		SN=SN+1
  5332			000020			ZZ=ZZ+ZZ
  5333						IFE	ZZ,<ZZ=1>
  5334	033142	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5335	033143	430 00 0 00 070271 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5336									;RESULT IN C(AC) NONZERO
  5337	033144	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5338						STOP^
  5339	033145	254 04 0 00 033146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5340	033146	324 00 0 00 033147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5341									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5342									;IN THE SUBTEST) TO LOOP ON ERROR^
  5343
  5344					;**********
  5345
  5346					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5347					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5348					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5349					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5350					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5351			007306		SN=SN+1
  5352			000040			ZZ=ZZ+ZZ
  5353						IFE	ZZ,<ZZ=1>
  5354	033147	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5355	033150	430 00 0 00 070272 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5356									;RESULT IN C(AC) NONZERO
  5357	033151	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5358						STOP^
  5359	033152	254 04 0 00 033153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5360	033153	324 00 0 00 033154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5362									;IN THE SUBTEST) TO LOOP ON ERROR^
  5363
  5364					;**********
  5365
  5366					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5367					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5368					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5369					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5370					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5371			007307		SN=SN+1
  5372			000100			ZZ=ZZ+ZZ
  5373						IFE	ZZ,<ZZ=1>
  5374	033154	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5375	033155	430 00 0 00 070273 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5376									;RESULT IN C(AC) NONZERO
  5377	033156	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5378						STOP^
  5379	033157	254 04 0 00 033160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5380	033160	324 00 0 00 033161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5381									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5382									;IN THE SUBTEST) TO LOOP ON ERROR^
  5383
  5384					;**********
  5385
  5386					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5387					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5388					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5389					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5390					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5391			007310		SN=SN+1
  5392			000200			ZZ=ZZ+ZZ
  5393						IFE	ZZ,<ZZ=1>
  5394	033161	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5395	033162	430 00 0 00 070274 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5396									;RESULT IN C(AC) NONZERO
  5397	033163	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5398						STOP^
  5399	033164	254 04 0 00 033165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5400	033165	324 00 0 00 033166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5401									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5402									;IN THE SUBTEST) TO LOOP ON ERROR^
  5403
  5404					;**********
  5405
  5406					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5407					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5408					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5409					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5410					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5411			007311		SN=SN+1
  5412			000400			ZZ=ZZ+ZZ
  5413						IFE	ZZ,<ZZ=1>
  5414	033166	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5415	033167	430 00 0 00 070275 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5416									;RESULT IN C(AC) NONZERO
  5417	033170	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5418						STOP^
  5419	033171	254 04 0 00 033172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5420	033172	324 00 0 00 033173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5422									;IN THE SUBTEST) TO LOOP ON ERROR^
  5423
  5424					;**********
  5425
  5426					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5427					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5428					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5429					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5430					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5431			007312		SN=SN+1
  5432			001000			ZZ=ZZ+ZZ
  5433						IFE	ZZ,<ZZ=1>
  5434	033173	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5435	033174	430 00 0 00 070276 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5436									;RESULT IN C(AC) NONZERO
  5437	033175	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5438						STOP^
  5439	033176	254 04 0 00 033177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5440	033177	324 00 0 00 033200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5441									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5442									;IN THE SUBTEST) TO LOOP ON ERROR^
  5443
  5444					;**********
  5445
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5446					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5447					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5448					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5449					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5450					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5451			007313		SN=SN+1
  5452			002000			ZZ=ZZ+ZZ
  5453						IFE	ZZ,<ZZ=1>
  5454	033200	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5455	033201	430 00 0 00 070277 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5456									;RESULT IN C(AC) NONZERO
  5457	033202	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5458						STOP^
  5459	033203	254 04 0 00 033204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5460	033204	324 00 0 00 033205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5461									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5462									;IN THE SUBTEST) TO LOOP ON ERROR^
  5463
  5464					;**********
  5465
  5466					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5467					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5468					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5469					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5470					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5471			007314		SN=SN+1
  5472			004000			ZZ=ZZ+ZZ
  5473						IFE	ZZ,<ZZ=1>
  5474	033205	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5475	033206	430 00 0 00 070300 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5476									;RESULT IN C(AC) NONZERO
  5477	033207	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5478						STOP^
  5479	033210	254 04 0 00 033211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5480	033211	324 00 0 00 033212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5481									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5482									;IN THE SUBTEST) TO LOOP ON ERROR^
  5483
  5484					;**********
  5485
  5486					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5487					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5488					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5489					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5490					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5491			007315		SN=SN+1
  5492			010000			ZZ=ZZ+ZZ
  5493						IFE	ZZ,<ZZ=1>
  5494	033212	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5495	033213	430 00 0 00 070301 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5496									;RESULT IN C(AC) NONZERO
  5497	033214	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5498						STOP^
  5499	033215	254 04 0 00 033216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5500	033216	324 00 0 00 033217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5501									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5502									;IN THE SUBTEST) TO LOOP ON ERROR^
  5503
  5504					;**********
  5505
  5506					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5507					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5508					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5509					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5510					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5511			007316		SN=SN+1
  5512			020000			ZZ=ZZ+ZZ
  5513						IFE	ZZ,<ZZ=1>
  5514	033217	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5515	033220	430 00 0 00 070302 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5516									;RESULT IN C(AC) NONZERO
  5517	033221	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5518						STOP^
  5519	033222	254 04 0 00 033223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5520	033223	324 00 0 00 033224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5521									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5522									;IN THE SUBTEST) TO LOOP ON ERROR^
  5523
  5524					;**********
  5525
  5526					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5527					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5528					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5529					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5530					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5531			007317		SN=SN+1
  5532			040000			ZZ=ZZ+ZZ
  5533						IFE	ZZ,<ZZ=1>
  5534	033224	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5535	033225	430 00 0 00 070303 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5536									;RESULT IN C(AC) NONZERO
  5537	033226	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5538						STOP^
  5539	033227	254 04 0 00 033230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5540	033230	324 00 0 00 033231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5541									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5542									;IN THE SUBTEST) TO LOOP ON ERROR^
  5543
  5544					;**********
  5545
  5546					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5547					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5548					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5549					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5550					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5551			007320		SN=SN+1
  5552			100000			ZZ=ZZ+ZZ
  5553						IFE	ZZ,<ZZ=1>
  5554	033231	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5555	033232	430 00 0 00 070304 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5556									;RESULT IN C(AC) NONZERO
  5557	033233	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5558						STOP^
  5559	033234	254 04 0 00 033235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5560	033235	324 00 0 00 033236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5561									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5562									;IN THE SUBTEST) TO LOOP ON ERROR^
  5563
  5564					;**********
  5565
  5566					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5567					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5568					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5569					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5570					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5571			007321		SN=SN+1
  5572			200000			ZZ=ZZ+ZZ
  5573						IFE	ZZ,<ZZ=1>
  5574	033236	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5575	033237	430 00 0 00 070305 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5576									;RESULT IN C(AC) NONZERO
  5577	033240	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5578						STOP^
  5579	033241	254 04 0 00 033242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5580	033242	324 00 0 00 033243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5581									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5582									;IN THE SUBTEST) TO LOOP ON ERROR^
  5583
  5584					;**********
  5585
  5586					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5587					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5588					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5589					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5590					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5591			007322		SN=SN+1
  5592			400000			ZZ=ZZ+ZZ
  5593						IFE	ZZ,<ZZ=1>
  5594	033243	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5595	033244	430 00 0 00 070306 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5596									;RESULT IN C(AC) NONZERO
  5597	033245	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5598						STOP^
  5599	033246	254 04 0 00 033247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5600	033247	324 00 0 00 033250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5601									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5602									;IN THE SUBTEST) TO LOOP ON ERROR^
  5603
  5604					;**********
  5605
  5606					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5607					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5608					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5609					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5610					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5611			007323		SN=SN+1
  5612		000001	000000			ZZ=ZZ+ZZ
  5613						IFE	ZZ,<ZZ=1>
  5614	033250	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5615	033251	430 00 0 00 070307 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5616									;RESULT IN C(AC) NONZERO
  5617	033252	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5618						STOP^
  5619	033253	254 04 0 00 033254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5620	033254	324 00 0 00 033255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5621									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5622									;IN THE SUBTEST) TO LOOP ON ERROR^
  5623
  5624					;**********
  5625
  5626					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5627					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5628					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5629					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5630					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5631			007324		SN=SN+1
  5632		000002	000000			ZZ=ZZ+ZZ
  5633						IFE	ZZ,<ZZ=1>
  5634	033255	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5635	033256	430 00 0 00 070310 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5636									;RESULT IN C(AC) NONZERO
  5637	033257	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5638						STOP^
  5639	033260	254 04 0 00 033261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5640	033261	324 00 0 00 033262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5642									;IN THE SUBTEST) TO LOOP ON ERROR^
  5643
  5644					;**********
  5645
  5646					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5647					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5648					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5649					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5650					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5651			007325		SN=SN+1
  5652		000004	000000			ZZ=ZZ+ZZ
  5653						IFE	ZZ,<ZZ=1>
  5654	033262	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5655	033263	430 00 0 00 070311 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5656									;RESULT IN C(AC) NONZERO
  5657	033264	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5658						STOP^
  5659	033265	254 04 0 00 033266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5660	033266	324 00 0 00 033267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5661									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5662									;IN THE SUBTEST) TO LOOP ON ERROR^
  5663
  5664					;**********
  5665
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5666					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5667					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5668					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5669					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5670					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5671			007326		SN=SN+1
  5672		000010	000000			ZZ=ZZ+ZZ
  5673						IFE	ZZ,<ZZ=1>
  5674	033267	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5675	033270	430 00 0 00 070312 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5676									;RESULT IN C(AC) NONZERO
  5677	033271	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5678						STOP^
  5679	033272	254 04 0 00 033273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5680	033273	324 00 0 00 033274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5681									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5682									;IN THE SUBTEST) TO LOOP ON ERROR^
  5683
  5684					;**********
  5685
  5686					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5687					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5688					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5689					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5690					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5691			007327		SN=SN+1
  5692		000020	000000			ZZ=ZZ+ZZ
  5693						IFE	ZZ,<ZZ=1>
  5694	033274	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5695	033275	430 00 0 00 070313 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5696									;RESULT IN C(AC) NONZERO
  5697	033276	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5698						STOP^
  5699	033277	254 04 0 00 033300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5700	033300	324 00 0 00 033301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5701									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5702									;IN THE SUBTEST) TO LOOP ON ERROR^
  5703
  5704					;**********
  5705
  5706					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5707					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5708					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5709					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5710					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5711			007330		SN=SN+1
  5712		000040	000000			ZZ=ZZ+ZZ
  5713						IFE	ZZ,<ZZ=1>
  5714	033301	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5715	033302	430 00 0 00 070314 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5716									;RESULT IN C(AC) NONZERO
  5717	033303	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5718						STOP^
  5719	033304	254 04 0 00 033305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5720	033305	324 00 0 00 033306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5721									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5722									;IN THE SUBTEST) TO LOOP ON ERROR^
  5723
  5724					;**********
  5725
  5726					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5727					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5728					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5729					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5730					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5731			007331		SN=SN+1
  5732		000100	000000			ZZ=ZZ+ZZ
  5733						IFE	ZZ,<ZZ=1>
  5734	033306	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5735	033307	430 00 0 00 070315 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5736									;RESULT IN C(AC) NONZERO
  5737	033310	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5738						STOP^
  5739	033311	254 04 0 00 033312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5740	033312	324 00 0 00 033313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5741									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5742									;IN THE SUBTEST) TO LOOP ON ERROR^
  5743
  5744					;**********
  5745
  5746					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5747					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5748					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5749					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5750					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5751			007332		SN=SN+1
  5752		000200	000000			ZZ=ZZ+ZZ
  5753						IFE	ZZ,<ZZ=1>
  5754	033313	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5755	033314	430 00 0 00 070316 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5756									;RESULT IN C(AC) NONZERO
  5757	033315	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5758						STOP^
  5759	033316	254 04 0 00 033317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5760	033317	324 00 0 00 033320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5762									;IN THE SUBTEST) TO LOOP ON ERROR^
  5763
  5764					;**********
  5765
  5766					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5767					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5768					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5769					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5770					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5771			007333		SN=SN+1
  5772		000400	000000			ZZ=ZZ+ZZ
  5773						IFE	ZZ,<ZZ=1>
  5774	033320	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5775	033321	430 00 0 00 070264 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5776									;RESULT IN C(AC) NONZERO
  5777	033322	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5778						STOP^
  5779	033323	254 04 0 00 033324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5780	033324	324 00 0 00 033325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5781									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5782									;IN THE SUBTEST) TO LOOP ON ERROR^
  5783
  5784					;**********
  5785
  5786					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5787					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5788					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5789					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5790					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5791			007334		SN=SN+1
  5792		001000	000000			ZZ=ZZ+ZZ
  5793						IFE	ZZ,<ZZ=1>
  5794	033325	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5795	033326	430 00 0 00 070317 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5796									;RESULT IN C(AC) NONZERO
  5797	033327	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5798						STOP^
  5799	033330	254 04 0 00 033331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5800	033331	324 00 0 00 033332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5801									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5802									;IN THE SUBTEST) TO LOOP ON ERROR^
  5803
  5804					;**********
  5805
  5806					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5807					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5808					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5809					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5810					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5811			007335		SN=SN+1
  5812		002000	000000			ZZ=ZZ+ZZ
  5813						IFE	ZZ,<ZZ=1>
  5814	033332	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5815	033333	430 00 0 00 070320 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5816									;RESULT IN C(AC) NONZERO
  5817	033334	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5818						STOP^
  5819	033335	254 04 0 00 033336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5820	033336	324 00 0 00 033337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5821									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5822									;IN THE SUBTEST) TO LOOP ON ERROR^
  5823
  5824					;**********
  5825
  5826					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5827					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5828					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5829					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5830					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5831			007336		SN=SN+1
  5832		004000	000000			ZZ=ZZ+ZZ
  5833						IFE	ZZ,<ZZ=1>
  5834	033337	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5835	033340	430 00 0 00 070321 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5836									;RESULT IN C(AC) NONZERO
  5837	033341	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5838						STOP^
  5839	033342	254 04 0 00 033343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5840	033343	324 00 0 00 033344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5841									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5842									;IN THE SUBTEST) TO LOOP ON ERROR^
  5843
  5844					;**********
  5845
  5846					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5847					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5848					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5849					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5850					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5851			007337		SN=SN+1
  5852		010000	000000			ZZ=ZZ+ZZ
  5853						IFE	ZZ,<ZZ=1>
  5854	033344	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5855	033345	430 00 0 00 070322 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5856									;RESULT IN C(AC) NONZERO
  5857	033346	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5858						STOP^
  5859	033347	254 04 0 00 033350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5860	033350	324 00 0 00 033351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5861									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5862									;IN THE SUBTEST) TO LOOP ON ERROR^
  5863
  5864					;**********
  5865
  5866					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5867					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5868					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5869					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5870					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5871			007340		SN=SN+1
  5872		020000	000000			ZZ=ZZ+ZZ
  5873						IFE	ZZ,<ZZ=1>
  5874	033351	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5875	033352	430 00 0 00 070323 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5876									;RESULT IN C(AC) NONZERO
  5877	033353	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5878						STOP^
  5879	033354	254 04 0 00 033355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5880	033355	324 00 0 00 033356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5882									;IN THE SUBTEST) TO LOOP ON ERROR^
  5883
  5884					;**********
  5885
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5886					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5887					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5888					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5889					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5890					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5891			007341		SN=SN+1
  5892		040000	000000			ZZ=ZZ+ZZ
  5893						IFE	ZZ,<ZZ=1>
  5894	033356	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5895	033357	430 00 0 00 070324 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5896									;RESULT IN C(AC) NONZERO
  5897	033360	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5898						STOP^
  5899	033361	254 04 0 00 033362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5900	033362	324 00 0 00 033363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5901									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5902									;IN THE SUBTEST) TO LOOP ON ERROR^
  5903
  5904					;**********
  5905
  5906					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5907					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5908					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5909					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5910					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5911			007342		SN=SN+1
  5912		100000	000000			ZZ=ZZ+ZZ
  5913						IFE	ZZ,<ZZ=1>
  5914	033363	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5915	033364	430 00 0 00 070325 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5916									;RESULT IN C(AC) NONZERO
  5917	033365	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5918						STOP^
  5919	033366	254 04 0 00 033367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5920	033367	324 00 0 00 033370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5922									;IN THE SUBTEST) TO LOOP ON ERROR^
  5923
  5924					;**********
  5925
  5926					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5927					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5928					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5929					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5930					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5931			007343		SN=SN+1
  5932		200000	000000			ZZ=ZZ+ZZ
  5933						IFE	ZZ,<ZZ=1>
  5934	033370	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5935	033371	430 00 0 00 070326 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5936									;RESULT IN C(AC) NONZERO
  5937	033372	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5938						STOP^
  5939	033373	254 04 0 00 033374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5940	033374	324 00 0 00 033375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5941									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5942									;IN THE SUBTEST) TO LOOP ON ERROR^
  5943
  5944					;**********
  5945
  5946					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5947					;C(AC)=0 AND C(E) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO. THIS
  5948					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS CLEARED AND XOR IS EXECUTED
  5949					;WITH ALL BITS OF E CLEAR EXCEPT FOR ONE FLOATING BIT WHICH IS SET TO A ONE.
  5950					;THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5951			007344		SN=SN+1
  5952		400000	000000			ZZ=ZZ+ZZ
  5953						IFE	ZZ,<ZZ=1>
  5954	033375	200 00 0 00 070253 		MOVE	[0]		;CLEAR AC
  5955	033376	430 00 0 00 070256 		XOR	[ZZ]		;*XOR WITH C(AC)=0 AND ONE BIT OF C(E) SET SHOULD
  5956									;RESULT IN C(AC) NONZERO
  5957	033377	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5958						STOP^
  5959	033400	254 04 0 00 033401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  5960	033401	324 00 0 00 033402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  5961									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  5962									;IN THE SUBTEST) TO LOOP ON ERROR^
  5963
  5964					;**********
  5965
  5966			007400		SN=7400
  5967			000000			ZZ=0
  5968
  5969					A7400:	REPEAT	^D36,
  5970					<;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5971					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  5972					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  5973					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  5974					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  5975					SN=SN+1
  5976						ZZ=ZZ+ZZ
  5977						IFE	ZZ,<ZZ=1>
  5978						MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  5979						XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  5980									;RESULT IN C(AC) NON-ZERO
  5981						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  5982						STOP
  5983					
  5984					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  5985					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  5986					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  5987					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  5988					
  5989					;**********
  5990					>
  5991					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  5992					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  5993					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  5994					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  5995					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-14
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  5996			007401		SN=SN+1
  5997			000000			ZZ=ZZ+ZZ
  5998			000001			IFE	ZZ,<ZZ=1>
  5999	033402	200 00 0 00 070265 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6000	033403	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6001									;RESULT IN C(AC) NON-ZERO
  6002	033404	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6003						STOP^
  6004	033405	254 04 0 00 033406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6005	033406	324 00 0 00 033407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6007									;IN THE SUBTEST) TO LOOP ON ERROR^
  6008
  6009					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6010					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6011					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6012					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6013
  6014					;**********
  6015
  6016					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6017					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6018					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6019					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6020					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6021			007402		SN=SN+1
  6022			000002			ZZ=ZZ+ZZ
  6023						IFE	ZZ,<ZZ=1>
  6024	033407	200 00 0 00 070266 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6025	033410	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6026									;RESULT IN C(AC) NON-ZERO
  6027	033411	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6028						STOP^
  6029	033412	254 04 0 00 033413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6030	033413	324 00 0 00 033414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6031									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6032									;IN THE SUBTEST) TO LOOP ON ERROR^
  6033
  6034					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6035					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6036					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6037					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6038
  6039					;**********
  6040
  6041					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6042					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6043					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6044					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6045					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6046			007403		SN=SN+1
  6047			000004			ZZ=ZZ+ZZ
  6048						IFE	ZZ,<ZZ=1>
  6049	033414	200 00 0 00 070267 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6050	033415	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-15
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6051									;RESULT IN C(AC) NON-ZERO
  6052	033416	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6053						STOP^
  6054	033417	254 04 0 00 033420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6055	033420	324 00 0 00 033421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6056									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6057									;IN THE SUBTEST) TO LOOP ON ERROR^
  6058
  6059					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6060					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6061					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6062					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6063
  6064					;**********
  6065
  6066					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6067					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6068					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6069					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6070					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6071			007404		SN=SN+1
  6072			000010			ZZ=ZZ+ZZ
  6073						IFE	ZZ,<ZZ=1>
  6074	033421	200 00 0 00 070270 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6075	033422	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6076									;RESULT IN C(AC) NON-ZERO
  6077	033423	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6078						STOP^
  6079	033424	254 04 0 00 033425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6080	033425	324 00 0 00 033426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6081									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6082									;IN THE SUBTEST) TO LOOP ON ERROR^
  6083
  6084					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6085					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6086					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6087					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6088
  6089					;**********
  6090
  6091					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6092					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6093					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6094					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6095					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6096			007405		SN=SN+1
  6097			000020			ZZ=ZZ+ZZ
  6098						IFE	ZZ,<ZZ=1>
  6099	033426	200 00 0 00 070271 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6100	033427	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6101									;RESULT IN C(AC) NON-ZERO
  6102	033430	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6103						STOP^
  6104	033431	254 04 0 00 033432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6105	033432	324 00 0 00 033433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-16
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6107									;IN THE SUBTEST) TO LOOP ON ERROR^
  6108
  6109					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6110					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6111					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6112					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6113
  6114					;**********
  6115
  6116					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6117					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6118					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6119					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6120					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6121			007406		SN=SN+1
  6122			000040			ZZ=ZZ+ZZ
  6123						IFE	ZZ,<ZZ=1>
  6124	033433	200 00 0 00 070272 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6125	033434	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6126									;RESULT IN C(AC) NON-ZERO
  6127	033435	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6128						STOP^
  6129	033436	254 04 0 00 033437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6130	033437	324 00 0 00 033440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6131									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6132									;IN THE SUBTEST) TO LOOP ON ERROR^
  6133
  6134					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6135					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6136					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6137					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6138
  6139					;**********
  6140
  6141					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6142					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6143					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6144					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6145					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6146			007407		SN=SN+1
  6147			000100			ZZ=ZZ+ZZ
  6148						IFE	ZZ,<ZZ=1>
  6149	033440	200 00 0 00 070273 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6150	033441	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6151									;RESULT IN C(AC) NON-ZERO
  6152	033442	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6153						STOP^
  6154	033443	254 04 0 00 033444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6155	033444	324 00 0 00 033445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6157									;IN THE SUBTEST) TO LOOP ON ERROR^
  6158
  6159					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6160					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-17
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6161					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6162					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6163
  6164					;**********
  6165
  6166					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6167					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6168					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6169					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6170					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6171			007410		SN=SN+1
  6172			000200			ZZ=ZZ+ZZ
  6173						IFE	ZZ,<ZZ=1>
  6174	033445	200 00 0 00 070274 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6175	033446	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6176									;RESULT IN C(AC) NON-ZERO
  6177	033447	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6178						STOP^
  6179	033450	254 04 0 00 033451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6180	033451	324 00 0 00 033452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6181									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6182									;IN THE SUBTEST) TO LOOP ON ERROR^
  6183
  6184					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6185					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6186					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6187					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6188
  6189					;**********
  6190
  6191					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6192					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6193					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6194					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6195					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6196			007411		SN=SN+1
  6197			000400			ZZ=ZZ+ZZ
  6198						IFE	ZZ,<ZZ=1>
  6199	033452	200 00 0 00 070275 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6200	033453	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6201									;RESULT IN C(AC) NON-ZERO
  6202	033454	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6203						STOP^
  6204	033455	254 04 0 00 033456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6205	033456	324 00 0 00 033457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6206									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6207									;IN THE SUBTEST) TO LOOP ON ERROR^
  6208
  6209					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6210					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6211					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6212					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6213
  6214					;**********
  6215
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-18
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6216					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6217					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6218					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6219					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6220					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6221			007412		SN=SN+1
  6222			001000			ZZ=ZZ+ZZ
  6223						IFE	ZZ,<ZZ=1>
  6224	033457	200 00 0 00 070276 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6225	033460	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6226									;RESULT IN C(AC) NON-ZERO
  6227	033461	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6228						STOP^
  6229	033462	254 04 0 00 033463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6230	033463	324 00 0 00 033464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6232									;IN THE SUBTEST) TO LOOP ON ERROR^
  6233
  6234					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6235					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6236					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6237					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6238
  6239					;**********
  6240
  6241					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6242					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6243					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6244					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6245					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6246			007413		SN=SN+1
  6247			002000			ZZ=ZZ+ZZ
  6248						IFE	ZZ,<ZZ=1>
  6249	033464	200 00 0 00 070277 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6250	033465	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6251									;RESULT IN C(AC) NON-ZERO
  6252	033466	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6253						STOP^
  6254	033467	254 04 0 00 033470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6255	033470	324 00 0 00 033471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6256									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6257									;IN THE SUBTEST) TO LOOP ON ERROR^
  6258
  6259					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6260					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6261					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6262					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6263
  6264					;**********
  6265
  6266					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6267					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6268					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6269					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6270					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-19
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6271			007414		SN=SN+1
  6272			004000			ZZ=ZZ+ZZ
  6273						IFE	ZZ,<ZZ=1>
  6274	033471	200 00 0 00 070300 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6275	033472	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6276									;RESULT IN C(AC) NON-ZERO
  6277	033473	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6278						STOP^
  6279	033474	254 04 0 00 033475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6280	033475	324 00 0 00 033476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6281									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6282									;IN THE SUBTEST) TO LOOP ON ERROR^
  6283
  6284					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6285					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6286					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6287					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6288
  6289					;**********
  6290
  6291					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6292					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6293					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6294					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6295					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6296			007415		SN=SN+1
  6297			010000			ZZ=ZZ+ZZ
  6298						IFE	ZZ,<ZZ=1>
  6299	033476	200 00 0 00 070301 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6300	033477	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6301									;RESULT IN C(AC) NON-ZERO
  6302	033500	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6303						STOP^
  6304	033501	254 04 0 00 033502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6305	033502	324 00 0 00 033503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6306									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6307									;IN THE SUBTEST) TO LOOP ON ERROR^
  6308
  6309					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6310					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6311					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6312					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6313
  6314					;**********
  6315
  6316					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6317					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6318					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6319					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6320					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6321			007416		SN=SN+1
  6322			020000			ZZ=ZZ+ZZ
  6323						IFE	ZZ,<ZZ=1>
  6324	033503	200 00 0 00 070302 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6325	033504	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-20
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6326									;RESULT IN C(AC) NON-ZERO
  6327	033505	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6328						STOP^
  6329	033506	254 04 0 00 033507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6330	033507	324 00 0 00 033510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6332									;IN THE SUBTEST) TO LOOP ON ERROR^
  6333
  6334					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6335					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6336					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6337					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6338
  6339					;**********
  6340
  6341					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6342					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6343					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6344					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6345					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6346			007417		SN=SN+1
  6347			040000			ZZ=ZZ+ZZ
  6348						IFE	ZZ,<ZZ=1>
  6349	033510	200 00 0 00 070303 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6350	033511	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6351									;RESULT IN C(AC) NON-ZERO
  6352	033512	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6353						STOP^
  6354	033513	254 04 0 00 033514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6355	033514	324 00 0 00 033515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6357									;IN THE SUBTEST) TO LOOP ON ERROR^
  6358
  6359					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6360					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6361					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6362					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6363
  6364					;**********
  6365
  6366					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6367					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6368					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6369					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6370					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6371			007420		SN=SN+1
  6372			100000			ZZ=ZZ+ZZ
  6373						IFE	ZZ,<ZZ=1>
  6374	033515	200 00 0 00 070304 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6375	033516	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6376									;RESULT IN C(AC) NON-ZERO
  6377	033517	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6378						STOP^
  6379	033520	254 04 0 00 033521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6380	033521	324 00 0 00 033522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-21
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6381									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6382									;IN THE SUBTEST) TO LOOP ON ERROR^
  6383
  6384					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6385					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6386					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6387					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6388
  6389					;**********
  6390
  6391					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6392					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6393					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6394					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6395					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6396			007421		SN=SN+1
  6397			200000			ZZ=ZZ+ZZ
  6398						IFE	ZZ,<ZZ=1>
  6399	033522	200 00 0 00 070305 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6400	033523	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6401									;RESULT IN C(AC) NON-ZERO
  6402	033524	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6403						STOP^
  6404	033525	254 04 0 00 033526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6405	033526	324 00 0 00 033527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6406									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6407									;IN THE SUBTEST) TO LOOP ON ERROR^
  6408
  6409					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6410					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6411					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6412					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6413
  6414					;**********
  6415
  6416					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6417					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6418					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6419					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6420					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6421			007422		SN=SN+1
  6422			400000			ZZ=ZZ+ZZ
  6423						IFE	ZZ,<ZZ=1>
  6424	033527	200 00 0 00 070306 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6425	033530	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6426									;RESULT IN C(AC) NON-ZERO
  6427	033531	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6428						STOP^
  6429	033532	254 04 0 00 033533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6430	033533	324 00 0 00 033534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6431									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6432									;IN THE SUBTEST) TO LOOP ON ERROR^
  6433
  6434					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6435					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-22
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6436					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6437					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6438
  6439					;**********
  6440
  6441					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6442					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6443					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6444					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6445					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6446			007423		SN=SN+1
  6447		000001	000000			ZZ=ZZ+ZZ
  6448						IFE	ZZ,<ZZ=1>
  6449	033534	200 00 0 00 070307 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6450	033535	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6451									;RESULT IN C(AC) NON-ZERO
  6452	033536	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6453						STOP^
  6454	033537	254 04 0 00 033540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6455	033540	324 00 0 00 033541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6457									;IN THE SUBTEST) TO LOOP ON ERROR^
  6458
  6459					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6460					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6461					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6462					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6463
  6464					;**********
  6465
  6466					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6467					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6468					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6469					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6470					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6471			007424		SN=SN+1
  6472		000002	000000			ZZ=ZZ+ZZ
  6473						IFE	ZZ,<ZZ=1>
  6474	033541	200 00 0 00 070310 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6475	033542	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6476									;RESULT IN C(AC) NON-ZERO
  6477	033543	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6478						STOP^
  6479	033544	254 04 0 00 033545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6480	033545	324 00 0 00 033546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6481									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6482									;IN THE SUBTEST) TO LOOP ON ERROR^
  6483
  6484					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6485					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6486					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6487					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6488
  6489					;**********
  6490
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-23
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6491					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6492					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6493					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6494					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6495					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6496			007425		SN=SN+1
  6497		000004	000000			ZZ=ZZ+ZZ
  6498						IFE	ZZ,<ZZ=1>
  6499	033546	200 00 0 00 070311 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6500	033547	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6501									;RESULT IN C(AC) NON-ZERO
  6502	033550	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6503						STOP^
  6504	033551	254 04 0 00 033552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6505	033552	324 00 0 00 033553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6507									;IN THE SUBTEST) TO LOOP ON ERROR^
  6508
  6509					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6510					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6511					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6512					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6513
  6514					;**********
  6515
  6516					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6517					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6518					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6519					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6520					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6521			007426		SN=SN+1
  6522		000010	000000			ZZ=ZZ+ZZ
  6523						IFE	ZZ,<ZZ=1>
  6524	033553	200 00 0 00 070312 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6525	033554	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6526									;RESULT IN C(AC) NON-ZERO
  6527	033555	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6528						STOP^
  6529	033556	254 04 0 00 033557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6530	033557	324 00 0 00 033560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6531									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6532									;IN THE SUBTEST) TO LOOP ON ERROR^
  6533
  6534					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6535					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6536					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6537					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6538
  6539					;**********
  6540
  6541					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6542					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6543					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6544					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6545					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-24
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6546			007427		SN=SN+1
  6547		000020	000000			ZZ=ZZ+ZZ
  6548						IFE	ZZ,<ZZ=1>
  6549	033560	200 00 0 00 070313 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6550	033561	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6551									;RESULT IN C(AC) NON-ZERO
  6552	033562	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6553						STOP^
  6554	033563	254 04 0 00 033564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6555	033564	324 00 0 00 033565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6556									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6557									;IN THE SUBTEST) TO LOOP ON ERROR^
  6558
  6559					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6560					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6561					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6562					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6563
  6564					;**********
  6565
  6566					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6567					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6568					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6569					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6570					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6571			007430		SN=SN+1
  6572		000040	000000			ZZ=ZZ+ZZ
  6573						IFE	ZZ,<ZZ=1>
  6574	033565	200 00 0 00 070314 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6575	033566	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6576									;RESULT IN C(AC) NON-ZERO
  6577	033567	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6578						STOP^
  6579	033570	254 04 0 00 033571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6580	033571	324 00 0 00 033572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6581									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6582									;IN THE SUBTEST) TO LOOP ON ERROR^
  6583
  6584					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6585					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6586					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6587					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6588
  6589					;**********
  6590
  6591					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6592					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6593					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6594					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6595					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6596			007431		SN=SN+1
  6597		000100	000000			ZZ=ZZ+ZZ
  6598						IFE	ZZ,<ZZ=1>
  6599	033572	200 00 0 00 070315 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6600	033573	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-25
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6601									;RESULT IN C(AC) NON-ZERO
  6602	033574	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6603						STOP^
  6604	033575	254 04 0 00 033576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6605	033576	324 00 0 00 033577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6606									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6607									;IN THE SUBTEST) TO LOOP ON ERROR^
  6608
  6609					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6610					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6611					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6612					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6613
  6614					;**********
  6615
  6616					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6617					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6618					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6619					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6620					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6621			007432		SN=SN+1
  6622		000200	000000			ZZ=ZZ+ZZ
  6623						IFE	ZZ,<ZZ=1>
  6624	033577	200 00 0 00 070316 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6625	033600	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6626									;RESULT IN C(AC) NON-ZERO
  6627	033601	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6628						STOP^
  6629	033602	254 04 0 00 033603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6630	033603	324 00 0 00 033604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6632									;IN THE SUBTEST) TO LOOP ON ERROR^
  6633
  6634					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6635					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6636					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6637					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6638
  6639					;**********
  6640
  6641					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6642					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6643					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6644					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6645					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6646			007433		SN=SN+1
  6647		000400	000000			ZZ=ZZ+ZZ
  6648						IFE	ZZ,<ZZ=1>
  6649	033604	200 00 0 00 070264 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6650	033605	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6651									;RESULT IN C(AC) NON-ZERO
  6652	033606	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6653						STOP^
  6654	033607	254 04 0 00 033610 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6655	033610	324 00 0 00 033611 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-26
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6656									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6657									;IN THE SUBTEST) TO LOOP ON ERROR^
  6658
  6659					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6660					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6661					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6662					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6663
  6664					;**********
  6665
  6666					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6667					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6668					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6669					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6670					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6671			007434		SN=SN+1
  6672		001000	000000			ZZ=ZZ+ZZ
  6673						IFE	ZZ,<ZZ=1>
  6674	033611	200 00 0 00 070317 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6675	033612	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6676									;RESULT IN C(AC) NON-ZERO
  6677	033613	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6678						STOP^
  6679	033614	254 04 0 00 033615 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6680	033615	324 00 0 00 033616 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6681									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6682									;IN THE SUBTEST) TO LOOP ON ERROR^
  6683
  6684					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6685					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6686					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6687					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6688
  6689					;**********
  6690
  6691					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6692					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6693					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6694					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6695					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6696			007435		SN=SN+1
  6697		002000	000000			ZZ=ZZ+ZZ
  6698						IFE	ZZ,<ZZ=1>
  6699	033616	200 00 0 00 070320 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6700	033617	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6701									;RESULT IN C(AC) NON-ZERO
  6702	033620	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6703						STOP^
  6704	033621	254 04 0 00 033622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6705	033622	324 00 0 00 033623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6706									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6707									;IN THE SUBTEST) TO LOOP ON ERROR^
  6708
  6709					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6710					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-27
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6711					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6712					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6713
  6714					;**********
  6715
  6716					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6717					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6718					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6719					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6720					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6721			007436		SN=SN+1
  6722		004000	000000			ZZ=ZZ+ZZ
  6723						IFE	ZZ,<ZZ=1>
  6724	033623	200 00 0 00 070321 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6725	033624	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6726									;RESULT IN C(AC) NON-ZERO
  6727	033625	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6728						STOP^
  6729	033626	254 04 0 00 033627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6730	033627	324 00 0 00 033630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6732									;IN THE SUBTEST) TO LOOP ON ERROR^
  6733
  6734					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6735					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6736					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6737					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6738
  6739					;**********
  6740
  6741					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6742					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6743					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6744					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6745					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6746			007437		SN=SN+1
  6747		010000	000000			ZZ=ZZ+ZZ
  6748						IFE	ZZ,<ZZ=1>
  6749	033630	200 00 0 00 070322 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6750	033631	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6751									;RESULT IN C(AC) NON-ZERO
  6752	033632	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6753						STOP^
  6754	033633	254 04 0 00 033634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6755	033634	324 00 0 00 033635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6756									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6757									;IN THE SUBTEST) TO LOOP ON ERROR^
  6758
  6759					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6760					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6761					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6762					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6763
  6764					;**********
  6765
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-28
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6766					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6767					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6768					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6769					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6770					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6771			007440		SN=SN+1
  6772		020000	000000			ZZ=ZZ+ZZ
  6773						IFE	ZZ,<ZZ=1>
  6774	033635	200 00 0 00 070323 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6775	033636	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6776									;RESULT IN C(AC) NON-ZERO
  6777	033637	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6778						STOP^
  6779	033640	254 04 0 00 033641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6780	033641	324 00 0 00 033642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6781									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6782									;IN THE SUBTEST) TO LOOP ON ERROR^
  6783
  6784					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6785					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6786					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6787					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6788
  6789					;**********
  6790
  6791					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6792					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6793					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6794					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6795					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6796			007441		SN=SN+1
  6797		040000	000000			ZZ=ZZ+ZZ
  6798						IFE	ZZ,<ZZ=1>
  6799	033642	200 00 0 00 070324 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6800	033643	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6801									;RESULT IN C(AC) NON-ZERO
  6802	033644	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6803						STOP^
  6804	033645	254 04 0 00 033646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6805	033646	324 00 0 00 033647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6807									;IN THE SUBTEST) TO LOOP ON ERROR^
  6808
  6809					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6810					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6811					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6812					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6813
  6814					;**********
  6815
  6816					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6817					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6818					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6819					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6820					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-29
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6821			007442		SN=SN+1
  6822		100000	000000			ZZ=ZZ+ZZ
  6823						IFE	ZZ,<ZZ=1>
  6824	033647	200 00 0 00 070325 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6825	033650	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6826									;RESULT IN C(AC) NON-ZERO
  6827	033651	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6828						STOP^
  6829	033652	254 04 0 00 033653 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6830	033653	324 00 0 00 033654 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6832									;IN THE SUBTEST) TO LOOP ON ERROR^
  6833
  6834					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6835					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6836					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6837					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6838
  6839					;**********
  6840
  6841					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6842					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6843					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6844					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6845					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6846			007443		SN=SN+1
  6847		200000	000000			ZZ=ZZ+ZZ
  6848						IFE	ZZ,<ZZ=1>
  6849	033654	200 00 0 00 070326 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6850	033655	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
  6851									;RESULT IN C(AC) NON-ZERO
  6852	033656	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6853						STOP^
  6854	033657	254 04 0 00 033660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6855	033660	324 00 0 00 033661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6856									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6857									;IN THE SUBTEST) TO LOOP ON ERROR^
  6858
  6859					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6860					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6861					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6862					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6863
  6864					;**********
  6865
  6866					;THIS TEST VERIFIES THAT THE RESULT OF THE XOR INSTRUCTION WHERE
  6867					;C(E)=0 AND C(AC) IS NON-ZERO IS AN AC WHOSE CONTENTS IS NON-ZERO.  THIS
  6868					;TEST IS REPEATED 36 TIMES. EACH TIME THE AC IS INITIALIZED SO THAT ONE
  6869					;AND ONLY ONE FLOATING BIT IS SET TO ONE AND XOR IS EXECUTED WITH E
  6870					;CONTAINING ALL ZEROS.  THE AC IS THEN CHECKED FOR A NON-ZERO RESULT.
  6871			007444		SN=SN+1
  6872		400000	000000			ZZ=ZZ+ZZ
  6873						IFE	ZZ,<ZZ=1>
  6874	033661	200 00 0 00 070256 		MOVE	[ZZ]		;PRELOAD AC WITH ONE FLOATING BIT SET
  6875	033662	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(E)=0 AND ONE BIT OF C(AC) SET SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-30
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6876									;RESULT IN C(AC) NON-ZERO
  6877	033663	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  6878						STOP^
  6879	033664	254 04 0 00 033665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6880	033665	324 00 0 00 033666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6882									;IN THE SUBTEST) TO LOOP ON ERROR^
  6883
  6884					;AD FM- EN [ADFM], AD FM- F/F'S[ADFM],F CYC ACT EN D[R1],
  6885					;IR BOOLE AD FM- F [IR2],IR BOOLE[IR1],IR XX (2,6,7,10,12,15)[IR2],
  6886					;AD EQV[ADCR],AD EQV F/F[ADC2],FCYC ACT EN A[F1],
  6887					;IR BOOLE (6,11)[IR2],IR BOOLE[IR1],IRXX(6,11)[IR2]
  6888
  6889					;**********
  6890
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6891			007500		SN=7500
  6892			000000			ZZ=0
  6893
  6894					A7500:	REPEAT ^D36,
  6895					<;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6896					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6897					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6898					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6899					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6900					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6901					;INDICATE AN ILLEGAL CARRY GENERATION.
  6902					SN=SN+1
  6903						ZZ=ZZ+ZZ
  6904						IFE	ZZ,<ZZ=1>
  6905						MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6906						XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6907						SKIPE			;PASS TEST IF C(AC)=0
  6908						STOP
  6909					
  6910					;**********
  6911					>
  6912					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6913					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6914					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6915					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6916					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6917					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6918					;INDICATE AN ILLEGAL CARRY GENERATION.
  6919			007501		SN=SN+1
  6920			000000			ZZ=ZZ+ZZ
  6921			000001			IFE	ZZ,<ZZ=1>
  6922	033666	200 00 0 00 070265 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6923	033667	430 00 0 00 070265 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6924	033670	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6925						STOP^
  6926	033671	254 04 0 00 033672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6927	033672	324 00 0 00 033673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6928									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6929									;IN THE SUBTEST) TO LOOP ON ERROR^
  6930
  6931					;**********
  6932
  6933					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6934					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6935					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6936					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6937					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6938					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6939					;INDICATE AN ILLEGAL CARRY GENERATION.
  6940			007502		SN=SN+1
  6941			000002			ZZ=ZZ+ZZ
  6942						IFE	ZZ,<ZZ=1>
  6943	033673	200 00 0 00 070266 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6944	033674	430 00 0 00 070266 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6945	033675	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  6946						STOP^
  6947	033676	254 04 0 00 033677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6948	033677	324 00 0 00 033700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6950									;IN THE SUBTEST) TO LOOP ON ERROR^
  6951
  6952					;**********
  6953
  6954					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6955					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6956					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6957					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6958					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6959					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6960					;INDICATE AN ILLEGAL CARRY GENERATION.
  6961			007503		SN=SN+1
  6962			000004			ZZ=ZZ+ZZ
  6963						IFE	ZZ,<ZZ=1>
  6964	033700	200 00 0 00 070267 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6965	033701	430 00 0 00 070267 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6966	033702	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6967						STOP^
  6968	033703	254 04 0 00 033704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6969	033704	324 00 0 00 033705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6970									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6971									;IN THE SUBTEST) TO LOOP ON ERROR^
  6972
  6973					;**********
  6974
  6975					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6976					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6977					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6978					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  6979					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  6980					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  6981					;INDICATE AN ILLEGAL CARRY GENERATION.
  6982			007504		SN=SN+1
  6983			000010			ZZ=ZZ+ZZ
  6984						IFE	ZZ,<ZZ=1>
  6985	033705	200 00 0 00 070270 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  6986	033706	430 00 0 00 070270 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  6987	033707	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  6988						STOP^
  6989	033710	254 04 0 00 033711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  6990	033711	324 00 0 00 033712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  6991									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  6992									;IN THE SUBTEST) TO LOOP ON ERROR^
  6993
  6994					;**********
  6995
  6996					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  6997					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  6998					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  6999					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7000					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7001					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7002					;INDICATE AN ILLEGAL CARRY GENERATION.
  7003			007505		SN=SN+1
  7004			000020			ZZ=ZZ+ZZ
  7005						IFE	ZZ,<ZZ=1>
  7006	033712	200 00 0 00 070271 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7007	033713	430 00 0 00 070271 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7008	033714	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7009						STOP^
  7010	033715	254 04 0 00 033716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7011	033716	324 00 0 00 033717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7013									;IN THE SUBTEST) TO LOOP ON ERROR^
  7014
  7015					;**********
  7016
  7017					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7018					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7019					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7020					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7021					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7022					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7023					;INDICATE AN ILLEGAL CARRY GENERATION.
  7024			007506		SN=SN+1
  7025			000040			ZZ=ZZ+ZZ
  7026						IFE	ZZ,<ZZ=1>
  7027	033717	200 00 0 00 070272 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7028	033720	430 00 0 00 070272 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7029	033721	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7030						STOP^
  7031	033722	254 04 0 00 033723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7032	033723	324 00 0 00 033724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7033									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7034									;IN THE SUBTEST) TO LOOP ON ERROR^
  7035
  7036					;**********
  7037
  7038					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7039					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7040					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7041					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7042					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7043					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7044					;INDICATE AN ILLEGAL CARRY GENERATION.
  7045			007507		SN=SN+1
  7046			000100			ZZ=ZZ+ZZ
  7047						IFE	ZZ,<ZZ=1>
  7048	033724	200 00 0 00 070273 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7049	033725	430 00 0 00 070273 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7050	033726	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7051						STOP^
  7052	033727	254 04 0 00 033730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7053	033730	324 00 0 00 033731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7054									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7055									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7056
  7057					;**********
  7058
  7059					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7060					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7061					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7062					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7063					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7064					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7065					;INDICATE AN ILLEGAL CARRY GENERATION.
  7066			007510		SN=SN+1
  7067			000200			ZZ=ZZ+ZZ
  7068						IFE	ZZ,<ZZ=1>
  7069	033731	200 00 0 00 070274 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7070	033732	430 00 0 00 070274 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7071	033733	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7072						STOP^
  7073	033734	254 04 0 00 033735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7074	033735	324 00 0 00 033736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7075									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7076									;IN THE SUBTEST) TO LOOP ON ERROR^
  7077
  7078					;**********
  7079
  7080					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7081					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7082					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7083					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7084					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7085					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7086					;INDICATE AN ILLEGAL CARRY GENERATION.
  7087			007511		SN=SN+1
  7088			000400			ZZ=ZZ+ZZ
  7089						IFE	ZZ,<ZZ=1>
  7090	033736	200 00 0 00 070275 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7091	033737	430 00 0 00 070275 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7092	033740	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7093						STOP^
  7094	033741	254 04 0 00 033742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7095	033742	324 00 0 00 033743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7096									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7097									;IN THE SUBTEST) TO LOOP ON ERROR^
  7098
  7099					;**********
  7100
  7101					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7102					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7103					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7104					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7105					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7106					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7107					;INDICATE AN ILLEGAL CARRY GENERATION.
  7108			007512		SN=SN+1
  7109			001000			ZZ=ZZ+ZZ
  7110						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7111	033743	200 00 0 00 070276 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7112	033744	430 00 0 00 070276 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7113	033745	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7114						STOP^
  7115	033746	254 04 0 00 033747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7116	033747	324 00 0 00 033750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7118									;IN THE SUBTEST) TO LOOP ON ERROR^
  7119
  7120					;**********
  7121
  7122					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7123					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7124					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7125					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7126					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7127					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7128					;INDICATE AN ILLEGAL CARRY GENERATION.
  7129			007513		SN=SN+1
  7130			002000			ZZ=ZZ+ZZ
  7131						IFE	ZZ,<ZZ=1>
  7132	033750	200 00 0 00 070277 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7133	033751	430 00 0 00 070277 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7134	033752	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7135						STOP^
  7136	033753	254 04 0 00 033754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7137	033754	324 00 0 00 033755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7138									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7139									;IN THE SUBTEST) TO LOOP ON ERROR^
  7140
  7141					;**********
  7142
  7143					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7144					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7145					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7146					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7147					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7148					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7149					;INDICATE AN ILLEGAL CARRY GENERATION.
  7150			007514		SN=SN+1
  7151			004000			ZZ=ZZ+ZZ
  7152						IFE	ZZ,<ZZ=1>
  7153	033755	200 00 0 00 070300 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7154	033756	430 00 0 00 070300 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7155	033757	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7156						STOP^
  7157	033760	254 04 0 00 033761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7158	033761	324 00 0 00 033762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7159									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7160									;IN THE SUBTEST) TO LOOP ON ERROR^
  7161
  7162					;**********
  7163
  7164					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7165					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7166					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7167					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7168					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7169					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7170					;INDICATE AN ILLEGAL CARRY GENERATION.
  7171			007515		SN=SN+1
  7172			010000			ZZ=ZZ+ZZ
  7173						IFE	ZZ,<ZZ=1>
  7174	033762	200 00 0 00 070301 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7175	033763	430 00 0 00 070301 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7176	033764	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7177						STOP^
  7178	033765	254 04 0 00 033766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7179	033766	324 00 0 00 033767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7181									;IN THE SUBTEST) TO LOOP ON ERROR^
  7182
  7183					;**********
  7184
  7185					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7186					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7187					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7188					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7189					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7190					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7191					;INDICATE AN ILLEGAL CARRY GENERATION.
  7192			007516		SN=SN+1
  7193			020000			ZZ=ZZ+ZZ
  7194						IFE	ZZ,<ZZ=1>
  7195	033767	200 00 0 00 070302 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7196	033770	430 00 0 00 070302 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7197	033771	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7198						STOP^
  7199	033772	254 04 0 00 033773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7200	033773	324 00 0 00 033774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7201									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7202									;IN THE SUBTEST) TO LOOP ON ERROR^
  7203
  7204					;**********
  7205
  7206					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7207					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7208					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7209					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7210					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7211					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7212					;INDICATE AN ILLEGAL CARRY GENERATION.
  7213			007517		SN=SN+1
  7214			040000			ZZ=ZZ+ZZ
  7215						IFE	ZZ,<ZZ=1>
  7216	033774	200 00 0 00 070303 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7217	033775	430 00 0 00 070303 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7218	033776	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7219						STOP^
  7220	033777	254 04 0 00 034000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7221	034000	324 00 0 00 034001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7223									;IN THE SUBTEST) TO LOOP ON ERROR^
  7224
  7225					;**********
  7226
  7227					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7228					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7229					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7230					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7231					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7232					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7233					;INDICATE AN ILLEGAL CARRY GENERATION.
  7234			007520		SN=SN+1
  7235			100000			ZZ=ZZ+ZZ
  7236						IFE	ZZ,<ZZ=1>
  7237	034001	200 00 0 00 070304 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7238	034002	430 00 0 00 070304 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7239	034003	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7240						STOP^
  7241	034004	254 04 0 00 034005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7242	034005	324 00 0 00 034006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7243									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7244									;IN THE SUBTEST) TO LOOP ON ERROR^
  7245
  7246					;**********
  7247
  7248					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7249					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7250					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7251					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7252					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7253					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7254					;INDICATE AN ILLEGAL CARRY GENERATION.
  7255			007521		SN=SN+1
  7256			200000			ZZ=ZZ+ZZ
  7257						IFE	ZZ,<ZZ=1>
  7258	034006	200 00 0 00 070305 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7259	034007	430 00 0 00 070305 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7260	034010	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7261						STOP^
  7262	034011	254 04 0 00 034012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7263	034012	324 00 0 00 034013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7265									;IN THE SUBTEST) TO LOOP ON ERROR^
  7266
  7267					;**********
  7268
  7269					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7270					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7271					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7272					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7273					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7274					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7275					;INDICATE AN ILLEGAL CARRY GENERATION.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7276			007522		SN=SN+1
  7277			400000			ZZ=ZZ+ZZ
  7278						IFE	ZZ,<ZZ=1>
  7279	034013	200 00 0 00 070306 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7280	034014	430 00 0 00 070306 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7281	034015	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7282						STOP^
  7283	034016	254 04 0 00 034017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7284	034017	324 00 0 00 034020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7285									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7286									;IN THE SUBTEST) TO LOOP ON ERROR^
  7287
  7288					;**********
  7289
  7290					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7291					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7292					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7293					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7294					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7295					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7296					;INDICATE AN ILLEGAL CARRY GENERATION.
  7297			007523		SN=SN+1
  7298		000001	000000			ZZ=ZZ+ZZ
  7299						IFE	ZZ,<ZZ=1>
  7300	034020	200 00 0 00 070307 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7301	034021	430 00 0 00 070307 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7302	034022	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7303						STOP^
  7304	034023	254 04 0 00 034024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7305	034024	324 00 0 00 034025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7306									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7307									;IN THE SUBTEST) TO LOOP ON ERROR^
  7308
  7309					;**********
  7310
  7311					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7312					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7313					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7314					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7315					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7316					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7317					;INDICATE AN ILLEGAL CARRY GENERATION.
  7318			007524		SN=SN+1
  7319		000002	000000			ZZ=ZZ+ZZ
  7320						IFE	ZZ,<ZZ=1>
  7321	034025	200 00 0 00 070310 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7322	034026	430 00 0 00 070310 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7323	034027	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7324						STOP^
  7325	034030	254 04 0 00 034031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7326	034031	324 00 0 00 034032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7327									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7328									;IN THE SUBTEST) TO LOOP ON ERROR^
  7329
  7330					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7331
  7332					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7333					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7334					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7335					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7336					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7337					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7338					;INDICATE AN ILLEGAL CARRY GENERATION.
  7339			007525		SN=SN+1
  7340		000004	000000			ZZ=ZZ+ZZ
  7341						IFE	ZZ,<ZZ=1>
  7342	034032	200 00 0 00 070311 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7343	034033	430 00 0 00 070311 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7344	034034	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7345						STOP^
  7346	034035	254 04 0 00 034036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7347	034036	324 00 0 00 034037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7348									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7349									;IN THE SUBTEST) TO LOOP ON ERROR^
  7350
  7351					;**********
  7352
  7353					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7354					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7355					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7356					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7357					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7358					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7359					;INDICATE AN ILLEGAL CARRY GENERATION.
  7360			007526		SN=SN+1
  7361		000010	000000			ZZ=ZZ+ZZ
  7362						IFE	ZZ,<ZZ=1>
  7363	034037	200 00 0 00 070312 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7364	034040	430 00 0 00 070312 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7365	034041	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7366						STOP^
  7367	034042	254 04 0 00 034043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7368	034043	324 00 0 00 034044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7369									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7370									;IN THE SUBTEST) TO LOOP ON ERROR^
  7371
  7372					;**********
  7373
  7374					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7375					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7376					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7377					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7378					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7379					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7380					;INDICATE AN ILLEGAL CARRY GENERATION.
  7381			007527		SN=SN+1
  7382		000020	000000			ZZ=ZZ+ZZ
  7383						IFE	ZZ,<ZZ=1>
  7384	034044	200 00 0 00 070313 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7385	034045	430 00 0 00 070313 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7386	034046	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7387						STOP^
  7388	034047	254 04 0 00 034050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7389	034050	324 00 0 00 034051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7390									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7391									;IN THE SUBTEST) TO LOOP ON ERROR^
  7392
  7393					;**********
  7394
  7395					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7396					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7397					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7398					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7399					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7400					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7401					;INDICATE AN ILLEGAL CARRY GENERATION.
  7402			007530		SN=SN+1
  7403		000040	000000			ZZ=ZZ+ZZ
  7404						IFE	ZZ,<ZZ=1>
  7405	034051	200 00 0 00 070314 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7406	034052	430 00 0 00 070314 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7407	034053	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7408						STOP^
  7409	034054	254 04 0 00 034055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7410	034055	324 00 0 00 034056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7412									;IN THE SUBTEST) TO LOOP ON ERROR^
  7413
  7414					;**********
  7415
  7416					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7417					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7418					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7419					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7420					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7421					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7422					;INDICATE AN ILLEGAL CARRY GENERATION.
  7423			007531		SN=SN+1
  7424		000100	000000			ZZ=ZZ+ZZ
  7425						IFE	ZZ,<ZZ=1>
  7426	034056	200 00 0 00 070315 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7427	034057	430 00 0 00 070315 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7428	034060	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7429						STOP^
  7430	034061	254 04 0 00 034062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7431	034062	324 00 0 00 034063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7433									;IN THE SUBTEST) TO LOOP ON ERROR^
  7434
  7435					;**********
  7436
  7437					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7438					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7439					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7440					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7441					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7442					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7443					;INDICATE AN ILLEGAL CARRY GENERATION.
  7444			007532		SN=SN+1
  7445		000200	000000			ZZ=ZZ+ZZ
  7446						IFE	ZZ,<ZZ=1>
  7447	034063	200 00 0 00 070316 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7448	034064	430 00 0 00 070316 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7449	034065	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7450						STOP^
  7451	034066	254 04 0 00 034067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7452	034067	324 00 0 00 034070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7453									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7454									;IN THE SUBTEST) TO LOOP ON ERROR^
  7455
  7456					;**********
  7457
  7458					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7459					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7460					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7461					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7462					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7463					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7464					;INDICATE AN ILLEGAL CARRY GENERATION.
  7465			007533		SN=SN+1
  7466		000400	000000			ZZ=ZZ+ZZ
  7467						IFE	ZZ,<ZZ=1>
  7468	034070	200 00 0 00 070264 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7469	034071	430 00 0 00 070264 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7470	034072	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7471						STOP^
  7472	034073	254 04 0 00 034074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7473	034074	324 00 0 00 034075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7474									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7475									;IN THE SUBTEST) TO LOOP ON ERROR^
  7476
  7477					;**********
  7478
  7479					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7480					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7481					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7482					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7483					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7484					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7485					;INDICATE AN ILLEGAL CARRY GENERATION.
  7486			007534		SN=SN+1
  7487		001000	000000			ZZ=ZZ+ZZ
  7488						IFE	ZZ,<ZZ=1>
  7489	034075	200 00 0 00 070317 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7490	034076	430 00 0 00 070317 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7491	034077	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7492						STOP^
  7493	034100	254 04 0 00 034101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7494	034101	324 00 0 00 034102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7496									;IN THE SUBTEST) TO LOOP ON ERROR^
  7497
  7498					;**********
  7499
  7500					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7501					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7502					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7503					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7504					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7505					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7506					;INDICATE AN ILLEGAL CARRY GENERATION.
  7507			007535		SN=SN+1
  7508		002000	000000			ZZ=ZZ+ZZ
  7509						IFE	ZZ,<ZZ=1>
  7510	034102	200 00 0 00 070320 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7511	034103	430 00 0 00 070320 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7512	034104	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7513						STOP^
  7514	034105	254 04 0 00 034106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7515	034106	324 00 0 00 034107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7517									;IN THE SUBTEST) TO LOOP ON ERROR^
  7518
  7519					;**********
  7520
  7521					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7522					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7523					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7524					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7525					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7526					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7527					;INDICATE AN ILLEGAL CARRY GENERATION.
  7528			007536		SN=SN+1
  7529		004000	000000			ZZ=ZZ+ZZ
  7530						IFE	ZZ,<ZZ=1>
  7531	034107	200 00 0 00 070321 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7532	034110	430 00 0 00 070321 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7533	034111	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7534						STOP^
  7535	034112	254 04 0 00 034113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7536	034113	324 00 0 00 034114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7537									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7538									;IN THE SUBTEST) TO LOOP ON ERROR^
  7539
  7540					;**********
  7541
  7542					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7543					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7544					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7545					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7546					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7547					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7548					;INDICATE AN ILLEGAL CARRY GENERATION.
  7549			007537		SN=SN+1
  7550		010000	000000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7551						IFE	ZZ,<ZZ=1>
  7552	034114	200 00 0 00 070322 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7553	034115	430 00 0 00 070322 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7554	034116	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7555						STOP^
  7556	034117	254 04 0 00 034120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7557	034120	324 00 0 00 034121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7558									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7559									;IN THE SUBTEST) TO LOOP ON ERROR^
  7560
  7561					;**********
  7562
  7563					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7564					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7565					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7566					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7567					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7568					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7569					;INDICATE AN ILLEGAL CARRY GENERATION.
  7570			007540		SN=SN+1
  7571		020000	000000			ZZ=ZZ+ZZ
  7572						IFE	ZZ,<ZZ=1>
  7573	034121	200 00 0 00 070323 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7574	034122	430 00 0 00 070323 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7575	034123	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7576						STOP^
  7577	034124	254 04 0 00 034125 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7578	034125	324 00 0 00 034126 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7580									;IN THE SUBTEST) TO LOOP ON ERROR^
  7581
  7582					;**********
  7583
  7584					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7585					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7586					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7587					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7588					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7589					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7590					;INDICATE AN ILLEGAL CARRY GENERATION.
  7591			007541		SN=SN+1
  7592		040000	000000			ZZ=ZZ+ZZ
  7593						IFE	ZZ,<ZZ=1>
  7594	034126	200 00 0 00 070324 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7595	034127	430 00 0 00 070324 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7596	034130	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7597						STOP^
  7598	034131	254 04 0 00 034132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7599	034132	324 00 0 00 034133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7600									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7601									;IN THE SUBTEST) TO LOOP ON ERROR^
  7602
  7603					;**********
  7604
  7605					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7606					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7607					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7608					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7609					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7610					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7611					;INDICATE AN ILLEGAL CARRY GENERATION.
  7612			007542		SN=SN+1
  7613		100000	000000			ZZ=ZZ+ZZ
  7614						IFE	ZZ,<ZZ=1>
  7615	034133	200 00 0 00 070325 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7616	034134	430 00 0 00 070325 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7617	034135	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7618						STOP^
  7619	034136	254 04 0 00 034137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7620	034137	324 00 0 00 034140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7621									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7622									;IN THE SUBTEST) TO LOOP ON ERROR^
  7623
  7624					;**********
  7625
  7626					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7627					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7628					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7629					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7630					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7631					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7632					;INDICATE AN ILLEGAL CARRY GENERATION.
  7633			007543		SN=SN+1
  7634		200000	000000			ZZ=ZZ+ZZ
  7635						IFE	ZZ,<ZZ=1>
  7636	034140	200 00 0 00 070326 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7637	034141	430 00 0 00 070326 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7638	034142	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7639						STOP^
  7640	034143	254 04 0 00 034144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7641	034144	324 00 0 00 034145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7642									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7643									;IN THE SUBTEST) TO LOOP ON ERROR^
  7644
  7645					;**********
  7646
  7647					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION
  7648					;WHERE C(AC) = C(E) IS AN AC CONTAINING ALL ZEROS.  FIRST,
  7649					;THE AC IS INITIALIZED WITH A WORD CONTAINING ALL ZEROS EXCEPT
  7650					;FOR ONE FLOATING ONE; THEN, XOR IS EXECUTED WITH E CONTAINING THE SAME
  7651					;NUMBER.  THE RESULT SHOULD BE AN AC CONTAINING ALL ZEROS.  THIS TEST
  7652					;IS REPEATED 36 TIMES.  IF ANY BIT IN THE RESULT IS NON-ZERO, IT MAY
  7653					;INDICATE AN ILLEGAL CARRY GENERATION.
  7654			007544		SN=SN+1
  7655		400000	000000			ZZ=ZZ+ZZ
  7656						IFE	ZZ,<ZZ=1>
  7657	034145	200 00 0 00 070256 		MOVE	[ZZ]		;INITIALIZE AC WITH ONE FLOATING BIT SET
  7658	034146	430 00 0 00 070256 		XOR	[ZZ]		;*XOR WITH C(AC)=C(E) SHOULD RESULT IN C(AC)=0
  7659	034147	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7660						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-14
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7661	034150	254 04 0 00 034151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7662	034151	324 00 0 00 034152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7663									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7664									;IN THE SUBTEST) TO LOOP ON ERROR^
  7665
  7666					;**********
  7667
  7668					;THIS TEST VERIFIES THAT THE RESULT OF AN XOR INSTRUCTION WHERE
  7669					;C(AC)=C(E)=0 IS AN AC CONTAINING ALL ZEROS; FIRST THE AC IS CLEARED; THEN
  7670					;XOR IS EXECUTED WITH C(E)=0.  THE RESULT IN THE AC IS CHECKED FOR ALL ZEROS
  7671
  7672	034152	200 00 0 00 070253 	A7600:	MOVE	[0]		;INITIALIZE AC TO ALL ZEROS
  7673	034153	430 00 0 00 070253 		XOR	[0]		;*XOR WITH C(AC)=C(E)=0 SHOULD RESULT INC(AC)=0
  7674	034154	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7675						STOP^
  7676	034155	254 04 0 00 034156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7677	034156	324 00 0 00 034157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7678									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7679									;IN THE SUBTEST) TO LOOP ON ERROR^
  7680
  7681					;**********
  7682
  7683					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7684					;C(AC)=0 AND C(E) ALL ONES IS AN AC CONTAINING ALL ZEROS SINCE
  7685					;THE EQUIVALENCE FUNCTION SHOULD SET ONLY LIKE BITS.  FIRST, THE AC
  7686					;SHOULD BE CLEARED; THEN, EQV IS EXECUTED WITH E CONTAINING ALL ONES.
  7687					;THE AC IS THEN CHECKED FOR ALL ZEROS
  7688
  7689	034157	200 00 0 00 070253 	A7700:	MOVE	[0]		;CLEAR THE AC
  7690	034160	444 00 0 00 070254 		EQV	[-1]		;*EQV WITH C(AC)=0 AND C(E) ALL ONES SHOULD
  7691									;RESULT IN C(AC)=0
  7692	034161	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  7693						STOP^
  7694	034162	254 04 0 00 034163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7695	034163	324 00 0 00 034164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7696									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7697									;IN THE SUBTEST) TO LOOP ON ERROR^
  7698
  7699					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7700			010000		SN=10000
  7701			000000			ZZ=0
  7702
  7703					A10000:	REPEAT	^D18,
  7704					<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7705					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7706					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7707					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7708					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7709					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7710					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7711					SN=SN+1
  7712						ZZ=ZZ+ZZ+1
  7713						IFE	<ZZ-1>,<ZZ=-2>
  7714						MOVE	[0]		;PRESET AC TO ALL ZEROS
  7715						EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7716									;RESULT IN C(AC) NON-ZERO
  7717						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7718						STOP
  7719					
  7720					;**********
  7721					>
  7722					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7723					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7724					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7725					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7726					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7727					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7728					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7729			010001		SN=SN+1
  7730			000001			ZZ=ZZ+ZZ+1
  7731		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
  7732	034164	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7733	034165	444 00 0 00 070333 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7734									;RESULT IN C(AC) NON-ZERO
  7735	034166	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7736						STOP^
  7737	034167	254 04 0 00 034170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7738	034170	324 00 0 00 034171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7739									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7740									;IN THE SUBTEST) TO LOOP ON ERROR^
  7741
  7742					;**********
  7743
  7744					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7745					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7746					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7747					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7748					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7749					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7750					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7751			010002		SN=SN+1
  7752		777777	777775			ZZ=ZZ+ZZ+1
  7753						IFE	<ZZ-1>,<ZZ=-2>
  7754	034171	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7755	034172	444 00 0 00 070334 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7756									;RESULT IN C(AC) NON-ZERO
  7757	034173	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7758						STOP^
  7759	034174	254 04 0 00 034175 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7760	034175	324 00 0 00 034176 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7762									;IN THE SUBTEST) TO LOOP ON ERROR^
  7763
  7764					;**********
  7765
  7766					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7767					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7768					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7769					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7770					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7771					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7772					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7773			010003		SN=SN+1
  7774		777777	777773			ZZ=ZZ+ZZ+1
  7775						IFE	<ZZ-1>,<ZZ=-2>
  7776	034176	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7777	034177	444 00 0 00 070335 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7778									;RESULT IN C(AC) NON-ZERO
  7779	034200	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7780						STOP^
  7781	034201	254 04 0 00 034202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7782	034202	324 00 0 00 034203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7783									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7784									;IN THE SUBTEST) TO LOOP ON ERROR^
  7785
  7786					;**********
  7787
  7788					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7789					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7790					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7791					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7792					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7793					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7794					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7795			010004		SN=SN+1
  7796		777777	777767			ZZ=ZZ+ZZ+1
  7797						IFE	<ZZ-1>,<ZZ=-2>
  7798	034203	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7799	034204	444 00 0 00 070336 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7800									;RESULT IN C(AC) NON-ZERO
  7801	034205	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7802						STOP^
  7803	034206	254 04 0 00 034207 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7804	034207	324 00 0 00 034210 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7806									;IN THE SUBTEST) TO LOOP ON ERROR^
  7807
  7808					;**********
  7809
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7810					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7811					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7812					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7813					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7814					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7815					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7816					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7817			010005		SN=SN+1
  7818		777777	777757			ZZ=ZZ+ZZ+1
  7819						IFE	<ZZ-1>,<ZZ=-2>
  7820	034210	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7821	034211	444 00 0 00 070337 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7822									;RESULT IN C(AC) NON-ZERO
  7823	034212	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7824						STOP^
  7825	034213	254 04 0 00 034214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7826	034214	324 00 0 00 034215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7827									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7828									;IN THE SUBTEST) TO LOOP ON ERROR^
  7829
  7830					;**********
  7831
  7832					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7833					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7834					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7835					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7836					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7837					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7838					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7839			010006		SN=SN+1
  7840		777777	777737			ZZ=ZZ+ZZ+1
  7841						IFE	<ZZ-1>,<ZZ=-2>
  7842	034215	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7843	034216	444 00 0 00 070340 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7844									;RESULT IN C(AC) NON-ZERO
  7845	034217	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7846						STOP^
  7847	034220	254 04 0 00 034221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7848	034221	324 00 0 00 034222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7850									;IN THE SUBTEST) TO LOOP ON ERROR^
  7851
  7852					;**********
  7853
  7854					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7855					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7856					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7857					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7858					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7859					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7860					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7861			010007		SN=SN+1
  7862		777777	777677			ZZ=ZZ+ZZ+1
  7863						IFE	<ZZ-1>,<ZZ=-2>
  7864	034222	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7865	034223	444 00 0 00 070341 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7866									;RESULT IN C(AC) NON-ZERO
  7867	034224	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7868						STOP^
  7869	034225	254 04 0 00 034226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7870	034226	324 00 0 00 034227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7872									;IN THE SUBTEST) TO LOOP ON ERROR^
  7873
  7874					;**********
  7875
  7876					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7877					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7878					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7879					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7880					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7881					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7882					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7883			010010		SN=SN+1
  7884		777777	777577			ZZ=ZZ+ZZ+1
  7885						IFE	<ZZ-1>,<ZZ=-2>
  7886	034227	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7887	034230	444 00 0 00 070342 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7888									;RESULT IN C(AC) NON-ZERO
  7889	034231	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7890						STOP^
  7891	034232	254 04 0 00 034233 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7892	034233	324 00 0 00 034234 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7894									;IN THE SUBTEST) TO LOOP ON ERROR^
  7895
  7896					;**********
  7897
  7898					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7899					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7900					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7901					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7902					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7903					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7904					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7905			010011		SN=SN+1
  7906		777777	777377			ZZ=ZZ+ZZ+1
  7907						IFE	<ZZ-1>,<ZZ=-2>
  7908	034234	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7909	034235	444 00 0 00 070343 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7910									;RESULT IN C(AC) NON-ZERO
  7911	034236	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7912						STOP^
  7913	034237	254 04 0 00 034240 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7914	034240	324 00 0 00 034241 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7916									;IN THE SUBTEST) TO LOOP ON ERROR^
  7917
  7918					;**********
  7919
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7920					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7921					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7922					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7923					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7924					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7925					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7926					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7927			010012		SN=SN+1
  7928		777777	776777			ZZ=ZZ+ZZ+1
  7929						IFE	<ZZ-1>,<ZZ=-2>
  7930	034241	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7931	034242	444 00 0 00 070344 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7932									;RESULT IN C(AC) NON-ZERO
  7933	034243	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7934						STOP^
  7935	034244	254 04 0 00 034245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7936	034245	324 00 0 00 034246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7937									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7938									;IN THE SUBTEST) TO LOOP ON ERROR^
  7939
  7940					;**********
  7941
  7942					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7943					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7944					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7945					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7946					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7947					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7948					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7949			010013		SN=SN+1
  7950		777777	775777			ZZ=ZZ+ZZ+1
  7951						IFE	<ZZ-1>,<ZZ=-2>
  7952	034246	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7953	034247	444 00 0 00 070345 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7954									;RESULT IN C(AC) NON-ZERO
  7955	034250	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7956						STOP^
  7957	034251	254 04 0 00 034252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7958	034252	324 00 0 00 034253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7960									;IN THE SUBTEST) TO LOOP ON ERROR^
  7961
  7962					;**********
  7963
  7964					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7965					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7966					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7967					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7968					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7969					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7970					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7971			010014		SN=SN+1
  7972		777777	773777			ZZ=ZZ+ZZ+1
  7973						IFE	<ZZ-1>,<ZZ=-2>
  7974	034253	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  7975	034254	444 00 0 00 070346 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7976									;RESULT IN C(AC) NON-ZERO
  7977	034255	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  7978						STOP^
  7979	034256	254 04 0 00 034257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  7980	034257	324 00 0 00 034260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  7981									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  7982									;IN THE SUBTEST) TO LOOP ON ERROR^
  7983
  7984					;**********
  7985
  7986					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  7987					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  7988					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  7989					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  7990					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  7991					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  7992					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  7993			010015		SN=SN+1
  7994		777777	767777			ZZ=ZZ+ZZ+1
  7995						IFE	<ZZ-1>,<ZZ=-2>
  7996	034260	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  7997	034261	444 00 0 00 070347 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  7998									;RESULT IN C(AC) NON-ZERO
  7999	034262	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8000						STOP^
  8001	034263	254 04 0 00 034264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8002	034264	324 00 0 00 034265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8004									;IN THE SUBTEST) TO LOOP ON ERROR^
  8005
  8006					;**********
  8007
  8008					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8009					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8010					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8011					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8012					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8013					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8014					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8015			010016		SN=SN+1
  8016		777777	757777			ZZ=ZZ+ZZ+1
  8017						IFE	<ZZ-1>,<ZZ=-2>
  8018	034265	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8019	034266	444 00 0 00 070350 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8020									;RESULT IN C(AC) NON-ZERO
  8021	034267	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8022						STOP^
  8023	034270	254 04 0 00 034271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8024	034271	324 00 0 00 034272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8026									;IN THE SUBTEST) TO LOOP ON ERROR^
  8027
  8028					;**********
  8029
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8030					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8031					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8032					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8033					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8034					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8035					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8036					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8037			010017		SN=SN+1
  8038		777777	737777			ZZ=ZZ+ZZ+1
  8039						IFE	<ZZ-1>,<ZZ=-2>
  8040	034272	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8041	034273	444 00 0 00 070351 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8042									;RESULT IN C(AC) NON-ZERO
  8043	034274	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8044						STOP^
  8045	034275	254 04 0 00 034276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8046	034276	324 00 0 00 034277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8047									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8048									;IN THE SUBTEST) TO LOOP ON ERROR^
  8049
  8050					;**********
  8051
  8052					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8053					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8054					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8055					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8056					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8057					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8058					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8059			010020		SN=SN+1
  8060		777777	677777			ZZ=ZZ+ZZ+1
  8061						IFE	<ZZ-1>,<ZZ=-2>
  8062	034277	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8063	034300	444 00 0 00 070352 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8064									;RESULT IN C(AC) NON-ZERO
  8065	034301	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8066						STOP^
  8067	034302	254 04 0 00 034303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8068	034303	324 00 0 00 034304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8070									;IN THE SUBTEST) TO LOOP ON ERROR^
  8071
  8072					;**********
  8073
  8074					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8075					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8076					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8077					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8078					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8079					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8080					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8081			010021		SN=SN+1
  8082		777777	577777			ZZ=ZZ+ZZ+1
  8083						IFE	<ZZ-1>,<ZZ=-2>
  8084	034304	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8085	034305	444 00 0 00 070353 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8086									;RESULT IN C(AC) NON-ZERO
  8087	034306	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8088						STOP^
  8089	034307	254 04 0 00 034310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8090	034310	324 00 0 00 034311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8092									;IN THE SUBTEST) TO LOOP ON ERROR^
  8093
  8094					;**********
  8095
  8096					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8097					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8098					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8099					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8100					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8101					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8102					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8103			010022		SN=SN+1
  8104		777777	377777			ZZ=ZZ+ZZ+1
  8105						IFE	<ZZ-1>,<ZZ=-2>
  8106	034311	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8107	034312	444 00 0 00 070354 		EQV	[XWD -1,ZZ]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8108									;RESULT IN C(AC) NON-ZERO
  8109	034313	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8110						STOP^
  8111	034314	254 04 0 00 034315 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8112	034315	324 00 0 00 034316 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8114									;IN THE SUBTEST) TO LOOP ON ERROR^
  8115
  8116					;**********
  8117
  8118			010100		SN=10100
  8119			000000			ZZ=0
  8120
  8121					A10100:	REPEAT	^D18,
  8122					<;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8123					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8124					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8125					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8126					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8127					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8128					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8129					SN=SN+1
  8130						ZZ=ZZ+ZZ+1
  8131						IFE	<ZZ-1>,<ZZ=-2>
  8132						MOVE	[0]		;PRESET AC TO ALL ZEROS
  8133						EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8134									;RESULT IN C(AC) NON-ZERO
  8135						SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8136						STOP
  8137					
  8138					;**********
  8139					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8140					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8141					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8142					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8143					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8144					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8145					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8146					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8147			010101		SN=SN+1
  8148			000001			ZZ=ZZ+ZZ+1
  8149		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
  8150	034316	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8151	034317	444 00 0 00 070355 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8152									;RESULT IN C(AC) NON-ZERO
  8153	034320	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8154						STOP^
  8155	034321	254 04 0 00 034322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8156	034322	324 00 0 00 034323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8157									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8158									;IN THE SUBTEST) TO LOOP ON ERROR^
  8159
  8160					;**********
  8161
  8162					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8163					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8164					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8165					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8166					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8167					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8168					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8169			010102		SN=SN+1
  8170		777777	777775			ZZ=ZZ+ZZ+1
  8171						IFE	<ZZ-1>,<ZZ=-2>
  8172	034323	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8173	034324	444 00 0 00 070356 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8174									;RESULT IN C(AC) NON-ZERO
  8175	034325	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8176						STOP^
  8177	034326	254 04 0 00 034327 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8178	034327	324 00 0 00 034330 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8180									;IN THE SUBTEST) TO LOOP ON ERROR^
  8181
  8182					;**********
  8183
  8184					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8185					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8186					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8187					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8188					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8189					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8190					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8191			010103		SN=SN+1
  8192		777777	777773			ZZ=ZZ+ZZ+1
  8193						IFE	<ZZ-1>,<ZZ=-2>
  8194	034330	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8195	034331	444 00 0 00 070357 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8196									;RESULT IN C(AC) NON-ZERO
  8197	034332	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8198						STOP^
  8199	034333	254 04 0 00 034334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8200	034334	324 00 0 00 034335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8201									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8202									;IN THE SUBTEST) TO LOOP ON ERROR^
  8203
  8204					;**********
  8205
  8206					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8207					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8208					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8209					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8210					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8211					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8212					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8213			010104		SN=SN+1
  8214		777777	777767			ZZ=ZZ+ZZ+1
  8215						IFE	<ZZ-1>,<ZZ=-2>
  8216	034335	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8217	034336	444 00 0 00 070360 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8218									;RESULT IN C(AC) NON-ZERO
  8219	034337	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8220						STOP^
  8221	034340	254 04 0 00 034341 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8222	034341	324 00 0 00 034342 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8223									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8224									;IN THE SUBTEST) TO LOOP ON ERROR^
  8225
  8226					;**********
  8227
  8228					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8229					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8230					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8231					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8232					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8233					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8234					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8235			010105		SN=SN+1
  8236		777777	777757			ZZ=ZZ+ZZ+1
  8237						IFE	<ZZ-1>,<ZZ=-2>
  8238	034342	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8239	034343	444 00 0 00 070361 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8240									;RESULT IN C(AC) NON-ZERO
  8241	034344	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8242						STOP^
  8243	034345	254 04 0 00 034346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8244	034346	324 00 0 00 034347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8245									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8246									;IN THE SUBTEST) TO LOOP ON ERROR^
  8247
  8248					;**********
  8249
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8250					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8251					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8252					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8253					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8254					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8255					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8256					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8257			010106		SN=SN+1
  8258		777777	777737			ZZ=ZZ+ZZ+1
  8259						IFE	<ZZ-1>,<ZZ=-2>
  8260	034347	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8261	034350	444 00 0 00 070362 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8262									;RESULT IN C(AC) NON-ZERO
  8263	034351	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8264						STOP^
  8265	034352	254 04 0 00 034353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8266	034353	324 00 0 00 034354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8267									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8268									;IN THE SUBTEST) TO LOOP ON ERROR^
  8269
  8270					;**********
  8271
  8272					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8273					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8274					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8275					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8276					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8277					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8278					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8279			010107		SN=SN+1
  8280		777777	777677			ZZ=ZZ+ZZ+1
  8281						IFE	<ZZ-1>,<ZZ=-2>
  8282	034354	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8283	034355	444 00 0 00 070363 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8284									;RESULT IN C(AC) NON-ZERO
  8285	034356	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8286						STOP^
  8287	034357	254 04 0 00 034360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8288	034360	324 00 0 00 034361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8289									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8290									;IN THE SUBTEST) TO LOOP ON ERROR^
  8291
  8292					;**********
  8293
  8294					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8295					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8296					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8297					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8298					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8299					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8300					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8301			010110		SN=SN+1
  8302		777777	777577			ZZ=ZZ+ZZ+1
  8303						IFE	<ZZ-1>,<ZZ=-2>
  8304	034361	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8305	034362	444 00 0 00 070364 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8306									;RESULT IN C(AC) NON-ZERO
  8307	034363	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8308						STOP^
  8309	034364	254 04 0 00 034365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8310	034365	324 00 0 00 034366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8312									;IN THE SUBTEST) TO LOOP ON ERROR^
  8313
  8314					;**********
  8315
  8316					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8317					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8318					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8319					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8320					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8321					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8322					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8323			010111		SN=SN+1
  8324		777777	777377			ZZ=ZZ+ZZ+1
  8325						IFE	<ZZ-1>,<ZZ=-2>
  8326	034366	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8327	034367	444 00 0 00 070365 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8328									;RESULT IN C(AC) NON-ZERO
  8329	034370	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8330						STOP^
  8331	034371	254 04 0 00 034372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8332	034372	324 00 0 00 034373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8333									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8334									;IN THE SUBTEST) TO LOOP ON ERROR^
  8335
  8336					;**********
  8337
  8338					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8339					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8340					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8341					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8342					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8343					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8344					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8345			010112		SN=SN+1
  8346		777777	776777			ZZ=ZZ+ZZ+1
  8347						IFE	<ZZ-1>,<ZZ=-2>
  8348	034373	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8349	034374	444 00 0 00 070366 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8350									;RESULT IN C(AC) NON-ZERO
  8351	034375	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8352						STOP^
  8353	034376	254 04 0 00 034377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8354	034377	324 00 0 00 034400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8355									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8356									;IN THE SUBTEST) TO LOOP ON ERROR^
  8357
  8358					;**********
  8359
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8360					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8361					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8362					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8363					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8364					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8365					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8366					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8367			010113		SN=SN+1
  8368		777777	775777			ZZ=ZZ+ZZ+1
  8369						IFE	<ZZ-1>,<ZZ=-2>
  8370	034400	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8371	034401	444 00 0 00 070367 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8372									;RESULT IN C(AC) NON-ZERO
  8373	034402	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8374						STOP^
  8375	034403	254 04 0 00 034404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8376	034404	324 00 0 00 034405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8377									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8378									;IN THE SUBTEST) TO LOOP ON ERROR^
  8379
  8380					;**********
  8381
  8382					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8383					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8384					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8385					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8386					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8387					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8388					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8389			010114		SN=SN+1
  8390		777777	773777			ZZ=ZZ+ZZ+1
  8391						IFE	<ZZ-1>,<ZZ=-2>
  8392	034405	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8393	034406	444 00 0 00 070370 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8394									;RESULT IN C(AC) NON-ZERO
  8395	034407	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8396						STOP^
  8397	034410	254 04 0 00 034411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8398	034411	324 00 0 00 034412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8399									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8400									;IN THE SUBTEST) TO LOOP ON ERROR^
  8401
  8402					;**********
  8403
  8404					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8405					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8406					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8407					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8408					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8409					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8410					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8411			010115		SN=SN+1
  8412		777777	767777			ZZ=ZZ+ZZ+1
  8413						IFE	<ZZ-1>,<ZZ=-2>
  8414	034412	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8415	034413	444 00 0 00 070371 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8416									;RESULT IN C(AC) NON-ZERO
  8417	034414	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8418						STOP^
  8419	034415	254 04 0 00 034416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8420	034416	324 00 0 00 034417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8422									;IN THE SUBTEST) TO LOOP ON ERROR^
  8423
  8424					;**********
  8425
  8426					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8427					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8428					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8429					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8430					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8431					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8432					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8433			010116		SN=SN+1
  8434		777777	757777			ZZ=ZZ+ZZ+1
  8435						IFE	<ZZ-1>,<ZZ=-2>
  8436	034417	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8437	034420	444 00 0 00 070372 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8438									;RESULT IN C(AC) NON-ZERO
  8439	034421	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8440						STOP^
  8441	034422	254 04 0 00 034423 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8442	034423	324 00 0 00 034424 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8443									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8444									;IN THE SUBTEST) TO LOOP ON ERROR^
  8445
  8446					;**********
  8447
  8448					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8449					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8450					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8451					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8452					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8453					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8454					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8455			010117		SN=SN+1
  8456		777777	737777			ZZ=ZZ+ZZ+1
  8457						IFE	<ZZ-1>,<ZZ=-2>
  8458	034424	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8459	034425	444 00 0 00 070373 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8460									;RESULT IN C(AC) NON-ZERO
  8461	034426	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8462						STOP^
  8463	034427	254 04 0 00 034430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8464	034430	324 00 0 00 034431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8465									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8466									;IN THE SUBTEST) TO LOOP ON ERROR^
  8467
  8468					;**********
  8469
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-14
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8470					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8471					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8472					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8473					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8474					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8475					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8476					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8477			010120		SN=SN+1
  8478		777777	677777			ZZ=ZZ+ZZ+1
  8479						IFE	<ZZ-1>,<ZZ=-2>
  8480	034431	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8481	034432	444 00 0 00 070374 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8482									;RESULT IN C(AC) NON-ZERO
  8483	034433	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8484						STOP^
  8485	034434	254 04 0 00 034435 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8486	034435	324 00 0 00 034436 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8487									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8488									;IN THE SUBTEST) TO LOOP ON ERROR^
  8489
  8490					;**********
  8491
  8492					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8493					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8494					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8495					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8496					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8497					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8498					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8499			010121		SN=SN+1
  8500		777777	577777			ZZ=ZZ+ZZ+1
  8501						IFE	<ZZ-1>,<ZZ=-2>
  8502	034436	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
  8503	034437	444 00 0 00 070375 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8504									;RESULT IN C(AC) NON-ZERO
  8505	034440	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8506						STOP^
  8507	034441	254 04 0 00 034442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8508	034442	324 00 0 00 034443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8509									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8510									;IN THE SUBTEST) TO LOOP ON ERROR^
  8511
  8512					;**********
  8513
  8514					;THIS TEST VERIFIES THAT THE RESULT OF AN EQV INSTRUCTION WHERE
  8515					;C(AC)=0 AND C(E) IS ALL ONES EXCEPT FOR A ZERO IN ONLY ONE BIT IS AN
  8516					;AC WHOSE CONTENTS IS NON-ZERO (A ONE RESULTS IN THE BIT WHERE
  8517					;E CONTAINS A ZERO).  THIS TEST IS REPEATED 36 TIMES SO THAT EACH BIT
  8518					;OF THE RESULT IS A ONE ONCE AND ONLY ONCE.  FIRST, THE AC IS
  8519					;CLEARED; THEN,EQV IS EXECUTED WITH ONE BIT OF E EQUAL TO ZERO.  THE 
  8520					;RESULT IN THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  8521			010122		SN=SN+1
  8522		777777	377777			ZZ=ZZ+ZZ+1
  8523						IFE	<ZZ-1>,<ZZ=-2>
  8524	034443	200 00 0 00 070253 		MOVE	[0]		;PRESET AC TO ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-15
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8525	034444	444 00 0 00 070255 		EQV	[XWD ZZ,-1]	;*EQV WITH C(AC)=0 AND ONE BIT OF C(E)=0 SHOULD
  8526									;RESULT IN C(AC) NON-ZERO
  8527	034445	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) NON-ZERO
  8528						STOP^
  8529	034446	254 04 0 00 034447 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8530	034447	324 00 0 00 034450 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8531									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8532									;IN THE SUBTEST) TO LOOP ON ERROR^
  8533
  8534					;**********
  8535
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8536					;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ZEROS
  8537					;EQUIVALENCED WITH AN E CONTAINING ALL ZEROS IS AN AC CONTAINING ALL
  8538					;ONES; AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES IS EQUIVALANCED
  8539					;WITH AN E CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC
  8540					;SHOULD BE ALL ZEROS.  FIRST, THE AC IS INITIALIZED TO ALL ZEROS, THEN,
  8541					;THIS AC IS EQUIVALENCED TWICE WITH AN E CONTAINING ALL ZEROS.  THE AC IS 
  8542					;THEN CHECKED FOR ALL ZEROS
  8543
  8544	034450	200 00 0 00 070253 	A10200:	MOVE	[0]		;CLEAR THE AC
  8545	034451	444 00 0 00 070253 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=ALL ONES
  8546	034452	444 00 0 00 070253 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
  8547	034453	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8548						STOP^
  8549	034454	254 04 0 00 034455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8550	034455	324 00 0 00 034456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8552									;IN THE SUBTEST) TO LOOP ON ERROR^
  8553
  8554					;**********
  8555
  8556					;THIS TEST VERIFIES THAT THE RESULT OF AN AC CONTAINING ALL ONES 
  8557					;EQUIVALENCED WITH AN E CONTAINING ALL ONES IS AN AC CONTAINING ALL ONES;
  8558					;AND FUTHERMORE, IF THIS AC CONTAINING ALL ONES ISEQUIVALENCED WITH AN E
  8559					;CONTAINING ALL ZEROS, THE FINAL RESULT IN THE AC SHOULD BE ALL ZEROS.
  8560					;FIRST, THE AC IS INITIALIZED TO ALL ONES; THEN, THIS AC IS 
  8561					;EQUIVALENCED WITH AN E OF ALL ONES.  NEXT, THIS SAME AC IS EQUIVALENCED
  8562					;WITH AN E OF ALL ZEROS.  THE AC IS THEN CHECKED FOR ALL ZEROS.
  8563
  8564	034456	200 00 0 00 070254 	A10300:	MOVE	[-1]		;SET C(AC) TO ALL ONES
  8565	034457	444 00 0 00 070254 		EQV	[-1]		;*EQV SHOULD RESULT IN C(AC) OF ALL ONES
  8566	034460	444 00 0 00 070253 		EQV	[0]		;*EQV SHOULD RESULT IN C(AC)=0
  8567	034461	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8568						STOP^
  8569	034462	254 04 0 00 034463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8570	034463	324 00 0 00 034464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8571									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8572									;IN THE SUBTEST) TO LOOP ON ERROR^
  8573
  8574					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8575			013000		SN=13000
  8576			000000			ZZ=0
  8577
  8578					A13000:	REPEAT	^D36,
  8579					<;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8580					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8581					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8582					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8583					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8584					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8585					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8586					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8587					SN=SN+1
  8588						ZZ=ZZ+ZZ
  8589						IFE	ZZ,<ZZ=1>
  8590						MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8591						AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8592						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8593						EQV	[0]		;RESULTS IN C(AC)=0
  8594						SKIPE			;PASS TEST IF C(AC)=0
  8595						STOP
  8596					
  8597					;**********
  8598					>
  8599					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8600					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8601					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8602					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8603					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8604					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8605					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8606					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8607			013001		SN=SN+1
  8608			000000			ZZ=ZZ+ZZ
  8609			000001			IFE	ZZ,<ZZ=1>
  8610	034464	200 00 0 00 070265 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8611	034465	404 00 0 00 070265 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8612	034466	444 00 0 00 070265 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8613	034467	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8614	034470	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8615						STOP^
  8616	034471	254 04 0 00 034472 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8617	034472	324 00 0 00 034473 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8619									;IN THE SUBTEST) TO LOOP ON ERROR^
  8620
  8621					;**********
  8622
  8623					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8624					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8625					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8626					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8627					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8628					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8629					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-1
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8630					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8631			013002		SN=SN+1
  8632			000002			ZZ=ZZ+ZZ
  8633						IFE	ZZ,<ZZ=1>
  8634	034473	200 00 0 00 070266 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8635	034474	404 00 0 00 070266 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8636	034475	444 00 0 00 070266 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8637	034476	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8638	034477	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8639						STOP^
  8640	034500	254 04 0 00 034501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8641	034501	324 00 0 00 034502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8642									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8643									;IN THE SUBTEST) TO LOOP ON ERROR^
  8644
  8645					;**********
  8646
  8647					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8648					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8649					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8650					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8651					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8652					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8653					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8654					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8655			013003		SN=SN+1
  8656			000004			ZZ=ZZ+ZZ
  8657						IFE	ZZ,<ZZ=1>
  8658	034502	200 00 0 00 070267 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8659	034503	404 00 0 00 070267 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8660	034504	444 00 0 00 070267 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8661	034505	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8662	034506	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8663						STOP^
  8664	034507	254 04 0 00 034510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8665	034510	324 00 0 00 034511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8666									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8667									;IN THE SUBTEST) TO LOOP ON ERROR^
  8668
  8669					;**********
  8670
  8671					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8672					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8673					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8674					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8675					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8676					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8677					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8678					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8679			013004		SN=SN+1
  8680			000010			ZZ=ZZ+ZZ
  8681						IFE	ZZ,<ZZ=1>
  8682	034511	200 00 0 00 070270 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8683	034512	404 00 0 00 070270 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8684	034513	444 00 0 00 070270 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-2
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8685	034514	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8686	034515	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8687						STOP^
  8688	034516	254 04 0 00 034517 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8689	034517	324 00 0 00 034520 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8691									;IN THE SUBTEST) TO LOOP ON ERROR^
  8692
  8693					;**********
  8694
  8695					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8696					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8697					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8698					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8699					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8700					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8701					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8702					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8703			013005		SN=SN+1
  8704			000020			ZZ=ZZ+ZZ
  8705						IFE	ZZ,<ZZ=1>
  8706	034520	200 00 0 00 070271 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8707	034521	404 00 0 00 070271 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8708	034522	444 00 0 00 070271 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8709	034523	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8710	034524	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8711						STOP^
  8712	034525	254 04 0 00 034526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8713	034526	324 00 0 00 034527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8715									;IN THE SUBTEST) TO LOOP ON ERROR^
  8716
  8717					;**********
  8718
  8719					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8720					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8721					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8722					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8723					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8724					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8725					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8726					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8727			013006		SN=SN+1
  8728			000040			ZZ=ZZ+ZZ
  8729						IFE	ZZ,<ZZ=1>
  8730	034527	200 00 0 00 070272 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8731	034530	404 00 0 00 070272 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8732	034531	444 00 0 00 070272 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8733	034532	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8734	034533	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8735						STOP^
  8736	034534	254 04 0 00 034535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8737	034535	324 00 0 00 034536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8738									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8739									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-3
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8740
  8741					;**********
  8742
  8743					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8744					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8745					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8746					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8747					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8748					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8749					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8750					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8751			013007		SN=SN+1
  8752			000100			ZZ=ZZ+ZZ
  8753						IFE	ZZ,<ZZ=1>
  8754	034536	200 00 0 00 070273 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8755	034537	404 00 0 00 070273 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8756	034540	444 00 0 00 070273 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8757	034541	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8758	034542	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8759						STOP^
  8760	034543	254 04 0 00 034544 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8761	034544	324 00 0 00 034545 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8762									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8763									;IN THE SUBTEST) TO LOOP ON ERROR^
  8764
  8765					;**********
  8766
  8767					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8768					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8769					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8770					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8771					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8772					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8773					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8774					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8775			013010		SN=SN+1
  8776			000200			ZZ=ZZ+ZZ
  8777						IFE	ZZ,<ZZ=1>
  8778	034545	200 00 0 00 070274 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8779	034546	404 00 0 00 070274 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8780	034547	444 00 0 00 070274 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8781	034550	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8782	034551	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8783						STOP^
  8784	034552	254 04 0 00 034553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8785	034553	324 00 0 00 034554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8787									;IN THE SUBTEST) TO LOOP ON ERROR^
  8788
  8789					;**********
  8790
  8791					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8792					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8793					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8794					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-4
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8795					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8796					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8797					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8798					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8799			013011		SN=SN+1
  8800			000400			ZZ=ZZ+ZZ
  8801						IFE	ZZ,<ZZ=1>
  8802	034554	200 00 0 00 070275 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8803	034555	404 00 0 00 070275 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8804	034556	444 00 0 00 070275 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8805	034557	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8806	034560	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8807						STOP^
  8808	034561	254 04 0 00 034562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8809	034562	324 00 0 00 034563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8811									;IN THE SUBTEST) TO LOOP ON ERROR^
  8812
  8813					;**********
  8814
  8815					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8816					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8817					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8818					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8819					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8820					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8821					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8822					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8823			013012		SN=SN+1
  8824			001000			ZZ=ZZ+ZZ
  8825						IFE	ZZ,<ZZ=1>
  8826	034563	200 00 0 00 070276 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8827	034564	404 00 0 00 070276 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8828	034565	444 00 0 00 070276 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8829	034566	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8830	034567	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8831						STOP^
  8832	034570	254 04 0 00 034571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8833	034571	324 00 0 00 034572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8835									;IN THE SUBTEST) TO LOOP ON ERROR^
  8836
  8837					;**********
  8838
  8839					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8840					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8841					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8842					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8843					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8844					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8845					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8846					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8847			013013		SN=SN+1
  8848			002000			ZZ=ZZ+ZZ
  8849						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-5
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8850	034572	200 00 0 00 070277 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8851	034573	404 00 0 00 070277 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8852	034574	444 00 0 00 070277 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8853	034575	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8854	034576	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8855						STOP^
  8856	034577	254 04 0 00 034600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8857	034600	324 00 0 00 034601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8859									;IN THE SUBTEST) TO LOOP ON ERROR^
  8860
  8861					;**********
  8862
  8863					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8864					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8865					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8866					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8867					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8868					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8869					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8870					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8871			013014		SN=SN+1
  8872			004000			ZZ=ZZ+ZZ
  8873						IFE	ZZ,<ZZ=1>
  8874	034601	200 00 0 00 070300 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8875	034602	404 00 0 00 070300 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8876	034603	444 00 0 00 070300 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8877	034604	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8878	034605	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8879						STOP^
  8880	034606	254 04 0 00 034607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8881	034607	324 00 0 00 034610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8883									;IN THE SUBTEST) TO LOOP ON ERROR^
  8884
  8885					;**********
  8886
  8887					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8888					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8889					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8890					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8891					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8892					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8893					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8894					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8895			013015		SN=SN+1
  8896			010000			ZZ=ZZ+ZZ
  8897						IFE	ZZ,<ZZ=1>
  8898	034610	200 00 0 00 070301 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8899	034611	404 00 0 00 070301 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8900	034612	444 00 0 00 070301 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8901	034613	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8902	034614	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8903						STOP^
  8904	034615	254 04 0 00 034616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-6
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8905	034616	324 00 0 00 034617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8906									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8907									;IN THE SUBTEST) TO LOOP ON ERROR^
  8908
  8909					;**********
  8910
  8911					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8912					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8913					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8914					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8915					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8916					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8917					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8918					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8919			013016		SN=SN+1
  8920			020000			ZZ=ZZ+ZZ
  8921						IFE	ZZ,<ZZ=1>
  8922	034617	200 00 0 00 070302 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8923	034620	404 00 0 00 070302 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8924	034621	444 00 0 00 070302 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8925	034622	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8926	034623	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8927						STOP^
  8928	034624	254 04 0 00 034625 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8929	034625	324 00 0 00 034626 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8930									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8931									;IN THE SUBTEST) TO LOOP ON ERROR^
  8932
  8933					;**********
  8934
  8935					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8936					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8937					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8938					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8939					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8940					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8941					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8942					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8943			013017		SN=SN+1
  8944			040000			ZZ=ZZ+ZZ
  8945						IFE	ZZ,<ZZ=1>
  8946	034626	200 00 0 00 070303 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8947	034627	404 00 0 00 070303 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8948	034630	444 00 0 00 070303 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8949	034631	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8950	034632	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8951						STOP^
  8952	034633	254 04 0 00 034634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8953	034634	324 00 0 00 034635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8954									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8955									;IN THE SUBTEST) TO LOOP ON ERROR^
  8956
  8957					;**********
  8958
  8959					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-7
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  8960					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8961					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8962					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8963					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8964					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8965					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8966					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8967			013020		SN=SN+1
  8968			100000			ZZ=ZZ+ZZ
  8969						IFE	ZZ,<ZZ=1>
  8970	034635	200 00 0 00 070304 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8971	034636	404 00 0 00 070304 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8972	034637	444 00 0 00 070304 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8973	034640	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8974	034641	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8975						STOP^
  8976	034642	254 04 0 00 034643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  8977	034643	324 00 0 00 034644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  8978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  8979									;IN THE SUBTEST) TO LOOP ON ERROR^
  8980
  8981					;**********
  8982
  8983					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  8984					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  8985					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  8986					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  8987					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  8988					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  8989					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  8990					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  8991			013021		SN=SN+1
  8992			200000			ZZ=ZZ+ZZ
  8993						IFE	ZZ,<ZZ=1>
  8994	034644	200 00 0 00 070305 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  8995	034645	404 00 0 00 070305 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  8996	034646	444 00 0 00 070305 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  8997	034647	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  8998	034650	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  8999						STOP^
  9000	034651	254 04 0 00 034652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9001	034652	324 00 0 00 034653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9002									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9003									;IN THE SUBTEST) TO LOOP ON ERROR^
  9004
  9005					;**********
  9006
  9007					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9008					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9009					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9010					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9011					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9012					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9013					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9014					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-8
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9015			013022		SN=SN+1
  9016			400000			ZZ=ZZ+ZZ
  9017						IFE	ZZ,<ZZ=1>
  9018	034653	200 00 0 00 070306 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9019	034654	404 00 0 00 070306 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9020	034655	444 00 0 00 070306 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9021	034656	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9022	034657	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9023						STOP^
  9024	034660	254 04 0 00 034661 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9025	034661	324 00 0 00 034662 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9026									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9027									;IN THE SUBTEST) TO LOOP ON ERROR^
  9028
  9029					;**********
  9030
  9031					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9032					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9033					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9034					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9035					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9036					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9037					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9038					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9039			013023		SN=SN+1
  9040		000001	000000			ZZ=ZZ+ZZ
  9041						IFE	ZZ,<ZZ=1>
  9042	034662	200 00 0 00 070307 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9043	034663	404 00 0 00 070307 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9044	034664	444 00 0 00 070307 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9045	034665	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9046	034666	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9047						STOP^
  9048	034667	254 04 0 00 034670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9049	034670	324 00 0 00 034671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9051									;IN THE SUBTEST) TO LOOP ON ERROR^
  9052
  9053					;**********
  9054
  9055					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9056					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9057					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9058					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9059					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9060					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9061					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9062					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9063			013024		SN=SN+1
  9064		000002	000000			ZZ=ZZ+ZZ
  9065						IFE	ZZ,<ZZ=1>
  9066	034671	200 00 0 00 070310 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9067	034672	404 00 0 00 070310 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9068	034673	444 00 0 00 070310 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9069	034674	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-9
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9070	034675	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9071						STOP^
  9072	034676	254 04 0 00 034677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9073	034677	324 00 0 00 034700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9074									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9075									;IN THE SUBTEST) TO LOOP ON ERROR^
  9076
  9077					;**********
  9078
  9079					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9080					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9081					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9082					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9083					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9084					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9085					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9086					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9087			013025		SN=SN+1
  9088		000004	000000			ZZ=ZZ+ZZ
  9089						IFE	ZZ,<ZZ=1>
  9090	034700	200 00 0 00 070311 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9091	034701	404 00 0 00 070311 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9092	034702	444 00 0 00 070311 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9093	034703	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9094	034704	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9095						STOP^
  9096	034705	254 04 0 00 034706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9097	034706	324 00 0 00 034707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9098									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9099									;IN THE SUBTEST) TO LOOP ON ERROR^
  9100
  9101					;**********
  9102
  9103					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9104					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9105					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9106					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9107					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9108					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9109					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9110					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9111			013026		SN=SN+1
  9112		000010	000000			ZZ=ZZ+ZZ
  9113						IFE	ZZ,<ZZ=1>
  9114	034707	200 00 0 00 070312 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9115	034710	404 00 0 00 070312 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9116	034711	444 00 0 00 070312 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9117	034712	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9118	034713	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9119						STOP^
  9120	034714	254 04 0 00 034715 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9121	034715	324 00 0 00 034716 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9122									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9123									;IN THE SUBTEST) TO LOOP ON ERROR^
  9124
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-10
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9125					;**********
  9126
  9127					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9128					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9129					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9130					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9131					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9132					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9133					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9134					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9135			013027		SN=SN+1
  9136		000020	000000			ZZ=ZZ+ZZ
  9137						IFE	ZZ,<ZZ=1>
  9138	034716	200 00 0 00 070313 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9139	034717	404 00 0 00 070313 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9140	034720	444 00 0 00 070313 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9141	034721	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9142	034722	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9143						STOP^
  9144	034723	254 04 0 00 034724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9145	034724	324 00 0 00 034725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9146									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9147									;IN THE SUBTEST) TO LOOP ON ERROR^
  9148
  9149					;**********
  9150
  9151					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9152					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9153					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9154					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9155					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9156					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9157					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9158					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9159			013030		SN=SN+1
  9160		000040	000000			ZZ=ZZ+ZZ
  9161						IFE	ZZ,<ZZ=1>
  9162	034725	200 00 0 00 070314 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9163	034726	404 00 0 00 070314 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9164	034727	444 00 0 00 070314 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9165	034730	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9166	034731	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9167						STOP^
  9168	034732	254 04 0 00 034733 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9169	034733	324 00 0 00 034734 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9170									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9171									;IN THE SUBTEST) TO LOOP ON ERROR^
  9172
  9173					;**********
  9174
  9175					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9176					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9177					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9178					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9179					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-11
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9180					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9181					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9182					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9183			013031		SN=SN+1
  9184		000100	000000			ZZ=ZZ+ZZ
  9185						IFE	ZZ,<ZZ=1>
  9186	034734	200 00 0 00 070315 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9187	034735	404 00 0 00 070315 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9188	034736	444 00 0 00 070315 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9189	034737	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9190	034740	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9191						STOP^
  9192	034741	254 04 0 00 034742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9193	034742	324 00 0 00 034743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9194									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9195									;IN THE SUBTEST) TO LOOP ON ERROR^
  9196
  9197					;**********
  9198
  9199					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9200					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9201					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9202					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9203					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9204					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9205					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9206					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9207			013032		SN=SN+1
  9208		000200	000000			ZZ=ZZ+ZZ
  9209						IFE	ZZ,<ZZ=1>
  9210	034743	200 00 0 00 070316 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9211	034744	404 00 0 00 070316 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9212	034745	444 00 0 00 070316 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9213	034746	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9214	034747	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9215						STOP^
  9216	034750	254 04 0 00 034751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9217	034751	324 00 0 00 034752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9218									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9219									;IN THE SUBTEST) TO LOOP ON ERROR^
  9220
  9221					;**********
  9222
  9223					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9224					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9225					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9226					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9227					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9228					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9229					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9230					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9231			013033		SN=SN+1
  9232		000400	000000			ZZ=ZZ+ZZ
  9233						IFE	ZZ,<ZZ=1>
  9234	034752	200 00 0 00 070264 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-12
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9235	034753	404 00 0 00 070264 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9236	034754	444 00 0 00 070264 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9237	034755	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9238	034756	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9239						STOP^
  9240	034757	254 04 0 00 034760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9241	034760	324 00 0 00 034761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9242									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9243									;IN THE SUBTEST) TO LOOP ON ERROR^
  9244
  9245					;**********
  9246
  9247					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9248					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9249					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9250					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9251					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9252					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9253					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9254					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9255			013034		SN=SN+1
  9256		001000	000000			ZZ=ZZ+ZZ
  9257						IFE	ZZ,<ZZ=1>
  9258	034761	200 00 0 00 070317 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9259	034762	404 00 0 00 070317 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9260	034763	444 00 0 00 070317 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9261	034764	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9262	034765	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9263						STOP^
  9264	034766	254 04 0 00 034767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9265	034767	324 00 0 00 034770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9267									;IN THE SUBTEST) TO LOOP ON ERROR^
  9268
  9269					;**********
  9270
  9271					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9272					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9273					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9274					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9275					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9276					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9277					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9278					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9279			013035		SN=SN+1
  9280		002000	000000			ZZ=ZZ+ZZ
  9281						IFE	ZZ,<ZZ=1>
  9282	034770	200 00 0 00 070320 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9283	034771	404 00 0 00 070320 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9284	034772	444 00 0 00 070320 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9285	034773	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9286	034774	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9287						STOP^
  9288	034775	254 04 0 00 034776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9289	034776	324 00 0 00 034777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-13
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9290									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9291									;IN THE SUBTEST) TO LOOP ON ERROR^
  9292
  9293					;**********
  9294
  9295					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9296					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9297					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9298					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9299					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9300					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9301					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9302					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9303			013036		SN=SN+1
  9304		004000	000000			ZZ=ZZ+ZZ
  9305						IFE	ZZ,<ZZ=1>
  9306	034777	200 00 0 00 070321 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9307	035000	404 00 0 00 070321 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9308	035001	444 00 0 00 070321 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9309	035002	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9310	035003	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9311						STOP^
  9312	035004	254 04 0 00 035005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9313	035005	324 00 0 00 035006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9314									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9315									;IN THE SUBTEST) TO LOOP ON ERROR^
  9316
  9317					;**********
  9318
  9319					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9320					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9321					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9322					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9323					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9324					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9325					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9326					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9327			013037		SN=SN+1
  9328		010000	000000			ZZ=ZZ+ZZ
  9329						IFE	ZZ,<ZZ=1>
  9330	035006	200 00 0 00 070322 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9331	035007	404 00 0 00 070322 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9332	035010	444 00 0 00 070322 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9333	035011	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9334	035012	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9335						STOP^
  9336	035013	254 04 0 00 035014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9337	035014	324 00 0 00 035015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9338									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9339									;IN THE SUBTEST) TO LOOP ON ERROR^
  9340
  9341					;**********
  9342
  9343					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9344					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-14
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9345					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9346					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9347					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9348					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9349					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9350					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9351			013040		SN=SN+1
  9352		020000	000000			ZZ=ZZ+ZZ
  9353						IFE	ZZ,<ZZ=1>
  9354	035015	200 00 0 00 070323 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9355	035016	404 00 0 00 070323 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9356	035017	444 00 0 00 070323 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9357	035020	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9358	035021	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9359						STOP^
  9360	035022	254 04 0 00 035023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9361	035023	324 00 0 00 035024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9362									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9363									;IN THE SUBTEST) TO LOOP ON ERROR^
  9364
  9365					;**********
  9366
  9367					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9368					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9369					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9370					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9371					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9372					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9373					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9374					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9375			013041		SN=SN+1
  9376		040000	000000			ZZ=ZZ+ZZ
  9377						IFE	ZZ,<ZZ=1>
  9378	035024	200 00 0 00 070324 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9379	035025	404 00 0 00 070324 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9380	035026	444 00 0 00 070324 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9381	035027	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9382	035030	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9383						STOP^
  9384	035031	254 04 0 00 035032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9385	035032	324 00 0 00 035033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9386									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9387									;IN THE SUBTEST) TO LOOP ON ERROR^
  9388
  9389					;**********
  9390
  9391					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9392					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9393					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9394					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9395					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9396					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9397					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9398					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9399			013042		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-15
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9400		100000	000000			ZZ=ZZ+ZZ
  9401						IFE	ZZ,<ZZ=1>
  9402	035033	200 00 0 00 070325 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9403	035034	404 00 0 00 070325 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9404	035035	444 00 0 00 070325 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9405	035036	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9406	035037	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9407						STOP^
  9408	035040	254 04 0 00 035041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9409	035041	324 00 0 00 035042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9410									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9411									;IN THE SUBTEST) TO LOOP ON ERROR^
  9412
  9413					;**********
  9414
  9415					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9416					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9417					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9418					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9419					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9420					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9421					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9422					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9423			013043		SN=SN+1
  9424		200000	000000			ZZ=ZZ+ZZ
  9425						IFE	ZZ,<ZZ=1>
  9426	035042	200 00 0 00 070326 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9427	035043	404 00 0 00 070326 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9428	035044	444 00 0 00 070326 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9429	035045	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9430	035046	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9431						STOP^
  9432	035047	254 04 0 00 035050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9433	035050	324 00 0 00 035051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9435									;IN THE SUBTEST) TO LOOP ON ERROR^
  9436
  9437					;**********
  9438
  9439					;THIS TEST CHECKS THE 'AND' INSTRUCTION AND THE ADDER ON A ONE-BIT-AT-A-TIME BASIS.
  9440					;THE AC IS LOADED WITH ALL ZEROS EXCEPT FOR ONE BIT EQUAL TO ONE; THE AC IS THEN
  9441					;ANDED WITH C(E) WHERE C(E)=C(AC).  THE NET RESULT SHOULD BE NO CHANGE TO C(AC).
  9442					;NEXT, THE AC IS EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9443					;BE ALL ONES IN THE AC.  THE AC IS THEN EQUIVALENCED WITH A WORD OF ALL ZEROS,
  9444					;WHICH SHOULD RESULT IN C(AC)=0.  THE AC IS CHECKED FOR ALL ZEROS.
  9445					;IF C(AC) IS NON-ZERO, THE TEST FAILS.  THIS TEST IS REPEATED 36 TIMES TO
  9446					;RIPPLE A ONE THROUGH EVERY BIT OF THE AC.
  9447			013044		SN=SN+1
  9448		400000	000000			ZZ=ZZ+ZZ
  9449						IFE	ZZ,<ZZ=1>
  9450	035051	200 00 0 00 070256 		MOVE	[ZZ]		;SETUP AC WITH A ONE IN ONLY ONE BIT
  9451	035052	404 00 0 00 070256 		AND	[ZZ]		;*AND FLOATING ONE WITH ITSELF SHOULD NOT CHANGE C(AC)
  9452	035053	444 00 0 00 070256 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9453	035054	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9454	035055	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-16
DFKAA1	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS (SETM, SETZ, AND, XOR, EQV)

  9455						STOP^
  9456	035056	254 04 0 00 035057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9457	035057	324 00 0 00 035060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9458									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9459									;IN THE SUBTEST) TO LOOP ON ERROR^
  9460
  9461					;**********
  9462
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9463					SUBTTL	TEST OF THE ADD INSTRUCTION
  9464
  9465					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED
  9466					;TO ADD A NON-ZERO NUMBER CONTAINED IN E TO AN AC CONTAINING ALL ZEROS,
  9467					;THE RESULT IS A NON-ZERO NUMBER IN THE AC.  FIRST, THE AC IS CLEARED;
  9468					;THEN, ANON-ZERO POSITIVE NUMBER IS ADDED TO THE AC USING THE ADD 
  9469					;INSTRUCTION.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9470
  9471	035060	200 00 0 00 070253 		A10400:	MOVE	[0]		;PRESET AC TO ALL ZEROS
  9472	035061	270 00 0 00 070376 		ADD	[123456765432]	;*ADD OF A NON-ZERO NUMBER TO AN AC OF ALL
  9473									;ZEROS SHOULD RESULT
  9474									;IN AN AC CONTAINING A NON-ZERO NUMBER
  9475	035062	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9476						STOP^
  9477	035063	254 04 0 00 035064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9478	035064	324 00 0 00 035065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9480									;IN THE SUBTEST) TO LOOP ON ERROR^
  9481
  9482					;AD ADD [ADC1], AD ADD EN [ADC1],
  9483					;F CYC ACT EN A [F1], AD FM + FETCH EN A [ADFP],
  9484					;F CYC ACT EN C[F1], IR ADSUB [IR1], IRXX [IR1]
  9485
  9486					;**********
  9487
  9488					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9489					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
  9490					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9491					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
  9492					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9493
  9494	035065	200 00 0 00 070376 	A10500:	MOVE	[123456765432]	;PRESET AC WITH A NON-ZERO NUMBER
  9495	035066	270 00 0 00 070253 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC
  9496									;CONTAINING A NON-ZERO NUMBER
  9497									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9498	035067	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9499						STOP^
  9500	035070	254 04 0 00 035071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9501	035071	324 00 0 00 035072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9502									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9503									;IN THE SUBTEST) TO LOOP ON ERROR^
  9504
  9505					;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F [E],
  9506					;AR AD ET2 EN [ARMA], IR ADSUB [IR1]
  9507
  9508					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9509					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9510					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
  9511					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9512					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
  9513					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9514
  9515	035072	200 00 0 00 070377 	A10600:	MOVE	[XWD 123456,0]	;PRESET AC WITH A NON-ZERO NUMBER
  9516	035073	270 00 0 00 070253 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
  9517									;A NON-ZERO NUMBER SHOULD RESULT IN AN AC
  9518									;CONTAINING A NON-ZERO NUMBER
  9519	035074	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9520						STOP^
  9521	035075	254 04 0 00 035076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9522	035076	324 00 0 00 035077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9523									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9524									;IN THE SUBTEST) TO LOOP ON ERROR^
  9525
  9526					;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F[E],
  9527					;AR AD ET2 EN [ARMA], IR AD SUB [IR1]
  9528
  9529					;*********
  9530
  9531					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9532					;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
  9533					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9534					;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
  9535					; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9536
  9537	035077	200 00 0 00 070400 	A10700:	MOVE	[123456]	;PRESET AC WITH A NON-ZERO NUMBER
  9538	035100	270 00 0 00 070253 		ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
  9539									;A NON-ZERO NUMBER
  9540									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9541	035101	336 00 0 00 000000 		SKIPN			;PASS TEST IS C(AC) IS NON-ZERO
  9542						STOP^
  9543	035102	254 04 0 00 035103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9544	035103	324 00 0 00 035104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9545									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9546									;IN THE SUBTEST) TO LOOP ON ERROR^
  9547
  9548					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9549					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9550					;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
  9551					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9552					;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
  9553					;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9554
  9555	035104	200 00 0 00 070253 	A13300:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
  9556	035105	270 00 0 00 070377 		ADD	[123456,,0]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
  9557									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9558	035106	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9559						STOP^
  9560	035107	254 04 0 00 035110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9561	035110	324 00 0 00 035111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9562									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9563									;IN THE SUBTEST) TO LOOP ON ERROR^
  9564
  9565					;**********
  9566
  9567					;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
  9568					;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
  9569					;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
  9570					;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
  9571					;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO
  9572
  9573	035111	200 00 0 00 070253 	A13400:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
  9574	035112	270 00 0 00 070400 		ADD	[123456]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
  9575									;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
  9576	035113	336 00 0 00 000000 		SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
  9577						STOP^
  9578	035114	254 04 0 00 035115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9579	035115	324 00 0 00 035116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9580									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9581									;IN THE SUBTEST) TO LOOP ON ERROR^
  9582
  9583					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9584					;ADD ZERO TO A RIPPLED ONE
  9585
  9586			011000		SN=11000
  9587			000000			ZZ=0
  9588
  9589					A11000:	REPEAT	^D36,
  9590					<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9591					;A WORD OF ALL ZEROS IS ADDED TO AN
  9592					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9593					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9594					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9595					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9596					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9597					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9598					;EVERY BIT OF THE AC.
  9599					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9600					SN=SN+1
  9601						ZZ=ZZ+ZZ
  9602						IFE	ZZ,<ZZ=1>
  9603						MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9604						ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9605						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9606						EQV	[0]		;RESULTS IN C(AC)=0
  9607						SKIPE			;PASS TEST IF C(AC)=0
  9608						STOP
  9609					
  9610					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9611					;IR ADDX [IR1], IR ADSUB [IR1]
  9612					
  9613					;**********
  9614					PAGE
  9615					>
  9616					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9617					;A WORD OF ALL ZEROS IS ADDED TO AN
  9618					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9619					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9620					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9621					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9622					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9623					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9624					;EVERY BIT OF THE AC.
  9625					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9626			011001		SN=SN+1
  9627			000000			ZZ=ZZ+ZZ
  9628			000001			IFE	ZZ,<ZZ=1>
  9629	035116	200 00 0 00 070265 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9630	035117	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9631	035120	444 00 0 00 070265 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9632	035121	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9633	035122	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9634						STOP^
  9635	035123	254 04 0 00 035124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9636	035124	324 00 0 00 035125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9638									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9639
  9640					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9641					;IR ADDX [IR1], IR ADSUB [IR1]
  9642
  9643					;**********
  9644					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9645
  9646					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9647					;A WORD OF ALL ZEROS IS ADDED TO AN
  9648					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9649					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9650					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9651					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9652					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9653					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9654					;EVERY BIT OF THE AC.
  9655					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9656			011002		SN=SN+1
  9657			000002			ZZ=ZZ+ZZ
  9658						IFE	ZZ,<ZZ=1>
  9659	035125	200 00 0 00 070266 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9660	035126	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9661	035127	444 00 0 00 070266 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9662	035130	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9663	035131	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9664						STOP^
  9665	035132	254 04 0 00 035133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9666	035133	324 00 0 00 035134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9667									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9668									;IN THE SUBTEST) TO LOOP ON ERROR^
  9669
  9670					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9671					;IR ADDX [IR1], IR ADSUB [IR1]
  9672
  9673					;**********
  9674					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9675
  9676					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9677					;A WORD OF ALL ZEROS IS ADDED TO AN
  9678					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9679					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9680					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9681					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9682					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9683					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9684					;EVERY BIT OF THE AC.
  9685					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9686			011003		SN=SN+1
  9687			000004			ZZ=ZZ+ZZ
  9688						IFE	ZZ,<ZZ=1>
  9689	035134	200 00 0 00 070267 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9690	035135	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9691	035136	444 00 0 00 070267 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9692	035137	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9693	035140	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9694						STOP^
  9695	035141	254 04 0 00 035142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9696	035142	324 00 0 00 035143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9698									;IN THE SUBTEST) TO LOOP ON ERROR^
  9699
  9700					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9701					;IR ADDX [IR1], IR ADSUB [IR1]
  9702
  9703					;**********
  9704					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9705
  9706					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9707					;A WORD OF ALL ZEROS IS ADDED TO AN
  9708					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9709					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9710					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9711					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9712					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9713					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9714					;EVERY BIT OF THE AC.
  9715					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9716			011004		SN=SN+1
  9717			000010			ZZ=ZZ+ZZ
  9718						IFE	ZZ,<ZZ=1>
  9719	035143	200 00 0 00 070270 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9720	035144	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9721	035145	444 00 0 00 070270 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9722	035146	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9723	035147	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9724						STOP^
  9725	035150	254 04 0 00 035151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9726	035151	324 00 0 00 035152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9727									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9728									;IN THE SUBTEST) TO LOOP ON ERROR^
  9729
  9730					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9731					;IR ADDX [IR1], IR ADSUB [IR1]
  9732
  9733					;**********
  9734					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9735
  9736					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9737					;A WORD OF ALL ZEROS IS ADDED TO AN
  9738					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9739					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9740					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9741					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9742					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9743					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9744					;EVERY BIT OF THE AC.
  9745					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9746			011005		SN=SN+1
  9747			000020			ZZ=ZZ+ZZ
  9748						IFE	ZZ,<ZZ=1>
  9749	035152	200 00 0 00 070271 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9750	035153	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9751	035154	444 00 0 00 070271 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9752	035155	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9753	035156	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9754						STOP^
  9755	035157	254 04 0 00 035160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9756	035160	324 00 0 00 035161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9757									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9758									;IN THE SUBTEST) TO LOOP ON ERROR^
  9759
  9760					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9761					;IR ADDX [IR1], IR ADSUB [IR1]
  9762
  9763					;**********
  9764					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9765
  9766					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9767					;A WORD OF ALL ZEROS IS ADDED TO AN
  9768					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9769					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9770					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9771					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9772					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9773					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9774					;EVERY BIT OF THE AC.
  9775					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9776			011006		SN=SN+1
  9777			000040			ZZ=ZZ+ZZ
  9778						IFE	ZZ,<ZZ=1>
  9779	035161	200 00 0 00 070272 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9780	035162	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9781	035163	444 00 0 00 070272 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9782	035164	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9783	035165	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9784						STOP^
  9785	035166	254 04 0 00 035167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9786	035167	324 00 0 00 035170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9787									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9788									;IN THE SUBTEST) TO LOOP ON ERROR^
  9789
  9790					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9791					;IR ADDX [IR1], IR ADSUB [IR1]
  9792
  9793					;**********
  9794					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9795
  9796					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9797					;A WORD OF ALL ZEROS IS ADDED TO AN
  9798					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9799					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9800					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9801					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9802					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9803					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9804					;EVERY BIT OF THE AC.
  9805					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9806			011007		SN=SN+1
  9807			000100			ZZ=ZZ+ZZ
  9808						IFE	ZZ,<ZZ=1>
  9809	035170	200 00 0 00 070273 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9810	035171	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9811	035172	444 00 0 00 070273 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9812	035173	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9813	035174	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9814						STOP^
  9815	035175	254 04 0 00 035176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9816	035176	324 00 0 00 035177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9818									;IN THE SUBTEST) TO LOOP ON ERROR^
  9819
  9820					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9821					;IR ADDX [IR1], IR ADSUB [IR1]
  9822
  9823					;**********
  9824					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9825
  9826					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9827					;A WORD OF ALL ZEROS IS ADDED TO AN
  9828					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9829					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9830					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9831					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9832					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9833					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9834					;EVERY BIT OF THE AC.
  9835					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9836			011010		SN=SN+1
  9837			000200			ZZ=ZZ+ZZ
  9838						IFE	ZZ,<ZZ=1>
  9839	035177	200 00 0 00 070274 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9840	035200	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9841	035201	444 00 0 00 070274 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9842	035202	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9843	035203	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9844						STOP^
  9845	035204	254 04 0 00 035205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9846	035205	324 00 0 00 035206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9847									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9848									;IN THE SUBTEST) TO LOOP ON ERROR^
  9849
  9850					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9851					;IR ADDX [IR1], IR ADSUB [IR1]
  9852
  9853					;**********
  9854					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-9
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9855
  9856					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9857					;A WORD OF ALL ZEROS IS ADDED TO AN
  9858					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9859					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9860					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9861					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9862					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9863					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9864					;EVERY BIT OF THE AC.
  9865					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9866			011011		SN=SN+1
  9867			000400			ZZ=ZZ+ZZ
  9868						IFE	ZZ,<ZZ=1>
  9869	035206	200 00 0 00 070275 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9870	035207	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9871	035210	444 00 0 00 070275 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9872	035211	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9873	035212	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9874						STOP^
  9875	035213	254 04 0 00 035214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9876	035214	324 00 0 00 035215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9878									;IN THE SUBTEST) TO LOOP ON ERROR^
  9879
  9880					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9881					;IR ADDX [IR1], IR ADSUB [IR1]
  9882
  9883					;**********
  9884					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-10
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9885
  9886					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9887					;A WORD OF ALL ZEROS IS ADDED TO AN
  9888					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9889					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9890					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9891					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9892					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9893					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9894					;EVERY BIT OF THE AC.
  9895					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9896			011012		SN=SN+1
  9897			001000			ZZ=ZZ+ZZ
  9898						IFE	ZZ,<ZZ=1>
  9899	035215	200 00 0 00 070276 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9900	035216	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9901	035217	444 00 0 00 070276 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9902	035220	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9903	035221	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9904						STOP^
  9905	035222	254 04 0 00 035223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9906	035223	324 00 0 00 035224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9907									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9908									;IN THE SUBTEST) TO LOOP ON ERROR^
  9909
  9910					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9911					;IR ADDX [IR1], IR ADSUB [IR1]
  9912
  9913					;**********
  9914					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-11
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9915
  9916					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9917					;A WORD OF ALL ZEROS IS ADDED TO AN
  9918					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9919					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9920					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9921					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9922					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9923					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9924					;EVERY BIT OF THE AC.
  9925					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9926			011013		SN=SN+1
  9927			002000			ZZ=ZZ+ZZ
  9928						IFE	ZZ,<ZZ=1>
  9929	035224	200 00 0 00 070277 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9930	035225	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9931	035226	444 00 0 00 070277 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9932	035227	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9933	035230	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9934						STOP^
  9935	035231	254 04 0 00 035232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9936	035232	324 00 0 00 035233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9937									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9938									;IN THE SUBTEST) TO LOOP ON ERROR^
  9939
  9940					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9941					;IR ADDX [IR1], IR ADSUB [IR1]
  9942
  9943					;**********
  9944					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-12
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9945
  9946					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9947					;A WORD OF ALL ZEROS IS ADDED TO AN
  9948					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9949					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9950					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9951					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9952					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9953					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9954					;EVERY BIT OF THE AC.
  9955					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9956			011014		SN=SN+1
  9957			004000			ZZ=ZZ+ZZ
  9958						IFE	ZZ,<ZZ=1>
  9959	035233	200 00 0 00 070300 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9960	035234	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9961	035235	444 00 0 00 070300 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9962	035236	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9963	035237	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9964						STOP^
  9965	035240	254 04 0 00 035241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9966	035241	324 00 0 00 035242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9967									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9968									;IN THE SUBTEST) TO LOOP ON ERROR^
  9969
  9970					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
  9971					;IR ADDX [IR1], IR ADSUB [IR1]
  9972
  9973					;**********
  9974					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-13
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

  9975
  9976					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
  9977					;A WORD OF ALL ZEROS IS ADDED TO AN
  9978					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
  9979					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
  9980					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
  9981					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
  9982					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
  9983					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
  9984					;EVERY BIT OF THE AC.
  9985					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
  9986			011015		SN=SN+1
  9987			010000			ZZ=ZZ+ZZ
  9988						IFE	ZZ,<ZZ=1>
  9989	035242	200 00 0 00 070301 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
  9990	035243	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
  9991	035244	444 00 0 00 070301 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
  9992	035245	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
  9993	035246	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
  9994						STOP^
  9995	035247	254 04 0 00 035250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
  9996	035250	324 00 0 00 035251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
  9997									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
  9998									;IN THE SUBTEST) TO LOOP ON ERROR^
  9999
 10000					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10001					;IR ADDX [IR1], IR ADSUB [IR1]
 10002
 10003					;**********
 10004					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-14
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10005
 10006					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10007					;A WORD OF ALL ZEROS IS ADDED TO AN
 10008					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10009					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10010					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10011					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10012					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10013					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10014					;EVERY BIT OF THE AC.
 10015					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10016			011016		SN=SN+1
 10017			020000			ZZ=ZZ+ZZ
 10018						IFE	ZZ,<ZZ=1>
 10019	035251	200 00 0 00 070302 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10020	035252	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10021	035253	444 00 0 00 070302 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10022	035254	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10023	035255	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10024						STOP^
 10025	035256	254 04 0 00 035257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10026	035257	324 00 0 00 035260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10027									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10028									;IN THE SUBTEST) TO LOOP ON ERROR^
 10029
 10030					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10031					;IR ADDX [IR1], IR ADSUB [IR1]
 10032
 10033					;**********
 10034					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-15
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10035
 10036					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10037					;A WORD OF ALL ZEROS IS ADDED TO AN
 10038					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10039					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10040					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10041					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10042					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10043					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10044					;EVERY BIT OF THE AC.
 10045					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10046			011017		SN=SN+1
 10047			040000			ZZ=ZZ+ZZ
 10048						IFE	ZZ,<ZZ=1>
 10049	035260	200 00 0 00 070303 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10050	035261	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10051	035262	444 00 0 00 070303 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10052	035263	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10053	035264	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10054						STOP^
 10055	035265	254 04 0 00 035266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10056	035266	324 00 0 00 035267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10058									;IN THE SUBTEST) TO LOOP ON ERROR^
 10059
 10060					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10061					;IR ADDX [IR1], IR ADSUB [IR1]
 10062
 10063					;**********
 10064					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-16
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10065
 10066					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10067					;A WORD OF ALL ZEROS IS ADDED TO AN
 10068					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10069					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10070					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10071					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10072					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10073					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10074					;EVERY BIT OF THE AC.
 10075					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10076			011020		SN=SN+1
 10077			100000			ZZ=ZZ+ZZ
 10078						IFE	ZZ,<ZZ=1>
 10079	035267	200 00 0 00 070304 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10080	035270	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10081	035271	444 00 0 00 070304 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10082	035272	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10083	035273	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10084						STOP^
 10085	035274	254 04 0 00 035275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10086	035275	324 00 0 00 035276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10087									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10088									;IN THE SUBTEST) TO LOOP ON ERROR^
 10089
 10090					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10091					;IR ADDX [IR1], IR ADSUB [IR1]
 10092
 10093					;**********
 10094					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-17
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10095
 10096					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10097					;A WORD OF ALL ZEROS IS ADDED TO AN
 10098					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10099					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10100					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10101					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10102					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10103					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10104					;EVERY BIT OF THE AC.
 10105					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10106			011021		SN=SN+1
 10107			200000			ZZ=ZZ+ZZ
 10108						IFE	ZZ,<ZZ=1>
 10109	035276	200 00 0 00 070305 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10110	035277	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10111	035300	444 00 0 00 070305 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10112	035301	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10113	035302	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10114						STOP^
 10115	035303	254 04 0 00 035304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10116	035304	324 00 0 00 035305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10118									;IN THE SUBTEST) TO LOOP ON ERROR^
 10119
 10120					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10121					;IR ADDX [IR1], IR ADSUB [IR1]
 10122
 10123					;**********
 10124					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-18
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10125
 10126					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10127					;A WORD OF ALL ZEROS IS ADDED TO AN
 10128					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10129					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10130					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10131					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10132					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10133					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10134					;EVERY BIT OF THE AC.
 10135					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10136			011022		SN=SN+1
 10137			400000			ZZ=ZZ+ZZ
 10138						IFE	ZZ,<ZZ=1>
 10139	035305	200 00 0 00 070306 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10140	035306	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10141	035307	444 00 0 00 070306 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10142	035310	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10143	035311	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10144						STOP^
 10145	035312	254 04 0 00 035313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10146	035313	324 00 0 00 035314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10147									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10148									;IN THE SUBTEST) TO LOOP ON ERROR^
 10149
 10150					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10151					;IR ADDX [IR1], IR ADSUB [IR1]
 10152
 10153					;**********
 10154					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-19
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10155
 10156					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10157					;A WORD OF ALL ZEROS IS ADDED TO AN
 10158					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10159					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10160					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10161					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10162					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10163					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10164					;EVERY BIT OF THE AC.
 10165					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10166			011023		SN=SN+1
 10167		000001	000000			ZZ=ZZ+ZZ
 10168						IFE	ZZ,<ZZ=1>
 10169	035314	200 00 0 00 070307 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10170	035315	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10171	035316	444 00 0 00 070307 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10172	035317	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10173	035320	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10174						STOP^
 10175	035321	254 04 0 00 035322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10176	035322	324 00 0 00 035323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10178									;IN THE SUBTEST) TO LOOP ON ERROR^
 10179
 10180					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10181					;IR ADDX [IR1], IR ADSUB [IR1]
 10182
 10183					;**********
 10184					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-20
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10185
 10186					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10187					;A WORD OF ALL ZEROS IS ADDED TO AN
 10188					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10189					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10190					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10191					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10192					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10193					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10194					;EVERY BIT OF THE AC.
 10195					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10196			011024		SN=SN+1
 10197		000002	000000			ZZ=ZZ+ZZ
 10198						IFE	ZZ,<ZZ=1>
 10199	035323	200 00 0 00 070310 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10200	035324	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10201	035325	444 00 0 00 070310 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10202	035326	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10203	035327	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10204						STOP^
 10205	035330	254 04 0 00 035331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10206	035331	324 00 0 00 035332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10208									;IN THE SUBTEST) TO LOOP ON ERROR^
 10209
 10210					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10211					;IR ADDX [IR1], IR ADSUB [IR1]
 10212
 10213					;**********
 10214					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-21
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10215
 10216					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10217					;A WORD OF ALL ZEROS IS ADDED TO AN
 10218					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10219					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10220					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10221					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10222					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10223					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10224					;EVERY BIT OF THE AC.
 10225					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10226			011025		SN=SN+1
 10227		000004	000000			ZZ=ZZ+ZZ
 10228						IFE	ZZ,<ZZ=1>
 10229	035332	200 00 0 00 070311 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10230	035333	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10231	035334	444 00 0 00 070311 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10232	035335	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10233	035336	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10234						STOP^
 10235	035337	254 04 0 00 035340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10236	035340	324 00 0 00 035341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10237									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10238									;IN THE SUBTEST) TO LOOP ON ERROR^
 10239
 10240					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10241					;IR ADDX [IR1], IR ADSUB [IR1]
 10242
 10243					;**********
 10244					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-22
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10245
 10246					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10247					;A WORD OF ALL ZEROS IS ADDED TO AN
 10248					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10249					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10250					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10251					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10252					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10253					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10254					;EVERY BIT OF THE AC.
 10255					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10256			011026		SN=SN+1
 10257		000010	000000			ZZ=ZZ+ZZ
 10258						IFE	ZZ,<ZZ=1>
 10259	035341	200 00 0 00 070312 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10260	035342	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10261	035343	444 00 0 00 070312 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10262	035344	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10263	035345	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10264						STOP^
 10265	035346	254 04 0 00 035347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10266	035347	324 00 0 00 035350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10267									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10268									;IN THE SUBTEST) TO LOOP ON ERROR^
 10269
 10270					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10271					;IR ADDX [IR1], IR ADSUB [IR1]
 10272
 10273					;**********
 10274					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-23
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10275
 10276					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10277					;A WORD OF ALL ZEROS IS ADDED TO AN
 10278					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10279					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10280					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10281					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10282					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10283					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10284					;EVERY BIT OF THE AC.
 10285					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10286			011027		SN=SN+1
 10287		000020	000000			ZZ=ZZ+ZZ
 10288						IFE	ZZ,<ZZ=1>
 10289	035350	200 00 0 00 070313 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10290	035351	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10291	035352	444 00 0 00 070313 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10292	035353	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10293	035354	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10294						STOP^
 10295	035355	254 04 0 00 035356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10296	035356	324 00 0 00 035357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10297									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10298									;IN THE SUBTEST) TO LOOP ON ERROR^
 10299
 10300					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10301					;IR ADDX [IR1], IR ADSUB [IR1]
 10302
 10303					;**********
 10304					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-24
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10305
 10306					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10307					;A WORD OF ALL ZEROS IS ADDED TO AN
 10308					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10309					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10310					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10311					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10312					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10313					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10314					;EVERY BIT OF THE AC.
 10315					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10316			011030		SN=SN+1
 10317		000040	000000			ZZ=ZZ+ZZ
 10318						IFE	ZZ,<ZZ=1>
 10319	035357	200 00 0 00 070314 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10320	035360	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10321	035361	444 00 0 00 070314 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10322	035362	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10323	035363	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10324						STOP^
 10325	035364	254 04 0 00 035365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10326	035365	324 00 0 00 035366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10327									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10328									;IN THE SUBTEST) TO LOOP ON ERROR^
 10329
 10330					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10331					;IR ADDX [IR1], IR ADSUB [IR1]
 10332
 10333					;**********
 10334					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-25
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10335
 10336					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10337					;A WORD OF ALL ZEROS IS ADDED TO AN
 10338					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10339					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10340					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10341					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10342					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10343					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10344					;EVERY BIT OF THE AC.
 10345					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10346			011031		SN=SN+1
 10347		000100	000000			ZZ=ZZ+ZZ
 10348						IFE	ZZ,<ZZ=1>
 10349	035366	200 00 0 00 070315 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10350	035367	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10351	035370	444 00 0 00 070315 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10352	035371	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10353	035372	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10354						STOP^
 10355	035373	254 04 0 00 035374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10356	035374	324 00 0 00 035375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10357									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10358									;IN THE SUBTEST) TO LOOP ON ERROR^
 10359
 10360					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10361					;IR ADDX [IR1], IR ADSUB [IR1]
 10362
 10363					;**********
 10364					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-26
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10365
 10366					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10367					;A WORD OF ALL ZEROS IS ADDED TO AN
 10368					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10369					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10370					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10371					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10372					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10373					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10374					;EVERY BIT OF THE AC.
 10375					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10376			011032		SN=SN+1
 10377		000200	000000			ZZ=ZZ+ZZ
 10378						IFE	ZZ,<ZZ=1>
 10379	035375	200 00 0 00 070316 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10380	035376	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10381	035377	444 00 0 00 070316 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10382	035400	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10383	035401	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10384						STOP^
 10385	035402	254 04 0 00 035403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10386	035403	324 00 0 00 035404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10387									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10388									;IN THE SUBTEST) TO LOOP ON ERROR^
 10389
 10390					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10391					;IR ADDX [IR1], IR ADSUB [IR1]
 10392
 10393					;**********
 10394					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-27
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10395
 10396					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10397					;A WORD OF ALL ZEROS IS ADDED TO AN
 10398					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10399					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10400					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10401					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10402					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10403					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10404					;EVERY BIT OF THE AC.
 10405					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10406			011033		SN=SN+1
 10407		000400	000000			ZZ=ZZ+ZZ
 10408						IFE	ZZ,<ZZ=1>
 10409	035404	200 00 0 00 070264 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10410	035405	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10411	035406	444 00 0 00 070264 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10412	035407	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10413	035410	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10414						STOP^
 10415	035411	254 04 0 00 035412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10416	035412	324 00 0 00 035413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10418									;IN THE SUBTEST) TO LOOP ON ERROR^
 10419
 10420					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10421					;IR ADDX [IR1], IR ADSUB [IR1]
 10422
 10423					;**********
 10424					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-28
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10425
 10426					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10427					;A WORD OF ALL ZEROS IS ADDED TO AN
 10428					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10429					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10430					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10431					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10432					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10433					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10434					;EVERY BIT OF THE AC.
 10435					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10436			011034		SN=SN+1
 10437		001000	000000			ZZ=ZZ+ZZ
 10438						IFE	ZZ,<ZZ=1>
 10439	035413	200 00 0 00 070317 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10440	035414	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10441	035415	444 00 0 00 070317 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10442	035416	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10443	035417	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10444						STOP^
 10445	035420	254 04 0 00 035421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10446	035421	324 00 0 00 035422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10447									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10448									;IN THE SUBTEST) TO LOOP ON ERROR^
 10449
 10450					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10451					;IR ADDX [IR1], IR ADSUB [IR1]
 10452
 10453					;**********
 10454					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-29
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10455
 10456					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10457					;A WORD OF ALL ZEROS IS ADDED TO AN
 10458					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10459					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10460					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10461					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10462					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10463					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10464					;EVERY BIT OF THE AC.
 10465					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10466			011035		SN=SN+1
 10467		002000	000000			ZZ=ZZ+ZZ
 10468						IFE	ZZ,<ZZ=1>
 10469	035422	200 00 0 00 070320 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10470	035423	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10471	035424	444 00 0 00 070320 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10472	035425	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10473	035426	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10474						STOP^
 10475	035427	254 04 0 00 035430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10476	035430	324 00 0 00 035431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10477									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10478									;IN THE SUBTEST) TO LOOP ON ERROR^
 10479
 10480					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10481					;IR ADDX [IR1], IR ADSUB [IR1]
 10482
 10483					;**********
 10484					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-30
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10485
 10486					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10487					;A WORD OF ALL ZEROS IS ADDED TO AN
 10488					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10489					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10490					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10491					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10492					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10493					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10494					;EVERY BIT OF THE AC.
 10495					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10496			011036		SN=SN+1
 10497		004000	000000			ZZ=ZZ+ZZ
 10498						IFE	ZZ,<ZZ=1>
 10499	035431	200 00 0 00 070321 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10500	035432	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10501	035433	444 00 0 00 070321 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10502	035434	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10503	035435	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10504						STOP^
 10505	035436	254 04 0 00 035437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10506	035437	324 00 0 00 035440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10507									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10508									;IN THE SUBTEST) TO LOOP ON ERROR^
 10509
 10510					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10511					;IR ADDX [IR1], IR ADSUB [IR1]
 10512
 10513					;**********
 10514					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-31
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10515
 10516					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10517					;A WORD OF ALL ZEROS IS ADDED TO AN
 10518					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10519					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10520					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10521					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10522					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10523					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10524					;EVERY BIT OF THE AC.
 10525					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10526			011037		SN=SN+1
 10527		010000	000000			ZZ=ZZ+ZZ
 10528						IFE	ZZ,<ZZ=1>
 10529	035440	200 00 0 00 070322 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10530	035441	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10531	035442	444 00 0 00 070322 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10532	035443	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10533	035444	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10534						STOP^
 10535	035445	254 04 0 00 035446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10536	035446	324 00 0 00 035447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10537									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10538									;IN THE SUBTEST) TO LOOP ON ERROR^
 10539
 10540					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10541					;IR ADDX [IR1], IR ADSUB [IR1]
 10542
 10543					;**********
 10544					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-32
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10545
 10546					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10547					;A WORD OF ALL ZEROS IS ADDED TO AN
 10548					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10549					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10550					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10551					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10552					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10553					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10554					;EVERY BIT OF THE AC.
 10555					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10556			011040		SN=SN+1
 10557		020000	000000			ZZ=ZZ+ZZ
 10558						IFE	ZZ,<ZZ=1>
 10559	035447	200 00 0 00 070323 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10560	035450	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10561	035451	444 00 0 00 070323 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10562	035452	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10563	035453	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10564						STOP^
 10565	035454	254 04 0 00 035455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10566	035455	324 00 0 00 035456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10567									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10568									;IN THE SUBTEST) TO LOOP ON ERROR^
 10569
 10570					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10571					;IR ADDX [IR1], IR ADSUB [IR1]
 10572
 10573					;**********
 10574					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-33
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10575
 10576					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10577					;A WORD OF ALL ZEROS IS ADDED TO AN
 10578					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10579					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10580					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10581					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10582					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10583					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10584					;EVERY BIT OF THE AC.
 10585					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10586			011041		SN=SN+1
 10587		040000	000000			ZZ=ZZ+ZZ
 10588						IFE	ZZ,<ZZ=1>
 10589	035456	200 00 0 00 070324 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10590	035457	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10591	035460	444 00 0 00 070324 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10592	035461	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10593	035462	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10594						STOP^
 10595	035463	254 04 0 00 035464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10596	035464	324 00 0 00 035465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10598									;IN THE SUBTEST) TO LOOP ON ERROR^
 10599
 10600					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10601					;IR ADDX [IR1], IR ADSUB [IR1]
 10602
 10603					;**********
 10604					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-34
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10605
 10606					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10607					;A WORD OF ALL ZEROS IS ADDED TO AN
 10608					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10609					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10610					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10611					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10612					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10613					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10614					;EVERY BIT OF THE AC.
 10615					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10616			011042		SN=SN+1
 10617		100000	000000			ZZ=ZZ+ZZ
 10618						IFE	ZZ,<ZZ=1>
 10619	035465	200 00 0 00 070325 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10620	035466	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10621	035467	444 00 0 00 070325 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10622	035470	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10623	035471	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10624						STOP^
 10625	035472	254 04 0 00 035473 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10626	035473	324 00 0 00 035474 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10627									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10628									;IN THE SUBTEST) TO LOOP ON ERROR^
 10629
 10630					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10631					;IR ADDX [IR1], IR ADSUB [IR1]
 10632
 10633					;**********
 10634					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-35
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10635
 10636					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10637					;A WORD OF ALL ZEROS IS ADDED TO AN
 10638					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10639					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10640					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10641					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10642					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10643					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10644					;EVERY BIT OF THE AC.
 10645					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10646			011043		SN=SN+1
 10647		200000	000000			ZZ=ZZ+ZZ
 10648						IFE	ZZ,<ZZ=1>
 10649	035474	200 00 0 00 070326 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10650	035475	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10651	035476	444 00 0 00 070326 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10652	035477	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10653	035500	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10654						STOP^
 10655	035501	254 04 0 00 035502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10656	035502	324 00 0 00 035503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10657									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10658									;IN THE SUBTEST) TO LOOP ON ERROR^
 10659
 10660					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10661					;IR ADDX [IR1], IR ADSUB [IR1]
 10662
 10663					;**********
 10664					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-36
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10665
 10666					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10667					;A WORD OF ALL ZEROS IS ADDED TO AN
 10668					;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10669					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
 10670					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10671					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10672					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10673					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10674					;EVERY BIT OF THE AC.
 10675					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10676			011044		SN=SN+1
 10677		400000	000000			ZZ=ZZ+ZZ
 10678						IFE	ZZ,<ZZ=1>
 10679	035503	200 00 0 00 070256 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 10680	035504	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
 10681	035505	444 00 0 00 070256 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10682	035506	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10683	035507	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10684						STOP^
 10685	035510	254 04 0 00 035511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10686	035511	324 00 0 00 035512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10687									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10688									;IN THE SUBTEST) TO LOOP ON ERROR^
 10689
 10690					;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
 10691					;IR ADDX [IR1], IR ADSUB [IR1]
 10692
 10693					;**********
 10694					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-37
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10695
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10696					;THIS TEST VERIFIES THAT THE ADDITION OF A WORD OF 
 10697					;ALL ZEROS TO AN AC OF ALL ZEROS RESULTS IN
 10698					;C(AC)=0. FIRST THE AC IS CLEARED; THEN, A WORD
 10699					;OF ALL ZEROS IS ADDED TO THE AC. THE RESULT IN
 10700					;THE AC IS THEN CHECKED TO INSURE THAT C(AC)=0
 10701
 10702	035512	200 00 0 00 070253 	A11100:	MOVE	[0]		;PRESET AC TO ZERO
 10703	035513	270 00 0 00 070253 		ADD	[0]		;*ADD OF ZERO TO ZERO SHOULD RESULT IN C(AC)=0
 10704	035514	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10705						STOP^
 10706	035515	254 04 0 00 035516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10707	035516	324 00 0 00 035517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10709									;IN THE SUBTEST) TO LOOP ON ERROR^
 10710
 10711					;FCE[F1], IR AD SUB [IR1]
 10712					;AD FM + EN [ADFP], AD FM + EN A [ADFP],
 10713					;F CYC ACT EN C[F1], IR ADSUB [IR1]
 10714
 10715					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10716					;ADD ZERO TO A RIPPLED ONE
 10717
 10718			013200		SN=13200
 10719			000000			ZZ=0
 10720
 10721					A13200:	REPEAT	^D36,
 10722					<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10723					;TO AN AC  OF ALL ZEROS IS ADDED A
 10724					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10725					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10726					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10727					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10728					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10729					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10730					;EVERY BIT OF THE AC.
 10731					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10732					SN=SN+1
 10733						ZZ=ZZ+ZZ
 10734						IFE	ZZ,<ZZ=1>
 10735						MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10736						ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10737						EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10738						EQV	[0]		;RESULTS IN C(AC)=0
 10739						SKIPE			;PASS TEST IF C(AC)=0
 10740						STOP
 10741					
 10742					;**********
 10743					>
 10744					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10745					;TO AN AC  OF ALL ZEROS IS ADDED A
 10746					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10747					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10748					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10749					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10750					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10751					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10752					;EVERY BIT OF THE AC.
 10753					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10754			013201		SN=SN+1
 10755			000000			ZZ=ZZ+ZZ
 10756			000001			IFE	ZZ,<ZZ=1>
 10757	035517	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10758	035520	270 00 0 00 070265 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10759	035521	444 00 0 00 070265 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10760	035522	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10761	035523	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10762						STOP^
 10763	035524	254 04 0 00 035525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10764	035525	324 00 0 00 035526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10765									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10766									;IN THE SUBTEST) TO LOOP ON ERROR^
 10767
 10768					;**********
 10769
 10770					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10771					;TO AN AC  OF ALL ZEROS IS ADDED A
 10772					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10773					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10774					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10775					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10776					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10777					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10778					;EVERY BIT OF THE AC.
 10779					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10780			013202		SN=SN+1
 10781			000002			ZZ=ZZ+ZZ
 10782						IFE	ZZ,<ZZ=1>
 10783	035526	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10784	035527	270 00 0 00 070266 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10785	035530	444 00 0 00 070266 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10786	035531	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10787	035532	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10788						STOP^
 10789	035533	254 04 0 00 035534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10790	035534	324 00 0 00 035535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10791									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10792									;IN THE SUBTEST) TO LOOP ON ERROR^
 10793
 10794					;**********
 10795
 10796					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10797					;TO AN AC  OF ALL ZEROS IS ADDED A
 10798					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10799					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10800					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10801					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10802					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10803					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10804					;EVERY BIT OF THE AC.
 10805					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10806			013203		SN=SN+1
 10807			000004			ZZ=ZZ+ZZ
 10808						IFE	ZZ,<ZZ=1>
 10809	035535	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10810	035536	270 00 0 00 070267 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10811	035537	444 00 0 00 070267 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10812	035540	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10813	035541	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10814						STOP^
 10815	035542	254 04 0 00 035543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10816	035543	324 00 0 00 035544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10818									;IN THE SUBTEST) TO LOOP ON ERROR^
 10819
 10820					;**********
 10821
 10822					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10823					;TO AN AC  OF ALL ZEROS IS ADDED A
 10824					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10825					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10826					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10827					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10828					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10829					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10830					;EVERY BIT OF THE AC.
 10831					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10832			013204		SN=SN+1
 10833			000010			ZZ=ZZ+ZZ
 10834						IFE	ZZ,<ZZ=1>
 10835	035544	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10836	035545	270 00 0 00 070270 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10837	035546	444 00 0 00 070270 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10838	035547	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10839	035550	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10840						STOP^
 10841	035551	254 04 0 00 035552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10842	035552	324 00 0 00 035553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10843									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10844									;IN THE SUBTEST) TO LOOP ON ERROR^
 10845
 10846					;**********
 10847
 10848					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10849					;TO AN AC  OF ALL ZEROS IS ADDED A
 10850					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10851					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10852					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10853					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10854					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10855					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10856					;EVERY BIT OF THE AC.
 10857					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10858			013205		SN=SN+1
 10859			000020			ZZ=ZZ+ZZ
 10860						IFE	ZZ,<ZZ=1>
 10861	035553	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10862	035554	270 00 0 00 070271 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10863	035555	444 00 0 00 070271 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10864	035556	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10865	035557	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10866						STOP^
 10867	035560	254 04 0 00 035561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10868	035561	324 00 0 00 035562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10869									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10870									;IN THE SUBTEST) TO LOOP ON ERROR^
 10871
 10872					;**********
 10873
 10874					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10875					;TO AN AC  OF ALL ZEROS IS ADDED A
 10876					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10877					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10878					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10879					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10880					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10881					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10882					;EVERY BIT OF THE AC.
 10883					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10884			013206		SN=SN+1
 10885			000040			ZZ=ZZ+ZZ
 10886						IFE	ZZ,<ZZ=1>
 10887	035562	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10888	035563	270 00 0 00 070272 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10889	035564	444 00 0 00 070272 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10890	035565	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10891	035566	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10892						STOP^
 10893	035567	254 04 0 00 035570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10894	035570	324 00 0 00 035571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10895									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10896									;IN THE SUBTEST) TO LOOP ON ERROR^
 10897
 10898					;**********
 10899
 10900					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10901					;TO AN AC  OF ALL ZEROS IS ADDED A
 10902					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10903					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10904					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10905					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10906					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10907					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10908					;EVERY BIT OF THE AC.
 10909					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10910			013207		SN=SN+1
 10911			000100			ZZ=ZZ+ZZ
 10912						IFE	ZZ,<ZZ=1>
 10913	035571	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10914	035572	270 00 0 00 070273 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10915	035573	444 00 0 00 070273 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10916	035574	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10917	035575	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10918						STOP^
 10919	035576	254 04 0 00 035577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10920	035577	324 00 0 00 035600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10922									;IN THE SUBTEST) TO LOOP ON ERROR^
 10923
 10924					;**********
 10925
 10926					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10927					;TO AN AC  OF ALL ZEROS IS ADDED A
 10928					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10929					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10930					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10931					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10932					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10933					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10934					;EVERY BIT OF THE AC.
 10935					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10936			013210		SN=SN+1
 10937			000200			ZZ=ZZ+ZZ
 10938						IFE	ZZ,<ZZ=1>
 10939	035600	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10940	035601	270 00 0 00 070274 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10941	035602	444 00 0 00 070274 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10942	035603	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10943	035604	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10944						STOP^
 10945	035605	254 04 0 00 035606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10946	035606	324 00 0 00 035607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10947									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10948									;IN THE SUBTEST) TO LOOP ON ERROR^
 10949
 10950					;**********
 10951
 10952					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10953					;TO AN AC  OF ALL ZEROS IS ADDED A
 10954					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10955					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10956					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10957					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10958					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10959					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10960					;EVERY BIT OF THE AC.
 10961					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10962			013211		SN=SN+1
 10963			000400			ZZ=ZZ+ZZ
 10964						IFE	ZZ,<ZZ=1>
 10965	035607	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10966	035610	270 00 0 00 070275 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10967	035611	444 00 0 00 070275 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10968	035612	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10969	035613	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10970						STOP^
 10971	035614	254 04 0 00 035615 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10972	035615	324 00 0 00 035616 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10973									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 10974									;IN THE SUBTEST) TO LOOP ON ERROR^
 10975
 10976					;**********
 10977
 10978					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 10979					;TO AN AC  OF ALL ZEROS IS ADDED A
 10980					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 10981					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 10982					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 10983					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 10984					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 10985					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 10986					;EVERY BIT OF THE AC.
 10987					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 10988			013212		SN=SN+1
 10989			001000			ZZ=ZZ+ZZ
 10990						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 10991	035616	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 10992	035617	270 00 0 00 070276 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 10993	035620	444 00 0 00 070276 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 10994	035621	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 10995	035622	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 10996						STOP^
 10997	035623	254 04 0 00 035624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 10998	035624	324 00 0 00 035625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 10999									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11000									;IN THE SUBTEST) TO LOOP ON ERROR^
 11001
 11002					;**********
 11003
 11004					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11005					;TO AN AC  OF ALL ZEROS IS ADDED A
 11006					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11007					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11008					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11009					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11010					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11011					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11012					;EVERY BIT OF THE AC.
 11013					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11014			013213		SN=SN+1
 11015			002000			ZZ=ZZ+ZZ
 11016						IFE	ZZ,<ZZ=1>
 11017	035625	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11018	035626	270 00 0 00 070277 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11019	035627	444 00 0 00 070277 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11020	035630	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11021	035631	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11022						STOP^
 11023	035632	254 04 0 00 035633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11024	035633	324 00 0 00 035634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11026									;IN THE SUBTEST) TO LOOP ON ERROR^
 11027
 11028					;**********
 11029
 11030					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11031					;TO AN AC  OF ALL ZEROS IS ADDED A
 11032					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11033					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11034					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11035					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11036					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11037					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11038					;EVERY BIT OF THE AC.
 11039					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11040			013214		SN=SN+1
 11041			004000			ZZ=ZZ+ZZ
 11042						IFE	ZZ,<ZZ=1>
 11043	035634	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11044	035635	270 00 0 00 070300 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11045	035636	444 00 0 00 070300 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11046	035637	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11047	035640	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11048						STOP^
 11049	035641	254 04 0 00 035642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11050	035642	324 00 0 00 035643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11051									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11052									;IN THE SUBTEST) TO LOOP ON ERROR^
 11053
 11054					;**********
 11055
 11056					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11057					;TO AN AC  OF ALL ZEROS IS ADDED A
 11058					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11059					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11060					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11061					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11062					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11063					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11064					;EVERY BIT OF THE AC.
 11065					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11066			013215		SN=SN+1
 11067			010000			ZZ=ZZ+ZZ
 11068						IFE	ZZ,<ZZ=1>
 11069	035643	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11070	035644	270 00 0 00 070301 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11071	035645	444 00 0 00 070301 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11072	035646	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11073	035647	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11074						STOP^
 11075	035650	254 04 0 00 035651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11076	035651	324 00 0 00 035652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11077									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11078									;IN THE SUBTEST) TO LOOP ON ERROR^
 11079
 11080					;**********
 11081
 11082					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11083					;TO AN AC  OF ALL ZEROS IS ADDED A
 11084					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11085					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11086					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11087					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11088					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11089					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11090					;EVERY BIT OF THE AC.
 11091					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11092			013216		SN=SN+1
 11093			020000			ZZ=ZZ+ZZ
 11094						IFE	ZZ,<ZZ=1>
 11095	035652	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11096	035653	270 00 0 00 070302 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11097	035654	444 00 0 00 070302 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11098	035655	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11099	035656	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11100						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11101	035657	254 04 0 00 035660 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11102	035660	324 00 0 00 035661 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11103									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11104									;IN THE SUBTEST) TO LOOP ON ERROR^
 11105
 11106					;**********
 11107
 11108					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11109					;TO AN AC  OF ALL ZEROS IS ADDED A
 11110					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11111					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11112					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11113					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11114					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11115					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11116					;EVERY BIT OF THE AC.
 11117					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11118			013217		SN=SN+1
 11119			040000			ZZ=ZZ+ZZ
 11120						IFE	ZZ,<ZZ=1>
 11121	035661	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11122	035662	270 00 0 00 070303 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11123	035663	444 00 0 00 070303 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11124	035664	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11125	035665	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11126						STOP^
 11127	035666	254 04 0 00 035667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11128	035667	324 00 0 00 035670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11129									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11130									;IN THE SUBTEST) TO LOOP ON ERROR^
 11131
 11132					;**********
 11133
 11134					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11135					;TO AN AC  OF ALL ZEROS IS ADDED A
 11136					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11137					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11138					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11139					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11140					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11141					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11142					;EVERY BIT OF THE AC.
 11143					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11144			013220		SN=SN+1
 11145			100000			ZZ=ZZ+ZZ
 11146						IFE	ZZ,<ZZ=1>
 11147	035670	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11148	035671	270 00 0 00 070304 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11149	035672	444 00 0 00 070304 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11150	035673	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11151	035674	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11152						STOP^
 11153	035675	254 04 0 00 035676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11154	035676	324 00 0 00 035677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11155									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11156									;IN THE SUBTEST) TO LOOP ON ERROR^
 11157
 11158					;**********
 11159
 11160					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11161					;TO AN AC  OF ALL ZEROS IS ADDED A
 11162					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11163					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11164					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11165					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11166					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11167					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11168					;EVERY BIT OF THE AC.
 11169					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11170			013221		SN=SN+1
 11171			200000			ZZ=ZZ+ZZ
 11172						IFE	ZZ,<ZZ=1>
 11173	035677	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11174	035700	270 00 0 00 070305 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11175	035701	444 00 0 00 070305 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11176	035702	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11177	035703	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11178						STOP^
 11179	035704	254 04 0 00 035705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11180	035705	324 00 0 00 035706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11181									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11182									;IN THE SUBTEST) TO LOOP ON ERROR^
 11183
 11184					;**********
 11185
 11186					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11187					;TO AN AC  OF ALL ZEROS IS ADDED A
 11188					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11189					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11190					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11191					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11192					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11193					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11194					;EVERY BIT OF THE AC.
 11195					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11196			013222		SN=SN+1
 11197			400000			ZZ=ZZ+ZZ
 11198						IFE	ZZ,<ZZ=1>
 11199	035706	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11200	035707	270 00 0 00 070306 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11201	035710	444 00 0 00 070306 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11202	035711	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11203	035712	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11204						STOP^
 11205	035713	254 04 0 00 035714 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11206	035714	324 00 0 00 035715 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11207									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11208									;IN THE SUBTEST) TO LOOP ON ERROR^
 11209
 11210					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-9
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11211
 11212					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11213					;TO AN AC  OF ALL ZEROS IS ADDED A
 11214					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11215					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11216					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11217					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11218					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11219					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11220					;EVERY BIT OF THE AC.
 11221					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11222			013223		SN=SN+1
 11223		000001	000000			ZZ=ZZ+ZZ
 11224						IFE	ZZ,<ZZ=1>
 11225	035715	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11226	035716	270 00 0 00 070307 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11227	035717	444 00 0 00 070307 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11228	035720	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11229	035721	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11230						STOP^
 11231	035722	254 04 0 00 035723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11232	035723	324 00 0 00 035724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11233									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11234									;IN THE SUBTEST) TO LOOP ON ERROR^
 11235
 11236					;**********
 11237
 11238					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11239					;TO AN AC  OF ALL ZEROS IS ADDED A
 11240					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11241					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11242					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11243					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11244					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11245					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11246					;EVERY BIT OF THE AC.
 11247					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11248			013224		SN=SN+1
 11249		000002	000000			ZZ=ZZ+ZZ
 11250						IFE	ZZ,<ZZ=1>
 11251	035724	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11252	035725	270 00 0 00 070310 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11253	035726	444 00 0 00 070310 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11254	035727	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11255	035730	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11256						STOP^
 11257	035731	254 04 0 00 035732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11258	035732	324 00 0 00 035733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11259									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11260									;IN THE SUBTEST) TO LOOP ON ERROR^
 11261
 11262					;**********
 11263
 11264					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11265					;TO AN AC  OF ALL ZEROS IS ADDED A
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-10
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11266					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11267					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11268					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11269					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11270					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11271					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11272					;EVERY BIT OF THE AC.
 11273					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11274			013225		SN=SN+1
 11275		000004	000000			ZZ=ZZ+ZZ
 11276						IFE	ZZ,<ZZ=1>
 11277	035733	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11278	035734	270 00 0 00 070311 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11279	035735	444 00 0 00 070311 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11280	035736	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11281	035737	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11282						STOP^
 11283	035740	254 04 0 00 035741 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11284	035741	324 00 0 00 035742 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11285									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11286									;IN THE SUBTEST) TO LOOP ON ERROR^
 11287
 11288					;**********
 11289
 11290					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11291					;TO AN AC  OF ALL ZEROS IS ADDED A
 11292					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11293					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11294					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11295					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11296					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11297					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11298					;EVERY BIT OF THE AC.
 11299					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11300			013226		SN=SN+1
 11301		000010	000000			ZZ=ZZ+ZZ
 11302						IFE	ZZ,<ZZ=1>
 11303	035742	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11304	035743	270 00 0 00 070312 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11305	035744	444 00 0 00 070312 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11306	035745	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11307	035746	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11308						STOP^
 11309	035747	254 04 0 00 035750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11310	035750	324 00 0 00 035751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11312									;IN THE SUBTEST) TO LOOP ON ERROR^
 11313
 11314					;**********
 11315
 11316					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11317					;TO AN AC  OF ALL ZEROS IS ADDED A
 11318					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11319					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11320					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-11
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11321					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11322					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11323					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11324					;EVERY BIT OF THE AC.
 11325					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11326			013227		SN=SN+1
 11327		000020	000000			ZZ=ZZ+ZZ
 11328						IFE	ZZ,<ZZ=1>
 11329	035751	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11330	035752	270 00 0 00 070313 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11331	035753	444 00 0 00 070313 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11332	035754	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11333	035755	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11334						STOP^
 11335	035756	254 04 0 00 035757 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11336	035757	324 00 0 00 035760 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11338									;IN THE SUBTEST) TO LOOP ON ERROR^
 11339
 11340					;**********
 11341
 11342					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11343					;TO AN AC  OF ALL ZEROS IS ADDED A
 11344					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11345					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11346					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11347					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11348					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11349					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11350					;EVERY BIT OF THE AC.
 11351					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11352			013230		SN=SN+1
 11353		000040	000000			ZZ=ZZ+ZZ
 11354						IFE	ZZ,<ZZ=1>
 11355	035760	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11356	035761	270 00 0 00 070314 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11357	035762	444 00 0 00 070314 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11358	035763	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11359	035764	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11360						STOP^
 11361	035765	254 04 0 00 035766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11362	035766	324 00 0 00 035767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11363									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11364									;IN THE SUBTEST) TO LOOP ON ERROR^
 11365
 11366					;**********
 11367
 11368					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11369					;TO AN AC  OF ALL ZEROS IS ADDED A
 11370					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11371					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11372					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11373					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11374					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11375					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-12
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11376					;EVERY BIT OF THE AC.
 11377					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11378			013231		SN=SN+1
 11379		000100	000000			ZZ=ZZ+ZZ
 11380						IFE	ZZ,<ZZ=1>
 11381	035767	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11382	035770	270 00 0 00 070315 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11383	035771	444 00 0 00 070315 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11384	035772	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11385	035773	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11386						STOP^
 11387	035774	254 04 0 00 035775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11388	035775	324 00 0 00 035776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11389									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11390									;IN THE SUBTEST) TO LOOP ON ERROR^
 11391
 11392					;**********
 11393
 11394					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11395					;TO AN AC  OF ALL ZEROS IS ADDED A
 11396					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11397					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11398					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11399					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11400					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11401					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11402					;EVERY BIT OF THE AC.
 11403					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11404			013232		SN=SN+1
 11405		000200	000000			ZZ=ZZ+ZZ
 11406						IFE	ZZ,<ZZ=1>
 11407	035776	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11408	035777	270 00 0 00 070316 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11409	036000	444 00 0 00 070316 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11410	036001	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11411	036002	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11412						STOP^
 11413	036003	254 04 0 00 036004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11414	036004	324 00 0 00 036005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11415									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11416									;IN THE SUBTEST) TO LOOP ON ERROR^
 11417
 11418					;**********
 11419
 11420					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11421					;TO AN AC  OF ALL ZEROS IS ADDED A
 11422					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11423					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11424					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11425					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11426					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11427					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11428					;EVERY BIT OF THE AC.
 11429					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11430			013233		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-13
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11431		000400	000000			ZZ=ZZ+ZZ
 11432						IFE	ZZ,<ZZ=1>
 11433	036005	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11434	036006	270 00 0 00 070264 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11435	036007	444 00 0 00 070264 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11436	036010	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11437	036011	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11438						STOP^
 11439	036012	254 04 0 00 036013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11440	036013	324 00 0 00 036014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11441									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11442									;IN THE SUBTEST) TO LOOP ON ERROR^
 11443
 11444					;**********
 11445
 11446					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11447					;TO AN AC  OF ALL ZEROS IS ADDED A
 11448					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11449					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11450					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11451					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11452					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11453					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11454					;EVERY BIT OF THE AC.
 11455					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11456			013234		SN=SN+1
 11457		001000	000000			ZZ=ZZ+ZZ
 11458						IFE	ZZ,<ZZ=1>
 11459	036014	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11460	036015	270 00 0 00 070317 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11461	036016	444 00 0 00 070317 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11462	036017	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11463	036020	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11464						STOP^
 11465	036021	254 04 0 00 036022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11466	036022	324 00 0 00 036023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11467									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11468									;IN THE SUBTEST) TO LOOP ON ERROR^
 11469
 11470					;**********
 11471
 11472					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11473					;TO AN AC  OF ALL ZEROS IS ADDED A
 11474					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11475					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11476					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11477					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11478					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11479					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11480					;EVERY BIT OF THE AC.
 11481					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11482			013235		SN=SN+1
 11483		002000	000000			ZZ=ZZ+ZZ
 11484						IFE	ZZ,<ZZ=1>
 11485	036023	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-14
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11486	036024	270 00 0 00 070320 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11487	036025	444 00 0 00 070320 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11488	036026	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11489	036027	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11490						STOP^
 11491	036030	254 04 0 00 036031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11492	036031	324 00 0 00 036032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11493									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11494									;IN THE SUBTEST) TO LOOP ON ERROR^
 11495
 11496					;**********
 11497
 11498					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11499					;TO AN AC  OF ALL ZEROS IS ADDED A
 11500					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11501					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11502					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11503					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11504					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11505					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11506					;EVERY BIT OF THE AC.
 11507					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11508			013236		SN=SN+1
 11509		004000	000000			ZZ=ZZ+ZZ
 11510						IFE	ZZ,<ZZ=1>
 11511	036032	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11512	036033	270 00 0 00 070321 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11513	036034	444 00 0 00 070321 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11514	036035	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11515	036036	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11516						STOP^
 11517	036037	254 04 0 00 036040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11518	036040	324 00 0 00 036041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11519									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11520									;IN THE SUBTEST) TO LOOP ON ERROR^
 11521
 11522					;**********
 11523
 11524					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11525					;TO AN AC  OF ALL ZEROS IS ADDED A
 11526					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11527					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11528					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11529					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11530					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11531					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11532					;EVERY BIT OF THE AC.
 11533					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11534			013237		SN=SN+1
 11535		010000	000000			ZZ=ZZ+ZZ
 11536						IFE	ZZ,<ZZ=1>
 11537	036041	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11538	036042	270 00 0 00 070322 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11539	036043	444 00 0 00 070322 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11540	036044	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-15
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11541	036045	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11542						STOP^
 11543	036046	254 04 0 00 036047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11544	036047	324 00 0 00 036050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11545									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11546									;IN THE SUBTEST) TO LOOP ON ERROR^
 11547
 11548					;**********
 11549
 11550					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11551					;TO AN AC  OF ALL ZEROS IS ADDED A
 11552					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11553					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11554					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11555					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11556					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11557					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11558					;EVERY BIT OF THE AC.
 11559					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11560			013240		SN=SN+1
 11561		020000	000000			ZZ=ZZ+ZZ
 11562						IFE	ZZ,<ZZ=1>
 11563	036050	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11564	036051	270 00 0 00 070323 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11565	036052	444 00 0 00 070323 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11566	036053	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11567	036054	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11568						STOP^
 11569	036055	254 04 0 00 036056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11570	036056	324 00 0 00 036057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11571									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11572									;IN THE SUBTEST) TO LOOP ON ERROR^
 11573
 11574					;**********
 11575
 11576					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11577					;TO AN AC  OF ALL ZEROS IS ADDED A
 11578					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11579					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11580					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11581					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11582					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11583					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11584					;EVERY BIT OF THE AC.
 11585					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11586			013241		SN=SN+1
 11587		040000	000000			ZZ=ZZ+ZZ
 11588						IFE	ZZ,<ZZ=1>
 11589	036057	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11590	036060	270 00 0 00 070324 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11591	036061	444 00 0 00 070324 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11592	036062	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11593	036063	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11594						STOP^
 11595	036064	254 04 0 00 036065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-16
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11596	036065	324 00 0 00 036066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11598									;IN THE SUBTEST) TO LOOP ON ERROR^
 11599
 11600					;**********
 11601
 11602					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11603					;TO AN AC  OF ALL ZEROS IS ADDED A
 11604					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11605					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11606					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11607					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11608					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11609					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11610					;EVERY BIT OF THE AC.
 11611					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11612			013242		SN=SN+1
 11613		100000	000000			ZZ=ZZ+ZZ
 11614						IFE	ZZ,<ZZ=1>
 11615	036066	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11616	036067	270 00 0 00 070325 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11617	036070	444 00 0 00 070325 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11618	036071	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11619	036072	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11620						STOP^
 11621	036073	254 04 0 00 036074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11622	036074	324 00 0 00 036075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11623									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11624									;IN THE SUBTEST) TO LOOP ON ERROR^
 11625
 11626					;**********
 11627
 11628					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11629					;TO AN AC  OF ALL ZEROS IS ADDED A
 11630					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11631					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11632					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11633					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11634					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11635					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11636					;EVERY BIT OF THE AC.
 11637					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11638			013243		SN=SN+1
 11639		200000	000000			ZZ=ZZ+ZZ
 11640						IFE	ZZ,<ZZ=1>
 11641	036075	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11642	036076	270 00 0 00 070326 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11643	036077	444 00 0 00 070326 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11644	036100	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11645	036101	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11646						STOP^
 11647	036102	254 04 0 00 036103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11648	036103	324 00 0 00 036104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11650									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-17
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11651
 11652					;**********
 11653
 11654					;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
 11655					;TO AN AC  OF ALL ZEROS IS ADDED A
 11656					;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
 11657					;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
 11658					;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
 11659					;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
 11660					;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
 11661					;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
 11662					;EVERY BIT OF THE AC.
 11663					;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
 11664			013244		SN=SN+1
 11665		400000	000000			ZZ=ZZ+ZZ
 11666						IFE	ZZ,<ZZ=1>
 11667	036104	200 00 0 00 070253 		MOVE	[0]		;LOAD AC WITH ALL ZEROS
 11668	036105	270 00 0 00 070256 		ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
 11669	036106	444 00 0 00 070256 		EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
 11670	036107	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11671	036110	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11672						STOP^
 11673	036111	254 04 0 00 036112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11674	036112	324 00 0 00 036113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11676									;IN THE SUBTEST) TO LOOP ON ERROR^
 11677
 11678					;**********
 11679
 11680					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-18
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11681					;ADD A RIPPLED ONE TO A RIPPLED ONE
 11682
 11683			011200		SN=11200
 11684			000000			ZZ=0
 11685
 11686					A11200:	REPEAT	^D35,
 11687					<;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11688					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11689					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11690					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11691					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11692					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11693					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11694					;SO THAT A ONE WILL BE FLOATED THROUGH
 11695					;BITS 1 THRU 35 OF BOTH AC AND E
 11696					SN=SN+1
 11697						ZZ=ZZ+ZZ
 11698						IFE	ZZ,<ZZ=1>
 11699						MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11700						ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11701						EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11702						EQV	[0]		;RESULTS IN C(AC)=0
 11703						SKIPE			;PASS TEST IF C(AC)=0
 11704						STOP
 11705					
 11706					;**********
 11707					>
 11708					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11709					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11710					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11711					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11712					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11713					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11714					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11715					;SO THAT A ONE WILL BE FLOATED THROUGH
 11716					;BITS 1 THRU 35 OF BOTH AC AND E
 11717			011201		SN=SN+1
 11718			000000			ZZ=ZZ+ZZ
 11719			000001			IFE	ZZ,<ZZ=1>
 11720	036113	200 00 0 00 070265 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11721	036114	270 00 0 00 070265 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11722	036115	444 00 0 00 070266 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11723	036116	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11724	036117	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11725						STOP^
 11726	036120	254 04 0 00 036121 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11727	036121	324 00 0 00 036122 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11728									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11729									;IN THE SUBTEST) TO LOOP ON ERROR^
 11730
 11731					;**********
 11732
 11733					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11734					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11735					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-19
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11736					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11737					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11738					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11739					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11740					;SO THAT A ONE WILL BE FLOATED THROUGH
 11741					;BITS 1 THRU 35 OF BOTH AC AND E
 11742			011202		SN=SN+1
 11743			000002			ZZ=ZZ+ZZ
 11744						IFE	ZZ,<ZZ=1>
 11745	036122	200 00 0 00 070266 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11746	036123	270 00 0 00 070266 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11747	036124	444 00 0 00 070267 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11748	036125	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11749	036126	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11750						STOP^
 11751	036127	254 04 0 00 036130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11752	036130	324 00 0 00 036131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11753									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11754									;IN THE SUBTEST) TO LOOP ON ERROR^
 11755
 11756					;**********
 11757
 11758					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11759					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11760					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11761					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11762					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11763					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11764					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11765					;SO THAT A ONE WILL BE FLOATED THROUGH
 11766					;BITS 1 THRU 35 OF BOTH AC AND E
 11767			011203		SN=SN+1
 11768			000004			ZZ=ZZ+ZZ
 11769						IFE	ZZ,<ZZ=1>
 11770	036131	200 00 0 00 070267 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11771	036132	270 00 0 00 070267 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11772	036133	444 00 0 00 070270 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11773	036134	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11774	036135	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11775						STOP^
 11776	036136	254 04 0 00 036137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11777	036137	324 00 0 00 036140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11778									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11779									;IN THE SUBTEST) TO LOOP ON ERROR^
 11780
 11781					;**********
 11782
 11783					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11784					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11785					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11786					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11787					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11788					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11789					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11790					;SO THAT A ONE WILL BE FLOATED THROUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-20
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11791					;BITS 1 THRU 35 OF BOTH AC AND E
 11792			011204		SN=SN+1
 11793			000010			ZZ=ZZ+ZZ
 11794						IFE	ZZ,<ZZ=1>
 11795	036140	200 00 0 00 070270 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11796	036141	270 00 0 00 070270 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11797	036142	444 00 0 00 070271 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11798	036143	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11799	036144	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11800						STOP^
 11801	036145	254 04 0 00 036146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11802	036146	324 00 0 00 036147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11804									;IN THE SUBTEST) TO LOOP ON ERROR^
 11805
 11806					;**********
 11807
 11808					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11809					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11810					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11811					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11812					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11813					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11814					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11815					;SO THAT A ONE WILL BE FLOATED THROUGH
 11816					;BITS 1 THRU 35 OF BOTH AC AND E
 11817			011205		SN=SN+1
 11818			000020			ZZ=ZZ+ZZ
 11819						IFE	ZZ,<ZZ=1>
 11820	036147	200 00 0 00 070271 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11821	036150	270 00 0 00 070271 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11822	036151	444 00 0 00 070272 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11823	036152	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11824	036153	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11825						STOP^
 11826	036154	254 04 0 00 036155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11827	036155	324 00 0 00 036156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11828									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11829									;IN THE SUBTEST) TO LOOP ON ERROR^
 11830
 11831					;**********
 11832
 11833					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11834					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11835					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11836					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11837					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11838					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11839					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11840					;SO THAT A ONE WILL BE FLOATED THROUGH
 11841					;BITS 1 THRU 35 OF BOTH AC AND E
 11842			011206		SN=SN+1
 11843			000040			ZZ=ZZ+ZZ
 11844						IFE	ZZ,<ZZ=1>
 11845	036156	200 00 0 00 070272 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-21
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11846	036157	270 00 0 00 070272 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11847	036160	444 00 0 00 070273 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11848	036161	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11849	036162	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11850						STOP^
 11851	036163	254 04 0 00 036164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11852	036164	324 00 0 00 036165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11853									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11854									;IN THE SUBTEST) TO LOOP ON ERROR^
 11855
 11856					;**********
 11857
 11858					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11859					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11860					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11861					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11862					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11863					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11864					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11865					;SO THAT A ONE WILL BE FLOATED THROUGH
 11866					;BITS 1 THRU 35 OF BOTH AC AND E
 11867			011207		SN=SN+1
 11868			000100			ZZ=ZZ+ZZ
 11869						IFE	ZZ,<ZZ=1>
 11870	036165	200 00 0 00 070273 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11871	036166	270 00 0 00 070273 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11872	036167	444 00 0 00 070274 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11873	036170	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11874	036171	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11875						STOP^
 11876	036172	254 04 0 00 036173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11877	036173	324 00 0 00 036174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11878									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11879									;IN THE SUBTEST) TO LOOP ON ERROR^
 11880
 11881					;**********
 11882
 11883					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11884					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11885					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11886					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11887					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11888					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11889					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11890					;SO THAT A ONE WILL BE FLOATED THROUGH
 11891					;BITS 1 THRU 35 OF BOTH AC AND E
 11892			011210		SN=SN+1
 11893			000200			ZZ=ZZ+ZZ
 11894						IFE	ZZ,<ZZ=1>
 11895	036174	200 00 0 00 070274 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11896	036175	270 00 0 00 070274 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11897	036176	444 00 0 00 070275 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11898	036177	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11899	036200	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11900						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-22
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11901	036201	254 04 0 00 036202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11902	036202	324 00 0 00 036203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11904									;IN THE SUBTEST) TO LOOP ON ERROR^
 11905
 11906					;**********
 11907
 11908					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11909					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11910					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11911					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11912					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11913					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11914					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11915					;SO THAT A ONE WILL BE FLOATED THROUGH
 11916					;BITS 1 THRU 35 OF BOTH AC AND E
 11917			011211		SN=SN+1
 11918			000400			ZZ=ZZ+ZZ
 11919						IFE	ZZ,<ZZ=1>
 11920	036203	200 00 0 00 070275 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11921	036204	270 00 0 00 070275 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11922	036205	444 00 0 00 070276 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11923	036206	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11924	036207	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11925						STOP^
 11926	036210	254 04 0 00 036211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11927	036211	324 00 0 00 036212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11928									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11929									;IN THE SUBTEST) TO LOOP ON ERROR^
 11930
 11931					;**********
 11932
 11933					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11934					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11935					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11936					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11937					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11938					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11939					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11940					;SO THAT A ONE WILL BE FLOATED THROUGH
 11941					;BITS 1 THRU 35 OF BOTH AC AND E
 11942			011212		SN=SN+1
 11943			001000			ZZ=ZZ+ZZ
 11944						IFE	ZZ,<ZZ=1>
 11945	036212	200 00 0 00 070276 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11946	036213	270 00 0 00 070276 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11947	036214	444 00 0 00 070277 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11948	036215	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11949	036216	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11950						STOP^
 11951	036217	254 04 0 00 036220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11952	036220	324 00 0 00 036221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11953									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11954									;IN THE SUBTEST) TO LOOP ON ERROR^
 11955
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-23
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 11956					;**********
 11957
 11958					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11959					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11960					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11961					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11962					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11963					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11964					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11965					;SO THAT A ONE WILL BE FLOATED THROUGH
 11966					;BITS 1 THRU 35 OF BOTH AC AND E
 11967			011213		SN=SN+1
 11968			002000			ZZ=ZZ+ZZ
 11969						IFE	ZZ,<ZZ=1>
 11970	036221	200 00 0 00 070277 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11971	036222	270 00 0 00 070277 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11972	036223	444 00 0 00 070300 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11973	036224	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11974	036225	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 11975						STOP^
 11976	036226	254 04 0 00 036227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 11977	036227	324 00 0 00 036230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 11978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 11979									;IN THE SUBTEST) TO LOOP ON ERROR^
 11980
 11981					;**********
 11982
 11983					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 11984					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 11985					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 11986					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 11987					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 11988					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 11989					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 11990					;SO THAT A ONE WILL BE FLOATED THROUGH
 11991					;BITS 1 THRU 35 OF BOTH AC AND E
 11992			011214		SN=SN+1
 11993			004000			ZZ=ZZ+ZZ
 11994						IFE	ZZ,<ZZ=1>
 11995	036230	200 00 0 00 070300 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 11996	036231	270 00 0 00 070300 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 11997	036232	444 00 0 00 070301 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 11998	036233	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 11999	036234	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12000						STOP^
 12001	036235	254 04 0 00 036236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12002	036236	324 00 0 00 036237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12004									;IN THE SUBTEST) TO LOOP ON ERROR^
 12005
 12006					;**********
 12007
 12008					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12009					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12010					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-24
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12011					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12012					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12013					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12014					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12015					;SO THAT A ONE WILL BE FLOATED THROUGH
 12016					;BITS 1 THRU 35 OF BOTH AC AND E
 12017			011215		SN=SN+1
 12018			010000			ZZ=ZZ+ZZ
 12019						IFE	ZZ,<ZZ=1>
 12020	036237	200 00 0 00 070301 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12021	036240	270 00 0 00 070301 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12022	036241	444 00 0 00 070302 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12023	036242	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12024	036243	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12025						STOP^
 12026	036244	254 04 0 00 036245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12027	036245	324 00 0 00 036246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12028									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12029									;IN THE SUBTEST) TO LOOP ON ERROR^
 12030
 12031					;**********
 12032
 12033					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12034					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12035					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12036					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12037					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12038					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12039					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12040					;SO THAT A ONE WILL BE FLOATED THROUGH
 12041					;BITS 1 THRU 35 OF BOTH AC AND E
 12042			011216		SN=SN+1
 12043			020000			ZZ=ZZ+ZZ
 12044						IFE	ZZ,<ZZ=1>
 12045	036246	200 00 0 00 070302 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12046	036247	270 00 0 00 070302 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12047	036250	444 00 0 00 070303 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12048	036251	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12049	036252	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12050						STOP^
 12051	036253	254 04 0 00 036254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12052	036254	324 00 0 00 036255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12053									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12054									;IN THE SUBTEST) TO LOOP ON ERROR^
 12055
 12056					;**********
 12057
 12058					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12059					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12060					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12061					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12062					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12063					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12064					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12065					;SO THAT A ONE WILL BE FLOATED THROUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-25
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12066					;BITS 1 THRU 35 OF BOTH AC AND E
 12067			011217		SN=SN+1
 12068			040000			ZZ=ZZ+ZZ
 12069						IFE	ZZ,<ZZ=1>
 12070	036255	200 00 0 00 070303 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12071	036256	270 00 0 00 070303 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12072	036257	444 00 0 00 070304 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12073	036260	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12074	036261	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12075						STOP^
 12076	036262	254 04 0 00 036263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12077	036263	324 00 0 00 036264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12078									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12079									;IN THE SUBTEST) TO LOOP ON ERROR^
 12080
 12081					;**********
 12082
 12083					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12084					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12085					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12086					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12087					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12088					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12089					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12090					;SO THAT A ONE WILL BE FLOATED THROUGH
 12091					;BITS 1 THRU 35 OF BOTH AC AND E
 12092			011220		SN=SN+1
 12093			100000			ZZ=ZZ+ZZ
 12094						IFE	ZZ,<ZZ=1>
 12095	036264	200 00 0 00 070304 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12096	036265	270 00 0 00 070304 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12097	036266	444 00 0 00 070305 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12098	036267	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12099	036270	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12100						STOP^
 12101	036271	254 04 0 00 036272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12102	036272	324 00 0 00 036273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12103									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12104									;IN THE SUBTEST) TO LOOP ON ERROR^
 12105
 12106					;**********
 12107
 12108					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12109					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12110					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12111					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12112					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12113					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12114					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12115					;SO THAT A ONE WILL BE FLOATED THROUGH
 12116					;BITS 1 THRU 35 OF BOTH AC AND E
 12117			011221		SN=SN+1
 12118			200000			ZZ=ZZ+ZZ
 12119						IFE	ZZ,<ZZ=1>
 12120	036273	200 00 0 00 070305 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-26
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12121	036274	270 00 0 00 070305 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12122	036275	444 00 0 00 070306 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12123	036276	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12124	036277	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12125						STOP^
 12126	036300	254 04 0 00 036301 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12127	036301	324 00 0 00 036302 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12129									;IN THE SUBTEST) TO LOOP ON ERROR^
 12130
 12131					;**********
 12132
 12133					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12134					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12135					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12136					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12137					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12138					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12139					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12140					;SO THAT A ONE WILL BE FLOATED THROUGH
 12141					;BITS 1 THRU 35 OF BOTH AC AND E
 12142			011222		SN=SN+1
 12143			400000			ZZ=ZZ+ZZ
 12144						IFE	ZZ,<ZZ=1>
 12145	036302	200 00 0 00 070306 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12146	036303	270 00 0 00 070306 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12147	036304	444 00 0 00 070307 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12148	036305	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12149	036306	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12150						STOP^
 12151	036307	254 04 0 00 036310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12152	036310	324 00 0 00 036311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12154									;IN THE SUBTEST) TO LOOP ON ERROR^
 12155
 12156					;**********
 12157
 12158					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12159					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12160					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12161					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12162					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12163					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12164					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12165					;SO THAT A ONE WILL BE FLOATED THROUGH
 12166					;BITS 1 THRU 35 OF BOTH AC AND E
 12167			011223		SN=SN+1
 12168		000001	000000			ZZ=ZZ+ZZ
 12169						IFE	ZZ,<ZZ=1>
 12170	036311	200 00 0 00 070307 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12171	036312	270 00 0 00 070307 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12172	036313	444 00 0 00 070310 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12173	036314	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12174	036315	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12175						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-27
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12176	036316	254 04 0 00 036317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12177	036317	324 00 0 00 036320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12178									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12179									;IN THE SUBTEST) TO LOOP ON ERROR^
 12180
 12181					;**********
 12182
 12183					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12184					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12185					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12186					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12187					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12188					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12189					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12190					;SO THAT A ONE WILL BE FLOATED THROUGH
 12191					;BITS 1 THRU 35 OF BOTH AC AND E
 12192			011224		SN=SN+1
 12193		000002	000000			ZZ=ZZ+ZZ
 12194						IFE	ZZ,<ZZ=1>
 12195	036320	200 00 0 00 070310 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12196	036321	270 00 0 00 070310 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12197	036322	444 00 0 00 070311 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12198	036323	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12199	036324	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12200						STOP^
 12201	036325	254 04 0 00 036326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12202	036326	324 00 0 00 036327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12203									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12204									;IN THE SUBTEST) TO LOOP ON ERROR^
 12205
 12206					;**********
 12207
 12208					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12209					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12210					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12211					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12212					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12213					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12214					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12215					;SO THAT A ONE WILL BE FLOATED THROUGH
 12216					;BITS 1 THRU 35 OF BOTH AC AND E
 12217			011225		SN=SN+1
 12218		000004	000000			ZZ=ZZ+ZZ
 12219						IFE	ZZ,<ZZ=1>
 12220	036327	200 00 0 00 070311 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12221	036330	270 00 0 00 070311 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12222	036331	444 00 0 00 070312 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12223	036332	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12224	036333	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12225						STOP^
 12226	036334	254 04 0 00 036335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12227	036335	324 00 0 00 036336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12228									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12229									;IN THE SUBTEST) TO LOOP ON ERROR^
 12230
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-28
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12231					;**********
 12232
 12233					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12234					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12235					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12236					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12237					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12238					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12239					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12240					;SO THAT A ONE WILL BE FLOATED THROUGH
 12241					;BITS 1 THRU 35 OF BOTH AC AND E
 12242			011226		SN=SN+1
 12243		000010	000000			ZZ=ZZ+ZZ
 12244						IFE	ZZ,<ZZ=1>
 12245	036336	200 00 0 00 070312 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12246	036337	270 00 0 00 070312 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12247	036340	444 00 0 00 070313 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12248	036341	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12249	036342	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12250						STOP^
 12251	036343	254 04 0 00 036344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12252	036344	324 00 0 00 036345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12253									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12254									;IN THE SUBTEST) TO LOOP ON ERROR^
 12255
 12256					;**********
 12257
 12258					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12259					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12260					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12261					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12262					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12263					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12264					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12265					;SO THAT A ONE WILL BE FLOATED THROUGH
 12266					;BITS 1 THRU 35 OF BOTH AC AND E
 12267			011227		SN=SN+1
 12268		000020	000000			ZZ=ZZ+ZZ
 12269						IFE	ZZ,<ZZ=1>
 12270	036345	200 00 0 00 070313 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12271	036346	270 00 0 00 070313 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12272	036347	444 00 0 00 070314 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12273	036350	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12274	036351	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12275						STOP^
 12276	036352	254 04 0 00 036353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12277	036353	324 00 0 00 036354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12278									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12279									;IN THE SUBTEST) TO LOOP ON ERROR^
 12280
 12281					;**********
 12282
 12283					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12284					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12285					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-29
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12286					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12287					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12288					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12289					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12290					;SO THAT A ONE WILL BE FLOATED THROUGH
 12291					;BITS 1 THRU 35 OF BOTH AC AND E
 12292			011230		SN=SN+1
 12293		000040	000000			ZZ=ZZ+ZZ
 12294						IFE	ZZ,<ZZ=1>
 12295	036354	200 00 0 00 070314 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12296	036355	270 00 0 00 070314 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12297	036356	444 00 0 00 070315 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12298	036357	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12299	036360	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12300						STOP^
 12301	036361	254 04 0 00 036362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12302	036362	324 00 0 00 036363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12304									;IN THE SUBTEST) TO LOOP ON ERROR^
 12305
 12306					;**********
 12307
 12308					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12309					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12310					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12311					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12312					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12313					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12314					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12315					;SO THAT A ONE WILL BE FLOATED THROUGH
 12316					;BITS 1 THRU 35 OF BOTH AC AND E
 12317			011231		SN=SN+1
 12318		000100	000000			ZZ=ZZ+ZZ
 12319						IFE	ZZ,<ZZ=1>
 12320	036363	200 00 0 00 070315 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12321	036364	270 00 0 00 070315 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12322	036365	444 00 0 00 070316 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12323	036366	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12324	036367	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12325						STOP^
 12326	036370	254 04 0 00 036371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12327	036371	324 00 0 00 036372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12328									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12329									;IN THE SUBTEST) TO LOOP ON ERROR^
 12330
 12331					;**********
 12332
 12333					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12334					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12335					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12336					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12337					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12338					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12339					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12340					;SO THAT A ONE WILL BE FLOATED THROUGH
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-30
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12341					;BITS 1 THRU 35 OF BOTH AC AND E
 12342			011232		SN=SN+1
 12343		000200	000000			ZZ=ZZ+ZZ
 12344						IFE	ZZ,<ZZ=1>
 12345	036372	200 00 0 00 070316 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12346	036373	270 00 0 00 070316 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12347	036374	444 00 0 00 070264 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12348	036375	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12349	036376	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12350						STOP^
 12351	036377	254 04 0 00 036400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12352	036400	324 00 0 00 036401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12353									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12354									;IN THE SUBTEST) TO LOOP ON ERROR^
 12355
 12356					;**********
 12357
 12358					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12359					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12360					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12361					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12362					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12363					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12364					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12365					;SO THAT A ONE WILL BE FLOATED THROUGH
 12366					;BITS 1 THRU 35 OF BOTH AC AND E
 12367			011233		SN=SN+1
 12368		000400	000000			ZZ=ZZ+ZZ
 12369						IFE	ZZ,<ZZ=1>
 12370	036401	200 00 0 00 070264 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12371	036402	270 00 0 00 070264 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12372	036403	444 00 0 00 070317 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12373	036404	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12374	036405	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12375						STOP^
 12376	036406	254 04 0 00 036407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12377	036407	324 00 0 00 036410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12378									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12379									;IN THE SUBTEST) TO LOOP ON ERROR^
 12380
 12381					;**********
 12382
 12383					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12384					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12385					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12386					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12387					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12388					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12389					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12390					;SO THAT A ONE WILL BE FLOATED THROUGH
 12391					;BITS 1 THRU 35 OF BOTH AC AND E
 12392			011234		SN=SN+1
 12393		001000	000000			ZZ=ZZ+ZZ
 12394						IFE	ZZ,<ZZ=1>
 12395	036410	200 00 0 00 070317 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-31
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12396	036411	270 00 0 00 070317 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12397	036412	444 00 0 00 070320 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12398	036413	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12399	036414	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12400						STOP^
 12401	036415	254 04 0 00 036416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12402	036416	324 00 0 00 036417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12403									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12404									;IN THE SUBTEST) TO LOOP ON ERROR^
 12405
 12406					;**********
 12407
 12408					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12409					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12410					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12411					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12412					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12413					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12414					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12415					;SO THAT A ONE WILL BE FLOATED THROUGH
 12416					;BITS 1 THRU 35 OF BOTH AC AND E
 12417			011235		SN=SN+1
 12418		002000	000000			ZZ=ZZ+ZZ
 12419						IFE	ZZ,<ZZ=1>
 12420	036417	200 00 0 00 070320 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12421	036420	270 00 0 00 070320 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12422	036421	444 00 0 00 070321 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12423	036422	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12424	036423	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12425						STOP^
 12426	036424	254 04 0 00 036425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12427	036425	324 00 0 00 036426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12429									;IN THE SUBTEST) TO LOOP ON ERROR^
 12430
 12431					;**********
 12432
 12433					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12434					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12435					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12436					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12437					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12438					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12439					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12440					;SO THAT A ONE WILL BE FLOATED THROUGH
 12441					;BITS 1 THRU 35 OF BOTH AC AND E
 12442			011236		SN=SN+1
 12443		004000	000000			ZZ=ZZ+ZZ
 12444						IFE	ZZ,<ZZ=1>
 12445	036426	200 00 0 00 070321 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12446	036427	270 00 0 00 070321 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12447	036430	444 00 0 00 070322 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12448	036431	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12449	036432	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12450						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-32
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12451	036433	254 04 0 00 036434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12452	036434	324 00 0 00 036435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12453									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12454									;IN THE SUBTEST) TO LOOP ON ERROR^
 12455
 12456					;**********
 12457
 12458					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12459					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12460					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12461					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12462					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12463					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12464					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12465					;SO THAT A ONE WILL BE FLOATED THROUGH
 12466					;BITS 1 THRU 35 OF BOTH AC AND E
 12467			011237		SN=SN+1
 12468		010000	000000			ZZ=ZZ+ZZ
 12469						IFE	ZZ,<ZZ=1>
 12470	036435	200 00 0 00 070322 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12471	036436	270 00 0 00 070322 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12472	036437	444 00 0 00 070323 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12473	036440	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12474	036441	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12475						STOP^
 12476	036442	254 04 0 00 036443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12477	036443	324 00 0 00 036444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12478									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12479									;IN THE SUBTEST) TO LOOP ON ERROR^
 12480
 12481					;**********
 12482
 12483					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12484					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12485					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12486					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12487					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12488					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12489					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12490					;SO THAT A ONE WILL BE FLOATED THROUGH
 12491					;BITS 1 THRU 35 OF BOTH AC AND E
 12492			011240		SN=SN+1
 12493		020000	000000			ZZ=ZZ+ZZ
 12494						IFE	ZZ,<ZZ=1>
 12495	036444	200 00 0 00 070323 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12496	036445	270 00 0 00 070323 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12497	036446	444 00 0 00 070324 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12498	036447	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12499	036450	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12500						STOP^
 12501	036451	254 04 0 00 036452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12502	036452	324 00 0 00 036453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12503									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12504									;IN THE SUBTEST) TO LOOP ON ERROR^
 12505
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-33
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12506					;**********
 12507
 12508					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12509					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12510					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12511					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12512					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12513					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12514					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12515					;SO THAT A ONE WILL BE FLOATED THROUGH
 12516					;BITS 1 THRU 35 OF BOTH AC AND E
 12517			011241		SN=SN+1
 12518		040000	000000			ZZ=ZZ+ZZ
 12519						IFE	ZZ,<ZZ=1>
 12520	036453	200 00 0 00 070324 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12521	036454	270 00 0 00 070324 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12522	036455	444 00 0 00 070325 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12523	036456	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12524	036457	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12525						STOP^
 12526	036460	254 04 0 00 036461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12527	036461	324 00 0 00 036462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12529									;IN THE SUBTEST) TO LOOP ON ERROR^
 12530
 12531					;**********
 12532
 12533					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12534					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12535					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
 12536					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12537					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12538					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12539					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12540					;SO THAT A ONE WILL BE FLOATED THROUGH
 12541					;BITS 1 THRU 35 OF BOTH AC AND E
 12542			011242		SN=SN+1
 12543		100000	000000			ZZ=ZZ+ZZ
 12544						IFE	ZZ,<ZZ=1>
 12545	036462	200 00 0 00 070325 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12546	036463	270 00 0 00 070325 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12547	036464	444 00 0 00 070326 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12548	036465	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12549	036466	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12550						STOP^
 12551	036467	254 04 0 00 036470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12552	036470	324 00 0 00 036471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12553									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12554									;IN THE SUBTEST) TO LOOP ON ERROR^
 12555
 12556					;**********
 12557
 12558					;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
 12559					;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
 12560					;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-34
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12561					;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
 12562					;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
 12563					;RESULT IN THE AC WILL BE ZERO AND THE TEST
 12564					;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
 12565					;SO THAT A ONE WILL BE FLOATED THROUGH
 12566					;BITS 1 THRU 35 OF BOTH AC AND E
 12567			011243		SN=SN+1
 12568		200000	000000			ZZ=ZZ+ZZ
 12569						IFE	ZZ,<ZZ=1>
 12570	036471	200 00 0 00 070326 		MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
 12571	036472	270 00 0 00 070326 		ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
 12572	036473	444 00 0 00 070256 		EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
 12573	036474	444 00 0 00 070253 		EQV	[0]		;RESULTS IN C(AC)=0
 12574	036475	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12575						STOP^
 12576	036476	254 04 0 00 036477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12577	036477	324 00 0 00 036500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12578									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12579									;IN THE SUBTEST) TO LOOP ON ERROR^
 12580
 12581					;**********
 12582
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12583			011300		SN=11300
 12584			000000			ZZ=0
 12585			000000			YY=0
 12586
 12587					A11300:	REPEAT	^D18,
 12588					<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12589					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12590					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12591					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12592					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12593					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12594					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12595					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12596					;FORMER VALUE PLUS THE CURRENT C(AC)
 12597					SN=SN+1
 12598						YY=YY/2
 12599						ZZ=ZZ+YY
 12600						IFE	YY,<YY=400000>
 12601						IFE	ZZ,<ZZ=400000>
 12602						MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12603						ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12604									;POWER SHOULD RESULT IN C(AC)=0.
 12605						SKIPE			;PASS TEST IF C(AC)=0
 12606						STOP
 12607					
 12608					;**********
 12609					>
 12610					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12611					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12612					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12613					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12614					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12615					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12616					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12617					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12618					;FORMER VALUE PLUS THE CURRENT C(AC)
 12619			011301		SN=SN+1
 12620			000000			YY=YY/2
 12621			000000			ZZ=ZZ+YY
 12622			400000			IFE	YY,<YY=400000>
 12623			400000			IFE	ZZ,<ZZ=400000>
 12624	036500	200 00 0 00 070256 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12625	036501	270 00 0 00 070256 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12626									;POWER SHOULD RESULT IN C(AC)=0.
 12627	036502	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12628						STOP^
 12629	036503	254 04 0 00 036504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12630	036504	324 00 0 00 036505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12632									;IN THE SUBTEST) TO LOOP ON ERROR^
 12633
 12634					;**********
 12635
 12636					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12637					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12638					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12639					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12640					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12641					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12642					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12643					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12644					;FORMER VALUE PLUS THE CURRENT C(AC)
 12645			011302		SN=SN+1
 12646			200000			YY=YY/2
 12647			600000			ZZ=ZZ+YY
 12648						IFE	YY,<YY=400000>
 12649						IFE	ZZ,<ZZ=400000>
 12650	036505	200 00 0 00 070401 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12651	036506	270 00 0 00 070326 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12652									;POWER SHOULD RESULT IN C(AC)=0.
 12653	036507	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12654						STOP^
 12655	036510	254 04 0 00 036511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12656	036511	324 00 0 00 036512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12657									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12658									;IN THE SUBTEST) TO LOOP ON ERROR^
 12659
 12660					;**********
 12661
 12662					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12663					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12664					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12665					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12666					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12667					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12668					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12669					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12670					;FORMER VALUE PLUS THE CURRENT C(AC)
 12671			011303		SN=SN+1
 12672			100000			YY=YY/2
 12673			700000			ZZ=ZZ+YY
 12674						IFE	YY,<YY=400000>
 12675						IFE	ZZ,<ZZ=400000>
 12676	036512	200 00 0 00 070402 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12677	036513	270 00 0 00 070325 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12678									;POWER SHOULD RESULT IN C(AC)=0.
 12679	036514	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12680						STOP^
 12681	036515	254 04 0 00 036516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12682	036516	324 00 0 00 036517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12683									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12684									;IN THE SUBTEST) TO LOOP ON ERROR^
 12685
 12686					;**********
 12687
 12688					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12689					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12690					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12691					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12692					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12693					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12694					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12695					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12696					;FORMER VALUE PLUS THE CURRENT C(AC)
 12697			011304		SN=SN+1
 12698			040000			YY=YY/2
 12699			740000			ZZ=ZZ+YY
 12700						IFE	YY,<YY=400000>
 12701						IFE	ZZ,<ZZ=400000>
 12702	036517	200 00 0 00 070403 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12703	036520	270 00 0 00 070324 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12704									;POWER SHOULD RESULT IN C(AC)=0.
 12705	036521	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12706						STOP^
 12707	036522	254 04 0 00 036523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12708	036523	324 00 0 00 036524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12709									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12710									;IN THE SUBTEST) TO LOOP ON ERROR^
 12711
 12712					;**********
 12713
 12714					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12715					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12716					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12717					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12718					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12719					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12720					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12721					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12722					;FORMER VALUE PLUS THE CURRENT C(AC)
 12723			011305		SN=SN+1
 12724			020000			YY=YY/2
 12725			760000			ZZ=ZZ+YY
 12726						IFE	YY,<YY=400000>
 12727						IFE	ZZ,<ZZ=400000>
 12728	036524	200 00 0 00 070404 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12729	036525	270 00 0 00 070323 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12730									;POWER SHOULD RESULT IN C(AC)=0.
 12731	036526	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12732						STOP^
 12733	036527	254 04 0 00 036530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12734	036530	324 00 0 00 036531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12735									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12736									;IN THE SUBTEST) TO LOOP ON ERROR^
 12737
 12738					;**********
 12739
 12740					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12741					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12742					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12743					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12744					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12745					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12746					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12747					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12748					;FORMER VALUE PLUS THE CURRENT C(AC)
 12749			011306		SN=SN+1
 12750			010000			YY=YY/2
 12751			770000			ZZ=ZZ+YY
 12752						IFE	YY,<YY=400000>
 12753						IFE	ZZ,<ZZ=400000>
 12754	036531	200 00 0 00 070405 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12755	036532	270 00 0 00 070322 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12756									;POWER SHOULD RESULT IN C(AC)=0.
 12757	036533	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12758						STOP^
 12759	036534	254 04 0 00 036535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12760	036535	324 00 0 00 036536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12762									;IN THE SUBTEST) TO LOOP ON ERROR^
 12763
 12764					;**********
 12765
 12766					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12767					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12768					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12769					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12770					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12771					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12772					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12773					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12774					;FORMER VALUE PLUS THE CURRENT C(AC)
 12775			011307		SN=SN+1
 12776			004000			YY=YY/2
 12777			774000			ZZ=ZZ+YY
 12778						IFE	YY,<YY=400000>
 12779						IFE	ZZ,<ZZ=400000>
 12780	036536	200 00 0 00 070406 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12781	036537	270 00 0 00 070321 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12782									;POWER SHOULD RESULT IN C(AC)=0.
 12783	036540	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12784						STOP^
 12785	036541	254 04 0 00 036542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12786	036542	324 00 0 00 036543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12787									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12788									;IN THE SUBTEST) TO LOOP ON ERROR^
 12789
 12790					;**********
 12791
 12792					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12793					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12794					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12795					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12796					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12797					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12798					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12799					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12800					;FORMER VALUE PLUS THE CURRENT C(AC)
 12801			011310		SN=SN+1
 12802			002000			YY=YY/2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12803			776000			ZZ=ZZ+YY
 12804						IFE	YY,<YY=400000>
 12805						IFE	ZZ,<ZZ=400000>
 12806	036543	200 00 0 00 070407 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12807	036544	270 00 0 00 070320 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12808									;POWER SHOULD RESULT IN C(AC)=0.
 12809	036545	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12810						STOP^
 12811	036546	254 04 0 00 036547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12812	036547	324 00 0 00 036550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12813									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12814									;IN THE SUBTEST) TO LOOP ON ERROR^
 12815
 12816					;**********
 12817
 12818					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12819					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12820					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12821					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12822					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12823					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12824					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12825					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12826					;FORMER VALUE PLUS THE CURRENT C(AC)
 12827			011311		SN=SN+1
 12828			001000			YY=YY/2
 12829			777000			ZZ=ZZ+YY
 12830						IFE	YY,<YY=400000>
 12831						IFE	ZZ,<ZZ=400000>
 12832	036550	200 00 0 00 070257 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12833	036551	270 00 0 00 070317 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12834									;POWER SHOULD RESULT IN C(AC)=0.
 12835	036552	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12836						STOP^
 12837	036553	254 04 0 00 036554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12838	036554	324 00 0 00 036555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12840									;IN THE SUBTEST) TO LOOP ON ERROR^
 12841
 12842					;**********
 12843
 12844					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12845					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12846					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12847					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12848					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12849					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12850					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12851					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12852					;FORMER VALUE PLUS THE CURRENT C(AC)
 12853			011312		SN=SN+1
 12854			000400			YY=YY/2
 12855			777400			ZZ=ZZ+YY
 12856						IFE	YY,<YY=400000>
 12857						IFE	ZZ,<ZZ=400000>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12858	036555	200 00 0 00 070410 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12859	036556	270 00 0 00 070264 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12860									;POWER SHOULD RESULT IN C(AC)=0.
 12861	036557	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12862						STOP^
 12863	036560	254 04 0 00 036561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12864	036561	324 00 0 00 036562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12865									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12866									;IN THE SUBTEST) TO LOOP ON ERROR^
 12867
 12868					;**********
 12869
 12870					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12871					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12872					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12873					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12874					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12875					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12876					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12877					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12878					;FORMER VALUE PLUS THE CURRENT C(AC)
 12879			011313		SN=SN+1
 12880			000200			YY=YY/2
 12881			777600			ZZ=ZZ+YY
 12882						IFE	YY,<YY=400000>
 12883						IFE	ZZ,<ZZ=400000>
 12884	036562	200 00 0 00 070411 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12885	036563	270 00 0 00 070316 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12886									;POWER SHOULD RESULT IN C(AC)=0.
 12887	036564	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12888						STOP^
 12889	036565	254 04 0 00 036566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12890	036566	324 00 0 00 036567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12891									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12892									;IN THE SUBTEST) TO LOOP ON ERROR^
 12893
 12894					;**********
 12895
 12896					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12897					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12898					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12899					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12900					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12901					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12902					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12903					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12904					;FORMER VALUE PLUS THE CURRENT C(AC)
 12905			011314		SN=SN+1
 12906			000100			YY=YY/2
 12907			777700			ZZ=ZZ+YY
 12908						IFE	YY,<YY=400000>
 12909						IFE	ZZ,<ZZ=400000>
 12910	036567	200 00 0 00 070412 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12911	036570	270 00 0 00 070315 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12912									;POWER SHOULD RESULT IN C(AC)=0.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12913	036571	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12914						STOP^
 12915	036572	254 04 0 00 036573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12916	036573	324 00 0 00 036574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12918									;IN THE SUBTEST) TO LOOP ON ERROR^
 12919
 12920					;**********
 12921
 12922					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12923					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12924					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12925					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12926					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12927					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12928					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12929					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12930					;FORMER VALUE PLUS THE CURRENT C(AC)
 12931			011315		SN=SN+1
 12932			000040			YY=YY/2
 12933			777740			ZZ=ZZ+YY
 12934						IFE	YY,<YY=400000>
 12935						IFE	ZZ,<ZZ=400000>
 12936	036574	200 00 0 00 070413 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12937	036575	270 00 0 00 070314 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12938									;POWER SHOULD RESULT IN C(AC)=0.
 12939	036576	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12940						STOP^
 12941	036577	254 04 0 00 036600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12942	036600	324 00 0 00 036601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12943									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12944									;IN THE SUBTEST) TO LOOP ON ERROR^
 12945
 12946					;**********
 12947
 12948					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12949					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12950					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12951					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12952					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12953					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12954					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12955					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12956					;FORMER VALUE PLUS THE CURRENT C(AC)
 12957			011316		SN=SN+1
 12958			000020			YY=YY/2
 12959			777760			ZZ=ZZ+YY
 12960						IFE	YY,<YY=400000>
 12961						IFE	ZZ,<ZZ=400000>
 12962	036601	200 00 0 00 070414 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12963	036602	270 00 0 00 070313 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12964									;POWER SHOULD RESULT IN C(AC)=0.
 12965	036603	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12966						STOP^
 12967	036604	254 04 0 00 036605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 12968	036605	324 00 0 00 036606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12970									;IN THE SUBTEST) TO LOOP ON ERROR^
 12971
 12972					;**********
 12973
 12974					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 12975					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 12976					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 12977					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 12978					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 12979					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 12980					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 12981					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 12982					;FORMER VALUE PLUS THE CURRENT C(AC)
 12983			011317		SN=SN+1
 12984			000010			YY=YY/2
 12985			777770			ZZ=ZZ+YY
 12986						IFE	YY,<YY=400000>
 12987						IFE	ZZ,<ZZ=400000>
 12988	036606	200 00 0 00 070415 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 12989	036607	270 00 0 00 070312 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 12990									;POWER SHOULD RESULT IN C(AC)=0.
 12991	036610	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 12992						STOP^
 12993	036611	254 04 0 00 036612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 12994	036612	324 00 0 00 036613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 12995									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 12996									;IN THE SUBTEST) TO LOOP ON ERROR^
 12997
 12998					;**********
 12999
 13000					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13001					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13002					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13003					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 13004					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13005					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13006					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13007					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 13008					;FORMER VALUE PLUS THE CURRENT C(AC)
 13009			011320		SN=SN+1
 13010			000004			YY=YY/2
 13011			777774			ZZ=ZZ+YY
 13012						IFE	YY,<YY=400000>
 13013						IFE	ZZ,<ZZ=400000>
 13014	036613	200 00 0 00 070416 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13015	036614	270 00 0 00 070311 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13016									;POWER SHOULD RESULT IN C(AC)=0.
 13017	036615	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13018						STOP^
 13019	036616	254 04 0 00 036617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13020	036617	324 00 0 00 036620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13021									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13022									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13023
 13024					;**********
 13025
 13026					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13027					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13028					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13029					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 13030					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13031					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13032					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13033					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 13034					;FORMER VALUE PLUS THE CURRENT C(AC)
 13035			011321		SN=SN+1
 13036			000002			YY=YY/2
 13037			777776			ZZ=ZZ+YY
 13038						IFE	YY,<YY=400000>
 13039						IFE	ZZ,<ZZ=400000>
 13040	036620	200 00 0 00 070417 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13041	036621	270 00 0 00 070310 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13042									;POWER SHOULD RESULT IN C(AC)=0.
 13043	036622	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13044						STOP^
 13045	036623	254 04 0 00 036624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13046	036624	324 00 0 00 036625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13047									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13048									;IN THE SUBTEST) TO LOOP ON ERROR^
 13049
 13050					;**********
 13051
 13052					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13053					;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13054					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13055					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
 13056					;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13057					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13058					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13059					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
 13060					;FORMER VALUE PLUS THE CURRENT C(AC)
 13061			011322		SN=SN+1
 13062			000001			YY=YY/2
 13063			777777			ZZ=ZZ+YY
 13064						IFE	YY,<YY=400000>
 13065						IFE	ZZ,<ZZ=400000>
 13066	036625	200 00 0 00 070331 		MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13067	036626	270 00 0 00 070307 		ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13068									;POWER SHOULD RESULT IN C(AC)=0.
 13069	036627	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13070						STOP^
 13071	036630	254 04 0 00 036631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13072	036631	324 00 0 00 036632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13073									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13074									;IN THE SUBTEST) TO LOOP ON ERROR^
 13075
 13076					;**********
 13077
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-9
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13078					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-10
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13079			011400		SN=11400
 13080			000000			ZZ=0
 13081			000000			YY=0
 13082
 13083					A11400:	REPEAT	^D18,
 13084					<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13085					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13086					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13087					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13088					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13089					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13090					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13091					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13092					;FORMER VALUE PLUS THE CURRENT C(AC)
 13093					SN=SN+1
 13094						YY=YY/2
 13095						ZZ=ZZ+YY
 13096						IFE	YY,<YY=400000>
 13097						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13098						MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13099									;POWER SHOULD RESULT IN C(AC)=0.
 13100						ADD	[YY]		;PASS TEST IF C(AC)=0
 13101						SKIPE
 13102						STOP
 13103					
 13104					;**********
 13105					>
 13106					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13107					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13108					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13109					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13110					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13111					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13112					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13113					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13114					;FORMER VALUE PLUS THE CURRENT C(AC)
 13115			011401		SN=SN+1
 13116			000000			YY=YY/2
 13117			000000			ZZ=ZZ+YY
 13118			400000			IFE	YY,<YY=400000>
 13119			400000			IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13120	036632	200 00 0 00 070420 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13121									;POWER SHOULD RESULT IN C(AC)=0.
 13122	036633	270 00 0 00 070306 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13123	036634	332 00 0 00 000000 		SKIPE
 13124						STOP^
 13125	036635	254 04 0 00 036636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13126	036636	324 00 0 00 036637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13128									;IN THE SUBTEST) TO LOOP ON ERROR^
 13129
 13130					;**********
 13131
 13132					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13133					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-11
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13134					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13135					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13136					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13137					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13138					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13139					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13140					;FORMER VALUE PLUS THE CURRENT C(AC)
 13141			011402		SN=SN+1
 13142			200000			YY=YY/2
 13143			600000			ZZ=ZZ+YY
 13144						IFE	YY,<YY=400000>
 13145						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13146	036637	200 00 0 00 070421 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13147									;POWER SHOULD RESULT IN C(AC)=0.
 13148	036640	270 00 0 00 070305 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13149	036641	332 00 0 00 000000 		SKIPE
 13150						STOP^
 13151	036642	254 04 0 00 036643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13152	036643	324 00 0 00 036644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13154									;IN THE SUBTEST) TO LOOP ON ERROR^
 13155
 13156					;**********
 13157
 13158					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13159					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13160					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13161					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13162					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13163					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13164					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13165					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13166					;FORMER VALUE PLUS THE CURRENT C(AC)
 13167			011403		SN=SN+1
 13168			100000			YY=YY/2
 13169			700000			ZZ=ZZ+YY
 13170						IFE	YY,<YY=400000>
 13171						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13172	036644	200 00 0 00 070422 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13173									;POWER SHOULD RESULT IN C(AC)=0.
 13174	036645	270 00 0 00 070304 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13175	036646	332 00 0 00 000000 		SKIPE
 13176						STOP^
 13177	036647	254 04 0 00 036650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13178	036650	324 00 0 00 036651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13180									;IN THE SUBTEST) TO LOOP ON ERROR^
 13181
 13182					;**********
 13183
 13184					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13185					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13186					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13187					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13188					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-12
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13189					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13190					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13191					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13192					;FORMER VALUE PLUS THE CURRENT C(AC)
 13193			011404		SN=SN+1
 13194			040000			YY=YY/2
 13195			740000			ZZ=ZZ+YY
 13196						IFE	YY,<YY=400000>
 13197						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13198	036651	200 00 0 00 070423 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13199									;POWER SHOULD RESULT IN C(AC)=0.
 13200	036652	270 00 0 00 070303 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13201	036653	332 00 0 00 000000 		SKIPE
 13202						STOP^
 13203	036654	254 04 0 00 036655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13204	036655	324 00 0 00 036656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13206									;IN THE SUBTEST) TO LOOP ON ERROR^
 13207
 13208					;**********
 13209
 13210					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13211					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13212					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13213					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13214					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13215					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13216					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13217					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13218					;FORMER VALUE PLUS THE CURRENT C(AC)
 13219			011405		SN=SN+1
 13220			020000			YY=YY/2
 13221			760000			ZZ=ZZ+YY
 13222						IFE	YY,<YY=400000>
 13223						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13224	036656	200 00 0 00 070424 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13225									;POWER SHOULD RESULT IN C(AC)=0.
 13226	036657	270 00 0 00 070302 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13227	036660	332 00 0 00 000000 		SKIPE
 13228						STOP^
 13229	036661	254 04 0 00 036662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13230	036662	324 00 0 00 036663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13232									;IN THE SUBTEST) TO LOOP ON ERROR^
 13233
 13234					;**********
 13235
 13236					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13237					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13238					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13239					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13240					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13241					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13242					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13243					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-13
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13244					;FORMER VALUE PLUS THE CURRENT C(AC)
 13245			011406		SN=SN+1
 13246			010000			YY=YY/2
 13247			770000			ZZ=ZZ+YY
 13248						IFE	YY,<YY=400000>
 13249						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13250	036663	200 00 0 00 070425 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13251									;POWER SHOULD RESULT IN C(AC)=0.
 13252	036664	270 00 0 00 070301 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13253	036665	332 00 0 00 000000 		SKIPE
 13254						STOP^
 13255	036666	254 04 0 00 036667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13256	036667	324 00 0 00 036670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13257									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13258									;IN THE SUBTEST) TO LOOP ON ERROR^
 13259
 13260					;**********
 13261
 13262					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13263					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13264					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13265					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13266					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13267					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13268					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13269					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13270					;FORMER VALUE PLUS THE CURRENT C(AC)
 13271			011407		SN=SN+1
 13272			004000			YY=YY/2
 13273			774000			ZZ=ZZ+YY
 13274						IFE	YY,<YY=400000>
 13275						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13276	036670	200 00 0 00 070426 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13277									;POWER SHOULD RESULT IN C(AC)=0.
 13278	036671	270 00 0 00 070300 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13279	036672	332 00 0 00 000000 		SKIPE
 13280						STOP^
 13281	036673	254 04 0 00 036674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13282	036674	324 00 0 00 036675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13283									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13284									;IN THE SUBTEST) TO LOOP ON ERROR^
 13285
 13286					;**********
 13287
 13288					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13289					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13290					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13291					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13292					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13293					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13294					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13295					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13296					;FORMER VALUE PLUS THE CURRENT C(AC)
 13297			011410		SN=SN+1
 13298			002000			YY=YY/2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-14
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13299			776000			ZZ=ZZ+YY
 13300						IFE	YY,<YY=400000>
 13301						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13302	036675	200 00 0 00 070427 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13303									;POWER SHOULD RESULT IN C(AC)=0.
 13304	036676	270 00 0 00 070277 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13305	036677	332 00 0 00 000000 		SKIPE
 13306						STOP^
 13307	036700	254 04 0 00 036701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13308	036701	324 00 0 00 036702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13310									;IN THE SUBTEST) TO LOOP ON ERROR^
 13311
 13312					;**********
 13313
 13314					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13315					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13316					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13317					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13318					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13319					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13320					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13321					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13322					;FORMER VALUE PLUS THE CURRENT C(AC)
 13323			011411		SN=SN+1
 13324			001000			YY=YY/2
 13325			777000			ZZ=ZZ+YY
 13326						IFE	YY,<YY=400000>
 13327						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13328	036702	200 00 0 00 070430 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13329									;POWER SHOULD RESULT IN C(AC)=0.
 13330	036703	270 00 0 00 070276 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13331	036704	332 00 0 00 000000 		SKIPE
 13332						STOP^
 13333	036705	254 04 0 00 036706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13334	036706	324 00 0 00 036707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13335									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13336									;IN THE SUBTEST) TO LOOP ON ERROR^
 13337
 13338					;**********
 13339
 13340					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13341					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13342					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13343					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13344					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13345					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13346					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13347					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13348					;FORMER VALUE PLUS THE CURRENT C(AC)
 13349			011412		SN=SN+1
 13350			000400			YY=YY/2
 13351			777400			ZZ=ZZ+YY
 13352						IFE	YY,<YY=400000>
 13353						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-15
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13354	036707	200 00 0 00 070431 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13355									;POWER SHOULD RESULT IN C(AC)=0.
 13356	036710	270 00 0 00 070275 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13357	036711	332 00 0 00 000000 		SKIPE
 13358						STOP^
 13359	036712	254 04 0 00 036713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13360	036713	324 00 0 00 036714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13362									;IN THE SUBTEST) TO LOOP ON ERROR^
 13363
 13364					;**********
 13365
 13366					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13367					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13368					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13369					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13370					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13371					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13372					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13373					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13374					;FORMER VALUE PLUS THE CURRENT C(AC)
 13375			011413		SN=SN+1
 13376			000200			YY=YY/2
 13377			777600			ZZ=ZZ+YY
 13378						IFE	YY,<YY=400000>
 13379						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13380	036714	200 00 0 00 070432 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13381									;POWER SHOULD RESULT IN C(AC)=0.
 13382	036715	270 00 0 00 070274 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13383	036716	332 00 0 00 000000 		SKIPE
 13384						STOP^
 13385	036717	254 04 0 00 036720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13386	036720	324 00 0 00 036721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13387									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13388									;IN THE SUBTEST) TO LOOP ON ERROR^
 13389
 13390					;**********
 13391
 13392					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13393					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13394					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13395					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13396					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13397					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13398					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13399					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13400					;FORMER VALUE PLUS THE CURRENT C(AC)
 13401			011414		SN=SN+1
 13402			000100			YY=YY/2
 13403			777700			ZZ=ZZ+YY
 13404						IFE	YY,<YY=400000>
 13405						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13406	036721	200 00 0 00 070433 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13407									;POWER SHOULD RESULT IN C(AC)=0.
 13408	036722	270 00 0 00 070273 		ADD	[YY]		;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-16
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13409	036723	332 00 0 00 000000 		SKIPE
 13410						STOP^
 13411	036724	254 04 0 00 036725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13412	036725	324 00 0 00 036726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13413									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13414									;IN THE SUBTEST) TO LOOP ON ERROR^
 13415
 13416					;**********
 13417
 13418					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13419					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13420					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13421					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13422					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13423					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13424					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13425					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13426					;FORMER VALUE PLUS THE CURRENT C(AC)
 13427			011415		SN=SN+1
 13428			000040			YY=YY/2
 13429			777740			ZZ=ZZ+YY
 13430						IFE	YY,<YY=400000>
 13431						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13432	036726	200 00 0 00 070434 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13433									;POWER SHOULD RESULT IN C(AC)=0.
 13434	036727	270 00 0 00 070272 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13435	036730	332 00 0 00 000000 		SKIPE
 13436						STOP^
 13437	036731	254 04 0 00 036732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13438	036732	324 00 0 00 036733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13439									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13440									;IN THE SUBTEST) TO LOOP ON ERROR^
 13441
 13442					;**********
 13443
 13444					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13445					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13446					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13447					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13448					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13449					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13450					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13451					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13452					;FORMER VALUE PLUS THE CURRENT C(AC)
 13453			011416		SN=SN+1
 13454			000020			YY=YY/2
 13455			777760			ZZ=ZZ+YY
 13456						IFE	YY,<YY=400000>
 13457						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13458	036733	200 00 0 00 070435 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13459									;POWER SHOULD RESULT IN C(AC)=0.
 13460	036734	270 00 0 00 070271 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13461	036735	332 00 0 00 000000 		SKIPE
 13462						STOP^
 13463	036736	254 04 0 00 036737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-17
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13464	036737	324 00 0 00 036740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13465									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13466									;IN THE SUBTEST) TO LOOP ON ERROR^
 13467
 13468					;**********
 13469
 13470					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13471					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13472					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13473					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13474					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13475					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13476					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13477					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13478					;FORMER VALUE PLUS THE CURRENT C(AC)
 13479			011417		SN=SN+1
 13480			000010			YY=YY/2
 13481			777770			ZZ=ZZ+YY
 13482						IFE	YY,<YY=400000>
 13483						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13484	036740	200 00 0 00 070436 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13485									;POWER SHOULD RESULT IN C(AC)=0.
 13486	036741	270 00 0 00 070270 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13487	036742	332 00 0 00 000000 		SKIPE
 13488						STOP^
 13489	036743	254 04 0 00 036744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13490	036744	324 00 0 00 036745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13491									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13492									;IN THE SUBTEST) TO LOOP ON ERROR^
 13493
 13494					;**********
 13495
 13496					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13497					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13498					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13499					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13500					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13501					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13502					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13503					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13504					;FORMER VALUE PLUS THE CURRENT C(AC)
 13505			011420		SN=SN+1
 13506			000004			YY=YY/2
 13507			777774			ZZ=ZZ+YY
 13508						IFE	YY,<YY=400000>
 13509						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13510	036745	200 00 0 00 070437 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13511									;POWER SHOULD RESULT IN C(AC)=0.
 13512	036746	270 00 0 00 070267 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13513	036747	332 00 0 00 000000 		SKIPE
 13514						STOP^
 13515	036750	254 04 0 00 036751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13516	036751	324 00 0 00 036752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13518									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-18
DFKAA2	MAC	13-Jan-89 10:22		TEST OF THE ADD INSTRUCTION

 13519
 13520					;**********
 13521
 13522					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13523					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13524					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13525					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13526					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13527					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13528					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13529					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13530					;FORMER VALUE PLUS THE CURRENT C(AC)
 13531			011421		SN=SN+1
 13532			000002			YY=YY/2
 13533			777776			ZZ=ZZ+YY
 13534						IFE	YY,<YY=400000>
 13535						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13536	036752	200 00 0 00 070333 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13537									;POWER SHOULD RESULT IN C(AC)=0.
 13538	036753	270 00 0 00 070266 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13539	036754	332 00 0 00 000000 		SKIPE
 13540						STOP^
 13541	036755	254 04 0 00 036756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13542	036756	324 00 0 00 036757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13543									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13544									;IN THE SUBTEST) TO LOOP ON ERROR^
 13545
 13546					;**********
 13547
 13548					;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
 13549					;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
 13550					;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
 13551					;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
 13552					;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
 13553					;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
 13554					;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
 13555					;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
 13556					;FORMER VALUE PLUS THE CURRENT C(AC)
 13557			011422		SN=SN+1
 13558			000001			YY=YY/2
 13559			777777			ZZ=ZZ+YY
 13560						IFE	YY,<YY=400000>
 13561						IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
 13562	036757	200 00 0 00 070254 		MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
 13563									;POWER SHOULD RESULT IN C(AC)=0.
 13564	036760	270 00 0 00 070265 		ADD	[YY]		;PASS TEST IF C(AC)=0
 13565	036761	332 00 0 00 000000 		SKIPE
 13566						STOP^
 13567	036762	254 04 0 00 036763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13568	036763	324 00 0 00 036764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13569									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13570									;IN THE SUBTEST) TO LOOP ON ERROR^
 13571
 13572					;**********
 13573
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA2	MAC	13-Jan-89 10:22		SPECIAL KI10 FOUR BIT ADDER TEST

 13574					SUBTTL	SPECIAL KI10 FOUR BIT ADDER TEST
 13575
 13576					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13577					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13578					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 33 TO BIT 32.
 13579
 13580	036764	200 00 0 00 070335 	A13500:	MOVE	[-1,,-5]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 33
 13581	036765	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 33 TO BIT 32
 13582	036766	444 00 0 00 070437 		EQV	[-1,,-4]	;RESULT IN AC=ALL ONES
 13583	036767	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13584	036770	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13585						STOP^
 13586	036771	254 04 0 00 036772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13587	036772	324 00 0 00 036773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13588									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13589									;IN THE SUBTEST) TO LOOP ON ERROR^
 13590
 13591					;**********
 13592
 13593					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13594					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13595					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 29 TO BIT 28.
 13596
 13597	036773	200 00 0 00 070341 	A13600:	MOVE	[-1,,-101]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 29
 13598	036774	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 29 TO BIT 28
 13599	036775	444 00 0 00 070433 		EQV	[-1,,-100]	;RESULT IN AC=ALL ONES
 13600	036776	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13601	036777	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13602						STOP^
 13603	037000	254 04 0 00 037001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13604	037001	324 00 0 00 037002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13605									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13606									;IN THE SUBTEST) TO LOOP ON ERROR^
 13607
 13608					;**********
 13609
 13610					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13611					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13612					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 25 TO BIT 24.
 13613
 13614	037002	200 00 0 00 070345 	A13700:	MOVE	[-1,,-2001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 25
 13615	037003	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 25 TO BIT 24
 13616	037004	444 00 0 00 070427 		EQV	[-1,,-2000]	;RESULT IN AC=ALL ONES
 13617	037005	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13618	037006	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13619						STOP^
 13620	037007	254 04 0 00 037010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13621	037010	324 00 0 00 037011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13623									;IN THE SUBTEST) TO LOOP ON ERROR^
 13624
 13625					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA2	MAC	13-Jan-89 10:22		SPECIAL KI10 FOUR BIT ADDER TEST

 13626					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13627					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13628					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 21 TO BIT 20.
 13629
 13630	037011	200 00 0 00 070351 	A14000:	MOVE	[-1,,-40001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 21
 13631	037012	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 21 TO BIT 20
 13632	037013	444 00 0 00 070423 		EQV	[-1,,-40000]	;RESULT IN AC=ALL ONES
 13633	037014	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13634	037015	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13635						STOP^
 13636	037016	254 04 0 00 037017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13637	037017	324 00 0 00 037020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13638									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13639									;IN THE SUBTEST) TO LOOP ON ERROR^
 13640
 13641					;**********
 13642
 13643					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13644					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13645					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 18 TO BIT 17.
 13646
 13647	037020	200 00 0 00 070354 	A14100:	MOVE	[-1,,-400001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 18
 13648	037021	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 18 TO BIT 17
 13649	037022	444 00 0 00 070420 		EQV	[-1,,400000]	;RESULT IN AC=ALL ONES
 13650	037023	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13651	037024	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13652						STOP^
 13653	037025	254 04 0 00 037026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13654	037026	324 00 0 00 037027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13656									;IN THE SUBTEST) TO LOOP ON ERROR^
 13657
 13658					;**********
 13659
 13660					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13661					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13662					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 14 TO BIT 13.
 13663
 13664	037027	200 00 0 00 070360 	A14200:	MOVE	[-11,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 14
 13665	037030	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 14 TO BIT 13
 13666	037031	444 00 0 00 070415 		EQV	[-10,,0]	;RESULT IN AC=ALL ONES
 13667	037032	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13668	037033	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13669						STOP^
 13670	037034	254 04 0 00 037035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13671	037035	324 00 0 00 037036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13673									;IN THE SUBTEST) TO LOOP ON ERROR^
 13674
 13675					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA2	MAC	13-Jan-89 10:22		SPECIAL KI10 FOUR BIT ADDER TEST

 13676					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13677					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13678					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 10 TO BIT 9.
 13679
 13680	037036	200 00 0 00 070364 	A14300:	MOVE	[-201,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 10
 13681	037037	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 10 TO BIT 9
 13682	037040	444 00 0 00 070411 		EQV	[-200,,0]	;RESULT IN AC=ALL ONES
 13683	037041	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13684	037042	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13685						STOP^
 13686	037043	254 04 0 00 037044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13687	037044	324 00 0 00 037045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13688									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13689									;IN THE SUBTEST) TO LOOP ON ERROR^
 13690
 13691					;**********
 13692
 13693					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13694					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13695					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 6 TO BIT 5.
 13696
 13697	037045	200 00 0 00 070370 	A14400:	MOVE	[-4001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 6
 13698	037046	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 6 TO BIT 5
 13699	037047	444 00 0 00 070406 		EQV	[-4000,,0]	;RESULT IN AC=ALL ONES
 13700	037050	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13701	037051	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13702						STOP^
 13703	037052	254 04 0 00 037053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13704	037053	324 00 0 00 037054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13706									;IN THE SUBTEST) TO LOOP ON ERROR^
 13707
 13708					;**********
 13709
 13710					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13711					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13712					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 2 TO BIT 1.
 13713
 13714	037054	200 00 0 00 070374 	A14500:	MOVE	[-100001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 2
 13715	037055	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 2 TO BIT 1
 13716	037056	444 00 0 00 070402 		EQV	[-100000,,0]	;RESULT IN AC=ALL ONES
 13717	037057	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13718	037060	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13719						STOP^
 13720	037061	254 04 0 00 037062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13721	037062	324 00 0 00 037063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13722									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13723									;IN THE SUBTEST) TO LOOP ON ERROR^
 13724
 13725					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11
DFKAA2	MAC	13-Jan-89 10:22		SPECIAL KI10 FOUR BIT ADDER TEST

 13726					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13727					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13728					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 1 TO BIT 0.
 13729
 13730	037063	200 00 0 00 070375 	A14600:	MOVE	[-200001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 1
 13731	037064	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 1 TO BIT 0
 13732	037065	444 00 0 00 070401 		EQV	[600000,,0]	;RESULT IN AC=ALL ONES
 13733	037066	444 00 0 00 070253 		EQV	[0]		;RESULT IN AC=0
 13734	037067	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13735						STOP^
 13736	037070	254 04 0 00 037071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13737	037071	324 00 0 00 037072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13738									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13739									;IN THE SUBTEST) TO LOOP ON ERROR^
 13740
 13741					;**********
 13742
 13743					;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
 13744					;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
 13745					;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT -1TO BIT 35.
 13746
 13747	037072	200 00 0 00 070254 	A14700:	MOVE	[-1,,-1]	;PRESET AC WITH ALL ONES
 13748	037073	270 00 0 00 070265 		ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT -1 TO BIT 35
 13749	037074	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13750						STOP^
 13751	037075	254 04 0 00 037076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13752	037076	324 00 0 00 037077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13753									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13754									;IN THE SUBTEST) TO LOOP ON ERROR^
 13755
 13756					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 13757					SUBTTL	TEST OF SUB AND COMPARE INSTRUCTIONS
 13758
 13759					;THIS TEST VERIFIES THAT IF A NON ZERO POSITIVE NUMBER IN E IS
 13760					;SUBTRACTED FROM THE AC WHEN C(AC)=0, THE RESULT IN THE AC
 13761					;IS NEGATIVE
 13762
 13763	037077	200 00 0 00 070253 	A11500:	MOVE	[0]		;PRESET AC TO ZERO
 13764	037100	274 00 0 00 070330 		SUB	[XWD 0,-1]	;*SUB OF POSITIVE NONZERO NUMBER FROM AC OF ALL ZEROS
 13765									;SHOULD RESULT IN C(AC) NEGATIVE
 13766	037101	331 00 0 00 000000 		SKIPL			;PASS TEST IF C(AC) IS NEGATIVE
 13767						STOP^
 13768	037102	254 04 0 00 037103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13769	037103	324 00 0 00 037104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13771									;IN THE SUBTEST) TO LOOP ON ERROR^
 13772
 13773					;AD AR- EN D [ADAM], F CYC ACT ENB [F1],
 13774					;IR SUBX[IR1], IR ADSUB[IR1]
 13775
 13776					;**********
 13777
 13778					;THIS TEST VERIFIES THAT IF A WORD OF ALL ZEROS IS
 13779					;SUBTRACTED FROM AN AC OF ALL ZEROS, THE RESULT
 13780					;IS AN AC OF ZEROS.
 13781
 13782	037104	200 00 0 00 070253 	A11600:	MOVE	[0]		;PRESET AC TO ZERO
 13783	037105	274 00 0 00 070253 		SUB	[0]		;*SUB OF 0 FROM 0 SHOULD RESULT IN C(AC)=0
 13784	037106	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13785						STOP^
 13786	037107	254 04 0 00 037110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13787	037110	324 00 0 00 037111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13788									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13789									;IN THE SUBTEST) TO LOOP ON ERROR^
 13790					;AD CRY 36[ADCR], F CYC ACT EN D[F1], IF SUBX [IR1]
 13791
 13792					;**********
 13793					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 13794			011700		SN=11700
 13795			000000			ZZ=0
 13796
 13797					A11700:	REPEAT	^D36,
 13798					<;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13799					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13800					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13801					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13802					SN=SN+1
 13803						ZZ=ZZ+ZZ
 13804						IFE	ZZ,<ZZ=1>
 13805						MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13806						SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13807						SKIPE			;PASS TEST IF C(AC)=0
 13808						STOP
 13809					
 13810					;**********
 13811					>
 13812					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13813					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13814					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13815					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13816			011701		SN=SN+1
 13817			000000			ZZ=ZZ+ZZ
 13818			000001			IFE	ZZ,<ZZ=1>
 13819	037111	200 00 0 00 070265 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13820	037112	274 00 0 00 070265 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13821	037113	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13822						STOP^
 13823	037114	254 04 0 00 037115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13824	037115	324 00 0 00 037116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13826									;IN THE SUBTEST) TO LOOP ON ERROR^
 13827
 13828					;**********
 13829
 13830					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13831					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13832					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13833					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13834			011702		SN=SN+1
 13835			000002			ZZ=ZZ+ZZ
 13836						IFE	ZZ,<ZZ=1>
 13837	037116	200 00 0 00 070266 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13838	037117	274 00 0 00 070266 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13839	037120	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13840						STOP^
 13841	037121	254 04 0 00 037122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13842	037122	324 00 0 00 037123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13843									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13844									;IN THE SUBTEST) TO LOOP ON ERROR^
 13845
 13846					;**********
 13847
 13848					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 13849					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13850					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13851					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13852			011703		SN=SN+1
 13853			000004			ZZ=ZZ+ZZ
 13854						IFE	ZZ,<ZZ=1>
 13855	037123	200 00 0 00 070267 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13856	037124	274 00 0 00 070267 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13857	037125	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13858						STOP^
 13859	037126	254 04 0 00 037127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13860	037127	324 00 0 00 037130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13861									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13862									;IN THE SUBTEST) TO LOOP ON ERROR^
 13863
 13864					;**********
 13865
 13866					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13867					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13868					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13869					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13870			011704		SN=SN+1
 13871			000010			ZZ=ZZ+ZZ
 13872						IFE	ZZ,<ZZ=1>
 13873	037130	200 00 0 00 070270 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13874	037131	274 00 0 00 070270 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13875	037132	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13876						STOP^
 13877	037133	254 04 0 00 037134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13878	037134	324 00 0 00 037135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13879									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13880									;IN THE SUBTEST) TO LOOP ON ERROR^
 13881
 13882					;**********
 13883
 13884					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13885					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13886					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13887					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13888			011705		SN=SN+1
 13889			000020			ZZ=ZZ+ZZ
 13890						IFE	ZZ,<ZZ=1>
 13891	037135	200 00 0 00 070271 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13892	037136	274 00 0 00 070271 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13893	037137	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13894						STOP^
 13895	037140	254 04 0 00 037141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13896	037141	324 00 0 00 037142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13897									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13898									;IN THE SUBTEST) TO LOOP ON ERROR^
 13899
 13900					;**********
 13901
 13902					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13903					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 13904					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13905					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13906			011706		SN=SN+1
 13907			000040			ZZ=ZZ+ZZ
 13908						IFE	ZZ,<ZZ=1>
 13909	037142	200 00 0 00 070272 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13910	037143	274 00 0 00 070272 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13911	037144	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13912						STOP^
 13913	037145	254 04 0 00 037146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13914	037146	324 00 0 00 037147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13916									;IN THE SUBTEST) TO LOOP ON ERROR^
 13917
 13918					;**********
 13919
 13920					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13921					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13922					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13923					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13924			011707		SN=SN+1
 13925			000100			ZZ=ZZ+ZZ
 13926						IFE	ZZ,<ZZ=1>
 13927	037147	200 00 0 00 070273 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13928	037150	274 00 0 00 070273 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13929	037151	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13930						STOP^
 13931	037152	254 04 0 00 037153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13932	037153	324 00 0 00 037154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13934									;IN THE SUBTEST) TO LOOP ON ERROR^
 13935
 13936					;**********
 13937
 13938					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13939					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13940					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13941					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13942			011710		SN=SN+1
 13943			000200			ZZ=ZZ+ZZ
 13944						IFE	ZZ,<ZZ=1>
 13945	037154	200 00 0 00 070274 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13946	037155	274 00 0 00 070274 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13947	037156	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13948						STOP^
 13949	037157	254 04 0 00 037160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13950	037160	324 00 0 00 037161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13952									;IN THE SUBTEST) TO LOOP ON ERROR^
 13953
 13954					;**********
 13955
 13956					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13957					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13958					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 13959					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13960			011711		SN=SN+1
 13961			000400			ZZ=ZZ+ZZ
 13962						IFE	ZZ,<ZZ=1>
 13963	037161	200 00 0 00 070275 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13964	037162	274 00 0 00 070275 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13965	037163	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13966						STOP^
 13967	037164	254 04 0 00 037165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13968	037165	324 00 0 00 037166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13970									;IN THE SUBTEST) TO LOOP ON ERROR^
 13971
 13972					;**********
 13973
 13974					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13975					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13976					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13977					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13978			011712		SN=SN+1
 13979			001000			ZZ=ZZ+ZZ
 13980						IFE	ZZ,<ZZ=1>
 13981	037166	200 00 0 00 070276 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 13982	037167	274 00 0 00 070276 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 13983	037170	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 13984						STOP^
 13985	037171	254 04 0 00 037172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 13986	037172	324 00 0 00 037173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 13987									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 13988									;IN THE SUBTEST) TO LOOP ON ERROR^
 13989
 13990					;**********
 13991
 13992					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 13993					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 13994					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 13995					;TIMES IN ORDER TO TEST ALL 36 BITS.
 13996			011713		SN=SN+1
 13997			002000			ZZ=ZZ+ZZ
 13998						IFE	ZZ,<ZZ=1>
 13999	037173	200 00 0 00 070277 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14000	037174	274 00 0 00 070277 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14001	037175	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14002						STOP^
 14003	037176	254 04 0 00 037177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14004	037177	324 00 0 00 037200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14005									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14006									;IN THE SUBTEST) TO LOOP ON ERROR^
 14007
 14008					;**********
 14009
 14010					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14011					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14012					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14013					;TIMES IN ORDER TO TEST ALL 36 BITS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14014			011714		SN=SN+1
 14015			004000			ZZ=ZZ+ZZ
 14016						IFE	ZZ,<ZZ=1>
 14017	037200	200 00 0 00 070300 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14018	037201	274 00 0 00 070300 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14019	037202	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14020						STOP^
 14021	037203	254 04 0 00 037204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14022	037204	324 00 0 00 037205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14023									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14024									;IN THE SUBTEST) TO LOOP ON ERROR^
 14025
 14026					;**********
 14027
 14028					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14029					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14030					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14031					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14032			011715		SN=SN+1
 14033			010000			ZZ=ZZ+ZZ
 14034						IFE	ZZ,<ZZ=1>
 14035	037205	200 00 0 00 070301 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14036	037206	274 00 0 00 070301 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14037	037207	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14038						STOP^
 14039	037210	254 04 0 00 037211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14040	037211	324 00 0 00 037212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14041									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14042									;IN THE SUBTEST) TO LOOP ON ERROR^
 14043
 14044					;**********
 14045
 14046					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14047					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14048					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14049					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14050			011716		SN=SN+1
 14051			020000			ZZ=ZZ+ZZ
 14052						IFE	ZZ,<ZZ=1>
 14053	037212	200 00 0 00 070302 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14054	037213	274 00 0 00 070302 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14055	037214	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14056						STOP^
 14057	037215	254 04 0 00 037216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14058	037216	324 00 0 00 037217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14059									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14060									;IN THE SUBTEST) TO LOOP ON ERROR^
 14061
 14062					;**********
 14063
 14064					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14065					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14066					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14067					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14068			011717		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14069			040000			ZZ=ZZ+ZZ
 14070						IFE	ZZ,<ZZ=1>
 14071	037217	200 00 0 00 070303 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14072	037220	274 00 0 00 070303 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14073	037221	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14074						STOP^
 14075	037222	254 04 0 00 037223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14076	037223	324 00 0 00 037224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14077									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14078									;IN THE SUBTEST) TO LOOP ON ERROR^
 14079
 14080					;**********
 14081
 14082					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14083					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14084					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14085					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14086			011720		SN=SN+1
 14087			100000			ZZ=ZZ+ZZ
 14088						IFE	ZZ,<ZZ=1>
 14089	037224	200 00 0 00 070304 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14090	037225	274 00 0 00 070304 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14091	037226	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14092						STOP^
 14093	037227	254 04 0 00 037230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14094	037230	324 00 0 00 037231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14095									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14096									;IN THE SUBTEST) TO LOOP ON ERROR^
 14097
 14098					;**********
 14099
 14100					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14101					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14102					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14103					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14104			011721		SN=SN+1
 14105			200000			ZZ=ZZ+ZZ
 14106						IFE	ZZ,<ZZ=1>
 14107	037231	200 00 0 00 070305 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14108	037232	274 00 0 00 070305 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14109	037233	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14110						STOP^
 14111	037234	254 04 0 00 037235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14112	037235	324 00 0 00 037236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14114									;IN THE SUBTEST) TO LOOP ON ERROR^
 14115
 14116					;**********
 14117
 14118					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14119					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14120					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14121					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14122			011722		SN=SN+1
 14123			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14124						IFE	ZZ,<ZZ=1>
 14125	037236	200 00 0 00 070306 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14126	037237	274 00 0 00 070306 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14127	037240	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14128						STOP^
 14129	037241	254 04 0 00 037242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14130	037242	324 00 0 00 037243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14131									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14132									;IN THE SUBTEST) TO LOOP ON ERROR^
 14133
 14134					;**********
 14135
 14136					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14137					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14138					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14139					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14140			011723		SN=SN+1
 14141		000001	000000			ZZ=ZZ+ZZ
 14142						IFE	ZZ,<ZZ=1>
 14143	037243	200 00 0 00 070307 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14144	037244	274 00 0 00 070307 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14145	037245	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14146						STOP^
 14147	037246	254 04 0 00 037247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14148	037247	324 00 0 00 037250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14149									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14150									;IN THE SUBTEST) TO LOOP ON ERROR^
 14151
 14152					;**********
 14153
 14154					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14155					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14156					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14157					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14158			011724		SN=SN+1
 14159		000002	000000			ZZ=ZZ+ZZ
 14160						IFE	ZZ,<ZZ=1>
 14161	037250	200 00 0 00 070310 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14162	037251	274 00 0 00 070310 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14163	037252	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14164						STOP^
 14165	037253	254 04 0 00 037254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14166	037254	324 00 0 00 037255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14168									;IN THE SUBTEST) TO LOOP ON ERROR^
 14169
 14170					;**********
 14171
 14172					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14173					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14174					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14175					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14176			011725		SN=SN+1
 14177		000004	000000			ZZ=ZZ+ZZ
 14178						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14179	037255	200 00 0 00 070311 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14180	037256	274 00 0 00 070311 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14181	037257	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14182						STOP^
 14183	037260	254 04 0 00 037261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14184	037261	324 00 0 00 037262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14185									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14186									;IN THE SUBTEST) TO LOOP ON ERROR^
 14187
 14188					;**********
 14189
 14190					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14191					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14192					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14193					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14194			011726		SN=SN+1
 14195		000010	000000			ZZ=ZZ+ZZ
 14196						IFE	ZZ,<ZZ=1>
 14197	037262	200 00 0 00 070312 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14198	037263	274 00 0 00 070312 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14199	037264	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14200						STOP^
 14201	037265	254 04 0 00 037266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14202	037266	324 00 0 00 037267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14203									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14204									;IN THE SUBTEST) TO LOOP ON ERROR^
 14205
 14206					;**********
 14207
 14208					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14209					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14210					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14211					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14212			011727		SN=SN+1
 14213		000020	000000			ZZ=ZZ+ZZ
 14214						IFE	ZZ,<ZZ=1>
 14215	037267	200 00 0 00 070313 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14216	037270	274 00 0 00 070313 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14217	037271	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14218						STOP^
 14219	037272	254 04 0 00 037273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14220	037273	324 00 0 00 037274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14221									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14222									;IN THE SUBTEST) TO LOOP ON ERROR^
 14223
 14224					;**********
 14225
 14226					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14227					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14228					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14229					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14230			011730		SN=SN+1
 14231		000040	000000			ZZ=ZZ+ZZ
 14232						IFE	ZZ,<ZZ=1>
 14233	037274	200 00 0 00 070314 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-9
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14234	037275	274 00 0 00 070314 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14235	037276	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14236						STOP^
 14237	037277	254 04 0 00 037300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14238	037300	324 00 0 00 037301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14239									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14240									;IN THE SUBTEST) TO LOOP ON ERROR^
 14241
 14242					;**********
 14243
 14244					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14245					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14246					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14247					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14248			011731		SN=SN+1
 14249		000100	000000			ZZ=ZZ+ZZ
 14250						IFE	ZZ,<ZZ=1>
 14251	037301	200 00 0 00 070315 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14252	037302	274 00 0 00 070315 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14253	037303	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14254						STOP^
 14255	037304	254 04 0 00 037305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14256	037305	324 00 0 00 037306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14257									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14258									;IN THE SUBTEST) TO LOOP ON ERROR^
 14259
 14260					;**********
 14261
 14262					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14263					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14264					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14265					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14266			011732		SN=SN+1
 14267		000200	000000			ZZ=ZZ+ZZ
 14268						IFE	ZZ,<ZZ=1>
 14269	037306	200 00 0 00 070316 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14270	037307	274 00 0 00 070316 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14271	037310	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14272						STOP^
 14273	037311	254 04 0 00 037312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14274	037312	324 00 0 00 037313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14276									;IN THE SUBTEST) TO LOOP ON ERROR^
 14277
 14278					;**********
 14279
 14280					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14281					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14282					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14283					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14284			011733		SN=SN+1
 14285		000400	000000			ZZ=ZZ+ZZ
 14286						IFE	ZZ,<ZZ=1>
 14287	037313	200 00 0 00 070264 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14288	037314	274 00 0 00 070264 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-10
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14289	037315	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14290						STOP^
 14291	037316	254 04 0 00 037317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14292	037317	324 00 0 00 037320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14293									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14294									;IN THE SUBTEST) TO LOOP ON ERROR^
 14295
 14296					;**********
 14297
 14298					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14299					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14300					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14301					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14302			011734		SN=SN+1
 14303		001000	000000			ZZ=ZZ+ZZ
 14304						IFE	ZZ,<ZZ=1>
 14305	037320	200 00 0 00 070317 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14306	037321	274 00 0 00 070317 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14307	037322	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14308						STOP^
 14309	037323	254 04 0 00 037324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14310	037324	324 00 0 00 037325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14312									;IN THE SUBTEST) TO LOOP ON ERROR^
 14313
 14314					;**********
 14315
 14316					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14317					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14318					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14319					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14320			011735		SN=SN+1
 14321		002000	000000			ZZ=ZZ+ZZ
 14322						IFE	ZZ,<ZZ=1>
 14323	037325	200 00 0 00 070320 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14324	037326	274 00 0 00 070320 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14325	037327	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14326						STOP^
 14327	037330	254 04 0 00 037331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14328	037331	324 00 0 00 037332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14329									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14330									;IN THE SUBTEST) TO LOOP ON ERROR^
 14331
 14332					;**********
 14333
 14334					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14335					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14336					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14337					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14338			011736		SN=SN+1
 14339		004000	000000			ZZ=ZZ+ZZ
 14340						IFE	ZZ,<ZZ=1>
 14341	037332	200 00 0 00 070321 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14342	037333	274 00 0 00 070321 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14343	037334	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-11
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14344						STOP^
 14345	037335	254 04 0 00 037336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14346	037336	324 00 0 00 037337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14347									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14348									;IN THE SUBTEST) TO LOOP ON ERROR^
 14349
 14350					;**********
 14351
 14352					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14353					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14354					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14355					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14356			011737		SN=SN+1
 14357		010000	000000			ZZ=ZZ+ZZ
 14358						IFE	ZZ,<ZZ=1>
 14359	037337	200 00 0 00 070322 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14360	037340	274 00 0 00 070322 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14361	037341	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14362						STOP^
 14363	037342	254 04 0 00 037343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14364	037343	324 00 0 00 037344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14365									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14366									;IN THE SUBTEST) TO LOOP ON ERROR^
 14367
 14368					;**********
 14369
 14370					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14371					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14372					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14373					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14374			011740		SN=SN+1
 14375		020000	000000			ZZ=ZZ+ZZ
 14376						IFE	ZZ,<ZZ=1>
 14377	037344	200 00 0 00 070323 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14378	037345	274 00 0 00 070323 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14379	037346	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14380						STOP^
 14381	037347	254 04 0 00 037350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14382	037350	324 00 0 00 037351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14383									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14384									;IN THE SUBTEST) TO LOOP ON ERROR^
 14385
 14386					;**********
 14387
 14388					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14389					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14390					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14391					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14392			011741		SN=SN+1
 14393		040000	000000			ZZ=ZZ+ZZ
 14394						IFE	ZZ,<ZZ=1>
 14395	037351	200 00 0 00 070324 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14396	037352	274 00 0 00 070324 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14397	037353	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14398						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-12
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14399	037354	254 04 0 00 037355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14400	037355	324 00 0 00 037356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14401									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14402									;IN THE SUBTEST) TO LOOP ON ERROR^
 14403
 14404					;**********
 14405
 14406					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14407					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14408					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14409					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14410			011742		SN=SN+1
 14411		100000	000000			ZZ=ZZ+ZZ
 14412						IFE	ZZ,<ZZ=1>
 14413	037356	200 00 0 00 070325 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14414	037357	274 00 0 00 070325 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14415	037360	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14416						STOP^
 14417	037361	254 04 0 00 037362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14418	037362	324 00 0 00 037363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14419									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14420									;IN THE SUBTEST) TO LOOP ON ERROR^
 14421
 14422					;**********
 14423
 14424					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14425					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14426					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14427					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14428			011743		SN=SN+1
 14429		200000	000000			ZZ=ZZ+ZZ
 14430						IFE	ZZ,<ZZ=1>
 14431	037363	200 00 0 00 070326 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14432	037364	274 00 0 00 070326 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14433	037365	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14434						STOP^
 14435	037366	254 04 0 00 037367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14436	037367	324 00 0 00 037370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14437									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14438									;IN THE SUBTEST) TO LOOP ON ERROR^
 14439
 14440					;**********
 14441
 14442					;THIS TEST VERIFIES THAT IF A RIPPLED ONE
 14443					;IS SUBTRACTED FROM ITSELF, THE RESULT IS
 14444					;AN AC OF ALL ZEROS. THIS TEST IS REPEATED 36
 14445					;TIMES IN ORDER TO TEST ALL 36 BITS.
 14446			011744		SN=SN+1
 14447		400000	000000			ZZ=ZZ+ZZ
 14448						IFE	ZZ,<ZZ=1>
 14449	037370	200 00 0 00 070256 		MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
 14450	037371	274 00 0 00 070256 		SUB	[ZZ]		;*SUB OF FLOATING ONE FROM ITSELF SHOULD RESULT IN C(AC)=0
 14451	037372	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14452						STOP^
 14453	037373	254 04 0 00 037374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-13
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14454	037374	324 00 0 00 037375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14455									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14456									;IN THE SUBTEST) TO LOOP ON ERROR^
 14457
 14458					;**********
 14459
 14460					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12-14
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14461					;THIS TEST VERIFIES THAT IF A WORD OF ALL
 14462					;ONES IS SUBTRACTED FROM ITSELF, THE RESULT
 14463					;IN THE AC IS ZERO.
 14464
 14465	037375	200 00 0 00 070254 	A12000:	MOVE	[-1]		;PRESET AC TO ALL ONES
 14466	037376	274 00 0 00 070254 		SUB	[-1]		;*SUB OF -1 FROM ITSELF SHOULD RESULT IN C(AC)=0
 14467	037377	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 14468						STOP^
 14469	037400	254 04 0 00 037401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14470	037401	324 00 0 00 037402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14472									;IN THE SUBTEST) TO LOOP ON ERROR^
 14473
 14474					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14475					;THIS TEST VERIFIES THAT CAMA ALWAYS SKIPS THE
 14476					;NEXT INSTRUCTION INDEPENDENT OF THE DATA WITH AC
 14477					;AND E. THIS TEST FAILS IF CAMA DOES NOT SKIP ALWAYS.
 14478
 14479	037402	200 00 0 00 070253 	A12100:	MOVE	[0]		;PRESET AC, E TO ZERO
 14480	037403	314 00 0 00 000000 		CAMA			;*CAMA SHOULD ALWAYS SKIP THE NEXT INSTRUCTION,
 14481									;OTHERWISE THIS TEST FAILS
 14482						STOP^
 14483	037404	254 04 0 00 037405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14484	037405	324 00 0 00 037406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14485									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14486									;IN THE SUBTEST) TO LOOP ON ERROR^
 14487
 14488					;ET0 [E], ET0 EN[E], IR CAXX[IR3], AD CRY 3C[ADCR],
 14489					;FCYC ACT EN D [ADCR], AD CRY 36 F/F'S [ADCR],
 14490					;PC CLOCK EN [PCC], ET0 C F/F[E], IR CAXX[IR3],
 14491					;ADZ COND P[ADZ] AND ADZ COND Z[ADZ]
 14492
 14493					;**********
 14494
 14495					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
 14496					;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY
 14497					;IF C(AC)=C(E). IN THIS TEST AC=E=0 AND
 14498					;C(AC)=C(E)=0. HENCE, CAME MUST
 14499					;SKIP THE NEXT INSTRUCTION
 14500					;IN THIS TEST
 14501
 14502	037406	200 00 0 00 070253 	A12200:	MOVE	[0]		;PRESET AC, E TO ZERO
 14503	037407	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP SINCE E=AC
 14504						STOP^
 14505	037410	254 04 0 00 037411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14506	037411	324 00 0 00 037412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14507									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14508									;IN THE SUBTEST) TO LOOP ON ERROR^
 14509
 14510					;AD FM + EN [ADFP], F CXC ACT ENC[F1], IRCAXX[IR3]
 14511
 14512					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA2	MAC	13-Jan-89 10:22		TEST OF SUB AND COMPARE INSTRUCTIONS

 14513					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE
 14514					;IT SKIPS THE NEXT INSTRUCTION OF AND ONLY IF
 14515					;C(AC)=C(E). IN THIS TEST C(AC)=C(E)=0;
 14516					;BUT, E IS NOT WITHIN THE AC RANGE.
 14517					;HENCE, CAME MUST SKIP
 14518					;THE NEXT INSTRUCTION IN THIS TEST.
 14519
 14520	037412	200 00 0 00 070253 	A12300:	MOVE	[0]		;*CAME SHOULD SKIP WHEN C(AC)=C(E)=0
 14521	037413	312 00 0 00 070253 		CAME	[0]
 14522						STOP^
 14523	037414	254 04 0 00 037415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14524	037415	324 00 0 00 037416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14525									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14526									;IN THE SUBTEST) TO LOOP ON ERROR^
 14527
 14528					;CAMX: FCE[F1], IR CAMX[IR1]
 14529
 14530					;**********
 14531
 14532					;THIS TEST VERIFIES THAT CAME IS DATA SENSITIVE.
 14533					;IT SKIPS THE NEXT INSTRUCTION IF AND ONLY IF
 14534					;C(AC)=C(E). IN THIS TEST C(AC)=0 AND
 14535					;C(E)=-1. HENCE, CAME SHOULD NOT
 14536					;SKIP THE NEXT INSTRUCTION IN THIS TEST.
 14537
 14538	037416	200 00 0 00 070253 	A12400:	MOVE	[0]		;PRESET AC TO ZERO
 14539	037417	312 00 0 00 070254 		CAME	[-1]		;*CAME SHOULD NOT SKIP BECAUSE C(AC)=0 ANDC(E)=-
 14540	037420	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAME PASSES TEST
 14541						STOP^
 14542	037421	254 04 0 00 037422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14543	037422	324 00 0 00 037423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14544									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14545									;IN THE SUBTEST) TO LOOP ON ERROR^
 14546
 14547					;AD AR- EN [ADAM], IR CAXX [IR3], F CYC ACT EN B [F1],
 14548					;AD AR- F/F'S [ADAM], AD ADD [ADC1], AD FM + FETCH EN A [ADFP],
 14549					;F CYC ACT EN A [F1], AD ADD EN C [ADC1], AD ADD F/F'S [ADC1]
 14550
 14551					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14552					SUBTTL	TEST OF COMPARE (CAMX) INSTRUCTIONS
 14553
 14554					;**********
 14555
 14556					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14557					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14558					;IN THIS TEST, C(AC)=-1 AND C(E)=0; HENCE, CAML SHOULD SKIP.  OTHERWISE,THE 
 14559					;PROGRAM HALTS.
 14560
 14561	037423	200 00 0 00 070254 	B100:	MOVE	[-1]		;PRELOAD AC WITH -1
 14562	037424	311 00 0 00 070253 		CAML	[0]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14563						STOP^
 14564	037425	254 04 0 00 037426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14565	037426	324 00 0 00 037427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14567									;IN THE SUBTEST) TO LOOP ON ERROR^
 14568
 14569					;*****     FAILURE ANALYSIS     *****
 14570					;C(AC0)		C(AC1)		FAILING SIGNAL
 14571
 14572					;				FC: AB PC EN
 14573					;				ET0: COND Q: PC CLK EN
 14574
 14575					;**********
 14576
 14577					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14578					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14579					;IN THIS CASE, C(AC)=0 AND C(E)=-1; HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
 14580					;THE PROGRAM HALTS.
 14581
 14582	037427	200 00 0 00 070253 	B200:	MOVE	[0]		;PRELOAD AC WITH 0
 14583	037430	311 00 0 00 070254 		CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
 14584									;C(AC) IS GREATER THAN C(E)
 14585	037431	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14586						STOP^
 14587	037432	254 04 0 00 037433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14588	037433	324 00 0 00 037434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14589									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14590									;IN THE SUBTEST) TO LOOP ON ERROR^
 14591
 14592					;*****     FAILURE ANALYSIS     *****
 14593					;C(AC0)		C(AC1)		FAILING SIGNAL
 14594
 14595					;				SW: FCE
 14596					;				FC: PC CHANGE
 14597
 14598					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14599					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14600					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14601					;IN THIS CASE, C(AC)=400000,,0 (THE MOST
 14602					;NEGATIVE NUMBER) AND C(E)=377777,,-1
 14603					;(THE MOST POSITIVE NUMBER); HENCE,
 14604					;CAML SHOULD SKIP.  OTHERWISE, THE
 14605					;PROGRAM HALTS
 14606
 14607	037434	200 00 0 00 070256 	B300:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
 14608	037435	311 00 0 00 070255 		CAML	[XWD 377777,-1]	;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14609						STOP^
 14610	037436	254 04 0 00 037437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14611	037437	324 00 0 00 037440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14612									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14613									;IN THE SUBTEST) TO LOOP ON ERROR^
 14614
 14615					;*****     FAILURE ANALYSIS     *****
 14616					;C(AC0)		C(AC1)		FAILING SIGNAL
 14617
 14618					;				FC: AD ADD
 14619
 14620					;**********
 14621
 14622					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14623					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14624					;IN THIS CASE, C(AC)=377777,,-1 (THE MOST POSITIVE NUMBER) AND C(E)=400000,,0 (THE MOST NEGA
 14625					TIVE NUMBER)
 14626					;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.
 14627
 14628	037440	200 00 0 00 070255 	B400:	MOVE	[XWD 377777,-1]	;PRELOAD AC WITH 377777,,-1
 14629	037441	311 00 0 00 070256 		CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
 14630									;C(AC) IS GREATER THAN C(E)
 14631	037442	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14632						STOP^
 14633	037443	254 04 0 00 037444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14634	037444	324 00 0 00 037445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14635									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14636									;IN THE SUBTEST) TO LOOP ON ERROR^
 14637
 14638					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14639					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14640					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14641					;IN THIS CASE, C(AC)=400000,,0 (THE MOST NEGTIVE NUMBER) AND C(E)=-1;
 14642					;HENCE, CAML SHOULD SKIP.  OTHERWISE, THE PROGRAM HALTS
 14643
 14644	037445	200 00 0 00 070256 	B500:	MOVE	[XWD 400000,0]	;PRELOAD AC WITH 400000,,0
 14645	037446	311 00 0 00 070254 		CAML	[-1]		;*CAML SHOULD SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14646						STOP^
 14647	037447	254 04 0 00 037450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14648	037450	324 00 0 00 037451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14650									;IN THE SUBTEST) TO LOOP ON ERROR^
 14651
 14652					;*****     FAILURE ANALYSIS     *****
 14653					;C(AC0)		C(AC1)		FAILING SIGNAL
 14654
 14655					;				FC: AD FM + EN
 14656
 14657					;**********
 14658
 14659					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14660					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14661					;IN THIS CASE, C(AC)=0 AND C(E)=-1 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
 14662					;THE PROGRAM HALTS.
 14663
 14664	037451	400 00 0 00 000000 	B600:	SETZ			;PRELOAD AC WITH 0		
 14665	037452	311 00 0 00 070254 		CAML	[-1]		;*CAML SHOULD NOT SKIP BECAUSE
 14666									;C(AC) IS GREATER THAN C(E)
 14667	037453	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES.
 14668						STOP^
 14669	037454	254 04 0 00 037455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14670	037455	324 00 0 00 037456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14671									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14672									;IN THE SUBTEST) TO LOOP ON ERROR^
 14673
 14674					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14675					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT INSTRUCTION WHEN AND
 14676					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14677					;IN THIS CASE, C(AC)=0 AND C(E)=0 ;HENCE, CAML SHOULD NOT SKIP.  OTHERWISE,
 14678					;THE PROGRAM HALTS.
 14679
 14680	037456	400 00 0 00 000000 	B700:	SETZ			;PRELOAD AS WITH 0		
 14681	037457	311 00 0 00 070253 		CAML	[0]		;*CAML SHOULD NOT SKIP BECAUSE C(AC)=C(E)
 14682	037460	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14683						STOP^
 14684	037461	254 04 0 00 037462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14685	037462	324 00 0 00 037463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14687									;IN THE SUBTEST) TO LOOP ON ERROR^
 14688
 14689					;*****     FAILURE ANALYSIS     *****
 14690					;C(AC0)		C(AC1)		FAILING SIGNAL
 14691
 14692					;				FC: AD CRY 36
 14693
 14694					;**********
 14695
 14696					;THIS TEST VERIFIES THAT CAML SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14697					;ONLY WHEN C(AC) IS LESS THAN C(E).
 14698					;IN THIS CASE, C(AC)=0 AND C(E)=400000,,O (THE MOST NEGATIVE NUMBER);
 14699					;HENCE CAML SHOULD NOT SKIP.  OTHERWISE, THE PROGRAM HALTS.
 14700
 14701	037463	400 00 0 00 000000 	B1000:	SETZ			;PRELOAD AC WITH 0
 14702	037464	311 00 0 00 070256 		CAML	[XWD 400000,0]	;*CAML SHOULD NOT SKIP BECAUSE
 14703									;C(AC) IS GREATER THAN C(E)
 14704	037465	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAML PASSES
 14705						STOP^
 14706	037466	254 04 0 00 037467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14707	037467	324 00 0 00 037470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14709									;IN THE SUBTEST) TO LOOP ON ERROR^
 14710
 14711					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14712					;THIS TEST VERIFIES THAT CAM IS DATA INDEPENDENT.  IT NEVER SKIPS
 14713					;THE NEXT SEQUENTIAL INSTRUCTION
 14714					;IN THIS CASE, C(AC)=-1 AND C(E)=0
 14715					;IF IT DOES SKIP THE NEXT INSTRUCTION, THE PROGRAM HALTS
 14716
 14717	037470	200 00 0 00 070254 	B1100:	MOVE	[-1]		;PRELOAD AC WITH -1	
 14718	037471	310 00 0 00 070253 		CAM	[0]		;*CAM SHOULD NEVER SKIP
 14719	037472	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAM PASSES
 14720						STOP^
 14721	037473	254 04 0 00 037474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14722	037474	324 00 0 00 037475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14723									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14724									;IN THE SUBTEST) TO LOOP ON ERROR^
 14725
 14726					;**********
 14727
 14728					;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14729					;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E).
 14730					;IN THIS CASE, C(AC)=-1 AND C(E)=0;  HENCE, CAMGE SHOULD NOT SKIP.
 14731					;OTHERWISE, THE PROGRAM HALTS.
 14732
 14733	037475	200 00 0 00 070254 	B1200:	MOVE	[-1]		;PRELOAD AC WITH-1	
 14734	037476	315 00 0 00 070253 		CAMGE	[0]		;*CAMGE SHOULD NOT SKIP BECAUSE C(AC) IS LESS THAN C(E)
 14735	037477	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAMGE PASSES.
 14736						STOP^
 14737	037500	254 04 0 00 037501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14738	037501	324 00 0 00 037502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14739									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14740									;IN THE SUBTEST) TO LOOP ON ERROR^
 14741
 14742					;*****     FAILURE ANALYSIS     *****
 14743					;C(AC0)		C(AC1)		FAILING SIGNAL
 14744
 14745					;				FC: PC CHANGE
 14746					;				FC: AB PC EN
 14747
 14748					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14749					;THIS TEST VERIFIES THAT CAMGE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14750					;ONLY WHEN C(AC) IS GREATER THAN OR EQUAL TO C(E)
 14751					;IN THIS CASE, C(AC)=0 AND C(E)=-1;  HENCE CAMGE SHOULD SKIP.
 14752					;OTHEWISE, THE PROGRAM HALTS.
 14753
 14754	037502	400 00 0 00 000000 	B1300:	SETZ			;PRELOAD AC WITH 0		
 14755	037503	315 00 0 00 070254 		CAMGE	[-1]		;*CAMGE SHOULD SKIP BECAUSE C(AC) IS GREATER THAN C(E)
 14756						STOP^
 14757	037504	254 04 0 00 037505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14758	037505	324 00 0 00 037506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14759									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14760									;IN THE SUBTEST) TO LOOP ON ERROR^
 14761
 14762					;*****     FAILURE ANALYSIS     *****
 14763					;C(AC0)		C(AC1)		FAILING SIGNAL
 14764
 14765					;				SW: FCE
 14766					;				ET0: COND Q: PC CLK EN
 14767
 14768					;**********
 14769
 14770					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14771					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
 14772					;IN THIS CASE C(AC)=0 AND C(E)=-1;  HENCE CAMN SHOULD SKIP.
 14773					;OTHERWISE, THE PROGRAM HALTS
 14774
 14775	037506	400 00 0 00 000000 	B1400:	SETZ			;PRELOAD AC WITH 0		
 14776	037507	316 00 0 00 070254 		CAMN	[-1]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)
 14777						STOP^
 14778	037510	254 04 0 00 037511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14779	037511	324 00 0 00 037512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14781									;IN THE SUBTEST) TO LOOP ON ERROR^
 14782
 14783					;*****     FAILURE ANALYSIS     *****
 14784					;C(AC0)		C(AC1)		FAILING SIGNAL
 14785
 14786					;				FC:AD FM + EN
 14787					;				FC: AD AR - EN
 14788					;				FC: AD CRY 36
 14789					;				FC: AD ADD
 14790					;				FC: AB PC EN
 14791					;				ET0: PC CLK EN
 14792
 14793					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14794					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 14795					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E)
 14796					;IN THIS CASE, C(AC)=0 AND C(E)=0;  HENCE CAMN SHOULD NOT SKIP.
 14797					;OTHERWISE, THE PROGRAM HALTS
 14798
 14799	037512	400 00 0 00 000000 	B1500:	SETZ			;PRELOAD AC WITH 0		
 14800	037513	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD NOT SKIP BECAUSE C(AC)=C(E).
 14801	037514	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF CAMN PASSES
 14802						STOP^
 14803	037515	254 04 0 00 037516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14804	037516	324 00 0 00 037517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14806									;IN THE SUBTEST) TO LOOP ON ERROR^
 14807
 14808					;*****     FAILURE ANALYSIS     *****
 14809					;C(AC0)		C(AC1)		FAILING SIGNAL
 14810
 14811					;				SW: FCE
 14812					;				FC: PC CHANGE
 14813
 14814					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14815			001600		SN=1600
 14816			000000			ZZ=0
 14817
 14818					B1600:	REPEAT	^D18,<
 14819					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14820					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14821					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14822					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14823					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14824					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14825					
 14826					SN=SN+1
 14827						ZZ=ZZ+ZZ
 14828						IFE	ZZ,<ZZ=1>
 14829						MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14830						CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14831						CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14832						STOP
 14833					
 14834					;*****     FAILURE ANALYSIS     *****
 14835					;C(AC0)		C(AC1)		FAILING SIGNAL
 14836					
 14837					;				ET0: COND P
 14838					
 14839					;**********
 14840					>
 14841
 14842					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14843					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14844					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14845					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14846					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14847					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14848
 14849			001601		SN=SN+1
 14850			000000			ZZ=ZZ+ZZ
 14851			000001			IFE	ZZ,<ZZ=1>
 14852	037517	200 00 0 00 070265 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14853	037520	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14854	037521	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14855						STOP^
 14856	037522	254 04 0 00 037523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14857	037523	324 00 0 00 037524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14858									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14859									;IN THE SUBTEST) TO LOOP ON ERROR^
 14860
 14861					;*****     FAILURE ANALYSIS     *****
 14862					;C(AC0)		C(AC1)		FAILING SIGNAL
 14863
 14864					;				ET0: COND P
 14865
 14866					;**********
 14867
 14868
 14869					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14870					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14871					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14872					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14873					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14874					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14875
 14876			001602		SN=SN+1
 14877			000002			ZZ=ZZ+ZZ
 14878						IFE	ZZ,<ZZ=1>
 14879	037524	200 00 0 00 070266 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14880	037525	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14881	037526	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14882						STOP^
 14883	037527	254 04 0 00 037530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14884	037530	324 00 0 00 037531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14885									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14886									;IN THE SUBTEST) TO LOOP ON ERROR^
 14887
 14888					;*****     FAILURE ANALYSIS     *****
 14889					;C(AC0)		C(AC1)		FAILING SIGNAL
 14890
 14891					;				ET0: COND P
 14892
 14893					;**********
 14894
 14895
 14896					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14897					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14898					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14899					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14900					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14901					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14902
 14903			001603		SN=SN+1
 14904			000004			ZZ=ZZ+ZZ
 14905						IFE	ZZ,<ZZ=1>
 14906	037531	200 00 0 00 070267 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14907	037532	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14908	037533	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14909						STOP^
 14910	037534	254 04 0 00 037535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14911	037535	324 00 0 00 037536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14912									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14913									;IN THE SUBTEST) TO LOOP ON ERROR^
 14914
 14915					;*****     FAILURE ANALYSIS     *****
 14916					;C(AC0)		C(AC1)		FAILING SIGNAL
 14917
 14918					;				ET0: COND P
 14919
 14920					;**********
 14921
 14922
 14923					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14924					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14925					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14926					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14927					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14928					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14929
 14930			001604		SN=SN+1
 14931			000010			ZZ=ZZ+ZZ
 14932						IFE	ZZ,<ZZ=1>
 14933	037536	200 00 0 00 070270 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14934	037537	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14935	037540	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14936						STOP^
 14937	037541	254 04 0 00 037542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14938	037542	324 00 0 00 037543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14939									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14940									;IN THE SUBTEST) TO LOOP ON ERROR^
 14941
 14942					;*****     FAILURE ANALYSIS     *****
 14943					;C(AC0)		C(AC1)		FAILING SIGNAL
 14944
 14945					;				ET0: COND P
 14946
 14947					;**********
 14948
 14949
 14950					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14951					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14952					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 14953					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14954					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14955					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14956
 14957			001605		SN=SN+1
 14958			000020			ZZ=ZZ+ZZ
 14959						IFE	ZZ,<ZZ=1>
 14960	037543	200 00 0 00 070271 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14961	037544	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14962	037545	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14963						STOP^
 14964	037546	254 04 0 00 037547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14965	037547	324 00 0 00 037550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14966									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14967									;IN THE SUBTEST) TO LOOP ON ERROR^
 14968
 14969					;*****     FAILURE ANALYSIS     *****
 14970					;C(AC0)		C(AC1)		FAILING SIGNAL
 14971
 14972					;				ET0: COND P
 14973
 14974					;**********
 14975
 14976
 14977					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 14978					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 14979					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 14980					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 14981					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 14982					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 14983
 14984			001606		SN=SN+1
 14985			000040			ZZ=ZZ+ZZ
 14986						IFE	ZZ,<ZZ=1>
 14987	037550	200 00 0 00 070272 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 14988	037551	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 14989	037552	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 14990						STOP^
 14991	037553	254 04 0 00 037554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 14992	037554	324 00 0 00 037555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 14993									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 14994									;IN THE SUBTEST) TO LOOP ON ERROR^
 14995
 14996					;*****     FAILURE ANALYSIS     *****
 14997					;C(AC0)		C(AC1)		FAILING SIGNAL
 14998
 14999					;				ET0: COND P
 15000
 15001					;**********
 15002
 15003
 15004					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15005					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15006					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15007					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15008					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15009					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15010
 15011			001607		SN=SN+1
 15012			000100			ZZ=ZZ+ZZ
 15013						IFE	ZZ,<ZZ=1>
 15014	037555	200 00 0 00 070273 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15015	037556	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15016	037557	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15017						STOP^
 15018	037560	254 04 0 00 037561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15019	037561	324 00 0 00 037562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15020									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15021									;IN THE SUBTEST) TO LOOP ON ERROR^
 15022
 15023					;*****     FAILURE ANALYSIS     *****
 15024					;C(AC0)		C(AC1)		FAILING SIGNAL
 15025
 15026					;				ET0: COND P
 15027
 15028					;**********
 15029
 15030
 15031					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15032					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15033					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15034					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15035					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15036					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15037
 15038			001610		SN=SN+1
 15039			000200			ZZ=ZZ+ZZ
 15040						IFE	ZZ,<ZZ=1>
 15041	037562	200 00 0 00 070274 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15042	037563	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15043	037564	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15044						STOP^
 15045	037565	254 04 0 00 037566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15046	037566	324 00 0 00 037567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15047									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15048									;IN THE SUBTEST) TO LOOP ON ERROR^
 15049
 15050					;*****     FAILURE ANALYSIS     *****
 15051					;C(AC0)		C(AC1)		FAILING SIGNAL
 15052
 15053					;				ET0: COND P
 15054
 15055					;**********
 15056
 15057
 15058					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15059					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15060					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15061					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15062					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15063					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15064
 15065			001611		SN=SN+1
 15066			000400			ZZ=ZZ+ZZ
 15067						IFE	ZZ,<ZZ=1>
 15068	037567	200 00 0 00 070275 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15069	037570	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15070	037571	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15071						STOP^
 15072	037572	254 04 0 00 037573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15073	037573	324 00 0 00 037574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15074									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15075									;IN THE SUBTEST) TO LOOP ON ERROR^
 15076
 15077					;*****     FAILURE ANALYSIS     *****
 15078					;C(AC0)		C(AC1)		FAILING SIGNAL
 15079
 15080					;				ET0: COND P
 15081
 15082					;**********
 15083
 15084
 15085					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15086					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15087					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15088					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15089					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15090					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15091
 15092			001612		SN=SN+1
 15093			001000			ZZ=ZZ+ZZ
 15094						IFE	ZZ,<ZZ=1>
 15095	037574	200 00 0 00 070276 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15096	037575	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15097	037576	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15098						STOP^
 15099	037577	254 04 0 00 037600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15100	037600	324 00 0 00 037601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15101									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15102									;IN THE SUBTEST) TO LOOP ON ERROR^
 15103
 15104					;*****     FAILURE ANALYSIS     *****
 15105					;C(AC0)		C(AC1)		FAILING SIGNAL
 15106
 15107					;				ET0: COND P
 15108
 15109					;**********
 15110
 15111
 15112					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15113					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15114					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15115					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15116					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15117					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15118
 15119			001613		SN=SN+1
 15120			002000			ZZ=ZZ+ZZ
 15121						IFE	ZZ,<ZZ=1>
 15122	037601	200 00 0 00 070277 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15123	037602	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15124	037603	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15125						STOP^
 15126	037604	254 04 0 00 037605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15127	037605	324 00 0 00 037606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15129									;IN THE SUBTEST) TO LOOP ON ERROR^
 15130
 15131					;*****     FAILURE ANALYSIS     *****
 15132					;C(AC0)		C(AC1)		FAILING SIGNAL
 15133
 15134					;				ET0: COND P
 15135
 15136					;**********
 15137
 15138
 15139					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15140					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15141					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15142					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15143					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15144					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15145
 15146			001614		SN=SN+1
 15147			004000			ZZ=ZZ+ZZ
 15148						IFE	ZZ,<ZZ=1>
 15149	037606	200 00 0 00 070300 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15150	037607	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15151	037610	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15152						STOP^
 15153	037611	254 04 0 00 037612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15154	037612	324 00 0 00 037613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15155									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15156									;IN THE SUBTEST) TO LOOP ON ERROR^
 15157
 15158					;*****     FAILURE ANALYSIS     *****
 15159					;C(AC0)		C(AC1)		FAILING SIGNAL
 15160
 15161					;				ET0: COND P
 15162
 15163					;**********
 15164
 15165
 15166					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15167					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15168					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15169					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15170					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15171					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15172
 15173			001615		SN=SN+1
 15174			010000			ZZ=ZZ+ZZ
 15175						IFE	ZZ,<ZZ=1>
 15176	037613	200 00 0 00 070301 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15177	037614	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15178	037615	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15179						STOP^
 15180	037616	254 04 0 00 037617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15181	037617	324 00 0 00 037620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15182									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15183									;IN THE SUBTEST) TO LOOP ON ERROR^
 15184
 15185					;*****     FAILURE ANALYSIS     *****
 15186					;C(AC0)		C(AC1)		FAILING SIGNAL
 15187
 15188					;				ET0: COND P
 15189
 15190					;**********
 15191
 15192
 15193					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15194					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15195					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15196					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15197					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15198					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15199
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15200			001616		SN=SN+1
 15201			020000			ZZ=ZZ+ZZ
 15202						IFE	ZZ,<ZZ=1>
 15203	037620	200 00 0 00 070302 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15204	037621	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15205	037622	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15206						STOP^
 15207	037623	254 04 0 00 037624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15208	037624	324 00 0 00 037625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15209									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15210									;IN THE SUBTEST) TO LOOP ON ERROR^
 15211
 15212					;*****     FAILURE ANALYSIS     *****
 15213					;C(AC0)		C(AC1)		FAILING SIGNAL
 15214
 15215					;				ET0: COND P
 15216
 15217					;**********
 15218
 15219
 15220					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15221					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15222					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15223					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15224					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15225					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15226
 15227			001617		SN=SN+1
 15228			040000			ZZ=ZZ+ZZ
 15229						IFE	ZZ,<ZZ=1>
 15230	037625	200 00 0 00 070303 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15231	037626	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15232	037627	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15233						STOP^
 15234	037630	254 04 0 00 037631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15235	037631	324 00 0 00 037632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15236									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15237									;IN THE SUBTEST) TO LOOP ON ERROR^
 15238
 15239					;*****     FAILURE ANALYSIS     *****
 15240					;C(AC0)		C(AC1)		FAILING SIGNAL
 15241
 15242					;				ET0: COND P
 15243
 15244					;**********
 15245
 15246
 15247					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15248					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15249					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15250					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15251					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15252					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15253
 15254			001620		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15255			100000			ZZ=ZZ+ZZ
 15256						IFE	ZZ,<ZZ=1>
 15257	037632	200 00 0 00 070304 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15258	037633	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15259	037634	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15260						STOP^
 15261	037635	254 04 0 00 037636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15262	037636	324 00 0 00 037637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15263									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15264									;IN THE SUBTEST) TO LOOP ON ERROR^
 15265
 15266					;*****     FAILURE ANALYSIS     *****
 15267					;C(AC0)		C(AC1)		FAILING SIGNAL
 15268
 15269					;				ET0: COND P
 15270
 15271					;**********
 15272
 15273
 15274					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15275					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15276					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15277					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15278					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15279					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15280
 15281			001621		SN=SN+1
 15282			200000			ZZ=ZZ+ZZ
 15283						IFE	ZZ,<ZZ=1>
 15284	037637	200 00 0 00 070305 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15285	037640	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15286	037641	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15287						STOP^
 15288	037642	254 04 0 00 037643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15289	037643	324 00 0 00 037644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15290									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15291									;IN THE SUBTEST) TO LOOP ON ERROR^
 15292
 15293					;*****     FAILURE ANALYSIS     *****
 15294					;C(AC0)		C(AC1)		FAILING SIGNAL
 15295
 15296					;				ET0: COND P
 15297
 15298					;**********
 15299
 15300
 15301					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15302					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15303					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15304					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15305					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15306					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15307
 15308			001622		SN=SN+1
 15309			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22-9
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15310						IFE	ZZ,<ZZ=1>
 15311	037644	200 00 0 00 070306 		MOVE	[XWD ZZ]	;PRELOAD AC,E WITH A FLOATING 1
 15312	037645	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15313	037646	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15314						STOP^
 15315	037647	254 04 0 00 037650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15316	037650	324 00 0 00 037651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15318									;IN THE SUBTEST) TO LOOP ON ERROR^
 15319
 15320					;*****     FAILURE ANALYSIS     *****
 15321					;C(AC0)		C(AC1)		FAILING SIGNAL
 15322
 15323					;				ET0: COND P
 15324
 15325					;**********
 15326
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15327			000000			ZZ=0
 15328
 15329						REPEAT	^D18,<
 15330					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15331					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15332					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15333					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15334					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15335					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15336					
 15337					SN=SN+1
 15338						ZZ=ZZ+ZZ
 15339						IFE	ZZ,<ZZ=1>
 15340						MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15341						CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15342						CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15343						STOP
 15344					
 15345					;**********
 15346					>
 15347
 15348					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15349					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15350					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15351					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15352					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15353					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15354
 15355			001623		SN=SN+1
 15356			000000			ZZ=ZZ+ZZ
 15357			000001			IFE	ZZ,<ZZ=1>
 15358	037651	200 00 0 00 070307 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15359	037652	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15360	037653	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15361						STOP^
 15362	037654	254 04 0 00 037655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15363	037655	324 00 0 00 037656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15364									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15365									;IN THE SUBTEST) TO LOOP ON ERROR^
 15366
 15367					;**********
 15368
 15369
 15370					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15371					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15372					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15373					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15374					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15375					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15376
 15377			001624		SN=SN+1
 15378			000002			ZZ=ZZ+ZZ
 15379						IFE	ZZ,<ZZ=1>
 15380	037656	200 00 0 00 070310 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15381	037657	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15382	037660	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15383						STOP^
 15384	037661	254 04 0 00 037662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15385	037662	324 00 0 00 037663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15386									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15387									;IN THE SUBTEST) TO LOOP ON ERROR^
 15388
 15389					;**********
 15390
 15391
 15392					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15393					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15394					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15395					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15396					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15397					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15398
 15399			001625		SN=SN+1
 15400			000004			ZZ=ZZ+ZZ
 15401						IFE	ZZ,<ZZ=1>
 15402	037663	200 00 0 00 070311 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15403	037664	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15404	037665	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15405						STOP^
 15406	037666	254 04 0 00 037667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15407	037667	324 00 0 00 037670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15409									;IN THE SUBTEST) TO LOOP ON ERROR^
 15410
 15411					;**********
 15412
 15413
 15414					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15415					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15416					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15417					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15418					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15419					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15420
 15421			001626		SN=SN+1
 15422			000010			ZZ=ZZ+ZZ
 15423						IFE	ZZ,<ZZ=1>
 15424	037670	200 00 0 00 070312 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15425	037671	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15426	037672	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15427						STOP^
 15428	037673	254 04 0 00 037674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15429	037674	324 00 0 00 037675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15430									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15431									;IN THE SUBTEST) TO LOOP ON ERROR^
 15432
 15433					;**********
 15434
 15435
 15436					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15437					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15438					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15439					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15440					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15441					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15442
 15443			001627		SN=SN+1
 15444			000020			ZZ=ZZ+ZZ
 15445						IFE	ZZ,<ZZ=1>
 15446	037675	200 00 0 00 070313 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15447	037676	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15448	037677	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15449						STOP^
 15450	037700	254 04 0 00 037701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15451	037701	324 00 0 00 037702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15452									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15453									;IN THE SUBTEST) TO LOOP ON ERROR^
 15454
 15455					;**********
 15456
 15457
 15458					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15459					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15460					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15461					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15462					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15463					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15464
 15465			001630		SN=SN+1
 15466			000040			ZZ=ZZ+ZZ
 15467						IFE	ZZ,<ZZ=1>
 15468	037702	200 00 0 00 070314 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15469	037703	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15470	037704	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15471						STOP^
 15472	037705	254 04 0 00 037706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15473	037706	324 00 0 00 037707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15474									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15475									;IN THE SUBTEST) TO LOOP ON ERROR^
 15476
 15477					;**********
 15478
 15479
 15480					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15481					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15482					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15483					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15484					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15485					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15486
 15487			001631		SN=SN+1
 15488			000100			ZZ=ZZ+ZZ
 15489						IFE	ZZ,<ZZ=1>
 15490	037707	200 00 0 00 070315 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15491	037710	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15492	037711	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15493						STOP^
 15494	037712	254 04 0 00 037713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15495	037713	324 00 0 00 037714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15497									;IN THE SUBTEST) TO LOOP ON ERROR^
 15498
 15499					;**********
 15500
 15501
 15502					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15503					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15504					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15505					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15506					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15507					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15508
 15509			001632		SN=SN+1
 15510			000200			ZZ=ZZ+ZZ
 15511						IFE	ZZ,<ZZ=1>
 15512	037714	200 00 0 00 070316 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15513	037715	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15514	037716	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15515						STOP^
 15516	037717	254 04 0 00 037720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15517	037720	324 00 0 00 037721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15518									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15519									;IN THE SUBTEST) TO LOOP ON ERROR^
 15520
 15521					;**********
 15522
 15523
 15524					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15525					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15526					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15527					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15528					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15529					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15530
 15531			001633		SN=SN+1
 15532			000400			ZZ=ZZ+ZZ
 15533						IFE	ZZ,<ZZ=1>
 15534	037721	200 00 0 00 070264 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15535	037722	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15536	037723	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15537						STOP^
 15538	037724	254 04 0 00 037725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15539	037725	324 00 0 00 037726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15541									;IN THE SUBTEST) TO LOOP ON ERROR^
 15542
 15543					;**********
 15544
 15545
 15546					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15547					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15548					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15549					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15550					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15551					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15552
 15553			001634		SN=SN+1
 15554			001000			ZZ=ZZ+ZZ
 15555						IFE	ZZ,<ZZ=1>
 15556	037726	200 00 0 00 070317 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15557	037727	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15558	037730	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15559						STOP^
 15560	037731	254 04 0 00 037732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15561	037732	324 00 0 00 037733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15562									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15563									;IN THE SUBTEST) TO LOOP ON ERROR^
 15564
 15565					;**********
 15566
 15567
 15568					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15569					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15570					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15571					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15572					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15573					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15574
 15575			001635		SN=SN+1
 15576			002000			ZZ=ZZ+ZZ
 15577						IFE	ZZ,<ZZ=1>
 15578	037733	200 00 0 00 070320 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15579	037734	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15580	037735	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15581						STOP^
 15582	037736	254 04 0 00 037737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15583	037737	324 00 0 00 037740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15585									;IN THE SUBTEST) TO LOOP ON ERROR^
 15586
 15587					;**********
 15588
 15589
 15590					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15591					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15592					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15593					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15594					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15595					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15596
 15597			001636		SN=SN+1
 15598			004000			ZZ=ZZ+ZZ
 15599						IFE	ZZ,<ZZ=1>
 15600	037740	200 00 0 00 070321 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15601	037741	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15602	037742	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15603						STOP^
 15604	037743	254 04 0 00 037744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15605	037744	324 00 0 00 037745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15606									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15607									;IN THE SUBTEST) TO LOOP ON ERROR^
 15608
 15609					;**********
 15610
 15611
 15612					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15613					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15614					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15615					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15616					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15617					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15618
 15619			001637		SN=SN+1
 15620			010000			ZZ=ZZ+ZZ
 15621						IFE	ZZ,<ZZ=1>
 15622	037745	200 00 0 00 070322 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15623	037746	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15624	037747	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15625						STOP^
 15626	037750	254 04 0 00 037751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15627	037751	324 00 0 00 037752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15628									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15629									;IN THE SUBTEST) TO LOOP ON ERROR^
 15630
 15631					;**********
 15632
 15633
 15634					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15635					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15636					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15637					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15638					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15639					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15640
 15641			001640		SN=SN+1
 15642			020000			ZZ=ZZ+ZZ
 15643						IFE	ZZ,<ZZ=1>
 15644	037752	200 00 0 00 070323 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15645	037753	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15646	037754	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15647						STOP^
 15648	037755	254 04 0 00 037756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15649	037756	324 00 0 00 037757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15650									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15651									;IN THE SUBTEST) TO LOOP ON ERROR^
 15652
 15653					;**********
 15654
 15655
 15656					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15657					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15658					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15659					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15660					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15661					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15662
 15663			001641		SN=SN+1
 15664			040000			ZZ=ZZ+ZZ
 15665						IFE	ZZ,<ZZ=1>
 15666	037757	200 00 0 00 070324 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15667	037760	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15668	037761	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15669						STOP^
 15670	037762	254 04 0 00 037763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15671	037763	324 00 0 00 037764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15673									;IN THE SUBTEST) TO LOOP ON ERROR^
 15674
 15675					;**********
 15676
 15677
 15678					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15679					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15680					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15681					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15682					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15683					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15684
 15685			001642		SN=SN+1
 15686			100000			ZZ=ZZ+ZZ
 15687						IFE	ZZ,<ZZ=1>
 15688	037764	200 00 0 00 070325 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15689	037765	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15690	037766	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15691						STOP^
 15692	037767	254 04 0 00 037770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15693	037770	324 00 0 00 037771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15694									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15695									;IN THE SUBTEST) TO LOOP ON ERROR^
 15696
 15697					;**********
 15698
 15699
 15700					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15701					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15702					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15703					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15704					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15705					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15706
 15707			001643		SN=SN+1
 15708			200000			ZZ=ZZ+ZZ
 15709						IFE	ZZ,<ZZ=1>
 15710	037771	200 00 0 00 070326 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15711	037772	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15712	037773	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15713						STOP^
 15714	037774	254 04 0 00 037775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15715	037775	324 00 0 00 037776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15717									;IN THE SUBTEST) TO LOOP ON ERROR^
 15718
 15719					;**********
 15720
 15721
 15722					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY
 15723					;WHEN C(AC) IS NOT EQUAL TO C(E).  IT ALSO VERIFIES THAT CAME
 15724					;SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND ONLY WHEN
 15725					;C(AC)=C(E).  IN BOTH CASES AC=E;  HENCE, C(AC)=C(E)
 15726					;IF EITHER CAMN OR CAME FAILS, THE PROGRAM HALTS
 15727					;THIS TEST IS REPEATED 36 TIMES IN ORDER TO FLOAT A 1 THRU ALL 36 BITS
 15728
 15729			001644		SN=SN+1
 15730			400000			ZZ=ZZ+ZZ
 15731						IFE	ZZ,<ZZ=1>
 15732	037776	200 00 0 00 070256 		MOVE	[XWD ZZ,0]	;PRELOAD AC,E WITH A FLOATING 1
 15733	037777	316 00 0 00 000000 		CAMN			;*CAMN SHOLD NOT SKIP BECAUSE C(AC)=C(E)		
 15734	040000	312 00 0 00 000000 		CAME			;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)		
 15735						STOP^
 15736	040001	254 04 0 00 040002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15737	040002	324 00 0 00 040003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15738									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15739									;IN THE SUBTEST) TO LOOP ON ERROR^
 15740
 15741					;**********
 15742
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15743			001700		SN=1700
 15744			000000			ZZ=0
 15745
 15746					B1700:	REPEAT	^D36,<
 15747					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15748					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15749					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15750					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15751					SN=SN+1
 15752						ZZ=ZZ+ZZ
 15753						IFE	ZZ,<ZZ=1>
 15754						SETZ			;PRELOAD AC WITH 0
 15755						CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15756						STOP		
 15757					
 15758					;**********
 15759					>
 15760
 15761					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15762					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15763					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15764					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15765			001701		SN=SN+1
 15766			000000			ZZ=ZZ+ZZ
 15767			000001			IFE	ZZ,<ZZ=1>
 15768	040003	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15769	040004	316 00 0 00 070265 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15770						STOP		^
 15771	040005	254 04 0 00 040006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15772	040006	324 00 0 00 040007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15773									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15774									;IN THE SUBTEST) TO LOOP ON ERROR^
 15775
 15776					;**********
 15777
 15778
 15779					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15780					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15781					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15782					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15783			001702		SN=SN+1
 15784			000002			ZZ=ZZ+ZZ
 15785						IFE	ZZ,<ZZ=1>
 15786	040007	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15787	040010	316 00 0 00 070266 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15788						STOP		^
 15789	040011	254 04 0 00 040012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15790	040012	324 00 0 00 040013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15791									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15792									;IN THE SUBTEST) TO LOOP ON ERROR^
 15793
 15794					;**********
 15795
 15796
 15797					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15798					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15799					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15800					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15801			001703		SN=SN+1
 15802			000004			ZZ=ZZ+ZZ
 15803						IFE	ZZ,<ZZ=1>
 15804	040013	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15805	040014	316 00 0 00 070267 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15806						STOP		^
 15807	040015	254 04 0 00 040016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15808	040016	324 00 0 00 040017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15809									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15810									;IN THE SUBTEST) TO LOOP ON ERROR^
 15811
 15812					;**********
 15813
 15814
 15815					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15816					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15817					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15818					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15819			001704		SN=SN+1
 15820			000010			ZZ=ZZ+ZZ
 15821						IFE	ZZ,<ZZ=1>
 15822	040017	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15823	040020	316 00 0 00 070270 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15824						STOP		^
 15825	040021	254 04 0 00 040022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15826	040022	324 00 0 00 040023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15827									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15828									;IN THE SUBTEST) TO LOOP ON ERROR^
 15829
 15830					;**********
 15831
 15832
 15833					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15834					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15835					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15836					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15837			001705		SN=SN+1
 15838			000020			ZZ=ZZ+ZZ
 15839						IFE	ZZ,<ZZ=1>
 15840	040023	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15841	040024	316 00 0 00 070271 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15842						STOP		^
 15843	040025	254 04 0 00 040026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15844	040026	324 00 0 00 040027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15846									;IN THE SUBTEST) TO LOOP ON ERROR^
 15847
 15848					;**********
 15849
 15850
 15851					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15852					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15853					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15854					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15855			001706		SN=SN+1
 15856			000040			ZZ=ZZ+ZZ
 15857						IFE	ZZ,<ZZ=1>
 15858	040027	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15859	040030	316 00 0 00 070272 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15860						STOP		^
 15861	040031	254 04 0 00 040032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15862	040032	324 00 0 00 040033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15863									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15864									;IN THE SUBTEST) TO LOOP ON ERROR^
 15865
 15866					;**********
 15867
 15868
 15869					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15870					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15871					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15872					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15873			001707		SN=SN+1
 15874			000100			ZZ=ZZ+ZZ
 15875						IFE	ZZ,<ZZ=1>
 15876	040033	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15877	040034	316 00 0 00 070273 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15878						STOP		^
 15879	040035	254 04 0 00 040036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15880	040036	324 00 0 00 040037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15882									;IN THE SUBTEST) TO LOOP ON ERROR^
 15883
 15884					;**********
 15885
 15886
 15887					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15888					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15889					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15890					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15891			001710		SN=SN+1
 15892			000200			ZZ=ZZ+ZZ
 15893						IFE	ZZ,<ZZ=1>
 15894	040037	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15895	040040	316 00 0 00 070274 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15896						STOP		^
 15897	040041	254 04 0 00 040042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15898	040042	324 00 0 00 040043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15899									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15900									;IN THE SUBTEST) TO LOOP ON ERROR^
 15901
 15902					;**********
 15903
 15904
 15905					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15906					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15907					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15908					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15909			001711		SN=SN+1
 15910			000400			ZZ=ZZ+ZZ
 15911						IFE	ZZ,<ZZ=1>
 15912	040043	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15913	040044	316 00 0 00 070275 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15914						STOP		^
 15915	040045	254 04 0 00 040046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15916	040046	324 00 0 00 040047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15918									;IN THE SUBTEST) TO LOOP ON ERROR^
 15919
 15920					;**********
 15921
 15922
 15923					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15924					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15925					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15926					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15927			001712		SN=SN+1
 15928			001000			ZZ=ZZ+ZZ
 15929						IFE	ZZ,<ZZ=1>
 15930	040047	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15931	040050	316 00 0 00 070276 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15932						STOP		^
 15933	040051	254 04 0 00 040052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15934	040052	324 00 0 00 040053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15935									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15936									;IN THE SUBTEST) TO LOOP ON ERROR^
 15937
 15938					;**********
 15939
 15940
 15941					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15942					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15943					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15944					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15945			001713		SN=SN+1
 15946			002000			ZZ=ZZ+ZZ
 15947						IFE	ZZ,<ZZ=1>
 15948	040053	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15949	040054	316 00 0 00 070277 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15950						STOP		^
 15951	040055	254 04 0 00 040056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15952	040056	324 00 0 00 040057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15953									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15954									;IN THE SUBTEST) TO LOOP ON ERROR^
 15955
 15956					;**********
 15957
 15958
 15959					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15960					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15961					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15962					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 15963			001714		SN=SN+1
 15964			004000			ZZ=ZZ+ZZ
 15965						IFE	ZZ,<ZZ=1>
 15966	040057	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15967	040060	316 00 0 00 070300 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15968						STOP		^
 15969	040061	254 04 0 00 040062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15970	040062	324 00 0 00 040063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15971									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15972									;IN THE SUBTEST) TO LOOP ON ERROR^
 15973
 15974					;**********
 15975
 15976
 15977					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15978					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15979					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15980					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15981			001715		SN=SN+1
 15982			010000			ZZ=ZZ+ZZ
 15983						IFE	ZZ,<ZZ=1>
 15984	040063	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 15985	040064	316 00 0 00 070301 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 15986						STOP		^
 15987	040065	254 04 0 00 040066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 15988	040066	324 00 0 00 040067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 15989									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 15990									;IN THE SUBTEST) TO LOOP ON ERROR^
 15991
 15992					;**********
 15993
 15994
 15995					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 15996					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 15997					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 15998					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 15999			001716		SN=SN+1
 16000			020000			ZZ=ZZ+ZZ
 16001						IFE	ZZ,<ZZ=1>
 16002	040067	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16003	040070	316 00 0 00 070302 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16004						STOP		^
 16005	040071	254 04 0 00 040072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16006	040072	324 00 0 00 040073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16008									;IN THE SUBTEST) TO LOOP ON ERROR^
 16009
 16010					;**********
 16011
 16012
 16013					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16014					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16015					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16016					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16017			001717		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16018			040000			ZZ=ZZ+ZZ
 16019						IFE	ZZ,<ZZ=1>
 16020	040073	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16021	040074	316 00 0 00 070303 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16022						STOP		^
 16023	040075	254 04 0 00 040076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16024	040076	324 00 0 00 040077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16026									;IN THE SUBTEST) TO LOOP ON ERROR^
 16027
 16028					;**********
 16029
 16030
 16031					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16032					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16033					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16034					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16035			001720		SN=SN+1
 16036			100000			ZZ=ZZ+ZZ
 16037						IFE	ZZ,<ZZ=1>
 16038	040077	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16039	040100	316 00 0 00 070304 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16040						STOP		^
 16041	040101	254 04 0 00 040102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16042	040102	324 00 0 00 040103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16044									;IN THE SUBTEST) TO LOOP ON ERROR^
 16045
 16046					;**********
 16047
 16048
 16049					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16050					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16051					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16052					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16053			001721		SN=SN+1
 16054			200000			ZZ=ZZ+ZZ
 16055						IFE	ZZ,<ZZ=1>
 16056	040103	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16057	040104	316 00 0 00 070305 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16058						STOP		^
 16059	040105	254 04 0 00 040106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16060	040106	324 00 0 00 040107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16061									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16062									;IN THE SUBTEST) TO LOOP ON ERROR^
 16063
 16064					;**********
 16065
 16066
 16067					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16068					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16069					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16070					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16071			001722		SN=SN+1
 16072			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16073						IFE	ZZ,<ZZ=1>
 16074	040107	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16075	040110	316 00 0 00 070306 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16076						STOP		^
 16077	040111	254 04 0 00 040112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16078	040112	324 00 0 00 040113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16079									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16080									;IN THE SUBTEST) TO LOOP ON ERROR^
 16081
 16082					;**********
 16083
 16084
 16085					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16086					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16087					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16088					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16089			001723		SN=SN+1
 16090		000001	000000			ZZ=ZZ+ZZ
 16091						IFE	ZZ,<ZZ=1>
 16092	040113	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16093	040114	316 00 0 00 070307 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16094						STOP		^
 16095	040115	254 04 0 00 040116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16096	040116	324 00 0 00 040117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16097									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16098									;IN THE SUBTEST) TO LOOP ON ERROR^
 16099
 16100					;**********
 16101
 16102
 16103					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16104					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16105					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16106					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16107			001724		SN=SN+1
 16108		000002	000000			ZZ=ZZ+ZZ
 16109						IFE	ZZ,<ZZ=1>
 16110	040117	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16111	040120	316 00 0 00 070310 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16112						STOP		^
 16113	040121	254 04 0 00 040122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16114	040122	324 00 0 00 040123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16115									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16116									;IN THE SUBTEST) TO LOOP ON ERROR^
 16117
 16118					;**********
 16119
 16120
 16121					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16122					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16123					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16124					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16125			001725		SN=SN+1
 16126		000004	000000			ZZ=ZZ+ZZ
 16127						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16128	040123	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16129	040124	316 00 0 00 070311 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16130						STOP		^
 16131	040125	254 04 0 00 040126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16132	040126	324 00 0 00 040127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16133									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16134									;IN THE SUBTEST) TO LOOP ON ERROR^
 16135
 16136					;**********
 16137
 16138
 16139					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16140					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16141					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16142					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16143			001726		SN=SN+1
 16144		000010	000000			ZZ=ZZ+ZZ
 16145						IFE	ZZ,<ZZ=1>
 16146	040127	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16147	040130	316 00 0 00 070312 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16148						STOP		^
 16149	040131	254 04 0 00 040132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16150	040132	324 00 0 00 040133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16151									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16152									;IN THE SUBTEST) TO LOOP ON ERROR^
 16153
 16154					;**********
 16155
 16156
 16157					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16158					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16159					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16160					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16161			001727		SN=SN+1
 16162		000020	000000			ZZ=ZZ+ZZ
 16163						IFE	ZZ,<ZZ=1>
 16164	040133	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16165	040134	316 00 0 00 070313 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16166						STOP		^
 16167	040135	254 04 0 00 040136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16168	040136	324 00 0 00 040137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16169									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16170									;IN THE SUBTEST) TO LOOP ON ERROR^
 16171
 16172					;**********
 16173
 16174
 16175					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16176					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16177					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16178					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16179			001730		SN=SN+1
 16180		000040	000000			ZZ=ZZ+ZZ
 16181						IFE	ZZ,<ZZ=1>
 16182	040137	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16183	040140	316 00 0 00 070314 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16184						STOP		^
 16185	040141	254 04 0 00 040142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16186	040142	324 00 0 00 040143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16187									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16188									;IN THE SUBTEST) TO LOOP ON ERROR^
 16189
 16190					;**********
 16191
 16192
 16193					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16194					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16195					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16196					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16197			001731		SN=SN+1
 16198		000100	000000			ZZ=ZZ+ZZ
 16199						IFE	ZZ,<ZZ=1>
 16200	040143	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16201	040144	316 00 0 00 070315 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16202						STOP		^
 16203	040145	254 04 0 00 040146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16204	040146	324 00 0 00 040147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16206									;IN THE SUBTEST) TO LOOP ON ERROR^
 16207
 16208					;**********
 16209
 16210
 16211					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16212					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16213					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16214					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16215			001732		SN=SN+1
 16216		000200	000000			ZZ=ZZ+ZZ
 16217						IFE	ZZ,<ZZ=1>
 16218	040147	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16219	040150	316 00 0 00 070316 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16220						STOP		^
 16221	040151	254 04 0 00 040152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16222	040152	324 00 0 00 040153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16223									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16224									;IN THE SUBTEST) TO LOOP ON ERROR^
 16225
 16226					;**********
 16227
 16228
 16229					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16230					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16231					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16232					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16233			001733		SN=SN+1
 16234		000400	000000			ZZ=ZZ+ZZ
 16235						IFE	ZZ,<ZZ=1>
 16236	040153	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16237	040154	316 00 0 00 070264 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-9
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16238						STOP		^
 16239	040155	254 04 0 00 040156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16240	040156	324 00 0 00 040157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16241									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16242									;IN THE SUBTEST) TO LOOP ON ERROR^
 16243
 16244					;**********
 16245
 16246
 16247					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16248					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16249					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16250					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16251			001734		SN=SN+1
 16252		001000	000000			ZZ=ZZ+ZZ
 16253						IFE	ZZ,<ZZ=1>
 16254	040157	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16255	040160	316 00 0 00 070317 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16256						STOP		^
 16257	040161	254 04 0 00 040162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16258	040162	324 00 0 00 040163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16259									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16260									;IN THE SUBTEST) TO LOOP ON ERROR^
 16261
 16262					;**********
 16263
 16264
 16265					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16266					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16267					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16268					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16269			001735		SN=SN+1
 16270		002000	000000			ZZ=ZZ+ZZ
 16271						IFE	ZZ,<ZZ=1>
 16272	040163	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16273	040164	316 00 0 00 070320 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16274						STOP		^
 16275	040165	254 04 0 00 040166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16276	040166	324 00 0 00 040167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16277									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16278									;IN THE SUBTEST) TO LOOP ON ERROR^
 16279
 16280					;**********
 16281
 16282
 16283					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16284					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16285					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16286					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16287			001736		SN=SN+1
 16288		004000	000000			ZZ=ZZ+ZZ
 16289						IFE	ZZ,<ZZ=1>
 16290	040167	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16291	040170	316 00 0 00 070321 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16292						STOP		^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-10
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16293	040171	254 04 0 00 040172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16294	040172	324 00 0 00 040173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16295									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16296									;IN THE SUBTEST) TO LOOP ON ERROR^
 16297
 16298					;**********
 16299
 16300
 16301					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16302					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16303					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16304					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16305			001737		SN=SN+1
 16306		010000	000000			ZZ=ZZ+ZZ
 16307						IFE	ZZ,<ZZ=1>
 16308	040173	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16309	040174	316 00 0 00 070322 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16310						STOP		^
 16311	040175	254 04 0 00 040176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16312	040176	324 00 0 00 040177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16314									;IN THE SUBTEST) TO LOOP ON ERROR^
 16315
 16316					;**********
 16317
 16318
 16319					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16320					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16321					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16322					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16323			001740		SN=SN+1
 16324		020000	000000			ZZ=ZZ+ZZ
 16325						IFE	ZZ,<ZZ=1>
 16326	040177	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16327	040200	316 00 0 00 070323 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16328						STOP		^
 16329	040201	254 04 0 00 040202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16330	040202	324 00 0 00 040203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16332									;IN THE SUBTEST) TO LOOP ON ERROR^
 16333
 16334					;**********
 16335
 16336
 16337					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16338					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16339					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16340					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16341			001741		SN=SN+1
 16342		040000	000000			ZZ=ZZ+ZZ
 16343						IFE	ZZ,<ZZ=1>
 16344	040203	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16345	040204	316 00 0 00 070324 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16346						STOP		^
 16347	040205	254 04 0 00 040206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-11
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16348	040206	324 00 0 00 040207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16349									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16350									;IN THE SUBTEST) TO LOOP ON ERROR^
 16351
 16352					;**********
 16353
 16354
 16355					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16356					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16357					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16358					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16359			001742		SN=SN+1
 16360		100000	000000			ZZ=ZZ+ZZ
 16361						IFE	ZZ,<ZZ=1>
 16362	040207	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16363	040210	316 00 0 00 070325 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16364						STOP		^
 16365	040211	254 04 0 00 040212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16366	040212	324 00 0 00 040213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16367									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16368									;IN THE SUBTEST) TO LOOP ON ERROR^
 16369
 16370					;**********
 16371
 16372
 16373					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16374					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16375					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16376					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16377			001743		SN=SN+1
 16378		200000	000000			ZZ=ZZ+ZZ
 16379						IFE	ZZ,<ZZ=1>
 16380	040213	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16381	040214	316 00 0 00 070326 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16382						STOP		^
 16383	040215	254 04 0 00 040216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16384	040216	324 00 0 00 040217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16386									;IN THE SUBTEST) TO LOOP ON ERROR^
 16387
 16388					;**********
 16389
 16390
 16391					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT INSTRUCTION WHEN AND
 16392					;ONLY WHEN C(AC)=0 AND C(E)=FLOATING 1.  HENCE,
 16393					;CAMN SHOULD SKIP;  OTHERWISE, THE PROGRAM HALTS
 16394					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF E
 16395			001744		SN=SN+1
 16396		400000	000000			ZZ=ZZ+ZZ
 16397						IFE	ZZ,<ZZ=1>
 16398	040217	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 16399	040220	316 00 0 00 070256 		CAMN	[ZZ]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16400						STOP		^
 16401	040221	254 04 0 00 040222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16402	040222	324 00 0 00 040223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24-12
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16403									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16404									;IN THE SUBTEST) TO LOOP ON ERROR^
 16405
 16406					;**********
 16407
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16408			002000		SN=2000
 16409			000000			ZZ=0
 16410
 16411					B2000:	REPEAT	^D36,<
 16412					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16413					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16414					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16415					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16416					SN=SN+1
 16417						ZZ=ZZ+ZZ
 16418						IFE	ZZ,<ZZ=1>
 16419						MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16420						CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16421						STOP
 16422					
 16423					;**********
 16424					>
 16425
 16426					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16427					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16428					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16429					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16430			002001		SN=SN+1
 16431			000000			ZZ=ZZ+ZZ
 16432			000001			IFE	ZZ,<ZZ=1>
 16433	040223	200 00 0 00 070265 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16434	040224	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16435						STOP^
 16436	040225	254 04 0 00 040226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16437	040226	324 00 0 00 040227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16438									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16439									;IN THE SUBTEST) TO LOOP ON ERROR^
 16440
 16441					;**********
 16442
 16443
 16444					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16445					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16446					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16447					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16448			002002		SN=SN+1
 16449			000002			ZZ=ZZ+ZZ
 16450						IFE	ZZ,<ZZ=1>
 16451	040227	200 00 0 00 070266 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16452	040230	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16453						STOP^
 16454	040231	254 04 0 00 040232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16455	040232	324 00 0 00 040233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16457									;IN THE SUBTEST) TO LOOP ON ERROR^
 16458
 16459					;**********
 16460
 16461
 16462					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16463					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16464					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16465					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16466			002003		SN=SN+1
 16467			000004			ZZ=ZZ+ZZ
 16468						IFE	ZZ,<ZZ=1>
 16469	040233	200 00 0 00 070267 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16470	040234	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16471						STOP^
 16472	040235	254 04 0 00 040236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16473	040236	324 00 0 00 040237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16474									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16475									;IN THE SUBTEST) TO LOOP ON ERROR^
 16476
 16477					;**********
 16478
 16479
 16480					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16481					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16482					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16483					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16484			002004		SN=SN+1
 16485			000010			ZZ=ZZ+ZZ
 16486						IFE	ZZ,<ZZ=1>
 16487	040237	200 00 0 00 070270 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16488	040240	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16489						STOP^
 16490	040241	254 04 0 00 040242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16491	040242	324 00 0 00 040243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16493									;IN THE SUBTEST) TO LOOP ON ERROR^
 16494
 16495					;**********
 16496
 16497
 16498					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16499					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16500					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16501					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16502			002005		SN=SN+1
 16503			000020			ZZ=ZZ+ZZ
 16504						IFE	ZZ,<ZZ=1>
 16505	040243	200 00 0 00 070271 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16506	040244	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16507						STOP^
 16508	040245	254 04 0 00 040246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16509	040246	324 00 0 00 040247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16511									;IN THE SUBTEST) TO LOOP ON ERROR^
 16512
 16513					;**********
 16514
 16515
 16516					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16517					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16518					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16519					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16520			002006		SN=SN+1
 16521			000040			ZZ=ZZ+ZZ
 16522						IFE	ZZ,<ZZ=1>
 16523	040247	200 00 0 00 070272 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16524	040250	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16525						STOP^
 16526	040251	254 04 0 00 040252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16527	040252	324 00 0 00 040253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16529									;IN THE SUBTEST) TO LOOP ON ERROR^
 16530
 16531					;**********
 16532
 16533
 16534					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16535					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16536					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16537					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16538			002007		SN=SN+1
 16539			000100			ZZ=ZZ+ZZ
 16540						IFE	ZZ,<ZZ=1>
 16541	040253	200 00 0 00 070273 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16542	040254	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16543						STOP^
 16544	040255	254 04 0 00 040256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16545	040256	324 00 0 00 040257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16546									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16547									;IN THE SUBTEST) TO LOOP ON ERROR^
 16548
 16549					;**********
 16550
 16551
 16552					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16553					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16554					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16555					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16556			002010		SN=SN+1
 16557			000200			ZZ=ZZ+ZZ
 16558						IFE	ZZ,<ZZ=1>
 16559	040257	200 00 0 00 070274 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16560	040260	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16561						STOP^
 16562	040261	254 04 0 00 040262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16563	040262	324 00 0 00 040263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16564									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16565									;IN THE SUBTEST) TO LOOP ON ERROR^
 16566
 16567					;**********
 16568
 16569
 16570					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16571					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16572					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16573					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16574			002011		SN=SN+1
 16575			000400			ZZ=ZZ+ZZ
 16576						IFE	ZZ,<ZZ=1>
 16577	040263	200 00 0 00 070275 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16578	040264	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16579						STOP^
 16580	040265	254 04 0 00 040266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16581	040266	324 00 0 00 040267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16582									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16583									;IN THE SUBTEST) TO LOOP ON ERROR^
 16584
 16585					;**********
 16586
 16587
 16588					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16589					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16590					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16591					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16592			002012		SN=SN+1
 16593			001000			ZZ=ZZ+ZZ
 16594						IFE	ZZ,<ZZ=1>
 16595	040267	200 00 0 00 070276 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16596	040270	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16597						STOP^
 16598	040271	254 04 0 00 040272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16599	040272	324 00 0 00 040273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16600									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16601									;IN THE SUBTEST) TO LOOP ON ERROR^
 16602
 16603					;**********
 16604
 16605
 16606					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16607					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16608					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16609					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16610			002013		SN=SN+1
 16611			002000			ZZ=ZZ+ZZ
 16612						IFE	ZZ,<ZZ=1>
 16613	040273	200 00 0 00 070277 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16614	040274	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16615						STOP^
 16616	040275	254 04 0 00 040276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16617	040276	324 00 0 00 040277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16619									;IN THE SUBTEST) TO LOOP ON ERROR^
 16620
 16621					;**********
 16622
 16623
 16624					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16625					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16626					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16627					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16628			002014		SN=SN+1
 16629			004000			ZZ=ZZ+ZZ
 16630						IFE	ZZ,<ZZ=1>
 16631	040277	200 00 0 00 070300 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16632	040300	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16633						STOP^
 16634	040301	254 04 0 00 040302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16635	040302	324 00 0 00 040303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16636									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16637									;IN THE SUBTEST) TO LOOP ON ERROR^
 16638
 16639					;**********
 16640
 16641
 16642					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16643					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16644					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16645					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16646			002015		SN=SN+1
 16647			010000			ZZ=ZZ+ZZ
 16648						IFE	ZZ,<ZZ=1>
 16649	040303	200 00 0 00 070301 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16650	040304	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16651						STOP^
 16652	040305	254 04 0 00 040306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16653	040306	324 00 0 00 040307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16654									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16655									;IN THE SUBTEST) TO LOOP ON ERROR^
 16656
 16657					;**********
 16658
 16659
 16660					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16661					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16662					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16663					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16664			002016		SN=SN+1
 16665			020000			ZZ=ZZ+ZZ
 16666						IFE	ZZ,<ZZ=1>
 16667	040307	200 00 0 00 070302 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16668	040310	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16669						STOP^
 16670	040311	254 04 0 00 040312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16671	040312	324 00 0 00 040313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16673									;IN THE SUBTEST) TO LOOP ON ERROR^
 16674
 16675					;**********
 16676
 16677
 16678					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16679					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16680					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16681					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16682			002017		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16683			040000			ZZ=ZZ+ZZ
 16684						IFE	ZZ,<ZZ=1>
 16685	040313	200 00 0 00 070303 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16686	040314	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16687						STOP^
 16688	040315	254 04 0 00 040316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16689	040316	324 00 0 00 040317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16691									;IN THE SUBTEST) TO LOOP ON ERROR^
 16692
 16693					;**********
 16694
 16695
 16696					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16697					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16698					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16699					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16700			002020		SN=SN+1
 16701			100000			ZZ=ZZ+ZZ
 16702						IFE	ZZ,<ZZ=1>
 16703	040317	200 00 0 00 070304 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16704	040320	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16705						STOP^
 16706	040321	254 04 0 00 040322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16707	040322	324 00 0 00 040323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16708									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16709									;IN THE SUBTEST) TO LOOP ON ERROR^
 16710
 16711					;**********
 16712
 16713
 16714					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16715					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16716					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16717					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16718			002021		SN=SN+1
 16719			200000			ZZ=ZZ+ZZ
 16720						IFE	ZZ,<ZZ=1>
 16721	040323	200 00 0 00 070305 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16722	040324	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16723						STOP^
 16724	040325	254 04 0 00 040326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16725	040326	324 00 0 00 040327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16726									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16727									;IN THE SUBTEST) TO LOOP ON ERROR^
 16728
 16729					;**********
 16730
 16731
 16732					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16733					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16734					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16735					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16736			002022		SN=SN+1
 16737			400000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16738						IFE	ZZ,<ZZ=1>
 16739	040327	200 00 0 00 070306 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16740	040330	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16741						STOP^
 16742	040331	254 04 0 00 040332 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16743	040332	324 00 0 00 040333 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16744									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16745									;IN THE SUBTEST) TO LOOP ON ERROR^
 16746
 16747					;**********
 16748
 16749
 16750					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16751					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16752					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16753					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16754			002023		SN=SN+1
 16755		000001	000000			ZZ=ZZ+ZZ
 16756						IFE	ZZ,<ZZ=1>
 16757	040333	200 00 0 00 070307 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16758	040334	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16759						STOP^
 16760	040335	254 04 0 00 040336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16761	040336	324 00 0 00 040337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16762									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16763									;IN THE SUBTEST) TO LOOP ON ERROR^
 16764
 16765					;**********
 16766
 16767
 16768					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16769					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16770					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16771					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16772			002024		SN=SN+1
 16773		000002	000000			ZZ=ZZ+ZZ
 16774						IFE	ZZ,<ZZ=1>
 16775	040337	200 00 0 00 070310 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16776	040340	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16777						STOP^
 16778	040341	254 04 0 00 040342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16779	040342	324 00 0 00 040343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16781									;IN THE SUBTEST) TO LOOP ON ERROR^
 16782
 16783					;**********
 16784
 16785
 16786					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16787					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16788					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16789					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16790			002025		SN=SN+1
 16791		000004	000000			ZZ=ZZ+ZZ
 16792						IFE	ZZ,<ZZ=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16793	040343	200 00 0 00 070311 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16794	040344	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16795						STOP^
 16796	040345	254 04 0 00 040346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16797	040346	324 00 0 00 040347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16798									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16799									;IN THE SUBTEST) TO LOOP ON ERROR^
 16800
 16801					;**********
 16802
 16803
 16804					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16805					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16806					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16807					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16808			002026		SN=SN+1
 16809		000010	000000			ZZ=ZZ+ZZ
 16810						IFE	ZZ,<ZZ=1>
 16811	040347	200 00 0 00 070312 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16812	040350	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16813						STOP^
 16814	040351	254 04 0 00 040352 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16815	040352	324 00 0 00 040353 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16816									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16817									;IN THE SUBTEST) TO LOOP ON ERROR^
 16818
 16819					;**********
 16820
 16821
 16822					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16823					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16824					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16825					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16826			002027		SN=SN+1
 16827		000020	000000			ZZ=ZZ+ZZ
 16828						IFE	ZZ,<ZZ=1>
 16829	040353	200 00 0 00 070313 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16830	040354	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16831						STOP^
 16832	040355	254 04 0 00 040356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16833	040356	324 00 0 00 040357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16835									;IN THE SUBTEST) TO LOOP ON ERROR^
 16836
 16837					;**********
 16838
 16839
 16840					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16841					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16842					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16843					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16844			002030		SN=SN+1
 16845		000040	000000			ZZ=ZZ+ZZ
 16846						IFE	ZZ,<ZZ=1>
 16847	040357	200 00 0 00 070314 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16848	040360	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16849						STOP^
 16850	040361	254 04 0 00 040362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16851	040362	324 00 0 00 040363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16852									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16853									;IN THE SUBTEST) TO LOOP ON ERROR^
 16854
 16855					;**********
 16856
 16857
 16858					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16859					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16860					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16861					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16862			002031		SN=SN+1
 16863		000100	000000			ZZ=ZZ+ZZ
 16864						IFE	ZZ,<ZZ=1>
 16865	040363	200 00 0 00 070315 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16866	040364	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16867						STOP^
 16868	040365	254 04 0 00 040366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16869	040366	324 00 0 00 040367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16871									;IN THE SUBTEST) TO LOOP ON ERROR^
 16872
 16873					;**********
 16874
 16875
 16876					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16877					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16878					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16879					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16880			002032		SN=SN+1
 16881		000200	000000			ZZ=ZZ+ZZ
 16882						IFE	ZZ,<ZZ=1>
 16883	040367	200 00 0 00 070316 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16884	040370	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16885						STOP^
 16886	040371	254 04 0 00 040372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16887	040372	324 00 0 00 040373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16888									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16889									;IN THE SUBTEST) TO LOOP ON ERROR^
 16890
 16891					;**********
 16892
 16893
 16894					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16895					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16896					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16897					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16898			002033		SN=SN+1
 16899		000400	000000			ZZ=ZZ+ZZ
 16900						IFE	ZZ,<ZZ=1>
 16901	040373	200 00 0 00 070264 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16902	040374	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-9
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16903						STOP^
 16904	040375	254 04 0 00 040376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16905	040376	324 00 0 00 040377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16906									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16907									;IN THE SUBTEST) TO LOOP ON ERROR^
 16908
 16909					;**********
 16910
 16911
 16912					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16913					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16914					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16915					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16916			002034		SN=SN+1
 16917		001000	000000			ZZ=ZZ+ZZ
 16918						IFE	ZZ,<ZZ=1>
 16919	040377	200 00 0 00 070317 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16920	040400	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16921						STOP^
 16922	040401	254 04 0 00 040402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16923	040402	324 00 0 00 040403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16924									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16925									;IN THE SUBTEST) TO LOOP ON ERROR^
 16926
 16927					;**********
 16928
 16929
 16930					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16931					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16932					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16933					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16934			002035		SN=SN+1
 16935		002000	000000			ZZ=ZZ+ZZ
 16936						IFE	ZZ,<ZZ=1>
 16937	040403	200 00 0 00 070320 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16938	040404	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16939						STOP^
 16940	040405	254 04 0 00 040406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16941	040406	324 00 0 00 040407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16942									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16943									;IN THE SUBTEST) TO LOOP ON ERROR^
 16944
 16945					;**********
 16946
 16947
 16948					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16949					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16950					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16951					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16952			002036		SN=SN+1
 16953		004000	000000			ZZ=ZZ+ZZ
 16954						IFE	ZZ,<ZZ=1>
 16955	040407	200 00 0 00 070321 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16956	040410	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16957						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-10
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 16958	040411	254 04 0 00 040412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16959	040412	324 00 0 00 040413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16960									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16961									;IN THE SUBTEST) TO LOOP ON ERROR^
 16962
 16963					;**********
 16964
 16965
 16966					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16967					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16968					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16969					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16970			002037		SN=SN+1
 16971		010000	000000			ZZ=ZZ+ZZ
 16972						IFE	ZZ,<ZZ=1>
 16973	040413	200 00 0 00 070322 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16974	040414	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16975						STOP^
 16976	040415	254 04 0 00 040416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16977	040416	324 00 0 00 040417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16979									;IN THE SUBTEST) TO LOOP ON ERROR^
 16980
 16981					;**********
 16982
 16983
 16984					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 16985					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 16986					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 16987					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 16988			002040		SN=SN+1
 16989		020000	000000			ZZ=ZZ+ZZ
 16990						IFE	ZZ,<ZZ=1>
 16991	040417	200 00 0 00 070323 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 16992	040420	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 16993						STOP^
 16994	040421	254 04 0 00 040422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 16995	040422	324 00 0 00 040423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 16996									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 16997									;IN THE SUBTEST) TO LOOP ON ERROR^
 16998
 16999					;**********
 17000
 17001
 17002					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 17003					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 17004					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 17005					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 17006			002041		SN=SN+1
 17007		040000	000000			ZZ=ZZ+ZZ
 17008						IFE	ZZ,<ZZ=1>
 17009	040423	200 00 0 00 070324 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 17010	040424	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17011						STOP^
 17012	040425	254 04 0 00 040426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-11
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 17013	040426	324 00 0 00 040427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17015									;IN THE SUBTEST) TO LOOP ON ERROR^
 17016
 17017					;**********
 17018
 17019
 17020					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 17021					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 17022					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 17023					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 17024			002042		SN=SN+1
 17025		100000	000000			ZZ=ZZ+ZZ
 17026						IFE	ZZ,<ZZ=1>
 17027	040427	200 00 0 00 070325 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 17028	040430	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17029						STOP^
 17030	040431	254 04 0 00 040432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17031	040432	324 00 0 00 040433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17032									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17033									;IN THE SUBTEST) TO LOOP ON ERROR^
 17034
 17035					;**********
 17036
 17037
 17038					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 17039					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 17040					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 17041					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 17042			002043		SN=SN+1
 17043		200000	000000			ZZ=ZZ+ZZ
 17044						IFE	ZZ,<ZZ=1>
 17045	040433	200 00 0 00 070326 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 17046	040434	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17047						STOP^
 17048	040435	254 04 0 00 040436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17049	040436	324 00 0 00 040437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17051									;IN THE SUBTEST) TO LOOP ON ERROR^
 17052
 17053					;**********
 17054
 17055
 17056					;THIS TEST VERIFIES THAT CAMN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN AND
 17057					;ONLY WHEN C(AC) IS NOT EQUAL TO C(E).  HENCE,
 17058					;CAMN SHOULD SKIP;  OTHERWISE THE PROGRAM HALTS.
 17059					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A 1 THRU ALL 36 BITS OF THE AC
 17060			002044		SN=SN+1
 17061		400000	000000			ZZ=ZZ+ZZ
 17062						IFE	ZZ,<ZZ=1>
 17063	040437	200 00 0 00 070256 		MOVE	[ZZ]		;PRELOAD AC WITH A FLOATING 1	
 17064	040440	316 00 0 00 070253 		CAMN	[0]		;*CAMN SHOULD SKIP BECAUSE C(AC) IS NOT EQUAL TO C(E)	
 17065						STOP^
 17066	040441	254 04 0 00 040442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17067	040442	324 00 0 00 040443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25-12
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAMX) INSTRUCTIONS

 17068									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17069									;IN THE SUBTEST) TO LOOP ON ERROR^
 17070
 17071					;**********
 17072
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17073					SUBTTL	TEST OF MOVS INSTRUCTION
 17074
 17075					;**********
 17076
 17077			002100		SN=2100
 17078			000000			ZZ=0
 17079
 17080					B2100:	REPEAT	^D18,<
 17081					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17082					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17083					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17084					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17085					
 17086					SN=SN+1
 17087						ZZ=ZZ+ZZ
 17088						IFE	ZZ,<ZZ=1>
 17089						MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17090									;AND MOVE RESULT INTO AC
 17091						CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17092						STOP		
 17093					
 17094					;**********
 17095					>
 17096
 17097					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17098					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17099					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17100					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17101
 17102			002101		SN=SN+1
 17103			000000			ZZ=ZZ+ZZ
 17104			000001			IFE	ZZ,<ZZ=1>
 17105	040443	204 00 0 00 070251 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17106									;AND MOVE RESULT INTO AC
 17107	040444	312 00 0 00 070251 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17108						STOP		^
 17109	040445	254 04 0 00 040446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17110	040446	324 00 0 00 040447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17111									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17112									;IN THE SUBTEST) TO LOOP ON ERROR^
 17113
 17114					;**********
 17115
 17116
 17117					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17118					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17119					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17120					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17121
 17122			002102		SN=SN+1
 17123			000002			ZZ=ZZ+ZZ
 17124						IFE	ZZ,<ZZ=1>
 17125	040447	204 00 0 00 070440 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17126									;AND MOVE RESULT INTO AC
 17127	040450	312 00 0 00 070440 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17128						STOP		^
 17129	040451	254 04 0 00 040452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17130	040452	324 00 0 00 040453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17131									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17132									;IN THE SUBTEST) TO LOOP ON ERROR^
 17133
 17134					;**********
 17135
 17136
 17137					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17138					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17139					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17140					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17141
 17142			002103		SN=SN+1
 17143			000004			ZZ=ZZ+ZZ
 17144						IFE	ZZ,<ZZ=1>
 17145	040453	204 00 0 00 070441 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17146									;AND MOVE RESULT INTO AC
 17147	040454	312 00 0 00 070441 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17148						STOP		^
 17149	040455	254 04 0 00 040456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17150	040456	324 00 0 00 040457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17151									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17152									;IN THE SUBTEST) TO LOOP ON ERROR^
 17153
 17154					;**********
 17155
 17156
 17157					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17158					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17159					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17160					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17161
 17162			002104		SN=SN+1
 17163			000010			ZZ=ZZ+ZZ
 17164						IFE	ZZ,<ZZ=1>
 17165	040457	204 00 0 00 070442 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17166									;AND MOVE RESULT INTO AC
 17167	040460	312 00 0 00 070442 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17168						STOP		^
 17169	040461	254 04 0 00 040462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17170	040462	324 00 0 00 040463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17171									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17172									;IN THE SUBTEST) TO LOOP ON ERROR^
 17173
 17174					;**********
 17175
 17176
 17177					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17178					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17179					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17180					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17181
 17182			002105		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17183			000020			ZZ=ZZ+ZZ
 17184						IFE	ZZ,<ZZ=1>
 17185	040463	204 00 0 00 070443 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17186									;AND MOVE RESULT INTO AC
 17187	040464	312 00 0 00 070443 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17188						STOP		^
 17189	040465	254 04 0 00 040466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17190	040466	324 00 0 00 040467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17191									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17192									;IN THE SUBTEST) TO LOOP ON ERROR^
 17193
 17194					;**********
 17195
 17196
 17197					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17198					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17199					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17200					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17201
 17202			002106		SN=SN+1
 17203			000040			ZZ=ZZ+ZZ
 17204						IFE	ZZ,<ZZ=1>
 17205	040467	204 00 0 00 070444 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17206									;AND MOVE RESULT INTO AC
 17207	040470	312 00 0 00 070444 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17208						STOP		^
 17209	040471	254 04 0 00 040472 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17210	040472	324 00 0 00 040473 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17212									;IN THE SUBTEST) TO LOOP ON ERROR^
 17213
 17214					;**********
 17215
 17216
 17217					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17218					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17219					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17220					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17221
 17222			002107		SN=SN+1
 17223			000100			ZZ=ZZ+ZZ
 17224						IFE	ZZ,<ZZ=1>
 17225	040473	204 00 0 00 070445 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17226									;AND MOVE RESULT INTO AC
 17227	040474	312 00 0 00 070445 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17228						STOP		^
 17229	040475	254 04 0 00 040476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17230	040476	324 00 0 00 040477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17232									;IN THE SUBTEST) TO LOOP ON ERROR^
 17233
 17234					;**********
 17235
 17236
 17237					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17238					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17239					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17240					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17241
 17242			002110		SN=SN+1
 17243			000200			ZZ=ZZ+ZZ
 17244						IFE	ZZ,<ZZ=1>
 17245	040477	204 00 0 00 070446 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17246									;AND MOVE RESULT INTO AC
 17247	040500	312 00 0 00 070446 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17248						STOP		^
 17249	040501	254 04 0 00 040502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17250	040502	324 00 0 00 040503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17251									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17252									;IN THE SUBTEST) TO LOOP ON ERROR^
 17253
 17254					;**********
 17255
 17256
 17257					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17258					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17259					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17260					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17261
 17262			002111		SN=SN+1
 17263			000400			ZZ=ZZ+ZZ
 17264						IFE	ZZ,<ZZ=1>
 17265	040503	204 00 0 00 070447 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17266									;AND MOVE RESULT INTO AC
 17267	040504	312 00 0 00 070447 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17268						STOP		^
 17269	040505	254 04 0 00 040506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17270	040506	324 00 0 00 040507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17271									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17272									;IN THE SUBTEST) TO LOOP ON ERROR^
 17273
 17274					;**********
 17275
 17276
 17277					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17278					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17279					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17280					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17281
 17282			002112		SN=SN+1
 17283			001000			ZZ=ZZ+ZZ
 17284						IFE	ZZ,<ZZ=1>
 17285	040507	204 00 0 00 070450 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17286									;AND MOVE RESULT INTO AC
 17287	040510	312 00 0 00 070450 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17288						STOP		^
 17289	040511	254 04 0 00 040512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17290	040512	324 00 0 00 040513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17291									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17292									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17293
 17294					;**********
 17295
 17296
 17297					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17298					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17299					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17300					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17301
 17302			002113		SN=SN+1
 17303			002000			ZZ=ZZ+ZZ
 17304						IFE	ZZ,<ZZ=1>
 17305	040513	204 00 0 00 070451 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17306									;AND MOVE RESULT INTO AC
 17307	040514	312 00 0 00 070451 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17308						STOP		^
 17309	040515	254 04 0 00 040516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17310	040516	324 00 0 00 040517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17312									;IN THE SUBTEST) TO LOOP ON ERROR^
 17313
 17314					;**********
 17315
 17316
 17317					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17318					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17319					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17320					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17321
 17322			002114		SN=SN+1
 17323			004000			ZZ=ZZ+ZZ
 17324						IFE	ZZ,<ZZ=1>
 17325	040517	204 00 0 00 070452 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17326									;AND MOVE RESULT INTO AC
 17327	040520	312 00 0 00 070452 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17328						STOP		^
 17329	040521	254 04 0 00 040522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17330	040522	324 00 0 00 040523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17332									;IN THE SUBTEST) TO LOOP ON ERROR^
 17333
 17334					;**********
 17335
 17336
 17337					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17338					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17339					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17340					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17341
 17342			002115		SN=SN+1
 17343			010000			ZZ=ZZ+ZZ
 17344						IFE	ZZ,<ZZ=1>
 17345	040523	204 00 0 00 070453 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17346									;AND MOVE RESULT INTO AC
 17347	040524	312 00 0 00 070453 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17348						STOP		^
 17349	040525	254 04 0 00 040526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17350	040526	324 00 0 00 040527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17351									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17352									;IN THE SUBTEST) TO LOOP ON ERROR^
 17353
 17354					;**********
 17355
 17356
 17357					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17358					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17359					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17360					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17361
 17362			002116		SN=SN+1
 17363			020000			ZZ=ZZ+ZZ
 17364						IFE	ZZ,<ZZ=1>
 17365	040527	204 00 0 00 070454 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17366									;AND MOVE RESULT INTO AC
 17367	040530	312 00 0 00 070454 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17368						STOP		^
 17369	040531	254 04 0 00 040532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17370	040532	324 00 0 00 040533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17371									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17372									;IN THE SUBTEST) TO LOOP ON ERROR^
 17373
 17374					;**********
 17375
 17376
 17377					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17378					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17379					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17380					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17381
 17382			002117		SN=SN+1
 17383			040000			ZZ=ZZ+ZZ
 17384						IFE	ZZ,<ZZ=1>
 17385	040533	204 00 0 00 070455 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17386									;AND MOVE RESULT INTO AC
 17387	040534	312 00 0 00 070455 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17388						STOP		^
 17389	040535	254 04 0 00 040536 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17390	040536	324 00 0 00 040537 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17391									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17392									;IN THE SUBTEST) TO LOOP ON ERROR^
 17393
 17394					;**********
 17395
 17396
 17397					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17398					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17399					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17400					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17401
 17402			002120		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17403			100000			ZZ=ZZ+ZZ
 17404						IFE	ZZ,<ZZ=1>
 17405	040537	204 00 0 00 070456 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17406									;AND MOVE RESULT INTO AC
 17407	040540	312 00 0 00 070456 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17408						STOP		^
 17409	040541	254 04 0 00 040542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17410	040542	324 00 0 00 040543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17412									;IN THE SUBTEST) TO LOOP ON ERROR^
 17413
 17414					;**********
 17415
 17416
 17417					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17418					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17419					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17420					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17421
 17422			002121		SN=SN+1
 17423			200000			ZZ=ZZ+ZZ
 17424						IFE	ZZ,<ZZ=1>
 17425	040543	204 00 0 00 070457 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17426									;AND MOVE RESULT INTO AC
 17427	040544	312 00 0 00 070457 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17428						STOP		^
 17429	040545	254 04 0 00 040546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17430	040546	324 00 0 00 040547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17431									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17432									;IN THE SUBTEST) TO LOOP ON ERROR^
 17433
 17434					;**********
 17435
 17436
 17437					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17438					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU BOTH HALVES
 17439					;OF E [C(E)=ZZ,,ZZ WHERE ZZ IS A FLOATING 1].  THEN, C(AC) IS CHECKED.
 17440					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF EACH HALF
 17441
 17442			002122		SN=SN+1
 17443			400000			ZZ=ZZ+ZZ
 17444						IFE	ZZ,<ZZ=1>
 17445	040547	204 00 0 00 070460 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17446									;AND MOVE RESULT INTO AC
 17447	040550	312 00 0 00 070460 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF C(AC) CONTAINS ZZ,,ZZ
 17448						STOP		^
 17449	040551	254 04 0 00 040552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17450	040552	324 00 0 00 040553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17452									;IN THE SUBTEST) TO LOOP ON ERROR^
 17453
 17454					;**********
 17455
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17456			002200		SN=2200
 17457			000000			ZZ=0
 17458
 17459					B2200:	REPEAT	^D18,<
 17460					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17461					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17462					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17463					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17464					
 17465					SN=SN+1
 17466						ZZ=ZZ+ZZ+1
 17467						IFE	<ZZ-1>,<ZZ=-2>
 17468						MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17469									;AND MOVE RESULT INTO AC
 17470						CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17471						STOP		
 17472					
 17473					;**********
 17474					>
 17475
 17476					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17477					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17478					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17479					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17480
 17481			002201		SN=SN+1
 17482			000001			ZZ=ZZ+ZZ+1
 17483		777777	777776			IFE	<ZZ-1>,<ZZ=-2>
 17484	040553	204 00 0 00 070461 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17485									;AND MOVE RESULT INTO AC
 17486	040554	312 00 0 00 070461 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17487						STOP		^
 17488	040555	254 04 0 00 040556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17489	040556	324 00 0 00 040557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17491									;IN THE SUBTEST) TO LOOP ON ERROR^
 17492
 17493					;**********
 17494
 17495
 17496					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17497					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17498					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17499					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17500
 17501			002202		SN=SN+1
 17502		777777	777775			ZZ=ZZ+ZZ+1
 17503						IFE	<ZZ-1>,<ZZ=-2>
 17504	040557	204 00 0 00 070462 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17505									;AND MOVE RESULT INTO AC
 17506	040560	312 00 0 00 070462 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17507						STOP		^
 17508	040561	254 04 0 00 040562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17509	040562	324 00 0 00 040563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17511									;IN THE SUBTEST) TO LOOP ON ERROR^
 17512
 17513					;**********
 17514
 17515
 17516					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17517					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17518					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17519					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17520
 17521			002203		SN=SN+1
 17522		777777	777773			ZZ=ZZ+ZZ+1
 17523						IFE	<ZZ-1>,<ZZ=-2>
 17524	040563	204 00 0 00 070463 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17525									;AND MOVE RESULT INTO AC
 17526	040564	312 00 0 00 070463 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17527						STOP		^
 17528	040565	254 04 0 00 040566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17529	040566	324 00 0 00 040567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17530									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17531									;IN THE SUBTEST) TO LOOP ON ERROR^
 17532
 17533					;**********
 17534
 17535
 17536					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17537					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17538					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17539					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17540
 17541			002204		SN=SN+1
 17542		777777	777767			ZZ=ZZ+ZZ+1
 17543						IFE	<ZZ-1>,<ZZ=-2>
 17544	040567	204 00 0 00 070464 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17545									;AND MOVE RESULT INTO AC
 17546	040570	312 00 0 00 070464 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17547						STOP		^
 17548	040571	254 04 0 00 040572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17549	040572	324 00 0 00 040573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17550									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17551									;IN THE SUBTEST) TO LOOP ON ERROR^
 17552
 17553					;**********
 17554
 17555
 17556					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17557					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17558					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17559					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17560
 17561			002205		SN=SN+1
 17562		777777	777757			ZZ=ZZ+ZZ+1
 17563						IFE	<ZZ-1>,<ZZ=-2>
 17564	040573	204 00 0 00 070465 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17565									;AND MOVE RESULT INTO AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17566	040574	312 00 0 00 070465 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17567						STOP		^
 17568	040575	254 04 0 00 040576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17569	040576	324 00 0 00 040577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17570									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17571									;IN THE SUBTEST) TO LOOP ON ERROR^
 17572
 17573					;**********
 17574
 17575
 17576					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17577					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17578					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17579					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17580
 17581			002206		SN=SN+1
 17582		777777	777737			ZZ=ZZ+ZZ+1
 17583						IFE	<ZZ-1>,<ZZ=-2>
 17584	040577	204 00 0 00 070466 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17585									;AND MOVE RESULT INTO AC
 17586	040600	312 00 0 00 070466 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17587						STOP		^
 17588	040601	254 04 0 00 040602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17589	040602	324 00 0 00 040603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17590									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17591									;IN THE SUBTEST) TO LOOP ON ERROR^
 17592
 17593					;**********
 17594
 17595
 17596					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17597					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17598					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17599					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17600
 17601			002207		SN=SN+1
 17602		777777	777677			ZZ=ZZ+ZZ+1
 17603						IFE	<ZZ-1>,<ZZ=-2>
 17604	040603	204 00 0 00 070467 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17605									;AND MOVE RESULT INTO AC
 17606	040604	312 00 0 00 070467 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17607						STOP		^
 17608	040605	254 04 0 00 040606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17609	040606	324 00 0 00 040607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17610									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17611									;IN THE SUBTEST) TO LOOP ON ERROR^
 17612
 17613					;**********
 17614
 17615
 17616					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17617					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17618					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17619					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17620
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17621			002210		SN=SN+1
 17622		777777	777577			ZZ=ZZ+ZZ+1
 17623						IFE	<ZZ-1>,<ZZ=-2>
 17624	040607	204 00 0 00 070470 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17625									;AND MOVE RESULT INTO AC
 17626	040610	312 00 0 00 070470 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17627						STOP		^
 17628	040611	254 04 0 00 040612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17629	040612	324 00 0 00 040613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17631									;IN THE SUBTEST) TO LOOP ON ERROR^
 17632
 17633					;**********
 17634
 17635
 17636					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17637					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17638					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17639					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17640
 17641			002211		SN=SN+1
 17642		777777	777377			ZZ=ZZ+ZZ+1
 17643						IFE	<ZZ-1>,<ZZ=-2>
 17644	040613	204 00 0 00 070471 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17645									;AND MOVE RESULT INTO AC
 17646	040614	312 00 0 00 070471 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17647						STOP		^
 17648	040615	254 04 0 00 040616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17649	040616	324 00 0 00 040617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17650									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17651									;IN THE SUBTEST) TO LOOP ON ERROR^
 17652
 17653					;**********
 17654
 17655
 17656					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17657					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17658					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17659					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17660
 17661			002212		SN=SN+1
 17662		777777	776777			ZZ=ZZ+ZZ+1
 17663						IFE	<ZZ-1>,<ZZ=-2>
 17664	040617	204 00 0 00 070472 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17665									;AND MOVE RESULT INTO AC
 17666	040620	312 00 0 00 070472 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17667						STOP		^
 17668	040621	254 04 0 00 040622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17669	040622	324 00 0 00 040623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17670									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17671									;IN THE SUBTEST) TO LOOP ON ERROR^
 17672
 17673					;**********
 17674
 17675
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17676					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17677					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17678					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17679					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17680
 17681			002213		SN=SN+1
 17682		777777	775777			ZZ=ZZ+ZZ+1
 17683						IFE	<ZZ-1>,<ZZ=-2>
 17684	040623	204 00 0 00 070473 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17685									;AND MOVE RESULT INTO AC
 17686	040624	312 00 0 00 070473 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17687						STOP		^
 17688	040625	254 04 0 00 040626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17689	040626	324 00 0 00 040627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17691									;IN THE SUBTEST) TO LOOP ON ERROR^
 17692
 17693					;**********
 17694
 17695
 17696					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17697					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17698					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17699					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17700
 17701			002214		SN=SN+1
 17702		777777	773777			ZZ=ZZ+ZZ+1
 17703						IFE	<ZZ-1>,<ZZ=-2>
 17704	040627	204 00 0 00 070474 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17705									;AND MOVE RESULT INTO AC
 17706	040630	312 00 0 00 070474 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17707						STOP		^
 17708	040631	254 04 0 00 040632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17709	040632	324 00 0 00 040633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17711									;IN THE SUBTEST) TO LOOP ON ERROR^
 17712
 17713					;**********
 17714
 17715
 17716					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17717					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17718					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17719					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17720
 17721			002215		SN=SN+1
 17722		777777	767777			ZZ=ZZ+ZZ+1
 17723						IFE	<ZZ-1>,<ZZ=-2>
 17724	040633	204 00 0 00 070475 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17725									;AND MOVE RESULT INTO AC
 17726	040634	312 00 0 00 070475 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17727						STOP		^
 17728	040635	254 04 0 00 040636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17729	040636	324 00 0 00 040637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17731									;IN THE SUBTEST) TO LOOP ON ERROR^
 17732
 17733					;**********
 17734
 17735
 17736					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17737					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17738					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17739					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17740
 17741			002216		SN=SN+1
 17742		777777	757777			ZZ=ZZ+ZZ+1
 17743						IFE	<ZZ-1>,<ZZ=-2>
 17744	040637	204 00 0 00 070476 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17745									;AND MOVE RESULT INTO AC
 17746	040640	312 00 0 00 070476 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17747						STOP		^
 17748	040641	254 04 0 00 040642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17749	040642	324 00 0 00 040643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17751									;IN THE SUBTEST) TO LOOP ON ERROR^
 17752
 17753					;**********
 17754
 17755
 17756					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17757					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17758					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17759					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17760
 17761			002217		SN=SN+1
 17762		777777	737777			ZZ=ZZ+ZZ+1
 17763						IFE	<ZZ-1>,<ZZ=-2>
 17764	040643	204 00 0 00 070477 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17765									;AND MOVE RESULT INTO AC
 17766	040644	312 00 0 00 070477 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17767						STOP		^
 17768	040645	254 04 0 00 040646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17769	040646	324 00 0 00 040647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17771									;IN THE SUBTEST) TO LOOP ON ERROR^
 17772
 17773					;**********
 17774
 17775
 17776					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17777					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17778					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17779					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17780
 17781			002220		SN=SN+1
 17782		777777	677777			ZZ=ZZ+ZZ+1
 17783						IFE	<ZZ-1>,<ZZ=-2>
 17784	040647	204 00 0 00 070500 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17785									;AND MOVE RESULT INTO AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17786	040650	312 00 0 00 070500 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17787						STOP		^
 17788	040651	254 04 0 00 040652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17789	040652	324 00 0 00 040653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17790									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17791									;IN THE SUBTEST) TO LOOP ON ERROR^
 17792
 17793					;**********
 17794
 17795
 17796					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17797					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17798					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17799					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17800
 17801			002221		SN=SN+1
 17802		777777	577777			ZZ=ZZ+ZZ+1
 17803						IFE	<ZZ-1>,<ZZ=-2>
 17804	040653	204 00 0 00 070501 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17805									;AND MOVE RESULT INTO AC
 17806	040654	312 00 0 00 070501 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17807						STOP		^
 17808	040655	254 04 0 00 040656 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17809	040656	324 00 0 00 040657 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17811									;IN THE SUBTEST) TO LOOP ON ERROR^
 17812
 17813					;**********
 17814
 17815
 17816					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17817					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU BOTH HALVES
 17818					;OF E [C(E)=ZZ,,ZZ, WHERE ZZ IS A FLOATING 0].  THEN, C(AC) IS CHECKED.
 17819					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 0 THRU ALL 18 BITS OF EACH HALF
 17820
 17821			002222		SN=SN+1
 17822		777777	377777			ZZ=ZZ+ZZ+1
 17823						IFE	<ZZ-1>,<ZZ=-2>
 17824	040657	204 00 0 00 070502 		MOVS	[XWD ZZ,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17825									;AND MOVE RESULT INTO AC
 17826	040660	312 00 0 00 070502 		CAME	[XWD ZZ,ZZ]	;PASS TEST IF AC CONTAINS ZZ,,ZZ
 17827						STOP		^
 17828	040661	254 04 0 00 040662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17829	040662	324 00 0 00 040663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17830									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17831									;IN THE SUBTEST) TO LOOP ON ERROR^
 17832
 17833					;**********
 17834
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17835			002300		SN=2300
 17836			000000			ZZ=0
 17837			000000			YY=0
 17838
 17839					B2300:	REPEAT	^D18,<
 17840					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17841					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17842					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17843					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17844					;THEN, C(AC) IS CHECKED.
 17845					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17846					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17847					
 17848					SN=SN+1
 17849						ZZ=ZZ+ZZ
 17850						YY=YY+YY+1
 17851						IFE	ZZ,<ZZ=1>
 17852						IFE	<YY-1>,<YY=-2>
 17853						MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17854									;AND MOVE RESULT INTO AC
 17855						CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17856						STOP		
 17857					
 17858					;**********
 17859					>
 17860
 17861					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17862					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17863					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17864					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17865					;THEN, C(AC) IS CHECKED.
 17866					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17867					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17868
 17869			002301		SN=SN+1
 17870			000000			ZZ=ZZ+ZZ
 17871			000001			YY=YY+YY+1
 17872			000001			IFE	ZZ,<ZZ=1>
 17873		777777	777776			IFE	<YY-1>,<YY=-2>
 17874	040663	204 00 0 00 070503 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17875									;AND MOVE RESULT INTO AC
 17876	040664	312 00 0 00 070504 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17877						STOP		^
 17878	040665	254 04 0 00 040666 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17879	040666	324 00 0 00 040667 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17880									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17881									;IN THE SUBTEST) TO LOOP ON ERROR^
 17882
 17883					;**********
 17884
 17885
 17886					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17887					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17888					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17889					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17890					;THEN, C(AC) IS CHECKED.
 17891					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17892					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17893
 17894			002302		SN=SN+1
 17895			000002			ZZ=ZZ+ZZ
 17896		777777	777775			YY=YY+YY+1
 17897						IFE	ZZ,<ZZ=1>
 17898						IFE	<YY-1>,<YY=-2>
 17899	040667	204 00 0 00 070505 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17900									;AND MOVE RESULT INTO AC
 17901	040670	312 00 0 00 070506 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17902						STOP		^
 17903	040671	254 04 0 00 040672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17904	040672	324 00 0 00 040673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17905									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17906									;IN THE SUBTEST) TO LOOP ON ERROR^
 17907
 17908					;**********
 17909
 17910
 17911					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17912					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17913					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17914					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17915					;THEN, C(AC) IS CHECKED.
 17916					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17917					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17918
 17919			002303		SN=SN+1
 17920			000004			ZZ=ZZ+ZZ
 17921		777777	777773			YY=YY+YY+1
 17922						IFE	ZZ,<ZZ=1>
 17923						IFE	<YY-1>,<YY=-2>
 17924	040673	204 00 0 00 070507 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17925									;AND MOVE RESULT INTO AC
 17926	040674	312 00 0 00 070510 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17927						STOP		^
 17928	040675	254 04 0 00 040676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17929	040676	324 00 0 00 040677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17930									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17931									;IN THE SUBTEST) TO LOOP ON ERROR^
 17932
 17933					;**********
 17934
 17935
 17936					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17937					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17938					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17939					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17940					;THEN, C(AC) IS CHECKED.
 17941					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17942					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17943
 17944			002304		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 17945			000010			ZZ=ZZ+ZZ
 17946		777777	777767			YY=YY+YY+1
 17947						IFE	ZZ,<ZZ=1>
 17948						IFE	<YY-1>,<YY=-2>
 17949	040677	204 00 0 00 070511 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17950									;AND MOVE RESULT INTO AC
 17951	040700	312 00 0 00 070512 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17952						STOP		^
 17953	040701	254 04 0 00 040702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17954	040702	324 00 0 00 040703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17955									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17956									;IN THE SUBTEST) TO LOOP ON ERROR^
 17957
 17958					;**********
 17959
 17960
 17961					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17962					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17963					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17964					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17965					;THEN, C(AC) IS CHECKED.
 17966					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17967					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17968
 17969			002305		SN=SN+1
 17970			000020			ZZ=ZZ+ZZ
 17971		777777	777757			YY=YY+YY+1
 17972						IFE	ZZ,<ZZ=1>
 17973						IFE	<YY-1>,<YY=-2>
 17974	040703	204 00 0 00 070513 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 17975									;AND MOVE RESULT INTO AC
 17976	040704	312 00 0 00 070514 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 17977						STOP		^
 17978	040705	254 04 0 00 040706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 17979	040706	324 00 0 00 040707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 17980									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 17981									;IN THE SUBTEST) TO LOOP ON ERROR^
 17982
 17983					;**********
 17984
 17985
 17986					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 17987					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 17988					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 17989					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 17990					;THEN, C(AC) IS CHECKED.
 17991					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 17992					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 17993
 17994			002306		SN=SN+1
 17995			000040			ZZ=ZZ+ZZ
 17996		777777	777737			YY=YY+YY+1
 17997						IFE	ZZ,<ZZ=1>
 17998						IFE	<YY-1>,<YY=-2>
 17999	040707	204 00 0 00 070515 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18000									;AND MOVE RESULT INTO AC
 18001	040710	312 00 0 00 070516 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18002						STOP		^
 18003	040711	254 04 0 00 040712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18004	040712	324 00 0 00 040713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18005									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18006									;IN THE SUBTEST) TO LOOP ON ERROR^
 18007
 18008					;**********
 18009
 18010
 18011					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18012					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18013					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18014					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18015					;THEN, C(AC) IS CHECKED.
 18016					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18017					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18018
 18019			002307		SN=SN+1
 18020			000100			ZZ=ZZ+ZZ
 18021		777777	777677			YY=YY+YY+1
 18022						IFE	ZZ,<ZZ=1>
 18023						IFE	<YY-1>,<YY=-2>
 18024	040713	204 00 0 00 070517 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18025									;AND MOVE RESULT INTO AC
 18026	040714	312 00 0 00 070520 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18027						STOP		^
 18028	040715	254 04 0 00 040716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18029	040716	324 00 0 00 040717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18030									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18031									;IN THE SUBTEST) TO LOOP ON ERROR^
 18032
 18033					;**********
 18034
 18035
 18036					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18037					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18038					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18039					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18040					;THEN, C(AC) IS CHECKED.
 18041					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18042					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18043
 18044			002310		SN=SN+1
 18045			000200			ZZ=ZZ+ZZ
 18046		777777	777577			YY=YY+YY+1
 18047						IFE	ZZ,<ZZ=1>
 18048						IFE	<YY-1>,<YY=-2>
 18049	040717	204 00 0 00 070521 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18050									;AND MOVE RESULT INTO AC
 18051	040720	312 00 0 00 070522 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18052						STOP		^
 18053	040721	254 04 0 00 040722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18054	040722	324 00 0 00 040723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18055									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18056									;IN THE SUBTEST) TO LOOP ON ERROR^
 18057
 18058					;**********
 18059
 18060
 18061					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18062					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18063					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18064					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18065					;THEN, C(AC) IS CHECKED.
 18066					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18067					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18068
 18069			002311		SN=SN+1
 18070			000400			ZZ=ZZ+ZZ
 18071		777777	777377			YY=YY+YY+1
 18072						IFE	ZZ,<ZZ=1>
 18073						IFE	<YY-1>,<YY=-2>
 18074	040723	204 00 0 00 070523 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18075									;AND MOVE RESULT INTO AC
 18076	040724	312 00 0 00 070524 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18077						STOP		^
 18078	040725	254 04 0 00 040726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18079	040726	324 00 0 00 040727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18080									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18081									;IN THE SUBTEST) TO LOOP ON ERROR^
 18082
 18083					;**********
 18084
 18085
 18086					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18087					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18088					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18089					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18090					;THEN, C(AC) IS CHECKED.
 18091					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18092					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18093
 18094			002312		SN=SN+1
 18095			001000			ZZ=ZZ+ZZ
 18096		777777	776777			YY=YY+YY+1
 18097						IFE	ZZ,<ZZ=1>
 18098						IFE	<YY-1>,<YY=-2>
 18099	040727	204 00 0 00 070525 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18100									;AND MOVE RESULT INTO AC
 18101	040730	312 00 0 00 070526 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18102						STOP		^
 18103	040731	254 04 0 00 040732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18104	040732	324 00 0 00 040733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18105									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18106									;IN THE SUBTEST) TO LOOP ON ERROR^
 18107
 18108					;**********
 18109
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18110
 18111					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18112					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18113					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18114					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18115					;THEN, C(AC) IS CHECKED.
 18116					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18117					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18118
 18119			002313		SN=SN+1
 18120			002000			ZZ=ZZ+ZZ
 18121		777777	775777			YY=YY+YY+1
 18122						IFE	ZZ,<ZZ=1>
 18123						IFE	<YY-1>,<YY=-2>
 18124	040733	204 00 0 00 070527 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18125									;AND MOVE RESULT INTO AC
 18126	040734	312 00 0 00 070530 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18127						STOP		^
 18128	040735	254 04 0 00 040736 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18129	040736	324 00 0 00 040737 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18131									;IN THE SUBTEST) TO LOOP ON ERROR^
 18132
 18133					;**********
 18134
 18135
 18136					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18137					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18138					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18139					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18140					;THEN, C(AC) IS CHECKED.
 18141					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18142					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18143
 18144			002314		SN=SN+1
 18145			004000			ZZ=ZZ+ZZ
 18146		777777	773777			YY=YY+YY+1
 18147						IFE	ZZ,<ZZ=1>
 18148						IFE	<YY-1>,<YY=-2>
 18149	040737	204 00 0 00 070531 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18150									;AND MOVE RESULT INTO AC
 18151	040740	312 00 0 00 070532 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18152						STOP		^
 18153	040741	254 04 0 00 040742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18154	040742	324 00 0 00 040743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18155									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18156									;IN THE SUBTEST) TO LOOP ON ERROR^
 18157
 18158					;**********
 18159
 18160
 18161					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18162					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18163					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18164					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18165					;THEN, C(AC) IS CHECKED.
 18166					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18167					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18168
 18169			002315		SN=SN+1
 18170			010000			ZZ=ZZ+ZZ
 18171		777777	767777			YY=YY+YY+1
 18172						IFE	ZZ,<ZZ=1>
 18173						IFE	<YY-1>,<YY=-2>
 18174	040743	204 00 0 00 070533 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18175									;AND MOVE RESULT INTO AC
 18176	040744	312 00 0 00 070534 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18177						STOP		^
 18178	040745	254 04 0 00 040746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18179	040746	324 00 0 00 040747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18181									;IN THE SUBTEST) TO LOOP ON ERROR^
 18182
 18183					;**********
 18184
 18185
 18186					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18187					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18188					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18189					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18190					;THEN, C(AC) IS CHECKED.
 18191					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18192					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18193
 18194			002316		SN=SN+1
 18195			020000			ZZ=ZZ+ZZ
 18196		777777	757777			YY=YY+YY+1
 18197						IFE	ZZ,<ZZ=1>
 18198						IFE	<YY-1>,<YY=-2>
 18199	040747	204 00 0 00 070535 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18200									;AND MOVE RESULT INTO AC
 18201	040750	312 00 0 00 070536 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18202						STOP		^
 18203	040751	254 04 0 00 040752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18204	040752	324 00 0 00 040753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18206									;IN THE SUBTEST) TO LOOP ON ERROR^
 18207
 18208					;**********
 18209
 18210
 18211					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18212					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18213					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18214					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18215					;THEN, C(AC) IS CHECKED.
 18216					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18217					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18218
 18219			002317		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18220			040000			ZZ=ZZ+ZZ
 18221		777777	737777			YY=YY+YY+1
 18222						IFE	ZZ,<ZZ=1>
 18223						IFE	<YY-1>,<YY=-2>
 18224	040753	204 00 0 00 070537 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18225									;AND MOVE RESULT INTO AC
 18226	040754	312 00 0 00 070540 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18227						STOP		^
 18228	040755	254 04 0 00 040756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18229	040756	324 00 0 00 040757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18230									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18231									;IN THE SUBTEST) TO LOOP ON ERROR^
 18232
 18233					;**********
 18234
 18235
 18236					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18237					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18238					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18239					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18240					;THEN, C(AC) IS CHECKED.
 18241					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18242					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18243
 18244			002320		SN=SN+1
 18245			100000			ZZ=ZZ+ZZ
 18246		777777	677777			YY=YY+YY+1
 18247						IFE	ZZ,<ZZ=1>
 18248						IFE	<YY-1>,<YY=-2>
 18249	040757	204 00 0 00 070541 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18250									;AND MOVE RESULT INTO AC
 18251	040760	312 00 0 00 070542 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18252						STOP		^
 18253	040761	254 04 0 00 040762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18254	040762	324 00 0 00 040763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18256									;IN THE SUBTEST) TO LOOP ON ERROR^
 18257
 18258					;**********
 18259
 18260
 18261					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18262					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18263					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18264					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18265					;THEN, C(AC) IS CHECKED.
 18266					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18267					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18268
 18269			002321		SN=SN+1
 18270			200000			ZZ=ZZ+ZZ
 18271		777777	577777			YY=YY+YY+1
 18272						IFE	ZZ,<ZZ=1>
 18273						IFE	<YY-1>,<YY=-2>
 18274	040763	204 00 0 00 070543 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18275									;AND MOVE RESULT INTO AC
 18276	040764	312 00 0 00 070544 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18277						STOP		^
 18278	040765	254 04 0 00 040766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18279	040766	324 00 0 00 040767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18281									;IN THE SUBTEST) TO LOOP ON ERROR^
 18282
 18283					;**********
 18284
 18285
 18286					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18287					;MOVES IT INTO AC.  IN THIS CASE, A 1 IS RIPPLED THRU THE LEFT HALF OF E
 18288					;AND A 0 IS RIPPLED THRU THE RIGHT HALF
 18289					;OF E [C(E)=ZZ,,YY, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18290					;THEN, C(AC) IS CHECKED.
 18291					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18292					;THE LEFT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18293
 18294			002322		SN=SN+1
 18295			400000			ZZ=ZZ+ZZ
 18296		777777	377777			YY=YY+YY+1
 18297						IFE	ZZ,<ZZ=1>
 18298						IFE	<YY-1>,<YY=-2>
 18299	040767	204 00 0 00 070545 		MOVS	[XWD ZZ,YY]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18300									;AND MOVE RESULT INTO AC
 18301	040770	312 00 0 00 070546 		CAME	[XWD YY,ZZ]	;PASS TEST IF AC CONTAINS YY,,ZZ
 18302						STOP		^
 18303	040771	254 04 0 00 040772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18304	040772	324 00 0 00 040773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18305									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18306									;IN THE SUBTEST) TO LOOP ON ERROR^
 18307
 18308					;**********
 18309
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18310			002400		SN=2400
 18311			000000			ZZ=0
 18312			000000			YY=0
 18313
 18314					B2400:	REPEAT	 ^D18,<
 18315					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18316					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18317					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18318					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18319					;THEN, C(AC) IS CHECKED.
 18320					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18321					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18322					
 18323					SN=SN+1
 18324						ZZ=ZZ+ZZ
 18325						YY=YY+YY+1
 18326						IFE	ZZ,<ZZ=1>
 18327						IFE	<YY-1>,<YY=-2>
 18328						MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18329									;AND MOVE RESULT INTO AC
 18330						CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18331						STOP		
 18332					
 18333					;**********
 18334					>
 18335
 18336					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18337					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18338					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18339					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18340					;THEN, C(AC) IS CHECKED.
 18341					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18342					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18343
 18344			002401		SN=SN+1
 18345			000000			ZZ=ZZ+ZZ
 18346			000001			YY=YY+YY+1
 18347			000001			IFE	ZZ,<ZZ=1>
 18348		777777	777776			IFE	<YY-1>,<YY=-2>
 18349	040773	204 00 0 00 070504 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18350									;AND MOVE RESULT INTO AC
 18351	040774	312 00 0 00 070503 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18352						STOP		^
 18353	040775	254 04 0 00 040776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18354	040776	324 00 0 00 040777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18355									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18356									;IN THE SUBTEST) TO LOOP ON ERROR^
 18357
 18358					;**********
 18359
 18360
 18361					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18362					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18363					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18364					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18365					;THEN, C(AC) IS CHECKED.
 18366					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18367					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18368
 18369			002402		SN=SN+1
 18370			000002			ZZ=ZZ+ZZ
 18371		777777	777775			YY=YY+YY+1
 18372						IFE	ZZ,<ZZ=1>
 18373						IFE	<YY-1>,<YY=-2>
 18374	040777	204 00 0 00 070506 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18375									;AND MOVE RESULT INTO AC
 18376	041000	312 00 0 00 070505 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18377						STOP		^
 18378	041001	254 04 0 00 041002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18379	041002	324 00 0 00 041003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18380									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18381									;IN THE SUBTEST) TO LOOP ON ERROR^
 18382
 18383					;**********
 18384
 18385
 18386					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18387					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18388					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18389					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18390					;THEN, C(AC) IS CHECKED.
 18391					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18392					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18393
 18394			002403		SN=SN+1
 18395			000004			ZZ=ZZ+ZZ
 18396		777777	777773			YY=YY+YY+1
 18397						IFE	ZZ,<ZZ=1>
 18398						IFE	<YY-1>,<YY=-2>
 18399	041003	204 00 0 00 070510 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18400									;AND MOVE RESULT INTO AC
 18401	041004	312 00 0 00 070507 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18402						STOP		^
 18403	041005	254 04 0 00 041006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18404	041006	324 00 0 00 041007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18405									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18406									;IN THE SUBTEST) TO LOOP ON ERROR^
 18407
 18408					;**********
 18409
 18410
 18411					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18412					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18413					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18414					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18415					;THEN, C(AC) IS CHECKED.
 18416					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18417					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18418
 18419			002404		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-2
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18420			000010			ZZ=ZZ+ZZ
 18421		777777	777767			YY=YY+YY+1
 18422						IFE	ZZ,<ZZ=1>
 18423						IFE	<YY-1>,<YY=-2>
 18424	041007	204 00 0 00 070512 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18425									;AND MOVE RESULT INTO AC
 18426	041010	312 00 0 00 070511 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18427						STOP		^
 18428	041011	254 04 0 00 041012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18429	041012	324 00 0 00 041013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18430									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18431									;IN THE SUBTEST) TO LOOP ON ERROR^
 18432
 18433					;**********
 18434
 18435
 18436					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18437					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18438					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18439					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18440					;THEN, C(AC) IS CHECKED.
 18441					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18442					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18443
 18444			002405		SN=SN+1
 18445			000020			ZZ=ZZ+ZZ
 18446		777777	777757			YY=YY+YY+1
 18447						IFE	ZZ,<ZZ=1>
 18448						IFE	<YY-1>,<YY=-2>
 18449	041013	204 00 0 00 070514 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18450									;AND MOVE RESULT INTO AC
 18451	041014	312 00 0 00 070513 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18452						STOP		^
 18453	041015	254 04 0 00 041016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18454	041016	324 00 0 00 041017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18455									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18456									;IN THE SUBTEST) TO LOOP ON ERROR^
 18457
 18458					;**********
 18459
 18460
 18461					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18462					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18463					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18464					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18465					;THEN, C(AC) IS CHECKED.
 18466					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18467					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18468
 18469			002406		SN=SN+1
 18470			000040			ZZ=ZZ+ZZ
 18471		777777	777737			YY=YY+YY+1
 18472						IFE	ZZ,<ZZ=1>
 18473						IFE	<YY-1>,<YY=-2>
 18474	041017	204 00 0 00 070516 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-3
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18475									;AND MOVE RESULT INTO AC
 18476	041020	312 00 0 00 070515 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18477						STOP		^
 18478	041021	254 04 0 00 041022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18479	041022	324 00 0 00 041023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18480									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18481									;IN THE SUBTEST) TO LOOP ON ERROR^
 18482
 18483					;**********
 18484
 18485
 18486					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18487					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18488					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18489					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18490					;THEN, C(AC) IS CHECKED.
 18491					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18492					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18493
 18494			002407		SN=SN+1
 18495			000100			ZZ=ZZ+ZZ
 18496		777777	777677			YY=YY+YY+1
 18497						IFE	ZZ,<ZZ=1>
 18498						IFE	<YY-1>,<YY=-2>
 18499	041023	204 00 0 00 070520 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18500									;AND MOVE RESULT INTO AC
 18501	041024	312 00 0 00 070517 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18502						STOP		^
 18503	041025	254 04 0 00 041026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18504	041026	324 00 0 00 041027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18505									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18506									;IN THE SUBTEST) TO LOOP ON ERROR^
 18507
 18508					;**********
 18509
 18510
 18511					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18512					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18513					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18514					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18515					;THEN, C(AC) IS CHECKED.
 18516					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18517					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18518
 18519			002410		SN=SN+1
 18520			000200			ZZ=ZZ+ZZ
 18521		777777	777577			YY=YY+YY+1
 18522						IFE	ZZ,<ZZ=1>
 18523						IFE	<YY-1>,<YY=-2>
 18524	041027	204 00 0 00 070522 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18525									;AND MOVE RESULT INTO AC
 18526	041030	312 00 0 00 070521 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18527						STOP		^
 18528	041031	254 04 0 00 041032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18529	041032	324 00 0 00 041033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-4
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18530									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18531									;IN THE SUBTEST) TO LOOP ON ERROR^
 18532
 18533					;**********
 18534
 18535
 18536					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18537					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18538					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18539					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18540					;THEN, C(AC) IS CHECKED.
 18541					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18542					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18543
 18544			002411		SN=SN+1
 18545			000400			ZZ=ZZ+ZZ
 18546		777777	777377			YY=YY+YY+1
 18547						IFE	ZZ,<ZZ=1>
 18548						IFE	<YY-1>,<YY=-2>
 18549	041033	204 00 0 00 070524 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18550									;AND MOVE RESULT INTO AC
 18551	041034	312 00 0 00 070523 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18552						STOP		^
 18553	041035	254 04 0 00 041036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18554	041036	324 00 0 00 041037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18556									;IN THE SUBTEST) TO LOOP ON ERROR^
 18557
 18558					;**********
 18559
 18560
 18561					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18562					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18563					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18564					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18565					;THEN, C(AC) IS CHECKED.
 18566					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18567					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18568
 18569			002412		SN=SN+1
 18570			001000			ZZ=ZZ+ZZ
 18571		777777	776777			YY=YY+YY+1
 18572						IFE	ZZ,<ZZ=1>
 18573						IFE	<YY-1>,<YY=-2>
 18574	041037	204 00 0 00 070526 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18575									;AND MOVE RESULT INTO AC
 18576	041040	312 00 0 00 070525 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18577						STOP		^
 18578	041041	254 04 0 00 041042 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18579	041042	324 00 0 00 041043 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18580									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18581									;IN THE SUBTEST) TO LOOP ON ERROR^
 18582
 18583					;**********
 18584
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-5
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18585
 18586					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18587					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18588					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18589					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18590					;THEN, C(AC) IS CHECKED.
 18591					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18592					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18593
 18594			002413		SN=SN+1
 18595			002000			ZZ=ZZ+ZZ
 18596		777777	775777			YY=YY+YY+1
 18597						IFE	ZZ,<ZZ=1>
 18598						IFE	<YY-1>,<YY=-2>
 18599	041043	204 00 0 00 070530 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18600									;AND MOVE RESULT INTO AC
 18601	041044	312 00 0 00 070527 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18602						STOP		^
 18603	041045	254 04 0 00 041046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18604	041046	324 00 0 00 041047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18605									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18606									;IN THE SUBTEST) TO LOOP ON ERROR^
 18607
 18608					;**********
 18609
 18610
 18611					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18612					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18613					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18614					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18615					;THEN, C(AC) IS CHECKED.
 18616					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18617					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18618
 18619			002414		SN=SN+1
 18620			004000			ZZ=ZZ+ZZ
 18621		777777	773777			YY=YY+YY+1
 18622						IFE	ZZ,<ZZ=1>
 18623						IFE	<YY-1>,<YY=-2>
 18624	041047	204 00 0 00 070532 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18625									;AND MOVE RESULT INTO AC
 18626	041050	312 00 0 00 070531 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18627						STOP		^
 18628	041051	254 04 0 00 041052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18629	041052	324 00 0 00 041053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18631									;IN THE SUBTEST) TO LOOP ON ERROR^
 18632
 18633					;**********
 18634
 18635
 18636					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18637					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18638					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18639					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-6
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18640					;THEN, C(AC) IS CHECKED.
 18641					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18642					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18643
 18644			002415		SN=SN+1
 18645			010000			ZZ=ZZ+ZZ
 18646		777777	767777			YY=YY+YY+1
 18647						IFE	ZZ,<ZZ=1>
 18648						IFE	<YY-1>,<YY=-2>
 18649	041053	204 00 0 00 070534 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18650									;AND MOVE RESULT INTO AC
 18651	041054	312 00 0 00 070533 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18652						STOP		^
 18653	041055	254 04 0 00 041056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18654	041056	324 00 0 00 041057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18655									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18656									;IN THE SUBTEST) TO LOOP ON ERROR^
 18657
 18658					;**********
 18659
 18660
 18661					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18662					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18663					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18664					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18665					;THEN, C(AC) IS CHECKED.
 18666					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18667					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18668
 18669			002416		SN=SN+1
 18670			020000			ZZ=ZZ+ZZ
 18671		777777	757777			YY=YY+YY+1
 18672						IFE	ZZ,<ZZ=1>
 18673						IFE	<YY-1>,<YY=-2>
 18674	041057	204 00 0 00 070536 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18675									;AND MOVE RESULT INTO AC
 18676	041060	312 00 0 00 070535 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18677						STOP		^
 18678	041061	254 04 0 00 041062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18679	041062	324 00 0 00 041063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18680									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18681									;IN THE SUBTEST) TO LOOP ON ERROR^
 18682
 18683					;**********
 18684
 18685
 18686					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18687					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18688					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18689					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18690					;THEN, C(AC) IS CHECKED.
 18691					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18692					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18693
 18694			002417		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-7
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18695			040000			ZZ=ZZ+ZZ
 18696		777777	737777			YY=YY+YY+1
 18697						IFE	ZZ,<ZZ=1>
 18698						IFE	<YY-1>,<YY=-2>
 18699	041063	204 00 0 00 070540 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18700									;AND MOVE RESULT INTO AC
 18701	041064	312 00 0 00 070537 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18702						STOP		^
 18703	041065	254 04 0 00 041066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18704	041066	324 00 0 00 041067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18706									;IN THE SUBTEST) TO LOOP ON ERROR^
 18707
 18708					;**********
 18709
 18710
 18711					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18712					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18713					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18714					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18715					;THEN, C(AC) IS CHECKED.
 18716					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18717					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18718
 18719			002420		SN=SN+1
 18720			100000			ZZ=ZZ+ZZ
 18721		777777	677777			YY=YY+YY+1
 18722						IFE	ZZ,<ZZ=1>
 18723						IFE	<YY-1>,<YY=-2>
 18724	041067	204 00 0 00 070542 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18725									;AND MOVE RESULT INTO AC
 18726	041070	312 00 0 00 070541 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18727						STOP		^
 18728	041071	254 04 0 00 041072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18729	041072	324 00 0 00 041073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18731									;IN THE SUBTEST) TO LOOP ON ERROR^
 18732
 18733					;**********
 18734
 18735
 18736					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18737					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18738					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18739					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18740					;THEN, C(AC) IS CHECKED.
 18741					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18742					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18743
 18744			002421		SN=SN+1
 18745			200000			ZZ=ZZ+ZZ
 18746		777777	577777			YY=YY+YY+1
 18747						IFE	ZZ,<ZZ=1>
 18748						IFE	<YY-1>,<YY=-2>
 18749	041073	204 00 0 00 070544 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-8
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVS INSTRUCTION

 18750									;AND MOVE RESULT INTO AC
 18751	041074	312 00 0 00 070543 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18752						STOP		^
 18753	041075	254 04 0 00 041076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18754	041076	324 00 0 00 041077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18755									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18756									;IN THE SUBTEST) TO LOOP ON ERROR^
 18757
 18758					;**********
 18759
 18760
 18761					;THIS TEST VERIFIES THAT MOVS SWAPS LEFT AND RIGHT HALVES OF E AND
 18762					;MOVES IT INTO AC.  IN THIS CASE, A 0 IS RIPPLED THRU THE LEFT HALF OF E
 18763					;AND A 1 IS RIPPLED THRU THE RIGHT HALF
 18764					;OF E [C(E)=YY,,ZZ, WHERE ZZ IS A FLOATING 1 AND YY IS A FLOATING 0].
 18765					;THEN, C(AC) IS CHECKED.
 18766					;THIS TEST IS REPEATED 18 TIMES TO FLOAT A 1 THRU ALL 18 BITS OF
 18767					;THE RIGHT HALF AND A 0 THRU ALL 18 BITS OF THE RIGHT HALF OF E
 18768
 18769			002422		SN=SN+1
 18770			400000			ZZ=ZZ+ZZ
 18771		777777	377777			YY=YY+YY+1
 18772						IFE	ZZ,<ZZ=1>
 18773						IFE	<YY-1>,<YY=-2>
 18774	041077	204 00 0 00 070546 		MOVS	[XWD YY,ZZ]	;*MOVS SHOULD SWAP HALVES OF C(E)
 18775									;AND MOVE RESULT INTO AC
 18776	041100	312 00 0 00 070545 		CAME	[XWD ZZ,YY]	;PASS TEST IF C(AC)=ZZ,,YY
 18777						STOP		^
 18778	041101	254 04 0 00 041102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18779	041102	324 00 0 00 041103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18781									;IN THE SUBTEST) TO LOOP ON ERROR^
 18782
 18783					;**********
 18784
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAXX) INSTRUCTIONS

 18785					SUBTTL	TEST OF COMPARE (CAXX) INSTRUCTIONS
 18786
 18787					;**********
 18788
 18789					;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 18790					;AND ONLY WHEN C(AC)=E
 18791					;IN THIS CASE C(AC)=E=0;  HENCE, CAIE SHOULD SKIP
 18792					;OTHERWISE THE PROGRAM HALTS
 18793
 18794	041103	400 00 0 00 000000 	B2500:	SETZ			;PRELOAD AC TO 0		
 18795	041104	302 00 0 00 000000 		CAIE			;*CAIE SHOULD SKIP BECAUSE C(AC)=E
 18796						STOP^
 18797	041105	254 04 0 00 041106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18798	041106	324 00 0 00 041107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18799									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18800									;IN THE SUBTEST) TO LOOP ON ERROR^
 18801
 18802					;*****     FAILURE ANALYSIS     *****
 18803					;C(AC0)		C(AC1)		FAILING SIGNAL
 18804
 18805					;				SW: PC CHANGE
 18806					;				FC: AD FM ; EN
 18807					;				FC: AD CRY 36
 18808					;				FC: AB PC EN
 18809					;				ET0: COND P: PC CLK EN
 18810
 18811					;**********
 18812
 18813					;THIS TEST VERIFIES THAT CAIE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 18814					;AND ONLY WHEN C(AC)=E
 18815					;IN THIS CASE C(AC)=E=1.  HENCE, CAIE SHOULD SKIP
 18816					;OTHERWISE THE PROGRAM HALTS
 18817
 18818	041107	200 00 0 00 070265 	B2600:	MOVE	[1]		;PRELOAD AC TO 1	
 18819	041110	302 00 0 00 000001 		CAIE	1		;*CAIE SHOULD SKIP BECAUSE C(AC)=E
 18820						STOP^
 18821	041111	254 04 0 00 041112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18822	041112	324 00 0 00 041113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18824									;IN THE SUBTEST) TO LOOP ON ERROR^
 18825
 18826					;*****     FAILURE ANALYSIS     *****
 18827					;C(AC0)		C(AC1)		FAILING SIGNAL
 18828
 18829					;				FC: AD AR - EN
 18830
 18831					;**********
 18832
 18833					;THIS TEST VERIFIES THAT CAME SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 18834					;AND ONLY WHEN C(AC)=C(E)
 18835					;IN THIS CASE C(AC)=C(E)=1;  HENCE, CAME SHOULD SKIP
 18836					;OTHERWISE THE PROGRAM HALTS
 18837
 18838	041113	201 00 0 00 000001 	B2700:	MOVEI	1		;PRELOAD AC TO 1	
 18839	041114	312 00 0 00 070265 		CAME	[1]		;*CAME SHOULD SKIP BECAUSE C(AC)=C(E)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30-1
DFKAA2	MAC	13-Jan-89 10:22		TEST OF COMPARE (CAXX) INSTRUCTIONS

 18840						STOP^
 18841	041115	254 04 0 00 041116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18842	041116	324 00 0 00 041117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18843									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18844									;IN THE SUBTEST) TO LOOP ON ERROR^
 18845
 18846					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 18847					SUBTTL	TEST OF BOOLEAN INSTRUCTIONS
 18848
 18849					;**********
 18850
 18851					;THIS TEST VERIFIES THAT SETCA IGNORES THE ADDRESS FIELD OF THE INSTUCTION WORD.
 18852					;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 18853					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES.
 18854
 18855	041117	201 00 0 00 777777 	B3000:	MOVEI	-1		;PRELOAD AC TO 0,,-1	
 18856	041120	450 00 0 00 070254 		SETCA	[-1]		;*SETCA SHOULD PUT -1,,0 INTO THE AC
 18857	041121	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC)=-1,,0
 18858						STOP^
 18859	041122	254 04 0 00 041123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18860	041123	324 00 0 00 041124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18861									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18862									;IN THE SUBTEST) TO LOOP ON ERROR^
 18863
 18864					;**********
 18865
 18866					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 18867					;RESULT IN THE AC.
 18868					;IN THIS CASE C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 18869					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES
 18870
 18871	041124	201 00 0 00 777777 	B3100:	MOVEI	-1		;PRELOAD AC TO 0,,-1
 18872	041125	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT -1,,0 INTO THE AC
 18873	041126	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
 18874						STOP^
 18875	041127	254 04 0 00 041130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18876	041130	324 00 0 00 041131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18878									;IN THE SUBTEST) TO LOOP ON ERROR^
 18879
 18880					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 32
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 18881					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 18882					;RESULT IN THE AC,
 18883					;IN THIS CASE C(AC)=0,,0  HENCE, THE RESULT IN THE AC SHOULD BE,-1
 18884					;IF THE RESULT IN THE AC IS -1,,-1, THE TEST PASSES
 18885
 18886	041131	201 00 0 00 000000 	B3200:	MOVEI	0		;PRELOAD AC TO 0,,0
 18887	041132	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT -1,,-1 INTO THE AC
 18888	041133	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC) =-1,,-1
 18889						STOP^
 18890	041134	254 04 0 00 041135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18891	041135	324 00 0 00 041136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18893									;IN THE SUBTEST) TO LOOP ON ERROR^
 18894
 18895					;*****     FAILURE ANALYSIS     *****
 18896					;C(AC0)		C(AC1)		FAILING SIGNAL
 18897
 18898					;0				ET2: AR AD EN
 18899
 18900					;**********
 18901
 18902					;THIS TEST VERIFIES THAT SETCA COMPLEMENTS C(AC), THEN PLACES THE
 18903					;RESULT IN THE AC,
 18904					;IN THIS CASE C(AC)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
 18905					;IF THE RESULT IN THE AC IS ZERO, THE TEST PASSES
 18906
 18907	041136	200 00 0 00 070254 	B3300:	MOVE	[-1]		;PRELOAD AC TO -1,,-1	
 18908	041137	450 00 0 00 000000 		SETCA			;*SETCA SHOULD PUT 0,,0 INTO THE AC
 18909	041140	312 00 0 00 070253 		CAME	[0]		;PASS TEST IF C(AC) IS ZERO
 18910						STOP^
 18911	041141	254 04 0 00 041142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18912	041142	324 00 0 00 041143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18913									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18914									;IN THE SUBTEST) TO LOOP ON ERROR^
 18915
 18916					;*****     FAILURE ANALYSIS     *****
 18917					;C(AC0)		C(AC1)		FAILING SIGNAL
 18918
 18919					;-1,,-1				FC: AD FM - EN
 18920
 18921					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 33
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 18922					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 18923					;RESULT IN THE AC.
 18924					;IN THIS CASE AC=E AND C(E)=C(AC)=0,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 18925					;IF THE RESULT IN THE AC IS -1,,0, THE TEST PASSES
 18926
 18927	041143	201 00 0 00 777777 	B3500:	MOVEI	-1		;PRELOAD AC TO 0,,-1
 18928	041144	460 00 0 00 000000 		SETCM			;*SETCM SHOULD PUT -1,,0 INTO THE AC
 18929	041145	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC) =-1,,0
 18930						STOP^
 18931	041146	254 04 0 00 041147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18932	041147	324 00 0 00 041150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18934									;IN THE SUBTEST) TO LOOP ON ERROR^
 18935
 18936					;*****     FAILURE ANALYSIS     *****
 18937					;C(AC0)		C(AC1)		FAILING SIGNAL
 18938
 18939					;-1,,-1				SW: FCE
 18940					;-1,,-1				FC: AD AR - EN
 18941					;0,,-1				ET2: AR AD EN
 18942
 18943					;**********
 18944
 18945					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 18946					;RESULT IN THE AC.
 18947					;IN THIS CASE C(E)=-1,,-1;  HENCE, THE RESULT IN THE AC SHOULD BE 0,,0
 18948					;IF THE RESULT IN THE AC IS ZERO,THE TEST PASSES
 18949
 18950	041150	460 00 0 00 070254 	B3600:	SETCM	[-1]		;*SETCM SHOULD PUT 0 INTO THE AC	
 18951	041151	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC0)=0		
 18952						STOP^
 18953	041152	254 04 0 00 041153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18954	041153	324 00 0 00 041154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18955									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18956									;IN THE SUBTEST) TO LOOP ON ERROR^
 18957
 18958					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 34
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 18959					;THIS TEST VERIFIES THAT SETCM COMPLEMENTS C(E), THEN PLACES THE
 18960					;RESULT IN THE AC.
 18961					;IN THIS CASE C(E)=0,,0;  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
 18962					;IF THE RESULT IN THE AC IS -1,,-1,THE TEST PASSES
 18963
 18964	041154	460 00 0 00 070253 	B3700:	SETCM	[0]		;*SETCM SHOULD PUT -1,,-1 INTO THE AC	
 18965	041155	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1	
 18966						STOP^
 18967	041156	254 04 0 00 041157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18968	041157	324 00 0 00 041160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18970									;IN THE SUBTEST) TO LOOP ON ERROR^
 18971
 18972					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 35
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 18973					;THIS TEST VERIFIES THAT SETO SETS C(AC) TO -1,,-1.  SETO IGNORES
 18974					;THE ADDRESS FIELD OF THE INSTRUCTION WORD.
 18975					;FIRST C(AC) IS SET TO 0,,0; THEN SETO IS EXECUTED.
 18976					;THE AC IS THEN CHECKED FOR ALL ONES.  IF C(AC) IS ALL ONES,
 18977					;THE TEST PASSES
 18978
 18979	041160	201 00 0 00 000000 	B4300:	MOVEI	0		;PRELOAD AC WITH 0,,0
 18980	041161	474 00 0 00 000000 		SETO			;*SETO SHOULD LOAD THE AC WITH -1,,-1
 18981	041162	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 18982						STOP^
 18983	041163	254 04 0 00 041164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 18984	041164	324 00 0 00 041165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 18985									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 18986									;IN THE SUBTEST) TO LOOP ON ERROR^
 18987
 18988					;*****     FAILURE ANALYSIS     *****
 18989					;C(AC0)		C(AC1)		FAILING SIGNAL
 18990
 18991					;0				ET2: AR AD EN
 18992
 18993					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 36
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 18994					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 18995					;INCLUSIVE OR OF C(AC) WITH THE COMPLEMENT OF C(MEMORY).
 18996					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0.
 18997					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 18998					;THE AC IS CHECKED FOR ITS FINAL CONTENTS NON-ZERO.
 18999					;IF C(AC) IS NOT=0, THE TEST PASSES
 19000
 19001	041165	201 00 0 00 000000 	B4400:	MOVEI	0		;PRELOAD AC,E WITH 0
 19002	041166	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 19003	041167	336 00 0 00 000000 		SKIPN			;PASS IF C(AC) IS NON-ZERO
 19004						STOP^
 19005	041170	254 04 0 00 041171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19006	041171	324 00 0 00 041172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19007									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19008									;IN THE SUBTEST) TO LOOP ON ERROR^
 19009
 19010					;**********
 19011
 19012					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 19013					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 19014					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=0
 19015					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 19016					;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
 19017					;IF C(AC0)=-1,,-1, THE TEST PASSES
 19018
 19019	041172	201 00 0 00 000000 	B4500:	MOVEI	0		;PRELOAD AC,E WITH 0
 19020	041173	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 19021	041174	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19022						STOP^
 19023	041175	254 04 0 00 041176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19024	041176	324 00 0 00 041177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19026									;IN THE SUBTEST) TO LOOP ON ERROR^
 19027
 19028					;*****     FAILURE ANALYSIS     *****
 19029					;C(AC0)		C(AC1)		FAILING SIGNAL
 19030
 19031					;0				SW: ET0
 19032					;0				FC: AD AR + EN
 19033					;0				ET2: AR AD EN
 19034
 19035					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 37
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19036					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 19037					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 19038					;IN THIS CASE AC=MEMORY=AC0 AND C(AC)=C(E)=-1,,-1
 19039					;HENCE THE RESULT IN THE AC SHOULD BE ALL ONES.
 19040					;THE AC IS CHECKED FOR ITS FINAL CONTENTS EQUAL TO -1,,-1
 19041					;IF C(AC0)=-1,,-1, THE TEST PASSES
 19042
 19043	041177	200 00 0 00 070254 	B4600:	MOVE	[-1]		;PRELOAD AC,E WITH -1,,-1
 19044	041200	464 00 0 00 000000 		ORCM			;*ORCM SHOULD PUT ALL ONES INTO AC0
 19045	041201	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19046						STOP^
 19047	041202	254 04 0 00 041203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19048	041203	324 00 0 00 041204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19049									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19050									;IN THE SUBTEST) TO LOOP ON ERROR^
 19051
 19052					;*****     FAILURE ANALYSIS     *****
 19053					;C(AC0)		C(AC1)		FAILING SIGNAL
 19054
 19055					;0				FC: AD FM - EN
 19056					;0				ET0: AR AD EN
 19057
 19058					;**********
 19059
 19060					;THIS TEST VERIFIES THAT ORCM CHANGES C(AC) TO THE LOGICAL
 19061					;INCLUSIVE OR OF C(AC) WITH COMPLEMENT OF C(MEMORY).
 19062					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1; HENCE, THE RESULT
 19063					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR ITS INAL CONTENTS=0.
 19064					;IF C(AC)=0, THE TEST PASSES
 19065
 19066	041204	201 00 0 00 000000 	B4700:	MOVEI	0		;PRELOAD AC WITH 0
 19067	041205	464 00 0 00 070254 		ORCM	[-1]		;*ORCM SHOULD PLACE ALL ZEROS INTO THE AC
 19068	041206	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0,,0
 19069						STOP^
 19070	041207	254 04 0 00 041210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19071	041210	324 00 0 00 041211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19072									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19073									;IN THE SUBTEST) TO LOOP ON ERROR^
 19074
 19075					;*****     FAILURE ANALYSIS     *****
 19076					;C(AC0)		C(AC1)		FAILING SIGNAL
 19077
 19078					;-E				SW: FCE
 19079
 19080					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19081					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19082					;INCLUSIVE OR OF C(AC) WITH C(E).
 19083					;IN THIS CASE AC=E AND C(AC)=C(E)=0,,0.  HENCE THE
 19084					;RESULT IN THE AC SHOULD BE 0,,0.
 19085					;THE AC IS CHECKED FOR 0,,0.  IF C(AC)=0,,0, THIS TEST PASSES
 19086
 19087	041211	201 00 0 00 000000 	B5000:	MOVEI	0		;PRELOAD AC,E WITH 0,,0
 19088	041212	434 00 0 00 000000 		IOR			;*IOR SHOULD PUT 0 INTO AC
 19089	041213	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0,,0
 19090						STOP^
 19091	041214	254 04 0 00 041215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19092	041215	324 00 0 00 041216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19093									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19094									;IN THE SUBTEST) TO LOOP ON ERROR^
 19095
 19096					;*****     FAILURE ANALYSIS     *****
 19097					;C(AC0)		C(AC1)		FAILING SIGNAL
 19098
 19099					;-1,,-1				SW: ET0
 19100					;-1,,-1				ET0: AR AD EN
 19101					;-1,,-1				ET0: AD AR - EN
 19102					;-1,,-1				ET2: AR AD EN
 19103
 19104					;**********
 19105
 19106					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19107					;INCLUSIVE OR OF C(AC) WITH C(E).
 19108					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 19109					;RESULT IN THE AC SHOULD BE -1,,-1.
 19110					;THE AC IS CHECKED FOR -1,,-1
 19111					;IF C(AC) =-1,,-1 THE TEST PASSES.
 19112
 19113	041216	201 00 0 00 000000 	B5100:	MOVEI	0		;PRELOAD AC WITH 0
 19114	041217	434 00 0 00 070254 		IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
 19115	041220	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)  =-1,,-1
 19116						STOP^
 19117	041221	254 04 0 00 041222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19118	041222	324 00 0 00 041223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19120									;IN THE SUBTEST) TO LOOP ON ERROR^
 19121
 19122					;*****     FAILURE ANALYSIS     *****
 19123					;C(AC0)		C(AC1)		FAILING SIGNAL
 19124
 19125					;E				SW: FCE
 19126					;0				FC: AD AR - EN
 19127
 19128					;*****     FAILURE ANALYSIS     *****
 19129					;C(AC0)		C(AC1)		FAILING SIGNAL
 19130
 19131					;0				FC: AD FM - EN
 19132
 19133	041223				NB5300:;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19134					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19135					;INCLUSIVE OR OF C(AC) WITH C(E).
 19136					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 19137					;RESULT IN THE AC SHOULD BE -1,,-1
 19138					;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
 19139					;IF C(AC)=-1, THE TEST PASSES
 19140
 19141	041223	474 00 0 00 000000 	B5200:	SETO			;PRELOAD AC WITH -1,,-1
 19142	041224	434 00 0 00 070254 		IOR	[-1]		;*IOR SHOULD PUT -1,,-1 INTO AC
 19143	041225	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 19144						STOP^
 19145	041226	254 04 0 00 041227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19146	041227	324 00 0 00 041230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19147									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19148									;IN THE SUBTEST) TO LOOP ON ERROR^
 19149
 19150					;**********
 19151
 19152					;THIS TEST VERIFIES THAT IOR CHANGES C(AC) TO THE LOGICAL
 19153					;INCLUSIVE OR OF C(AC) WITH C(E).
 19154					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE
 19155					;RESULT IN THE AC SHOULD BE -1,,-1
 19156					;THE AC IS CHECKED FOR ITS CONTENTS = ALL ONES
 19157					;IF C(AC)=-1,,-1, THE TEST PASSES
 19158
 19159	041230	474 00 0 00 000000 	B5300:	SETO			;PRELOAD AC WITH -1,,-1
 19160	041231	434 00 0 00 070253 		IOR	[0]		;*IOR SHOULD PUT -1,,-1 INTO AC
 19161	041232	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 19162						STOP^
 19163	041233	254 04 0 00 041234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19164	041234	324 00 0 00 041235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19165									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19166									;IN THE SUBTEST) TO LOOP ON ERROR^
 19167
 19168					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19169					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19170					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19171					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT 
 19172					;IN THE AC SHOULD BE 0,,-1
 19173					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THE TEST PASSES
 19174
 19175	041235	474 00 0 00 000000 	B5500:	SETO			;PRELOAD AC WITH ALL ONES
 19176	041236	420 00 0 00 070331 		ANDCM	[XWD -1,0]	;*ANDCM SHOULD PLACE 0,,-1 IN THE AC
 19177	041237	312 00 0 00 070330 		CAME	[0,,-1]		;IF C(AC)=0,,-1, THE TEST PASSES
 19178						STOP^
 19179	041240	254 04 0 00 041241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19180	041241	324 00 0 00 041242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19181									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19182									;IN THE SUBTEST) TO LOOP ON ERROR^
 19183
 19184					;*****     FAILURE ANALYSIS     *****
 19185					;C(AC0)		C(AC1)		FAILING SIGNAL
 19186
 19187					;-E				SW: FCE
 19188					;-1,,-1				FC: AD AR - EN
 19189					;-1,,0				ET2: AR AD EN
 19190
 19191					;**********
 19192
 19193					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19194					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19195					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0.  HENCE,
 19196					;THE RESULT IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 19197					;IF C(AC)=0, THE TEST PASSES.
 19198
 19199	041242	474 00 0 00 000000 	B5600:	SETO			;PRELOAD AC WITH ALL ONES
 19200	041243	420 00 0 00 000000 		ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
 19201	041244	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19202						STOP^
 19203	041245	254 04 0 00 041246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19204	041246	324 00 0 00 041247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19206									;IN THE SUBTEST) TO LOOP ON ERROR^
 19207
 19208					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19209					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19210					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19211					;IN THIS CASE C(AC)=-1,,-1, AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19212					;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR -1,,-1.
 19213					;IF C(AC)=-1,,-1, THE TEST PASSES
 19214
 19215	041247	474 00 0 00 000000 	B5700:	SETO			;PRELOAD AC WITH 0		
 19216	041250	420 00 0 00 070253 		ANDCM	[0]		;*ANDCM SHOULD PLACE -1,,-1 IN THE AC
 19217	041251	312 00 0 00 070254 		CAME	[-1]		;IF C(AC)=-1,,-1, THE TEST PASSES
 19218						STOP^
 19219	041252	254 04 0 00 041253 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19220	041253	324 00 0 00 041254 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19221									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19222									;IN THE SUBTEST) TO LOOP ON ERROR^
 19223
 19224					;**********
 19225
 19226					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19227					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19228					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 19229					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 19230					;IF C(AC)=0, THE TEST PASSES
 19231
 19232	041254	201 00 0 00 000000 	B6000:	MOVEI	0		;PRELOAD AC WITH 0	
 19233	041255	420 00 0 00 000000 		ANDCM			;*ANDCM SHOULD PLACE 0 IN THE AC
 19234	041256	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19235						STOP^
 19236	041257	254 04 0 00 041260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19237	041260	324 00 0 00 041261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19238									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19239									;IN THE SUBTEST) TO LOOP ON ERROR^
 19240
 19241					;*****     FAILURE ANALYSIS     *****
 19242					;C(AC0)		C(AC1)		FAILING SIGNAL
 19243
 19244					;-1,,-1				FC: AD FM + EN
 19245
 19246					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19247					;THIS TEST VERIFIES THAT ANDCM CHANGES C(AC) TO THE LOGICAL AND
 19248					;OF C(AC) AND THE COMPLEMENT OF C(MEMORY).
 19249					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1. HENCE, THE RESULT IN THE AC
 19250					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.
 19251					;IF C(AC)=0, THE TEST PASSES
 19252
 19253	041261	400 00 0 00 000000 	B6100:	SETZ			;PRELOAD AC WITH 0	
 19254	041262	420 00 0 00 070254 		ANDCM	[-1]		;*ANDCM SHOULD PLACE 0 IN THE AC	
 19255	041263	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 19256						STOP^
 19257	041264	254 04 0 00 041265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19258	041265	324 00 0 00 041266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19259									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19260									;IN THE SUBTEST) TO LOOP ON ERROR^
 19261
 19262					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19263					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19264					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19265					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19266					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.  IF C(AC) IS
 19267					;EQUAL TO ZERO, THE TEST PASSES.
 19268
 19269	041266	200 00 0 00 070331 	B6200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19270	041267	410 00 0 00 070253 		ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
 19271	041270	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19272						STOP^
 19273	041271	254 04 0 00 041272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19274	041272	324 00 0 00 041273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19276									;IN THE SUBTEST) TO LOOP ON ERROR^
 19277
 19278					;*****     FAILURE ANALYSIS     *****
 19279					;C(AC0)		C(AC1)		FAILING SIGNAL
 19280
 19281					;E				SW: FCE
 19282					;0,,-1				FC: AD AR + EN
 19283
 19284					;**********
 19285
 19286					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19287					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19288					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE
 19289					;RESULT IN THE AC SHOULD BE 0,,707070.  THE AC IS CHECKED
 19290					;FOR 0,,707070.  IF C(AC)=0,,707070, THE TEST PASSES.
 19291
 19292	041273	200 00 0 00 070331 	B6300:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19293	041274	410 00 0 00 070332 		ANDCA	[707070707070]	;*ANDCA SHOULD PLACE 0,,707070 IN THE AC
 19294	041275	312 00 0 00 070547 		CAME	[XWD 0,707070]	;IF C(AC)=0,,707070, THE TEST PASSES
 19295						STOP^
 19296	041276	254 04 0 00 041277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19297	041277	324 00 0 00 041300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19299									;IN THE SUBTEST) TO LOOP ON ERROR^
 19300
 19301					;*****     FAILURE ANALYSIS     *****
 19302					;C(AC0)		C(AC1)		FAILING SIGNAL
 19303
 19304					;707070,,707070			FC: AD FM - EN
 19305					;707070,,707070			ET2: AR AD EN
 19306
 19307					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19308					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19309					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19310					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=0. HENCE, THE RESULT
 19311					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC=0,
 19312					;THE TEST PASSES.
 19313
 19314	041300	400 00 0 00 000000 	B6400:	SETZ			;CLEAR THE AC AND E		
 19315	041301	410 00 0 00 000000 		ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
 19316	041302	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 19317						STOP^
 19318	041303	254 04 0 00 041304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19319	041304	324 00 0 00 041305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19320									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19321									;IN THE SUBTEST) TO LOOP ON ERROR^
 19322
 19323					;**********
 19324
 19325					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19326					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19327					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19328					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR ALL ONES.
 19329					;IF C(AC)=-1,,-1, THE TEST PASSES.
 19330
 19331	041305	400 00 0 00 000000 	B6500:	SETZ			;CLEAR THE AC		
 19332	041306	410 00 0 00 070254 		ANDCA	[-1]		;*ANDCA SHOULD PLACE ALL ONES IN THE AC
 19333	041307	312 00 0 00 070254 		CAME	[-1]		;IF C(AC)=ALL ONES, THE TEST PASSES.
 19334						STOP^
 19335	041310	254 04 0 00 041311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19336	041311	324 00 0 00 041312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19338									;IN THE SUBTEST) TO LOOP ON ERROR^
 19339
 19340					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19341					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19342					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19343					;IN THIS CASE AC=E=AC0 AND C(AC)=C(E)=-1,,-1. HENCE, THE RESULT
 19344					;IN THE AC SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 19345					;THE TEST PASSES.
 19346
 19347	041312	474 00 0 00 000000 	B6600:	SETO			;PRESET AC TO ALL ONES		
 19348	041313	410 00 0 00 000000 		ANDCA			;*ANDCA SHOULD PLACE 0 IN THE AC
 19349	041314	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES
 19350						STOP^
 19351	041315	254 04 0 00 041316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19352	041316	324 00 0 00 041317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19353									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19354									;IN THE SUBTEST) TO LOOP ON ERROR^
 19355
 19356					;**********
 19357
 19358					;THIS TEST VERIFIES THAT ANDCA CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19359					;OF THE COMPLEMENT OF C(AC) AND C(E).
 19360					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19361					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 19362					;THE TEST PASSES.
 19363
 19364	041317	474 00 0 00 000000 	B6700:	SETO			;PRESET AC TO ALL ONES		
 19365	041320	410 00 0 00 070253 		ANDCA	[0]		;*ANDCA SHOULD PLACE 0 IN THE AC
 19366	041321	332 00 0 00 000000 		SKIPE			;IF C(AC)=0, THE TEST PASSES.
 19367						STOP^
 19368	041322	254 04 0 00 041323 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19369	041323	324 00 0 00 041324 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19370									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19371									;IN THE SUBTEST) TO LOOP ON ERROR^
 19372
 19373					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 46
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19374					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19375					;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19376					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0; HENCE, THE RESULT IN THE AC
 19377					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 19378					;THIS TEST PASSES.
 19379
 19380	041324	200 00 0 00 070331 	B7000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19381	041325	440 00 0 00 070253 		ANDCB	[0]		;*ANDCB SHOULD PLACE 0,,-1 IN THE AC
 19382	041326	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 19383						STOP^
 19384	041327	254 04 0 00 041330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19385	041330	324 00 0 00 041331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19386									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19387									;IN THE SUBTEST) TO LOOP ON ERROR^
 19388
 19389					;*****     FAILURE ANALYSIS     *****
 19390					;C(AC0)		C(AC1)		FAILING SIGNAL
 19391
 19392					;0,,-E				SW: FCE
 19393					;-1,,-1				FC: AD FM - EN
 19394					;0				ET2: AR AD EN
 19395
 19396					;**********
 19397
 19398					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION
 19399					;OF THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19400					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,-1; HENCE, THE RESULT IN THE AC
 19401					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0,
 19402					;THIS TEST PASSES.
 19403
 19404	041331	200 00 0 00 070331 	B7100:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19405	041332	440 00 0 00 070254 		ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN AC
 19406	041333	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19407						STOP^
 19408	041334	254 04 0 00 041335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19409	041335	324 00 0 00 041336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19410									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19411									;IN THE SUBTEST) TO LOOP ON ERROR^
 19412
 19413					;*****     FAILURE ANALYSIS     *****
 19414					;C(AC0)		C(AC1)		FAILING SIGNAL
 19415
 19416					;0,,-1				FC: AD AR - EN
 19417
 19418					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 47
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19419
 19420					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19421					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19422					;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 19423					;SHOULD BE ALL ONES.  THE AC IS CHECKED FOR ALL ONES.  IF C(AC)=-1,,-1,
 19424					;THE TEST PASSES.
 19425
 19426	041336	400 00 0 00 000000 	B7200:	SETZ			;PRELOAD AC,E WITH ZEROES
 19427	041337	440 00 0 00 000000 		ANDCB			;*ANDCB SHOULD PLACE ALL ONES IN THE AC
 19428	041340	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC) IS ALL ONES
 19429						STOP^
 19430	041341	254 04 0 00 041342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19431	041342	324 00 0 00 041343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19433									;IN THE SUBTEST) TO LOOP ON ERROR^
 19434
 19435					;**********
 19436
 19437					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19438					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19439					;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE THE RESULT IN THE AC
 19440					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19441
 19442	041343	474 00 0 00 000000 	B7300:	SETO			;PRELOAD AC,E WITH ONES
 19443	041344	440 00 0 00 000000 		ANDCB			;*ANDCB SHOULD PLACE ALL ZEROS IN THE AC
 19444	041345	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19445						STOP^
 19446	041346	254 04 0 00 041347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19447	041347	324 00 0 00 041350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19448									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19449									;IN THE SUBTEST) TO LOOP ON ERROR^
 19450
 19451					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 48
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19452					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19453					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19454					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19455					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19456
 19457	041350	400 00 0 00 000000 	B7400:	SETZ			;PRELOAD AC WITH 0
 19458	041351	440 00 0 00 070254 		ANDCB	[-1]		;*ANDCB SHOULD PLACE 0 IN THE AC
 19459	041352	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19460						STOP^
 19461	041353	254 04 0 00 041354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19462	041354	324 00 0 00 041355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19464									;IN THE SUBTEST) TO LOOP ON ERROR^
 19465
 19466					;**********
 19467
 19468					;THIS TEST VERIFIES THAT ANDCB CHANGES C(AC) TO THE LOGICAL AND FUNCTION OF
 19469					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19470					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19471					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19472
 19473	041355	474 00 0 00 000000 	B7500:	SETO			;PRELOAD AC WITH -1,,-1
 19474	041356	440 00 0 00 070253 		ANDCB	[0]		;*ANDCB SHOULD PLACE 0 IN THE AC
 19475	041357	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19476						STOP^
 19477	041360	254 04 0 00 041361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19478	041361	324 00 0 00 041362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19479									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19480									;IN THE SUBTEST) TO LOOP ON ERROR^
 19481
 19482					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 49
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19483					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19484					;THE COMPLEMENT OF C(AC) AND C(E).
 19485					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19486					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 19487					;THIS TEST FAILS.
 19488
 19489	041362	200 00 0 00 070331 	B7600:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19490	041363	454 00 0 00 070253 		ORCA	[0]		;*ORCA SHOULD PLACE 0,,-1 IN THE AC
 19491	041364	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 19492						STOP^
 19493	041365	254 04 0 00 041366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19494	041366	324 00 0 00 041367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19496									;IN THE SUBTEST) TO LOOP ON ERROR^
 19497
 19498					;*****     FAILURE ANALYSIS     *****
 19499					;C(AC0)		C(AC1)		FAILING SIGNAL
 19500
 19501					;-1,,0				SW: ET0
 19502					;-1,,0				FC: AD AR - EN
 19503					;0				FC: AD FM + EN
 19504					;-1,,-1				ET0: AR AD EN
 19505					;-1,,-1				ET0: AD AR - EN
 19506					;-1,,0				ET2: AR AD EN
 19507
 19508					;**********
 19509
 19510					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19511					;THE COMPLEMENT OF C(AC) AND C(E).
 19512					;IN THIS CASE C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, THE RESULT IN THE AC
 19513					;SHOULD BE 707070,,-1.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 19514					;THIS TEST FAILS.
 19515
 19516	041367	200 00 0 00 070331 	B10000:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 19517	041370	454 00 0 00 070332 		ORCA	[707070707070]	;*ORCA SHOULD PLACE 707070,,-1 IN THE AC
 19518	041371	312 00 0 00 070550 		CAME	[XWD 707070,-1]	;PASS IF C(AC)=707070,,-1
 19519						STOP^
 19520	041372	254 04 0 00 041373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19521	041373	324 00 0 00 041374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19523									;IN THE SUBTEST) TO LOOP ON ERROR^
 19524
 19525					;*****     FAILURE ANALYSIS     *****
 19526					;C(AC0)		C(AC1)		FAILING SIGNAL
 19527
 19528					;0,,-1				SW: FCE
 19529
 19530					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 50
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19531					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19532					;THE COMPLEMENT OF C(AC) AND C(E).
 19533					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 19534					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 19535
 19536	041374	400 00 0 00 000000 	B10100:	SETZ			;PRELOAD AC,E WITH 0
 19537	041375	454 00 0 00 000000 		ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 19538	041376	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19539						STOP^
 19540	041377	254 04 0 00 041400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19541	041400	324 00 0 00 041401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19543									;IN THE SUBTEST) TO LOOP ON ERROR^
 19544
 19545					;**********
 19546
 19547					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OF FUNCTION OF
 19548					;THE COMPLEMENT OF C(AC) AND C(E).
 19549					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19550					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 19551
 19552	041401	474 00 0 00 000000 	B10200:	SETO			;PRELOAD AC,E WITH 0
 19553	041402	454 00 0 00 000000 		ORCA			;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 19554	041403	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19555						STOP^
 19556	041404	254 04 0 00 041405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19557	041405	324 00 0 00 041406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19558									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19559									;IN THE SUBTEST) TO LOOP ON ERROR^
 19560
 19561					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 51
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19562					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19563					;THE COMPLEMENT OF C(AC) AND C(E).
 19564					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESUTL IN THE AC
 19565					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 19566
 19567	041406	400 00 0 00 000000 	B10300:	SETZ			;PRELOAD AC WITH 0
 19568	041407	454 00 0 00 070254 		ORCA	[-1]		;*ORCA SHOULD PLACE -1,,-1 IN THE AC
 19569	041410	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19570						STOP^
 19571	041411	254 04 0 00 041412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19572	041412	324 00 0 00 041413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19573									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19574									;IN THE SUBTEST) TO LOOP ON ERROR^
 19575
 19576					;**********
 19577
 19578					;THIS TEST VERIFIES THAT ORCA CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19579					;THE COMPLEMENT OF C(AC) AND C(E).
 19580					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19581					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 19582
 19583	041413	474 00 0 00 000000 	B10400:	SETO			;PRELOAD AC WITH -1,,-1
 19584	041414	454 00 0 00 070253 		ORCA	[0]		;*ORCA SHOULD PLACE 0 IN THE AC
 19585	041415	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19586						STOP^
 19587	041416	254 04 0 00 041417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19588	041417	324 00 0 00 041420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19589									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19590									;IN THE SUBTEST) TO LOOP ON ERROR^
 19591
 19592					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 52
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19593					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19594					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 19595					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE THE RESULT
 19596					;IN THE AC 070707,,-1.  THE AC IS CHECKED FOR 070707,,-1.  IF C(AC)=070707,,-1,
 19597					;THIS TEST PASSES
 19598
 19599	041420	200 00 0 00 070331 	B10500:	MOVE	[XWD -1,0]	;PRELOAD THE AC WITH -1,,0
 19600	041421	470 00 0 00 070332 		ORCB	[707070707070]	;*ORCB SHOULD PLACE 070707,,-1 IN THE AC
 19601	041422	312 00 0 00 070551 		CAME	[XWD 070707,-1]	;PASS IF C(AC)=070707,,-1
 19602						STOP^
 19603	041423	254 04 0 00 041424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19604	041424	324 00 0 00 041425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19605									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19606									;IN THE SUBTEST) TO LOOP ON ERROR^
 19607
 19608					;*****     FAILURE ANALYSIS     *****
 19609					;C(AC0)		C(AC1)		FAILING SIGNAL
 19610
 19611					;-1,,-1				SW: FCE
 19612					;707070,,0			SW: ET0
 19613					;0,,-1				FC: AD AR + EN
 19614					;070707,,070707			FC: AD FM + EN
 19615					;070707,,070707			ET0: AR AD EN
 19616					;-1,,-1				ET0: AD AR - EN
 19617					;707070,,0			ET2: AR AD EN
 19618
 19619					;**********
 19620
 19621					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19622					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 19623					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE THE RESULT
 19624					;IN THE AC -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 19625					;THIS TEST PASSES
 19626
 19627	041425	200 00 0 00 070330 	B10700:	MOVE	[XWD 0,-1]	;PRELOAD THE AC WITH 0,,-1
 19628	041426	470 00 0 00 070254 		ORCB	[-1]		;*ORCB SHOULD PLACE -1,,0 IN THE AC
 19629	041427	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 19630						STOP^
 19631	041430	254 04 0 00 041431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19632	041431	324 00 0 00 041432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19633									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19634									;IN THE SUBTEST) TO LOOP ON ERROR^
 19635
 19636					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 53
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19637					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19638					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19639					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19640					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)-1,,-1, THE TEST PASSES
 19641
 19642	041432	400 00 0 00 000000 	B11000:	SETZ			;PRELOAD AC WITH 0		
 19643	041433	470 00 0 00 070253 		ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 19644	041434	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19645						STOP^
 19646	041435	254 04 0 00 041436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19647	041436	324 00 0 00 041437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19648									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19649									;IN THE SUBTEST) TO LOOP ON ERROR^
 19650
 19651					;**********
 19652
 19653					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19654					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19655					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19656					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES
 19657
 19658	041437	474 00 0 00 000000 	B11100:	SETO			;PRELOAD AC WITH -1,,-1
 19659	041440	470 00 0 00 070254 		ORCB	[-1]		;*ORCB SHOULD PLACE 0 IN THE AC
 19660	041441	302 00 0 00 000000 		CAIE			;PASS IF C(AC)=0
 19661						STOP^
 19662	041442	254 04 0 00 041443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19663	041443	324 00 0 00 041444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19664									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19665									;IN THE SUBTEST) TO LOOP ON ERROR^
 19666
 19667					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 54
DFKAA2	MAC	13-Jan-89 10:22		TEST OF BOOLEAN INSTRUCTIONS

 19668					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19669					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E)
 19670					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 19671					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES
 19672
 19673	041444	400 00 0 00 000000 	B11200:	SETZ			;PRELOAD AC WITH 0		
 19674	041445	470 00 0 00 070254 		ORCB	[-1]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 19675	041446	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19676						STOP^
 19677	041447	254 04 0 00 041450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19678	041450	324 00 0 00 041451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19680									;IN THE SUBTEST) TO LOOP ON ERROR^
 19681
 19682					;**********
 19683
 19684					;THIS TEST VERIFIES THAT ORCB CHANGES C(AC) TO THE LOGICAL OR FUNCTION OF
 19685					;THE COMPLEMENT OF C(AC) AND THE COMPLEMENT OF C(E).
 19686					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 19687					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES
 19688
 19689	041451	474 00 0 00 000000 	B11300:	SETO			;PRELOAD AC WITH -1,,-1		
 19690	041452	470 00 0 00 070253 		ORCB	[0]		;*ORCB SHOULD PLACE -1,,-1 IN THE AC
 19691	041453	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 19692						STOP^
 19693	041454	254 04 0 00 041455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19694	041455	324 00 0 00 041456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19695									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19696									;IN THE SUBTEST) TO LOOP ON ERROR^
 19697
 19698					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 55
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVN INSTRUCTION

 19699					SUBTTL	TEST OF MOVN INSTRUCTION
 19700
 19701					;**********
 19702
 19703					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
 19704					;IN THIS CASE C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19705					;THE AC IS CHECKED FOR 0, THE NEGATIVE OF 0.  IF C(AC)=0, THIS TEST PASSES
 19706
 19707	041456	474 00 0 00 000000 	B11500:	SETO			;PRELOAD AC WITH -1,,-1		
 19708	041457	210 00 0 00 070253 		MOVN	[0]		;*MOVN SHOULD PLACE 0 INTO THE AC
 19709	041460	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19710						STOP^
 19711	041461	254 04 0 00 041462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19712	041462	324 00 0 00 041463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19713									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19714									;IN THE SUBTEST) TO LOOP ON ERROR^
 19715
 19716					;*****     FAILURE ANALYSIS     *****
 19717					;C(AC0)		C(AC1)		FAILING SIGNAL
 19718
 19719					;E				SW: FCE
 19720					;-1,,-1				FC: AD FM + EN
 19721					;-1,,-1				FC: AD CRY 36
 19722
 19723					;**********
 19724
 19725					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
 19726					;IN THIS CASE C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE 1,,0
 19727					;THE AC IS CHECKED FOR 1,,0.  IF C(AC)=1,,0, THE TEST PASSES
 19728
 19729	041463	200 00 0 00 070331 	B11600:	MOVE	[XWD -1,0]	;PRELOAD AC,E WITH -1,,0
 19730	041464	210 00 0 00 000000 		MOVN			;*MOVN SHOULD PLACE 1,,0 INTO THE AC
 19731	041465	312 00 0 00 070307 		CAME	[XWD 1,0]	;PASS IF C(AC)=1,,0
 19732						STOP^
 19733	041466	254 04 0 00 041467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19734	041467	324 00 0 00 041470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19735									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19736									;IN THE SUBTEST) TO LOOP ON ERROR^
 19737
 19738					;*****     FAILURE ANALYSIS     *****
 19739					;C(AC0)		C(AC1)		FAILING SIGNAL
 19740
 19741					;0				FC: AD ADD
 19742					;0				FC: AD FM - EN
 19743					;0				FC: AD AR - EN
 19744					;-1,,0				ET2: AR AD EN
 19745
 19746					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 56
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVN INSTRUCTION

 19747					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC.
 19748					;IN THIS CASE C(E) =707070,,707070.  HENCE, THE RESULT IN THE AC SHOULD BE
 19749					;070707,,070710.  THE AC IS CHECKED FOR 070707,,070710.  IF C(AC)=
 19750					;070707,,070710, THE TEST PASSES
 19751
 19752	041470	400 00 0 00 000000 	B11700:	SETZ			;PRELOAD AC WITH 0		
 19753	041471	210 00 0 00 070332 		MOVN	[707070707070]	;*MOVN SHOULD PLACE 070707,,070710 INTO THE AC
 19754	041472	312 00 0 00 070552 		CAME	[070707070710]	;PASS IF C(AC) 070707,,070710
 19755						STOP^
 19756	041473	254 04 0 00 041474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19757	041474	324 00 0 00 041475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19758									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19759									;IN THE SUBTEST) TO LOOP ON ERROR^
 19760
 19761					;**********
 19762
 19763					;THIS TEST VERIFIES THAT MOVN PLACES THE NEGATIVE OF C(E) INTO THE AC
 19764					;IN THIS CASE C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
 19765					;THE AC IS CHECKED FOR 0,,1, THE NEGATIVE OF -1,,-1.  IF C(AC)=1, THIS TEST PASSES
 19766
 19767	041475	210 00 0 00 070254 	B12100:	MOVN	[-1]		;*MOVN SHOULD PLACE 0,,1 INTO THE AC	
 19768	041476	302 00 0 00 000001 		CAIE	1		;PASS OF C(AC)=0,,1
 19769						STOP^
 19770	041477	254 04 0 00 041500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19771	041500	324 00 0 00 041501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19773									;IN THE SUBTEST) TO LOOP ON ERROR^
 19774
 19775					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVM INSTRUCTION

 19776					SUBTTL	TEST OF MOVM INSTRUCTION
 19777
 19778					;**********
 19779
 19780					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC.
 19781					;IN THIS CASE, C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19782					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 19783
 19784	041501	474 00 0 00 000000 	B12200:	SETO			;PRELOAD AC WITH -1,,-1		
 19785	041502	214 00 0 00 070253 		MOVM	[0]		;*MOVM SHOULD PLACE 0 INTO THE AC	
 19786	041503	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 19787						STOP^
 19788	041504	254 04 0 00 041505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19789	041505	324 00 0 00 041506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19790									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19791									;IN THE SUBTEST) TO LOOP ON ERROR^
 19792
 19793					;*****     FAILURE ANALYSIS     *****
 19794					;C(AC0)		C(AC1)		FAILING SIGNAL
 19795
 19796					;E				SW: FCE
 19797
 19798					;**********
 19799
 19800					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 19801					;IN THIS CASE, C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0,,1.
 19802					;THE AC IS CHECKED FOR 0,,1.  IF C(AC)=0,,1, THIS TEST PASSES
 19803
 19804	041506	400 00 0 00 000000 	B12300:	SETZ			;PRELOAD AC WITH 0		
 19805	041507	214 00 0 00 070254 		MOVM	[-1]		;*MOVM SHOULD PLACE 0,,1 INTO THE AC
 19806	041510	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=0,,1
 19807						STOP^
 19808	041511	254 04 0 00 041512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19809	041512	324 00 0 00 041513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19811									;IN THE SUBTEST) TO LOOP ON ERROR^
 19812
 19813					;*****     FAILURE ANALYSIS     *****
 19814					;C(AC0)		C(AC1)		FAILING SIGNAL
 19815
 19816					;0				FC: AD FM + EN
 19817					;0				FC: AD ADD
 19818					;0				FC: AD CRY 36
 19819					;0				FC: AD AR - EN
 19820					;-1,,-1				ET2: AR AD EN
 19821
 19822					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 58
DFKAA2	MAC	13-Jan-89 10:22		TEST OF MOVM INSTRUCTION

 19823					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 19824					;IN THIS CASE, C(E)=400000,,0.  HENCE, THE RESULT IN THE AC SHOULD BE
 19825					;400000,,0.  THE AC IS CHECKED FOR 400000,,0.
 19826					;IF C(AC)=400000,,0, THIS TEST PASSES.
 19827
 19828	041513	400 00 0 00 000000 	B12400:	SETZ
 19829	041514	214 00 0 00 070256 		MOVM	[XWD 400000,0]	;*MOVM SHOULD PLACE 400000,,0 INTO THE AC
 19830	041515	312 00 0 00 070256 		CAME	[XWD 400000,0]	;PASS IF C(AC)=400000,,0
 19831						STOP^
 19832	041516	254 04 0 00 041517 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19833	041517	324 00 0 00 041520 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19835									;IN THE SUBTEST) TO LOOP ON ERROR^
 19836
 19837					;**********
 19838
 19839					;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
 19840					;IN THIS CASE, C(E)=377777,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE
 19841					;377777,,-1.  THE AC IS CHECKED FOR 377777,,-1.
 19842					;IF C(AC)=377777,,-1, THIS TEST PASSES.
 19843
 19844	041520	400 00 0 00 000000 	B12500:	SETZ			;PRELOAD AC WITH 0
 19845	041521	214 00 0 00 070255 		MOVM	[XWD 377777,-1]	;*MOVM SHOULD PLACE 377777,,-1 INTO THE AC
 19846	041522	312 00 0 00 070255 		CAME	[XWD 377777,-1]	;PASS IF C(AC)=377777,,-1
 19847						STOP^
 19848	041523	254 04 0 00 041524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19849	041524	324 00 0 00 041525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19851									;IN THE SUBTEST) TO LOOP ON ERROR^
 19852
 19853					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 19854					SUBTTL	TEST OF LOGICAL TEST INSTRUCTIONS
 19855
 19856					;**********
 19857
 19858					;THIS TEST VERIFIES THAT TDN DOES NOT MODIFY THE AC BECAUSE
 19859					;TDN IS A NO-OP
 19860					;FIRST, THE AC IS PRELOADED WITH 0.  THEN,
 19861					;TDN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19862					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THE TEST PASSES
 19863	041525	400 00 0 00 000000 	B12600:	SETZ			;PRELOAD AC WITH 0
 19864	041526	610 00 0 00 070254 		TDN	[-1]		;*TDN IS A NO-OP
 19865	041527	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TDN SKIPS
 19866	041530	302 00 0 00 000000 		CAIE			;PASS TEST IF C(AC) IS UNMODIFIED BY TDN
 19867						STOP^
 19868	041531	254 04 0 00 041532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19869	041532	324 00 0 00 041533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19871									;IN THE SUBTEST) TO LOOP ON ERROR^
 19872
 19873					;*****     FAILURE ANALYSIS     *****
 19874					;C(AC0)		C(AC1)		FAILING SIGNAL
 19875
 19876					;-1,,-1				FC: AD FM + EN
 19877
 19878					;**********
 19879
 19880					;THIS TEST VERIFIES THAT TSN DOES NOT MODIFY THE AC BECAUSE
 19881					;TSN IS A NO-OP
 19882					;FIRST, THE AC IS PRELOADED WITH -1.  THEN,
 19883					;TSN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19884					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THIS TEST PASSES
 19885
 19886	041533	474 00 0 00 000000 	B12700:	SETO			;PRELOAD AC WITH -1,,-1
 19887	041534	611 00 0 00 070331 		TSN	[XWD -1,0]	;*TSN IS A NO-OP
 19888	041535	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TSN SKIPS
 19889	041536	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC) IS UNMODIFIED BY TSN
 19890						STOP^
 19891	041537	254 04 0 00 041540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19892	041540	324 00 0 00 041541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19894									;IN THE SUBTEST) TO LOOP ON ERROR^
 19895
 19896					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 19897					;THIS TEST VERIFIES THAT TRN DOE NOT MODIFY THE AC BECAUSE
 19898					;TRN IS A NO-OP.
 19899					;FIRST, THE AC IS PRELOADED WITH 0.  THEN,
 19900					;TRN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19901					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THIS TEST PASSES
 19902
 19903	041541	400 00 0 00 000000 	B13000:	SETZ			;PRELOAD AC WITH 0
 19904	041542	600 00 0 00 123456 		TRN	123456		;*TRN IS A NO-OP
 19905	041543	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TRN SKIPS
 19906	041544	302 00 0 00 000000 		CAIE			;PASS TEST IF C(AC) IS UNMODIFIED BY TRN
 19907						STOP^
 19908	041545	254 04 0 00 041546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19909	041546	324 00 0 00 041547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19911									;IN THE SUBTEST) TO LOOP ON ERROR^
 19912
 19913					;**********
 19914
 19915					;THIS TEST VERIFIES THAT TLN DOES NOT MODIFY THE AC BECAUSE
 19916					;TLN IS A NO-OP.
 19917					;FIRST,THE AC IS PRELOADED WITH -1,,-1.  THEN,
 19918					;TRN IS EXECUTED.  THE AC IS THEN CHECKED FOR
 19919					;NO MODIFICATION.  IF C(AC) IS UNALTERED, THIS TEST PASSES
 19920
 19921	041547	474 00 0 00 000000 	B13100:	SETO			;PRELOAD AC WITH -1,,-1
 19922	041550	601 00 0 00 123456 		TLN	123456		;*TRN IS A NO-OP
 19923	041551	310 00 0 00 000000 		CAM			;CAM IS A NO-OP.  IT IS HERE IN CASE TRN SKIPS
 19924	041552	312 00 0 00 000000 		CAME			;PASS TEST IF C(AC) IS UNMODIFIED BY TRN
 19925						STOP^
 19926	041553	254 04 0 00 041554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19927	041554	324 00 0 00 041555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19928									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19929									;IN THE SUBTEST) TO LOOP ON ERROR^
 19930
 19931					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 19932					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 19933					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19934					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 19935					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC) -1,,-1, THE TEST PASSES.
 19936
 19937	041555	400 00 0 00 000000 	B13200:	SETZ			;PRELOAD AC WITH 0
 19938	041556	670 00 0 00 070254 		TDO	[-1]		;*TDO SHOULD PLACE ALL ONES IN THE AC
 19939	041557	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 19940	041560	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 19941						STOP^
 19942	041561	254 04 0 00 041562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19943	041562	324 00 0 00 041563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19945									;IN THE SUBTEST) TO LOOP ON ERROR^
 19946
 19947					;*****     FAILURE ANALYSIS     *****
 19948					;C(AC0)		C(AC1)		FAILING SIGNAL
 19949
 19950					;E				SW: FCE
 19951					;0				SW: ET1
 19952					;0				ET1: BR AR EN
 19953					;0				ET1: AD BR - EN
 19954					;0				ET1: AD EQV
 19955
 19956					;**********
 19957
 19958					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 19959					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19960					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19961					;THIS AC IS CHECKED FOR ZERO.  IF C(AC) IS ZERO, THE TEST PASSES.
 19962
 19963	041563	400 00 0 00 000000 	B13300:	SETZ			;PRELOAD AC WITH 0
 19964	041564	670 00 0 00 000000 		TDO			;*TDO SHOULD PLACE ALL ZERO IN THE AC		
 19965	041565	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 19966	041566	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) ZERO
 19967						STOP^
 19968	041567	254 04 0 00 041570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19969	041570	324 00 0 00 041571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19970									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19971									;IN THE SUBTEST) TO LOOP ON ERROR^
 19972
 19973					;*****     FAILURE ANALYSIS     *****
 19974					;C(AC0)		C(AC1)		FAILING SIGNAL
 19975
 19976					;-1,,-1				ET1: AD AR + EN
 19977
 19978					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 19979					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC,
 19980					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19981					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 19982					;THE AC IS CHECKED FOR ITS CONTENTS ZERO.  IF C(AC) IS ZERO, THE TEST PASSES.
 19983
 19984	041571	400 00 0 00 000000 	B13400:	SETZ			;PRELOAD AC WITH 0
 19985	041572	670 00 0 00 070253 		TDO	[0]		;*TDO SHOULD PLACE ALL ZERO IN THE AC
 19986	041573	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 19987	041574	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC) IS ZERO
 19988						STOP^
 19989	041575	254 04 0 00 041576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 19990	041576	324 00 0 00 041577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 19991									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 19992									;IN THE SUBTEST) TO LOOP ON ERROR^
 19993
 19994					;**********
 19995
 19996					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 19997					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 19998					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.
 19999					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20000					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 20001
 20002	041577	474 00 0 00 000000 	B13600:	SETO			;PRELOAD AC WITH -1,,-1
 20003	041600	670 00 0 00 000000 		TDO			;*TDO SHOULD PLACE ALL ONES IN THE AC
 20004	041601	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 20005	041602	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC) -1,,-1
 20006						STOP^
 20007	041603	254 04 0 00 041604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20008	041604	324 00 0 00 041605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20009									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20010									;IN THE SUBTEST) TO LOOP ON ERROR^
 20011
 20012					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20013					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 20014					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20015					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20016					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 20017
 20018	041605	474 00 0 00 000000 	B14000:	SETO			;PRELOAD AC WITH -1,,-1
 20019	041606	670 00 0 00 070253 		TDO	[0]		;*TDO SHOULD PLACE ALL ONES IN THE AC
 20020	041607	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO SKIPS
 20021	041610	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20022						STOP^
 20023	041611	254 04 0 00 041612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20024	041612	324 00 0 00 041613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20025									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20026									;IN THE SUBTEST) TO LOOP ON ERROR^
 20027
 20028					;*****     FAILURE ANALYSIS     *****
 20029					;C(AC0)		C(AC1)		FAILING SIGNAL
 20030
 20031					;0				ET1: AD FM - EN
 20032					;0				ET2: AR AD EN
 20033
 20034					;**********
 20035
 20036					;THIS TEST VERIFIES THAT TDZ PLACES ZERO IN THE BITS OF THE AC
 20037					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20038					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20039					;THE AC IS CHECKED FOR 0.  IF C(AC) 0, THE TEST PASSES.
 20040
 20041	041613	400 00 0 00 000000 	B14100:	SETZ			;PRELOAD AC WITH 0		
 20042	041614	630 00 0 00 000000 		TDZ			;*TDZ SHOULD PLACE ALL ZERO IN THE AC
 20043	041615	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20044	041616	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20045						STOP^
 20046	041617	254 04 0 00 041620 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20047	041620	324 00 0 00 041621 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20048									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20049									;IN THE SUBTEST) TO LOOP ON ERROR^
 20050
 20051					;*****     FAILURE ANALYSIS     *****
 20052					;C(AC0)		C(AC1)		FAILING SIGNAL
 20053
 20054					;-1,,-1				FC: AD FM + EN
 20055
 20056					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20057					;THIS TEST VERIFIES THAT TDZ PLACES ZERO IN THE BITS OF THE AC
 20058					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20059					;IN THIS CASE, C(AC)=-1,,-1,,-1 AND C(E)=-1,,0.
 20060					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,-1.
 20061					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)= 0,,-1, THE TEST PASSES.
 20062
 20063	041621	474 00 0 00 000000 	B14200:	SETO			;PRELOAD AC WITH -1,,-1		
 20064	041622	630 00 0 00 070331 		TDZ	[XWD -1,0]	;*TDZ SHOULD PLACE 0,,-1 IN THE AC
 20065	041623	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20066	041624	312 00 0 00 070330 		CAME	[0,-1]		;PASS TEST IF C(AC)=0,,-1
 20067						STOP^
 20068	041625	254 04 0 00 041626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20069	041626	324 00 0 00 041627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20070									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20071									;IN THE SUBTEST) TO LOOP ON ERROR^
 20072
 20073					;*****     FAILURE ANALYSIS     *****
 20074					;C(AC0)		C(AC1)		FAILING SIGNAL
 20075
 20076					;-E				SW: FCE
 20077					;-1,,-1				FC: AD AR -EN
 20078					;-1,,0				ET2: AR AD EN
 20079
 20080					;**********
 20081
 20082					;THIS TEST VERIFIES THAT TDZ PLACES ZEROS IN THE BITS OF THE AC
 20083					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20084					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20085					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 20086
 20087	041627	474 00 0 00 000000 	B14400:	SETO			;PRELOAD AC WITH -1,,-1
 20088	041630	630 00 0 00 000000 		TDZ			;*TDZ SHOULD PLACE ALL ZERO IN THE AC
 20089	041631	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20090	041632	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20091						STOP^
 20092	041633	254 04 0 00 041634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20093	041634	324 00 0 00 041635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20095									;IN THE SUBTEST) TO LOOP ON ERROR^
 20096
 20097					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20098					;THIS TEST VERIFIES THAT TDZ PLACES ZEROS IN THE BITS OF THE AC
 20099					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20100					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20101					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES.
 20102
 20103	041635	400 00 0 00 000000 	B14500:	SETZ			;PRELOAD AC WITH 0
 20104	041636	630 00 0 00 070254 		TDZ	[-1]		;*TDZ SHOULD PLACE ALL ZEROS IN THE AC
 20105	041637	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20106	041640	332 00 0 00 000000 		SKIPE			;PASS TEST IS C(AC)=0
 20107						STOP^
 20108	041641	254 04 0 00 041642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20109	041642	324 00 0 00 041643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20110									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20111									;IN THE SUBTEST) TO LOOP ON ERROR^
 20112
 20113					;**********
 20114
 20115					;THIS TEST VERIFIES THAT TDZ PLACES ZEROS IN THE BITS OF THE AC
 20116					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20117					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.
 20118					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20119					;THE AC IS CHECKED -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 20120
 20121	041643	474 00 0 00 000000 	B14600:	SETO			;PRELOAD AC WITH -1,,-1
 20122	041644	630 00 0 00 070253 		TDZ	[0]		;*TDZ SHOULD PLACE ALL ONES IN THE AC
 20123	041645	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDO
 20124	041646	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20125						STOP^
 20126	041647	254 04 0 00 041650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20127	041650	324 00 0 00 041651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20129									;IN THE SUBTEST) TO LOOP ON ERROR^
 20130					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20131					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20132					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20133					;IN THIS CASE, C(AC)=-1 AND C(E)=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0.
 20134					;THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 20135
 20136	041651	474 00 0 00 000000 	B14700:	SETO			;PRELOAD AC WITH -1,,-1
 20137	041652	650 00 0 00 070330 		TDC	[XWD 0,-1]	;*TDC SHOULD PLACE -1,,0 INTO THE AC
 20138	041653	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20139	041654	312 00 0 00 070331 		CAME	[-1,,0]		;PASS TEST IF C(AC)=-1,,0
 20140						STOP^
 20141	041655	254 04 0 00 041656 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20142	041656	324 00 0 00 041657 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20144									;IN THE SUBTEST) TO LOOP ON ERROR^
 20145
 20146					;*****     FAILURE ANALYSIS     *****
 20147					;C(AC0)		C(AC1)		FAILING SIGNAL
 20148
 20149					;-E				SW: FCE
 20150					;0				FC: AD AR - EN
 20151					;0,,-1				ET2: AR AD EN
 20152
 20153					;**********
 20154
 20155					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20156					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20157					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20158					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20159
 20160	041657	400 00 0 00 000000 	B15000:	SETZ			;PRELOAD AC, E WITH 0
 20161	041660	650 00 0 00 000000 		TDC			;*TDC SHOULD PLACE 0 INTO THE AC
 20162	041661	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20163	041662	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20164						STOP^
 20165	041663	254 04 0 00 041664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20166	041664	324 00 0 00 041665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20168									;IN THE SUBTEST) TO LOOP ON ERROR^
 20169
 20170					;*****     FAILURE ANALYSIS     *****
 20171					;C(AC0)		C(AC1)		FAILING SIGNAL
 20172
 20173					;-1,,-1				FC:AD FM + EN
 20174
 20175					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20176					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20177					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20178					;IN THIS CASE, AC=E AND C(AC)= C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 20179					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST FAILS
 20180
 20181	041665	474 00 0 00 000000 	B15400:	SETO			;PRELOAD AC WITH -1,,-1		
 20182	041666	650 00 0 00 000000 		TDC			;*TDC SHOULD PLACE 0 INTO THE AC
 20183	041667	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20184	041670	332 00 0 00 000000 		SKIPE			;PASS TEST IF C(AC)=0
 20185						STOP^
 20186	041671	254 04 0 00 041672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20187	041672	324 00 0 00 041673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20188									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20189									;IN THE SUBTEST) TO LOOP ON ERROR^
 20190
 20191					;**********
 20192
 20193					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20194					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20195					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20196					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 20197
 20198	041673	400 00 0 00 000000 	B15500:	SETZ			;PRELOAD AC WITH 0		
 20199	041674	650 00 0 00 070254 		TDC	[-1]		;*TDC SHOULD PLACE -1,,-1 INTO THE AC
 20200	041675	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20201	041676	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20202						STOP^
 20203	041677	254 04 0 00 041700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20204	041700	324 00 0 00 041701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20206									;IN THE SUBTEST) TO LOOP ON ERROR^
 20207
 20208					;*****     FAILURE ANALYSIS     *****
 20209					;C(AC0)		C(AC1)		FAILING SIGNAL
 20210
 20211					;0				FC: AD EQV
 20212
 20213					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20214					;THIS TEST VERIFIES THAT TDC COMPLEMENTS THE BITS OF THE AC
 20215					;WHICH ARE MASKED BY C(E) AND DOES NOT AFFECT THE UNMASKED BITS OF THE AC.
 20216					;IN THIS CASE, C(AC)=-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 20217					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 20218
 20219	041701	474 00 0 00 000000 	B15600:	SETO			;PRELOAD AC WITH -1,,-1		
 20220	041702	650 00 0 00 070253 		TDC	[0]		;*TDC SHOULD PLACE -1,,-1 INTO THE AC
 20221	041703	300 00 0 00 000000 		CAI			;CAI IS A NO-OP.  IT IS HERE IN CASE TDC SKIPS
 20222	041704	312 00 0 00 070254 		CAME	[-1]		;PASS TEST IF C(AC)=-1,,-1
 20223						STOP^
 20224	041705	254 04 0 00 041706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20225	041706	324 00 0 00 041707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20226									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20227									;IN THE SUBTEST) TO LOOP ON ERROR^
 20228
 20229					;**********
 20230
 20231					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT
 20232					;SEQUENTIAL INSTRUCTION.  IF TDNA DOES NOT
 20233					;SKIP, THIS TEST FAILS.
 20234
 20235	041707	400 00 0 00 000000 	B15700:	SETZ			;PRESET AC, E TO 0		
 20236	041710	614 00 0 00 000000 		TDNA			;*TDNA SHOULD SKIP THE NEXT INSTRUCTION
 20237						STOP^
 20238	041711	254 04 0 00 041712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20239	041712	324 00 0 00 041713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20240									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20241									;IN THE SUBTEST) TO LOOP ON ERROR^
 20242
 20243					;*****     FAILURE ANALYSIS     *****
 20244					;C(AC0)		C(AC1)		FAILING SIGNAL
 20245
 20246					;0				SW: ET1
 20247					;0				FC: AB PC EN
 20248					;0				ET1: BR AR EN
 20249					;0				ET1: PC CLOCK
 20250					;0				ET2: MC INST FETCH EN
 20251
 20252					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20253					;THIS TEST VERIFIES THAT TDN NEVER SKIPS
 20254					;NEXT SEQUENTIAL INSTRUCTION.
 20255					;THIS TEST FAILS IF TDN SKIPS.
 20256
 20257	041713	474 00 0 00 000000 	B16000:	SETO			;PRESET AC, E TO -1,,-1		
 20258	041714	610 00 0 00 000000 		TDN			;*TDN SHOULD NOT SKIP
 20259	041715	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20260						STOP^
 20261	041716	254 04 0 00 041717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20262	041717	324 00 0 00 041720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20263									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20264									;IN THE SUBTEST) TO LOOP ON ERROR^
 20265
 20266					;**********
 20267
 20268					;THIS TEST VERIFIES THAT TDN NEVER SKIPS THE
 20269					;NEXT SEQUENTIAL INSTRUCTION.
 20270					;THIS TEST FAILS IF TDN SKIPS.
 20271
 20272	041720	400 00 0 00 000000 	B16100:	SETZ			;PRESET AC, E TO 0		
 20273	041721	610 00 0 00 000000 		TDN			;*TDN SHOULD NOT SKIP
 20274	041722	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20275						STOP^
 20276	041723	254 04 0 00 041724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20277	041724	324 00 0 00 041725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20278									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20279									;IN THE SUBTEST) TO LOOP ON ERROR^
 20280
 20281					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20282					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20283					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20284					;BY C(E), ARE ZERO.
 20285					;IN THIS TEST C(AC) = -1..0 AND C(E) = 707070..707070.
 20286					;HENCE, TDNE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION.
 20287					;IF TDNE SKIPS, THIS TEST FAILS
 20288
 20289	041725	200 00 0 00 070331 	B16200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1..0
 20290	041726	612 00 0 00 070332 		TDNE	[707070707070]	;*TDNE SHOULD NOT SKIP
 20291	041727	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNE PASSES
 20292						STOP^
 20293	041730	254 04 0 00 041731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20294	041731	324 00 0 00 041732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20295									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20296									;IN THE SUBTEST) TO LOOP ON ERROR^
 20297
 20298					;*****     FAILURE ANALYSIS     *****
 20299					;C(AC0)		C(AC1)		FAILING SIGNAL
 20300
 20301					;-1,,0				SW:FCE
 20302					;-1,,0				SW: PC CHANGE
 20303					;-1,,-1				FC: AD AR + EN
 20304					;E				ET2: MC INST FETCH EN
 20305
 20306					;**********
 20307
 20308					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20309					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20310					;BY C(E), ARE ZERO.
 20311					;IN THIS CASE, AC=E AND C(AC)=0.
 20312					;HENCE, TDNE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20313					;IF TDNE DOES NOT SKIP, THIS TEST FAILS.
 20314
 20315	041732	400 00 0 00 000000 	B16300:	SETZ			;PRELOAD AC, E WITH 0		
 20316	041733	612 00 0 00 000000 		TDNE			;*TDNE SHOULD SKIP THE NEXT INSTRUCTION
 20317						STOP^
 20318	041734	254 04 0 00 041735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20319	041735	324 00 0 00 041736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20320									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20321									;IN THE SUBTEST) TO LOOP ON ERROR^
 20322
 20323					;*****     FAILURE ANALYSIS     *****
 20324					;C(AC0)		C(AC1)		FAILING SIGNAL
 20325
 20326					;0				SW: ET1
 20327					;0				ET1: PC CLOCK
 20328
 20329					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20330					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN 
 20331					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20332					;BY C(E) ARE ZERO.
 20333					;IN THIS TEST AC=E AND C(AC)=C(E)=0.  HENCE TDNN
 20334					;SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20335					;IF TDNN SKIPS, THE TEST FAILS.
 20336
 20337	041736	400 00 0 00 000000 	B16400:	SETZ			;PRELOAD AC,E WITH 0
 20338	041737	616 00 0 00 000000 		TDNN			;*TDNN SHOULD NOT SKIP THE NEXT INSTRUCTION
 20339	041740	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNE PASSES
 20340						STOP^
 20341	041741	254 04 0 00 041742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20342	041742	324 00 0 00 041743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20344									;IN THE SUBTEST) TO LOOP ON ERROR^
 20345
 20346					;*****     FAILURE ANALYSIS     *****
 20347					;C(AC0)		C(AC1)		FAILING SIGNAL
 20348
 20349					;0				SW: PC CHANGE
 20350					;0				FC: AB PC EN
 20351					;0				ET2: MC INST FETCH EN
 20352
 20353					;**********
 20354
 20355					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT
 20356					;SEQUENTIAL INSTRUCTION.  IF TDNA DOES NOT
 20357					;SKIP, THIS TEST FAILS.
 20358
 20359	041743	474 00 0 00 000000 	B16500:	SETO			;PRESET AC, E TO 0		
 20360	041744	614 00 0 00 000000 		TDNA			;*TDNA SHOULD SKIP THE NEXT INSTRUCTION
 20361						STOP^
 20362	041745	254 04 0 00 041746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20363	041746	324 00 0 00 041747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20364									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20365									;IN THE SUBTEST) TO LOOP ON ERROR^
 20366
 20367					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20368					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20369					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E),
 20370					;ARE ZERO
 20371					;IN THIS TEST C(AC)=-1,,0 AND C(E)=707070,,707070.  HENCE, TDNN
 20372					;SHOULD SKIP THE NEXT INSTRUCTION.  IF IT DOES NOT SKIP, THIS TEST FAILS.
 20373
 20374	041747	200 00 0 00 070331 	B16600:	MOVE	[XWD -1,0]	;PRESET AC TO -1,,0
 20375	041750	616 00 0 00 070332 		TDNN	[707070707070]	;*TDNN SHOULD SKIP THE NEXT INSTRUCTION
 20376						STOP^
 20377	041751	254 04 0 00 041752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20378	041752	324 00 0 00 041753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20379									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20380									;IN THE SUBTEST) TO LOOP ON ERROR^
 20381
 20382					;*****     FAILURE ANALYSIS     *****
 20383					;C(AC0)		C(AC1)		FAILING SIGNAL
 20384
 20385					;-1,,0				SW: FCE
 20386					;-1,,0				SW: ET1
 20387					;-1,,0				ET1: PC CLOCK
 20388
 20389					;**********
 20390
 20391					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20392					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20393					;BY C(E), ARE ZERO.
 20394					;IN THIS TEST, C(AC)=-1,,-1 AND C(E)=0.  HENCE, TDNE SHOULD SKIP
 20395					;THE NEXT SEQUENTIAL INSTRUCTION.
 20396					;IF TDNE DOES NOT SKIP, THIS TEST FAILS
 20397
 20398	041753	474 00 0 00 000000 	B16700:	SETO			;PRESET AC TO ALL ONES		
 20399	041754	612 00 0 00 070253 		TDNE	[0]		;*TDNE SHOULD SKIP THE NEXT INSTRUCTION
 20400						STOP^
 20401	041755	254 04 0 00 041756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20402	041756	324 00 0 00 041757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20403									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20404									;IN THE SUBTEST) TO LOOP ON ERROR^
 20405
 20406					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20407					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20408					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED
 20409					;BY C(E), ARE ZERO.
 20410					;IN THIS TEST C(AC)=0 AND C(E)=-1,,-1, HENCE, TDNE SHOULD SKIP
 20411					;THE NEXT SEQUENTIAL INSTRUCTION.
 20412					;IF TDNE DOES NOT SKIP, THIS TEST FAILS
 20413
 20414	041757	400 00 0 00 000000 	B17000:	SETZ			;PRESET AC TO 0		
 20415	041760	612 00 0 00 070254 		TDNE	[-1]		;*TDNE SHOULD SKIP THE NEXT INSTRUCTION
 20416						STOP^
 20417	041761	254 04 0 00 041762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20418	041762	324 00 0 00 041763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20419									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20420									;IN THE SUBTEST) TO LOOP ON ERROR^
 20421
 20422					;*****     FAILURE ANALYSIS     *****
 20423					;C(AC0)		C(AC1)		FAILING SIGNAL
 20424
 20425					;0				FC: AD FM + EN
 20426
 20427					;**********
 20428
 20429					;THIS TEST VERIFIES THAT TDN NEVER SKIPS THE NEXT SEQUENTIAL INSTRUCTION.
 20430					;THIS TEST FAILS IF TDN SKIPS
 20431
 20432	041763	474 00 0 00 000000 	B17300:	SETO			;PRESET AC TO -1,,-1		
 20433	041764	610 00 0 00 070253 		TDN	[0]		;*TDN SHOULD NOT SKIP
 20434	041765	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20435						STOP^
 20436	041766	254 04 0 00 041767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20437	041767	324 00 0 00 041770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20438									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20439									;IN THE SUBTEST) TO LOOP ON ERROR^
 20440
 20441					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20442					;THIS TEST VERIFIES THAT TDN NEVER SKIPS THE NEXT SEQUENTIAL INSTRUCTION.
 20443					;THIS TEST FAILS IF TDN SKIPS
 20444
 20445	041770	400 00 0 00 000000 	B17400:	SETZ			;PRESET AC TO 0
 20446	041771	610 00 0 00 070254 		TDN	[-1]		;*TDN SHOULD NOT SKIP
 20447	041772	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDN PASSES
 20448						STOP^
 20449	041773	254 04 0 00 041774 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20450	041774	324 00 0 00 041775 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20452									;IN THE SUBTEST) TO LOOP ON ERROR^
 20453
 20454					;**********
 20455
 20456					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 20457					;THIS TEST FAILS IF TDNA DOES NOT SKIP
 20458
 20459	041775	474 00 0 00 000000 	B17700:	SETO			;PRESET AC TO -1,,-1
 20460	041776	614 00 0 00 070253 		TDNA	[0]		;*TDNA SHOULD SKIP
 20461						STOP^
 20462	041777	254 04 0 00 042000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20463	042000	324 00 0 00 042001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20464									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20465									;IN THE SUBTEST) TO LOOP ON ERROR^
 20466
 20467					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20468					;THIS TEST VERIFIES THAT TDNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 20469					;THIS TEST FAILS IF TDNA DOES NOT SKIP
 20470
 20471	042001	400 00 0 00 000000 	B20000:	SETZ			;PRESET AC TO 0
 20472	042002	614 00 0 00 070254 		TDNA	[-1]		;*TDNA SHOULD SKIP
 20473						STOP^
 20474	042003	254 04 0 00 042004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20475	042004	324 00 0 00 042005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20476									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20477									;IN THE SUBTEST) TO LOOP ON ERROR^
 20478
 20479					;**********
 20480
 20481					;THIS TEST VERIFIES THAT TDNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20482					;AND ONLY WHEN ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20483					;IN THIS TEST AC=E AND C(AC)=C(E)=-1,,-1.  HENCE TDNE SHOULD NOT SKIP.
 20484					;IF TDNE SKIPS, THIS TEST FAILS.
 20485
 20486	042005	474 00 0 00 000000 	B20400:	SETO			;PRESET AC,E TO -1,,-1
 20487	042006	612 00 0 00 000000 		TDNE			;*TDNE SHOULD NOT SKIP
 20488	042007	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNE PASSES
 20489						STOP^
 20490	042010	254 04 0 00 042011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20491	042011	324 00 0 00 042012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20492									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20493									;IN THE SUBTEST) TO LOOP ON ERROR^
 20494
 20495					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20496					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20497					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20498					;IN THIS TEST, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE TDNN SHOULD SKIP
 20499					;IF TDNN DOES NOT SKIP, THIS TEST FAILS
 20500
 20501	042012	474 00 0 00 000000 	B20600:	SETO			;PRESET AC,E TO -1,,-1
 20502	042013	616 00 0 00 000000 		TDNN			;*TDNN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20503						STOP^
 20504	042014	254 04 0 00 042015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20505	042015	324 00 0 00 042016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20507									;IN THE SUBTEST) TO LOOP ON ERROR^
 20508
 20509					;**********
 20510
 20511					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20512					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20513					;IN THIS TEST, C(AC)=0 AND C(E)=-1,,-1.  HENCE TDNN SHOULD NOT SKIP
 20514					;IF TDNN SKIPS, THIS TEST FAILS
 20515
 20516	042016	400 00 0 00 000000 	B20700:	SETZ			;PRESET AC TO 0
 20517	042017	616 00 0 00 070254 		TDNN	[-1]		;*TDNN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20518	042020	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNN PASSES
 20519						STOP^
 20520	042021	254 04 0 00 042022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20521	042022	324 00 0 00 042023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20523									;IN THE SUBTEST) TO LOOP ON ERROR^
 20524
 20525					;*****     FAILURE ANALYSIS     *****
 20526					;C(AC0)		C(AC1)		FAILING SIGNAL
 20527
 20528					;0				FC: AD FM + EN
 20529
 20530					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20531					;THIS TEST VERIFIES THAT TDNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION WHEN
 20532					;AND ONLY WHEN NOT ALL OF THE BITS OF THE AC, WHICH ARE MASKED BY C(E), ARE ZERO.
 20533					;IN THIS TEST, C(AC)=-1,,-1 AND C(E)=0.  HENCE TDNN SHOULD NOT SKIP
 20534					;IF TDNN SKIPS, THIS TEST FAILS
 20535
 20536	042023	474 00 0 00 000000 	B21000:	SETO			;PRESET AC TO -1,,-1
 20537	042024	616 00 0 00 070253 		TDNN	[0]		;*TDNN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 20538	042025	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TDNN PASSES
 20539						STOP^
 20540	042026	254 04 0 00 042027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20541	042027	324 00 0 00 042030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20543									;IN THE SUBTEST) TO LOOP ON ERROR^
 20544
 20545					;*****     FAILURE ANALYSIS     *****
 20546					;C(AC0)		C(AC1)		FAILING SIGNAL
 20547
 20548					;-1,,-1				FC: AD AR + EN
 20549
 20550					;**********
 20551
 20552					;THIS TEST VERIFIES THAT TDO PLACES ONES IN THE BITS OF THE AC
 20553					;WHICH ARE MASKED BY C(E) AND DOES NOT EFFECT THE UNMASKED BITS OF THE AC.
 20554					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,0
 20555					;THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 20556
 20557	042030	400 00 0 00 000000 	B21100:	SETZ			;PRELOAD AC WITH 0
 20558	042031	670 00 0 00 070331 		TDO	[XWD -1,0]	;*TDO SHOULD PLACE -1,,0 INTO THE AC
 20559	042032	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20560						STOP^
 20561	042033	254 04 0 00 042034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20562	042034	324 00 0 00 042035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20563									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20564									;IN THE SUBTEST) TO LOOP ON ERROR^
 20565
 20566					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20567					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20568					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20569					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20570					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE,
 20571					;THE RESULT IN THE AC SHOULD BE 0,,-1.  THE AC IS
 20572					;CHECKED FOR 0,,-1.  THIS TEST PASSES IF C(AC)=0,,-1
 20573
 20574	042035	400 00 0 00 000000 	B21400:	SETZ			;PRESET AC WITH 0
 20575	042036	671 00 0 00 070331 		TSO	[XWD -1,0]	;*TSO SHOULD PLACE 0,,-1 INTO THE AC
 20576	042037	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 20577						STOP^
 20578	042040	254 04 0 00 042041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20579	042041	324 00 0 00 042042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20580									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20581									;IN THE SUBTEST) TO LOOP ON ERROR^
 20582
 20583					;*****     FAILURE ANALYSIS     *****
 20584					;C(AC0)		C(AC1)		FAILING SIGNAL
 20585
 20586					;0				SW: FCE
 20587					;0				SW: ET0
 20588					;0				SW: ET1
 20589					;0				FC: AD FM + EN
 20590					;0				FC: AD AR + EN
 20591					;0				ET0: AR SWAP
 20592					;0				ET0: AD FM + EN
 20593					;0				ET0: AD AR + EN
 20594					;0				ET1: BR AR EN
 20595					;0				ET1: AD BR - EN
 20596					;-1,,-1				ET1: AD AR + EN
 20597					;0				ET1: AD EQV
 20598
 20599					;**********
 20600
 20601					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20602					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20603					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20604					;IN THIS CASE, C(AC)=0 AND C(E)=0,,-1.  HENCE,
 20605					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20606					;CHECKED FOR -1,,0.  THIS TEST PASSES IF C(AC)=-1,,0
 20607
 20608	042042	400 00 0 00 000000 	B21500:	SETZ			;PRESET AC WITH 0
 20609	042043	671 00 0 00 070330 		TSO	[XWD 0,-1]	;*TSO SHOULD PLACE -1,,0 INTO THE AC
 20610	042044	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20611						STOP^
 20612	042045	254 04 0 00 042046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20613	042046	324 00 0 00 042047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20614									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20615									;IN THE SUBTEST) TO LOOP ON ERROR^
 20616
 20617					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20618					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20619					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20620					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20621					;IN THIS CASE, C(AC)=0 AND C(E)=0,,-1.  HENCE,
 20622					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20623					;CHECKED FOR ITS CONTENTS NON-ZERO.  THIS TEST PASSES IF C(AC) IS NON-ZERO
 20624
 20625	042047	400 00 0 00 000000 	B21600:	SETZ			;PRELOAD AC,E WITH 0
 20626	042050	671 00 0 00 000000 		TSO			;*TSO SHOULD PLACE 0 INTO THE AC
 20627	042051	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20628						STOP^
 20629	042052	254 04 0 00 042053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20630	042053	324 00 0 00 042054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20632									;IN THE SUBTEST) TO LOOP ON ERROR^
 20633
 20634					;**********
 20635
 20636					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20637					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20638					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20639					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE,
 20640					;THE RESULT IN THE AC SHOULD BE -1,,-1.  THE AC IS
 20641					;CHECKED FOR -1,,-1.  THIS TEST PASSES IF C(AC) -1,,-1
 20642
 20643	042054	474 00 0 00 000000 	B21700:	SETO			;PRELOAD AC,E WITH -1,,-1
 20644	042055	671 00 0 00 000000 		TSO			;*TSO SHOULD PLACE -1,,-1 INTO THE AC
 20645	042056	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20646						STOP^
 20647	042057	254 04 0 00 042060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20648	042060	324 00 0 00 042061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20650									;IN THE SUBTEST) TO LOOP ON ERROR^
 20651
 20652					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20653					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20654					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20655					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20656					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE,
 20657					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20658					;CHECKED FOR -1,,0.  THIS TEST PASSES IF C(AC)=-1,,0
 20659
 20660	042061	200 00 0 00 070331 	B22200:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 20661	042062	671 00 0 00 070330 		TSO	[XWD 0,-1]	;*TSO SHOULD PLACE -1,,0 INTO THE AC
 20662	042063	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 20663						STOP^
 20664	042064	254 04 0 00 042065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20665	042065	324 00 0 00 042066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20666									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20667									;IN THE SUBTEST) TO LOOP ON ERROR^
 20668
 20669					;**********
 20670
 20671					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20672					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20673					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20674					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE,
 20675					;THE RESULT IN THE AC SHOULD BE 0,,-1.  THE AC IS
 20676					;CHECKED FOR 0,,-1.  THIS TEST PASSES IF C(AC)=0,,-1
 20677
 20678	042066	201 00 0 00 777777 	B22300:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 20679	042067	671 00 0 00 070253 		TSO	[0]		;*TSO SHOULD PLACE 0,,-1 INTO THE AC
 20680	042070	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 20681						STOP^
 20682	042071	254 04 0 00 042072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20683	042072	324 00 0 00 042073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20685									;IN THE SUBTEST) TO LOOP ON ERROR^
 20686
 20687					;*****     FAILURE ANALYSIS     *****
 20688					;C(AC0)		C(AC1)		FAILING SIGNAL
 20689
 20690					;0				ET1: AD FM - EN
 20691					;0				ET2: AR AD EN
 20692
 20693					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20694					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20695					;WHICH ARE MASKED BY BOTH HALVES OF C(E) SWAPPED.
 20696					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20697					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE,
 20698					;THE RESULT IN THE AC SHOULD BE -1,,0.  THE AC IS
 20699					;CHECKED FOR -1,,0.  THIS TEST PASSES IF C(AC)=-1,,0
 20700
 20701	042073	200 00 0 00 070331 	B22400:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 20702	042074	671 00 0 00 070253 		TSO	[0]		;*TSO SHOULD PLACE -1,,0 INTO THE AC
 20703	042075	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20704						STOP^
 20705	042076	254 04 0 00 042077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20706	042077	324 00 0 00 042100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20707									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20708									;IN THE SUBTEST) TO LOOP ON ERROR^
 20709
 20710					;**********
 20711
 20712					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20713					;WHICH ARE MARKED BY BOTH HALVES OF C(E) SWAPPED.
 20714					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20715					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE,
 20716					;THE RESULT IN THE AC SHOULD BE -1,,-1.  THE AC IS
 20717					;CHECKED FOR -1,,-1.  THIS TEST PASSES IF C(AC)=-1,,-1
 20718
 20719	042100	201 00 0 00 777777 	B22500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 20720	042101	671 00 0 00 070254 		TSO	[-1]		;*TSO SHOULD PLACE -1,,-1 INTO THE AC
 20721	042102	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20722						STOP^
 20723	042103	254 04 0 00 042104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20724	042104	324 00 0 00 042105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20725									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20726									;IN THE SUBTEST) TO LOOP ON ERROR^
 20727
 20728					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA3	MAC	13-Jan-89 10:22		TEST OF LOGICAL TEST INSTRUCTIONS

 20729					;THIS TEST VERIFIES THAT TSO PLACES ONES IN THE BITS OF THE AC
 20730					;WHICH ARE MARKED BY BOTH HALVES OF C(E) SWAPPED.
 20731					;THE UNMASKED BITS OF THE AC ARE NOT AFFECTED
 20732					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE,
 20733					;THE RESULT IN THE AC SHOULD BE -1,,-1.  THE AC IS
 20734					;CHECKED FOR -1,,-1.  THIS TEST PASSES IF C(AC)=-1,,-1
 20735
 20736	042105	200 00 0 00 070331 	B22600:	MOVE	[XWD -1,0]	;PRELOAD AC WITH -1,,0
 20737	042106	671 00 0 00 070254 		TSO	[-1]		;*TSO SHOULD PLACE -1,,-1 INTO THE AC
 20738	042107	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20739						STOP^
 20740	042110	254 04 0 00 042111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20741	042111	324 00 0 00 042112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20742									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20743									;IN THE SUBTEST) TO LOOP ON ERROR^
 20744
 20745					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 20746					SUBTTL	TEST OF HWT INSTRUCTIONS
 20747
 20748					;**********
 20749
 20750					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20751					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20752					;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 20753					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20754
 20755	042112	400 00 0 00 000000 	B22700:	SETZ			;PRELOAD AC,E WITH 0		
 20756	042113	500 00 0 00 000000 		HLL			;*HLL SHOULD PLACE 0 INTO THE AC
 20757	042114	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20758						STOP^
 20759	042115	254 04 0 00 042116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20760	042116	324 00 0 00 042117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20761									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20762									;IN THE SUBTEST) TO LOOP ON ERROR^
 20763
 20764					;*****     FAILURE ANALYSIS     *****
 20765					;C(AC0)		C(AC1)		FAILING SIGNAL
 20766
 20767					;-1,,0				FC: AD AR + EN
 20768					;0,,-1				FC: AD RT FM + EN
 20769
 20770					;**********
 20771
 20772					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20773					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20774					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 20775					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 20776					;THIS TEST PASSES.
 20777
 20778	042117	474 00 0 00 000000 	B23000:	SETO			;PRELOAD AC WITH -1,,-1
 20779	042120	500 00 0 00 070253 		HLL	[0]		;*HLL SHOULD PLACE 0,,-1 INTO THE AC
 20780	042121	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 20781						STOP^
 20782	042122	254 04 0 00 042123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20783	042123	324 00 0 00 042124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20784									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20785									;IN THE SUBTEST) TO LOOP ON ERROR^
 20786
 20787					;*****     FAILURE ANALYSIS     *****
 20788					;C(AC0)		C(AC1)		FAILING SIGNAL
 20789
 20790					;0,,-1				SW: FCE
 20791					;0				ET2: AR AD EN
 20792
 20793					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 20794					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20795					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20796					;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20797					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 20798
 20799	042124	474 00 0 00 000000 	B23200:	SETO			;PRELOAD AC,E WITH -1,,-1		
 20800	042125	500 00 0 00 000000 		HLL			;*HLL SHOULD PLACE -1,,-1 INTO THE AC
 20801	042126	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 20802						STOP^
 20803	042127	254 04 0 00 042130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20804	042130	324 00 0 00 042131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20806									;IN THE SUBTEST) TO LOOP ON ERROR^
 20807
 20808					;**********
 20809
 20810					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20811					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20812					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20813					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 20814					;THIS TEST PASSES
 20815
 20816	042131	400 00 0 00 000000 	B23400:	SETZ			;PRELOAD AC WITH 0		
 20817	042132	500 00 0 00 070254 		HLL	[-1]		;*HLL SHOULD PLACE -1,,0 INTO THE AC	
 20818	042133	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20819						STOP^
 20820	042134	254 04 0 00 042135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20821	042135	324 00 0 00 042136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20822									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20823									;IN THE SUBTEST) TO LOOP ON ERROR^
 20824
 20825					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 20826					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20827					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20828					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 20829					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0,
 20830					;THIS TEST PASSES.
 20831
 20832	042136	400 00 0 00 000000 	B23600:	SETZ			;PRELOAD AC WITH 0		
 20833	042137	500 00 0 00 070331 		HLL	[XWD -1,0]	;*HLL SHOULD PLACE -1,,0 INTO THE AC
 20834	042140	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20835						STOP^
 20836	042141	254 04 0 00 042142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20837	042142	324 00 0 00 042143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20838									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20839									;IN THE SUBTEST) TO LOOP ON ERROR^
 20840
 20841					;**********
 20842
 20843					;THIS TEST VERIFIES THAT HLL PLACES THE LEFT HALF OF C(E) INTO
 20844					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 20845					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0,,-1.  HENCE, THE RESULT IN THE AC
 20846					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1,
 20847					;THIS TEST PASSES.
 20848
 20849	042143	474 00 0 00 000000 	B23700:	SETO			;PRELOAD AC WITH -1,,-1
 20850	042144	500 00 0 00 070330 		HLL	[XWD 0,-1]	;*HLL SHOULD PLACE 0,,-1 INTO THE AC
 20851	042145	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 20852						STOP^
 20853	042146	254 04 0 00 042147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20854	042147	324 00 0 00 042150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20855									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20856									;IN THE SUBTEST) TO LOOP ON ERROR^
 20857
 20858					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 20859					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20860					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20861					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 20862					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20863
 20864	042150	400 00 0 00 000000 	B24000:	SETZ			;PRELOAD AC,E WITH 0		
 20865	042151	510 00 0 00 000000 		HLLZ			;*HLLZ SHOULD PLACE 0 INTO THE AC
 20866	042152	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20867						STOP^
 20868	042153	254 04 0 00 042154 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20869	042154	324 00 0 00 042155 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20870									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20871									;IN THE SUBTEST) TO LOOP ON ERROR^
 20872
 20873					;*****     FAILURE ANALYSIS     *****
 20874					;C(AC0)		C(AC1)		FAILING SIGNAL
 20875
 20876					;-1,,0				FC: AD LT AR + EN
 20877
 20878					;**********
 20879
 20880					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20881					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20882					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20883					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 20884					;IF C(AC)=-1,,0, THIS TEST PASSES.
 20885
 20886	042155	474 00 0 00 000000 	B24300:	SETO			;PRELOAD AC WITH -1,,-1
 20887	042156	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20888	042157	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20889						STOP^
 20890	042160	254 04 0 00 042161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20891	042161	324 00 0 00 042162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20893									;IN THE SUBTEST) TO LOOP ON ERROR^
 20894
 20895					;*****     FAILURE ANALYSIS     *****
 20896					;C(AC0)		C(AC1)		FAILING SIGNAL
 20897
 20898					;0				SW: FCE
 20899					;-1,,-1				ET2: AR LT AD EN
 20900
 20901					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 20902					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20903					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20904					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 20905					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO
 20906					;IF C(AC) IS NON-ZERO, THIS TEST PASSES.
 20907
 20908	042162	400 00 0 00 000000 	B24400:	SETZ			;PRELOAD AC WITH -1,,-1
 20909	042163	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20910	042164	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 20911						STOP^
 20912	042165	254 04 0 00 042166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20913	042166	324 00 0 00 042167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20914									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20915									;IN THE SUBTEST) TO LOOP ON ERROR^
 20916
 20917					;**********
 20918
 20919					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20920					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20921					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 20922					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO
 20923					;IF C(AC) IS ZERO, THIS TEST PASSES.
 20924
 20925	042167	474 00 0 00 000000 	B24500:	SETO			;PRELOAD AC WITH -1,,-1		
 20926	042170	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20927	042171	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 20928						STOP^
 20929	042172	254 04 0 00 042173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20930	042173	324 00 0 00 042174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20931									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20932									;IN THE SUBTEST) TO LOOP ON ERROR^
 20933
 20934					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 20935					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20936					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20937					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 20938					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO
 20939					;IF C(AC) IS ZERO, THIS TEST PASSES.
 20940
 20941	042174	400 00 0 00 000000 	B24600:	SETZ			;PRELOAD AC WITH 0
 20942	042175	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE 0 INTO THE AC
 20943	042176	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 20944						STOP^
 20945	042177	254 04 0 00 042200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20946	042200	324 00 0 00 042201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20947									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20948									;IN THE SUBTEST) TO LOOP ON ERROR^
 20949
 20950					;**********
 20951
 20952					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 20953					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1.
 20954					;THE RESULT IN THE AC SHOULD BE 0
 20955					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20956
 20957	042201	474 00 0 00 000000 	B24700:	SETO			;PRELOAD AC WITH -1,,-1
 20958	042202	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 20959	042203	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20960						STOP^
 20961	042204	254 04 0 00 042205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20962	042205	324 00 0 00 042206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20964									;IN THE SUBTEST) TO LOOP ON ERROR^
 20965
 20966					;*****     FAILURE ANALYSIS     *****
 20967					;C(AC0)		C(AC1)		FAILING SIGNAL
 20968
 20969					;-1,,0				FC: AD LT AR + EN
 20970					;0,,-1				ET2: AR LT AD EN
 20971
 20972					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 20973					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 20974					;IN THIS CASE C(AC)=0 AND E=0,,-1.
 20975					;THE RESULT IN THE AC SHOULD BE 0
 20976					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 20977
 20978	042206	400 00 0 00 000000 	B25000:	SETZ			;PRELOAD AC WITH 0
 20979	042207	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 20980	042210	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 20981						STOP^
 20982	042211	254 04 0 00 042212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 20983	042212	324 00 0 00 042213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 20984									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 20985									;IN THE SUBTEST) TO LOOP ON ERROR^
 20986
 20987					;**********
 20988
 20989					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 20990					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 20991					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 20992					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 20993					;IF C(AC)=-1,,0, THIS TEST PASSES.
 20994
 20995	042213	474 00 0 00 000000 	B25100:	SETO			;PRELOAD AC WITH -1,,-1
 20996	042214	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 20997	042215	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 20998						STOP^
 20999	042216	254 04 0 00 042217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21000	042217	324 00 0 00 042220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21001									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21002									;IN THE SUBTEST) TO LOOP ON ERROR^
 21003
 21004					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 32
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21005					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21006					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21007					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21008					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21009					;IF C(AC)=-1,,0 THIS TEST PASSES.
 21010
 21011	042220	400 00 0 00 000000 	B25200:	SETZ			;PRELOAD AC WITH 0
 21012	042221	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21013	042222	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21014						STOP^
 21015	042223	254 04 0 00 042224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21016	042224	324 00 0 00 042225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21017									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21018									;IN THE SUBTEST) TO LOOP ON ERROR^
 21019
 21020					;**********
 21021
 21022					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21023					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21024					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21025					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21026					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21027
 21028	042225	201 00 0 00 777777 	B25300:	MOVEI	-1		;PRELOAD AC WITH -1,,-1
 21029	042226	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21030	042227	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21031						STOP^
 21032	042230	254 04 0 00 042231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21033	042231	324 00 0 00 042232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21034									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21035									;IN THE SUBTEST) TO LOOP ON ERROR^
 21036
 21037					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 33
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21038					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21039					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21040					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21041					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21042					;IF C(AC)=-1,,0 THIS TEST PASSES.
 21043
 21044	042232	205 00 0 00 777777 	B25400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21045	042233	510 00 0 00 070254 		HLLZ	[-1]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21046	042234	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 21047						STOP^
 21048	042235	254 04 0 00 042236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21049	042236	324 00 0 00 042237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21051									;IN THE SUBTEST) TO LOOP ON ERROR^
 21052
 21053					;**********
 21054
 21055					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21056					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21057					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21058					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.
 21059					;IF C(AC) IS ZERO, THIS TEST PASSES.
 21060
 21061	042237	201 00 0 00 777777 	B25500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21062	042240	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE 0 INTO THE AC
 21063	042241	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 21064						STOP^
 21065	042242	254 04 0 00 042243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21066	042243	324 00 0 00 042244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21067									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21068									;IN THE SUBTEST) TO LOOP ON ERROR^
 21069
 21070					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 34
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21071					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21072					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21073					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21074					;SHOULD BE 0.  THE AC IS CHECKED FOR ZERO.
 21075					;IF C(AC) IS ZERO, THIS TEST PASSES.
 21076
 21077	042244	205 00 0 00 777777 	B25600:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21078	042245	510 00 0 00 070253 		HLLZ	[0]		;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21079	042246	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS ZERO.
 21080						STOP^
 21081	042247	254 04 0 00 042250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21082	042250	324 00 0 00 042251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21084									;IN THE SUBTEST) TO LOOP ON ERROR^
 21085
 21086					;**********
 21087
 21088					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21089					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21090					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21091					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21092					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21093
 21094	042251	201 00 0 00 777777 	B25700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21095	042252	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21096	042253	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21097						STOP^
 21098	042254	254 04 0 00 042255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21099	042255	324 00 0 00 042256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21101									;IN THE SUBTEST) TO LOOP ON ERROR^
 21102
 21103					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 35
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21104					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 21105					;IN THIS CASE C(AC)=0,,-1 AND E=0,,-1.
 21106					;THE RESULT IN THE AC SHOULD BE 0
 21107					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 21108
 21109	042256	201 00 0 00 777777 	B26000:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21110	042257	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 21111	042260	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21112						STOP^
 21113	042261	254 04 0 00 042262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21114	042262	324 00 0 00 042263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21115									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21116									;IN THE SUBTEST) TO LOOP ON ERROR^
 21117
 21118					;**********
 21119
 21120					;THIS TEST VERIFIES THAT HLLZ PLACES THE LEFT HALF OF C(E) INTO
 21121					;THE LEFT HALF OF THE AC AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 21122					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21123					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 21124					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21125
 21126	042263	205 00 0 00 777777 	B26100:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21127	042264	510 00 0 00 070331 		HLLZ	[XWD -1,0]	;*HLLZ SHOULD PLACE -1,,0 INTO THE AC
 21128	042265	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21129						STOP^
 21130	042266	254 04 0 00 042267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21131	042267	324 00 0 00 042270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21133									;IN THE SUBTEST) TO LOOP ON ERROR^
 21134
 21135					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 36
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21136					;THIS TEST VERIFIES THAT HLLZI ALWAYS CLEARS THE AC.
 21137					;IN THIS CASE C(AC)=-1,,0 AND E=0,,-1.
 21138					;THE RESULT IN THE AC SHOULD BE 0
 21139					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 21140
 21141	042270	205 00 0 00 777777 	B26200:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21142	042271	511 00 0 00 777777 		HLLZI	-1		;*HLLZI SHOULD CLEAR THE AC
 21143	042272	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21144						STOP^
 21145	042273	254 04 0 00 042274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21146	042274	324 00 0 00 042275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21147									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21148									;IN THE SUBTEST) TO LOOP ON ERROR^
 21149
 21150					;**********
 21151
 21152					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21153					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21154					;IN THIS CASE AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 21155					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21156
 21157	042275	400 00 0 00 000000 	B26300:	SETZ			;PRELOAD AC WITH 0
 21158	042276	540 00 0 00 000000 		HRR			;*HRR SHOULD PLACE 0 INTO THE AC
 21159	042277	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21160						STOP^
 21161	042300	254 04 0 00 042301 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21162	042301	324 00 0 00 042302 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21163									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21164									;IN THE SUBTEST) TO LOOP ON ERROR^
 21165
 21166					;*****     FAILURE ANALYSIS     *****
 21167					;C(AC0)		C(AC1)		FAILING SIGNAL
 21168
 21169					;0,,-1				FC: AD RT AR + EN
 21170					;-1,,0				FC: AD LT FM + EN
 21171
 21172					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 37
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21173					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21174					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21175					;IN THIS CASE AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21176					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21177
 21178	042302	474 00 0 00 000000 	B26500:	SETO			;PRELOAD AC WITH -1,,-1
 21179	042303	540 00 0 00 000000 		HRR			;*HRR SHOULD PLACE -1,,-1 INTO THE AC
 21180	042304	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21181						STOP^
 21182	042305	254 04 0 00 042306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21183	042306	324 00 0 00 042307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21184									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21185									;IN THE SUBTEST) TO LOOP ON ERROR^
 21186
 21187					;*****     FAILURE ANALYSIS     *****
 21188					;C(AC0)		C(AC1)		FAILING SIGNAL
 21189
 21190					;-1,,0				SW: FCE
 21191
 21192					;**********
 21193
 21194					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21195					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21196					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21197					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21198
 21199	042307	474 00 0 00 000000 	B26600:	SETO			;PRELOAD AC WITH -1,,-1
 21200	042310	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE -1,,0 INTO THE AC
 21201	042311	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21202						STOP^
 21203	042312	254 04 0 00 042313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21204	042313	324 00 0 00 042314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21205									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21206									;IN THE SUBTEST) TO LOOP ON ERROR^
 21207
 21208					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21209					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21210					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21211					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21212					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21213
 21214	042314	474 00 0 00 000000 	B26700:	SETO			;PRELOAD AC WITH -1,,-1
 21215	042315	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE -1,,-1 INTO THE AC
 21216	042316	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21217						STOP^
 21218	042317	254 04 0 00 042320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21219	042320	324 00 0 00 042321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21220									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21221									;IN THE SUBTEST) TO LOOP ON ERROR^
 21222
 21223					;*****     FAILURE ANALYSIS     *****
 21224					;C(AC0)		C(AC1)		FAILING SIGNAL
 21225
 21226					;0,,-1				ET2: AR AD EN
 21227
 21228					;**********
 21229
 21230					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21231					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21232					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21233					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21234
 21235	042321	474 00 0 00 000000 	B27000:	SETO			;PRELOAD AC WITH -1,,-1
 21236	042322	540 00 0 00 070253 		HRR	[0]		;*HRR SHOULD PLACE -1,,0 INTO THE AC
 21237	042323	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=0
 21238						STOP^
 21239	042324	254 04 0 00 042325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21240	042325	324 00 0 00 042326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21241									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21242									;IN THE SUBTEST) TO LOOP ON ERROR^
 21243
 21244					;*****     FAILURE ANALYSIS     *****
 21245					;C(AC0)		C(AC1)		FAILING SIGNAL
 21246
 21247					;0				ET2: AR AD EN
 21248
 21249					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21250					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21251					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21252					;IN THIS CASE C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21253					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21254
 21255	042326	400 00 0 00 000000 	B27100:	SETZ			;PRELOAD AC WITH 0
 21256	042327	540 00 0 00 070253 		HRR	[0]		;*HRR SHOULD PLACE 0 INTO THE AC
 21257	042330	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21258						STOP^
 21259	042331	254 04 0 00 042332 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21260	042332	324 00 0 00 042333 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21262									;IN THE SUBTEST) TO LOOP ON ERROR^
 21263
 21264					;**********
 21265
 21266					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21267					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21268					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21269					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21270
 21271	042333	400 00 0 00 000000 	B27200:	SETZ			;PRELOAD AC WITH 0
 21272	042334	540 00 0 00 070254 		HRR	[-1]		;*HRR SHOULD PLACE 0,,-1 INTO THE AC
 21273	042335	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21274						STOP^
 21275	042336	254 04 0 00 042337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21276	042337	324 00 0 00 042340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21277									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21278									;IN THE SUBTEST) TO LOOP ON ERROR^
 21279
 21280					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21281					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21282					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21283					;IN THIS CASE C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21284					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21285
 21286	042340	400 00 0 00 000000 	B27300:	SETZ			;PRELOAD AC WITH 0
 21287	042341	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE 0,,-1 INTO THE AC
 21288	042342	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21289						STOP^
 21290	042343	254 04 0 00 042344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21291	042344	324 00 0 00 042345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21292									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21293									;IN THE SUBTEST) TO LOOP ON ERROR^
 21294
 21295					;*****     FAILURE ANALYSIS     *****
 21296					;C(AC0)		C(AC1)		FAILING SIGNAL
 21297
 21298					;-1,,-1				FC: AD LT FM + EN
 21299
 21300					;**********
 21301
 21302					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21303					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21304					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21305					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21306
 21307	042345	400 00 0 00 000000 	B27400:	SETZ			;PRELOAD AC WITH 0
 21308	042346	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE 0 INTO THE AC
 21309	042347	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21310						STOP^
 21311	042350	254 04 0 00 042351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21312	042351	324 00 0 00 042352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21314									;IN THE SUBTEST) TO LOOP ON ERROR^
 21315
 21316					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21317					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21318					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21319					;IN THIS CASE C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21320					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21321
 21322	042352	201 00 0 00 777777 	B27500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21323	042353	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE 0 INTO THE AC
 21324	042354	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21325						STOP^
 21326	042355	254 04 0 00 042356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21327	042356	324 00 0 00 042357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21328									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21329									;IN THE SUBTEST) TO LOOP ON ERROR^
 21330
 21331					;**********
 21332
 21333					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21334					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21335					;IN THIS CASE C(AC)=-1,,0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21336					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21337
 21338	042357	205 00 0 00 777777 	B27600:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21339	042360	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE -1,,-1 INTO THE AC
 21340	042361	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21341						STOP^
 21342	042362	254 04 0 00 042363 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21343	042363	324 00 0 00 042364 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21344									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21345									;IN THE SUBTEST) TO LOOP ON ERROR^
 21346
 21347					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21348					;THIS TEST VERIFIES THAT HRRI PLACES E INTO
 21349					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED
 21350					;IN THIS CASE C(AC)=0,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21351					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21352
 21353	042364	201 00 0 00 777777 	B27700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21354	042365	541 00 0 00 777777 		HRRI	-1		;*HRRI SHOULD PLACE 0,,-1 INTO THE AC
 21355	042366	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21356						STOP^
 21357	042367	254 04 0 00 042370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21358	042370	324 00 0 00 042371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21359									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21360									;IN THE SUBTEST) TO LOOP ON ERROR^
 21361
 21362					;**********
 21363
 21364					;THIS TEST VERIFIES THAT HRR PLACES THE RIGHT HALF OF C(E) INTO
 21365					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21366					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21367					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21368
 21369	042371	205 00 0 00 777777 	B30000:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 21370	042372	540 00 0 00 070331 		HRR	[XWD -1,0]	;*HRR SHOULD PLACE -1,,0 INTO THE AC
 21371	042373	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21372						STOP^
 21373	042374	254 04 0 00 042375 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21374	042375	324 00 0 00 042376 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21375									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21376									;IN THE SUBTEST) TO LOOP ON ERROR^
 21377
 21378					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21379					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21380					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21381					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 21382					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21383
 21384	042376	400 00 0 00 000000 	B30100:	SETZ			;PRELOAD AC,E WITH 0
 21385	042377	550 00 0 00 000000 		HRRZ			;*HRRZ SHOULD PLACE 0 INTO THE AC
 21386	042400	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21387						STOP^
 21388	042401	254 04 0 00 042402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21389	042402	324 00 0 00 042403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21390									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21391									;IN THE SUBTEST) TO LOOP ON ERROR^
 21392
 21393					;*****     FAILURE ANALYSIS     *****
 21394					;C(AC0)		C(AC1)		FAILING SIGNAL
 21395
 21396					;0,,-1				FC: AD RT AR + EN
 21397
 21398					;**********
 21399
 21400					;THIS TEST VERIFIES THAT HRRZI PLACES E INTO
 21401					;THE RIGHT HALF OF THE AC AND CLEARS THE LEFT HALF OF THE AC
 21402					;IN THIS CASE C(AC)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21403					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 21404
 21405	042403	474 00 0 00 000000 	B30400:	SETO			;PRELOAD AC WITH -1,,-1
 21406	042404	551 00 0 00 777777 		HRRZI	-1		;*HRRZI SHOULD PLACE 0,,-1 INTO THE AC
 21407	042405	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21408						STOP^
 21409	042406	254 04 0 00 042407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21410	042407	324 00 0 00 042410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21412									;IN THE SUBTEST) TO LOOP ON ERROR^
 21413
 21414					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21415					;THIS TEST VERIFIES THAT HRRZI PLACES E INTO
 21416					;THE RIGHT HALF OF THE AC AND CLEARS THE LEFT HALF OF THE AC
 21417					;IN THIS CASE C(AC)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21418					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 21419
 21420	042410	474 00 0 00 000000 	B30500:	SETO			;PRELOAD AC WITH -1,,-1
 21421	042411	551 00 0 00 000000 		HRRZI	0		;*HRRZI SHOULD PLACE 0 INTO THE AC
 21422	042412	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21423						STOP^
 21424	042413	254 04 0 00 042414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21425	042414	324 00 0 00 042415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21426									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21427									;IN THE SUBTEST) TO LOOP ON ERROR^
 21428
 21429					;*****     FAILURE ANALYSIS     *****
 21430					;C(AC0)		C(AC1)		FAILING SIGNAL
 21431
 21432					;0,,-1				FC: AD RT AR + EN
 21433
 21434					;**********
 21435
 21436					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21437					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21438					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21439					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21440
 21441	042415	474 00 0 00 000000 	B30600:	SETO			;PRELOAD AC WITH -1,,-1
 21442	042416	550 00 0 00 070331 		HRRZ	[XWD -1,0]	;*HRRZ SHOULD PLACE 0 INTO THE AC
 21443	042417	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21444						STOP^
 21445	042420	254 04 0 00 042421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21446	042421	324 00 0 00 042422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21447									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21448									;IN THE SUBTEST) TO LOOP ON ERROR^
 21449
 21450					;*****     FAILURE ANALYSIS     *****
 21451					;C(AC0)		C(AC1)		FAILING SIGNAL
 21452
 21453					;E				SW: FCE
 21454					;-1,,0				ET2: AR RT AD EN
 21455
 21456					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21457					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21458					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21459					;IN THIS CASE C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21460					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21461
 21462	042422	474 00 0 00 000000 	B30700:	SETO			;PRELOAD AC WITH -1,,-1
 21463	042423	550 00 0 00 070254 		HRRZ	[-1]		;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21464	042424	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21465						STOP^
 21466	042425	254 04 0 00 042426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21467	042426	324 00 0 00 042427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21468									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21469									;IN THE SUBTEST) TO LOOP ON ERROR^
 21470
 21471					;**********
 21472
 21473					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21474					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21475					;IN THIS CASE C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21476					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21477
 21478	042427	201 00 0 00 777777 	B31000:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 21479	042430	550 00 0 00 070254 		HRRZ	[-1]		;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21480	042431	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21481						STOP^
 21482	042432	254 04 0 00 042433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21483	042433	324 00 0 00 042434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21485									;IN THE SUBTEST) TO LOOP ON ERROR^
 21486
 21487					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 46
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21488					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21489					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21490					;IN THIS CASE C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21491					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21492
 21493	042434	201 00 0 00 777777 	B31100:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21494	042435	550 00 0 00 070253 		HRRZ	[0]		;*HRRZ SHOULD PLACE 0 INTO THE AC
 21495	042436	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21496						STOP^
 21497	042437	254 04 0 00 042440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21498	042440	324 00 0 00 042441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21500									;IN THE SUBTEST) TO LOOP ON ERROR^
 21501
 21502					;**********
 21503
 21504					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21505					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21506					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21507					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21508
 21509	042441	205 00 0 00 777777 	B31200:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21510	042442	550 00 0 00 070254 		HRRZ	[-1]		;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21511	042443	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21512						STOP^
 21513	042444	254 04 0 00 042445 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21514	042445	324 00 0 00 042446 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21515									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21516									;IN THE SUBTEST) TO LOOP ON ERROR^
 21517
 21518					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 47
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21519					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21520					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21521					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21522					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21523
 21524	042446	205 00 0 00 777777 	B31300:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21525	042447	550 00 0 00 070253 		HRRZ	[0]		;*HRRZ SHOULD PLACE 0 INTO THE AC
 21526	042450	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21527						STOP^
 21528	042451	254 04 0 00 042452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21529	042452	324 00 0 00 042453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21530									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21531									;IN THE SUBTEST) TO LOOP ON ERROR^
 21532
 21533					;**********
 21534
 21535					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21536					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21537					;IN THIS CASE C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21538					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21539
 21540	042453	201 00 0 00 777777 	B31400:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21541	042454	550 00 0 00 070331 		HRRZ	[XWD -1,0]	;*HRRZ SHOULD PLACE 0 INTO THE AC
 21542	042455	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21543						STOP^
 21544	042456	254 04 0 00 042457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21545	042457	324 00 0 00 042460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21546									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21547									;IN THE SUBTEST) TO LOOP ON ERROR^
 21548
 21549					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 48
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21550					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21551					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21552					;IN THIS CASE C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE, THE RESULT IN THE AC
 21553					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21554
 21555	042460	205 00 0 00 777777 	B31500:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21556	042461	550 00 0 00 070330 		HRRZ	[XWD 0,-1]	;*HRRZ SHOULD PLACE 0,,-1 INTO THE AC
 21557	042462	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21558						STOP^
 21559	042463	254 04 0 00 042464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21560	042464	324 00 0 00 042465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21561									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21562									;IN THE SUBTEST) TO LOOP ON ERROR^
 21563
 21564					;**********
 21565
 21566					;THIS TEST VERIFIES THAT HRRZI PLACES E INTO
 21567					;THE RIGHT HALF OF THE AC AND CLEARS THE LEFT HALF OF THE AC
 21568					;IN THIS CASE C(AC)=0,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21569					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 21570
 21571	042465	201 00 0 00 777777 	B31600:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21572	042466	551 00 0 00 777777 		HRRZI	-1		;*HRRZI SHOULD PLACE 0,,-1 INTO THE AC
 21573	042467	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,1
 21574						STOP^
 21575	042470	254 04 0 00 042471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21576	042471	324 00 0 00 042472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21577									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21578									;IN THE SUBTEST) TO LOOP ON ERROR^
 21579
 21580					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 49
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21581					;THIS TEST VERIFIES THAT HRRZ PLACES THE RIGHT HALF OF C(E) INTO
 21582					;RIGHT HALF OF THE AC AND PLACES ZEROS INTO THE LEFT HALF OF THE AC
 21583					;IN THIS CASE C(AC)=-1,,0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21584					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21585
 21586	042472	205 00 0 00 777777 	B31700:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21587	042473	550 00 0 00 070331 		HRRZ	[XWD -1,0]	;*HRRZ SHOULD PLACE 0 INTO THE AC,0]
 21588	042474	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21589						STOP^
 21590	042475	254 04 0 00 042476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21591	042476	324 00 0 00 042477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21592									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21593									;IN THE SUBTEST) TO LOOP ON ERROR^
 21594
 21595					;**********
 21596
 21597					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21598					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21599					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 21600					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21601
 21602	042477	400 00 0 00 000000 	B32000:	SETZ			;PRELOAD AC WITH 0		
 21603	042500	504 00 0 00 000000 		HRL			;*HRL SHOULD PLACE 0 INTO THE AC
 21604	042501	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21605						STOP^
 21606	042502	254 04 0 00 042503 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21607	042503	324 00 0 00 042504 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21608									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21609									;IN THE SUBTEST) TO LOOP ON ERROR^
 21610
 21611					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 50
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21612					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21613					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21614					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21615					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21616
 21617	042504	474 00 0 00 000000 	B32100:	SETO			;PRELOAD AC WITH -1,,-1		
 21618	042505	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,-1 INTO THE AC
 21619	042506	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21620						STOP^
 21621	042507	254 04 0 00 042510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21622	042510	324 00 0 00 042511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21623									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21624									;IN THE SUBTEST) TO LOOP ON ERROR^
 21625
 21626					;*****     FAILURE ANALYSIS     *****
 21627					;C(AC0)		C(AC1)		FAILING SIGNAL
 21628
 21629					;E,,-1				SW: FCE
 21630					;0,,-1				FC: AD RT FM + EN
 21631					;0,,-1				ET2: AR LT AR RT EN
 21632					;-1,,0				ET2: AR RT AD EN
 21633
 21634					;**********
 21635
 21636					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21637					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21638					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21639					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21640
 21641	042511	474 00 0 00 000000 	B32200:	SETO			;PRELOAD AC WITH -1,,-1		
 21642	042512	504 00 0 00 070253 		HRL	[0]		;*HRL SHOULD PLACE 0,,-1 INTO THE AC
 21643	042513	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21644						STOP^
 21645	042514	254 04 0 00 042515 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21646	042515	324 00 0 00 042516 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21648									;IN THE SUBTEST) TO LOOP ON ERROR^
 21649
 21650					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 51
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21651					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21652					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21653					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21654					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21655
 21656	042516	474 00 0 00 000000 	B32300:	SETO			;PRELOAD AC WITH -1,,-1		
 21657	042517	544 00 0 00 070253 		HLR	[0]		;*HLR SHOULD PLACE -1,,0 INTO THE AC
 21658	042520	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 21659						STOP^
 21660	042521	254 04 0 00 042522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21661	042522	324 00 0 00 042523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21662									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21663									;IN THE SUBTEST) TO LOOP ON ERROR^
 21664
 21665					;*****     FAILURE ANALYSIS     *****
 21666					;C(AC0)		C(AC1)		FAILING SIGNAL
 21667
 21668					;0				ET2: AR LT AD EN
 21669
 21670					;**********
 21671
 21672					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21673					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21674					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21675					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21676
 21677	042523	400 00 0 00 000000 	B32600:	SETZ			;PRELOAD AC WITH 0		
 21678	042524	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,0 INTO THE AC
 21679	042525	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 21680						STOP^
 21681	042526	254 04 0 00 042527 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21682	042527	324 00 0 00 042530 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21683									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21684									;IN THE SUBTEST) TO LOOP ON ERROR^
 21685
 21686					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 52
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21687					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21688					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21689					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21690					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21691
 21692	042530	400 00 0 00 000000 	B32700:	SETZ			;PRELOAD AC WITH 0		
 21693	042531	544 00 0 00 070254 		HLR	[-1]		;*HLR SHOULD PLACE 0,,-1 INTO THE AC
 21694	042532	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21695						STOP^
 21696	042533	254 04 0 00 042534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21697	042534	324 00 0 00 042535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21698									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21699									;IN THE SUBTEST) TO LOOP ON ERROR^
 21700
 21701					;*****     FAILURE ANALYSIS     *****
 21702					;C(AC0)		C(AC1)		FAILING SIGNAL
 21703
 21704					;0				SW: FCE
 21705					;-1,,-1				FC: AD LT FM + EN
 21706					;0				ET2: AR RT AR LT EN
 21707
 21708					;**********
 21709
 21710					;THIS TEST VERIFIES THAT HRLI PLACES E INTO
 21711					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 21712					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21713					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 21714
 21715	042535	400 00 0 00 000000 	B33000:	SETZ			;PRELOAD AC WITH -1,,-1		
 21716	042536	505 00 0 00 777777 		HRLI	-1		;*HRLI SHOULD PLACE -1,,-1 INTO THE AC
 21717	042537	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,-1
 21718						STOP^
 21719	042540	254 04 0 00 042541 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21720	042541	324 00 0 00 042542 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21721									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21722									;IN THE SUBTEST) TO LOOP ON ERROR^
 21723
 21724					;*****     FAILURE ANALYSIS     *****
 21725					;C(AC0)		C(AC1)		FAILING SIGNAL
 21726
 21727					;-1,,-1				FC: AD RT FM + EN
 21728					;0				ET2: AR LT AR RT EN
 21729
 21730					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 53
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21731					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21732					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21733					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21734					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21735
 21736	042542	400 00 0 00 000000 	B33100:	SETZ			;PRELOAD AC WITH -1,,-1		
 21737	042543	544 00 0 00 070331 		HLR	[XWD -1,0]	;*HLR SHOULD PLACE -1,,-1 INTO THE AC
 21738	042544	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21739						STOP^
 21740	042545	254 04 0 00 042546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21741	042546	324 00 0 00 042547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21742									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21743									;IN THE SUBTEST) TO LOOP ON ERROR^
 21744
 21745					;**********
 21746
 21747					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21748					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21749					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21750					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21751
 21752	042547	400 00 0 00 000000 	B33200:	SETZ			;PRELOAD AC WITH 0		
 21753	042550	504 00 0 00 070331 		HRL	[XWD -1,0]	;*HRL SHOULD PLACE 0 INTO THE AC
 21754	042551	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21755						STOP^
 21756	042552	254 04 0 00 042553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21757	042553	324 00 0 00 042554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21758									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21759									;IN THE SUBTEST) TO LOOP ON ERROR^
 21760
 21761					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 54
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21762					;THIS TEST VERIFIES THAT HLRI ALWAYS CLEARS THE RIGHT HALF
 21763					;OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21764					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21765					;SHOULD BE 0.  THE AC IS CHECKED FOR 0
 21766					;IF C(AC)=0, THIS TEST PASSES.
 21767
 21768	042554	400 00 0 00 000000 	B33300:	SETZ			;PRELOAD AC WITH 0		
 21769	042555	545 00 0 00 777777 		HLRI	-1		;*HLRI SHOULD PLACE 0 INTO THE AC
 21770	042556	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21771						STOP^
 21772	042557	254 04 0 00 042560 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21773	042560	324 00 0 00 042561 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21774									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21775									;IN THE SUBTEST) TO LOOP ON ERROR^
 21776
 21777					;*****     FAILURE ANALYSIS     *****
 21778					;C(AC0)		C(AC1)		FAILING SIGNAL
 21779
 21780					;-1,,0				FC:AD LT FM + EN
 21781
 21782					;**********
 21783
 21784					;THIS TEST VERIFIES THAT HRLI PLACES E INTO
 21785					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED.
 21786					;IN THIS CASE C(AC)=-1,,-1 AND E=-1,,-1.  HENCE, THE RESULT IN THE AC
 21787					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 21788
 21789	042561	474 00 0 00 000000 	B33400:	SETO			;PRELOAD AC WITH -1,,-1		
 21790	042562	505 00 0 00 777777 		HRLI	-1		;*HRLI SHOULD PLACE -1,,-1 INTO THE AC
 21791	042563	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21792						STOP^
 21793	042564	254 04 0 00 042565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21794	042565	324 00 0 00 042566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21795									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21796									;IN THE SUBTEST) TO LOOP ON ERROR^
 21797
 21798					;*****     FAILURE ANALYSIS     *****
 21799					;C(AC0)		C(AC1)		FAILING SIGNAL
 21800
 21801					;-1,,0				ET2: AR RT AD EN
 21802
 21803
 21804					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 55
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21805					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21806					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21807					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21808					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21809
 21810	042566	474 00 0 00 000000 	B33500:	SETO			;PRELOAD AC WITH -1,,-1		
 21811	042567	544 00 0 00 070331 		HLR	[XWD -1,0]	;*HLR SHOULD PLACE -1,,-1 INTO THE AC
 21812	042570	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21813						STOP^
 21814	042571	254 04 0 00 042572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21815	042572	324 00 0 00 042573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21816									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21817									;IN THE SUBTEST) TO LOOP ON ERROR^
 21818
 21819					;**********
 21820
 21821					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21822					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21823					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 21824					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21825
 21826	042573	474 00 0 00 000000 	B33600:	SETO			;PRELOAD AC WITH -1,,-1		
 21827	042574	504 00 0 00 070331 		HRL	[XWD -1,0]	;*HRL SHOULD PLACE 0,,-1 INTO THE AC
 21828	042575	312 00 0 00 070330 		CAME	[XWD 0,-1]	;PASS IF C(AC)=0,,-1
 21829						STOP^
 21830	042576	254 04 0 00 042577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21831	042577	324 00 0 00 042600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21832									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21833									;IN THE SUBTEST) TO LOOP ON ERROR^
 21834
 21835					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 56
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21836					;THIS TEST VERIFIES THAT HLRI ALWAYS CLEARS THE RIGHT HALF
 21837					;OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21838					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 21839					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0
 21840					;IF C(AC)=-1,,0, THIS TEST PASSES.
 21841
 21842	042600	474 00 0 00 000000 	B33700:	SETO			;PRELOAD AC WITH -1,,-1		
 21843	042601	545 00 0 00 777777 		HLRI	-1		;*HLRI SHOULD PLACE -1,,0 INTO THE AC
 21844	042602	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21845						STOP^
 21846	042603	254 04 0 00 042604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21847	042604	324 00 0 00 042605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21848									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21849									;IN THE SUBTEST) TO LOOP ON ERROR^
 21850
 21851					;*****     FAILURE ANALYSIS     *****
 21852					;C(AC0)		C(AC1)		FAILING SIGNAL
 21853
 21854					;0				ET2: AR LT AD EN
 21855
 21856					;**********
 21857
 21858					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21859					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21860					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21861					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21862
 21863	042605	201 00 0 00 777777 	B34000:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21864	042606	504 00 0 00 070253 		HRL	[0]		;*HRL SHOULD PLACE 0,,-1 INTO THE AC
 21865	042607	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21866						STOP^
 21867	042610	254 04 0 00 042611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21868	042611	324 00 0 00 042612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21869									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21870									;IN THE SUBTEST) TO LOOP ON ERROR^
 21871
 21872					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21873					;THIS TEST VERIFIES THAT HLRI ALWAYS CLEARS THE RIGHT HALF
 21874					;OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21875					;IN THIS CASE, C(AC)=0,,-1 AND E=0.  HENCE, THE RESULT IN THE AC
 21876					;SHOULD BE 0.  THE AC IS CHECKED FOR 0
 21877					;IF C(AC)=0, THIS TEST PASSES.
 21878
 21879	042612	201 00 0 00 777777 	B34100:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21880	042613	545 00 0 00 000000 		HLRI			;*HLRI SHOULD PLACE 0 INTO THE AC
 21881	042614	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 21882						STOP^
 21883	042615	254 04 0 00 042616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21884	042616	324 00 0 00 042617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21885									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21886									;IN THE SUBTEST) TO LOOP ON ERROR^
 21887
 21888					;**********
 21889
 21890					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21891					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21892					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21893					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21894
 21895	042617	201 00 0 00 777777 	B34200:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21896	042620	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,-1 INTO THE AC
 21897	042621	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21898						STOP^
 21899	042622	254 04 0 00 042623 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21900	042623	324 00 0 00 042624 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21901									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21902									;IN THE SUBTEST) TO LOOP ON ERROR^
 21903
 21904					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 58
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21905					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21906					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21907					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21908					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 21909
 21910	042624	201 00 0 00 777777 	B34300:	MOVEI	-1		;PRELOAD AC WITH 0,,-1	
 21911	042625	544 00 0 00 070254 		HLR	[-1]		;*HLR SHOULD PLACE 0,,-1 INTO THE AC
 21912	042626	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 21913						STOP^
 21914	042627	254 04 0 00 042630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21915	042630	324 00 0 00 042631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21916									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21917									;IN THE SUBTEST) TO LOOP ON ERROR^
 21918
 21919					;**********
 21920
 21921					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21922					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21923					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21924					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 21925
 21926	042631	205 00 0 00 777777 	B34400:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21927	042632	504 00 0 00 070253 		HRL	[0]		;*HRL SHOULD PLACE 0 INTO THE AC
 21928	042633	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0
 21929						STOP^
 21930	042634	254 04 0 00 042635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21931	042635	324 00 0 00 042636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21932									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21933									;IN THE SUBTEST) TO LOOP ON ERROR^
 21934
 21935					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 59
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21936					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21937					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21938					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 21939					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21940
 21941	042636	205 00 0 00 777777 	B34500:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21942	042637	544 00 0 00 070253 		HLR	[0]		;*HLR SHOULD PLACE -1,,0 INTO THE AC
 21943	042640	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21944						STOP^
 21945	042641	254 04 0 00 042642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21946	042642	324 00 0 00 042643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21947									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21948									;IN THE SUBTEST) TO LOOP ON ERROR^
 21949
 21950					;**********
 21951
 21952					;THIS TEST VERIFIES THAT HRL PLACES THE RIGHT HALF OF C(E) INTO
 21953					;THE LEFT HALF OF THE AC.  THE RIGHT HALF OF THE AC IS UNAFFECTED
 21954					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 21955					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 21956
 21957	042643	205 00 0 00 777777 	B34600:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21958	042644	504 00 0 00 070254 		HRL	[-1]		;*HRL SHOULD PLACE -1,,0 INTO THE AC
 21959	042645	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 21960						STOP^
 21961	042646	254 04 0 00 042647 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21962	042647	324 00 0 00 042650 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21964									;IN THE SUBTEST) TO LOOP ON ERROR^
 21965
 21966					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 60
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 21967					;THIS TEST VERIFIES THAT HLR PLACES THE LEFT HALF OF C(E) INTO
 21968					;THE RIGHT HALF OF THE AC.  THE LEFT HALF OF THE AC IS UNAFFECTED.
 21969					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=-1,,-1  HENCE, THE RESULT IN THE AC
 21970					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 21971
 21972	042650	205 00 0 00 777777 	B34700:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 21973	042651	544 00 0 00 070254 		HLR	[-1]		;*HLR SHOULD PLACE -1,,-1 INTO THE AC
 21974	042652	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 21975						STOP^
 21976	042653	254 04 0 00 042654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21977	042654	324 00 0 00 042655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21979									;IN THE SUBTEST) TO LOOP ON ERROR^
 21980
 21981					;**********
 21982
 21983					;THIS TEST VERIFIES THAT HLLM PLACES THE LEFT HALF OF C(AC) INTO
 21984					;THE LEFT HALF OF E.  THE RIGHT HALF OF E IS UNAFFECTED.
 21985					;IN THIS CASE, AC=E AND C(AC)= C(E)=0.  HENCE, THE RESULT IN E
 21986					;SHOULD BE 0.  E IS CHECKED FOR 0.  IF C(E)=0, THIS TEXT PASSES.
 21987
 21988	042655	400 00 0 00 000000 	B35000:	SETZ			;PRELOAD AC,E WITH 0
 21989	042656	502 00 0 00 000000 		HLLM			;*HLLM SHOULD PLACE 0 INTO E
 21990	042657	332 00 0 00 000000 		SKIPE			;PASS IF C(E)=0
 21991						STOP^
 21992	042660	254 04 0 00 042661 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 21993	042661	324 00 0 00 042662 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 21994									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 21995									;IN THE SUBTEST) TO LOOP ON ERROR^
 21996
 21997					;*****     FAILURE ANALYSIS     *****
 21998					;C(AC0)		C(AC1)		FAILING SIGNAL
 21999
 22000					;-1,,0		0		FC: AD FM + EN
 22001					;0,,-1		0,,-1		ET0: AD RT BR + EN
 22002					;B35000		0,,-1		ET0: BR AR EN
 22003					;-1,,0		0,,-1		ET0: AD LT AR + EN
 22004
 22005					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 61
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22006					;THIS TEST VERIFIES THAT HLLM PLACES THE LEFT HALF OF C(AC) INTO
 22007					;THE LEFT HALF OF E.  THE RIGHT HALF OF E IS UNAFFECTED.
 22008					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 22009					;SHOULD BE 0,,-1.  E IS CHECKED FOR 0,,-1. IF C(E)=0,,-1, THIS TEST PASSES.
 22010
 22011	042662	400 00 0 00 000000 	B35500:	SETZ			;PRELOAD AC WITH 0
 22012	042663	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 22013	042664	502 00 0 00 000001 		HLLM	1		;*HLLM SHOULD PLACE 0,,-1 INTO E
 22014	042665	302 01 0 00 777777 		CAIE	1,- 1		;PASS IF C(E) =0,,-1
 22015						STOP^
 22016	042666	254 04 0 00 042667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22017	042667	324 00 0 00 042670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22018									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22019									;IN THE SUBTEST) TO LOOP ON ERROR^
 22020
 22021					;*****     FAILURE ANALYSIS     *****
 22022					;C(AC0)		C(AC1)		FAILING SIGNAL
 22023
 22024					;0		-1,,-1		SW: FCE PSE
 22025					;0		0		SW: ET0
 22026					;0		-1,,-1		ET0: AR AD EN
 22027					;0		0		ET2: AR LT AD EN
 22028
 22029					;**********
 22030
 22031					;THIS TEST VERIFIES THAT HLLM PLACES THE LEFT HALF OF C(AC) INTO
 22032					;THE LEFT HALF OF E.  THE RIGHT HALF OF E IS UNAFFECTED.
 22033					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN E
 22034					;SHOULD BE -1,,0.  E IS CHECKED FOR -1,,0. IF C(E)=-1,,0, THIS TEST PASSES
 22035
 22036	042670	474 00 0 00 000000 	B35600:	SETO			;PRELOAD AC WITH -1,,-1
 22037	042671	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0
 22038	042672	502 00 0 00 000001 		HLLM	1		;*HLLM SHOULD PLACE -1,,0 INTO E
 22039	042673	312 01 0 00 070331 		CAME	1,[XWD -1,0]	;PASS IF C(E) = -1,,0
 22040						STOP^
 22041	042674	254 04 0 00 042675 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22042	042675	324 00 0 00 042676 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22044									;IN THE SUBTEST) TO LOOP ON ERROR^
 22045
 22046					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 62
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22047					;THIS TEST VERIFIES THAT HRRM PLACES THE RIGHT HALF OF C(AC) INTO
 22048					;THE RIGHT HALF OF E.  THE LEFT HALF OF E IS UNAFFECTED.
 22049					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 22050					;SHOULD BE -1,,0.  E IS CHECKED FOR -1,,0
 22051					;IF C(E) = -1,,0, THIS TEST PASSES.
 22052
 22053	042676	400 00 0 00 000000 	B35700:	SETZ			;PRELOAD AC WITH 0
 22054	042677	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 22055	042700	542 00 0 00 000001 		HRRM	1		;*HRRM SHOULD PLACE -1,,0 INTO E
 22056	042701	312 01 0 00 070331 		CAME	1,[XWD -1,0]	;PASS IF C(E) = -1,,0
 22057						STOP^
 22058	042702	254 04 0 00 042703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22059	042703	324 00 0 00 042704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22060									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22061									;IN THE SUBTEST) TO LOOP ON ERROR^
 22062
 22063					;*****     FAILURE ANALYSIS     *****
 22064					;C(AC0)		C(AC1)		FAILING SIGNAL
 22065
 22066					;0		-1,,-1		SW: FCE PSE
 22067					;0		0		SW: ET0
 22068					;0		-1,,-1		FC: AD FM + EN
 22069					;-1,,-1		-1,,-1		ET0: AD LT BR + EN
 22070					;0		-1,,-1		ET0: AD RT AR + EN
 22071					;0		0		ET0: BR AR EN
 22072					;0		-1,,-1		ET0: AR AD EN
 22073					;0		0		ET2: AR AD EN
 22074
 22075					;**********
 22076
 22077					;THIS TEST VERIFIES THAT HRRM PLACES THE RIGHT HALF OF C(AC) INTO
 22078					;THE RIGHT HALF OF E.  THE LEFT HALF OF E IS UNAFFECTED.
 22079					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN E
 22080					;SHOULD BE 0,,-1.  E IS CHECKED FOR = 0,,-1
 22081					;IF C(E) = 0,,-1, THIS TEST PASSES.
 22082
 22083	042704	474 00 0 00 000000 	B36000:	SETO			;PRELOAD AC WITH -1,,-1
 22084	042705	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0
 22085	042706	542 00 0 00 000001 		HRRM	1		;*HRRM SHOULD PLACE 0,,-1 INTO E
 22086	042707	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E) = 0,,-1
 22087						STOP^
 22088	042710	254 04 0 00 042711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22089	042711	324 00 0 00 042712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22091									;IN THE SUBTEST) TO LOOP ON ERROR^
 22092
 22093					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 63
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22094					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22095					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22096					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE THE RESULT IN THE AC
 22097					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22098
 22099	042712	474 00 0 00 000000 	B36100:	SETO			;PRELOAD AC WITH -1,,-1
 22100	042713	520 00 0 00 000000 		HLLO			;*HLLO SHOULD PLACE -1,,-1 INTO THE AC
 22101	042714	312 00 0 00 070254 		CAME	[-1]		;PASS OF C(AC)=-1,,-1
 22102						STOP^
 22103	042715	254 04 0 00 042716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22104	042716	324 00 0 00 042717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22105									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22106									;IN THE SUBTEST) TO LOOP ON ERROR^
 22107
 22108					;*****     FAILURE ANALYSIS     *****
 22109					;C(AC0)		C(AC1)		FAILING SIGNAL
 22110
 22111					;0,,-1				SW: FCE
 22112
 22113					;**********
 22114
 22115					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22116					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22117					;IN THIS CASE, C(AC)=0 AND C(E)=0,,-1.  HENCE THE RESULT IN THE AC
 22118					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22119
 22120	042717	400 00 0 00 000000 	B36200:	SETZ			;PRELOAD AC WITH 0
 22121	042720	520 00 0 00 070330 		HLLO	[XWD 0,-1]	;*HLLO SHOULD PLACE 0,,-1 INTO THE AC
 22122	042721	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22123						STOP^
 22124	042722	254 04 0 00 042723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22125	042723	324 00 0 00 042724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22126									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22127									;IN THE SUBTEST) TO LOOP ON ERROR^
 22128
 22129					;*****     FAILURE ANALYSIS     *****
 22130					;C(AC0)		C(AC1)		FAILING SIGNAL
 22131
 22132					;-1,,-1				FC: AD LT AR + EN
 22133
 22134					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 64
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22135					;THIS TEST VERIFIES THAT HRRO PLACES THE RIGHT HALF OF C(E) INTO
 22136					;THE RIGHT HALF OF THE AC AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22137					;IN THIS CASE, AC=E AND C(AC)=C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC
 22138					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22139
 22140	042724	474 00 0 00 000000 	B36300:	SETO			;PRELOAD AC,E WITH -1,,-1
 22141	042725	560 00 0 00 000000 		HRRO			;*HRRO SHOULD PLACE -1,,-1 INTO THE AC
 22142	042726	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22143						STOP^
 22144	042727	254 04 0 00 042730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22145	042730	324 00 0 00 042731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22146									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22147									;IN THE SUBTEST) TO LOOP ON ERROR^
 22148
 22149					;*****     FAILURE ANALYSIS     *****
 22150					;C(AC0)		C(AC1)		FAILING SIGNAL
 22151
 22152					;-1,,0				SW: FCE
 22153
 22154					;**********
 22155
 22156					;THIS TEST VERIFIES THAT HRRO PLACES THE RIGHT HALF OF C(E) INTO
 22157					;THE RIGHT HALF OF THE AC AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22158					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 22159					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 22160
 22161	042731	400 00 0 00 000000 	B36400:	SETZ			;PRELOAD AC WITH 0
 22162	042732	560 00 0 00 070331 		HRRO	[XWD -1,0]	;*HRRO SHOULD PLACE -1,,0 INTO THE AC
 22163	042733	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 22164						STOP^
 22165	042734	254 04 0 00 042735 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22166	042735	324 00 0 00 042736 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22168									;IN THE SUBTEST) TO LOOP ON ERROR^
 22169
 22170					;*****     FAILURE ANALYSIS     *****
 22171					;C(AC0)		C(AC1)		FAILING SIGNAL
 22172
 22173					;-1,,-1				FC: AD RT AR + EN
 22174
 22175					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 65
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22176					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22177					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22178					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE THE RESULT IN THE AC
 22179					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22180
 22181	042736	400 00 0 00 000000 	B36500:	SETZ			;PRELOAD AC WITH 0
 22182	042737	520 00 0 00 070253 		HLLO	[0]		;*HLLO SHOULD PLACE 0,,-1 INTO THE AC
 22183	042740	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22184						STOP^
 22185	042741	254 04 0 00 042742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22186	042742	324 00 0 00 042743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22187									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22188									;IN THE SUBTEST) TO LOOP ON ERROR^
 22189
 22190					;*****     FAILURE ANALYSIS     *****
 22191					;C(AC0)		C(AC1)		FAILING SIGNAL
 22192
 22193					;0				ET2: AR LT AD EN
 22194
 22195					;**********
 22196
 22197					;THIS TEST VERIFIES THAT HRRO PLACES THE RIGHT HALF OF C(E) INTO
 22198					;THE RIGHT HALF OF THE AC AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22199					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC
 22200					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 22201
 22202	042743	400 00 0 00 000000 	B36600:	SETZ			;PRELOAD AC WITH 0
 22203	042744	560 00 0 00 070253 		HRRO	[0]		;*HRRO SHOULD PLACE -1,,0 INTO THE AC
 22204	042745	312 00 0 00 070331 		CAME	[-1,,0]		;PASS IF C(AC)=-1,,0
 22205						STOP^
 22206	042746	254 04 0 00 042747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22207	042747	324 00 0 00 042750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22208									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22209									;IN THE SUBTEST) TO LOOP ON ERROR^
 22210
 22211					;*****     FAILURE ANALYSIS     *****
 22212					;C(AC0)		C(AC1)		FAILING SIGNAL
 22213
 22214					;0				ET2: AR AD EN
 22215
 22216					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 66
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22217					;THIS TEST VERIFIES THAT HLLOI ALWAYS PLACES 0,,-1 INTO THE AC.
 22218					;IN THIS CASE, C(AC)=0 AND E=0.
 22219					;THE RESULT IN THE AC SHOULD BE 0,,-1.
 22220					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 22221
 22222	042750	400 00 0 00 000000 	B37100:	SETZ			;PRELOAD AC WITH 0
 22223	042751	521 00 0 00 000000 		HLLOI			;*HLLOI SHOULD PLACE 0,,-1 INTO THE AC
 22224	042752	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22225						STOP^
 22226	042753	254 04 0 00 042754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22227	042754	324 00 0 00 042755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22228									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22229									;IN THE SUBTEST) TO LOOP ON ERROR^
 22230
 22231					;*****     FAILURE ANALYSIS     *****
 22232					;C(AC0)		C(AC1)		FAILING SIGNAL
 22233
 22234					;-1,,-1				FC: AD LT AR + EN
 22235					;0				ET2: AR AD EN
 22236
 22237					;**********
 22238
 22239					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22240					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22241					;IN THIS CASE, C(AC)=0 AND E=0.  HENCE, THE RESULT IN THE AC
 22242					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1, THIS TEST PASSES
 22243
 22244	042755	400 00 0 00 000000 	B37200:	SETZ			;PRELOAD AC WITH 0
 22245	042756	561 00 0 00 000000 		HRROI			;*HRROI SHOULD PLACE -1,,0 INTO THE AC
 22246	042757	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 22247						STOP^
 22248	042760	254 04 0 00 042761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22249	042761	324 00 0 00 042762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22250									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22251									;IN THE SUBTEST) TO LOOP ON ERROR^
 22252
 22253					;*****     FAILURE ANALYSIS     *****
 22254					;C(AC0)		C(AC1)		FAILING SIGNAL
 22255
 22256					;-1,,-1				FC: AD RT AR + EN
 22257					;0				ET2: AR AD EN
 22258
 22259					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 67
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22260					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22261					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22262					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE THE RESULT IN THE AC
 22263					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22264
 22265	042762	400 00 0 00 000000 	B37300:	SETZ			;PRELOAD AC WITH 0
 22266	042763	520 00 0 00 070331 		HLLO	[XWD -1,0]	;*HLLO SHOULD PLACE -1,,-1 INTO THE AC
 22267	042764	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22268						STOP^
 22269	042765	254 04 0 00 042766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22270	042766	324 00 0 00 042767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22271									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22272									;IN THE SUBTEST) TO LOOP ON ERROR^
 22273
 22274					;**********
 22275
 22276					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22277					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22278					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 22279					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22280
 22281	042767	400 00 0 00 000000 	B37400:	SETZ			;PRELOAD AC WITH 0
 22282	042770	561 00 0 00 777777 		HRROI	-1		;*HRRIO SHOULD PLACE -1,,-1 INTO THE AC
 22283	042771	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22284						STOP^
 22285	042772	254 04 0 00 042773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22286	042773	324 00 0 00 042774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22287									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22288									;IN THE SUBTEST) TO LOOP ON ERROR^
 22289
 22290					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 68
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22291					;THIS TEST VERIFIES THAT HLLOI ALWAYS PLACES 0,,-1 INTO THE AC.
 22292					;IN THIS CASE, C(AC)=0 AND E=0.
 22293					;THE RESULT IN THE AC SHOULD BE 0,,-1.
 22294					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES
 22295
 22296	042774	474 00 0 00 000000 	B37500:	SETO			;PRELOAD AC WITH -1,,-1
 22297	042775	521 00 0 00 000000 		HLLOI			;*HLLOI SHOULD PLACE 0,,-1 INTO THE AC
 22298	042776	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22299						STOP^
 22300	042777	254 04 0 00 043000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22301	043000	324 00 0 00 043001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22302									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22303									;IN THE SUBTEST) TO LOOP ON ERROR^
 22304
 22305					;**********
 22306
 22307					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22308					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22309					;IN THIS CASE, C(AC)=0 AND E=0.  HENCE, THE RESULT IN THE AC
 22310					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 22311
 22312	043001	474 00 0 00 000000 	B37600:	SETO			;PRELOAD AC WITH -1,,-1
 22313	043002	561 00 0 00 000000 		HRROI			;*HRRIO SHOULD PLACE -1,,0 INTO THE AC
 22314	043003	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 22315						STOP^
 22316	043004	254 04 0 00 043005 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22317	043005	324 00 0 00 043006 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22318									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22319									;IN THE SUBTEST) TO LOOP ON ERROR^
 22320
 22321					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 69
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22322					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22323					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22324					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE THE RESULT IN THE AC
 22325					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22326
 22327	043006	474 00 0 00 000000 	B37700:	SETO			;PRELOAD AC WITH -1,,-1
 22328	043007	520 00 0 00 070331 		HLLO	[XWD -1,0]	;*HLLO SHOULD PLACE -1,,-1 INTO THE AC
 22329	043010	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22330						STOP^
 22331	043011	254 04 0 00 043012 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22332	043012	324 00 0 00 043013 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22333									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22334									;IN THE SUBTEST) TO LOOP ON ERROR^
 22335
 22336					;**********
 22337
 22338					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22339					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22340					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.  HENCE, THE RESULT IN THE AC
 22341					;SHOULD BE -1,,-1.  THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22342
 22343	043013	474 00 0 00 000000 	B40000:	SETO			;PRELOAD AC WITH -1,,-1
 22344	043014	561 00 0 00 777777 		HRROI	-1		;*HRRIO SHOULD PLACE -1,,-1 INTO THE AC
 22345	043015	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22346						STOP^
 22347	043016	254 04 0 00 043017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22348	043017	324 00 0 00 043020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22349									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22350									;IN THE SUBTEST) TO LOOP ON ERROR^
 22351
 22352					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 70
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22353					;THIS TEST VERIFIES THAT HRROI PLACES E INTO THE RIGHT HALF OF THE AC
 22354					;AND PLACES ONES INTO THE LEFT HALF OF THE AC.
 22355					;IN THIS CASE, C(AC)=0,,-1 AND E=0.  HENCE, THE RESULT IN THE AC
 22356					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES
 22357
 22358	043020	201 00 0 00 777777 	B40100:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 22359	043021	561 00 0 00 000000 		HRROI			;*HRRIO SHOULD PLACE -1,,0 INTO THE AC
 22360	043022	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0
 22361						STOP^
 22362	043023	254 04 0 00 043024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22363	043024	324 00 0 00 043025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22364									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22365									;IN THE SUBTEST) TO LOOP ON ERROR^
 22366
 22367					;**********
 22368
 22369					;THIS TEST VERIFIES THAT HLLO PLACES THE LEFT HALF OF C(E) INTO
 22370					;THE LEFT HALF OF THE AC AND PLACES ONES INTO THE RIGHT HALF OF THE AC.
 22371					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE THE RESULT IN THE AC
 22372					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22373
 22374	043025	205 00 0 00 777777 	B40200:	MOVSI	-1		;PRELOAD AC WITH -1,,0	
 22375	043026	520 00 0 00 070330 		HLLO	[XWD 0,-1]	;*HLLO SHOULD PLACE 0,,-1 INTO THE AC
 22376	043027	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22377						STOP^
 22378	043030	254 04 0 00 043031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22379	043031	324 00 0 00 043032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22380									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22381									;IN THE SUBTEST) TO LOOP ON ERROR^
 22382
 22383					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 71
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22384					;THIS TEST VERIFIES THAT HRLZ PLACES THE RIGHT HALF OF C(E)
 22385					;INTO THE LEFT HALF OF THE AC.
 22386					;AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 22387					;IN THIS CASE, AC=E AND C(AC)=C(E)=0. HENCE, THE FINAL RESULT IN THE AC
 22388					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22389
 22390	043032	400 00 0 00 000000 	B40300:	SETZ			;PRELOAD AC WITH 0
 22391	043033	514 00 0 00 000000 		HRLZ			;*HRLZ SHOULD PLACE 0 INTO THE AC
 22392	043034	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22393						STOP^
 22394	043035	254 04 0 00 043036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22395	043036	324 00 0 00 043037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22396									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22397									;IN THE SUBTEST) TO LOOP ON ERROR^
 22398
 22399					;**********
 22400
 22401					;THIS TEST VERIFIES THAT HLRZ PLACES THE LEFT HALF OF C(E)
 22402					;INTO THE RIGHT HALF OF THE AC
 22403					;AND PLACES ZEROS INTO THE LEFT HALF OF THE AC.
 22404					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC
 22405					;SHOULD BE 0.  THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22406
 22407	043037	400 00 0 00 000000 	B40400:	SETZ			;PRELOAD AC WITH 0
 22408	043040	554 00 0 00 000000 		HLRZ			;*HLRZ SHOULD PLACE 0 INTO THE AC
 22409	043041	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22410						STOP^
 22411	043042	254 04 0 00 043043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22412	043043	324 00 0 00 043044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22413									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22414									;IN THE SUBTEST) TO LOOP ON ERROR^
 22415
 22416					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 72
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22417					;THIS TEST VERIFIES THAT HRLZI PLACES E INTO THE LEFT HALF OF THE AC
 22418					;AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 22419					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE THE RESULT IN THE AC
 22420					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0
 22421					;IF C(AC)=-1,,0, THIS TEST PASSES.
 22422
 22423	043044	400 00 0 00 000000 	B40700:	SETZ			;PRELOAD AC WITH 0		
 22424	043045	515 00 0 00 777777 		HRLZI	-1		;*HRLZI SHOULD PLACE -1,,0 INTO THE AC
 22425	043046	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 22426						STOP^
 22427	043047	254 04 0 00 043050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22428	043050	324 00 0 00 043051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22429									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22430									;IN THE SUBTEST) TO LOOP ON ERROR^
 22431
 22432					;*****     FAILURE ANALYSIS     *****
 22433					;C(AC0)		C(AC1)		FAILING SIGNAL
 22434
 22435					;0				ET2: AR LT AR RT EN
 22436
 22437					;**********
 22438
 22439					;THIS TEST VERIFIES THAT HLRZ PLACES THE LEFT HALF OF C(E)
 22440					;INTO THE RIGHT HALF OF THE AC
 22441					;AND PLACES ZEROS INTO THE LEFT HALF OF THE AC.
 22442					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 22443					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22444
 22445	043051	400 00 0 00 000000 	B41000:	SETZ			;PRELOAD AC WITH 0
 22446	043052	554 00 0 00 070331 		HLRZ	[XWD -1,0]	;*HLRZ SHOULD PLACE 0,,-1 INTO THE AC
 22447	043053	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22448						STOP^
 22449	043054	254 04 0 00 043055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22450	043055	324 00 0 00 043056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22452									;IN THE SUBTEST) TO LOOP ON ERROR^
 22453
 22454					;*****     FAILURE ANALYSIS     *****
 22455					;C(AC0)		C(AC1)		FAILING SIGNAL
 22456
 22457					;0				SW: FCE
 22458					;-1,,0				ET2: AR RT AR LT EN
 22459
 22460					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 73
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22461					;THIS TEST VERIFIES THAT HRLZI PLACES E INTO THE LEFT HALF OF THE AC
 22462					;AND PLACES ZEROS INTO THE RIGHT HALF OF THE AC.
 22463					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.  HENCE THE RESULT IN THE AC
 22464					;SHOULD BE -1,,0.  THE AC IS CHECKED FOR -1,,0.
 22465					;IF C(AC)=-1,,0, THIS TEST PASSES.
 22466
 22467	043056	474 00 0 00 000000 	B41100:	SETO			;PRELOAD AC WITH -1,,-1
 22468	043057	515 00 0 00 777777 		HRLZI	-1		;*HRLZI SHOULD PLACE -1,,0 INTO THE AC
 22469	043060	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(AC)=-1,,0.
 22470						STOP^
 22471	043061	254 04 0 00 043062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22472	043062	324 00 0 00 043063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22473									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22474									;IN THE SUBTEST) TO LOOP ON ERROR^
 22475
 22476					;**********
 22477
 22478					;THIS TEST VERIFIES THAT HLRZ PLACES THE LEFT HALF OF C(E)
 22479					;INTO THE RIGHT HALF OF THE AC
 22480					;AND PLACES ZEROS INTO THE LEFT HALF OF THE AC.
 22481					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC
 22482					;SHOULD BE 0,,-1.  THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST PASSES.
 22483
 22484	043063	474 00 0 00 000000 	B41200:	SETO			;PRELOAD AC WITH -1,,-1
 22485	043064	554 00 0 00 070331 		HLRZ	[XWD -1,0]	;*HLRZ SHOULD PLACE 0,,-1 INTO THE AC
 22486	043065	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC)=0,,-1
 22487						STOP^
 22488	043066	254 04 0 00 043067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22489	043067	324 00 0 00 043070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22491									;IN THE SUBTEST) TO LOOP ON ERROR^
 22492
 22493					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 74
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22494					;THIS TEST VERIFIES THAT HLLE PLACES THE LEFT HALF OF C(E)
 22495					;INTO THE LEFT HALF OF THE AC
 22496					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22497					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0
 22498					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22499
 22500	043070	400 00 0 00 000000 	B41500:	SETZ			;PRELOAD AC WITH 0		
 22501	043071	530 00 0 00 000000 		HLLE			;*HLLE SHOULD PLACE 0 INTO THE AC
 22502	043072	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22503						STOP^
 22504	043073	254 04 0 00 043074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22505	043074	324 00 0 00 043075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22507									;IN THE SUBTEST) TO LOOP ON ERROR^
 22508
 22509					;*****     FAILURE ANALYSIS     *****
 22510					;C(AC0)		C(AC1)		FAILING SIGNAL
 22511
 22512					;-1,,0				FC: AD LT AR + EN
 22513
 22514					;**********
 22515
 22516					;THIS TEST VERIFIES THAT HLLE PLACES THE LEFT HALF OF C(E)
 22517					;INTO THE LEFT HALF OF THE AC
 22518					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22519					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
 22520					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22521
 22522	043075	400 00 0 00 000000 	B41600:	SETZ			;PRELOAD AC WITH 0		
 22523	043076	530 00 0 00 070254 		HLLE	[-1]		;*HLLE SHOULD PLACE -1,,-1 INTO THE AC
 22524	043077	312 00 0 00 070254 		CAME	[XWD -1,-1]	;PASS IF C(AC)=-1,,-1
 22525						STOP^
 22526	043100	254 04 0 00 043101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22527	043101	324 00 0 00 043102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22529									;IN THE SUBTEST) TO LOOP ON ERROR^
 22530
 22531					;*****     FAILURE ANALYSIS     *****
 22532					;C(AC0)		C(AC1)		FAILING SIGNAL
 22533
 22534					;0				SW: FCE
 22535					;-1,,-1				ET2: AR LT AD EN
 22536					;-1,,0				ET2: AR0(1): AR RT AD EN
 22537
 22538					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 75
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22539					;THIS TEST VERIFIES THAT HRRE PLACES THE RIGHT HALF OF C(E)
 22540					;INTO THE RIGHT HALF OF THE AC.
 22541					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC.
 22542					;IN THIS CASE C(AC)=0 AND C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22543					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22544
 22545	043102	400 00 0 00 000000 	B42000:	SETZ			;PRELOAD AC WITH 0		
 22546	043103	570 00 0 00 070254 		HRRE	[-1]		;*HRRE SHOULD PLACE -1,,-1 INTO THE AC
 22547	043104	312 00 0 00 070254 		CAME	[-1,,-1]	;PASS IF C(AC)=-1,,-1
 22548						STOP^
 22549	043105	254 04 0 00 043106 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22550	043106	324 00 0 00 043107 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22552									;IN THE SUBTEST) TO LOOP ON ERROR^
 22553
 22554					;**********
 22555
 22556					;THIS TEST VERIFIES THAT HLLE PLACES THE LEFT HALF OF C(E)
 22557					;INTO THE LEFT HALF OF THE AC
 22558					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22559					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1
 22560					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22561
 22562	043107	400 00 0 00 000000 	B42200:	SETZ			;PRELOAD AC WITH 0		
 22563	043110	530 00 0 00 070331 		HLLE	[XWD -1,0]	;*HLLE SHOULD PLACE -1,,-1 INTO THE AC
 22564	043111	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22565						STOP^
 22566	043112	254 04 0 00 043113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22567	043113	324 00 0 00 043114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22569									;IN THE SUBTEST) TO LOOP ON ERROR^
 22570
 22571					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22572					;THIS TEST VERIFIES THAT HRRE PLACES THE RIGHT HALF OF C(E)
 22573					;INTO THE RIGHT HALF OF THE AC.
 22574					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC.
 22575					;IN THIS CASE, AC=E AND C(AC)=C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22576					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22577
 22578	043114	400 00 0 00 000000 	B42300:	SETZ			;PRELOAD AC,E WITH 0		
 22579	043115	570 00 0 00 000000 		HRRE			;*HRRE SHOULD PLACE 0 INTO THE AC
 22580	043116	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22581						STOP^
 22582	043117	254 04 0 00 043120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22583	043120	324 00 0 00 043121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22585									;IN THE SUBTEST) TO LOOP ON ERROR^
 22586
 22587					;*****     FAILURE ANALYSIS     *****
 22588					;C(AC0)		C(AC1)		FAILING SIGNAL
 22589
 22590					;E				SW: FCE
 22591					;-1,,0				ET2: AR RT AD EN
 22592					;0,,-1				ET2: AR18(1): AR LT AD EN
 22593					;0,,-1				FC: AR RT AR + EN
 22594
 22595					;**********
 22596
 22597					;THIS TEST VERIFIES THAT HRRE PLACES THE RIGHT HALF OF C(E)
 22598					;INTO THE RIGHT HALF OF THE AC.
 22599					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC.
 22600					;IN THIS CASE C(AC)=0 AND C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22601					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 22602
 22603	043121	400 00 0 00 000000 	B42500:	SETZ			;PRELOAD AC WITH 0		
 22604	043122	570 00 0 00 070331 		HRRE	[XWD -1,0]	;*HRRE SHOULD PLACE 0 INTO THE AC
 22605	043123	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22606						STOP^
 22607	043124	254 04 0 00 043125 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22608	043125	324 00 0 00 043126 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22609									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22610									;IN THE SUBTEST) TO LOOP ON ERROR^
 22611
 22612					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 77
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22613					;THIS TEST VERIFIES THAT HRREI PLACES E INTO THE RIGHT HALF OF THE AC
 22614					;AND PLACES THE LEFTMOST BIT OF E INTO ALL BITS OF THE LEFT HALF OF THE AC
 22615					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22616					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 22617
 22618	043126	400 00 0 00 000000 	B42700:	SETZ			;PRELOAD AC WITH 0		
 22619	043127	571 00 0 00 777777 		HRREI	-1		;*HRREI SHOULD PLACE -1,,-1 INTO THE AC
 22620	043130	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22621						STOP^
 22622	043131	254 04 0 00 043132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22623	043132	324 00 0 00 043133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22624									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22625									;IN THE SUBTEST) TO LOOP ON ERROR^
 22626
 22627					;*****     FAILURE ANALYSIS     *****
 22628					;C(AC0)		C(AC1)		FAILING SIGNAL
 22629
 22630					;-1,,0				ET2: AR RT AD EN
 22631					;0,,-1				ET2: AR18(1): AR LT AD EN
 22632
 22633					;**********
 22634
 22635					;THIS TEST VERIFIES THAT HLLEI ALWAYS CLEARS THE AC.
 22636					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,-1.
 22637					;THE RESULT IN THE AC SHOULD BE 0
 22638					;THE AC IS CHECKED FOR 0.
 22639					;IF C(AC)=0, THIS TEST PASSES.
 22640
 22641	043133	474 00 0 00 000000 	B43000:	SETO			;PRELOAD AC WITH -1,,-1
 22642	043134	531 00 0 00 777777 		HLLEI	-1		;*HLLEI SHOULD CLEAR THE AC
 22643	043135	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22644						STOP^
 22645	043136	254 04 0 00 043137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22646	043137	324 00 0 00 043140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22648									;IN THE SUBTEST) TO LOOP ON ERROR^
 22649
 22650					;*****     FAILURE ANALYSIS     *****
 22651					;C(AC0)		C(AC1)		FAILING SIGNAL
 22652
 22653					;-1,,0				FC: AD LT AR + EN
 22654					;0,,-1				ET2: AR LT AD EN
 22655
 22656					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22657					;THIS TEST VERIFIES THAT HLLEI ALWAYS CLEARS THE AC.
 22658					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,400000.
 22659					;THE RESULT IN THE AC SHOULD BE 0
 22660					;THE AC IS CHECKED FOR 0.
 22661					;IF C(AC) = ZERO, THIS TEST PASSES.
 22662
 22663	043140	474 00 0 00 000000 	B43100:	SETO			;PRELOAD AC WITH -1,,-1
 22664	043141	531 00 0 00 400000 		HLLEI	400000		;*HLLEI SHOULD CLEAR THE AC
 22665	043142	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0.
 22666						STOP^
 22667	043143	254 04 0 00 043144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22668	043144	324 00 0 00 043145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22669									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22670									;IN THE SUBTEST) TO LOOP ON ERROR^
 22671
 22672					;**********
 22673
 22674					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22675					;INTO THE LEFT HALF OF THE AC
 22676					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22677					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22678					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22679
 22680	043145	400 00 0 00 000000 	B43400:	SETZ			;PRELOAD AC WITH 0
 22681	043146	534 00 0 00 000000 		HRLE			;*HRLE SHOULD PLACE 0 INTO THE AC
 22682	043147	332 00 0 00 000000 		SKIPE			;FAIL IF C(AC)=0,,-1
 22683						STOP^
 22684	043150	254 04 0 00 043151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22685	043151	324 00 0 00 043152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22687									;IN THE SUBTEST) TO LOOP ON ERROR^
 22688
 22689					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 79
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22690					;THIS TEST VERIFIES THAT HRLEI PLACES E INTO THE LEFT HALF OF THE AC
 22691					;AND PLACES THE LEFTMOST BIT OF E INTO ALL BITS OF THE RIGHT HALF OF THE AC
 22692					;IN THIS CASE, C(AC)=0 AND E=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD -1,,-1
 22693					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=1,,-1, THIS TEST PASSES.
 22694
 22695	043152	400 00 0 00 000000 	B43500:	SETZ			;PRELOAD AC WITH 0		
 22696	043153	535 00 0 00 777777 		HRLEI	-1		;*HRLEI SHOULD PLACE -1,,-1 INTO THE AC
 22697	043154	312 00 0 00 070254 		CAME	[XWD -1,-1]	;PASS IF C(AC)=-1,,-1
 22698						STOP^
 22699	043155	254 04 0 00 043156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22700	043156	324 00 0 00 043157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22701									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22702									;IN THE SUBTEST) TO LOOP ON ERROR^
 22703
 22704					;*****     FAILURE ANALYSIS     *****
 22705					;C(AC0)		C(AC1)		FAILING SIGNAL
 22706
 22707					;-1,,0				ET2: AR LT AR RT EN
 22708					;-1,,0				ET2: AR 18(1): AR RT AD EN
 22709
 22710					;**********
 22711
 22712					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22713					;INTO THE LEFT HALF OF THE AC
 22714					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22715					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22716					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22717
 22718	043157	534 00 0 00 070253 	B43600:	HRLE	[0]		;*HRLE SHOULD PLACE 0 INTO THE AC	
 22719	043160	332 00 0 00 000000 		SKIPE			;FAIL IF C(AC)=0,,-1
 22720						STOP^
 22721	043161	254 04 0 00 043162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22722	043162	324 00 0 00 043163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22723									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22724									;IN THE SUBTEST) TO LOOP ON ERROR^
 22725
 22726					;*****     FAILURE ANALYSIS     *****
 22727					;C(AC0)		C(AC1)		FAILING SIGNAL
 22728
 22729					;E,,0				SW: FCE
 22730
 22731					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 80
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22732					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22733					;INTO THE LEFT HALF OF THE AC
 22734					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22735					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22736					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22737
 22738	043163	534 00 0 00 070254 	B43700:	HRLE	[-1]		;PRELOAD AC WITH 0	
 22739	043164	312 00 0 00 070254 		CAME	[-1]		;*HRLE SHOULD PLACE 0 INTO THE AC
 22740						STOP			^;FAIL IF C(AC)=0,,-1
 22741
 22742	043165	254 04 0 00 043166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22743	043166	324 00 0 00 043167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22744									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22745									;IN THE SUBTEST) TO LOOP ON ERROR
 22746
 22747					;*****     FAILURE ANALYSIS     *****
 22748					;C(AC0)		C(AC1)		FAILING SIGNAL
 22749
 22750					;-1,,0				ET2: AR LT AR RT EN
 22751					;-1,,0				ET2: AR18(1): AR RT AD EN
 22752
 22753					;**********
 22754
 22755					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22756					;INTO THE LEFT HALF OF THE AC
 22757					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22758					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22759					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22760
 22761	043167	534 00 0 00 070331 	B44000:	HRLE	[XWD -1,0]	;PRELOAD AC WITH 0
 22762	043170	332 00 0 00 000000 		SKIPE			;*HRLE SHOULD PLACE 0 INTO THE AC
 22763						STOP			^;FAIL IF C(AC)=0,,-1
 22764
 22765	043171	254 04 0 00 043172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22766	043172	324 00 0 00 043173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22767									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22768									;IN THE SUBTEST) TO LOOP ON ERROR
 22769
 22770					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 81
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22771					;THIS TEST VERIFIES THAT HRLE PLACES THE RIGHT HALF OF C(E)
 22772					;INTO THE LEFT HALF OF THE AC
 22773					;AND PLACES BIT 18 OF C(E) INTO ALL BITS OF THE RIGHT HALF OF THE AC.
 22774					;IN THIS CASE, C(AC)=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22775					;THE AC IS CHECKED FOR 0,,-1.  IF C(AC)=0,,-1, THIS TEST FAILS
 22776
 22777	043173	534 00 0 00 070330 	B44100:	HRLE	[XWD 0,-1]	;PRELOAD AC WITH 0
 22778	043174	312 00 0 00 070254 		CAME	[-1]		;*HRLE SHOULD PLACE 0 INTO THE AC
 22779						STOP			^;FAIL IF C(AC)=0,,-1
 22780
 22781	043175	254 04 0 00 043176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22782	043176	324 00 0 00 043177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22783									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22784									;IN THE SUBTEST) TO LOOP ON ERROR
 22785
 22786					;**********
 22787
 22788					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22789					;INTO THE RIGHT HALF OF THE AC
 22790					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22791					;IN THIS CASE, C(AC=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22792					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22793
 22794
 22795	043177	400 00 0 00 000000 	B44200:	SETZ			;PRELOAD AC WITH 0
 22796	043200	574 00 0 00 000000 		HLRE			;*HLRE SHOULD PLACE 0 INTO THE AC
 22797	043201	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22798						STOP^
 22799	043202	254 04 0 00 043203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22800	043203	324 00 0 00 043204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22801									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22802									;IN THE SUBTEST) TO LOOP ON ERROR^
 22803
 22804					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 82
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22805					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22806					;INTO THE RIGHT HALF OF THE AC
 22807					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22808					;IN THIS CASE, C(AC=0 AND C(E)=0.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22809					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22810
 22811
 22812	043204	400 00 0 00 000000 	B44300:	SETZ			;PRELOAD AC WITH 0
 22813	043205	574 00 0 00 070254 		HLRE	[-1]		;*HLRE SHOULD PLACE -1,,-1 INTO THE AC
 22814	043206	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1	
 22815						STOP^
 22816	043207	254 04 0 00 043210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22817	043210	324 00 0 00 043211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22818									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22819									;IN THE SUBTEST) TO LOOP ON ERROR^
 22820
 22821					;*****     FAILURE ANALYSIS     *****
 22822					;C(AC0)		C(AC1)		FAILING SIGNAL
 22823
 22824					;0				SW: FCE
 22825					;-1,,0				ET2: AR RT AR LT EN
 22826					;0,,-1				ET2: AR0(1): AR LT AD EN
 22827
 22828					;**********
 22829
 22830					;THIS TEST VERIFIES THAT HLREI CLEARS THE AC
 22831					;IN THIS CASE C(AC)=-1,,-1 AND E=0,,-1
 22832					;THE RESULT IN THE AC SHOULD BE 0
 22833					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THEN TEST PASSES
 22834
 22835	043211	474 00 0 00 000000 	B44500:	SETO			;PRELOAD AC WITH -1,,-1
 22836	043212	575 00 0 00 777777 		HLREI	-1		;*HLREI SHOULD CLEAR THE AC
 22837	043213	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22838						STOP^
 22839	043214	254 04 0 00 043215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22840	043215	324 00 0 00 043216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22841									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22842									;IN THE SUBTEST) TO LOOP ON ERROR^
 22843
 22844					;*****     FAILURE ANALYSIS     *****
 22845					;C(AC0)		C(AC1)		FAILING SIGNAL
 22846
 22847					;0,,1				ET2: AR RT AR LT EN
 22848
 22849					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 83
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22850					;THIS TEST VERIFIES THAT HLREI CLEARS THE AC
 22851					;IN THIS CASE C(AC)=0 AND E=0
 22852					;THE RESULT IN THE AC SHOULD BE 0
 22853					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THE TEST PASSES
 22854
 22855	043216	575 00 0 00 000000 	B44600:	HLREI			;*HLREI SHOULD CLEAR THE AC		
 22856	043217	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22857						STOP^
 22858	043220	254 04 0 00 043221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22859	043221	324 00 0 00 043222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22860									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22861									;IN THE SUBTEST) TO LOOP ON ERROR^
 22862
 22863					;**********
 22864
 22865					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22866					;INTO THE RIGHT HALF OF THE AC
 22867					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22868					;IN THIS CASE, C(E)=-1,,0.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22869					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22870
 22871
 22872	043222	574 00 0 00 070331 	B44700:	HLRE	[XWD -1,0]	;*HLRE SHOULD PLACE -1,,0 INTO THE AC
 22873	043223	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22874						STOP^
 22875	043224	254 04 0 00 043225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22876	043225	324 00 0 00 043226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22878									;IN THE SUBTEST) TO LOOP ON ERROR^
 22879
 22880					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 84
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22881					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22882					;INTO THE RIGHT HALF OF THE AC
 22883					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22884					;IN THIS CASE, C(E)=0,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE 0.
 22885					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES
 22886
 22887	043226	574 00 0 00 070330 	B45000:	HLRE	[XWD 0,-1]	;*HLRE SHOULD PLACE 0,,-1 INTO THE AC
 22888	043227	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0
 22889						STOP^
 22890	043230	254 04 0 00 043231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22891	043231	324 00 0 00 043232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22893									;IN THE SUBTEST) TO LOOP ON ERROR^
 22894
 22895					;**********
 22896
 22897					;THIS TEST VERIFIES THAT HLRE PLACES THE LEFT HALF OF C(E)
 22898					;INTO THE RIGHT HALF OF THE AC
 22899					;AND PLACES BIT 0 OF C(E) INTO ALL BITS OF THE LEFT HALF OF THE AC
 22900					;IN THIS CASE, C(E)=-1,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1.
 22901					;THE AC IS CHECKED FOR -1,,-1.  IF C(AC)=-1,,-1, THIS TEST PASSES
 22902
 22903	043232	574 00 0 00 070254 	B45100:	HLRE	[-1]		;*HLRE SHOULD PLACE -1,,-1 INTO THE AC
 22904	043233	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 22905						STOP^
 22906	043234	254 04 0 00 043235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22907	043235	324 00 0 00 043236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22908									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22909									;IN THE SUBTEST) TO LOOP ON ERROR^
 22910
 22911					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 85
DFKAA3	MAC	13-Jan-89 10:22		TEST OF HWT INSTRUCTIONS

 22912					;THIS TEST VERIFIES THAT HLREM PLACES THE LEFT HALF OF C(AC)
 22913					;INTO THE RIGHT HALF OF E
 22914					;AND PLACES BIT 0 OF C(AC) INTO ALL BITS OF THE LEFT HALF OF E.
 22915					;IN THIS CASE, C(AC)=1,,0 AND C(E)=0.  HENCE, THE RESULT IN E SHOULD BE -1,,-1.
 22916					;E IS CHECKED FOR -1,,-1.  IF C(E)=-1,,-1, THIS TEST PASSES
 22917
 22918	043236	400 00 0 00 000000 	B45200:	SETZ			;PRELOAD E WITH 0
 22919	043237	200 01 0 00 070331 		MOVE	1,[XWD -1,0]	;PRELOAD AC WITH -1,,0
 22920	043240	576 01 0 00 000000 		HLREM	1,		;*HLREM SHOULD PLACE -1,,-1 INTO E
 22921	043241	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(E)=-1,,-1
 22922						STOP^
 22923	043242	254 04 0 00 043243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22924	043243	324 00 0 00 043244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22925									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22926									;IN THE SUBTEST) TO LOOP ON ERROR^
 22927
 22928					;*****     FAILURE ANALYSIS     *****
 22929					;C(AC0)		C(AC1)		FAILING SIGNAL
 22930
 22931					;0		-1,,0		SW: SCE
 22932					;0		-1,,0		SW: ET0
 22933					;0		-1,,0		ET0: AR AD EN
 22934					;-1,,0		-1,,0		ET2: AR RT AR + EN
 22935					;0,,-1		-1,,0		ET2: AR0(1): AR LT AD EN
 22936
 22937					;**********
 22938
 22939					;THIS TEST VERIFIES THAT HRLM PLACES THE RIGHT HALF OF C(AC) INTO THE LEFT HALF OF E.
 22940					;THE RIGHT HALF OF E IS UNAFFECTED
 22941					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=0.  HENCE, THE RESULT IN E SHOULD BE -1,,0.
 22942					;E IS CHECKED FOR -1,,0.  IF C(E)=-1,,0, THIS  TEST PASSES.
 22943
 22944	043244	400 00 0 00 000000 	B45400:	SETZ			;PRELOAD E WITH 0
 22945	043245	201 01 0 00 777777 		MOVEI	1,-1		;PRELOAD AC WITH 0,,-1
 22946	043246	506 01 0 00 000000 		HRLM	1,		;*HRLM SHOULD PLACE -1,,0 INTO E
 22947	043247	312 00 0 00 070331 		CAME	[XWD -1,0]	;PASS IF C(E)=-1,,0
 22948						STOP^
 22949	043250	254 04 0 00 043251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 22950	043251	324 00 0 00 043252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 22951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 22952									;IN THE SUBTEST) TO LOOP ON ERROR^
 22953
 22954					;*****     FAILURE ANALYSIS     *****
 22955					;C(AC0)		C(AC1)		FAILING SIGNAL
 22956
 22957					;0		0,,-1		SW: FCE PSE
 22958					;0,,-1		0,,-1		SW: ET0
 22959					;-1,,-1		0,,-1		ET0: AD RT BR + EN
 22960					;-1,,B45400	0,,-1		ET0: BR AR EN
 22961					;0		0,,-1		ET0: AR AD EN
 22962					;0		0,,-1		ET2: AR LT AR RT EN
 22963
 22964					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 22965					SUBTTL	SUPPLEMENTARY ADDER TESTS - FLT 1 + 0
 22966
 22967					;**********
 22968
 22969			045500		SN=45500
 22970			000000			XX=0
 22971
 22972					B45500:	REPEAT	^D18,<
 22973					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 22974					;IS THE FLOATING ONE.
 22975					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 22976					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 22977					
 22978					SN=SN+1
 22979						XX=XX+XX
 22980						IFE	XX,<XX=1>
 22981						HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 22982						ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 22983						CAME	[XX]		;CHECK ADDER UPON FAILURE	
 22984						STOP
 22985					
 22986					;**********
 22987					>
 22988
 22989					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 22990					;IS THE FLOATING ONE.
 22991					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 22992					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 22993
 22994			045501		SN=SN+1
 22995			000000			XX=XX+XX
 22996			000001			IFE	XX,<XX=1>
 22997	043252	551 00 0 00 000001 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 22998	043253	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 22999	043254	312 00 0 00 070265 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23000						STOP^
 23001	043255	254 04 0 00 043256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23002	043256	324 00 0 00 043257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23004									;IN THE SUBTEST) TO LOOP ON ERROR^
 23005
 23006					;**********
 23007
 23008
 23009					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23010					;IS THE FLOATING ONE.
 23011					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23012					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23013
 23014			045502		SN=SN+1
 23015			000002			XX=XX+XX
 23016						IFE	XX,<XX=1>
 23017	043257	551 00 0 00 000002 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23018	043260	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23019	043261	312 00 0 00 070266 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-1
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23020						STOP^
 23021	043262	254 04 0 00 043263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23022	043263	324 00 0 00 043264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23023									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23024									;IN THE SUBTEST) TO LOOP ON ERROR^
 23025
 23026					;**********
 23027
 23028
 23029					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23030					;IS THE FLOATING ONE.
 23031					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23032					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23033
 23034			045503		SN=SN+1
 23035			000004			XX=XX+XX
 23036						IFE	XX,<XX=1>
 23037	043264	551 00 0 00 000004 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23038	043265	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23039	043266	312 00 0 00 070267 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23040						STOP^
 23041	043267	254 04 0 00 043270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23042	043270	324 00 0 00 043271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23044									;IN THE SUBTEST) TO LOOP ON ERROR^
 23045
 23046					;**********
 23047
 23048
 23049					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23050					;IS THE FLOATING ONE.
 23051					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23052					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23053
 23054			045504		SN=SN+1
 23055			000010			XX=XX+XX
 23056						IFE	XX,<XX=1>
 23057	043271	551 00 0 00 000010 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23058	043272	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23059	043273	312 00 0 00 070270 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23060						STOP^
 23061	043274	254 04 0 00 043275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23062	043275	324 00 0 00 043276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23063									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23064									;IN THE SUBTEST) TO LOOP ON ERROR^
 23065
 23066					;**********
 23067
 23068
 23069					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23070					;IS THE FLOATING ONE.
 23071					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23072					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23073
 23074			045505		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-2
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23075			000020			XX=XX+XX
 23076						IFE	XX,<XX=1>
 23077	043276	551 00 0 00 000020 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23078	043277	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23079	043300	312 00 0 00 070271 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23080						STOP^
 23081	043301	254 04 0 00 043302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23082	043302	324 00 0 00 043303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23084									;IN THE SUBTEST) TO LOOP ON ERROR^
 23085
 23086					;**********
 23087
 23088
 23089					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23090					;IS THE FLOATING ONE.
 23091					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23092					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23093
 23094			045506		SN=SN+1
 23095			000040			XX=XX+XX
 23096						IFE	XX,<XX=1>
 23097	043303	551 00 0 00 000040 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23098	043304	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23099	043305	312 00 0 00 070272 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23100						STOP^
 23101	043306	254 04 0 00 043307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23102	043307	324 00 0 00 043310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23103									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23104									;IN THE SUBTEST) TO LOOP ON ERROR^
 23105
 23106					;**********
 23107
 23108
 23109					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23110					;IS THE FLOATING ONE.
 23111					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23112					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23113
 23114			045507		SN=SN+1
 23115			000100			XX=XX+XX
 23116						IFE	XX,<XX=1>
 23117	043310	551 00 0 00 000100 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23118	043311	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23119	043312	312 00 0 00 070273 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23120						STOP^
 23121	043313	254 04 0 00 043314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23122	043314	324 00 0 00 043315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23123									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23124									;IN THE SUBTEST) TO LOOP ON ERROR^
 23125
 23126					;**********
 23127
 23128
 23129					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-3
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23130					;IS THE FLOATING ONE.
 23131					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23132					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23133
 23134			045510		SN=SN+1
 23135			000200			XX=XX+XX
 23136						IFE	XX,<XX=1>
 23137	043315	551 00 0 00 000200 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23138	043316	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23139	043317	312 00 0 00 070274 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23140						STOP^
 23141	043320	254 04 0 00 043321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23142	043321	324 00 0 00 043322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23144									;IN THE SUBTEST) TO LOOP ON ERROR^
 23145
 23146					;**********
 23147
 23148
 23149					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23150					;IS THE FLOATING ONE.
 23151					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23152					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23153
 23154			045511		SN=SN+1
 23155			000400			XX=XX+XX
 23156						IFE	XX,<XX=1>
 23157	043322	551 00 0 00 000400 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23158	043323	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23159	043324	312 00 0 00 070275 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23160						STOP^
 23161	043325	254 04 0 00 043326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23162	043326	324 00 0 00 043327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23163									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23164									;IN THE SUBTEST) TO LOOP ON ERROR^
 23165
 23166					;**********
 23167
 23168
 23169					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23170					;IS THE FLOATING ONE.
 23171					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23172					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23173
 23174			045512		SN=SN+1
 23175			001000			XX=XX+XX
 23176						IFE	XX,<XX=1>
 23177	043327	551 00 0 00 001000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23178	043330	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23179	043331	312 00 0 00 070276 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23180						STOP^
 23181	043332	254 04 0 00 043333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23182	043333	324 00 0 00 043334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23183									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23184									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-4
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23185
 23186					;**********
 23187
 23188
 23189					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23190					;IS THE FLOATING ONE.
 23191					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23192					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23193
 23194			045513		SN=SN+1
 23195			002000			XX=XX+XX
 23196						IFE	XX,<XX=1>
 23197	043334	551 00 0 00 002000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23198	043335	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23199	043336	312 00 0 00 070277 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23200						STOP^
 23201	043337	254 04 0 00 043340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23202	043340	324 00 0 00 043341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23203									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23204									;IN THE SUBTEST) TO LOOP ON ERROR^
 23205
 23206					;**********
 23207
 23208
 23209					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23210					;IS THE FLOATING ONE.
 23211					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23212					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23213
 23214			045514		SN=SN+1
 23215			004000			XX=XX+XX
 23216						IFE	XX,<XX=1>
 23217	043341	551 00 0 00 004000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23218	043342	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23219	043343	312 00 0 00 070300 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23220						STOP^
 23221	043344	254 04 0 00 043345 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23222	043345	324 00 0 00 043346 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23223									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23224									;IN THE SUBTEST) TO LOOP ON ERROR^
 23225
 23226					;**********
 23227
 23228
 23229					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23230					;IS THE FLOATING ONE.
 23231					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23232					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23233
 23234			045515		SN=SN+1
 23235			010000			XX=XX+XX
 23236						IFE	XX,<XX=1>
 23237	043346	551 00 0 00 010000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23238	043347	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23239	043350	312 00 0 00 070301 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-5
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23240						STOP^
 23241	043351	254 04 0 00 043352 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23242	043352	324 00 0 00 043353 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23243									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23244									;IN THE SUBTEST) TO LOOP ON ERROR^
 23245
 23246					;**********
 23247
 23248
 23249					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23250					;IS THE FLOATING ONE.
 23251					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23252					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23253
 23254			045516		SN=SN+1
 23255			020000			XX=XX+XX
 23256						IFE	XX,<XX=1>
 23257	043353	551 00 0 00 020000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23258	043354	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23259	043355	312 00 0 00 070302 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23260						STOP^
 23261	043356	254 04 0 00 043357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23262	043357	324 00 0 00 043360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23263									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23264									;IN THE SUBTEST) TO LOOP ON ERROR^
 23265
 23266					;**********
 23267
 23268
 23269					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23270					;IS THE FLOATING ONE.
 23271					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23272					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23273
 23274			045517		SN=SN+1
 23275			040000			XX=XX+XX
 23276						IFE	XX,<XX=1>
 23277	043360	551 00 0 00 040000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23278	043361	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23279	043362	312 00 0 00 070303 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23280						STOP^
 23281	043363	254 04 0 00 043364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23282	043364	324 00 0 00 043365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23283									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23284									;IN THE SUBTEST) TO LOOP ON ERROR^
 23285
 23286					;**********
 23287
 23288
 23289					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23290					;IS THE FLOATING ONE.
 23291					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23292					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23293
 23294			045520		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-6
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23295			100000			XX=XX+XX
 23296						IFE	XX,<XX=1>
 23297	043365	551 00 0 00 100000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23298	043366	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23299	043367	312 00 0 00 070304 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23300						STOP^
 23301	043370	254 04 0 00 043371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23302	043371	324 00 0 00 043372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23304									;IN THE SUBTEST) TO LOOP ON ERROR^
 23305
 23306					;**********
 23307
 23308
 23309					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23310					;IS THE FLOATING ONE.
 23311					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23312					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23313
 23314			045521		SN=SN+1
 23315			200000			XX=XX+XX
 23316						IFE	XX,<XX=1>
 23317	043372	551 00 0 00 200000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23318	043373	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23319	043374	312 00 0 00 070305 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23320						STOP^
 23321	043375	254 04 0 00 043376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23322	043376	324 00 0 00 043377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23323									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23324									;IN THE SUBTEST) TO LOOP ON ERROR^
 23325
 23326					;**********
 23327
 23328
 23329					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23330					;IS THE FLOATING ONE.
 23331					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23332					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23333
 23334			045522		SN=SN+1
 23335			400000			XX=XX+XX
 23336						IFE	XX,<XX=1>
 23337	043377	551 00 0 00 400000 		HRRZI	XX		;PRELOAD AC WITH FLOATING ONE
 23338	043400	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23339	043401	312 00 0 00 070306 		CAME	[XX]		;CHECK ADDER UPON FAILURE	
 23340						STOP^
 23341	043402	254 04 0 00 043403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23342	043403	324 00 0 00 043404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23344									;IN THE SUBTEST) TO LOOP ON ERROR^
 23345
 23346					;**********
 23347
 23348					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-7
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23349			000000			XX=0
 23350
 23351						REPEAT	^D18,<
 23352					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23353					;IS THE FLOATING ONE.
 23354					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23355					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23356					
 23357					SN=SN+1
 23358						XX=XX+XX
 23359						IFE	XX,<XX=1>
 23360						HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23361						ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23362						CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23363						STOP		
 23364					
 23365					;**********
 23366					>
 23367
 23368					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23369					;IS THE FLOATING ONE.
 23370					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23371					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23372
 23373			045523		SN=SN+1
 23374			000000			XX=XX+XX
 23375			000001			IFE	XX,<XX=1>
 23376	043404	515 00 0 00 000001 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23377	043405	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23378	043406	312 00 0 00 070307 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23379						STOP		^
 23380	043407	254 04 0 00 043410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23381	043410	324 00 0 00 043411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23382									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23383									;IN THE SUBTEST) TO LOOP ON ERROR^
 23384
 23385					;**********
 23386
 23387
 23388					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23389					;IS THE FLOATING ONE.
 23390					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23391					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23392
 23393			045524		SN=SN+1
 23394			000002			XX=XX+XX
 23395						IFE	XX,<XX=1>
 23396	043411	515 00 0 00 000002 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23397	043412	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23398	043413	312 00 0 00 070310 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23399						STOP		^
 23400	043414	254 04 0 00 043415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23401	043415	324 00 0 00 043416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23402									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23403									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-8
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23404
 23405					;**********
 23406
 23407
 23408					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23409					;IS THE FLOATING ONE.
 23410					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23411					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23412
 23413			045525		SN=SN+1
 23414			000004			XX=XX+XX
 23415						IFE	XX,<XX=1>
 23416	043416	515 00 0 00 000004 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23417	043417	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23418	043420	312 00 0 00 070311 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23419						STOP		^
 23420	043421	254 04 0 00 043422 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23421	043422	324 00 0 00 043423 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23422									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23423									;IN THE SUBTEST) TO LOOP ON ERROR^
 23424
 23425					;**********
 23426
 23427
 23428					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23429					;IS THE FLOATING ONE.
 23430					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23431					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23432
 23433			045526		SN=SN+1
 23434			000010			XX=XX+XX
 23435						IFE	XX,<XX=1>
 23436	043423	515 00 0 00 000010 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23437	043424	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23438	043425	312 00 0 00 070312 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23439						STOP		^
 23440	043426	254 04 0 00 043427 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23441	043427	324 00 0 00 043430 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23442									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23443									;IN THE SUBTEST) TO LOOP ON ERROR^
 23444
 23445					;**********
 23446
 23447
 23448					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23449					;IS THE FLOATING ONE.
 23450					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23451					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23452
 23453			045527		SN=SN+1
 23454			000020			XX=XX+XX
 23455						IFE	XX,<XX=1>
 23456	043430	515 00 0 00 000020 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23457	043431	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23458	043432	312 00 0 00 070313 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-9
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23459						STOP		^
 23460	043433	254 04 0 00 043434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23461	043434	324 00 0 00 043435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23462									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23463									;IN THE SUBTEST) TO LOOP ON ERROR^
 23464
 23465					;**********
 23466
 23467
 23468					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23469					;IS THE FLOATING ONE.
 23470					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23471					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23472
 23473			045530		SN=SN+1
 23474			000040			XX=XX+XX
 23475						IFE	XX,<XX=1>
 23476	043435	515 00 0 00 000040 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23477	043436	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23478	043437	312 00 0 00 070314 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23479						STOP		^
 23480	043440	254 04 0 00 043441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23481	043441	324 00 0 00 043442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23482									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23483									;IN THE SUBTEST) TO LOOP ON ERROR^
 23484
 23485					;**********
 23486
 23487
 23488					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23489					;IS THE FLOATING ONE.
 23490					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23491					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23492
 23493			045531		SN=SN+1
 23494			000100			XX=XX+XX
 23495						IFE	XX,<XX=1>
 23496	043442	515 00 0 00 000100 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23497	043443	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23498	043444	312 00 0 00 070315 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23499						STOP		^
 23500	043445	254 04 0 00 043446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23501	043446	324 00 0 00 043447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23502									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23503									;IN THE SUBTEST) TO LOOP ON ERROR^
 23504
 23505					;**********
 23506
 23507
 23508					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23509					;IS THE FLOATING ONE.
 23510					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23511					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23512
 23513			045532		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-10
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23514			000200			XX=XX+XX
 23515						IFE	XX,<XX=1>
 23516	043447	515 00 0 00 000200 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23517	043450	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23518	043451	312 00 0 00 070316 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23519						STOP		^
 23520	043452	254 04 0 00 043453 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23521	043453	324 00 0 00 043454 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23523									;IN THE SUBTEST) TO LOOP ON ERROR^
 23524
 23525					;**********
 23526
 23527
 23528					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23529					;IS THE FLOATING ONE.
 23530					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23531					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23532
 23533			045533		SN=SN+1
 23534			000400			XX=XX+XX
 23535						IFE	XX,<XX=1>
 23536	043454	515 00 0 00 000400 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23537	043455	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23538	043456	312 00 0 00 070264 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23539						STOP		^
 23540	043457	254 04 0 00 043460 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23541	043460	324 00 0 00 043461 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23543									;IN THE SUBTEST) TO LOOP ON ERROR^
 23544
 23545					;**********
 23546
 23547
 23548					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23549					;IS THE FLOATING ONE.
 23550					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23551					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23552
 23553			045534		SN=SN+1
 23554			001000			XX=XX+XX
 23555						IFE	XX,<XX=1>
 23556	043461	515 00 0 00 001000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23557	043462	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23558	043463	312 00 0 00 070317 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23559						STOP		^
 23560	043464	254 04 0 00 043465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23561	043465	324 00 0 00 043466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23562									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23563									;IN THE SUBTEST) TO LOOP ON ERROR^
 23564
 23565					;**********
 23566
 23567
 23568					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-11
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23569					;IS THE FLOATING ONE.
 23570					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23571					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23572
 23573			045535		SN=SN+1
 23574			002000			XX=XX+XX
 23575						IFE	XX,<XX=1>
 23576	043466	515 00 0 00 002000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23577	043467	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23578	043470	312 00 0 00 070320 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23579						STOP		^
 23580	043471	254 04 0 00 043472 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23581	043472	324 00 0 00 043473 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23582									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23583									;IN THE SUBTEST) TO LOOP ON ERROR^
 23584
 23585					;**********
 23586
 23587
 23588					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23589					;IS THE FLOATING ONE.
 23590					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23591					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23592
 23593			045536		SN=SN+1
 23594			004000			XX=XX+XX
 23595						IFE	XX,<XX=1>
 23596	043473	515 00 0 00 004000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23597	043474	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23598	043475	312 00 0 00 070321 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23599						STOP		^
 23600	043476	254 04 0 00 043477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23601	043477	324 00 0 00 043500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23602									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23603									;IN THE SUBTEST) TO LOOP ON ERROR^
 23604
 23605					;**********
 23606
 23607
 23608					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23609					;IS THE FLOATING ONE.
 23610					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23611					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23612
 23613			045537		SN=SN+1
 23614			010000			XX=XX+XX
 23615						IFE	XX,<XX=1>
 23616	043500	515 00 0 00 010000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23617	043501	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23618	043502	312 00 0 00 070322 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23619						STOP		^
 23620	043503	254 04 0 00 043504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23621	043504	324 00 0 00 043505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23622									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23623									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-12
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23624
 23625					;**********
 23626
 23627
 23628					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23629					;IS THE FLOATING ONE.
 23630					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23631					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23632
 23633			045540		SN=SN+1
 23634			020000			XX=XX+XX
 23635						IFE	XX,<XX=1>
 23636	043505	515 00 0 00 020000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23637	043506	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23638	043507	312 00 0 00 070323 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23639						STOP		^
 23640	043510	254 04 0 00 043511 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23641	043511	324 00 0 00 043512 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23642									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23643									;IN THE SUBTEST) TO LOOP ON ERROR^
 23644
 23645					;**********
 23646
 23647
 23648					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23649					;IS THE FLOATING ONE.
 23650					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23651					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23652
 23653			045541		SN=SN+1
 23654			040000			XX=XX+XX
 23655						IFE	XX,<XX=1>
 23656	043512	515 00 0 00 040000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23657	043513	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23658	043514	312 00 0 00 070324 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23659						STOP		^
 23660	043515	254 04 0 00 043516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23661	043516	324 00 0 00 043517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23662									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23663									;IN THE SUBTEST) TO LOOP ON ERROR^
 23664
 23665					;**********
 23666
 23667
 23668					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23669					;IS THE FLOATING ONE.
 23670					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23671					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23672
 23673			045542		SN=SN+1
 23674			100000			XX=XX+XX
 23675						IFE	XX,<XX=1>
 23676	043517	515 00 0 00 100000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23677	043520	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23678	043521	312 00 0 00 070325 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-13
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + 0

 23679						STOP		^
 23680	043522	254 04 0 00 043523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23681	043523	324 00 0 00 043524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23682									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23683									;IN THE SUBTEST) TO LOOP ON ERROR^
 23684
 23685					;**********
 23686
 23687
 23688					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23689					;IS THE FLOATING ONE.
 23690					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23691					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23692
 23693			045543		SN=SN+1
 23694			200000			XX=XX+XX
 23695						IFE	XX,<XX=1>
 23696	043524	515 00 0 00 200000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23697	043525	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23698	043526	312 00 0 00 070326 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23699						STOP		^
 23700	043527	254 04 0 00 043530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23701	043530	324 00 0 00 043531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23703									;IN THE SUBTEST) TO LOOP ON ERROR^
 23704
 23705					;**********
 23706
 23707
 23708					;THIS TEST VERIFIES THAT THE RESULT OF A ZERO ADDED TO A FLOATING ONE
 23709					;IS THE FLOATING ONE.
 23710					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 23711					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23712
 23713			045544		SN=SN+1
 23714			400000			XX=XX+XX
 23715						IFE	XX,<XX=1>
 23716	043531	515 00 0 00 400000 		HRLZI	XX		;PRELOAD AC WITH FLOATING ONE
 23717	043532	270 00 0 00 070253 		ADD	[0]		;ADD ZERO TO A FLOATING ONE	
 23718	043533	312 00 0 00 070256 		CAME	[XX,,0]		;CHECK ADDER UPON FALIRE
 23719						STOP		^
 23720	043534	254 04 0 00 043535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23721	043535	324 00 0 00 043536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23722									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23723									;IN THE SUBTEST) TO LOOP ON ERROR^
 23724
 23725					;**********
 23726
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 23727					SUBTTL	SUPPLEMENTARY ADDER TESTS - O + FLT 0
 23728
 23729					;**********
 23730
 23731			045600		SN=45600
 23732					B45600:	REPEAT	^D18,<
 23733					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23734					;IS THE FLOATING ZERO.
 23735					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23736					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23737					
 23738					SN=SN+1
 23739						XX=<XX+XX+1>&777777
 23740						IFE	<XX-1>,<XX=777776>
 23741						SETZ			;PRELOAD AC WITH 0
 23742						ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23743						CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23744						STOP		
 23745					
 23746					;**********
 23747					>
 23748
 23749					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23750					;IS THE FLOATING ZERO.
 23751					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23752					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23753
 23754			045601		SN=SN+1
 23755			000001			XX=<XX+XX+1>&777777
 23756			777776			IFE	<XX-1>,<XX=777776>
 23757	043536	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23758	043537	270 00 0 00 070333 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23759	043540	312 00 0 00 070333 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23760						STOP		^
 23761	043541	254 04 0 00 043542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23762	043542	324 00 0 00 043543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23763									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23764									;IN THE SUBTEST) TO LOOP ON ERROR^
 23765
 23766					;**********
 23767
 23768
 23769					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23770					;IS THE FLOATING ZERO.
 23771					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23772					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23773
 23774			045602		SN=SN+1
 23775			777775			XX=<XX+XX+1>&777777
 23776						IFE	<XX-1>,<XX=777776>
 23777	043543	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23778	043544	270 00 0 00 070334 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23779	043545	312 00 0 00 070334 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23780						STOP		^
 23781	043546	254 04 0 00 043547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-1
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 23782	043547	324 00 0 00 043550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23783									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23784									;IN THE SUBTEST) TO LOOP ON ERROR^
 23785
 23786					;**********
 23787
 23788
 23789					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23790					;IS THE FLOATING ZERO.
 23791					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23792					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23793
 23794			045603		SN=SN+1
 23795			777773			XX=<XX+XX+1>&777777
 23796						IFE	<XX-1>,<XX=777776>
 23797	043550	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23798	043551	270 00 0 00 070335 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23799	043552	312 00 0 00 070335 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23800						STOP		^
 23801	043553	254 04 0 00 043554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23802	043554	324 00 0 00 043555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23804									;IN THE SUBTEST) TO LOOP ON ERROR^
 23805
 23806					;**********
 23807
 23808
 23809					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23810					;IS THE FLOATING ZERO.
 23811					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23812					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23813
 23814			045604		SN=SN+1
 23815			777767			XX=<XX+XX+1>&777777
 23816						IFE	<XX-1>,<XX=777776>
 23817	043555	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23818	043556	270 00 0 00 070336 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23819	043557	312 00 0 00 070336 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23820						STOP		^
 23821	043560	254 04 0 00 043561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23822	043561	324 00 0 00 043562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23824									;IN THE SUBTEST) TO LOOP ON ERROR^
 23825
 23826					;**********
 23827
 23828
 23829					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23830					;IS THE FLOATING ZERO.
 23831					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23832					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23833
 23834			045605		SN=SN+1
 23835			777757			XX=<XX+XX+1>&777777
 23836						IFE	<XX-1>,<XX=777776>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-2
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 23837	043562	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23838	043563	270 00 0 00 070337 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23839	043564	312 00 0 00 070337 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23840						STOP		^
 23841	043565	254 04 0 00 043566 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23842	043566	324 00 0 00 043567 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23843									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23844									;IN THE SUBTEST) TO LOOP ON ERROR^
 23845
 23846					;**********
 23847
 23848
 23849					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23850					;IS THE FLOATING ZERO.
 23851					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23852					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23853
 23854			045606		SN=SN+1
 23855			777737			XX=<XX+XX+1>&777777
 23856						IFE	<XX-1>,<XX=777776>
 23857	043567	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23858	043570	270 00 0 00 070340 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23859	043571	312 00 0 00 070340 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23860						STOP		^
 23861	043572	254 04 0 00 043573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23862	043573	324 00 0 00 043574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23863									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23864									;IN THE SUBTEST) TO LOOP ON ERROR^
 23865
 23866					;**********
 23867
 23868
 23869					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23870					;IS THE FLOATING ZERO.
 23871					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23872					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23873
 23874			045607		SN=SN+1
 23875			777677			XX=<XX+XX+1>&777777
 23876						IFE	<XX-1>,<XX=777776>
 23877	043574	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23878	043575	270 00 0 00 070341 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23879	043576	312 00 0 00 070341 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23880						STOP		^
 23881	043577	254 04 0 00 043600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23882	043600	324 00 0 00 043601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23883									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23884									;IN THE SUBTEST) TO LOOP ON ERROR^
 23885
 23886					;**********
 23887
 23888
 23889					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23890					;IS THE FLOATING ZERO.
 23891					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-3
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 23892					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23893
 23894			045610		SN=SN+1
 23895			777577			XX=<XX+XX+1>&777777
 23896						IFE	<XX-1>,<XX=777776>
 23897	043601	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23898	043602	270 00 0 00 070342 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23899	043603	312 00 0 00 070342 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23900						STOP		^
 23901	043604	254 04 0 00 043605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23902	043605	324 00 0 00 043606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23904									;IN THE SUBTEST) TO LOOP ON ERROR^
 23905
 23906					;**********
 23907
 23908
 23909					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23910					;IS THE FLOATING ZERO.
 23911					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23912					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23913
 23914			045611		SN=SN+1
 23915			777377			XX=<XX+XX+1>&777777
 23916						IFE	<XX-1>,<XX=777776>
 23917	043606	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23918	043607	270 00 0 00 070343 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23919	043610	312 00 0 00 070343 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23920						STOP		^
 23921	043611	254 04 0 00 043612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23922	043612	324 00 0 00 043613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23923									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23924									;IN THE SUBTEST) TO LOOP ON ERROR^
 23925
 23926					;**********
 23927
 23928
 23929					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23930					;IS THE FLOATING ZERO.
 23931					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23932					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23933
 23934			045612		SN=SN+1
 23935			776777			XX=<XX+XX+1>&777777
 23936						IFE	<XX-1>,<XX=777776>
 23937	043613	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23938	043614	270 00 0 00 070344 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23939	043615	312 00 0 00 070344 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23940						STOP		^
 23941	043616	254 04 0 00 043617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23942	043617	324 00 0 00 043620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23943									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23944									;IN THE SUBTEST) TO LOOP ON ERROR^
 23945
 23946					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-4
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 23947
 23948
 23949					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23950					;IS THE FLOATING ZERO.
 23951					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23952					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23953
 23954			045613		SN=SN+1
 23955			775777			XX=<XX+XX+1>&777777
 23956						IFE	<XX-1>,<XX=777776>
 23957	043620	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23958	043621	270 00 0 00 070345 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23959	043622	312 00 0 00 070345 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23960						STOP		^
 23961	043623	254 04 0 00 043624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23962	043624	324 00 0 00 043625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23963									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23964									;IN THE SUBTEST) TO LOOP ON ERROR^
 23965
 23966					;**********
 23967
 23968
 23969					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23970					;IS THE FLOATING ZERO.
 23971					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23972					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23973
 23974			045614		SN=SN+1
 23975			773777			XX=<XX+XX+1>&777777
 23976						IFE	<XX-1>,<XX=777776>
 23977	043625	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23978	043626	270 00 0 00 070346 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23979	043627	312 00 0 00 070346 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 23980						STOP		^
 23981	043630	254 04 0 00 043631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 23982	043631	324 00 0 00 043632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 23983									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 23984									;IN THE SUBTEST) TO LOOP ON ERROR^
 23985
 23986					;**********
 23987
 23988
 23989					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 23990					;IS THE FLOATING ZERO.
 23991					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 23992					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 23993
 23994			045615		SN=SN+1
 23995			767777			XX=<XX+XX+1>&777777
 23996						IFE	<XX-1>,<XX=777776>
 23997	043632	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 23998	043633	270 00 0 00 070347 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 23999	043634	312 00 0 00 070347 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24000						STOP		^
 24001	043635	254 04 0 00 043636 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-5
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24002	043636	324 00 0 00 043637 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24004									;IN THE SUBTEST) TO LOOP ON ERROR^
 24005
 24006					;**********
 24007
 24008
 24009					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24010					;IS THE FLOATING ZERO.
 24011					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24012					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24013
 24014			045616		SN=SN+1
 24015			757777			XX=<XX+XX+1>&777777
 24016						IFE	<XX-1>,<XX=777776>
 24017	043637	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24018	043640	270 00 0 00 070350 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24019	043641	312 00 0 00 070350 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24020						STOP		^
 24021	043642	254 04 0 00 043643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24022	043643	324 00 0 00 043644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24023									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24024									;IN THE SUBTEST) TO LOOP ON ERROR^
 24025
 24026					;**********
 24027
 24028
 24029					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24030					;IS THE FLOATING ZERO.
 24031					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24032					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24033
 24034			045617		SN=SN+1
 24035			737777			XX=<XX+XX+1>&777777
 24036						IFE	<XX-1>,<XX=777776>
 24037	043644	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24038	043645	270 00 0 00 070351 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24039	043646	312 00 0 00 070351 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24040						STOP		^
 24041	043647	254 04 0 00 043650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24042	043650	324 00 0 00 043651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24044									;IN THE SUBTEST) TO LOOP ON ERROR^
 24045
 24046					;**********
 24047
 24048
 24049					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24050					;IS THE FLOATING ZERO.
 24051					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24052					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24053
 24054			045620		SN=SN+1
 24055			677777			XX=<XX+XX+1>&777777
 24056						IFE	<XX-1>,<XX=777776>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-6
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24057	043651	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24058	043652	270 00 0 00 070352 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24059	043653	312 00 0 00 070352 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24060						STOP		^
 24061	043654	254 04 0 00 043655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24062	043655	324 00 0 00 043656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24063									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24064									;IN THE SUBTEST) TO LOOP ON ERROR^
 24065
 24066					;**********
 24067
 24068
 24069					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24070					;IS THE FLOATING ZERO.
 24071					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24072					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24073
 24074			045621		SN=SN+1
 24075			577777			XX=<XX+XX+1>&777777
 24076						IFE	<XX-1>,<XX=777776>
 24077	043656	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24078	043657	270 00 0 00 070353 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24079	043660	312 00 0 00 070353 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24080						STOP		^
 24081	043661	254 04 0 00 043662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24082	043662	324 00 0 00 043663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24084									;IN THE SUBTEST) TO LOOP ON ERROR^
 24085
 24086					;**********
 24087
 24088
 24089					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24090					;IS THE FLOATING ZERO.
 24091					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 24092					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24093
 24094			045622		SN=SN+1
 24095			377777			XX=<XX+XX+1>&777777
 24096						IFE	<XX-1>,<XX=777776>
 24097	043663	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24098	043664	270 00 0 00 070354 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ZERO
 24099	043665	312 00 0 00 070354 		CAME	[-1,,XX]	;CHECK ADDER UPON FAILURE
 24100						STOP		^
 24101	043666	254 04 0 00 043667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24102	043667	324 00 0 00 043670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24103									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24104									;IN THE SUBTEST) TO LOOP ON ERROR^
 24105
 24106					;**********
 24107
 24108					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-7
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24109			000000			XX=0
 24110
 24111						REPEAT	^D18,<
 24112					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24113					;IS THE FLOATING ZERO.
 24114					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24115					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24116					
 24117					SN=SN+1
 24118						XX=<XX+XX+1>&777777
 24119						IFE	<XX-1>,<XX=777776>
 24120						SETZ			;PRELOAD AC WITH 0
 24121						ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24122						CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24123						STOP		
 24124					
 24125					;**********
 24126					>
 24127
 24128					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24129					;IS THE FLOATING ZERO.
 24130					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24131					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24132
 24133			045623		SN=SN+1
 24134			000001			XX=<XX+XX+1>&777777
 24135			777776			IFE	<XX-1>,<XX=777776>
 24136	043670	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24137	043671	270 00 0 00 070355 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24138	043672	312 00 0 00 070355 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24139						STOP		^
 24140	043673	254 04 0 00 043674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24141	043674	324 00 0 00 043675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24143									;IN THE SUBTEST) TO LOOP ON ERROR^
 24144
 24145					;**********
 24146
 24147
 24148					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24149					;IS THE FLOATING ZERO.
 24150					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24151					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24152
 24153			045624		SN=SN+1
 24154			777775			XX=<XX+XX+1>&777777
 24155						IFE	<XX-1>,<XX=777776>
 24156	043675	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24157	043676	270 00 0 00 070356 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24158	043677	312 00 0 00 070356 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24159						STOP		^
 24160	043700	254 04 0 00 043701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24161	043701	324 00 0 00 043702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24162									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24163									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-8
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24164
 24165					;**********
 24166
 24167
 24168					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24169					;IS THE FLOATING ZERO.
 24170					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24171					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24172
 24173			045625		SN=SN+1
 24174			777773			XX=<XX+XX+1>&777777
 24175						IFE	<XX-1>,<XX=777776>
 24176	043702	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24177	043703	270 00 0 00 070357 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24178	043704	312 00 0 00 070357 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24179						STOP		^
 24180	043705	254 04 0 00 043706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24181	043706	324 00 0 00 043707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24182									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24183									;IN THE SUBTEST) TO LOOP ON ERROR^
 24184
 24185					;**********
 24186
 24187
 24188					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24189					;IS THE FLOATING ZERO.
 24190					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24191					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24192
 24193			045626		SN=SN+1
 24194			777767			XX=<XX+XX+1>&777777
 24195						IFE	<XX-1>,<XX=777776>
 24196	043707	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24197	043710	270 00 0 00 070360 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24198	043711	312 00 0 00 070360 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24199						STOP		^
 24200	043712	254 04 0 00 043713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24201	043713	324 00 0 00 043714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24202									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24203									;IN THE SUBTEST) TO LOOP ON ERROR^
 24204
 24205					;**********
 24206
 24207
 24208					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24209					;IS THE FLOATING ZERO.
 24210					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24211					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24212
 24213			045627		SN=SN+1
 24214			777757			XX=<XX+XX+1>&777777
 24215						IFE	<XX-1>,<XX=777776>
 24216	043714	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24217	043715	270 00 0 00 070361 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24218	043716	312 00 0 00 070361 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-9
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24219						STOP		^
 24220	043717	254 04 0 00 043720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24221	043720	324 00 0 00 043721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24223									;IN THE SUBTEST) TO LOOP ON ERROR^
 24224
 24225					;**********
 24226
 24227
 24228					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24229					;IS THE FLOATING ZERO.
 24230					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24231					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24232
 24233			045630		SN=SN+1
 24234			777737			XX=<XX+XX+1>&777777
 24235						IFE	<XX-1>,<XX=777776>
 24236	043721	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24237	043722	270 00 0 00 070362 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24238	043723	312 00 0 00 070362 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24239						STOP		^
 24240	043724	254 04 0 00 043725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24241	043725	324 00 0 00 043726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24242									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24243									;IN THE SUBTEST) TO LOOP ON ERROR^
 24244
 24245					;**********
 24246
 24247
 24248					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24249					;IS THE FLOATING ZERO.
 24250					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24251					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24252
 24253			045631		SN=SN+1
 24254			777677			XX=<XX+XX+1>&777777
 24255						IFE	<XX-1>,<XX=777776>
 24256	043726	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24257	043727	270 00 0 00 070363 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24258	043730	312 00 0 00 070363 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24259						STOP		^
 24260	043731	254 04 0 00 043732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24261	043732	324 00 0 00 043733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24263									;IN THE SUBTEST) TO LOOP ON ERROR^
 24264
 24265					;**********
 24266
 24267
 24268					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24269					;IS THE FLOATING ZERO.
 24270					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24271					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24272
 24273			045632		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-10
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24274			777577			XX=<XX+XX+1>&777777
 24275						IFE	<XX-1>,<XX=777776>
 24276	043733	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24277	043734	270 00 0 00 070364 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24278	043735	312 00 0 00 070364 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24279						STOP		^
 24280	043736	254 04 0 00 043737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24281	043737	324 00 0 00 043740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24282									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24283									;IN THE SUBTEST) TO LOOP ON ERROR^
 24284
 24285					;**********
 24286
 24287
 24288					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24289					;IS THE FLOATING ZERO.
 24290					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24291					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24292
 24293			045633		SN=SN+1
 24294			777377			XX=<XX+XX+1>&777777
 24295						IFE	<XX-1>,<XX=777776>
 24296	043740	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24297	043741	270 00 0 00 070365 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24298	043742	312 00 0 00 070365 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24299						STOP		^
 24300	043743	254 04 0 00 043744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24301	043744	324 00 0 00 043745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24302									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24303									;IN THE SUBTEST) TO LOOP ON ERROR^
 24304
 24305					;**********
 24306
 24307
 24308					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24309					;IS THE FLOATING ZERO.
 24310					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24311					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24312
 24313			045634		SN=SN+1
 24314			776777			XX=<XX+XX+1>&777777
 24315						IFE	<XX-1>,<XX=777776>
 24316	043745	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24317	043746	270 00 0 00 070366 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24318	043747	312 00 0 00 070366 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24319						STOP		^
 24320	043750	254 04 0 00 043751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24321	043751	324 00 0 00 043752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24323									;IN THE SUBTEST) TO LOOP ON ERROR^
 24324
 24325					;**********
 24326
 24327
 24328					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-11
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24329					;IS THE FLOATING ZERO.
 24330					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24331					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24332
 24333			045635		SN=SN+1
 24334			775777			XX=<XX+XX+1>&777777
 24335						IFE	<XX-1>,<XX=777776>
 24336	043752	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24337	043753	270 00 0 00 070367 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24338	043754	312 00 0 00 070367 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24339						STOP		^
 24340	043755	254 04 0 00 043756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24341	043756	324 00 0 00 043757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24342									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24343									;IN THE SUBTEST) TO LOOP ON ERROR^
 24344
 24345					;**********
 24346
 24347
 24348					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24349					;IS THE FLOATING ZERO.
 24350					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24351					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24352
 24353			045636		SN=SN+1
 24354			773777			XX=<XX+XX+1>&777777
 24355						IFE	<XX-1>,<XX=777776>
 24356	043757	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24357	043760	270 00 0 00 070370 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24358	043761	312 00 0 00 070370 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24359						STOP		^
 24360	043762	254 04 0 00 043763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24361	043763	324 00 0 00 043764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24362									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24363									;IN THE SUBTEST) TO LOOP ON ERROR^
 24364
 24365					;**********
 24366
 24367
 24368					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24369					;IS THE FLOATING ZERO.
 24370					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24371					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24372
 24373			045637		SN=SN+1
 24374			767777			XX=<XX+XX+1>&777777
 24375						IFE	<XX-1>,<XX=777776>
 24376	043764	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24377	043765	270 00 0 00 070371 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24378	043766	312 00 0 00 070371 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24379						STOP		^
 24380	043767	254 04 0 00 043770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24381	043770	324 00 0 00 043771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24382									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24383									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-12
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24384
 24385					;**********
 24386
 24387
 24388					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24389					;IS THE FLOATING ZERO.
 24390					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24391					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24392
 24393			045640		SN=SN+1
 24394			757777			XX=<XX+XX+1>&777777
 24395						IFE	<XX-1>,<XX=777776>
 24396	043771	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24397	043772	270 00 0 00 070372 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24398	043773	312 00 0 00 070372 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24399						STOP		^
 24400	043774	254 04 0 00 043775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24401	043775	324 00 0 00 043776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24402									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24403									;IN THE SUBTEST) TO LOOP ON ERROR^
 24404
 24405					;**********
 24406
 24407
 24408					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24409					;IS THE FLOATING ZERO.
 24410					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24411					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24412
 24413			045641		SN=SN+1
 24414			737777			XX=<XX+XX+1>&777777
 24415						IFE	<XX-1>,<XX=777776>
 24416	043776	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24417	043777	270 00 0 00 070373 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24418	044000	312 00 0 00 070373 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24419						STOP		^
 24420	044001	254 04 0 00 044002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24421	044002	324 00 0 00 044003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24422									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24423									;IN THE SUBTEST) TO LOOP ON ERROR^
 24424
 24425					;**********
 24426
 24427
 24428					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24429					;IS THE FLOATING ZERO.
 24430					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24431					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24432
 24433			045642		SN=SN+1
 24434			677777			XX=<XX+XX+1>&777777
 24435						IFE	<XX-1>,<XX=777776>
 24436	044003	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24437	044004	270 00 0 00 070374 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24438	044005	312 00 0 00 070374 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-13
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - O + FLT 0

 24439						STOP		^
 24440	044006	254 04 0 00 044007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24441	044007	324 00 0 00 044010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24442									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24443									;IN THE SUBTEST) TO LOOP ON ERROR^
 24444
 24445					;**********
 24446
 24447
 24448					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24449					;IS THE FLOATING ZERO.
 24450					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24451					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24452
 24453			045643		SN=SN+1
 24454			577777			XX=<XX+XX+1>&777777
 24455						IFE	<XX-1>,<XX=777776>
 24456	044010	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24457	044011	270 00 0 00 070375 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24458	044012	312 00 0 00 070375 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24459						STOP		^
 24460	044013	254 04 0 00 044014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24461	044014	324 00 0 00 044015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24462									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24463									;IN THE SUBTEST) TO LOOP ON ERROR^
 24464
 24465					;**********
 24466
 24467
 24468					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO ADDED TO A ZERO
 24469					;IS THE FLOATING ZERO.
 24470					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24471					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24472
 24473			045644		SN=SN+1
 24474			377777			XX=<XX+XX+1>&777777
 24475						IFE	<XX-1>,<XX=777776>
 24476	044015	400 00 0 00 000000 		SETZ			;PRELOAD AC WITH 0
 24477	044016	270 00 0 00 070255 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ZERO
 24478	044017	312 00 0 00 070255 		CAME	[XX,,-1]	;CHECK ADDER UPON FAILURE
 24479						STOP		^
 24480	044020	254 04 0 00 044021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24481	044021	324 00 0 00 044022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24482									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24483									;IN THE SUBTEST) TO LOOP ON ERROR^
 24484
 24485					;**********
 24486
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24487					SUBTTL	SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1
 24488
 24489					;**********
 24490
 24491			045700		SN=45700
 24492			000000			XX=0
 24493
 24494					B45700:	REPEAT	^D17,<
 24495					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24496					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24497					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24498					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24499					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24500					
 24501					SN=SN+1
 24502						XX=XX+XX
 24503						IFE	XX,<XX=1>
 24504						HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24505						ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24506						CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24507						STOP		
 24508					
 24509					;**********
 24510					>
 24511
 24512					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24513					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24514					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24515					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24516					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24517
 24518			045701		SN=SN+1
 24519			000000			XX=XX+XX
 24520			000001			IFE	XX,<XX=1>
 24521	044022	551 00 0 00 000001 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24522	044023	270 00 0 00 070265 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24523	044024	312 00 0 00 070266 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24524						STOP		^
 24525	044025	254 04 0 00 044026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24526	044026	324 00 0 00 044027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24527									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24528									;IN THE SUBTEST) TO LOOP ON ERROR^
 24529
 24530					;**********
 24531
 24532
 24533					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24534					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24535					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24536					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24537					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24538
 24539			045702		SN=SN+1
 24540			000002			XX=XX+XX
 24541						IFE	XX,<XX=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-1
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24542	044027	551 00 0 00 000002 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24543	044030	270 00 0 00 070266 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24544	044031	312 00 0 00 070267 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24545						STOP		^
 24546	044032	254 04 0 00 044033 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24547	044033	324 00 0 00 044034 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24548									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24549									;IN THE SUBTEST) TO LOOP ON ERROR^
 24550
 24551					;**********
 24552
 24553
 24554					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24555					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24556					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24557					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24558					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24559
 24560			045703		SN=SN+1
 24561			000004			XX=XX+XX
 24562						IFE	XX,<XX=1>
 24563	044034	551 00 0 00 000004 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24564	044035	270 00 0 00 070267 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24565	044036	312 00 0 00 070270 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24566						STOP		^
 24567	044037	254 04 0 00 044040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24568	044040	324 00 0 00 044041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24569									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24570									;IN THE SUBTEST) TO LOOP ON ERROR^
 24571
 24572					;**********
 24573
 24574
 24575					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24576					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24577					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24578					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24579					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24580
 24581			045704		SN=SN+1
 24582			000010			XX=XX+XX
 24583						IFE	XX,<XX=1>
 24584	044041	551 00 0 00 000010 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24585	044042	270 00 0 00 070270 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24586	044043	312 00 0 00 070271 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24587						STOP		^
 24588	044044	254 04 0 00 044045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24589	044045	324 00 0 00 044046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24590									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24591									;IN THE SUBTEST) TO LOOP ON ERROR^
 24592
 24593					;**********
 24594
 24595
 24596					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-2
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24597					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24598					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24599					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24600					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24601
 24602			045705		SN=SN+1
 24603			000020			XX=XX+XX
 24604						IFE	XX,<XX=1>
 24605	044046	551 00 0 00 000020 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24606	044047	270 00 0 00 070271 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24607	044050	312 00 0 00 070272 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24608						STOP		^
 24609	044051	254 04 0 00 044052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24610	044052	324 00 0 00 044053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24611									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24612									;IN THE SUBTEST) TO LOOP ON ERROR^
 24613
 24614					;**********
 24615
 24616
 24617					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24618					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24619					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24620					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24621					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24622
 24623			045706		SN=SN+1
 24624			000040			XX=XX+XX
 24625						IFE	XX,<XX=1>
 24626	044053	551 00 0 00 000040 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24627	044054	270 00 0 00 070272 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24628	044055	312 00 0 00 070273 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24629						STOP		^
 24630	044056	254 04 0 00 044057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24631	044057	324 00 0 00 044060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24632									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24633									;IN THE SUBTEST) TO LOOP ON ERROR^
 24634
 24635					;**********
 24636
 24637
 24638					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24639					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24640					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24641					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24642					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24643
 24644			045707		SN=SN+1
 24645			000100			XX=XX+XX
 24646						IFE	XX,<XX=1>
 24647	044060	551 00 0 00 000100 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24648	044061	270 00 0 00 070273 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24649	044062	312 00 0 00 070274 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24650						STOP		^
 24651	044063	254 04 0 00 044064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-3
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24652	044064	324 00 0 00 044065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24653									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24654									;IN THE SUBTEST) TO LOOP ON ERROR^
 24655
 24656					;**********
 24657
 24658
 24659					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24660					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24661					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24662					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24663					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24664
 24665			045710		SN=SN+1
 24666			000200			XX=XX+XX
 24667						IFE	XX,<XX=1>
 24668	044065	551 00 0 00 000200 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24669	044066	270 00 0 00 070274 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24670	044067	312 00 0 00 070275 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24671						STOP		^
 24672	044070	254 04 0 00 044071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24673	044071	324 00 0 00 044072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24674									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24675									;IN THE SUBTEST) TO LOOP ON ERROR^
 24676
 24677					;**********
 24678
 24679
 24680					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24681					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24682					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24683					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24684					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24685
 24686			045711		SN=SN+1
 24687			000400			XX=XX+XX
 24688						IFE	XX,<XX=1>
 24689	044072	551 00 0 00 000400 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24690	044073	270 00 0 00 070275 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24691	044074	312 00 0 00 070276 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24692						STOP		^
 24693	044075	254 04 0 00 044076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24694	044076	324 00 0 00 044077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24695									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24696									;IN THE SUBTEST) TO LOOP ON ERROR^
 24697
 24698					;**********
 24699
 24700
 24701					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24702					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24703					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24704					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24705					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24706
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-4
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24707			045712		SN=SN+1
 24708			001000			XX=XX+XX
 24709						IFE	XX,<XX=1>
 24710	044077	551 00 0 00 001000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24711	044100	270 00 0 00 070276 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24712	044101	312 00 0 00 070277 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24713						STOP		^
 24714	044102	254 04 0 00 044103 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24715	044103	324 00 0 00 044104 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24717									;IN THE SUBTEST) TO LOOP ON ERROR^
 24718
 24719					;**********
 24720
 24721
 24722					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24723					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24724					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24725					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24726					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24727
 24728			045713		SN=SN+1
 24729			002000			XX=XX+XX
 24730						IFE	XX,<XX=1>
 24731	044104	551 00 0 00 002000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24732	044105	270 00 0 00 070277 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24733	044106	312 00 0 00 070300 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24734						STOP		^
 24735	044107	254 04 0 00 044110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24736	044110	324 00 0 00 044111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24737									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24738									;IN THE SUBTEST) TO LOOP ON ERROR^
 24739
 24740					;**********
 24741
 24742
 24743					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24744					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24745					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24746					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24747					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24748
 24749			045714		SN=SN+1
 24750			004000			XX=XX+XX
 24751						IFE	XX,<XX=1>
 24752	044111	551 00 0 00 004000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24753	044112	270 00 0 00 070300 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24754	044113	312 00 0 00 070301 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24755						STOP		^
 24756	044114	254 04 0 00 044115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24757	044115	324 00 0 00 044116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24758									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24759									;IN THE SUBTEST) TO LOOP ON ERROR^
 24760
 24761					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-5
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24762
 24763
 24764					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24765					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24766					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24767					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24768					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24769
 24770			045715		SN=SN+1
 24771			010000			XX=XX+XX
 24772						IFE	XX,<XX=1>
 24773	044116	551 00 0 00 010000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24774	044117	270 00 0 00 070301 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24775	044120	312 00 0 00 070302 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24776						STOP		^
 24777	044121	254 04 0 00 044122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24778	044122	324 00 0 00 044123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24779									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24780									;IN THE SUBTEST) TO LOOP ON ERROR^
 24781
 24782					;**********
 24783
 24784
 24785					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24786					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24787					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24788					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24789					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24790
 24791			045716		SN=SN+1
 24792			020000			XX=XX+XX
 24793						IFE	XX,<XX=1>
 24794	044123	551 00 0 00 020000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24795	044124	270 00 0 00 070302 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24796	044125	312 00 0 00 070303 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24797						STOP		^
 24798	044126	254 04 0 00 044127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24799	044127	324 00 0 00 044130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24800									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24801									;IN THE SUBTEST) TO LOOP ON ERROR^
 24802
 24803					;**********
 24804
 24805
 24806					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24807					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24808					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24809					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24810					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24811
 24812			045717		SN=SN+1
 24813			040000			XX=XX+XX
 24814						IFE	XX,<XX=1>
 24815	044130	551 00 0 00 040000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24816	044131	270 00 0 00 070303 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-6
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24817	044132	312 00 0 00 070304 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24818						STOP		^
 24819	044133	254 04 0 00 044134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24820	044134	324 00 0 00 044135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24821									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24822									;IN THE SUBTEST) TO LOOP ON ERROR^
 24823
 24824					;**********
 24825
 24826
 24827					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24828					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24829					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24830					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24831					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24832
 24833			045720		SN=SN+1
 24834			100000			XX=XX+XX
 24835						IFE	XX,<XX=1>
 24836	044135	551 00 0 00 100000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24837	044136	270 00 0 00 070304 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24838	044137	312 00 0 00 070305 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24839						STOP		^
 24840	044140	254 04 0 00 044141 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24841	044141	324 00 0 00 044142 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24842									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24843									;IN THE SUBTEST) TO LOOP ON ERROR^
 24844
 24845					;**********
 24846
 24847
 24848					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24849					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24850					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24851					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24852					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24853
 24854			045721		SN=SN+1
 24855			200000			XX=XX+XX
 24856						IFE	XX,<XX=1>
 24857	044142	551 00 0 00 200000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24858	044143	270 00 0 00 070305 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24859	044144	312 00 0 00 070306 		CAME	[XX+XX]		;CHECK ADDER UPON FAILURE
 24860						STOP		^
 24861	044145	254 04 0 00 044146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24862	044146	324 00 0 00 044147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24863									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24864									;IN THE SUBTEST) TO LOOP ON ERROR^
 24865
 24866					;**********
 24867
 24868					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-7
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24869					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24870					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24871					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24872					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24873					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24874			045722		SN=SN+1
 24875			400000			XX=XX+XX
 24876	044147	551 00 0 00 400000 		HRRZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24877	044150	270 00 0 00 070306 		ADD	[XX]		;ADD A FLOATING ONE TO ITSELF	
 24878	044151	312 00 0 00 070307 		CAME	[1,,0]		;CHECK ADDRESS UPON FAILURE
 24879						STOP		^
 24880	044152	254 04 0 00 044153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24881	044153	324 00 0 00 044154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24882									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24883									;IN THE SUBTEST) TO LOOP ON ERROR^
 24884
 24885					;**********
 24886
 24887			000000			XX=0
 24888
 24889						REPEAT	^D17,<
 24890					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24891					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24892					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24893					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24894					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24895					
 24896					SN=SN+1
 24897						XX=XX+XX
 24898						IFE	XX,<XX=1>
 24899						HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24900						ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24901						CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24902						STOP		
 24903					
 24904					;**********
 24905					>
 24906
 24907					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24908					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24909					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24910					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24911					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24912
 24913			045723		SN=SN+1
 24914			000000			XX=XX+XX
 24915			000001			IFE	XX,<XX=1>
 24916	044154	515 00 0 00 000001 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24917	044155	270 00 0 00 070307 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24918	044156	312 00 0 00 070310 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24919						STOP		^
 24920	044157	254 04 0 00 044160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24921	044160	324 00 0 00 044161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24922									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24923									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-8
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24924
 24925					;**********
 24926
 24927
 24928					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24929					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24930					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24931					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24932					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24933
 24934			045724		SN=SN+1
 24935			000002			XX=XX+XX
 24936						IFE	XX,<XX=1>
 24937	044161	515 00 0 00 000002 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24938	044162	270 00 0 00 070310 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24939	044163	312 00 0 00 070311 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24940						STOP		^
 24941	044164	254 04 0 00 044165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24942	044165	324 00 0 00 044166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24943									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24944									;IN THE SUBTEST) TO LOOP ON ERROR^
 24945
 24946					;**********
 24947
 24948
 24949					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24950					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24951					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24952					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24953					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24954
 24955			045725		SN=SN+1
 24956			000004			XX=XX+XX
 24957						IFE	XX,<XX=1>
 24958	044166	515 00 0 00 000004 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24959	044167	270 00 0 00 070311 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24960	044170	312 00 0 00 070312 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24961						STOP		^
 24962	044171	254 04 0 00 044172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24963	044172	324 00 0 00 044173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24964									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24965									;IN THE SUBTEST) TO LOOP ON ERROR^
 24966
 24967					;**********
 24968
 24969
 24970					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24971					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24972					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24973					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24974					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24975
 24976			045726		SN=SN+1
 24977			000010			XX=XX+XX
 24978						IFE	XX,<XX=1>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-9
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 24979	044173	515 00 0 00 000010 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 24980	044174	270 00 0 00 070312 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 24981	044175	312 00 0 00 070313 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 24982						STOP		^
 24983	044176	254 04 0 00 044177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 24984	044177	324 00 0 00 044200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 24985									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 24986									;IN THE SUBTEST) TO LOOP ON ERROR^
 24987
 24988					;**********
 24989
 24990
 24991					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 24992					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 24993					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 24994					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 24995					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 24996
 24997			045727		SN=SN+1
 24998			000020			XX=XX+XX
 24999						IFE	XX,<XX=1>
 25000	044200	515 00 0 00 000020 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25001	044201	270 00 0 00 070313 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25002	044202	312 00 0 00 070314 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25003						STOP		^
 25004	044203	254 04 0 00 044204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25005	044204	324 00 0 00 044205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25007									;IN THE SUBTEST) TO LOOP ON ERROR^
 25008
 25009					;**********
 25010
 25011
 25012					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25013					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25014					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25015					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25016					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25017
 25018			045730		SN=SN+1
 25019			000040			XX=XX+XX
 25020						IFE	XX,<XX=1>
 25021	044205	515 00 0 00 000040 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25022	044206	270 00 0 00 070314 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25023	044207	312 00 0 00 070315 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25024						STOP		^
 25025	044210	254 04 0 00 044211 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25026	044211	324 00 0 00 044212 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25027									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25028									;IN THE SUBTEST) TO LOOP ON ERROR^
 25029
 25030					;**********
 25031
 25032
 25033					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-10
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 25034					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25035					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25036					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25037					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25038
 25039			045731		SN=SN+1
 25040			000100			XX=XX+XX
 25041						IFE	XX,<XX=1>
 25042	044212	515 00 0 00 000100 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25043	044213	270 00 0 00 070315 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25044	044214	312 00 0 00 070316 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25045						STOP		^
 25046	044215	254 04 0 00 044216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25047	044216	324 00 0 00 044217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25048									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25049									;IN THE SUBTEST) TO LOOP ON ERROR^
 25050
 25051					;**********
 25052
 25053
 25054					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25055					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25056					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25057					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25058					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25059
 25060			045732		SN=SN+1
 25061			000200			XX=XX+XX
 25062						IFE	XX,<XX=1>
 25063	044217	515 00 0 00 000200 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25064	044220	270 00 0 00 070316 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25065	044221	312 00 0 00 070264 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25066						STOP		^
 25067	044222	254 04 0 00 044223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25068	044223	324 00 0 00 044224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25070									;IN THE SUBTEST) TO LOOP ON ERROR^
 25071
 25072					;**********
 25073
 25074
 25075					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25076					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25077					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25078					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25079					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25080
 25081			045733		SN=SN+1
 25082			000400			XX=XX+XX
 25083						IFE	XX,<XX=1>
 25084	044224	515 00 0 00 000400 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25085	044225	270 00 0 00 070264 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25086	044226	312 00 0 00 070317 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25087						STOP		^
 25088	044227	254 04 0 00 044230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-11
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 25089	044230	324 00 0 00 044231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25091									;IN THE SUBTEST) TO LOOP ON ERROR^
 25092
 25093					;**********
 25094
 25095
 25096					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25097					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25098					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25099					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25100					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25101
 25102			045734		SN=SN+1
 25103			001000			XX=XX+XX
 25104						IFE	XX,<XX=1>
 25105	044231	515 00 0 00 001000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25106	044232	270 00 0 00 070317 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25107	044233	312 00 0 00 070320 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25108						STOP		^
 25109	044234	254 04 0 00 044235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25110	044235	324 00 0 00 044236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25111									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25112									;IN THE SUBTEST) TO LOOP ON ERROR^
 25113
 25114					;**********
 25115
 25116
 25117					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25118					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25119					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25120					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25121					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25122
 25123			045735		SN=SN+1
 25124			002000			XX=XX+XX
 25125						IFE	XX,<XX=1>
 25126	044236	515 00 0 00 002000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25127	044237	270 00 0 00 070320 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25128	044240	312 00 0 00 070321 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25129						STOP		^
 25130	044241	254 04 0 00 044242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25131	044242	324 00 0 00 044243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25132									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25133									;IN THE SUBTEST) TO LOOP ON ERROR^
 25134
 25135					;**********
 25136
 25137
 25138					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25139					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25140					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25141					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25142					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25143
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-12
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 25144			045736		SN=SN+1
 25145			004000			XX=XX+XX
 25146						IFE	XX,<XX=1>
 25147	044243	515 00 0 00 004000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25148	044244	270 00 0 00 070321 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25149	044245	312 00 0 00 070322 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25150						STOP		^
 25151	044246	254 04 0 00 044247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25152	044247	324 00 0 00 044250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25154									;IN THE SUBTEST) TO LOOP ON ERROR^
 25155
 25156					;**********
 25157
 25158
 25159					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25160					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25161					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25162					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25163					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25164
 25165			045737		SN=SN+1
 25166			010000			XX=XX+XX
 25167						IFE	XX,<XX=1>
 25168	044250	515 00 0 00 010000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25169	044251	270 00 0 00 070322 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25170	044252	312 00 0 00 070323 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25171						STOP		^
 25172	044253	254 04 0 00 044254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25173	044254	324 00 0 00 044255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25174									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25175									;IN THE SUBTEST) TO LOOP ON ERROR^
 25176
 25177					;**********
 25178
 25179
 25180					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25181					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25182					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25183					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25184					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25185
 25186			045740		SN=SN+1
 25187			020000			XX=XX+XX
 25188						IFE	XX,<XX=1>
 25189	044255	515 00 0 00 020000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25190	044256	270 00 0 00 070323 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25191	044257	312 00 0 00 070324 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25192						STOP		^
 25193	044260	254 04 0 00 044261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25194	044261	324 00 0 00 044262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25195									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25196									;IN THE SUBTEST) TO LOOP ON ERROR^
 25197
 25198					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-13
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 25199
 25200
 25201					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25202					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25203					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25204					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25205					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25206
 25207			045741		SN=SN+1
 25208			040000			XX=XX+XX
 25209						IFE	XX,<XX=1>
 25210	044262	515 00 0 00 040000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25211	044263	270 00 0 00 070324 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25212	044264	312 00 0 00 070325 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25213						STOP		^
 25214	044265	254 04 0 00 044266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25215	044266	324 00 0 00 044267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25216									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25217									;IN THE SUBTEST) TO LOOP ON ERROR^
 25218
 25219					;**********
 25220
 25221
 25222					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25223					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25224					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25225					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25226					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25227
 25228			045742		SN=SN+1
 25229			100000			XX=XX+XX
 25230						IFE	XX,<XX=1>
 25231	044267	515 00 0 00 100000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25232	044270	270 00 0 00 070325 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25233	044271	312 00 0 00 070326 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25234						STOP		^
 25235	044272	254 04 0 00 044273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25236	044273	324 00 0 00 044274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25237									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25238									;IN THE SUBTEST) TO LOOP ON ERROR^
 25239
 25240					;**********
 25241
 25242
 25243					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25244					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25245					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25246					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25247					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25248
 25249			045743		SN=SN+1
 25250			200000			XX=XX+XX
 25251						IFE	XX,<XX=1>
 25252	044274	515 00 0 00 200000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25253	044275	270 00 0 00 070326 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-14
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 1 + FLT 1

 25254	044276	312 00 0 00 070256 		CAME	[XX+XX,,0]	;CHECK ADDER UPON FAILURE
 25255						STOP		^
 25256	044277	254 04 0 00 044300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25257	044300	324 00 0 00 044301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25258									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25259									;IN THE SUBTEST) TO LOOP ON ERROR^
 25260
 25261					;**********
 25262
 25263					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ONE
 25264					;ADDED TO A FLOATING ONE IS A FLOATING ONE
 25265					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ONE.
 25266					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ONE THRU ALL 36 BITS OF THE ADDER.
 25267					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25268
 25269			045744		SN=SN+1
 25270			400000			XX=XX+XX
 25271						IFE	XX,<XX=1>
 25272	044301	515 00 0 00 400000 		HRLZI	XX		;PRELOAD AC WITH A FLOATING ONE
 25273	044302	270 00 0 00 070256 		ADD	[XX,,0]		;ADD A FLOATING ONE TO ITSELF	
 25274	044303	312 00 0 00 070253 		CAME	[0,,0]		;CHECK ADDER UPON FAILURE
 25275						STOP		^
 25276	044304	254 04 0 00 044305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25277	044305	324 00 0 00 044306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25278									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25279									;IN THE SUBTEST) TO LOOP ON ERROR^
 25280
 25281					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25282					SUBTTL	SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 
 25283
 25284					;**********
 25285
 25286			046000		SN=46000
 25287			000000			XX=0
 25288
 25289					B46000:	REPEAT	^D17,<
 25290					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25291					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25292					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25293					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25294					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25295					
 25296					SN=SN+1
 25297						XX=<XX+XX+1>&777777
 25298						IFE	<XX-1>,<XX=777776>
 25299						HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25300						ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25301						CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25302						STOP		
 25303					
 25304					;**********
 25305					>
 25306
 25307					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25308					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25309					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25310					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25311					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25312
 25313			046001		SN=SN+1
 25314			000001			XX=<XX+XX+1>&777777
 25315			777776			IFE	<XX-1>,<XX=777776>
 25316	044306	561 00 0 00 777776 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25317	044307	270 00 0 00 070333 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25318	044310	312 00 0 00 070437 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25319						STOP		^
 25320	044311	254 04 0 00 044312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25321	044312	324 00 0 00 044313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25322									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25323									;IN THE SUBTEST) TO LOOP ON ERROR^
 25324
 25325					;**********
 25326
 25327
 25328					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25329					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25330					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25331					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25332					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25333
 25334			046002		SN=SN+1
 25335			777775			XX=<XX+XX+1>&777777
 25336						IFE	<XX-1>,<XX=777776>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-1
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25337	044313	561 00 0 00 777775 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25338	044314	270 00 0 00 070334 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25339	044315	312 00 0 00 070553 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25340						STOP		^
 25341	044316	254 04 0 00 044317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25342	044317	324 00 0 00 044320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25344									;IN THE SUBTEST) TO LOOP ON ERROR^
 25345
 25346					;**********
 25347
 25348
 25349					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25350					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25351					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25352					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25353					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25354
 25355			046003		SN=SN+1
 25356			777773			XX=<XX+XX+1>&777777
 25357						IFE	<XX-1>,<XX=777776>
 25358	044320	561 00 0 00 777773 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25359	044321	270 00 0 00 070335 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25360	044322	312 00 0 00 070554 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25361						STOP		^
 25362	044323	254 04 0 00 044324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25363	044324	324 00 0 00 044325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25364									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25365									;IN THE SUBTEST) TO LOOP ON ERROR^
 25366
 25367					;**********
 25368
 25369
 25370					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25371					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25372					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25373					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25374					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25375
 25376			046004		SN=SN+1
 25377			777767			XX=<XX+XX+1>&777777
 25378						IFE	<XX-1>,<XX=777776>
 25379	044325	561 00 0 00 777767 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25380	044326	270 00 0 00 070336 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25381	044327	312 00 0 00 070555 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25382						STOP		^
 25383	044330	254 04 0 00 044331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25384	044331	324 00 0 00 044332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25386									;IN THE SUBTEST) TO LOOP ON ERROR^
 25387
 25388					;**********
 25389
 25390
 25391					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-2
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25392					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25393					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25394					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25395					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25396
 25397			046005		SN=SN+1
 25398			777757			XX=<XX+XX+1>&777777
 25399						IFE	<XX-1>,<XX=777776>
 25400	044332	561 00 0 00 777757 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25401	044333	270 00 0 00 070337 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25402	044334	312 00 0 00 070556 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25403						STOP		^
 25404	044335	254 04 0 00 044336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25405	044336	324 00 0 00 044337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25406									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25407									;IN THE SUBTEST) TO LOOP ON ERROR^
 25408
 25409					;**********
 25410
 25411
 25412					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25413					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25414					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25415					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25416					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25417
 25418			046006		SN=SN+1
 25419			777737			XX=<XX+XX+1>&777777
 25420						IFE	<XX-1>,<XX=777776>
 25421	044337	561 00 0 00 777737 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25422	044340	270 00 0 00 070340 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25423	044341	312 00 0 00 070557 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25424						STOP		^
 25425	044342	254 04 0 00 044343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25426	044343	324 00 0 00 044344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25427									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25428									;IN THE SUBTEST) TO LOOP ON ERROR^
 25429
 25430					;**********
 25431
 25432
 25433					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25434					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25435					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25436					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25437					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25438
 25439			046007		SN=SN+1
 25440			777677			XX=<XX+XX+1>&777777
 25441						IFE	<XX-1>,<XX=777776>
 25442	044344	561 00 0 00 777677 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25443	044345	270 00 0 00 070341 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25444	044346	312 00 0 00 070560 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25445						STOP		^
 25446	044347	254 04 0 00 044350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-3
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25447	044350	324 00 0 00 044351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25448									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25449									;IN THE SUBTEST) TO LOOP ON ERROR^
 25450
 25451					;**********
 25452
 25453
 25454					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25455					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25456					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25457					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25458					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25459
 25460			046010		SN=SN+1
 25461			777577			XX=<XX+XX+1>&777777
 25462						IFE	<XX-1>,<XX=777776>
 25463	044351	561 00 0 00 777577 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25464	044352	270 00 0 00 070342 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25465	044353	312 00 0 00 070561 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25466						STOP		^
 25467	044354	254 04 0 00 044355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25468	044355	324 00 0 00 044356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25469									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25470									;IN THE SUBTEST) TO LOOP ON ERROR^
 25471
 25472					;**********
 25473
 25474
 25475					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25476					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25477					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25478					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25479					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25480
 25481			046011		SN=SN+1
 25482			777377			XX=<XX+XX+1>&777777
 25483						IFE	<XX-1>,<XX=777776>
 25484	044356	561 00 0 00 777377 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25485	044357	270 00 0 00 070343 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25486	044360	312 00 0 00 070562 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25487						STOP		^
 25488	044361	254 04 0 00 044362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25489	044362	324 00 0 00 044363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25491									;IN THE SUBTEST) TO LOOP ON ERROR^
 25492
 25493					;**********
 25494
 25495
 25496					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25497					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25498					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25499					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25500					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25501
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-4
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25502			046012		SN=SN+1
 25503			776777			XX=<XX+XX+1>&777777
 25504						IFE	<XX-1>,<XX=777776>
 25505	044363	561 00 0 00 776777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25506	044364	270 00 0 00 070344 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25507	044365	312 00 0 00 070563 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25508						STOP		^
 25509	044366	254 04 0 00 044367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25510	044367	324 00 0 00 044370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25512									;IN THE SUBTEST) TO LOOP ON ERROR^
 25513
 25514					;**********
 25515
 25516
 25517					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25518					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25519					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25520					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25521					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25522
 25523			046013		SN=SN+1
 25524			775777			XX=<XX+XX+1>&777777
 25525						IFE	<XX-1>,<XX=777776>
 25526	044370	561 00 0 00 775777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25527	044371	270 00 0 00 070345 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25528	044372	312 00 0 00 070564 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25529						STOP		^
 25530	044373	254 04 0 00 044374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25531	044374	324 00 0 00 044375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25532									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25533									;IN THE SUBTEST) TO LOOP ON ERROR^
 25534
 25535					;**********
 25536
 25537
 25538					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25539					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25540					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25541					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25542					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25543
 25544			046014		SN=SN+1
 25545			773777			XX=<XX+XX+1>&777777
 25546						IFE	<XX-1>,<XX=777776>
 25547	044375	561 00 0 00 773777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25548	044376	270 00 0 00 070346 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25549	044377	312 00 0 00 070565 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25550						STOP		^
 25551	044400	254 04 0 00 044401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25552	044401	324 00 0 00 044402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25553									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25554									;IN THE SUBTEST) TO LOOP ON ERROR^
 25555
 25556					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-5
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25557
 25558
 25559					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25560					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25561					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25562					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25563					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25564
 25565			046015		SN=SN+1
 25566			767777			XX=<XX+XX+1>&777777
 25567						IFE	<XX-1>,<XX=777776>
 25568	044402	561 00 0 00 767777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25569	044403	270 00 0 00 070347 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25570	044404	312 00 0 00 070566 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25571						STOP		^
 25572	044405	254 04 0 00 044406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25573	044406	324 00 0 00 044407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25574									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25575									;IN THE SUBTEST) TO LOOP ON ERROR^
 25576
 25577					;**********
 25578
 25579
 25580					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25581					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25582					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25583					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25584					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25585
 25586			046016		SN=SN+1
 25587			757777			XX=<XX+XX+1>&777777
 25588						IFE	<XX-1>,<XX=777776>
 25589	044407	561 00 0 00 757777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25590	044410	270 00 0 00 070350 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25591	044411	312 00 0 00 070567 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25592						STOP		^
 25593	044412	254 04 0 00 044413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25594	044413	324 00 0 00 044414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25595									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25596									;IN THE SUBTEST) TO LOOP ON ERROR^
 25597
 25598					;**********
 25599
 25600
 25601					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25602					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25603					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25604					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25605					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25606
 25607			046017		SN=SN+1
 25608			737777			XX=<XX+XX+1>&777777
 25609						IFE	<XX-1>,<XX=777776>
 25610	044414	561 00 0 00 737777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25611	044415	270 00 0 00 070351 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-6
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25612	044416	312 00 0 00 070570 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25613						STOP		^
 25614	044417	254 04 0 00 044420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25615	044420	324 00 0 00 044421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25616									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25617									;IN THE SUBTEST) TO LOOP ON ERROR^
 25618
 25619					;**********
 25620
 25621
 25622					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25623					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25624					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25625					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25626					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25627
 25628			046020		SN=SN+1
 25629			677777			XX=<XX+XX+1>&777777
 25630						IFE	<XX-1>,<XX=777776>
 25631	044421	561 00 0 00 677777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25632	044422	270 00 0 00 070352 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25633	044423	312 00 0 00 070571 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25634						STOP		^
 25635	044424	254 04 0 00 044425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25636	044425	324 00 0 00 044426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25638									;IN THE SUBTEST) TO LOOP ON ERROR^
 25639
 25640					;**********
 25641
 25642
 25643					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25644					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25645					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25646					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25647					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25648
 25649			046021		SN=SN+1
 25650			577777			XX=<XX+XX+1>&777777
 25651						IFE	<XX-1>,<XX=777776>
 25652	044426	561 00 0 00 577777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25653	044427	270 00 0 00 070353 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25654	044430	312 00 0 00 070572 		CAME	[-1,,<XX+XX>&777777]	;CHECK ADDER UPON FAILURE
 25655						STOP		^
 25656	044431	254 04 0 00 044432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25657	044432	324 00 0 00 044433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25658									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25659									;IN THE SUBTEST) TO LOOP ON ERROR^
 25660
 25661					;**********
 25662
 25663					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-7
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25664					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25665					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25666					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25667					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25668					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25669
 25670			046022		SN=SN+1
 25671			377777			XX=<XX+XX+1>&777777
 25672	044433	561 00 0 00 377777 		HRROI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25673	044434	270 00 0 00 070354 		ADD	[-1,,XX]	;ADD A FLOATING ZERO TO ITSELF
 25674	044435	312 00 0 00 070461 		CAME	[-2,,-2]	;CHECK ADDER UPON FAILURE
 25675						STOP		^
 25676	044436	254 04 0 00 044437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25677	044437	324 00 0 00 044440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25678									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25679									;IN THE SUBTEST) TO LOOP ON ERROR^
 25680
 25681					;**********
 25682
 25683			000000			XX=0
 25684
 25685						REPEAT	^D18,<
 25686					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25687					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25688					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25689					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25690					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25691					
 25692					SN=SN+1
 25693						XX=<XX+XX+1>&777777
 25694						IFE	<XX-1>,<XX=777776>
 25695						HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25696						ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25697						CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25698						STOP		
 25699					
 25700					;**********
 25701					>
 25702
 25703					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25704					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25705					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25706					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25707					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25708
 25709			046023		SN=SN+1
 25710			000001			XX=<XX+XX+1>&777777
 25711			777776			IFE	<XX-1>,<XX=777776>
 25712	044440	525 00 0 00 777776 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25713	044441	270 00 0 00 070355 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25714	044442	312 00 0 00 070573 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25715						STOP		^
 25716	044443	254 04 0 00 044444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25717	044444	324 00 0 00 044445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25718									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-8
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25719									;IN THE SUBTEST) TO LOOP ON ERROR^
 25720
 25721					;**********
 25722
 25723
 25724					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25725					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25726					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25727					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25728					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25729
 25730			046024		SN=SN+1
 25731			777775			XX=<XX+XX+1>&777777
 25732						IFE	<XX-1>,<XX=777776>
 25733	044445	525 00 0 00 777775 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25734	044446	270 00 0 00 070356 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25735	044447	312 00 0 00 070574 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25736						STOP		^
 25737	044450	254 04 0 00 044451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25738	044451	324 00 0 00 044452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25739									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25740									;IN THE SUBTEST) TO LOOP ON ERROR^
 25741
 25742					;**********
 25743
 25744
 25745					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25746					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25747					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25748					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25749					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25750
 25751			046025		SN=SN+1
 25752			777773			XX=<XX+XX+1>&777777
 25753						IFE	<XX-1>,<XX=777776>
 25754	044452	525 00 0 00 777773 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25755	044453	270 00 0 00 070357 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25756	044454	312 00 0 00 070575 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25757						STOP		^
 25758	044455	254 04 0 00 044456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25759	044456	324 00 0 00 044457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25760									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25761									;IN THE SUBTEST) TO LOOP ON ERROR^
 25762
 25763					;**********
 25764
 25765
 25766					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25767					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25768					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25769					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25770					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25771
 25772			046026		SN=SN+1
 25773			777767			XX=<XX+XX+1>&777777
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-9
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25774						IFE	<XX-1>,<XX=777776>
 25775	044457	525 00 0 00 777767 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25776	044460	270 00 0 00 070360 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25777	044461	312 00 0 00 070576 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25778						STOP		^
 25779	044462	254 04 0 00 044463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25780	044463	324 00 0 00 044464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25781									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25782									;IN THE SUBTEST) TO LOOP ON ERROR^
 25783
 25784					;**********
 25785
 25786
 25787					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25788					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25789					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25790					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25791					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25792
 25793			046027		SN=SN+1
 25794			777757			XX=<XX+XX+1>&777777
 25795						IFE	<XX-1>,<XX=777776>
 25796	044464	525 00 0 00 777757 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25797	044465	270 00 0 00 070361 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25798	044466	312 00 0 00 070577 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25799						STOP		^
 25800	044467	254 04 0 00 044470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25801	044470	324 00 0 00 044471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25802									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25803									;IN THE SUBTEST) TO LOOP ON ERROR^
 25804
 25805					;**********
 25806
 25807
 25808					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25809					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25810					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25811					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25812					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25813
 25814			046030		SN=SN+1
 25815			777737			XX=<XX+XX+1>&777777
 25816						IFE	<XX-1>,<XX=777776>
 25817	044471	525 00 0 00 777737 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25818	044472	270 00 0 00 070362 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25819	044473	312 00 0 00 070600 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25820						STOP		^
 25821	044474	254 04 0 00 044475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25822	044475	324 00 0 00 044476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25824									;IN THE SUBTEST) TO LOOP ON ERROR^
 25825
 25826					;**********
 25827
 25828
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-10
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25829					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25830					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25831					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25832					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25833					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25834
 25835			046031		SN=SN+1
 25836			777677			XX=<XX+XX+1>&777777
 25837						IFE	<XX-1>,<XX=777776>
 25838	044476	525 00 0 00 777677 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25839	044477	270 00 0 00 070363 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25840	044500	312 00 0 00 070601 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25841						STOP		^
 25842	044501	254 04 0 00 044502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25843	044502	324 00 0 00 044503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25844									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25845									;IN THE SUBTEST) TO LOOP ON ERROR^
 25846
 25847					;**********
 25848
 25849
 25850					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25851					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25852					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25853					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25854					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25855
 25856			046032		SN=SN+1
 25857			777577			XX=<XX+XX+1>&777777
 25858						IFE	<XX-1>,<XX=777776>
 25859	044503	525 00 0 00 777577 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25860	044504	270 00 0 00 070364 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25861	044505	312 00 0 00 070602 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25862						STOP		^
 25863	044506	254 04 0 00 044507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25864	044507	324 00 0 00 044510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25865									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25866									;IN THE SUBTEST) TO LOOP ON ERROR^
 25867
 25868					;**********
 25869
 25870
 25871					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25872					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25873					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25874					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25875					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25876
 25877			046033		SN=SN+1
 25878			777377			XX=<XX+XX+1>&777777
 25879						IFE	<XX-1>,<XX=777776>
 25880	044510	525 00 0 00 777377 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25881	044511	270 00 0 00 070365 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25882	044512	312 00 0 00 070603 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25883						STOP		^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-11
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25884	044513	254 04 0 00 044514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25885	044514	324 00 0 00 044515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25886									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25887									;IN THE SUBTEST) TO LOOP ON ERROR^
 25888
 25889					;**********
 25890
 25891
 25892					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25893					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25894					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25895					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25896					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25897
 25898			046034		SN=SN+1
 25899			776777			XX=<XX+XX+1>&777777
 25900						IFE	<XX-1>,<XX=777776>
 25901	044515	525 00 0 00 776777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25902	044516	270 00 0 00 070366 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25903	044517	312 00 0 00 070604 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25904						STOP		^
 25905	044520	254 04 0 00 044521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25906	044521	324 00 0 00 044522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25907									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25908									;IN THE SUBTEST) TO LOOP ON ERROR^
 25909
 25910					;**********
 25911
 25912
 25913					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25914					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25915					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25916					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25917					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25918
 25919			046035		SN=SN+1
 25920			775777			XX=<XX+XX+1>&777777
 25921						IFE	<XX-1>,<XX=777776>
 25922	044522	525 00 0 00 775777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25923	044523	270 00 0 00 070367 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25924	044524	312 00 0 00 070605 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25925						STOP		^
 25926	044525	254 04 0 00 044526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25927	044526	324 00 0 00 044527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25928									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25929									;IN THE SUBTEST) TO LOOP ON ERROR^
 25930
 25931					;**********
 25932
 25933
 25934					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25935					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25936					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25937					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25938					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-12
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25939
 25940			046036		SN=SN+1
 25941			773777			XX=<XX+XX+1>&777777
 25942						IFE	<XX-1>,<XX=777776>
 25943	044527	525 00 0 00 773777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25944	044530	270 00 0 00 070370 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25945	044531	312 00 0 00 070606 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25946						STOP		^
 25947	044532	254 04 0 00 044533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25948	044533	324 00 0 00 044534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25949									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25950									;IN THE SUBTEST) TO LOOP ON ERROR^
 25951
 25952					;**********
 25953
 25954
 25955					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25956					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25957					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25958					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25959					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25960
 25961			046037		SN=SN+1
 25962			767777			XX=<XX+XX+1>&777777
 25963						IFE	<XX-1>,<XX=777776>
 25964	044534	525 00 0 00 767777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25965	044535	270 00 0 00 070371 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25966	044536	312 00 0 00 070607 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25967						STOP		^
 25968	044537	254 04 0 00 044540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25969	044540	324 00 0 00 044541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25970									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25971									;IN THE SUBTEST) TO LOOP ON ERROR^
 25972
 25973					;**********
 25974
 25975
 25976					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25977					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25978					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 25979					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 25980					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 25981
 25982			046040		SN=SN+1
 25983			757777			XX=<XX+XX+1>&777777
 25984						IFE	<XX-1>,<XX=777776>
 25985	044541	525 00 0 00 757777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 25986	044542	270 00 0 00 070372 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 25987	044543	312 00 0 00 070610 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 25988						STOP		^
 25989	044544	254 04 0 00 044545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 25990	044545	324 00 0 00 044546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 25991									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 25992									;IN THE SUBTEST) TO LOOP ON ERROR^
 25993
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-13
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 25994					;**********
 25995
 25996
 25997					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 25998					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 25999					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 26000					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 26001					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 26002
 26003			046041		SN=SN+1
 26004			737777			XX=<XX+XX+1>&777777
 26005						IFE	<XX-1>,<XX=777776>
 26006	044546	525 00 0 00 737777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 26007	044547	270 00 0 00 070373 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 26008	044550	312 00 0 00 070611 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 26009						STOP		^
 26010	044551	254 04 0 00 044552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26011	044552	324 00 0 00 044553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26013									;IN THE SUBTEST) TO LOOP ON ERROR^
 26014
 26015					;**********
 26016
 26017
 26018					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 26019					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 26020					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 26021					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 26022					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 26023
 26024			046042		SN=SN+1
 26025			677777			XX=<XX+XX+1>&777777
 26026						IFE	<XX-1>,<XX=777776>
 26027	044553	525 00 0 00 677777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 26028	044554	270 00 0 00 070374 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 26029	044555	312 00 0 00 070612 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 26030						STOP		^
 26031	044556	254 04 0 00 044557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26032	044557	324 00 0 00 044560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26033									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26034									;IN THE SUBTEST) TO LOOP ON ERROR^
 26035
 26036					;**********
 26037
 26038
 26039					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 26040					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 26041					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 26042					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 26043					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 26044
 26045			046043		SN=SN+1
 26046			577777			XX=<XX+XX+1>&777777
 26047						IFE	<XX-1>,<XX=777776>
 26048	044560	525 00 0 00 577777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-14
DFKAA3	MAC	13-Jan-89 10:22		SUPPLEMENTARY ADDER TESTS - FLT 0 + 0FLT 

 26049	044561	270 00 0 00 070375 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 26050	044562	312 00 0 00 070613 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 26051						STOP		^
 26052	044563	254 04 0 00 044564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26053	044564	324 00 0 00 044565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26054									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26055									;IN THE SUBTEST) TO LOOP ON ERROR^
 26056
 26057					;**********
 26058
 26059
 26060					;THIS TEST VERIFIES THAT THE RESULT OF A FLOATING ZERO
 26061					;ADDED TO A FLOATING ZERO IS A FLOATING ZERO
 26062					;PLACED ONE BIT POSITION LEFT OF THE ORIGINAL FLOATING ZERO.
 26063					;THIS TEST IS REPEATED 36 TIMES TO FLOAT A ZERO THRU ALL 36 BITS OF THE ADDER.
 26064					;THIS TEST IS DESIGNED TO TEST THE ADDER AND RELATED DATA PATHS ONLY.
 26065
 26066			046044		SN=SN+1
 26067			377777			XX=<XX+XX+1>&777777
 26068						IFE	<XX-1>,<XX=777776>
 26069	044565	525 00 0 00 377777 		HRLOI	XX		;PRELOAD AC WITH A FLOATING ZERO
 26070	044566	270 00 0 00 070255 		ADD	[XX,,-1]	;ADD A FLOATING ZERO TO ITSELF
 26071	044567	312 00 0 00 070333 		CAME	[<XX+XX+1>&777777,,-2]	;CHECK ADDER UPON FAILURE
 26072						STOP		^
 26073	044570	254 04 0 00 044571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26074	044571	324 00 0 00 044572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26075									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26076									;IN THE SUBTEST) TO LOOP ON ERROR^
 26077
 26078					;**********
 26079
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26080					SUBTTL	TEST OF AC HARDWARE AND INDEX REGISTERS
 26081
 26082					;NOTE:	AN "*" IN THE COMMENT FIELD OF AN INSTRUCTION INDICATES THAT
 26083					;	IT IS THE TESTED INSTRUCTION.
 26084
 26085
 26086					;**********
 26087
 26088					;THIS TEST VERIFIES THAT AC1 IS ACCESSABLE
 26089					;IN THIS CASE, AC1 IS PRELOADED WITH 1.
 26090					;C(AC1) IS THEN CHECKED FOR A1.  THIS TEST PASSES IF C(AC1)=1.
 26091					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26092
 26093	044572	400 00 0 00 000000 	C100:	SETZ			;CLEAR AC0
 26094	044573	201 01 0 00 000001 		MOVEI	1,1		;PRELOAD AC1 UMTH 1
 26095	044574	302 01 0 00 000001 		CAIE	1,1		;PASS IF C(AC1)=1
 26096						STOP^
 26097	044575	254 04 0 00 044576 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26098	044576	324 00 0 00 044577 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26099									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26100									;IN THE SUBTEST) TO LOOP ON ERROR^
 26101
 26102					;**********
 26103
 26104					;THIS TEST VERIFIES THAT AC2 IS ACCESSABLE.
 26105					;IN THIS CASE, AC2 IS PRELOADED WITH 2.
 26106					;C(AC2) IS THEN CHECKED FOR 2.  THIS TEST PASSES IF C(AC2)=2.
 26107					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26108
 26109	044577	201 02 0 00 000002 	C200:	MOVEI	2,2		;PRELOAD AC2 WITH 2
 26110	044600	302 02 0 00 000002 		CAIE	2,2		;PASS IF C(AC2)=2
 26111						STOP^
 26112	044601	254 04 0 00 044602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26113	044602	324 00 0 00 044603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26114									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26115									;IN THE SUBTEST) TO LOOP ON ERROR^
 26116
 26117					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26118					;THIS TEST VERIFIES THAT AC4 IS ACCESSABLE.
 26119					;IN THIS CASE, AC4 IS PRELOADED WITH 4.
 26120					;C(AC4) IS THEN CHECKED FOR 4.  THIS TEST PASSES IF C(AC4)=4.
 26121					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26122
 26123	044603	201 04 0 00 000004 	C300:	MOVEI	4,4		;PRELOAD AC4 WITH 4 
 26124	044604	302 04 0 00 000004 		CAIE	4,4		;PASS IF C(AC4)=4
 26125						STOP^
 26126	044605	254 04 0 00 044606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26127	044606	324 00 0 00 044607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26129									;IN THE SUBTEST) TO LOOP ON ERROR^
 26130
 26131					;**********
 26132
 26133					;THIS TEST VERIFIES THAT AC10 IS ACCESSABLE.
 26134					;IN THIS CASE, AC10 IS PRELOADED WITH 10.
 26135					;C(AC10) IS THEN CHECKED FOR 10.  THIS TEST PASSES IF C(AC10)=10.
 26136					;IF THIS TEST FAILS, THE AC HARDWARE IS PROBABLY FAULTY
 26137
 26138	044607	201 10 0 00 000010 	C400:	MOVEI	10,10		;PRELOAD AC10 WITH 10
 26139	044610	302 10 0 00 000010 		CAIE	10,10		;PASS IF C(AC10)=10
 26140						STOP^
 26141	044611	254 04 0 00 044612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26142	044612	324 00 0 00 044613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26144									;IN THE SUBTEST) TO LOOP ON ERROR^
 26145
 26146					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26147			000500		SN=500
 26148		777777	777777			ZZ=-1
 26149
 26150					;THIS TEST VERIFIES THAT ALL ACS EXIST
 26151					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26152					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26153					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26154
 26155					C500:	REPEAT	^D16,
 26156					<	ZZ=ZZ+1
 26157						MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR>
 26158			000000			ZZ=ZZ+1
 26159	044613	201 00 0 00 000000 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26160			000001			ZZ=ZZ+1
 26161	044614	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26162			000002			ZZ=ZZ+1
 26163	044615	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26164			000003			ZZ=ZZ+1
 26165	044616	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26166			000004			ZZ=ZZ+1
 26167	044617	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26168			000005			ZZ=ZZ+1
 26169	044620	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26170			000006			ZZ=ZZ+1
 26171	044621	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26172			000007			ZZ=ZZ+1
 26173	044622	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26174			000010			ZZ=ZZ+1
 26175	044623	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26176			000011			ZZ=ZZ+1
 26177	044624	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26178			000012			ZZ=ZZ+1
 26179	044625	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26180			000013			ZZ=ZZ+1
 26181	044626	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26182			000014			ZZ=ZZ+1
 26183	044627	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26184			000015			ZZ=ZZ+1
 26185	044630	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26186			000016			ZZ=ZZ+1
 26187	044631	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26188			000017			ZZ=ZZ+1
 26189	044632	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD EACH AC WITH ITS ADDR
 26190					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26191			000020			ZZ=20
 26192
 26193						REPEAT	^D16,<
 26194					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26195					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26196					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26197					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26198					
 26199					SN=SN+1
 26200						ZZ=ZZ-1
 26201						CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26202						STOP
 26203									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26204					
 26205					;**********
 26206					>
 26207
 26208					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26209					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26210					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26211					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26212
 26213			000501		SN=SN+1
 26214			000017			ZZ=ZZ-1
 26215	044633	302 17 0 00 000017 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26216						STOP^
 26217	044634	254 04 0 00 044635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26218	044635	324 00 0 00 044636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26219									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26220									;IN THE SUBTEST) TO LOOP ON ERROR^
 26221									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26222
 26223					;**********
 26224
 26225
 26226					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26227					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26228					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26229					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26230
 26231			000502		SN=SN+1
 26232			000016			ZZ=ZZ-1
 26233	044636	302 16 0 00 000016 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26234						STOP^
 26235	044637	254 04 0 00 044640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26236	044640	324 00 0 00 044641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26237									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26238									;IN THE SUBTEST) TO LOOP ON ERROR^
 26239									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26240
 26241					;**********
 26242
 26243
 26244					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26245					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26246					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26247					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26248
 26249			000503		SN=SN+1
 26250			000015			ZZ=ZZ-1
 26251	044641	302 15 0 00 000015 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26252						STOP^
 26253	044642	254 04 0 00 044643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26254	044643	324 00 0 00 044644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26256									;IN THE SUBTEST) TO LOOP ON ERROR^
 26257									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26258
 26259					;**********
 26260
 26261
 26262					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26263					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26264					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26265					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26266
 26267			000504		SN=SN+1
 26268			000014			ZZ=ZZ-1
 26269	044644	302 14 0 00 000014 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26270						STOP^
 26271	044645	254 04 0 00 044646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26272	044646	324 00 0 00 044647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26273									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26274									;IN THE SUBTEST) TO LOOP ON ERROR^
 26275									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26276
 26277					;**********
 26278
 26279
 26280					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26281					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26282					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26283					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26284
 26285			000505		SN=SN+1
 26286			000013			ZZ=ZZ-1
 26287	044647	302 13 0 00 000013 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26288						STOP^
 26289	044650	254 04 0 00 044651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26290	044651	324 00 0 00 044652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26291									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26292									;IN THE SUBTEST) TO LOOP ON ERROR^
 26293									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26294
 26295					;**********
 26296
 26297
 26298					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26299					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26300					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26301					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26302
 26303			000506		SN=SN+1
 26304			000012			ZZ=ZZ-1
 26305	044652	302 12 0 00 000012 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26306						STOP^
 26307	044653	254 04 0 00 044654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26308	044654	324 00 0 00 044655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26310									;IN THE SUBTEST) TO LOOP ON ERROR^
 26311									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26312
 26313					;**********
 26314
 26315
 26316					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26317					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26318					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26319					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26320
 26321			000507		SN=SN+1
 26322			000011			ZZ=ZZ-1
 26323	044655	302 11 0 00 000011 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26324						STOP^
 26325	044656	254 04 0 00 044657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26326	044657	324 00 0 00 044660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26327									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26328									;IN THE SUBTEST) TO LOOP ON ERROR^
 26329									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26330
 26331					;**********
 26332
 26333
 26334					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26335					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26336					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26337					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26338
 26339			000510		SN=SN+1
 26340			000010			ZZ=ZZ-1
 26341	044660	302 10 0 00 000010 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26342						STOP^
 26343	044661	254 04 0 00 044662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26344	044662	324 00 0 00 044663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26345									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26346									;IN THE SUBTEST) TO LOOP ON ERROR^
 26347									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26348
 26349					;**********
 26350
 26351
 26352					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26353					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26354					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26355					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26356
 26357			000511		SN=SN+1
 26358			000007			ZZ=ZZ-1
 26359	044663	302 07 0 00 000007 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26360						STOP^
 26361	044664	254 04 0 00 044665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26362	044665	324 00 0 00 044666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26363									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26364									;IN THE SUBTEST) TO LOOP ON ERROR^
 26365									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26366
 26367					;**********
 26368
 26369
 26370					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26371					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26372					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26373					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26374
 26375			000512		SN=SN+1
 26376			000006			ZZ=ZZ-1
 26377	044666	302 06 0 00 000006 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26378						STOP^
 26379	044667	254 04 0 00 044670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26380	044670	324 00 0 00 044671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26381									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26382									;IN THE SUBTEST) TO LOOP ON ERROR^
 26383									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26384
 26385					;**********
 26386
 26387
 26388					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26389					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26390					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26391					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26392
 26393			000513		SN=SN+1
 26394			000005			ZZ=ZZ-1
 26395	044671	302 05 0 00 000005 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26396						STOP^
 26397	044672	254 04 0 00 044673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26398	044673	324 00 0 00 044674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26399									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26400									;IN THE SUBTEST) TO LOOP ON ERROR^
 26401									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26402
 26403					;**********
 26404
 26405
 26406					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26407					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26408					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26409					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26410
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26411			000514		SN=SN+1
 26412			000004			ZZ=ZZ-1
 26413	044674	302 04 0 00 000004 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26414						STOP^
 26415	044675	254 04 0 00 044676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26416	044676	324 00 0 00 044677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26418									;IN THE SUBTEST) TO LOOP ON ERROR^
 26419									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26420
 26421					;**********
 26422
 26423
 26424					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26425					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26426					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26427					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26428
 26429			000515		SN=SN+1
 26430			000003			ZZ=ZZ-1
 26431	044677	302 03 0 00 000003 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26432						STOP^
 26433	044700	254 04 0 00 044701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26434	044701	324 00 0 00 044702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26435									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26436									;IN THE SUBTEST) TO LOOP ON ERROR^
 26437									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26438
 26439					;**********
 26440
 26441
 26442					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26443					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26444					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26445					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26446
 26447			000516		SN=SN+1
 26448			000002			ZZ=ZZ-1
 26449	044702	302 02 0 00 000002 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26450						STOP^
 26451	044703	254 04 0 00 044704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26452	044704	324 00 0 00 044705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26453									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26454									;IN THE SUBTEST) TO LOOP ON ERROR^
 26455									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26456
 26457					;**********
 26458
 26459
 26460					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26461					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26462					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26463					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26464
 26465			000517		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26466			000001			ZZ=ZZ-1
 26467	044705	302 01 0 00 000001 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26468						STOP^
 26469	044706	254 04 0 00 044707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26470	044707	324 00 0 00 044710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26472									;IN THE SUBTEST) TO LOOP ON ERROR^
 26473									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26474
 26475					;**********
 26476
 26477
 26478					;THIS TEST VERIFIES THAT ALL ACS EXIST.
 26479					;FIRST, EACH AC IS PRELOADED WITH ITS OWN ADDRESS;
 26480					;THEN, THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26481					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS
 26482
 26483			000520		SN=SN+1
 26484			000000			ZZ=ZZ-1
 26485	044710	302 00 0 00 000000 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26486						STOP^
 26487	044711	254 04 0 00 044712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26488	044712	324 00 0 00 044713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26489									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26490									;IN THE SUBTEST) TO LOOP ON ERROR^
 26491									;IN CASE OF FAILURE, LOOP TO C500 ADDRESS
 26492
 26493					;**********
 26494
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26495			000600		SN=600
 26496			000000			ZZ=0
 26497
 26498					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26499					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26500					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS; THEN THE CONTENTS OF EACH
 26501					;AC IS CHECKED FOR ITS ADDRESS.  IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26502
 26503					C600:	REPEAT	^D15,
 26504					<	ZZ=ZZ+1
 26505						MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26506						MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.>
 26507			000001			ZZ=ZZ+1
 26508	044713	201 00 0 00 000001 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26509	044714	202 00 0 00 000001 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26510			000002			ZZ=ZZ+1
 26511	044715	201 00 0 00 000002 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26512	044716	202 00 0 00 000002 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26513			000003			ZZ=ZZ+1
 26514	044717	201 00 0 00 000003 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26515	044720	202 00 0 00 000003 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26516			000004			ZZ=ZZ+1
 26517	044721	201 00 0 00 000004 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26518	044722	202 00 0 00 000004 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26519			000005			ZZ=ZZ+1
 26520	044723	201 00 0 00 000005 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26521	044724	202 00 0 00 000005 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26522			000006			ZZ=ZZ+1
 26523	044725	201 00 0 00 000006 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26524	044726	202 00 0 00 000006 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26525			000007			ZZ=ZZ+1
 26526	044727	201 00 0 00 000007 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26527	044730	202 00 0 00 000007 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26528			000010			ZZ=ZZ+1
 26529	044731	201 00 0 00 000010 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26530	044732	202 00 0 00 000010 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26531			000011			ZZ=ZZ+1
 26532	044733	201 00 0 00 000011 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26533	044734	202 00 0 00 000011 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26534			000012			ZZ=ZZ+1
 26535	044735	201 00 0 00 000012 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26536	044736	202 00 0 00 000012 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26537			000013			ZZ=ZZ+1
 26538	044737	201 00 0 00 000013 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26539	044740	202 00 0 00 000013 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26540			000014			ZZ=ZZ+1
 26541	044741	201 00 0 00 000014 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26542	044742	202 00 0 00 000014 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26543			000015			ZZ=ZZ+1
 26544	044743	201 00 0 00 000015 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26545	044744	202 00 0 00 000015 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26546			000016			ZZ=ZZ+1
 26547	044745	201 00 0 00 000016 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26548	044746	202 00 0 00 000016 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26549			000017			ZZ=ZZ+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26550	044747	201 00 0 00 000017 		MOVEI	ZZ		;PRELOAD EACH AC WITH ITS ADDRESS
 26551	044750	202 00 0 00 000017 		MOVEM	ZZ		;BY REFERENCING EACH AC AS MEMORY.
 26552
 26553			000020			ZZ=20
 26554
 26555						REPEAT	^D15,<
 26556					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26557					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26558					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26559					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26560					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26561					
 26562					SN=SN+1
 26563						ZZ=ZZ-1
 26564						CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26565						STOP
 26566									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26567					
 26568					;**********
 26569					>
 26570
 26571					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26572					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26573					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26574					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26575					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26576
 26577			000601		SN=SN+1
 26578			000017			ZZ=ZZ-1
 26579	044751	302 17 0 00 000017 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26580						STOP^
 26581	044752	254 04 0 00 044753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26582	044753	324 00 0 00 044754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26583									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26584									;IN THE SUBTEST) TO LOOP ON ERROR^
 26585									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26586
 26587					;**********
 26588
 26589
 26590					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26591					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26592					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26593					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26594					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26595
 26596			000602		SN=SN+1
 26597			000016			ZZ=ZZ-1
 26598	044754	302 16 0 00 000016 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26599						STOP^
 26600	044755	254 04 0 00 044756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26601	044756	324 00 0 00 044757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26602									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26603									;IN THE SUBTEST) TO LOOP ON ERROR^
 26604									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26605
 26606					;**********
 26607
 26608
 26609					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26610					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26611					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26612					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26613					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26614
 26615			000603		SN=SN+1
 26616			000015			ZZ=ZZ-1
 26617	044757	302 15 0 00 000015 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26618						STOP^
 26619	044760	254 04 0 00 044761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26620	044761	324 00 0 00 044762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26621									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26622									;IN THE SUBTEST) TO LOOP ON ERROR^
 26623									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26624
 26625					;**********
 26626
 26627
 26628					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26629					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26630					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26631					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26632					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26633
 26634			000604		SN=SN+1
 26635			000014			ZZ=ZZ-1
 26636	044762	302 14 0 00 000014 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26637						STOP^
 26638	044763	254 04 0 00 044764 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26639	044764	324 00 0 00 044765 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26640									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26641									;IN THE SUBTEST) TO LOOP ON ERROR^
 26642									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26643
 26644					;**********
 26645
 26646
 26647					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26648					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26649					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26650					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26651					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26652
 26653			000605		SN=SN+1
 26654			000013			ZZ=ZZ-1
 26655	044765	302 13 0 00 000013 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26656						STOP^
 26657	044766	254 04 0 00 044767 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26658	044767	324 00 0 00 044770 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26659									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26660									;IN THE SUBTEST) TO LOOP ON ERROR^
 26661									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26662
 26663					;**********
 26664
 26665
 26666					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26667					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26668					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26669					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26670					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26671
 26672			000606		SN=SN+1
 26673			000012			ZZ=ZZ-1
 26674	044770	302 12 0 00 000012 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26675						STOP^
 26676	044771	254 04 0 00 044772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26677	044772	324 00 0 00 044773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26678									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26679									;IN THE SUBTEST) TO LOOP ON ERROR^
 26680									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26681
 26682					;**********
 26683
 26684
 26685					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26686					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26687					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26688					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26689					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26690
 26691			000607		SN=SN+1
 26692			000011			ZZ=ZZ-1
 26693	044773	302 11 0 00 000011 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26694						STOP^
 26695	044774	254 04 0 00 044775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26696	044775	324 00 0 00 044776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26698									;IN THE SUBTEST) TO LOOP ON ERROR^
 26699									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26700
 26701					;**********
 26702
 26703
 26704					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26705					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26706					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26707					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26708					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26709
 26710			000610		SN=SN+1
 26711			000010			ZZ=ZZ-1
 26712	044776	302 10 0 00 000010 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26713						STOP^
 26714	044777	254 04 0 00 045000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26715	045000	324 00 0 00 045001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26717									;IN THE SUBTEST) TO LOOP ON ERROR^
 26718									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26719
 26720					;**********
 26721
 26722
 26723					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26724					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26725					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26726					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26727					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26728
 26729			000611		SN=SN+1
 26730			000007			ZZ=ZZ-1
 26731	045001	302 07 0 00 000007 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26732						STOP^
 26733	045002	254 04 0 00 045003 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26734	045003	324 00 0 00 045004 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26735									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26736									;IN THE SUBTEST) TO LOOP ON ERROR^
 26737									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26738
 26739					;**********
 26740
 26741
 26742					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26743					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26744					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26745					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26746					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26747
 26748			000612		SN=SN+1
 26749			000006			ZZ=ZZ-1
 26750	045004	302 06 0 00 000006 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26751						STOP^
 26752	045005	254 04 0 00 045006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26753	045006	324 00 0 00 045007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26754									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26755									;IN THE SUBTEST) TO LOOP ON ERROR^
 26756									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26757
 26758					;**********
 26759
 26760
 26761					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26762					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26763					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26764					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26765					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26766
 26767			000613		SN=SN+1
 26768			000005			ZZ=ZZ-1
 26769	045007	302 05 0 00 000005 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26770						STOP^
 26771	045010	254 04 0 00 045011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26772	045011	324 00 0 00 045012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26773									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26774									;IN THE SUBTEST) TO LOOP ON ERROR^
 26775									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26776
 26777					;**********
 26778
 26779
 26780					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26781					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26782					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26783					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26784					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26785
 26786			000614		SN=SN+1
 26787			000004			ZZ=ZZ-1
 26788	045012	302 04 0 00 000004 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26789						STOP^
 26790	045013	254 04 0 00 045014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26791	045014	324 00 0 00 045015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26792									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26793									;IN THE SUBTEST) TO LOOP ON ERROR^
 26794									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26795
 26796					;**********
 26797
 26798
 26799					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26800					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26801					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26802					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26803					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26804
 26805			000615		SN=SN+1
 26806			000003			ZZ=ZZ-1
 26807	045015	302 03 0 00 000003 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26808						STOP^
 26809	045016	254 04 0 00 045017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26810	045017	324 00 0 00 045020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26811									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26812									;IN THE SUBTEST) TO LOOP ON ERROR^
 26813									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26814
 26815					;**********
 26816
 26817
 26818					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26819					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26820					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26821					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26822					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26823
 26824			000616		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26825			000002			ZZ=ZZ-1
 26826	045020	302 02 0 00 000002 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26827						STOP^
 26828	045021	254 04 0 00 045022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26829	045022	324 00 0 00 045023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26830									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26831									;IN THE SUBTEST) TO LOOP ON ERROR^
 26832									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26833
 26834					;**********
 26835
 26836
 26837					;THIS TEST VERIFIES THAT AN ADDRESS WITHIN THE AC RANGE MAY BE ACCESSED AS
 26838					;EITHER AN AC OR A MEMORY LOCATION AND THAT EITHER REFERENCE REFERS TO THE
 26839					;SAME HARDWARE.  EACH AC IS PRELOADED WITH ITS ADDRESS
 26840					;THEN THE CONTENTS OF EACH AC IS CHECKED FOR ITS ADDRESS.
 26841					;IF ANY AC DOES NOT CONTAIN ITS ADDRESS, THIS TEST FAILS.
 26842
 26843			000617		SN=SN+1
 26844			000001			ZZ=ZZ-1
 26845	045023	302 01 0 00 000001 		CAIE	ZZ,ZZ		;CHECK THAT EACH AC CONTAINS ITS OWN ADDRESS
 26846						STOP^
 26847	045024	254 04 0 00 045025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26848	045025	324 00 0 00 045026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26850									;IN THE SUBTEST) TO LOOP ON ERROR^
 26851									;IN CASE OF FAILURE, LOOP TO C600 ADDRESS
 26852
 26853					;**********
 26854
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26855			000700		SN=700
 26856			000000			ZZ=0
 26857
 26858					C700:	REPEAT	^D15,<
 26859					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26860					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26861					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26862					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26863					
 26864					SN=SN+1
 26865						ZZ=ZZ+1
 26866						MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26867						CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26868						STOP
 26869					
 26870					;**********
 26871					>
 26872
 26873					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26874					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26875					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26876					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26877
 26878			000701		SN=SN+1
 26879			000001			ZZ=ZZ+1
 26880	045026	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26881	045027	302 01 0 01 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26882						STOP^
 26883	045030	254 04 0 00 045031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26884	045031	324 00 0 00 045032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26885									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26886									;IN THE SUBTEST) TO LOOP ON ERROR^
 26887
 26888					;**********
 26889
 26890
 26891					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26892					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26893					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26894					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26895
 26896			000702		SN=SN+1
 26897			000002			ZZ=ZZ+1
 26898	045032	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26899	045033	302 02 0 02 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26900						STOP^
 26901	045034	254 04 0 00 045035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26902	045035	324 00 0 00 045036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26904									;IN THE SUBTEST) TO LOOP ON ERROR^
 26905
 26906					;**********
 26907
 26908
 26909					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26910					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26911					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26912					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26913
 26914			000703		SN=SN+1
 26915			000003			ZZ=ZZ+1
 26916	045036	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26917	045037	302 03 0 03 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26918						STOP^
 26919	045040	254 04 0 00 045041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26920	045041	324 00 0 00 045042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26922									;IN THE SUBTEST) TO LOOP ON ERROR^
 26923
 26924					;**********
 26925
 26926
 26927					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26928					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26929					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26930					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26931
 26932			000704		SN=SN+1
 26933			000004			ZZ=ZZ+1
 26934	045042	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26935	045043	302 04 0 04 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26936						STOP^
 26937	045044	254 04 0 00 045045 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26938	045045	324 00 0 00 045046 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26939									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26940									;IN THE SUBTEST) TO LOOP ON ERROR^
 26941
 26942					;**********
 26943
 26944
 26945					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26946					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26947					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26948					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26949
 26950			000705		SN=SN+1
 26951			000005			ZZ=ZZ+1
 26952	045046	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26953	045047	302 05 0 05 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26954						STOP^
 26955	045050	254 04 0 00 045051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26956	045051	324 00 0 00 045052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26957									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26958									;IN THE SUBTEST) TO LOOP ON ERROR^
 26959
 26960					;**********
 26961
 26962
 26963					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26964					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 26965					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26966					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26967
 26968			000706		SN=SN+1
 26969			000006			ZZ=ZZ+1
 26970	045052	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26971	045053	302 06 0 06 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26972						STOP^
 26973	045054	254 04 0 00 045055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26974	045055	324 00 0 00 045056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26975									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26976									;IN THE SUBTEST) TO LOOP ON ERROR^
 26977
 26978					;**********
 26979
 26980
 26981					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 26982					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 26983					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 26984					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 26985
 26986			000707		SN=SN+1
 26987			000007			ZZ=ZZ+1
 26988	045056	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 26989	045057	302 07 0 07 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 26990						STOP^
 26991	045060	254 04 0 00 045061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 26992	045061	324 00 0 00 045062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 26993									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 26994									;IN THE SUBTEST) TO LOOP ON ERROR^
 26995
 26996					;**********
 26997
 26998
 26999					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27000					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27001					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27002					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27003
 27004			000710		SN=SN+1
 27005			000010			ZZ=ZZ+1
 27006	045062	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27007	045063	302 10 0 10 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27008						STOP^
 27009	045064	254 04 0 00 045065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27010	045065	324 00 0 00 045066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27011									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27012									;IN THE SUBTEST) TO LOOP ON ERROR^
 27013
 27014					;**********
 27015
 27016
 27017					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27018					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27019					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27020					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27021
 27022			000711		SN=SN+1
 27023			000011			ZZ=ZZ+1
 27024	045066	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27025	045067	302 11 0 11 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27026						STOP^
 27027	045070	254 04 0 00 045071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27028	045071	324 00 0 00 045072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27029									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27030									;IN THE SUBTEST) TO LOOP ON ERROR^
 27031
 27032					;**********
 27033
 27034
 27035					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27036					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27037					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27038					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27039
 27040			000712		SN=SN+1
 27041			000012			ZZ=ZZ+1
 27042	045072	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27043	045073	302 12 0 12 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27044						STOP^
 27045	045074	254 04 0 00 045075 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27046	045075	324 00 0 00 045076 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27047									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27048									;IN THE SUBTEST) TO LOOP ON ERROR^
 27049
 27050					;**********
 27051
 27052
 27053					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27054					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27055					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27056					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27057
 27058			000713		SN=SN+1
 27059			000013			ZZ=ZZ+1
 27060	045076	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27061	045077	302 13 0 13 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27062						STOP^
 27063	045100	254 04 0 00 045101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27064	045101	324 00 0 00 045102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27065									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27066									;IN THE SUBTEST) TO LOOP ON ERROR^
 27067
 27068					;**********
 27069
 27070
 27071					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27072					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27073					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27074					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27075
 27076			000714		SN=SN+1
 27077			000014			ZZ=ZZ+1
 27078	045102	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27079	045103	302 14 0 14 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27080						STOP^
 27081	045104	254 04 0 00 045105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27082	045105	324 00 0 00 045106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27084									;IN THE SUBTEST) TO LOOP ON ERROR^
 27085
 27086					;**********
 27087
 27088
 27089					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27090					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27091					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27092					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27093
 27094			000715		SN=SN+1
 27095			000015			ZZ=ZZ+1
 27096	045106	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27097	045107	302 15 0 15 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27098						STOP^
 27099	045110	254 04 0 00 045111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27100	045111	324 00 0 00 045112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27101									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27102									;IN THE SUBTEST) TO LOOP ON ERROR^
 27103
 27104					;**********
 27105
 27106
 27107					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27108					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27109					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27110					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27111
 27112			000716		SN=SN+1
 27113			000016			ZZ=ZZ+1
 27114	045112	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27115	045113	302 16 0 16 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27116						STOP^
 27117	045114	254 04 0 00 045115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27118	045115	324 00 0 00 045116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27120									;IN THE SUBTEST) TO LOOP ON ERROR^
 27121
 27122					;**********
 27123
 27124
 27125					;THIS TEST VERIFIES THAT THE INDEX REGISTERS ARE ACCESSABLE.
 27126					;FIRST, AN INDEX REGISTER IS PRELOADED WITH ITS ADDRESS; THEN,
 27127					;IT IS REFERENCED AS AN INDEX REGISTER.  IF IT CONTAINS ITS ADDRESS, THIS TEST PASSES.
 27128					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER.
 27129
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27130			000717		SN=SN+1
 27131			000017			ZZ=ZZ+1
 27132	045116	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD INDEX REGISTER WITH ITS ADDRESS
 27133	045117	302 17 0 17 000000 		CAIE	ZZ,(ZZ)		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27134						STOP^
 27135	045120	254 04 0 00 045121 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27136	045121	324 00 0 00 045122 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27138									;IN THE SUBTEST) TO LOOP ON ERROR^
 27139
 27140					;**********
 27141
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27142			001000		SN=1000
 27143			000000			ZZ=0
 27144
 27145					C1000:	REPEAT	^D15,<
 27146					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27147					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27148					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27149					
 27150					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27151					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27152					
 27153					SN=SN+1
 27154						ZZ=ZZ+1
 27155						MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27156						HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27157						CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27158						STOP
 27159					
 27160					;**********
 27161					>
 27162
 27163					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27164					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27165					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27166
 27167					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27168					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27169
 27170			001001		SN=SN+1
 27171			000001			ZZ=ZZ+1
 27172	045122	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27173	045123	505 01 0 00 000001 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27174	045124	312 01 0 01 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27175						STOP^
 27176	045125	254 04 0 00 045126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27177	045126	324 00 0 00 045127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27178									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27179									;IN THE SUBTEST) TO LOOP ON ERROR^
 27180
 27181					;**********
 27182
 27183
 27184					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27185					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27186					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27187
 27188					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27189					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27190
 27191			001002		SN=SN+1
 27192			000002			ZZ=ZZ+1
 27193	045127	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27194	045130	505 02 0 00 000002 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27195	045131	312 02 0 02 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27196						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27197	045132	254 04 0 00 045133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27198	045133	324 00 0 00 045134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27199									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27200									;IN THE SUBTEST) TO LOOP ON ERROR^
 27201
 27202					;**********
 27203
 27204
 27205					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27206					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27207					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27208
 27209					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27210					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27211
 27212			001003		SN=SN+1
 27213			000003			ZZ=ZZ+1
 27214	045134	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27215	045135	505 03 0 00 000003 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27216	045136	312 03 0 03 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27217						STOP^
 27218	045137	254 04 0 00 045140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27219	045140	324 00 0 00 045141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27220									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27221									;IN THE SUBTEST) TO LOOP ON ERROR^
 27222
 27223					;**********
 27224
 27225
 27226					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27227					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27228					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27229
 27230					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27231					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27232
 27233			001004		SN=SN+1
 27234			000004			ZZ=ZZ+1
 27235	045141	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27236	045142	505 04 0 00 000004 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27237	045143	312 04 0 04 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27238						STOP^
 27239	045144	254 04 0 00 045145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27240	045145	324 00 0 00 045146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27241									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27242									;IN THE SUBTEST) TO LOOP ON ERROR^
 27243
 27244					;**********
 27245
 27246
 27247					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27248					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27249					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27250
 27251					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27252					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27253
 27254			001005		SN=SN+1
 27255			000005			ZZ=ZZ+1
 27256	045146	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27257	045147	505 05 0 00 000005 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27258	045150	312 05 0 05 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27259						STOP^
 27260	045151	254 04 0 00 045152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27261	045152	324 00 0 00 045153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27263									;IN THE SUBTEST) TO LOOP ON ERROR^
 27264
 27265					;**********
 27266
 27267
 27268					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27269					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27270					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27271
 27272					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27273					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27274
 27275			001006		SN=SN+1
 27276			000006			ZZ=ZZ+1
 27277	045153	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27278	045154	505 06 0 00 000006 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27279	045155	312 06 0 06 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27280						STOP^
 27281	045156	254 04 0 00 045157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27282	045157	324 00 0 00 045160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27283									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27284									;IN THE SUBTEST) TO LOOP ON ERROR^
 27285
 27286					;**********
 27287
 27288
 27289					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27290					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27291					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27292
 27293					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27294					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27295
 27296			001007		SN=SN+1
 27297			000007			ZZ=ZZ+1
 27298	045160	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27299	045161	505 07 0 00 000007 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27300	045162	312 07 0 07 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27301						STOP^
 27302	045163	254 04 0 00 045164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27303	045164	324 00 0 00 045165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27304									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27305									;IN THE SUBTEST) TO LOOP ON ERROR^
 27306
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27307					;**********
 27308
 27309
 27310					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27311					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27312					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27313
 27314					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27315					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27316
 27317			001010		SN=SN+1
 27318			000010			ZZ=ZZ+1
 27319	045165	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27320	045166	505 10 0 00 000010 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27321	045167	312 10 0 10 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27322						STOP^
 27323	045170	254 04 0 00 045171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27324	045171	324 00 0 00 045172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27325									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27326									;IN THE SUBTEST) TO LOOP ON ERROR^
 27327
 27328					;**********
 27329
 27330
 27331					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27332					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27333					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27334
 27335					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27336					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27337
 27338			001011		SN=SN+1
 27339			000011			ZZ=ZZ+1
 27340	045172	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27341	045173	505 11 0 00 000011 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27342	045174	312 11 0 11 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27343						STOP^
 27344	045175	254 04 0 00 045176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27345	045176	324 00 0 00 045177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27346									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27347									;IN THE SUBTEST) TO LOOP ON ERROR^
 27348
 27349					;**********
 27350
 27351
 27352					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27353					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27354					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27355
 27356					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27357					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27358
 27359			001012		SN=SN+1
 27360			000012			ZZ=ZZ+1
 27361	045177	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27362	045200	505 12 0 00 000012 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27363	045201	312 12 0 12 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27364						STOP^
 27365	045202	254 04 0 00 045203 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27366	045203	324 00 0 00 045204 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27367									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27368									;IN THE SUBTEST) TO LOOP ON ERROR^
 27369
 27370					;**********
 27371
 27372
 27373					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27374					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27375					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27376
 27377					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27378					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27379
 27380			001013		SN=SN+1
 27381			000013			ZZ=ZZ+1
 27382	045204	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27383	045205	505 13 0 00 000013 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27384	045206	312 13 0 13 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27385						STOP^
 27386	045207	254 04 0 00 045210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27387	045210	324 00 0 00 045211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27388									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27389									;IN THE SUBTEST) TO LOOP ON ERROR^
 27390
 27391					;**********
 27392
 27393
 27394					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27395					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27396					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27397
 27398					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27399					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27400
 27401			001014		SN=SN+1
 27402			000014			ZZ=ZZ+1
 27403	045211	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27404	045212	505 14 0 00 000014 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27405	045213	312 14 0 14 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27406						STOP^
 27407	045214	254 04 0 00 045215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27408	045215	324 00 0 00 045216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27409									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27410									;IN THE SUBTEST) TO LOOP ON ERROR^
 27411
 27412					;**********
 27413
 27414
 27415					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27416					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27417					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27418
 27419					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27420					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27421
 27422			001015		SN=SN+1
 27423			000015			ZZ=ZZ+1
 27424	045216	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27425	045217	505 15 0 00 000015 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27426	045220	312 15 0 15 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27427						STOP^
 27428	045221	254 04 0 00 045222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27429	045222	324 00 0 00 045223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27430									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27431									;IN THE SUBTEST) TO LOOP ON ERROR^
 27432
 27433					;**********
 27434
 27435
 27436					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27437					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27438					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27439
 27440					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27441					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27442
 27443			001016		SN=SN+1
 27444			000016			ZZ=ZZ+1
 27445	045223	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27446	045224	505 16 0 00 000016 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27447	045225	312 16 0 16 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27448						STOP^
 27449	045226	254 04 0 00 045227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27450	045227	324 00 0 00 045230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27452									;IN THE SUBTEST) TO LOOP ON ERROR^
 27453
 27454					;**********
 27455
 27456
 27457					;THIS TEST VERIFIES THAT ALL INDEX REGISTERS INDEX CORRECTLY.
 27458					;FIRST, BOTH HALVES OF THE INDEX REGISTER ARE PRELOADED WITH ITS ADDRESS.
 27459					;THEN, THE INDEX REGISTER IS REFERENCED.  IT IS THEN CHECKED FOR ITS ADDRESS IN BOTH HALVES.
 27460
 27461					;IF IT CONTAINS ITS ADDRESS IN BOTH HALVES THIS TEST PASSES.
 27462					;THIS TEST IS REPEATED 15 TIMES IN ORDER TO TEST EACH INDEX REGISTER
 27463
 27464			001017		SN=SN+1
 27465			000017			ZZ=ZZ+1
 27466	045230	201 17 0 00 000017 		MOVEI	ZZ,ZZ		;PRELOAD BOTH HALVES OF INDEX REG WITH ITS ADDRESS
 27467	045231	505 17 0 00 000017 		HRLI	ZZ,ZZ		;PASS IF INDEX REGISTER CONTAINS ITS ADDRESS
 27468	045232	312 17 0 17 000000 		CAME	ZZ,(ZZ)		;IN BOTH HALVES
 27469						STOP^
 27470	045233	254 04 0 00 045234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27471	045234	324 00 0 00 045235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AC HARDWARE AND INDEX REGISTERS

 27472									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27473									;IN THE SUBTEST) TO LOOP ON ERROR^
 27474
 27475					;**********
 27476
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27477					SUBTTL	TEST OF INDEX REGISTER ADDRESSING
 27478
 27479					;**********
 27480
 27481					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27482					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27483					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27484					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A 0,
 27485					;THE FINAL RESULT IN AC3 SHOULD BE 0.  IF C(AC3)=0, THIS TEST PASSES.
 27486
 27487	045235	476 00 0 00 000003 	C1100:	SETOM	3		;PRELOAD AC3 WITH -1,,1
 27488	045236	402 00 0 00 000001 		SETZM	1		;PRELOAD AC1 WITH 0
 27489	045237	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER 2 WITH 1
 27490	045240	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27491	045241	332 00 0 00 000003 		SKIPE	3		;TEST INDEXING
 27492						STOP^
 27493	045242	254 04 0 00 045243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27494	045243	324 00 0 00 045244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27496									;IN THE SUBTEST) TO LOOP ON ERROR^
 27497
 27498					;**********
 27499
 27500			001200		SN=1200
 27501			000000			ZZ=0
 27502
 27503					C1200:	REPEAT	^D18,<
 27504					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27505					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27506					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27507					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27508					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27509					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27510					
 27511					SN=SN+1
 27512						ZZ=ZZ+ZZ
 27513						IFE	ZZ,<ZZ=1>
 27514						SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27515						MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27516						MOVEI	2,1		;SETUP INDEX REGISTER
 27517						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27518						CAIE	3,ZZ		;TEST INDEXING
 27519						STOP
 27520					
 27521					;**********
 27522					>
 27523
 27524					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27525					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27526					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27527					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27528					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27529					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27530
 27531			001201		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27532			000000			ZZ=ZZ+ZZ
 27533			000001			IFE	ZZ,<ZZ=1>
 27534	045244	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27535	045245	201 01 0 00 000001 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27536	045246	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27537	045247	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27538	045250	302 03 0 00 000001 		CAIE	3,ZZ		;TEST INDEXING
 27539						STOP^
 27540	045251	254 04 0 00 045252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27541	045252	324 00 0 00 045253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27542									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27543									;IN THE SUBTEST) TO LOOP ON ERROR^
 27544
 27545					;**********
 27546
 27547
 27548					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27549					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27550					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27551					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27552					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27553					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27554
 27555			001202		SN=SN+1
 27556			000002			ZZ=ZZ+ZZ
 27557						IFE	ZZ,<ZZ=1>
 27558	045253	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27559	045254	201 01 0 00 000002 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27560	045255	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27561	045256	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27562	045257	302 03 0 00 000002 		CAIE	3,ZZ		;TEST INDEXING
 27563						STOP^
 27564	045260	254 04 0 00 045261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27565	045261	324 00 0 00 045262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27567									;IN THE SUBTEST) TO LOOP ON ERROR^
 27568
 27569					;**********
 27570
 27571
 27572					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27573					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27574					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27575					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27576					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27577					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27578
 27579			001203		SN=SN+1
 27580			000004			ZZ=ZZ+ZZ
 27581						IFE	ZZ,<ZZ=1>
 27582	045262	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27583	045263	201 01 0 00 000004 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27584	045264	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27585	045265	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27586	045266	302 03 0 00 000004 		CAIE	3,ZZ		;TEST INDEXING
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27587						STOP^
 27588	045267	254 04 0 00 045270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27589	045270	324 00 0 00 045271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27590									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27591									;IN THE SUBTEST) TO LOOP ON ERROR^
 27592
 27593					;**********
 27594
 27595
 27596					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27597					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27598					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27599					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27600					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27601					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27602
 27603			001204		SN=SN+1
 27604			000010			ZZ=ZZ+ZZ
 27605						IFE	ZZ,<ZZ=1>
 27606	045271	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27607	045272	201 01 0 00 000010 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27608	045273	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27609	045274	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27610	045275	302 03 0 00 000010 		CAIE	3,ZZ		;TEST INDEXING
 27611						STOP^
 27612	045276	254 04 0 00 045277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27613	045277	324 00 0 00 045300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27614									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27615									;IN THE SUBTEST) TO LOOP ON ERROR^
 27616
 27617					;**********
 27618
 27619
 27620					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27621					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27622					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27623					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27624					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27625					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27626
 27627			001205		SN=SN+1
 27628			000020			ZZ=ZZ+ZZ
 27629						IFE	ZZ,<ZZ=1>
 27630	045300	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27631	045301	201 01 0 00 000020 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27632	045302	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27633	045303	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27634	045304	302 03 0 00 000020 		CAIE	3,ZZ		;TEST INDEXING
 27635						STOP^
 27636	045305	254 04 0 00 045306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27637	045306	324 00 0 00 045307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27638									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27639									;IN THE SUBTEST) TO LOOP ON ERROR^
 27640
 27641					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27642
 27643
 27644					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27645					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27646					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27647					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27648					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27649					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27650
 27651			001206		SN=SN+1
 27652			000040			ZZ=ZZ+ZZ
 27653						IFE	ZZ,<ZZ=1>
 27654	045307	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27655	045310	201 01 0 00 000040 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27656	045311	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27657	045312	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27658	045313	302 03 0 00 000040 		CAIE	3,ZZ		;TEST INDEXING
 27659						STOP^
 27660	045314	254 04 0 00 045315 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27661	045315	324 00 0 00 045316 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27662									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27663									;IN THE SUBTEST) TO LOOP ON ERROR^
 27664
 27665					;**********
 27666
 27667
 27668					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27669					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27670					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27671					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27672					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27673					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27674
 27675			001207		SN=SN+1
 27676			000100			ZZ=ZZ+ZZ
 27677						IFE	ZZ,<ZZ=1>
 27678	045316	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27679	045317	201 01 0 00 000100 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27680	045320	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27681	045321	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27682	045322	302 03 0 00 000100 		CAIE	3,ZZ		;TEST INDEXING
 27683						STOP^
 27684	045323	254 04 0 00 045324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27685	045324	324 00 0 00 045325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27687									;IN THE SUBTEST) TO LOOP ON ERROR^
 27688
 27689					;**********
 27690
 27691
 27692					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27693					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27694					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27695					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27696					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27697					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27698
 27699			001210		SN=SN+1
 27700			000200			ZZ=ZZ+ZZ
 27701						IFE	ZZ,<ZZ=1>
 27702	045325	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27703	045326	201 01 0 00 000200 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27704	045327	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27705	045330	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27706	045331	302 03 0 00 000200 		CAIE	3,ZZ		;TEST INDEXING
 27707						STOP^
 27708	045332	254 04 0 00 045333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27709	045333	324 00 0 00 045334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27711									;IN THE SUBTEST) TO LOOP ON ERROR^
 27712
 27713					;**********
 27714
 27715
 27716					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27717					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27718					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27719					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27720					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27721					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27722
 27723			001211		SN=SN+1
 27724			000400			ZZ=ZZ+ZZ
 27725						IFE	ZZ,<ZZ=1>
 27726	045334	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27727	045335	201 01 0 00 000400 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27728	045336	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27729	045337	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27730	045340	302 03 0 00 000400 		CAIE	3,ZZ		;TEST INDEXING
 27731						STOP^
 27732	045341	254 04 0 00 045342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27733	045342	324 00 0 00 045343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27734									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27735									;IN THE SUBTEST) TO LOOP ON ERROR^
 27736
 27737					;**********
 27738
 27739
 27740					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27741					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27742					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27743					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27744					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27745					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27746
 27747			001212		SN=SN+1
 27748			001000			ZZ=ZZ+ZZ
 27749						IFE	ZZ,<ZZ=1>
 27750	045343	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27751	045344	201 01 0 00 001000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27752	045345	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27753	045346	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27754	045347	302 03 0 00 001000 		CAIE	3,ZZ		;TEST INDEXING
 27755						STOP^
 27756	045350	254 04 0 00 045351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27757	045351	324 00 0 00 045352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27758									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27759									;IN THE SUBTEST) TO LOOP ON ERROR^
 27760
 27761					;**********
 27762
 27763
 27764					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27765					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27766					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27767					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27768					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27769					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27770
 27771			001213		SN=SN+1
 27772			002000			ZZ=ZZ+ZZ
 27773						IFE	ZZ,<ZZ=1>
 27774	045352	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27775	045353	201 01 0 00 002000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27776	045354	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27777	045355	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27778	045356	302 03 0 00 002000 		CAIE	3,ZZ		;TEST INDEXING
 27779						STOP^
 27780	045357	254 04 0 00 045360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27781	045360	324 00 0 00 045361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27782									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27783									;IN THE SUBTEST) TO LOOP ON ERROR^
 27784
 27785					;**********
 27786
 27787
 27788					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27789					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27790					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27791					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27792					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27793					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27794
 27795			001214		SN=SN+1
 27796			004000			ZZ=ZZ+ZZ
 27797						IFE	ZZ,<ZZ=1>
 27798	045361	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27799	045362	201 01 0 00 004000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27800	045363	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27801	045364	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27802	045365	302 03 0 00 004000 		CAIE	3,ZZ		;TEST INDEXING
 27803						STOP^
 27804	045366	254 04 0 00 045367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27805	045367	324 00 0 00 045370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27807									;IN THE SUBTEST) TO LOOP ON ERROR^
 27808
 27809					;**********
 27810
 27811
 27812					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27813					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27814					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27815					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27816					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27817					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27818
 27819			001215		SN=SN+1
 27820			010000			ZZ=ZZ+ZZ
 27821						IFE	ZZ,<ZZ=1>
 27822	045370	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27823	045371	201 01 0 00 010000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27824	045372	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27825	045373	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27826	045374	302 03 0 00 010000 		CAIE	3,ZZ		;TEST INDEXING
 27827						STOP^
 27828	045375	254 04 0 00 045376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27829	045376	324 00 0 00 045377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27830									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27831									;IN THE SUBTEST) TO LOOP ON ERROR^
 27832
 27833					;**********
 27834
 27835
 27836					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27837					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27838					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27839					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27840					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27841					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27842
 27843			001216		SN=SN+1
 27844			020000			ZZ=ZZ+ZZ
 27845						IFE	ZZ,<ZZ=1>
 27846	045377	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27847	045400	201 01 0 00 020000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27848	045401	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27849	045402	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27850	045403	302 03 0 00 020000 		CAIE	3,ZZ		;TEST INDEXING
 27851						STOP^
 27852	045404	254 04 0 00 045405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27853	045405	324 00 0 00 045406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27854									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27855									;IN THE SUBTEST) TO LOOP ON ERROR^
 27856
 27857					;**********
 27858
 27859
 27860					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27861					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-7
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27862					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27863					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27864					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27865					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27866
 27867			001217		SN=SN+1
 27868			040000			ZZ=ZZ+ZZ
 27869						IFE	ZZ,<ZZ=1>
 27870	045406	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27871	045407	201 01 0 00 040000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27872	045410	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27873	045411	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27874	045412	302 03 0 00 040000 		CAIE	3,ZZ		;TEST INDEXING
 27875						STOP^
 27876	045413	254 04 0 00 045414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27877	045414	324 00 0 00 045415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27878									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27879									;IN THE SUBTEST) TO LOOP ON ERROR^
 27880
 27881					;**********
 27882
 27883
 27884					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27885					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27886					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27887					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27888					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27889					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27890
 27891			001220		SN=SN+1
 27892			100000			ZZ=ZZ+ZZ
 27893						IFE	ZZ,<ZZ=1>
 27894	045415	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27895	045416	201 01 0 00 100000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27896	045417	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27897	045420	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27898	045421	302 03 0 00 100000 		CAIE	3,ZZ		;TEST INDEXING
 27899						STOP^
 27900	045422	254 04 0 00 045423 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27901	045423	324 00 0 00 045424 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27902									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27903									;IN THE SUBTEST) TO LOOP ON ERROR^
 27904
 27905					;**********
 27906
 27907
 27908					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27909					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27910					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27911					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27912					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27913					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27914
 27915			001221		SN=SN+1
 27916			200000			ZZ=ZZ+ZZ
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7-8
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27917						IFE	ZZ,<ZZ=1>
 27918	045424	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27919	045425	201 01 0 00 200000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27920	045426	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27921	045427	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27922	045430	302 03 0 00 200000 		CAIE	3,ZZ		;TEST INDEXING
 27923						STOP^
 27924	045431	254 04 0 00 045432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27925	045432	324 00 0 00 045433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27927									;IN THE SUBTEST) TO LOOP ON ERROR^
 27928
 27929					;**********
 27930
 27931
 27932					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27933					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27934					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27935					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27936					;FLOATING 1.  THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27937					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27938
 27939			001222		SN=SN+1
 27940			400000			ZZ=ZZ+ZZ
 27941						IFE	ZZ,<ZZ=1>
 27942	045433	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27943	045434	201 01 0 00 400000 		MOVEI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27944	045435	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27945	045436	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27946	045437	302 03 0 00 400000 		CAIE	3,ZZ		;TEST INDEXING
 27947						STOP^
 27948	045440	254 04 0 00 045441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27949	045441	324 00 0 00 045442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27951									;IN THE SUBTEST) TO LOOP ON ERROR^
 27952
 27953					;**********
 27954
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 27955			001300		SN=1300
 27956			000000			ZZ=0
 27957
 27958					C1300:	REPEAT	^D18,<
 27959					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27960					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27961					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27962					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27963					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27964					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27965					
 27966					SN=SN+1
 27967						ZZ=ZZ+ZZ
 27968						IFE	ZZ,<ZZ=1>
 27969						SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27970						MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27971						MOVEI	2,1		;SETUP INDEX REGISTER
 27972						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27973						CAME	3,[ZZ,,0]	;TEST INDEXING
 27974						STOP
 27975					
 27976					;**********
 27977					>
 27978
 27979					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 27980					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 27981					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 27982					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 27983					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 27984					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 27985
 27986			001301		SN=SN+1
 27987			000000			ZZ=ZZ+ZZ
 27988			000001			IFE	ZZ,<ZZ=1>
 27989	045442	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 27990	045443	205 01 0 00 000001 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 27991	045444	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 27992	045445	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 27993	045446	312 03 0 00 070307 		CAME	3,[ZZ,,0]	;TEST INDEXING
 27994						STOP^
 27995	045447	254 04 0 00 045450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 27996	045450	324 00 0 00 045451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 27997									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 27998									;IN THE SUBTEST) TO LOOP ON ERROR^
 27999
 28000					;**********
 28001
 28002
 28003					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28004					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28005					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28006					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28007					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28008					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28009
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28010			001302		SN=SN+1
 28011			000002			ZZ=ZZ+ZZ
 28012						IFE	ZZ,<ZZ=1>
 28013	045451	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28014	045452	205 01 0 00 000002 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28015	045453	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28016	045454	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28017	045455	312 03 0 00 070310 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28018						STOP^
 28019	045456	254 04 0 00 045457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28020	045457	324 00 0 00 045460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28021									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28022									;IN THE SUBTEST) TO LOOP ON ERROR^
 28023
 28024					;**********
 28025
 28026
 28027					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28028					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28029					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28030					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28031					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28032					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28033
 28034			001303		SN=SN+1
 28035			000004			ZZ=ZZ+ZZ
 28036						IFE	ZZ,<ZZ=1>
 28037	045460	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28038	045461	205 01 0 00 000004 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28039	045462	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28040	045463	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28041	045464	312 03 0 00 070311 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28042						STOP^
 28043	045465	254 04 0 00 045466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28044	045466	324 00 0 00 045467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28045									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28046									;IN THE SUBTEST) TO LOOP ON ERROR^
 28047
 28048					;**********
 28049
 28050
 28051					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28052					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28053					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28054					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28055					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28056					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28057
 28058			001304		SN=SN+1
 28059			000010			ZZ=ZZ+ZZ
 28060						IFE	ZZ,<ZZ=1>
 28061	045467	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28062	045470	205 01 0 00 000010 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28063	045471	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28064	045472	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28065	045473	312 03 0 00 070312 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28066						STOP^
 28067	045474	254 04 0 00 045475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28068	045475	324 00 0 00 045476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28070									;IN THE SUBTEST) TO LOOP ON ERROR^
 28071
 28072					;**********
 28073
 28074
 28075					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28076					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28077					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28078					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28079					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28080					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28081
 28082			001305		SN=SN+1
 28083			000020			ZZ=ZZ+ZZ
 28084						IFE	ZZ,<ZZ=1>
 28085	045476	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28086	045477	205 01 0 00 000020 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28087	045500	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28088	045501	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28089	045502	312 03 0 00 070313 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28090						STOP^
 28091	045503	254 04 0 00 045504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28092	045504	324 00 0 00 045505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28093									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28094									;IN THE SUBTEST) TO LOOP ON ERROR^
 28095
 28096					;**********
 28097
 28098
 28099					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28100					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28101					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28102					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28103					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28104					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28105
 28106			001306		SN=SN+1
 28107			000040			ZZ=ZZ+ZZ
 28108						IFE	ZZ,<ZZ=1>
 28109	045505	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28110	045506	205 01 0 00 000040 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28111	045507	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28112	045510	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28113	045511	312 03 0 00 070314 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28114						STOP^
 28115	045512	254 04 0 00 045513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28116	045513	324 00 0 00 045514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28118									;IN THE SUBTEST) TO LOOP ON ERROR^
 28119
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28120					;**********
 28121
 28122
 28123					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28124					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28125					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28126					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28127					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28128					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28129
 28130			001307		SN=SN+1
 28131			000100			ZZ=ZZ+ZZ
 28132						IFE	ZZ,<ZZ=1>
 28133	045514	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28134	045515	205 01 0 00 000100 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28135	045516	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28136	045517	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28137	045520	312 03 0 00 070315 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28138						STOP^
 28139	045521	254 04 0 00 045522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28140	045522	324 00 0 00 045523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28141									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28142									;IN THE SUBTEST) TO LOOP ON ERROR^
 28143
 28144					;**********
 28145
 28146
 28147					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28148					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28149					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28150					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28151					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28152					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28153
 28154			001310		SN=SN+1
 28155			000200			ZZ=ZZ+ZZ
 28156						IFE	ZZ,<ZZ=1>
 28157	045523	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28158	045524	205 01 0 00 000200 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28159	045525	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28160	045526	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28161	045527	312 03 0 00 070316 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28162						STOP^
 28163	045530	254 04 0 00 045531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28164	045531	324 00 0 00 045532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28165									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28166									;IN THE SUBTEST) TO LOOP ON ERROR^
 28167
 28168					;**********
 28169
 28170
 28171					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28172					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28173					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28174					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28175					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28176					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28177
 28178			001311		SN=SN+1
 28179			000400			ZZ=ZZ+ZZ
 28180						IFE	ZZ,<ZZ=1>
 28181	045532	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28182	045533	205 01 0 00 000400 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28183	045534	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28184	045535	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28185	045536	312 03 0 00 070264 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28186						STOP^
 28187	045537	254 04 0 00 045540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28188	045540	324 00 0 00 045541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28189									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28190									;IN THE SUBTEST) TO LOOP ON ERROR^
 28191
 28192					;**********
 28193
 28194
 28195					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28196					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28197					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28198					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28199					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28200					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28201
 28202			001312		SN=SN+1
 28203			001000			ZZ=ZZ+ZZ
 28204						IFE	ZZ,<ZZ=1>
 28205	045541	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28206	045542	205 01 0 00 001000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28207	045543	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28208	045544	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28209	045545	312 03 0 00 070317 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28210						STOP^
 28211	045546	254 04 0 00 045547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28212	045547	324 00 0 00 045550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28213									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28214									;IN THE SUBTEST) TO LOOP ON ERROR^
 28215
 28216					;**********
 28217
 28218
 28219					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28220					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28221					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28222					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28223					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28224					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28225
 28226			001313		SN=SN+1
 28227			002000			ZZ=ZZ+ZZ
 28228						IFE	ZZ,<ZZ=1>
 28229	045550	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28230	045551	205 01 0 00 002000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28231	045552	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28232	045553	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28233	045554	312 03 0 00 070320 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28234						STOP^
 28235	045555	254 04 0 00 045556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28236	045556	324 00 0 00 045557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28237									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28238									;IN THE SUBTEST) TO LOOP ON ERROR^
 28239
 28240					;**********
 28241
 28242
 28243					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28244					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28245					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28246					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28247					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28248					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28249
 28250			001314		SN=SN+1
 28251			004000			ZZ=ZZ+ZZ
 28252						IFE	ZZ,<ZZ=1>
 28253	045557	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28254	045560	205 01 0 00 004000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28255	045561	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28256	045562	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28257	045563	312 03 0 00 070321 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28258						STOP^
 28259	045564	254 04 0 00 045565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28260	045565	324 00 0 00 045566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28261									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28262									;IN THE SUBTEST) TO LOOP ON ERROR^
 28263
 28264					;**********
 28265
 28266
 28267					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28268					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28269					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28270					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28271					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28272					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28273
 28274			001315		SN=SN+1
 28275			010000			ZZ=ZZ+ZZ
 28276						IFE	ZZ,<ZZ=1>
 28277	045566	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28278	045567	205 01 0 00 010000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28279	045570	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28280	045571	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28281	045572	312 03 0 00 070322 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28282						STOP^
 28283	045573	254 04 0 00 045574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28284	045574	324 00 0 00 045575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28285									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28286									;IN THE SUBTEST) TO LOOP ON ERROR^
 28287
 28288					;**********
 28289
 28290
 28291					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28292					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28293					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28294					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28295					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28296					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28297
 28298			001316		SN=SN+1
 28299			020000			ZZ=ZZ+ZZ
 28300						IFE	ZZ,<ZZ=1>
 28301	045575	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28302	045576	205 01 0 00 020000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28303	045577	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28304	045600	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28305	045601	312 03 0 00 070323 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28306						STOP^
 28307	045602	254 04 0 00 045603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28308	045603	324 00 0 00 045604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28310									;IN THE SUBTEST) TO LOOP ON ERROR^
 28311
 28312					;**********
 28313
 28314
 28315					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28316					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28317					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28318					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28319					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28320					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28321
 28322			001317		SN=SN+1
 28323			040000			ZZ=ZZ+ZZ
 28324						IFE	ZZ,<ZZ=1>
 28325	045604	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28326	045605	205 01 0 00 040000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28327	045606	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28328	045607	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28329	045610	312 03 0 00 070324 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28330						STOP^
 28331	045611	254 04 0 00 045612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28332	045612	324 00 0 00 045613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28333									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28334									;IN THE SUBTEST) TO LOOP ON ERROR^
 28335
 28336					;**********
 28337
 28338
 28339					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-7
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28340					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28341					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28342					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28343					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28344					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28345
 28346			001320		SN=SN+1
 28347			100000			ZZ=ZZ+ZZ
 28348						IFE	ZZ,<ZZ=1>
 28349	045613	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28350	045614	205 01 0 00 100000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28351	045615	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28352	045616	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28353	045617	312 03 0 00 070325 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28354						STOP^
 28355	045620	254 04 0 00 045621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28356	045621	324 00 0 00 045622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28357									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28358									;IN THE SUBTEST) TO LOOP ON ERROR^
 28359
 28360					;**********
 28361
 28362
 28363					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28364					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28365					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28366					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28367					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28368					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28369
 28370			001321		SN=SN+1
 28371			200000			ZZ=ZZ+ZZ
 28372						IFE	ZZ,<ZZ=1>
 28373	045622	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28374	045623	205 01 0 00 200000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28375	045624	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28376	045625	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28377	045626	312 03 0 00 070326 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28378						STOP^
 28379	045627	254 04 0 00 045630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28380	045630	324 00 0 00 045631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28381									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28382									;IN THE SUBTEST) TO LOOP ON ERROR^
 28383
 28384					;**********
 28385
 28386
 28387					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28388					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28389					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28390					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28391					;FLOATING 1, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 1.
 28392					;IF C(AC3)=A FLOATING 1, THIS TEST PASSES.
 28393
 28394			001322		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8-8
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28395			400000			ZZ=ZZ+ZZ
 28396						IFE	ZZ,<ZZ=1>
 28397	045631	476 00 0 00 000003 		SETOM	3		;PRELOAD AC3 WITH -1,,-1
 28398	045632	205 01 0 00 400000 		MOVSI	1,ZZ		;PRELOAD AC1 WITH FLOATING 1
 28399	045633	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28400	045634	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28401	045635	312 03 0 00 070256 		CAME	3,[ZZ,,0]	;TEST INDEXING
 28402						STOP^
 28403	045636	254 04 0 00 045637 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28404	045637	324 00 0 00 045640 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28405									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28406									;IN THE SUBTEST) TO LOOP ON ERROR^
 28407
 28408					;**********
 28409
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28410					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28411					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28412					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28413					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH -1,,-1,
 28414					;THE FINAL RESULT IN AC3 SHOULD BE -1,,-1.  IF C(AC3)=-1,,-1, THIS TEST PASSES.
 28415
 28416	045640	402 00 0 00 000003 	C1400:	SETZM	3		;PRELOAD AC3 WITH 0
 28417	045641	476 00 0 00 000001 		SETOM	1		;PRELOAD AC1 WITH -1,,-1
 28418	045642	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28419	045643	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28420	045644	312 03 0 00 070254 		CAME	3,[-1,,-1]	;TEST INDEXING
 28421						STOP^
 28422	045645	254 04 0 00 045646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28423	045646	324 00 0 00 045647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28424									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28425									;IN THE SUBTEST) TO LOOP ON ERROR^
 28426
 28427					;**********
 28428
 28429			001500		SN=1500
 28430			000000			ZZ=0
 28431
 28432					C1500:	REPEAT	^D18,<
 28433					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28434					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28435					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28436					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28437					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28438					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28439					
 28440					SN=SN+1
 28441						ZZ=<ZZ+ZZ+1>&777777
 28442						IFE	<ZZ-1>,<ZZ=777776>
 28443						SETZM	3		;PRELOAD AC3 WITH 0
 28444						HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28445						MOVEI	2,1		;SETUP INDEX REGISTER
 28446						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28447						CAME	3,[-1,,ZZ]	;TEST INDEXING
 28448						STOP
 28449					
 28450					;**********
 28451					>
 28452
 28453					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28454					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28455					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28456					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28457					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28458					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28459
 28460			001501		SN=SN+1
 28461			000001			ZZ=<ZZ+ZZ+1>&777777
 28462			777776			IFE	<ZZ-1>,<ZZ=777776>
 28463	045647	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28464	045650	561 01 0 00 777776 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28465	045651	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28466	045652	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28467	045653	312 03 0 00 070333 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28468						STOP^
 28469	045654	254 04 0 00 045655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28470	045655	324 00 0 00 045656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28472									;IN THE SUBTEST) TO LOOP ON ERROR^
 28473
 28474					;**********
 28475
 28476
 28477					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28478					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28479					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28480					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28481					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28482					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28483
 28484			001502		SN=SN+1
 28485			777775			ZZ=<ZZ+ZZ+1>&777777
 28486						IFE	<ZZ-1>,<ZZ=777776>
 28487	045656	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28488	045657	561 01 0 00 777775 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28489	045660	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28490	045661	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28491	045662	312 03 0 00 070334 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28492						STOP^
 28493	045663	254 04 0 00 045664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28494	045664	324 00 0 00 045665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28496									;IN THE SUBTEST) TO LOOP ON ERROR^
 28497
 28498					;**********
 28499
 28500
 28501					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28502					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28503					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28504					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28505					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28506					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28507
 28508			001503		SN=SN+1
 28509			777773			ZZ=<ZZ+ZZ+1>&777777
 28510						IFE	<ZZ-1>,<ZZ=777776>
 28511	045665	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28512	045666	561 01 0 00 777773 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28513	045667	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28514	045670	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28515	045671	312 03 0 00 070335 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28516						STOP^
 28517	045672	254 04 0 00 045673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28518	045673	324 00 0 00 045674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28519									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28520									;IN THE SUBTEST) TO LOOP ON ERROR^
 28521
 28522					;**********
 28523
 28524
 28525					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28526					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28527					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28528					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28529					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28530					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28531
 28532			001504		SN=SN+1
 28533			777767			ZZ=<ZZ+ZZ+1>&777777
 28534						IFE	<ZZ-1>,<ZZ=777776>
 28535	045674	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28536	045675	561 01 0 00 777767 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28537	045676	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28538	045677	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28539	045700	312 03 0 00 070336 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28540						STOP^
 28541	045701	254 04 0 00 045702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28542	045702	324 00 0 00 045703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28543									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28544									;IN THE SUBTEST) TO LOOP ON ERROR^
 28545
 28546					;**********
 28547
 28548
 28549					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28550					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28551					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28552					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28553					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28554					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28555
 28556			001505		SN=SN+1
 28557			777757			ZZ=<ZZ+ZZ+1>&777777
 28558						IFE	<ZZ-1>,<ZZ=777776>
 28559	045703	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28560	045704	561 01 0 00 777757 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28561	045705	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28562	045706	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28563	045707	312 03 0 00 070337 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28564						STOP^
 28565	045710	254 04 0 00 045711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28566	045711	324 00 0 00 045712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28567									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28568									;IN THE SUBTEST) TO LOOP ON ERROR^
 28569
 28570					;**********
 28571
 28572
 28573					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28574					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28575					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28576					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28577					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28578					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28579
 28580			001506		SN=SN+1
 28581			777737			ZZ=<ZZ+ZZ+1>&777777
 28582						IFE	<ZZ-1>,<ZZ=777776>
 28583	045712	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28584	045713	561 01 0 00 777737 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28585	045714	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28586	045715	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28587	045716	312 03 0 00 070340 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28588						STOP^
 28589	045717	254 04 0 00 045720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28590	045720	324 00 0 00 045721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28591									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28592									;IN THE SUBTEST) TO LOOP ON ERROR^
 28593
 28594					;**********
 28595
 28596
 28597					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28598					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28599					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28600					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28601					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28602					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28603
 28604			001507		SN=SN+1
 28605			777677			ZZ=<ZZ+ZZ+1>&777777
 28606						IFE	<ZZ-1>,<ZZ=777776>
 28607	045721	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28608	045722	561 01 0 00 777677 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28609	045723	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28610	045724	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28611	045725	312 03 0 00 070341 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28612						STOP^
 28613	045726	254 04 0 00 045727 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28614	045727	324 00 0 00 045730 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28615									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28616									;IN THE SUBTEST) TO LOOP ON ERROR^
 28617
 28618					;**********
 28619
 28620
 28621					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28622					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28623					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28624					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28625					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28626					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28627
 28628			001510		SN=SN+1
 28629			777577			ZZ=<ZZ+ZZ+1>&777777
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28630						IFE	<ZZ-1>,<ZZ=777776>
 28631	045730	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28632	045731	561 01 0 00 777577 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28633	045732	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28634	045733	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28635	045734	312 03 0 00 070342 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28636						STOP^
 28637	045735	254 04 0 00 045736 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28638	045736	324 00 0 00 045737 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28639									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28640									;IN THE SUBTEST) TO LOOP ON ERROR^
 28641
 28642					;**********
 28643
 28644
 28645					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28646					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28647					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28648					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28649					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28650					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28651
 28652			001511		SN=SN+1
 28653			777377			ZZ=<ZZ+ZZ+1>&777777
 28654						IFE	<ZZ-1>,<ZZ=777776>
 28655	045737	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28656	045740	561 01 0 00 777377 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28657	045741	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28658	045742	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28659	045743	312 03 0 00 070343 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28660						STOP^
 28661	045744	254 04 0 00 045745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28662	045745	324 00 0 00 045746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28663									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28664									;IN THE SUBTEST) TO LOOP ON ERROR^
 28665
 28666					;**********
 28667
 28668
 28669					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28670					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28671					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28672					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28673					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28674					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28675
 28676			001512		SN=SN+1
 28677			776777			ZZ=<ZZ+ZZ+1>&777777
 28678						IFE	<ZZ-1>,<ZZ=777776>
 28679	045746	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28680	045747	561 01 0 00 776777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28681	045750	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28682	045751	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28683	045752	312 03 0 00 070344 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28684						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28685	045753	254 04 0 00 045754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28686	045754	324 00 0 00 045755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28687									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28688									;IN THE SUBTEST) TO LOOP ON ERROR^
 28689
 28690					;**********
 28691
 28692
 28693					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28694					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28695					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28696					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28697					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28698					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28699
 28700			001513		SN=SN+1
 28701			775777			ZZ=<ZZ+ZZ+1>&777777
 28702						IFE	<ZZ-1>,<ZZ=777776>
 28703	045755	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28704	045756	561 01 0 00 775777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28705	045757	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28706	045760	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28707	045761	312 03 0 00 070345 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28708						STOP^
 28709	045762	254 04 0 00 045763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28710	045763	324 00 0 00 045764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28711									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28712									;IN THE SUBTEST) TO LOOP ON ERROR^
 28713
 28714					;**********
 28715
 28716
 28717					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28718					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28719					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28720					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28721					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28722					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28723
 28724			001514		SN=SN+1
 28725			773777			ZZ=<ZZ+ZZ+1>&777777
 28726						IFE	<ZZ-1>,<ZZ=777776>
 28727	045764	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28728	045765	561 01 0 00 773777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28729	045766	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28730	045767	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28731	045770	312 03 0 00 070346 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28732						STOP^
 28733	045771	254 04 0 00 045772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28734	045772	324 00 0 00 045773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28735									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28736									;IN THE SUBTEST) TO LOOP ON ERROR^
 28737
 28738					;**********
 28739
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28740
 28741					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28742					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28743					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28744					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28745					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28746					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28747
 28748			001515		SN=SN+1
 28749			767777			ZZ=<ZZ+ZZ+1>&777777
 28750						IFE	<ZZ-1>,<ZZ=777776>
 28751	045773	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28752	045774	561 01 0 00 767777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28753	045775	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28754	045776	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28755	045777	312 03 0 00 070347 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28756						STOP^
 28757	046000	254 04 0 00 046001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28758	046001	324 00 0 00 046002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28759									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28760									;IN THE SUBTEST) TO LOOP ON ERROR^
 28761
 28762					;**********
 28763
 28764
 28765					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28766					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28767					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28768					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28769					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28770					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28771
 28772			001516		SN=SN+1
 28773			757777			ZZ=<ZZ+ZZ+1>&777777
 28774						IFE	<ZZ-1>,<ZZ=777776>
 28775	046002	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28776	046003	561 01 0 00 757777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28777	046004	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28778	046005	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28779	046006	312 03 0 00 070350 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28780						STOP^
 28781	046007	254 04 0 00 046010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28782	046010	324 00 0 00 046011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28783									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28784									;IN THE SUBTEST) TO LOOP ON ERROR^
 28785
 28786					;**********
 28787
 28788
 28789					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28790					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28791					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28792					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28793					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28794					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-7
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28795
 28796			001517		SN=SN+1
 28797			737777			ZZ=<ZZ+ZZ+1>&777777
 28798						IFE	<ZZ-1>,<ZZ=777776>
 28799	046011	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28800	046012	561 01 0 00 737777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28801	046013	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28802	046014	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28803	046015	312 03 0 00 070351 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28804						STOP^
 28805	046016	254 04 0 00 046017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28806	046017	324 00 0 00 046020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28807									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28808									;IN THE SUBTEST) TO LOOP ON ERROR^
 28809
 28810					;**********
 28811
 28812
 28813					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28814					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28815					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28816					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28817					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28818					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28819
 28820			001520		SN=SN+1
 28821			677777			ZZ=<ZZ+ZZ+1>&777777
 28822						IFE	<ZZ-1>,<ZZ=777776>
 28823	046020	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28824	046021	561 01 0 00 677777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28825	046022	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28826	046023	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28827	046024	312 03 0 00 070352 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28828						STOP^
 28829	046025	254 04 0 00 046026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28830	046026	324 00 0 00 046027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28832									;IN THE SUBTEST) TO LOOP ON ERROR^
 28833
 28834					;**********
 28835
 28836
 28837					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28838					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28839					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28840					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28841					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28842					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28843
 28844			001521		SN=SN+1
 28845			577777			ZZ=<ZZ+ZZ+1>&777777
 28846						IFE	<ZZ-1>,<ZZ=777776>
 28847	046027	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28848	046030	561 01 0 00 577777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28849	046031	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9-8
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28850	046032	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28851	046033	312 03 0 00 070353 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28852						STOP^
 28853	046034	254 04 0 00 046035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28854	046035	324 00 0 00 046036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28855									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28856									;IN THE SUBTEST) TO LOOP ON ERROR^
 28857
 28858					;**********
 28859
 28860
 28861					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28862					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28863					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28864					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28865					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28866					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28867
 28868			001522		SN=SN+1
 28869			377777			ZZ=<ZZ+ZZ+1>&777777
 28870						IFE	<ZZ-1>,<ZZ=777776>
 28871	046036	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28872	046037	561 01 0 00 377777 		HRROI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28873	046040	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28874	046041	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28875	046042	312 03 0 00 070354 		CAME	3,[-1,,ZZ]	;TEST INDEXING
 28876						STOP^
 28877	046043	254 04 0 00 046044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28878	046044	324 00 0 00 046045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28879									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28880									;IN THE SUBTEST) TO LOOP ON ERROR^
 28881
 28882					;**********
 28883
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28884			001600		SN=1600
 28885			000000			ZZ=0 
 28886
 28887					C1600:	REPEAT	^D18,<
 28888					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28889					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28890					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28891					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28892					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28893					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28894					
 28895					SN=SN+1
 28896						ZZ=<ZZ+ZZ+1>&777777
 28897						IFE	<ZZ-1>,<ZZ=777776>
 28898						SETZM	3		;PRELOAD AC3 WITH 0
 28899						HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28900						MOVEI	2,1		;SETUP INDEX REGISTER
 28901						MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28902						CAME	3,[ZZ,,-1]	;TEST INDEXING
 28903						STOP
 28904					
 28905					;**********
 28906					>
 28907
 28908					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28909					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28910					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28911					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28912					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28913					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28914
 28915			001601		SN=SN+1
 28916			000001			ZZ=<ZZ+ZZ+1>&777777
 28917			777776			IFE	<ZZ-1>,<ZZ=777776>
 28918	046045	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28919	046046	525 01 0 00 777776 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28920	046047	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28921	046050	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28922	046051	312 03 0 00 070355 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28923						STOP^
 28924	046052	254 04 0 00 046053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28925	046053	324 00 0 00 046054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28927									;IN THE SUBTEST) TO LOOP ON ERROR^
 28928
 28929					;**********
 28930
 28931
 28932					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28933					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28934					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28935					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28936					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28937					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28938
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28939			001602		SN=SN+1
 28940			777775			ZZ=<ZZ+ZZ+1>&777777
 28941						IFE	<ZZ-1>,<ZZ=777776>
 28942	046054	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28943	046055	525 01 0 00 777775 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28944	046056	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28945	046057	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28946	046060	312 03 0 00 070356 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28947						STOP^
 28948	046061	254 04 0 00 046062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28949	046062	324 00 0 00 046063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28951									;IN THE SUBTEST) TO LOOP ON ERROR^
 28952
 28953					;**********
 28954
 28955
 28956					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28957					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28958					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28959					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28960					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28961					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28962
 28963			001603		SN=SN+1
 28964			777773			ZZ=<ZZ+ZZ+1>&777777
 28965						IFE	<ZZ-1>,<ZZ=777776>
 28966	046063	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28967	046064	525 01 0 00 777773 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28968	046065	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28969	046066	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 28970	046067	312 03 0 00 070357 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28971						STOP^
 28972	046070	254 04 0 00 046071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28973	046071	324 00 0 00 046072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28974									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28975									;IN THE SUBTEST) TO LOOP ON ERROR^
 28976
 28977					;**********
 28978
 28979
 28980					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 28981					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 28982					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 28983					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 28984					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 28985					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 28986
 28987			001604		SN=SN+1
 28988			777767			ZZ=<ZZ+ZZ+1>&777777
 28989						IFE	<ZZ-1>,<ZZ=777776>
 28990	046072	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 28991	046073	525 01 0 00 777767 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 28992	046074	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 28993	046075	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 28994	046076	312 03 0 00 070360 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 28995						STOP^
 28996	046077	254 04 0 00 046100 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 28997	046100	324 00 0 00 046101 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 28998									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 28999									;IN THE SUBTEST) TO LOOP ON ERROR^
 29000
 29001					;**********
 29002
 29003
 29004					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29005					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29006					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29007					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29008					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29009					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29010
 29011			001605		SN=SN+1
 29012			777757			ZZ=<ZZ+ZZ+1>&777777
 29013						IFE	<ZZ-1>,<ZZ=777776>
 29014	046101	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29015	046102	525 01 0 00 777757 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29016	046103	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29017	046104	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29018	046105	312 03 0 00 070361 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29019						STOP^
 29020	046106	254 04 0 00 046107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29021	046107	324 00 0 00 046110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29022									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29023									;IN THE SUBTEST) TO LOOP ON ERROR^
 29024
 29025					;**********
 29026
 29027
 29028					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29029					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29030					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29031					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29032					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29033					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29034
 29035			001606		SN=SN+1
 29036			777737			ZZ=<ZZ+ZZ+1>&777777
 29037						IFE	<ZZ-1>,<ZZ=777776>
 29038	046110	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29039	046111	525 01 0 00 777737 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29040	046112	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29041	046113	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29042	046114	312 03 0 00 070362 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29043						STOP^
 29044	046115	254 04 0 00 046116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29045	046116	324 00 0 00 046117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29047									;IN THE SUBTEST) TO LOOP ON ERROR^
 29048
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29049					;**********
 29050
 29051
 29052					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29053					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29054					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29055					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29056					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29057					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29058
 29059			001607		SN=SN+1
 29060			777677			ZZ=<ZZ+ZZ+1>&777777
 29061						IFE	<ZZ-1>,<ZZ=777776>
 29062	046117	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29063	046120	525 01 0 00 777677 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29064	046121	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29065	046122	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29066	046123	312 03 0 00 070363 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29067						STOP^
 29068	046124	254 04 0 00 046125 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29069	046125	324 00 0 00 046126 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29070									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29071									;IN THE SUBTEST) TO LOOP ON ERROR^
 29072
 29073					;**********
 29074
 29075
 29076					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29077					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29078					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29079					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29080					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29081					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29082
 29083			001610		SN=SN+1
 29084			777577			ZZ=<ZZ+ZZ+1>&777777
 29085						IFE	<ZZ-1>,<ZZ=777776>
 29086	046126	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29087	046127	525 01 0 00 777577 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29088	046130	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29089	046131	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29090	046132	312 03 0 00 070364 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29091						STOP^
 29092	046133	254 04 0 00 046134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29093	046134	324 00 0 00 046135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29095									;IN THE SUBTEST) TO LOOP ON ERROR^
 29096
 29097					;**********
 29098
 29099
 29100					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29101					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29102					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29103					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29104					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29105					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29106
 29107			001611		SN=SN+1
 29108			777377			ZZ=<ZZ+ZZ+1>&777777
 29109						IFE	<ZZ-1>,<ZZ=777776>
 29110	046135	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29111	046136	525 01 0 00 777377 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29112	046137	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29113	046140	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29114	046141	312 03 0 00 070365 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29115						STOP^
 29116	046142	254 04 0 00 046143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29117	046143	324 00 0 00 046144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29118									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29119									;IN THE SUBTEST) TO LOOP ON ERROR^
 29120
 29121					;**********
 29122
 29123
 29124					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29125					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29126					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29127					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29128					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29129					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29130
 29131			001612		SN=SN+1
 29132			776777			ZZ=<ZZ+ZZ+1>&777777
 29133						IFE	<ZZ-1>,<ZZ=777776>
 29134	046144	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29135	046145	525 01 0 00 776777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29136	046146	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29137	046147	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29138	046150	312 03 0 00 070366 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29139						STOP^
 29140	046151	254 04 0 00 046152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29141	046152	324 00 0 00 046153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29143									;IN THE SUBTEST) TO LOOP ON ERROR^
 29144
 29145					;**********
 29146
 29147
 29148					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29149					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29150					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29151					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29152					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29153					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29154
 29155			001613		SN=SN+1
 29156			775777			ZZ=<ZZ+ZZ+1>&777777
 29157						IFE	<ZZ-1>,<ZZ=777776>
 29158	046153	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29159	046154	525 01 0 00 775777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29160	046155	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29161	046156	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29162	046157	312 03 0 00 070367 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29163						STOP^
 29164	046160	254 04 0 00 046161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29165	046161	324 00 0 00 046162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29166									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29167									;IN THE SUBTEST) TO LOOP ON ERROR^
 29168
 29169					;**********
 29170
 29171
 29172					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29173					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29174					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29175					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29176					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29177					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29178
 29179			001614		SN=SN+1
 29180			773777			ZZ=<ZZ+ZZ+1>&777777
 29181						IFE	<ZZ-1>,<ZZ=777776>
 29182	046162	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29183	046163	525 01 0 00 773777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29184	046164	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29185	046165	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29186	046166	312 03 0 00 070370 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29187						STOP^
 29188	046167	254 04 0 00 046170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29189	046170	324 00 0 00 046171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29191									;IN THE SUBTEST) TO LOOP ON ERROR^
 29192
 29193					;**********
 29194
 29195
 29196					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29197					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29198					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29199					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29200					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29201					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29202
 29203			001615		SN=SN+1
 29204			767777			ZZ=<ZZ+ZZ+1>&777777
 29205						IFE	<ZZ-1>,<ZZ=777776>
 29206	046171	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29207	046172	525 01 0 00 767777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29208	046173	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29209	046174	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29210	046175	312 03 0 00 070371 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29211						STOP^
 29212	046176	254 04 0 00 046177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29213	046177	324 00 0 00 046200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29214									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29215									;IN THE SUBTEST) TO LOOP ON ERROR^
 29216
 29217					;**********
 29218
 29219
 29220					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29221					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29222					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29223					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29224					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29225					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29226
 29227			001616		SN=SN+1
 29228			757777			ZZ=<ZZ+ZZ+1>&777777
 29229						IFE	<ZZ-1>,<ZZ=777776>
 29230	046200	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29231	046201	525 01 0 00 757777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29232	046202	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29233	046203	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29234	046204	312 03 0 00 070372 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29235						STOP^
 29236	046205	254 04 0 00 046206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29237	046206	324 00 0 00 046207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29238									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29239									;IN THE SUBTEST) TO LOOP ON ERROR^
 29240
 29241					;**********
 29242
 29243
 29244					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29245					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29246					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29247					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29248					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29249					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29250
 29251			001617		SN=SN+1
 29252			737777			ZZ=<ZZ+ZZ+1>&777777
 29253						IFE	<ZZ-1>,<ZZ=777776>
 29254	046207	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29255	046210	525 01 0 00 737777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29256	046211	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29257	046212	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29258	046213	312 03 0 00 070373 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29259						STOP^
 29260	046214	254 04 0 00 046215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29261	046215	324 00 0 00 046216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29263									;IN THE SUBTEST) TO LOOP ON ERROR^
 29264
 29265					;**********
 29266
 29267
 29268					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-7
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29269					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29270					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29271					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29272					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29273					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29274
 29275			001620		SN=SN+1
 29276			677777			ZZ=<ZZ+ZZ+1>&777777
 29277						IFE	<ZZ-1>,<ZZ=777776>
 29278	046216	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29279	046217	525 01 0 00 677777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29280	046220	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29281	046221	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29282	046222	312 03 0 00 070374 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29283						STOP^
 29284	046223	254 04 0 00 046224 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29285	046224	324 00 0 00 046225 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29287									;IN THE SUBTEST) TO LOOP ON ERROR^
 29288
 29289					;**********
 29290
 29291
 29292					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29293					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29294					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29295					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29296					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29297					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29298
 29299			001621		SN=SN+1
 29300			577777			ZZ=<ZZ+ZZ+1>&777777
 29301						IFE	<ZZ-1>,<ZZ=777776>
 29302	046225	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29303	046226	525 01 0 00 577777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29304	046227	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29305	046230	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29306	046231	312 03 0 00 070375 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29307						STOP^
 29308	046232	254 04 0 00 046233 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29309	046233	324 00 0 00 046234 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29310									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29311									;IN THE SUBTEST) TO LOOP ON ERROR^
 29312
 29313					;**********
 29314
 29315
 29316					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29317					;IN THIS TEST, A MOVE INSTRUCTION USING INDEXING IS EXECUTED.  THE MOVE INSTRUCTION
 29318					;SHOULD PLACE THE CONTENTS OF THE LOCATION SPECIFIED BY INDEX REGISTER 2 INTO AC3.
 29319					;SINCE INDEX REGISTER 2 WAS PRELOADED WITH A 1 AND AC1 WAS PRELOADED WITH A
 29320					;FLOATING 0, THE FINAL RESULT IN AC3 SHOULD BE A FLOATING 0.
 29321					;IF C(AC3)=A FLOATING 0, THIS TEST PASSES.
 29322
 29323			001622		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10-8
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29324			377777			ZZ=<ZZ+ZZ+1>&777777
 29325						IFE	<ZZ-1>,<ZZ=777776>
 29326	046234	402 00 0 00 000003 		SETZM	3		;PRELOAD AC3 WITH 0
 29327	046235	525 01 0 00 377777 		HRLOI	1,ZZ		;PRELOAD AC1 WITH FLOATING 0
 29328	046236	201 02 0 00 000001 		MOVEI	2,1		;SETUP INDEX REGISTER
 29329	046237	200 03 0 02 000000 		MOVE	3,(2)		;*FWT FROM INDEXED LOCATION
 29330	046240	312 03 0 00 070255 		CAME	3,[ZZ,,-1]	;TEST INDEXING
 29331						STOP^
 29332	046241	254 04 0 00 046242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29333	046242	324 00 0 00 046243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29334									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29335									;IN THE SUBTEST) TO LOOP ON ERROR^
 29336
 29337					;**********
 29338
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29339					;VERIFY INDEXING WHERE 'E' IS NON-ZERO
 29340
 29341			001700		SN=1700
 29342		777777	777777			ZZ=-1
 29343		777777	777770			XX=-10
 29344
 29345					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29346					;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
 29347					;WHERE ZZ+1 IS THE INDEX REG.  THE AC IS PRELOADED WITH ITS OWN ADDRESS, 0,,ZZ.
 29348					;CAIE IS USED TO TEST THE INDEXING OPERATION.
 29349					;IF THE RESULT IN C(AC)=XX+C(ZZ+1 - RIGHT), THIS TEST PASSES.
 29350					;XX+C(ZZ+1 - RIGHT) SHOULD = ZZ.
 29351
 29352					C1700:	REPEAT	^D15,
 29353					<SN=SN+1
 29354						ZZ=ZZ+1
 29355						XX=XX+3
 29356						MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29357						MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29358						CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29359						STOP
 29360					
 29361					;**********
 29362					>
 29363			001701		SN=SN+1
 29364			000000			ZZ=ZZ+1
 29365		777777	777773			XX=XX+3
 29366	046243	201 01 0 00 000005 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29367	046244	201 00 0 00 000000 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29368	046245	302 00 0 01 777773 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29369						STOP^
 29370	046246	254 04 0 00 046247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29371	046247	324 00 0 00 046250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29372									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29373									;IN THE SUBTEST) TO LOOP ON ERROR^
 29374
 29375					;**********
 29376
 29377			001702		SN=SN+1
 29378			000001			ZZ=ZZ+1
 29379		777777	777776			XX=XX+3
 29380	046250	201 02 0 00 000003 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29381	046251	201 01 0 00 000001 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29382	046252	302 01 0 02 777776 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29383						STOP^
 29384	046253	254 04 0 00 046254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29385	046254	324 00 0 00 046255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29386									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29387									;IN THE SUBTEST) TO LOOP ON ERROR^
 29388
 29389					;**********
 29390
 29391			001703		SN=SN+1
 29392			000002			ZZ=ZZ+1
 29393			000001			XX=XX+3
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29394	046255	201 03 0 00 000001 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29395	046256	201 02 0 00 000002 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29396	046257	302 02 0 03 000001 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29397						STOP^
 29398	046260	254 04 0 00 046261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29399	046261	324 00 0 00 046262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29401									;IN THE SUBTEST) TO LOOP ON ERROR^
 29402
 29403					;**********
 29404
 29405			001704		SN=SN+1
 29406			000003			ZZ=ZZ+1
 29407			000004			XX=XX+3
 29408	046262	201 04 0 00 777777 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29409	046263	201 03 0 00 000003 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29410	046264	302 03 0 04 000004 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29411						STOP^
 29412	046265	254 04 0 00 046266 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29413	046266	324 00 0 00 046267 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29414									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29415									;IN THE SUBTEST) TO LOOP ON ERROR^
 29416
 29417					;**********
 29418
 29419			001705		SN=SN+1
 29420			000004			ZZ=ZZ+1
 29421			000007			XX=XX+3
 29422	046267	201 05 0 00 777775 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29423	046270	201 04 0 00 000004 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29424	046271	302 04 0 05 000007 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29425						STOP^
 29426	046272	254 04 0 00 046273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29427	046273	324 00 0 00 046274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29429									;IN THE SUBTEST) TO LOOP ON ERROR^
 29430
 29431					;**********
 29432
 29433			001706		SN=SN+1
 29434			000005			ZZ=ZZ+1
 29435			000012			XX=XX+3
 29436	046274	201 06 0 00 777773 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29437	046275	201 05 0 00 000005 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29438	046276	302 05 0 06 000012 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29439						STOP^
 29440	046277	254 04 0 00 046300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29441	046300	324 00 0 00 046301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29442									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29443									;IN THE SUBTEST) TO LOOP ON ERROR^
 29444
 29445					;**********
 29446
 29447			001707		SN=SN+1
 29448			000006			ZZ=ZZ+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-2
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29449			000015			XX=XX+3
 29450	046301	201 07 0 00 777771 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29451	046302	201 06 0 00 000006 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29452	046303	302 06 0 07 000015 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29453						STOP^
 29454	046304	254 04 0 00 046305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29455	046305	324 00 0 00 046306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29457									;IN THE SUBTEST) TO LOOP ON ERROR^
 29458
 29459					;**********
 29460
 29461			001710		SN=SN+1
 29462			000007			ZZ=ZZ+1
 29463			000020			XX=XX+3
 29464	046306	201 10 0 00 777767 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29465	046307	201 07 0 00 000007 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29466	046310	302 07 0 10 000020 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29467						STOP^
 29468	046311	254 04 0 00 046312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29469	046312	324 00 0 00 046313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29470									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29471									;IN THE SUBTEST) TO LOOP ON ERROR^
 29472
 29473					;**********
 29474
 29475			001711		SN=SN+1
 29476			000010			ZZ=ZZ+1
 29477			000023			XX=XX+3
 29478	046313	201 11 0 00 777765 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29479	046314	201 10 0 00 000010 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29480	046315	302 10 0 11 000023 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29481						STOP^
 29482	046316	254 04 0 00 046317 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29483	046317	324 00 0 00 046320 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29485									;IN THE SUBTEST) TO LOOP ON ERROR^
 29486
 29487					;**********
 29488
 29489			001712		SN=SN+1
 29490			000011			ZZ=ZZ+1
 29491			000026			XX=XX+3
 29492	046320	201 12 0 00 777763 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29493	046321	201 11 0 00 000011 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29494	046322	302 11 0 12 000026 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29495						STOP^
 29496	046323	254 04 0 00 046324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29497	046324	324 00 0 00 046325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29498									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29499									;IN THE SUBTEST) TO LOOP ON ERROR^
 29500
 29501					;**********
 29502
 29503			001713		SN=SN+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-3
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29504			000012			ZZ=ZZ+1
 29505			000031			XX=XX+3
 29506	046325	201 13 0 00 777761 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29507	046326	201 12 0 00 000012 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29508	046327	302 12 0 13 000031 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29509						STOP^
 29510	046330	254 04 0 00 046331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29511	046331	324 00 0 00 046332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29512									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29513									;IN THE SUBTEST) TO LOOP ON ERROR^
 29514
 29515					;**********
 29516
 29517			001714		SN=SN+1
 29518			000013			ZZ=ZZ+1
 29519			000034			XX=XX+3
 29520	046332	201 14 0 00 777757 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29521	046333	201 13 0 00 000013 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29522	046334	302 13 0 14 000034 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29523						STOP^
 29524	046335	254 04 0 00 046336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29525	046336	324 00 0 00 046337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29526									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29527									;IN THE SUBTEST) TO LOOP ON ERROR^
 29528
 29529					;**********
 29530
 29531			001715		SN=SN+1
 29532			000014			ZZ=ZZ+1
 29533			000037			XX=XX+3
 29534	046337	201 15 0 00 777755 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29535	046340	201 14 0 00 000014 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29536	046341	302 14 0 15 000037 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29537						STOP^
 29538	046342	254 04 0 00 046343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29539	046343	324 00 0 00 046344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29541									;IN THE SUBTEST) TO LOOP ON ERROR^
 29542
 29543					;**********
 29544
 29545			001716		SN=SN+1
 29546			000015			ZZ=ZZ+1
 29547			000042			XX=XX+3
 29548	046344	201 16 0 00 777753 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29549	046345	201 15 0 00 000015 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29550	046346	302 15 0 16 000042 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29551						STOP^
 29552	046347	254 04 0 00 046350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29553	046350	324 00 0 00 046351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29554									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29555									;IN THE SUBTEST) TO LOOP ON ERROR^
 29556
 29557					;**********
 29558
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-4
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29559			001717		SN=SN+1
 29560			000016			ZZ=ZZ+1
 29561			000045			XX=XX+3
 29562	046351	201 17 0 00 777751 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29563	046352	201 16 0 00 000016 		MOVEI	ZZ,ZZ		;PRELOAD AC WITH 0,,ZZ
 29564	046353	302 16 0 17 000045 		CAIE	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29565						STOP^
 29566	046354	254 04 0 00 046355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29567	046355	324 00 0 00 046356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29568									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29569									;IN THE SUBTEST) TO LOOP ON ERROR^
 29570
 29571					;**********
 29572
 29573					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-5
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29574			002000		SN=2000
 29575		777777	777777			ZZ=-1
 29576		777777	777760			XX=-20
 29577
 29578					;THIS TEST VERIFIES THAT INDEX REGISTER ADDRESSING FUNCTIONS CORRECTLY.
 29579					;IN THIS TEST, THE INDEX REG IS SET-UP WITH MOVEI ZZ+1,ZZ-XX,
 29580					;WHERE ZZ+1 IS THE INDEX REG.  INDEXING IS TESTED BY LOADING
 29581					;THE AC VIA MOVEI ZZ,XX(ZZ+1), WHERE XX+C(ZZ+1)=ZZ.
 29582					;IF THE RESULT IN THE AC EQUALS 0,,ZZ, THIS TEST PASSES.
 29583
 29584					C2000:	REPEAT	^D15,
 29585					<SN=SN+1
 29586						ZZ=ZZ+1
 29587						XX=XX+5
 29588						MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29589						MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29590						CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29591						STOP
 29592					
 29593					;**********
 29594					>
 29595			002001		SN=SN+1
 29596			000000			ZZ=ZZ+1
 29597		777777	777765			XX=XX+5
 29598	046356	201 01 0 00 000013 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29599	046357	201 00 0 01 777765 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29600	046360	302 00 0 00 000000 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29601						STOP^
 29602	046361	254 04 0 00 046362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29603	046362	324 00 0 00 046363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29604									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29605									;IN THE SUBTEST) TO LOOP ON ERROR^
 29606
 29607					;**********
 29608
 29609			002002		SN=SN+1
 29610			000001			ZZ=ZZ+1
 29611		777777	777772			XX=XX+5
 29612	046363	201 02 0 00 000007 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29613	046364	201 01 0 02 777772 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29614	046365	302 01 0 00 000001 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29615						STOP^
 29616	046366	254 04 0 00 046367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29617	046367	324 00 0 00 046370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29618									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29619									;IN THE SUBTEST) TO LOOP ON ERROR^
 29620
 29621					;**********
 29622
 29623			002003		SN=SN+1
 29624			000002			ZZ=ZZ+1
 29625		777777	777777			XX=XX+5
 29626	046370	201 03 0 00 000003 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29627	046371	201 02 0 03 777777 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29628	046372	302 02 0 00 000002 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-6
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29629						STOP^
 29630	046373	254 04 0 00 046374 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29631	046374	324 00 0 00 046375 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29632									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29633									;IN THE SUBTEST) TO LOOP ON ERROR^
 29634
 29635					;**********
 29636
 29637			002004		SN=SN+1
 29638			000003			ZZ=ZZ+1
 29639			000004			XX=XX+5
 29640	046375	201 04 0 00 777777 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29641	046376	201 03 0 04 000004 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29642	046377	302 03 0 00 000003 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29643						STOP^
 29644	046400	254 04 0 00 046401 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29645	046401	324 00 0 00 046402 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29646									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29647									;IN THE SUBTEST) TO LOOP ON ERROR^
 29648
 29649					;**********
 29650
 29651			002005		SN=SN+1
 29652			000004			ZZ=ZZ+1
 29653			000011			XX=XX+5
 29654	046402	201 05 0 00 777773 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29655	046403	201 04 0 05 000011 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29656	046404	302 04 0 00 000004 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29657						STOP^
 29658	046405	254 04 0 00 046406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29659	046406	324 00 0 00 046407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29661									;IN THE SUBTEST) TO LOOP ON ERROR^
 29662
 29663					;**********
 29664
 29665			002006		SN=SN+1
 29666			000005			ZZ=ZZ+1
 29667			000016			XX=XX+5
 29668	046407	201 06 0 00 777767 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29669	046410	201 05 0 06 000016 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29670	046411	302 05 0 00 000005 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29671						STOP^
 29672	046412	254 04 0 00 046413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29673	046413	324 00 0 00 046414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29674									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29675									;IN THE SUBTEST) TO LOOP ON ERROR^
 29676
 29677					;**********
 29678
 29679			002007		SN=SN+1
 29680			000006			ZZ=ZZ+1
 29681			000023			XX=XX+5
 29682	046414	201 07 0 00 777763 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29683	046415	201 06 0 07 000023 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-7
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29684	046416	302 06 0 00 000006 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29685						STOP^
 29686	046417	254 04 0 00 046420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29687	046420	324 00 0 00 046421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29688									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29689									;IN THE SUBTEST) TO LOOP ON ERROR^
 29690
 29691					;**********
 29692
 29693			002010		SN=SN+1
 29694			000007			ZZ=ZZ+1
 29695			000030			XX=XX+5
 29696	046421	201 10 0 00 777757 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29697	046422	201 07 0 10 000030 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29698	046423	302 07 0 00 000007 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29699						STOP^
 29700	046424	254 04 0 00 046425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29701	046425	324 00 0 00 046426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29703									;IN THE SUBTEST) TO LOOP ON ERROR^
 29704
 29705					;**********
 29706
 29707			002011		SN=SN+1
 29708			000010			ZZ=ZZ+1
 29709			000035			XX=XX+5
 29710	046426	201 11 0 00 777753 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29711	046427	201 10 0 11 000035 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29712	046430	302 10 0 00 000010 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29713						STOP^
 29714	046431	254 04 0 00 046432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29715	046432	324 00 0 00 046433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29716									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29717									;IN THE SUBTEST) TO LOOP ON ERROR^
 29718
 29719					;**********
 29720
 29721			002012		SN=SN+1
 29722			000011			ZZ=ZZ+1
 29723			000042			XX=XX+5
 29724	046433	201 12 0 00 777747 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29725	046434	201 11 0 12 000042 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29726	046435	302 11 0 00 000011 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29727						STOP^
 29728	046436	254 04 0 00 046437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29729	046437	324 00 0 00 046440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29730									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29731									;IN THE SUBTEST) TO LOOP ON ERROR^
 29732
 29733					;**********
 29734
 29735			002013		SN=SN+1
 29736			000012			ZZ=ZZ+1
 29737			000047			XX=XX+5
 29738	046440	201 13 0 00 777743 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-8
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29739	046441	201 12 0 13 000047 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29740	046442	302 12 0 00 000012 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29741						STOP^
 29742	046443	254 04 0 00 046444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29743	046444	324 00 0 00 046445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29744									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29745									;IN THE SUBTEST) TO LOOP ON ERROR^
 29746
 29747					;**********
 29748
 29749			002014		SN=SN+1
 29750			000013			ZZ=ZZ+1
 29751			000054			XX=XX+5
 29752	046445	201 14 0 00 777737 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29753	046446	201 13 0 14 000054 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29754	046447	302 13 0 00 000013 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29755						STOP^
 29756	046450	254 04 0 00 046451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29757	046451	324 00 0 00 046452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29758									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29759									;IN THE SUBTEST) TO LOOP ON ERROR^
 29760
 29761					;**********
 29762
 29763			002015		SN=SN+1
 29764			000014			ZZ=ZZ+1
 29765			000061			XX=XX+5
 29766	046452	201 15 0 00 777733 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29767	046453	201 14 0 15 000061 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29768	046454	302 14 0 00 000014 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29769						STOP^
 29770	046455	254 04 0 00 046456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29771	046456	324 00 0 00 046457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29773									;IN THE SUBTEST) TO LOOP ON ERROR^
 29774
 29775					;**********
 29776
 29777			002016		SN=SN+1
 29778			000015			ZZ=ZZ+1
 29779			000066			XX=XX+5
 29780	046457	201 16 0 00 777727 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29781	046460	201 15 0 16 000066 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29782	046461	302 15 0 00 000015 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29783						STOP^
 29784	046462	254 04 0 00 046463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29785	046463	324 00 0 00 046464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29787									;IN THE SUBTEST) TO LOOP ON ERROR^
 29788
 29789					;**********
 29790
 29791			002017		SN=SN+1
 29792			000016			ZZ=ZZ+1
 29793			000073			XX=XX+5
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11-9
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INDEX REGISTER ADDRESSING

 29794	046464	201 17 0 00 777723 		MOVEI	ZZ+1,ZZ-XX	;SETUP INDEX REGISTER
 29795	046465	201 16 0 17 000073 		MOVEI	ZZ,XX(ZZ+1)	;*TEST INDEXING
 29796	046466	302 16 0 00 000016 		CAIE	ZZ,ZZ		;PASS IF C(AC)=0,,ADDRESS OF AC
 29797						STOP^
 29798	046467	254 04 0 00 046470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29799	046470	324 00 0 00 046471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29800									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29801									;IN THE SUBTEST) TO LOOP ON ERROR^
 29802
 29803					;**********
 29804
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA4	MAC	13-Jan-89 10:22		TEST OF EXCH INSTRUCTION

 29805					SUBTTL	TEST OF EXCH INSTRUCTION
 29806
 29807					;**********
 29808
 29809					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29810					;MOVES C(AC) INTO E.
 29811					;IN THIS CASE, AC=E=0 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
 29812					;IN AC0 SHOULD BE 0.  IF C(AC)=0, THE TEST PASSES.
 29813
 29814	046471	400 00 0 00 000000 	C2100:	SETZ			;PRELOAD AC,E WITH 0
 29815	046472	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 0 INTO AC0
 29816	046473	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0
 29817						STOP^
 29818	046474	254 04 0 00 046475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29819	046475	324 00 0 00 046476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29820									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29821									;IN THE SUBTEST) TO LOOP ON ERROR^
 29822
 29823					;**********
 29824
 29825					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29826					;MOVES C(AC) INTO E.
 29827					;IN THIS CASE, AC=E=-1,,-1 AND C(AC)=C(E).  HENCE, THE FINAL RESULT
 29828					;IN AC0 SHOULD BE -1,,-1.  IF C(AC)=-1,,-1, THE TEST PASSES.
 29829
 29830	046476	474 00 0 00 000000 	C2200:	SETO			;PRELOAD AC,E WITH -1,,-1
 29831	046477	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE -1,,-1 INTO AC0
 29832	046500	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC0)=-1,,-1
 29833						STOP^
 29834	046501	254 04 0 00 046502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29835	046502	324 00 0 00 046503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29836									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29837									;IN THE SUBTEST) TO LOOP ON ERROR^
 29838
 29839					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA4	MAC	13-Jan-89 10:22		TEST OF EXCH INSTRUCTION

 29840					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29841					;MOVES C(AC) INTO E.
 29842					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=0,,-1.  HENCE, THE FINAL RESULT
 29843					;IN THE AC SHOULD BE 0,,-1 AND THE RESULT IN E SHOULD BE -1,,0,
 29844					;IF THESE RESULTS OCCUR, THE TEST PASSES.
 29845
 29846	046503	205 00 0 00 777777 	C2400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 29847	046504	201 01 0 00 777777 		MOVEI	1,-1		;PRELOAD E WITH 0,,-1
 29848	046505	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD PLACE 0,,-1 INTO THE AC AND -1,,0 INTO E
 29849	046506	312 01 0 00 070331 		CAME	1,[-1,,0]	;PASS IF C(E)=-1,,0
 29850						STOP^
 29851	046507	254 04 0 00 046510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29852	046510	324 00 0 00 046511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29853									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29854									;IN THE SUBTEST) TO LOOP ON ERROR^
 29855	046511	312 00 0 00 070330 	C2410:	CAME	0,[0,,-1]	;PASS IF C(AC)=0,,-1
 29856						STOP^
 29857	046512	254 04 0 00 046513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29858	046513	324 00 0 00 046514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29859									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29860									;IN THE SUBTEST) TO LOOP ON ERROR^
 29861
 29862					;**********
 29863
 29864					;THIS TEST VERIFIES THAT EXCH MOVES C(E) INTO AC AND
 29865					;MOVES C(AC) INTO E.
 29866					;IN THIS CASE, C(AC)=0,,-1 AND C(E)=-1,,0.  HENCE, THE FINAL RESULT
 29867					;IN THE AC SHOULD BE -1,,0 AND THE RESULT IN E SHOULD BE 0,,-1.
 29868					;IF THESE RESULTS OCCUR, THE TEST PASSES.
 29869
 29870	046514	201 00 0 00 777777 	C2700:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 29871	046515	205 01 0 00 777777 		MOVSI	1,-1		;PRELOAD E WITH -1,,0
 29872	046516	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD PLACE -1,,0 INTO THE AC AND 0,,-1 INTO E
 29873	046517	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 29874						STOP^
 29875	046520	254 04 0 00 046521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29876	046521	324 00 0 00 046522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29878									;IN THE SUBTEST) TO LOOP ON ERROR^
 29879	046522	312 00 0 00 070331 	C2710:	CAME	,[XWD -1,0]	;PASS IF C(AC)=-1,,0
 29880						STOP^
 29881	046523	254 04 0 00 046524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29882	046524	324 00 0 00 046525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29883									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29884									;IN THE SUBTEST) TO LOOP ON ERROR^
 29885
 29886					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA4	MAC	13-Jan-89 10:22		TEST OF EXCH INSTRUCTION

 29887					;THIS TEST IS A RELIABILITY CHECK OF EXCH.
 29888					;FIRST, AC, E ARE PRELOADED WITH 252525,,252525.  THERE, EXCH IS
 29889					;EXECUTED 7 TIMES.  THE AC IS THEN CHECKED FOR 252525,,252525.
 29890					;IF C(AC)=C(E)=252525,,252525, THIS TEST PASSES.
 29891					;IN THIS TEST AC=E=AC0
 29892
 29893	046525	200 00 0 00 070614 	C3000:	MOVE	[252525252525]	;PRELOAD AC,E WITH 252525,,252525
 29894						REPEAT	7,
 29895					<	EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0>
 29896	046526	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29897	046527	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29898	046530	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29899	046531	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29900	046532	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29901	046533	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29902	046534	250 00 0 00 000000 		EXCH			;*EXCH SHOULD PLACE 252525,,252525 INTO AC0
 29903	046535	312 00 0 00 070614 		CAME	[252525252525]	;PASS IF C(AC0)=252525,,252525
 29904						STOP^
 29905	046536	254 04 0 00 046537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29906	046537	324 00 0 00 046540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29907									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29908									;IN THE SUBTEST) TO LOOP ON ERROR^
 29909
 29910					;**********
 29911					PAGE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF EXCH INSTRUCTION

 29912					;THIS TEST VERIFIES THAT EXCH MOVES C(AC) INTO E AND C(E) INTO THE AC.
 29913					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.  EXCH IS EXECUTED 7 TIMES; THEN,
 29914					;THE AC IS CHECKED FOR -1,,-1 AND E IS CHECKED FOR 0.  IF EITHER OF THESE
 29915					;RESULTS ARE NOT FOUND, THIS TEST FAILS.
 29916
 29917	046540	400 00 0 00 000000 	C3100:	SETZ			;PRELOAD AC WITH 0
 29918	046541	474 01 0 00 000000 		SETO	1,0		;PRELOAD E WITH -1,,-1
 29919						REPEAT	7,
 29920					<	EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)>
 29921	046542	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29922	046543	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29923	046544	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29924	046545	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29925	046546	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29926	046547	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29927	046550	250 00 0 00 000001 		EXCH	1		;*EXCH SHOULD EXCHANGE C(AC) AND C(E)
 29928	046551	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1
 29929						STOP^
 29930	046552	254 04 0 00 046553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29931	046553	324 00 0 00 046554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29932									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29933									;IN THE SUBTEST) TO LOOP ON ERROR^
 29934	046554	312 01 0 00 070253 	C3110:	CAME	1,[0]		;PASS IF C(E)=0
 29935						STOP^
 29936	046555	254 04 0 00 046556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29937	046556	324 00 0 00 046557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29939									;IN THE SUBTEST) TO LOOP ON ERROR^
 29940
 29941					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MOVEM INSTRUCTION

 29942					SUBTTL	TEST OF MOVEM INSTRUCTION
 29943
 29944					;THIS TEST VERIFIES THAT MOVEM PLACES C(AC) INTO E AND DOES NOT MODIFY C(AC)
 29945					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0.  HENCE, THE RESULT IN AC AND E SHOULD
 29946					;BE -1,,-1.  IF C(AC) AND C(E)=-1,,-1, THIS TEST PASSES
 29947
 29948	046557	474 00 0 00 000000 	C3200:	SETO			;PRELOAD AC WITH -1,,-1
 29949	046560	400 01 0 00 000000 		SETZ	1,0		;PRELOAD E WITH 0
 29950	046561	202 00 0 00 000001 		MOVEM	1		;*MOVEM SHOULD PLACE -1,,-1 INTO E
 29951	046562	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(E)=-1,,-1
 29952						STOP^
 29953	046563	254 04 0 00 046564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29954	046564	324 00 0 00 046565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29955									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29956									;IN THE SUBTEST) TO LOOP ON ERROR^
 29957	046565	312 00 0 00 070254 	C3210:	CAME	0,[-1]		;PASS IF C(AC)=-1,,-1
 29958						STOP^
 29959	046566	254 04 0 00 046567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29960	046567	324 00 0 00 046570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29961									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29962									;IN THE SUBTEST) TO LOOP ON ERROR^
 29963
 29964					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 29965					SUBTTL	TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS
 29966
 29967					;**********
 29968
 29969					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION
 29970					;IF JFCL SKIPS THE NEXT INSTRUCTION, THIS TEST FAILS
 29971
 29972	046570	200 00 0 00 070615 	C3300:	MOVE	[HALT .+3]	;THIS INSTRUCTION SHOULD NOT AFFECT THE TEST
 29973	046571	255 17 0 00 046572 		JFCL	17,.+1		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
 29974	046572	304 00 0 00 000000 		CAIA			;SKIP HALT INSTRUCTION IF JFCL PASSES
 29975						STOP^
 29976	046573	254 04 0 00 046574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29977	046574	324 00 0 00 046575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29978									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29979									;IN THE SUBTEST) TO LOOP ON ERROR^
 29980
 29981					;**********
 29982
 29983					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY0 FLAG.
 29984					;ADDI IS USED TO SET CRY0.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY0.
 29985					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY0 WAS RESET BY THE PREVIOUS JFCL.
 29986					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY0
 29987
 29988	046575	200 00 0 00 070254 	C3400:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 29989	046576	271 00 0 00 000001 		ADDI	1		;SET CRY0 FLAG
 29990	046577	255 17 0 00 046600 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 29991	046600	255 04 0 00 046602 		JFCL	4,.+2		;PASS IF CRY0 WAS RESET BY PREVIOUS INSTRUCTION
 29992	046601	334 00 0 00 000000 		SKIPA			;SKIP HALT IF CRY0 WAS CLEARED
 29993						STOP^
 29994	046602	254 04 0 00 046603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 29995	046603	324 00 0 00 046604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 29996									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 29997									;IN THE SUBTEST) TO LOOP ON ERROR^
 29998
 29999					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30000					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE CRY1 FLAG.
 30001					;ADDI IS USED TO SET CRY1.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR CRY1.
 30002					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER CRY1 WAS RESET BY THE PREVIOUS JFCL.
 30003					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR CRY1
 30004
 30005	046604	200 00 0 00 070254 	C3500:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 30006	046605	271 00 0 00 000001 		ADDI	1		;SET CRY1 FLAG
 30007	046606	255 17 0 00 046607 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 30008	046607	255 02 0 00 046611 		JFCL	2,.+2		;PASS IF CRY1 WAS RESET BY PREVIOUS INSTRUCTION
 30009	046610	334 00 0 00 000000 		SKIPA			;SKIP HALT IF CRY1 WAS CLEARED
 30010						STOP^
 30011	046611	254 04 0 00 046612 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30012	046612	324 00 0 00 046613 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30013									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30014									;IN THE SUBTEST) TO LOOP ON ERROR^
 30015
 30016					;**********
 30017
 30018					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE AROV FLAG.
 30019					;ADDI IS USED TO SET AROV.  THEN, JFCL 17,.+1 IS EXECUTED TO CLEAR AROV.
 30020					;JFCL 4,.+2 IS EXECUTED TO DETERMINE WHETHER AROV WAS RESET BY THE PREVIOUS JFCL.
 30021					;THIS TEST FAILS IF JFCL 17,.+1 DID NOT CLEAR AROV
 30022
 30023	046613	205 00 0 00 400000 	C3600:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
 30024	046614	270 00 0 00 070256 		ADD	[XWD 400000,0]	;SET AROV FLAG
 30025	046615	255 17 0 00 046616 		JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 30026	046616	255 10 0 00 046620 		JFCL	10,.+2		;PASS IF AROV WAS RESET BY PREVIOUS INSTRUCTION
 30027	046617	334 00 0 00 000000 		SKIPA			;SKIP HALT IF AROV WAS CLEARED
 30028						STOP^
 30029	046620	254 04 0 00 046621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30030	046621	324 00 0 00 046622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30031									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30032									;IN THE SUBTEST) TO LOOP ON ERROR^
 30033
 30034					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30035					;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
 30036					;IN THIS TEST, ADD IS USED TO SET CRY0.  THEN JFCL 0,.+2 IS EXECUTED.
 30037					;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 30038
 30039	046622	205 00 0 00 400000 	C3700:	MOVSI	400000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
 30040	046623	270 00 0 00 070254 		ADD	[-1]		;SET CRY0 FLAG
 30041	046624	255 00 0 00 046626 		JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
 30042	046625	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT SKIP
 30043						STOP^
 30044	046626	254 04 0 00 046627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30045	046627	324 00 0 00 046630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30047									;IN THE SUBTEST) TO LOOP ON ERROR^
 30048
 30049					;**********
 30050
 30051					;THIS TEST VERIFIES THAT JFCL 0, IS A NO-OP.
 30052					;IN THIS TEST, ADD IS USED TO SET CRY1.  THEN JFCL 0,.+2 IS EXECUTED.
 30053					;IF JFCL 0,.+2 DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 30054
 30055	046630	205 00 0 00 200000 	C4000:	MOVSI	200000		;PRELOAD AC WITH MOST NEGATIVE NUMBER
 30056	046631	270 00 0 00 070326 		ADD	[XWD 200000,0]	;SET CRY1 FLAG
 30057	046632	255 00 0 00 046634 		JFCL	.+2		;*JFCL SHOULD RETURN TO NEXT SEQUENTIAL INSTRUCTION
 30058	046633	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT SKIP
 30059						STOP^
 30060	046634	254 04 0 00 046635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30061	046635	324 00 0 00 046636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30062									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30063									;IN THE SUBTEST) TO LOOP ON ERROR^
 30064
 30065					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30066					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30067					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30068					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
 30069					;BECAUSE A FLAG WAS SET BY ADDI
 30070					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
 30071					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30072
 30073	046636	200 00 0 00 070254 	C4100:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
 30074	046637	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY0/1 FLAGS
 30075	046640	255 17 0 00 046642 		JFCL	17,.+2		;*JFCL SHOULD JUMP BECAUSE FLAGS ARE SET
 30076						STOP^
 30077	046641	254 04 0 00 046642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30078	046642	324 00 0 00 046643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30079									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30080									;IN THE SUBTEST) TO LOOP ON ERROR^
 30081
 30082					;**********
 30083
 30084					;THIS TEST VERIFIES THAT CAI DOES NOT CLEAR ANY ARITHMETIC FLAGS.
 30085					;FIRST, CRY0 AND CRY1 ARE SET BY ADDI; THEN CAI IS EXECUTED.
 30086					;JFCL SHOULD JUMP BECAUSE FLAGS ARE SET.  IF JFCL DOES NOT JUMP,
 30087					;THE FLAGS WERE CLEARED BY CAI.  HENCE, CAI FAILED
 30088
 30089	046643	200 00 0 00 070254 	C4200:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 30090	046644	271 00 0 00 000001 		ADDI	1		;SET CYR0/1 FLAGS
 30091	046645	300 17 0 00 000017 		CAI	17,17		;*CAI SHOULD NOT CLEAR FLAGS
 30092	046646	255 17 0 00 046650 		JFCL	17,.+2		;PASS IF CAI CLEARED FLAGS
 30093						STOP^
 30094	046647	254 04 0 00 046650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30095	046650	324 00 0 00 046651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30096									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30097									;IN THE SUBTEST) TO LOOP ON ERROR^
 30098
 30099					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30100					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30101					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30102					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN JFCL SHOULD SKIP
 30103					;BECAUSE A FLAG WAS SET BY ADDI
 30104					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
 30105					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30106
 30107	046651	200 00 0 00 070254 	C4300:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
 30108	046652	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY1 FLAGS
 30109	046653	255 02 0 00 046655 		JFCL	2,.+2		;*JFCL SHOULD JUMP BECAUSE CRY1 FLAG IS SET
 30110						STOP^
 30111	046654	254 04 0 00 046655 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30112	046655	324 00 0 00 046656 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30113									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30114									;IN THE SUBTEST) TO LOOP ON ERROR^
 30115
 30116					;**********
 30117
 30118					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30119					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30120					;IN THIS TEST, ADDI SHOULD SET CRY0 AND CRY1.  THEN, JFCL SHOULD SKIP
 30121					;BECAUSE A FLAG WAS SET BY ADDI
 30122					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR
 30123					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30124
 30125	046656	200 00 0 00 070254 	C4400:	MOVE	[-1]		;PRELOAD AC WITH ALL ONES
 30126	046657	271 00 0 00 000001 		ADDI	1		;*ADDI SHOULD SET CRY0 FLAG
 30127	046660	255 04 0 00 046662 		JFCL	4,.+2		;*JFCL SHOULD JUMP BECAUSE CRY0 FLAG IS SET
 30128						STOP^
 30129	046661	254 04 0 00 046662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30130	046662	324 00 0 00 046663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30131									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30132									;IN THE SUBTEST) TO LOOP ON ERROR^
 30133
 30134					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30135					;THIS TEST VERIFIES THAT ADDI HAS THE ABILITY TO SET AN ARITHMETIC FLAG AND
 30136					;THAT 'JFCL 17,.+2' JUMPS WHENEVER ANY ARITHMETIC FLAG IS SET.
 30137					;BECAUSE A FLAG WAS SET BY ADD
 30138					;IF THIS TEST FAILS, ADDI COULD HAVE FAILED TO SET A FLAG OR 
 30139					;JFCL COULD HAVE FAILED TO JUMP WHEN A FLAG WAS SET
 30140
 30141	046663	205 00 0 00 400000 	C4500:	MOVSI	400000		;PRELOAD AC WITH ALL ONES
 30142	046664	270 00 0 00 070256 		ADD	[XWD 400000,0]	;*ADD SHOULD SET AROV FLAG
 30143	046665	255 10 0 00 046667 		JFCL	10,.+2		;*JFCL SHOULD JUMP BECAUSE AROV FLAG IS SET
 30144						STOP^
 30145	046666	254 04 0 00 046667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30146	046667	324 00 0 00 046670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30147									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30148									;IN THE SUBTEST) TO LOOP ON ERROR^
 30149
 30150					;**********
 30151
 30152					;THIS TEST VERIFIES THAT JFCL 17,.+1 ALWAYS CLEARS THE FLOATING OVERFLOW FLAG (FOV).
 30153					;FIRST JFCL 17,.+1 IS EXECUTED TO CLEAR FOV.  THEN, JFCL 1,.+2 IS EXECUTED TO DETERMINE
 30154					;WHETHER FOV WAS CLEARED.  IF FOV WAS CLEAR, THIS TEST PASSES
 30155
 30156	046670	255 17 0 00 046671 	C4600:	JFCL	17,.+1		;*CLEAR ARITHMETIC FLAGS
 30157	046671	255 01 0 00 046673 		JFCL	1,.+2		;PASS IF FOV WAS CLEARED
 30158	046672	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
 30159						STOP^
 30160	046673	254 04 0 00 046674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30161	046674	324 00 0 00 046675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30162									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30163									;IN THE SUBTEST) TO LOOP ON ERROR^
 30164
 30165					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30166					;THIS TEST VERIFIES THAT JFCL 13, DOES NOT RESET CRY0.
 30167					;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL 13,.+2 IS EXECUTED
 30168					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY0.
 30169					;THIS TEST PASSES IF JFCL 13,.+1 DID NOT RESET CRY0.
 30170
 30171	046675	200 00 0 00 070254 	C4700:	MOVE	[-1]		;RELOAD AC WITH -1,,-1
 30172	046676	271 00 0 00 000001 		ADDI	1		;SET CRY0/1
 30173	046677	255 13 0 00 046700 		JFCL	13,.+1		;*JFCL 13, SHOULD NOT RESET CRY0
 30174	046700	255 04 0 00 046702 		JFCL	4,.+2		;FAIL IF CRY 0 WAS RESET
 30175						STOP^
 30176	046701	254 04 0 00 046702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30177	046702	324 00 0 00 046703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30178									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30179									;IN THE SUBTEST) TO LOOP ON ERROR^
 30180
 30181					;**********
 30182
 30183					;THIS TEST VERIFIES THAT JFCL 15, DOES NOT RESET CRY1.
 30184					;FIRST CRY0 AND CRY1 ARE SET BY ADDI; THEN, JFCL15,.+2 IS EXECUTED
 30185					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT CRY1.
 30186					;THIS TEST PASSES IF JFCL 15,.+1 DID NOT RESET CRY1.
 30187
 30188	046703	200 00 0 00 070254 	C5000:	MOVE	[-1]		;PRELOAD AC WITH -1,,-1
 30189	046704	271 00 0 00 000001 		ADDI	1		;SET CRY0/1
 30190	046705	255 15 0 00 046706 		JFCL	15,.+1		;*JFCL15, SHOULD NOT RESET CRY0
 30191	046706	255 02 0 00 046710 		JFCL	2,.+2		;FAIL IF CRY1 WAS RESET
 30192						STOP^
 30193	046707	254 04 0 00 046710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30194	046710	324 00 0 00 046711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30195									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30196									;IN THE SUBTEST) TO LOOP ON ERROR^
 30197
 30198					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30199					;THIS TEST VERIFIES THAT JFCL 17, DOES NOT RESET AROV.
 30200					;FIRST AROV IS SET BY ADD; THEN, JFCL 17,.+2 IS EXECUTED
 30201					;TO CLEAR ALL ARITHMETIC FLAGS EXCEPT AROV.
 30202					;THIS TEST PASSES IF JFCL 17,.+1 DID NOT RESET AROV.
 30203
 30204	046711	205 00 0 00 400000 	C5100:	MOVSI	400000		;PRELOAD AC WITH -1,,-1
 30205	046712	270 00 0 00 070256 		ADD	[XWD 400000,0]	;SET AROV 
 30206	046713	255 07 0 00 046714 		JFCL	7,.+1		;*JFCL 17, SHOULD NOT RESET AROV
 30207	046714	255 10 0 00 046716 		JFCL	10,.+2		;FAIL IF AROV WAS RESET
 30208						STOP^
 30209	046715	254 04 0 00 046716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30210	046716	324 00 0 00 046717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30211									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30212									;IN THE SUBTEST) TO LOOP ON ERROR^
 30213
 30214					;**********
 30215
 30216					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET AROV.
 30217					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
 30218					;AROV IS THEN CHECKED.  IF AROV IS SET, THIS TEST FAILS.
 30219
 30220	046717	255 17 0 00 046720 	C5200:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 30221	046720	400 00 0 00 000000 		SETZ			;PRELOAD AC,E WITH 0
 30222	046721	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET AROV
 30223	046722	255 10 0 00 046724 		JFCL	10,.+2		;PASS IF AROV WAS RESET
 30224	046723	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
 30225						STOP^
 30226	046724	254 04 0 00 046725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30227	046725	324 00 0 00 046726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30228									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30229									;IN THE SUBTEST) TO LOOP ON ERROR^
 30230
 30231					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30232					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY0.
 30233					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
 30234					;CRY0 IS THEN CHECKED.  IF CRY0 IS SET, THIS TEST FAILS.
 30235
 30236
 30237	046726	400 00 0 00 000000 	C5300:	SETZ			;RESET ARITHMETIC FLAGS
 30238	046727	255 17 0 00 046730 		JFCL	17,.+1		;PRELOAD AC,E WITH 0
 30239	046730	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET CRY0
 30240	046731	255 04 0 00 046733 		JFCL	4,.+2		;PASS IF CRY0 WAS RESET
 30241	046732	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
 30242						STOP^
 30243	046733	254 04 0 00 046734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30244	046734	324 00 0 00 046735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30245									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30246									;IN THE SUBTEST) TO LOOP ON ERROR^
 30247
 30248					;**********
 30249
 30250					;THIS TEST VERIFIES THAT ADD OF 0 TO 0 WILL NOT SET CRY1.
 30251					;FIRST, ALL FLAGS ARE RESET, THEN 0 IS ADDED TO 0 VIA ADD.
 30252					;CRY1 IS THEN CHECKED.  IF CRY1 IS SET, THIS TEST FAILS.
 30253
 30254	046735	400 00 0 00 000000 	C5400:	SETZ			;RESET ARITHMETIC FLAGS
 30255	046736	255 17 0 00 046737 		JFCL	17,.+1		;PRELOAD AC,E WITH 0
 30256	046737	270 00 0 00 000000 		ADD			;*ADD SHOULD NOT SET CRY1
 30257	046740	255 02 0 00 046742 		JFCL	2,.+2		;PASS IF CRY1 WAS RESET
 30258	046741	334 00 0 00 000000 		SKIPA			;SKIP HALT IF ADD PASSED
 30259						STOP^
 30260	046742	254 04 0 00 046743 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30261	046743	324 00 0 00 046744 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30262									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30263									;IN THE SUBTEST) TO LOOP ON ERROR^
 30264
 30265					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30266					;THIS TEST VERIFIES THAT THE 30X AND THE 31X INSTRUCTION GROUPS DO NOT AFFECT
 30267					;THE ARITHMETIC FLAGS.  FIRST, THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, CAI
 30268					;AND CAM ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
 30269					;THIS TEST FAILS AND CAI OR CAM IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
 30270
 30271	046744	255 17 0 00 046745 	C5500:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30272	046745	400 00 0 00 000000 		SETZ			;CLEAR AC,0
 30273	046746	300 00 0 00 000000 		CAI			;*CAI SHOULD NOT SET ANY ARITHMETIC FLAG
 30274	046747	310 00 0 00 070254 		CAM	[-1]		;*CAM SHOULD NOT SET ANY ARITHMETIC FLAG
 30275	046750	255 17 0 00 046752 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
 30276	046751	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
 30277						STOP^
 30278	046752	254 04 0 00 046753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30279	046753	324 00 0 00 046754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30281									;IN THE SUBTEST) TO LOOP ON ERROR^
 30282
 30283					;**********
 30284
 30285					;THIS TEST VERIFIES THAT THE BOOLEAN INSTRUCTION GROUPS DO NOT AFFECT
 30286					;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, XOR [0]
 30287					;AND XOR [-1] ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
 30288					;THIS TEST FAILS AND XOR IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
 30289
 30290	046754	255 17 0 00 046755 	C5600:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30291	046755	474 00 0 00 000000 		SETO			;CLEAR AC,0
 30292	046756	430 00 0 00 070253 		XOR	[0]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
 30293	046757	430 00 0 00 070254 		XOR	[-1]		;*XOR SHOULD NOT SET ANY ARITHMETIC FLAG
 30294	046760	255 17 0 00 046762 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
 30295	046761	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TEST PASSED
 30296						STOP^
 30297	046762	254 04 0 00 046763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30298	046763	324 00 0 00 046764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30299									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30300									;IN THE SUBTEST) TO LOOP ON ERROR^
 30301
 30302					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30303					;THIS TEST VERIFIES THAT THE AOBJX INSTRUCTION GROUP DOES DO NOT AFFECT
 30304					;THE ARITHMETIC FLAGS.  FIRST THE FLAGS ARE CLEARED AND AC0 IS CLEARED; THEN, AOBJN
 30305					;AND AOBJP ARE EXECUTED.  THE FLAGS ARE THEN CHECKED.  IF ANY OF THE FLAGS ARE SET,
 30306					;THIS TEST FAILS AND AOBJN OR AOBJP IS CONSIDERED TO HAVE ERRONEOUSLY SET THE FLAGS
 30307
 30308	046764	474 00 0 00 000000 	C5700:	SETO			;CLEAR ALL FLAGS
 30309	046765	255 17 0 00 046766 		JFCL	17,.+1		;CLEAR AC,0
 30310	046766	253 00 0 00 046767 		AOBJN	.+1		;*AOBJN SHOULD NOT SET ANY ARITHMETIC ARITHMETIC
 30311	046767	252 00 0 00 046770 		AOBJP	.+1		;*AOBJP SHOULD NOT SET ANY ARITHMETIC FLAG
 30312	046770	255 17 0 00 046772 		JFCL	17,.+2		;FAIL IF ANY FLAG WAS SET
 30313	046771	334 00 0 00 000000 		SKIPA			;SKIP HALT IF TST PASSED
 30314						STOP^
 30315	046772	254 04 0 00 046773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30316	046773	324 00 0 00 046774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30318									;IN THE SUBTEST) TO LOOP ON ERROR^
 30319
 30320					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JFCL INSTRUCTION AND ARITHMETIC FLAGS

 30321					;THIS TEST VERIFIES THAT SKIP DOES NOT AFFECT THE FLAGS.
 30322					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, SKIP IS EXECUTED.
 30323					;IF SKIP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.
 30324
 30325	046774	255 17 0 00 046775 	C5701:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30326	046775	330 00 0 00 070254 		SKIP	0,[-1]		;*SKIP SHOULD NOT SET ANY FLAGS
 30327	046776	255 17 0 00 047000 		JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
 30328	046777	334 00 0 00 000000 		SKIPA			;PASS IF NO FLAG IS SET
 30329						STOP^
 30330	047000	254 04 0 00 047001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30331	047001	324 00 0 00 047002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30333									;IN THE SUBTEST) TO LOOP ON ERROR^
 30334
 30335					;**********
 30336
 30337					;THIS TEST VERIFIES THAT JUMP DOES NOT AFFECT THE FLAGS.
 30338					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED; THEN, JUMP IS EXECUTED.
 30339					;IF JUMP SETS AROV, CRYO, CRY1 OR FOV, THIS TEST FAILS.
 30340
 30341	047002	255 17 0 00 047003 	C5702:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30342	047003	320 00 0 00 070254 		JUMP	0,[-1]		;*JUMP SHOULD NOT SET ANY FLAGS
 30343	047004	255 17 0 00 047006 		JFCL	17,.+2		;FAIL IF ANY FLAG IS SET
 30344	047005	334 00 0 00 000000 		SKIPA			;PASS IF NO FLAG IS SET
 30345						STOP^
 30346	047006	254 04 0 00 047007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30347	047007	324 00 0 00 047010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30348									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30349									;IN THE SUBTEST) TO LOOP ON ERROR^
 30350
 30351					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS

 30352					SUBTTL	TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS
 30353
 30354					;**********
 30355
 30356					;THIS TEST VERIFIES THAT 'JRST, 0' DOES NOT SET ANY FLAGS.
 30357					;FIRST THE ARITHMETIC FLAGS ARE RESET; THEN, 'JRST 0,.+1' IS EXECUTED
 30358					;THE AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED. IF ANY
 30359					;OF THESE FLAGS ARE SET, THIS TEST FAILS
 30360
 30361	047010	255 17 0 00 047011 	C6000:	JFCL	17,.+1		;RESET ALL FLAGS
 30362	047011	254 00 0 00 047012 		JRST	.+1		;*JRST SHOULD NOT SET ANY FLAGS
 30363	047012	255 16 0 00 047014 		JFCL	16,.+2		;PASS IF NO FLAGS ARE SET
 30364	047013	334 00 0 00 000000 		SKIPA			;SKIP HALT IF JRST PASSES
 30365						STOP^
 30366	047014	254 04 0 00 047015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30367	047015	324 00 0 00 047016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30368									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30369									;IN THE SUBTEST) TO LOOP ON ERROR^
 30370
 30371					;**********
 30372
 30373					;THIS TEST VERIFIES THAT 'MOVE 2,2' DOES NOT SET ANY FLAGS.
 30374					;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, 'MOVE 2,2' IS EXECUTED.
 30375					;THE FOV,AROV,CRY0 AND CRY1 FLAGS ARE THEN CHECKED.  IF ANY
 30376					;OF THESE FLAGS ARE SET, THIS TEST FAILS
 30377
 30378	047016	255 17 0 00 047017 	C6100:	JFCL	17,.+1		;RESET ALL FLAGS
 30379	047017	200 02 0 00 000002 		MOVE	2,2		;*MOVE SHOULD NOT SET ANY FLAGS
 30380	047020	255 17 0 00 047022 		JFCL	17,.+2		;PASS IF NO FLAGS ARE SET
 30381	047021	334 00 0 00 000000 		SKIPA			;SKIP HALT IF MOVE PASSED
 30382						STOP^
 30383	047022	254 04 0 00 047023 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30384	047023	324 00 0 00 047024 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30386									;IN THE SUBTEST) TO LOOP ON ERROR^
 30387
 30388					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS

 30389					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30390					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY0 FLAG.
 30391					;FIRST, ALL FLAGS ARE RESET; THEN AC1 IS SET TO SPECIFY CRY0.
 30392					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY0.  CRY0 IS THEN CHECKED.  IF
 30393					;CRY0 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30394
 30395	047024	255 17 0 00 047025 	C6200:	JFCL	17,.+1		;CLEAR ALL FLAGS
 30396						SFLAG	CRY0		^;SET CRY0 FLAG
 30397
 30398	047025	205 01 0 00 200000 		MOVSI	1,CRY0
 30399	047026	255 17 0 00 047027 		JFCL	17,.+1	;RESET ALL FLAGS
 30400	047027	254 02 0 01 047030 		JRST	2,.+1(1)		;SET CRY0 FLAG
 30401	047030	255 04 0 00 047032 		JFCL	4,.+2		;PASS IF CRY0 IS SET
 30402						STOP^
 30403	047031	254 04 0 00 047032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30404	047032	324 00 0 00 047033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30405									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30406									;IN THE SUBTEST) TO LOOP ON ERROR^
 30407
 30408					;**********
 30409
 30410					;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
 30411					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
 30412					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADDI;
 30413					;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF CRY1 WAS CLEARED, THE
 30414					;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30415
 30416	047033	200 00 0 00 070254 	C6300:	MOVE	[-1]		;PRELOAD AC0 WITH -1,,-1
 30417	047034	271 00 0 00 000001 		ADDI	1		;SET CRY0/1 FLAGS
 30418						SFLAG	0		^;RESET ALL ARITHMETIC FLAGS
 30419
 30420	047035	205 01 0 00 000000 		MOVSI	1,0
 30421	047036	255 17 0 00 047037 		JFCL	17,.+1	;RESET ALL FLAGS
 30422	047037	254 02 0 01 047040 		JRST	2,.+1(1)		;SET 0 FLAG
 30423	047040	255 02 0 00 047042 		JFCL	2,.+2		;PASS IF CRY1 IS RESET
 30424	047041	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
 30425						STOP^
 30426	047042	254 04 0 00 047043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30427	047043	324 00 0 00 047044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30429									;IN THE SUBTEST) TO LOOP ON ERROR^
 30430
 30431					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS

 30432
 30433					;THIS TEST VERIFIES THAT JRST 2,.+(1) WILL SET THE ARITHMETIC FLAG
 30434					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAIN 0.  HENCE, JRST 2,.+1(1)
 30435					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0/1, FLAGS ARE SET BY ADD
 30436					;THEN THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.  IF AROV WAS CLEARED, THE
 30437					;TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30438
 30439	047044	205 00 0 00 400000 	C6400:	MOVSI	400000		;PRELOAD AC0 WITH -1,,-1
 30440	047045	270 00 0 00 070254 		ADD	[-1]		;SET CRY0 AND AROV FLAGS
 30441						SFLAG	0		^;RESET ALL ARITHMETIC FLAGS
 30442
 30443	047046	205 01 0 00 000000 		MOVSI	1,0
 30444	047047	255 17 0 00 047050 		JFCL	17,.+1	;RESET ALL FLAGS
 30445	047050	254 02 0 01 047051 		JRST	2,.+1(1)		;SET 0 FLAG
 30446	047051	255 10 0 00 047053 		JFCL	10,.+2		;PASS IF AROV IS RESET
 30447	047052	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
 30448						STOP^
 30449	047053	254 04 0 00 047054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30450	047054	324 00 0 00 047055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30452									;IN THE SUBTEST) TO LOOP ON ERROR^
 30453
 30454					;**********
 30455
 30456					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30457					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE AROV FLAG.
 30458					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY AROV.
 30459					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET AROV.  AROV IS THEN CHECKED.  IF
 30460					;AROV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30461
 30462	047055				C6500:	SFLAG	AROV		^;SET AROV FLAG
 30463
 30464	047055	205 01 0 00 400000 		MOVSI	1,AROV
 30465	047056	255 17 0 00 047057 		JFCL	17,.+1	;RESET ALL FLAGS
 30466	047057	254 02 0 01 047060 		JRST	2,.+1(1)		;SET AROV FLAG
 30467	047060	255 10 0 00 047062 		JFCL	10,.+2		;PASS IF AROV WAS SET
 30468						STOP^
 30469	047061	254 04 0 00 047062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30470	047062	324 00 0 00 047063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30472									;IN THE SUBTEST) TO LOOP ON ERROR^
 30473
 30474					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS

 30475					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30476					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE CRY1 FLAG.
 30477					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY CRY1.
 30478					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET CRY1.  CRY1 IS THEN CHECKED.  IF
 30479					;CRY1 IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30480
 30481	047063				C6600:	SFLAG	CRY1		^;SET CRY1 FLAG
 30482
 30483	047063	205 01 0 00 100000 		MOVSI	1,CRY1
 30484	047064	255 17 0 00 047065 		JFCL	17,.+1	;RESET ALL FLAGS
 30485	047065	254 02 0 01 047066 		JRST	2,.+1(1)		;SET CRY1 FLAG
 30486	047066	255 02 0 00 047070 		JFCL	2,.+2		;PASS IF CRY1 WAS SET
 30487						STOP^
 30488	047067	254 04 0 00 047070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30489	047070	324 00 0 00 047071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30491									;IN THE SUBTEST) TO LOOP ON ERROR^
 30492
 30493					;**********
 30494
 30495					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30496					;SPECIFIED IN AC1.  IN THIS CASE, AC1 SPECIFIES THE FOV FLAG.
 30497					;FIRST, ALL FLAGS ARE RESET; THEN AC1 SET TO SPECIFY FOV.
 30498					;NEXT, JRST 2,.+1(1) IS EXECUTED TO SET FOV.  FOV IS THEN CHECKED.  IF
 30499					;FOV IS SET, THIS TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30500
 30501	047071				C6700:	SFLAG	FOV		^;SET FOV FLAG
 30502
 30503	047071	205 01 0 00 040000 		MOVSI	1,FOV
 30504	047072	255 17 0 00 047073 		JFCL	17,.+1	;RESET ALL FLAGS
 30505	047073	254 02 0 01 047074 		JRST	2,.+1(1)		;SET FOV FLAG
 30506	047074	255 01 0 00 047076 		JFCL	1,.+2		;PASS IF FOV WAS SET
 30507						STOP^
 30508	047075	254 04 0 00 047076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30509	047076	324 00 0 00 047077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30511									;IN THE SUBTEST) TO LOOP ON ERROR^
 30512
 30513					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 32
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS

 30514					;THIS TEST VERIFIES THAT JFCL 0, SHOULD NEVER JUMP.
 30515					;FIRST, FOV IS SET VIA JRST2, ;THEN JFCL 0,
 30516					;IS EXECUTED.  IF JFCL 0, DOES NOT SKIP, THIS TEST PASSES
 30517
 30518	047077				C7000:	SFLAG	FOV		^;SET FOV FLAG
 30519
 30520	047077	205 01 0 00 040000 		MOVSI	1,FOV
 30521	047100	255 17 0 00 047101 		JFCL	17,.+1	;RESET ALL FLAGS
 30522	047101	254 02 0 01 047102 		JRST	2,.+1(1)		;SET FOV FLAG
 30523	047102	255 00 0 00 047104 		JFCL	,.+2		;*JFCL SHOULD NOT JUMP
 30524	047103	334 00 0 00 000000 		SKIPA			;PASS IF JFCL DID NOT JUMP
 30525						STOP^
 30526	047104	254 04 0 00 047105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30527	047105	324 00 0 00 047106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30529									;IN THE SUBTEST) TO LOOP ON ERROR^
 30530
 30531					;**********
 30532
 30533					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30534					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
 30535					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE CRY0, FLAG IS SET BY JRST 2,.+1(1)
 30536					;WITH C(AC1)=CRY0.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
 30537					;IF CRY0 WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30538
 30539	047106				C7100:	SFLAG	CRY0		^;SET CRY0 FLAGS
 30540
 30541	047106	205 01 0 00 200000 		MOVSI	1,CRY0
 30542	047107	255 17 0 00 047110 		JFCL	17,.+1	;RESET ALL FLAGS
 30543	047110	254 02 0 01 047111 		JRST	2,.+1(1)		;SET CRY0 FLAG
 30544	047111	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS
 30545	047112	254 02 0 01 047113 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
 30546	047113	255 04 0 00 047115 		JFCL	4,.+2		;PASS IF CRY0 FLAG WAS RESET
 30547	047114	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
 30548						STOP^
 30549	047115	254 04 0 00 047116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30550	047116	324 00 0 00 047117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30552									;IN THE SUBTEST) TO LOOP ON ERROR^
 30553
 30554					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 33
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JRST INSTRUCTION AND ARITHMETIC FLAGS

 30555					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30556					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
 30557					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE FOV, FLAG IS SET BY JRST 2,.+1(1)
 30558					;WITH C(AC1)=FOV.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1 WITH C(AC1)=0.
 30559					;IF FOV WAS CLEARED, THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30560
 30561	047117				C7200:	SFLAG	FOV		^;SET FOV FLAG
 30562
 30563	047117	205 01 0 00 040000 		MOVSI	1,FOV
 30564	047120	255 17 0 00 047121 		JFCL	17,.+1	;RESET ALL FLAGS
 30565	047121	254 02 0 01 047122 		JRST	2,.+1(1)		;SET FOV FLAG
 30566	047122	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITHMETIC FLAGS,
 30567	047123	254 02 0 01 047124 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
 30568	047124	255 01 0 00 047126 		JFCL	1,.+2		;PASS IF FOV FLAG WAS RESET
 30569	047125	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PSSED
 30570						STOP^
 30571	047126	254 04 0 00 047127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30572	047127	324 00 0 00 047130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30573									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30574									;IN THE SUBTEST) TO LOOP ON ERROR^
 30575
 30576					;**********
 30577
 30578					;THIS TEST VERIFIES THAT JRST 2,.+1(1) WILL SET THE ARITHMETIC FLAG
 30579					;SPECIFIED IN AC1.  IN THIS CASE, AC1 CONTAINS 0.  HENCE, JRST 2,.+1(1)
 30580					;SHOULD RESET THE ARITHMETIC FLAGS.  FIRST, THE ARITHMETIC FLAGS ARE RESET BY
 30581					;JFCL 17,.+1.  THEN, THE FLAGS SHOULD BE CLEARED BY JRST 2,.+1.
 30582					;IF ALL THE ARITHMETIC FLAGS WERE CLEARED,
 30583					;THE TEST PASSES.  OTHERWISE, JRST 2,.+1 IS FAULTY
 30584
 30585	047130	255 17 0 00 047131 	C7300:	JFCL	17,.+1		;CLEAR FLAGS
 30586	047131	400 01 0 00 000000 		SETZ	1,		;SETUP MASK TO CLEAR ARITMETIC FLAGS
 30587	047132	254 02 0 01 047133 		JRST	2,.+1(1)	;*RESET ARITHMETIC FLAGS
 30588	047133	255 17 0 00 047135 		JFCL	17,.+2		;PASS IF ALL FLAGS ARE RESET
 30589	047134	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF TEST PASSED
 30590						STOP^
 30591	047135	254 04 0 00 047136 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30592	047136	324 00 0 00 047137 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30593									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30594									;IN THE SUBTEST) TO LOOP ON ERROR^
 30595
 30596					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 34
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JSP INSTRUCTION

 30597					SUBTTL	TEST OF JSP INSTRUCTION
 30598
 30599					;**********
 30600
 30601					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS AND PC IN THE AC.
 30602					;IN THIS CASE, THE FLAGS ARE RESET; THEN, JSP IS EXECUTED.  THE AC IS THEN
 30603					;CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC)=0, IT INDICATES
 30604					;THAT NEITHER THE FLAGS NOR THE PC WAS SAVED.  HENCE, THIS TEST FAILS.
 30605
 30606	047137	403 00 0 00 000001 	C7400:	SETZB	1		;CLEAR AC AND SETUP MASK TO RESET FLAGS
 30607	047140	254 02 0 01 047141 		JRST	2,.+1(1)	;RESET FLAGS
 30608	047141	265 00 0 00 047142 		JSP	.+1		;*JSP SHOULD STORE FLAGS AND PC IN THE AC
 30609	047142	336 00 0 00 000000 		SKIPN			;PASS IF C(AC) IS NON-ZERO
 30610						STOP			^;IT DID NOT STORE ANY FLAGS OR PC
 30611
 30612	047143	254 04 0 00 047144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30613	047144	324 00 0 00 047145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30614									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30615									;IN THE SUBTEST) TO LOOP ON ERROR
 30616
 30617					;**********
 30618
 30619					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE PC IN THE RIGHT HALF OF THE AC.
 30620					;IN THIS CASE, THE AC IS CLEARED, THEN, JSP IS EXECUTED.  THE RIGHT HALF OF
 30621					;THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(AC RIGHT HALF)
 30622					;IS NON-ZERO, IT INDICATED THAT THE PC WAS SAVED; AND THIS TEST PASSES.
 30623
 30624	047145	400 00 0 00 000000 	C7500:	SETZ			;CLEAN AC
 30625	047146	265 00 0 00 047147 		JSP	.+1		;*JSP SHOULD STORE THE PC IN THE AC
 30626	047147	606 00 0 00 777777 		TRNN	-1		;PASS IF C(AC) IN NON-ZERO
 30627						STOP^
 30628	047150	254 04 0 00 047151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30629	047151	324 00 0 00 047152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30630									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30631									;IN THE SUBTEST) TO LOOP ON ERROR^
 30632
 30633					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 35
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JSP INSTRUCTION

 30634					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30635					;FIST, THE AC IS CLEARED; THEN, SOME FLAGS ARE SET AND JSP IS EXECUTED.
 30636					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30637					;WHETHER THE FLAGS WERE SAVED.  IF C(AC-LEFT) IS NON-ZERO, THIS TEST PASSES
 30638
 30639	047152	402 00 0 00 000000 	C7600:	SETZM	0		;CLEAR AC
 30640	047153	205 01 0 00 740000 		MOVSI	1,740000	;SET UP MASK TO SET FLAGS
 30641	047154	254 02 0 01 047155 		JRST	2,.+1(1)	;SET SOME ARITHMETIC FLAGS
 30642	047155	265 00 0 00 047156 		JSP	.+1		;*JSP SHOULD STORE FLAGS IN THE AC
 30643	047156	607 00 0 00 777777 		TLNN	-1		;PASS IF C(AC) IS NON-ZERO
 30644						STOP^
 30645	047157	254 04 0 00 047160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30646	047160	324 00 0 00 047161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30648									;IN THE SUBTEST) TO LOOP ON ERROR^
 30649
 30650					;**********
 30651
 30652					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30653					;FIRST, THE AC IS CLEARED; THEN, THE AROV FLAG IS SET AND JSP IS EXECUTED.
 30654					;THEN, THE AROV FLAG BIT OF
 30655					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30656					;WHETHER THE AROV FLAG WAS SAVED.  IF THE AROV FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30657
 30658	047161	402 00 0 00 000000 	C7700:	SETZM	0		;CLEAR THE AC
 30659						SFLAG	AROV		^;SET AROV FLAG
 30660
 30661	047162	205 01 0 00 400000 		MOVSI	1,AROV
 30662	047163	255 17 0 00 047164 		JFCL	17,.+1	;RESET ALL FLAGS
 30663	047164	254 02 0 01 047165 		JRST	2,.+1(1)		;SET AROV FLAG
 30664	047165	265 00 0 00 047166 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30665	047166	607 00 0 00 400000 		TLNN	AROV		;PASS IF AROV WAS SAVED
 30666						STOP^
 30667	047167	254 04 0 00 047170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30668	047170	324 00 0 00 047171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30669									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30670									;IN THE SUBTEST) TO LOOP ON ERROR^
 30671
 30672					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 36
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JSP INSTRUCTION

 30673					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30674					;FIRST, THE AC IS CLEARED; THEN, THE CRY0 FLAG IS SET AND JSP IS EXECUTED.
 30675					;THEN, THE CRY0 FLAG BIT OF
 30676					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30677					;WHETHER THE CRY0 FLAG WAS SAVED.  IF THE CRY0 FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30678
 30679	047171	402 00 0 00 000000 	C10000:	SETZM	0		;CLEAR THE AC
 30680						SFLAG	CRY0		^;SET CRY0 FLAG
 30681
 30682	047172	205 01 0 00 200000 		MOVSI	1,CRY0
 30683	047173	255 17 0 00 047174 		JFCL	17,.+1	;RESET ALL FLAGS
 30684	047174	254 02 0 01 047175 		JRST	2,.+1(1)		;SET CRY0 FLAG
 30685	047175	265 00 0 00 047176 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30686	047176	607 00 0 00 200000 		TLNN	CRY0		;PASS IF CRY0 WAS SAVED
 30687						STOP^
 30688	047177	254 04 0 00 047200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30689	047200	324 00 0 00 047201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30691									;IN THE SUBTEST) TO LOOP ON ERROR^
 30692
 30693					;**********
 30694
 30695					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30696					;FIRST, THE AC IS CLEARED; THEN, THE CRY1 FLAG IS SET AND JSP IS EXECUTED.
 30697					;THEN, THE CRY1 FLAG BIT OF
 30698					;THE LEFT HALF OF THE AC IS CHECKED FOR ITS CONTENTS NON-ZERO TO DETERMINE
 30699					;WHETHER THE FLAG WAS SAVED.  IF THE CRY1 FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30700
 30701	047201	400 00 0 00 000000 	C10100:	SETZ			;CLEAR AC
 30702						SFLAG	CRY1		^;SET CRY1 FLAG
 30703
 30704	047202	205 01 0 00 100000 		MOVSI	1,CRY1
 30705	047203	255 17 0 00 047204 		JFCL	17,.+1	;RESET ALL FLAGS
 30706	047204	254 02 0 01 047205 		JRST	2,.+1(1)		;SET CRY1 FLAG
 30707	047205	265 00 0 00 047206 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30708	047206	607 00 0 00 100000 		TLNN	CRY1		;PASS IF AROV WAS SAVED
 30709						STOP^
 30710	047207	254 04 0 00 047210 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30711	047210	324 00 0 00 047211 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30712									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30713									;IN THE SUBTEST) TO LOOP ON ERROR^
 30714
 30715					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 37
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JSP INSTRUCTION

 30716					;THIS TEST VERIFIES THAT JSP ALWAYS STORES THE FLAGS IN THE LEFT HALF OF THE AC.
 30717					;FRIST, THE AC IS CLEARED; THEN, THE FOV FLAG IS SET AND JSP IS EXECUTED.
 30718					;THEN, THE FOV FLAG BIT OF THE LEFT HALF OF THE AC IS CHECKED FOR
 30719					;ITS CONTENTS NON-ZERO TO DETERMINE WHETHER THE FOV FLAG WAS SAVED.
 30720					;IF THE FOV FLAG BIT OF THE AC IS SET, THIS TEST PASSES
 30721
 30722	047211	400 00 0 00 000000 	C10200:	SETZ			;CLEAR THE AC
 30723						SFLAG	FOV		^;SET FOV FLAG
 30724
 30725	047212	205 01 0 00 040000 		MOVSI	1,FOV
 30726	047213	255 17 0 00 047214 		JFCL	17,.+1	;RESET ALL FLAGS
 30727	047214	254 02 0 01 047215 		JRST	2,.+1(1)		;SET FOV FLAG
 30728	047215	265 00 0 00 047216 		JSP	.+1		;*JSP SHOULD SAVE THE FLAGS IN THE AC-LEFT
 30729	047216	607 00 0 00 040000 		TLNN	FOV		;PASS IF FOV WAS SAVED
 30730						STOP^
 30731	047217	254 04 0 00 047220 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30732	047220	324 00 0 00 047221 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30733									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30734									;IN THE SUBTEST) TO LOOP ON ERROR^
 30735
 30736					;**********
 30737
 30738					;THIS TEST VERIFIES THAT JSP WILL STORE ONLY FLAGS THAT EXIST.
 30739					;I.E. RESET FLAGS WILL NOT BE SET IN THE AC.  ONLY FLAGS THAT ARE
 30740					;CLEARABLE BY JRSTF WILL BE CHECKED HERE.  FIRST ALL CLEARABLE
 30741					;FLAGS ARE RESET BY JRSTF;  THEN JSP IS EXECUTED.  THE AC IS THEN CHECKED.
 30742					;IF ANY CLEARABLE FLAGS ARE SET IN THE AC, THIS TEST FAILS.
 30743
 30744	047221				C10300:	SFLAG	0		^;CLEAR ALL CLEARABLE FLAGS
 30745
 30746	047221	205 01 0 00 000000 		MOVSI	1,0
 30747	047222	255 17 0 00 047223 		JFCL	17,.+1	;RESET ALL FLAGS
 30748	047223	254 02 0 01 047224 		JRST	2,.+1(1)		;SET 0 FLAG
 30749	047224	265 00 0 00 047225 		JSP	.+1		;*JSP SHOULD NOT STORE CLEARABLE FALGS
 30750	047225	603 00 0 00 761777 		TLNE	761777		;FAIL IF ANY CLEARABLE FLAG IS SET
 30751						STOP^
 30752	047226	254 04 0 00 047227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30753	047227	324 00 0 00 047230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30754									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30755									;IN THE SUBTEST) TO LOOP ON ERROR^
 30756
 30757					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JSP INSTRUCTION

 30758					;THIS TEST VERIFIES THAT JSP ALWAYS JUMPS.
 30759					;IN THIS TEST, JSP .+2 IS EXECUTED.  IF JSP JUMPS, THE TEST PASSES;
 30760					;OTHERWISE, THIS TEST HALTS
 30761
 30762	047230	265 00 0 00 047232 	C10400:	JSP	.+2		;*JSP SHOULD ALWAYS JUMP
 30763						STOP^
 30764	047231	254 04 0 00 047232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30765	047232	324 00 0 00 047233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30766									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30767									;IN THE SUBTEST) TO LOOP ON ERROR^
 30768
 30769					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39
DFKAA4	MAC	13-Jan-89 10:22		TEST JRST INSTRUCTION

 30770					SUBTTL	TEST JRST INSTRUCTION
 30771
 30772					;**********
 30773
 30774					;THIS TEST VERIFIES THAT JRST ALWAYS JUMPS.
 30775					;IN THIS TEST, JRST .+2 IS EXECUTED.  IF JRST JUMPS, THE TEST PASSES;
 30776					;OTHERWISE, THIS TEST HALTS
 30777
 30778	047233	254 00 0 00 047235 	C10500:	JRST	.+2		;*JRST 0, SHOULD ALWAYS JUMP
 30779						STOP^
 30780	047234	254 04 0 00 047235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30781	047235	324 00 0 00 047236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30782									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30783									;IN THE SUBTEST) TO LOOP ON ERROR^
 30784
 30785					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOBJX INSTRUCTIONS

 30786					SUBTTL	TEST OF AOBJX INSTRUCTIONS
 30787
 30788					;**********
 30789
 30790					;THIS TEST VERIFIES THAT AOBJN ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
 30791					;FIRST, THE AC IS CLEARED; THEN, AOBJN IS EXECUTED AND THE AC IS CHECKED
 30792					;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 30793
 30794	047236	400 00 0 00 000000 	C11200:	SETZ			;CLEAR THE AC
 30795	047237	253 00 0 00 047240 		AOBJN	.+1		;*AOBJN SHOULD ADD 1 TO BOTH HALVES OF THE AC
 30796	047240	312 00 0 00 070251 		CAME	[XWD 1,1]	;PASS IF C(AC)=1,,1
 30797						STOP^
 30798	047241	254 04 0 00 047242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30799	047242	324 00 0 00 047243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30800									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30801									;IN THE SUBTEST) TO LOOP ON ERROR^
 30802
 30803					;**********
 30804
 30805					;THIS TEST VERIFIES THAT AOBJP ALWAYS ADDS 1 TO BOTH HALVES OF THE AC.
 30806					;FIRST, THE AC IS CLEARED; THEN AOBJP IS EXECUTED AND THE AC IS CHECKED
 30807					;FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 30808
 30809	047243	200 00 0 00 070502 	C11300:	MOVE	[XWD 377777,377777]	;PRELOAD AC WITH 377777,,377777
 30810	047244	252 00 0 00 047245 		AOBJP	.+1			;*AOBJP SHOULD ADD, TO BOTH HALVES OF THE AC
 30811	047245	312 00 0 00 070460 		CAME	[XWD 400000,400000]	;PASS IF C(AC)=400000,400000
 30812						STOP^
 30813	047246	254 04 0 00 047247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30814	047247	324 00 0 00 047250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30815									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30816									;IN THE SUBTEST) TO LOOP ON ERROR^
 30817
 30818					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOBJX INSTRUCTIONS

 30819					;THIS TEST VERIFIES THAT AOBJN WILL NOT JUMP WHEN C(AC) IS POSITIVE
 30820					;FIRST, THE AC IS CLEARED; AND AOBJN IS EXECUTED.  AOBJN SHOULD NOT JUMP
 30821					;BECAUSE C(AC) IS POSITIVE.  IF AOBJN JUMPS, THIS TEST FAILS
 30822
 30823	047250	400 00 0 00 000000 	C11400:	SETZ			;CLEAR THE AC
 30824	047251	253 00 0 00 047253 		AOBJN	.+2		;*AOBJN SHOULD NOT JUMP WHEN C(AC) IS POSITIVE
 30825	047252	334 00 0 00 000000 		SKIPA			;PASS IF AOBJN DOES NOT JUMP
 30826						STOP^
 30827	047253	254 04 0 00 047254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30828	047254	324 00 0 00 047255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30829									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30830									;IN THE SUBTEST) TO LOOP ON ERROR^
 30831
 30832					;**********
 30833
 30834					;THIS TEST VERIFIES THAT AOBJP WILL JUMP WHEN C(AC) IS POSITIVE
 30835					;FIRST, THE AC IS CLEARED; AND AOBJP IS EXECUTED.  AOBJP SHOULD JUMP
 30836					;BECAUSE C(AC) IS POSITIVE.  IF AOBJP DOES NOT JUMP, THIS TEST FAILS
 30837
 30838	047255	400 00 0 00 000000 	C11500:	SETZ			;CLEAR THE AC
 30839	047256	252 00 0 00 047260 		AOBJP 	.+2		;*AOBJP SHOULD JUMP BECAUSE C(AC) IS POSITIVE
 30840						STOP^
 30841	047257	254 04 0 00 047260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30842	047260	324 00 0 00 047261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30843									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30844									;IN THE SUBTEST) TO LOOP ON ERROR^
 30845
 30846					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOBJX INSTRUCTIONS

 30847					;THIS TEST VERIFIES THAT AOBJN WILL JUMP WHEN C(AC) IS NEGATIVE
 30848					;FIRST, THE AC IS PRELOADED WITH 400000,,0; AND AOBJN IS EXECUTED.  AOBJN SHOULD JUMP
 30849					;BECAUSE C(AC) IS NEGATIVE.  IF AOBJN DOES NOT JUMP, THIS TEST FAILS
 30850
 30851	047261	200 00 0 00 070460 	C11600:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
 30852	047262	253 00 0 00 047264 		AOBJN	.+2		;*AOBJN SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
 30853						STOP^
 30854	047263	254 04 0 00 047264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30855	047264	324 00 0 00 047265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30856									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30857									;IN THE SUBTEST) TO LOOP ON ERROR^
 30858
 30859					;**********
 30860
 30861					;THIS TEST VERIFIES THAT AOBJP WILL NOT JUMP WHEN C(AC) IS NEGATIVE.  FIRST,
 30862					;THE AC IS PRELOADED WITH 400000,,0; AND AOBJP IS EXECUTED.  AOBJP SHOULD NOT JUMP
 30863					;BECAUSE C(AC) IS NEGATIVE.  IF AOBJP JUMPS, THIS TEST FAILS
 30864
 30865	047265	200 00 0 00 070460 	C11700:	MOVE	[XWD 400000,400000]	;PRELOAD AC WITH 400000,,400000
 30866	047266	252 00 0 00 047270 		AOBJP	.+2		;*AOBJP SHOULD NOT JUMP BECAUSE C(AC) IS NEGATIVE
 30867	047267	334 00 0 00 000000 		SKIPA			;PASS IF AOBJP DOES NOT JUMP
 30868						STOP^
 30869	047270	254 04 0 00 047271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30870	047271	324 00 0 00 047272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30872									;IN THE SUBTEST) TO LOOP ON ERROR^
 30873
 30874					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOBJX INSTRUCTIONS

 30875					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON AOBJN.
 30876					;THE AC IS PRELOADED WITH -1,,-1; THEN AOBJN IS EXECUTED. AOBJN SHOULD ADD ONE
 30877					;TO BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 30878					;CARRY WAS GENERATED, THIS TEST PASSES
 30879
 30880	047272	474 00 0 00 000000 	C12000:	SETO			;PRELOAD AC WITH -1,, -1
 30881	047273	253 00 0 00 047274 		AOBJN	.+1		;*AOBJN SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 30882	047274	332 00 0 00 000000 		SKIPE			;PASS IF C(AC)=0 (NO CARRY WAS GENERATED)
 30883						STOP^
 30884	047275	254 04 0 00 047276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30885	047276	324 00 0 00 047277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30886									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30887									;IN THE SUBTEST) TO LOOP ON ERROR^
 30888
 30889					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44
DFKAA4	MAC	13-Jan-89 10:22		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX

 30890					SUBTTL	TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX
 30891
 30892					;THIS TEST VERIFIES THAT MOVNI SETS CRY0 AND CRY1 FLAGS ONLY WHEN THE DATA IS 0.
 30893					;FIRST, THE ARITHMETIC FLAGS ARE RESET; THEN, MOVNI IS EXECUTED WITH DATA OF ZEROS.
 30894					;THE ARITHMETIC FLAGS ARE CHECKED.
 30895					; CRY0/1 ARE SET AND AROV AND FOV RESET, THIS TEST PASSES.
 30896
 30897	047277	255 17 0 00 047300 	C12100:	JFCL	17,.+1		;CLEAR FLAGS
 30898	047300	211 00 0 00 000000 		MOVNI	0		;* MOVNI 0 SHOULD SET CRY0/1
 30899	047301	255 04 0 00 047303 		JCRY0	.+2		;PASS IF CRY0 IS SET
 30900						STOP^
 30901	047302	254 04 0 00 047303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30902	047303	324 00 0 00 047304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30904									;IN THE SUBTEST) TO LOOP ON ERROR^
 30905	047304	255 02 0 00 047306 		JCRY1	.+2		;PASS IF CRY1 IS SET
 30906						STOP^
 30907	047305	254 04 0 00 047306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30908	047306	324 00 0 00 047307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30909									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30910									;IN THE SUBTEST) TO LOOP ON ERROR^
 30911	047307	255 10 0 00 047311 		JOV	.+2		;PASS IF AROV RESET
 30912	047310	334 00 0 00 000000 		SKIPA
 30913						STOP^
 30914	047311	254 04 0 00 047312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30915	047312	324 00 0 00 047313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30916									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30917									;IN THE SUBTEST) TO LOOP ON ERROR^
 30918	047313	255 01 0 00 047315 		JFOV	.+2		;PASS IF FOV RESET
 30919	047314	334 00 0 00 000000 		SKIPA
 30920						STOP^
 30921	047315	254 04 0 00 047316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30922	047316	324 00 0 00 047317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30923									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30924									;IN THE SUBTEST) TO LOOP ON ERROR^
 30925
 30926					;**********
 30927
 30928					;THIS TEST VERIFIES THAT MOVN WILL NOT SET ARITHMETIC FLAGS WHEN THE DATA IS -1,,-1.
 30929					;FIRST, THE FLAGS ARE RESET; THEN, MOVN [-1,,-1] IS EXECUTED.
 30930					;THE ARITHMETIC FLAGS ARE CHECKED.
 30931					;IF ANY ARITHMETIC FLAG IS SET, THIS TEST FAILS.
 30932
 30933	047317	255 17 0 00 047320 	C12200:	JFCL	17,.+1		;CLEAR FLAGS
 30934	047320	210 00 0 00 070254 		MOVN	[-1]		;*MOVN [-1,,-1] SHOULD SET ARITHMETIC FLAGS
 30935	047321	255 17 0 00 047323 		JFCL	17,.+2		;FAIL IF AN ARITHMETIC FLAG IS SET
 30936	047322	334 00 0 00 000000 		SKIPA			;SKIP HALT INSTRUCTION IF MOVN PASSED.
 30937						STOP^
 30938	047323	254 04 0 00 047324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30939	047324	324 00 0 00 047325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30940									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30941									;IN THE SUBTEST) TO LOOP ON ERROR^
 30942
 30943					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45
DFKAA4	MAC	13-Jan-89 10:22		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX

 30944					;THIS TEST VERIFIES THAT MOVN WILL SET THE AROV AND
 30945					;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
 30946					;FIRST, THE FLAGS ARE RESET; THEN, MOVN [400000,,0] IS EXECUTED.
 30947					;THE ARITHMETIC FLAGS ARE CHECKED.
 30948					;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.
 30949
 30950	047325	255 17 0 00 047326 	C12300:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
 30951	047326	210 00 0 00 070256 		MOVN	[XWD 400000,0]	;*MOVN [400000,,0] SHOULD SET AROV AND CRY1 ONLY
 30952	047327	255 10 0 00 047331 		JOV	.+2		;PASS IF AROV IS SET
 30953						STOP^
 30954	047330	254 04 0 00 047331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30955	047331	324 00 0 00 047332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30956									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30957									;IN THE SUBTEST) TO LOOP ON ERROR^
 30958	047332	255 02 0 00 047334 		JCRY1	.+2		;PASS IF CRY0 IS SET
 30959						STOP^
 30960	047333	254 04 0 00 047334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30961	047334	324 00 0 00 047335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30963									;IN THE SUBTEST) TO LOOP ON ERROR^
 30964	047335	255 04 0 00 047337 		JCRY0	.+2		;PASS IF CRY0 IS RESET
 30965	047336	334 00 0 00 000000 		SKIPA
 30966						STOP^
 30967	047337	254 04 0 00 047340 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30968	047340	324 00 0 00 047341 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30970									;IN THE SUBTEST) TO LOOP ON ERROR^
 30971	047341	255 01 0 00 047343 		JFOV	.+2		;PASS IF FOV IS RESET
 30972	047342	334 00 0 00 000000 		SKIPA
 30973						STOP^
 30974	047343	254 04 0 00 047344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30975	047344	324 00 0 00 047345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30976									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30977									;IN THE SUBTEST) TO LOOP ON ERROR^
 30978
 30979					;**********
 30980
 30981					;THIS TEST VERIFIES THAT MOVM WILL SET THE AROV AND
 30982					;CRY1 FLAGS ONLY WHEN THE DATA IS 400000,,0
 30983					;FIRST, THE FLAGS ARE RESET; THEN, MOVM [400000,,0] IS EXECUTED.
 30984					;THE ARITHMETIC FLAGS ARE CHECKED.
 30985					;IF AROV AND CRY1 ARE SET AND CRY0 AND FOV ARE RESET, THIS TEST PASSES.
 30986
 30987	047345	255 17 0 00 047346 	C12301:	JFCL	17,.+1		;CLEAR ARITHMETIC FLAGS
 30988	047346	214 00 0 00 070256 		MOVM	[XWD 400000,0]	;*MOVM [400000,,0] SHOULD SET AROV AND CRY1 ONLY
 30989	047347	255 10 0 00 047351 		JOV	.+2		;PASS IF AROV IS SET
 30990						STOP^
 30991	047350	254 04 0 00 047351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30992	047351	324 00 0 00 047352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 30993									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 30994									;IN THE SUBTEST) TO LOOP ON ERROR^
 30995	047352	255 02 0 00 047354 		JCRY1	.+2		;PASS IF CRY0 IS SET
 30996						STOP^
 30997	047353	254 04 0 00 047354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 30998	047354	324 00 0 00 047355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45-1
DFKAA4	MAC	13-Jan-89 10:22		TEST SETTING OF ARITHMETIC FLAGS VIA MOVNX AND MOVMX

 30999									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31000									;IN THE SUBTEST) TO LOOP ON ERROR^
 31001	047355	255 04 0 00 047357 		JCRY0	.+2		;PASS IF CRY0 IS RESET
 31002	047356	334 00 0 00 000000 		SKIPA
 31003						STOP^
 31004	047357	254 04 0 00 047360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31005	047360	324 00 0 00 047361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31006									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31007									;IN THE SUBTEST) TO LOOP ON ERROR^
 31008	047361	255 01 0 00 047363 		JFOV	.+2		;PASS IF FOV IS RESET
 31009	047362	334 00 0 00 000000 		SKIPA
 31010						STOP^
 31011	047363	254 04 0 00 047364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31012	047364	324 00 0 00 047365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31013									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31014									;IN THE SUBTEST) TO LOOP ON ERROR^
 31015
 31016					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 46
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOS AND SOS INSTRUCTIONS

 31017					SUBTTL	TEST OF AOS AND SOS INSTRUCTIONS
 31018
 31019					;**********
 31020
 31021					;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
 31022					;FIRST, E IS CLEARED; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 1.
 31023					;IF C(E) IS NOT 1 OR AOS SKIPPED, THIS TEST FAILS
 31024
 31025	047365	400 00 0 00 000000 	C12600:	SETZ			;CLEAR E
 31026	047366	350 00 0 00 000000 		AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
 31027	047367	302 00 0 00 000001 		CAIE	1		;PASS IF C(E)=0,,1 ANDAOS DID NOT SKIP
 31028						STOP^
 31029	047370	254 04 0 00 047371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31030	047371	324 00 0 00 047372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31031									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31032									;IN THE SUBTEST) TO LOOP ON ERROR^
 31033
 31034					;**********
 31035
 31036					;THIS TEST VERIFIES THAT AOS ADDS 1 TO MEMORY AND DOES NOT SKIP.
 31037					;FIRST, E IS PRELOADED WITH -1,,-1; THEN, AOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
 31038					;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS
 31039
 31040	047372	474 00 0 00 000000 	C12700:	SETO			;PRELOAD E WITH -1,,-1
 31041	047373	350 00 0 00 000000 		AOS			;*AOS SHOULD ADD 1 TO C(E) AND NOT SKIP
 31042	047374	302 00 0 00 000000 		CAIE			;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
 31043						STOP^
 31044	047375	254 04 0 00 047376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31045	047376	324 00 0 00 047377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31046									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31047									;IN THE SUBTEST) TO LOOP ON ERROR^
 31048
 31049					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 47
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOS AND SOS INSTRUCTIONS

 31050					;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
 31051					;FIRST, E IS CLEARED; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR -1,,-1.
 31052					;IF C(E) IS NOT -1,,-1 OR SOS SKIPPED, THIS TEST FAILS
 31053
 31054	047377	400 00 0 00 000000 	C13100:	SETZ			;CLEAR E
 31055	047400	370 00 0 00 000000 		SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND NOT SKIP
 31056	047401	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(E)=-1,,-1 AND SOS DID NOT SKIP
 31057						STOP^
 31058	047402	254 04 0 00 047403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31059	047403	324 00 0 00 047404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31060									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31061									;IN THE SUBTEST) TO LOOP ON ERROR^
 31062
 31063					;**********
 31064
 31065					;THIS TEST VERIFIES THAT SOS SUBTRACTS 1 FROM MEMORY AND DOES NOT SKIP.
 31066					;FIRST, E IS PRELOADED WITH A; THEN, SOS IS EXECUTED. NEXT E IS CHECKED FOR 0.
 31067					;IF C(E) IS NOT 0 OR SOS SKIPPED, THIS TEST FAILS
 31068
 31069	047404	201 00 0 00 000001 	C13200:	MOVEI	1		;PRELOAD E WITH 1
 31070	047405	370 00 0 00 000000 		SOS			;*SOS SHOULD SUBTRACT 1 FROM C(E) AND DID NOT SKIP
 31071	047406	302 00 0 00 000000 		CAIE	0		;PASS IF C(E)=0 AND SOS DID NOT SKIP
 31072						STOP^
 31073	047407	254 04 0 00 047410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31074	047410	324 00 0 00 047411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31075									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31076									;IN THE SUBTEST) TO LOOP ON ERROR^
 31077
 31078					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 48
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOS AND SOS INSTRUCTIONS

 31079					;THIS TEST VERIFIES THAT SOS SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
 31080					;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
 31081					;SOS IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
 31082					;AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31083
 31084	047411	255 17 0 00 047412 	C13300:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31085	047412	201 00 0 00 000001 		MOVEI	1		;PRELOAD E WITH 1
 31086	047413	370 00 0 00 000000 		SOS			;*SOS SHOULD SET CRY0/1
 31087	047414	255 04 0 00 047416 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31088						STOP^
 31089	047415	254 04 0 00 047416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31090	047416	324 00 0 00 047417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31091									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31092									;IN THE SUBTEST) TO LOOP ON ERROR^
 31093	047417	255 02 0 00 047421 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31094						STOP^
 31095	047420	254 04 0 00 047421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31096	047421	324 00 0 00 047422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31097									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31098									;IN THE SUBTEST) TO LOOP ON ERROR^
 31099	047422	255 10 0 00 047424 		JOV	.+2		;PASS IF AROV IS RESET
 31100	047423	334 00 0 00 000000 		SKIPA
 31101						STOP^
 31102	047424	254 04 0 00 047425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31103	047425	324 00 0 00 047426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31104									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31105									;IN THE SUBTEST) TO LOOP ON ERROR^
 31106	047426	255 01 0 00 047430 		JFOV	.+2		;PASS IF FOV IS RESET
 31107	047427	334 00 0 00 000000 		SKIPA
 31108						STOP^
 31109	047430	254 04 0 00 047431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31110	047431	324 00 0 00 047432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31111									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31112									;IN THE SUBTEST) TO LOOP ON ERROR^
 31113
 31114					;**********
 31115
 31116					;THIS TEST VERIFIES THAT AOS SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
 31117					;FIRST THE FLAGS ARE RESET; THEN
 31118					;AOS IS EXECUTED.  THE FLAGS ARE CHECKED.
 31119					;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31120
 31121	047432	255 17 0 00 047433 	C13400:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31122	047433	474 00 0 00 000000 		SETO			;PRELOAD E WITH 1
 31123	047434	350 00 0 00 000000 		AOS			;*AOS SHOULD SET CRY0 AND CRY1
 31124	047435	255 04 0 00 047437 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31125						STOP^
 31126	047436	254 04 0 00 047437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31127	047437	324 00 0 00 047440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31129									;IN THE SUBTEST) TO LOOP ON ERROR^
 31130	047440	255 02 0 00 047442 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31131						STOP^
 31132	047441	254 04 0 00 047442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31133	047442	324 00 0 00 047443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 48-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOS AND SOS INSTRUCTIONS

 31134									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31135									;IN THE SUBTEST) TO LOOP ON ERROR^
 31136	047443	255 10 0 00 047445 		JOV	.+2		;PASS IF AROV IS RESET
 31137	047444	334 00 0 00 000000 		SKIPA
 31138						STOP^
 31139	047445	254 04 0 00 047446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31140	047446	324 00 0 00 047447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31141									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31142									;IN THE SUBTEST) TO LOOP ON ERROR^
 31143	047447	255 01 0 00 047451 		JFOV	.+2		;PASS IF FOV IS RESET
 31144	047450	334 00 0 00 000000 		SKIPA
 31145						STOP^
 31146	047451	254 04 0 00 047452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31147	047452	324 00 0 00 047453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31148									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31149									;IN THE SUBTEST) TO LOOP ON ERROR^
 31150
 31151					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 49
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS

 31152					SUBTTL	TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS
 31153
 31154					;**********
 31155
 31156					;THIS TEST VERIFIES THAT JFCL 1, WILL ALWAYS CLEAR FOV FLAG.
 31157					;FIRST, FOV IS SET VIA JRST 2, ;THEN JFCL 1,.+1 IS EXECUTED TO CLEAR FOV.
 31158					;IF FOV WAS CLEARED, THIS TEST PASSES.
 31159
 31160	047453				C13600:	SFLAG	FOV		^;SET FOV FLAG
 31161
 31162	047453	205 01 0 00 040000 		MOVSI	1,FOV
 31163	047454	255 17 0 00 047455 		JFCL	17,.+1	;RESET ALL FLAGS
 31164	047455	254 02 0 01 047456 		JRST	2,.+1(1)		;SET FOV FLAG
 31165	047456	255 01 0 00 047457 		JFCL	1,.+1		;*JFCL SHOULD RESET FOV
 31166	047457	255 01 0 00 047461 		JFCL	1,.+2		;PASS IF FOV IS RESET
 31167	047460	334 00 0 00 000000 		SKIPA			;SKIP HALT IF JFCL 1,.+1 PASSED
 31168						STOP^
 31169	047461	254 04 0 00 047462 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31170	047462	324 00 0 00 047463 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31171									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31172									;IN THE SUBTEST) TO LOOP ON ERROR^
 31173
 31174					;**********
 31175
 31176					;THIS TEST VERIFIES THAT JRST 2, CAN SET FXU AND JSP CAN SAVE FXU IN THE AC.
 31177					;FIRST, FXU IS SET VIA JRST 2, ;THEN, JSP IS EXECUTED. THE AC IS CHECKED
 31178					;FOR FXU.  IF FXU IS SET, THIS TEST PASSES; OTHERWISE, EITHER JRST 2, OR JSP FAILED.
 31179
 31180	047463				C13700:	SFLAG	FXU		^;*SET FXU FLAG
 31181
 31182	047463	205 01 0 00 000100 		MOVSI	1,FXU
 31183	047464	255 17 0 00 047465 		JFCL	17,.+1	;RESET ALL FLAGS
 31184	047465	254 02 0 01 047466 		JRST	2,.+1(1)		;SET FXU FLAG
 31185	047466	265 00 0 00 047467 		JSP	.+1		;*STORE FXU FLAG IN AC
 31186	047467	607 00 0 00 000100 		TLNN	FXU		;PASS IF FXU IS SET IN THE AC
 31187						STOP^
 31188	047470	254 04 0 00 047471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31189	047471	324 00 0 00 047472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31191									;IN THE SUBTEST) TO LOOP ON ERROR^
 31192
 31193					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 50
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS

 31194					;THIS TEST VERIFIES THAT JRST 2, CAN RESET FXU AND JSP CAN SAVE FXU IN THE AC.
 31195					;FIRST, FXU IS SET; THEN, FXU IS RESET VIA JRST 2,.  NEXT, JSP IS EXECUTED; AND
 31196					;THE AC IS CHECKED FOR FXU RESET.  IF FXU IS RESET IN THE AC, THIS TEST PASSES;
 31197					;OTHERWISE, JRST 2, FAILED TO CLEAR FXU OR JSP STORED FXU INCORECTLY.
 31198
 31199	047472				C14000:	SFLAG	FXU		^;SET FXU FLAG
 31200
 31201	047472	205 01 0 00 000100 		MOVSI	1,FXU
 31202	047473	255 17 0 00 047474 		JFCL	17,.+1	;RESET ALL FLAGS
 31203	047474	254 02 0 01 047475 		JRST	2,.+1(1)		;SET FXU FLAG
 31204						SFLAG			^;*RESET FXU FLAG
 31205
 31206	047475	205 01 0 00 000000 		MOVSI	1,
 31207	047476	255 17 0 00 047477 		JFCL	17,.+1	;RESET ALL FLAGS
 31208	047477	254 02 0 01 047500 		JRST	2,.+1(1)		;SET  FLAG
 31209	047500	265 00 0 00 047501 		JSP	.+1		;*STORE FXU FLAG IN THE AC
 31210	047501	603 00 0 00 000100 		TLNE	FXU		;PASS IF FXU IS RESET IN THE AC
 31211						STOP^
 31212	047502	254 04 0 00 047503 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31213	047503	324 00 0 00 047504 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31214									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31215									;IN THE SUBTEST) TO LOOP ON ERROR^
 31216
 31217					;**********
 31218
 31219					;THIS TEST VERIFIES THAT JRST 2, CAN SET DCK AND JSP CAN SAVE DCK IN THE AC.
 31220					;FIRST, DCK IS SET VIA JRST 2, ;THEN JSP IS EXECUTED.  THE AC IS CHECKED
 31221					;FOR DCK.  IF DCK IS SET, THIS TEST PASSES, OTHERWISE JRST 2, OR JSP FAILED.
 31222
 31223	047504				C14100:	SFLAG	DCK		^;*SET DCK FLAG
 31224
 31225	047504	205 01 0 00 000040 		MOVSI	1,DCK
 31226	047505	255 17 0 00 047506 		JFCL	17,.+1	;RESET ALL FLAGS
 31227	047506	254 02 0 01 047507 		JRST	2,.+1(1)		;SET DCK FLAG
 31228	047507	265 00 0 00 047510 		JSP	.+1		;*STORE FXU FLAG IN AC
 31229	047510	607 00 0 00 000040 		TLNN	DCK		;PASS IF FXU IS SET IN THE AC
 31230						STOP^
 31231	047511	254 04 0 00 047512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31232	047512	324 00 0 00 047513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31233									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31234									;IN THE SUBTEST) TO LOOP ON ERROR^
 31235
 31236					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 51
DFKAA4	MAC	13-Jan-89 10:22		TEST OF INTERACTION OF JFCL, JRST, AND JSP WITH ARITHMETIC FLAGS

 31237					;THIS TEST VERIFIES THAT JRST 2, CAN RESET DCK AND JSP CAN SAVE DCK IN THE AC.
 31238					;FIRST, FXU IS SET; THEN, DCK IS RESET VIA JRST 2,.  NEXT, JSP IS EXPECTED; AND
 31239					;THE AC IS CHECKED FOR DCK RESET.  IF DCK IS RESET IN THE AC, THIS TEST PASSES;
 31240					;OTHERWISE, JRST 2, FAILED TO CLEAR DCK OR JSP STORED DCK INCORRECTLY.
 31241
 31242	047513				C14200:	SFLAG	DCK		^;SET DCK FLAG
 31243
 31244	047513	205 01 0 00 000040 		MOVSI	1,DCK
 31245	047514	255 17 0 00 047515 		JFCL	17,.+1	;RESET ALL FLAGS
 31246	047515	254 02 0 01 047516 		JRST	2,.+1(1)		;SET DCK FLAG
 31247						SFLAG			^;*RESET DCK FLAG
 31248
 31249	047516	205 01 0 00 000000 		MOVSI	1,
 31250	047517	255 17 0 00 047520 		JFCL	17,.+1	;RESET ALL FLAGS
 31251	047520	254 02 0 01 047521 		JRST	2,.+1(1)		;SET  FLAG
 31252	047521	265 00 0 00 047522 		JSP	.+1		;*STORE DCK FLAG IN THE AC
 31253	047522	603 00 0 00 000040 		TLNE	DCK		;PASS IF DCK IS RESET IN THE AC
 31254						STOP^
 31255	047523	254 04 0 00 047524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31256	047524	324 00 0 00 047525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31257									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31258									;IN THE SUBTEST) TO LOOP ON ERROR^
 31259
 31260					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 52
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JUMPX INSTRUCTIONS

 31261					SUBTTL	TEST OF JUMPX INSTRUCTIONS
 31262
 31263					;**********
 31264
 31265					;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31266					;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS -1,,-1.  HENCE,
 31267					;JUMPL SHOULD JUMP.  IF JUMPL JUMPS, THIS TEST PASSES.
 31268
 31269	047525	474 00 0 00 000000 	C14500:	SETO			;PRELOAD AC WITH -1,,-1
 31270	047526	321 00 0 00 047530 		JUMPL	.+2		;*JUMPL SHOULD JUMP BECAUSE C(AC) IS NEGATIVE
 31271						STOP^
 31272	047527	254 04 0 00 047530 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31273	047530	324 00 0 00 047531 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31274									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31275									;IN THE SUBTEST) TO LOOP ON ERROR^
 31276
 31277					;**********
 31278
 31279					;THIS TEST VERIFIES THAT JUMPL IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31280					;C(AC) IS NEGATIVE.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
 31281					;JUMPL SHOULD NOT JUMP.  IF JUMPL DOES NOT JUMP, THIS TEST PASSES.
 31282
 31283	047531	400 00 0 00 000000 	C14600:	SETZ			;PRELOAD AC WITH 0
 31284	047532	321 00 0 00 047534 		JUMPL	.+2		;*JUMPL SHOULD NOT JUMP
 31285	047533	334 00 0 00 000000 		SKIPA			;PASS IF JUMPL DOES NOT JUMP
 31286						STOP^
 31287	047534	254 04 0 00 047535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31288	047535	324 00 0 00 047536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31289									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31290									;IN THE SUBTEST) TO LOOP ON ERROR^
 31291
 31292					;**********
 31293
 31294					;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31295					;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
 31296					;JUMPE SHOULD JUMP.  IF JUMPE JUMPS, THIS TEST PASSES.
 31297
 31298	047536	400 00 0 00 000000 	C14700:	SETZ			;PRELOAD AC WITH 0
 31299	047537	322 00 0 00 047541 		JUMPE	.+2		;*JUMPE SHOULD JUMP
 31300						STOP^
 31301	047540	254 04 0 00 047541 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31302	047541	324 00 0 00 047542 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31304									;IN THE SUBTEST) TO LOOP ON ERROR^
 31305
 31306					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 53
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JUMPX INSTRUCTIONS

 31307					;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31308					;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
 31309					;JUMPN SHOULD JUMP.  IF JUMPN JUMPS, THIS TEST PASSES.
 31310
 31311	047542	201 00 0 00 000001 	C15000:	MOVEI	1		;PRELOAD AC WITH 1
 31312	047543	326 00 0 00 047545 		JUMPN	.+2		;*JUMPN SHOULD JUMP
 31313						STOP^
 31314	047544	254 04 0 00 047545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31315	047545	324 00 0 00 047546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31316									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31317									;IN THE SUBTEST) TO LOOP ON ERROR^
 31318
 31319					;**********
 31320
 31321					;THIS TEST VERIFIES THAT JUMPE IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31322					;C(AC)=0.  IN THIS TEST, THE AC CONTAINS 2.  HENCE,
 31323					;JUMPL SHOULD NOT JUMP.  IF JUMPE DOES NOT JUMP, THIS TEST PASSES.
 31324
 31325	047546	201 00 0 00 000002 	C15100:	MOVEI	2		;PRELOAD AC WITH 2
 31326	047547	322 00 0 00 047551 		JUMPE	.+2		;*JUMPE SHOULD NOT JUMP
 31327	047550	334 00 0 00 000000 		SKIPA			;PASS IF JUMPE DID NOT JUMP
 31328						STOP^
 31329	047551	254 04 0 00 047552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31330	047552	324 00 0 00 047553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31331									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31332									;IN THE SUBTEST) TO LOOP ON ERROR^
 31333
 31334					;**********
 31335
 31336					;THIS TEST VERIFIES THAT JUMPN IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31337					;C(AC) IS NON-ZERO.  IN THIS TEST, THE AC CONTAINS 0.  HENCE,
 31338					;JUMPN SHOULD NOT JUMP.  IF JUMPN DOES NOT JUMP, THIS TEST PASSES.
 31339
 31340	047553	400 00 0 00 000000 	C15200:	SETZ			;PRELOAD AC WITH 0
 31341	047554	326 00 0 00 047556 		JUMPN	.+2		;*JUMPN SHOULD NOT JUMP
 31342	047555	334 00 0 00 000000 		SKIPA			;PASS IF JUMPN DID NOT JUMP
 31343						STOP^
 31344	047556	254 04 0 00 047557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31345	047557	324 00 0 00 047560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31346									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31347									;IN THE SUBTEST) TO LOOP ON ERROR^
 31348
 31349					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 54
DFKAA4	MAC	13-Jan-89 10:22		TEST OF JUMPX INSTRUCTIONS

 31350					;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31351					;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS 1.  HENCE,
 31352					;JUMPG SHOULD JUMP.  IF JUMPG JUMPS, THIS TEST PASSES.
 31353
 31354	047560	201 00 0 00 000001 	C15300:	MOVEI	1		;PRELOAD  AC WITH 1
 31355	047561	327 00 0 00 047563 		JUMPG	.+2		;*JUMPG SHOULD JUMP
 31356						STOP^
 31357	047562	254 04 0 00 047563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31358	047563	324 00 0 00 047564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31359									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31360									;IN THE SUBTEST) TO LOOP ON ERROR^
 31361
 31362					;**********
 31363
 31364					;THIS TEST VERIFIES THAT JUMPG IS DATA DEPENDENT.  IT WILL JUMP IF AND ONLY IF
 31365					;C(AC) IS GREATER THAN 0.  IN THIS TEST, THE AC CONTAINS -1,,0.  HENCE,
 31366					;JUMPG SHOULD NOT JUMP.  IF JUMPG DOES NOT JUMP, THIS TEST PASSES.
 31367
 31368	047564	205 00 0 00 777777 	C15400:	MOVSI	-1		;PRELOAD AC WITH -1,,0
 31369	047565	327 00 0 00 047567 		JUMPG	.+2		;*JUMPG SHOULD NOT JUMP
 31370	047566	334 00 0 00 000000 		SKIPA			;PASS IF JUMPG DID NOT JUMP
 31371						STOP^
 31372	047567	254 04 0 00 047570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31373	047570	324 00 0 00 047571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31374									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31375									;IN THE SUBTEST) TO LOOP ON ERROR^
 31376
 31377					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 55
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOJ AND SOJ INSTRUCTIONS

 31378					SUBTTL	TEST OF AOJ AND SOJ INSTRUCTIONS
 31379
 31380					;**********
 31381
 31382					;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
 31383					;FIRST, THE AC IS PRELOADED WITH 0; THEN, AOJ IS EXECUTED.  NEXT, THE
 31384					;AC IS CHECKED FOR 1.  IF C(AC) IS NOT 1 OR AOJ SKIPPED, THIS TEST FAILS.
 31385
 31386	047571	400 00 0 00 000000 	C15500:	SETZ			;PRELOAD AC WITH 0
 31387	047572	340 00 0 00 047574 		AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
 31388	047573	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
 31389						STOP^
 31390	047574	254 04 0 00 047575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31391	047575	324 00 0 00 047576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31392									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31393									;IN THE SUBTEST) TO LOOP ON ERROR^
 31394
 31395					;**********
 31396
 31397					;THIS TEST VERIFIES THAT AOJ ADDS 1 TO THE AC AND DOES NOT JUMP.
 31398					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, AOJ IS EXECUTED.  NEXT, THE
 31399					;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR AOJ SKIPPED, THIS TEST FAILS.
 31400
 31401	047576	474 00 0 00 000000 	C15600:	SETO			;PRELOAD AC WITH 0
 31402	047577	340 00 0 00 047601 		AOJ	.+2		;*AOJ SHOULD ADD 1 TO THE AC AND NOT JUMP
 31403	047600	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=1 AND AOJ DID NOT JUMP
 31404						STOP^
 31405	047601	254 04 0 00 047602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31406	047602	324 00 0 00 047603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31407									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31408									;IN THE SUBTEST) TO LOOP ON ERROR^
 31409
 31410					;**********
 31411
 31412					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
 31413					;FIRST, THE AC IS PRELOADED WITH 0; THEN, SOJ IS EXECUTED.  NEXT, THE
 31414					;AC IS CHECKED FOR -1,,-1.  IF C(AC) IS NOT -1,,-1 OR SOJ SKIPPED, THIS TEST FAILS.
 31415
 31416	047603	400 00 0 00 000000 	C15700:	SETZ			;PRELOAD AC WITH 0
 31417	047604	360 00 0 00 047606 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
 31418	047605	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC)=-1,,-1 AND SOJ DID NOT JUMP
 31419						STOP^
 31420	047606	254 04 0 00 047607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31421	047607	324 00 0 00 047610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31422									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31423									;IN THE SUBTEST) TO LOOP ON ERROR^
 31424
 31425					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 56
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOJ AND SOJ INSTRUCTIONS

 31426					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
 31427					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, SOJ IS EXECUTED.  NEXT, THE
 31428					;AC IS CHECKED FOR -1,,-2.  IF C(AC) IS NOT -1,,-2 OR SOJ SKIPPED, THIS TEST FAILS.
 31429
 31430	047610	474 00 0 00 000000 	C16000:	SETO			;PRELOAD AC WITH -1,,-1
 31431	047611	360 00 0 00 047613 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
 31432	047612	312 00 0 00 070333 		CAME	[-2]		;PASS IF C(AC)=-1,,-2 AND SOJ DID NOT JUMP
 31433						STOP^
 31434	047613	254 04 0 00 047614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31435	047614	324 00 0 00 047615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31436									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31437									;IN THE SUBTEST) TO LOOP ON ERROR^
 31438
 31439					;**********
 31440
 31441					;THIS TEST VERIFIES THAT SOJ SUBTRACTS 1 FROM THE AC AND DOES NOT JUMP.
 31442					;FIRST, THE AC IS PRELOADED WITH 0,,1; THEN, SOJ IS EXECUTED.  NEXT, THE
 31443					;AC IS CHECKED FOR 0.  IF C(AC) IS NOT 0 OR SOJ SKIPPED, THIS TEST FAILS.
 31444
 31445	047615	201 00 0 00 000001 	C16100:	MOVEI	1		;PRELOAD AC WITH 1
 31446	047616	360 00 0 00 047620 		SOJ	.+2		;*SOJ SHOULD SUBTRACT 1 FROM THE AC AND NOT JUMP
 31447	047617	302 00 0 00 000000 		CAIE	0		;PASS IF C(AC)=0 AND SOJ DID NOT JUMP
 31448						STOP^
 31449	047620	254 04 0 00 047621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31450	047621	324 00 0 00 047622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31452									;IN THE SUBTEST) TO LOOP ON ERROR^
 31453
 31454					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOJ AND SOJ INSTRUCTIONS

 31455					;THIS TEST VERIFIES THAT SOJ AC, FOLLOWED BY AOJ AC, HAS NO NET EFFECT ON C(AC).
 31456					;IN THIS CASE, THE AC IS PRELOADED WITH 0; THEN, SOJ AC, FOLLOWED BY AOJ. 
 31457					;AC, IS REPEATED 7 TIMES.  THE AC IS THEN CHECKED FOR ITS ORIGINAL CONTENTS, 0.
 31458					;IF C(AC)=0, THIS TEST PASSES; OTHERWISE AOJ OR SOJ FAILED.
 31459
 31460			000017		C16200:	AC=17
 31461	047622	400 17 0 00 000000 		SETZ	AC,		;PRELOAD AC WITH 0
 31462						REPEAT	^D10,<
 31463						SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31464						AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC>
 31465
 31466	047623	360 17 0 00 047623 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31467	047624	340 17 0 00 047624 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31468
 31469	047625	360 17 0 00 047625 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31470	047626	340 17 0 00 047626 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31471
 31472	047627	360 17 0 00 047627 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31473	047630	340 17 0 00 047630 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31474
 31475	047631	360 17 0 00 047631 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31476	047632	340 17 0 00 047632 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31477
 31478	047633	360 17 0 00 047633 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31479	047634	340 17 0 00 047634 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31480
 31481	047635	360 17 0 00 047635 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31482	047636	340 17 0 00 047636 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31483
 31484	047637	360 17 0 00 047637 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31485	047640	340 17 0 00 047640 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31486
 31487	047641	360 17 0 00 047641 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31488	047642	340 17 0 00 047642 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31489
 31490	047643	360 17 0 00 047643 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31491	047644	340 17 0 00 047644 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31492
 31493	047645	360 17 0 00 047645 		SOJ	AC,.		;*SOJ SHOULD SUBTRACT 1 FROM THE AC
 31494	047646	340 17 0 00 047646 		AOJ	AC,.		;*AOJ SHOULD ADD 1 TO THE AC
 31495	047647	332 00 0 00 000017 		SKIPE	AC		;PASS IF C(AC) IS UNCHANGED. I.E. C(AC)=0
 31496						STOP^
 31497	047650	254 04 0 00 047651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31498	047651	324 00 0 00 047652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31499									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31500									;IN THE SUBTEST) TO LOOP ON ERROR^
 31501
 31502					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 58
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOJ AND SOJ INSTRUCTIONS

 31503					;THIS TEST VERIFIES THAT SOJ SETS CRY0/1 FLAGS IF C(E) IS A NON-ZERO NUMBER OTHER
 31504					;THAN 400000,,0.  IN THIS CASE, C(E)=1.  FIRST THE FLAGS ARE RESET; THEN
 31505					;SOJ IS EXECUTED.  THE  FLAGS ARE CHECKED.  IF CRY0 AND CRY1 ARE SET
 31506					;AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31507
 31508	047652	255 17 0 00 047653 	C16201:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31509	047653	201 00 0 00 000001 		MOVEI	1		;PRELOAD E WITH 1
 31510	047654	360 00 0 00 000000 		SOJ			;*SOJ SHOULD SET CRY0/1
 31511	047655	255 04 0 00 047657 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31512						STOP^
 31513	047656	254 04 0 00 047657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31514	047657	324 00 0 00 047660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31515									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31516									;IN THE SUBTEST) TO LOOP ON ERROR^
 31517	047660	255 02 0 00 047662 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31518						STOP^
 31519	047661	254 04 0 00 047662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31520	047662	324 00 0 00 047663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31521									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31522									;IN THE SUBTEST) TO LOOP ON ERROR^
 31523	047663	255 10 0 00 047665 		JOV	.+2		;PASS IF AROV IS RESET
 31524	047664	334 00 0 00 000000 		SKIPA
 31525						STOP^
 31526	047665	254 04 0 00 047666 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31527	047666	324 00 0 00 047667 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31529									;IN THE SUBTEST) TO LOOP ON ERROR^
 31530	047667	255 01 0 00 047671 		JFOV	.+2		;PASS IF FOV IS RESET
 31531	047670	334 00 0 00 000000 		SKIPA
 31532						STOP^
 31533	047671	254 04 0 00 047672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31534	047672	324 00 0 00 047673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31535									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31536									;IN THE SUBTEST) TO LOOP ON ERROR^
 31537
 31538					;**********
 31539
 31540					;THIS TEST VERIFIES THAT AOJ SETS CRY0 AND CRY1 FLAG IF C(E) IS -1,,-1
 31541					;FIRST THE FLAGS ARE RESET; THEN
 31542					;AOJ IS EXECUTED.  THE FLAGS ARE CHECKED.
 31543					;IF CRY0 AND CRY1 ARE SET AND AROV AND FOV ARE RESET, THIS TEST PASSES.
 31544
 31545	047673	255 17 0 00 047674 	C16202:	JFCL	17,.+1		;RESET ARITHMETIC FLAGS
 31546	047674	474 00 0 00 000000 		SETO			;PRELOAD E WITH 1
 31547	047675	340 00 0 00 000000 		AOJ			;*AOJ SHOULD SET CRY0 AND CRY1
 31548	047676	255 04 0 00 047700 		JCRY0	.+2		;PASS IF CRY0 IS SET
 31549						STOP^
 31550	047677	254 04 0 00 047700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31551	047700	324 00 0 00 047701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31552									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31553									;IN THE SUBTEST) TO LOOP ON ERROR^
 31554	047701	255 02 0 00 047703 		JCRY1	.+2		;PASS IF CRY1 IS SET
 31555						STOP^
 31556	047702	254 04 0 00 047703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31557	047703	324 00 0 00 047704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 58-1
DFKAA4	MAC	13-Jan-89 10:22		TEST OF AOJ AND SOJ INSTRUCTIONS

 31558									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31559									;IN THE SUBTEST) TO LOOP ON ERROR^
 31560	047704	255 10 0 00 047706 		JOV	.+2		;PASS IF AROV IS RESET
 31561	047705	334 00 0 00 000000 		SKIPA
 31562						STOP^
 31563	047706	254 04 0 00 047707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31564	047707	324 00 0 00 047710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31565									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31566									;IN THE SUBTEST) TO LOOP ON ERROR^
 31567	047710	255 01 0 00 047712 		JFOV	.+2		;PASS IF FOV IS RESET
 31568	047711	334 00 0 00 000000 		SKIPA
 31569						STOP^
 31570	047712	254 04 0 00 047713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31571	047713	324 00 0 00 047714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31572									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31573									;IN THE SUBTEST) TO LOOP ON ERROR^
 31574
 31575					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 59
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31576					SUBTTL	TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS
 31577
 31578					;**********
 31579
 31580					;THIS TEST VERIFIES THAT ADDM DOES NOT MODIFY C(AC)
 31581					;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN ADDM IS EXECUTED.
 31582					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31583
 31584	047714	477 00 0 00 000001 	C16400:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31585	047715	272 00 0 00 000001 		ADDM	1		;*ADDM SHOULD NOT AFFECT C(AC)
 31586	047716	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY ADDM
 31587						STOP^
 31588	047717	254 04 0 00 047720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31589	047720	324 00 0 00 047721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31590									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31591									;IN THE SUBTEST) TO LOOP ON ERROR^
 31592
 31593					;**********
 31594
 31595					;THIS TEST VERIFIES THAT HRREM DOES NOT MODIFY C(AC)
 31596					;THE AC IS PRELOADED WITH 0,,-1.  THEN HRRM IS EXECUTED.
 31597					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31598
 31599	047721	201 00 0 00 777777 	C16500:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 31600	047722	572 00 0 00 000001 		HRREM	1		;*HRRM SHOULD NOT AFFECT C(AC)
 31601	047723	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY HRRM
 31602						STOP^
 31603	047724	254 04 0 00 047725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31604	047725	324 00 0 00 047726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31605									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31606									;IN THE SUBTEST) TO LOOP ON ERROR^
 31607
 31608					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 60
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31609					;THIS TEST VERIFIES THAT MOVSM DOES NOT MODIFY C(AC)
 31610					;THE AC IS PRELOADED WITH 0,,-1.  THEN MOVSM IS EXECUTED.
 31611					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31612
 31613	047726	201 00 0 00 777777 	C16600:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 31614	047727	206 00 0 00 000001 		MOVSM	1		;*MOVSM SHOULD NOT AFFECT C(AC)
 31615	047730	302 00 0 00 777777 		CAIE	-1		;PASS IF C(AC) IS UNMODIFIED BY MOVSM
 31616						STOP^
 31617	047731	254 04 0 00 047732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31618	047732	324 00 0 00 047733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31619									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31620									;IN THE SUBTEST) TO LOOP ON ERROR^
 31621
 31622					;**********
 31623
 31624					;THIS TEST VERIFIES THAT XORM DOES NOT MODIFY C(AC)
 31625					;BOTH AC AND E ARE PRELOADED WITH -1,,-1.  THEN XORM IS EXECUTED.
 31626					;THIS TEST PASSES IF C(AC) ARE UNCHANGED
 31627
 31628	047733	477 00 0 00 000001 	C16700:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31629	047734	432 00 0 00 000001 		XORM	1		;*XORM SHOULD NOT AFFECT C(AC)
 31630	047735	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(AC) IS UNMODIFIED BY XORM
 31631						STOP^
 31632	047736	254 04 0 00 047737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31633	047737	324 00 0 00 047740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31634									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31635									;IN THE SUBTEST) TO LOOP ON ERROR^
 31636
 31637					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 61
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31638					;THIS TEST VERIFIES THAT ADDB ADDS C(AC) TO C(E) AND PLACES THE
 31639					;RESULT IN BOTH AC AND E.  IN THIS TEST, BOTH AC AND E ARE PRELOADED
 31640					;WITH -1,,-1, THEN, ADDB IS EXECUTED.  C(AC) IS THEN COMPARED TO C(E);
 31641					;AND C(AC) IS THEN COMPARED TO -2.  IF BOTH OF THESE COMPARISONS SUCCEED, THIS
 31642					;TEST PASSES; OTHERWISE, ADDB FAILED
 31643
 31644	047740	477 00 0 00 000001 	C17000:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31645	047741	273 00 0 00 000001 		ADDB	1		;*ADDB SHOULD ADD C(AC) TO C(E) AND PLACE RESULT
 31646									;INTO BOTH AC AND E
 31647	047742	312 00 0 00 000001 		CAME	1		;PASS IF C(AC)=C(E)
 31648						STOP^
 31649	047743	254 04 0 00 047744 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31650	047744	324 00 0 00 047745 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31651									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31652									;IN THE SUBTEST) TO LOOP ON ERROR^
 31653	047745	312 00 0 00 070333 		CAME	[-2]		;PASS IF C(AC)=-2
 31654						STOP^
 31655	047746	254 04 0 00 047747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31656	047747	324 00 0 00 047750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31657									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31658									;IN THE SUBTEST) TO LOOP ON ERROR^
 31659
 31660					;**********
 31661
 31662					;THIS TEST VERIFIES THAT ADDM ADDS C(AC) TO C(E) AND PLACES THE RESULT IN E
 31663					;IN THIS CASE, AC, E ARE BOTH PRELOADED WITH -1; THEN, ADDM IS EXECUTED.
 31664					;E IS THEN CHECKED FOR -2.  IF C(E)=-2, THIS TEST PASSES; OTHERWISE, ADDM FAILED
 31665
 31666	047750	477 00 0 00 000001 	C17100:	SETOB	1		;PRELOAD AC, E WITH -1,,-1
 31667	047751	272 00 0 00 000001 		ADDM	1		;*ADDM SHOULD ADD C(AC) TO C(E)
 31668	047752	312 01 0 00 070333 		CAME	1,[-2]		;PASS IF C(E)=-2
 31669						STOP^
 31670	047753	254 04 0 00 047754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31671	047754	324 00 0 00 047755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31673									;IN THE SUBTEST) TO LOOP ON ERROR^
 31674
 31675					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 62
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31676					;THIS TEST VERIFIES THAT HLLOS PLACES ONES ON THE RIGHT HALF OF E
 31677					;BUT DOES NOT AFFECT THE LEFT HALF OF E.  IN THIS CASE,
 31678					;E IS PRELOADED WITH 0; THE, HLLOS IS EXECUTED.  THE RESULT
 31679					;IN E SHOULD BE 0,,-1.  IF C(E)=0,,-1, THIS TEST PASSES
 31680
 31681	047755	402 00 0 00 000001 	C17200:	SETZM	1		;PRELOAD E WITH 0
 31682	047756	523 00 0 00 000001 		HLLOS	1		;*HLLOS SHOULD PLACE 0,,-1 INTO E
 31683	047757	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 31684						STOP^
 31685	047760	254 04 0 00 047761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31686	047761	324 00 0 00 047762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31687									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31688									;IN THE SUBTEST) TO LOOP ON ERROR^
 31689
 31690					;**********
 31691
 31692					;THIS TEST VERIFIES THAT MOVSS SWAPS BOTHS HALVES OF E AND
 31693					;PLACES THE RESULT IN E.  IN THIS CASE, E IS PRELOADED WITH
 31694					;-1,,0; THEN, MOVSS IS EXECUTED.  THE RESULT IN E SHOULD BE 0,,-1.
 31695					;IF C(E)=0,,-1, THIS TEST PASSES
 31696
 31697	047762	205 01 0 00 777777 	C17300:	MOVSI	1,-1		;PRELOAD E WITH -1,,0
 31698	047763	207 00 0 00 000001 		MOVSS	1		;*MOVSS SHOULD PLACE 0,,-1 INTO E
 31699	047764	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 31700						STOP^
 31701	047765	254 04 0 00 047766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31702	047766	324 00 0 00 047767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31703									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31704									;IN THE SUBTEST) TO LOOP ON ERROR^
 31705
 31706					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 63
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31707					;THIS TEST VERIFIES THAT AOS ADDS ONE TO MEMORY BUT DOES NOT SKIP
 31708					;FIRST, E IS PRELOADED WITH -1,-1; THEN, AOS IS EXECUTED.  NEXT, E IS CHECKED FOR 0.
 31709					;IF C(E) IS NOT 0 OR AOS SKIPPED, THIS TEST FAILS
 31710
 31711	047767	477 00 0 00 000001 	C17400:	SETOB	1		;PRELOAD E WITH -1,,-1
 31712	047770	350 00 0 00 000001 		AOS	1		;*AOS SHOULD ADD TO C(E) AND NOT SKIP
 31713	047771	302 01 0 00 000000 		CAIE	1,0		;PASS IF C(E)=0,,0 AND AOS DID NOT SKIP
 31714						STOP^
 31715	047772	254 04 0 00 047773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31716	047773	324 00 0 00 047774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31717									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31718									;IN THE SUBTEST) TO LOOP ON ERROR^
 31719
 31720					;**********
 31721
 31722					;THIS TEST VERIFIES THAT HRLM PLACES C(AC-RIGHT) INTO E-LEFT AND DOES
 31723					;NOT MODIFY E-RIGHT.  IN THIS CASE, AC IS PRELOADED WITH 0 AND E IS PRELOADED
 31724					;WITH -1,,-1.  THEN, HRLM IS EXECUTED.  E IS THEN CHECKED FOR 0,,-1.  IF
 31725					;C(E)=0,,-1, THIS TEST PASSES
 31726
 31727	047774	400 00 0 00 000000 	C17500:	SETZ			;PRELOAD AC WITH 0
 31728	047775	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 31729	047776	506 00 0 00 000001 		HRLM	1		;*HRLM SHOULD PLACE 0,,-1 INTO E
 31730	047777	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(E)=0,,-1
 31731						STOP^
 31732	050000	254 04 0 00 050001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31733	050001	324 00 0 00 050002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31734									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31735									;IN THE SUBTEST) TO LOOP ON ERROR^
 31736
 31737					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 64
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31738					;THIS TEST VERIFIES THAT HRRS DOES NOT MODIFY E
 31739					;E IS PRELOADED WITH 0 AND AC IS PRELOADED WITH -1,,-1.
 31740					;HRRS IS EXECUTED; THEN E IS CHECKED.  IF C(E) DOES
 31741					;NOT CHANGE, THIS TEST PASSES
 31742
 31743	050002	474 00 0 00 000000 	C17600:	SETO			;PRELOAD AC WITH -1,,-1
 31744	050003	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0,,0
 31745	050004	543 00 0 00 000001 		HRRS	1		;*HRRS SHOULD PLACE 0,,0 INTO E
 31746	050005	332 00 0 00 000001 		SKIPE	1
 31747						STOP^
 31748	050006	254 04 0 00 050007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31749	050007	324 00 0 00 050010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31750									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31751									;IN THE SUBTEST) TO LOOP ON ERROR^
 31752
 31753					;**********
 31754
 31755					;THIS TEST VERIFIES THAT HRRZM PLACES C(AC-RIGHT) INTO E-RIGHT AND PLACES
 31756					;ZEROS INTO E-LEFT.  IN THIS CASE, AC=E=AC1 AND C(AC)=C(E)=-1,,0.  HRRZM
 31757					;IS EXECUTED AND AC1 IS CHECKED FOR 0.  IF AC1=0, THIS TEST PASSES.
 31758
 31759	050010	474 00 0 00 000000 	C17700:	SETO			;PRELOAD AC0 WITH -1,,-1
 31760	050011	205 01 0 00 777777 		MOVSI	1,-1		;PRELOAD AC1 WITH -1,,0
 31761	050012	552 01 0 00 000001 		HRRZM	1,1		;*HRRZM SHOULD PLACE 0 INTO AC1
 31762	050013	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC1)=0
 31763						STOP^
 31764	050014	254 04 0 00 050015 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31765	050015	324 00 0 00 050016 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31766									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31767									;IN THE SUBTEST) TO LOOP ON ERROR^
 31768
 31769					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 65
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31770					;THIS TEST VERIFIES THAT JFCL 17,.+1 NEVER JUMPS AND DOES NOT MODIFY C(AC0).
 31771					;FIRST, AC0 IS PRELOADED; THEN, JFCL IS EXECUTED.  IF AC0 IS MODIFIED
 31772					;OR JFCL SKIPS, THIS TEST FAILS
 31773
 31774	050016	400 00 0 00 000000 	C20000:	SETZ			;CLEAR AC0
 31775	050017	255 17 0 00 050020 		JFCL	17,.+1		;*JFCL SHOULD NOT JUMP OR MODIFY C(AC0).
 31776	050020	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0 AND JFCL DID NOT JUMP
 31777						STOP^
 31778	050021	254 04 0 00 050022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31779	050022	324 00 0 00 050023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31781									;IN THE SUBTEST) TO LOOP ON ERROR^
 31782
 31783					;**********
 31784
 31785					;THIS TEST VERIFIES THAT XORM PERFORMS THE LOGICAL EXCLUSIVE OR FUNCTION
 31786					;BETWEEN C(AC) AND C(E) AND PLACES THE RESULT INTO E
 31787					;IN THIS CASE, AC AND E ARE PRELOADED WITH -1,,-1; THEN, XORM IS
 31788					;EXECUTED.  IF THE RESULT IN E IS 0, THE TEST PASSES
 31789
 31790	050023	477 00 0 00 000001 	C20100:	SETOB	1		;PRELOAD AC,E WITH -1,,-1
 31791	050024	432 00 0 00 000001 		XORM	1		;*XORM SHOULD PLACE 0 INTO E
 31792	050025	302 01 0 00 000000 		CAIE	1,0		;PASS IF C(E)=0
 31793						STOP^
 31794	050026	254 04 0 00 050027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31795	050027	324 00 0 00 050030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31796									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31797									;IN THE SUBTEST) TO LOOP ON ERROR^
 31798
 31799					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 66
DFKAA4	MAC	13-Jan-89 10:22		TEST OF MEMORY, BOTH AND SELF MODE INSTRUCTIONS

 31800					;THIS TEST VERIFIES THAT SETZB PLACES ZEROS INTO BOTH AC AND E.
 31801					;AFTER SETZB IS EXECUTED, BOTH AC AND E ARE CHECKED
 31802					;FOR 0.  IF EITHER AC OR E CONTAINS ANY ONES, THIS TEST FAILS
 31803
 31804	050030	403 00 0 00 000001 	C20200:	SETZB	1		;*SETZB SHOULD PLACE ZEROES IN BOTH AC AND E
 31805	050031	316 00 0 00 070253 		CAMN	[0]		;FAIL IF C(AC) IS NON-ZERO
 31806	050032	312 00 0 00 000001 		CAME	1		;FAIL IF C(E) IS NON-ZERO
 31807						STOP^
 31808	050033	254 04 0 00 050034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31809	050034	324 00 0 00 050035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31810									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31811									;IN THE SUBTEST) TO LOOP ON ERROR^
 31812
 31813					;**********
 31814
 31815					;THIS TEST VERIFIES THAT SETAB PLACES C(AC) INTO BOTH AC AND E.
 31816					;FIRST, AC IS PRELOADED WITH -1,,-1 AND E IS PRELOADED WITH 0;
 31817					;THEN, SETAB IS EXECUTED.  BOTH AC AND E ARE CHECKED FOR -1,,-1
 31818					;IF EITHER AC OR E CONTAIN ANY ZEROS, THIS TEST FAILS.
 31819
 31820	050035	400 01 0 00 000000 	C20300:	SETZ	1,		;PRELOAD E WITH 0
 31821	050036	474 00 0 00 000000 		SETO			;PRELOAD AC WITH -1,,-1
 31822	050037	427 00 0 00 000001 		SETAB	1		;*SETAB SHOULD PLACE -1,,-1 INTO BOTH AC AND E
 31823	050040	316 00 0 00 070254 		CAMN	[-1]		;FAIL IF C(AC) IS NOT -1,-1
 31824	050041	312 00 0 00 000001 		CAME	1		;FAIL IF C(E) IS NOT -1,,-1
 31825						STOP^
 31826	050042	254 04 0 00 050043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31827	050043	324 00 0 00 050044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31828									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31829									;IN THE SUBTEST) TO LOOP ON ERROR^
 31830
 31831					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 67
DFKAA4	MAC	13-Jan-89 10:22		XCT INSTRUCTION - BASIC TESTS

 31832					SUBTTL	XCT INSTRUCTION - BASIC TESTS
 31833
 31834					;**********
 31835
 31836					;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
 31837					;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION
 31838					;AFTER EXECUTING MOVEI, CONTROL SHOULD RETURN TO
 31839					;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT.
 31840					;THIS TEST PASSES IF CONTROL RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING XCT
 31841
 31842	050044	403 00 0 00 000001 	C20400:	SETZB	1		;CLEAR AC0 AND AC1
 31843	050045	256 00 0 00 070616 		XCT	[MOVEI 1,.+2]	;*XCT SHOULD RETURN CONTROL TO NEXT INSTRUCTION
 31844	050046	334 00 0 00 000000 		SKIPA
 31845						STOP^
 31846	050047	254 04 0 00 050050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31847	050050	324 00 0 00 050051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31848									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31849									;IN THE SUBTEST) TO LOOP ON ERROR^
 31850
 31851					;**********
 31852
 31853					;THIS TEST VERIFIES THAT XCT WILL EXECUTE THE INSTRUCTION SPECIFIED BY C(E)
 31854					;IN THIS CASE, C(E) SPECIFIES A MOVEI INSTRUCTION.
 31855					;AFTER EXECUTING MOVEI, THE AC SPECIFIED BY MOVEI IS CHECKED FOR
 31856					;0,,1 (THE EXPECTED RESULT).  IF C(AC)=0,,1, THIS TEST PASSES
 31857
 31858	050051	403 00 0 00 000001 	C20500:	SETZB	1		;CLEAR AC
 31859	050052	256 00 0 00 070617 		XCT	[MOVEI 1,1]	;*XCT OF MOVEI SHOULD PLACE 1 IN THE AC
 31860	050053	302 01 0 00 000001 		CAIE	1,1		;PASS IF C(AC)=1
 31861						STOP^
 31862	050054	254 04 0 00 050055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31863	050055	324 00 0 00 050056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31864									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31865									;IN THE SUBTEST) TO LOOP ON ERROR^
 31866
 31867					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 68
DFKAA4	MAC	13-Jan-89 10:22		XCT INSTRUCTION - BASIC TESTS

 31868					;THIS TEST VERIFIES THAT A NEST OF XCT INSTRUCTIONS WILL EXECUTE
 31869					;THE INSTRUCTION SPECIFIED BY THE MOST NESTED XCT AND RETURN CONTROL TO
 31870					;THE NEXT SEQUENTIAL INSTRUCTION FOLLOWING THE FIRST XCT.
 31871					;IN THIS CASE, THE EXECUTED INSTRUCTION IS MOVEI.  AFTER EXECUTING THE MOVEI,
 31872					;C(AC) IS CHECKED FOR 0,,-1 (THE EXPECTED RESULT).  IF C(AC)=0,,-1, THIS TEST PASSES
 31873
 31874	050056	403 00 0 00 000001 	C20600:	SETZB	1		;CLEAR AC
 31875	050057	256 00 0 00 070624 		XCT	[XCT[XCT[XCT[XCT[MOVEI 1,-1]]]]] ;*NESTED XCT OF MOVEI
 31876									;SHOULD PLACE 0,,-1 INTO AC
 31877	050060	302 01 0 00 777777 		CAIE	1,-1		;PASS IF C(AC)=0,,-1
 31878						STOP^
 31879	050061	254 04 0 00 050062 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31880	050062	324 00 0 00 050063 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31882									;IN THE SUBTEST) TO LOOP ON ERROR^
 31883
 31884					;**********
 31885
 31886					;THIS TEST VERIFIES THAT XCT WILL NOT MODIFY AN AC WHICH IS NOT SPECIFIED BY THE
 31887					;EXECUTED INSTRUCTION.  IN THIS CASE, AC0 IS CLEARED AND THEN CHECKED FOR ZERO AFTER
 31888					;THE XCT INSTRUCTION IS EXECUTED.  AC0 SHOULD NOT BE MODIFIED.
 31889
 31890	050063	403 00 0 00 000001 	C20700:	SETZB	1		;CLEAR AC0,AC1
 31891	050064	256 00 0 00 070625 		XCT	[MOVE 1,[-1]]	;*XCT SHOULD NOT MODIFY AC0
 31892	050065	332 00 0 00 000000 		SKIPE			;PASS IF AC0 WAS NOT MODIFIED
 31893						STOP^
 31894	050066	254 04 0 00 050067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31895	050067	324 00 0 00 050070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31897									;IN THE SUBTEST) TO LOOP ON ERROR^
 31898
 31899					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 69
DFKAA4	MAC	13-Jan-89 10:22		XCT INSTRUCTION - BASIC TESTS

 31900					;THIS TEST VERIFIES THAT XCT OF SKIPA SHOULD RETURN CONTROL TO THE
 31901					;SECOND SEQUENTIAL INSTRUCTION FOLLOWING XCT
 31902
 31903	050070	256 00 0 00 070626 	C21000:	XCT	[SKIPA]		;XCT OF SKIPA SHOULD RETURN CONTROL TO .+2
 31904						STOP^
 31905	050071	254 04 0 00 050072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31906	050072	324 00 0 00 050073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31907									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31908									;IN THE SUBTEST) TO LOOP ON ERROR^
 31909
 31910					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 70
DFKAA4	MAC	13-Jan-89 10:22		INDIRECT ADDRESSING - BASIC TESTS

 31911					SUBTTL	INDIRECT ADDRESSING - BASIC TESTS
 31912
 31913					;**********
 31914
 31915					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31916					;ARE WITHIN THE AC RANGE.
 31917					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31918					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 0,
 31919					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31920
 31921	050073	476 00 0 00 000001 	C21100:	SETOM	1		;PRELOAD AC WITH -1,,-1
 31922	050074	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31923	050075	402 00 0 00 000003 		SETZM	3		;PRELOAD INDIRECT ADDRESS WITH 0
 31924	050076	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESSS SHOULD
 31925									;PLACE 0 INTO THE AC
 31926	050077	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC)=0
 31927						STOP^
 31928	050100	254 04 0 00 050101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31929	050101	324 00 0 00 050102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31930									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31931									;IN THE SUBTEST) TO LOOP ON ERROR^
 31932
 31933					;**********
 31934
 31935					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31936					;ARE WITHIN THE AC RANGE.
 31937					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31938					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR -1,,-1,
 31939					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31940
 31941	050102	402 00 0 00 000001 	C21200:	SETZM	1		;PRELOAD AC WITH -1,,-1
 31942	050103	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31943	050104	476 00 0 00 000003 		SETOM	3		;PRELOAD INDIRECT ADDRESS WITH -1,,-1
 31944	050105	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
 31945									;PLACE -1,,-1 INTO THE AC
 31946	050106	312 01 0 00 070254 		CAME	1,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 31947						STOP^
 31948	050107	254 04 0 00 050110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31949	050110	324 00 0 00 050111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31951									;IN THE SUBTEST) TO LOOP ON ERROR^
 31952
 31953					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 71
DFKAA4	MAC	13-Jan-89 10:22		INDIRECT ADDRESSING - BASIC TESTS

 31954					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31955					;ARE WITHIN THE AC RANGE.
 31956					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31957					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
 31958					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31959
 31960	050111	402 00 0 00 000001 	C21300:	SETZM	1		;PRELOAD AC WITH 0
 31961	050112	201 07 0 00 000003 		MOVEI	7,3		;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31962	050113	200 03 0 00 070332 		MOVE	3,[707070,,707070] ;PRELOAD INDIRECT ADDRESS WITH 707070,,707070
 31963	050114	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
 31964									;PLACE 707070,,707070 INTO THE AC
 31965	050115	312 01 0 00 070332 		CAME	1,[707070,,707070]	;PASS IF C(AC)=707070,,707070
 31966						STOP^
 31967	050116	254 04 0 00 050117 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31968	050117	324 00 0 00 050120 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31969									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31970									;IN THE SUBTEST) TO LOOP ON ERROR^
 31971
 31972					;**********
 31973
 31974					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
 31975					;AND @E IS BEYOND THE AC RANGE.
 31976					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31977					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 707070,,707070,
 31978					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31979
 31980	050120	254 00 0 00 050122 	C21400:	JRST	.+2
 31981	050121	707070	707070			XWD	707070,707070	;INDIRECT ADDRESS AND ITS DATA
 31982	050122	402 00 0 00 000001 		SETZM	1		;PRELOAD AC WITH 0
 31983	050123	201 07 0 00 050121 		MOVEI	7,C21400+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 31984	050124	200 01 1 00 000007 		MOVE	1,@7		;*FWT FROM INDIRECT ADDRESS SHOULD
 31985									;PLACE 707070,,707070 INTO AC
 31986	050125	312 01 0 00 050121 		CAME	1,C21400+1	;PASS IF C(AC)=707070,,707070
 31987						STOP^
 31988	050126	254 04 0 00 050127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 31989	050127	324 00 0 00 050130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 31990									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 31991									;IN THE SUBTEST) TO LOOP ON ERROR^
 31992
 31993					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 72
DFKAA4	MAC	13-Jan-89 10:22		INDIRECT ADDRESSING - BASIC TESTS

 31994					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 31995					;ARE BEYOND THE AC RANGE.
 31996					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A MOVE.
 31997					;AFTER MOVE IS EXECUTED, C(AC) IS CHECKED FOR 202020,,202020,
 31998					;THE INITIAL CONTENTS OF THE INDIRECT ADDRESS
 31999
 32000	050130	254 00 0 00 050133 	C21500:	JRST	.+3
 32001	050131	000000	050132				.+1		;DIRECT ADDRESS AND ITS DATA
 32002	050132	202020	202020			XWD	202020,202020	;INDIRECT ADDRESS AND ITS DATA
 32003	050133	402 00 0 00 000001 		SETZM	1		;PRELOAD AC WITH 0
 32004	050134	200 01 1 00 050131 		MOVE	1,@C21500+1	;*FWT FROM INDIRECT ADDRESS SHOULD
 32005									;PLACE 202020,,202020 INTO AC
 32006	050135	312 01 0 00 050132 		CAME	1,C21500+2	;PASS IF C(AC)=202020,,202020
 32007						STOP^
 32008	050136	254 04 0 00 050137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32009	050137	324 00 0 00 050140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32010									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32011									;IN THE SUBTEST) TO LOOP ON ERROR^
 32012
 32013					;**********
 32014
 32015					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN BOTH E AND @E
 32016					;ARE BEYOND THE AC RANGE.
 32017					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.
 32018
 32019	050140	254 00 0 00 050143 	C21600:	JRST	.+3
 32020	050141	000000	050142				.+1		;DIRECT ADDRESS AND ITS DATA
 32021	050142	272727	272727			XWD	272727,272727	;INDIRECT ADDRESS AND ITS DATA
 32022	050143	200 01 0 00 050142 		MOVE	1,C21600+2	;PRELOAD AC
 32023	050144	312 01 1 00 050141 		CAME	1,@C21600+1	;*CAME OF DATA FROM INDIRECT ADDRESS - NON-AC RANGE
 32024						STOP^
 32025	050145	254 04 0 00 050146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32026	050146	324 00 0 00 050147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32027									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32028									;IN THE SUBTEST) TO LOOP ON ERROR^
 32029
 32030					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 73
DFKAA4	MAC	13-Jan-89 10:22		INDIRECT ADDRESSING - BASIC TESTS

 32031					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING WORKS WHEN E IS WITHIN THE AC RANGE
 32032					;AND @E IS BEYOND THE AC RANGE.
 32033					;THE INSTRUCTION SPECIFYING INDIRECT ADDRESSING IS A CAME.
 32034
 32035	050147	254 00 0 00 050151 	C21700:	JRST	.+2
 32036	050150	252525	252525			XWD	252525,252525	;INDIRECT ADDRESS AND ITS DATA
 32037	050151	201 07 0 00 050150 		MOVEI	7,C21700+1	;SETUP DIRECT ADDRESS WITH INDIRECT ADDRESS
 32038	050152	200 01 0 00 050150 		MOVE	1,C21700+1	;SETUP AC
 32039	050153	312 01 1 00 000007 		CAME	1,@7		;*CAME IF DATA FROM INDIRECT ADDRESS - AC RANGE
 32040						STOP^
 32041	050154	254 04 0 00 050155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32042	050155	324 00 0 00 050156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32043									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32044									;IN THE SUBTEST) TO LOOP ON ERROR^
 32045
 32046					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 74
DFKAA4	MAC	13-Jan-89 10:22		TEST INDIRECT ADDRESSING WITH INDEXING

 32047					SUBTTL	TEST INDIRECT ADDRESSING WITH INDEXING
 32048
 32049					;SETUP INDEX REGISTERS
 32050
 32051	050156	201 01 0 00 777774 		MOVEI	1,-4
 32052	050157	201 03 0 00 000002 		MOVEI	3,2
 32053	050160	201 04 0 00 000010 		MOVEI	4,10
 32054	050161	201 05 0 00 000001 		MOVEI	5,1
 32055	050162	201 06 0 00 000005 		MOVEI	6,5
 32056	050163	201 07 0 00 000007 		MOVEI	7,7
 32057	050164	201 10 0 00 000004 		MOVEI	10,4
 32058	050165	201 11 0 00 777772 		MOVEI	11,-6
 32059	050166	201 12 0 00 000005 		MOVEI	12,5
 32060	050167	201 13 0 00 000002 		MOVEI	13,2
 32061
 32062	050170	254 00 0 00 050221 		JRST	C22000		;RESUME TEST
 32063
 32064					;INDIRECT ADDRESSING/INDEXING TEST TABLE
 32065
 32066					;;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;
 32067
 32068					;DO NOT MODIFY THIS TABLE OR TESTS C21700 THRU C22600 INDEPENDENTLY !
 32069
 32070					;;;;;;;;;;          ;;;;;;;;;;          ;;;;;;;;;;
 32071
 32072	050171	000003	050174		E217:		E217A(3)
 32073	050172	000020	050177		E220:		@E220A
 32074	050173	220220	220220		E220B:	220220,,220220
 32075	050174	000020	050201		E217A:		@E221A		;E221-4
 32076	050175	221221	221221		E221B:	221221,,221221
 32077	050176	217217	217217		E222A:	217217,,217217		;E217A+2
 32078	050177	000000	050173		E220A:		E220B
 32079	050200	000000	050200		E221:		E221
 32080	050201	000000	050175		E221A:		E221B
 32081	050202	000000	050200		E222:		E221
 32082	050203	223223	223223		E223A:	223223,,223223
 32083	050204	000004	050204		E224A:		E224A(4)	;E223-6
 32084	050205	222222	222222			222222,,222222		;E222A+7
 32085	050206	000000	050206		E225:		E225
 32086	050207	000007	050176				E222A(7)	;E222+5
 32087	050210	000020	050213				@E225A		;E225+2
 32088	050211	225225	225225		E225B:	225225,,225225
 32089	050212	000000	050212		E223:		E223
 32090	050213	000000	050211		E225A:		E225B
 32091	050214	224224	224224			224224,,224224		;E224A+10
 32092	050215	226226	226226		E226B:	226226,,226226
 32093	050216	000000	050203				E223A		;E223+4
 32094	050217	000025	050217		E226A:		@E226A(5)	;E223+5
 32095	050220	000000	050215				E226B		;E226A+1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 75
DFKAA4	MAC	13-Jan-89 10:22		TEST INDIRECT ADDRESSING WITH INDEXING

 32096					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32097					Y.
 32098					;IN THIS CASE, MOVE 2,@E217 IS TESTED WHERE C(E217)=E217A(3) AND C(3)=0,,2.
 32099					;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A+2)=217217,,217217
 32100
 32101	050221	476 00 0 00 000002 	C22000:	SETOM	2		;INITIALIZE AC
 32102	050222	200 02 1 00 050171 		MOVE	2,@E217		;TEST INDIRECT ADDRESSING WITH INDEXING
 32103	050223	312 02 0 00 050176 		CAME	2,E217A+2	;PASS IF C(AC)=217217,,217217
 32104						STOP^
 32105	050224	254 04 0 00 050225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32106	050225	324 00 0 00 050226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32107									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32108									;IN THE SUBTEST) TO LOOP ON ERROR^
 32109
 32110					;**********
 32111
 32112					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32113					Y.
 32114					;IN THIS CASE, MOVE 2,@E220 IS TESTED WHERE C(E220)=@E220A AND C(E220A)=E220B.
 32115					;HENCE, THE RESULT IN THE AC SHOULD BE C(E220B)=220220,,220220
 32116
 32117	050226	402 00 0 00 000002 	C22100:	SETZM	2		;INITIALIZE AC
 32118	050227	200 02 1 00 050172 		MOVE	2,@E220		;TEST INDIRECT ADDRESSING WITH INDEXING
 32119	050230	312 02 0 00 050173 		CAME	2,E220B		;PASS IF C(AC)=220220,,220220
 32120						STOP^
 32121	050231	254 04 0 00 050232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32122	050232	324 00 0 00 050233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32123									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32124									;IN THE SUBTEST) TO LOOP ON ERROR^
 32125
 32126					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76
DFKAA4	MAC	13-Jan-89 10:22		TEST INDIRECT ADDRESSING WITH INDEXING

 32127					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32128					Y.
 32129					;IN THIS CASE,E221(1) 2,@E217 IS TESTED WHERE C(1)=-4 AND E221-4=E217A
 32130					;HENCE, THE RESULT IN THE AC SHOULD BE C(E217A)=@E221A=20,,E221A
 32131
 32132	050233	476 00 0 00 000002 	C22200:	SETOM	2		;INITIALIZE AC
 32133	050234	200 02 0 01 050200 		MOVE	2,E221(1)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32134	050235	312 02 0 00 050174 		CAME	2,E217A		;PASS IF C(AC)=@E221A=20,,E221A
 32135						STOP^
 32136	050236	254 04 0 00 050237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32137	050237	324 00 0 00 050240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32138									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32139									;IN THE SUBTEST) TO LOOP ON ERROR^
 32140
 32141					;**********
 32142
 32143					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32144					Y.
 32145					;IN THIS CASE, MOVE 2,E222(6) IS TESTED WHERE C(6)=5
 32146					;HENCE, THE RESULT IN THE AC SHOULD BE C(E222+5)=E222A(7)=7,,E222A
 32147
 32148	050240	402 00 0 00 000002 	C22300:	SETZM	2		;INITIALIZE AC
 32149	050241	200 02 0 06 050202 		MOVE	2,E222(6)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32150	050242	312 02 0 00 050207 		CAME	2,E222+5	;PASS IF C(AC)=E222A(7)=7,,E222A
 32151						STOP^
 32152	050243	254 04 0 00 050244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32153	050244	324 00 0 00 050245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32155									;IN THE SUBTEST) TO LOOP ON ERROR^
 32156
 32157					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 77
DFKAA4	MAC	13-Jan-89 10:22		TEST INDIRECT ADDRESSING WITH INDEXING

 32158					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32159					Y.
 32160					;IN THIS CASE, MOVE 2,@E223(10) IS TESTED WHERE C(10)=4 AND C(E223+4)=E223A
 32161					;HENCE, THE RESULT IN THE AC SHOULD BE C(E223A)=223223,,223223
 32162
 32163	050245	476 00 0 00 000002 	C22400:	SETOM	2		;INITIALIZE AC
 32164	050246	200 02 1 10 050212 		MOVE	2,@E223(10)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32165	050247	312 02 0 00 050203 		CAME	2,E223A		;PASS IF C(AC)=223223,,223223
 32166						STOP^
 32167	050250	254 04 0 00 050251 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32168	050251	324 00 0 00 050252 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32169									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32170									;IN THE SUBTEST) TO LOOP ON ERROR^
 32171
 32172					;**********
 32173
 32174					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32175					Y.
 32176					;IN THIS CASE, MOVE 2,@E223(11) IS TESTED WHERE C(11)=-6, C(E223-6)=E224A(4) AND C(4)=10
 32177					;HENCE, THE RESULT IN THE AC SHOULD BE C(E224A+10)=224224,,224224
 32178
 32179	050252	402 00 0 00 000002 	C22500:	SETZM	2		;INITIALIZE AC
 32180	050253	200 02 1 11 050212 		MOVE	2,@E223(11)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32181	050254	312 02 0 00 050214 		CAME	2,E224A+10	;PASS IF C(AC)=224224,,224224
 32182						STOP^
 32183	050255	254 04 0 00 050256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32184	050256	324 00 0 00 050257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32185									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32186									;IN THE SUBTEST) TO LOOP ON ERROR^
 32187
 32188					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78
DFKAA4	MAC	13-Jan-89 10:22		TEST INDIRECT ADDRESSING WITH INDEXING

 32189					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32190					Y.
 32191					;IN THIS CASE, MOVE 2,@E225(13) IS TESTED WHERE C(13)=2, C(E225+2)=@E225A
 32192					;AND C(E225A)=E225B
 32193					;HENCE, THE RESULT IN THE AC SHOULD BE C(E225B)=225225,,225225
 32194
 32195	050257	476 00 0 00 000002 	C22600:	SETOM	2		;INITIALIZE AC
 32196	050260	200 02 1 13 050206 		MOVE	2,@E225(13)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32197	050261	312 02 0 00 050211 		CAME	2,E225B		;PASS IF C(AC)=225225,,225225
 32198						STOP^
 32199	050262	254 04 0 00 050263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32200	050263	324 00 0 00 050264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32201									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32202									;IN THE SUBTEST) TO LOOP ON ERROR^
 32203
 32204					;**********
 32205
 32206					;THIS TEST VERIFIES THAT INDIRECT ADDRESSING IN COMBINATION WITH INDEXING FUNCTIONS CORRECTL
 32207					Y.
 32208					;IN THIS CASE, MOVE 2,@E223(12) IS TESTED WHERE C(12)=5, C(E223+5)=@E226A(5),
 32209					;C(5)=1 AND C(E226A+1)=E226B
 32210					;HENCE, THE RESULT IN THE AC SHOULD BE C(E226B)=226226,,226226
 32211
 32212	050264	402 00 0 00 000002 	C22700:	SETZM	2		;INITIALIZE AC
 32213	050265	200 02 1 12 050212 		MOVE	2,@E223(12)	;TEST INDIRECT ADDRESSING WITH INDEXING
 32214	050266	312 02 0 00 050215 		CAME	2,E226B		;PASS IF C(AC)=226226,,226226
 32215						STOP^
 32216	050267	254 04 0 00 050270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32217	050270	324 00 0 00 050271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32218									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32219									;IN THE SUBTEST) TO LOOP ON ERROR^
 32220
 32221					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSR INSTRUCTION

 32222					SUBTTL	TEST OF JSR INSTRUCTION
 32223
 32224					;**********
 32225
 32226					;THIS TEST VERIFIES THAT JSR STORES THE FLAGS AND PC IN LOCATION E.
 32227					;IN THIS CASE, E IS CLEARED, CRY0 IS SET AND JSR IS EXECUTED.
 32228					;NEXT, E IS CHECKED FOR ITS CONTENTS NON-ZERO.  IF C(E) IS NON-ZERO,
 32229					;THIS TEST PASSES.
 32230
 32231	050271				C23000:	SFLAG	CRY0		^;SET CRY0 FLAG
 32232
 32233	050271	205 01 0 00 200000 		MOVSI	1,CRY0
 32234	050272	255 17 0 00 050273 		JFCL	17,.+1	;RESET ALL FLAGS
 32235	050273	254 02 0 01 050274 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32236	050274	402 00 0 00 050276 		SETZM	.+2		;PRELOAD E WITH 0
 32237	050275	264 00 0 00 050276 		JSR	.+1		;*JSR SHOULD PLACE FLAGS AND PC INTO AC
 32238	050276	000000	000000			0			;E: PRESET TO 0, SHOULD RECEIVE FLAGS AND PC FROM JSR
 32239	050277	336 00 0 00 050276 		SKIPN	.-1		;PASS IF C(E) IS NON-ZERO.
 32240						STOP^
 32241	050300	254 04 0 00 050301 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32242	050301	324 00 0 00 050302 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32243									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32244									;IN THE SUBTEST) TO LOOP ON ERROR^
 32245
 32246					;**********
 32247
 32248					;THIS TEST VERIFIES THAT JSR IGNORES THE AC FIELD;
 32249					;HENCE, IT DOES NOT MODIFY THE SPECIFIED AC.
 32250					;IN THIS CASE, CRY0 IS SET.  THE AC IS PRELOADED WITH -1,,-1 AND JSR IS EXECUTED.
 32251					;THE AC IS THEN CHECKED.  IF C(AC)=-1,,-1, THIS TEST PASSES.
 32252
 32253	050302				C23100:	SFLAG	CRY0		^;SET CRY0
 32254
 32255	050302	205 01 0 00 200000 		MOVSI	1,CRY0
 32256	050303	255 17 0 00 050304 		JFCL	17,.+1	;RESET ALL FLAGS
 32257	050304	254 02 0 01 050305 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32258	050305	474 01 0 00 000000 		SETO	1,		;PRELOAD AC WITH -1,,-1
 32259	050306	264 01 0 00 050307 		JSR	1,.+1		;*JSR SHOULD NOT MODIFY THE AC
 32260	050307	000000	000000			0			;STORE PC + FLAGS HERE
 32261	050310	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 32262						STOP^
 32263	050311	254 04 0 00 050312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32264	050312	324 00 0 00 050313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32265									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32266									;IN THE SUBTEST) TO LOOP ON ERROR^
 32267
 32268					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSR INSTRUCTION

 32269					;THIS TEST VERIFIES THAT JSR STORES THE FLAGS IN E-LEFT HALF.
 32270					;IN THIS TEST, CRY0 IS SET, E IS CLEARED AND JSR IS EXECUTED.
 32271					;NEXT, C(E-LEFT) ARE PLACED INTO AC0 AND AC0 IS CHECKED FOR ITS CONTENTS NON-ZERO.
 32272					;IF C(AC0) ARE NON-ZERO, THIS TEST PASSES.
 32273
 32274	050313				C23200:	SFLAG	CRY0		^;SET CRY0
 32275
 32276	050313	205 01 0 00 200000 		MOVSI	1,CRY0
 32277	050314	255 17 0 00 050315 		JFCL	17,.+1	;RESET ALL FLAGS
 32278	050315	254 02 0 01 050316 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32279	050316	402 00 0 00 050320 		SETZM	.+2		;CLEAR E
 32280	050317	264 00 0 00 050320 		JSR	.+1		;*JSR SHOULD STORE FLAGS IN E
 32281	050320	000000	000000			0			;STORE FLAGS HERE (CRY0 MAKES THIS A MOVE INST)
 32282	050321	510 00 0 00 050320 		HLLZ	.-1		;PUT FLAGS INTO AC0
 32283	050322	336 00 0 00 000000 		SKIPN			;PASS IF C(AC0) NON-ZERO
 32284						STOP^
 32285	050323	254 04 0 00 050324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32286	050324	324 00 0 00 050325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32287									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32288									;IN THE SUBTEST) TO LOOP ON ERROR^
 32289
 32290					;**********
 32291
 32292					;THIS TEST VERIFIES THAT JSR TRANSFERS CONTROL TO E+1.
 32293					;IN THIS CASE, CRY0 IS SET AND E  AND AC0 CLEARED; THEN, JSR IS EXECUTED.
 32294					;IF JSR RESUMES CONTROL AT E INSTEAD OF E+1, AC0 WILL BE MODIFIED;
 32295					;HENCE, THE TEST WILL FAIL WHEN AC0 IS CHECKED FOR 0 BECAUSE
 32296					;C(E) IS DECODED AS A MOVE INSTRUCTION.
 32297
 32298	050325				C23300:	SFLAG	CRY0		^;SET CRY0
 32299
 32300	050325	205 01 0 00 200000 		MOVSI	1,CRY0
 32301	050326	255 17 0 00 050327 		JFCL	17,.+1	;RESET ALL FLAGS
 32302	050327	254 02 0 01 050330 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32303	050330	403 00 0 00 050332 		SETZB	.+2		;CLEAR AC0 AND E
 32304	050331	264 00 0 00 050332 		JSR	.+1		;*JSR SHOULD RESUME CONTROL AT E+1
 32305	050332	000000	000000			0			;STORE FLAGS HERE (CRY0 MAKES THIS A MOVE INST)
 32306	050333	332 00 0 00 000000 		SKIPE	0		;PASS IF C(AC0)=0
 32307						STOP^
 32308	050334	254 04 0 00 050335 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32309	050335	324 00 0 00 050336 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32310									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32311									;IN THE SUBTEST) TO LOOP ON ERROR^
 32312
 32313					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSR INSTRUCTION

 32314					;THIS TEST VERIFIES THAT JSR JUMPS TO E+1
 32315					;IN THIS CASE, AC0 IS CLEARED AND CRY0 IS SET; THEN, JSR .+2 IS EXECUTED.
 32316					;IF JSR DID NOT JUMP, ONES ARE LOADED WITH AC0; AND THE TEST FAILS.
 32317					;OTHERWISE, AC0 REMAINS CLEAR AND THE TEST PASSES
 32318
 32319	050336				C23400:	SFLAG	CRY0		^;SET CRY0
 32320
 32321	050336	205 01 0 00 200000 		MOVSI	1,CRY0
 32322	050337	255 17 0 00 050340 		JFCL	17,.+1	;RESET ALL FLAGS
 32323	050340	254 02 0 01 050341 		JRST	2,.+1(1)		;SET CRY0 FLAG
 32324	050341	400 00 0 00 000000 		SETZ			;CLEAR AC0
 32325	050342	264 00 0 00 050344 		JSR	.+2		;*JSR SHOULD JUMP
 32326	050343	474 00 0 00 000000 		SETO			;LOAD AC0 WITH ONES IF JSR FAILED TO JUMP
 32327	050344	000000	000000			0			;STORE FLAGS HERE
 32328	050345	332 00 0 00 000000 		SKIPE			;PASS  IF JSR JUMPED CORRECTLY
 32329						STOP^
 32330	050346	254 04 0 00 050347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32331	050347	324 00 0 00 050350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32332									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32333									;IN THE SUBTEST) TO LOOP ON ERROR^
 32334
 32335					;**********
 32336
 32337					;THIS TEST VERIFIES THAT JSR STORES THE PC IN E - RIGHT HALF.  THE PC
 32338					;IS ONE GREATER THAN THE LOCATION OF THE JSR INSTRUCTION.
 32339					;THIS TEST WILL FAIL IF JSR STORES E INSTEAD OF PC IN E - RIGHT HALF.
 32340					;IN CASE OF FAILURE, AR PC EN AT ET2 WAS FAULTY.
 32341
 32342	050350				C23500:	SFLAG	0		^;CLEAR ALL FLAGS
 32343
 32344	050350	205 01 0 00 000000 		MOVSI	1,0
 32345	050351	255 17 0 00 050352 		JFCL	17,.+1	;RESET ALL FLAGS
 32346	050352	254 02 0 01 050353 		JRST	2,.+1(1)		;SET 0 FLAG
 32347	050353	264 00 0 00 050355 		JSR	.+2		;*JSR SHOULD STORE PC+1 IN E - RIGHT
 32348	050354	254 04 0 00 050354 		HALT	.		;JSR SHOULD SKIP OVER THIS HALT
 32349	050355	000000	000000			0			;STORE FLAGS AND PC HERE
 32350	050356	550 00 0 00 050355 		HRRZ	.-1		;PUT STORED CONTENTS OF E - RIGHT INTO AC0
 32351	050357	306 00 0 00 050355 		CAIN	.-2		;FAIL IF C(AC0)=E
 32352						STOP^
 32353	050360	254 04 0 00 050361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32354	050361	324 00 0 00 050362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32355									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32356									;IN THE SUBTEST) TO LOOP ON ERROR^
 32357
 32358					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSR INSTRUCTION

 32359					;THIS TEST VERIFIES THAT JSR STORES THE PC IN E - RIGHT HALF.  THE PC
 32360					;IS ONE GREATER THAN THE LOCATION OF THE JSR INSTRUCTION.
 32361					;THIS TEST WILL PASS IF JSR STORES PC IN E - RIGHT HALF.
 32362
 32363	050362	264 00 0 00 050364 	C23600:	JSR	.+2		;*JSR SHOULD STORE PC+1 IN E - RIGHT
 32364	050363	254 04 0 00 050363 		HALT	.		;JSR SHOULD SKIP OVER THIS HALT
 32365	050364	000000	000000			0			;STORE FLAGS AND PC HERE
 32366	050365	550 00 0 00 050364 		HRRZ	.-1		;PUT STORED CONTENTS OF E - RIGHT INTO AC0
 32367	050366	302 00 0 00 050363 		CAIE	C23600+1	;PASS IF C(AC0)=C23600+1 [PC]
 32368						STOP^
 32369	050367	254 04 0 00 050370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32370	050370	324 00 0 00 050371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32371									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32372									;IN THE SUBTEST) TO LOOP ON ERROR^
 32373
 32374					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSA INSTRUCTION

 32375					SUBTTL	TEST OF JSA INSTRUCTION
 32376
 32377					;**********
 32378
 32379					;THIS TEST VERIFIES THAT JSA JUMPS TO LOCATION E+1.
 32380					;IN THIS TEST, AC1 IS CLEARED AND A CAM 0,0 IS LOADED
 32381					;INTO THE AC OF THE JSA INSTRUCTION.
 32382					;IF JSA DOES NOT JUMP, AC1 WILL BE LOADED WITH ONES.  AC1 IS CHECKED FOR ZEROS.
 32383					;IF C(AC1)=0, THE TEST PASSES; OTHERWISE, THIS TEST FAILS BECAUSE JSA DID NOT JUMP.
 32384
 32385	050371	400 01 0 00 000000 	C23700:	SETZ	1,		;CLEAR AC1
 32386	050372	200 00 0 00 070627 		MOVE	[CAM]		;LOAD CAM INTO AC0
 32387	050373	266 00 0 00 050375 		JSA	.+2		;*JSA SHOULD JUMP TO E+1
 32388	050374	474 00 0 00 000001 		SETO	1		;JSA SHOULD JUMP OVER THIS INSTRUCTION
 32389	050375	000000	000000			0			;PASS IF JSA JUMPED
 32390	050376	332 00 0 00 000001 		SKIPE	1
 32391						STOP^
 32392	050377	254 04 0 00 050400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32393	050400	324 00 0 00 050401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32394									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32395									;IN THE SUBTEST) TO LOOP ON ERROR^
 32396
 32397					;**********
 32398
 32399					;THIS TEST VERIFIES THAT JSA JUMPS TO LOCATION E+1.
 32400					;IN THIS TEST, AC1 IS CLEARED AND A MOVEI 1,1234 IS LOADED
 32401					;INTO THE AC OF THE JSA INSTRUCTION.
 32402					;IF JSA DOES NOT JUMP, AC1 WILL BE LOADED WITH 0,,1234.  AC1 IS CHECKED FOR ZEROS.
 32403					;IF C(AC1)=0, THE TEST PASSES; OTHERWISE, THIS TEST FAILS BECAUSE JSA DID NOT JUMP.
 32404
 32405	050401	400 01 0 00 000000 	C24000:	SETZ	1,		;CLEAR AC1
 32406	050402	200 00 0 00 070630 		MOVE	[MOVEI 1,1234]	;LOAD MOVEI 1,1234 INTO AC
 32407	050403	266 00 0 00 050404 		JSA	.+1		;*JSA SHOULD JUMP TO E+1
 32408	050404	000000	000000			0			;JSA SHOULD JUMP OVER THIS LOCATION
 32409	050405	306 01 0 00 001234 		CAIN	1,1234		;FAIL IF JSA DID NOT JUMP OVER PREVIOUS INSTRUCTION
 32410						STOP^
 32411	050406	254 04 0 00 050407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32412	050407	324 00 0 00 050410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32413									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32414									;IN THE SUBTEST) TO LOOP ON ERROR^
 32415
 32416					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSA INSTRUCTION

 32417					;THIS TEST VERIFIES THAT JSA LOADS PC OF LOC OF JSA+1 INTO AC RIGHT. 
 32418					;THIS TEST WILL FAIL IF JSA LOADS E INTO AC RIGHT INSTEAD OF PC.
 32419
 32420	050410	266 00 0 00 050412 	C24100:	JSA	.+2		;*JSA SHOULD LOAD PC INTO AC RIGHT
 32421	050411	254 04 0 00 050411 		HALT	.		;JSA SHOULD JUMP OVER THIS LOCATION
 32422	050412	000000	000000			0			;JSA SHOULD JUMP OVER THIS LOCATION
 32423	050413	552 00 0 00 000001 		HRRZM	1		;PUT C(AC-RIGHT) INTO AC1
 32424	050414	306 01 0 00 050412 		CAIN	1,.-2		;FAIL IF E WAS LOADED INTO AC-RIGHT INSTEAD OF PC
 32425						STOP^
 32426	050415	254 04 0 00 050416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32427	050416	324 00 0 00 050417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32429									;IN THE SUBTEST) TO LOOP ON ERROR^
 32430
 32431					;**********
 32432
 32433					;THIS TEST VERIFIES THAT JSA PLACES C(AC) INTO E
 32434					;THIS TEST WILL FAIL IF EITHER 0,,E OR 0,,PC IS LOADED
 32435					;INTO E INSTEAD OF C(AC)
 32436
 32437	050417	403 00 0 00 050421 	C24200:	SETZB	.+2		;CLEAR AC,E
 32438	050420	266 00 0 00 050421 		JSA	.+1		;*JSA SHOULD LOAD C(AC) [ZEROS] INTO E
 32439	050421	000000	000000			0			;JSA SHOULD PLACE ZEROS HERE
 32440	050422	200 01 0 00 050421 		MOVE	1,.-1		;SAVE C(AC)
 32441	050423	306 01 0 00 050421 		CAIN	1,.-2		;FAIL IF JSA LOADED 0,,E OR 0,,PC INTO E
 32442						STOP^
 32443	050424	254 04 0 00 050425 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32444	050425	324 00 0 00 050426 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32446									;IN THE SUBTEST) TO LOOP ON ERROR^
 32447
 32448					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSA INSTRUCTION

 32449					;THIS TEST VERIFIES THAT JSA PLACES PC INTO AC-RIGHT
 32450					;THIS TEST WILL FAIL IF PC IS NOT LOADED INTO AC-RIGHT
 32451
 32452	050426	201 00 0 00 777777 	C24300:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 32453	050427	266 00 0 00 050430 		JSA	.+1		;*JSA SHOULD PLACE E,,PC INTO THE AC
 32454	050430	000000	000000			0			;JSA SHOULD PLACE C(AC) HERE
 32455	050431	606 00 0 00 777777 		TRNN	-1		;FAIL IF AR LT AR RT EN FAILED
 32456						STOP^
 32457	050432	254 04 0 00 050433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32458	050433	324 00 0 00 050434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32459									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32460									;IN THE SUBTEST) TO LOOP ON ERROR^
 32461
 32462					;**********
 32463
 32464					;THIS TEST VERIFIES THAT JSA PLACES THE PC OF THE LOCATION OF JSA+1 IN AC-RIGHT
 32465					;THIS TEST FAILS IF A PC WAS NOT LOADED INTO AC RIGHT
 32466
 32467	050434	400 00 0 00 000000 	C24400:	SETZ			;CLEAR AC
 32468	050435	266 00 0 00 050436 		JSA	.+1		;*JSA SHOULD LOAD PC INTO AC - RIGHT
 32469	050436	000000	000000			0			;JSA SHOULD PLACE C(AC) HERE
 32470	050437	606 00 0 00 777777 		TRNN	-1		;PASS IF AC - RIGHT IS NON-ZERO
 32471						STOP^
 32472	050440	254 04 0 00 050441 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32473	050441	324 00 0 00 050442 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32474									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32475									;IN THE SUBTEST) TO LOOP ON ERROR^
 32476
 32477					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSA INSTRUCTION

 32478					;THIS TEST VERIFIES THAT JSA PLACES IN AC-LEFT
 32479					;THIS TEST FAILS IF JSA LOADS PC INSTEAD OF E INTO AC-LEFT
 32480
 32481	050442	266 00 0 00 050444 	C24500:	JSA	.+2		;*JSA SHOULD LOAD E INTO AC-LEFT
 32482	050443	254 04 0 00 050443 		HALT	.		;JSA SHOULD JUMP OVER THIS INSTRUCTION
 32483	050444	000000	000000			0			;E:
 32484	050445	556 00 0 00 000001 		HLRZM	1		;SAVE C(AC - LEFT)
 32485	050446	306 01 0 00 050443 		CAIN	1,.-3		;FAIL IF JSA LOADED PC INSTEAD OF E INTO AC-LEFT
 32486						STOP^
 32487	050447	254 04 0 00 050450 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32488	050450	324 00 0 00 050451 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32489									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32490									;IN THE SUBTEST) TO LOOP ON ERROR^
 32491
 32492					;**********
 32493
 32494					;THIS TEST VERIFIES THAT JSA LOADS E,,PC INTO THE AC
 32495					;FIRST, THE AC IS PRELOADED WITH -1,,-1; THEN, JSA IS EXECUTED.
 32496					;THE AC IS CHECKED FOR E,,PC.  IF C(AC)=E,,PC, THIS TEST PASSES
 32497
 32498	050451	474 00 0 00 000000 	C24600:	SETO			;PRELOAD AC WITH -1,,-1
 32499	050452	266 00 0 00 050454 		JSA	.+2		;*JSA SHOULD PLACE E,,PC INTO THE AC
 32500	050453	254 04 0 00 050453 		HALT	.		;JSA SHOULD JUMP OVER HERE, PC:
 32501	050454	000000	000000			0			;JSA SHOULD STORE C(AC) HERE, E:
 32502	050455	312 00 0 00 070631 		CAME	[XWD .-1,.-2]	;PASS IF C(AC)=E,,PC
 32503						STOP^
 32504	050456	254 04 0 00 050457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32505	050457	324 00 0 00 050460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32506									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32507									;IN THE SUBTEST) TO LOOP ON ERROR^
 32508
 32509					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSA INSTRUCTION

 32510					;THIS TEST VERIFIES THAT JSA LOADS E,,PC INTO THE AC
 32511					;FIRST, THE AC IS PRELOADED WITH 0 JSA IS EXECUTED.
 32512					;THE AC IS CHECKED FOR E,,PC.  IF C(AC)=E,,PC, THIS TEST PASSES
 32513
 32514	050460	400 00 0 00 000000 	C24700:	SETZ			;PRELOAD AC WITH 0
 32515	050461	266 00 0 00 050463 		JSA	.+2		;*JSA SHOULD PLACE E,,PC INTO THE AC
 32516	050462	254 04 0 00 050462 		HALT	.		;JSA SHOULD JUMP OVER HERE, PC:
 32517	050463	000000	000000			0			;JSA SHOULD STORE C(AC) HERE, E:
 32518	050464	312 00 0 00 070632 		CAME	[XWD .-1,.-2]	;PASS IF C(AC)=E,,PC
 32519						STOP^
 32520	050465	254 04 0 00 050466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32521	050466	324 00 0 00 050467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32523									;IN THE SUBTEST) TO LOOP ON ERROR^
 32524
 32525					;**********
 32526
 32527					;THIS TEST VERIFIES THAT JSA LOADS C(AC) INTO E.
 32528					;AC IS FIRST CLEARED AND E IS PRELOADED WITH ONES;
 32529					;THEN JSA IS EXECUTED.  E IS CHECKED FOR ZEROS.  IF C(E)=0,
 32530					;THIS TEST PASSES.
 32531
 32532	050467	400 00 0 00 000000 	C25000:	SETZ			;CLEAR AC
 32533	050470	476 00 0 00 050472 		SETOM	.+2		;PRELOAD E WITH -1,,-1
 32534	050471	266 00 0 00 050472 		JSA	.+1		;*JSA SHOULD PLACE C(AC) INTO E
 32535	050472	000000	000000			0			;E: SHOULD GET C(AC) FROM JSA
 32536	050473	332 00 0 00 050472 		SKIPE	.-1		;PASS IF C(E)=0
 32537						STOP^
 32538	050474	254 04 0 00 050475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32539	050475	324 00 0 00 050476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32541									;IN THE SUBTEST) TO LOOP ON ERROR^
 32542
 32543					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSA INSTRUCTION

 32544					;THIS TEST VERIFIES THAT JSA LOADS C(AC) INTO E.
 32545					;AC IS FIRST PRELOADED WITH -1,,-1 AND E IS CLEARED;
 32546					;THEN, JSA IS EXECUTED.  E IS CHECKED FOR -1,,-1.  IF C(E)=-1,,-1,
 32547					;THIS TEST PASSES.
 32548
 32549	050476	477 00 0 00 000001 	C25100:	SETOB	1		;PRELOAD AC -1,,-1
 32550	050477	402 00 0 00 050501 		SETZM	.+2		;PRELOAD E WITH 0
 32551	050500	266 00 0 00 050501 		JSA	.+1		;*JSA SHOULD PLACE C(AC) INTO E
 32552	050501	000000	000000			0			;E: SHOULD GET C(AC) FROM JSA
 32553	050502	312 01 0 00 050501 		CAME	1,.-1		;PASS IF C(E)=-1,,-1
 32554						STOP^
 32555	050503	254 04 0 00 050504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32556	050504	324 00 0 00 050505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32557									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32558									;IN THE SUBTEST) TO LOOP ON ERROR^
 32559
 32560					;**********
 32561
 32562					;THIS TEST VERIFIES THAT JSA LOADS C(AC) INTO E.
 32563					;AC IS FIRST CLEARED AND E IS PRELOADED WITH ONES;
 32564					;THEN JSA IS EXECUTED.  E IS CHECKED FOR ZEROS.  IF C(E)=0,
 32565					;THIS TEST PASSES.
 32566
 32567	050505	201 00 0 00 777777 	C25200:	MOVEI	-1		;PRELOAD AC WITH 0,,-1
 32568	050506	266 00 0 00 050507 		JSA	.+1		;*JSA SHOULD PLACE C(AC) INTO E
 32569	050507	000000	000000			0			;E: SHOULD GET C(AC) FROM JSA
 32570	050510	200 01 0 00 050507 		MOVE	1,.-1		;PASS IF C(E)=0,,-1
 32571	050511	302 01 0 00 777777 		CAIE	1,-1
 32572						STOP^
 32573	050512	254 04 0 00 050513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32574	050513	324 00 0 00 050514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32575									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32576									;IN THE SUBTEST) TO LOOP ON ERROR^
 32577
 32578					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JSA INSTRUCTION

 32579					;THIS TEST VERIFIES THAT JSA DOES NOT MODIFY AC+1
 32580					;IN THIS TEST, AC+1 IS PRELOADED WITH -1,,-1; THEN JSA IS EXECUTED
 32581					;AC+1 IS THEN CHECKED FOR ITS ORIGINAL CONTENTS, -1,,-1.
 32582					;IF C(AC+1)=-1,,-1, THIS TEST PASSES
 32583
 32584	050514	476 00 0 00 000001 	C25300:	SETOM	1		;PRELOAD AC+1 WITH -1,,-1
 32585	050515	266 00 0 00 050516 		JSA	.+1		;*JSA SHOULD NOT MODIFY AC+1
 32586	050516	310 00 0 00 000000 		CAM			;JSA SHOULD JUMP OVER THIS, E:PC:
 32587	050517	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF AC+1 WAS NOT MODIFIED BY JSA
 32588						STOP^
 32589	050520	254 04 0 00 050521 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32590	050521	324 00 0 00 050522 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32591									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32592									;IN THE SUBTEST) TO LOOP ON ERROR^
 32593
 32594					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JRA INSTRUCTION

 32595					SUBTTL	TEST OF JRA INSTRUCTION
 32596
 32597					;**********
 32598
 32599					;THIS TEST VERIFIES THAT JRA TRANSFERS CONTROL TO LOCATION E
 32600					;THIS TEST FAILS IF JRA DOES NOT JUMP TO E.
 32601
 32602	050522	200 00 0 00 070633 	C25400:	MOVE	[JRST .+4]	;PRELOAD AC0 WITH JRST .+4
 32603	050523	205 01 0 00 050525 		MOVSI	1,.+2		;PRELOAD AC WITH E,,0
 32604	050524	267 01 0 00 050525 		JRA	1,.+1		;*JRA SHOULD JUMP TO NEXT INSTRUCTION
 32605	050525	334 00 0 00 000000 		SKIPA			;PASS IF JRA JUMPS TO E
 32606						STOP^
 32607	050526	254 04 0 00 050527 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32608	050527	324 00 0 00 050530 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32609									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32610									;IN THE SUBTEST) TO LOOP ON ERROR^
 32611
 32612					;**********
 32613
 32614					;THIS TEST VERIFIES THAT JRA TRANSFERS CONTROL TO LOCATION E
 32615					;THIS TEST FAILS IF JRA DOES NOT JUMP TO E.
 32616
 32617	050530	205 00 0 00 050533 	C25500:	MOVSI	.+3		;PRELOAD AC WITH E+1
 32618	050531	267 00 0 00 050532 		JRA	.+1		;*JRA SHOULD JUMP TO NEXT SEQUENTIAL INSTRUCTION
 32619	050532	334 00 0 00 000000 		SKIPA			;PASS IF JRA JUMPS TO E
 32620						STOP^
 32621	050533	254 04 0 00 050534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32622	050534	324 00 0 00 050535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32623									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32624									;IN THE SUBTEST) TO LOOP ON ERROR^
 32625
 32626					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JRA INSTRUCTION

 32627					;THIS TEST VERIFIES THAT JRA TRANSFERS CONTROL TO LOCATION E
 32628					;THIS TEST FAILS IF JRA DOES NOT JUMP TO E.
 32629
 32630	050535	403 00 0 00 000001 	C25600:	SETZB	1		;PRELOAD AC0, AC1 WITH ZEROS
 32631	050536	267 00 0 00 050540 		JRA	.+2		;*JRA SHOULD JUMP OVER NEXT SEQUENTIAL INSTRUCTION
 32632	050537	474 01 0 00 000000 		SETO	1,		;LOAD AC1 WITH ONES IF JRA DOES NOT JUMP
 32633	050540	332 00 0 00 000001 		SKIPE	1		;PASS IF JRA JUMPED
 32634						STOP^
 32635	050541	254 04 0 00 050542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32636	050542	324 00 0 00 050543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32638									;IN THE SUBTEST) TO LOOP ON ERROR^
 32639
 32640					;**********
 32641
 32642					;THIS TEST VERIFIES THAT JRA PLACES C(C(AC-LEFT)) INTO THE AC AND JUMPS TO E
 32643					;THIS TEST FAILS IF JRA JUMPS TO E+1 OR DOES NOT LOAD THE AC CORRECTLY.
 32644
 32645	050543	400 00 0 00 000000 	C25700:	SETZ			;CLEAR AC
 32646	050544	267 00 0 00 050545 		JRA	.+1		;*JRA SHOULD PLACE 0 INTO THE AC AND JUMP .+1
 32647	050545	332 00 0 00 000000 		SKIPE			;PASS IF AC WAS LOADED CORRECTLY
 32648									;AND JRA JUMPED CORRECTLY.
 32649						STOP^
 32650	050546	254 04 0 00 050547 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32651	050547	324 00 0 00 050550 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32652									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32653									;IN THE SUBTEST) TO LOOP ON ERROR^
 32654
 32655					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JRA INSTRUCTION

 32656					;THIS TEST VERIFIES THAT JRA PLACES C(C(AC-LEFT)) INTO THE AC
 32657					;FIRST, THE AC IS PRELOADED WITH 1,,2 AND AC1 AND AC2 ARE
 32658					;INITIALIZED WITH THEIR RESPECTIVE ADDRESSES; JRA IS EXECUTED, AND
 32659					;THE AC IS CHECKED FOR 0,,1, THE ORIGINAL C(C(AC-LEFT)). IF C(AC)=0,,1,
 32660					;THIS TEST PASSES
 32661
 32662	050550	200 00 0 00 070634 	C26200:	MOVE	[XWD 1,2]	;PRELOAD AC WITH 1,,2
 32663	050551	201 01 0 00 000001 		MOVEI	1,1		;INITIALIZE AC1 WITH 0,,1
 32664	050552	201 02 0 00 000002 		MOVEI	2,2		;INITIALIZE AC2 WITH 0,,2
 32665	050553	267 00 0 00 050554 		JRA	.+1		;*JRA SHOULD PLACE 0,,1 INTO THE AC
 32666	050554	302 00 0 00 000001 		CAIE	1		;PASS IF C(AC)=0,,1
 32667						STOP^
 32668	050555	254 04 0 00 050556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32669	050556	324 00 0 00 050557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32670									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32671									;IN THE SUBTEST) TO LOOP ON ERROR^
 32672
 32673					;**********
 32674
 32675					;THIS TEST VERIFIES THAT JRA CAN RESTORE AC0 FROM AC0 WHEN AC0 IS THE
 32676					;SPECIFIED AC AND C(AC0-LEFT)=0.
 32677					;FIRST, AC0 IS PRELOADED AND JRA IS EXECUTED.  THEN, AC0 IS CHECKED FOR
 32678					;ITS INITIAL CONTENTS.  IF THE RESULT IN AC0, IS CORRECT, THIS TEST PASSES.
 32679
 32680	050557	551 00 0 00 070635 	C26300:	HRRZI	[135531,,246642]	;PRELOAD AC0 WITH 0,, LITERAL ADDRESS
 32681	050560	267 00 0 00 050561 		JRA	.+1		;*JRA SHOULD PLACE C(AC0) INTO AC0
 32682	050561	302 00 0 00 070635 		CAIE	[135531,,246642] ;PASS IF JRA PLACED C(AC0) INTO AC0
 32683						STOP^
 32684	050562	254 04 0 00 050563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32685	050563	324 00 0 00 050564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32687									;IN THE SUBTEST) TO LOOP ON ERROR^
 32688
 32689					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA5	MAC	13-Jan-89 10:22		TEST OF JRA INSTRUCTION

 32690					;THIS TEST VERIFIES THAT JRA CAN RESOTRE AC0 FROM MEMORY WHEN AC0 IS THE
 32691					;SPECIFIED AC.
 32692					;FIRST, AC0 IS PRELOADED WITH [LITERAL ADDRESS ,,0] AND JRA IS EXECUTED.  THEN,
 32693					;AC0 IS CHECKED FOR THE SPECIFIED LITERAL, 135246,,246135.  IF 
 32694					;C(AC0)=135246,,246135, THE TEST PASSES.
 32695
 32696	050564	515 00 0 00 070636 	C26400:	HRLZI	[135246,,246135] ;PRELOAD AC0 WITH [LITERAL ADDRESS ,,0]
 32697	050565	267 00 0 00 050566 		JRA	.+1		;*JRA SHOULD PLACE 135246,,246135 INTO AC0
 32698	050566	312 00 0 00 070636 		CAME	[135246,,246135];PASS IF C(AC0)=135246,,246135
 32699						STOP^
 32700	050567	254 04 0 00 050570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32701	050570	324 00 0 00 050571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32702									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32703									;IN THE SUBTEST) TO LOOP ON ERROR^
 32704
 32705					;**********
 32706
 32707					;THIS TEST VERIFIES THAT JRA CAN RESOTRE AC0 FROM MEMORY WHEN AC0 IS THE
 32708					;SPECIFIED AC.
 32709					;FIRST, AC0 IS PRELOADED WITH [-1,, ADDRESS OF JCA INSTRUCTION] AND JRA IS EXECUTED.
 32710					;THEN, AC0 IS CHECKED FOR THE JRA INSTRUCTION.  IF 
 32711					;C(AC0)= THE JRA INSTRUCTION, THE TEST PASSES.
 32712
 32713	050571	525 00 0 00 050572 	C26500:	HRLOI	.+1		;PRELOAD AC WITH -1,, ADDRESS OF JRA INSTRUCTION
 32714	050572	267 00 0 00 050573 		JRA	.+1		;*JRA SHOULD PLACE ITSELF INTO AC0
 32715	050573	312 00 0 00 050572 		CAME	.-1		;PASS IF AC CONTAINS JRA INSTRUCTION
 32716						STOP^
 32717	050574	254 04 0 00 050575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32718	050575	324 00 0 00 050576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32720									;IN THE SUBTEST) TO LOOP ON ERROR^
 32721
 32722					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA5	MAC	13-Jan-89 10:22		TESTS OF BIS FLAG

 32723					SUBTTL	TESTS OF BIS FLAG
 32724
 32725					;**********
 32726
 32727					;THIS TEST VERIFIES THAT JRST 2, CAN CLEAR BIS
 32728					;FIRST, BIS IS SET VIA JRST 2, ;THEN, BIS IS CLEARED VIA JRST 2,.
 32729					;THE FLAGS ARE SAVED AND BIS IS CHECKED.  THIS TEST PASSES IF BIS IS RESET;
 32730					;OTHERWISE JRST 2, FAILED TO RESET BIS.
 32731
 32732	050576				C26600:	SFLAG	BIS		^;SET BIS FLAG
 32733
 32734	050576	205 01 0 00 020000 		MOVSI	1,BIS
 32735	050577	255 17 0 00 050600 		JFCL	17,.+1	;RESET ALL FLAGS
 32736	050600	254 02 0 01 050601 		JRST	2,.+1(1)		;SET BIS FLAG
 32737						SFLAG			^;*RESET BIS FLAG
 32738
 32739	050601	205 01 0 00 000000 		MOVSI	1,
 32740	050602	255 17 0 00 050603 		JFCL	17,.+1	;RESET ALL FLAGS
 32741	050603	254 02 0 01 050604 		JRST	2,.+1(1)		;SET  FLAG
 32742	050604	265 00 0 00 050605 		JSP	.+1		;SAVE FLAGS
 32743	050605	603 00 0 00 020037 		TLNE	BIS+37		;PASS IF BIS FLAG IS RESET
 32744						STOP^
 32745	050606	254 04 0 00 050607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32746	050607	324 00 0 00 050610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32748									;IN THE SUBTEST) TO LOOP ON ERROR^
 32749
 32750					;**********
 32751
 32752					;THIS TEST VERIFIES THAT JRST 2, CAN SET BIS.
 32753					;FIRST, BIS IS SET VIA JRST 2, AND THE FLAGS ARE SAVED.
 32754					;BIS IS THEN CHECKED.  IF BIS IS SET, THIS TEST PASSES.
 32755
 32756	050610				C26700:	SFLAG	BIS		^;*SET BIS FLAG VIA JRST
 32757
 32758	050610	205 01 0 00 020000 		MOVSI	1,BIS
 32759	050611	255 17 0 00 050612 		JFCL	17,.+1	;RESET ALL FLAGS
 32760	050612	254 02 0 01 050613 		JRST	2,.+1(1)		;SET BIS FLAG
 32761	050613	265 00 0 00 050614 		JSP	.+1		;SAVE FLAGS
 32762	050614	607 00 0 00 020000 		TLNN	BIS		;PASS IF BIS FLAG IS SET
 32763						STOP^
 32764	050615	254 04 0 00 050616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32765	050616	324 00 0 00 050617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32766									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32767									;IN THE SUBTEST) TO LOOP ON ERROR^
 32768
 32769					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA5	MAC	13-Jan-89 10:22		TESTS OF BIS FLAG

 32770					;THIS TEST VERIFIES THAT JSR ALWAYS RESETS BIS.
 32771					;FIRST BIS IS SET; THEN JSR IS EXECUTED.  THE FLAGS ARE
 32772					;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA JSR, THIS TEST PASSES.
 32773
 32774	050617				C27000:	SFLAG	BIS		^;SET BIS
 32775
 32776	050617	205 01 0 00 020000 		MOVSI	1,BIS
 32777	050620	255 17 0 00 050621 		JFCL	17,.+1	;RESET ALL FLAGS
 32778	050621	254 02 0 01 050622 		JRST	2,.+1(1)		;SET BIS FLAG
 32779	050622	264 00 0 00 050623 		JSR	.+1		;*JSR SHOULD RESET BIS
 32780	050623	000000	000000			0			;JSR SAVES FLAGS HERE
 32781	050624	265 00 0 00 050625 		JSP	.+1		;SAVE FLAGS
 32782	050625	603 00 0 00 020000 		TLNE	BIS		;PASS IF BIS FLAG IS RESET
 32783						STOP^
 32784	050626	254 04 0 00 050627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32785	050627	324 00 0 00 050630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32786									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32787									;IN THE SUBTEST) TO LOOP ON ERROR^
 32788
 32789					;**********
 32790
 32791					;THIS TEST VERIFIES THAT JSP ALWAYS RESETS BIS.
 32792					;FIRST BIS IS SET; THEN JSP IS EXECUTED.  THE FLAGS ARE
 32793					;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA JSP, THIS TEST PASSES.
 32794
 32795	050630				C27001:	SFLAG	BIS		^;SET BIS
 32796
 32797	050630	205 01 0 00 020000 		MOVSI	1,BIS
 32798	050631	255 17 0 00 050632 		JFCL	17,.+1	;RESET ALL FLAGS
 32799	050632	254 02 0 01 050633 		JRST	2,.+1(1)		;SET BIS FLAG
 32800	050633	265 00 0 00 050634 		JSP	.+1		;*JSP SHOULD RESET BIS
 32801	050634	265 00 0 00 050635 		JSP	.+1		;SAVE FLAGS
 32802	050635	603 00 0 00 020000 		TLNE	BIS		;PASS IF BIS FLAG IS RESET
 32803						STOP^
 32804	050636	254 04 0 00 050637 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32805	050637	324 00 0 00 050640 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32806									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32807									;IN THE SUBTEST) TO LOOP ON ERROR^
 32808
 32809					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA5	MAC	13-Jan-89 10:22		TESTS OF BIS FLAG

 32810					;THIS TEST VERIFIES THAT THE BITS IN POSITIONS 8, 9 AND 10 ARE CLEARABLE.
 32811					;FIRST, THE ARITHMETIC FLAGS ARE CLEARED;
 32812					;THEN, BITS 8, 9 AND 10 OF THE PC-WORD IS EXAMINED.
 32813					;IF ANY OF THESE BITS ARE SET, THIS TEST FAILS BECAUSE THEY SHOULD BE CLEAR.
 32814
 32815	050640				C27100:	SFLAG			^;CLEAR ARITHMETIC FLAGS
 32816
 32817	050640	205 01 0 00 000000 		MOVSI	1,
 32818	050641	255 17 0 00 050642 		JFCL	17,.+1	;RESET ALL FLAGS
 32819	050642	254 02 0 01 050643 		JRST	2,.+1(1)		;SET  FLAG
 32820	050643	265 00 0 00 050644 		JSP	.+1		;SAVE FLAGS
 32821	050644	603 00 0 00 001600 		TLNE	1600		;PASS IF THESE BITS ARE CLEAR
 32822						STOP^
 32823	050645	254 04 0 00 050646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32824	050646	324 00 0 00 050647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32826									;IN THE SUBTEST) TO LOOP ON ERROR^
 32827
 32828					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 32829					SUBTTL	TEST OF MSCL FWT INSTRUCTIONS
 32830
 32831					;**********
 32832
 32833					;THIS TEST VERIFIES THAT MOVEM PLACES C(AC) INTO E AND DOES
 32834					;NOT MODIFY C(AC).
 32835					;IN THIS CASE, C(AC)=252525,,252525 ANS C(E)=707070,,707070.
 32836					;HENCE, THE RESULT IN E SHOULD BE 252525,,252525.
 32837					;THE AC IS CHECKED FOR 252525,,252525.  IF ANY OTHER NUMBER IS
 32838					;FOUND IN THE AC, IT WAS CLOBBERED BY MOVEM, AND THIS TEST FAILS.
 32839					;E IS CHECKED FOR 252525,,252525.  IF ANY OTHER NUMBER IS FOUND
 32840					;IN E, IT WAS UPDATED INCORRECTLY BY MOVEM.
 32841
 32842	050647	200 00 0 00 070614 	C50000:	MOVE	[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 32843	050650	200 01 0 00 070332 		MOVE	1,[707070,,707070]	;PRELOAD E WITH 707070,,707070
 32844	050651	202 00 0 00 000001 		MOVEM	0,1			;*MOVEM SHOULD PLACE 252525,,252525
 32845										;INTO E AND NOT AFFECT THE AC
 32846	050652	312 00 0 00 070614 		CAME	0,[252525,,252525]	;PASS IF C(AC) IS NOT CLOBBERED
 32847						STOP^
 32848	050653	254 04 0 00 050654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32849	050654	324 00 0 00 050655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32851									;IN THE SUBTEST) TO LOOP ON ERROR^
 32852	050655	312 01 0 00 070614 		CAME	1,[252525,,252525]	;PASS IF E WAS UPDATED CORRECTLY
 32853						STOP^
 32854	050656	254 04 0 00 050657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32855	050657	324 00 0 00 050660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32856									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32857									;IN THE SUBTEST) TO LOOP ON ERROR^
 32858
 32859					;**********
 32860
 32861					;THIS TEST VERIFIES THAT MOVES PLACES C(E) INTO THE AC IF AC IS NON-ZERO.
 32862					;IN THIS CASE, C(AC)=707070,,707070 AND C(E)=123456,,123456.  HENCE, BOTH
 32863					;THE AC AND E SHOULD CONTAIN 123456,,123456 AFTER MOVES IS EXECUTED.
 32864					;BOTH AC AND E ARE CHECKED FOR 123456,,123456.  IF EITHER AC OR E
 32865					;CONTAIN A DIFFERENT RESULT, THIS TEST FAILS
 32866
 32867	050660	200 02 0 00 070332 	C50100:	MOVE	2,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 32868	050661	200 01 0 00 070637 		MOVE	1,[123456,,123456]	;PRELOAD E WITH 123456,,123456
 32869	050662	203 02 0 00 000001 		MOVES	2,1			;*MOVES SHOULD PLACE 123456,,123456
 32870										;INTO BOTH AC AND E
 32871	050663	312 02 0 00 070637 		CAME	2,[123456,,123456]	;PASS IF C(AC)=123456,,123456
 32872						STOP^
 32873	050664	254 04 0 00 050665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32874	050665	324 00 0 00 050666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32875									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32876									;IN THE SUBTEST) TO LOOP ON ERROR^
 32877	050666	312 01 0 00 070637 		CAME	1,[123456,,123456]	;PASS IF C(E)=123456,,123456
 32878						STOP^
 32879	050667	254 04 0 00 050670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32880	050670	324 00 0 00 050671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32882									;IN THE SUBTEST) TO LOOP ON ERROR^
 32883
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 32884					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 32885					;THIS TEST VERIFIES THAT MOVES IS A NO-OP IF AC=0
 32886					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=707070,,707070
 32887					;AFTER MOVES IS EXECUTED, AC AND E ARE CHECKED FOR THEIR ORIGINAL DATA.
 32888					;IF EITHER C(AC) OR C(E) CHANGED AS A RESULT OF MOVES, THIS TEST FAILS.
 32889
 32890	050671	200 01 0 00 070332 	C50110:	MOVE	1,[707070,,707070]	;PRELOAD E WITH 707070,,707070
 32891	050672	474 00 0 00 000000 		SETO				;PRELOAD AC WITH -1,,-1
 32892	050673	203 00 0 00 000001 		MOVES	0,1			;*MOVES SHOULD FUNCTION AS A NO-OP
 32893	050674	312 00 0 00 070254 		CAME	0,[-1,,-1]		;PASS IF C(AC) WAS NOT MODIFIED
 32894						STOP^
 32895	050675	254 04 0 00 050676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32896	050676	324 00 0 00 050677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32897									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32898									;IN THE SUBTEST) TO LOOP ON ERROR^
 32899	050677	312 01 0 00 070332 		CAME	1,[707070,,707070]	;PASS IF C(E) WAS NOT MODIFIED
 32900						STOP^
 32901	050700	254 04 0 00 050701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32902	050701	324 00 0 00 050702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32904									;IN THE SUBTEST) TO LOOP ON ERROR^
 32905
 32906					;**********
 32907
 32908					;THIS TEST VERIFIES THAT MOVSI LOADS THE WORD E,0 INTO THE AC.
 32909					;IN THIS CASE, C(AC)=707070,,707070 AND E=0,,-1.
 32910					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,0.
 32911					;THE AC IS CHECKED FOR -1,,0.  IF C(AC)=-1,,0, THIS TEST PASSES.
 32912
 32913	050702	200 01 0 00 070332 	C50200:	MOVE	1,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 32914	050703	205 01 0 00 777777 		MOVSI	1,-1			;*MOVSI SHOULD PLACE -1,,0 INTO THE AC
 32915	050704	312 01 0 00 070331 		CAME	1,[-1,,0]		;PASS IF C(AC)=1,,0
 32916						STOP^
 32917	050705	254 04 0 00 050706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32918	050706	324 00 0 00 050707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32920									;IN THE SUBTEST) TO LOOP ON ERROR^
 32921
 32922					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 32923					;THIS TEST VERIFIES THAT MOVNM PLACES THE NEGATIVE OF C(AC)
 32924					;INTO E.  IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-3.
 32925					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1 AND THE RESULT
 32926					;IN E SHOULD BE 0,,1
 32927
 32928	050707	474 01 0 00 000000 	C50300:	SETO	1,			;PRELOAD AC WITH -1,,-1
 32929	050710	200 02 0 00 070334 		MOVE	2,[-1,,-3]		;PRELOAD E WITH -1,,-3
 32930	050711	212 01 0 00 000002 		MOVNM	1,2			;*MOVNM SHOULD PLACE 0,,1 INTO E
 32931										;AND NOT AFFTECT C(AC)
 32932	050712	312 01 0 00 070254 		CAME	1,[-1]			;PASS IF C(AC)=-1,,-1
 32933						STOP^
 32934	050713	254 04 0 00 050714 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32935	050714	324 00 0 00 050715 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32936									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32937									;IN THE SUBTEST) TO LOOP ON ERROR^
 32938	050715	302 02 0 00 000001 		CAIE	2,1			;PASS IF C(E)=0,,1
 32939						STOP^
 32940	050716	254 04 0 00 050717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32941	050717	324 00 0 00 050720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32942									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32943									;IN THE SUBTEST) TO LOOP ON ERROR^
 32944
 32945					;**********
 32946
 32947					;THIS TEST VERIFIES THAT MOVNM PLACES THE NEGATIVE OF C(AC)
 32948					;INTO E.  IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-3.
 32949					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,-1 AND THE RESULT
 32950					;IN E SHOULD BE 0,,1
 32951
 32952	050720	474 01 0 00 000000 	C50301:	SETO	1,			;PRELOAD AC WITH -1,,-1
 32953	050721	200 02 0 00 070334 		MOVE	2,[-1,,-3]		;PRELOAD E WITH -1,,-3
 32954	050722	202 02 0 00 050734 		MOVEM	2,E50301
 32955	050723	212 01 0 00 050734 		MOVNM	1,E50301		;*MOVNM SHOULD PLACE 0,,1 INTO E
 32956										;AND NOT AFFTECT C(AC)
 32957	050724	312 01 0 00 070254 		CAME	1,[-1]			;PASS IF C(AC)=-1,,-1
 32958						STOP^
 32959	050725	254 04 0 00 050726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32960	050726	324 00 0 00 050727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32961									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32962									;IN THE SUBTEST) TO LOOP ON ERROR^
 32963	050727	200 02 0 00 050734 		MOVE	2,E50301
 32964	050730	302 02 0 00 000001 		CAIE	2,1			;PASS IF C(E)=0,,1
 32965						STOP^
 32966	050731	254 04 0 00 050732 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32967	050732	324 00 0 00 050733 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32968									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32969									;IN THE SUBTEST) TO LOOP ON ERROR^
 32970
 32971	050733	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 32972	050734	000000	000000		E50301:	0				;TESTED MEMORY LOCATION
 32973
 32974					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 32975					;THIS TEST VERIFIES THAT MOVNS PLACES THE NEGATIVE OF C(E) INTO E
 32976					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=0,
 32977					;C(AC)=0 AND C(E)=0,,1
 32978					;HENCE, THE RESULT IN THE AC SHOULD BE 0
 32979					;AND THE RESULT IN E SHOULD BE -1,,-1
 32980
 32981	050735	400 00 0 00 000000 	C50400:	SETZ				;CLEAR AC
 32982	050736	201 02 0 00 000001 		MOVEI	2,1			;PRELOAD E WITH 0,,1
 32983	050737	213 00 0 00 000002 		MOVNS	0,2			;*MOVNS SHOULD PLACE -1,,-1 INTO E
 32984										;AND SHOULD NOT AFFECT THE AC
 32985	050740	332 00 0 00 000000 		SKIPE				;PASS IF THE AC IS UNALTERED
 32986						STOP^
 32987	050741	254 04 0 00 050742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32988	050742	324 00 0 00 050743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32989									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32990									;IN THE SUBTEST) TO LOOP ON ERROR^
 32991	050743	312 02 0 00 070254 		CAME	2,[-1]			;PASS IF C(E)=-1,,-1
 32992						STOP^
 32993	050744	254 04 0 00 050745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 32994	050745	324 00 0 00 050746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 32995									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 32996									;IN THE SUBTEST) TO LOOP ON ERROR^
 32997
 32998					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 32999					;THIS TEST VERIFIES THAT MOVNS PLACES THE NEGATIVE OF C(E) INTO E
 33000					;AND INTO THE AC IF THE AC IS NON-ZO.  IN THIS CASE, AC=0,
 33001					;C(AC)=0 AND C(E)=0,,1
 33002					;HENCE, THE RESULT IN THE AC SHOULD BE 0
 33003					;AND THE RESULT IN E SHOULD BE -1,,-1
 33004
 33005	050746	400 00 0 00 000000 	C50401:	SETZ				;CLEAR AC
 33006	050747	201 02 0 00 000001 		MOVEI	2,1			;PRELOAD E WITH 0,,1
 33007	050750	202 02 0 00 050762 		MOVEM	2,E50401
 33008	050751	213 00 0 00 050762 		MOVNS	0,E50401		;*MOVNS SHOULD PLACE -1,,-1 INTO E
 33009										;AND SHOULD NOT AFFECT THE AC
 33010	050752	332 00 0 00 000000 		SKIPE				;PASS IF THE AC IS UNALTERED
 33011						STOP^
 33012	050753	254 04 0 00 050754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33013	050754	324 00 0 00 050755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33014									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33015									;IN THE SUBTEST) TO LOOP ON ERROR^
 33016	050755	200 02 0 00 050762 		MOVE	2,E50401
 33017	050756	312 02 0 00 070254 		CAME	2,[-1]			;PASS IF C(E)=-1,,-1
 33018						STOP^
 33019	050757	254 04 0 00 050760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33020	050760	324 00 0 00 050761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33021									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33022									;IN THE SUBTEST) TO LOOP ON ERROR^
 33023
 33024	050761	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 33025	050762	000000	000000		E50401:	0				;TESTED MEMORY LOCATION
 33026
 33027					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 33028					;THIS TEST VERIFIES THAT MOVNS PLACES THE NEGATIVE OF C(E) INTO E
 33029					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=1,
 33030					;C(AC=0 AND C(E)=3
 33031					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,3
 33032					;AND THE RESULT IN E SHOULD BE -1,,3.
 33033
 33034	050763	400 01 0 00 000000 	C50410:	SETZ	1,			;CLEAR AC
 33035	050764	201 02 0 00 000003 		MOVEI	2,3			;PRELOAD WITH 0,,3
 33036	050765	213 01 0 00 000002 		MOVNS	1,2			;*MOVNS SHOULD PLACE -1,,-3 INTO E
 33037										;AND -1,,-3 INTO THE AC
 33038	050766	312 01 0 00 070334 		CAME	1,[-1,,-3]		;PASS IF C(AC)=-1,,-3
 33039						STOP^
 33040	050767	254 04 0 00 050770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33041	050770	324 00 0 00 050771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33042									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33043									;IN THE SUBTEST) TO LOOP ON ERROR^
 33044	050771	312 02 0 00 070334 		CAME	2,[-1,,-3]		;PASS IF C(E)=-1,,-3
 33045						STOP^
 33046	050772	254 04 0 00 050773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33047	050773	324 00 0 00 050774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33048									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33049									;IN THE SUBTEST) TO LOOP ON ERROR^
 33050
 33051					;**********
 33052
 33053					;THIS TEST VERIFIES THAT MOVMI MOVES THE WORD 0,,E INTO THE AC.
 33054					;IN THIS CASE, C(AC)=0 AND E=0,,-2.  HENCE, THE RESULT IN THE AC
 33055					;SHOULD BE 0,,-2.
 33056
 33057	050774	400 01 0 00 000000 	C50500:	SETZ	1,			;CLEAR AC
 33058	050775	215 01 0 00 777776 		MOVMI	1,-2			;*MOVMI SHOULD PLACE 0,,-2 INTO AC
 33059	050776	302 01 0 00 777776 		CAIE	1,-2			;PASS IF C(AC)=0,,-2
 33060						STOP^
 33061	050777	254 04 0 00 051000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33062	051000	324 00 0 00 051001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33063									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33064									;IN THE SUBTEST) TO LOOP ON ERROR^
 33065
 33066					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 33067					;THIS TEST VERIFIES THAT MOVM MOVES THE MAGNITUDE OF C(E) NTO THE AC.
 33068					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-2.  HENCE, THE RESULT IN THE AC
 33069					;SHOULD BE 0,,2.
 33070
 33071	051001	400 01 0 00 000000 	C50501:	SETZ	1,			;CLEAR AC
 33072	051002	200 03 0 00 070333 		MOVE	3,[-2]			;PRELOAD E WITH -1,,-2
 33073	051003	214 01 0 00 000003 		MOVM	1,3			;*MOVM SHOULD PLACE 0,,2 INTO AC
 33074	051004	302 01 0 00 000002 		CAIE	1,2			;PASS IF C(AC)=0,,2
 33075						STOP^
 33076	051005	254 04 0 00 051006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33077	051006	324 00 0 00 051007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33078									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33079									;IN THE SUBTEST) TO LOOP ON ERROR^
 33080
 33081					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 33082					;THIS TEST VERIFIES THAT MOVMM PLACES THE MAGNITUDE OF C(AC)
 33083					;INTO E.  IN THIS CASE, C(AC)=-1,,-2 AND C(E)=0.  HENCE, THE
 33084					;RESULT IN E SHOULD BE 0,,2 AND C(AC) SHOULD REMAIN UNCHANGED.
 33085
 33086	051007	200 01 0 00 070333 	C50600:	MOVE	1,[-1,,-2]		;PRELOAD AC WITH -1,,-2
 33087	051010	400 02 0 00 000000 		SETZ	2,			;CLEAR E
 33088	051011	216 01 0 00 000002 		MOVMM	1,2			;*MOVMM SHOULD PLACE 0,,2 INTO E
 33089										;AND SHOULD NOT CHANGE C(AC)
 33090	051012	312 01 0 00 070333 		CAME	1,[-1,,-2]		;PASS IF C(AC) IS NOT ALTERED
 33091						STOP^
 33092	051013	254 04 0 00 051014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33093	051014	324 00 0 00 051015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33095									;IN THE SUBTEST) TO LOOP ON ERROR^
 33096	051015	302 02 0 00 000002 		CAIE	2,2			;PASS IF C(E)=0,,2
 33097						STOP^
 33098	051016	254 04 0 00 051017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33099	051017	324 00 0 00 051020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33101									;IN THE SUBTEST) TO LOOP ON ERROR^
 33102
 33103					;**********
 33104
 33105					;THIS TEST VERIFIES THAT MONMS PLACES THE MAGNITUDE OF C(E) INTO E
 33106					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=0, C(AC)=0
 33107					;AND C(E)=-1,,-2.
 33108					;HENCE, THE RESULT IN THE AC SHOULD BE 0 AND THE RESULT IN
 33109					;E SHOULD BE 0,,2.
 33110
 33111	051020	400 00 0 00 000000 	C50700:	SETZ			;CLEAR AC
 33112	051021	200 02 0 00 070333 		MOVE	2,[-1,,-2]		;PRELOAD E WITH -1,,-1
 33113	051022	217 00 0 00 000002 		MOVMS	0,2			;*MOVMS	SHOULD PLACE 0,,1 INTO E
 33114										;AND SHOULD NOT CHANGE C(AC)
 33115	051023	332 00 0 00 000000 		SKIPE				;PASS IF C(AC) IS UNALTERED
 33116						STOP^
 33117	051024	254 04 0 00 051025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33118	051025	324 00 0 00 051026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33119									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33120									;IN THE SUBTEST) TO LOOP ON ERROR^
 33121	051026	302 02 0 00 000002 		CAIE	2,2			;PASS IF C(E)=0,,2
 33122						STOP^
 33123	051027	254 04 0 00 051030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33124	051030	324 00 0 00 051031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33125									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33126									;IN THE SUBTEST) TO LOOP ON ERROR^
 33127
 33128					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL FWT INSTRUCTIONS

 33129					;THIS TEST VERIFIES THAT MOVMS PLACES THE MAGNITUDE OF C(E) INTO E
 33130					;AND INTO THE AC IF THE AC IS NON-ZERO.  IN THIS CASE, AC=1, C(AC)=-1,,-1
 33131					;AND C(E)=-1,,-2.
 33132					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,2 AND THE RESULT
 33133					;IN E SHOULD BE 0,,2.
 33134
 33135	051031	474 01 0 00 000000 	C50710:	SETO	1,			;PRELOAD AC WITH -1,,-1
 33136	051032	200 02 0 00 070333 		MOVE	2,[-1,,-2]		;PRELOAD E WITH -1,,-2
 33137	051033	217 01 0 00 000002 		MOVMS	1,2			;*MOVMS SHOULD PLACE 0,,2 INTO E
 33138										;AND SHOULD PLACE 0,,2 INTO THE AC
 33139	051034	302 01 0 00 000002 		CAIE	1,2			;PASS IF C(AC)=0,,2
 33140						STOP^
 33141	051035	254 04 0 00 051036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33142	051036	324 00 0 00 051037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33143									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33144									;IN THE SUBTEST) TO LOOP ON ERROR^
 33145	051037	302 02 0 00 000002 		CAIE	2,2			;PASS IF C(E)=0,,2
 33146						STOP^
 33147	051040	254 04 0 00 051041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33148	051041	324 00 0 00 051042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33149									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33150									;IN THE SUBTEST) TO LOOP ON ERROR^
 33151
 33152					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL ADD/SUB INSTRUCTIONS

 33153					SUBTTL	TEST OF MSCL ADD/SUB INSTRUCTIONS
 33154
 33155					;**********
 33156
 33157					;THIS TEST VERIFIES THAT SUBI SUBTRACTS THE WORD 0,,E FROM C(AC)
 33158					;AND PLACES THE RESULT INTO THE AC.  IN THIS CASE, C(AC)=70 AND
 33159					;E=0,,2.  HENCE, THE RESULT IN THE AC SHOULD BE 66.
 33160
 33161	051042	201 01 0 00 000070 	C51000:	MOVEI	1,70			;PRELOAD AC WITH 70
 33162	051043	275 01 0 00 000002 		SUBI	1,2			;*SUBI SHOULD PLACE 66 INTO AC
 33163	051044	302 01 0 00 000066 		CAIE	1,66			;PASS IF C(AC)=66
 33164						STOP^
 33165	051045	254 04 0 00 051046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33166	051046	324 00 0 00 051047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33168									;IN THE SUBTEST) TO LOOP ON ERROR^
 33169
 33170					;**********
 33171
 33172					;THIS TEST VERIFIES THAT SUBM SUBTRACTS C(E) FROM C(AC) AND
 33173					;PLACES THE RESULT INTO E.  THE AC IS UNAFFECTED.  IN THIS CASE,
 33174					;C(AC)=100 AND C(E)=37.  HENCE, THE RESULTS IN AC AND
 33175					;E SHOULD BE 0,,100 AND 0,,41 RESPECTIVELY.
 33176
 33177	051047	201 01 0 00 000100 	C51100:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33178	051050	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH 0,,37
 33179	051051	276 01 0 00 000002 		SUBM	1,2			;*SUBM SHOULD PLACE
 33180										;0,,41 INTO E AND NOT CHANGE C(AC)
 33181	051052	302 01 0 00 000100 		CAIE	1,100			;PASS IF C(AC) IS UNCHANGED
 33182						STOP^
 33183	051053	254 04 0 00 051054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33184	051054	324 00 0 00 051055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33185									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33186									;IN THE SUBTEST) TO LOOP ON ERROR^
 33187	051055	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33188						STOP^
 33189	051056	254 04 0 00 051057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33190	051057	324 00 0 00 051060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33191									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33192									;IN THE SUBTEST) TO LOOP ON ERROR^
 33193
 33194					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL ADD/SUB INSTRUCTIONS

 33195					;THIS TEST VERIFIES THAT SUBM SUBTRACTS C(E) FROM C(AC) AND
 33196					;PLACES THE RESULT INTO E.  THE AC IS UNAFFECTED.  IN THIS CASE,
 33197					;C(AC)=100 AND C(E)=37.  HENCE, THE RESULTS IN AC AND
 33198					;E SHOULD BE 0,,100 AND 0,,41 RESPECTIVELY.
 33199
 33200	051060	201 01 0 00 000100 	C51101:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33201	051061	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH 0,,37
 33202	051062	202 02 0 00 051074 		MOVEM	2,E51101
 33203	051063	276 01 0 00 051074 		SUBM	1,E51101		;*SUBM SHOULD PLACE
 33204										;0,,41 INTO E AND NOT CHANGE C(AC)
 33205	051064	302 01 0 00 000100 		CAIE	1,100			;PASS IF C(AC) IS UNCHANGED
 33206						STOP^
 33207	051065	254 04 0 00 051066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33208	051066	324 00 0 00 051067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33209									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33210									;IN THE SUBTEST) TO LOOP ON ERROR^
 33211	051067	200 02 0 00 051074 		MOVE	2,E51101
 33212	051070	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33213						STOP^
 33214	051071	254 04 0 00 051072 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33215	051072	324 00 0 00 051073 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33216									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33217									;IN THE SUBTEST) TO LOOP ON ERROR^
 33218
 33219	051073	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 33220	051074	000000	000000		E51101:	0				;TEST WORD MEMORY
 33221
 33222					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL ADD/SUB INSTRUCTIONS

 33223					;THIS TEST VERIFIES THAT SUBB SUBTRACTS C(E) FROM C(AC) AND
 33224					;PLACES THE RESULT INTO BOTH AC AND E.  IN THIS CASE,
 33225					;C(AC)=0,,100 AND C(E)=0,,37.  HENCE, THE RESULT IN BOTH
 33226					;AC AND E SHOULD BE 0,,41.
 33227
 33228	051075	201 01 0 00 000100 	C51200:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33229	051076	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH O,,37
 33230	051077	277 01 0 00 000002 		SUBB	1,2			;*SUBB SHOULD PLACE 0,,41 INTO BOTH AC  AND E
 33231	051100	302 01 0 00 000041 		CAIE	1,41			;PASS IF C(AC)=0,,41
 33232						STOP^
 33233	051101	254 04 0 00 051102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33234	051102	324 00 0 00 051103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33235									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33236									;IN THE SUBTEST) TO LOOP ON ERROR^
 33237	051103	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33238						STOP^
 33239	051104	254 04 0 00 051105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33240	051105	324 00 0 00 051106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33241									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33242									;IN THE SUBTEST) TO LOOP ON ERROR^
 33243
 33244					;**********
 33245
 33246					;THIS TEST VERIFIES THAT SUBB SUBTRACTS C(E) FROM C(AC) AND
 33247					;PLACES THE RESULT INTO BOTH AC AND E.  IN THIS CASE,
 33248					;C(AC)=0,,100 AND C(E)=0,,37.  HENCE, THE RESULT IN BOTH
 33249					;AC AND E SHOULD BE 0,,41.
 33250
 33251	051106	201 01 0 00 000100 	C51201:	MOVEI	1,100			;PRELOAD AC WITH 0,,100
 33252	051107	201 02 0 00 000037 		MOVEI	2,37			;PRELOAD E WITH O,,37
 33253	051110	202 02 0 00 051122 		MOVEM	2,E51201
 33254	051111	277 01 0 00 051122 		SUBB	1,E51201		;*SUBB SHOULD PLACE 0,,41 INTO BOTH AC  AND E
 33255	051112	302 01 0 00 000041 		CAIE	1,41			;PASS IF C(AC)=0,,41
 33256						STOP^
 33257	051113	254 04 0 00 051114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33258	051114	324 00 0 00 051115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33259									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33260									;IN THE SUBTEST) TO LOOP ON ERROR^
 33261	051115	200 02 0 00 051122 		MOVE	2,E51201
 33262	051116	302 02 0 00 000041 		CAIE	2,41			;PASS IF C(E)=0,,41
 33263						STOP^
 33264	051117	254 04 0 00 051120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33265	051120	324 00 0 00 051121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33267									;IN THE SUBTEST) TO LOOP ON ERROR^
 33268
 33269	051121	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 33270	051122	000000	000000		E51201:	0				;TEST WORD MEMORY
 33271
 33272					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33273					SUBTTL	TEST OF MSCL CAIX INSTRUCTIONS
 33274
 33275					;**********
 33276
 33277					;THIS TEST VERIFIES THAT CAIL COMPARES C(AC) WITH E AND
 33278					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN E.
 33279					;IN THIS CASE, C(AC)=0,,1 AND E=0,,2
 33280					;HENCE, CAIL SHOULD SKIP THE NEXT INSTRUCTION.
 33281					;IF CAIL SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33282
 33283	051123	201 01 0 00 000001 	C51300:	MOVEI	1,1			;PRELOAD AC WITH 0,,1
 33284	051124	301 01 0 00 000002 		CAIL	1,2			;*CAIL SHOULD SKIP THE NEXT INSTRUCTION
 33285						STOP^
 33286	051125	254 04 0 00 051126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33287	051126	324 00 0 00 051127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33288									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33289									;IN THE SUBTEST) TO LOOP ON ERROR^
 33290
 33291					;**********
 33292
 33293					;THIS TEST VERIFIES THAT CAIL COMPARES C(AC) WITH E AND
 33294					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN E.
 33295					;IN THIS CASE, C(AC)=0,,2 AND E=0,,2.
 33296					;HENCE, CAIL SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33297					;IF CAIL DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33298
 33299	051127	201 01 0 00 000002 	C51310:	MOVEI	1,2			;PRELOAD AC WITH 0,,2
 33300	051130	301 01 0 00 000002 		CAIL	1,2			;*CAIL SHOULD NOT SKIP THE NEXT INSTRUCTION
 33301	051131	334 00 0 00 000000 		SKIPA				;PASS IF CAIL DOES NOT SKIP
 33302						STOP^
 33303	051132	254 04 0 00 051133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33304	051133	324 00 0 00 051134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33305									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33306									;IN THE SUBTEST) TO LOOP ON ERROR^
 33307
 33308					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 32
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33309					;THIS TEST VERIFIES THAT CAIL COMPARES C(AC) WITH E AND
 33310					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN E
 33311					;IN THIS CASE, C(AC)=0,,3 AND E=0,,2
 33312					;HENCE, CAIL SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33313					;IF CAIL DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33314
 33315	051134	201 01 0 00 000003 	C51320:	MOVEI	1,3			;PRELOAD AC WITH 0,,3
 33316	051135	301 01 0 00 000002 		CAIL	1,2			;*CAIL SHOULD SKIP THE NEXT INSTRUCTION
 33317	051136	334 00 0 00 000000 		SKIPA				;PASS IF CAIL DOES NOT SKIP
 33318						STOP^
 33319	051137	254 04 0 00 051140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33320	051140	324 00 0 00 051141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33321									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33322									;IN THE SUBTEST) TO LOOP ON ERROR^
 33323
 33324					;**********
 33325
 33326					;THIS TEST VERIFIES THAT CAILE COMPARES C(AC) WITH E AND
 33327					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO E
 33328					;IN THIS CASE, C(AC)=-1,,-1 AND E=0
 33329					;HENCE, CAILE SHOULD SKIP THE NEXT INSTRUCTION
 33330					;IF CAILE SKIPS THE NEXT INSTRUCTION, THE TEST PASSES
 33331
 33332	051141	474 01 0 00 000000 	C51400:	SETO	1,			;PRELOAD AC WITH -1,,-1
 33333	051142	303 01 0 00 000000 		CAILE	1,0			;*CAILE SHOULD SKIP THE NEXT INSTRUCTION
 33334						STOP^
 33335	051143	254 04 0 00 051144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33336	051144	324 00 0 00 051145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33338									;IN THE SUBTEST) TO LOOP ON ERROR^
 33339
 33340					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 33
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33341					;THIS TEST VERIFIES THAT CAILE COMPARES C(AC) WITH E AND
 33342					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO E
 33343					;IN THIS CASE, C(AC)=0	AND E=0
 33344					;HENCE, CAILE SHOULD SKIP THE NEXT INSTRUCTION.
 33345					;IF CAILE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33346
 33347	051145	400 01 0 00 000000 	C51410:	SETZ	1,			;PRELOAD AC WITH 0
 33348	051146	303 01 0 00 000000 		CAILE	1,0			;*CAILE SHOULD SKIP THE NEXT INSTRUCTION.
 33349						STOP^
 33350	051147	254 04 0 00 051150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33351	051150	324 00 0 00 051151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33352									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33353									;IN THE SUBTEST) TO LOOP ON ERROR^
 33354
 33355					;**********
 33356
 33357					;THIS TEST VERIFIES THAT CAILE COMPARES C(AC) WITH E AND
 33358					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO E 
 33359					;IN THIS CASE, C(AC)=0,,1 AND E=0
 33360					;HENCE, CAILE SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33361					;IF CAILE DOES NOT SKIP THE NEXT INSTRUCTION, THE TEST PASSES
 33362
 33363	051151	201 01 0 00 000001 	C51420:	MOVEI	1,1			;PRELOAD AC WITH 0,,1
 33364	051152	303 01 0 00 000000 		CAILE	1,0			;*CAILE SHOULD NOT SKIP THE NEXT INSTRUCTION
 33365	051153	334 00 0 00 000000 		SKIPA				;PASS IF CAILE DOES NOT SKIP
 33366						STOP^
 33367	051154	254 04 0 00 051155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33368	051155	324 00 0 00 051156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33369									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33370									;IN THE SUBTEST) TO LOOP ON ERROR^
 33371
 33372					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 34
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33373					;THIS TEST VERIFIES THAT CAIA COMPARES C(AC) WITH E AND ALWAYS
 33374					;SKIPS THE NEXT INSTRUCTION
 33375					;IN THIS CASE, C(AC)=-1,,-1 AND E=0
 33376					;HENCE, CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33377					;IF CAIA SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33378
 33379	051156	474 01 0 00 000000 	C51500:	SETO	1,			;PRELOAD AC WITH -1,,-1
 33380	051157	304 01 0 00 000000 		CAIA	1,0			;*CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33381						STOP^
 33382	051160	254 04 0 00 051161 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33383	051161	324 00 0 00 051162 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33384									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33385									;IN THE SUBTEST) TO LOOP ON ERROR^
 33386
 33387					;**********
 33388
 33389					;THIS TEST VERIFIES THAT CAIA COMPARES C(AC) WITH E AND ALWAYS
 33390					;SKIPS THE NEXT INSTRUCTION
 33391					;IN THIS CASE, C(AC)=0 AND E=0
 33392					;HENCE, CAIA SHOULD SKIP THE NEXT INSTRUCTION.
 33393					;IF CAIA SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33394
 33395	051162	400 01 0 00 000000 	C51510:	SETZ	1,			;PRELOAD AC WITH 0
 33396	051163	304 01 0 00 000000 		CAIA	1,0			;*CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33397						STOP^
 33398	051164	254 04 0 00 051165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33399	051165	324 00 0 00 051166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33401									;IN THE SUBTEST) TO LOOP ON ERROR^
 33402
 33403					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 35
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33404					;THIS TEST VERIFIES THAT CAIA COMPARES C(AC) WITH E AND ALWAYS
 33405					;SKIPS THE NEXT INSTRUCTION
 33406					;IN THIS CASE, C(AC)=0,,1 AND E=0
 33407					;HENCE, CAIA SHOULD SKIP THE NEXT INSTRUCTION.
 33408					;IF CAIA SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33409
 33410	051166	201 01 0 00 000001 	C51520:	MOVEI	1,1			;PRELOAD AC WITH 0,,1
 33411	051167	304 01 0 00 000000 		CAIA	1,0			;*CAIA SHOULD SKIP THE NEXT INSTRUCTION
 33412						STOP^
 33413	051170	254 04 0 00 051171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33414	051171	324 00 0 00 051172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33415									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33416									;IN THE SUBTEST) TO LOOP ON ERROR^
 33417
 33418					;**********
 33419
 33420					;THIS TEST VERIFIES THAT CAIGE COMPARES C(AC) WITH E AND
 33421					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN OR EQUAL TO E.
 33422					;IN THIS CASE, C(AC)=0,,5 AND E=0,,6
 33423					;HENCE, CAIGE SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33424					;IF CAIGE DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 33425
 33426	051172	201 02 0 00 000005 	C51600:	MOVEI	2,5			;PRELOAD AC WITH 0,,5
 33427	051173	305 02 0 00 000006 		CAIGE	2,6			;*CAIGE SHOULD NOT SKIP THE NEXT INSTRUCTION
 33428	051174	334 00 0 00 000000 		SKIPA				;PASS IF CAIGE DOES NOT SKIP
 33429						STOP^
 33430	051175	254 04 0 00 051176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33431	051176	324 00 0 00 051177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33433									;IN THE SUBTEST) TO LOOP ON ERROR^
 33434
 33435					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 36
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33436					;THIS TEST VERIFIES THAT CAIGE COMPARES C(AC) WITH E AND
 33437					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN OR EQUAL TO E
 33438					;IN THIS CASE, C(AC)=0,,6 AND E=0,,6
 33439					;HENCE, CAIGE SHOULD SKIP THE NEXT INSTRUCTION.
 33440					;IF CAIGE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33441
 33442	051177	201 02 0 00 000006 	C51610:	MOVEI	2,6			;PRELOAD AC WITH 0,,6
 33443	051200	305 00 0 00 000000 		CAIGE				;*CAIGE SHOULD SKIP THE NEXT INSTRUCTION
 33444						STOP^
 33445	051201	254 04 0 00 051202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33446	051202	324 00 0 00 051203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33447									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33448									;IN THE SUBTEST) TO LOOP ON ERROR^
 33449
 33450					;**********
 33451
 33452					;THIS TEST VERIFIES THAT CAIGE COMPARES C(AC) WITH E AND
 33453					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN OR EQUAL TO E.
 33454					;IN THIS CASE, C(AC)=0,,7 AND E=0,,6
 33455					;HENCE, CAIGE SHOULD SKIP THE NEXT INSTRUCTION.
 33456					;IF CAIGE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33457
 33458	051203	201 02 0 00 000007 	C51620:	MOVEI	2,7		;PRELOAD AC WITH 0,,7
 33459	051204	305 02 0 00 000006 		CAIGE	2,6		;*CAIGE SHOULD SKIP THE NEXT INSTRUCTION
 33460						STOP^
 33461	051205	254 04 0 00 051206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33462	051206	324 00 0 00 051207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33464									;IN THE SUBTEST) TO LOOP ON ERROR^
 33465
 33466					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 37
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33467					;THIS TEST VERIRIES THAT CAIN COMPARES C(AC) WITH E AND
 33468					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS NOT EQUAL TO E.
 33469					;IN THIS CASE, C(AC)=0 AND E=0,,1
 33470					;HENCE, CAIN SHOULD SKIP THE NEXT INSTRUCTION.
 33471					;IF CAIN SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33472
 33473	051207	400 06 0 00 000000 	C51700:	SETZ	6,		;PRELOAD AC WITH 0
 33474	051210	306 06 0 00 000001 		CAIN	6,1		;*CAIN SHOULD SKIP THE NEXT INSTRUCTION
 33475						STOP^
 33476	051211	254 04 0 00 051212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33477	051212	324 00 0 00 051213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33478									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33479									;IN THE SUBTEST) TO LOOP ON ERROR^
 33480
 33481					;**********
 33482
 33483					;THIS TEST VERIFIES THAT CAIN COMPARES C(AC) WITH E AND
 33484					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS NOT EQUAL TO E.
 33485					;IN THIS CASE, C(AC)=0,,1 AND E=0,,1
 33486					;HENCE, CAIN SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33487					;IF CAIN DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 33488
 33489	051213	200 06 0 00 000001 	C51710:	MOVE	6,1		;PRELOAD AC WITH 0,,1
 33490	051214	306 06 0 00 000001 		CAIN	6,1		;*CAIN SHOULD NOT SKIP THE NEXT INSTRUCTION
 33491	051215	334 00 0 00 000000 		SKIPA			;PASS IF CAIN SKIPS
 33492						STOP^
 33493	051216	254 04 0 00 051217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33494	051217	324 00 0 00 051220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33495									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33496									;IN THE SUBTEST) TO LOOP ON ERROR^
 33497
 33498					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33499					;THIS TEST VERIFIES THAT CAIN COMPARES C(AC) WITH E AND
 33500					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS NOT EQUAL TO E.
 33501					;IN THIS CASE, C(AC)=0,,2 AND E=0,,1
 33502					;HENCE, CAIN SHOULD SKIP THE NEXT INSTRUCTION.
 33503					;IF CAIN SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33504
 33505	051220	201 06 0 00 000002 	C51720:	MOVEI	6,2		;PRELOAD AC WITH
 33506	051221	306 06 0 00 000001 		CAIN	6,1		;*CAIN SHOULD SKIP THE NEXT INSTRUCTION
 33507						STOP^
 33508	051222	254 04 0 00 051223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33509	051223	324 00 0 00 051224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33511									;IN THE SUBTEST) TO LOOP ON ERROR^
 33512
 33513					;**********
 33514
 33515					;THIS TEST VERIFIES THAT CAIG COMPARES C(AC) WITH E AND
 33516					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN E.
 33517					;IN THIS CASE, C(AC)=0,,2 AND E=0,,3.
 33518					;HENCE, CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33519					;IF CAIG DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES
 33520
 33521	051224	201 11 0 00 000002 	C52000:	MOVEI	11,2		;PRELOAD AC WITH 0,,2
 33522	051225	307 11 0 00 000003 		CAIG	11,3		;*CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION
 33523	051226	334 00 0 00 000000 		SKIPA			;PASS IF CAIG DID NOT SKIP
 33524						STOP^
 33525	051227	254 04 0 00 051230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33526	051230	324 00 0 00 051231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33527									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33528									;IN THE SUBTEST) TO LOOP ON ERROR^
 33529
 33530					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAIX INSTRUCTIONS

 33531					;THIS TEST VERIFIES THAT CAIG COMPARES C(AC) WITH E AND
 33532					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN E.
 33533					;IN THIS CASE, C(AC)=0,,3 AND E=0,,3.
 33534					;HENCE, CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33535					;IF CAIG DOES NOT SKIP THE NEXT INSTRUCTION, THE TEST PASSES.
 33536
 33537	051231	201 11 0 00 000003 	C52010:	MOVEI	11,3		;PRELOAD AC WITH 0,,3
 33538	051232	307 11 0 00 000003 		CAIG	11,3		;*CAIG SHOULD NOT SKIP THE NEXT INSTRUCTION
 33539	051233	334 00 0 00 000000 		SKIPA			;PASS IF CAIG DID NOT SKIP
 33540						STOP^
 33541	051234	254 04 0 00 051235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33542	051235	324 00 0 00 051236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33543									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33544									;IN THE SUBTEST) TO LOOP ON ERROR^
 33545
 33546					;**********
 33547
 33548					;THIS TEST VERIFIES THAT CAIG COMPARES C(AC) WITH E AND
 33549					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN E.
 33550					;IN THIS CASE, C(AC)=0,,4 AND E=0,,3.
 33551					;HENCE, CAIG SHOULD SKIP THE NEXT INSTRUCTION.
 33552					;IF CAIG SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33553
 33554	051236	201 11 0 00 000004 	C52020:	MOVEI	11,4		;PRELOAD AC WITH 0,,4
 33555	051237	307 11 0 00 000003 		CAIG	11,3		;*CAIG SHOULD SKIP THE NEXT INSTRUCTION
 33556						STOP^
 33557	051240	254 04 0 00 051241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33558	051241	324 00 0 00 051242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33559									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33560									;IN THE SUBTEST) TO LOOP ON ERROR^
 33561
 33562					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAMX INSTRUCTIONS

 33563					SUBTTL	TEST OF MSCL CAMX INSTRUCTIONS
 33564
 33565					;**********
 33566
 33567					;THIS TEST VERIFIES THAT CAMLE COMPARES C(AC) WITH C(E) AND
 33568					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAT OR EQUAL TO C(E).
 33569					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=0
 33570					;HENCE, CAMLE SHOULD SKIP THE NEXT INSTRUCTION.
 33571					;IF CAMLE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33572
 33573	051242	474 01 0 00 000000 	C52100:	SETO	1,		;PRELOAD AC WITH -1,,-1
 33574	051243	400 02 0 00 000000 		SETZ	2,		;PRELOAD E WITH 0
 33575	051244	313 01 0 00 000002 		CAMLE	1,2		;*CAMLE SHOULD SKIP THE NEXT INSTRUCTION
 33576						STOP^
 33577	051245	254 04 0 00 051246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33578	051246	324 00 0 00 051247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33580									;IN THE SUBTEST) TO LOOP ON ERROR^
 33581
 33582					;**********
 33583
 33584					;THIS TEST VERIFIES THAT CAMLE COMPARES C(AC) WITH C(E) AND
 33585					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO C(E).
 33586					;IN THIS CASE, C(AC)=0 AND C(E)=0
 33587					;HENCE, CAMLE SHOULD SKIP THE NEXT INSTRUCTION.
 33588					;IF CAMLE SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES
 33589
 33590	051247	400 01 0 00 000000 	C52110:	SETZ	1,		;CLEAR AC
 33591	051250	313 01 0 00 070253 		CAMLE	1,[0]		;*CAMLE SHOULD SKIP THE NEXT INSTRUCTION
 33592						STOP^
 33593	051251	254 04 0 00 051252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33594	051252	324 00 0 00 051253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33595									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33596									;IN THE SUBTEST) TO LOOP ON ERROR^
 33597
 33598					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAMX INSTRUCTIONS

 33599					;THIS TEST VERIFIES THAT CAMLE COMPARES C(AC) WITH C(E) AND
 33600					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS LESS THAN OR EQUAL TO C(E).
 33601					;IN THIS CASE, C(AC)=0,,1 AND C(E)=0
 33602					;HENCE, CAMLE SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33603					;IF CAMLE DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33604
 33605	051253	201 01 0 00 000001 	C52120:	MOVEI	1,1		;PRELOAD AC WITH 0,,1
 33606	051254	400 02 0 00 000000 		SETZ	2,		;PRELOAD E WITH 0
 33607	051255	313 01 0 00 000002 		CAMLE	1,2		;*CAMLE SHOULD NOT SKIP THE NEXT INSTRUCTION
 33608	051256	334 00 0 00 000000 		SKIPA			;PASS IF CAMLE DOES NOT SKIP
 33609						STOP^
 33610	051257	254 04 0 00 051260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33611	051260	324 00 0 00 051261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33612									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33613									;IN THE SUBTEST) TO LOOP ON ERROR^
 33614
 33615					;**********
 33616
 33617					;THIS TEST VERIFIES THAT CAMG COMPARES C(AC) WITH C(E) AND
 33618					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN C(E).
 33619					;IN THIS CASE, C(AC)=-1,,-2 AND C(E)=-1,,-2.
 33620					;HENCE, CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33621					;IF CAMG DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33622
 33623	051261	561 10 0 00 777776 	C52200:	HRROI	10,-2		;PRELOAD AC WITH -1,,-2
 33624	051262	317 10 0 00 070254 		CAMG	10,[-1,,-1]	;*CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33625	051263	334 00 0 00 000000 		SKIPA			;PASS IF CAMG DOES NOT SKIP
 33626						STOP^
 33627	051264	254 04 0 00 051265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33628	051265	324 00 0 00 051266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33629									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33630									;IN THE SUBTEST) TO LOOP ON ERROR^
 33631
 33632					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL CAMX INSTRUCTIONS

 33633					;THIS TEST VERIFIES THAT CAMG COMPARES C(AC) WITH C(E) AND
 33634					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN C(E).
 33635					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=-1,,-1.
 33636					;HENCE, CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION.
 33637					;IF CAMG DOES NOT SKIP THE NEXT INSTRUCTION, THIS TEST PASSES.
 33638	051266	474 10 0 00 000000 	C52210:	SETO	10,		;PRELOAD AC WITH -1,,-1.
 33639	051267	317 10 0 00 070254 		CAMG	10,[-1,,-1]	;*CAMG SHOULD NOT SKIP THE NEXT INSTRUCTION
 33640	051270	334 00 0 00 000000 		SKIPA			;PASS IF CAMG DOES NOT SKIP
 33641						STOP^
 33642	051271	254 04 0 00 051272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33643	051272	324 00 0 00 051273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33644									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33645									;IN THE SUBTEST) TO LOOP ON ERROR^
 33646
 33647					;**********
 33648
 33649					;THIS TEST VERIFIES THAT CAMG COMPARES C(AC) WITH C(E) AND
 33650					;SKIPS THE NEXT INSTRUCTION IF C(AC) IS GREATER THAN C(E).
 33651					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1.
 33652					;HENCE, CAMG SHOULD SKIP THE NEXT INSTRUCTION.
 33653					;IF CAMG SKIPS THE NEXT INSTRUCTION, THIS TEST PASSES.
 33654
 33655	051273	400 10 0 00 000000 	C52220:	SETZ	10,		;PRELOAD AC WITH 0
 33656	051274	317 10 0 00 070254 		CAMG	10,[-1,,-1]	;*CAMG SHOULD SKIP THE NEXT INSTRUCTION
 33657						STOP^
 33658	051275	254 04 0 00 051276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33659	051276	324 00 0 00 051277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33661									;IN THE SUBTEST) TO LOOP ON ERROR^
 33662
 33663					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL JUMPX INSTRUCTIONS

 33664					SUBTTL	TEST OF MSCL JUMPX INSTRUCTIONS
 33665
 33666					;**********
 33667
 33668					;THIS TEST VERIFIES THAT JUMPLE COMPARES C(AC) WITH 0 AND
 33669					;JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC) IS LESS THAN OR
 33670					;EQUAL TO 0.  IN THIS CASE, C(AC)=-1,,-1.  HENCE, JUMPLE SHOULD JUMP.
 33671
 33672	051277	474 17 0 00 000000 	C52300:	SETO	17,		;PRELOAD AC WITH -1,,-1
 33673	051300	323 17 0 00 051302 		JUMPLE	17,.+2		;*JUMPLE SHOULD JUMP
 33674						STOP^
 33675	051301	254 04 0 00 051302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33676	051302	324 00 0 00 051303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33677									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33678									;IN THE SUBTEST) TO LOOP ON ERROR^
 33679
 33680					;**********
 33681
 33682					;THIS TEST VERIFIES THAT JUMPLE COMPARES C(AC) WITH 0 AND
 33683					;JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC) IS LESS THAN OR
 33684					;EQUAL TO 0.  IN THIS CASE, C(AC)=0.  HENCE, JUMPLE SHOULD JUMP.
 33685
 33686	051303	400 17 0 00 000000 	C52310:	SETZ	17,		;PRELOAD AC WITH 0
 33687	051304	323 17 0 00 051306 		JUMPLE	17,.+2		;*JUMPLE SHOULD JUMP
 33688						STOP^
 33689	051305	254 04 0 00 051306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33690	051306	324 00 0 00 051307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33691									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33692									;IN THE SUBTEST) TO LOOP ON ERROR^
 33693
 33694					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL JUMPX INSTRUCTIONS

 33695					;THIS TEST VERIFIES THAT JUMPLE COMPARES C(AC) WITH 0 AND JUMPS
 33696					;TO THE LOCATION SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO
 33697					;0.  IN THIS CASE, C(AC)=0,,1.  HENCE, JUMPLE SHOULD NOT JUMP.
 33698
 33699	051307	201 17 0 00 000001 	C52320:	MOVEI	17,1		;PRELOAD AC WITH 0,,1
 33700	051310	320 17 0 00 051312 		JUMP	17,.+2		;*JUMPLE SHOULD NOT JUMP
 33701	051311	334 00 0 00 000000 		SKIPA			;PASS IF JUMPLE DOES NOT JUMP
 33702						STOP^
 33703	051312	254 04 0 00 051313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33704	051313	324 00 0 00 051314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33706									;IN THE SUBTEST) TO LOOP ON ERROR^
 33707
 33708					;**********
 33709
 33710					;THIS TEST VERIFIES THAT JUMPGE COMPARES C(AC) WITH 0 AND JUMPS TO
 33711					;THE LOCATION SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 33712					;IN THIS CASE, C(AC)=-1,,-1.  HENCE, JUMPGE SHOULD NOT JUMP.
 33713
 33714	051314	474 16 0 00 000000 	C52400:	SETO	16,		;PRELOAD AC WITH -1,,-1
 33715	051315	325 16 0 00 051317 		JUMPGE	16,.+2		;*JUMPGE SHOULD NOT JUMP
 33716	051316	334 00 0 00 000000 		SKIPA			;PASS IF JUMPGE DOES NOT JUMP
 33717						STOP^
 33718	051317	254 04 0 00 051320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33719	051320	324 00 0 00 051321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33720									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33721									;IN THE SUBTEST) TO LOOP ON ERROR^
 33722
 33723					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL JUMPX INSTRUCTIONS

 33724					;THIS TEST VERIFIES THAT JUMPGE COMPARES C(AC) WITH O AND JUMPS TO
 33725					;THE LOCATION SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 33726					;IN THIS CASE, C(AC)=0.  HENCE, JUMPGE SHOULD JUMP.
 33727
 33728	051321	400 16 0 00 000000 	C52410:	SETZ	16,		;PRELOAD AC WITH 0
 33729	051322	325 16 0 00 051324 		JUMPGE	16,.+2		;*JUMPGE SHOULD JUMP
 33730						STOP^
 33731	051323	254 04 0 00 051324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33732	051324	324 00 0 00 051325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33733									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33734									;IN THE SUBTEST) TO LOOP ON ERROR^
 33735
 33736					;**********
 33737
 33738					;THIS TEST VERIFIES THAT JUMPGE COMPARES C(AC) WITH 0 AND JUMPS TO
 33739					;THE LOCATION SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 33740					;IN THIS CASE, C(AC)=0,,1.  HENCE, JUMPGE SHOULD JUMP.
 33741
 33742	051325	201 16 0 00 000001 	C52420:	MOVEI	16,1		;PRELOAD AC WITH 0,,1
 33743	051326	325 16 0 00 051330 		JUMPGE	16,.+2		;*JUMPGE SHOULD JUMP
 33744						STOP^
 33745	051327	254 04 0 00 051330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33746	051330	324 00 0 00 051331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33747									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33748									;IN THE SUBTEST) TO LOOP ON ERROR^
 33749
 33750					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 46
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 33751					SUBTTL	TEST OF MSCL AOJX INSTRUCTIONS
 33752
 33753					;**********
 33754
 33755					;THIS TEST VERIFIES THAT AOJL INCREMENTS C(AC) BY 0,,1 AND PLACES
 33756					;THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS COMPARED
 33757					;TO 0 AND THE PROGRAM JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC)
 33758					;IS LESS THAN 0.  IN THIS CASE, C(AC)=-1,,-2 BEFORE INCREMENTING.
 33759					;HENCE, AOJL SHOULD JUMP.
 33760
 33761	051331	561 15 0 00 777776 	C52500:	HRROI	15,-2		;PRELOAD AC WITH -1,,-2
 33762	051332	341 15 0 00 051334 		AOJL	15,.+2		;*AOJL SHOULD ADD 0,,1 TO C(AC) AND JUMP
 33763						STOP^
 33764	051333	254 04 0 00 051334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33765	051334	324 00 0 00 051335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33766									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33767									;IN THE SUBTEST) TO LOOP ON ERROR^
 33768	051335	312 15 0 00 070254 		CAME	15,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33769						STOP^
 33770	051336	254 04 0 00 051337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33771	051337	324 00 0 00 051340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33773									;IN THE SUBTEST) TO LOOP ON ERROR^
 33774
 33775					;**********
 33776
 33777					;THIS TEST VERIFIES THAT AOJL INCREMENTS C(AC) BY 0,,1 AND
 33778					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33779					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33780					;SPECIFIED BY E IF C(AC) IS LESS THAN 0.
 33781					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33782					;HENCE, AOJ SHOULD NOT JUMP
 33783
 33784	051340	474 15 0 00 000000 	C52510:	SETO	15,		;PRELOAD AC WITH
 33785	051341	341 15 0 00 051343 		AOJL	15,.+2		;*AOJL SHOULD ADD 0,,1 TO C(AC)
 33786									;AND NOT JUMP
 33787	051342	334 00 0 00 000000 		SKIPA			;PASS IF AOJL DID NOT JUMP
 33788						STOP^
 33789	051343	254 04 0 00 051344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33790	051344	324 00 0 00 051345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33791									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33792									;IN THE SUBTEST) TO LOOP ON ERROR^
 33793	051345	302 15 0 00 000000 		CAIE	15,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 33794						STOP^
 33795	051346	254 04 0 00 051347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33796	051347	324 00 0 00 051350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33798									;IN THE SUBTEST) TO LOOP ON ERROR^
 33799
 33800					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 47
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 33801					;THIS TEST VERIFIES THAT AOJL INCREMENTS C(AC) BY 0,,1 AND
 33802					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33803					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33804					;SPECIFIED BY E IF C(AC) IS 0 BEFORE INCREMENTING
 33805					;HENCE, AOJL SHOULD NOT JUMP
 33806
 33807	051350	400 15 0 00 000000 	C52520:	SETZ	15,		;PRELOAD AC WITH 0
 33808	051351	341 15 0 00 051353 		AOJL	15,.+2		;*AOJL SHOULD ADD 0,,1 TO C(AC)
 33809									;AND NOT JUMP
 33810	051352	334 00 0 00 000000 		SKIPA			;PASS IF AOJL DID NOT JUMP
 33811						STOP^
 33812	051353	254 04 0 00 051354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33813	051354	324 00 0 00 051355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33815									;IN THE SUBTEST) TO LOOP ON ERROR^
 33816	051355	302 15 0 00 000001 		CAIE	15,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 33817						STOP^
 33818	051356	254 04 0 00 051357 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33819	051357	324 00 0 00 051360 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33820									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33821									;IN THE SUBTEST) TO LOOP ON ERROR^
 33822
 33823					;**********
 33824
 33825					;THIS TEST VERIFIES THAT AOJE INCREMENTS C(AC) BY 0,,1 AND
 33826					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33827					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33828					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0
 33829					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 33830					;HENCE, AOJE SHOULD NOT JUMP
 33831
 33832	051360	561 14 0 00 777776 	C52600:	HRROI	14,-2		;PRELOAD AC WITH -1,,-2
 33833	051361	342 14 0 00 051363 		AOJE	14,.+2		;*AOJE SHOULD ADD 0,,1 TO C(AC)
 33834									;AND NOT JUMP
 33835	051362	334 00 0 00 000000 		SKIPA			;PASS IF AOJE DID NOT JUMP
 33836						STOP^
 33837	051363	254 04 0 00 051364 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33838	051364	324 00 0 00 051365 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33839									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33840									;IN THE SUBTEST) TO LOOP ON ERROR^
 33841	051365	312 14 0 00 070254 		CAME	14,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33842						STOP^
 33843	051366	254 04 0 00 051367 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33844	051367	324 00 0 00 051370 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33846									;IN THE SUBTEST) TO LOOP ON ERROR^
 33847
 33848					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 48
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 33849					;THIS TEST VERIFIES THAT AOJE INCREMENTS C(AC) BY 0,,1 AND
 33850					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33851					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33852					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 33853					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING.
 33854					;HENCE, AOJE SHOULD JUMP
 33855
 33856	051370	474 14 0 00 000000 	C52610:	SETO	14,		;PRELOAD AC WITH -1,,-1
 33857	051371	342 14 0 00 051373 		AOJE	14,.+2		;*AOJ SHOULD ADD 0,,1 TO C(AC)
 33858									;AND JUMP
 33859						STOP^
 33860	051372	254 04 0 00 051373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33861	051373	324 00 0 00 051374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33862									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33863									;IN THE SUBTEST) TO LOOP ON ERROR^
 33864	051374	302 14 0 00 000000 		CAIE	14,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 33865						STOP^
 33866	051375	254 04 0 00 051376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33867	051376	324 00 0 00 051377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33868									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33869									;IN THE SUBTEST) TO LOOP ON ERROR^
 33870
 33871					;**********
 33872
 33873					;THIS TEST VERIFIES THAT AOJE INCREMENTS C(AC) BY 0,,1 AND
 33874					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33875					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33876					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 33877					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 33878					;HENCE, AOJE SHOULD NOT JUMP
 33879
 33880	051377	400 14 0 00 000000 	C52620:	SETZ	14,		;PRELOAD AC WITH 0
 33881	051400	342 14 0 00 051402 		AOJE	14,.+2		;*AOJE SHOULD ADD 0,11 TO C(AC)
 33882									;AND NOT JUMP
 33883	051401	334 00 0 00 000000 		SKIPA			;PASS IF AOJE DID NOT JUMP
 33884						STOP^
 33885	051402	254 04 0 00 051403 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33886	051403	324 00 0 00 051404 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33887									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33888									;IN THE SUBTEST) TO LOOP ON ERROR^
 33889	051404	302 14 0 00 000001 		CAIE	14,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 33890						STOP^
 33891	051405	254 04 0 00 051406 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33892	051406	324 00 0 00 051407 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33894									;IN THE SUBTEST) TO LOOP ON ERROR^
 33895
 33896					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 49
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 33897					;THIS TEST VERIFIES THAT AOJLE INCREMENTS C(AC) BY 0,,1 AND
 33898					;PLACES THE RESULT BACK INTO TLE$EC.  THE RESULT IN THE AC IS
 33899					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33900					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0.
 33901					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33902					;HENCE, AOJLE SHOULD
 33903
 33904	051407	561 13 0 00 777776 	C52700:	HRROI	13,-2		;PRELOAD AC WITH -1,,-2
 33905	051410	343 13 0 00 051412 		AOJLE	13,.+2		;*AOJLE SHOULD ADD 0,,1 TO C(AC)
 33906									;AND JUMP
 33907						STOP^
 33908	051411	254 04 0 00 051412 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33909	051412	324 00 0 00 051413 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33911									;IN THE SUBTEST) TO LOOP ON ERROR^
 33912	051413	312 13 0 00 070254 		CAME	13,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33913						STOP^
 33914	051414	254 04 0 00 051415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33915	051415	324 00 0 00 051416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33916									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33917									;IN THE SUBTEST) TO LOOP ON ERROR^
 33918
 33919					;**********
 33920
 33921					;THIS TEST VERIFIES THAT AOJLE INCREMENTS C(AC) BY 0,,1 AND
 33922					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33923					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33924					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0
 33925					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33926					;HENCE, AOJLE SHOULD JUMP.
 33927
 33928	051416	474 13 0 00 000000 	C52710:	SETO	13,		;PRELOAD AC WITH -1,,-1
 33929	051417	343 13 0 00 051421 		AOJLE	13,.+2		;*AOJLE SHOULD ADD 0,,1 TO C(AC)
 33930									;AND JUMP
 33931						STOP^
 33932	051420	254 04 0 00 051421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33933	051421	324 00 0 00 051422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33934									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33935									;IN THE SUBTEST) TO LOOP ON ERROR^
 33936	051422	302 13 0 00 000000 		CAIE	13,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 33937						STOP^
 33938	051423	254 04 0 00 051424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33939	051424	324 00 0 00 051425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33940									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33941									;IN THE SUBTEST) TO LOOP ON ERROR^
 33942
 33943					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 50
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 33944					;THIS TEST VERIFIES THAT AOJLE INCREMENTS C(AC) BY 0,,1 AND
 33945					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33946					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 33947					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0.
 33948					;IN THIS CASE, C(AC) IS 0
 33949					;HENCE, AOJLE SHOULD NOT JUMP.
 33950
 33951	051425	400 13 0 00 000000 	C52720:	SETZ	13,		;PRELOAD AC WITH 0
 33952	051426	343 13 0 00 051430 		AOJLE	13,.+2		;*AOJLE SHOULD ADD 0,,1 TO C(AC)
 33953									;AND NOT JUMP
 33954	051427	334 00 0 00 000000 		SKIPA			;PASS IF AOJLE DID NOT JUMP
 33955						STOP^
 33956	051430	254 04 0 00 051431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33957	051431	324 00 0 00 051432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33958									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33959									;IN THE SUBTEST) TO LOOP ON ERROR^
 33960	051432	302 13 0 00 000001 		CAIE	13,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 33961						STOP^
 33962	051433	254 04 0 00 051434 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33963	051434	324 00 0 00 051435 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33964									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33965									;IN THE SUBTEST) TO LOOP ON ERROR^
 33966
 33967					;**********
 33968
 33969					;THIS TEST VERIFIES THAT AOJA INCREMENTS C(AC) BY 0,,1 AND
 33970					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 33971					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 33972					;SPECIFIED BY E.
 33973					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 33974					;HENCE, AOJA SHOULD JUMP
 33975
 33976	051435	561 12 0 00 777776 	C53000:	HRROI	12,-2		;PRELOAD AC WITH -1,,-2
 33977	051436	344 12 0 00 051440 		AOJA	12,.+2		;*AOJA SHOULD ADD 0,,1 TO C(AC)
 33978									;AND JUMP
 33979						STOP^
 33980	051437	254 04 0 00 051440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33981	051440	324 00 0 00 051441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33983									;IN THE SUBTEST) TO LOOP ON ERROR^
 33984	051441	312 12 0 00 070254 		CAME	12,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 33985						STOP^
 33986	051442	254 04 0 00 051443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 33987	051443	324 00 0 00 051444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 33988									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 33989									;IN THE SUBTEST) TO LOOP ON ERROR^
 33990
 33991					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 51
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 33992					;THIS TEST VERIFIES THAT AOJA INCREMENTS C(AC) BY 0,,1 AND
 33993					;PLACES THE RESULT BACK INTO AC.  THE RESULT IN THE AC IS
 33994					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 33995					;SPECIFIED BY E.
 33996					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 33997					;HENCE, AOJA SHOULD JUMP
 33998
 33999	051444	474 12 0 00 000000 	C53010:	SETO	12,		;PRELOAD AC WITH -1,,-1
 34000	051445	344 12 0 00 051447 		AOJA	12,.+2		;*AOJA SHOULD ADD 0,,1 TO C(AC)
 34001									;AND JUMP
 34002						STOP^
 34003	051446	254 04 0 00 051447 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34004	051447	324 00 0 00 051450 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34005									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34006									;IN THE SUBTEST) TO LOOP ON ERROR^
 34007	051450	302 12 0 00 000000 		CAIE	12,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 34008						STOP^
 34009	051451	254 04 0 00 051452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34010	051452	324 00 0 00 051453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34011									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34012									;IN THE SUBTEST) TO LOOP ON ERROR^
 34013
 34014					;**********
 34015
 34016					;THIS TEST VERIFIES THAT AOJA INCREMENTS C(AC) BY 0,,1 AND
 34017					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34018					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 34019					;SPECIFIED BY E.
 34020					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34021					;HENCE, AOJA SHOULD JUMP
 34022
 34023	051453	400 12 0 00 000000 	C53020:	SETZ	12,		;PRELOAD AC WITH 0
 34024	051454	344 12 0 00 051456 		AOJA	12,.+2		;*AOJA SHOULD ADD 0,,1 TO C(AC)
 34025									;AND JUMP
 34026						STOP^
 34027	051455	254 04 0 00 051456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34028	051456	324 00 0 00 051457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34029									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34030									;IN THE SUBTEST) TO LOOP ON ERROR^
 34031	051457	302 12 0 00 000001 		CAIE	12,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34032						STOP^
 34033	051460	254 04 0 00 051461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34034	051461	324 00 0 00 051462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34035									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34036									;IN THE SUBTEST) TO LOOP ON ERROR^
 34037
 34038					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 52
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 34039					;THIS TEST VERIFIES THAT AOJGE INCREMENTS C(AC) BY 0,,1 AND
 34040					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34041					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34042					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 34043					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 34044					;HENCE, AOJGE SHOULD NOT JUMP
 34045
 34046	051462	561 11 0 00 777776 	C53100:	HRROI	11,-2		;PRELOAD AC WITH -1,,-2
 34047	051463	345 11 0 00 051465 		AOJGE	11,.+2		;*AOJGE SHOULD ADD 0,,1 TO C(AC)
 34048									;AND NOT JUMP
 34049	051464	334 00 0 00 000000 		SKIPA			;PASS IF AOJGE DID NOT JUMP
 34050						STOP^
 34051	051465	254 04 0 00 051466 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34052	051466	324 00 0 00 051467 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34053									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34054									;IN THE SUBTEST) TO LOOP ON ERROR^
 34055	051467	312 11 0 00 070254 		CAME	11,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 34056						STOP^
 34057	051470	254 04 0 00 051471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34058	051471	324 00 0 00 051472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34059									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34060									;IN THE SUBTEST) TO LOOP ON ERROR^
 34061
 34062					;**********
 34063
 34064					;THIS TEST VERIFIES THAT AOJGE INCREMENTS C(AC) BY 0,,1 AND
 34065					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34066					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34067					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0.
 34068					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 34069					;HENCE, AOJ SHOULD JUMP
 34070
 34071	051472	474 11 0 00 000000 	C53110:	SETO	11,		;PRELOAD AC WITH -1,,-1
 34072	051473	345 11 0 00 051475 		AOJGE	11,.+2		;*AOJGE SHOULD ADD 0,,1 TO C(AC)
 34073									;AND JUMP
 34074						STOP^
 34075	051474	254 04 0 00 051475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34076	051475	324 00 0 00 051476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34077									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34078									;IN THE SUBTEST) TO LOOP ON ERROR^
 34079	051476	302 11 0 00 000000 		CAIE	11,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 34080						STOP^
 34081	051477	254 04 0 00 051500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34082	051500	324 00 0 00 051501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34084									;IN THE SUBTEST) TO LOOP ON ERROR^
 34085
 34086					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 53
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 34087					;THIS TEST VERIFIES THAT AOJGE INCREMENTS C(AC) BY 0,,1 AND
 34088					;PLACES THE RESULT BACK INTO AC.  THE RESULT IN THE AC IS
 34089					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34090					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 34091					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34092					;HENCE, AOJGE SHOULD JUMP
 34093
 34094	051501	400 11 0 00 000000 	C53120:	SETZ	11,		;PRELOAD AC WITH 0
 34095	051502	345 11 0 00 051504 		AOJGE	11,.+2		;*AOJGE SHOULD ADD 0,,1 TO C(AC)
 34096									;AND JUMP
 34097						STOP^
 34098	051503	254 04 0 00 051504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34099	051504	324 00 0 00 051505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34100									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34101									;IN THE SUBTEST) TO LOOP ON ERROR^
 34102	051505	302 11 0 00 000001 		CAIE	11,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34103						STOP^
 34104	051506	254 04 0 00 051507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34105	051507	324 00 0 00 051510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34106									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34107									;IN THE SUBTEST) TO LOOP ON ERROR^
 34108
 34109					;**********
 34110
 34111					;THIS TEST VERIFIES THAT AOJN INCREMENTS C(AC) BY 0,,1 AND
 34112					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34113					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34114					;SPECIFIED BY E IF C(AC) IS NOT EQUAL TO 0.
 34115					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INCREMENTING
 34116					;HENCE, AOJN SHOULD JUMP
 34117
 34118	051510	561 10 0 00 777776 	C53200:	HRROI	10,-2		;PRELOAD AC WITH -1,,-2
 34119	051511	346 10 0 00 051513 		AOJN	10,.+2		;*AOJN SHOULD ADD 0,,1 TO C(AC)
 34120									;AND JUMP
 34121						STOP^
 34122	051512	254 04 0 00 051513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34123	051513	324 00 0 00 051514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34125									;IN THE SUBTEST) TO LOOP ON ERROR^
 34126	051514	312 10 0 00 070254 		CAME	10,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 34127						STOP^
 34128	051515	254 04 0 00 051516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34129	051516	324 00 0 00 051517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34131									;IN THE SUBTEST) TO LOOP ON ERROR^
 34132
 34133					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 54
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 34134					;THIS TEST VERIFIES THAT AOJN INCREMENTS C(AC) BY 0,,1 AND
 34135					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34136					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34137					;SPECIFIED BY E IF C(AC) IS NOT EQUAL TO 0.
 34138					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 34139					;HENCE, AOJ SHOULD NOT JUMP.
 34140
 34141	051517	474 10 0 00 000000 	C53210:	SETO	10,		;PRELOAD AC WITH -1,,-1
 34142	051520	346 10 0 00 051522 		AOJN	10,.+2		;*AOJN SHOULD ADD 0,,1 TO C(AC)
 34143									;AND NOT JUMP
 34144	051521	334 00 0 00 000000 		SKIPA			;PASS IF AOJN DID NOT JUMP
 34145						STOP^
 34146	051522	254 04 0 00 051523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34147	051523	324 00 0 00 051524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34148									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34149									;IN THE SUBTEST) TO LOOP ON ERROR^
 34150	051524	302 10 0 00 000000 		CAIE	10,0		;PASS IF C(AC) INCREMENTED CORRRECTLY
 34151						STOP^
 34152	051525	254 04 0 00 051526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34153	051526	324 00 0 00 051527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34155									;IN THE SUBTEST) TO LOOP ON ERROR^
 34156
 34157					;**********
 34158
 34159					;THIS TEST VERIFIES THAT AOJN INCREMENTS C(AC) BY 0,,1 AND
 34160					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34161					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34162					;SPECIFIED BY E IF C(AC) IS NOT EQUAL TO 0.
 34163					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34164					;HENCE, AOJN SHOULD JUMP.
 34165
 34166	051527	400 10 0 00 000000 	C53220:	SETZ	10,		;PRELOAD AC WITH 0
 34167	051530	346 10 0 00 051532 		AOJN	10,.+2		;*AOJN SHOULD ADD 0,,1 TO C(AC)
 34168									;AND JUMP
 34169						STOP^
 34170	051531	254 04 0 00 051532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34171	051532	324 00 0 00 051533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34172									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34173									;IN THE SUBTEST) TO LOOP ON ERROR^
 34174	051533	302 10 0 00 000001 		CAIE	10,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34175						STOP^
 34176	051534	254 04 0 00 051535 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34177	051535	324 00 0 00 051536 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34178									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34179									;IN THE SUBTEST) TO LOOP ON ERROR^
 34180
 34181					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 55
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 34182					;THIS TEST VERIFIES THAT AOJG INCREMENTS C(AC) BY 0,,1 AND
 34183					;PLACES THE RESULT BACK INTO THE AC.  THE REAULT IN THE AC IS
 34184					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34185					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0
 34186					;IN THIS CASE, C(AC) IS -1,,-2 BEFORE INC
 34187					;HENCE, AOJG SHOULD NOT JUMP
 34188
 34189	051536	561 07 0 00 777776 	C53300:	HRROI	7,-2		;PRELOAD AC WITH -1,,-2
 34190	051537	347 07 0 00 051541 		AOJG	7,.+2		;*AOJG SHOULD ADD 0,11 TO C(AC)
 34191									;AND NOT JUMP
 34192	051540	334 00 0 00 000000 		SKIPA			;PASS IF AOJG DID NOT JUMP
 34193						STOP^
 34194	051541	254 04 0 00 051542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34195	051542	324 00 0 00 051543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34196									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34197									;IN THE SUBTEST) TO LOOP ON ERROR^
 34198	051543	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF C(AC) INCREMENTED CORRECTLY
 34199						STOP^
 34200	051544	254 04 0 00 051545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34201	051545	324 00 0 00 051546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34202									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34203									;IN THE SUBTEST) TO LOOP ON ERROR^
 34204
 34205					;**********
 34206
 34207					;THIS TEST VERIFIES THAT AOJG INCREMENTS C(AC) BY 0,,1 AND
 34208					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34209					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34210					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 34211					;IN THIS CASE, C(AC) IS -1,,-1 BEFORE INCREMENTING
 34212					;HENCE, AOJG SHOULD NOT JUMP.
 34213
 34214	051546	474 07 0 00 000000 	C53310:	SETO	7,		;PRELOAD AC WITH -1,,-1
 34215	051547	347 07 0 00 051551 		AOJG	7,.+2		;*AOJG SHOULD ADD 0,,1 TO C(AC)
 34216									;AND NOT JUMP
 34217	051550	334 00 0 00 000000 		SKIPA			;PASS IF AOJG DID NOT JUMP
 34218						STOP^
 34219	051551	254 04 0 00 051552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34220	051552	324 00 0 00 051553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34221									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34222									;IN THE SUBTEST) TO LOOP ON ERROR^
 34223	051553	302 07 0 00 000000 		CAIE	7,0		;PASS IF C(AC) INCREMENTED CORRECTLY
 34224						STOP^
 34225	051554	254 04 0 00 051555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34226	051555	324 00 0 00 051556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34227									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34228									;IN THE SUBTEST) TO LOOP ON ERROR^
 34229
 34230					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 56
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOJX INSTRUCTIONS

 34231					;THIS TEST VERIFIES THAT AOJG INCREMENTS C(AC) BY 0,,1 AND
 34232					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34233					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34234					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 34235					;IN THIS CASE, C(AC) IS 0 BEFORE INCREMENTING
 34236					;HENCE, AOJG SHOULD JUMP
 34237
 34238	051556	400 07 0 00 000000 	C53320:	SETZ	7,		;PRELOAD AC WITH 0
 34239	051557	347 07 0 00 051561 		AOJG	7,.+2		;*AOJG SHOULD ADD 0,,1 TO C(AC)
 34240									;AND JUMP
 34241						STOP^
 34242	051560	254 04 0 00 051561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34243	051561	324 00 0 00 051562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34244									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34245									;IN THE SUBTEST) TO LOOP ON ERROR^
 34246	051562	302 07 0 00 000001 		CAIE	7,1		;PASS IF C(AC) INCREMENTED CORRECTLY
 34247						STOP^
 34248	051563	254 04 0 00 051564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34249	051564	324 00 0 00 051565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34250									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34251									;IN THE SUBTEST) TO LOOP ON ERROR^
 34252
 34253					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34254					SUBTTL	TEST OF MSCL AOSX INSTRUCTIONS
 34255
 34256					;**********
 34257
 34258					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34259					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34260					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0
 34261					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34262					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34263					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD SKIP ; AND THE
 34264					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34265					;RESPECTIVELY.
 34266
 34267	051565	200 06 0 00 070332 	C53400:	MOVE	6,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34268	051566	561 07 0 00 777776 		HRROI	7,-2		;PRELOAD E WITH -1,,-2
 34269	051567	351 06 0 00 000007 		AOSL	6,7		;*AOSL SHOULD ADD 0,,1 TO C(E),
 34270									;UPDATE AC AND SKIP
 34271						STOP^
 34272	051570	254 04 0 00 051571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34273	051571	324 00 0 00 051572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34274									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34275									;IN THE SUBTEST) TO LOOP ON ERROR^
 34276	051572	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34277						STOP^
 34278	051573	254 04 0 00 051574 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34279	051574	324 00 0 00 051575 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34281									;IN THE SUBTEST) TO LOOP ON ERROR^
 34282	051575	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34283						STOP^
 34284	051576	254 04 0 00 051577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34285	051577	324 00 0 00 051600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34287									;IN THE SUBTEST) TO LOOP ON ERROR^
 34288
 34289					;**********
 34290
 34291					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34292					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34293					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0
 34294					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34295					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34296					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD SKIP ; AND THE
 34297					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34298					;RESPECTIVELY.
 34299
 34300	051600	200 06 0 00 070332 	C53401:	MOVE	6,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34301	051601	561 07 0 00 777776 		HRROI	7,-2		;PRELOAD E WITH -1,,-2
 34302	051602	202 07 0 00 051616 		MOVEM	7,E53401
 34303	051603	351 06 0 00 051616 		AOSL	6,E53401	;*AOSL SHOULD ADD 0,,1 TO C(E),
 34304									;UPDATE AC AND SKIP
 34305						STOP^
 34306	051604	254 04 0 00 051605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34307	051605	324 00 0 00 051606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34308									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34309									;IN THE SUBTEST) TO LOOP ON ERROR^
 34310	051606	200 07 0 00 051616 		MOVE	7,E53401
 34311	051607	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34312						STOP^
 34313	051610	254 04 0 00 051611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34314	051611	324 00 0 00 051612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34315									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34316									;IN THE SUBTEST) TO LOOP ON ERROR^
 34317	051612	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34318						STOP^
 34319	051613	254 04 0 00 051614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34320	051614	324 00 0 00 051615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34321									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34322									;IN THE SUBTEST) TO LOOP ON ERROR^
 34323
 34324	051615	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 34325	051616	000000	000000		E53401:	0			;TEST WORD MEMORY
 34326
 34327					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 58
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34328					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34329					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34330					;THE NEXT INSTRUCTION IF C(E) ISLESS THAN 0
 34331					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34332					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34333					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD NOT SKIP; AND THE
 34334					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34335					;RESPECTIVELY.
 34336
 34337	051617	200 06 0 00 070332 	C53410:	MOVE	6,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34338	051620	474 07 0 00 000000 		SETO	7,		;PRELOAD E WITH -1,,-1
 34339	051621	351 06 0 00 000007 		AOSL	6,7		;*AOSL SHOULD ADD 00,1 TO C(E)
 34340									;UPDATE AC AND NOT SKIP
 34341	051622	334 00 0 00 000000 		SKIPA			;PASS IF AOSL DID NOT SKIP
 34342						STOP^
 34343	051623	254 04 0 00 051624 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34344	051624	324 00 0 00 051625 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34345									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34346									;IN THE SUBTEST) TO LOOP ON ERROR^
 34347	051625	312 07 0 00 070253 		CAME	7,[0]		;PASS IF E INCREMENTED CORRECTLY
 34348						STOP^
 34349	051626	254 04 0 00 051627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34350	051627	324 00 0 00 051630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34351									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34352									;IN THE SUBTEST) TO LOOP ON ERROR^
 34353	051630	312 06 0 00 070253 		CAME	6,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34354						STOP^
 34355	051631	254 04 0 00 051632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34356	051632	324 00 0 00 051633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34357									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34358									;IN THE SUBTEST) TO LOOP ON ERROR^
 34359
 34360					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 59
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34361					;THIS TEST VERIFIES THAT AOSL INCREMENTS C(E) BY 0,,1 AND PLACES
 34362					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34363					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 34364					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34365					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0
 34366					;BEFORE INCREMENTING.  HENCE, AOSL SHOULD NOT SKIP; AND THE
 34367					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34368					;RESPECTIVELY
 34369
 34370	051633	200 06 0 00 070332 	C53420:	MOVE	6,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34371	051634	400 07 0 00 000000 		SETZ	7,		;PRELOAD E WITH 0
 34372	051635	351 06 0 00 000007 		AOSL	6,7		;*AOSL SHOULD ADD 0,,1 TO C(E).
 34373									;UPDATE AC AND NOT SKIP
 34374	051636	334 00 0 00 000000 		SKIPA			;PASS IF AOSL DID NOT SKIP
 34375						STOP^
 34376	051637	254 04 0 00 051640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34377	051640	324 00 0 00 051641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34378									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34379									;IN THE SUBTEST) TO LOOP ON ERROR^
 34380	051641	312 07 0 00 070265 		CAME	7,[1]		;PASS IF E INCREMENTED CORRECTLY
 34381						STOP^
 34382	051642	254 04 0 00 051643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34383	051643	324 00 0 00 051644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34384									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34385									;IN THE SUBTEST) TO LOOP ON ERROR^
 34386	051644	312 06 0 00 070265 		CAME	6,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34387						STOP^
 34388	051645	254 04 0 00 051646 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34389	051646	324 00 0 00 051647 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34390									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34391									;IN THE SUBTEST) TO LOOP ON ERROR^
 34392
 34393					;**********
 34394
 34395					;THIS TEST VERIFIES THAT AOSE INCREMENTS C(E) BY 0,,1 AND PLACES
 34396					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34397					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0.
 34398					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34399					;IN THIS CASE, AC=5, C(AC)=707070,,707070AND C(E)=-1,,-2
 34400					;BEFORE INCREMENTING.  HENCE, AOSE SHOULD NOT SKIP; AND THE
 34401					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34402					;RESPECTIVELY.
 34403
 34404	051647	200 05 0 00 070332 	C53500:	MOVE	5,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34405	051650	561 06 0 00 777776 		HRROI	6,-2		;PRELOAD E WITH -1,,-2
 34406	051651	352 05 0 00 000006 		AOSE	5,6		;*AOSE SHOULD ADD 0,,1 TO C(E),
 34407									;UPDATE AC AND NOT SKIP
 34408	051652	334 00 0 00 000000 		SKIPA			;PASS IF AOSE DID NOT SKIP
 34409						STOP^
 34410	051653	254 04 0 00 051654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34411	051654	324 00 0 00 051655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34412									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34413									;IN THE SUBTEST) TO LOOP ON ERROR^
 34414	051655	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34415						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 59-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34416	051656	254 04 0 00 051657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34417	051657	324 00 0 00 051660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34418									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34419									;IN THE SUBTEST) TO LOOP ON ERROR^
 34420	051660	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34421						STOP^
 34422	051661	254 04 0 00 051662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34423	051662	324 00 0 00 051663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34424									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34425									;IN THE SUBTEST) TO LOOP ON ERROR^
 34426
 34427					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 60
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34428					;THIS TEST VERIFIES THAT AOSE INCREMENTS C(E) BY 0,,1 AND PLACES
 34429					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34430					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 34431					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34432					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34433					;BEFORE INCREMENTING.  HENCE, AOSE SHOULD SKIP; AND THE
 34434					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34435					;RESPECTIVELY.
 34436
 34437	051663	200 05 0 00 070332 	C53510:	MOVE	5,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34438	051664	474 06 0 00 000000 		SETO	6,		;PRELOAD E WITH -1,,-1
 34439	051665	352 05 0 00 000006 		AOSE	5,6		;*AOSE SHOULD ADD 0,,1 TO C(E),
 34440									;UPDATE AC AND SKIP
 34441						STOP^
 34442	051666	254 04 0 00 051667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34443	051667	324 00 0 00 051670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34444									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34445									;IN THE SUBTEST) TO LOOP ON ERROR^
 34446	051670	312 06 0 00 070253 		CAME	6,[0]		;PASS IF E INCREMENTED CORRECTLY
 34447						STOP^
 34448	051671	254 04 0 00 051672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34449	051672	324 00 0 00 051673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34450									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34451									;IN THE SUBTEST) TO LOOP ON ERROR^
 34452	051673	312 05 0 00 070253 		CAME	5,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34453						STOP^
 34454	051674	254 04 0 00 051675 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34455	051675	324 00 0 00 051676 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34457									;IN THE SUBTEST) TO LOOP ON ERROR^
 34458
 34459					;**********
 34460
 34461					;THIS TEST VERIFIES THAT AOSE INCREMENTS C(E) BY 0,,1 AND PLACES
 34462					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34463					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 34464					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34465					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(AC)=0
 34466					;BEFORE INCREMENTING.  HENCE, AOSE SHOULD NOT SKIP; AND THE
 34467					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34468					;RESPECTIVELY.
 34469
 34470	051676	200 05 0 00 070332 	C53520:	MOVE	5,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34471	051677	400 06 0 00 000000 		SETZ	6,		;PRELOAD E WITH 0
 34472	051700	352 05 0 00 000006 		AOSE	5,6		;*AOSE SHOULD ADD 0,,1 TO C(E),
 34473									;UPDATE AC AND NOT SKIP
 34474	051701	334 00 0 00 000000 		SKIPA			;PASS IF AOSE DID NOT SKIP
 34475						STOP^
 34476	051702	254 04 0 00 051703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34477	051703	324 00 0 00 051704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34478									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34479									;IN THE SUBTEST) TO LOOP ON ERROR^
 34480	051704	312 06 0 00 070265 		CAME	6,[1]		;PASS IF E INCREMENTED CORRECTLY
 34481						STOP^
 34482	051705	254 04 0 00 051706 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 60-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34483	051706	324 00 0 00 051707 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34484									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34485									;IN THE SUBTEST) TO LOOP ON ERROR^
 34486	051707	312 05 0 00 070265 		CAME	5,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34487						STOP^
 34488	051710	254 04 0 00 051711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34489	051711	324 00 0 00 051712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34491									;IN THE SUBTEST) TO LOOP ON ERROR^
 34492
 34493					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 61
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34494					;THIS TEST VERIFIES THAT AOSLE INCREMENTS C(E) BY 0,,1 AND PLACES
 34495					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34496					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO0
 34497					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34498					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34499					;BEFORE INCREMENTING.  HENCE, AOSLE SHOULD SKIP; AND THE
 34500					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34501					;RESPECTIVELY.
 34502
 34503	051712	200 04 0 00 070332 	C53600:	MOVE	4,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34504	051713	561 05 0 00 777776 		HRROI	5,-2		;PRELOAD E WITH -1,,-2
 34505	051714	353 04 0 00 000005 		AOSLE	4,5		;*AOSLE SHOULD ADD 0,,1 TO C(E),
 34506									;UPDATE AC AND SKIP ZERO
 34507						STOP^
 34508	051715	254 04 0 00 051716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34509	051716	324 00 0 00 051717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34510									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34511									;IN THE SUBTEST) TO LOOP ON ERROR^
 34512	051717	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34513						STOP^
 34514	051720	254 04 0 00 051721 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34515	051721	324 00 0 00 051722 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34516									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34517									;IN THE SUBTEST) TO LOOP ON ERROR^
 34518	051722	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34519						STOP^
 34520	051723	254 04 0 00 051724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34521	051724	324 00 0 00 051725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34522									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34523									;IN THE SUBTEST) TO LOOP ON ERROR^
 34524
 34525					;**********
 34526
 34527					;THIS TEST VERIFIES THAT AOSLE INCREMENTS C(E) BY 0,,1 AND PLACES
 34528					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34529					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 34530					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34531					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34532					;BEFORE INCREMENTING.  HENCE, AOSLE SHOULD SKIP; AND THE
 34533					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34534					;RESPECTIVELY.
 34535
 34536	051725	200 04 0 00 070332 	C53610:	MOVE	4,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34537	051726	476 05 0 00 000000 		SETOM	5,		;PRELOAD E WITH -1,,-1
 34538	051727	353 04 0 00 000005 		AOSLE	4,5		;*AOSLE SHOULD ADD 0,,1 TO C(E)
 34539									;UPDATE AC AND SKIP
 34540						STOP^
 34541	051730	254 04 0 00 051731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34542	051731	324 00 0 00 051732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34543									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34544									;IN THE SUBTEST) TO LOOP ON ERROR^
 34545	051732	312 05 0 00 070253 		CAME	5,[0]		;PASS IF E INCREMENTED CORRECTLY
 34546						STOP^
 34547	051733	254 04 0 00 051734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34548	051734	324 00 0 00 051735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 61-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34549									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34550									;IN THE SUBTEST) TO LOOP ON ERROR^
 34551	051735	312 04 0 00 070253 		CAME	4,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34552						STOP^
 34553	051736	254 04 0 00 051737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34554	051737	324 00 0 00 051740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34556									;IN THE SUBTEST) TO LOOP ON ERROR^
 34557
 34558					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 62
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34559					;THIS TEST VERIFIES THAT AOSLE INCREMENTS C(E) BY 0,,1 AND PLACES
 34560					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34561					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0
 34562					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34563					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0
 34564					;BEFORE INCREMENTING.  HENCE, AOSLE SHOULD NOT SKIP ; AND THE
 34565					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34566					;RESPECTIVELY.
 34567
 34568	051740	200 04 0 00 070332 	C53620:	MOVE	4,[707070,,707070]	;PRELOAD AC WITH 707070,,707070
 34569	051741	400 00 0 00 000005 		SETZ	5		;PRELOAD E WITH 0
 34570	051742	353 04 0 00 000005 		AOSLE	4,5		;*AOSLE SHOULD ADD 0,,1 TO C(E)
 34571									;UPDATE AC AND NOT SKIP
 34572	051743	334 00 0 00 000000 		SKIPA			;PASS IF AOSLE DID NOT SKIP
 34573						STOP^
 34574	051744	254 04 0 00 051745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34575	051745	324 00 0 00 051746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34576									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34577									;IN THE SUBTEST) TO LOOP ON ERROR^
 34578	051746	312 05 0 00 070265 		CAME	5,[1]		;PASS IF E INCREMENTED CORRECTLY
 34579						STOP^
 34580	051747	254 04 0 00 051750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34581	051750	324 00 0 00 051751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34582									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34583									;IN THE SUBTEST) TO LOOP ON ERROR^
 34584	051751	312 04 0 00 070265 		CAME	4,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34585						STOP^
 34586	051752	254 04 0 00 051753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34587	051753	324 00 0 00 051754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34588									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34589									;IN THE SUBTEST) TO LOOP ON ERROR^
 34590
 34591					;**********
 34592
 34593					;THIS TEST VERIFIES THAT AOSA INCREMENTS C(E) BY 0,,1 AND PLACES
 34594					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 34595					;THE NEXT INSTRUCTION.
 34596					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34597					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34598					;BEFORE INCREMENTING.  HENCE, AOSA SHOULD SKIP ; AND THE
 34599					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34600					;RESPECTIVELY.
 34601
 34602	051754	200 03 0 00 070332 	C53700:	MOVE	3,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34603	051755	561 04 0 00 777776 		HRROI	4,-2		;PRELOAD E WITH -1,,-2
 34604	051756	354 03 0 00 000004 		AOSA	3,4		;*AOSA SHOULD ADD 0,,1 TO C(E),
 34605									;UPDATE AC AND SKIP
 34606						STOP^
 34607	051757	254 04 0 00 051760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34608	051760	324 00 0 00 051761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34609									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34610									;IN THE SUBTEST) TO LOOP ON ERROR^
 34611	051761	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34612						STOP^
 34613	051762	254 04 0 00 051763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 62-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34614	051763	324 00 0 00 051764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34615									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34616									;IN THE SUBTEST) TO LOOP ON ERROR^
 34617	051764	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34618						STOP^
 34619	051765	254 04 0 00 051766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34620	051766	324 00 0 00 051767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34621									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34622									;IN THE SUBTEST) TO LOOP ON ERROR^
 34623
 34624					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 63
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34625					;THIS TEST VERIFIES THAT AOSA INCREMENTS C(E) BY 0,,1 AND PLACES
 34626					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 34627					;THE NEXT INSTRUCTION.
 34628					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34629					;;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34630					;BEFORE INCREMENTING.  HENCE, AOSA SHOULD SKIP AND THE
 34631					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34632					;RESPECTIVELY
 34633
 34634	051767	200 03 0 00 070332 	C53710:	MOVE	3,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34635	051770	474 04 0 00 000000 		SETO	4,		;PRELOAD E WITH -1,,-1
 34636	051771	354 03 0 00 000004 		AOSA	3,4		;*AOSA SHOULD ADD 0,,1 TO C(E),
 34637									;UPDATE AC AND SKIP
 34638						STOP^
 34639	051772	254 04 0 00 051773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34640	051773	324 00 0 00 051774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34642									;IN THE SUBTEST) TO LOOP ON ERROR^
 34643	051774	312 04 0 00 070253 		CAME	4,[0]		;PASS IF E INCREMENTED CORRECTLY
 34644						STOP^
 34645	051775	254 04 0 00 051776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34646	051776	324 00 0 00 051777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34648									;IN THE SUBTEST) TO LOOP ON ERROR^
 34649	051777	312 03 0 00 070253 		CAME	3,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34650						STOP^
 34651	052000	254 04 0 00 052001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34652	052001	324 00 0 00 052002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34653									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34654									;IN THE SUBTEST) TO LOOP ON ERROR^
 34655
 34656					;**********
 34657
 34658					;THIS TEST VERIFIES THAT AOS INCREMENTS C(E) BY 0,,1 AND PLACES
 34659					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 34660					;THE NEXT INSTRUCTION.
 34661					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34662					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0
 34663					;BEFORE INCREMENTING.  HENCE, AOSA SHOULD SKIP ; AND THE
 34664					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34665					;RESPECTIVELY
 34666
 34667	052002	200 03 0 00 070332 	C53720:	MOVE	3,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34668	052003	400 04 0 00 000000 		SETZ	4,		;PRELOAD E WITH 0
 34669	052004	354 03 0 00 000004 		AOSA	3,4		;*AOSA SHOULD ADD 0,,1 TO C(E),
 34670									;UPDATE AC AND SKIP
 34671						STOP^
 34672	052005	254 04 0 00 052006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34673	052006	324 00 0 00 052007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34674									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34675									;IN THE SUBTEST) TO LOOP ON ERROR^
 34676	052007	312 04 0 00 070265 		CAME	4,[1]		;PASS IF E INCREMENTED CORRECTLY
 34677						STOP^
 34678	052010	254 04 0 00 052011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34679	052011	324 00 0 00 052012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 63-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34680									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34681									;IN THE SUBTEST) TO LOOP ON ERROR^
 34682	052012	312 03 0 00 070265 		CAME	3,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34683						STOP^
 34684	052013	254 04 0 00 052014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34685	052014	324 00 0 00 052015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34687									;IN THE SUBTEST) TO LOOP ON ERROR^
 34688
 34689					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 64
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34690					;THIS TEST VERIFIES THAT AOSGE INCREMENTS C(E) BY 0,,1 AND PLACES
 34691					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34692					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 34693					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34694					;IN THIS CASE, AC=2, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34695					;BEFORE INCREMENTING.  HENCE, AOSGE SHOULD NOT SKIP; AND THE
 34696					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34697					;RESPECTIVELY
 34698
 34699	052015	200 02 0 00 070332 	C54000:	MOVE	2,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34700	052016	561 03 0 00 777776 		HRROI	3,-2		;PRELOAD E WITH -1,,-2
 34701	052017	355 02 0 00 000003 		AOSGE	2,3		;*AOSGE SHOULD ADD 0,,1 TO C(E),
 34702									;UPDATE AC AND NOT SKIP
 34703	052020	334 00 0 00 000000 		SKIPA			;PASS IF AOSGE DID NOT SKIP
 34704						STOP^
 34705	052021	254 04 0 00 052022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34706	052022	324 00 0 00 052023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34707									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34708									;IN THE SUBTEST) TO LOOP ON ERROR^
 34709	052023	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34710						STOP^
 34711	052024	254 04 0 00 052025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34712	052025	324 00 0 00 052026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34713									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34714									;IN THE SUBTEST) TO LOOP ON ERROR^
 34715	052026	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34716						STOP^
 34717	052027	254 04 0 00 052030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34718	052030	324 00 0 00 052031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34720									;IN THE SUBTEST) TO LOOP ON ERROR^
 34721
 34722					;**********
 34723
 34724					;THIS TEST VERIFIES THAT AOSGE INCREMENTS C(E) BY 0,,1 AND PLACES
 34725					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34726					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 34727					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34728					;IN THIS CASE, AC=2, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34729					;BEFORE INCREMENTING.  HENCE, AOSGE SHOULD SKIP; AND THE
 34730					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34731					;RESPECTIVELY
 34732
 34733	052031	200 02 0 00 070332 	C54010:	MOVE	2,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34734	052032	474 03 0 00 000000 		SETO	3,		;PRELOAD E WITH 0
 34735	052033	355 02 0 00 000003 		AOSGE	2,3		;*AOSGE SHOULD ADD 0,,1 TO C(E),
 34736									;UPDATE AC AND SKIP
 34737						STOP^
 34738	052034	254 04 0 00 052035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34739	052035	324 00 0 00 052036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34740									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34741									;IN THE SUBTEST) TO LOOP ON ERROR^
 34742	052036	312 03 0 00 070253 		CAME	3,[0]		;PASS IF E INCREMENTED CORRECTLY
 34743						STOP^
 34744	052037	254 04 0 00 052040 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 64-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34745	052040	324 00 0 00 052041 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34746									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34747									;IN THE SUBTEST) TO LOOP ON ERROR^
 34748	052041	312 02 0 00 070253 		CAME	2,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34749						STOP^
 34750	052042	254 04 0 00 052043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34751	052043	324 00 0 00 052044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34752									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34753									;IN THE SUBTEST) TO LOOP ON ERROR^
 34754
 34755					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 65
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34756					;THIS TEST VERIFIES THAT AOSGE INCREMENTS C(E) BY 0,,1 AND PLACES
 34757					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34758					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 34759					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34760					;IN THIS CASE, AC=2, C(AC)=707070,,707070 AND C(E)=0
 34761					;BEFORE INCREMENTING.  HENCE, AOSGE SHOULD SKIP; AND THE
 34762					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34763					;RESPECTIVELY
 34764
 34765	052044	200 02 0 00 070332 	C54020:	MOVE	2,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34766	052045	400 03 0 00 000000 		SETZ	3,		;PRELOAD E WITH 0
 34767	052046	355 02 0 00 000003 		AOSGE	2,3		;*AOSGE SHOULD ADD 0,,1 TO C(E),
 34768									;UPDATE AC AND SKIP
 34769						STOP^
 34770	052047	254 04 0 00 052050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34771	052050	324 00 0 00 052051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34773									;IN THE SUBTEST) TO LOOP ON ERROR^
 34774	052051	312 03 0 00 070265 		CAME	3,[1]		;PASS IF E INCREMENTED CORRECTLY
 34775						STOP^
 34776	052052	254 04 0 00 052053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34777	052053	324 00 0 00 052054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34778									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34779									;IN THE SUBTEST) TO LOOP ON ERROR^
 34780	052054	312 02 0 00 070265 		CAME	2,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34781						STOP^
 34782	052055	254 04 0 00 052056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34783	052056	324 00 0 00 052057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34784									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34785									;IN THE SUBTEST) TO LOOP ON ERROR^
 34786
 34787					;**********
 34788
 34789					;THIS TEST VERIFIES THAT AOSN INCREMENTS C(E) BY 0,,1 AND PLACES
 34790					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34791					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO.
 34792					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34793					;IN THIS CASE, AC=1, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34794					;BEFORE INCREMENTING.  HENCE, AOSN SHOULD NOT SKIP; AND THE
 34795					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 34796					;RESPECTIVELY
 34797
 34798	052057	200 01 0 00 070332 	C54100:	MOVE	1,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34799	052060	561 02 0 00 777776 		HRROI	2,-2		;PRELOAD E WITH -1,,-2
 34800	052061	356 01 0 00 000002 		AOSN	1,2		;*AOSN SHOULD ADD 0,,1 TO C(E),
 34801									;UPDATE AC AND SKIP
 34802						STOP^
 34803	052062	254 04 0 00 052063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34804	052063	324 00 0 00 052064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34805									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34806									;IN THE SUBTEST) TO LOOP ON ERROR^
 34807	052064	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34808						STOP^
 34809	052065	254 04 0 00 052066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34810	052066	324 00 0 00 052067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 65-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34811									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34812									;IN THE SUBTEST) TO LOOP ON ERROR^
 34813	052067	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34814						STOP^
 34815	052070	254 04 0 00 052071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34816	052071	324 00 0 00 052072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34818									;IN THE SUBTEST) TO LOOP ON ERROR^
 34819
 34820					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 66
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34821					;THIS TEST VERIFIES THAT AOSN INCREMENTS C(E) BY 0,,1 AND PLACES
 34822					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34823					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 34824					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34825					;IN THIS CASE, AC=1, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34826					;BEFORE INCREMENTING.  HENCE, AOSN SHOULD NOT SKIP; AND THE
 34827					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 34828					;RESPECTIVELY
 34829
 34830	052072	200 01 0 00 070332 	C54110:	MOVE	1,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34831	052073	474 02 0 00 000000 		SETO	2,		;PRELOAD E WITH -1,,-1
 34832	052074	356 01 0 00 000002 		AOSN	1,2		;*AOSN SHOULD ADD 0,,1 TO C(E),
 34833									;UPDATE AC AND NOT SKIP
 34834	052075	334 00 0 00 000000 		SKIPA			;PASS IF AOSN DID NOT SKIP
 34835						STOP^
 34836	052076	254 04 0 00 052077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34837	052077	324 00 0 00 052100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34838									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34839									;IN THE SUBTEST) TO LOOP ON ERROR^
 34840	052100	312 02 0 00 070253 		CAME	2,[0]		;PASS IF E INCREMENTED CORRECTLY
 34841						STOP^
 34842	052101	254 04 0 00 052102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34843	052102	324 00 0 00 052103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34844									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34845									;IN THE SUBTEST) TO LOOP ON ERROR^
 34846	052103	312 01 0 00 070253 		CAME	1,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34847						STOP^
 34848	052104	254 04 0 00 052105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34849	052105	324 00 0 00 052106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34851									;IN THE SUBTEST) TO LOOP ON ERROR^
 34852
 34853					;**********
 34854
 34855					;THIS TEST VERIFIES THAT AOSN INCREMENTS C(E) BY 0,,1 AND PLACES
 34856					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34857					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 34858					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34859					;IN THIS CASE, AC=1, C(AC)=707070,,707070 AND C(E)=0
 34860					;BEFORE INCREMENTING.  HENCE, AOSN SHOULD SKIP; AND THE
 34861					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 34862					;RESPECTIVELY
 34863
 34864	052106	200 01 0 00 070332 	C54120:	MOVE	1,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34865	052107	400 02 0 00 000000 		SETZ	2,		;PRELOAD E WITH 0
 34866	052110	356 01 0 00 000002 		AOSN	1,2		;*AOSN SHOULD ADD 0,,1 TO C(E),
 34867									;UPDATE AC AND SKIP
 34868						STOP^
 34869	052111	254 04 0 00 052112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34870	052112	324 00 0 00 052113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34872									;IN THE SUBTEST) TO LOOP ON ERROR^
 34873	052113	312 02 0 00 070265 		CAME	2,[1]		;PASS IF E INCREMENTED CORRECTLY
 34874						STOP^
 34875	052114	254 04 0 00 052115 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 66-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34876	052115	324 00 0 00 052116 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34877									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34878									;IN THE SUBTEST) TO LOOP ON ERROR^
 34879	052116	312 01 0 00 070265 		CAME	1,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 34880						STOP^
 34881	052117	254 04 0 00 052120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34882	052120	324 00 0 00 052121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34883									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34884									;IN THE SUBTEST) TO LOOP ON ERROR^
 34885
 34886					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 67
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34887					;THIS TEST VERIFIES THAT AOSG INCREMENTS C(E) BY 0,,1 AND PLACES
 34888					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34889					;THE NEST INSTRUCTION IF C(E) IS GREATER THAN 0
 34890					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34891					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=-1,,-2
 34892					;BEFORE INCREMENTING.  HENCE, AOSG SHOULD NOT SKIP; AND THE
 34893					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND -1,,-1
 34894					;RESPECTIVELY
 34895
 34896	052121	200 00 0 00 070332 	C54200:	MOVE	0,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34897	052122	561 01 0 00 777776 		HRROI	1,-2		;PRELOAD E WITH -1,,-2
 34898	052123	357 00 0 00 000001 		AOSG	0,1		;*AOSG SHOULD ADD 0,,1 TO C(E),
 34899									;AND NOT SKIP
 34900	052124	334 00 0 00 000000 		SKIPA			;PASS IF AOSG DID NOT SKIP
 34901						STOP^
 34902	052125	254 04 0 00 052126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34903	052126	324 00 0 00 052127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34904									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34905									;IN THE SUBTEST) TO LOOP ON ERROR^
 34906	052127	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF E INCREMENTED CORRECTLY
 34907						STOP^
 34908	052130	254 04 0 00 052131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34909	052131	324 00 0 00 052132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34910									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34911									;IN THE SUBTEST) TO LOOP ON ERROR^
 34912	052132	312 00 0 00 070332 		CAME	0,[707070,,707070] ;PASS IF C(AC) WAS NOT MODIFIED
 34913						STOP^
 34914	052133	254 04 0 00 052134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34915	052134	324 00 0 00 052135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34916									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34917									;IN THE SUBTEST) TO LOOP ON ERROR^
 34918
 34919					;**********
 34920
 34921					;THIS TEST VERIFIES THAT AOSG INCREMENTS C(E) BY 0,,1 AND PLACES
 34922					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34923					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 34924					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34925					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=-1,,-1
 34926					;BEFORE INCREMENTING.  HENCE, AOSG SHOULD NOT SKIP; AND THE
 34927					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 34928					;RESPECTIVELY
 34929
 34930	052135	200 00 0 00 070332 	C54210:	MOVE	0,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34931	052136	474 01 0 00 000000 		SETO	1,		;PRELOAD E WITH -1,,-1
 34932	052137	357 00 0 00 000001 		AOSG	0,1		;*AOSG SHOULD ADD 0,,1 TO C(E),
 34933									;AND NOT SKIP
 34934	052140	334 00 0 00 000000 		SKIPA			;PASS IF AOSG DID NOT SKIP
 34935						STOP^
 34936	052141	254 04 0 00 052142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34937	052142	324 00 0 00 052143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34939									;IN THE SUBTEST) TO LOOP ON ERROR^
 34940	052143	312 01 0 00 070253 		CAME	1,[0]		;PASS IF E INCREMENTED CORRECTLY
 34941						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 67-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34942	052144	254 04 0 00 052145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34943	052145	324 00 0 00 052146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34945									;IN THE SUBTEST) TO LOOP ON ERROR^
 34946	052146	312 00 0 00 070332 		CAME	0,[707070,,707070] ;PASS IF C(AC) WAS NOT MODIFIED
 34947						STOP^
 34948	052147	254 04 0 00 052150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34949	052150	324 00 0 00 052151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34951									;IN THE SUBTEST) TO LOOP ON ERROR^
 34952
 34953					;***********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 68
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL AOSX INSTRUCTIONS

 34954					;THIS TEST VERIFIES THAT AOSG INCREMENTS C(E) BY 0,,1 AND PLACES
 34955					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 34956					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 34957					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 34958					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0
 34959					;BEFORE INCREMENTING.  HENCE, AOSG SHOULD SKIP; AND THE
 34960					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0,,1
 34961					;RESPECTIVELY
 34962
 34963	052151	200 00 0 00 070332 	C54220:	MOVE	0,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 34964	052152	400 01 0 00 000000 		SETZ	1,		;PRELOAD E WITH 0
 34965	052153	357 00 0 00 000001 		AOSG	0,1		;*AOSG SHOULD ADD 0,,1 TO C(E),
 34966									;AND SKIP
 34967						STOP^
 34968	052154	254 04 0 00 052155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34969	052155	324 00 0 00 052156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34970									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34971									;IN THE SUBTEST) TO LOOP ON ERROR^
 34972	052156	312 01 0 00 070265 		CAME	1,[1]		;PASS IF E INCREMENTED CORRECTLY
 34973						STOP^
 34974	052157	254 04 0 00 052160 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34975	052160	324 00 0 00 052161 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34976									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34977									;IN THE SUBTEST) TO LOOP ON ERROR^
 34978	052161	312 00 0 00 070332 		CAME	0,[707070,,707070] ;PASS IF C(AC) WAS NOT MODIFIED
 34979						STOP^
 34980	052162	254 04 0 00 052163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 34981	052163	324 00 0 00 052164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 34982									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 34983									;IN THE SUBTEST) TO LOOP ON ERROR^
 34984
 34985					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 69
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 34986					SUBTTL	TEST OF MSCL SOJX INSTRUCTIONS
 34987
 34988					;**********
 34989
 34990					;THIS TEST VERIFIES THAT SOJL DECREMENTS C(AC) BY 0,,1 AND
 34991					;PLACES THE RESTULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 34992					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 34993					;SPECIFIED BY E IF C(AC) IS LESS THAN 0.
 34994					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJL
 34995					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 34996
 34997	052164	201 17 0 00 000000 	C54300:	MOVEI	17,0		;PRELOAD AC WITH 0
 34998	052165	361 17 0 00 052167 		SOJL	17,.+2		;*SOJL SHOULD SUBTRACT 0,,1 FROM C(AC)
 34999									;AND JUMP
 35000						STOP^
 35001	052166	254 04 0 00 052167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35002	052167	324 00 0 00 052170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35003									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35004									;IN THE SUBTEST) TO LOOP ON ERROR^
 35005	052170	312 17 0 00 070254 		CAME	17,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35006						STOP^
 35007	052171	254 04 0 00 052172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35008	052172	324 00 0 00 052173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35009									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35010									;IN THE SUBTEST) TO LOOP ON ERROR^
 35011
 35012					;***********
 35013
 35014					;THIS TEST VERIFIES THAT SOJL DECREMENTS C(AC) BY 0,,1 AND
 35015					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35016					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35017					;SPECIFIED BY E IF C(AC) IS LESS THAN 0.
 35018					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJL
 35019					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0.
 35020
 35021	052173	201 17 0 00 000001 	C54310:	MOVEI	17,1		;PRELOAD AC WITH 0,,1
 35022	052174	361 17 0 00 052176 		SOJL	17,.+2			;*SOJL SHOULD SUBTRACT 0,,1 FROM C(AC)
 35023	052175	334 00 0 00 000000 		SKIPA			;PASS IF SOJL DID NOT JUMP
 35024						STOP^
 35025	052176	254 04 0 00 052177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35026	052177	324 00 0 00 052200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35027									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35028									;IN THE SUBTEST) TO LOOP ON ERROR^
 35029	052200	312 17 0 00 070253 		CAME	17,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35030						STOP^
 35031	052201	254 04 0 00 052202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35032	052202	324 00 0 00 052203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35033									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35034									;IN THE SUBTEST) TO LOOP ON ERROR^
 35035
 35036					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 70
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35037					;THIS TEST VERIFIES THAT SOJL DECREMENTS C(AC) BY 0,,1 AND
 35038					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35039					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35040					;SPECIFIED BY E IF C(AC) IS LESS THAN 0
 35041					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJ
 35042					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35043
 35044	052203	201 17 0 00 000002 	C54320:	MOVEI	17,2		;PRELOAD AC WITH 0,,2
 35045	052204	361 17 0 00 052206 		SOJL	17,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35046									;AND NOT JUMP.
 35047	052205	334 00 0 00 000000 		SKIPA			;PASS IF SOJL DID NOT JUMP
 35048						STOP^
 35049	052206	254 04 0 00 052207 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35050	052207	324 00 0 00 052210 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35051									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35052									;IN THE SUBTEST) TO LOOP ON ERROR^
 35053	052210	312 17 0 00 070265 		CAME	17,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35054						STOP^
 35055	052211	254 04 0 00 052212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35056	052212	324 00 0 00 052213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35058									;IN THE SUBTEST) TO LOOP ON ERROR^
 35059
 35060					;**********
 35061
 35062					;THIS TEST VERIFIES THAT SOJE DECREMENTS C(AC) BY 0,,1 AND
 35063					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35064					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35065					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 35066					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJE
 35067					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35068
 35069	052213	201 16 0 00 000000 	C54400:	MOVEI	16,0		;PRELOAD AC WITH 0
 35070	052214	362 16 0 00 052216 		SOJE	16,.+2		;*SOJE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35071									;AND NOT JUMP.
 35072	052215	334 00 0 00 000000 		SKIPA			;PASS IF SOJE DID NOT JUMP
 35073						STOP^
 35074	052216	254 04 0 00 052217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35075	052217	324 00 0 00 052220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35076									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35077									;IN THE SUBTEST) TO LOOP ON ERROR^
 35078	052220	312 16 0 00 070254 		CAME	16,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35079						STOP^
 35080	052221	254 04 0 00 052222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35081	052222	324 00 0 00 052223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35082									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35083									;IN THE SUBTEST) TO LOOP ON ERROR^
 35084
 35085					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 71
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35086					;THIS TEST VERIFIES THAT SOJE DECREMENTS C(AC) BY 0,,1 AND
 35087					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35088					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35089					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0
 35090					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJ
 35091					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35092
 35093	052223	201 16 0 00 000001 	C54410:	MOVEI	16,1		;PRELOAD AC WITH 0,,1
 35094	052224	362 16 0 00 052226 		SOJE	16,.+2		;*SOJE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35095									;AND JUMP
 35096						STOP^
 35097	052225	254 04 0 00 052226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35098	052226	324 00 0 00 052227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35099									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35100									;IN THE SUBTEST) TO LOOP ON ERROR^
 35101	052227	312 16 0 00 070253 		CAME	16,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35102						STOP^
 35103	052230	254 04 0 00 052231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35104	052231	324 00 0 00 052232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35105									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35106									;IN THE SUBTEST) TO LOOP ON ERROR^
 35107
 35108					;**********
 35109
 35110					;THIS TEST VERIFIES THAT SOJE DECREMENTS C(AC) BY 0,,1 AND
 35111					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35112					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35113					;SPECIFIED BY E IF C(AC) IS EQUAL TO 0.
 35114					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJE
 35115					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35116
 35117	052232	201 16 0 00 000002 	C54420:	MOVEI	16,2		;PRELOAD AC WITH 0,,2
 35118	052233	362 16 0 00 052235 		SOJE	16,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35119									;AND NOT JUMP.
 35120	052234	334 00 0 00 000000 		SKIPA			;PASS IF SOJE DID NOT JUMP
 35121						STOP^
 35122	052235	254 04 0 00 052236 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35123	052236	324 00 0 00 052237 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35125									;IN THE SUBTEST) TO LOOP ON ERROR^
 35126	052237	312 16 0 00 070265 		CAME	16,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35127						STOP^
 35128	052240	254 04 0 00 052241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35129	052241	324 00 0 00 052242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35131									;IN THE SUBTEST) TO LOOP ON ERROR^
 35132
 35133					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 72
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35134					;THIS TEST VERIFIES THAT SOJLE DECREMENTS C(AC) BY 0,,1 AND
 35135					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35136					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35137					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0
 35138					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJLE
 35139					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35140
 35141	052242	201 15 0 00 000000 	C54500:	MOVEI	15,0		;PRELOAD AC WITH 0
 35142	052243	363 15 0 00 052245 		SOJLE	15,.+2		;*SOJLE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35143									;AND JUMP
 35144						STOP^
 35145	052244	254 04 0 00 052245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35146	052245	324 00 0 00 052246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35147									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35148									;IN THE SUBTEST) TO LOOP ON ERROR^
 35149	052246	312 15 0 00 070254 		CAME	15,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35150						STOP^
 35151	052247	254 04 0 00 052250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35152	052250	324 00 0 00 052251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35154									;IN THE SUBTEST) TO LOOP ON ERROR^
 35155
 35156					;**********
 35157
 35158					;THIS TEST VERIFIES THAT SOJLE DECREMENTS C(AC) BY 0,,1 AND
 35159					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35160					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35161					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUALTO 0.
 35162					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJLE
 35163					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35164
 35165	052251	201 15 0 00 000001 	C54510:	MOVEI	15,1		;PRELOAD AC WITH 0,,1
 35166	052252	363 15 0 00 052254 		SOJLE	15,.+2		;*SOJLE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35167									;AND JUMP
 35168						STOP^
 35169	052253	254 04 0 00 052254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35170	052254	324 00 0 00 052255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35171									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35172									;IN THE SUBTEST) TO LOOP ON ERROR^
 35173	052255	312 15 0 00 070253 		CAME	15,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35174						STOP^
 35175	052256	254 04 0 00 052257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35176	052257	324 00 0 00 052260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35177									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35178									;IN THE SUBTEST) TO LOOP ON ERROR^
 35179
 35180					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 73
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35181					;THIS TEST VERIFIES THAT SOJLE DECREMENTS C(AC) BY 0,,1 AND
 35182					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35183					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35184					;SPECIFIED BY E IF C(AC) IS LESS THAN OR EQUAL TO 0.
 35185					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJLE
 35186					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35187
 35188	052260	201 15 0 00 000002 	C54520:	MOVEI	15,2		;PRELOAD AC WITH 0,,2
 35189	052261	363 15 0 00 052263 		SOJLE	15,.+2		;*SOJLE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35190									;AND NOT JUMP
 35191	052262	334 00 0 00 000000 		SKIPA			;PASS IF SOJLE DID NOT JUMP
 35192						STOP^
 35193	052263	254 04 0 00 052264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35194	052264	324 00 0 00 052265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35195									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35196									;IN THE SUBTEST) TO LOOP ON ERROR^
 35197	052265	312 15 0 00 070265 		CAME	15,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35198						STOP^
 35199	052266	254 04 0 00 052267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35200	052267	324 00 0 00 052270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35201									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35202									;IN THE SUBTEST) TO LOOP ON ERROR^
 35203
 35204					;**********
 35205
 35206					;THIS TEST VERIFIES THAT SOJA DECREMENTS C(AC) BY 0,,1 AND
 35207					;PLACES THE RESULT INTO THE AC.  THE RESULT IN THE AC IS
 35208					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 35209					;SPECIFIED BY E
 35210					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJA
 35211					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35212
 35213	052270	201 14 0 00 000000 	C54600:	MOVEI	14,0		;PRELOAD AC WITH 0
 35214	052271	364 14 0 00 052273 		SOJA	14,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35215									;AND JUMP
 35216						STOP^
 35217	052272	254 04 0 00 052273 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35218	052273	324 00 0 00 052274 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35219									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35220									;IN THE SUBTEST) TO LOOP ON ERROR^
 35221	052274	312 14 0 00 070254 		CAME	14,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35222						STOP^
 35223	052275	254 04 0 00 052276 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35224	052276	324 00 0 00 052277 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35225									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35226									;IN THE SUBTEST) TO LOOP ON ERROR^
 35227
 35228					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 74
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35229					;THIS TEST VERIFIES THAT SOJA DECREMENTS C(AC) BY 0,,1 AND
 35230					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35231					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 35232					;SPECIFIED BY E
 35233					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJA
 35234					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35235
 35236	052277	201 14 0 00 000001 	C54610:	MOVEI	14,1		;PRELOAD AC WITH 0,,1
 35237	052300	364 14 0 00 052302 		SOJA	14,.+2		;*SOJA SHOULD SUBTRACT 0,,1 FROM C(AC)
 35238									;AND JUMP
 35239						STOP^
 35240	052301	254 04 0 00 052302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35241	052302	324 00 0 00 052303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35242									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35243									;IN THE SUBTEST) TO LOOP ON ERROR^
 35244	052303	312 14 0 00 070253 		CAME	14,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35245						STOP^
 35246	052304	254 04 0 00 052305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35247	052305	324 00 0 00 052306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35248									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35249									;IN THE SUBTEST) TO LOOP ON ERROR^
 35250
 35251					;**********
 35252
 35253					;THIS TEST VERIFIES THAT SOJA DECREMENTS C(AC) BY 0,,1 AND
 35254					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35255					;COMPARED TO 0 AND THE PROGRAM ALWAYS JUMPS TO THE LOCATION
 35256					;SPECIFIED BY E
 35257					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJA
 35258					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1
 35259
 35260	052306	201 14 0 00 000002 	C54620:	MOVEI	14,2		;PRELOAD AC WITH 0,,2
 35261	052307	364 14 0 00 052311 		SOJA	14,.+2		;*SOJA SHOULD SUBTRACT 0,,1 FROM C(AC)
 35262									;AND JUMP
 35263						STOP^
 35264	052310	254 04 0 00 052311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35265	052311	324 00 0 00 052312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35267									;IN THE SUBTEST) TO LOOP ON ERROR^
 35268	052312	312 14 0 00 070265 		CAME	14,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35269						STOP^
 35270	052313	254 04 0 00 052314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35271	052314	324 00 0 00 052315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35273									;IN THE SUBTEST) TO LOOP ON ERROR^
 35274
 35275					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 75
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35276					;THIS TEST VERIFIES THAT SOJGE DECREMENTS C(AC) BY 0,,1 AND
 35277					;PLACES THE RESULT BACK INTO THE AC.  THE  RESULT IN THE AC IS
 35278					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35279					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 35280					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE, SOJGE
 35281					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1
 35282
 35283	052315	201 13 0 00 000000 	C54700:	MOVEI	13,0		;PRELOAD A C WITH 0
 35284	052316	365 13 0 00 052320 		SOJGE	13,.+2		;*SOJGE SHOULD SUBTRACT 0,,1 FROM C(AC)
 35285									;AND NOT JUMP
 35286	052317	334 00 0 00 000000 		SKIPA			;PASS IF SOJGE DID NOT JUMP
 35287						STOP^
 35288	052320	254 04 0 00 052321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35289	052321	324 00 0 00 052322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35290									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35291									;IN THE SUBTEST) TO LOOP ON ERROR^
 35292	052322	312 13 0 00 070254 		CAME	13,[-1]	;PASS IF C(AC) DECREMENTED CORRECTLY
 35293						STOP^
 35294	052323	254 04 0 00 052324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35295	052324	324 00 0 00 052325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35296									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35297									;IN THE SUBTEST) TO LOOP ON ERROR^
 35298
 35299					;**********
 35300
 35301					;THIS TEST VERIFIES THAT SOJGE DECREMENTS C(AC) BY 0,,1 AND
 35302					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35303					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35304					;SPECIFIED BY E IF C(AC) IS GREATER THAN OR EQUAL TO 0
 35305					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJGE
 35306					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0
 35307
 35308	052325	201 13 0 00 000001 	C54710:	MOVEI	13,1		;PRELOAD AC WITH 0,,1
 35309	052326	365 13 0 00 052330 		SOJGE	13,.+2		;*SOJ SHOULD SUBTRACT 0,,1 FROM C(AC)
 35310									;AND JUMP
 35311						STOP^
 35312	052327	254 04 0 00 052330 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35313	052330	324 00 0 00 052331 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35314									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35315									;IN THE SUBTEST) TO LOOP ON ERROR^
 35316	052331	312 13 0 00 070253 		CAME	13,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35317						STOP^
 35318	052332	254 04 0 00 052333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35319	052333	324 00 0 00 052334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35320									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35321									;IN THE SUBTEST) TO LOOP ON ERROR^
 35322
 35323					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35324					;THIS TEST VERIRIES THAT SOJGE DECREMENTS C(AC) BY 0,,1 AND PLACES THE
 35325					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS COMPARED
 35326					;TO 0 AND THE PROGRAM JUMPS TO THE LOCATION SPECIFIED BY E IF C(AC IS
 35327					;GREATER THAN OR EQUAL TO 0.  IN THIS CASE, C(AC = 0,,2 BEFORE
 35328					;DECREMENTING.  HENCE, SOJGE SHOULD JUMP AND THE RESULT IN THE AC SHOULD
 35329					;BE 0,,1.
 35330
 35331	052334	201 13 0 00 000002 	C54720:	MOVEI	13,2		;PRELOAD AC WITH 0,,2
 35332	052335	365 13 0 00 052337 		SOJGE	13,.+2		;*SOJGE SHOULD SUBTRACT0,,1 FROM C(AC)
 35333									;AND JUMP.
 35334						STOP^
 35335	052336	254 04 0 00 052337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35336	052337	324 00 0 00 052340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35338									;IN THE SUBTEST) TO LOOP ON ERROR^
 35339	052340	312 13 0 00 070265 		CAME	13,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35340						STOP^
 35341	052341	254 04 0 00 052342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35342	052342	324 00 0 00 052343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35344									;IN THE SUBTEST) TO LOOP ON ERROR^
 35345
 35346					;**********
 35347
 35348					;THIS TEST VERIFIES THAT SOJN DECREMENTS C(AC) BY 0,,1 AND
 35349					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35350					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION 
 35351					;SPECIFIED BY E IF C(AC) IS NON-ZERO.
 35352					;IN THIS CASE, C(AC)=0 BEFORE DECREMENTING.  HENCE,SOJN
 35353					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1.
 35354
 35355	052343	201 12 0 00 000000 	C55000:	MOVEI	12,0		;PRELOAD AC WITH 0
 35356	052344	366 12 0 00 052346 		SOJN	12,.+2		;*SOJN SHOULD SUBTRACT 0,,1 FROM C(AC)
 35357									;AND JUMP.
 35358						STOP^
 35359	052345	254 04 0 00 052346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35360	052346	324 00 0 00 052347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35362									;IN THE SUBTEST) TO LOOP ON ERROR^
 35363	052347	312 12 0 00 070254 		CAME	12,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35364						STOP^
 35365	052350	254 04 0 00 052351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35366	052351	324 00 0 00 052352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35367									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35368									;IN THE SUBTEST) TO LOOP ON ERROR^
 35369
 35370					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 77
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35371					;THIS TEST VERIRIES THAT SOJN DECREMENTS C(AC) BY 0,,1 AND
 35372					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35373					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION SPECIFIED
 35374					;BY E IF C(AC) IS NON-ZERO.
 35375					;IN THIS CASE, C(AC) = 0,,1 BEFORE DECREMENTING.  HENCE, SOJN
 35376					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0.
 35377
 35378	052352	201 12 0 00 000001 	C55010:	MOVEI	12,1		;PRELOAD AC WITH 0,,1
 35379	052353	366 12 0 00 052355 		SOJN	12,.+2		;*SOJN SHOULD SUBTRACT 0,,1 FROM C(AC)
 35380									;AND NOT JUMP.
 35381	052354	334 00 0 00 000000 		SKIPA			;PASS IF SOJN DID NOT JUMP
 35382						STOP^
 35383	052355	254 04 0 00 052356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35384	052356	324 00 0 00 052357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35386									;IN THE SUBTEST) TO LOOP ON ERROR^
 35387	052357	312 12 0 00 070253 		CAME	12,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35388						STOP^
 35389	052360	254 04 0 00 052361 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35390	052361	324 00 0 00 052362 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35391									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35392									;IN THE SUBTEST) TO LOOP ON ERROR^
 35393
 35394					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35395					;THIS TEST VERIFIES THAT SOJN DECREMENTS C(AC) BY 0,,1 AND
 35396					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35397					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35398					;SPECIFIED BY E IF C(AC) IS NON-ZERO.
 35399					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJN
 35400					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1.
 35401
 35402	052362	201 12 0 00 000002 	C55020:	MOVEI	12,2		;PRELOAD AC WITH 0,,2
 35403	052363	366 12 0 00 052365 		SOJN	12,.+2		;*SOJN SHOULD SUBTRACT 0,,1 FROM C(AC)
 35404									;AND JUMP.
 35405						STOP^
 35406	052364	254 04 0 00 052365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35407	052365	324 00 0 00 052366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35409									;IN THE SUBTEST) TO LOOP ON ERROR^
 35410	052366	312 12 0 00 070265 		CAME	12,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35411						STOP^
 35412	052367	254 04 0 00 052370 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35413	052370	324 00 0 00 052371 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35414									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35415									;IN THE SUBTEST) TO LOOP ON ERROR^
 35416
 35417					;**********
 35418
 35419					;THIS TEST VERIFIES THAT SOJG DECREMENTS C(AC) BY 0,,1 AND
 35420					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35421					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35422					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 35423					;IN THIS CASE, C(AC) = 0 BEFORE DECREMENTING.  HENCE, SOJG
 35424					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE -1,,-1.
 35425
 35426	052371	201 11 0 00 000000 	C55100:	MOVEI	11,0		;PRELOAD AC WITH 0
 35427	052372	367 11 0 00 052374 		SOJG	11,.+2		;*SOJG SHOULD SUBTRACT 0,,1 FROM C(AC)
 35428									;AND NOT JUMP.
 35429	052373	334 00 0 00 000000 		SKIPA			;PASS IF SOJG DID NOT JUMP
 35430						STOP^
 35431	052374	254 04 0 00 052375 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35432	052375	324 00 0 00 052376 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35433									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35434									;IN THE SUBTEST) TO LOOP ON ERROR^
 35435	052376	312 11 0 00 070254 		CAME	11,[-1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35436						STOP^
 35437	052377	254 04 0 00 052400 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35438	052400	324 00 0 00 052401 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35439									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35440									;IN THE SUBTEST) TO LOOP ON ERROR^
 35441
 35442					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 79
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOJX INSTRUCTIONS

 35443					;THIS TEST VERIRIES THAT SOJG DECREMENTS C(AC) BY 0,,1 AND
 35444					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35445					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35446					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 35447					;IN THIS CASE, C(AC)=0,,1 BEFORE DECREMENTING.  HENCE, SOJG
 35448					;SHOULD NOT JUMP AND THE RESULT IN THE AC SHOULD BE 0.
 35449
 35450	052401	201 11 0 00 000001 	C55110:	MOVEI	11,1		;PRELOAD AC WITH 0,,1
 35451	052402	367 11 0 00 052404 		SOJG	11,.+2		;*SOJG SHOULD SUBTRACT 0,,1 FROM C(AC)
 35452									;AND NOT JUMP.
 35453	052403	334 00 0 00 000000 		SKIPA			;PASS IF SOJG DID NOT JUMP
 35454						STOP^
 35455	052404	254 04 0 00 052405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35456	052405	324 00 0 00 052406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35457									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35458									;IN THE SUBTEST) TO LOOP ON ERROR^
 35459	052406	312 11 0 00 070253 		CAME	11,[0]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35460						STOP^
 35461	052407	254 04 0 00 052410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35462	052410	324 00 0 00 052411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35464									;IN THE SUBTEST) TO LOOP ON ERROR^
 35465
 35466					;**********
 35467
 35468					;THIS TEST VERIFIES THAT SOJG DECREMENTS C(AC) BY 0,,1 AND
 35469					;PLACES THE RESULT BACK INTO THE AC.  THE RESULT IN THE AC IS
 35470					;COMPARED TO 0 AND THE PROGRAM JUMPS TO THE LOCATION
 35471					;SPECIFIED BY E IF C(AC) IS GREATER THAN 0.
 35472					;IN THIS CASE, C(AC)=0,,2 BEFORE DECREMENTING.  HENCE, SOJG
 35473					;SHOULD JUMP AND THE RESULT IN THE AC SHOULD BE 0,,1.
 35474
 35475	052411	201 11 0 00 000002 	C55120:	MOVEI	11,2		;PRELOAD AC WITH 0,,2
 35476	052412	367 11 0 00 052414 		SOJG	11,.+2		;*SOJG SHOULD SUBTRACT O,,1 FROM C(AC)
 35477									;AND JUMP.
 35478						STOP^
 35479	052413	254 04 0 00 052414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35480	052414	324 00 0 00 052415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35481									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35482									;IN THE SUBTEST) TO LOOP ON ERROR^
 35483	052415	312 11 0 00 070265 		CAME	11,[1]		;PASS IF C(AC) DECREMENTED CORRECTLY
 35484						STOP^
 35485	052416	254 04 0 00 052417 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35486	052417	324 00 0 00 052420 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35487									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35488									;IN THE SUBTEST) TO LOOP ON ERROR^
 35489
 35490					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 80
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35491					SUBTTL	TEST OF MSCL SOSX INSTRUCTIONS
 35492
 35493					;**********
 35494
 35495					;THIS TEST VERIFIES THAT SOSL DECREMENTS C(E) BY 0,,1 AND PLACES
 35496					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35497					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35498					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35499					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0
 35500					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD SKIP; AND THE
 35501					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND -1,,-1
 35502					;RESPECTIVELY.
 35503
 35504	052420	200 00 0 00 070332 	C55200:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35505	052421	201 01 0 00 000000 		MOVEI	1,0		;PRELOAD E WITH 0
 35506	052422	371 00 0 00 000001 		SOSL	0,1		;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E)
 35507									;AND SKIP
 35508						STOP^
 35509	052423	254 04 0 00 052424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35510	052424	324 00 0 00 052425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35512									;IN THE SUBTEST) TO LOOP ON ERROR^
 35513	052425	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35514						STOP^
 35515	052426	254 04 0 00 052427 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35516	052427	324 00 0 00 052430 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35518									;IN THE SUBTEST) TO LOOP ON ERROR^
 35519	052430	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF C(AC) WAS NOT MODIFIED
 35520						STOP^
 35521	052431	254 04 0 00 052432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35522	052432	324 00 0 00 052433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35523									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35524									;IN THE SUBTEST) TO LOOP ON ERROR^
 35525
 35526					;**********
 35527
 35528					;THIS TEST VERIFIES THAT SOSL DECREMENTS C(E) BY 0,,1 AND PLACES
 35529					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35530					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35531					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35532					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0,,1
 35533					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD NOT SKIP; AND THE
 35534					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 35535					;RESPECTIVELY.
 35536
 35537	052433	200 00 0 00 070332 	C55210:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35538	052434	201 01 0 00 000001 		MOVEI	1,1		;PRELOAD E WITH 0,,1
 35539	052435	371 00 0 00 000001 		SOSL	0,1		;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E),
 35540									;AND NOT SKIP.
 35541	052436	334 00 0 00 000000 		SKIPA			;PASS IF SOSL DID NOT SKIP
 35542						STOP^
 35543	052437	254 04 0 00 052440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35544	052440	324 00 0 00 052441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35545									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 80-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35546									;IN THE SUBTEST) TO LOOP ON ERROR^
 35547	052441	312 01 0 00 070253 		CAME	1,[0]		;PASS IF E DECREMENTED CORRECTLY
 35548						STOP^
 35549	052442	254 04 0 00 052443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35550	052443	324 00 0 00 052444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35551									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35552									;IN THE SUBTEST) TO LOOP ON ERROR^
 35553	052444	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF C(AC) WAS NOT MODIFIED
 35554						STOP^
 35555	052445	254 04 0 00 052446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35556	052446	324 00 0 00 052447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35557									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35558									;IN THE SUBTEST) TO LOOP ON ERROR^
 35559
 35560					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 81
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35561					;THIS TEST VERIFIES THAT SOSL DECREMENTS C(E) BY 0,,1 AND PLACES
 35562					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35563					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35564					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35565					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E)=0,,1
 35566					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD NOT SKIP; AND THE
 35567					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 35568					;RESPECTIVELY.
 35569
 35570	052447	200 00 0 00 070332 	C55211:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35571	052450	201 01 0 00 000001 		MOVEI	1,1		;PRELOAD E WITH 0,,1
 35572	052451	202 01 0 00 052466 		MOVEM	1,E55211
 35573	052452	371 00 0 00 052466 		SOSL	0,E55211	;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E),
 35574									;AND NOT SKIP.
 35575	052453	334 00 0 00 000000 		SKIPA			;PASS IF SOSL DID NOT SKIP
 35576						STOP^
 35577	052454	254 04 0 00 052455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35578	052455	324 00 0 00 052456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35580									;IN THE SUBTEST) TO LOOP ON ERROR^
 35581	052456	200 01 0 00 052466 		MOVE	1,E55211
 35582	052457	312 01 0 00 070253 		CAME	1,[0]		;PASS IF E DECREMENTED CORRECTLY
 35583						STOP^
 35584	052460	254 04 0 00 052461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35585	052461	324 00 0 00 052462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35586									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35587									;IN THE SUBTEST) TO LOOP ON ERROR^
 35588	052462	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF C(AC) WAS NOT MODIFIED
 35589						STOP^
 35590	052463	254 04 0 00 052464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35591	052464	324 00 0 00 052465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35592									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35593									;IN THE SUBTEST) TO LOOP ON ERROR^
 35594
 35595	052465	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 35596	052466	000000	000000		E55211:	0			;TEST WORD MEMORY
 35597
 35598					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 82
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35599					;THIS TEST VERIFIES THAT SOS DECREMENTS C(E) BY 0,,1 AND PLACES
 35600					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35601					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN 0.
 35602					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35603					;IN THIS CASE, AC=0, C(AC)=707070,,707070 AND C(E) 0,,2
 35604					;BEFORE INCREMENTING.  HENCE, SOSL SHOULD NOT SKIP; AND THE
 35605					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0,,1
 35606					;RESPECTIVELY.
 35607
 35608	052467	200 00 0 00 070332 	C55220:	MOVE	0,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35609	052470	201 01 0 00 000002 		MOVEI	1,2		;PRELOAD E WITH 0,,2
 35610	052471	371 00 0 00 000001 		SOSL	0,1		;*SOSL SHOULD SUBTRACT 0,,1 FROM C(E),
 35611									;AND NOT SKIP
 35612
 35613	052472	334 00 0 00 000000 		SKIPA			;PASS IF SOSL DID NOT SKIP
 35614						STOP^
 35615	052473	254 04 0 00 052474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35616	052474	324 00 0 00 052475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35617									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35618									;IN THE SUBTEST) TO LOOP ON ERROR^
 35619	052475	312 01 0 00 070265 		CAME	1,[1]		;PASS IF E DECREMENTED CORRECTLY
 35620						STOP^
 35621	052476	254 04 0 00 052477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35622	052477	324 00 0 00 052500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35623									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35624									;IN THE SUBTEST) TO LOOP ON ERROR^
 35625	052500	312 00 0 00 070332 		CAME	0,[707070,,707070]  ;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35626						STOP^
 35627	052501	254 04 0 00 052502 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35628	052502	324 00 0 00 052503 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35629									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35630									;IN THE SUBTEST) TO LOOP ON ERROR^
 35631
 35632					;**********
 35633
 35634					;THIS TEST VERIFIES THAT SOSE DECREMENTS C(E) BY 0,,1 AND PLACES
 35635					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35636					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 35637					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35638					;IN THIS CASE, AC=10, C(AC)=707070,,707070 AND C(E)=0
 35639					;BEFORE INCREMENTING.  HENCE, SOSE SHOULD NOT SKIP ; AND THE
 35640					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35641					;RESPECTIVELY.
 35642
 35643	052503	200 10 0 00 070332 	C55300:	MOVE	10,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35644	052504	201 11 0 00 000000 		MOVEI	11,0		;PRELOAD E WITH 0
 35645	052505	372 10 0 00 000011 		SOSE	10,11		;*SOSE SHOULD SUBTRACT 0,,1 FROM C(E),
 35646									;UPDATE AC AND NOT SKIP
 35647
 35648	052506	334 00 0 00 000000 		SKIPA			;PASS IF SOSE DID NOT SKIP
 35649						STOP^
 35650	052507	254 04 0 00 052510 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35651	052510	324 00 0 00 052511 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35652									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35653									;IN THE SUBTEST) TO LOOP ON ERROR^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 82-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35654	052511	312 11 0 00 070254 		CAME	11,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35655						STOP^
 35656	052512	254 04 0 00 052513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35657	052513	324 00 0 00 052514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35658									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35659									;IN THE SUBTEST) TO LOOP ON ERROR^
 35660	052514	312 10 0 00 070254 		CAME	10,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35661						STOP^
 35662	052515	254 04 0 00 052516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35663	052516	324 00 0 00 052517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35664									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35665									;IN THE SUBTEST) TO LOOP ON ERROR^
 35666
 35667					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 83
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35668					;THIS TEST VERIFIES THAT SOSE DECREMENTS C(E) BY 0,,1 AND PLACES
 35669					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35670					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0
 35671					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35672					;IN THIS CASE, AC=10, C(AC)=707070,,707070 AND C(E)=0,,1
 35673					;BEFORE INCREMENTING.  HENCE, SOSE SHOULD SKIP ; AND THE
 35674					;FINAL RESULTS IN AC AND E SHOULD BE 707070,,707070 AND 0
 35675					;RESPECTIVELY.
 35676
 35677	052517	200 10 0 00 070332 	C55310:	MOVE	10,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35678	052520	201 11 0 00 000001 		MOVEI	11,1		;PRELOAD E WITH 0,,1
 35679	052521	372 10 0 00 000011 		SOSE	10,11		;*SOS SHOULD SUBTRACT 0,,1 FROM C(E)
 35680									;UPDATE AC AND SKIP
 35681						STOP^
 35682	052522	254 04 0 00 052523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35683	052523	324 00 0 00 052524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35685									;IN THE SUBTEST) TO LOOP ON ERROR^
 35686	052524	312 11 0 00 070253 		CAME	11,[0]		;PASS IF E DECREMENTED CORRECTLY
 35687						STOP^
 35688	052525	254 04 0 00 052526 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35689	052526	324 00 0 00 052527 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35691									;IN THE SUBTEST) TO LOOP ON ERROR^
 35692	052527	312 10 0 00 070253 		CAME	10,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35693						STOP^
 35694	052530	254 04 0 00 052531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35695	052531	324 00 0 00 052532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35696									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35697									;IN THE SUBTEST) TO LOOP ON ERROR^
 35698
 35699					;**********
 35700
 35701					;THIS TEST VERIFIES THAT SOSE DECREMENTS C(E) BY 0,11 AND PLACES
 35702					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35703					;THE NEXT INSTRUCTION IF C(E) IS EQUAL TO 0.
 35704					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35705					;IN THIS CASE, AC=10, C(AC)=707070,,707070 AND C(E)=0,,2
 35706					;BEFORE INCREMENTING. HENCE, SOSE SHOULD NOT SKIP ; AND THE
 35707					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 35708					;RESPECTIVELY.
 35709
 35710	052532	200 10 0 00 070332 	C55320:	MOVE	10,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 35711	052533	201 11 0 00 000002 		MOVEI	11,2		;PRELOAD E WITH 0,,2
 35712	052534	372 10 0 00 000011 		SOSE	10,11		;*SOSE SHOULD SUBTRACT 0,,1 FROM C(E),
 35713									;UPDATE AC AND NOT SKIP
 35714
 35715	052535	334 00 0 00 000000 		SKIPA			;PASS IF SOSE DID NOT SKIP
 35716						STOP^
 35717	052536	254 04 0 00 052537 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35718	052537	324 00 0 00 052540 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35720									;IN THE SUBTEST) TO LOOP ON ERROR^
 35721	052540	312 11 0 00 070265 		CAME	11,[1]		;PASS IF E DECREMENTED CORRECTLY
 35722						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 83-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35723	052541	254 04 0 00 052542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35724	052542	324 00 0 00 052543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35725									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35726									;IN THE SUBTEST) TO LOOP ON ERROR^
 35727	052543	312 10 0 00 070265 		CAME	10,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35728						STOP^
 35729	052544	254 04 0 00 052545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35730	052545	324 00 0 00 052546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35732									;IN THE SUBTEST) TO LOOP ON ERROR^
 35733
 35734					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 84
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35735					;THIS TEST VERIFIES THAT SOSLE DECREMENTS C(E) BY 0,,1 AND PLACES
 35736					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35737					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 35738					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35739					;IN THIS CASE, AC=7, C(AC)=707070,,707070 AND C(E)=0
 35740					;BEFORE INCREMENTING.  HENCE, SOSLE SHOULD SKIP ; AND THE
 35741					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35742					;RESPECTIVELY.
 35743
 35744	052546	200 07 0 00 070332 	C55400:	MOVE	7,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35745	052547	201 10 0 00 000000 		MOVEI	10,0		;PRELOAD E WITH 0
 35746	052550	373 07 0 00 000010 		SOSLE	7,10		;*SOSLE SHOULD SUBTRACT 0,,1 FROM C(E),
 35747									;UPDATE AC AND SKIP
 35748						STOP^
 35749	052551	254 04 0 00 052552 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35750	052552	324 00 0 00 052553 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35751									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35752									;IN THE SUBTEST) TO LOOP ON ERROR^
 35753	052553	312 10 0 00 070254 		CAME	10,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35754						STOP^
 35755	052554	254 04 0 00 052555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35756	052555	324 00 0 00 052556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35757									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35758									;IN THE SUBTEST) TO LOOP ON ERROR^
 35759	052556	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35760						STOP^
 35761	052557	254 04 0 00 052560 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35762	052560	324 00 0 00 052561 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35763									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35764									;IN THE SUBTEST) TO LOOP ON ERROR^
 35765
 35766					;**********
 35767
 35768					;THIS TEST VERIFIES THAT SOSLE DECREMENTS C(E) BY 0,,1 AND PLACES
 35769					;THE RESULT INTO E. THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35770					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 35771					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35772					;IN THIS CASE, AC=7, C(AC)=070707,,070707 AND C(E)=0,,1
 35773					;BEFORE INCREMENTING.  HENCE, SOSLE SHOULD SKIP ; AND THE
 35774					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 35775					;RESPECTIVELY.
 35776
 35777	052561	200 07 0 00 070332 	C55410:	MOVE	7,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 35778	052562	201 10 0 00 000001 		MOVEI	10,1		;PRELOAD E WITH 0,,1
 35779	052563	373 07 0 00 000010 		SOSLE	7,10		;*SOSLE SHOULD SUBTRACT 0,,1 FROM C(E),
 35780									;UPDATE AC AND SKIP
 35781						STOP^
 35782	052564	254 04 0 00 052565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35783	052565	324 00 0 00 052566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35784									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35785									;IN THE SUBTEST) TO LOOP ON ERROR^
 35786	052566	312 10 0 00 070253 		CAME	10,[0]		;PASS IF E DECREMENTED CORRECTLY
 35787						STOP^
 35788	052567	254 04 0 00 052570 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35789	052570	324 00 0 00 052571 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 84-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35790									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35791									;IN THE SUBTEST) TO LOOP ON ERROR^
 35792	052571	312 07 0 00 070253 		CAME	7,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35793						STOP^
 35794	052572	254 04 0 00 052573 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35795	052573	324 00 0 00 052574 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35796									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35797									;IN THE SUBTEST) TO LOOP ON ERROR^
 35798
 35799					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 85
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35800					;THIS TEST VERIFIES THAT SOSLE DECREMENTS C(E) BY 0,,1 AND PLACES
 35801					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35802					;THE NEXT INSTRUCTION IF C(E) IS LESS THAN OR EQUAL TO 0.
 35803					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35804					;IN THIS CASE, AC=7, C(AC)=707070,,707070 AND C(E)=0,,2
 35805					;BEFORE INCREMENTING.  HENCE, SOSLE SHOULD NOT SKIP; AND THE
 35806					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 35807					;RESPECTIVELY.
 35808
 35809	052574	200 07 0 00 070332 	C55420:	MOVE	7,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35810	052575	201 10 0 00 000002 		MOVEI	10,2		;PRELOAD E WITH 0,,2
 35811	052576	373 07 0 00 000010 		SOSLE	7,10		;*SOSLE SHOULD SUBTRACT 0,,1 FROM C(E),
 35812									;UPDATE AC AND NOT SKIP
 35813	052577	334 00 0 00 000000 		SKIPA			;PASS IF SOSLE DID NOT SKIP
 35814						STOP^
 35815	052600	254 04 0 00 052601 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35816	052601	324 00 0 00 052602 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35817									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35818									;IN THE SUBTEST) TO LOOP ON ERROR^
 35819	052602	312 10 0 00 070265 		CAME	10,[1]		;PASS IF E DECREMENTED CORRECTLY
 35820						STOP^
 35821	052603	254 04 0 00 052604 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35822	052604	324 00 0 00 052605 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35823									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35824									;IN THE SUBTEST) TO LOOP ON ERROR^
 35825	052605	312 07 0 00 070265 		CAME	7,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35826						STOP^
 35827	052606	254 04 0 00 052607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35828	052607	324 00 0 00 052610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35829									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35830									;IN THE SUBTEST) TO LOOP ON ERROR^
 35831
 35832					;**********
 35833
 35834					;THIS TEST VERIFIES THAT SOSA DECREMENTS C(E) BY 0,,1 AND PLACES
 35835					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 35836					;THE NEXT INSTRUCTION.
 35837					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35838					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0
 35839					;BEFORE INCREMENTING. HENCE, SOSA SHOULD SKIP ; AND THE
 35840					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35841					;RESPECTIVELY.
 35842
 35843	052610	200 06 0 00 070332 	C55500:	MOVE	6,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35844	052611	201 07 0 00 000000 		MOVEI	7,0		;PRELOAD E WITH 0
 35845	052612	374 06 0 00 000007 		SOSA	6,7		;*SOSA SHOULD SUBTRACT 0,,1 FROM C(E),
 35846									;UPDATE AC AND SKIP
 35847						STOP^
 35848	052613	254 04 0 00 052614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35849	052614	324 00 0 00 052615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35850									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35851									;IN THE SUBTEST) TO LOOP ON ERROR^
 35852	052615	312 07 0 00 070254 		CAME	7,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35853						STOP^
 35854	052616	254 04 0 00 052617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 85-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35855	052617	324 00 0 00 052620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35856									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35857									;IN THE SUBTEST) TO LOOP ON ERROR^
 35858	052620	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35859						STOP^
 35860	052621	254 04 0 00 052622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35861	052622	324 00 0 00 052623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35862									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35863									;IN THE SUBTEST) TO LOOP ON ERROR^
 35864
 35865					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35866					;THIS TEST VERIFIES THAT SOSA DECREMENTS C(E) BY 0,,1 AND PLACES
 35867					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 35868					;THE NEXT INSTRUCTION.
 35869					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THEAC.
 35870					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0,,1
 35871					;BEFORE INCREMENTING.  HENCE, SOSA SHOULD BE 0 AND 0
 35872					;RESPECTIVELY.
 35873
 35874	052623	200 06 0 00 070332 	C55510:	MOVE	6,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35875	052624	201 07 0 00 000001 		MOVEI	7,1		;PRELOAD E WITH 0,,1
 35876	052625	374 06 0 00 000007 		SOSA	6,7		;*SOSA SHOULD SUBTRACT 0,,1 FROM C(E),
 35877									;UPDATE AC AND SKIP
 35878						STOP^
 35879	052626	254 04 0 00 052627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35880	052627	324 00 0 00 052630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35881									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35882									;IN THE SUBTEST) TO LOOP ON ERROR^
 35883	052630	312 07 0 00 070253 		CAME	7,[0]		;PASS IF E DECREMENTED CORRECTLY
 35884						STOP^
 35885	052631	254 04 0 00 052632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35886	052632	324 00 0 00 052633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35887									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35888									;IN THE SUBTEST) TO LOOP ON ERROR^
 35889	052633	312 06 0 00 070253 		CAME	6,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35890						STOP^
 35891	052634	254 04 0 00 052635 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35892	052635	324 00 0 00 052636 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35893									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35894									;IN THE SUBTEST) TO LOOP ON ERROR^
 35895
 35896					;**********
 35897
 35898					;THIS TEST VERIFIES THAT SOSA DECREMENTS C(E) BY 0,,1 AND PLACES
 35899					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND ALWAYS SKIPS
 35900					;THE NEXT INSTRUCTION.
 35901					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35902					;IN THIS CASE, AC=6, C(AC)=707070,,707070 AND C(E)=0,,2
 35903					;BEFORE INCREMENTING.  HENCE, SOSA SHOULD SKIP ; AND THE
 35904					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 35905					;RESPECTIVELY.
 35906
 35907	052636	200 06 0 00 070332 	C55520:	MOVE	6,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 35908	052637	201 07 0 00 000002 		MOVEI	7,2		;PRELOAD E WITH 0,,2
 35909	052640	374 06 0 00 000007 		SOSA	6,7		;*SOSA SHOULD SUBTRACT 0,,1 FROM C(E),
 35910									;UPDATE AC AND SKIP
 35911						STOP^
 35912	052641	254 04 0 00 052642 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35913	052642	324 00 0 00 052643 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35914									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35915									;IN THE SUBTEST) TO LOOP ON ERROR^
 35916	052643	312 07 0 00 070265 		CAME	7,[1]		;PASS IF E DECREMENTED CORRECTLY
 35917						STOP^
 35918	052644	254 04 0 00 052645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35919	052645	324 00 0 00 052646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35920									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35921									;IN THE SUBTEST) TO LOOP ON ERROR^
 35922	052646	312 06 0 00 070265 		CAME	6,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35923						STOP^
 35924	052647	254 04 0 00 052650 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35925	052650	324 00 0 00 052651 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35927									;IN THE SUBTEST) TO LOOP ON ERROR^
 35928
 35929					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35930					;THIS TEST VERIFIES THAT SOSGE DECREMENTS C(E) BY 0,,1 AND PLACES
 35931					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35932					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0.
 35933					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35934					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=0
 35935					;BEFORE INCREMENTING.  HENCE, SOSGE SHOULD NOT SKIP ; AND THE
 35936					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 35937					;RESPECTIVELY.
 35938
 35939	052651	200 05 0 00 070332 	C55600:	MOVE	5,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35940	052652	201 06 0 00 000000 		MOVEI	6,0		;PRELOAD E WITH 0
 35941	052653	375 05 0 00 000006 		SOSGE	5,6		;*SOSGE SHOULD SUBTRACT 0,,1 FROM C(E),
 35942									;UPDATE AC AND NOT SKIP
 35943	052654	334 00 0 00 000000 		SKIPA			;PASS IF SOSGE DID NOT SKIP
 35944						STOP^
 35945	052655	254 04 0 00 052656 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35946	052656	324 00 0 00 052657 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35947									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35948									;IN THE SUBTEST) TO LOOP ON ERROR^
 35949	052657	312 06 0 00 070254 		CAME	6,[-1]		;PASS IF E DECREMENTED CORRECTLY
 35950						STOP^
 35951	052660	254 04 0 00 052661 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35952	052661	324 00 0 00 052662 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35953									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35954									;IN THE SUBTEST) TO LOOP ON ERROR^
 35955	052662	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35956						STOP^
 35957	052663	254 04 0 00 052664 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35958	052664	324 00 0 00 052665 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35959									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35960									;IN THE SUBTEST) TO LOOP ON ERROR^
 35961
 35962					;**********
 35963
 35964					;THIS TEST VERIFIES THAT SOSGE DECREMENTS C(E) BY 0,,1 AND PLACES
 35965					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35966					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0.
 35967					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 35968					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=0,,1
 35969					;BEFORE INCREMENTING.  HENCE, SOSGE SHOULD SKIP ; AND THE
 35970					;FINAL RESULTS IN ACAND E SHOULD BE 0 AND 0
 35971					;RESPECTIVELY.
 35972
 35973	052665	200 05 0 00 070332 	C55610:	MOVE	5,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 35974	052666	201 06 0 00 000001 		MOVEI	6,1		;PRELOAD E WITH 0,,1
 35975	052667	375 05 0 00 000006 		SOSGE	5,6		;*SOSGE SHOULD SUBTRACT 0,,1 FROM C(E),
 35976									;UPDATE AC AND SKIP
 35977						STOP^
 35978	052670	254 04 0 00 052671 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35979	052671	324 00 0 00 052672 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35980									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35981									;IN THE SUBTEST) TO LOOP ON ERROR^
 35982	052672	312 06 0 00 070253 		CAME	6,[0]		;PASS IF E DECREMENTED CORRECTLY
 35983						STOP^
 35984	052673	254 04 0 00 052674 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35985	052674	324 00 0 00 052675 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35987									;IN THE SUBTEST) TO LOOP ON ERROR^
 35988	052675	312 05 0 00 070253 		CAME	5,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 35989						STOP^
 35990	052676	254 04 0 00 052677 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 35991	052677	324 00 0 00 052700 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 35992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 35993									;IN THE SUBTEST) TO LOOP ON ERROR^
 35994
 35995					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 35996					;THIS TEST VERIFIES THAT SOSGE DECREMENTS C(E) BY 0,,1 AND PLACES
 35997					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 35998					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN OR EQUAL TO 0
 35999					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36000					;IN THIS CASE, AC=5, C(AC)=707070,,707070 AND C(E)=0,,2
 36001					;BEFORE INCREMENTING.  HENCE, SOSGE SHOULD SKIP ; AND THE
 36002					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 36003					;RESPECTIVELY.
 36004
 36005	052700	200 05 0 00 070332 	C55620:	MOVE	5,[707070,,707070] ;PRELOAD AC WITH 707070,,707070
 36006	052701	201 06 0 00 000002 		MOVEI	6,2		;PRELOAD E WITH 0,,2
 36007	052702	375 05 0 00 000006 		SOSGE	5,6		;*SOSGE SHOULD SUBTRACT 0,,1 FROM C(E),
 36008									;UPDATE AC AND SKIP
 36009						STOP^
 36010	052703	254 04 0 00 052704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36011	052704	324 00 0 00 052705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36013									;IN THE SUBTEST) TO LOOP ON ERROR^
 36014	052705	312 06 0 00 070265 		CAME	6,[1]		;PASS IF E DECREMENTED CORRECTLY
 36015						STOP^
 36016	052706	254 04 0 00 052707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36017	052707	324 00 0 00 052710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36018									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36019									;IN THE SUBTEST) TO LOOP ON ERROR^
 36020	052710	312 05 0 00 070265 		CAME	5,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36021						STOP^
 36022	052711	254 04 0 00 052712 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36023	052712	324 00 0 00 052713 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36025									;IN THE SUBTEST) TO LOOP ON ERROR^
 36026
 36027					;**********
 36028
 36029					;THIS TEST VERIFIES SOSN DECREMENTS C(E) BY 0,,1 AND PLACES
 36030					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36031					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 36032					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36033					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0
 36034					;BEFORE INCREMENTING.  HENCE, SOSN SHOULD SKIP ; AND THE
 36035					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 36036					;RESPECTIVELY.
 36037
 36038	052713	200 04 0 00 070332 	C55700:	MOVE	4,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36039	052714	201 05 0 00 000000 		MOVEI	5,0		;PRELOAD E WITH 0
 36040	052715	376 04 0 00 000005 		SOSN	4,5		;*SOSN SHOULD SUBTRACT 0,,1 FROM C(E),
 36041									;UPDATE AC AND SKIP
 36042						STOP^
 36043	052716	254 04 0 00 052717 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36044	052717	324 00 0 00 052720 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36045									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36046									;IN THE SUBTEST) TO LOOP ON ERROR^
 36047	052720	312 05 0 00 070254 		CAME	5,[-1]		;PASS IF E DECREMENTED CORRECTLY
 36048						STOP^
 36049	052721	254 04 0 00 052722 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36050	052722	324 00 0 00 052723 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 36051									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36052									;IN THE SUBTEST) TO LOOP ON ERROR^
 36053	052723	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36054						STOP^
 36055	052724	254 04 0 00 052725 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36056	052725	324 00 0 00 052726 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36058									;IN THE SUBTEST) TO LOOP ON ERROR^
 36059
 36060					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 36061					;THIS TEST VERIFIES THAT SOSN DECREMENTS C(E) BY 0,,1 AND PLACES
 36062					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36063					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 36064					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC
 36065					;IN THIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0,,1
 36066					;BEFORE INCREMENTING.  HENCE, SOSN SHOULD NOT SKIP ; AND THE
 36067					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 36068					;RESPECTIVELY.
 36069
 36070	052726	200 04 0 00 070332 	C55710:	MOVE	4,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36071	052727	201 05 0 00 000001 		MOVEI	5,1		;PRELOAD E WITH 0,,1
 36072	052730	376 04 0 00 000005 		SOSN	4,5		;*SOSN SHOULD SUBTRACT 0,,1 FROM C(E),
 36073									;UPDATE AC AND NOT SKIP
 36074	052731	334 00 0 00 000000 		SKIPA			;PASS IF SOSN DID NOT SKIP
 36075						STOP^
 36076	052732	254 04 0 00 052733 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36077	052733	324 00 0 00 052734 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36078									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36079									;IN THE SUBTEST) TO LOOP ON ERROR^
 36080	052734	312 05 0 00 070253 		CAME	5,[0]		;PASS IF E DECREMENTED CORRECTLY
 36081						STOP^
 36082	052735	254 04 0 00 052736 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36083	052736	324 00 0 00 052737 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36084									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36085									;IN THE SUBTEST) TO LOOP ON ERROR^
 36086	052737	312 04 0 00 070253 		CAME	4,[0]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36087						STOP^
 36088	052740	254 04 0 00 052741 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36089	052741	324 00 0 00 052742 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36090									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36091									;IN THE SUBTEST) TO LOOP ON ERROR^
 36092
 36093					;**********
 36094
 36095					;THIS TEST VERIFIES THAT SOSN DECREMENTS C(E) BY 0,,1 AND PLACES
 36096					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36097					;THE NEXT INSTRUCTION IF C(E) IS NON-ZERO
 36098					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36099					;INtTHIS CASE, AC=4, C(AC)=707070,,707070 AND C(E)=0,,2
 36100					;BEFORE INCREMENTING.  HENCE, SOSN SHOULD SKIP ; AND THE
 36101					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 0,,1
 36102					;RESPECTIVELY
 36103
 36104	052742	200 04 0 00 070332 	C55720:	MOVE	4,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36105	052743	201 05 0 00 000002 		MOVEI	5,2		;PRELOAD E WITH 0,,2
 36106	052744	376 04 0 00 000005 		SOSN	4,5		;*SOSN SHOULD SUBTRACT 0,,1 FROM C(E),
 36107									;UPDATE AC AND SKIP
 36108						STOP^
 36109	052745	254 04 0 00 052746 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36110	052746	324 00 0 00 052747 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36111									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36112									;IN THE SUBTEST) TO LOOP ON ERROR^
 36113	052747	312 05 0 00 070265 		CAME	5,[1]		;PASS IF E DECREMENTED CORRECTLY
 36114						STOP^
 36115	052750	254 04 0 00 052751 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 36116	052751	324 00 0 00 052752 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36118									;IN THE SUBTEST) TO LOOP ON ERROR^
 36119	052752	312 04 0 00 070265 		CAME	4,[1]		;PASS IF ACWAS UPDATED IF AC NON-ZERO
 36120						STOP^
 36121	052753	254 04 0 00 052754 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36122	052754	324 00 0 00 052755 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36123									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36124									;IN THE SUBTEST) TO LOOP ON ERROR^
 36125
 36126					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 90
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 36127					;THIS TEST VERIFIESTHAT SOSG DECREMENTS C(E) BY 0,,1 AND PLACES
 36128					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36129					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 36130					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36131					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0
 36132					;BEFORE INCREMENTING.  HENCE, SOSG SHOULD NOT SKIP ; AND THE 
 36133					;FINAL RESULTS IN AC AND E SHOULD BE -1,,-1 AND -1,,-1
 36134					;RESPECTIVELY.
 36135
 36136	052755	200 03 0 00 070332 	C56000:	MOVE	3,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36137	052756	201 04 0 00 000000 		MOVEI	4,0		;PRELOAD E WITH 0
 36138	052757	377 03 0 00 000004 		SOSG	3,4		;*SOSG SHOULD SUBTRACT 0,,1 FROM C(E),
 36139									;UPDATE AC AND NOT SKIP
 36140	052760	334 00 0 00 000000 		SKIPA			;PASS IF SOSG DID NOT SKIP
 36141						STOP^
 36142	052761	254 04 0 00 052762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36143	052762	324 00 0 00 052763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36144									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36145									;IN THE SUBTEST) TO LOOP ON ERROR^
 36146	052763	312 04 0 00 070254 		CAME	4,[-1]		;PASS IF E DECREMENTED CORRECTLY
 36147						STOP^
 36148	052764	254 04 0 00 052765 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36149	052765	324 00 0 00 052766 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36150									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36151									;IN THE SUBTEST) TO LOOP ON ERROR^
 36152	052766	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36153						STOP^
 36154	052767	254 04 0 00 052770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36155	052770	324 00 0 00 052771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36157									;IN THE SUBTEST) TO LOOP ON ERROR^
 36158
 36159					;**********
 36160
 36161					;THIS TEST VERIFIES THAT SOSG DECREMENTS C(E) BY 0,,1 AND PLACES
 36162					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36163					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0.
 36164					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36165					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0,,1
 36166					;BEFORE INCREMENTING.  HENCE, SOSG SHOULD NOT SKIP ; AND THE
 36167					;FINAL RESULTS IN AC AND E SHOULD BE 0 AND 0
 36168					;RESPECTIVELY.
 36169
 36170	052771	200 03 0 00 070332 	C56010:	MOVE	3,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36171	052772	201 04 0 00 000001 		MOVEI	4,1		;PRELOAD E WITH 0,,1
 36172	052773	377 03 0 00 000004 		SOSG	3,4		;*SOSG SHOULD SUBTRACT 0,,1 FROM C(E),
 36173									;UPDATE AC AND NOT SKIP
 36174	052774	334 00 0 00 000000 		SKIPA			;PASS IF SOSG DID NOT SKIP
 36175						STOP^
 36176	052775	254 04 0 00 052776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36177	052776	324 00 0 00 052777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36178									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36179									;IN THE SUBTEST) TO LOOP ON ERROR^
 36180	052777	312 04 0 00 070253 		CAME	4,[0]		;PASS IF E DECREMENTED CORRECTLY
 36181						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 90-1
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 36182	053000	254 04 0 00 053001 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36183	053001	324 00 0 00 053002 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36184									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36185									;IN THE SUBTEST) TO LOOP ON ERROR^
 36186	053002	312 03 0 00 070253 		CAME	3,[0]		;PASS IF AC WAS UPDATED IS AC NON-ZERO
 36187						STOP^
 36188	053003	254 04 0 00 053004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36189	053004	324 00 0 00 053005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36190									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36191									;IN THE SUBTEST) TO LOOP ON ERROR^
 36192
 36193					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 91
DFKAA5	MAC	13-Jan-89 10:22		TEST OF MSCL SOSX INSTRUCTIONS

 36194					;THIS TEST VERIFIES THAT SOSG DECREMENTS C(E) BY 0,,1 AND PLACES
 36195					;THE RESULT INTO E.  THE RESULT IN E IS COMPARED TO 0 AND SKIPS
 36196					;THE NEXT INSTRUCTION IF C(E) IS GREATER THAN 0
 36197					;IF THE AC IS NON-ZERO, THE RESULT IS ALSO PLACED INTO THE AC.
 36198					;IN THIS CASE, AC=3, C(AC)=707070,,707070 AND C(E)=0,,2
 36199					;BEFORE INCREMENTING.  HENCE, SOSG SHOULD SKIP ; AND THE
 36200					;FINAL RESULTS IN AC AND E SHOULD BE 0,,1 AND 011,
 36201					;RESPECTIVELY.
 36202
 36203	053005	200 03 0 00 070332 	C56020:	MOVE	3,[707070,,707070]  ;PRELOAD AC WITH 707070,,707070
 36204	053006	201 04 0 00 000002 		MOVEI	4,2		;PRELOAD E WITH 0,,2
 36205	053007	377 03 0 00 000004 		SOSG	3,4		;*SOSG SHOULD SUBTRACT 0,,1 FROM C(E),
 36206									;UPDATE AC AND SKIP
 36207						STOP^
 36208	053010	254 04 0 00 053011 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36209	053011	324 00 0 00 053012 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36211									;IN THE SUBTEST) TO LOOP ON ERROR^
 36212	053012	312 04 0 00 070265 		CAME	4,[1]		;PASS IF E DECREMENTED CORRECTLY
 36213						STOP^
 36214	053013	254 04 0 00 053014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36215	053014	324 00 0 00 053015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36216									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36217									;IN THE SUBTEST) TO LOOP ON ERROR^
 36218	053015	312 03 0 00 070265 		CAME	3,[1]		;PASS IF AC WAS UPDATED IF AC NON-ZERO
 36219						STOP^
 36220	053016	254 04 0 00 053017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36221	053017	324 00 0 00 053020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36223									;IN THE SUBTEST) TO LOOP ON ERROR^
 36224
 36225					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36226					SUBTTL	TEST OF MSCL BOOLEAN INSTRUCTIONS
 36227
 36228					;**********
 36229
 36230					;THIS TEST VERIFIES THAT SETZI CLEARS THE AC AND DOES NOT AFFECT E.
 36231					;FIRST, AC AND E ARE PRELOADED WITH -1,,-1, THEN, SETZI IS EXECUTED.
 36232					;AC IS THEN CHECKED FOR 0 AND E IS CHECKED FOR -1,,-1
 36233
 36234	053020	474 01 0 00 000000 	C56100:	SETO	1,		;PRELOAD AC WITH -1,,-1
 36235	053021	474 02 0 00 000000 		SETO	2,		;PRELOAD E WITH -1,,-1
 36236	053022	401 01 0 00 000002 		SETZI	1,2		;*SETZI SHOULD CLEAR THE AC
 36237	053023	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC)=0
 36238						STOP^
 36239	053024	254 04 0 00 053025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36240	053025	324 00 0 00 053026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36241									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36242									;IN THE SUBTEST) TO LOOP ON ERROR^
 36243	053026	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF C(E)=-1,,-1
 36244						STOP^
 36245	053027	254 04 0 00 053030 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36246	053030	324 00 0 00 053031 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36247									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36248									;IN THE SUBTEST) TO LOOP ON ERROR^
 36249
 36250					;**********
 36251
 36252					;THIS TEST VERIFIES THAT SETZM CLEARS C(E) AND DOES NOT AFFECT C(AC)
 36253					;FIRST, AC AND E ARE PRELOADED WITH -1,,-1; THEN SETZM IS EXECUTED.
 36254					;AC IS THEN CHECKED FOR -1,,-1 AND E IS CHECKED FOR 0.
 36255
 36256	053031	474 01 0 00 000000 	C56200:	SETO	1,		;PRELOAD AC WITH -1,,-1
 36257	053032	474 02 0 00 000000 		SETO	2,		;PRELOAD E WITH -1,,-1
 36258	053033	402 01 0 00 000002 		SETZM	1,2		;*SETZM SHOULD CLEAR E
 36259	053034	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 36260						STOP^
 36261	053035	254 04 0 00 053036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36262	053036	324 00 0 00 053037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36263									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36264									;IN THE SUBTEST) TO LOOP ON ERROR^
 36265	053037	332 00 0 00 000002 		SKIPE	2		;PASS IF C(E)=0
 36266						STOP^
 36267	053040	254 04 0 00 053041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36268	053041	324 00 0 00 053042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36270									;IN THE SUBTEST) TO LOOP ON ERROR^
 36271
 36272					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36273					;THIS TEST VERIFIES THAT SETOI PLACES ALL ONES INTO THE AC.
 36274					;FIRST, THE AC AND E ARE CLEARED; THEN, SETOI IS EXECUTED.
 36275					;AC AND E ARE CHECKED FOR -1,,-1 AND 0 RESPECTIVELY
 36276
 36277	053042	403 01 0 00 000002 	C56300:	SETZB	1,2		;CLEAR AC,E
 36278	053043	475 01 0 00 000002 		SETOI	1,2		;*SETOI SHOULD PLACE -1,,-1 INTO THE AC
 36279	053044	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 36280						STOP^
 36281	053045	254 04 0 00 053046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36282	053046	324 00 0 00 053047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36283									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36284									;IN THE SUBTEST) TO LOOP ON ERROR^
 36285	053047	332 00 0 00 000002 		SKIPE	2		;PASS IF C(E)=0
 36286						STOP^
 36287	053050	254 04 0 00 053051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36288	053051	324 00 0 00 053052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36289									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36290									;IN THE SUBTEST) TO LOOP ON ERROR^
 36291
 36292					;**********
 36293
 36294					;THIS TEST VERIFIES THAT SETOM PLACES ALL ONES INTO E
 36295					;FIRST, THE AC AND E ARE CLEARED, THEN SETOM IS EXECUTED.
 36296					;AC AND E ARE THEN CHECKED FOR 0 AND -1,,-1 RESPECTIVELY.
 36297
 36298	053052	403 01 0 00 000002 	C56400:	SETZB	1,2		;CLEAR AC,E
 36299	053053	476 01 0 00 000002 		SETOM	1,2		;*SETOM SHOULD PLACE -1,,-1 INTO E
 36300	053054	332 00 0 00 000001 		SKIPE	1		;PASS IF C(AC)=0
 36301						STOP^
 36302	053055	254 04 0 00 053056 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36303	053056	324 00 0 00 053057 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36304									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36305									;IN THE SUBTEST) TO LOOP ON ERROR^
 36306	053057	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF C(E)=-1,,-1
 36307						STOP^
 36308	053060	254 04 0 00 053061 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36309	053061	324 00 0 00 053062 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36310									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36311									;IN THE SUBTEST) TO LOOP ON ERROR^
 36312
 36313					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36314					;THIS TEST VERIFIES THAT SETOB PLACES ALL ONES INTO BOTH AC AND E.
 36315					;FIRST, BOTH AC AND E ARE CLEARED; THEN, SETOB IS EXECUTED.
 36316					;AC AND E ARE BOTH CHECKED FOR -1,,-1
 36317
 36318	053062	403 01 0 00 000002 	C56500:	SETZB	1,2		;CLEAR AC,E
 36319	053063	477 01 0 00 000002 		SETOB	1,2		;*SETOB SHOULD PUT -1,,-1 INTO BOTH AC AND E
 36320	053064	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(AC)=-1,,-1
 36321						STOP^
 36322	053065	254 04 0 00 053066 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36323	053066	324 00 0 00 053067 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36324									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36325									;IN THE SUBTEST) TO LOOP ON ERROR^
 36326	053067	312 02 0 00 070254 		CAME	2,[-1]		;PASS IF C(E)=-1,,-1
 36327						STOP^
 36328	053070	254 04 0 00 053071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36329	053071	324 00 0 00 053072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36330									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36331									;IN THE SUBTEST) TO LOOP ON ERROR^
 36332
 36333					;**********
 36334
 36335					;THIS TEST VERIFIES THAT ANDI PLACES THE LOGICAL AND FUNCTION
 36336					;OF C(AC) AND 0,,E INTO THE AC.
 36337					;IN THIS CASE, C(AC)=777000,,707070 AND E=0,,123123.
 36338					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,103103
 36339
 36340	053072	200 01 0 00 070640 	C56600:	MOVE	1,[777000,,707070]	;PRELOAD AC WITH 777000,,707070
 36341	053073	405 01 0 00 123123 		ANDI	1,123123	;*ANDI SHOULD PLACE 0,,103103 INTO THE AC
 36342	053074	302 01 0 00 103020 		CAIE	1,103020	;PASS IF C(AC)=103103
 36343						STOP^
 36344	053075	254 04 0 00 053076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36345	053076	324 00 0 00 053077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36346									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36347									;IN THE SUBTEST) TO LOOP ON ERROR^
 36348
 36349					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36350					;THIS TEST VERIFIES THAT ANDM PLACES THE LOGICAL AND FUNCTION OF
 36351					;C(AC) AND C(E) INTO E.
 36352					;IN THIS CASE, C(AC)=777000,,000777 AND C(E)=123456,,123456.
 36353					;HENCE, THE RESULTS IN AC AND E SHOULD BE 777000,,000777 AND
 36354					;123000,,00456 RESPECTIVELY
 36355
 36356	053077	200 01 0 00 070641 	C56700:	MOVE	1,[777000,,777]	;PRELOAD E WITH 777000,,000777
 36357	053100	200 02 0 00 070637 		MOVE	2,[123456,,123456]	;PRELOAD AC WITH 123456,,123456
 36358	053101	406 02 0 00 000001 		ANDM	2,1		;*ANDM SHOULD PLACE 123000,,000456 INTO E
 36359	053102	312 02 0 00 070637 		CAME	2,[123456,,123456]	;PASS IF C(AC) NOT MODIFIED
 36360						STOP^
 36361	053103	254 04 0 00 053104 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36362	053104	324 00 0 00 053105 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36363									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36364									;IN THE SUBTEST) TO LOOP ON ERROR^
 36365	053105	312 01 0 00 070642 		CAME	1,[123000,,000456]	;PASS IF C(E)=123000,,000456
 36366						STOP^
 36367	053106	254 04 0 00 053107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36368	053107	324 00 0 00 053110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36369									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36370									;IN THE SUBTEST) TO LOOP ON ERROR^
 36371
 36372					;**********
 36373
 36374					;THIS TEST VERIFIES THAT ANDM PLACES THE LOGICAL AND FUNCTION OF
 36375					;C(AC) AND C(E) INTO E.
 36376					;IN THIS CASE, C(AC)=777000,,000777 AND C(E)=123456,,123456.
 36377					;HENCE, THE RESULTS IN AC AND E SHOULD BE 777000,,000777 AND
 36378					;123000,,00456 RESPECTIVELY
 36379
 36380	053110	200 01 0 00 070641 	C56701:	MOVE	1,[777000,,777]	;PRELOAD E WITH 777000,,000777
 36381	053111	202 01 0 00 053124 		MOVEM	1,E56701
 36382	053112	200 02 0 00 070637 		MOVE	2,[123456,,123456]	;PRELOAD AC WITH 123456,,123456
 36383	053113	406 02 0 00 053124 		ANDM	2,E56701	;*ANDM SHOULD PLACE 123000,,000456 INTO E
 36384	053114	312 02 0 00 070637 		CAME	2,[123456,,123456]	;PASS IF C(AC) NOT MODIFIED
 36385						STOP^
 36386	053115	254 04 0 00 053116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36387	053116	324 00 0 00 053117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36388									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36389									;IN THE SUBTEST) TO LOOP ON ERROR^
 36390	053117	200 01 0 00 053124 		MOVE	1,E56701
 36391	053120	312 01 0 00 070642 		CAME	1,[123000,,000456]	;PASS IF C(E)=123000,,000456
 36392						STOP^
 36393	053121	254 04 0 00 053122 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36394	053122	324 00 0 00 053123 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36395									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36396									;IN THE SUBTEST) TO LOOP ON ERROR^
 36397
 36398	053123	334 00 0 00 000000 		SKIPA				;GO TO NEXT TEST
 36399	053124	000000	000000		E56701:	0				;TEST WORD MEMORY
 36400
 36401					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36402					;THIS TEST VERIFIES THAT ANDCB PLACES THE LOGICAL AND FUNCTION OF 
 36403					;C(AC) AND C(E) INTO BOTH AC AND E
 36404					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=121212,,-1
 36405					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 121212,,0,
 36406
 36407	053125	561 03 0 00 000000 	C57000:	HRROI	3,0		;PRELOAD AC WITH -1,,0
 36408	053126	525 06 0 00 121212 		HRLOI	6,121212	;PRELOAD E WITH 121212,,-1
 36409	053127	407 03 0 00 000006 		ANDB	3,6		;*ANDB SHOULD PLACE 121212,,0 INTO BOTH AC AND E
 36410	053130	312 03 0 00 070643 		CAME	3,[121212,,0]	;PASS IF C(AC)=121212,,0
 36411						STOP^
 36412	053131	254 04 0 00 053132 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36413	053132	324 00 0 00 053133 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36414									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36415									;IN THE SUBTEST) TO LOOP ON ERROR^
 36416	053133	312 06 0 00 070643 		CAME	6,[121212,,0]	;PASS IF C(E)=121212,,0
 36417						STOP^
 36418	053134	254 04 0 00 053135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36419	053135	324 00 0 00 053136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36420									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36421									;IN THE SUBTEST) TO LOOP ON ERROR^
 36422
 36423					;**********
 36424
 36425					;THIS TEST VERIFIES THAT ANDCB PLACES THE LOGICAL AND FUNCTION OF 
 36426					;C(AC) AND C(E) INTO BOTH AC AND E
 36427					;IN THIS CASE, C(AC)=-1,,0 AND C(E)=121212,,-1
 36428					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 121212,,0,
 36429
 36430	053136	561 03 0 00 000000 	C57001:	HRROI	3,0		;PRELOAD AC WITH -1,,0
 36431	053137	525 06 0 00 121212 		HRLOI	6,121212	;PRELOAD E WITH 121212,,-1
 36432	053140	202 06 0 00 053152 		MOVEM	6,E57001
 36433	053141	407 03 0 00 053152 		ANDB	3,E57001	;*ANDB SHOULD PLACE 121212,,0 INTO BOTH AC AND E
 36434	053142	312 03 0 00 070643 		CAME	3,[121212,,0]	;PASS IF C(AC)=121212,,0
 36435						STOP^
 36436	053143	254 04 0 00 053144 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36437	053144	324 00 0 00 053145 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36438									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36439									;IN THE SUBTEST) TO LOOP ON ERROR^
 36440	053145	200 06 0 00 053152 		MOVE	6,E57001
 36441	053146	312 06 0 00 070643 		CAME	6,[121212,,0]	;PASS IF C(E)=121212,,0
 36442						STOP^
 36443	053147	254 04 0 00 053150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36444	053150	324 00 0 00 053151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36446									;IN THE SUBTEST) TO LOOP ON ERROR^
 36447
 36448	053151	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 36449	053152	000000	000000		E57001:	0			;TEST WORD MEMORY
 36450
 36451					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36452					;THIS TEST VERIFIES THAT ANDCAI PLACES THE LOGICAL AND FUNCTION
 36453					;OF THE WORD 0,E AND THE COMPLEMENT OF C(AC) INTO THE AC
 36454					;IN THIS CASE, C(AC)=777,000,,707070 AND E=0,135246
 36455					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,030206
 36456
 36457	053153	200 05 0 00 070640 	C57100:	MOVE	5,[777000,,707070]	;PRELOAD AC WITH 777000,,707070
 36458	053154	411 05 0 00 135246 		ANDCAI	5,135246	;*ANDCAI SHOULD PLACE 0,,30206 INTO THE AC
 36459	053155	302 05 0 00 030206 		CAIE	5,030206	;PASS IF C(AC)=030206
 36460						STOP^
 36461	053156	254 04 0 00 053157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36462	053157	324 00 0 00 053160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36464									;IN THE SUBTEST) TO LOOP ON ERROR^
 36465
 36466					;**********
 36467
 36468					;THIS TEST VERIFIES THAT ANDCAM PLACES THE LOGICAL AND FUNCTION OF
 36469					;C(E) AND THE COMPLEMENT OF C(AC) INTO E.
 36470					;IN THIS CASE, C(AC)=000767,,-1 AND C(E)=777350,,-2
 36471					;HENCE, THE RESULTS IN AC AND E SHOULD BE 000767,,-1 AND
 36472					;777010,,0 RESPECTIVELY.
 36473
 36474	053160	525 04 0 00 000767 	C57200:	HRLOI	4,767		;PRELOAD AC WITH 000767,,-1
 36475	053161	200 06 0 00 070644 		MOVE	6,[777350,,-2]	;PRELOAD E WITH 777350,,-2
 36476	053162	412 04 0 00 000006 		ANDCAM	4,6		;*ANDCAM SHOULD PLACE 777010,,0
 36477									;INTO E
 36478	053163	312 04 0 00 070645 		CAME	4,[767,,-1]	;PASS IF C(AC) IS UNCHANGED
 36479						STOP^
 36480	053164	254 04 0 00 053165 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36481	053165	324 00 0 00 053166 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36482									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36483									;IN THE SUBTEST) TO LOOP ON ERROR^
 36484	053166	312 06 0 00 070646 		CAME	6,[777010,,0]	;PASS IF C(E)=777010,,0
 36485						STOP^
 36486	053167	254 04 0 00 053170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36487	053170	324 00 0 00 053171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36488									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36489									;IN THE SUBTEST) TO LOOP ON ERROR^
 36490
 36491					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36492					;THIS TEST VERIFIES THAT ANDCAB PLACES THE LOGICAN AND FUNCTION OF
 36493					;C(E) AND THE COMPLEMENT OF C(AC) INTO BOTH AC AND E.
 36494					;IN THIS CASE, C(AC)=000777,,770077 AND C(E)=123456,246123
 36495					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 123000,,006100
 36496
 36497	053171	200 01 0 00 070647 	C57300:	MOVE	1,[000777,,770077]	;PRELOAD AC WITH 000777,770077
 36498	053172	200 02 0 00 070650 		MOVE	2,[123456,,246123]	;PRELOAD E WITH 123456,246123
 36499	053173	413 01 0 00 000002 		ANDCAB	1,2		;*ANDCAB SHOULD PLACE 123000,006100
 36500									;INTO BOTH AC AND E
 36501	053174	312 01 0 00 070651 		CAME	1,[123000,,006100]	;PASS IF C(AC)=123000,006100
 36502						STOP^
 36503	053175	254 04 0 00 053176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36504	053176	324 00 0 00 053177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36505									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36506									;IN THE SUBTEST) TO LOOP ON ERROR^
 36507	053177	312 02 0 00 070651 		CAME	2,[123000,,006100]	;PASS IF C(E)=123000,006100
 36508						STOP^
 36509	053200	254 04 0 00 053201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36510	053201	324 00 0 00 053202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36512									;IN THE SUBTEST) TO LOOP ON ERROR^
 36513
 36514					;**********
 36515
 36516					;THIS TEST VERIFIES THAT SETMI MOVES THE WORD 0,,E INTO THE AC
 36517					;IN THIS CASE, C(AC)=-1,,-1 AND E=0,,123456.  HENCE, THE RESULT
 36518					;IN THE AC SHOULD BE 0,,123456
 36519
 36520	053202	474 05 0 00 000000 	C57400:	SETO	5,		;PRELOAD AC WITH -1,,-1
 36521	053203	415 05 0 00 123456 		SETMI	5,123456	;*SETMI SHOULD PLACE 0,,123456 INTO THE AC
 36522	053204	302 05 0 00 123456 		CAIE	5,123456	;PASS IF C(AC)=0,123456
 36523						STOP^
 36524	053205	254 04 0 00 053206 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36525	053206	324 00 0 00 053207 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36526									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36527									;IN THE SUBTEST) TO LOOP ON ERROR^
 36528
 36529					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36530					;THIS TEST VERIFIES THAT SETMM IS A NO-OP.  HENCE, IT SHOULD
 36531					;NOT MODIFY AC OR E.
 36532					;IN THIS CASE, C(AC)=0 AND C(E)=-1,,-1; AND NEITHER SHOULD NOT BE CHANGED
 36533
 36534	053207	400 16 0 00 000000 	C57500:	SETZ	16,		;CLEAR C(AC)
 36535	053210	474 17 0 00 000000 		SETO	17,		;PRELOAD E WITH -1,,-1
 36536	053211	416 16 0 00 000017 		SETMM	16,17		;*SETMM IS A NO-OP
 36537	053212	332 00 0 00 000016 		SKIPE	16		;PASS IF C(AC) UNCHANGED
 36538						STOP^
 36539	053213	254 04 0 00 053214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36540	053214	324 00 0 00 053215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36541									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36542									;IN THE SUBTEST) TO LOOP ON ERROR^
 36543	053215	312 17 0 00 070254 		CAME	17,[-1]		;PASS IF C(E) UNCHANGED
 36544						STOP^
 36545	053216	254 04 0 00 053217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36546	053217	324 00 0 00 053220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36547									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36548									;IN THE SUBTEST) TO LOOP ON ERROR^
 36549
 36550					;**********
 36551
 36552					;THIS TEST VERIFIES THAT SETMB PLACES C(E) INTO THE AC
 36553					;IN THIS CASE, C(AC)=-1,,-1 AND C(E)=100,,-200  HENCE, THE RESULT
 36554					;IN BOTH AC AND E SHOULD BE 000100,,-200.
 36555
 36556	053220	474 00 0 00 000000 	C57600:	SETO	0,		;CLEAR AC
 36557	053221	200 01 0 00 070652 		MOVE	1,[100,,-200]	;PRELOAD E WITH 100,,-200
 36558	053222	417 00 0 00 000001 		SETMB	0,1		;*SETMB SHOULD PLACE 100,,-200 INTO THE AC
 36559	053223	312 00 0 00 070652 		CAME	0,[100,,-200]	;PASS IF C(AC)=100,,-200
 36560						STOP^
 36561	053224	254 04 0 00 053225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36562	053225	324 00 0 00 053226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36563									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36564									;IN THE SUBTEST) TO LOOP ON ERROR^
 36565	053226	312 01 0 00 070652 		CAME	1,[100,,-200]	;PASS IF C(E)=100,,-200
 36566						STOP^
 36567	053227	254 04 0 00 053230 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36568	053230	324 00 0 00 053231 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36569									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36570									;IN THE SUBTEST) TO LOOP ON ERROR^
 36571
 36572					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36573					;THIS TEST VERIFIES THAT ANDCMI PLACES THE LOGICAL AND FUNCTION
 36574					;OF C(AC) AND THE COMPLEMENT OF THE WORD 0,,E INTO THE AC.
 36575					;IN THIS CASE, C(AC)=123456,,246135 AND E=0,,717273.
 36576					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,040104.
 36577
 36578	053231	200 15 0 00 070653 	C57700:	MOVE	15,[123456,,246135]	;PRELOAD AC WITH 123456,,246135
 36579	053232	421 15 0 00 717273 		ANDCMI	15,717273	;*ANDCMI SHOULD PLACE 123456,,040104
 36580									;INTO THE AC
 36581	053233	312 15 0 00 070654 		CAME	15,[123456,,040104]	;PASS IF C(AC)=123456,,040104
 36582						STOP^
 36583	053234	254 04 0 00 053235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36584	053235	324 00 0 00 053236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36585									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36586									;IN THE SUBTEST) TO LOOP ON ERROR^
 36587
 36588					;**********
 36589
 36590					;THIS TEST VERIFIES THAT ANDCMM PLACES THE LOGICAL AND FUNCTION OF
 36591					;C(AC) AND THE COMPLEMENT OF C(E) INTO E.
 36592					;IN THIS CASE,C(AC)=12321,,456654 AND C(E)= 770077,,007770
 36593					;HENCE, THE RESULT IN E SHOULD BE 003300,,450004
 36594
 36595	053236	200 14 0 00 070655 	C60000:	MOVE	14,[123321,,456654]	;PRELOAD AC WITH 123321,,456654
 36596	053237	200 15 0 00 070656 		MOVE	15,[770077,,007770]	;PRELOAD E WITH 77007770
 36597	053240	422 14 0 00 000015 		ANDCMM	14,15			;*ANDCMM SHOULD PLACE 003300,,450004 INTO THE AC
 36598	053241	312 14 0 00 070655 		CAME	14,[123321,,456654]	;PASS IF C(AC) UNCHANGED
 36599						STOP^
 36600	053242	254 04 0 00 053243 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36601	053243	324 00 0 00 053244 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36602									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36603									;IN THE SUBTEST) TO LOOP ON ERROR^
 36604	053244	312 15 0 00 070657 		CAME	15,[3300,,450004]	;PASS IF C(E) = 003300,,450004
 36605						STOP^
 36606	053245	254 04 0 00 053246 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36607	053246	324 00 0 00 053247 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36608									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36609									;IN THE SUBTEST) TO LOOP ON ERROR^
 36610
 36611					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36612					;THIS TEST VERIFIES THAT ANDCMB PLACES THE LOGICAL AND FUNCTION OF
 36613					;C(AC) AND THE COMPLEMENT OF C(E) INTO BOTH AC AND E.
 36614					;IN THIS CASE, C(AC)123456,,663322 AND C(E) = 777000,,700770
 36615					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 000456,,063002
 36616
 36617	053247	200 13 0 00 070660 	C60100:	MOVE	13,[123456,,663322]	;PRELOAD AC WITH 123456,,663322
 36618	053250	200 14 0 00 070661 		MOVE	14,[777000,,700770]	;PRELOAD E WITH 777000,,700770
 36619	053251	423 13 0 00 000014 		ANDCMB	13,14			;*ANDCMB SHOULD PLACE 000456,,063002
 36620										;INTO BOTH AC AND E
 36621	053252	312 13 0 00 070662 		CAME	13,[456,,63002]		;PASS IF C(AC)=000456,,063002
 36622						STOP^
 36623	053253	254 04 0 00 053254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36624	053254	324 00 0 00 053255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36625									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36626									;IN THE SUBTEST) TO LOOP ON ERROR^
 36627	053255	312 14 0 00 070662 		CAME	14,[456,,63002]		;PASS IF C(E)=000456,,063002
 36628						STOP^
 36629	053256	254 04 0 00 053257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36630	053257	324 00 0 00 053260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36632									;IN THE SUBTEST) TO LOOP ON ERROR^
 36633
 36634					;**********
 36635
 36636
 36637					;THIS TEST VERIFIES THAT SETA IS A NO-OP. IT AFFECTS NEITHER
 36638					;AC OR E. IN THIS CASE, C(AC)=123456,,777776 AND C(E)=010203,,123450.
 36639					;SETA SHOULD NOT MODIFY C(AC) OR C(E)
 36640
 36641	053260	200 12 0 00 070663 	C60200:	MOVE	12,[123456,,777776]	;PRELOAD AC WITH 123456,,-2
 36642	053261	200 13 0 00 070664 		MOVE	13,[010203,,123450]	;PRELOAD E WITH 010203,,123450
 36643	053262	424 12 0 00 000013 		SETA	12,13			;*SETA IS A NO-OP
 36644	053263	312 12 0 00 070663 		CAME	12,[123456,,-2]		;PASS IF C(AC) UNCHANGED
 36645						STOP^
 36646	053264	254 04 0 00 053265 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36647	053265	324 00 0 00 053266 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36648									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36649									;IN THE SUBTEST) TO LOOP ON ERROR^
 36650	053266	312 13 0 00 070664 		CAME	13,[010203,,123450]	;PASS IF C(E) UNCHANGED
 36651						STOP^
 36652	053267	254 04 0 00 053270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36653	053270	324 00 0 00 053271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36654									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36655									;IN THE SUBTEST) TO LOOP ON ERROR^
 36656
 36657					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36658					;THIS TEST VERIFIES THAT SETAI IS A NO-OP. IT DOES NOT AFFECT THE AC.
 36659					;IN THIS CASE, C(AC)=123456,,777776 AND E=0,,123450
 36660					;SETA SHOULD NOT MODIFY C(AC)
 36661
 36662	053271	200 12 0 00 070663 	C60300:	MOVE 12,[123456,,777776]	;PRELOAD AC WITH 123456,,-2
 36663	053272	425 12 0 00 123450 		SETAI	12,123450		;*SETAI IS A NO-OP
 36664	053273	312 12 0 00 070663 		CAME	12,[123456,,-2]		;PASS IF C(AC) UNCHANGED
 36665						STOP^
 36666	053274	254 04 0 00 053275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36667	053275	324 00 0 00 053276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36668									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36669									;IN THE SUBTEST) TO LOOP ON ERROR^
 36670
 36671					;**********
 36672
 36673					;THIS TEST VERIFIES THAT SETAM PLACES C(AC) INTO E.
 36674					;IN THIS CASE, C(AC)=123456,,0 AND C(E)=-1,,-1.  HENCE, THE
 36675					;RESULT IN E SHOULD BE 123456,,0
 36676
 36677	053276	515 11 0 00 123456 	C60400:	HRLZI	11,123456		;PRELOAD AC WITH 123456,,0
 36678	053277	474 12 0 00 000000 		SETO	12,			;PRELOAD E WITH -1,,-1
 36679	053300	426 11 0 00 000012 		SETAM	11,12			;SETAM SHOULD PLACE 123456,,0 INTO E
 36680	053301	312 11 0 00 070377 		CAME	11,[123456,,0]		;PASS IF C(AC) UNCHANGED
 36681						STOP^
 36682	053302	254 04 0 00 053303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36683	053303	324 00 0 00 053304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36685									;IN THE SUBTEST) TO LOOP ON ERROR^
 36686	053304	312 12 0 00 070377 		CAME	12,[123456,,0]		;PASS IF C(E)=123456,,0
 36687						STOP^
 36688	053305	254 04 0 00 053306 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36689	053306	324 00 0 00 053307 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36690									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36691									;IN THE SUBTEST) TO LOOP ON ERROR^
 36692
 36693					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36694					;THIS TEST VERIFIES THAT XORI PLACES THE LOGICAL EXCLUSIVE OR FUNCTION
 36695					;OF C(AC) AND THE WORD 0,,E INTO THE AC.
 36696					;IN THIS CASE, C(AC)=000777,,123456 AND E=0,,434431
 36697					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,517067.
 36698
 36699	053307	200 10 0 00 070665 	C60500:	MOVE	10,[777,,123456]	;PRELOAD AC WITH 000777,,123456
 36700	053310	431 10 0 00 434431 		XORI	10,434431		;*XORI SHOULD PLACE 000777,,517067 INTO THE AC
 36701	053311	312 10 0 00 070666 		CAME	10,[777,,517067]	;PASS IF C(AC)=000777,,517067
 36702						STOP^
 36703	053312	254 04 0 00 053313 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36704	053313	324 00 0 00 053314 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36705									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36706									;IN THE SUBTEST) TO LOOP ON ERROR^
 36707
 36708					;**********
 36709
 36710					;THIS TEST VERIFIES THAT XORB PLACES THE LOGICAL EXCLUSIVE OR FUNCTION
 36711					;OF C(AC) AND C(E) INTO BOTH AC AND E.
 36712					;IN THIS CASE, C(AC)=707077,,555666 AND C(E)=123456,,765432
 36713					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 624421,,230254
 36714
 36715	053314	200 07 0 00 070667 	C60600:	MOVE	7,[707077,,555666]	;PRELOAD AC WITH 707077,,555666
 36716	053315	200 10 0 00 070376 		MOVE	10,[123456,,765432]	;PRELOAD E WITH 123456,,765432
 36717	053316	433 07 0 00 000010 		XORB	7,10			;*XORB SHOULD PLACE 624421,,230254
 36718										;INTO BOTH AC AND E
 36719	053317	312 07 0 00 070670 		CAME	7,[624421,,230254]	;PASS IF C(AC)=624421,,230254
 36720						STOP^
 36721	053320	254 04 0 00 053321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36722	053321	324 00 0 00 053322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36723									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36724									;IN THE SUBTEST) TO LOOP ON ERROR^
 36725	053322	312 10 0 00 070670 		CAME	10,[624421,,230254]	;PASS IF C(E)=624421,,230254
 36726						STOP^
 36727	053323	254 04 0 00 053324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36728	053324	324 00 0 00 053325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36729									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36730									;IN THE SUBTEST) TO LOOP ON ERROR^
 36731
 36732					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36733					;THIS TEST VERIFIES THAT IORI PLACES THE INCLUSIVE OR FUNCTION
 36734					;OF C(AC) AND THE WORD 0,,E INTO THE AC.
 36735					;IN THIS CASE, C(AC)=707070,,123456 AND E=0,,765567
 36736					;HENCE, THE RESULT IN THE AC SHOULD BE 707070,,767577
 36737
 36738	053325	200 06 0 00 070671 	C60700:	MOVE	6,[707070,,123456]  ;PRELOAD AC WITH 707070,,123456
 36739	053326	435 06 0 00 765567 		IORI	6,765567	;*IORI SHOULD PLACE 707070,,767577 INTO THE AC
 36740	053327	312 06 0 00 070672 		CAME	6,[707070,,767577]  ;PASS IF C(AC)=707070,,767577
 36741						STOP^
 36742	053330	254 04 0 00 053331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36743	053331	324 00 0 00 053332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36744									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36745									;IN THE SUBTEST) TO LOOP ON ERROR^
 36746
 36747					;**********
 36748
 36749					;THIS TEST VERIFIES THAT IORM PLACES THE INCLUSIVE OR FUNCTION
 36750					;OF C(AC) AND C(E) INTO E.
 36751					;IN THIS CASE, C(AC)=123456,,777666 AND C(E)=777001,,123470
 36752					;HENCE, THE RESULT IN E SHOULD BE 777457,,777676
 36753
 36754	053332	200 05 0 00 070673 	C61000:	MOVE	5,[123456,,777666]  ;PRELOAD AC WITH 123456,777666
 36755	053333	200 06 0 00 070674 		MOVE	6,[777001,,123470]  ;PRELOAD E WITH 777001,,123470
 36756	053334	436 05 0 00 000006 		IORM	5,6		;*IORM SHOULD PLACE
 36757									;777457,777676 INTO E
 36758	053335	312 05 0 00 070673 		CAME	5,[123456,,777666]  ;PASS IF C(AC) UNMODIFIED
 36759						STOP^
 36760	053336	254 04 0 00 053337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36761	053337	324 00 0 00 053340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36762									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36763									;IN THE SUBTEST) TO LOOP ON ERROR^
 36764	053340	312 06 0 00 070675 		CAME	6,[777457,,777676] ;PASS IF C(E)=777457,777676
 36765						STOP^
 36766	053341	254 04 0 00 053342 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36767	053342	324 00 0 00 053343 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36768									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36769									;IN THE SUBTEST) TO LOOP ON ERROR^
 36770
 36771					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36772					;THIS TEST VERIFIES THAT IORB PLACES THE INCLUSIVE OR FUNCTION
 36773					;OF C(AC) AND C(E) INTO E.
 36774					;IN THIS CASE, C(AC)=123456,,777666 AND C(E)=777001,,123470
 36775					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 777457,,777676
 36776
 36777	053343	200 05 0 00 070673 	C61100:	MOVE	5,[123456,,777666]  ;PRELOAD AC WITH 123456,777666
 36778	053344	200 06 0 00 070674 		MOVE	6,[777001,,123470]  ;PRELOAD E WITH 777001,,123470
 36779	053345	437 05 0 00 000006 		IORB	5,6		;*IORB SHOULD PLACE
 36780									;777457,,777676 INTO
 36781	053346	312 05 0 00 070675 		CAME	5,[777457,,777676]  ;PASS IF C(AC)=777457,,777676
 36782						STOP^
 36783	053347	254 04 0 00 053350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36784	053350	324 00 0 00 053351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36785									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36786									;IN THE SUBTEST) TO LOOP ON ERROR^
 36787	053351	312 06 0 00 070675 		CAME	6,[777457,,777676]  ;PASS IF C(E)=777457,,777676
 36788						STOP^
 36789	053352	254 04 0 00 053353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36790	053353	324 00 0 00 053354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36791									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36792									;IN THE SUBTEST) TO LOOP ON ERROR^
 36793
 36794					;**********
 36795
 36796					;THIS TEST VERIFIES THAT ANDCBI PLACES THE LOGICAL AND FUNCTION
 36797					;OF THE COMPLEMENTS OF BOTH C(AC) AND THE WORD 0,,E INTO THE AC
 36798					;IN THIS CASE, C(AC)=777000,,123456 AND E=0,,706050.
 36799					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,050321.
 36800
 36801	053354	200 04 0 00 070676 	C61200:	MOVE	4,[777000,,123456]  ;PRELOAD AC WITH 777000,,123456
 36802	053355	441 04 0 00 706050 		ANDCBI	4,706050	;*ANDCBI SHOULD PLACE 000777,,050321
 36803									;INTO THE AC
 36804	053356	312 04 0 00 070677 		CAME	4,[777,,50321]	;PASS IF C(AC)=000777,,050321
 36805						STOP^
 36806	053357	254 04 0 00 053360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36807	053360	324 00 0 00 053361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36808									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36809									;IN THE SUBTEST) TO LOOP ON ERROR^
 36810
 36811					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36812					;THIS TEST VERIFIES THAT ANDCBM PLACES THE LOGICAL AND FUNCTION
 36813					;OF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO
 36814					;IN THE CASE, C(AC)=777007,,771100 AND C(E)=063202,,123477
 36815					;HENCE, THE RESULT IN E SHOULD BE 000570,,004200
 36816
 36817	053361	200 03 0 00 070700 	C61300:	MOVE	3,[777007,,771100]  ;PRELOAD AC WITH 777007,,771100
 36818	053362	200 04 0 00 070701 		MOVE	4,[63202,,123477]   ;PRELOAD E WITH 063202,,123477
 36819	053363	442 03 0 00 000004 		ANDCBM	3,4		;*ANDCBM SHOULD PLACE
 36820									;000570,,004200 INTO E.
 36821	053364	312 03 0 00 070700 		CAME	3,[777007,,771100] ;PASS IF C(AC) IS UNCHANGED
 36822						STOP^
 36823	053365	254 04 0 00 053366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36824	053366	324 00 0 00 053367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36826									;IN THE SUBTEST) TO LOOP ON ERROR^
 36827	053367	312 04 0 00 070702 		CAME	4,[570,,4200]	;PASS IF C(E)=000570,,004200
 36828						STOP^
 36829	053370	254 04 0 00 053371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36830	053371	324 00 0 00 053372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36831									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36832									;IN THE SUBTEST) TO LOOP ON ERROR^
 36833
 36834					;**********
 36835
 36836					;THIS TEST VERIFIES THAT ANDCBB PLACES THE LOGICAL AND FUNCTION
 36837					;OF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO BOTH AC AND E
 36838					;IN THIS CASE, C(AC)=777007,,771100 AND C(E)=063202,,123477
 36839					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 000570,,004200
 36840
 36841	053372	200 03 0 00 070700 	C61400:	MOVE	3,[777007,,771100]  ;PRELOAD WITH 777007,,771100
 36842	053373	200 04 0 00 070701 		MOVE	4,[63202,,123477]   ;PRELOAD E WITH 063202,,123477
 36843	053374	443 03 0 00 000004 		ANDCBB	3,4		;*ANDCBB SHOULD PLACE
 36844									;000570,,004200 INTO BOTH AC AND E
 36845	053375	312 03 0 00 070702 		CAME	3,[570,,4200]	;PASS IF C(AC)=000570,,004200
 36846						STOP^
 36847	053376	254 04 0 00 053377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36848	053377	324 00 0 00 053400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36849									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36850									;IN THE SUBTEST) TO LOOP ON ERROR^
 36851	053400	312 04 0 00 070702 		CAME	4,[570,,4200]	;PASS IF C(E)=000570,,004200
 36852						STOP^
 36853	053401	254 04 0 00 053402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36854	053402	324 00 0 00 053403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36855									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36856									;IN THE SUBTEST) TO LOOP ON ERROR^
 36857
 36858					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36859					;THIS TEST VERIFIES THAT EQVI PLACES THE LOGICAL EQUIVALENCE FUNCTION
 36860					;OF C(AC) AND THE WORD 0,,E INTO THE AC
 36861					;IN THIS CASE, C(AC)=707070,,123426 AND E=0,,123363
 36862					;HENCE, THE RESULT IN THE AC SHOULD BE 070707,,777032
 36863
 36864	053403	200 02 0 00 070703 	C61500:	MOVE	2,[707070,,123426]  ;PRELOAD AC WITH 707070,,123426
 36865	053404	445 02 0 00 123363 		EQVI	2,123363	;*EQVI SHOULD PLACE
 36866									;070707,,777032 INTO THE AC
 36867	053405	312 02 0 00 070704 		CAME	2,[70707,,777032]  ;PASS IF C(AC)=070707,,777032
 36868						STOP^
 36869	053406	254 04 0 00 053407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36870	053407	324 00 0 00 053410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36872									;IN THE SUBTEST) TO LOOP ON ERROR^
 36873
 36874					;**********
 36875
 36876					;THIS TEST VERIFIES THAT EQVM PLACES THE LOGICAL EQUIVALENCE FUNCTION
 36877					;OF C(AC) AND C(E) INTO E.
 36878					;IN THIS CASE, C(AC)= 123456,,123457 AND C(E) = 707633,,121212
 36879					;HENCE, THE RESULT IN E SHOULD BE 153512,,775132
 36880
 36881	053410	200 01 0 00 070705 	C61600:	MOVE	1,[123456,,123457] ;PRELOAD AC WITH 123456,,123457
 36882	053411	200 02 0 00 070706 		MOVE	2,[707633,,121212] ;PRELOAD AC WITH 707633,,121212
 36883	053412	446 01 0 00 000002 		EQVM	1,2		;*EQVM SHOULD PLACE 153512,,775132 INTO	E.
 36884	053413	312 01 0 00 070705 		CAME	1,[123456,,123457] ;PASS IF C(AC) UNCHANGED
 36885						STOP^
 36886	053414	254 04 0 00 053415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36887	053415	324 00 0 00 053416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36888									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36889									;IN THE SUBTEST) TO LOOP ON ERROR^
 36890	053416	312 02 0 00 070707 		CAME	2,[153512,,775132];PASS IF C(E) = 153512,,775132
 36891						STOP^
 36892	053417	254 04 0 00 053420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36893	053420	324 00 0 00 053421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36894									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36895									;IN THE SUBTEST) TO LOOP ON ERROR^
 36896
 36897					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36898					;THIS TEST VERIFIES THAT EQVB PLACES THE LOGICAL EQUIVALENCE FUNCTION
 36899					;OF C(AC)AND C(E) INTO BOTH AC AND  E.
 36900					;IN THIS CASE, C(AC) = 123456,,123457 AND C(E) = 707633,,121212
 36901					;HENSE, THE RSULT IN BOTH AC AND 	E SHOULD BE 153512,,775132
 36902
 36903	053421	200 01 0 00 070705 	C61700:	MOVE	1,[123456,,123457]	;PRELOAD AC WITH 123456,,12345
 36904	053422	200 02 0 00 070706 		MOVE	2,[707633,,121212]	;PRELOAD AC WITH 707633,,121212
 36905	053423	447 01 0 00 000002 		EQVB	1,2			;*EQVB SHOULD PLACE 153512,,775132
 36906										;INTO BOTHE AC AND E.
 36907	053424	312 01 0 00 070707 		CAME	1,[153512,,775132]	;PASS IC C(AC)=153512,,775132
 36908						STOP^
 36909	053425	254 04 0 00 053426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36910	053426	324 00 0 00 053427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36911									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36912									;IN THE SUBTEST) TO LOOP ON ERROR^
 36913	053427	312 02 0 00 070707 		CAME	2,[153512,,775132]	;PASS IF C(E)=153512,,775132
 36914						STOP^
 36915	053430	254 04 0 00 053431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36916	053431	324 00 0 00 053432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36917									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36918									;IN THE SUBTEST) TO LOOP ON ERROR^
 36919
 36920					;**********
 36921
 36922					;THIS TEST VERIFIES THAT SETCAI PLACES THE COMPLEMENT OF C(AC)
 36923					;INTO THE AC.
 36924					;IN THIS CASE, C(AC)=777000,,123456 AND E=0,,707070
 36925					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,654321
 36926
 36927	053432	200 00 0 00 070676 	C62000:	MOVE	0,[777000,,123456]	;PRELOAD AC WITH 777000,,123456
 36928	053433	451 00 0 00 707070 		SETCAI	0,707070		;*SETCAI SHOULD PLACE 000777,,654321
 36929										;INTO THE AC
 36930	053434	312 00 0 00 070710 		CAME	0,[777,,654321]	;PASS IF C(AC)=000777,,654321
 36931						STOP^
 36932	053435	254 04 0 00 053436 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36933	053436	324 00 0 00 053437 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36934									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36935									;IN THE SUBTEST) TO LOOP ON ERROR^
 36936
 36937					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36938					;THIS TEST VERIFIES THAT SETCAM PLACES THE COMPLEMENT OF C(AC)
 36939					;INTO E.
 36940					;IN THIS CASE, C(AC)=123456,,765432 AND C(E)=-1,,-1.
 36941					;HENCE, THE RESULT IN E SHOULD BE 654321,,012345
 36942
 36943	053437	200 17 0 00 070376 	C62100:	MOVE	17,[123456,,765432]	;PRELOAD AC WITH 123456,,765432
 36944	053440	474 00 0 00 000000 		SETO	0,			;PRELOAD E WITH -1,,-1
 36945	053441	452 17 0 00 000000 		SETCAM	17,0			;*SETCAM SHOULD PLACE
 36946										;654321,,012345 INTO E
 36947	053442	312 17 0 00 070376 		CAME	17,[123456,,765432]	;PASS IF C(AC) IS UNCHANGED
 36948						STOP^
 36949	053443	254 04 0 00 053444 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36950	053444	324 00 0 00 053445 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36951									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36952									;IN THE SUBTEST) TO LOOP ON ERROR^
 36953	053445	312 00 0 00 070711 		CAME	0,[654321,,12345]	;PASS IF C(E)=654321,,012345
 36954						STOP^
 36955	053446	254 04 0 00 053447 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36956	053447	324 00 0 00 053450 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36957									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36958									;IN THE SUBTEST) TO LOOP ON ERROR^
 36959
 36960					;**********
 36961
 36962					;THIS TEST VERIFIES THAT SETCAB PLACES THE COMPLEMENT OF C(AC)
 36963					;INTO BOTH AC AND E.
 36964					;IN THIS CASE, C(AC)=123456,,765432 AND C(E)=-1,,-1.
 36965					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 654321,,012345
 36966
 36967	053450	200 17 0 00 070376 	C62200:	MOVE	17,[123456,,765432]	;PRELOAD AC WITH 123456,,76543
 36968	053451	474 00 0 00 000000 		SETO	0,			;PRELOAD E WITH -1,,-1
 36969	053452	453 17 0 00 000000 		SETCAB	17,0			;*SETCAB SHOULD PLACE
 36970										;654321,,012345 INTO BOTH AC AND E
 36971	053453	312 17 0 00 070711 		CAME	17,[654321,,12345]	;PASS IF C(AC)=654321,,012345
 36972						STOP^
 36973	053454	254 04 0 00 053455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36974	053455	324 00 0 00 053456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36975									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36976									;IN THE SUBTEST) TO LOOP ON ERROR^
 36977	053456	312 00 0 00 070711 		CAME	0,[654321,,12345]	;PASS IF C(E)=654321,,012345
 36978						STOP^
 36979	053457	254 04 0 00 053460 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36980	053460	324 00 0 00 053461 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36981									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36982									;IN THE SUBTEST) TO LOOP ON ERROR^
 36983
 36984					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 36985					;THIS TEST VERIFIES THAT ORCAI PLACES THE INCLUSIVE OR FUNCTION
 36986					;OF THE WORD 0,,E AND THE COMPLEMENT OF C(AC) INTO THE AC.
 36987					;IN THIS CASE, C(AC)=777000,,123477 AND E=0,,765401
 36988					;HENCE, THE RESULT IN THE AC SHOULD BE 000777,,775701
 36989
 36990	053461	200 16 0 00 070712 	C62300:	MOVE	16,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 36991	053462	455 16 0 00 765401 		ORCAI	16,765401		;*ORCAI SHOULD PLACE 000777,,767477
 36992										;INTO THE AC
 36993	053463	312 16 0 00 070713 		CAME	16,[777,,775701]	;PASS IF C(AC)=000777,,775701
 36994						STOP^
 36995	053464	254 04 0 00 053465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 36996	053465	324 00 0 00 053466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 36997									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 36998									;IN THE SUBTEST) TO LOOP ON ERROR^
 36999
 37000					;**********
 37001
 37002					;THIS TEST VERIFIES THAT ORCAM PLACES THE INCLUSIVE OR FUNCTION
 37003					;OF C(E) AND THE COMPLEMENT OF C(AC) INTO
 37004					;IN THIS CASE, C(AC)=777000,,123477 AND C(E)=707070,,707072
 37005					;HENCE, THE RESULT IN E SHOULD BE 707777,,757372
 37006
 37007	053466	200 15 0 00 070712 	C62400:	MOVE	15,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 37008	053467	200 16 0 00 070714 		MOVE	16,[707070,,707072]	;PRELOAD E WITH 707070,,707072
 37009	053470	456 15 0 00 000016 		ORCAM	15,16			;*ORCAM SHOULD PLACE 707777,,757372
 37010										;INTO E
 37011	053471	312 15 0 00 070712 		CAME	15,[777000,,123477]	;PASS IF C(AC) IS UNCHANGED
 37012						STOP^
 37013	053472	254 04 0 00 053473 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37014	053473	324 00 0 00 053474 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37015									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37016									;IN THE SUBTEST) TO LOOP ON ERROR^
 37017	053474	312 16 0 00 070715 		CAME	16,[707777,,757372]	;PASS IF C(E)=707777,,757372
 37018						STOP^
 37019	053475	254 04 0 00 053476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37020	053476	324 00 0 00 053477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37021									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37022									;IN THE SUBTEST) TO LOOP ON ERROR^
 37023
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 37024					;**********
 37025					;THIS TEST VERIFIES THAT ORCAB PLACES THE INCLUSIVE OR FUNCTION
 37026					;OF C(E) AND THE COMPLEMENT OF C(AC) INTO BOTH AC AND E.
 37027					;IN THIS CASE, C(AC)=777000,,123477 AND C(E)=707070,,707072
 37028					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 707777,,757372
 37029
 37030	053477	200 15 0 00 070712 	C62500:	MOVE	15,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 37031	053500	200 16 0 00 070714 		MOVE	16,[707070,,707072]	;PRELOAD E WITH 707070,,707072
 37032	053501	457 15 0 00 000016 		ORCAB	15,16			;*ORCAB SHOULD PLACE 707777,,757372
 37033										;INTO BOTHE AC AND E
 37034	053502	312 15 0 00 070715 		CAME	15,[707777,,757372]	;PASS IF C(AC)=707777,,757372
 37035						STOP^
 37036	053503	254 04 0 00 053504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37037	053504	324 00 0 00 053505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37038									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37039									;IN THE SUBTEST) TO LOOP ON ERROR^
 37040	053505	312 16 0 00 070715 		CAME	16,[707777,,757372]	;PASS IF C(E)=707777,,757372
 37041						STOP^
 37042	053506	254 04 0 00 053507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37043	053507	324 00 0 00 053510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37044									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37045									;IN THE SUBTEST) TO LOOP ON ERROR^
 37046
 37047					;**********
 37048
 37049					;THIS TEST VERIFIES THAT SETCMI PLACES THE COMPLEMENT OF THE
 37050					;WORD 0,,E INTO THE AC
 37051					;IN THIS CASE, C(AC)=777000,,123456 AND E=0,,707070
 37052					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,070707
 37053
 37054	053510	200 00 0 00 070676 	C62600:	MOVE	0,[777000,,123456]	;PRELOAD AC WITH 777000,,123456
 37055	053511	461 00 0 00 707070 		SETCMI	0,707070		;*SETCMI SHOULD PLACE -1,,070707
 37056										;INTO THE AC
 37057	053512	312 00 0 00 070716 		CAME	0,[-1,,070707]		;PASS IF C(AC)=-1,,070707
 37058						STOP^
 37059	053513	254 04 0 00 053514 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37060	053514	324 00 0 00 053515 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37061									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37062									;IN THE SUBTEST) TO LOOP ON ERROR^
 37063
 37064					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 37065					;THIS TEST VERIFIES THAT SETCMM PLACES THE COMPLEMENT OF C(E)
 37066					;INTO E.
 37067					;IN THIS CASE, C(E)=123456,,765432 AND C(AC)=-1,,-1.
 37068					;HENCE, THE RESULT IN E SHOULD BE 654321,,012345
 37069
 37070	053515	200 17 0 00 070376 	C62700:	MOVE	17,[123456,,765432]	;PRELOAD E WITH 123456,,76543
 37071	053516	474 00 0 00 000000 		SETO	0,			;PRELOAD AC WITH -1,,-1
 37072	053517	462 00 0 00 000017 		SETCMM	0,17			;*SETCMM SHOULD PLACE
 37073										;654321,012345 INTO E
 37074	053520	312 00 0 00 070254 		CAME	0,[-1]			;PASS IF C(AC) UNCHANGED
 37075						STOP^
 37076	053521	254 04 0 00 053522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37077	053522	324 00 0 00 053523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37078									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37079									;IN THE SUBTEST) TO LOOP ON ERROR^
 37080	053523	312 17 0 00 070711 		CAME	17,[654321,,12345]	;PASS IF C(E)=654321,,012345
 37081						STOP^
 37082	053524	254 04 0 00 053525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37083	053525	324 00 0 00 053526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37084									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37085									;IN THE SUBTEST) TO LOOP ON ERROR^
 37086
 37087					;**********
 37088
 37089					;THIS TEST VERIFIES THAT SETCMB PLACES THE COMPLEMENT OF C(E)
 37090					;INTO BOTH AC AND E.
 37091					;IN THIS CASE, C(E)=123456,,765432 AND C(AC)=-1,,-1.
 37092					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 654321,,012345
 37093
 37094	053526	200 17 0 00 070376 	C63000:	MOVE	17,[123456,,765432]	;PRELOAD E WITH 123456,,76543
 37095	053527	474 00 0 00 000000 		SETO	0,			;PRELOAD AC WITH -1,,-1
 37096	053530	463 00 0 00 000017 		SETCMB	0,17			;*SETCMB SHOULD PLACE
 37097										;654321,,012345 INTO BOTH AC AND E
 37098	053531	312 00 0 00 070711 		CAME	0,[654321,,12345]	;PASS IF C(AC)=654321,,012345
 37099						STOP^
 37100	053532	254 04 0 00 053533 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37101	053533	324 00 0 00 053534 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37102									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37103									;IN THE SUBTEST) TO LOOP ON ERROR^
 37104	053534	312 17 0 00 070711 		CAME	17,[654321,,12345]	;PASS IF C(E)=654321,,012345
 37105						STOP^
 37106	053535	254 04 0 00 053536 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37107	053536	324 00 0 00 053537 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37108									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37109									;IN THE SUBTEST) TO LOOP ON ERROR^
 37110
 37111					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 37112					;THIS TEST VERIFIES THAT ORCMI PLACES THE INCLUSIVE OR FUNCTION
 37113					;OF C(AC) AND THE COMPLEMENT OF THE WORD 0,,E INTO THE AC.
 37114					;IN THIS CASE, C(AC)=777000,,123477 AND E=0,,765401
 37115					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,133777
 37116
 37117	053537	200 16 0 00 070712 	C63100:	MOVE	16,[777000,,123477]	;PRELOAD AC WITH 777000,,123477
 37118	053540	465 16 0 00 765401 		ORCMI	16,765401		;*ORCMI SHOULD PLACE -1,,133777
 37119										;INTO THE AC
 37120	053541	312 16 0 00 070717 		CAME	16,[-1,,133777]		;PASS IF C(AC)=-1,,133777
 37121						STOP^
 37122	053542	254 04 0 00 053543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37123	053543	324 00 0 00 053544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37125									;IN THE SUBTEST) TO LOOP ON ERROR^
 37126
 37127					;**********
 37128
 37129					;THIS TEST VERIFIES THAT ORCMM PLACES THE INCLUSIVE OR FUNCTION
 37130					;OF C(AC) AND THE COMPLEMENT OC C(E) INTO
 37131					;IN THIS CASE, C(E)=777000,,123477 AND C (AC)=707070,,707072
 37132					;HENCE, THE RESULT IN E SHOULD BE 707777,,757372
 37133
 37134	053544	200 15 0 00 070712 	C63200:	MOVE	15,[777000,,123477]	;PRELOAD E WITH 777000,,123477
 37135	053545	200 16 0 00 070714 		MOVE	16,[707070,,707072]	;PRELOAD AC WITH 707070,,707072
 37136	053546	466 16 0 00 000015 		ORCMM	16,15			;*ORCMM SHOULD PLACE 707777,,757372
 37137										;INTO E
 37138	053547	312 16 0 00 070714 		CAME	16,[707070,,707072]	;PASS IF C(AC) IS UNCHANGED
 37139						STOP^
 37140	053550	254 04 0 00 053551 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37141	053551	324 00 0 00 053552 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37142									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37143									;IN THE SUBTEST) TO LOOP ON ERROR^
 37144	053552	312 15 0 00 070715 		CAME	15,[707777,,757372]	;PASS IF C(E)=707777,,757372
 37145						STOP^
 37146	053553	254 04 0 00 053554 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37147	053554	324 00 0 00 053555 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37148									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37149									;IN THE SUBTEST) TO LOOP ON ERROR^
 37150
 37151					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 37152					;THIS TEST VERIFIES THAT ORCMB PLACES THE INCLUSIVE OR FUNCTION
 37153					;OF C(AC) AND THE COMPLEMENT OF C(E) INTO BOTH AC AND E.
 37154					;IN THIS CASE, C(E)=777000,,123477 AND C(AC)=707070,,707072
 37155					;HENCE, THE RESULT IN BOTH AC AND E SHOULD BE 707777,,757372
 37156
 37157	053555	200 15 0 00 070712 	C63300:	MOVE	15,[777000,,123477]  ;PRELOAD E WITH 777000,,123477
 37158	053556	200 16 0 00 070714 		MOVE	16,[707070,,707072]  ;PRELOAD AC WITH 707070,,707072
 37159	053557	467 16 0 00 000015 		ORCMB	16,15		;*ORCMB SHOULD PLACE 707777,,757372
 37160									;INTO BOTH AC AND E
 37161	053560	312 16 0 00 070715 		CAME	16,[707777,,757372]  ;PASS IF C(AC)=707777,,757372
 37162						STOP^
 37163	053561	254 04 0 00 053562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37164	053562	324 00 0 00 053563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37165									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37166									;IN THE SUBTEST) TO LOOP ON ERROR^
 37167	053563	312 15 0 00 070715 		CAME	15,[707777,,757372]  ;PASS OF C(E)=707777,,757372
 37168						STOP^
 37169	053564	254 04 0 00 053565 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37170	053565	324 00 0 00 053566 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37171									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37172									;IN THE SUBTEST) TO LOOP ON ERROR^
 37173
 37174					;**********
 37175
 37176					;THIS TEST VERIFIES THAT ORCBI PLACES THE LOGICAL INCLUSIVE OR
 37177					;FUNCTION OF THE COMPLEMENTS OF BOTH C(AC) AND THE WORD 0,,E INTO THE AC.
 37178					;IN THIS CASE, C(AC)=707070,,070706 AND E=0,,770011.
 37179					;HENCE, THE RESULT IN THE AC SHOULD BE -1,,707777
 37180
 37181	053566	200 15 0 00 070720 	C63400:	MOVE	15,[707070,,070706]  ;PRELOAD AC WITH 707070,,070706
 37182	053567	471 15 0 00 770011 		ORCBI	15,770011	;*ORCBI SHOULD PLACE -1,,707777 INTO THE AC
 37183	053570	312 15 0 00 070721 		CAME	15,[-1,,707777]	;PASS IF C(AC)=-1,707777
 37184						STOP^
 37185	053571	254 04 0 00 053572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37186	053572	324 00 0 00 053573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37187									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37188									;IN THE SUBTEST) TO LOOP ON ERROR^
 37189
 37190					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL BOOLEAN INSTRUCTIONS

 37191					;THIS TEST VERIFIES THAT ORCBM PLACES THE LOGICAL INCLUSIVE OR
 37192					;FUNCTION OF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO
 37193					;IN THIS CASE, C(AC)=123456,,770077 AND C(E)=777001,,123324
 37194					;HENCE, THE RESULT IN E SHOULD BE 654777,,657753
 37195
 37196	053573	200 14 0 00 070722 	C63500:	MOVE	14,[123456,,770077]  ;PRELOAD AC WITH 123456,,770077
 37197	053574	200 15 0 00 070723 		MOVE	15,[777001,,123324]  ;PRELOAD E WITH 777001,,123324
 37198	053575	472 14 0 00 000015 		ORCBM	14,15		;*ORCBM SHOULD PLACE 654777,,657753
 37199									;INTO E
 37200	053576	312 14 0 00 070722 		CAME	14,[123456,,770077]  ;PASS IF C(AC) IS UNCHANGED
 37201						STOP^
 37202	053577	254 04 0 00 053600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37203	053600	324 00 0 00 053601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37204									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37205									;IN THE SUBTEST) TO LOOP ON ERROR^
 37206	053601	312 15 0 00 070724 		CAME	15,[654777,,657753]   ;PASS IF C(E)=654777,,657753
 37207						STOP^
 37208	053602	254 04 0 00 053603 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37209	053603	324 00 0 00 053604 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37211									;IN THE SUBTEST) TO LOOP ON ERROR^
 37212
 37213					;**********
 37214
 37215					;THIS TEST VERIFIES THAT ORCBB PLACES THE LOGICAL INCLUSIVE OR
 37216					;FUNCTIONOF THE COMPLEMENTS OF BOTH C(AC) AND C(E) INTO BOTH AC AND E
 37217					;IN THIS CASE, C(AC)=123456,,770077 AND C(E)=777001,,657753
 37218
 37219	053604	200 14 0 00 070722 	C63600:	MOVE	14,[123456,,770077]  ;PRELOAD AC WITH 123456,,770077
 37220	053605	200 15 0 00 070723 		MOVE	15,[777001,,123324]  ;PRELOAD E WITH 777001,,123324
 37221	053606	473 14 0 00 000015 		ORCBB	14,15		;*ORCBB SHOULD PLACE 654777,,657753
 37222									;INTO BOTH AC AND E
 37223	053607	312 14 0 00 070724 		CAME	14,[654777,,657753]  ;PASS IF C(AC)=654777,,657753
 37224						STOP^
 37225	053610	254 04 0 00 053611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37226	053611	324 00 0 00 053612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37227									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37228									;IN THE SUBTEST) TO LOOP ON ERROR^
 37229	053612	312 15 0 00 070724 		CAME	15,[654777,,657753]  ;PASS IF C(E)=654777,,657753
 37230						STOP^
 37231	053613	254 04 0 00 053614 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37232	053614	324 00 0 00 053615 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37233									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37234									;IN THE SUBTEST) TO LOOP ON ERROR^
 37235
 37236					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37237					SUBTTL	TEST OF MSCL HWT INSTRUCTIONS
 37238
 37239					;**********
 37240
 37241					;THIS TEST VERIFIES THAT HLLI CLEARS AC LEFT
 37242					;IN THIS CASE, C(AC)=707070,,123456 AND E=777000
 37243					;HENCE, THE RESULT IN THE AC SHOULD BE 0,,123456
 37244
 37245	053615	200 17 0 00 070671 	C63700:	MOVE	17,[707070,,123456]	;PRELOAD AC WITH 707070,,123456
 37246	053616	501 17 0 00 777000 		HLLI	17,777000	;*HLLI SHOULD PLACE 0,,123456 INTO THHE AC
 37247	053617	302 17 0 00 123456 		CAIE	17,123456	;PASS IF C(AC)=0,,123456
 37248						STOP^
 37249	053620	254 04 0 00 053621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37250	053621	324 00 0 00 053622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37251									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37252									;IN THE SUBTEST) TO LOOP ON ERROR^
 37253
 37254					;**********
 37255
 37256					;THIS TEST VERIFIES THAT HLLS PLACES C(E) INTO THE AC IF AC IS NON-ZERO
 37257					;AND IS A NO-OP IF AC=0
 37258					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E)=123456,,765432
 37259					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1
 37260					;AND 123456,,765432 RESPECTIVELY
 37261
 37262	053622	474 00 0 00 000000 	C64000:	SETO	0		;PRELOAD AC WITH -1,,-1
 37263	053623	200 02 0 00 070376 		MOVE	2,[123456,,765432]	;PRELOAD E WITH 123456,,765432
 37264	053624	503 00 0 00 000002 		HLLS	0,2		;*HLLS SHOULD NOT AFFECT AC OR E
 37265	053625	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37266						STOP^
 37267	053626	254 04 0 00 053627 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37268	053627	324 00 0 00 053630 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37269									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37270									;IN THE SUBTEST) TO LOOP ON ERROR^
 37271	053630	312 02 0 00 070376 		CAME	2,[123456,,765432]	;PASS IF C(C) IS UNCHANGED
 37272						STOP^
 37273	053631	254 04 0 00 053632 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37274	053632	324 00 0 00 053633 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37275									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37276									;IN THE SUBTEST) TO LOOP ON ERROR^
 37277
 37278					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37279					;THIS TEST VERIFIES THAT HLLS PLACES C(E) INTO THE AC IF AC IS NON-ZERO?
 37280					;AND IS A NO-OP IF AC=0
 37281					;IN THIS CASE, AC=1, C(AC)=1,,-1 AND C(E)=123456,,765432
 37282					;HENCE, THE RESULTS IN AC AND E WHOULD BE 123456,,765432
 37283					;AND 123456,,765432 RESPECTVIELY
 37284
 37285	053633	474 01 0 00 000000 	C64010:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37286	053634	200 02 0 00 070376 		MOVE	2,[123456,,765432]	;PRELOAD E WITH 123456,,765432
 37287	053635	503 01 0 00 000002 		HLLS	1,2		;*HLLS SHOULD PLACE 123456,,765432 INTO THE AC
 37288	053636	312 01 0 00 070376 		CAME	1,[123456,,765432]	;PASS IF C(AC)=123456,,765432
 37289						STOP^
 37290	053637	254 04 0 00 053640 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37291	053640	324 00 0 00 053641 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37292									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37293									;IN THE SUBTEST) TO LOOP ON ERROR^
 37294	053641	312 02 0 00 070376 		CAME	2,[123456,,765432]	;PASS IF C(C) IS UNCHANGED
 37295						STOP^
 37296	053642	254 04 0 00 053643 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37297	053643	324 00 0 00 053644 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37298									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37299									;IN THE SUBTEST) TO LOOP ON ERROR^
 37300
 37301					;**********
 37302
 37303					;THIS TEST VERIFIES THAT HRLS PLACES C(E-RIGHT) INTO E-LEFT, BUT
 37304					;DOES NOT AFFECT E-RIGHT.  IF AC IS NON-ZERO, THE RESULT IN E
 37305					;IS ALSO PLACED INTO THE AC.
 37306					;IN THIS CASE, AC=0, C(AC)=1,,-1 AND C(E)=123456,707070
 37307					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE -1,,-1
 37308					;AND 707070,,707070.
 37309
 37310	053644	474 00 0 00 000000 	C64100:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37311	053645	200 03 0 00 070725 		MOVE	3,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37312	053646	507 00 0 00 000003 		HRLS	0,3		;*HRLS SHOULD PLACE 707070,,707070
 37313									;INTO E.
 37314	053647	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37315						STOP^
 37316	053650	254 04 0 00 053651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37317	053651	324 00 0 00 053652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37318									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37319									;IN THE SUBTEST) TO LOOP ON ERROR^
 37320	053652	312 03 0 00 070332 		CAME	3,[707070,,707070]	;PASS IF C(E)=707070,,707070
 37321						STOP^
 37322	053653	254 04 0 00 053654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37323	053654	324 00 0 00 053655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37324									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37325									;IN THE SUBTEST) TO LOOP ON ERROR^
 37326
 37327					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37328					;THIS TEST VERIFIES THAT HRLS PLACES C(E-RIGHT) INTO E-LEFT, BUT
 37329					;DOES NOT AFFECT E-RIGHT.  IF AC IS NON-ZERO, THE RESULT IN E
 37330					;IS ALSO PLACED INTO THE AC.
 37331					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E)=123456,,707070
 37332					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 707070,,707070
 37333					;AND 707070,,707070.
 37334
 37335	053655	474 01 0 00 000000 	C64110:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37336	053656	200 03 0 00 070725 		MOVE	3,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37337	053657	507 01 0 00 000003 		HRLS	1,3		;*HRLS SHOULD PLACE 707070,,707070
 37338									;INTO BOTH AC AND E.
 37339	053660	312 01 0 00 070332 		CAME	1,[707070,,707070]	;PASS IF C(AC)=707070,,707070
 37340						STOP^
 37341	053661	254 04 0 00 053662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37342	053662	324 00 0 00 053663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37344									;IN THE SUBTEST) TO LOOP ON ERROR^
 37345	053663	312 03 0 00 070332 		CAME	3,[707070,,707070]	;PASS IF C(E)=707070,,707070
 37346						STOP^
 37347	053664	254 04 0 00 053665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37348	053665	324 00 0 00 053666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37349									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37350									;IN THE SUBTEST) TO LOOP ON ERROR^
 37351
 37352					;**********
 37353
 37354					;THIS TEST VERIFIES THAN HLLZM PLACES C(AC-LEFT) INTO E-LEFT AND
 37355					;PLACES 0 INTO E-RIGHT
 37356					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,717171
 37357					;HENCE, THE RESULT IN E SHOULD BE 123456,,0
 37358
 37359	053666	200 01 0 00 070726 	C64200:	MOVE	1,[123456,,123422]	;PRELOAD AC WITH 123456,,123422
 37360	053667	200 02 0 00 070727 		MOVE	2,[707070,,717171]	;PRELOAD AC WITH 707070,,717171
 37361	053670	512 01 0 00 000002 		HLLZM	1,2		;*HLLZM SHOULD PLACE 123456,,0 INTO E
 37362	053671	312 01 0 00 070726 		CAME	1,[123456,,123422]	;PASS IF C(AC) UNCHANGED
 37363						STOP^
 37364	053672	254 04 0 00 053673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37365	053673	324 00 0 00 053674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37366									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37367									;IN THE SUBTEST) TO LOOP ON ERROR^
 37368	053674	312 02 0 00 070377 		CAME	2,[123456,,0]	;PASS IF C(E)=123456,,0
 37369						STOP^
 37370	053675	254 04 0 00 053676 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37371	053676	324 00 0 00 053677 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37372									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37373									;IN THE SUBTEST) TO LOOP ON ERROR^
 37374
 37375					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37376					;THIS TEST VERIFIES THAT HLLZS CLEARS THE RIGHT HALF OF E, BUT DOESN'T
 37377					;AFFECT THE LEFT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37378					;ALSO PLACED INTO THE AC.
 37379					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E)=123456,,707070
 37380					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1
 37381					;AND 123456,,0 RESPECTIVELY
 37382
 37383	053677	474 00 0 00 000000 	C64300:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37384	053700	200 17 0 00 070725 		MOVE	17,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37385	053701	513 00 0 00 000017 		HLLZS	0,17		;*HLLZS SHOULD PLACE 123456,,0 INTO E.
 37386	053702	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37387						STOP^
 37388	053703	254 04 0 00 053704 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37389	053704	324 00 0 00 053705 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37390									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37391									;IN THE SUBTEST) TO LOOP ON ERROR^
 37392	053705	312 17 0 00 070377 		CAME	17,[123456,,0]	;PASS IF C(E)=123456,,0
 37393						STOP^
 37394	053706	254 04 0 00 053707 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37395	053707	324 00 0 00 053710 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37396									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37397									;IN THE SUBTEST) TO LOOP ON ERROR^
 37398
 37399
 37400					;**********
 37401
 37402					;THIS TEST VERIFIES THAT HLLZS CLEARS THE RIGHT HALF OF E, BUT DOESN'T
 37403					;AFFECT THE LEFT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37404					;ALSO PLACED INTO THE AC.
 37405					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E)=123456,,707070
 37406					;HENCE, THE RESULTS IN AC AND E SHOULD BE 123456,,0
 37407					;AND 123456,,0 RESPECTIVELY.
 37408
 37409	053710	474 01 0 00 000000 	C64310:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37410	053711	200 17 0 00 070725 		MOVE	17,[123456,,707070]	;PRELOAD E WITH 123456,,707070
 37411	053712	513 01 0 00 000017 		HLLZS	1,17		;*HLLZS SHOULD PLACE 123456,,0 INTO
 37412									;BOTH AC AND E
 37413	053713	312 01 0 00 070377 		CAME	1,[123456,,0]	;PASS IF C(AC)=123456,,0
 37414						STOP^
 37415	053714	254 04 0 00 053715 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37416	053715	324 00 0 00 053716 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37417									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37418									;IN THE SUBTEST) TO LOOP ON ERROR^
 37419	053716	312 17 0 00 070377 		CAME	17,[123456,,0]	;PASS IF C(E)=123456,,0
 37420						STOP^
 37421	053717	254 04 0 00 053720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37422	053720	324 00 0 00 053721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37423									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37424									;IN THE SUBTEST) TO LOOP ON ERROR^
 37425
 37426					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37427					;THIS TEST VERIFIES THAT HRLZM PLACES C(AC-RIGHT) INTO E-LEFT AND
 37428					;PLACES O INTO E-RIGHT.
 37429					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,,717171
 37430					;HENCE, THE RESULT IN E SHOULD BE 123422,,0
 37431
 37432	053721	200 01 0 00 070726 	C64400:	MOVE	1,[123456,,123422]	;PRELOAD AC WITH 123456,,123422
 37433	053722	200 02 0 00 070727 		MOVE	2,[707070,,717171]	;PRELOAD AC WITH 707070,,717171
 37434	053723	516 01 0 00 000002 		HRLZM	1,2		;*HRLZM SHOULD PLACE 123422,,0 INTO E
 37435	053724	312 01 0 00 070726 		CAME	1,[123456,,123422]	;PASS IF C(AC) UNCHANGED
 37436						STOP^
 37437	053725	254 04 0 00 053726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37438	053726	324 00 0 00 053727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37439									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37440									;IN THE SUBTEST) TO LOOP ON ERROR^
 37441	053727	312 02 0 00 070730 		CAME	2,[123422,,0]	;PASS IF C(E)=123422,,0
 37442						STOP^
 37443	053730	254 04 0 00 053731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37444	053731	324 00 0 00 053732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37446									;IN THE SUBTEST) TO LOOP ON ERROR^
 37447
 37448					;**********
 37449
 37450					;THIS TEST VERIFIES THAT HRLZS PLACES C(E-RIGHT) INTO E-LEFT AND
 37451					;CLEARS E-RIGHT. IF AC IS NON-ZERO, THE RESULT IN E IS ALSO
 37452					;PLACED INTO THE AC.
 37453					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E)=123456,,707076
 37454					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE -1,,-1
 37455					;AND 707076,,0
 37456
 37457	053732	474 00 0 00 000000 	C64500:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37458	053733	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37459	053734	517 00 0 00 000016 		HRLZS	0,16		;*HRLZS SHOULD PLACE 707076,,0
 37460									;INTO E.
 37461	053735	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37462						STOP^
 37463	053736	254 04 0 00 053737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37464	053737	324 00 0 00 053740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37465									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37466									;IN THE SUBTEST) TO LOOP ON ERROR^
 37467	053740	312 16 0 00 070732 		CAME	16,[707076,,0]	;PASS IF C(AC)=707076,,0
 37468						STOP^
 37469	053741	254 04 0 00 053742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37470	053742	324 00 0 00 053743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37471									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37472									;IN THE SUBTEST) TO LOOP ON ERROR^
 37473
 37474					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37475					;THIS TEST VERIFIES THAT HRLZS PLACES C(E-RIGHT) INTO E-LEFT AND
 37476					;CLEARS E-RIGHT.  IF AC IS NON-ZERO, THE RESULT IN E IS ALSO
 37477					;PLACED INTO THE AC.
 37478					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E)=123456,,707076
 37479					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 707076,,0
 37480					;AND 707076,,0
 37481
 37482	053743	474 01 0 00 000000 	C64510:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37483	053744	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37484	053745	517 01 0 00 000016 		HRLZS	1,16		;*HRLZS SHOULD PLACE 707076,,0
 37485									;INTO BOTH AC AND E.
 37486	053746	312 01 0 00 070732 		CAME	1,[707076,,0]	;PASS IF C(AC)=707076,,0
 37487						STOP^
 37488	053747	254 04 0 00 053750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37489	053750	324 00 0 00 053751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37491									;IN THE SUBTEST) TO LOOP ON ERROR^
 37492	053751	312 16 0 00 070732 		CAME	16,[707076,,0]	;PASS IF C(AC)=707076,,0
 37493						STOP^
 37494	053752	254 04 0 00 053753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37495	053753	324 00 0 00 053754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37497									;IN THE SUBTEST) TO LOOP ON ERROR^
 37498
 37499					;**********
 37500
 37501					;THIS TEST VERIFIES THAT HLLOM PLACES C(AC-LEFT) INTO E-LEFT AND
 37502					;PLACES -1 INTO E-RIGHT.
 37503					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,,717171
 37504					;HENCE, THE RESULT IN E SHOULD BE 123456,,-1.
 37505
 37506	053754	200 01 0 00 070726 	C64600:	MOVE	1,[123456,,123422]	;PRELOAD AC WITH 123456,,123422
 37507	053755	200 02 0 00 070727 		MOVE	2,[707070,,717171]	;PRELOAD AC WITH 707070,,717171
 37508	053756	522 01 0 00 000002 		HLLOM	1,2		;*HLLOM SHOULD PLACE 123456,,-1 INTO E
 37509	053757	312 01 0 00 070726 		CAME	1,[123456,,123422]	;PASS IF C(AC) UNCHANGED
 37510						STOP^
 37511	053760	254 04 0 00 053761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37512	053761	324 00 0 00 053762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37513									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37514									;IN THE SUBTEST) TO LOOP ON ERROR^
 37515	053762	312 02 0 00 070733 		CAME	2,[123456,,-1]	;PASS IF C(E)=123456,,-1
 37516						STOP^
 37517	053763	254 04 0 00 053764 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37518	053764	324 00 0 00 053765 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37519									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37520									;IN THE SUBTEST) TO LOOP ON ERROR^
 37521
 37522					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37523					;THIS TEST VERIFIES THAT HRLO, C(E-RIGHT) INTO AC=LEFT AND
 37524					;PLACES -1 INTO AC-RIGHT.  IN THIS CASE, C(AC)=123456,,135724 AND
 37525					;C(E)=765432,,246135.  HENCE, THE RESULT IN THE AC SHOULD BE 246135,,-1
 37526
 37527	053765	200 15 0 00 070734 	C64700:	MOVE	15,[123456,,135724]	;PRELOAD AC WITH 123456,,135724
 37528	053766	200 16 0 00 070735 		MOVE	16,[765432,,246135]	;PRELOAD E WITH 765432,,246135
 37529	053767	524 15 0 00 000016 		HRLO	15,16		;*HRLO SHOULD PLACE 246135,,-1 INTO AC
 37530	053770	312 15 0 00 070736 		CAME	15,[246135,,-1]	;PASS IF C(AC)=246135,,-1
 37531						STOP^
 37532	053771	254 04 0 00 053772 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37533	053772	324 00 0 00 053773 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37535									;IN THE SUBTEST) TO LOOP ON ERROR^
 37536	053773	312 16 0 00 070735 		CAME	16,[765432,,246135]	;PASS IF C(E) UNCHANGED
 37537						STOP^
 37538	053774	254 04 0 00 053775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37539	053775	324 00 0 00 053776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37540									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37541									;IN THE SUBTEST) TO LOOP ON ERROR^
 37542
 37543					;**********
 37544
 37545					;THIS TEST VERIFIES THAT HRLOI PLACES 0,,E INTO AC-LEFT AND
 37546					;PLACES ONES INTO AC-RIGHT.  IN THIS CASE, C(AC)=0 AND E=0,,123456.
 37547					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,-1
 37548
 37549	053776	400 14 0 00 000000 	C65000:	SETZ	14,		;CLEAR AC
 37550	053777	525 14 0 00 123456 		HRLOI	14,123456	;*HRLOI SHOULD PLACE 123456,,-1 INTO THE AC
 37551	054000	312 14 0 00 070733 		CAME	14,[123456,,-1]	;PASS IF C(AC)=123456,,-1
 37552						STOP^
 37553	054001	254 04 0 00 054002 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37554	054002	324 00 0 00 054003 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37555									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37556									;IN THE SUBTEST) TO LOOP ON ERROR^
 37557
 37558					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 32
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37559					;THIS TEST VERIFIES THAT HRLOM PLACES C(AC-RIGHT) INTO E-LEFT
 37560					;AND PLACES -1 INTO E-RIGHT. IN THIS CASE, C(E)=0 AND C(AC)=123123,,456765
 37561					;HENCE, THE RESULT IN E SHOULD BE 456765,,-1.
 37562
 37563	054003	402 00 0 00 000014 	C65100:	SETZM	14		;CLEAR E
 37564	054004	200 13 0 00 070737 		MOVE	13,[123123,,456765]	;PRELOAD AC WITH 123123,,456765
 37565	054005	526 13 0 00 000014 		HRLOM	13,14		;*HRLOM SHOULD PLACE 456765,,-1 INTO E
 37566	054006	312 13 0 00 070737 		CAME	13,[123123,,456765]	;PASS IF C(AC) UNCHANGED
 37567
 37568						STOP^
 37569	054007	254 04 0 00 054010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37570	054010	324 00 0 00 054011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37571									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37572									;IN THE SUBTEST) TO LOOP ON ERROR^
 37573	054011	312 14 0 00 070740 		CAME	14,[456765,,-1]	;PASS IF C(E)=456765,,-1
 37574						STOP^
 37575	054012	254 04 0 00 054013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37576	054013	324 00 0 00 054014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37577									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37578									;IN THE SUBTEST) TO LOOP ON ERROR^
 37579
 37580					;**********
 37581
 37582
 37583					;THIS TEST VERIFIES THAT HRLOS PLACES C(E-RIGHT) INTO E-LEFT AND
 37584					;PLACES -1 INTO E-RIGHT. IF AC IS NON-ZERO, THE RESULT IN E IS ALOS
 37585					;PLACED INTO THE AC.
 37586					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,707076
 37587					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 0
 37588					;AND 707076,,0
 37589
 37590	054014	400 00 0 00 000000 	C65200:	SETZ	0,		;PRELOAD AC WITH 0
 37591	054015	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37592	054016	527 00 0 00 000016 		HRLOS	0,16		;*HRLZS SHOULD PLACE 707076,,-1
 37593									;INTO E.
 37594	054017	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37595						STOP^
 37596	054020	254 04 0 00 054021 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37597	054021	324 00 0 00 054022 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37598									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37599									;IN THE SUBTEST) TO LOOP ON ERROR^
 37600	054022	312 16 0 00 070741 		CAME	16,[707076,,-1]	;PASS IF C(AC)=707076,,-1
 37601						STOP^
 37602	054023	254 04 0 00 054024 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37603	054024	324 00 0 00 054025 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37604									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37605									;IN THE SUBTEST) TO LOOP ON ERROR^
 37606
 37607					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 33
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37608					;THIS TEST VERIFIES THAT HRLOS PLACES C(E-RIGHT) INTO E-LEFT AND
 37609					;PLACES -1 INTO E-RIGHT. IF AC IS NON-ZERO, THE RESULT IN E IS ALSO
 37610					;PLACED INTO THE AC.
 37611					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123456,,707076
 37612					;HENCE, THE RESULTS IN AC AND E RESPECTIVELY SHOULD BE 707076,,-1
 37613					;AND 707076,,-1
 37614
 37615	054025	400 01 0 00 000000 	C65210:	SETZ	1,		;PRELOAD AC WITH 0
 37616	054026	200 16 0 00 070731 		MOVE	16,[123456,,707076]	;PRELOAD E WITH 123456,,707076
 37617	054027	527 01 0 00 000016 		HRLOS	1,16		;*HRLZS SHOULD PLACE 707076,,-1
 37618									;INTO BOTH AC AND E
 37619	054030	312 01 0 00 070741 		CAME	1,[707076,,-1]	;PASS IF C(AC)=707076,,-1
 37620						STOP^
 37621	054031	254 04 0 00 054032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37622	054032	324 00 0 00 054033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37623									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37624									;IN THE SUBTEST) TO LOOP ON ERROR^
 37625	054033	312 16 0 00 070741 		CAME	16,[707076,,-1]	;PASS IF C(AC)=707076,,-1
 37626						STOP^
 37627	054034	254 04 0 00 054035 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37628	054035	324 00 0 00 054036 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37629									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37630									;IN THE SUBTEST) TO LOOP ON ERROR^
 37631
 37632					;**********
 37633
 37634					;THIS TEST VERIFIES THAT HLLEM PLACES C(AC-LEFT) INTO E-LEFT
 37635					;AND PLACES BIT 0 OF THE AC INTO BITS 18 THRU 35 OF E.  IN THIS CASE,
 37636					;C(AC)=123456,,707076 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 37637					;SHOULD BE 123456,,0.
 37638
 37639	054036	200 12 0 00 070731 	C65300:	MOVE	12,[123456,,707076]	;PRELOAD AC WITH 123456,,707076
 37640	054037	476 00 0 00 000013 		SETOM	13		;PRELOAD E WITH -1,,-1
 37641	054040	532 12 0 00 000013 		HLLEM	12,13		;*HLLEM SHOULD PLACE 123456,,0 INTO E
 37642	054041	312 12 0 00 070731 		CAME	12,[123456,,707076]	;PASS IF C(AC) UNCHANGED
 37643						STOP^
 37644	054042	254 04 0 00 054043 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37645	054043	324 00 0 00 054044 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37646									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37647									;IN THE SUBTEST) TO LOOP ON ERROR^
 37648	054044	312 13 0 00 070377 		CAME	13,[123456,,0]	;PASS IF C(E)=123456,,0
 37649						STOP^
 37650	054045	254 04 0 00 054046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37651	054046	324 00 0 00 054047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37652									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37653									;IN THE SUBTEST) TO LOOP ON ERROR^
 37654
 37655					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 34
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37656					;THIS TEST VERIFIES THAT HLLES PLACES C(E-LEFT) INTO E-LEFT AND
 37657					;PLACES BIT 0 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO
 37658					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37659					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=765432,,0.
 37660					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 37661					;AND 765432,,-1 RESPECTIVELY.
 37662
 37663	054047	400 00 0 00 000000 	C65400:	SETZ	0,		;CLEAR AC
 37664	054050	515 02 0 00 765432 		HRLZI	2,765432	;PRELOAD E WITH 765432,,0
 37665	054051	533 00 0 00 000002 		HLLES	0,2		;*HLLES SHOULD PLACE 765432,,-1
 37666									;INTO E
 37667	054052	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37668						STOP^
 37669	054053	254 04 0 00 054054 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37670	054054	324 00 0 00 054055 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37671									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37672									;IN THE SUBTEST) TO LOOP ON ERROR^
 37673	054055	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37674						STOP^
 37675	054056	254 04 0 00 054057 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37676	054057	324 00 0 00 054060 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37677									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37678									;IN THE SUBTEST) TO LOOP ON ERROR^
 37679
 37680					;**********
 37681
 37682					;THIS TEST VERIFIES THAT HLLES PLACES C(E-LEFT) INTO E-LEFT AND
 37683					;PLACES BIT 0 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO,
 37684					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37685					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=765432,,0
 37686					;HENCE, THE RESULTS IN AC AND E SHOULD BE 765432,,-1
 37687					;AND 765432,,-1 RESPECTIVELY
 37688
 37689	054060	400 01 0 00 000000 	C65410:	SETZ	1,		;CLEAR AC
 37690	054061	515 02 0 00 765432 		HRLZI	2,765432	;PRELOAD E WITH 765432,,0
 37691	054062	533 01 0 00 000002 		HLLES	1,2		;*HLLES SHOULD PLACE 765432,,-1
 37692									;INTO BOTH AC AND E
 37693	054063	312 01 0 00 070742 		CAME	1,[765432,,-1]	;PASS IF C(AC)=765432,,-1
 37694						STOP^
 37695	054064	254 04 0 00 054065 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37696	054065	324 00 0 00 054066 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37698									;IN THE SUBTEST) TO LOOP ON ERROR^
 37699	054066	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37700						STOP^
 37701	054067	254 04 0 00 054070 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37702	054070	324 00 0 00 054071 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37703									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37704									;IN THE SUBTEST) TO LOOP ON ERROR^
 37705
 37706					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 35
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37707					;THIS TEST VERIFIES THAT HLLEM PLACES C(AC-RIGHT) INTO E-LEFT
 37708					;AND PLACES BIT 18 OF THE AC INTO BITS 18 THRU 35 OF E.  IN THIS CASE,
 37709					;C(AC)=365432,123456 AND C(E)=-1,,-1.  HENCE, THE RESULT IN E
 37710					;SHOULD BE 365432,,0.
 37711
 37712	054071	200 12 0 00 070743 	C65500:	MOVE	12,[365432,,123456]	;PRELOAD AC WITH 365432,,123456
 37713	054072	476 00 0 00 000013 		SETOM	13		;PRELOAD E WITH -1,,-1
 37714	054073	532 12 0 00 000013 		HLLEM	12,13		;*HLLEM SHOULD PLACE 365432,,0 INTO E
 37715	054074	312 12 0 00 070743 		CAME	12,[365432,,123456]	;PASS IF C(AC) UNCHANGED
 37716						STOP^
 37717	054075	254 04 0 00 054076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37718	054076	324 00 0 00 054077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37720									;IN THE SUBTEST) TO LOOP ON ERROR^
 37721	054077	312 13 0 00 070744 		CAME	13,[365432,,0]	;PASS IF C(E)=365432,,0
 37722						STOP^
 37723	054100	254 04 0 00 054101 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37724	054101	324 00 0 00 054102 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37725									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37726									;IN THE SUBTEST) TO LOOP ON ERROR^
 37727
 37728					;**********
 37729
 37730					;THIS TEST VERIFIES THAT HRLES PLACES C(E-RIGHT) INTO E-LEFT AND
 37731					;PLACES BIT 18 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO,
 37732					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37733					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=0,,765432
 37734					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 37735					;AND 765432,,-1 RESPECTIVELY
 37736
 37737	054102	400 00 0 00 000000 	C65600:	SETZ	0,		;CLEAR AC
 37738	054103	551 02 0 00 765432 		HRRZI	2,765432	;PRELOAD E WITH 0,,765432
 37739	054104	537 00 0 00 000002 		HRLES	0,2		;*HLLES SHOULD PLACE 765432,,-1
 37740									;INTO
 37741	054105	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37742						STOP^
 37743	054106	254 04 0 00 054107 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37744	054107	324 00 0 00 054110 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37745									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37746									;IN THE SUBTEST) TO LOOP ON ERROR^
 37747	054110	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37748						STOP^
 37749	054111	254 04 0 00 054112 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37750	054112	324 00 0 00 054113 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37751									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37752									;IN THE SUBTEST) TO LOOP ON ERROR^
 37753
 37754					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 36
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37755					;THIS TEST VERIFIES THAT HRLES PLACES C(E-RIGHT) INTO E-LEFT AND
 37756					;PLACES BIT 18 OF E INTO BITS 18 THRU 35 OF E.  IF AC IS NON-ZERO,
 37757					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 37758					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=0,,765432
 37759					;HENCE, THE RESULTS IN AC AND E SHOULD BE 765432,,-1
 37760					;AND 765432,,-1 RESPECTIVELY.
 37761
 37762	054113	400 01 0 00 000000 	C65610:	SETZ	1,		;CLEAR AC
 37763	054114	551 02 0 00 765432 		HRRZI	2,765432	;PRELOAD E WITH 0,765432
 37764	054115	537 01 0 00 000002 		HRLES	1,2		;*HLLES SHOULD PLACE 765432,,-1
 37765									;INTO BOTH AC AND E
 37766	054116	312 01 0 00 070742 		CAME	1,[765432,,-1]	;PASS IF C(AC)=765442,,-1
 37767						STOP^
 37768	054117	254 04 0 00 054120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37769	054120	324 00 0 00 054121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37771									;IN THE SUBTEST) TO LOOP ON ERROR^
 37772	054121	312 02 0 00 070742 		CAME	2,[765432,,-1]	;PASS IF C(E)=765432,,-1
 37773						STOP^
 37774	054122	254 04 0 00 054123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37775	054123	324 00 0 00 054124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37776									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37777									;IN THE SUBTEST) TO LOOP ON ERROR^
 37778
 37779
 37780					;**********
 37781
 37782					;THIS TEST VERIFIES THAT HLRM SHOULD PLACE C(AC-LEFT) INTO E-RIGHT
 37783					;AND NOT AFFECT E-LEFT.  IN THIS CASE, C(AC)=123456,,701234
 37784					;AND C(E)=0.  HENCE, THE RESULT IN E SHOULD BE 0,,123456
 37785
 37786	054124	200 11 0 00 070745 	C65700:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 37787	054125	402 00 0 00 000012 		SETZM	12		;CLEAR E
 37788	054126	546 11 0 00 000012 		HLRM	11,12		;*HLRM SHOULD PLACE 0,,123456 INTO E
 37789	054127	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC) UNCHANGE
 37790						STOP^
 37791	054130	254 04 0 00 054131 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37792	054131	324 00 0 00 054132 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37793									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37794									;IN THE SUBTEST) TO LOOP ON ERROR^
 37795	054132	302 12 0 00 123456 		CAIE	12,123456	;PASS IF C(E)=0,,123456
 37796						STOP^
 37797	054133	254 04 0 00 054134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37798	054134	324 00 0 00 054135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37799									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37800									;IN THE SUBTEST) TO LOOP ON ERROR^
 37801
 37802					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 37
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37803					;THIS TEST VERIFIES THAT HLRS PLACES C(E-LEFT) INTO E-RIGHT AND
 37804					;DOES NOT AFFECT E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 37805					;IS ALSO PLACED INTO THE AC.
 37806					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123123,,246135
 37807					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 37808					;AND 123123,,123123 RESPECTIVELY.
 37809
 37810	054135	400 00 0 00 000000 	C66000:	SETZ	0,		;CLEAR AC
 37811	054136	200 12 0 00 070746 		MOVE	12,[123123,,246135]	;PRELOAD E WITH 123123,,246135
 37812	054137	547 00 0 00 000012 		HLRS	0,12		;*HLRS SHOULD PLACE 123123,,123123
 37813									;INTO E.
 37814	054140	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) UNCHANGED
 37815						STOP^
 37816	054141	254 04 0 00 054142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37817	054142	324 00 0 00 054143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37818									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37819									;IN THE SUBTEST) TO LOOP ON ERROR^
 37820	054143	312 12 0 00 070747 		CAME	12,[123123,,123123]	;PASS IF C(E)=123123,,123123
 37821						STOP^
 37822	054144	254 04 0 00 054145 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37823	054145	324 00 0 00 054146 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37824									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37825									;IN THE SUBTEST) TO LOOP ON ERROR^
 37826
 37827
 37828					;**********
 37829
 37830					;THIS TEST VERIFIES THAT HLRS PLACES C(E-LEFT) INTO E-RIGHT AND
 37831					;DOES NOT AFFECT E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 37832					;IS ALSO PLACED INTO THE AC.
 37833					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123123,,246135
 37834					;HENCE, THE RESULTS IN AC AND E SHOULD BE 123123,,123123
 37835					;AND 123123,,123123 RESPECTIVELY.
 37836
 37837	054146	400 01 0 00 000000 	C66010:	SETZ	1,		;CLEAR AC
 37838	054147	200 12 0 00 070746 		MOVE	12,[123123,,246135]	;PRELOAD E WITH 123123,,246135
 37839	054150	547 01 0 00 000012 		HLRS	1,12		;*HLRS SHOULD PLACE 123123,,123123
 37840									;INTO BOTH AC AND E.
 37841	054151	312 01 0 00 070747 		CAME	1,[123123,,123123]	;PASS IF C(AC)=123123,,123123
 37842						STOP^
 37843	054152	254 04 0 00 054153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37844	054153	324 00 0 00 054154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37845									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37846									;IN THE SUBTEST) TO LOOP ON ERROR^
 37847	054154	312 12 0 00 070747 		CAME	12,[123123,,123123]	;PASS IF C(E)=123123,,123123
 37848						STOP^
 37849	054155	254 04 0 00 054156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37850	054156	324 00 0 00 054157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37851									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37852									;IN THE SUBTEST) TO LOOP ON ERROR^
 37853
 37854					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37855					;THIS TEST VERIFIES THAT HRRZS CLEARS THE LEFT HALF OF E, BUT DOES NOT
 37856					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37857					;ALSO PLACED INTO THE AC.
 37858					;IN THIS CASE, AC = 0, C(AC) = -1,,-1 AND C(E) = 123456,,701234
 37859					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1 AND 0,,701234
 37860					;RESPECTIVELY.
 37861
 37862	054157	474 00 0 00 000000 	C66100:	SETO	0		;PRELOAD AC WITH -1,,-1
 37863	054160	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 37864	054161	553 00 0 00 000017 		HRRZS	0,17		;HRRZS SHOULD PLACE 0,,701234 INTO E
 37865	054162	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) UNCHANGED
 37866						STOP^
 37867	054163	254 04 0 00 054164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37868	054164	324 00 0 00 054165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37869									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37870									;IN THE SUBTEST) TO LOOP ON ERROR^
 37871	054165	302 17 0 00 701234 		CAIE	17,701234	;PASS IF C(E) = 0,,701234
 37872						STOP^
 37873	054166	254 04 0 00 054167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37874	054167	324 00 0 00 054170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37875									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37876									;IN THE SUBTEST) TO LOOP ON ERROR^
 37877
 37878					;**********
 37879
 37880					;THIS TEST VERIFIES THAT HRRZS CLEARS THE LEFT HALF OF E, BUT DOES NOT
 37881					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37882					;ALSO PLACED INTO THE AC.
 37883					;IN THIS CASE, AC = 1, C(AC) = -1,,-1 AND C(E) = 123456,,701234
 37884					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,701234 AND 0,,701234
 37885					;RESPECTIVELY.
 37886
 37887	054170	474 01 0 00 000000 	C66110:	SETO	1,		;PRELOAD AC WITH -1,,-1
 37888	054171	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 37889	054172	553 01 0 00 000017 		HRRZS	1,17		;HRRZS SHOULD PLACE 0,,701234 INTO
 37890									;BOTH AC AND E
 37891	054173	302 01 0 00 701234 		CAIE	1,701234	;PASS IF C(AC) = 0,,701234
 37892						STOP^
 37893	054174	254 04 0 00 054175 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37894	054175	324 00 0 00 054176 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37895									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37896									;IN THE SUBTEST) TO LOOP ON ERROR^
 37897	054176	302 17 0 00 701234 		CAIE	17,701234	;PASS IF C(E) = 0,,701234
 37898						STOP^
 37899	054177	254 04 0 00 054200 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37900	054200	324 00 0 00 054201 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37901									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37902									;IN THE SUBTEST) TO LOOP ON ERROR^
 37903
 37904					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37905					;THIS TEST VERIFIES THAT HLRZI CLEARS THE AC
 37906					;IN THIS CASE, C(AC) = -1,,-1 AND E = 0,,-1.  HENCE, THE
 37907					;RESULT IN THE AC SHOULD BE 0.
 37908
 37909	054201	474 00 0 00 000007 	C66200:	SETO	7		;PRELOAD AC WITH -1,,-1
 37910	054202	555 07 0 00 777777 		HLRZI	7,-1		;*HLRZI SHOULD CLEAR THE AC
 37911	054203	332 00 0 00 000007 		SKIPE	7		;PASS IF C(AC) = 0
 37912						STOP^
 37913	054204	254 04 0 00 054205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37914	054205	324 00 0 00 054206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37915									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37916									;IN THE SUBTEST) TO LOOP ON ERROR^
 37917
 37918					;**********
 37919
 37920					;THIS TEST VERIFIES THAT HLRZM PLACES C(AC-LEFT) INTO E-RIGHT AND
 37921					;PLACES 0 INTO E-LEFT.
 37922					;IN THIS CASE, C(AC) = 123456,,123422 AND C(E) = 707070,,717171
 37923					;HENCE, THE RESULT IN E SHOULD BE 0,,123456.
 37924
 37925	054206	200 01 0 00 070726 	C66300:	MOVE	1,[123456,,123422]  ;PRELOAD AC WITH 123456,,123422
 37926	054207	200 02 0 00 070727 		MOVE	2,[707070,,717171]  ;PRELOAD AC WITH 707070,,717171
 37927	054210	556 01 0 00 000002 		HLRZM	1,2		;*HLRZM SHOULD PLACE 0,,123456 INTO E.
 37928	054211	312 01 0 00 070726 		CAME	1,[123456,,123422]  ;PASS IF C(AC) UNCHANGED
 37929						STOP^
 37930	054212	254 04 0 00 054213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37931	054213	324 00 0 00 054214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37932									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37933									;IN THE SUBTEST) TO LOOP ON ERROR^
 37934	054214	302 02 0 00 123456 		CAIE	2,123456	;PASS IF C(E) = 0,,123456
 37935						STOP^
 37936	054215	254 04 0 00 054216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37937	054216	324 00 0 00 054217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37939									;IN THE SUBTEST) TO LOOP ON ERROR^
 37940
 37941					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37942					;THIS TEST VERIFIES THAT HLRZM PLACES C(AC-LEFT) INTO E-RIGHT AND
 37943					;PLACES 0 INTO E-LEFT.
 37944					;IN THIS CASE, C(AC) = 123456,,123422 AND C(E) = 707070,,717171
 37945					;HENCE, THE RESULT IN E SHOULD BE 0,,123456.
 37946
 37947	054217	200 01 0 00 070726 	C66301:	MOVE	1,[123456,,123422]  ;PRELOAD AC WITH 123456,,123422
 37948	054220	200 02 0 00 070727 		MOVE	2,[707070,,717171]  ;PRELOAD AC WITH 707070,,717171
 37949	054221	202 02 0 00 054233 		MOVEM	2,E66301
 37950	054222	556 01 0 00 054233 		HLRZM	1,E66301	;*HLRZM SHOULD PLACE 0,,123456 INTO E.
 37951	054223	312 01 0 00 070726 		CAME	1,[123456,,123422]  ;PASS IF C(AC) UNCHANGED
 37952						STOP^
 37953	054224	254 04 0 00 054225 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37954	054225	324 00 0 00 054226 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37955									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37956									;IN THE SUBTEST) TO LOOP ON ERROR^
 37957	054226	200 02 0 00 054233 		MOVE	2,E66301
 37958	054227	302 02 0 00 123456 		CAIE	2,123456	;PASS IF C(E) = 0,,123456
 37959						STOP^
 37960	054230	254 04 0 00 054231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37961	054231	324 00 0 00 054232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37963									;IN THE SUBTEST) TO LOOP ON ERROR^
 37964
 37965	054232	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 37966	054233	000000	000000		E66301:	0			;TEST WORD MEMORY
 37967
 37968					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 37969					;THIS TEST VERIFIES THAT HLRZS PLACES C(E-LEFT) INTO E-RIGHT AND
 37970					;PLACES 0 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E IS
 37971					;ALSO PLACED INTO THE AC.
 37972					;IN THIS CASE, AC = 0, C(AC) = -1,,-1 AND C(E) = 123456,,701234.
 37973					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1 AND 0,,123456
 37974					;RESPECTIVELY.
 37975
 37976	054234	474 00 0 00 000000 	C66400:	SETO	0,		;PRELOAD AC WITH -1,,-1
 37977	054235	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 37978	054236	557 00 0 00 000007 		HLRZS	0,7		;*HLRZS SHOULD PLACE 0,,123456 INTO E
 37979	054237	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) IS UNCHANGED
 37980						STOP^
 37981	054240	254 04 0 00 054241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37982	054241	324 00 0 00 054242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37983									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37984									;IN THE SUBTEST) TO LOOP ON ERROR^
 37985	054242	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E) = 0,,123456
 37986						STOP^
 37987	054243	254 04 0 00 054244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 37988	054244	324 00 0 00 054245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 37989									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 37990									;IN THE SUBTEST) TO LOOP ON ERROR^
 37991
 37992					;**********
 37993
 37994					;THIS TEST VERIFIES THAT HLRZS PLACES C(E-LEFT) INTO E-RIGHT AND
 37995					;PLACES 0 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 37996					;IS ALSO PLACED INTO THE AC.
 37997					;IN THIS CASE, AC = 6, C(AC) = -1,,-1 AND C(E) = 123456,,701234.
 37998					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,123456 AND 0123456
 37999					;RESPECTIVELY.
 38000
 38001	054245	474 06 0 00 000000 	C66410:	SETO	6,		;PRELOAD AC WITH -1,,-1
 38002	054246	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38003	054247	557 06 0 00 000007 		HLRZS	6,7		;*HLRZS SHOULD PLACE 0,,123456 INTO
 38004									;BOTH AC AND E
 38005	054250	302 06 0 00 123456 		CAIE	6,123456	;PASS IF C(AC) = 0,,123456
 38006						STOP^
 38007	054251	254 04 0 00 054252 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38008	054252	324 00 0 00 054253 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38009									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38010									;IN THE SUBTEST) TO LOOP ON ERROR^
 38011	054253	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E) = 0,,123456
 38012						STOP^
 38013	054254	254 04 0 00 054255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38014	054255	324 00 0 00 054256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38015									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38016									;IN THE SUBTEST) TO LOOP ON ERROR^
 38017
 38018					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 38019					;THIS TEST VERIFIES THAT HLRZS PLACES C(E-LEFT) INTO E-RIGHT AND
 38020					;PLACES 0 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 38021					;IS ALSO PLACED INTO THE AC.
 38022					;IN THIS CASE, AC = 6, C(AC) = -1,,-1 AND C(E) = 123456,,701234.
 38023					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,123456 AND 0123456
 38024					;RESPECTIVELY.
 38025
 38026	054256	474 06 0 00 000000 	C66411:	SETO	6,		;PRELOAD AC WITH -1,,-1
 38027	054257	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38028	054260	202 07 0 00 054272 		MOVEM	7,E66411
 38029	054261	557 06 0 00 054272 		HLRZS	6,E66411	;*HLRZS SHOULD PLACE 0,,123456 INTO
 38030									;BOTH AC AND E
 38031	054262	302 06 0 00 123456 		CAIE	6,123456	;PASS IF C(AC) = 0,,123456
 38032						STOP^
 38033	054263	254 04 0 00 054264 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38034	054264	324 00 0 00 054265 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38035									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38036									;IN THE SUBTEST) TO LOOP ON ERROR^
 38037	054265	200 07 0 00 054272 		MOVE	7,E66411
 38038	054266	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E) = 0,,123456
 38039						STOP^
 38040	054267	254 04 0 00 054270 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38041	054270	324 00 0 00 054271 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38042									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38043									;IN THE SUBTEST) TO LOOP ON ERROR^
 38044
 38045	054271	334 00 0 00 000000 		SKIPA			;GO TO NEXT TEST
 38046	054272	000000	000000		E66411:	0			;TEST WORD MEMORY
 38047
 38048					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 38049					;THIS TEST VERIFIES THAT HRROM PLACES C(AC-RIGHT) INTO E-RIGHT AND
 38050					;PLACES -1 INTO E-LEFT.  IN THIS CASE, C(AC) = 123456,,701234 AND
 38051					;C(E) = 0.  HENCE, THE RESULT IN E SHOULD BE -1,,601234.
 38052
 38053	054273	200 05 0 00 070745 	C66500:	MOVE	5,[123456,,701234]  ;PRELOAD AC WITH 123456,,701234
 38054	054274	402 00 0 00 000006 		SETZM	6		;CLEAR E
 38055	054275	562 05 0 00 000006 		HRROM	5,6		;*HRROM SHOULD PLACE -1,,701234 INTO E
 38056	054276	312 05 0 00 070745 		CAME	5,[123456,,701234]  ;PASS IF C(AC) UNCHANGED
 38057						STOP^
 38058	054277	254 04 0 00 054300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38059	054300	324 00 0 00 054301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38060									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38061									;IN THE SUBTEST) TO LOOP ON ERROR^
 38062	054301	312 06 0 00 070750 		CAME	6,[-1,,701234]	;PASS IF C(E) = -1,,701234
 38063						STOP^
 38064	054302	254 04 0 00 054303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38065	054303	324 00 0 00 054304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38066									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38067									;IN THE SUBTEST) TO LOOP ON ERROR^
 38068
 38069
 38070					;**********
 38071
 38072					;THIS TEST VERIFIES THAT HRROS PLACES -1 INTO THE LEFT HALF OF E, BUT DOES NOT
 38073					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO THE RESULT IN E IS
 38074					;ALSO PLACED INTO THE AC.
 38075					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,701234
 38076					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 38077					;AND -1,,701234 RESPECTIVELY.
 38078
 38079	054304	400 00 0 00 000000 	C66600:	SETZ	0		;PRELOAD AC WITH 0
 38080	054305	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38081	054306	563 00 0 00 000017 		HRROS	0,17		;HRROS SHOULD PLACE -1,,701234 INTO E
 38082	054307	312 00 0 00 070253 		CAME	0,[0]		;PASS IF C(AC) IS UNCHANGED
 38083						STOP^
 38084	054310	254 04 0 00 054311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38085	054311	324 00 0 00 054312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38086									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38087									;IN THE SUBTEST) TO LOOP ON ERROR^
 38088	054312	312 17 0 00 070750 		CAME	17,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38089						STOP^
 38090	054313	254 04 0 00 054314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38091	054314	324 00 0 00 054315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38092									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38093									;IN THE SUBTEST) TO LOOP ON ERROR^
 38094
 38095					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 38096					;THIS TEST VERIFIES THAT HRROS PLACES -1 INTO THE LEFT HALF OF E, BUT DOES NOT
 38097					;AFFECT THE RIGHT HALF OF E.  IF AC IS NON-ZERO THE RESULT IN E IS
 38098					;ALSO PLACED INTO THE AC.
 38099					;IN THIS CASE, AC=16, C(AC)=0 AND C(E)=123456,,701234
 38100					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,701234
 38101					;AND -1,,701234 RESPECTIVELY.
 38102
 38103	054315	400 16 0 00 000000 	C66610:	SETZ	16,		;PRELOAD AC WITH 0
 38104	054316	200 17 0 00 070745 		MOVE	17,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38105	054317	563 16 0 00 000017 		HRROS	16,17		;*HRROS SHOULD PLACE -1,,701234 INTO
 38106									;BOTH AC AND E
 38107	054320	312 16 0 00 070750 		CAME	16,[-1,,701234]	;PASS IF C(AC)=-1,,701234
 38108						STOP^
 38109	054321	254 04 0 00 054322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38110	054322	324 00 0 00 054323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38111									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38112									;IN THE SUBTEST) TO LOOP ON ERROR^
 38113	054323	312 17 0 00 070750 		CAME	17,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38114						STOP^
 38115	054324	254 04 0 00 054325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38116	054325	324 00 0 00 054326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38117									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38118									;IN THE SUBTEST) TO LOOP ON ERROR^
 38119
 38120					;**********
 38121
 38122					;THIS TEST VERIFIES THAT HLRO PLACES C(E-LEFT) INTO AC-RIGHT AND
 38123					;PLACES -1 INTO AC-LEFT.  IN THIS CASE, C(AC)=0
 38124					;C(E)=765432,,107654.  HENCE, THE RESULT IN THE AC SHOULD BE -1,,765432.
 38125
 38126	054326	400 04 0 00 000000 	C66700:	SETZ	4,		;CLEAR AC
 38127	054327	200 05 0 00 070751 		MOVE	5,[765432,,107654]  ;PRELOAD E WITH 765432,,107654
 38128	054330	564 04 0 00 000005 		HLRO	4,5		;*HLRO SHOULD PLACE -1,,765432 INTO THE AC
 38129	054331	312 04 0 00 070752 		CAME	4,[-1,,765432]	;PASS IF C(AC)=-1,,765432
 38130						STOP^
 38131	054332	254 04 0 00 054333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38132	054333	324 00 0 00 054334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38133									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38134									;IN THE SUBTEST) TO LOOP ON ERROR^
 38135	054334	312 05 0 00 070751 		CAME	5,[765432,,107654]  ;PASS IF C(E) IS UNCHANGED
 38136						STOP^
 38137	054335	254 04 0 00 054336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38138	054336	324 00 0 00 054337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38139									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38140									;IN THE SUBTEST) TO LOOP ON ERROR^
 38141
 38142					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 38143					;THIS TEST VERIFIES THAT HLROI PLACES -1,,0 INTO THE AC.
 38144					;IN THIS CASE, C(AC)=123456,,765432 AND E=070707.  HENCE, THE
 38145					;RESULT IN THE AC SHOULD BE -1,,0
 38146
 38147	054337	200 03 0 00 070376 	C67000:	MOVE	3,[123456,,765432]  ;PRELOAD AC WITH 123456,,765432
 38148	054340	565 03 0 00 070707 		HLROI	3,070707	;*HLROI SHOULD PLACE -1,,0 INTO THE AC
 38149	054341	312 03 0 00 070331 		CAME	3,[-1,,0]	;PASS IF C(AC)=-1,,0
 38150						STOP^
 38151	054342	254 04 0 00 054343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38152	054343	324 00 0 00 054344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38154									;IN THE SUBTEST) TO LOOP ON ERROR^
 38155
 38156					;**********
 38157
 38158					;THIS TEST VERIFIES THAT HLROM PLACES C(AC-LEFT) INTO E RIGHT AND
 38159					;PLACES -1 INTO E-LEFT
 38160					;IN THIS CASE, C(AC)=123456,,123422 AND C(E)=707070,,717171
 38161					;HENCE, THE RESULT IN E SHOULD BE -1,,123456
 38162
 38163	054344	200 01 0 00 070726 	C67100:	MOVE	1,[123456,,123422]  ;PRELOAD AC WITH 123456,,123422
 38164	054345	200 02 0 00 070727 		MOVE	2,[707070,,717171]  ;PRELOAD AC WITH 707070,,717171
 38165	054346	566 01 0 00 000002 		HLROM	1,2		;*HLROM SHOULD PLACE -1,,123456 INTO E
 38166	054347	312 01 0 00 070726 		CAME	1,[123456,,123422]  ;PASS IF C(AC) UNCHANGED
 38167						STOP^
 38168	054350	254 04 0 00 054351 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38169	054351	324 00 0 00 054352 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38170									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38171									;IN THE SUBTEST) TO LOOP ON ERROR^
 38172	054352	312 02 0 00 070753 		CAME	2,[-1,,123456]	;PASS IF C(E)=-1,,123456
 38173						STOP^
 38174	054353	254 04 0 00 054354 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38175	054354	324 00 0 00 054355 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38176									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38177									;IN THE SUBTEST) TO LOOP ON ERROR^
 38178
 38179					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 46
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 38180					;THIS TEST VERIFIES THAT HLROS PLACES C(E-LEFT) INTO E-RIGHT AND
 38181					;PLACES -1 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 38182					;IS ALSO PLACED INTO THE AC.
 38183					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,701234.
 38184					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0
 38185					;AND -1,,123456 RESPECTIVELY
 38186
 38187	054355	400 00 0 00 000000 	C67200:	SETZ	0		;PRELOAD AC WITH 0
 38188	054356	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38189	054357	567 00 0 00 000007 		HLROS	0,7		;*HLROS SHOULD PLACE -1,,123456 INTO E
 38190									;
 38191	054360	302 00 0 00 000000 		CAIE	0,0		;PASS IF C(AC) IS UNCHANGED
 38192						STOP^
 38193	054361	254 04 0 00 054362 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38194	054362	324 00 0 00 054363 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38195									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38196									;IN THE SUBTEST) TO LOOP ON ERROR^
 38197	054363	312 07 0 00 070753 		CAME	7,[-1,,123456]	;PASS IF C(E)=-1,,123456
 38198						STOP^
 38199	054364	254 04 0 00 054365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38200	054365	324 00 0 00 054366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38201									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38202									;IN THE SUBTEST) TO LOOP ON ERROR^
 38203
 38204					;**********
 38205
 38206					;THIS TEST VERIFIES THAT HLROS PLACES C(E-LEFT) INTO E-RIGHT AND
 38207					;PLACES -1 INTO E-LEFT.  IF AC IS NON-ZERO, THE RESULT IN E
 38208					;IS ALSO PLACED INTO THE AC.
 38209					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123456,,701234.
 38210					;HENCE, THE RESULT IN AC AND E SHOULD BE -1,,123456
 38211					;AND -1,,123456 RESPECTIVELY.
 38212
 38213	054366	400 01 0 00 000000 	C67210:	SETZ	1,		;PRELOAD AC WITH 0
 38214	054367	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38215	054370	567 01 0 00 000007 		HLROS	1,7		;*HLROS SHOULD PLACE -1,,123456 INTO
 38216									;BOTH AC AND E
 38217	054371	312 01 0 00 070753 		CAME	1,[-1,,123456]	;PASS IF C(AC)=-1,,123456
 38218						STOP^
 38219	054372	254 04 0 00 054373 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38220	054373	324 00 0 00 054374 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38221									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38222									;IN THE SUBTEST) TO LOOP ON ERROR^
 38223	054374	312 07 0 00 070753 		CAME	7,[-1,,123456]	;PASS IF C(E)=-1,,123456
 38224						STOP^
 38225	054375	254 04 0 00 054376 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38226	054376	324 00 0 00 054377 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38227									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38228									;IN THE SUBTEST) TO LOOP ON ERROR^
 38229
 38230					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 47
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 38231					;THIS TEST VERIFIES THAT HRRES PLACES C(E-RIGHT) INTO E-RIGHT
 38232					;AND PLACES BIT 18 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS NON-ZERO,
 38233					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38234					;IN THIS CASE, AC=0, C(AC)=0 AND C(E)=123456,,701234
 38235					;HENCE, THE RESULT IN AC AND E SHOULD BE 0
 38236					;AND -1,,701234 RESPECTIVELY.
 38237
 38238	054377	400 00 0 00 000000 	C67300:	SETZ	0,		;PRELOAD AC WITH 0
 38239	054400	200 03 0 00 070745 		MOVE	3,[123456,,701234]  ;PRELOAD WITH 123456,,701234
 38240	054401	573 00 0 00 000003 		HRRES	0,3		;HRRES SHOULD PLACE -1,,701234 INTO E
 38241
 38242	054402	332 00 0 00 000000 		SKIPE			;PASS IF C(AC) IS UNCHANGED
 38243						STOP^
 38244	054403	254 04 0 00 054404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38245	054404	324 00 0 00 054405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38246									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38247									;IN THE SUBTEST) TO LOOP ON ERROR^
 38248	054405	312 03 0 00 070750 		CAME	3,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38249						STOP^
 38250	054406	254 04 0 00 054407 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38251	054407	324 00 0 00 054410 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38252									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38253									;IN THE SUBTEST) TO LOOP ON ERROR^
 38254
 38255					;**********
 38256
 38257					;THIS TEST VERIFIES THAT HRRES, PLACES C(E-RIGHT) INTO E-RIGHT
 38258					;AND PLACES BIT 18 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS NON-ZERO,
 38259					;THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38260					;IN THIS CASE, AC=1, C(AC)=0 AND C(E)=123456,,701234.
 38261					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,701234
 38262					;AND -1,,701234 RESPECTIVELY.
 38263
 38264	054410	400 01 0 00 000000 	C67310:	SETZ	1,		;PRELOAD AC WITH 0
 38265	054411	200 03 0 00 070745 		MOVE	3,[123456,,701234]  ;PRELOAD WITH 123456,,701234
 38266	054412	573 01 0 00 000003 		HRRES	1,3		;HRRES SHOULD PLACE -1,,701234 INTO
 38267									;BOTH AC AND E
 38268	054413	312 01 0 00 070750 		CAME	1,[-1,,701234]	;PASS IF C(AC)=-1,,701234
 38269						STOP^
 38270	054414	254 04 0 00 054415 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38271	054415	324 00 0 00 054416 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38273									;IN THE SUBTEST) TO LOOP ON ERROR^
 38274	054416	312 03 0 00 070750 		CAME	3,[-1,,701234]	;PASS IF C(E)=-1,,701234
 38275						STOP^
 38276	054417	254 04 0 00 054420 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38277	054420	324 00 0 00 054421 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38278									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38279									;IN THE SUBTEST) TO LOOP ON ERROR^
 38280
 38281					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 48
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL HWT INSTRUCTIONS

 38282					;THIS TEST VERIFIES THAT HLRES PLACES C(E-LEFT) INTO E-RIGHT
 38283					;AND PLACES BIT 0 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS
 38284					;NON-ZERO, THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38285					;IN THIS CASE, AC=0, C(AC)=-1,,-1 AND C(E) 123456,,701234
 38286					;HENCE, THE RESULTS IN AC AND E SHOULD BE -1,,-1
 38287					;AND 0,,123456 RESPECTIVELY.
 38288
 38289	054421	474 00 0 00 000000 	C67400:	SETO	0,		;PRELOAD AC WITH -1,,-1
 38290	054422	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38291	054423	577 00 0 00 000007 		HLRES	0,7		;*HLRES SHOULD PLACE 0,,123456 INTO E
 38292
 38293	054424	312 00 0 00 070254 		CAME	0,[-1]		;PASS IF C(AC) IS UNCHANGED
 38294						STOP^
 38295	054425	254 04 0 00 054426 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38296	054426	324 00 0 00 054427 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38297									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38298									;IN THE SUBTEST) TO LOOP ON ERROR^
 38299	054427	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E)=0,,123456
 38300						STOP^
 38301	054430	254 04 0 00 054431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38302	054431	324 00 0 00 054432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38304									;IN THE SUBTEST) TO LOOP ON ERROR^
 38305
 38306					;**********
 38307
 38308					;THIS TEST VERIFIES THAT HLRES PLACES C(E-LEFT) INTO E-RIGHT
 38309					;AND PLACES BIT 0 OF E INTO BITS 0 THRU 17 OF E.  IF AC IS
 38310					;NON-ZERO, THE RESULT IN E IS ALSO PLACED INTO THE AC.
 38311					;IN THIS CASE, AC=1, C(AC)=-1,,-1 AND C(E) 123456,,701234.
 38312					;HENCE, THE RESULTS IN AC AND E SHOULD BE 0,,123456
 38313					;AND 0,,123456 RESPECTIVELY.
 38314
 38315	054432	474 01 0 00 000000 	C67410:	SETO	1,		;PRELOAD AC WITH -1,,-1
 38316	054433	200 07 0 00 070745 		MOVE	7,[123456,,701234]  ;PRELOAD E WITH 123456,,701234
 38317	054434	577 01 0 00 000007 		HLRES	1,7		;*HLRES SHOULD PLACE 0,,123456 INTO
 38318									;BOTH AC AND E
 38319	054435	302 01 0 00 123456 		CAIE	1,123456	;PASS IF C(AC)=0,,123456
 38320						STOP^
 38321	054436	254 04 0 00 054437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38322	054437	324 00 0 00 054440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38323									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38324									;IN THE SUBTEST) TO LOOP ON ERROR^
 38325	054440	302 07 0 00 123456 		CAIE	7,123456	;PASS IF C(E)=0,,123456
 38326						STOP^
 38327	054441	254 04 0 00 054442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38328	054442	324 00 0 00 054443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38329									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38330									;IN THE SUBTEST) TO LOOP ON ERROR^
 38331
 38332					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 49
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38333					SUBTTL	TEST OF MSCL LOGICAL TEST INSTRUCTIONS
 38334
 38335					;**********
 38336
 38337					;THIS TEST VERIFIES THAT TRNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38338					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 38339					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38340					;HENCE, TRNE SHOULD SKIP THE NEXT INSTRUCTION.  THE AC IS ALSO
 38341					;CHECKED FOR NO MODIFICATION.
 38342
 38343	054443	200 17 0 00 070745 	C67500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38344	054444	602 17 0 00 000003 		TRNE	17,3			;*TRNE SHOULD SKIP THE NEXT INSTRUCTION
 38345						STOP^
 38346	054445	254 04 0 00 054446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38347	054446	324 00 0 00 054447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38348									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38349									;IN THE SUBTEST) TO LOOP ON ERROR^
 38350	054447	312 17 0 00 070745 		CAME	17,[123456,,701234]	;PASS IF C AC) UNCHANGED
 38351						STOP^
 38352	054450	254 04 0 00 054451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38353	054451	324 00 0 00 054452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38354									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38355									;IN THE SUBTEST) TO LOOP ON ERROR^
 38356
 38357					;**********
 38358
 38359					;THIS TEST VERIFIES THAT TRNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38360					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 38361					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38362					;HENCE, TRNE SHOULD NOT SKIP THE NEXT INSTRUCTION.  THE AC IS ALSO
 38363					;CHECKED FOR NO MODIFICATION.
 38364
 38365	054452	200 16 0 00 070745 	C67510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38366	054453	602 16 0 00 000300 		TRNE	16,300			;*TRNE SHOULD NOT SKIP THE NEXT INSTRUCTION
 38367	054454	334 00 0 00 000000 		SKIPA				;PASS IF TRNE DID NOT SKIP
 38368						STOP^
 38369	054455	254 04 0 00 054456 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38370	054456	324 00 0 00 054457 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38371									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38372									;IN THE SUBTEST) TO LOOP ON ERROR^
 38373	054457	312 16 0 00 070745 		CAME	16,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38374						STOP^
 38375	054460	254 04 0 00 054461 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38376	054461	324 00 0 00 054462 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38377									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38378									;IN THE SUBTEST) TO LOOP ON ERROR^
 38379
 38380					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 50
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38381					;THIS TEST VERIFIES THAT TLNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38382					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38383					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38384					;HENCE, TLNE SHOULD SKIP THE NEXT INSTRUCTION, THE AC IS ALSO
 38385					;CHECKED FOR NO MODIFICATION.
 38386
 38387	054462	200 15 0 00 070745 	C67600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38388	054463	603 15 0 00 000300 		TLNE	15,300			;*TLNE CHOULD SKIP
 38389						STOP^
 38390	054464	254 04 0 00 054465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38391	054465	324 00 0 00 054466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38392									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38393									;IN THE SUBTEST) TO LOOP ON ERROR^
 38394	054466	312 15 0 00 070745 		CAME	15,[123456,,701234]	;PASS IF C(AC) IS UNCHANGED
 38395						STOP^
 38396	054467	254 04 0 00 054470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38397	054470	324 00 0 00 054471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38398									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38399									;IN THE SUBTEST) TO LOOP ON ERROR^
 38400
 38401					;**********
 38402
 38403					;THIS TEST VERIFIES THAT TLNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38404					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO
 38405					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38406					;HENCE, TLNE SHOULD NOT SKIP THE NEXT INSTRUCTION, THE AC IS ALSO
 38407					;CHECKED FOR NO MODIFICATION
 38408
 38409	054471	200 14 0 00 070745 	C67610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38410	054472	603 14 0 00 000003 		TLNE	14,3			;*TLNE SHOULD NOT SKIP
 38411	054473	334 00 0 00 000000 		SKIPA				;PASS IF TLNE DID NOT SKIP
 38412						STOP^
 38413	054474	254 04 0 00 054475 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38414	054475	324 00 0 00 054476 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38415									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38416									;IN THE SUBTEST) TO LOOP ON ERROR^
 38417	054476	312 14 0 00 070745 		CAME	14,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38418						STOP^
 38419	054477	254 04 0 00 054500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38420	054500	324 00 0 00 054501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38421									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38422									;IN THE SUBTEST) TO LOOP ON ERROR^
 38423
 38424					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 51
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38425					;THIS TEST VERIFIES THAT TRNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38426					;INSTRUCTION.  HENCE, TRNA IS INDEPENDENT OF BOTH C(A) AND E
 38427					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38428					;HENCE, TRNA SHOULD SKIP THENEXT INSTRUCTION AND NOT ALTER C(AC).
 38429
 38430	054501	200 13 0 00 070745 	C67700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38431	054502	604 13 0 00 000003 		TRNA	13,3			;*TRNA SHOULD ALWAYS SKIP
 38432						STOP^
 38433	054503	254 04 0 00 054504 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38434	054504	324 00 0 00 054505 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38435									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38436									;IN THE SUBTEST) TO LOOP ON ERROR^
 38437	054505	312 13 0 00 070745 		CAME	13,[123456,,701234]	;PASS IFC(AC) UNCHANGED
 38438						STOP^
 38439	054506	254 04 0 00 054507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38440	054507	324 00 0 00 054510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38441									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38442									;IN THE SUBTEST) TO LOOP ON ERROR^
 38443
 38444					;**********
 38445
 38446					;THIS TEST VERIFhES THAT TRNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38447					;INSTRUCTION.  HENCE, TRNA IS INDEPENDENT OF BOTH C(A) AND E.
 38448					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38449					;HENCE, TRNA SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38450
 38451	054510	200 12 0 00 070745 	C67710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38452	054511	604 12 0 00 000300 		TRNA	12,300			;*TRNA SHOQLD ALWAYS SKIP
 38453						STOP^
 38454	054512	254 04 0 00 054513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38455	054513	324 00 0 00 054514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38456									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38457									;IN THE SUBTEST) TO LOOP ON ERROR^
 38458	054514	312 12 0 00 070745 		CAME	12,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38459						STOP^
 38460	054515	254 04 0 00 054516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38461	054516	324 00 0 00 054517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38462									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38463									;IN THE SUBTEST) TO LOOP ON ERROR^
 38464
 38465					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 52
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38466					;THIS TEST VERIFIaS THAT TLNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38467					;INSTRUCTION.  HENCE, TLNA IS INDEPENDENt OF BOTH C(AC) AND E.
 38468					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38469					;HENCE, TLNA SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38470
 38471	054517	200 11 0 00 070745 	C70000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38472	054520	605 11 0 00 000003 		TLNA	11,3			;*TLNA SHOULD ALWAYS SKIP
 38473						STOP^
 38474	054521	254 04 0 00 054522 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38475	054522	324 00 0 00 054523 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38476									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38477									;IN THE SUBTEST) TO LOOP ON ERROR^
 38478	054523	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38479						STOP^
 38480	054524	254 04 0 00 054525 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38481	054525	324 00 0 00 054526 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38482									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38483									;IN THE SUBTEST) TO LOOP ON ERROR^
 38484
 38485					;**********
 38486
 38487					;THIS TEST VERIFIES THAT TLNA ALWAYS SKIPS THE NEXT SEQUENTIAL
 38488					;INSTRUCTION.  HENCE, TLNA IS INDEPENDENT OF BOTH C(AC) AND E.
 38489					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38490					;HENCE, TLNA SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38491
 38492	054526	200 10 0 00 070745 	C70010:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38493	054527	605 10 0 00 000300 		TLNA	10,300			;*TLNA SHOULD ALWAYS SKIP
 38494						STOP^
 38495	054530	254 04 0 00 054531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38496	054531	324 00 0 00 054532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38497									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38498									;IN THE SUBTEST) TO LOOP ON ERROR^
 38499	054532	312 10 0 00 070745 		CAME	10,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38500						STOP^
 38501	054533	254 04 0 00 054534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38502	054534	324 00 0 00 054535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38503									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38504									;IN THE SUBTEST) TO LOOP ON ERROR^
 38505
 38506					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 53
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38507					;THIS TEST VERIFIES THAT TRNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38508					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN
 38509					;E ARE ZERO.  IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38510					;HENCE, TRNN SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38511
 38512	054535	200 07 0 00 070745 	C70100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38513	054536	606 07 0 00 000300 		TRNN	7,300			;*TRNN SHOULD SKIP
 38514						SToP^
 38515	054537	254 04 0 00 054540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38516	054540	324 00 0 00 054541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38517									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38518									;IN THE SUBTEST) TO LOOP ON ERROR^
 38519	054541	312 07 0 00 070745 		CAME	7,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38520						STOP^
 38521	054542	254 04 0 00 054543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38522	054543	324 00 0 00 054544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38523									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38524									;IN THE SUBTEST) TO LOOP ON ERROR^
 38525
 38526					;**********
 38527
 38528					;THIS TEST VERIFIES THAT TRNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38529					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN
 38530					;E ARE ZERO.  IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38531					;HENCE, TRNN SHoULD NOT SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38532
 38533	054544	200 06 0 00 070745 	C70110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38534	054545	606 06 0 00 000003 		TRNN	6,3			;*TRNN SHOULD NOT SKIP
 38535	054546	334 00 0 00 000000 		SKIPA				;PASS IF TRNN DID NOT SKIP
 38536						STOP^
 38537	054547	254 04 0 00 054550 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38538	054550	324 00 0 00 054551 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38539									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38540									;IN THE SUBTEST) TO LOOP ON ERROR^
 38541	054551	312 06 0 00 070745 		CAME	6,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38542						STOP^
 38543	054552	254 04 0 00 054553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38544	054553	324 00 0 00 054554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38545									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38546									;IN THE SUBTEST) TO LOOP ON ERROR^
 38547
 38548					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 54
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38549					;THIS TEST VERIFIES THAT TLNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38550					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38551					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38552					;HENCE, TLNN SHOULD SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38553
 38554	054554	200 05 0 00 070745 	C70200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38555	054555	607 05 0 00 000003 		TLNN	5,3			;*TLNN SHOULD SKIP
 38556						STOP^
 38557	054556	254 04 0 00 054557 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38558	054557	324 00 0 00 054560 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38559									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38560									;IN THE SUBTEST) TO LOOP ON ERROR^
 38561	054560	312 05 0 00 070745 		CAME	5,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38562						STOP^
 38563	054561	254 04 0 00 054562 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38564	054562	324 00 0 00 054563 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38565									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38566									;IN THE SUBTEST) TO LOOP ON ERROR^
 38567
 38568					;**********
 38569
 38570					;THIS TEST VERIFIES thAT TLNN SkIPS THE NEXT SEQUENTIAL INSTRUcTION
 38571					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38572					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38573					;HENCE, TLNN SHOULD NOT SKIP THE NEXT INSTRUCTION AND NOT ALTER C(AC).
 38574
 38575	054563	200 04 0 00 070745 	C70210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38576	054564	607 04 0 00 000300 		TLNN	4,300			;*TLNN SHOULD NOT SKIP
 38577	054565	334 00 0 00 000000 		SKIPA				;PASS IF TLNN DOES NOT SKIP
 38578						STOP^
 38579	054566	254 04 0 00 054567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38580	054567	324 00 0 00 054570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38581									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38582									;IN THE SUBTEST) TO LOOP ON ERROR^
 38583	054570	312 04 0 00 070745 		CAME	4,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38584						STOP^
 38585	054571	254 04 0 00 054572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38586	054572	324 00 0 00 054573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38587									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38588									;IN THE SUBTEST) TO LOOP ON ERROR^
 38589
 38590					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 55
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38591					;THIS TEST VERIFIES THAT TSNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38592					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38593					;BOTH HALVES SNAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38594					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 38595					;HENCE, TSNE SHOULD SKIP THE NEXT INSTRUCtION AND
 38596					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED.
 38597
 38598	054573	200 03 0 00 070745 	C70300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38599	054574	200 04 0 00 070754 		MOVE	4,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 38600	054575	613 03 0 00 000004 		TSNE	3,4			;*TSNE SHOULD SKIP
 38601						STOP^
 38602	054576	254 04 0 00 054577 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38603	054577	324 00 0 00 054600 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38604									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38605									;IN THE SUBTEST) TO LOOP ON ERROR^
 38606	054600	312 03 0 00 070745 		CAME	3,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38607						STOP^
 38608	054601	254 04 0 00 054602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38609	054602	324 00 0 00 054603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38610									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38611									;IN THE SUBTEST) TO LOOP ON ERROR^
 38612	054603	312 04 0 00 070754 		CAME	4,[76543,,654321]	;PASS IF C(E) UNCHANGED
 38613						STOP^
 38614	054604	254 04 0 00 054605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38615	054605	324 00 0 00 054606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38616									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38617									;IN THE SUBTEST) TO LOOP ON ERROR^
 38618
 38619					;**********
 38620
 38621					;THIS TEST VERIFIES THAT TSNE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38622					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38623					;BOTH HALVES SNAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38624					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654323
 38625					;HENCE, TSNE SHOULD NOT SKIP THE NEXT INSTRUCTION AND
 38626					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED.
 38627
 38628	054606	200 02 0 00 070745 	C70310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38629	054607	200 03 0 00 070755 		MOVE	3,[76543,,654323]	;PRELOAD E WITH 076543,,654323
 38630	054610	613 02 0 00 000003 		TSNE	2,3			;*TSNE SHOULD NOT SKIP
 38631	054611	334 00 0 00 000000 		SKIPA				;PASS IF TSOE DId NOT SKIP
 38632						STOP^
 38633	054612	254 04 0 00 054613 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38634	054613	324 00 0 00 054614 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38635									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38636									;IN THE SUBTEST) TO LOOP ON ERROR^
 38637	054614	312 02 0 00 070745 		CAME	2,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38638						STOP^
 38639	054615	254 04 0 00 054616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38640	054616	324 00 0 00 054617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38641									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38642									;IN THE SUBTEST) TO LOOP ON ERROR^
 38643	054617	312 03 0 00 070755 		CAME	3,[76543,,654323]	;PASS IF C(E) UNCHANGED
 38644						STOP^
 38645	054620	254 04 0 00 054621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 55-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38646	054621	324 00 0 00 054622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38647									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38648									;IN THE SUBTEST) TO LOOP ON ERROR^
 38649
 38650					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 56
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38651					;THIS TEST VERIFIES THAT TSNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38652					;NEITHER AC NOR E ARE AFFECTED.
 38653					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 38654					;HENCE, TSNA SHOULD SKIP THE NEXT INSTRUCTION AND
 38655					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38656
 38657	054622	200 01 0 00 070745 	C70400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38658	054623	200 02 0 00 070754 		MOVE	2,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 38659	054624	615 01 0 00 000002 		TSNA	1,2			;*TSNA SHOULD SKIP
 38660						STOP^
 38661	054625	254 04 0 00 054626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38662	054626	324 00 0 00 054627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38663									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38664									;IN THE SUBTEST) TO LOOP ON ERROR^
 38665	054627	312 01 0 00 070745 		CAME	1,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38666						STOP^
 38667	054630	254 04 0 00 054631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38668	054631	324 00 0 00 054632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38669									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38670									;IN THE SUBTEST) TO LOOP ON ERROR^
 38671	054632	312 02 0 00 070754 		CAME	2,[76543,,654321]	;PASS IF C(E) UNCHANGED
 38672						STOP^
 38673	054633	254 04 0 00 054634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38674	054634	324 00 0 00 054635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38675									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38676									;IN THE SUBTEST) TO LOOP ON ERROR^
 38677
 38678					;**********
 38679
 38680					;THIS TEST VERIFIES THAT TSNA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38681					;NEITHER AC NOR E ARE EFFECTED.
 38682					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654323
 38683					;HENCE, TSNA SHOULD SKIP THE NEXT INSTRUCTION AND
 38684					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38685
 38686	054635	200 00 0 00 070745 	C70410:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38687	054636	200 01 0 00 070755 		MOVE	1,[76543,,654323]	;PRELOAD E WITH 076543,,654323
 38688	054637	615 00 0 00 000001 		TSNA	0,1			;*TSNA SHOULD SKIP
 38689						STOP^
 38690	054640	254 04 0 00 054641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38691	054641	324 00 0 00 054642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38692									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38693									;IN THE SUBTEST) TO LOOP ON ERROR^
 38694	054642	312 01 0 00 070755 		CAME	1,[76543,,654323]	;PASS IF C(E) UNCHANGED
 38695						STOP^
 38696	054643	254 04 0 00 054644 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38697	054644	324 00 0 00 054645 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38698									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38699									;IN THE SUBTEST) TO LOOP ON ERROR^
 38700
 38701					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38702					;THIS TEST VERIFIES THAT TSNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38703					;IF AND ONLY IF NOT ALL HITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38704					;BOTH HALVES SWAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38705					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076547,,654321
 38706					;HENCE, TSNN SHOULD SKIP THE NEXT INSTRUCTION AND
 38707					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38708
 38709	054645	200 17 0 00 070745 	C70500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38710	054646	200 00 0 00 070756 		MOVE	0,[76547,,654321]	;PRELOAD E WITH 076547,,654321
 38711	054647	617 17 0 00 000000 		TSNN	17,0			;*TSNN SHOULD SKIP
 38712						STOP^
 38713	054650	254 04 0 00 054651 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38714	054651	324 00 0 00 054652 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38715									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38716									;IN THE SUBTEST) TO LOOP ON ERROR^
 38717	054652	312 17 0 00 070745 		CAME	17,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38718						STOP^
 38719	054653	254 04 0 00 054654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38720	054654	324 00 0 00 054655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38721									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38722									;IN THE SUBTEST) TO LOOP ON ERROR^
 38723	054655	312 00 0 00 070756 		CAME	0,[76547,,654321]	;PASS IF C(E) UNCHANGED
 38724						STOP^
 38725	054656	254 04 0 00 054657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38726	054657	324 00 0 00 054660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38727									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38728									;IN THE SUBTEST) TO LOOP ON ERROR^
 38729
 38730					;**********
 38731
 38732					;THIS TEST VERIFIES THAT TSNN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38733					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN C(E) WITH
 38734					;BOTH HALVES SWAPPED ARE ZERO.  NEITHER AC NOR E ARE AFFECTED.
 38735					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 38736					;HENCE, TSNN SHOULD NOT SKIP THE NEXT INSTRUCTION AND
 38737					;BOTH C(AC) AND C(E) SHOULD BE UNMODIFIED
 38738
 38739	054660	200 16 0 00 070745 	C70510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38740	054661	200 17 0 00 070754 		MOVE	17,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 38741	054662	617 16 0 00 000017 		TSNN	16,17			;*TSNN SHOULD NOT SKIP
 38742	054663	334 00 0 00 000000 		SKIPA				;PASS IF TSNN DID NOT SKIP
 38743						STOP^
 38744	054664	254 04 0 00 054665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38745	054665	324 00 0 00 054666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38746									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38747									;IN THE SUBTEST) TO LOOP ON ERROR^
 38748	054666	312 16 0 00 070745 		CAME	16,[123456,,701234]	;PASS IF C(AC) UNCHANGED
 38749						STOP^
 38750	054667	254 04 0 00 054670 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38751	054670	324 00 0 00 054671 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38752									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38753									;IN THE SUBTEST) TO LOOP ON ERROR^
 38754	054671	312 17 0 00 070754 		CAME	17,[76543,,654321]	;PASS IF C(E) UNCHANGED
 38755						STOP^
 38756	054672	254 04 0 00 054673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38757	054673	324 00 0 00 054674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38758									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38759									;IN THE SUBTEST) TO LOOP ON ERROR^
 38760
 38761					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 58
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38762					;THIS TEST VERIFIES THAT TRZ CHANGES ALL BITS IN THE AC-RIGHT WHICH
 38763					;CORRESPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38764					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38765					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701234
 38766
 38767	054674	200 15 0 00 070745 	C70600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234]
 38768	054675	620 12 0 00 000003 		TRZ	12,3			;*TRZ SHOULD PLACE 123456,,701234 INTO
 38769										;THE AC AND NOT SKIP
 38770	054676	334 00 0 00 000000 		SKIPA				;PASS IF TRZ DOES NOT SKIP
 38771						STOP^
 38772	054677	254 04 0 00 054700 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38773	054700	324 00 0 00 054701 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38774									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38775									;IN THE SUBTEST) TO LOOP ON ERROR^
 38776	054701	312 15 0 00 070745 		CAME	15,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38777						STOP^
 38778	054702	254 04 0 00 054703 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38779	054703	324 00 0 00 054704 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38781									;IN THE SUBTEST) TO LOOP ON ERROR^
 38782
 38783					;**********
 38784
 38785					;THIS TEST VERIFIES THAT TRZ CHANGES ALL BITS IN THE AC-RIGHT WHICH
 38786					;CORRESPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38787					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38788					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701034
 38789
 38790	054704	200 14 0 00 070745 	C70610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38791	054705	620 14 0 00 000300 		TRZ	14,300			;*TRZ SHOULD PLACE 123456,,701234 INTO
 38792										;THE ACAND NOT SKIP
 38793	054706	334 00 0 00 000000 		SKIPA				;PASS IF TRX DOES NOT SKIP
 38794						STOP^
 38795	054707	254 04 0 00 054710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38796	054710	324 00 0 00 054711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38798									;IN THE SUBTEST) TO LOOP ON ERROR^
 38799	054711	312 14 0 00 070757 		CAME	14,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 38800						STOP^
 38801	054712	254 04 0 00 054713 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38802	054713	324 00 0 00 054714 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38804									;IN THE SUBTEST) TO LOOP ON ERROR^
 38805
 38806					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 59
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38807					;THIS TEST VERIFIES THAT TLZ CHANGES ALL BITS IN THE AC-LEFT WHICH
 38808					;CORRESPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38809					;IN THIS CACE, C(AC)=123456,,701234 AND E=300
 38810					;HENCE, THE RESULT IN THE AC SHOUL BE 123456,,701234
 38811
 38812	054714	200 13 0 00 070745 	C70700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38813	054715	621 13 0 00 000300 		TLZ	13,300			;*TLZ SHOULD PLACE 123456,,701234 INTO
 38814										;THE AC AND NOT SKIP
 38815	054716	334 00 0 00 000000 		SKIPA				;PASS IF TLZ DOES NOT SKIP
 38816						STOP^
 38817	054717	254 04 0 00 054720 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38818	054720	324 00 0 00 054721 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38819									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38820									;IN THE SUBTEST) TO LOOP ON ERROR^
 38821	054721	312 13 0 00 070745 		CAME	13,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38822						STOP^
 38823	054722	254 04 0 00 054723 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38824	054723	324 00 0 00 054724 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38826									;IN THE SUBTEST) TO LOOP ON ERROR^
 38827
 38828					;**********
 38829
 38830					;THIS TEST VERIFIES THAT TLZ CHANGES ALL BITS IN THE AC-LEFT WHICH
 38831					;CORRSPOND TO 1'S IN E TO ZERO AND DOES NOT SKIP.
 38832					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38833					;HENCE, THE RESULT IN THE AC SHOULD BE 123454,,701234
 38834
 38835	054724	200 12 0 00 070745 	C70710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38836	054725	621 12 0 00 000003 		TLZ	12,3			;*TLZ SHOULD PLACE 123454,,701234 INTO
 38837										;THE AC AND NOT SKIP
 38838	054726	334 00 0 00 000000 		SKIPA				;PASS IF TLZ DOES NOT SKIP
 38839						STOP^
 38840	054727	254 04 0 00 054730 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38841	054730	324 00 0 00 054731 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38842									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38843									;IN THE SUBTEST) TO LOOP ON ERROR^
 38844	054731	312 12 0 00 070760 		CAME	12,[123454,,701234]	;PASS IF C(AC)=123454,701234
 38845						STOP^
 38846	054732	254 04 0 00 054733 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38847	054733	324 00 0 00 054734 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38848									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38849									;IN THE SUBTEST) TO LOOP ON ERROR^
 38850
 38851					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 60
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38852					;THIS TEST VERIFIES THAT TRZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38853					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 38854					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38855					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38856					;HENCE, TRZE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38857					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234
 38858
 38859	054734	200 11 0 00 070745 	C71000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38860	054735	622 11 0 00 000003 		TRZE	11,3			;*TRZE SHOULD SKIP AND
 38861										;PLACE 123456,,701234 INTO THE AC
 38862						STOP^
 38863	054736	254 04 0 00 054737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38864	054737	324 00 0 00 054740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38865									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38866									;IN THE SUBTEST) TO LOOP ON ERROR^
 38867	054740	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38868						STOP^
 38869	054741	254 04 0 00 054742 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38870	054742	324 00 0 00 054743 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38872									;IN THE SUBTEST) TO LOOP ON ERROR^
 38873
 38874					;**********
 38875
 38876					;THIS TEST VERIFIES THAT TRZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38877					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRSPONDING TO 1'S IN E ARE ZERO.
 38878					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38879					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38880					;HENCE, TRZE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38881					;AND THE RESULT IN THE AC SHOUDL BE 123456,,701034
 38882
 38883	054743	200 10 0 00 070745 	C71010:	MOVE	10,[123456,,701234]	;PRELOAD AC WIT@ 123456,,701234
 38884	054744	622 10 0 00 000300 		TRZE	10,300			;*TRZE SHOULD PLACE 123456,,701034 INTO
 38885										;THE AC AND NOT SKIP
 38886	054745	334 00 0 00 000000 		SKIPA				;PASS IF TRZE DOES NOT SKIP
 38887						STOP^
 38888	054746	254 04 0 00 054747 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38889	054747	324 00 0 00 054750 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38890									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38891									;IN THE SUBTEST) TO LOOP ON ERROR^
 38892	054750	312 10 0 00 070757 		CAME	10,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 38893						STOP^
 38894	054751	254 04 0 00 054752 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38895	054752	324 00 0 00 054753 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38897									;IN THE SUBTEST) TO LOOP ON ERROR^
 38898
 38899					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 61
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38900					;THIS TEST VERIFIES THAT TLZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38901					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38902					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38903					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 38904					;HENCE, TLZE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38905					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234
 38906
 38907	054753	200 07 0 00 070745 	C71100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38908	054754	623 07 0 00 000300 		TLZE	7,300			;*TLZE SHOULD SKIP AND
 38909										;PLACE 123456,,701234 INTO THE AC
 38910						STOP^
 38911	054755	254 04 0 00 054756 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38912	054756	324 00 0 00 054757 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38913									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38914									;IN THE SUBTEST) TO LOOP ON ERROR^
 38915	054757	312 07 0 00 070745 		CAME	7,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38916						STOP^
 38917	054760	254 04 0 00 054761 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38918	054761	324 00 0 00 054762 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38920									;IN THE SUBTEST) TO LOOP ON ERROR^
 38921
 38922					;**********
 38923
 38924					;THIS TEST VERIFIES THAT TLZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38925					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 38926					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 38927					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 38928					;HENCE, TLZE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 38929					;AND THE RESULT IN THE AC SHOULD BE 123454,,701234
 38930
 38931	054762	200 06 0 00 070745 	C71110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38932	054763	623 06 0 00 000003 		TLZE	6,3			;*TLZE SHOULD PLACE 123454,,701234 INTO
 38933										;THE AC AND NOT SKIP
 38934	054764	334 00 0 00 000000 		SKIPA				;PASS IF TLZE DOES NOT SKIP
 38935						STOP^
 38936	054765	254 04 0 00 054766 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38937	054766	324 00 0 00 054767 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38939									;IN THE SUBTEST) TO LOOP ON ERROR^
 38940	054767	312 06 0 00 070760 		CAME	6,[123454,,701234]	;PASS IF C(AC)=123454,,701234
 38941						STOP^
 38942	054770	254 04 0 00 054771 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38943	054771	324 00 0 00 054772 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38945									;IN THE SUBTEST) TO LOOP ON ERROR^
 38946
 38947					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 62
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38948					;THIS TEST VERIFIES THAT TRZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38949					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 38950					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38951					;HENCE, TRZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 38952					;THE AC SHOULD BE 123456,,701234
 38953
 38954	054772	200 05 0 00 070745 	C71200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38955	054773	624 05 0 00 000003 		TRZA	5,3			;*TRZA SHOULD SKIP AND
 38956										;PLACE 123456,,701234 INTO THE AC
 38957						STOP^
 38958	054774	254 04 0 00 054775 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38959	054775	324 00 0 00 054776 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38960									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38961									;IN THE SUBTEST) TO LOOP ON ERROR^
 38962	054776	312 05 0 00 070745 		CAME	5,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 38963						STOP^
 38964	054777	254 04 0 00 055000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38965	055000	324 00 0 00 055001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38966									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38967									;IN THE SUBTEST) TO LOOP ON ERROR^
 38968
 38969					;**********
 38970
 38971					;THIS TEST VERIFIES THAT TRZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 38972					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 38973					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 38974					;HENCE, TRZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 38975					;THE AC SHOULD BE 123456,,701234.
 38976
 38977	055001	200 04 0 00 070745 	C71210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 38978	055002	624 04 0 00 000300 		TRZA	4,300			;*TRZA SHOULD SKIP AND
 38979										;PLACE 123456,,701034 INTO THE AC
 38980						STOP^
 38981	055003	254 04 0 00 055004 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38982	055004	324 00 0 00 055005 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38983									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38984									;IN THE SUBTEST) TO LOOP ON ERROR^
 38985	055005	312 04 0 00 070757 		CAME	4,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 38986						STOP^
 38987	055006	254 04 0 00 055007 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 38988	055007	324 00 0 00 055010 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 38989									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 38990									;IN THE SUBTEST) TO LOOP ON ERROR^
 38991
 38992					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 63
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 38993					;THIS TEST VERIFIES THAT TLZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRQCTION
 38994					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 38995					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 38996					;HENCE, TLZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 38997					;THE AC SHOULD BE 123454,,701234.
 38998
 38999	055010	200 03 0 00 070745 	C71300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39000	055011	625 03 0 00 000003 		TLZA	3,3			;*TLZA SHOULD SKIP AND
 39001										;PLACE 123454,,701234 INTO THE AC
 39002						STOP^
 39003	055012	254 04 0 00 055013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39004	055013	324 00 0 00 055014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39005									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39006									;IN THE SUBTEST) TO LOOP ON ERROR^
 39007	055014	312 03 0 00 070760 		CAME	3,[123454,,701234]	;PASS IF C(AC)=123454,,701234
 39008						STOP^
 39009	055015	254 04 0 00 055016 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39010	055016	324 00 0 00 055017 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39011									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39012									;IN THE SUBTEST) TO LOOP ON ERROR^
 39013
 39014					;**********
 39015
 39016					;THIS TEST VERIFIES THAT TLZA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39017					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E TO ZERO.
 39018					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39019					;HENCE, TLZA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39020					;THE AC SHOULD BE 123456,,701234.
 39021
 39022	055017	200 02 0 00 070745 	C71310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39023	055020	625 02 0 00 000300 		TLZA	2,300			;*TLZA SHOULD SKIP AND
 39024										;PLACE 123456,,701234 INTO THE AC
 39025						STOP^
 39026	055021	254 04 0 00 055022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39027	055022	324 00 0 00 055023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39028									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39029									;IN THE SUBTEST) TO LOOP ON ERROR^
 39030	055023	312 02 0 00 070745 		CAME	2,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39031						STOP^
 39032	055024	254 04 0 00 055025 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39033	055025	324 00 0 00 055026 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39034									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39035									;IN THE SUBTEST) TO LOOP ON ERROR^
 39036
 39037					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 64
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39038					;THIS TEST VERIFIES THAT TRZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39039					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39040					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 39041					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39042					;HENCE, TRZN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39043					;AND THE RESULT IN THE AC SHOULD BE 123456,,701034.
 39044
 39045	055026	200 01 0 00 070745 	C71400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39046	055027	626 01 0 00 000300 		TRZN	1,300			;*TRZN SHOULD SKIP AND
 39047										;PLACE 123456,,701034 INTO THE AC
 39048						STOP^
 39049	055030	254 04 0 00 055031 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39050	055031	324 00 0 00 055032 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39051									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39052									;IN THE SUBTEST) TO LOOP ON ERROR^
 39053	055032	312 01 0 00 070757 		CAME	1,[123456,,701034]	;PASS IF C(AC)=123456,,701034
 39054						STOP^
 39055	055033	254 04 0 00 055034 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39056	055034	324 00 0 00 055035 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39058									;IN THE SUBTEST) TO LOOP ON ERROR^
 39059
 39060					;**********
 39061
 39062					;THIS TEST VERIFIES THAT TRZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39063					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39064					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 39065					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39066					;HENCE, TRZN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39067					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234.
 39068
 39069	055035	200 00 0 00 070745 	C71410:	MOVE	0,[123456,,701234]	;PRELOAD AC WATH 123456,,701234
 39070	055036	626 00 0 00 000003 		TRZN	0,3			;*TRZN SHOULD PLACE 123456,,701234 INTO
 39071										;THE AC AND NOT SKIP
 39072	055037	334 00 0 00 000000 		SKIPA				;PASS IF TRZN DOES NOT SKIP
 39073						STOP^
 39074	055040	254 04 0 00 055041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39075	055041	324 00 0 00 055042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39076									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39077									;IN THE SUBTEST) TO LOOP ON ERROR^
 39078	055042	312 00 0 00 070745 		CAME	0,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39079						STOP^
 39080	055043	254 04 0 00 055044 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39081	055044	324 00 0 00 055045 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39082									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39083									;IN THE SUBTEST) TO LOOP ON ERROR^
 39084
 39085					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 65
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39086					;THIS TEST VERIFIES THAT TLZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39087					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39088					;THESE MASKED AC BITS ARE THEN CHANGED TO ZEROS.
 39089					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39090					;HENCE, TLZN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39091					;AND THE RESULT IN THE AC SHOULD BE 123454,,701234.
 39092
 39093	055045	200 17 0 00 070745 	C71500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39094	055046	627 17 0 00 000003 		TLZN	17,3			;TLZN SHOULD SKIP AND
 39095										;PLACE 123454,,701234 INTO THE AC
 39096						STOP^
 39097	055047	254 04 0 00 055050 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39098	055050	324 00 0 00 055051 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39099									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39100									;IN THE SUBTEST) TO LOOP ON ERROR^
 39101	055051	312 17 0 00 070760 		CAME	17,[123454,,701234]	;PASS IF C(AC)=123454,,701234
 39102						STOP^
 39103	055052	254 04 0 00 055053 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39104	055053	324 00 0 00 055054 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39105									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39106									;IN THE SUBTEST) TO LOOP ON ERROR^
 39107
 39108					;**********
 39109
 39110					;THIS TEST VERIFIES THAT TLZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39111					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39112					;THESE MASKED AC BIPS ARE THEN CHANGED TO ZEROS.
 39113					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39114					;HENCE, TLZN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39115					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234.
 39116
 39117	055054	200 16 0 00 070745 	C71510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39118	055055	627 16 0 00 000300 		TLZN	16,300			;*TLZN SHOULD PLACE 123456,,701234 INTO
 39119										;THE AC AND NOT SKIP
 39120	055056	334 00 0 00 000000 		SKIPA				;PASS IF TLZN DOES NOT SKIP
 39121						STOP^
 39122	055057	254 04 0 00 055060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39123	055060	324 00 0 00 055061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39124									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39125									;IN THE SUBTEST) TO LOOP ON ERROR^
 39126	055061	312 16 0 00 070745 		CAME	16,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39127						STOP^
 39128	055062	254 04 0 00 055063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39129	055063	324 00 0 00 055064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39130									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39131									;IN THE SUBTEST) TO LOOP ON ERROR^
 39132
 39133					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 66
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39134					;THIS TEST VERIFIES THAT TSZ CLEARS ALL BITS OF THE AC WHICH
 39135					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39136					;NOT SKIP THE NEXT INSTRUCTION. C(E) IS NOT AFFECTED.
 39137					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321.
 39138					;HENCE, TSZ SHOULD NOT SKIP AND C(AC) SHOULD BE 123456,,701234.
 39139
 39140	055064	200 15 0 00 070745 	C71600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39141	055065	200 16 0 00 070754 		MOVE	16,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39142	055066	631 15 0 00 000016 		TSZ	15,16			;*TSZ SHOULD NOT SKIP AND
 39143										;PLACE 123456,,701234 INTO THE AC
 39144	055067	334 00 0 00 000000 		SKIPA				;PASS IF TSZ DID NOT SKIP
 39145						STOP^
 39146	055070	254 04 0 00 055071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39147	055071	324 00 0 00 055072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39148									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39149									;IN THE SUBTEST) TO LOOP ON ERROR^
 39150	055072	312 15 0 00 070745 		CAME	15,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39151						STOP^
 39152	055073	254 04 0 00 055074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39153	055074	324 00 0 00 055075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39154									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39155									;IN THE SUBTEST) TO LOOP ON ERROR^
 39156	055075	312 16 0 00 070754 		CAME	16,[76543,,654321]	;PASS IF C(E) UNCHANCED
 39157						STOP^
 39158	055076	254 04 0 00 055077 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39159	055077	324 00 0 00 055100 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39160									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39161									;IN THE SUBTEST) TO LOOP ON ERROR^
 39162
 39163					;**********
 39164
 39165					;THIS TEST VERIFIES THAT TSZ CLEARS ALL BITS OF THE AC WHICH
 39166					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39167					;NOT SKIP THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED.
 39168					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070.
 39169					;HENCE, TSZ SHOULD NOT SKIP AND C(AC) SHOULD BE 020406,,501210.
 39170
 39171	055100	200 14 0 00 070745 	C71610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39172	055101	200 15 0 00 070761 		MOVE	15,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 39173	055102	631 14 0 00 000015 		TSZ	14,15			;*TSZ SHOULD NOT SKIP AND
 39174										;PLACE 020406,,501210 INTO THE AC
 39175	055103	334 00 0 00 000000 		SKIPA				;PASS IF TSZ DID NOT SKIP
 39176						STOP^
 39177	055104	254 04 0 00 055105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39178	055105	324 00 0 00 055106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39179									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39180									;IN THE SUBTEST) TO LOOP ON ERROR^
 39181	055106	312 14 0 00 070762 		CAME	14,[020406,,501210]	;PASS IF C(AC)=020406,,501210
 39182						STOP^
 39183	055107	254 04 0 00 055110 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39184	055110	324 00 0 00 055111 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39185									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39186									;IN THE SUBTEST) TO LOOP ON ERROR^
 39187	055111	312 15 0 00 070761 		CAME	15,[252525,,707070]	;PASS IF C(E) UNCHANGED
 39188						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 66-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39189	055112	254 04 0 00 055113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39190	055113	324 00 0 00 055114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39191									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39192									;IN THE SUBTEST) TO LOOP ON ERROR^
 39193
 39194					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 67
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39195					;THIS TEST VERIFIES THAT TDZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39196					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39197					;C(E).
 39198					;AC BITS ARE THEN CHANGED TO ZERO.
 39199					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543.
 39200					;HENCE, TDZE SHOULD SKIP AND THE RESULT IN THE AC
 39201					;SHOULD BE 123456,,701234.  C(E) IS NOT AFFECTED.
 39202
 39203	055114	200 13 0 00 070745 	C71700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39204	055115	200 14 0 00 070763 		MOVE	14,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 39205	055116	632 13 0 00 000014 		TDZE	13,14			;*TDZE SHOULD SKIP AND
 39206										;PLACE 123456,,701234 INTO THE AC
 39207						STOP^
 39208	055117	254 04 0 00 055120 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39209	055120	324 00 0 00 055121 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39210									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39211									;IN THE SUBTEST) TO LOOP ON ERROR^
 39212	055121	312 13 0 00 070745 		CAME	13,[123456,,701234]	;PASS IF C(AC)=123456,,701234]
 39213						STOP^
 39214	055122	254 04 0 00 055123 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39215	055123	324 00 0 00 055124 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39216									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39217									;IN THE SUBTEST) TO LOOP ON ERROR^
 39218	055124	312 14 0 00 070763 		CAME	14,[654321,,076543]	;PASS IF C(E) UNCHANGED
 39219						STOP^
 39220	055125	254 04 0 00 055126 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39221	055126	324 00 0 00 055127 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39223									;IN THE SUBTEST) TO LOOP ON ERROR^
 39224
 39225					;**********
 39226
 39227					;THIS TEST VERIFIES THAT TDZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39228					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39229					;C(E) ARE ZERO. THESE MASKED
 39230					;AC BITS ARE THEN CHANGED TO ZERO.
 39231					;IN THIS CASE, C(AC)= 123456,,701234 AND C(E)= 754321,,076543
 39232					;HENCE, TDZE SHOULD NOT SKIP AND THE RESULT IN AC
 39233					;SHOULD BE 023456,,701234 C(E) IS NOT AFFECTED
 39234
 39235	055127	200 12 0 00 070745 	C71710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39236	055130	200 13 0 00 070764 		MOVE	13,[754321,,076543]	;PRELOAD E WITH 754321,,076543
 39237	055131	632 12 0 00 000013 		TDZE	12,13			;*TDZE SHOULD NOT SKIP AND
 39238										;PLACE 023456,,701234 INTO THE AC
 39239	055132	334 00 0 00 000000 		SKIPA				;PASS IF TDZE DOES NOT SKIP
 39240						STOP^
 39241	055133	254 04 0 00 055134 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39242	055134	324 00 0 00 055135 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39243									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39244									;IN THE SUBTEST) TO LOOP ON ERROR^
 39245	055135	312 12 0 00 070765 		CAME	12,[023456,,701234]	;PASS IF C(AC)= 023456,,701234
 39246						STOP^
 39247	055136	254 04 0 00 055137 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39248	055137	324 00 0 00 055140 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39249									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 67-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39250									;IN THE SUBTEST) TO LOOP ON ERROR^
 39251	055140	312 13 0 00 070764 		CAME	13,[754321,,076543]	;PASS IF C(E) UNCHANGED
 39252						STOP^
 39253	055141	254 04 0 00 055142 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39254	055142	324 00 0 00 055143 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39255									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39256									;IN THE SUBTEST) TO LOOP ON ERROR^
 39257
 39258					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 68
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39259					;THIS TEST VERIFIES THAT TSZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39260					;IF AND ONLY IF ALL BITS IN THE AC CORRECPONDING TO 1'S IN
 39261					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39262					;AC BITS ARE THEN CHANGED TO ZERO.
 39263					;IN THIS CASE, C(AC)= 123456,,701234 AND C(E)= 076543,,654321
 39264					;HENCE, TSZE SHOULD SKIP AND THE RESULT IN AC
 39265					;SHOULD BE 123456,,701234 C(E) IS NOT AFFECTED
 39266
 39267	055143	200 11 0 00 070745 	C72000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39268	055144	200 12 0 00 070754 		MOVE	12,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39269	055145	633 11 0 00 000012 		TSZE	11,12			;*TSZE SHOULD SKIP AND
 39270										;PLACE 123456,,701234 INTO THE AC
 39271						STOP^
 39272	055146	254 04 0 00 055147 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39273	055147	324 00 0 00 055150 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39274									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39275									;IN THE SUBTEST) TO LOOP ON ERROR^
 39276	055150	312 11 0 00 070745 		CAME	11,[123456,,701234]	;PASS IF C(AC)= 123456,,701234
 39277						STOP^
 39278	055151	254 04 0 00 055152 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39279	055152	324 00 0 00 055153 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39280									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39281									;IN THE SUBTEST) TO LOOP ON ERROR^
 39282	055153	312 12 0 00 070754 		CAME	12,[76543,,654321]	;PASS IF C(E) UNCHANGED
 39283						STOP^
 39284	055154	254 04 0 00 055155 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39285	055155	324 00 0 00 055156 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39287									;IN THE SUBTEST) TO LOOP ON ERROR^
 39288
 39289					;**********
 39290
 39291					;THIS TEST VERIFIES THAT TSZE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39292					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39293					;C (E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39294					;AC BITS ARE THEN CHANGED TO ZERO
 39295					;IN THIS CASE, C(AC)= 123456,,701234 AND C(E)= 076543,,657321
 39296					;HENCE, TSZE SHOULD NOT SKIP AND THE RESULT IN AC
 39297					;SHOULD BE 120456,,701234 C(E) IS NOT AFFECTED
 39298
 39299	055156	200 10 0 00 070745 	C72010:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39300	055157	200 11 0 00 070766 		MOVE	11,[76543,,657321]	;PRELOAD E WITH 076543,,654321
 39301	055160	633 10 0 00 000011 		TSZE	10,11			;*TSZE SHOULD NOT SKIP AND
 39302										;PLACE 120456,,701234 INTO THE AC
 39303	055161	334 00 0 00 000000 		SKIPA				;PASS IF TSZE DID NOT SKIP
 39304						STOP^
 39305	055162	254 04 0 00 055163 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39306	055163	324 00 0 00 055164 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39307									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39308									;IN THE SUBTEST) TO LOOP ON ERROR^
 39309	055164	312 10 0 00 070767 		CAME	10,[120456,,701234]	;PASS IF C(AC)= 120456,,701234
 39310						STOP^
 39311	055165	254 04 0 00 055166 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39312	055166	324 00 0 00 055167 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39313									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 68-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39314									;IN THE SUBTEST) TO LOOP ON ERROR^
 39315	055167	312 11 0 00 070766 		CAME	11,[76543,,657321]	;PASS IF C(E) UNCHANGED
 39316						STOP^
 39317	055170	254 04 0 00 055171 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39318	055171	324 00 0 00 055172 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39319									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39320									;IN THE SUBTEST) TO LOOP ON ERROR^
 39321
 39322
 39323					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 69
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39324					;THIS TEST VERIFIES THAT TDZA CLEARS ALL BITS OF THE AC WHICH
 39325					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 39326					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 39327					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)= 654321,,076543
 39328					;HENCE, TD2A SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 123456,,701234
 39329
 39330	055172	200 07 0 00 070745 	C72100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39331	055173	200 10 0 00 070763 		MOVE	10,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 39332	055174	634 07 0 00 000010 		TDZA	7,10			;*TDZA SHOULD SKIP AND
 39333										;PLACE 123456,,701234 INTO THE AC
 39334						STOP^
 39335	055175	254 04 0 00 055176 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39336	055176	324 00 0 00 055177 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39337									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39338									;IN THE SUBTEST) TO LOOP ON ERROR^
 39339	055177	312 07 0 00 070745 		CAME	7,[123456,,701234]	;PASS IF C(AC)= 123456,,701234
 39340						STOP^
 39341	055200	254 04 0 00 055201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39342	055201	324 00 0 00 055202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39344									;IN THE SUBTEST) TO LOOP ON ERROR^
 39345	055202	312 10 0 00 070763 		CAME	10,[654321,,076543]	;PASS IF C(AC)=123456,,701234
 39346						STOP^
 39347	055203	254 04 0 00 055204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39348	055204	324 00 0 00 055205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39349									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39350									;IN THE SUBTEST) TO LOOP ON ERROR^
 39351	055205	312 10 0 00 070763 		CAME	10,[654321,,076543]	;PASS IF C(E) UNCHANGED
 39352						STOP^
 39353	055206	254 04 0 00 055207 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39354	055207	324 00 0 00 055210 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39355									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39356									;IN THE SUBTEST) TO LOOP ON ERROR^
 39357
 39358					;**********
 39359
 39360					;THIS TEST VERIFIES THAT TDZA CLEARS ALL BITS OF THE AC WHICH
 39361					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 39362					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 39363					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 39364					;HENCE, TDZA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 121052,,000204
 39365
 39366	055210	200 06 0 00 070745 	C72110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39367	055211	200 07 0 00 070761 		MOVE	7,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 39368	055212	634 06 0 00 000007 		TDZA	6,7			;*TDZA SHOULD SKIP AND
 39369									;PLACE 121052,,000204 INTO THE AC
 39370						STOP^
 39371	055213	254 04 0 00 055214 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39372	055214	324 00 0 00 055215 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39373									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39374									;IN THE SUBTEST) TO LOOP ON ERROR^
 39375	055215	312 06 0 00 070770 		CAME	6,[121052,,000204]	;PASS IF C(AC)=121052,,000204
 39376						STOP^
 39377	055216	254 04 0 00 055217 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39378	055217	324 00 0 00 055220 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 69-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39379									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39380									;IN THE SUBTEST) TO LOOP ON ERROR^
 39381	055220	312 07 0 00 070761 		CAME	7,[252525,,707070]	;PASS IF C(E) UNCHANGED
 39382						STOP^
 39383	055221	254 04 0 00 055222 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39384	055222	324 00 0 00 055223 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39385									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39386									;IN THE SUBTEST) TO LOOP ON ERROR^
 39387
 39388					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 70
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39389					;THIS TEST VERIFIES TH`T TSZA CLEARS AHL BITS OF THE AC WHICH
 39390					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 39391					;SKIPS THE NEXT INSTRUCTION. C(E) IS NOT AFFECTED.
 39392					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 39393					;HENCE, TSZA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 123456,,701234
 39394
 39395	055223	200 05 0 00 070745 	C72200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39396	055224	200 06 0 00 070754 		MOVE	6,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39397	055225	635 05 0 00 000006 		TSZA	5,6			;*TSZA SHOULD SKIP AND
 39398										;PLACE 123456,,701234 INTO THE AC
 39399						STOP^
 39400	055226	254 04 0 00 055227 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39401	055227	324 00 0 00 055230 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39402									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39403									;IN THE SUBTEST) TO LOOP ON ERROR^
 39404	055230	312 05 0 00 070745 		CAME	5,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39405						STOP^
 39406	055231	254 04 0 00 055232 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39407	055232	324 00 0 00 055233 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39408									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39409									;IN THE SUBTEST) TO LOOP ON ERROR^
 39410	055233	312 06 0 00 070754 		CAME	6,[076543,,654321]	;PASS IF C(E) UNCHANGED
 39411						STOP^
 39412	055234	254 04 0 00 055235 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39413	055235	324 00 0 00 055236 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39414									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39415									;IN THE SUBTEST) TO LOOP ON ERROR^
 39416
 39417					;**********
 39418
 39419					;THIS TEST VERIFIES THAT TSZA CLEARS ALL BITS OF THE AC WHICH
 39420					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 39421					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED.
 39422					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=701234,,123456
 39423					;HENCE, TSZA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 0
 39424
 39425	055236	200 04 0 00 070745 	C72210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39426	055237	200 05 0 00 070771 		MOVE	5,[701234,,123456]	;PRELOAD E WITH 701234,,123456
 39427	055240	635 04 0 00 000005 		TSZA	4,5			;*TSZA SHOULD SKIP AND
 39428										;PLACE 0 INTO THE AC
 39429						STOP^
 39430	055241	254 04 0 00 055242 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39431	055242	324 00 0 00 055243 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39432									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39433									;IN THE SUBTEST) TO LOOP ON ERROR^
 39434	055243	312 04 0 00 070253 		CAME	4,[0]			;PASS IF C(AC)=0
 39435						STOP^
 39436	055244	254 04 0 00 055245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39437	055245	324 00 0 00 055246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39438									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39439									;IN THE SUBTEST) TO LOOP ON ERROR^
 39440	055246	312 05 0 00 070771 		CAME	5,[701234,,123456]	;PASS IF C(E) UNCHANGED
 39441						SToP^
 39442	055247	254 04 0 00 055250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39443	055250	324 00 0 00 055251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 70-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39444									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39445									;IN THE SUBTEST) TO LOOP ON ERROR^
 39446
 39447					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 71
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39448					;THIS TEST VERIFIES THAT TDZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39449					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39450					;C(E) ARE ZERO.  THESE MASKED
 39451					;AC BITS ARE THEN CHANGEDTO ZERO.
 39452					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076547
 39453					;HENCE, TDZN SHOULD SKIP AND THE RESULT IN THE AC
 39454					;SHOULD BE 123456(,701230.  C(E) IS NOT AFFECTED.
 39455
 39456	055251	200 03 0 00 070745 	C72300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39457	055252	200 04 0 00 070772 		MOVE	4,[654321,,76547]	;PRELOAD E WITH 654321,,076547
 39458	055253	636 03 0 00 000004 		TDZN	3,4			;*TDZN SHoULD SKIP AND
 39459										;PLACE 123456,,701230 INTO THE AC
 39460						STOP^
 39461	055254	254 04 0 00 055255 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39462	055255	324 00 0 00 055256 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39464									;IN THE SUBTEST) TO LOOP ON ERROR^
 39465	055256	312 03 0 00 070773 		CAME	3,[123456,,701230]	;PASS IF C(AC)=123456,,701230
 39466						STOP^
 39467	055257	254 04 0 00 055260 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39468	055260	324 00 0 00 055261 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39469									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39470									;IN THE SUBTEST) TO LOOP ON ERROR^
 39471	055261	312 04 0 00 070772 		CAME	4,[654321,,076547]	;PASS IF C(E) UNCHANGED
 39472						STOP^
 39473	055262	254 04 0 00 055263 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39474	055263	324 00 0 00 055264 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39475									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39476									;IN THE SUBTEST) TO LOOP ON ERROR^
 39477
 39478					;**********
 39479
 39480					;THIS TEST VERIFIES THAT TDZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39481					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39482					;C(E) ARE ZERO.  THESE MASKED
 39483					;AC BITS ARE THEN CHANGED TO ZERO.
 39484					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 39485					;HENCE, TDZN SHOULD NOT SKIP AND THE RESULT IN THE AC
 39486					;SHOULD BE 123456,,701234.  C(E) IS NOT AFFECTED.
 39487
 39488	055264	200 02 0 00 070745 	C72310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39489	055265	200 03 0 00 070763 		MOVE	3,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 39490	055266	636 02 0 00 000003 		TDZN	2,3			;*TDZN SHOULD NOT SKIP AND
 39491										;PLACE 123456,,701234 INTO THE AC
 39492	055267	334 00 0 00 000000 		SKIPA				;PASS IF TDZN DOES NOT SKIP
 39493						STOP^
 39494	055270	254 04 0 00 055271 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39495	055271	324 00 0 00 055272 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39497									;IN THE SUBTEST) TO LOOP ON ERROR^
 39498	055272	312 02 0 00 070745 		CAME	2,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 39499						STOP^
 39500	055273	254 04 0 00 055274 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39501	055274	324 00 0 00 055275 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39502									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 71-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39503									;IN THE SUBTEST) TO LOOP ON ERROR^
 39504	055275	312 03 0 00 070763 		CAME	3,[654321,,076543]	;PASS IF C(E) UNCHANGED
 39505						STOP^
 39506	055276	254 04 0 00 055277 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39507	055277	324 00 0 00 055300 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39508									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39509									;IN THE SUBTEST) TO LOOP ON ERROR^
 39510
 39511					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 72
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39512					;THIS TEST VERIFIES THaT TSZN SKIPS THE NEXT SEQQENPIAL INSTRUCTION
 39513					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39514					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39515					;AC BITS ARE THEN CHANGED TO ZERO.
 39516					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=077543,,654321.
 39517					;HENCE, TSZN SHOULD SKIP AND THE RESULT IN THE AC
 39518					;SHOULD BE 123456,,700234.  C(E) IS NOT AFFECTED.
 39519
 39520	055300	200 01 0 00 070745 	C72400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39521	055301	200 02 0 00 070774 		MOVE	2,[077543,,654321]	;PRELOAD E WITH 077543,,654321
 39522	055302	637 01 0 00 000002 		TSZN	1,2			;*TSZN SHOULD SKIP AND
 39523										;PLACE 123456,,700234 INTO THE AC
 39524						STOP^
 39525	055303	254 04 0 00 055304 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39526	055304	324 00 0 00 055305 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39527									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39528									;IN THE SUBTEST) TO LOOP ON ERROR^
 39529	055305	312 01 0 00 070775 		CAME	1,[123456,,700234]	;PASS IF C(AC)=123456,,700234
 39530						STOP^
 39531	055306	254 04 0 00 055307 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39532	055307	324 00 0 00 055310 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39533									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39534									;IN THE SUBTEST) TO LOOP ON ERROR^
 39535	055310	312 02 0 00 070774 		CAME	2,[77543,,654321]	;PASS IF C(E) UNCHANGED
 39536						STOP^
 39537	055311	254 04 0 00 055312 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39538	055312	324 00 0 00 055313 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39539									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39540									;IN THE SUBTEST) TO LOOP ON ERROR^
 39541
 39542					;**********
 39543
 39544					;THIS TEST VERIFIES THAT TSZN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39545					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 39546					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 39547					;AC BITS ARE THEN CHANGED TO ZERO.
 39548					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321.-
 39549					;HENCE, TSZN SHOULD NOT SKIP AND THE RESULT IN THE AC
 39550					;SHOULD BE 123456,,701234.  C(E) IS NOT AFFECTED.
 39551
 39552	055313	200 00 0 00 070745 	C72410:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39553	055314	200 01 0 00 070754 		MOVE	1,[76543,,654321]	;PRElOAD E WITH 076543,,654321
 39554	055315	637 00 0 00 000001 		TSZN	0,1			;*TSZN SHOULD NOT SKIP AND
 39555										;PLACE 123456,,701234 INTO THE AC
 39556	055316	334 00 0 00 000000 		SKIPA				;PASS IF TSZN DOES NOT SKIP
 39557						STOP^
 39558	055317	254 04 0 00 055320 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39559	055320	324 00 0 00 055321 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39560									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39561									;IN THE SUBTEST) TO LOOP ON ERROR^
 39562	055321	312 00 0 00 070745 		CAME	0,[123456,,701234]	;PASS IF C(AC)=123456,,701234]
 39563						STOP^
 39564	055322	254 04 0 00 055323 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39565	055323	324 00 0 00 055324 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 72-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39567									;IN THE SUBTEST) TO LOOP ON ERROR^
 39568	055324	312 01 0 00 070754 		CAME	1,[76543,,654321]	;PASS IF C(E) UNCHANGED
 39569						STOP^
 39570	055325	254 04 0 00 055326 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39571	055326	324 00 0 00 055327 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39572									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39573									;IN THE SUBTEST) TO LOOP ON ERROR^
 39574
 39575					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 73
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39576					;THIS TEST VERIFIES THAT TRC COMPLEMENTS ALL BITS IN THE AC-RIGHT WHICH
 39577					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39578					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39579					;HENCE, THE RESULT IN THE AC SHOUHD BE 123456,,701237
 39580
 39581	055327	200 17 0 00 070745 	C72500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39582	055330	640 17 0 00 000003 		TRC	17,3			;*TRC SHOULD NOT SKIP AND
 39583										;PLACE 123456,,701237 INTO THE AC
 39584	055331	334 00 0 00 000000 		SKIPA				;PASS IF TRC DID NOT SKIP
 39585						STOP^
 39586	055332	254 04 0 00 055333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39587	055333	324 00 0 00 055334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39588									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39589									;IN THE SUBTEST) TO LOOP ON ERROR^
 39590	055334	312 17 0 00 070776 		CAME	17,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39591						STOP^
 39592	055335	254 04 0 00 055336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39593	055336	324 00 0 00 055337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39594									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39595									;IN THE SUBTEST) TO LOOP ON ERROR^
 39596
 39597					;**********
 39598
 39599					;THIS TEST VERIFIES THAT TRC COMPLEMENTS ALL BITS IN THE AC-RIGHT WHICH
 39600					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39601					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39602					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701134
 39603
 39604	055337	200 16 0 00 070745 	C72510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39605	055340	640 16 0 00 000300 		TRC	16,300			;*TRC SHOULD NOT SKIP AND
 39606										;PLACE 123456,,701134 INTO THE AC
 39607	055341	334 00 0 00 000000 		SKIPA				;PASS IF TRC DID NOT SKIP
 39608						STOP^
 39609	055342	254 04 0 00 055343 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39610	055343	324 00 0 00 055344 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39611									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39612									;IN THE SUBTEST) TO LOOP ON ERROR^
 39613	055344	312 16 0 00 070777 		CAME	16,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39614						STOP^
 39615	055345	254 04 0 00 055346 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39616	055346	324 00 0 00 055347 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39617									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39618									;IN THE SUBTEST) TO LOOP ON ERROR^
 39619
 39620					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 74
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39621					;THIS TEST VERIFIES THAT TLC COMPLEMENTS ALL BITS IN THE AC-LEFT WHICH
 39622					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39623					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39624					;HENCE, ThE RESULT IN THE AC SHOULD BE 123756,,701234.
 39625
 39626	055347	200 15 0 00 070745 	C72600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39627	055350	641 15 0 00 000300 		TLC	15,300			;*TLC SHOULD NOT SKIP AND
 39628										;PLACE 123756,,701234 INTO THE AC
 39629	055351	334 00 0 00 000000 		SKIPA				;PASS IF TLC DID NOT SKIP
 39630						STOP^
 39631	055352	254 04 0 00 055353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39632	055353	324 00 0 00 055354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39633									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39634									;IN THE SUBTEST) TO LOOP ON ERROR^
 39635	055354	312 15 0 00 071000 		CAME	15,[123756,,701234]	;PASS IF A(AC)=123756,,701234
 39636						STOP^
 39637	055355	254 04 0 00 055356 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39638	055356	324 00 0 00 055357 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39639									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39640									;IN THE SUBTEST) TO LOOP ON ERROR^
 39641
 39642					;**********
 39643
 39644					;THIS TEST VERIFIES THAT TLC COMPLEMENTS ALL BITS IN THE AC-LEFT WHICH
 39645					;CORRESPOND TO 1'S IN E AND DOES NOT SKIP.
 39646					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39647					;HENCE, THE RESULT IN THE AC SHOULD BE 123455,,701234.
 39648
 39649	055357	200 14 0 00 070745 	C72610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39650	055360	641 14 0 00 000003 		TLC	14,3			;*TLC SHOULD NOT SKIP AND
 39651										;PLACE 123455,,701234 INTO THE AC
 39652	055361	334 00 0 00 000000 		SKIPA				;PASS IF TLC DID NOT SKIP
 39653						STOP^
 39654	055362	254 04 0 00 055363 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39655	055363	324 00 0 00 055364 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39656									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39657									;IN THE SUBTEST) TO LOOP ON ERROR^
 39658	055364	312 14 0 00 071001 		CAME	14,[123455,,701234]	;PASS IF C(AC)=123455,,701234
 39659						STOP^
 39660	055365	254 04 0 00 055366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39661	055366	324 00 0 00 055367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39662									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39663									;IN THE SUBTEST) TO LOOP ON ERROR^
 39664
 39665					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 75
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39666					;THIS TEST VERIFIES THAT TRCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39667					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39668					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39669					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39670					;HENCE, TRCE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39671					;AND THE RESULT IN THE AC SHOULD BE 123456,,701237.
 39672
 39673	055367	200 13 0 00 070745 	C72700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39674	055370	642 13 0 00 000003 		TRCE	13,3			;*TRCE SHOULD SKIP AND
 39675										;PLACE 123456,,701237 INTO ThE AC
 39676						STOP^
 39677	055371	254 04 0 00 055372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39678	055372	324 00 0 00 055373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39679									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39680									;IN THE SUBTEST) TO LOOP ON ERROR^
 39681	055373	312 13 0 00 070776 		CAME	13,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39682						STOP^
 39683	055374	254 04 0 00 055375 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39684	055375	324 00 0 00 055376 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39685									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39686									;IN THE SUBTEST) TO LOOP ON ERROR^
 39687
 39688					;**********
 39689
 39690					;THIS TEST VERIFIES THAT TRCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39691					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39692					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39693					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39694					;HENCE, TRCE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39695					;AND THE RESULT IN THE AC SHOULD BE 123456,,701134
 39696
 39697	055376	200 12 0 00 070745 	C72710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39698	055377	642 12 0 00 000300 		TRCE	12,300			;*TRCE SHOULD NOT SKIP AND
 39699										;PLACE 123456,,701134 INTO THE AC
 39700	055400	334 00 0 00 000000 		SKIPA				;PASS IF TRCE DID NOT SKIP
 39701						STOP^
 39702	055401	254 04 0 00 055402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39703	055402	324 00 0 00 055403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39704									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39705									;IN THE SUBTEST) TO LOOP ON ERROR^
 39706	055403	312 12 0 00 070777 		CAME	12,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39707						STOP^
 39708	055404	254 04 0 00 055405 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39709	055405	324 00 0 00 055406 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39710									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39711									;IN THE SUBTEST) TO LOOP ON ERROR^
 39712
 39713					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39714					;THIS TEST VERIFIES THAT TLCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39715					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39716					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39717					;IN THIS CASE, C(AC)=123456,,701234 AND E=300.
 39718					;HENCE, TLCE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39719					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234.
 39720
 39721	055406	200 11 0 00 070745 	C73000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39722	055407	643 11 0 00 000300 		TLCE	11,300			;*TLCE SHOULD SKIP AND
 39723										;PLACE 123756,,701234 INTO THE AC
 39724						STOP^
 39725	055410	254 04 0 00 055411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39726	055411	324 00 0 00 055412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39727									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39728									;IN THE SUBTEST) TO LOOP ON ERROR^
 39729	055412	312 11 0 00 071000 		CAME	11,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 39730						STOP^
 39731	055413	254 04 0 00 055414 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39732	055414	324 00 0 00 055415 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39733									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39734									;IN THE SUBTEST) TO LOOP ON ERROR^
 39735
 39736					;**********
 39737
 39738					;THIS TEST VERIFIES THAT TLCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39739					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39740					;THESE MASKED AC BITS ARE THEN COMPLEMENTED.
 39741					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39742					;HENCE, TLCE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39743					;AND THE RESULT IN THE AC SHOULD BE 123455,,701234.
 39744
 39745	055415	200 10 0 00 070745 	C73010:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39746	055416	643 10 0 00 000003 		TLCE	10,3			;*TLCE SHOULD NOT SKIP AND
 39747										;PLACE 123455,,701234 INTO THE AC
 39748	055417	334 00 0 00 000000 		SKIPA				;PASS IF TLCE DID NOT SKIP
 39749						STOP^
 39750	055420	254 04 0 00 055421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39751	055421	324 00 0 00 055422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39752									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39753									;IN THE SUBTEST) TO LOOP ON ERROR^
 39754	055422	312 10 0 00 071001 		CAME	10,[123455,,701234]	;PASS IF C(AC)=123455,,701234]
 39755						STOP^
 39756	055423	254 04 0 00 055424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39757	055424	324 00 0 00 055425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39758									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39759									;IN THE SUBTEST) TO LOOP ON ERROR^
 39760
 39761					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 77
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39762					;THIS TEST VERIFIES THAT TRCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39763					;AND COMPLEMENTS ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E.
 39764					;IN THIS CASE, C(AC)=123456,,701234 AND E=3.
 39765					;HENCE, TRCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39766					;THE AC SHOULD BE 123456,,701237.
 39767
 39768	055425	200 07 0 00 070745 	C73100:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39769	055426	644 07 0 00 000003 		TRCA	7,3			;*TRCA SHOULD SKIP AND
 39770										;PLACE 123456,,701237 INTO THE AC
 39771						STOP^
 39772	055427	254 04 0 00 055430 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39773	055430	324 00 0 00 055431 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39774									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39775									;IN THE SUBTEST) TO LOOP ON ERROR^
 39776	055431	312 07 0 00 070776 		CAME	7,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39777						STOP^
 39778	055432	254 04 0 00 055433 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39779	055433	324 00 0 00 055434 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39780									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39781									;IN THE SUBTEST) TO LOOP ON ERROR^
 39782
 39783					;**********
 39784
 39785					;THIS TEST VERIFIES THAT TRCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39786					;AND COMPLEMENTS ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E
 39787					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39788					;HENCE, TRCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39789					;THE AC SHOULD BE 123456,,701134
 39790
 39791	055434	200 06 0 00 070745 	C73110:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39792	055435	644 06 0 00 000300 		TRCA	6,300			;*TRCA SHOULD SKIP AND
 39793										;PLACE 123456,,701134 INTO THE AC
 39794						STOP^
 39795	055436	254 04 0 00 055437 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39796	055437	324 00 0 00 055440 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39798									;IN THE SUBTEST) TO LOOP ON ERROR^
 39799	055440	312 06 0 00 070777 		CAME	6,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39800						STOP^
 39801	055441	254 04 0 00 055442 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39802	055442	324 00 0 00 055443 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39804									;IN THE SUBTEST) TO LOOP ON ERROR^
 39805
 39806					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39807					;THIS TEST VERIFIES THAT TLCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39808					;AND COMPLEMENTS ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E
 39809					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 39810					;HENCE, TLCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39811					;THE AC SHOULD 123456,,701234
 39812
 39813	055443	200 05 0 00 070745 	C73200:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39814	055444	645 05 0 00 000003 		TLCA	5,3			;*TLCA SHOULD SKIP AND
 39815										;PLACE 12345,,701234 INTO THE AC
 39816						STOP^
 39817	055445	254 04 0 00 055446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39818	055446	324 00 0 00 055447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39819									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39820									;IN THE SUBTEST) TO LOOP ON ERROR^
 39821	055447	312 05 0 00 071001 		CAME	5,[123455,,701234]	;PASS IF C(AC)=123455,,701234
 39822						STOP^
 39823	055450	254 04 0 00 055451 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39824	055451	324 00 0 00 055452 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39826									;IN THE SUBTEST) TO LOOP ON ERROR^
 39827
 39828					;**********
 39829
 39830					;THIS TEST VERIFIES THAT TLCA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39831					;AND COMPLEMENTS ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E
 39832					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39833					;HENCE, TLCA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 39834					;THE AC SHOULD BE 123756,,701234
 39835
 39836	055452	200 04 0 00 070745 	C73210:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39837	055453	645 04 0 00 000300 		TLCA	4,300			;*TLCA SHOULD SKIP AND
 39838										;PLACE 123756,,701234 INTO THE AC
 39839						STOP^
 39840	055454	254 04 0 00 055455 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39841	055455	324 00 0 00 055456 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39842									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39843									;IN THE SUBTEST) TO LOOP ON ERROR^
 39844	055456	312 04 0 00 071000 		CAME	4,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 39845						STOP^
 39846	055457	254 04 0 00 055460 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39847	055460	324 00 0 00 055461 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39848									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39849									;IN THE SUBTEST) TO LOOP ON ERROR^
 39850
 39851					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 79
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39852					;THIS TEST VERIFIES THAT TRCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39853					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39854					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39855					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39856					;HENCE, TRCN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39857					;AND RESULT IN THE AC SHOULD BE 123456,,701134
 39858
 39859	055461	200 03 0 00 070745 	C73300:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39860	055462	646 03 0 00 000300 		TRCN	3,300			;*SHOULD SKIP AND
 39861										;PLACE 123456,,701134 INTO THE AC
 39862						STOP^
 39863	055463	254 04 0 00 055464 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39864	055464	324 00 0 00 055465 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39865									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39866									;IN THE SUBTEST) TO LOOP ON ERROR^
 39867	055465	312 03 0 00 070777 		CAME	3,[123456,,701134]	;PASS IF C(AC)=123456,,701134
 39868						STOP^
 39869	055466	254 04 0 00 055467 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39870	055467	324 00 0 00 055470 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39871									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39872									;IN THE SUBTEST) TO LOOP ON ERROR^
 39873
 39874					;**********
 39875
 39876					;THIS TEST VERIFIES THAT TRCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39877					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 39878					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39879					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 39880					;HENCE, TRCN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39881					;AND THE RESULT IN THE AC SHOULD BE 123456,,701237
 39882
 39883	055470	200 02 0 00 070745 	C73310:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39884	055471	646 02 0 00 000003 		TRCN	2,3			;*TRCN SHOULD NOT SKIP AND
 39885										;PLACE 123456,,701237 INTO THE AC
 39886	055472	334 00 0 00 000000 		SKIPA				;PASS IF TRCN DID NOT SKIP
 39887						STOP^
 39888	055473	254 04 0 00 055474 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39889	055474	324 00 0 00 055475 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39890									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39891									;IN THE SUBTEST) TO LOOP ON ERROR^
 39892	055475	312 02 0 00 070776 		CAME	2,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 39893						STOP^
 39894	055476	254 04 0 00 055477 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39895	055477	324 00 0 00 055500 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39896									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39897									;IN THE SUBTEST) TO LOOP ON ERROR^
 39898
 39899					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 80
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39900					;THIS TEST VERIFIES THAT TLCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39901					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 39902					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39903					;IN THE CASE, C(AC)=123456,,701234 AND E=3
 39904					;HENCE, TLCN SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39905					;AND THE RESULT IN THE AC SHOULD BE 123456,,701234
 39906
 39907	055500	200 01 0 00 070745 	C73400:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39908	055501	647 01 0 00 000003 		TLCN	1,3			;*TLCN SHOULD SKIP AND
 39909										;PLACE 123455,701234 INTO THE AC
 39910						STOP^
 39911	055502	254 04 0 00 055503 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39912	055503	324 00 0 00 055504 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39913									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39914									;IN THE SUBTEST) TO LOOP ON ERROR^
 39915	055504	312 01 0 00 071001 		CAME	1,[123455,,701234]	;PASS IF C(AC)=123455,,701234
 39916						STOP^
 39917	055505	254 04 0 00 055506 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39918	055506	324 00 0 00 055507 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39920									;IN THE SUBTEST) TO LOOP ON ERROR^
 39921
 39922					;**********
 39923
 39924					;THIS TEST VERIFIES THAT TLCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 39925					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZER.
 39926					;THESE MASKED AC BITS ARE THEN COMPLEMENTED
 39927					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 39928					;HENCE, TLCN SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 39929					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234
 39930
 39931	055507	200 00 0 00 070745 	C73410:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39932	055510	647 00 0 00 000300 		TLCN	0,300			;*TLCN SHOULD NOT SKIP AND
 39933										;PLACE 123756,,701234 INTO THE AC
 39934	055511	334 00 0 00 000000 		SKIPA				;PASS IF TLCN DID NOT SKIP
 39935						STOP^
 39936	055512	254 04 0 00 055513 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39937	055513	324 00 0 00 055514 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39938									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39939									;IN THE SUBTEST) TO LOOP ON ERROR^
 39940	055514	312 00 0 00 071000 		CAME	0,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 39941						STOP^
 39942	055515	254 04 0 00 055516 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39943	055516	324 00 0 00 055517 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39944									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39945									;IN THE SUBTEST) TO LOOP ON ERROR^
 39946
 39947					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 81
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 39948					;THIS TEST VERIFIES THAT TSL COMPLEMENTS ALL BITS OF THE AC WHICH
 39949					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39950					;NOT SKIP THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 39951					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)6543,,654321
 39952					;HENCE, TSC SHOULD NOT SKIP AND C(AC) SHOULD BE -1,,-1
 39953
 39954	055517	200 17 0 00 070745 	C73500:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39955	055520	200 00 0 00 070754 		MOVE	0,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 39956	055521	651 17 0 00 000000 		TSC	17,0			;*TSC SHOULD NOT SKIP AND
 39957										;PLACE -1,,-1 INTO THE AC
 39958	055522	334 00 0 00 000000 		SKIPA				;PASS IF TSC DOES NOT SKIP
 39959						STOP^
 39960	055523	254 04 0 00 055524 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39961	055524	324 00 0 00 055525 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39963									;IN THE SUBTEST) TO LOOP ON ERROR^
 39964	055525	312 17 0 00 070254 		CAME	17,[-1]			;PASS IF C(AC)=-1,,-1
 39965						STOP^
 39966	055526	254 04 0 00 055527 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39967	055527	324 00 0 00 055530 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39968									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39969									;IN THE SUBTEST) TO LOOP ON ERROR^
 39970	055530	312 00 0 00 070754 		CAME	0,[076543,,654321]	;PASS IF C(E) UNCHANGED
 39971						STOP^
 39972	055531	254 04 0 00 055532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39973	055532	324 00 0 00 055533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39974									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39975									;IN THE SUBTEST) TO LOOP ON ERROR^
 39976
 39977					;**********
 39978
 39979					;THIS TEST VERIFIES THAT TSC COMPLEMENTS ALL BITS OF THE AC WHICH
 39980					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND DOES
 39981					;NOT SKIP THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 39982					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 39983					;HENCE, TSC SHOULD NOT SKIP AND C(AC) SHOULD BE 624426,,553711
 39984
 39985	055533	200 16 0 00 070745 	C73510:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 39986	055534	200 17 0 00 070761 		MOVE	17,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 39987	055535	651 16 0 00 000017 		TSC	16,17			;*TSC SHOULD NOT SKIP AND
 39988										;PLACE 624426,,553711 INTO THE AC
 39989	055536	334 00 0 00 000000 		SKIPA				;PASS IF TSC DOES NOT SKIP
 39990						STOP^
 39991	055537	254 04 0 00 055540 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39992	055540	324 00 0 00 055541 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39993									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 39994									;IN THE SUBTEST) TO LOOP ON ERROR^
 39995	055541	312 16 0 00 071002 		CAME	16,[624426,,553711]	;PASS IF C(AC)=624426,,553711
 39996						STOP^
 39997	055542	254 04 0 00 055543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 39998	055543	324 00 0 00 055544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 39999									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40000									;IN THE SUBTEST) TO LOOP ON ERROR^
 40001	055544	312 17 0 00 070761 		CAME	17,[252525,,707070]	;PASS IF C(E) UNCHANGED
 40002						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 81-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40003	055545	254 04 0 00 055546 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40004	055546	324 00 0 00 055547 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40005									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40006									;IN THE SUBTEST) TO LOOP ON ERROR^
 40007
 40008					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 82
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40009					;THIS TEST VERIFIES THAT TDCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40010					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40011					;C(E) ARE ZERO.  THESE MASKED
 40012					;AC BITS ARE THEN COMPLEMENTED
 40013					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 40014					;HENCE, TDCE SHOULD SKIP AND THE RESULT IN AC
 40015					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 40016
 40017	055547	200 15 0 00 070745 	C73600:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40018	055550	200 16 0 00 070763 		MOVE	16,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40019	055551	652 15 0 00 000016 		TDCE	15,16			;*TDCE SHOULD SKIP AND
 40020										;PLACE -1,,-1 INTO THE AC
 40021						STOP^
 40022	055552	254 04 0 00 055553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40023	055553	324 00 0 00 055554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40024									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40025									;IN THE SUBTEST) TO LOOP ON ERROR^
 40026	055554	312 15 0 00 070254 		CAME	15,[-1]			;PASS IF C(AC)=-1,,-1
 40027						STOP^
 40028	055555	254 04 0 00 055556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40029	055556	324 00 0 00 055557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40030									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40031									;IN THE SUBTEST) TO LOOP ON ERROR^
 40032	055557	312 16 0 00 070763 		CAME	16,[654321,,076543]	;PASS IF C(E) UNCHANGED
 40033						STOP^
 40034	055560	254 04 0 00 055561 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40035	055561	324 00 0 00 055562 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40036									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40037									;IN THE SUBTEST) TO LOOP ON ERROR^
 40038
 40039					;**********
 40040
 40041					;THIS TEST VERIFIES THAT TDCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40042					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40043					;C(E) ARE ZERO.  THESE MASKED 
 40044					;AC BITS ARE THEN COMPLEMENTED
 40045					;IN THIS CASE, C(AC)=123456,,701234 AND C(E) 754321,,076543
 40046					;HENCE, TDCE SHOULD NOT SKIP AND THE RESULT IN AC
 40047					;SHOULD BE 677777,,-1 C(E) IS NOT AFFECTED.
 40048
 40049	055562	200 14 0 00 070745 	C73610:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40050	055563	200 15 0 00 070764 		MOVE	15,[754321,,076543]	;PRELOAD E WITH 754321,,076543
 40051	055564	652 14 0 00 000015 		TDCE	14,15			;*TDCE SHOULD NOT SKIP AND
 40052										;PLACE 677777,,-1 INTO THE AC
 40053	055565	334 00 0 00 000000 		SKIPA				;PASS IF TDCE DOES NOT SKIP
 40054						STOP^
 40055	055566	254 04 0 00 055567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40056	055567	324 00 0 00 055570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40057									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40058									;IN THE SUBTEST) TO LOOP ON ERROR^
 40059	055570	312 14 0 00 070374 		CAME	14,[677777,,-1]		;PASS IF C(AC)=677777,,-1
 40060						STOP^
 40061	055571	254 04 0 00 055572 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40062	055572	324 00 0 00 055573 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40063									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 82-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40064									;IN THE SUBTEST) TO LOOP ON ERROR^
 40065	055573	312 15 0 00 070764 		CAME	15,[754321,,076543]	;PASS IF C(E) UNCHANGED
 40066						STOP^
 40067	055574	254 04 0 00 055575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40068	055575	324 00 0 00 055576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40069									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40070									;IN THE SUBTEST) TO LOOP ON ERROR^
 40071
 40072					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 83
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40073					;THIS TEST VERIFIES THAT TSCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40074					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40075					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40076					;AC BITS ARE THEN COMPLEMENTED
 40077					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40078					;HENCE, TSCE SHOULD SKIP AND THE RESULT IN THE AC
 40079					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 40080
 40081	055576	200 13 0 00 070745 	C73700:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40082	055577	200 14 0 00 070754 		MOVE	14,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 40083	055600	653 13 0 00 000014 		TSCE	13,14			;*TSCE SHOULD SKIP AND
 40084										;PLACE -1,,-1 INTO THE AC
 40085						STOP^
 40086	055601	254 04 0 00 055602 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40087	055602	324 00 0 00 055603 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40088									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40089									;IN THE SUBTEST) TO LOOP ON ERROR^
 40090	055603	312 13 0 00 070254 		CAME 	13,[-1]			;PASS IF C(E) UNCHANGED
 40091						STOP^
 40092	055604	254 04 0 00 055605 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40093	055605	324 00 0 00 055606 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40094									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40095									;IN THE SUBTEST) TO LOOP ON ERROR^
 40096
 40097					;**********
 40098
 40099					;THIS TEST VERIFIES THAT TSCE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40100					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40101					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40102					;AC BITS ARE THEN COMPLEMENTED
 40103					;IN THIS CASE, C(AC)=123456,701234 AND C(E)=076543,,657321
 40104					;HENCE, TSCE SHOULD NOT SKIP AND THE RESULT IN THE AC
 40105					;SHOULD BE 774777,,-1.  C(E) IS NOT AFFECTED.
 40106
 40107	055606	200 12 0 00 070745 	C73710:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40108	055607	200 13 0 00 070766 		MOVE	13,[76543,,657321]	;PRELOAD E WITH 076543,,657321
 40109	055610	653 12 0 00 000013 		TSCE	12,13			;*TSCE HOULD NOT SKIP AND
 40110										;PLACE 774777,,-1 INTO THE AC
 40111	055611	334 00 0 00 000000 		SKIPA				;PASS IF TSCE DOES NOT SKIP
 40112						STOP^
 40113	055612	254 04 0 00 055613 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40114	055613	324 00 0 00 055614 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40115									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40116									;IN THE SUBTEST) TO LOOP ON ERROR^
 40117	055614	312 12 0 00 071003 		CAME	12,[774777,,-1]		;PASS IF C(AC)=774777,,-1
 40118						STOP^
 40119	055615	254 04 0 00 055616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40120	055616	324 00 0 00 055617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40121									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40122									;IN THE SUBTEST) TO LOOP ON ERROR^
 40123	055617	312 13 0 00 070766 		CAME	13,[76543,,657321]	;PASS IF C(E) UNCHANGED
 40124						STOP^
 40125	055620	254 04 0 00 055621 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40126	055621	324 00 0 00 055622 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40127									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 83-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40128									;IN THE SUBTEST) TO LOOP ON ERROR^
 40129
 40130					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 84
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40131					;THIS TEST VERIFIES THAT TDCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40132					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 40133					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40134					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 40135					;HENCE, TDCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40136
 40137	055622	200 11 0 00 070745 	C74000:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40138	055623	200 12 0 00 070763 		MOVE	12,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40139	055624	654 11 0 00 000012 		TDCA	11,12			;*TDCA SHOULD SKIP AND
 40140										;PLACE -1,,-1 INTO THE AC
 40141						STOP^
 40142	055625	254 04 0 00 055626 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40143	055626	324 00 0 00 055627 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40144									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40145									;IN THE SUBTEST) TO LOOP ON ERROR^
 40146	055627	312 11 0 00 070254 		CAME	11,[-1]			;PASS IF C(AC)=-1,,-1
 40147						STOP^
 40148	055630	254 04 0 00 055631 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40149	055631	324 00 0 00 055632 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40150									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40151									;IN THE SUBTEST) TO LOOP ON ERROR^
 40152	055632	312 12 0 00 070763 		CAME	12,[654321,,76543]	;PASS IF C(E) UNCHANGED
 40153						STOP^
 40154	055633	254 04 0 00 055634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40155	055634	324 00 0 00 055635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40156									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40157									;IN THE SUBTEST) TO LOOP ON ERROR^
 40158
 40159					;**********
 40160
 40161					;THIS TEST VERIFIES THAT TDCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40162					;CORRESPOND TO 1'S IN C(E) AND SLWAYS
 40163					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 40164					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 40165					;HENCE, TDCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 371173,,006244
 40166
 40167	055635	200 10 0 00 070745 	C74100:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40168	055636	200 11 0 00 070761 		MOVE	11,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 40169	055637	654 10 0 00 000011 		TDCA	10,11			;*TDCA SHOULD SKP AND
 40170										;PLACE 371173,,006244 INTO THE AC
 40171						STOP^
 40172	055640	254 04 0 00 055641 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40173	055641	324 00 0 00 055642 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40174									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40175									;IN THE SUBTEST) TO LOOP ON ERROR^
 40176	055642	312 10 0 00 071004 		CAME	10,[371173,,6244]	;PASS IF C(AC)=371173,,006244
 40177						STOP^
 40178	055643	254 04 0 00 055644 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40179	055644	324 00 0 00 055645 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40180									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40181									;IN THE SUBTEST) TO LOOP ON ERROR^
 40182	055645	312 11 0 00 070761 		CAME	11,[252525,,707070]	;PASS IF C(E) UNCHANGED
 40183						STOP^
 40184	055646	254 04 0 00 055647 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40185	055647	324 00 0 00 055650 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 84-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40186									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40187									;IN THE SUBTEST) TO LOOP ON ERROR^
 40188
 40189					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 85
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40190					;THIS TEST VERIFIES THAT TSCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40191					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40192					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40193					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40194					;HENCE, TSCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40195
 40196	055650	200 07 0 00 070745 	C74200:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40197	055651	200 10 0 00 070754 		MOVE	10,[076543,,654321]	;PRELOAD E WITH 076543,,654321
 40198	055652	655 07 0 00 000010 		TSCA	7,10			;*TSCA CHOULD SKIP AND
 40199										;PLACE -1,,-1 INTO THE AC
 40200						STOP^
 40201	055653	254 04 0 00 055654 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40202	055654	324 00 0 00 055655 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40203									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40204									;IN THE SUBTEST) TO LOOP ON ERROR^
 40205	055655	312 07 0 00 070254 		CAME	7,[-1]			;PASS IF C(AC)=-1,,-1
 40206						STOP^
 40207	055656	254 04 0 00 055657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40208	055657	324 00 0 00 055660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40209									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40210									;IN THE SUBTEST) TO LOOP ON ERROR^
 40211	055660	312 10 0 00 070754 		CAME	10,[076543,,654321]	;PASS IF C(E) UNCHANGED
 40212						STOP^
 40213	055661	254 04 0 00 055662 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40214	055662	324 00 0 00 055663 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40215									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40216									;IN THE SUBTEST) TO LOOP ON ERROR^
 40217
 40218					;**********
 40219
 40220					;THIS TEST VERIFIES THAT TSCA COMPLEMENTS ALL BITS OF THE AC WHICH
 40221					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40222					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40223					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=701234,,123456
 40224					;HENCE, TSCA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 0
 40225
 40226	055663	200 06 0 00 070745 	C74210:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40227	055664	200 07 0 00 070771 		MOVE	7,[701234,,123456]	;PRELOAD E WITH 701234,,123456
 40228	055665	655 06 0 00 000007 		TSCA	6,7			;*TSCA SHOULD SKIP AND
 40229										;PLACE 0 INTO THE AC
 40230						STOP^
 40231	055666	254 04 0 00 055667 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40232	055667	324 00 0 00 055670 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40233									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40234									;IN THE SUBTEST) TO LOOP ON ERROR^
 40235	055670	312 06 0 00 070253 		CAME	6,[0]			;PASS IF C(AC)=0
 40236						STOP^
 40237	055671	254 04 0 00 055672 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40238	055672	324 00 0 00 055673 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40239									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40240									;IN THE SUBTEST) TO LOOP ON ERROR^
 40241	055673	312 07 0 00 070771 		CAME	7,[701234,,123456]	;PASS IF C(E) UNCHANGED
 40242						STOP^
 40243	055674	254 04 0 00 055675 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40244	055675	324 00 0 00 055676 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 85-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40245									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40246									;IN THE SUBTEST) TO LOOP ON ERROR^
 40247
 40248					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40249					;THIS TEST VERIFIES THAT TDCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40250					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40251					;C(E) ARE ZERO.  THESE MASKED
 40252					;AC BITS ARE THEN COMPLEMENTED
 40253					;IN THE CASE, C(AC)=123456,,701234 AND C(E)=654321,,076547
 40254					;HENCE, TDCN SHOULD SKIP AND THE RESULT IN AC
 40255					;SHOULD BE -1,,777773 C(E) IS NOT AFFECTED
 40256
 40257	055676	200 05 0 00 070745 	C74300:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40258	055677	200 06 0 00 070772 		MOVE	6,[654321,,76547]	;PRELOAD E WITH 654321,,076547
 40259	055700	656 05 0 00 000006 		TDCN	5,6			;*TDCN SHOULD SKIP AND
 40260										;PLACE -1,,777773 INTO THE AC
 40261						STOP^
 40262	055701	254 04 0 00 055702 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40263	055702	324 00 0 00 055703 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40264									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40265									;IN THE SUBTEST) TO LOOP ON ERROR^
 40266	055703	312 05 0 00 070335 		CAME	5,[-1,,777773]		;PASS IF C(AC)=-1,777773
 40267						STOP^
 40268	055704	254 04 0 00 055705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40269	055705	324 00 0 00 055706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40270									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40271									;IN THE SUBTEST) TO LOOP ON ERROR^
 40272	055706	312 06 0 00 070772 		CAME	6,[654321,,76547]	;PASS IF C(E) UNCHANGED
 40273						STOP^
 40274	055707	254 04 0 00 055710 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40275	055710	324 00 0 00 055711 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40276									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40277									;IN THE SUBTEST) TO LOOP ON ERROR^
 40278
 40279					;**********
 40280
 40281					;THIS TEST VERIFIES THAT TDCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40282					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40283					;C(E) ARE ZERO.  THESE MASKED
 40284					;AC BITS ARE THEN COMPLEMENTED
 40285					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 40286					;HENCE, TDCN SHOULD NOT SKIP AND THE REUSLT IN AC
 40287					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 40288
 40289	055711	200 04 0 00 070745 	C74310:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40290	055712	200 05 0 00 070763 		MOVE	5,[654321,,76543]	;PRELOAD E WITH 654321,,076543
 40291	055713	656 04 0 00 000005 		TDCN	4,5			;*TDCN SHOULD NOT SKIP AND
 40292										;PLACE -1,,-1 INTO THE AC
 40293	055714	334 00 0 00 000000 		SKIPA				;PASS IF TDCN DOES NOT SKIP
 40294						STOP^
 40295	055715	254 04 0 00 055716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40296	055716	324 00 0 00 055717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40297									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40298									;IN THE SUBTEST) TO LOOP ON ERROR^
 40299	055717	312 04 0 00 070254 		CAME	4,[-1]			;PASS IF C(AC)=-1,,-1
 40300						STOP^
 40301	055720	254 04 0 00 055721 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40302	055721	324 00 0 00 055722 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40303									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 86-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40304									;IN THE SUBTEST) TO LOOP ON ERROR^
 40305	055722	312 05 0 00 070763 		CAME	5,[654321,,76543]	;PASS IF C(E) UNCHANGED
 40306						STOP^
 40307	055723	254 04 0 00 055724 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40308	055724	324 00 0 00 055725 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40309									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40310									;IN THE SUBTEST) TO LOOP ON ERROR^
 40311
 40312					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40313					;THIS TEST VERIFIES THAT TSCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40314					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40315					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40316					;AC BITS ARE THEN COMPLEMENTED
 40317					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=077543,,654321
 40318					;HENCE, TSCN SHOULD SKIP AND THE RESULT IN AC
 40319					;SHOULD BE -1,,776777.  C(E) IS NOT AFFECTED
 40320
 40321	055725	200 03 0 00 070745 	C74400:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40322	055726	200 04 0 00 070774 		MOVE	4,[77543,,654321]	;PRELOAD E WITH 077543,,654321
 40323	055727	657 03 0 00 000004 		TSCN	3,4			;*TSCN SHOULD SKIP AND
 40324										;PLACE -1,,776777 INTO THE AC
 40325						STOP^
 40326	055730	254 04 0 00 055731 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40327	055731	324 00 0 00 055732 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40328									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40329									;IN THE SUBTEST) TO LOOP ON ERROR^
 40330	055732	312 03 0 00 070344 		CAME	3,[-1,,776777]		;PASS IF C(AC)=-1,776777
 40331						STOP^
 40332	055733	254 04 0 00 055734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40333	055734	324 00 0 00 055735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40334									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40335									;IN THE SUBTEST) TO LOOP ON ERROR^
 40336	055735	312 04 0 00 070774 		CAME	4,[77543,,654321]	;PASS IF C(E) UNCHANGED
 40337						STOP^
 40338	055736	254 04 0 00 055737 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40339	055737	324 00 0 00 055740 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40340									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40341									;IN THE SUBTEST) TO LOOP ON ERROR^
 40342
 40343					;**********
 40344
 40345					;THIS TEST VERIFIES THAT TSCN SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40346					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40347					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40348					;AC BITS ARE THEN COMPLEMENTD
 40349					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40350					;HENCE, TSCN SHOULD NOT SKIP AND THE RESULT IN AC
 40351					;SHOULD BE -1,,-1.  C(E) IS NOT AFFECTED.
 40352
 40353	055740	200 02 0 00 070745 	C74410:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40354	055741	200 03 0 00 070754 		MOVE	3,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 40355	055742	657 02 0 00 000003 		TSCN	2,3			;*TSCN SHOULD NOT SKIP AND
 40356										;PLACE -1,,-1 INTO THE AC
 40357	055743	334 00 0 00 000000 		SKIPA				;PASS IF TSCN DOES NOT SKIP
 40358						STOP^
 40359	055744	254 04 0 00 055745 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40360	055745	324 00 0 00 055746 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40362									;IN THE SUBTEST) TO LOOP ON ERROR^
 40363	055746	312 02 0 00 070254 		CAME	2,[-1]			;PASS IF C(AC)=-1,,-1
 40364						STOP^
 40365	055747	254 04 0 00 055750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40366	055750	324 00 0 00 055751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40367									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 87-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40368									;IN THE SUBTEST) TO LOOP ON ERROR^
 40369	055751	312 03 0 00 070754 		CAME	3,[76543,,654321]	;PASS IF C(E) UNCHANGED
 40370						STOP^
 40371	055752	254 04 0 00 055753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40372	055753	324 00 0 00 055754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40373									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40374									;IN THE SUBTEST) TO LOOP ON ERROR^
 40375
 40376					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 88
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40377					;THIS TEST VERIFIES THAT TRO CHANGES ALL BITS IN THE AC-RIGHT WHICH
 40378					;CORRESPOND TO 1'S IN E TO ONES AND DOES ANT SKIP
 40379					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40380					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701237
 40381
 40382	055754	200 01 0 00 070745 	C74500:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40383	055755	660 01 0 00 000003 		TRO	1,3			;*TRO SHOULD NOT SKIP AND
 40384										;PLACE 123456,,701237 INTO THE AC
 40385	055756	334 00 0 00 000000 		SKIPA				;PASS IF TRO DID NOT SKIP
 40386						STOP^
 40387	055757	254 04 0 00 055760 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40388	055760	324 00 0 00 055761 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40389									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40390									;IN THE SUBTEST) TO LOOP ON ERROR^
 40391	055761	312 01 0 00 070776 		CAME	1,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 40392						STOP^
 40393	055762	254 04 0 00 055763 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40394	055763	324 00 0 00 055764 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40395									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40396									;IN THE SUBTEST) TO LOOP ON ERROR^
 40397
 40398					;**********
 40399
 40400					;THIS TEST VERIFIES THAT TRO CHANGES ALL BITS IN THE AC-RIGHT WHICH
 40401					;CORRESPOND TO 1'S IN E TO ONES AND DOES NOT SKIP
 40402					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40403					;HENCE, THE RESULT IN THE AC SHOULD BE 123456,,701224
 40404
 40405	055764	200 00 0 00 070745 	C74510:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40406	055765	660 00 0 00 000300 		TRO	0,300			;*TRO SHOULD NOT SKIP AND
 40407										;PLACE 123456,,701334 INTO THE AC
 40408	055766	334 00 0 00 000000 		SKIPA				;PASS IF TRO DID NOT SKIP
 40409						STOP^
 40410	055767	254 04 0 00 055770 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40411	055770	324 00 0 00 055771 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40412									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40413									;IN THE SUBTEST) TO LOOP ON ERROR^
 40414	055771	312 00 0 00 071005 		CAME	0,[123456,,701334]	;PASS IF C(AC)=123456,,701334
 40415						STOP^
 40416	055772	254 04 0 00 055773 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40417	055773	324 00 0 00 055774 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40418									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40419									;IN THE SUBTEST) TO LOOP ON ERROR^
 40420
 40421					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 89
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40422					;THIS TEST VERIFIES THAT TLO CHANGES ALL BITS IN THE AC-LEFT WHICH
 40423					;CORRESPOND TO 1'S IN E TO ONES AND DOES NOT SKIP
 40424					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40425					;HENCE, THE RESULT IN THE AC SHOULD BE 123756,,701234
 40426
 40427	055774	200 17 0 00 070745 	C74600:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40428	055775	661 17 0 00 000300 		TLO	17,300			;*TLO SHOULD NOT SKIP AND
 40429										;PLACE 123756,,701234 INTO THE AC
 40430	055776	334 00 0 00 000000 		SKIPA				;PASS IF TLO DID NOT SKIP
 40431						STOP^
 40432	055777	254 04 0 00 056000 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40433	056000	324 00 0 00 056001 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40434									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40435									;IN THE SUBTEST) TO LOOP ON ERROR^
 40436	056001	312 17 0 00 071000 		CAME	17,[123756,,701234]	;PASS IF C(AC)=123456,,701234
 40437						STOP^
 40438	056002	254 04 0 00 056003 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40439	056003	324 00 0 00 056004 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40440									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40441									;IN THE SUBTEST) TO LOOP ON ERROR^
 40442
 40443					;**********
 40444
 40445					;THIS TEST VERIFIES THAT TLO CHANGES ALL BITS IN THE AC-LEFT WHICH
 40446					;CORRESPOND TO 1'S IN E TO ONES AND DOES NOT SKIP
 40447					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40448					;HENCE, THE RESULT IN THE AC SHOULD BE 123457,,701234
 40449
 40450	056004	200 16 0 00 071006 	C74610:	MOVE	16,[123456,,70234]	;PRELOAD AC WITH 123456,,701234
 40451	056005	661 16 0 00 000003 		TLO	16,3			;*TLO SHOULD NOT SKIP AND
 40452										;PLACE 123457,,701234 INTO THE AC
 40453	056006	334 00 0 00 000000 		SKIPA				;PASS IF DID NOT SKIP
 40454						STOP^
 40455	056007	254 04 0 00 056010 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40456	056010	324 00 0 00 056011 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40457									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40458									;IN THE SUBTEST) TO LOOP ON ERROR^
 40459	056011	312 16 0 00 071007 		CAME	16,[123457,,70234]	;PASS IF C(AC)=123457,,701234
 40460						STOP^
 40461	056012	254 04 0 00 056013 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40462	056013	324 00 0 00 056014 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40463									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40464									;IN THE SUBTEST) TO LOOP ON ERROR^
 40465
 40466					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 90
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40467					;THIS TEST VERIFIES THAT TROE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40468					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40469					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40470					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40471					;HENCE, TROE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40472					;AND RESULT IN THE AC SHOUD BE 123456,,701237
 40473
 40474	056014	200 15 0 00 070745 	C74700:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40475	056015	662 15 0 00 000003 		TROE	15,3			;TROE SHOULD SKIP AND
 40476										;PLACE 123456,,701237 IN TO THE AC
 40477						STOP^
 40478	056016	254 04 0 00 056017 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40479	056017	324 00 0 00 056020 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40480									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40481									;IN THE SUBTEST) TO LOOP ON ERROR^
 40482	056020	312 15 0 00 070776 		CAME	15,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 40483						STOP^
 40484	056021	254 04 0 00 056022 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40485	056022	324 00 0 00 056023 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40486									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40487									;IN THE SUBTEST) TO LOOP ON ERROR^
 40488
 40489					;**********
 40490
 40491					;THIS TEST VERIFIES THAT TROE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40492					;IF AND ONLY IF ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40493					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40494					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40495					;HENCE, TROE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40496					;AND THE RESULT IN THE AC SHOULD BE 123456,,701334
 40497
 40498	056023	200 14 0 00 070745 	C74710:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40499	056024	662 14 0 00 000300 		TROE	14,300			;*TROE SHOULD NOT SKIP AND
 40500										;PLACE 123456,,701224 INTO THE AC
 40501	056025	334 00 0 00 000000 		SKIPA				;PASS IF DID NOT SKIP
 40502						STOP^
 40503	056026	254 04 0 00 056027 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40504	056027	324 00 0 00 056030 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40505									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40506									;IN THE SUBTEST) TO LOOP ON ERROR^
 40507	056030	312 14 0 00 071005 		CAME	14,[123456,,701334]	;PASS IF C(AC)=123456,,701334
 40508						STOP^
 40509	056031	254 04 0 00 056032 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40510	056032	324 00 0 00 056033 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40512									;IN THE SUBTEST) TO LOOP ON ERROR^
 40513
 40514					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 91
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40515					;THIS TEST VERIFIES THAT TLOE SKIPS THE NEXT SEQUENTIAL  INSTRUCTION
 40516					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 40517					;THESE MASKED AC BITS ARE TEN CHANGED TO ONES
 40518					;IN THES CASE, C(AC)=123456,,701234 AND E=300
 40519					;HENCE, TLOE SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40520					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234
 40521
 40522	056033	200 13 0 00 070745 	C75000:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40523	056034	663 13 0 00 000300 		TLOE	13,300			;*TLOE SOULD SKIP AND
 40524										;PLAND 123756,,701234 INTO THE AC
 40525						STOP^
 40526	056035	254 04 0 00 056036 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40527	056036	324 00 0 00 056037 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40528									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40529									;IN THE SUBTEST) TO LOOP ON ERROR^
 40530	056037	312 13 0 00 071000 		CAME	13,[123756,,701234]	;PASS IF C(AC)=123456,,701234
 40531						STOP^
 40532	056040	254 04 0 00 056041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40533	056041	324 00 0 00 056042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40534									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40535									;IN THE SUBTEST) TO LOOP ON ERROR^
 40536
 40537					;********
 40538
 40539					;THIS TEST VERIFIES THAT TLOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40540					;IF AND ONLY IF ALL BITS IN AC-LEFT CORRESPONDING  TO 1'S IN E ARE ZERO.
 40541					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40542					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40543					;HENCE, TLOE SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40544					;AND THE RESULT IN THE AC SHOULD BE 123457,,701234
 40545
 40546	056042	200 12 0 00 070745 	C75010:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40547	056043	663 12 0 00 000003 		TLOE	12,3			;*TLOE SHOULD NOT SKIP AND
 40548										;PLACE 123457,,701234 INTO THE AC
 40549	056044	334 00 0 00 000000 		SKIPA				;PASS IF TLOE DID NOT SKIP
 40550						STOP^
 40551	056045	254 04 0 00 056046 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40552	056046	324 00 0 00 056047 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40553									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40554									;IN THE SUBTEST) TO LOOP ON ERROR^
 40555	056047	312 12 0 00 071010 		CAME	12,[123457,,701234]	;PASS IF C(AC)=123457,,701234
 40556						STOP^
 40557	056050	254 04 0 00 056051 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40558	056051	324 00 0 00 056052 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40559									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40560									;IN THE SUBTEST) TO LOOP ON ERROR^
 40561
 40562					;*******
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 92
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40563					;THIS TEST VERIFIES THAT TROA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTUCTION
 40564					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ONES
 40565					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40566					;HENCE, TROA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 40567					;THE AC SHOULD BE 123456,,701237
 40568
 40569	056052	200 11 0 00 070745 	C75100:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40570	056053	664 11 0 00 000003 		TROA	11,3			;*TROA SHOULD SKIP AND
 40571										;PLACE 123456,,701237
 40572						STOP^
 40573	056054	254 04 0 00 056055 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40574	056055	324 00 0 00 056056 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40575									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40576									;IN THE SUBTEST) TO LOOP ON ERROR^
 40577	056056	312 11 0 00 070776 		CAME	11,[123456,,701237]	;PASS IF C(AC)=123456,,701237
 40578						STOP^
 40579	056057	254 04 0 00 056060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40580	056060	324 00 0 00 056061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40581									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40582									;IN THE SUBTEST) TO LOOP ON ERROR^
 40583
 40584					;**********
 40585
 40586					;THIS TEST VERIFIES THAT TROA ALWAYS SKIPS THE NEXT SEQUENTAIL INSTRUCTION
 40587					;AND CHANGES ALL BITS IN AC-RIGHT WHICH CORRESPOND TO 1'S IN E TO ONES
 40588					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40589					;HENCE, TROA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 40590					;THE AC SHOULD BE 123456,,701334
 40591
 40592	056061	200 10 0 00 070745 	C75110:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40593	056062	664 10 0 00 000300 		TROA	10,300			;*TROA SHOULD SKIP AND
 40594										;PLACE 123456,,701334 INTO THE AC
 40595						STOP^
 40596	056063	254 04 0 00 056064 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40597	056064	324 00 0 00 056065 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40598									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40599									;IN THE SUBTEST) TO LOOP ON ERROR^
 40600	056065	312 10 0 00 071005 		CAME	10,[123456,,701334]	;PASS IF C (AC)=123456,,701334
 40601						STOP^
 40602	056066	254 04 0 00 056067 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40603	056067	324 00 0 00 056070 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40604									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40605									;IN THE SUBTEST) TO LOOP ON ERROR^
 40606
 40607					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 93
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40608					;THIS TEST VERIFIES THAT TLOA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTUCTION
 40609					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND 1'S IN E TO ONES
 40610					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40611					;HENCE, TLOA SHOULD SKIP THE NEXT INSTRUCTION AND RESULT IN
 40612					;THE AC SHOULD BE 123457,,701234
 40613
 40614	056070	200 07 0 00 070745 	C75200:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40615	056071	665 07 0 00 000003 		TLOA	7,3			;*TLOA SHOULD SKIP AND
 40616										;PLACE 123457,,701234 INTO THE AC
 40617						STOP^
 40618	056072	254 04 0 00 056073 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40619	056073	324 00 0 00 056074 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40620									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40621									;IN THE SUBTEST) TO LOOP ON ERROR^
 40622	056074	312 07 0 00 071010 		CAME	7,[123457,,701234]	;PASS IF C(AC)=123457,,701234]
 40623						STOP^
 40624	056075	254 04 0 00 056076 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40625	056076	324 00 0 00 056077 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40626									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40627									;IN THE SUBTEST) TO LOOP ON ERROR^
 40628
 40629					;**********
 40630
 40631					;THIS TEST VERIFIES THAT TLOA ALWAYS SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40632					;AND CHANGES ALL BITS IN AC-LEFT WHICH CORRESPOND TO 1'S IN E TO ONES
 40633					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40634					;HENCE, TLOA SHOULD SKIP THE NEXT INSTRUCTION AND THE RESULT IN
 40635					;THE AC SHOULD BE 123756,,701234
 40636
 40637	056077	200 06 0 00 070745 	C75210:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40638	056100	665 06 0 00 000300 		TLOA	6,300			;*TLOA SHOULD SKIP AND
 40639										;PLACE 123756,,701234 INTO THE AC
 40640						STOP^
 40641	056101	254 04 0 00 056102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40642	056102	324 00 0 00 056103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40643									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40644									;IN THE SUBTEST) TO LOOP ON ERROR^
 40645	056103	312 06 0 00 071000 		CAME	6,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 40646						STOP^
 40647	056104	254 04 0 00 056105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40648	056105	324 00 0 00 056106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40649									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40650									;IN THE SUBTEST) TO LOOP ON ERROR^
 40651
 40652					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 94
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40653					;THIS TEST VERIFIES THAT TRON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40654					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40655					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40656					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40657					;HENCE, TRON SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40658					;AND THE RESULT IN THE AC SHOULD BE 123456,,701334
 40659
 40660	056106	200 05 0 00 070745 	C75300:	MOVE	5,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40661	056107	666 05 0 00 000300 		TRON	5,300			;*TRON SHOULD SKIP AND
 40662										;PLACE 123456,,701334 INTO THE AC
 40663						STOP^
 40664	056110	254 04 0 00 056111 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40665	056111	324 00 0 00 056112 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40666									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40667									;IN THE SUBTEST) TO LOOP ON ERROR^
 40668	056112	312 05 0 00 071005 		CAME	5,[123456,,701334]	;PASS IF C(AC)=123456,,701334
 40669						STOP^
 40670	056113	254 04 0 00 056114 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40671	056114	324 00 0 00 056115 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40672									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40673									;IN THE SUBTEST) TO LOOP ON ERROR^
 40674
 40675					;**********
 40676
 40677					;THIS TEST VERIFIES THAT TRON SKIPS THE NEXT SEQUENTIAL INSTUCTION
 40678					;IF AND ONLY IF NOT ALL BITS IN AC-RIGHT CORRESPONDING TO 1'S IN E ARE ZERO.
 40679					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40680					;IN THIS CASE, C(AC)=123456,,701234 AND E=3
 40681					;HENCE, TRON SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40682					;AND THE RESULT IN THE AC SHOULD BE 123456,,701237
 40683
 40684	056115	200 04 0 00 070745 	C75310:	MOVE	4,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40685	056116	666 04 0 00 000003 		TRON	4,3			;*TRON SHOULD NOT  SKIP AND
 40686										;PLACE 123456,,701237 INTO THE AC
 40687	056117	334 00 0 00 000000 		SKIPA				;PASS IF TRON DID NOT SKIP
 40688						STOP^
 40689	056120	254 04 0 00 056121 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40690	056121	324 00 0 00 056122 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40691									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40692									;IN THE SUBTEST) TO LOOP ON ERROR^
 40693	056122	312 04 0 00 070776 		CAME	4,[123456,,701237]	;PASS IF C(AC)=123456,701237
 40694						STOP^
 40695	056123	254 04 0 00 056124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40696	056124	324 00 0 00 056125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40697									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40698									;IN THE SUBTEST) TO LOOP ON ERROR^
 40699
 40700					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 95
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40701					;THIS TEST VERIFIES THAT TLON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40702					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 40703					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40704					;IN THIS CASE, C(AC)-123456,,701234 AND E=3
 40705					;HENCE, TLON SHOULD SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40706					;AND THE RESULT IN THE AC SHOULD BE 123457,,701234
 40707
 40708	056125	200 03 0 00 070745 	C75400:	MOVE	3,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40709	056126	667 03 0 00 000003 		TLON	3,3			;*TLON SHOULD SKIP AND
 40710										;PLACE 123457,,701234 INTO THE AC
 40711						STOP^
 40712	056127	254 04 0 00 056130 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40713	056130	324 00 0 00 056131 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40714									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40715									;IN THE SUBTEST) TO LOOP ON ERROR^
 40716	056131	312 03 0 00 071010 		CAME	3,[123457,,701234]	;PASS IF C(AC)=123457,,701234
 40717						STOP^
 40718	056132	254 04 0 00 056133 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40719	056133	324 00 0 00 056134 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40720									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40721									;IN THE SUBTEST) TO LOOP ON ERROR^
 40722
 40723					;*******
 40724
 40725					;THIS TEST VERIFIES THAT TLON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40726					;IF AND ONLY IF NOT ALL BITS IN AC-LEFT CORRESPONDING TO 1'S IN E ARE ZERO.
 40727					;THESE MASKED AC BITS ARE THEN CHANGED TO ONES
 40728					;IN THIS CASE, C(AC)=123456,,701234 AND E=300
 40729					;HENCE, TLON SHOULD NOT SKIP THE NEXT SEQUENTIAL INSTRUCTION
 40730					;AND THE RESULT IN THE AC SHOULD BE 123756,,701234
 40731
 40732	056134	200 02 0 00 070745 	C75410:	MOVE	2,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40733	056135	667 02 0 00 000300 		TLON	2,300			;*TLON SHOULD NOT SKIP AND
 40734										;PLACE 123756,,701234 INTO THE AC
 40735	056136	334 00 0 00 000000 		SKIPA				;PASS IF TLON DID NOT SKIP
 40736						STOP^
 40737	056137	254 04 0 00 056140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40738	056140	324 00 0 00 056141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40739									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40740									;IN THE SUBTEST) TO LOOP ON ERROR^
 40741	056141	312 02 0 00 071000 		CAME	2,[123756,,701234]	;PASS IF C(AC)=123756,,701234
 40742						STOP^
 40743	056142	254 04 0 00 056143 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40744	056143	324 00 0 00 056144 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40745									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40746									;IN THE SUBTEST) TO LOOP ON ERROR^
 40747
 40748					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 96
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40749					;THIS TEST VERIFIES THAT TDOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40750					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40751					;C(E)ARE ZERO.  THESE MASKED
 40752					;AC BITS ARE THEN CHANGED TO ONES
 40753					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543 
 40754					;HENCE, TDOE SHOULD SKIP AND THE RESULT IN AC
 40755					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 40756
 40757	056144	200 01 0 00 070745 	C75500:	MOVE	1,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40758	056145	200 02 0 00 070763 		MOVE	2,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40759	056146	672 01 0 00 000002 		TDOE	1,2			;*TDOE SHOULD SKIP AND
 40760										;PLACE -1,,-1 INTO THE AC
 40761						STOP^
 40762	056147	254 04 0 00 056150 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40763	056150	324 00 0 00 056151 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40764									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40765									;IN THE SUBTEST) TO LOOP ON ERROR^
 40766	056151	312 01 0 00 070254 		CAME	1,[-1]			;PASS IF C(AC)=-1,,-1
 40767						STOP^
 40768	056152	254 04 0 00 056153 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40769	056153	324 00 0 00 056154 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40770									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40771									;IN THE SUBTEST) TO LOOP ON ERROR^
 40772	056154	312 02 0 00 070763 		CAME	2,[654321,,76543]	;PASS IF C(E) UNCHANGED
 40773						STOP^
 40774	056155	254 04 0 00 056156 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40775	056156	324 00 0 00 056157 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40776									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40777									;IN THE SUBTEST) TO LOOP ON ERROR^
 40778
 40779					;**********
 40780
 40781					;THIS TEST VERIFIES THAT TDOE SKIPS THE NEXT SEQUENTAIL INSTRUCTION
 40782					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40783					;C(E) ARE ZERO.  THESE MASKED
 40784					;AC BITS ARE THEN CHANGED TO ONES
 40785					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=754321,,076543
 40786					;HENCE, TDOE SHOULD NOT SKIP AND THE RESULT IN AC
 40787					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTD
 40788
 40789	056157	200 00 0 00 070745 	C75510:	MOVE	0,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40790	056160	200 01 0 00 070764 		MOVE	1,[754321,,76543]	;PRELOAD E WITH 754321,,076543
 40791	056161	672 00 0 00 000001 		TDOE	0,1			;*TDOE SHOULD NOT SKIP AND
 40792										;PLACE -1,,-1 INTO THE AC
 40793	056162	334 00 0 00 000000 		SKIPA				;PASS IF TDOE DOES NOT SKIP
 40794						STOP^
 40795	056163	254 04 0 00 056164 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40796	056164	324 00 0 00 056165 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40797									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40798									;IN THE SUBTEST) TO LOOP ON ERROR^
 40799	056165	312 00 0 00 070254 		CAME	0,[-1]			;PASS IF C(AC)=-1,,-1
 40800						STOP^
 40801	056166	254 04 0 00 056167 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40802	056167	324 00 0 00 056170 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40803									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 96-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40804									;IN THE SUBTEST) TO LOOP ON ERROR^
 40805	056170	312 01 0 00 070764 		CAME	1,[754321,,76543]	;PASS IF C(E) UNCHANGED
 40806						STOP^
 40807	056171	254 04 0 00 056172 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40808	056172	324 00 0 00 056173 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40809									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40810									;IN THE SUBTEST) TO LOOP ON ERROR^
 40811
 40812					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 97
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40813					;THIS TEST VERIFIES THAT TSOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40814					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40815					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40816					;AC BITS ARE THEN CHANGED TO ONES.
 40817					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40818					;HENCE, TSOE SHOULD SKIP AND THE RESULT IN AC
 40819					;SHOULD BE -1,,-1.  C(E) IS NOT AFFECTED
 40820
 40821	056173	200 17 0 00 070745 	C75600:	MOVE	17,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40822	056174	200 00 0 00 070754 		MOVE	0,[76543,,654321]	;PRELOAD E WITH 076543,,654321
 40823	056175	673 17 0 00 000000 		TSOE	17,0			;*TSOE SHOULD SKIP AND
 40824										;PLACE -1,,-1 INTO THE AC
 40825						STOP^
 40826	056176	254 04 0 00 056177 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40827	056177	324 00 0 00 056200 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40828									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40829									;IN THE SUBTEST) TO LOOP ON ERROR^
 40830	056200	312 17 0 00 070254 		CAME	17,[-1]			;PASS IF C(AC)=-1,,-1
 40831						STOP^
 40832	056201	254 04 0 00 056202 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40833	056202	324 00 0 00 056203 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40835									;IN THE SUBTEST) TO LOOP ON ERROR^
 40836	056203	312 00 0 00 070754 		CAME	0,[76543,,654321]	;PASS IF C(E) UNCHANGED
 40837						STOP^
 40838	056204	254 04 0 00 056205 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40839	056205	324 00 0 00 056206 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40840									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40841									;IN THE SUBTEST) TO LOOP ON ERROR^
 40842
 40843					;**********
 40844
 40845					;THIS TEST VERIFIES THAT TSOE SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40846					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40847					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 40848					;AC BITS ARE THEN  CHANGED TO ONES.
 40849					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,657321
 40850					;HENCE, TSOE SHOULD NOT SKIP AND THE RESULT IN THE AC
 40851					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED.
 40852
 40853	056206	200 16 0 00 070745 	C75610:	MOVE	16,[123456,,701234]	;PRELOAD AC WITH 123456,701234
 40854	056207	200 17 0 00 070766 		MOVE	17,[76543,,657321]	;PRELOAD E WITH 076543,,657321
 40855	056210	673 16 0 00 000017 		TSOE	16,17			;*TSOE SHOULD NOT SKIP AND
 40856										;*TSOE SHOULD NOT SKIP AND
 40857										;PLACE -1,,-1 INTO THE AC
 40858	056211	334 00 0 00 000000 		SKIPA				;PASS IF SKIP
 40859						STOP^
 40860	056212	254 04 0 00 056213 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40861	056213	324 00 0 00 056214 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40862									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40863									;IN THE SUBTEST) TO LOOP ON ERROR^
 40864	056214	312 16 0 00 070254 		CAME	16,[-1]			;PASS IF C(AC)=-1,,-1
 40865						STOP^
 40866	056215	254 04 0 00 056216 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40867	056216	324 00 0 00 056217 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 97-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40868									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40869									;IN THE SUBTEST) TO LOOP ON ERROR^
 40870	056217	312 17 0 00 070766 		CAME	17,[76543,,657321]	;PASS IF C(E) UNCHANGED
 40871						STOP^
 40872	056220	254 04 0 00 056221 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40873	056221	324 00 0 00 056222 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40874									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40875									;IN THE SUBTEST) TO LOOP ON ERROR^
 40876
 40877					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 98
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40878					;THIS TEST VERIFIES THAT TDOA PLACES ONES INTO ALL BITS OF THE AC WHICH
 40879					;CORRRESPOND TO 1'S IN C(E) AND ALWAYS
 40880					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 40881					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)= 654321,,076543
 40882					;HENCE, TDOA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40883
 40884	056222	200 15 0 00 070745 	C75700:	MOVE	15,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40885	056223	200 16 0 00 070763 		MOVE	16,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 40886	056224	674 15 0 00 000016 		TDOA	15,16			;*TDOA SHOULD SKIP AND
 40887										;PLACE -1,,-1 INTO THE AC
 40888						STOP^
 40889	056225	254 04 0 00 056226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40890	056226	324 00 0 00 056227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40891									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40892									;IN THE SUBTEST) TO LOOP ON ERROR^
 40893	056227	312 15 0 00 070254 		CAME	15,[-1]			;PASS IF C(AC)=-1,,-1
 40894						STOP^
 40895	056230	254 04 0 00 056231 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40896	056231	324 00 0 00 056232 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40897									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40898									;IN THE SUBTEST) TO LOOP ON ERROR^
 40899	056232	312 16 0 00 070763 		CAME	16,[654321,,076543]	;PASS IF C(E) UNCHANGED
 40900						STOP^
 40901	056233	254 04 0 00 056234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40902	056234	324 00 0 00 056235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40903									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40904									;IN THE SUBTEST) TO LOOP ON ERROR^
 40905
 40906					;**********
 40907
 40908					;THIS TEST VERIFIES THAT TDOA PLACE ONES ALL BIT OF THE AC WHICH
 40909					;CORRESPOND TO 1'S IN C(E) AND ALWAYS
 40910					;SKIPS THE NEXT INSTRUCTION C(E) IS NOT AFFECTED
 40911					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=252525,,707070
 40912					;HENCE, TDOA SHOULD ALWAYS SKIP AND C(AC) SHOULD BE 373577,,707274
 40913
 40914	056235	200 14 0 00 070745 	C75710:	MOVE	14,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40915	056236	200 15 0 00 070761 		MOVE	15,[252525,,707070]	;PRELOAD E WITH 252525,,707070
 40916	056237	674 14 0 00 000015 		TDOA	14,15			;*TDOA SHOULD SKIP AND
 40917										;PLACE 373577,707274 ONTO THE AC
 40918						STOP^
 40919	056240	254 04 0 00 056241 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40920	056241	324 00 0 00 056242 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40921									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40922									;IN THE SUBTEST) TO LOOP ON ERROR^
 40923	056242	312 14 0 00 071011 		CAME	14,[373577,,707274]	;PASS IF C(AC)=373577,,707274
 40924						STOP^
 40925	056243	254 04 0 00 056244 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40926	056244	324 00 0 00 056245 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40927									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40928									;IN THE SUBTEST) TO LOOP ON ERROR^
 40929	056245	312 15 0 00 070761 		CAME	15,[252525,,707070]	;PASS IF C(E) UNCHANGED
 40930						STOP^
 40931	056246	254 04 0 00 056247 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40932	056247	324 00 0 00 056250 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 98-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40933									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40934									;IN THE SUBTEST) TO LOOP ON ERROR^
 40935
 40936					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 99
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40937					;THIS TEST VERIFIES THAT TSOA PLACE ONES INTO ALL BITS OF THE AC WHICH
 40938					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40939					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40940					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 40941					;HENCE, TSOA SHOULD SLAWAYS SKIP AND C(AC) SHOULD BE -1,,-1
 40942
 40943	056250	200 13 0 00 070745 	C76000:	MOVE	13,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40944	056251	200 14 0 00 071012 		MOVE	14,[176543,,654321]	;PRELOAD E WITH 076543,,654321
 40945	056252	675 13 0 00 000014 		TSOA	13,14			;*TSOA SHOULD SKIP AND
 40946										;PLACE -1,,-1 ONTO THE AC
 40947						STOP^
 40948	056253	254 04 0 00 056254 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40949	056254	324 00 0 00 056255 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40950									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40951									;IN THE SUBTEST) TO LOOP ON ERROR^
 40952	056255	312 13 0 00 070254 		CAME	13,[-1]			;PASS IF C(AC)=-1,,-1
 40953						STOP^
 40954	056256	254 04 0 00 056257 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40955	056257	324 00 0 00 056260 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40956									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40957									;IN THE SUBTEST) TO LOOP ON ERROR^
 40958	056260	312 14 0 00 071012 		CAME	14,[176543,,654321]	;PASS IF C(E) UNCHANGED
 40959						STOP^
 40960	056261	254 04 0 00 056262 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40961	056262	324 00 0 00 056263 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40962									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40963									;IN THE SUBTEST) TO LOOP ON ERROR^
 40964
 40965					;**********
 40966
 40967					;THIS TEST VERIFIES THAT TSOA PLACES ONES INTO ALL BITS OF THE AC WHICH
 40968					;CORRESPOND TO 1'S IN C(E) WITH BOTH HALVES SWAPPED AND ALWAYS
 40969					;SKIPS THE NEXT INSTRUCTION.  C(E) IS NOT AFFECTED
 40970					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=701234,,123456
 40971					;HENCE, TSOA SHOULD SLWAYS SKIP AND C(AC) SHOULD BE 123456,,701234
 40972
 40973	056263	200 12 0 00 070745 	C76010:	MOVE	12,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 40974	056264	200 13 0 00 070771 		MOVE	13,[701234,,123456]	;PRELOAD E WITH 701234,123456
 40975	056265	675 12 0 00 000013 		TSOA	12,13			;*TSOA SHOULD SKIP AND
 40976										;PLACE 123456,,701234 INTO THE AC
 40977						STOP^
 40978	056266	254 04 0 00 056267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40979	056267	324 00 0 00 056270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40980									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40981									;IN THE SUBTEST) TO LOOP ON ERROR^
 40982	056270	312 12 0 00 070745 		CAME	12,[123456,,701234]	;PASS IF C(AC)=123456,,701234
 40983						STOP^
 40984	056271	254 04 0 00 056272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40985	056272	324 00 0 00 056273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 40986									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40987									;IN THE SUBTEST) TO LOOP ON ERROR^
 40988	056273	312 13 0 00 070771 		CAME	13,[701234,,123456]	;PASS IF C(E) UNCHANGED
 40989						STOP^
 40990	056274	254 04 0 00 056275 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 40991	056275	324 00 0 00 056276 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 99-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40992									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 40993									;IN THE SUBTEST) TO LOOP ON ERROR^
 40994
 40995					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 100
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 40996					;THIS TEST VERIFIES THAT TDON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 40997					;IF AND ONLY IF ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 40998					;C(E) ARE ZERO.  THESE MASKED
 40999					;AC BITS ARE THEN CHANGED TO ONES
 41000					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076547
 41001					;HENCE, TDON SHOULD SKIP AND THE RESULT IN AC
 41002					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 41003
 41004	056276	200 11 0 00 070745 	C76100:	MOVE	11,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 41005	056277	200 12 0 00 070772 		MOVE	12,[654321,,076547]	;PRELOAD E WITH 654321,,076547
 41006	056300	676 11 0 00 000012 		TDON	11,12			;*TDON SHOULD SKIP AND
 41007										;PLACE -1,,-1 INTO THE AC
 41008						STOP^
 41009	056301	254 04 0 00 056302 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41010	056302	324 00 0 00 056303 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41011									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41012									;IN THE SUBTEST) TO LOOP ON ERROR^
 41013	056303	312 11 0 00 070254 		CAME	11,[-1]			;PASS IF C(AC)=-1,,-1
 41014						STOP^
 41015	056304	254 04 0 00 056305 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41016	056305	324 00 0 00 056306 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41017									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41018									;IN THE SUBTEST) TO LOOP ON ERROR^
 41019	056306	312 12 0 00 070772 		CAME	12,[654321,,076547]	;PASS IF C(E) UNCHANGED
 41020						STOP^
 41021	056307	254 04 0 00 056310 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41022	056310	324 00 0 00 056311 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41023									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41024									;IN THE SUBTEST) TO LOOP ON ERROR^
 41025
 41026					;**********
 41027
 41028					;THIS TEST VERIFIES THAT TDON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 41029					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 41030					;C(E) ARE ZERO.  THESE MASKED
 41031					;AC BITS ARE THEN CHANGED TO ONES.
 41032					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=654321,,076543
 41033					;THENC, TDON SHOULD NOT SKIP AND THE RESULT IN TH AC
 41034					;SHOULD BE -1,,-1 C(E) IS NOT AFFECTED
 41035
 41036	056311	200 10 0 00 070745 	C76110:	MOVE	10,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 41037	056312	200 11 0 00 070763 		MOVE	11,[654321,,076543]	;PRELOAD E WITH 654321,,076543
 41038	056313	676 10 0 00 000011 		TDON	10,11			;*TDON SHOULD NOT SKIP AND
 41039										;PLACE -1,,-1 INTO THE AC
 41040	056314	334 00 0 00 000000 		SKIPA				;PASS IF TDON DOES NOT SKIP
 41041						STOP	^
 41042	056315	254 04 0 00 056316 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41043	056316	324 00 0 00 056317 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41044									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41045									;IN THE SUBTEST) TO LOOP ON ERROR^
 41046	056317	312 10 0 00 070254 		CAME	10,[-1]			;PASS IF C(AC)=-1,,-1
 41047						STOP^
 41048	056320	254 04 0 00 056321 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41049	056321	324 00 0 00 056322 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41050									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 100-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 41051									;IN THE SUBTEST) TO LOOP ON ERROR^
 41052	056322	312 11 0 00 070763 		CAME	11,[654321,,076543]	;PASS IF C(E) UNCHANGED
 41053						STOP^
 41054	056323	254 04 0 00 056324 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41055	056324	324 00 0 00 056325 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41056									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41057									;IN THE SUBTEST) TO LOOP ON ERROR^
 41058
 41059					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 101
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 41060					;THIS TEST VERIFIES THAT TSON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 41061					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 41062					;C(E) WITH BOTH HALVE SWAPPED ARE ZERO.  THESE MASKED
 41063					;AC BITS ARE THEN CHANGED TO ONES
 41064					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=077543,,654321
 41065					;HENCE, TSON SHOULD SKIP AND THE RESULT IN AC
 41066					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 41067
 41068	056325	200 07 0 00 070745 	C76200:	MOVE	7,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 41069	056326	200 10 0 00 070774 		MOVE	10,[77543,,654321]	;PRELOAD E WITH 077543,,654321]
 41070	056327	677 07 0 00 000010 		TSON	7,10			;*TSON HOULD SKIP AND
 41071										;PLACE -1,,-1 INTO THE AC
 41072						STOP^
 41073	056330	254 04 0 00 056331 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41074	056331	324 00 0 00 056332 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41075									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41076									;IN THE SUBTEST) TO LOOP ON ERROR^
 41077	056332	312 07 0 00 070254 		CAME	7,[-1]			;PASS IF C(AC)=-1,,-1
 41078						STOP^
 41079	056333	254 04 0 00 056334 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41080	056334	324 00 0 00 056335 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41081									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41082									;IN THE SUBTEST) TO LOOP ON ERROR^
 41083	056335	312 10 0 00 070774 		CAME	10,[77543,,654321]	;PASS IF C(E) UNCHANGED
 41084						STOP^
 41085	056336	254 04 0 00 056337 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41086	056337	324 00 0 00 056340 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41087									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41088									;IN THE SUBTEST) TO LOOP ON ERROR^
 41089
 41090					;**********
 41091
 41092					;THIS TEST VERIFIES THAT TSON SKIPS THE NEXT SEQUENTIAL INSTRUCTION
 41093					;IF AND ONLY IF NOT ALL BITS IN THE AC CORRESPONDING TO 1'S IN
 41094					;C(E) WITH BOTH HALVES SWAPPED ARE ZERO.  THESE MASKED
 41095					;AC BITS ARE THEN CHANGED TO ONES.
 41096					;IN THIS CASE, C(AC)=123456,,701234 AND C(E)=076543,,654321
 41097					;HENCE, TSON SHOULD NOT SKIP AND THE RESULT IN AC
 41098					;SHOULD BE -1,,-1  C(E) IS NOT AFFECTED
 41099
 41100	056340	200 06 0 00 070745 	C76210:	MOVE	6,[123456,,701234]	;PRELOAD AC WITH 123456,,701234
 41101	056341	200 07 0 00 070754 		MOVE	7,[76543,,654321]	;PRELOAD E WITH 076543MM654321
 41102	056342	677 06 0 00 000007 		TSON	6,7			;*TSON SHOULD NOT SKIP AND
 41103										;PLACE -1,,-1 INTO THE AC
 41104	056343	334 00 0 00 000000 		SKIPA				;PASS IF TSON DOES NOT SKIP
 41105						STOP^
 41106	056344	254 04 0 00 056345 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41107	056345	324 00 0 00 056346 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41108									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41109									;IN THE SUBTEST) TO LOOP ON ERROR^
 41110	056346	312 06 0 00 070254 		CAME	6,[-1]			;PASS IF C(AC)-=1,,-1
 41111						STOP^
 41112	056347	254 04 0 00 056350 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41113	056350	324 00 0 00 056351 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41114									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 101-1
DFKAA6	MAC	13-Jan-89 10:22		TEST OF MSCL LOGICAL TEST INSTRUCTIONS

 41115									;IN THE SUBTEST) TO LOOP ON ERROR^
 41116	056351	312 07 0 00 070754 		CAME	7,[76543,,654321]	;PASS IF C(E) UNCHANGED
 41117						STOP^
 41118	056352	254 04 0 00 056353 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41119	056353	324 00 0 00 056354 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41120									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41121									;IN THE SUBTEST) TO LOOP ON ERROR^
 41122
 41123					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSH INSTRUCTION

 41124					SUBTTL	TEST OF PUSH INSTRUCTION
 41125
 41126					;**********
 41127
 41128					;THIS TEST VERIFIES THAT PUSH DECODES CORRECTLY.
 41129					;IF PUSH DECODES AS PUSHJ, THIS TEST FAILS.
 41130
 41131	056354	400 02 0 00 000000 	C27200:	SETZ	2,		;CLEAR AC
 41132	056355	261 02 0 00 056357 		PUSH	2,.+2		;*PUSH SHOULD NOT JUMP
 41133	056356	334 00 0 00 000000 		SKIPA			;PASS IF PUSH DID NOT JUMP
 41134						STOP^
 41135	056357	254 04 0 00 056360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41136	056360	324 00 0 00 056361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41137									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41138									;IN THE SUBTEST) TO LOOP ON ERROR^
 41139
 41140					;**********
 41141
 41142					;THIS TEST VERIFIES THAT PUSH DOES NOT MODIFY C(E).
 41143					;CLEAR E AND AC; THEN, EXECUTE PUSH.
 41144					;CHECK E FOR ORIGINAL CONTENTS ,0.
 41145					;PASS IF C(E)=0.
 41146
 41147	056361	403 00 0 00 000002 	C27300:	SETZB	2		;CLEAR AC,E
 41148	056362	261 02 0 00 000000 		PUSH	2,		;*PUSH SHOULD NOT ALTER C(E)
 41149	056363	332 00 0 00 000000 		SKIPE			;PASS IF C(E)=0,,0
 41150						STOP^
 41151	056364	254 04 0 00 056365 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41152	056365	324 00 0 00 056366 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41153									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41154									;IN THE SUBTEST) TO LOOP ON ERROR^
 41155
 41156					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSH INSTRUCTION

 41157					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC.
 41158					;FIRST THE AC IS CLEARED; THEN PUSH IS EXECUTED.
 41159					;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 41160
 41161	056366	400 02 0 00 000000 	C27400:	SETZ	2,		;CLEAR AC
 41162	056367	261 02 0 00 056370 		PUSH	2,.+1		;*PUSH SHOULD ADD 1,,1 TO C(AC)
 41163	056370	312 02 0 00 070251 		CAME	2,[XWD 1,1]	;PASS IF C(AC)=1,,1
 41164						STOP^
 41165	056371	254 04 0 00 056372 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41166	056372	324 00 0 00 056373 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41167									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41168									;IN THE SUBTEST) TO LOOP ON ERROR^
 41169
 41170					;**********
 41171
 41172					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
 41173					;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
 41174					;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR THE INITIAL VALUE, 0.
 41175					;IF C(AC0)=0, THIS TEST PASSES
 41176
 41177	056373	403 00 0 00 000002 	C27500:	SETZB	2		;CLEAR AC AND AC0
 41178	056374	261 02 0 00 071013 		PUSH	2,[16541320]	;*PUSH SHOULD NOT MODIFY C(AC0)
 41179	056375	332 00 0 00 000000 		SKIPE			;PASS IF C(AC0)=0
 41180						STOP^
 41181	056376	254 04 0 00 056377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41182	056377	324 00 0 00 056400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41183									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41184									;IN THE SUBTEST) TO LOOP ON ERROR^
 41185
 41186					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSH INSTRUCTION

 41187					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC BEFORE MODIFYING C(C(AC-RIGHT)).
 41188					;FIRST, THE AC AND AC0 ARE ZEROED; THEN PUSH IS EXECUTED.
 41189					;C(C(AC-RIGHT)) [BEFORE AC UPDATING] (AC0) IS CHECKED FOR 
 41190					;IF C(AC0)IS NOT EQUAL TO E, THIS TEST PASSES
 41191
 41192	056400	403 01 0 00 000002 	C27600:	SETZB	1,2		;CLEAR AC AND AC0
 41193	056401	261 02 0 00 056402 		PUSH	2,.+1		;*PUSH SHOULD NOT MODIFY C(AC0)
 41194	056402	306 00 0 00 056402 		CAIN	.		;FAIL IF C(AC0)=E
 41195						STOP^
 41196	056403	254 04 0 00 056404 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41197	056404	324 00 0 00 056405 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41198									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41199									;IN THE SUBTEST) TO LOOP ON ERROR^
 41200
 41201					;**********
 41202
 41203					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
 41204					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC AND THE LOCATION SPECIFIED
 41205					;BY UPDATING C(AC-RIGHT) ARE CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
 41206					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
 41207					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.
 41208
 41209	056405	403 01 0 00 000002 	C27700:	SETZB	1,2		;CLEAR AC, C(AC-RIGHT)
 41210	056406	261 02 0 00 070254 		PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC1
 41211	056407	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(1)=-1,,-1
 41212						STOP^
 41213	056410	254 04 0 00 056411 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41214	056411	324 00 0 00 056412 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41215									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41216									;IN THE SUBTEST) TO LOOP ON ERROR^
 41217
 41218					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSH INSTRUCTION

 41219					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
 41220					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE, AC
 41221					;IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=0.
 41222					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR 0, THE
 41223					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=0, THIS TEST PASSES.
 41224
 41225	056412	402 00 0 00 000002 	C30000:	SETZM	2		;CLEAR AC
 41226	056413	261 02 0 00 070253 		PUSH	2,[0]		;*PUSH SHOULD PLACE 0 INTO AC1
 41227	056414	332 00 0 00 000001 		SKIPE	1		;PASS IF C(1)=0
 41228						STOP^
 41229	056415	254 04 0 00 056416 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41230	056416	324 00 0 00 056417 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41231									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41232									;IN THE SUBTEST) TO LOOP ON ERROR^
 41233
 41234					;**********
 41235
 41236					;THIS TEST VERIFIES THAT PUSH ADDS 1,,1 TO THE AC; THEN, MOVES C(E) INTO
 41237					;THE LOCATION SPECIFIED BY C(AC-RIGHT).  IN THIS CASE,
 41238					;AC IS PRELOADED WITH 0,,-1, AND THE LOCATION SPECIFIED
 41239					;BY UPDATING C(AC-RIGHT) IS CLEARED; THEN, PUSH IS EXECUTED WITH C(E)=-1,,-1.
 41240					;THE LOCATION SPECIFIED BY C(AC-RIGHT) IS THEN CHECKED FOR -1,,-1, THE
 41241					;ORIGINAL C(E).  IF C(C(AC-RIGHT))=-1,,-1, THIS TEST PASSES.
 41242
 41243	056417	201 02 0 00 777777 	C30100:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
 41244	056420	400 00 0 00 000000 		SETZ			;CLEAR AC, C(AC-RIGHT)
 41245	056421	261 02 0 00 070254 		PUSH	2,[-1]		;*PUSH SHOULD PLACE -1,,-1 INTO AC0
 41246	056422	312 00 0 00 070254 		CAME	[-1]		;PASS IF C(0)=-1,,-1
 41247						STOP^
 41248	056423	254 04 0 00 056424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41249	056424	324 00 0 00 056425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41250									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41251									;IN THE SUBTEST) TO LOOP ON ERROR^
 41252
 41253					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSH INSTRUCTION

 41254					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON PUSH.
 41255					;THE AC IS PRELOADED WITH 0,,-1; THEN PUSH IS EXECUTED. PUSH SHOULD ADD ONE
 41256					;TO BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41257					;CARRY WAS GENERATED, THIS TEST PASSES
 41258
 41259	056425	201 02 0 00 777777 	C30101:	MOVEI	2,-1		;PRELOAD AC WITH 0,, -1
 41260	056426	261 02 0 00 000000 		PUSH	2,0		;*PUSH SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41261	056427	312 02 0 00 070307 		CAME	2,[1,,0]	;PASS IF C(AC)=1,,0 (NO CARRY WAS GENERATED)
 41262						STOP^
 41263	056430	254 04 0 00 056431 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41264	056431	324 00 0 00 056432 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41265									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41266									;IN THE SUBTEST) TO LOOP ON ERROR^
 41267
 41268					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSHJ INSTRUCTION

 41269					SUBTTL	TEST OF PUSHJ INSTRUCTION
 41270
 41271					;**********
 41272
 41273					;THIS TEST VERIFIES THAT PUSHJ TRANSFERS CONTROL TO THE LOCATION ADDRESSED BY E.
 41274					;IF PUSHJ DOES NOT JUMP, THIS TEST FAILS
 41275
 41276	056432				C30200:	SFLAG	CRY0		^;SETS CRY0 FLAG
 41277
 41278	056432	205 01 0 00 200000 		MOVSI	1,CRY0
 41279	056433	255 17 0 00 056434 		JFCL	17,.+1	;RESET ALL FLAGS
 41280	056434	254 02 0 01 056435 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41281	056435	400 00 0 00 000000 		SETZ			;CLEAR AC
 41282	056436	260 00 0 00 056440 		PUSHJ	.+2		;*PUSHJ SHOULD JUMP TO LOCATION E
 41283						STOP^
 41284	056437	254 04 0 00 056440 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41285	056440	324 00 0 00 056441 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41286									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41287									;IN THE SUBTEST) TO LOOP ON ERROR^
 41288
 41289					;**********
 41290
 41291					;THIS TEST VERIFIES THAT PUSHJ DOES NOT MODIFY C(PC) WHERE PC IS ONE GREATER
 41292					;THAN THE LOCATION OF THE PUSHJ INSTRUCTION.
 41293					;IF PUSHJ MODIFIES C(PC), THIS TEST FAILS
 41294
 41295	056441				C30300:	SFLAG	CRY0		^;SET CRY0
 41296
 41297	056441	205 01 0 00 200000 		MOVSI	1,CRY0
 41298	056442	255 17 0 00 056443 		JFCL	17,.+1	;RESET ALL FLAGS
 41299	056443	254 02 0 01 056444 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41300	056444	403 01 0 00 056446 		SETZB	1,.+2		;CLEAR C(AC-RIGHT) AND C(PC)
 41301	056445	260 00 0 00 056450 		PUSHJ	.+3		;*PUSHJ SHOULD NOT MODIFY C(PC)
 41302	056446	000000	000000			0			;THIS LOCATION SHOULD NOT BE MODIFIED BY PUSHJ
 41303	056447	310 00 0 00 000000 		CAM			;PUSHJ SHOULD JUMP OVER THIS LOCATION
 41304	056450	332 00 0 00 056446 		SKIPE	.-2		;PASS IF PUSHJ DID NOT MODIFY C(PC)
 41305						STOP^
 41306	056451	254 04 0 00 056452 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41307	056452	324 00 0 00 056453 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41308									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41309									;IN THE SUBTEST) TO LOOP ON ERROR^
 41310
 41311					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSHJ INSTRUCTION

 41312					;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN E
 41313					;IF PUSHJ STORED IN E, THIS TEST FAILS
 41314
 41315	056453				C30400:	SFLAG	CRY0		^;SET CRY0
 41316
 41317	056453	205 01 0 00 200000 		MOVSI	1,CRY0
 41318	056454	255 17 0 00 056455 		JFCL	17,.+1	;RESET ALL FLAGS
 41319	056455	254 02 0 01 056456 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41320	056456	403 00 0 00 000001 		SETZB	1		;CLEAR AC AND C(AC-RIGHT
 41321	056457	260 00 0 00 056460 		PUSHJ	.+1		;*PUSHJ SHOULD NOT STORE IN E
 41322	056460	200 02 0 00 056460 		MOVE	2,.		;SAVE C(E)
 41323	056461	312 02 0 00 056460 		CAME	2,.-1		;FAIL IF PUSHJ STORED IN E
 41324						STOP^
 41325	056462	254 04 0 00 056463 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41326	056463	324 00 0 00 056464 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41327									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41328									;IN THE SUBTEST) TO LOOP ON ERROR^
 41329
 41330					;**********
 41331
 41332					;THIS TEST VERIFIES THAT PUSHJ DOES NOT STORE IN LOC 0
 41333					;PUSHJ SHOULD STORE PC IN C(AC-RIGHT) - LOCATION 2.
 41334					;IF PUSHJ STORES IN LOCATION 0, THIS TEST FAILS
 41335
 41336	056464	201 02 0 00 000001 	C30500:	MOVEI	2,1		;PRELOAD AC WITH 0,,1
 41337	056465	400 00 0 00 000000 		SETZ	0		;CLEAR 0
 41338	056466	260 02 0 00 056467 		PUSHJ	2,.+1		;*PUSHJ SHOULD NOT STORE IN LOCATION 0
 41339	056467	332 00 0 00 000000 		SKIPE			;FAIL IF PUSHJ STORED IN LOCATION 0
 41340						STOP^
 41341	056470	254 04 0 00 056471 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41342	056471	324 00 0 00 056472 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41343									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41344									;IN THE SUBTEST) TO LOOP ON ERROR^
 41345
 41346					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSHJ INSTRUCTION

 41347					;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN THE LOCATION SPECIFIED
 41348					;BY C(AC-RIGHT) AFTER INCREMENTING AC.
 41349					;IN THIS TEST, AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
 41350					;C(C(AC-RIGHT))IS THEN COMPARED TO ZERO.  IF C(C(AC-RIGHT)) IS NON-ZERO,
 41351					;A PC WAS STORED AND THIS TEST PASSES.
 41352
 41353	056472	403 00 0 00 000001 	C30600:	SETZB	1		;CLEAR AC, C(AC-RIGHT)
 41354	056473	260 00 0 00 056475 		PUSHJ	.+2		;*PUSHJ SHOULD STORE PC IN RIGHT HALF OF C(AC-RIGHT)
 41355	056474	254 04 0 00 056474 		HALT	.		;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
 41356	056475	405 01 0 00 777777 		ANDI	1,-1		;SAVE C(C(AC-RIGHT))
 41357	056476	306 01 0 00 056475 		CAIN	1,.-1		;FAIL IF PC WAS NOT STORED IN C(AC-RIGHT)
 41358						STOP^
 41359	056477	254 04 0 00 056500 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41360	056500	324 00 0 00 056501 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41361									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41362									;IN THE SUBTEST) TO LOOP ON ERROR^
 41363
 41364					;**********
 41365
 41366					;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
 41367					;THE AC IS CLEARED AND PUSHJ IS EXECUTED
 41368					;AC IS CHECKED FOR 1,,1 IF C(AC)=1,,1, THIS TEST PASSES
 41369
 41370	056501	400 00 0 00 000000 	C31000:	SETZ			;CLEAR AC
 41371	056502	260 00 0 00 056503 		PUSHJ	.+1		;*PUSHJ SHOULD PLACE 1,,1 INTO THE AC
 41372	056503	312 00 0 00 070251 		CAME	[1,,1]		;PASS IF C(AC)=1,,1
 41373						STOP^
 41374	056504	254 04 0 00 056505 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41375	056505	324 00 0 00 056506 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41376									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41377									;IN THE SUBTEST) TO LOOP ON ERROR^
 41378
 41379					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSHJ INSTRUCTION

 41380					;THIS TEST VERIFIES THAT PUSHJ STORES THE FLAGS IN LEFT HALF OF C(AC-RIGHT)
 41381					;FIRST, CRY0 IS SET AND AC AND C(AC-RIGHT) ARE CLEARED; THEN, PUSHJ IS EXECUTED.
 41382					;C(C(AC-RIGHT)) IS THEN CHECKED FOR CRY0.  IF CRY0 IS SET, THIS TEST PASSES.
 41383
 41384	056506				C31100:	SFLAG	CRY0		^;SET CRY0
 41385
 41386	056506	205 01 0 00 200000 		MOVSI	1,CRY0
 41387	056507	255 17 0 00 056510 		JFCL	17,.+1	;RESET ALL FLAGS
 41388	056510	254 02 0 01 056511 		JRST	2,.+1(1)		;SET CRY0 FLAG
 41389	056511	403 00 0 00 000001 		SETZB	1		;CLEAR AC AND C(AC-RIGHT)
 41390	056512	260 00 0 00 056513 		PUSHJ	.+1		;*PUSHJ SHOULD STORE FLAGS IN LEFT HALF OF C(AC-RIGHT)
 41391	056513	607 01 0 00 200000 		TLNN	1,CRY0		;PASS IF CRY0 STORED CORRECTLY
 41392						STOP^
 41393	056514	254 04 0 00 056515 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41394	056515	324 00 0 00 056516 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41395									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41396									;IN THE SUBTEST) TO LOOP ON ERROR^
 41397
 41398					;**********
 41399
 41400					;THIS TEST VERIFIES THAT PUSHJ ADDS 1,,1 TO THE AC
 41401					;THE AC IS PRELOADED WITH 0,,1 AND PUSHJ IS EXECUTED
 41402					;AC IS CHECKED FOR 1,,2 IF C(AC)=1,,2, THIS TEST PASSES
 41403
 41404	056516	201 01 0 00 000001 	C31400:	MOVEI	1,1		;PRELOAD AC WITH 0,,1
 41405	056517	260 01 0 00 056521 		PUSHJ	1,.+2		;*PUSHJ SHOULD PLACE 1,,2 INTO THE AC
 41406	056520	254 04 0 00 000000 		HALT			;PUSHJ SHOULD JUMP OVER THIS INSTRUCTION
 41407	056521	312 01 0 00 070634 		CAME	1,[XWD 1,2]	;PASS IF AC WAS INCREMENTED CORRECTLY
 41408						STOP^
 41409	056522	254 04 0 00 056523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41410	056523	324 00 0 00 056524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41411									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41412									;IN THE SUBTEST) TO LOOP ON ERROR^
 41413
 41414					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSHJ INSTRUCTION

 41415					;THIS TEST VERIFIES THAT PUSHJ STORES THE PC IN RIGHT HALF OF C(AC-RIGHT)
 41416					;THIS TEST PASSES IF THE PC WAS STORED CORRECTLY.
 41417
 41418	056524	201 01 0 00 000001 	C31500:	MOVEI	1,1		;PLACE 0,,1 INTO AC
 41419	056525	260 01 0 00 056527 		PUSHJ	1,.+2		;*PUSHJ SHOULD STORE .+1 INTO RIGHT HALF OF C(AC-RIGHT)
 41420	056526	254 04 0 00 000000 		HALT			;PUSHJ SHOULD JUMP OVER THIS PC
 41421	056527	405 02 0 00 777777 		ANDI	2,-1		;SAVE RIGHT HALF OF C(AC-RIGHT)
 41422	056530	302 02 0 00 056526 		CAIE	2,.-2		;PASS IF PC STORED CORRECTLY
 41423						STOP^
 41424	056531	254 04 0 00 056532 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41425	056532	324 00 0 00 056533 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41426									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41427									;IN THE SUBTEST) TO LOOP ON ERROR^
 41428
 41429					;**********
 41430
 41431					;THIS TEST VERIFIES THAT PUSHJ ALWAYS RESETS BIS.
 41432					;FIRST BIS IS SET; THEN PUSHJ IS EXECUTED.  THE FLAGS ARE
 41433					;THEN SAVED AND CHECKED.  IF BIS WAS RESET VIA PUSHJ, THIS TEST PASSES.
 41434
 41435	056533				C31501:	SFLAG	BIS		^;SET BIS
 41436
 41437	056533	205 01 0 00 020000 		MOVSI	1,BIS
 41438	056534	255 17 0 00 056535 		JFCL	17,.+1	;RESET ALL FLAGS
 41439	056535	254 02 0 01 056536 		JRST	2,.+1(1)		;SET BIS FLAG
 41440	056536	400 00 0 00 000000 		SETZ			;CLEAR AC
 41441	056537	260 00 0 00 056540 		PUSHJ	.+1		;*PUSHJ SHOULD RESET BIS
 41442	056540	265 00 0 00 056541 		JSP	.+1		;SAVE FLAGS
 41443	056541	603 00 0 00 020000 		TLNE	BIS		;PASS IF BIS FLAG IS RESET
 41444						STOP^
 41445	056542	254 04 0 00 056543 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41446	056543	324 00 0 00 056544 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41447									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41448									;IN THE SUBTEST) TO LOOP ON ERROR^
 41449
 41450					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 11
DFKAA7	MAC	13-Jan-89 10:22		TEST OF PUSHJ INSTRUCTION

 41451					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON PUSHJ.
 41452					;THE AC IS PRELOADED WITH 0,,-1; THEN PUSHJ IS EXECUTED. PUSHJ SHOULD ADD ONE
 41453					;TO BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41454					;CARRY WAS GENERATED, THIS TEST PASSES
 41455
 41456	056544	201 02 0 00 777777 	C31502:	MOVEI	2,-1		;PRELOAD AC WITH 0,,-1
 41457	056545	260 02 0 00 056546 		PUSHJ	2,.+1		;*PUSHJ SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41458	056546	312 02 0 00 070307 		CAME	2,[1,,0]	;PASS IF C(AC)=1,,0 (NO CARRY WAS GENERATED)
 41459						STOP^
 41460	056547	254 04 0 00 056550 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41461	056550	324 00 0 00 056551 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41462									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41463									;IN THE SUBTEST) TO LOOP ON ERROR^
 41464
 41465					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA7	MAC	13-Jan-89 10:22		TEST OF POP INSTRUCTION

 41466					SUBTTL	TEST OF POP INSTRUCTION
 41467
 41468					;**********
 41469
 41470					;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
 41471					;THE AC IS PRELOADED WITH 1,,1; THEN, POP IS EXECUTED.
 41472					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 41473
 41474	056551	200 00 0 00 070251 	C31600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41475	056552	262 00 0 00 000001 		POP	1		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
 41476	056553	332 00 0 00 000000 		SKIPE			;PASS IF AC WAS DECREMENTED CORRECTLY
 41477						STOP^
 41478	056554	254 04 0 00 056555 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41479	056555	324 00 0 00 056556 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41480									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41481									;IN THE SUBTEST) TO LOOP ON ERROR^
 41482
 41483					;**********
 41484
 41485					;THIS TEST VERIFIES THAT POP SUBTRACTS 1,,1 FROM THE AC
 41486					;THE AC IS PRELOADED WITH 2,,2; THEN, POP IS EXECUTED.
 41487					;THE AC IS CHECKED FOR 1,,1.  IF C(AC)=1,,1, THIS TEST PASSES.
 41488
 41489	056556	200 00 0 00 070440 	C31700:	MOVE	[XWD 2,2]	;PRELOAD AC WITH E,,E WHERE E=2
 41490	056557	201 02 0 00 000005 		MOVEI	2,5		;PRELOAD 2 WITH 0,,5
 41491	056560	262 00 0 00 000002 		POP	2		;*POP SHOULD SUBTRACT 1,,1 FROM THE AC
 41492	056561	312 00 0 00 070251 		CAME	[1,,1]		;PASS IF AC WAS DECREMENTED CORRECTLY
 41493						STOP^
 41494	056562	254 04 0 00 056563 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41495	056563	324 00 0 00 056564 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41497									;IN THE SUBTEST) TO LOOP ON ERROR^
 41498
 41499					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA7	MAC	13-Jan-89 10:22		TEST OF POP INSTRUCTION

 41500					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E
 41501					;IN THIS CASE, AC=0 AND AC IS PRELOADED WITH 2,,2; E=2 AND IS PRELOADED WITH 0.
 41502					;POP IS THEN EXECUTED.  POP SHOULD PLACE 0 INTO E.  IF C(E)=0, THIS TEST PASSES.
 41503
 41504	056564	200 00 0 00 070440 	C32300:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41505	056565	402 00 0 00 000002 		SETZM	2		;CLEAR E AND C(AC-RIGHT)
 41506	056566	262 00 0 00 000002 		POP	2		;*POP SHOULD PLACE 0 INTO E
 41507	056567	332 00 0 00 000002 		SKIPE	2		;PASS IF C(E)=0
 41508						STOP^
 41509	056570	254 04 0 00 056571 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41510	056571	324 00 0 00 056572 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41511									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41512									;IN THE SUBTEST) TO LOOP ON ERROR^
 41513
 41514					;**********
 41515
 41516					;THIS TEST VERIFIES THAT POP DOES NOT MODIFY C(C(AC-RIGHT)-1).
 41517					;THIS TEST FAILS IF C(C(AC-RIGHT)-1) IS MODIFIED BY POP.
 41518
 41519	056572	200 00 0 00 070440 	C32400:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41520	056573	201 02 0 00 000017 		MOVEI	2,17		;PRELOAD 2 WITH 0,,17
 41521	056574	402 00 0 00 000001 		SETZM	1		;CLEAR C(C(AC-RIGHT)-1)
 41522	056575	262 00 0 00 000002 		POP	2		;*POP SHOULD NOT MODIFY C(C(AC-RIGHT)-1)
 41523	056576	332 00 0 00 000001 		SKIPE	1		;PASS IF C(C(AC-RIGHT)-1) WAS UNALTERED
 41524						STOP^
 41525	056577	254 04 0 00 056600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41526	056600	324 00 0 00 056601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41527									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41528									;IN THE SUBTEST) TO LOOP ON ERROR^
 41529
 41530					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA7	MAC	13-Jan-89 10:22		TEST OF POP INSTRUCTION

 41531					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.
 41532					;IN THIS CASE, AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,3.
 41533					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,3 [C(C(AC-RIGHT))] .
 41534					;IF C(E)=0,,3, THIS TEST PASSES.
 41535
 41536	056601	200 00 0 00 070440 	C32500:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41537	056602	201 02 0 00 000003 		MOVEI	2,3		;PRELOAD C(AC-RIGHT) WITH 0,,3
 41538	056603	402 00 0 00 000003 		SETZM	3		;CLEAR E
 41539	056604	262 00 0 00 000003 		POP	3		;*POP SHOULD PLACE 0,,3 INTO E
 41540	056605	302 03 0 00 000003 		CAIE	3,3		;PASS IF C(E)=0,,3
 41541						STOP^
 41542	056606	254 04 0 00 056607 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41543	056607	324 00 0 00 056610 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41544									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41545									;IN THE SUBTEST) TO LOOP ON ERROR^
 41546
 41547					;**********
 41548
 41549					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
 41550					;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH 0,,17.
 41551					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR 0,,17 [C(C(AC-RIGHT))] .
 41552					;IF C(E)=0,,17, THIS TEST PASSES.
 41553
 41554	056610	402 00 0 00 000002 	C32600:	SETZM	2		;CLEAR E
 41555	056611	200 00 0 00 070440 		MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41556	056612	201 02 0 00 000017 		MOVEI	2,17		;PRELOAD C(AC-RIGHT) WITH 0,,17
 41557	056613	262 00 0 00 000002 		POP	2		;*POP SHOULD PLACE 0,,17 INTO E
 41558	056614	302 02 0 00 000017 		CAIE	2,17		;PASS IF C(E)=0,,17
 41559						STOP^
 41560	056615	254 04 0 00 056616 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41561	056616	324 00 0 00 056617 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41562									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41563									;IN THE SUBTEST) TO LOOP ON ERROR^
 41564
 41565					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA7	MAC	13-Jan-89 10:22		TEST OF POP INSTRUCTION

 41566					;THIS TEST VERIFIES THAT POP STORES C(C(AC-RIGHT)) INTO E.  IN THIS CASE,
 41567					;AC IS PRELOADED WITH 2,,2 AND AC2 [C(AC-RIGHT)] IS PRELOADED WITH -1,,-1.
 41568					;E IS CLEARED AND POP IS EXECUTED.  E IS THEN CHECKED FOR -1,,-1 [C(C(AC-RIGHT))] .
 41569					;IF C(E)=0,,3, THIS TEST PASSES.
 41570
 41571	056617	200 00 0 00 070440 	C33100:	MOVE	[XWD 2,2]	;PRELOAD AC WITH 2,,2
 41572	056620	476 00 0 00 000002 		SETOM	2		;PRELOAD C(AC-RIGHT) WITH -1,,-1
 41573	056621	402 00 0 00 000003 		SETZM	3		;CLEAR E
 41574	056622	262 00 0 00 000003 		POP	3		;*POP SHOULD PLACE -1,,-1 INTO E
 41575	056623	312 03 0 00 070254 		CAME	3,[-1]		;PASS IF C(E)=-1,,-1
 41576						STOP^
 41577	056624	254 04 0 00 056625 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41578	056625	324 00 0 00 056626 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41579									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41580									;IN THE SUBTEST) TO LOOP ON ERROR^
 41581
 41582					;**********
 41583
 41584					;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC.
 41585					;IN THIS CASE, THE AC IS PRELOADED WITH 1,,17; E=1 AND E IS PRELOADED WITH 0;
 41586					;C(AC-RIGHT) IS PRELOADED WITH -1,,-1; AND POP IS EXECUTED.  POP SHOULD PLACE -1,,-1
 41587					;INTO E AND 0,,16 INTO AC.  IF AC AND E ARE UPDATED CORRECTLY, THIS TEST PASSES.
 41588
 41589	056626	200 00 0 00 071014 	C33300:	MOVE	[XWD 1,17]	;PRELOAD AC WITH 1,,17
 41590	056627	402 00 0 00 000001 		SETZM	1		;PRELOAD E WITH 0
 41591	056630	476 00 0 00 000017 		SETOM	17		;PRELOAD C(AC-RIGHT) WITH 1,,1
 41592	056631	262 00 0 00 000001 		POP	1		;*POP SHOULD PLACE -1,,-1 INTO E AND 0,,16 INTO AC
 41593	056632	312 01 0 00 070254 		CAME	1,[-1]		;PASS IF C(E)=-1,,-1
 41594						STOP^
 41595	056633	254 04 0 00 056634 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41596	056634	324 00 0 00 056635 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41597									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41598									;IN THE SUBTEST) TO LOOP ON ERROR^
 41599	056635	302 00 0 00 000016 	C33310:	CAIE	16		;PASS IF C(AC)=0,,16
 41600						STOP^
 41601	056636	254 04 0 00 056637 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41602	056637	324 00 0 00 056640 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41603									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41604									;IN THE SUBTEST) TO LOOP ON ERROR^
 41605
 41606					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA7	MAC	13-Jan-89 10:22		TEST OF POP INSTRUCTION

 41607					;THIS TEST VERIFIES THAT POP PLACES C(C(AC-RIGHT)) INTO E AND ADDS 1,,1 TO AC
 41608					;IN THIS CASE, THE AC IS PRELOADED WITH -1,,0; E=17 
 41609					;C(AC-RIGHT) IS PRELOADED WITH 0; AND POP IS EXECUTED.  POP SHOULD PLACE 0
 41610					;INTO E.  IF AC IS UPDATED CORRECTLY, THIS TEST PASSES.
 41611
 41612	056640	205 01 0 00 777777 	C33400:	MOVSI	1,-1		;PRELOAD AC WITH -1,,0
 41613	056641	400 00 0 00 000000 		SETZ			;CLEAR C(AC-RIGHT)
 41614	056642	262 01 0 00 000017 		POP	1,17		;*POP SHOULD PLACE 0 INTO E
 41615	056643	332 00 0 00 000017 		SKIPE	17		;PASS IF C(E)=0
 41616						STOP^
 41617	056644	254 04 0 00 056645 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41618	056645	324 00 0 00 056646 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41619									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41620									;IN THE SUBTEST) TO LOOP ON ERROR^
 41621
 41622					;**********
 41623
 41624					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON POP.
 41625					;THE AC IS PRELOADED WITH 1,,0; THEN POP IS EXECUTED. POP SHOULD SUBTRACT ONE
 41626					;FROM BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41627					;CARRY WAS GENERATED, THIS TEST PASSES
 41628
 41629	056646	515 02 0 00 000001 	C33401:	HRLZI	2,1		;PRELOAD AC WITH 1,,0
 41630	056647	262 02 0 00 000000 		POP	2,0		;*POP SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41631	056650	302 02 0 00 777777 		CAIE	2,-1		;PASS IF C(AC)=0,,-1 (NO CARRY WAS GENERATED)
 41632						STOP^
 41633	056651	254 04 0 00 056652 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41634	056652	324 00 0 00 056653 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41635									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41636									;IN THE SUBTEST) TO LOOP ON ERROR^
 41637
 41638					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA7	MAC	13-Jan-89 10:22		TEST OF POPJ INSTRUCTION

 41639					SUBTTL	TEST OF POPJ INSTRUCTION
 41640
 41641					;**********
 41642
 41643					;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
 41644					;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
 41645					;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.
 41646
 41647	056653	200 00 0 00 070251 	C33500:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41648	056654	201 01 0 00 056657 		MOVEI	1,.+3		;PRELOAD C(AC-RIGHT) WITH .+3
 41649	056655	263 00 0 00 056657 		POPJ	.+2		;*POPJ SHOULD JUMP TO LOCATION
 41650									;ADDRESSED BY C(C(AC-RIGHT))
 41651						STOP^
 41652	056656	254 04 0 00 056657 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41653	056657	324 00 0 00 056660 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41654									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41655									;IN THE SUBTEST) TO LOOP ON ERROR^
 41656
 41657					;**********
 41658
 41659					;THIS TEST VERIFIES THAT POPJ SUBTRACTS 1,,1 FROM THE AC
 41660					;THIS AC IS PRELOADED WITH 1,,1; THEN,POPJ IS EXECUTED.
 41661					;THE AC IS CHECKED FOR 0.  IF C(AC)=0, THIS TEST PASSES.
 41662
 41663	056660	200 00 0 00 070251 	C33600:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41664	056661	201 01 0 00 056663 		MOVEI	1,.+2		;PRELOAD C(AC-NIGHT)WITH .+2
 41665	056662	263 00 0 00 056663 		POPJ	.+1		;*POPJ SHOULD SUBTRACT 1,,1 FROM AC
 41666	056663	312 00 0 00 070253 		CAME	[0]		;PASS IF C(AC)=0
 41667						STOP^
 41668	056664	254 04 0 00 056665 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41669	056665	324 00 0 00 056666 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41670									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41671									;IN THE SUBTEST) TO LOOP ON ERROR^
 41672
 41673					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA7	MAC	13-Jan-89 10:22		TEST OF POPJ INSTRUCTION

 41674					;THIS TEST VERIFIES THAT POPJ JUMPS TO THE LOCATION ADDRESSED BY RIGHT HALF OF
 41675					;C(C(AC-RIGHT)) BEFORE POPJ DECREMENTED THE AC.
 41676					;THIS TEST PASSES IF POPJ JUMPS CORRECTLY.
 41677
 41678	056666	200 00 0 00 070251 	C33700:	MOVE	[XWD 1,1]	;PRELOAD AC WITH 1,,1
 41679	056667	201 01 0 00 056671 		MOVEI	1,.+2		;PRELOAD C(AC-RIGHT) WITH C33700+3
 41680
 41681	056670	263 00 0 00 056672 		POPJ	.+2		;*POPJ SHOULD JUMP TO C33700+3
 41682	056671	334 00 0 00 000000 		SKIPA			;PASS IF POPJ JUMPED CORRECTLY
 41683						STOP^
 41684	056672	254 04 0 00 056673 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41685	056673	324 00 0 00 056674 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41686									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41687									;IN THE SUBTEST) TO LOOP ON ERROR^
 41688
 41689					;**********
 41690
 41691					;THIS TEST VERIFIES THAT THERE IS NO CARRY FROM BIT 18 TO BIT 17 OF THE AC ON POPJ.
 41692					;THE AC IS PRELOADED WITH 1,,0; THEN POPJ IS EXECUTED. POPJ SHOULD SUBTRACT ONE
 41693					;FROM BOTH HALVES OF THE AC WITHOUT GENERATING A CARRY FROM BIT 18 TO BIT 17. IF NO
 41694					;CARRY WAS GENERATED, THIS TEST PASSES
 41695
 41696	056674	515 02 0 00 000001 	C33701:	HRLZI	2,1		;PRELOAD AC WITH 1,,0
 41697	056675	201 00 0 00 056677 		MOVEI	0,.+2		;PRELOAD C(AC-RIGHT) WITH  C33701+3
 41698	056676	263 02 0 00 000000 		POPJ	2,0		;*POPJ SHOULD NOT GENERATE A CARRY FROM BIT 18 TO 17
 41699	056677	302 02 0 00 777777 		CAIE	2,-1		;PASS IF C(AC)=0,,-1 (NO CARRY WAS GENERATED)
 41700						STOP^
 41701	056700	254 04 0 00 056701 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41702	056701	324 00 0 00 056702 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41703									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41704									;IN THE SUBTEST) TO LOOP ON ERROR^
 41705
 41706					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA7	MAC	13-Jan-89 10:22		XCT INSTRUCTION - ADDITIONAL TESTS

 41707					SUBTTL	XCT INSTRUCTION - ADDITIONAL TESTS
 41708
 41709					;**********
 41710
 41711					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41712					;TO THE LOCATION OF THE XCT.
 41713
 41714	056702	477 00 0 00 000001 	C34000:	SETOB	1
 41715	056703	256 00 0 00 071015 		XCT	[CAME 0,1]	;*CAME SHOULD SKIP TO C34000+3
 41716						STOP^
 41717	056704	254 04 0 00 056705 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41718	056705	324 00 0 00 056706 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41719									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41720									;IN THE SUBTEST) TO LOOP ON ERROR^
 41721
 41722					;**********
 41723
 41724					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41725					;TO THE LOCATION OF THE XCT.
 41726
 41727	056706	477 00 0 00 000001 	C34100:	SETOB	1
 41728	056707	256 00 0 00 071017 		XCT	[XCT[XCT[CAME 0,1]]]	;*CAME SHOULD SKIP TO C34100+3
 41729						STOP^
 41730	056710	254 04 0 00 056711 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41731	056711	324 00 0 00 056712 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41732									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41733									;IN THE SUBTEST) TO LOOP ON ERROR^
 41734
 41735					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA7	MAC	13-Jan-89 10:22		XCT INSTRUCTION - ADDITIONAL TESTS

 41736					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41737					;SPECIFIED BY THE JUMP.
 41738
 41739	056712	256 00 0 00 071020 	C34200:	XCT	[JRST .+4]	;*JRST SHOULD JUMP TO C34200+4
 41740
 41741	056713	254 04 0 00 000000 		HALT			;JRST SHOULD JUMP OVER THIS LOCATION
 41742	056714	254 04 0 00 000000 		HALT			;JRST SHOULD JUMP OVER THIS LOCATION
 41743						STOP^
 41744	056715	254 04 0 00 056716 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41745	056716	324 00 0 00 056717 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41746									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41747									;IN THE SUBTEST) TO LOOP ON ERROR^
 41748
 41749					;**********
 41750
 41751					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41752					;SPECIFIED BY THE JUMP AND THAT WHEN THE PC IS SAVED IT CONTAINS AN
 41753					;ADDRESS ONE GREATER THAN THE LOCATION OF FIRST XCT OF THE CHAIN.
 41754
 41755	056717	402 00 0 00 000003 	C34300:	SETZM	3		;CLEAR AC OF JSP
 41756	056720	256 00 0 00 071023 		XCT	[XCT[XCT[JSP 3,.+3]]] ;*JSP SHOULD JUMP TO C34300+4 AND
 41757	056721	254 04 0 00 000000 		HALT			;THE SAVED PC SHOULD BE C 34300+2	
 41758	056722	254 04 0 00 000000 		HALT			;PASS IF JSP JUMPED CORRECTLY	
 41759	056723	620 03 0 00 056721 		TRZ	3,.-2		;AND SAVED PC=C34300+2
 41760	056724	602 03 0 00 777777 		TRNE	3,-1
 41761						STOP^
 41762	056725	254 04 0 00 056726 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41763	056726	324 00 0 00 056727 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41764									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41765									;IN THE SUBTEST) TO LOOP ON ERROR^
 41766
 41767					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA7	MAC	13-Jan-89 10:22		XCT INSTRUCTION - ADDITIONAL TESTS

 41768					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41769					;TO THE LOCATION OF THE XCT.
 41770					;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
 41771					;FOLLOWING XCT SHOULD BE EXECUTED AFTER 'CAME' IS EXECUTED.
 41772
 41773	056727	403 00 0 00 000000 	C34400:	SETZB	0		;SET-UP AC,E SO THAT
 41774	056730	476 00 0 00 000001 		SETOM	1		;CAME WILL NOT SKIP
 41775	056731	256 00 0 00 071015 		XCT	[CAME 0,1]	;*CAME SHOULD CAUSE EXECUTION
 41776									;OF INSTRUCTION FOLLOWING XCT
 41777	056732	254 00 0 00 056734 		JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED
 41778						STOP^
 41779	056733	254 04 0 00 056734 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41780	056734	324 00 0 00 056735 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41781									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41782									;IN THE SUBTEST) TO LOOP ON ERROR^
 41783
 41784					;**********
 41785
 41786					;THIS TEST VERIFIES INDEXING FOR XCT OF AN ADD INSTRUCTION
 41787					;C(4)=10, AND C(6)=3, SO THE RESULT IN 6 (THE AC) SHOULD BE 16
 41788					;C(11)=13
 41789
 41790	056735	201 04 0 00 000010 	C34500:	MOVEI	4,10		;PRELOAD INDEX REG WITH 10
 41791	056736	201 11 0 00 000013 		MOVEI	11,13		;PRELOAD EFFECTIVE ADDRESS WITH 13
 41792	056737	201 06 0 00 000003 		MOVEI	6,3		;PRELOAD AC WITH 3
 41793	056740	256 00 0 00 071024 		XCT	[ADD 6,1(4)]	;*ADD SHOULD PLACE 16 IN AC
 41794	056741	302 06 0 00 000016 		CAIE	6,16		;PASS IF C(AC)=16
 41795						STOP^
 41796	056742	254 04 0 00 056743 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41797	056743	324 00 0 00 056744 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41798									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41799									;IN THE SUBTEST) TO LOOP ON ERROR^
 41800
 41801					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA7	MAC	13-Jan-89 10:22		XCT INSTRUCTION - ADDITIONAL TESTS

 41802					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41803					;TO THE LOCATION OF THE XCT
 41804					;IN THIS CASE, NO SKIP SHOULD OCCUR  ;HENCE, THE INSTRUCTION
 41805					;FOLLOWING XCT SHOULD BE EXECUTED AFTER CAME IS EXECUTED.
 41806
 41807	056744	402 00 0 00 000002 	C34600:	SETZM	2		;SETUP E SO THAT SKIPL WILL NOT SKIP
 41808	056745	256 00 0 00 071025 		XCT	[SKIPL 1,2]	;*SKIPL SHOULD CAUSE INSTRUCTION
 41809									;OF FOLLOWING INSTRUCTION
 41810	056746	254 00 0 00 056750 		JRST	.+2		;PASS IF THIS INSTRUCTION IS EXECUTED.
 41811						STOP^
 41812	056747	254 04 0 00 056750 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41813	056750	324 00 0 00 056751 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41814									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41815									;IN THE SUBTEST) TO LOOP ON ERROR^
 41816	056751	332 00 0 00 000001 	C34610:	SKIPE	1		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
 41817									;PLACED 0 INTO AC1
 41818						STOP^
 41819	056752	254 04 0 00 056753 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41820	056753	324 00 0 00 056754 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41821									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41822									;IN THE SUBTEST) TO LOOP ON ERROR^
 41823
 41824					;**********
 41825
 41826					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A SKIP INSTRUCTION, THE SKIP IS RELATIVE
 41827					;TO THE LOCATION OF THE XCT.
 41828
 41829	056754	476 00 0 00 000006 	C34700:	SETOM	6		;SETUP E SO THAT SKIPL WILL SKIP
 41830	056755	256 00 0 00 071026 		XCT	[SKIPL 3,6]	;*SKIPL SHOULD SKIP TO C34700+3
 41831						STOP^
 41832	056756	254 04 0 00 056757 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41833	056757	324 00 0 00 056760 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41834									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41835									;IN THE SUBTEST) TO LOOP ON ERROR^
 41836	056760	331 00 0 00 000003 	C34710:	SKIPL	3		;*SKIPE SHOULD SKIP BECAUSE XCT OF SKIPL
 41837									;PLACED 0 INTO AC1
 41838						STOP^
 41839	056761	254 04 0 00 056762 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41840	056762	324 00 0 00 056763 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41841									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41842									;IN THE SUBTEST) TO LOOP ON ERROR^
 41843
 41844					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA7	MAC	13-Jan-89 10:22		XCT INSTRUCTION - ADDITIONAL TESTS

 41845					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41846					;SPECIFIED BY THE JUMP.
 41847					;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN
 41848
 41849	056763	200 03 0 00 071027 	C35000:	MOVE	3,[-2,,5]	;SETUP AC SO THAT AOBJN WILL JUMP
 41850	056764	256 00 0 00 071030 		XCT	[AOBJN 3,.+3]	;*JUMP SHOULD BE TO C35000+4
 41851	056765	254 04 0 00 000000 		HALT			;JUMP OVER THIS INSTRUCTION
 41852	056766	254 04 0 00 000000 		HALT			;JUMP OVER THIS INSTRUCTION
 41853	056767	312 03 0 00 071031 		CAME	3,[-1,,6]	;PASS IF C(AC)=-1,,6 AND AOBJN JUMPED
 41854						STOP^
 41855	056770	254 04 0 00 056771 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41856	056771	324 00 0 00 056772 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41857									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41858									;IN THE SUBTEST) TO LOOP ON ERROR^
 41859
 41860					;**********
 41861
 41862					;THIS TEST VERIFIES THAT IF AN XCT EXECUTES A JUMP, PROGRAM FLOW IS ALTERED AS
 41863					;SPECIFIED BY THE JUMP.
 41864					;THIS TEST ALSO VERIFIES CORRECT UPDATING OF THE AC FOR AOBJN
 41865
 41866	056772	200 03 0 00 071031 	C35100:	MOVE	3,[-1,,6]	;SETUP AC SO THAT AOBJN WILL NOT JUMP
 41867	056773	256 00 0 00 071032 		XCT	[AOBJN 3,.+2]	;*AOBJN SHOULD NOT JUMP
 41868	056774	312 03 0 00 071033 		CAME	3,[0,,7]	;PASS IF AOBJN DID NOT JUMP AND C(AC)=0,,7
 41869						STOP^
 41870	056775	254 04 0 00 056776 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41871	056776	324 00 0 00 056777 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41872									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41873									;IN THE SUBTEST) TO LOOP ON ERROR^
 41874
 41875					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA7	MAC	13-Jan-89 10:22		TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING

 41876					SUBTTL	TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING
 41877
 41878					;**********
 41879
 41880					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
 41881					;FROM AN INDIRECTLY ADDRESSED LOCATION
 41882
 41883	056777	403 00 0 00 000002 	C35200:	SETZB	2
 41884	057000	254 00 0 00 057003 		JRST	.+3
 41885	057001	000000	057002				.+1
 41886	057002	476 00 0 00 000002 		SETOM	2		;THIS INSTRUCTION SHOULD BE EXECUTED
 41887	057003	256 00 1 00 057001 		XCT	@.-2
 41888	057004	312 02 0 00 070254 		CAME	2,[-1,,-1]	;PASS IF 'SETOM 2' WAS EXECUTED
 41889						STOP^
 41890	057005	254 04 0 00 057006 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41891	057006	324 00 0 00 057007 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41892									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41893									;IN THE SUBTEST) TO LOOP ON ERROR^
 41894
 41895					;**********
 41896
 41897					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
 41898					;FROM AN INDEXED LOCATION
 41899
 41900	057007	201 04 0 00 057010 	C35300:	MOVEI	4,.+1
 41901	057010	254 00 0 00 057012 		JRST	.+2
 41902	057011	302 04 0 00 057010 		CAIE	4,.-1		;THIS INSTRUCTION SHOULD BE EXECUTED
 41903	057012	256 00 0 04 000001 		XCT	1(4)
 41904						STOP			^;PASS IF 'CAIE 4,,-1' WAS EXECUTED
 41905
 41906	057013	254 04 0 00 057014 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41907	057014	324 00 0 00 057015 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41908									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41909									;IN THE SUBTEST) TO LOOP ON ERROR
 41910
 41911					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA7	MAC	13-Jan-89 10:22		TEST XCT INSTRUCTION WITH INDIRECT ADDRESSING AND INDEXING

 41912					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INSTRUCTION
 41913					;FROM AN INDIRECTLY ADDRESSED AND INDEXED LOCATION
 41914
 41915	057015	402 00 0 00 000005 	C35400:	SETZM	5
 41916	057016	201 03 0 00 057021 		MOVEI	3,.+3
 41917	057017	254 00 0 00 057021 		JRST	.+2
 41918	057020	201 05 0 00 057023 		MOVEI	5,.+3
 41919	057021	256 00 1 03 777777 		XCT	@-1(3)
 41920	057022	254 00 0 00 057024 		JRST	.+2
 41921	057023	476 00 0 00 000005 		SETOM	5		;THIS INSTRUCTION SHOULD BE EXECUTED
 41922	057024	312 05 0 00 070254 		CAME	5,[-1,,-1]	;PASS IF 'SETOM 5' WAS EXECUTED
 41923						STOP^
 41924	057025	254 04 0 00 057026 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41925	057026	324 00 0 00 057027 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41926									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41927									;IN THE SUBTEST) TO LOOP ON ERROR^
 41928
 41929					;**********
 41930
 41931					;THIS TEST VERIFIES THAT XCT WILL EXECUTE AN INDIRECTLY ADDRESSED
 41932					;AND INDEXED INSTRUCTION
 41933
 41934	057027	402 00 0 00 000003 	C35500:	SETZM	3
 41935	057030	201 10 0 00 000003 		MOVEI	10,3
 41936	057031	254 00 0 00 057036 		JRST	.+5
 41937	057032	254 04 0 00 000000 		HALT
 41938	057033	254 04 0 00 000000 		HALT
 41939	057034	200 03 1 10 057032 		MOVE	3,@.-2(10)	;THIS INSTRUCTION SHOULD BE EXECUTED
 41940	057035	254 04 0 00 070547 		HALT	[0,,707070]
 41941	057036	256 00 0 00 057034 		XCT	.-2
 41942	057037	302 03 0 00 707070 		CAIE	3,707070	;PASS IF 'MOVE 3,@.-2(10)' WAS EXECUTED
 41943						STOP^
 41944	057040	254 04 0 00 057041 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41945	057041	324 00 0 00 057042 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41946									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41947									;IN THE SUBTEST) TO LOOP ON ERROR^
 41948
 41949					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 41950					SUBTTL	TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER
 41951
 41952					;**********
 41953
 41954					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 41955					;IN THIS CASE, 0,,0 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 41956					;SO THAT FINAL C(AC)=0,,0.
 41957					;C(AC+1) SHOULD NOT BE AFFECTED.
 41958
 41959	057042	200 00 0 00 070253 	C35600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 41960	057043	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 41961	057044	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 0,,0 RIGHT 3 BIT POSITIONS
 41962	057045	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 41963						STOP^
 41964	057046	254 04 0 00 057047 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41965	057047	324 00 0 00 057050 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41966									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41967									;IN THE SUBTEST) TO LOOP ON ERROR^
 41968	057050	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 41969						STOP^
 41970	057051	254 04 0 00 057052 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41971	057052	324 00 0 00 057053 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41972									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41973									;IN THE SUBTEST) TO LOOP ON ERROR^
 41974
 41975					;**********
 41976
 41977					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 41978					;IN THIS CASE, -1,,-1 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 41979					;SO THAT FINAL C(AC)=-1,,-1.
 41980					;C(AC+1) SHOULD NOT BE AFFECTED.
 41981
 41982	057053	200 00 0 00 070254 	C35700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH 0,,0
 41983	057054	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 41984	057055	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE -1,,-1 RIGHT 3 BIT POSITIONS
 41985	057056	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 41986						STOP^
 41987	057057	254 04 0 00 057060 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41988	057060	324 00 0 00 057061 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41989									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41990									;IN THE SUBTEST) TO LOOP ON ERROR^
 41991	057061	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 41992						STOP^
 41993	057062	254 04 0 00 057063 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 41994	057063	324 00 0 00 057064 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 41995									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 41996									;IN THE SUBTEST) TO LOOP ON ERROR^
 41997
 41998					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 41999					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42000					;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 42001					;SO THAT FINAL C(AC)=525252,,525252.
 42002					;C(AC+1) SHOULD NOT BE AFFECTED.
 42003
 42004	057064	200 00 0 00 070614 	C36000:	MOVE	0,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
 42005	057065	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42006	057066	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 252525,,252525
 42007									;RIGHT 3 BIT POSITIONS
 42008	057067	312 00 0 00 071035 		CAME	0,[525252,,525252] ;PASS IF C(AC)=525252,,525252
 42009						STOP^
 42010	057070	254 04 0 00 057071 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42011	057071	324 00 0 00 057072 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42012									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42013									;IN THE SUBTEST) TO LOOP ON ERROR^
 42014	057072	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42015						STOP^
 42016	057073	254 04 0 00 057074 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42017	057074	324 00 0 00 057075 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42018									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42019									;IN THE SUBTEST) TO LOOP ON ERROR^
 42020
 42021					;**********
 42022
 42023					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42024					;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 42025					;SO THAT FINAL C(AC)=252525,,252525.
 42026					;C(AC+1) SHOULD NOT BE AFFECTED.
 42027
 42028	057075	200 00 0 00 071035 	C36100:	MOVE	0,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
 42029	057076	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42030	057077	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 525252,,525252
 42031									;RIGHT 3 BIT POSITIONS
 42032	057100	312 00 0 00 070614 		CAME	0,[252525,,252525] ;PASS IF C(AC)=252525,,252525
 42033						STOP^
 42034	057101	254 04 0 00 057102 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42035	057102	324 00 0 00 057103 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42036									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42037									;IN THE SUBTEST) TO LOOP ON ERROR^
 42038	057103	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42039						STOP^
 42040	057104	254 04 0 00 057105 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42041	057105	324 00 0 00 057106 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42042									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42043									;IN THE SUBTEST) TO LOOP ON ERROR^
 42044
 42045					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42046					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42047					;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 42048					;SO THAT FINAL C(AC)=023070,,360370.
 42049					;C(AC+1) SHOULD NOT BE AFFECTED.
 42050
 42051	057106	200 00 0 00 071036 	C36200:	MOVE	0,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
 42052	057107	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42053	057110	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 230703,,603700
 42054									;RIGHT 3 BIT POSITIONS
 42055	057111	312 00 0 00 071037 		CAME	0,[023070,,360370] ;PASS IF C(AC)=023070,,360370
 42056						STOP^
 42057	057112	254 04 0 00 057113 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42058	057113	324 00 0 00 057114 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42059									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42060									;IN THE SUBTEST) TO LOOP ON ERROR^
 42061	057114	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42062						STOP^
 42063	057115	254 04 0 00 057116 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42064	057116	324 00 0 00 057117 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42065									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42066									;IN THE SUBTEST) TO LOOP ON ERROR^
 42067
 42068					;**********
 42069
 42070					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42071					;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED RIGHT 3 BIT POSITIONS
 42072					;SO THAT FINAL C(AC)=200760,,360706.
 42073					;C(AC+1) SHOULD NOT BE AFFECTED.
 42074
 42075	057117	200 00 0 00 071040 	C36300:	MOVE	0,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
 42076	057120	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42077	057121	241 00 0 00 777775 		ROT	0,-3		;*ROT SHOULD ROTATE 007603,,607062
 42078									;RIGHT 3 BIT POSITIONS
 42079	057122	312 00 0 00 071041 		CAME	0,[200760,,360706] ;PASS IF C(AC)=200760,,360706
 42080						STOP^
 42081	057123	254 04 0 00 057124 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42082	057124	324 00 0 00 057125 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42083									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42084									;IN THE SUBTEST) TO LOOP ON ERROR^
 42085	057125	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42086						STOP^
 42087	057126	254 04 0 00 057127 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42088	057127	324 00 0 00 057130 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42089									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42090									;IN THE SUBTEST) TO LOOP ON ERROR^
 42091
 42092					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42093					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42094					;IN THIS CASE, 0,,0 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42095					;SO THAT FINAL C(AC)=0,,0.
 42096					;C(AC+1) SHOULD NOT BE AFFECTED.
 42097
 42098	057130	200 02 0 00 070253 	C36400:	MOVE	2,[0,,0]	;PRELOAD AC WITH 0,,0
 42099	057131	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42100	057132	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 0,,0 LEFT 15 BIT POSITIONS
 42101	057133	312 02 0 00 070253 		CAME	2,[0,,0]	;PASS IF C(AC)=0,,0
 42102						STOP^
 42103	057134	254 04 0 00 057135 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42104	057135	324 00 0 00 057136 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42105									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42106									;IN THE SUBTEST) TO LOOP ON ERROR^
 42107	057136	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42108						STOP^
 42109	057137	254 04 0 00 057140 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42110	057140	324 00 0 00 057141 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42111									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42112									;IN THE SUBTEST) TO LOOP ON ERROR^
 42113
 42114					;**********
 42115
 42116					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42117					;IN THIS CASE, -1,,-1 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42118					;SO THAT FINAL C(AC)=-1,,-1.
 42119					;C(AC+1) SHOULD NOT BE AFFECTED.
 42120
 42121	057141	200 02 0 00 070254 	C36500:	MOVE	2,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42122	057142	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42123	057143	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE -1,,-1 LEFT 15 BIT POSITIONS
 42124	057144	312 02 0 00 070254 		CAME	2,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 42125						STOP^
 42126	057145	254 04 0 00 057146 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42127	057146	324 00 0 00 057147 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42128									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42129									;IN THE SUBTEST) TO LOOP ON ERROR^
 42130	057147	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42131						STOP^
 42132	057150	254 04 0 00 057151 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42133	057151	324 00 0 00 057152 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42134									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42135									;IN THE SUBTEST) TO LOOP ON ERROR^
 42136
 42137					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42138					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42139					;IN THIS CASE, 252525,,252525 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42140					;SO THAT FINAL C(AC)=525252,,525252.
 42141					;C(AC+1) SHOULD NOT BE AFFECTED.
 42142
 42143	057152	200 02 0 00 070614 	C36600:	MOVE	2,[252525,,252525] ;PRELOAD AC WITH 252525,,252525
 42144	057153	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42145	057154	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 252525,,252525
 42146									;LEFT 15 BIT POSITIONS
 42147	057155	312 02 0 00 071035 		CAME	2,[525252,,525252] ;PASS IF C(AC)=525252,,525252
 42148						STOP^
 42149	057156	254 04 0 00 057157 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42150	057157	324 00 0 00 057160 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42151									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42152									;IN THE SUBTEST) TO LOOP ON ERROR^
 42153	057160	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42154						STOP^
 42155	057161	254 04 0 00 057162 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42156	057162	324 00 0 00 057163 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42157									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42158									;IN THE SUBTEST) TO LOOP ON ERROR^
 42159
 42160					;**********
 42161
 42162					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42163					;IN THIS CASE, 525252,,525252 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42164					;SO THAT FINAL C(AC)=252525,,252525.
 42165					;C(AC+1) SHOULD NOT BE AFFECTED.
 42166
 42167	057163	200 02 0 00 071035 	C36700:	MOVE	2,[525252,,525252] ;PRELOAD AC WITH 525252,,525252
 42168	057164	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42169	057165	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 525252,,525252
 42170									;LEFT 15 BIT POSITIONS
 42171	057166	312 02 0 00 070614 		CAME	2,[252525,,252525] ;PASS IF C(AC)=252525,,252525
 42172						STOP^
 42173	057167	254 04 0 00 057170 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42174	057170	324 00 0 00 057171 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42175									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42176									;IN THE SUBTEST) TO LOOP ON ERROR^
 42177	057171	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42178						STOP^
 42179	057172	254 04 0 00 057173 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42180	057173	324 00 0 00 057174 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42181									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42182									;IN THE SUBTEST) TO LOOP ON ERROR^
 42183
 42184					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42185					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42186					;IN THIS CASE, 230703,,603700 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42187					;SO THAT FINAL C(AC)074076,,004616.
 42188					;C(AC+1) SHOULD NOT BE AFFECTED.
 42189
 42190	057174	200 02 0 00 071036 	C37000:	MOVE	2,[230703,,603700] ;PRELOAD AC WITH 230703,,603700
 42191	057175	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42192	057176	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 230703,,603700
 42193									;LEFT 15 BIT POSITIONS
 42194	057177	312 02 0 00 071042 		CAME	2,[074076,,004616] ;PASS IF C(AC)074076,,004616
 42195						STOP^
 42196	057200	254 04 0 00 057201 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42197	057201	324 00 0 00 057202 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42198									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42199									;IN THE SUBTEST) TO LOOP ON ERROR^
 42200	057202	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42201						STOP^
 42202	057203	254 04 0 00 057204 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42203	057204	324 00 0 00 057205 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42204									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42205									;IN THE SUBTEST) TO LOOP ON ERROR^
 42206
 42207					;**********
 42208
 42209					;THIS TEST VERIFIES THAT A ROT INSTRUCTION FUNCTIONS CORRECTLY.
 42210					;IN THIS CASE, 007603,,607062 SHOULD BE ROTATED LEFT 15 BIT POSITIONS
 42211					;SO THAT FINAL C(AC)074161,,440174.
 42212					;C(AC+1) SHOULD NOT BE AFFECTED.
 42213
 42214	057205	200 02 0 00 071040 	C37100:	MOVE	2,[007603,,607062] ;PRELOAD AC WITH 007603,,607062
 42215	057206	200 03 0 00 071034 		MOVE	3,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42216	057207	241 02 0 00 000015 		ROT	2,15		;*ROT SHOULD ROTATE 007603,,607062
 42217									;LEFT 15 BIT POSITIONS
 42218	057210	312 02 0 00 071043 		CAME	2,[074161,,440174] ;PASS IF C(AC)074161,,440174
 42219						STOP^
 42220	057211	254 04 0 00 057212 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42221	057212	324 00 0 00 057213 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42222									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42223									;IN THE SUBTEST) TO LOOP ON ERROR^
 42224	057213	312 03 0 00 071034 		CAME	3,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42225						STOP^
 42226	057214	254 04 0 00 057215 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42227	057215	324 00 0 00 057216 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42228									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42229									;IN THE SUBTEST) TO LOOP ON ERROR^
 42230
 42231					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 32
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42232					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42233					;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42234					;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0
 42235
 42236	057216	200 00 0 00 070253 	C37200:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 42237	057217	200 01 0 00 070253 		MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
 42238	057220	245 00 0 00 000003 		ROTC	0,3		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 3 BIT POSITIONS
 42239	057221	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 42240						STOP^
 42241	057222	254 04 0 00 057223 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42242	057223	324 00 0 00 057224 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42243									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42244									;IN THE SUBTEST) TO LOOP ON ERROR^
 42245	057224	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
 42246						STOP^
 42247	057225	254 04 0 00 057226 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42248	057226	324 00 0 00 057227 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42249									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42250									;IN THE SUBTEST) TO LOOP ON ERROR^
 42251
 42252					;**********
 42253
 42254					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42255					;IN THIS CASE, -1,,-1 -1,,-1 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42256					;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1
 42257
 42258	057227	200 00 0 00 070254 	C37300:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42259	057230	200 01 0 00 070254 		MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
 42260	057231	245 00 0 00 000003 		ROTC	0,3		;*ROTC SHOULD ROTATE -1,,-1
 42261									;-1,,-1 LEFT 3 BIT POSITIONS
 42262	057232	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 42263						STOP^
 42264	057233	254 04 0 00 057234 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42265	057234	324 00 0 00 057235 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42266									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42267									;IN THE SUBTEST) TO LOOP ON ERROR^
 42268	057235	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
 42269						STOP^
 42270	057236	254 04 0 00 057237 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42271	057237	324 00 0 00 057240 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42272									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42273									;IN THE SUBTEST) TO LOOP ON ERROR^
 42274
 42275					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 33
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42276					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42277					;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42278					;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252
 42279
 42280	057240	200 00 0 00 070614 	C37400:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42281	057241	200 01 0 00 070614 		MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
 42282	057242	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 252525,,252525
 42283										;252525,,252525 LEFT 3 BIT POSITIONS
 42284	057243	312 00 0 00 071035 		CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
 42285						STOP^
 42286	057244	254 04 0 00 057245 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42287	057245	324 00 0 00 057246 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42288									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42289									;IN THE SUBTEST) TO LOOP ON ERROR^
 42290	057246	312 01 0 00 071035 		CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
 42291						STOP^
 42292	057247	254 04 0 00 057250 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42293	057250	324 00 0 00 057251 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42294									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42295									;IN THE SUBTEST) TO LOOP ON ERROR^
 42296
 42297					;**********
 42298
 42299					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42300					;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42301					;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525
 42302
 42303	057251	200 00 0 00 071035 	C37500:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42304	057252	200 01 0 00 071035 		MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
 42305	057253	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 525252,,525252
 42306										;525252,,525252 LEFT 3 BIT POSITIONS
 42307	057254	312 00 0 00 070614 		CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
 42308						STOP^
 42309	057255	254 04 0 00 057256 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42310	057256	324 00 0 00 057257 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42311									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42312									;IN THE SUBTEST) TO LOOP ON ERROR^
 42313	057257	312 01 0 00 070614 		CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
 42314						STOP^
 42315	057260	254 04 0 00 057261 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42316	057261	324 00 0 00 057262 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42317									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42318									;IN THE SUBTEST) TO LOOP ON ERROR^
 42319
 42320					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 34
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42321					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42322					;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42323					;SO THAT FINAL C(AC)=307036,,37007 AND FINAL C(AC+1)=700376,,003772
 42324
 42325	057262	200 00 0 00 071036 	C37600:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42326	057263	200 01 0 00 071044 		MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
 42327	057264	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 230703,,603700
 42328										;770037,,600377 LEFT 3 BIT POSITIONS
 42329	057265	312 00 0 00 071045 		CAME	0,[307036,,037007]	;PASS IF C(AC)=307036,,37007
 42330						STOP^
 42331	057266	254 04 0 00 057267 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42332	057267	324 00 0 00 057270 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42333									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42334									;IN THE SUBTEST) TO LOOP ON ERROR^
 42335	057270	312 01 0 00 071046 		CAME	1,[700376,,003772]	;PASS IF C(AC+1)=700376,,003772
 42336						STOP^
 42337	057271	254 04 0 00 057272 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42338	057272	324 00 0 00 057273 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42339									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42340									;IN THE SUBTEST) TO LOOP ON ERROR^
 42341
 42342					;**********
 42343
 42344					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42345					;IN THIS CASE, 776003,,760077 007603,,607062 SHOULD BE ROTATED LEFT 3 BIT POSITIONS
 42346					;SO THAT FINAL C(AC)=760037,,600770 AND FINAL C(AC+1)=076036,,070627
 42347
 42348	057273	200 00 0 00 071047 	C37700:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
 42349	057274	200 01 0 00 071040 		MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
 42350	057275	245 00 0 00 000003 		ROTC	0,3			;*ROTC SHOULD ROTATE 776003,,760077
 42351										;007603,,607062 LEFT 3 BIT POSITIONS
 42352	057276	312 00 0 00 071050 		CAME	0,[760037,,600770]	;PASS IF C(AC)=076036,,070627
 42353						STOP^
 42354	057277	254 04 0 00 057300 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42355	057300	324 00 0 00 057301 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42356									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42357									;IN THE SUBTEST) TO LOOP ON ERROR^
 42358	057301	312 01 0 00 071051 		CAME	1,[076036,,070627]	;PASS IF C(AC+1)=760037,,600770
 42359						STOP^
 42360	057302	254 04 0 00 057303 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42361	057303	324 00 0 00 057304 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42362									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42363									;IN THE SUBTEST) TO LOOP ON ERROR^
 42364
 42365					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 35
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42366					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42367					;IN THIS CASE, 0,,0 0,,0 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42368					;SO THAT FINAL C(AC)=0,,0 AND FINAL C(AC+1)=0,,0
 42369
 42370	057304	200 00 0 00 070253 	C40000:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 42371	057305	200 01 0 00 070253 		MOVE	1,[0,,0]	;PRELOAD AC+1 WITH 0,,0
 42372	057306	245 00 0 00 000007 		ROTC	0,7		;*ROTC SHOULD ROTATE 0,,0 0,,0 LEFT 7 BIT POSITIONS
 42373	057307	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 42374						STOP^
 42375	057310	254 04 0 00 057311 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42376	057311	324 00 0 00 057312 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42377									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42378									;IN THE SUBTEST) TO LOOP ON ERROR^
 42379	057312	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC+1)=0,,0
 42380						STOP^
 42381	057313	254 04 0 00 057314 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42382	057314	324 00 0 00 057315 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42383									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42384									;IN THE SUBTEST) TO LOOP ON ERROR^
 42385
 42386					;**********
 42387
 42388					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42389					;IN THIS CASE, -1,,-1 -1,,-1  SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42390					;SO THAT FINAL C(AC)=-1,,-1 AND FINAL C(AC+1)=-1,,-1
 42391
 42392	057315	200 00 0 00 070254 	C40100:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42393	057316	200 01 0 00 070254 		MOVE	1,[-1,,-1]	;PRELOAD AC+1 WITH -1,,-1
 42394	057317	245 00 0 00 000007 		ROTC	0,7		;*ROTC SHOULD ROTATE -1,,-1
 42395									;-1,,-1 LEFT 7 BIT POSITIONS
 42396	057320	312 00 0 00 070254 		CAME	0,[-1,,-1]	;PASS IF C(AC)=-1,,-1
 42397						STOP^
 42398	057321	254 04 0 00 057322 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42399	057322	324 00 0 00 057323 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42400									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42401									;IN THE SUBTEST) TO LOOP ON ERROR^
 42402	057323	312 01 0 00 070254 		CAME	1,[-1,,-1]	;PASS IF C(AC+1)=-1,,-1
 42403						STOP^
 42404	057324	254 04 0 00 057325 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42405	057325	324 00 0 00 057326 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42406									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42407									;IN THE SUBTEST) TO LOOP ON ERROR^
 42408
 42409					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 36
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42410					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42411					;IN THIS CASE, 252525,,252525 252525,,252525 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42412					;SO THAT FINAL C(AC)=525252,,525252 AND FINAL C(AC+1)=525252,,525252
 42413
 42414	057326	200 00 0 00 070614 	C40200:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42415	057327	200 01 0 00 070614 		MOVE	1,[252525,,252525]	;PRELOAD AC+1 WITH 252525,,252525
 42416	057330	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 252525,,252525
 42417										;252525,,252525 LEFT 7 BIT POSITIONS
 42418	057331	312 00 0 00 071035 		CAME	0,[525252,,525252]	;PASS IF C(AC)=525252,,525252
 42419						STOP^
 42420	057332	254 04 0 00 057333 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42421	057333	324 00 0 00 057334 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42422									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42423									;IN THE SUBTEST) TO LOOP ON ERROR^
 42424	057334	312 01 0 00 071035 		CAME	1,[525252,,525252]	;PASS IF C(AC+1)=525252,,525252
 42425						STOP^
 42426	057335	254 04 0 00 057336 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42427	057336	324 00 0 00 057337 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42428									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42429									;IN THE SUBTEST) TO LOOP ON ERROR^
 42430
 42431					;**********
 42432
 42433					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42434					;IN THIS CASE, 525252,,525252 525252,,525252 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42435					;SO THAT FINAL C(AC)=252525,,252525 AND FINAL C(AC+1)=252525,,252525 
 42436
 42437	057337	200 00 0 00 071035 	C40300:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42438	057340	200 01 0 00 071035 		MOVE	1,[525252,,525252]	;PRELOAD AC+1 WITH 525252,,525252
 42439	057341	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 525252,,525252
 42440										;525252,,525252 LEFT 7 BIT POSITIONS
 42441	057342	312 00 0 00 070614 		CAME	0,[252525,,252525]	;PASS IF C(AC)=252525,,252525
 42442						STOP^
 42443	057343	254 04 0 00 057344 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42444	057344	324 00 0 00 057345 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42445									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42446									;IN THE SUBTEST) TO LOOP ON ERROR^
 42447	057345	312 01 0 00 070614 		CAME	1,[252525,,252525]	;PASS IF C(AC+1)=252525,,252525
 42448						STOP^
 42449	057346	254 04 0 00 057347 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42450	057347	324 00 0 00 057350 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42451									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42452									;IN THE SUBTEST) TO LOOP ON ERROR^
 42453
 42454					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 37
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42455					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42456					;IN THIS CASE, 230703,,603700 770037,,600377 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42457					;SO THAT FINAL C(AC)=160740,,760176 AND FINAL C(AC+1)=007740,,077646
 42458
 42459	057350	200 00 0 00 071036 	C40400:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42460	057351	200 01 0 00 071044 		MOVE	1,[770037,,600377]	;PRELOAD AC+1 WITH 770037,,600377
 42461	057352	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 230703,,603700
 42462										;770037,,600377 LEFT 7 BIT POSITIONS
 42463	057353	312 00 0 00 071052 		CAME	0,[160740,,760176]	;PASS IF C(AC)=160740,,760176
 42464						STOP^
 42465	057354	254 04 0 00 057355 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42466	057355	324 00 0 00 057356 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42467									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42468									;IN THE SUBTEST) TO LOOP ON ERROR^
 42469	057356	312 01 0 00 071053 		CAME	1,[007740,,077646]	;PASS IF C(AC+1)=007740,,077646
 42470						STOP^
 42471	057357	254 04 0 00 057360 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42472	057360	324 00 0 00 057361 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42473									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42474									;IN THE SUBTEST) TO LOOP ON ERROR^
 42475
 42476					;**********
 42477
 42478					;THIS TEST VERIFIES THAT A ROTC INSTRUCTION FUNCTIONS CORRECTLY.
 42479					;IN THIS CASE, 776003,,760077 007603,,607063 SHOULD BE ROTATED LEFT 7 BIT POSITIONS
 42480					;SO THAT FINAL C(AC)=400774,,017610 AND FINAL C(AC+1)=740741,,614577
 42481
 42482	057361	200 00 0 00 071047 	C40500:	MOVE	0,[776003,,760077]	;PRELOAD AC WITH 776003,,760077
 42483	057362	200 01 0 00 071040 		MOVE	1,[007603,,607062]	;PRELOAD AC+1 WITH 007603,,607062
 42484	057363	245 00 0 00 000007 		ROTC	0,7			;*ROTC SHOULD ROTATE 776003,,760077
 42485										;007603,,607062 LEFT 7 BIT POSITIONS
 42486	057364	312 00 0 00 071054 		CAME	0,[400774,,017601]	;PASS IF C(AC)=400774,,017601
 42487						STOP^
 42488	057365	254 04 0 00 057366 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42489	057366	324 00 0 00 057367 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42490									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42491									;IN THE SUBTEST) TO LOOP ON ERROR^
 42492	057367	312 01 0 00 071055 		CAME	1,[740741,,614577]	;PASS IF C(AC+1)=740741,,614577
 42493						STOP^
 42494	057370	254 04 0 00 057371 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42495	057371	324 00 0 00 057372 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42496									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42497									;IN THE SUBTEST) TO LOOP ON ERROR^
 42498
 42499					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42500					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42501					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42502					;SO THAT FINAL C(AC)=0,,0.
 42503					;C(AC+1) SHOULD NOT BE AFFECTED
 42504
 42505	057372	200 00 0 00 070253 	C40600:	MOVE	0,[0,,0]	;PRELOAD AC WITH 0,,0
 42506	057373	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42507	057374	242 00 0 00 777745 		LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
 42508									;RIGHT 33 OCTAL BIT POSITIONS
 42509	057375	312 00 0 00 070253 		CAME	0,[0,,0]	;PASS IF C(AC)=0,,0
 42510						STOP^
 42511	057376	254 04 0 00 057377 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42512	057377	324 00 0 00 057400 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42513									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42514									;IN THE SUBTEST) TO LOOP ON ERROR^
 42515	057400	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42516						STOP^
 42517	057401	254 04 0 00 057402 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42518	057402	324 00 0 00 057403 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42519									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42520									;IN THE SUBTEST) TO LOOP ON ERROR^
 42521
 42522					;**********
 42523
 42524					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42525					;IN -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42526					;SO THAT FINAL C(AC)=0,,777.
 42527					;C(AC+1) SHOULD NOT BE AFFECTED
 42528
 42529	057403	200 00 0 00 070254 	C40700:	MOVE	0,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42530	057404	200 01 0 00 071034 		MOVE	1,[172737,,405060] ;PRELOAD AC+1 WITH 172737,,405060
 42531	057405	242 00 0 00 777745 		LSH	0,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
 42532									;RIGHT 33 OCTAL BIT POSITIONS
 42533	057406	312 00 0 00 070262 		CAME	0,[0,777]	;PASS IF C(AC)=0,,777
 42534						STOP^
 42535	057407	254 04 0 00 057410 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42536	057410	324 00 0 00 057411 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42537									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42538									;IN THE SUBTEST) TO LOOP ON ERROR^
 42539	057411	312 01 0 00 071034 		CAME	1,[172737,,405060] ;PASS IF C(AC+1) NOT AFFECTED
 42540						STOP^
 42541	057412	254 04 0 00 057413 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42542	057413	324 00 0 00 057414 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42543									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42544									;IN THE SUBTEST) TO LOOP ON ERROR^
 42545
 42546					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42547					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42548					;IN 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42549					;SO THAT FINAL C(AC)=0,,252.
 42550					;C(AC+1) SHOULD NOT BE AFFECTED
 42551
 42552	057414	200 00 0 00 070614 	C41000:	MOVE	0,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42553	057415	200 01 0 00 071034 		MOVE	1,[172737,,405060] 	;PRELOAD AC+1 WITH 172737,,405060
 42554	057416	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
 42555										;RIGHT 33 OCTAL BIT POSITIONS
 42556	057417	312 00 0 00 071056 		CAME	0,[0,,252]		;PASS IF C(AC)=0,,252
 42557						STOP^
 42558	057420	254 04 0 00 057421 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42559	057421	324 00 0 00 057422 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42560									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42561									;IN THE SUBTEST) TO LOOP ON ERROR^
 42562	057422	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42563						STOP^
 42564	057423	254 04 0 00 057424 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42565	057424	324 00 0 00 057425 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42566									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42567									;IN THE SUBTEST) TO LOOP ON ERROR^
 42568
 42569					;**********
 42570
 42571					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42572					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42573					;SO THAT FINAL C(AC)=0,,525.
 42574					;C(AC+1) SHOULD NOT BE AFFECTED
 42575
 42576	057425	200 00 0 00 071035 	C41100:	MOVE	0,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42577	057426	200 01 0 00 071034 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
 42578	057427	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
 42579										;RIGHT 33 OCTAL BIT POSITIONS
 42580	057430	312 00 0 00 071057 		CAME	0,[0,,525]		;PASS IF C(AC)=0,,525
 42581						STOP^
 42582	057431	254 04 0 00 057432 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42583	057432	324 00 0 00 057433 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42584									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42585									;IN THE SUBTEST) TO LOOP ON ERROR^
 42586	057433	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42587						STOP^
 42588	057434	254 04 0 00 057435 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42589	057435	324 00 0 00 057436 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42590									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42591									;IN THE SUBTEST) TO LOOP ON ERROR^
 42592
 42593					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42594					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42595					;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42596					;SO THAT FINAL C(AC)=0,,230.
 42597					;C(AC+1) SHOULD NOT BE AFFECTED
 42598
 42599	057436	200 00 0 00 071036 	C41200:	MOVE	0,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42600	057437	200 01 0 00 071034 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
 42601	057440	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
 42602										;RIGHT 33 OCTAL BIT POSITIONS
 42603	057441	312 00 0 00 071060 		CAME	0,[0,,230]		;PASS IF C(AC)=230703,,603700
 42604						STOP^
 42605	057442	254 04 0 00 057443 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42606	057443	324 00 0 00 057444 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42607									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42608									;IN THE SUBTEST) TO LOOP ON ERROR^
 42609	057444	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42610						STOP^
 42611	057445	254 04 0 00 057446 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42612	057446	324 00 0 00 057447 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42613									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42614									;IN THE SUBTEST) TO LOOP ON ERROR^
 42615
 42616					;**********
 42617
 42618					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42619					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42620					;SO THAT FINAL C(AC)=0,,7.
 42621					;C(AC+1) SHOULD NOT BE AFFECTED
 42622
 42623	057447	200 00 0 00 071040 	C41300:	MOVE	0,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
 42624	057450	200 01 0 00 071034 		MOVE	1,[172737,,405060]	;PRELOAD AC+1 WITH 172737,,405060
 42625	057451	242 00 0 00 777745 		LSH	0,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,6070062
 42626										;RIGHT 33 OCTAL BIT POSITIONS
 42627	057452	312 00 0 00 071033 		CAME	0,[0,,7]		;PASS IF C(AC)=0,,7
 42628						STOP^
 42629	057453	254 04 0 00 057454 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42630	057454	324 00 0 00 057455 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42631									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42632									;IN THE SUBTEST) TO LOOP ON ERROR^
 42633	057455	312 01 0 00 071034 		CAME	1,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42634						STOP^
 42635	057456	254 04 0 00 057457 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42636	057457	324 00 0 00 057460 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42637									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42638									;IN THE SUBTEST) TO LOOP ON ERROR^
 42639
 42640					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42641					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42642					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42643					;SO THAT FINAL C(AC)=0,,0.
 42644					;C(AC+1) SHOULD NOT BE AFFECTED
 42645
 42646	057460	200 01 0 00 070253 	C41400:	MOVE	1,[0,,0]	;PRELOAD AC WITH 0,,0
 42647	057461	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42648	057462	242 01 0 00 777751 		LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT 0,,0
 42649									;RIGHT 27 OCTAL BIT POSITIONS
 42650	057463	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
 42651						STOP^
 42652	057464	254 04 0 00 057465 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42653	057465	324 00 0 00 057466 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42654									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42655									;IN THE SUBTEST) TO LOOP ON ERROR^
 42656	057466	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42657						STOP^
 42658	057467	254 04 0 00 057470 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42659	057470	324 00 0 00 057471 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42660									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42661									;IN THE SUBTEST) TO LOOP ON ERROR^
 42662
 42663					;**********
 42664
 42665					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42666					;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42667					;SO THAT FINAL C(AC)=0,,17777.
 42668					;C(AC+1) SHOULD NOT BE AFFECTED
 42669
 42670	057471	200 01 0 00 070254 	C41500:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42671	057472	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42672	057473	242 01 0 00 777751 		LSH	1,-27		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
 42673									;RIGHT 27 OCTAL BIT POSITIONS
 42674	057474	312 01 0 00 071061 		CAME	1,[0,,17777]	;PASS IF C(AC)=0,17777
 42675						STOP^
 42676	057475	254 04 0 00 057476 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42677	057476	324 00 0 00 057477 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42678									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42679									;IN THE SUBTEST) TO LOOP ON ERROR^
 42680	057477	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42681						STOP^
 42682	057500	254 04 0 00 057501 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42683	057501	324 00 0 00 057502 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42684									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42685									;IN THE SUBTEST) TO LOOP ON ERROR^
 42686
 42687					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42688					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42689					;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42690					;SO THAT FINAL C(AC)=0,,5252.
 42691					;C(AC+1) SHOULD NOT BE AFFECTED
 42692
 42693	057502	200 01 0 00 070614 	C41600:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42694	057503	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42695	057504	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
 42696										;RIGHT 27 OCTAL BIT POSITIONS
 42697	057505	312 01 0 00 071062 		CAME	1,[0,,5252]		;PASS IF C(AC)=0,,5252
 42698						STOP^
 42699	057506	254 04 0 00 057507 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42700	057507	324 00 0 00 057510 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42701									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42702									;IN THE SUBTEST) TO LOOP ON ERROR^
 42703	057510	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42704						STOP^
 42705	057511	254 04 0 00 057512 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42706	057512	324 00 0 00 057513 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42707									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42708									;IN THE SUBTEST) TO LOOP ON ERROR^
 42709
 42710					;**********
 42711
 42712					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42713					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42714					;SO THAT FINAL C(AC)=0,,12525.
 42715					;C(AC+1) SHOULD NOT BE AFFECTED
 42716
 42717	057513	200 01 0 00 071035 	C41700:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42718	057514	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42719	057515	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
 42720										;RIGHT 27 OCTAL BIT POSITIONS
 42721	057516	312 01 0 00 071063 		CAME	1,[0,,12525]		;PASS IF C(AC)=0,,12525
 42722						STOP^
 42723	057517	254 04 0 00 057520 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42724	057520	324 00 0 00 057521 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42725									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42726									;IN THE SUBTEST) TO LOOP ON ERROR^
 42727	057521	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42728						STOP^
 42729	057522	254 04 0 00 057523 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42730	057523	324 00 0 00 057524 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42731									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42732									;IN THE SUBTEST) TO LOOP ON ERROR^
 42733
 42734					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42735					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42736					;IN THIS CASE, 230703,602700 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42737					;SO THAT FINAL C(AC)=0,,4616.
 42738					;C(AC+1) SHOULD NOT BE AFFECTED
 42739
 42740	057524	200 01 0 00 071036 	C42000:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,603700
 42741	057525	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42742	057526	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
 42743										;RIGHT 27 OCTAL BIT POSITIONS
 42744	057527	312 01 0 00 071064 		CAME	1,[0,,4616]		;PASS IF C(AC)=0,,4616
 42745						STOP^
 42746	057530	254 04 0 00 057531 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42747	057531	324 00 0 00 057532 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42748									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42749									;IN THE SUBTEST) TO LOOP ON ERROR^
 42750	057532	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42751						STOP^
 42752	057533	254 04 0 00 057534 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42753	057534	324 00 0 00 057535 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42754									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42755									;IN THE SUBTEST) TO LOOP ON ERROR^
 42756
 42757					;**********
 42758
 42759					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42760					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 27 OCTAL BIT POSITIONS
 42761					;SO THAT FINAL C(AC)=0,,174.
 42762					;C(AC+1) SHOULD NOT BE AFFECTED
 42763
 42764	057535	200 01 0 00 071040 	C42100:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
 42765	057536	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42766	057537	242 01 0 00 777751 		LSH	1,-27			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
 42767										;RIGHT 27 OCTAL BIT POSITIONS
 42768	057540	312 01 0 00 071065 		CAME	1,[0,,174]		;PASS IF C(AC)=0,,174
 42769						STOP^
 42770	057541	254 04 0 00 057542 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42771	057542	324 00 0 00 057543 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42772									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42773									;IN THE SUBTEST) TO LOOP ON ERROR^
 42774	057543	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42775						STOP^
 42776	057544	254 04 0 00 057545 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42777	057545	324 00 0 00 057546 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42778									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42779									;IN THE SUBTEST) TO LOOP ON ERROR^
 42780
 42781					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42782					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42783					;IN THIS CASE, 0,,0 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42784					;SO THAT FINAL C(AC)=0,,0.
 42785					;C(AC+1) SHOULD NOT BE AFFECTED
 42786
 42787	057546	200 01 0 00 070253 	C42200:	MOVE	1,[0,0]		;PRELOAD AC WITH 0,,0
 42788	057547	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42789	057550	242 01 0 00 777745 		LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT 0,,0
 42790									;RIGHT 33 OCTAL BIT POSITIONS
 42791	057551	312 01 0 00 070253 		CAME	1,[0,,0]	;PASS IF C(AC)=0,,0
 42792						STOP^
 42793	057552	254 04 0 00 057553 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42794	057553	324 00 0 00 057554 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42795									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42796									;IN THE SUBTEST) TO LOOP ON ERROR^
 42797	057554	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42798						STOP^
 42799	057555	254 04 0 00 057556 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42800	057556	324 00 0 00 057557 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42801									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42802									;IN THE SUBTEST) TO LOOP ON ERROR^
 42803
 42804					;**********
 42805
 42806					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42807					;IN THIS CASE, -1,,-1 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42808					;SO THAT FINAL C(AC)=0,,777.
 42809					;C(AC+1) SHOULD NOT BE AFFECTED
 42810
 42811	057557	200 01 0 00 070254 	C42300:	MOVE	1,[-1,,-1]	;PRELOAD AC WITH -1,,-1
 42812	057560	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42813	057561	242 01 0 00 777745 		LSH	1,-33		;*LSH SHOULD LOGICALLY SHIFT -1,,-1
 42814									;RIGHT 33 OCTAL BIT POSITIONS
 42815	057562	312 01 0 00 070262 		CAME	1,[0,,777]	;PASS IF C(AC)=0,,777
 42816						STOP^
 42817	057563	254 04 0 00 057564 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42818	057564	324 00 0 00 057565 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42819									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42820									;IN THE SUBTEST) TO LOOP ON ERROR^
 42821	057565	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42822						STOP^
 42823	057566	254 04 0 00 057567 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42824	057567	324 00 0 00 057570 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42825									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42826									;IN THE SUBTEST) TO LOOP ON ERROR^
 42827
 42828					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42829					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42830					;IN THIS CASE, 252525,,252525 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42831					;SO THAT FINAL C(AC)=0,,252.
 42832					;C(AC+1) SHOULD NOT BE AFFECTED
 42833
 42834	057570	200 01 0 00 070614 	C42400:	MOVE	1,[252525,,252525]	;PRELOAD AC WITH 252525,,252525
 42835	057571	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42836	057572	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 252525,,252525
 42837										;RIGHT 33 OCTAL BIT POSITIONS
 42838	057573	312 01 0 00 071056 		CAME	1,[0,,252]		;PASS IF C(AC)=0,,252
 42839						STOP^
 42840	057574	254 04 0 00 057575 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42841	057575	324 00 0 00 057576 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42842									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42843									;IN THE SUBTEST) TO LOOP ON ERROR^
 42844	057576	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42845						STOP^
 42846	057577	254 04 0 00 057600 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42847	057600	324 00 0 00 057601 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42848									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42849									;IN THE SUBTEST) TO LOOP ON ERROR^
 42850
 42851					;**********
 42852
 42853					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42854					;IN THIS CASE, 525252,,525252 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42855					;SO THAT FINAL C(AC)=0,,525.
 42856					;C(AC+1) SHOULD NOT BE AFFECTED
 42857
 42858	057601	200 01 0 00 071035 	C42500:	MOVE	1,[525252,,525252]	;PRELOAD AC WITH 525252,,525252
 42859	057602	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42860	057603	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 525252,,525252
 42861										;RIGHT 33 OCTAL BIT POSITIONS
 42862	057604	312 01 0 00 071057 		CAME	1,[0,,525]		;PASS IF C(AC)=0,525
 42863						STOP^
 42864	057605	254 04 0 00 057606 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42865	057606	324 00 0 00 057607 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42866									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42867									;IN THE SUBTEST) TO LOOP ON ERROR^
 42868	057607	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42869						STOP^
 42870	057610	254 04 0 00 057611 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42871	057611	324 00 0 00 057612 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42872									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42873									;IN THE SUBTEST) TO LOOP ON ERROR^
 42874
 42875					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 46
DFKAA7	MAC	13-Jan-89 10:22		TEST OF SHIFT/ROTATE INSTRUCTIONS USED IN THE ERROR HANDLER

 42876					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42877					;IN THIS CASE, 230703,,603700 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42878					;SO THAT FINAL C(AC)=0,,230.
 42879					;C(AC+1) SHOULD NOT BE AFFECTED
 42880
 42881	057612	200 01 0 00 071036 	C42600:	MOVE	1,[230703,,603700]	;PRELOAD AC WITH 230703,,603700
 42882	057613	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42883	057614	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 230703,,603700
 42884										;RIGHT 33 OCTAL BIT POSITIONS
 42885	057615	312 01 0 00 071060 		CAME	1,[0,,230]		;PASS IF C(AC)=0,,230
 42886						STOP^
 42887	057616	254 04 0 00 057617 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42888	057617	324 00 0 00 057620 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42889									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42890									;IN THE SUBTEST) TO LOOP ON ERROR^
 42891	057620	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42892						STOP^
 42893	057621	254 04 0 00 057622 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42894	057622	324 00 0 00 057623 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42895									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42896									;IN THE SUBTEST) TO LOOP ON ERROR^
 42897
 42898					;**********
 42899
 42900					;THIS TEST VERIFIES THAT THE LSH INSTRUCTION FUNCTIONS CORRECTLY
 42901					;IN THIS CASE, 007603,,607062 SHOULD BE LOGICALLY SHIFTED RIGHT 33 OCTAL BIT POSITIONS
 42902					;SO THAT FINAL C(AC)=0,,7.
 42903					;C(AC+1) SHOULD NOT BE AFFECTED
 42904
 42905	057623	200 01 0 00 071040 	C42700:	MOVE	1,[007603,,607062]	;PRELOAD AC WITH 007603,,607062
 42906	057624	200 02 0 00 071034 		MOVE	2,[172737,,405060]	;PRELOAD C(AC+1) WITH 172737,,405060
 42907	057625	242 01 0 00 777745 		LSH	1,-33			;*LSH SHOULD LOGICALLY SHIFT 007603,,607062
 42908										;RIGHT 33 OCTAL BIT POSITIONS
 42909	057626	312 01 0 00 071033 		CAME	1,[0,,7]		;PASS IF C(AC)=0,,7
 42910						STOP^
 42911	057627	254 04 0 00 057630 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42912	057630	324 00 0 00 057631 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42913									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42914									;IN THE SUBTEST) TO LOOP ON ERROR^
 42915	057631	312 02 0 00 071034 		CAME	2,[172737,,405060]	;PASS IF C(AC+1) NOT AFFECTED
 42916						STOP^
 42917	057632	254 04 0 00 057633 		HALT	.+1		;TEST FAILED IF PROGRAM HALTS HERE
 42918	057633	324 00 0 00 057634 		JUMPA	.+1		;IF TEST FAILS, CHANGE THIS INSTRUCTION (JUMPA .+1) TO
 42919									;JUMPA X (X IS THE ADDRESS OF THE FIRST INSTRUCTION
 42920									;IN THE SUBTEST) TO LOOP ON ERROR^
 42921
 42922					;**********
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
DFKAA8	MAC	13-Jan-89 10:22		PI/IOT/APR DIAGNOSTIC SECTION

 42923					SUBTTL	PI/IOT/APR DIAGNOSTIC SECTION
 42924
 42925	057634	402 00 0 00 030037 	BEGIOT:	SETZM	USER		;CLEAR USER CONTROL WORD
 42926	057635	265 00 0 00 057636 		JSP	0,.+1		;GET FLAGS
 42927	057636	603 00 0 00 010000 		TLNE	USERF		;IN USER MODE ?
 42928	057637	476 00 0 00 030037 		SETOM	USER		;YES, SET USER CONTROL WORD
 42929	057640	336 00 0 00 030042 		SKIPN	MONFLG		;SPECIAL USER MODE ?
 42930	057641	402 00 0 00 030037 		SETZM	USER		;YES, CLEAR USER CONTROL WORD
 42931	057642	336 00 0 00 030037 		SKIPN	USER
 42932	057643	254 00 0 00 057645 		JRST	IOT0		;RUN IOT TEST ONLY IN EXEC MODE
 42933
 42934	057644	254 00 0 00 030057 		JRST	BEGEND		;OTHERWISE START OVER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 2
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 42935					SUBTTL	MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS
 42936
 42937						LALL
 42938			000774			LAST=774		;LAST POSSIBLE DEVICE
 42939
 42940					;OPERATOR DEFINITIONS
 42941
 42942		264000	070120			OPDEF	TRPPI	[JSR	TRAPPI]	;FILL INTERRUPT LOCATIONS
 42943		264000	070103			OPDEF	HALTPI	[JSR	HALTPI]	;FILL INT. LOC. WITH HALTS
 42944		264000	070072			OPDEF	CLRTRP	[JSR	TRPCLR]	;CLEAR TRAPS
 42945
 42946						OPDEF	CLRAPR	[CONO APR,LIOCLR!LCSBER!LCNXER!LCPAER!LCIOPF!LCPWRF!LCCASD!LDSBER!LD
 42947		700200	267760		NXER!LDPAER!LDIOPF!LDPWRF!LDCASD!LCCAER!LDCAER!LCSAER!LDSAER]
 42948		700600	031577			OPDEF	CLRPI	[CONO PI,LRQCLR!PICLR!CHNOFF!PIOFF!177]
 42949
 42950					;MACROS
 42951
 42952						DEFINE	BLURB	<
 42953					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 42954					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 42955					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 42956					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 42957					>
 42958						DEFINE	BLURB1	<
 42959					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 42960					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 42961					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 42962					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 42963					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 42964					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 42965					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 42966					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 3
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 42967						DEFINE	WATINT	<
 42968						MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 42969						SOJG	13,.		;AND WAIT>
 42970
 42971						DEFINE	STOP2<
 42972						HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 42973						JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.>
 42974
 42975						DEFINE	TSET<
 42976						%X=.			;DEFINE %X TO SAVE
 42977						MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 42978						MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT>
 42979
 42980						DEFINE	TGET<
 42981						MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 42982						CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 42983						STOP2>
 42984
 42985						DEFINE	TBOTH<
 42986						TGET
 42987					
 42988						TSET>
 42989
 42990						DEFINE	PINO	(A,%NO)<
 42991					
 42992					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 42993					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 42994					
 42995						TSET
 42996					%NO:	CLRBTH
 42997						CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 42998						WATINT
 42999						CONSZ	PI,A		;CHECK WHY INT. IN PROGRESS IS SET.
 43000						STOP
 43001						TGET
 43002					>
 43003						DEFINE	PIYES	(A,B,%YES)<
 43004					
 43005					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 43006					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 43007					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 43008					
 43009						TSET
 43010					%YES:	CLRBTH
 43011						CONO	PI,REQSET+A	;SET CHANNEL REQUEST BUT NOT ACTIVE
 43012						WATINT
 43013						CONSZ	PI,B		;CHECK WHY INT. IN PROGRESS IS SET.
 43014						STOP
 43015						TGET
 43016					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 4
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 43017						DEFINE	PIHCLR	(A,B,%HCLR)<
 43018					
 43019					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 43020					
 43021						TSET
 43022					%HCLR:	CLRBTH
 43023						CONO	PI,REQSET+PION+A	;CAUSE INT. TO SET HOLD
 43024						WATINT
 43025						CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 43026						CONSZ	PI,B		;HOLD FLOP FAILED TO CLEAR.
 43027						STOP
 43028						TGET
 43029					>
 43030						DEFINE	PIONOF	(A,%ONOF)<
 43031					
 43032					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 43033					;AND THAT AN INTERUPT DOES NOT OCCUR
 43034					
 43035					BLURB1
 43036					
 43037						TSET
 43038					%ONOF:	CLRBTH
 43039						CONO	PI,REQSET+A	;SET REQ. BUT NOT ACTIVE
 43040						SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 43041						CONO	PI,PICLR+A	;PI RESET FAILED TO CLEAR PIR FLAG.
 43042						WATINT
 43043						SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 43044						STOP
 43045						TGET
 43046					>
 43047						DEFINE	PIDIS	(A,B,%PICHK)<
 43048					
 43049					;CHECK THAT A JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 43050					
 43051						TSET
 43052					%PICHK:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 43053						MOVEM	A		;INTO A
 43054						CONO	PI,CHNON+PION+REQSET+B	;TURN ON PI AND REQEST ON CH B
 43055						WATINT
 43056						JRST	.+3
 43057						CONO	PI,CHNON+PION+LRQCLR+B	;TURN OF INTERRUPT REQUEST
 43058						JEN	@1		;DISMISS THE INTERRUPT
 43059						CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 43060						STOP
 43061						TGET
 43062						CLRBTH
 43063					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 5
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 43064						DEFINE	PITEST	(A,%PITST)<
 43065					
 43066					;TEST SETTING OF CHANNEL FLOP
 43067					
 43068						TSET
 43069					%PITST:	CLRBTH
 43070						CONO	PI,CHNON+A	;PION FAILED TO SET
 43071						CONSO	PI,A
 43072						STOP
 43073						TBOTH
 43074						CLRBTH
 43075					;TEST CLEARING OF CHANNEL FLOP
 43076						CONO	PI,CHNON+A	;CHECK PIO CLR
 43077						CONO	PI,CHNOFF+A	;TURN OFF CHANNELS
 43078						CONSZ	PI,A		;CHECK WHY FLOP NOT CLEAR
 43079						STOP
 43080						TBOTH
 43081						CLRBTH
 43082					;CHECK RESETING OF PI SYSTEM
 43083						CONO	PI,CHNON+A	;CHECK THAT PI RESET CLEARS
 43084						CONO	PI,PICLR	;PI SYSTEM
 43085						CONSZ	PI,A
 43086						STOP
 43087						TBOTH
 43088						CLRBTH
 43089					;TEST THAT CONO ONLY SETS PION
 43090						CONO	PI,CHNON	;TEST PIO SET
 43091						CONSZ	PI,A		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 43092						STOP
 43093						TBOTH
 43094						CLRBTH
 43095					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 43096						CONO	PI,CHNON+A	;TEST PIO CLR
 43097						CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 43098						CONSO	PI,A		;BE SET
 43099						STOP
 43100						TGET
 43101					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 6
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 43102						DEFINE	EXECUT<
 43103					;FILL THE INTERRUPT LOCATIONS WITH "MOVEI'S"
 43104						MOVE	1,[MOVEI 42]	;STORE A MOVEI IN
 43105						MOVEM	1,(1)		;INTO 42-60
 43106						CAME	1,[MOVEI 57]
 43107						AOJA	1,.-2		;LOOP>
 43108
 43109						DEFINE	STOP<
 43110						HALT	.+1		;INSTRUCTION FAILED REPLACE
 43111						JRST	.+1		;WITH JRST BACK>
 43112
 43113						DEFINE	STOP1<
 43114						HALT	.+1		;UUO FAILED TO STORE MA BITS
 43115						JRST	.+1		;INTO RIGHT HALF OF 40>
 43116
 43117						DEFINE	XUUO	(X,Y,%XUO)<
 43118					
 43119					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 43120					;ARE CORRECT.
 43121					
 43122						MLUUO==X		;THE UUO TO BE EXECUTED
 43123						TSET
 43124					%XUO:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 43125						MOVEM	0,41		;IN TO 41
 43126						X			;EXECUTE A UUO
 43127						HALT	.+1		;UUO DID NOT TRAP TO FORTY
 43128						MOVEI	2,.-1		;GET UUO PC
 43129						ANDI	1,-1		;MASK FLAGS OUT
 43130						CAME	1,2		;PC CORRECT ?
 43131						HALT	.+1		;PC OF UUO NOT = TO PC STORED
 43132						MOVE	0,40		;GET UUO !
 43133						CAME	0,[X!0]		;CORRECT UUO STORED IN 40?
 43134						SKIPA			;NO
 43135						JRST	Y		;TESTS OK !
 43136						STOP1
 43137						TGET
 43138					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 7
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 43139						DEFINE	XUUOA	(X,%UUPC,%XUPC0,%XUPC1)<
 43140					
 43141					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 43142					
 43143						EFIELD==X		;"E" WE ARE TESTING FOR
 43144						TSET
 43145					%UUPC:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 43146						MOVEM	41		;INTO 41
 43147						1B8!X			;EXECUTE A UUO
 43148					%XUPC0:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 43149						MOVE	0,40		;GET UUO
 43150						ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 43151						CAIE	X		;MA BITS CORRECT?
 43152					%XUPC1:	STOP1
 43153						TGET
 43154					>
 43155
 43156						DEFINE	CLRBTH<
 43157						CLRAPR
 43158						CLRPI>
 43159
 43160						DEFINE	CLRBT1<
 43161						CLRAPR
 43162						CLRPI>
 43163
 43164						DEFINE	TRAP	(A,B)<
 43165						MOVE	[A]		;SET TRAP INSTRUCTION
 43166						MOVEM	B		;INTO TRAP LOCATION>
 43167
 43168						DEFINE	STUCK<
 43169						WATINT
 43170						JRST	.		;LOOOP ON SELF>
 43171
 43172						DEFINE	SBWAIT	(A,%CLKUP)<
 43173					%CLKUP:	CONO	APR,LESBER!LSSBER!A
 43174						STUCK>		;WAIT S BUS ERRORS
 43175						DEFINE	TRPCHK	(%TPC)<
 43176					%TPC:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 43177						JRST	.+3		;DONT IF STAND ALONE
 43178						JRSTF	@.+1		;AND RESTORE THEM
 43179						USERF,.+1		;NEW PC AND FLAGS>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 8
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 43180						DEFINE	XCHN2	(A,B,C)<
 43181					
 43182					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 43183					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 43184					;IF ERROR OCCURS CHECK "PIN" PRINT
 43185					
 43186						TRPCHK
 43187						CLRBTH
 43188						HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43189						MOVE	[JSP A]		;SET UP FOR CORRECT
 43190						MOVEM	B		;INTERRUPT TRAP
 43191						CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 43192						CONO	PI,REQSET!C	;REQUEST INTERRUPT ON TWO CHANNELS
 43193						STUCK
 43194					>
 43195						DEFINE	PSKPA	(A,B,%X)<
 43196					
 43197					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 43198					;AN INTERRUPT INSTRUCTION.
 43199					
 43200						CLRBTH
 43201						HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43202						MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 43203						MOVEM	A		;INTO TRAP LOCATION
 43204						MOVE	[JSP 1,%X]	;SECOND TRAP INSTRUCTION
 43205						MOVEM	A+1		;INTO SECOND PI INSTRUCTION
 43206						MOVEI	1		;SET AC TO NON ZERO
 43207						CONO	PI,REQSET!PION!CHNON!B ;REQUEST INTERRUPT ON CH B
 43208					
 43209					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 43210					
 43211						WATINT
 43212						STOP
 43213					%X:	CLRBTH
 43214						CAIE	2		;ONLY ONE AOSE PREFORMED?
 43215						STOP
 43216					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 9
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 43217						DEFINE	PSKPB	(A,B,%X)<
 43218					
 43219					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 43220					;THE INTERRUPT.
 43221					
 43222						CLRBTH
 43223						HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43224						MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 43225						MOVEM	A		;INTO TRAP LOCATION
 43226						MOVE	[JSP 1,%X]	;SECOND TRAP INSTRUCTION
 43227						MOVEM	A+1		;INTO SECOND PI INSTRUCTION
 43228						MOVEI	1		;SET AC TO NON ZERO
 43229						CONO	PI,REQSET!PION!CHNON!B ;REQUEST INTERRUPT ON CH B
 43230					
 43231					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 43232					
 43233						WATINT
 43234						STOP
 43235					%X:	CLRBTH
 43236						CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 43237						STOP
 43238					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 10
DFKAA8	MAC	13-Jan-89 10:22		MACRO'S OPDEFS AND SPECIAL FLAG DEFINITIONS

 43239						DEFINE	FMUUO	(A,%FMTST,%NOFM),<
 43240					
 43241					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 43242					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 43243					;CORRECT PC.
 43244					
 43245						AC=A			;TESTED AC
 43246					
 43247						TSET
 43248						MOVE	A,[XWD 1000,0]	;SET UP UUO INTO AC A TO EXECUTE
 43249						MOVE	13,[JSP 11,%FMTST] ;SET UP UUO TRAP INSTRUCTION
 43250						MOVEM	13,41		;INTO LOCATION 41
 43251						MOVE	A+1,[JRST %NOFM] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 43252						JRST	A		;GO EXECUTE  UUO
 43253					%NOFM:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 43254						JRST	.+1		;LOOP TO %FMUUO IF ERROR
 43255					%FMTST:	ANDI	11,-1		;MASK FLAGS
 43256						CAIE	11,A+1		;PC STORED SHOULD = A +1
 43257						STOP
 43258						TGET
 43259					>
 43260
 43261						DEFINE	INDPI	(A,B,%XX),<
 43262					
 43263					;GET OURSELVES INTO A TIGHT INDIRECT LOOP.
 43264					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 43265					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 43266					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 43267					
 43268						TSET
 43269						MOVEI	10,^D10		;TIMES TO DO THIS TEST
 43270						MOVEM	10,COUNTX#	;STORE IT
 43271						MOVE	10,[JSP 1,%XX]	;INTERRUPT TRAP INSTRUCTION
 43272						MOVEM	10,A		;STORE FOR INTERRUPT REQUEST
 43273						CLRBT1
 43274						CONO	PI,2377		;TURN ON PI AND CHANNELS
 43275						CONO	APR,LESBER!LSSBER!B	;ENABLE AND SET S BUS ERRORS,ENABLE CH B
 43276						JRST	@.		;LOOP
 43277						HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 43278					%XX:	TGET
 43279						ANDI	1,-1		;MASK PC BITS
 43280						CAIE	1,%XX-2		;WAS CORRECT PC STORED?
 43281						STOP
 43282						SOSE	COUNTX		;LOOP TEST
 43283						JEN	@1		;DISMISS INTERRUPT
 43284						CLRBTH
 43285					>
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 12
DFKAA8	MAC	13-Jan-89 10:22		IOT TESTING

 43286					SUBTTL	IOT TESTING
 43287
 43288					;IF IOT HANGS - CHECK ARRT AND ARLT CLR
 43289					;AND OR AR SIGN SMEAR..
 43290
 43291					;TEST THE IOT'S
 43292	057645				IOTXXX:
 43293
 43294	057645				IOTXX:
 43295	057645	264 00 00 00 070231 	IOT0:	JSR	TRPSET		;FILL THE TRAP LOCATIONS
 43296	057646	474 01 0 00 000000 		SETO	1,		;THE IOTS FAIL
 43297	057647	7 000 04 0 00 000001 		DATAI	1		;TO STORE C(E)
 43298	057650	7 000 24 0 00 000001 		CONI	1		;CHECK IR DECODE
 43299	057651	316 01 0 00 070254 		CAMN	1,[-1]		;IR IOT ,IOT0-T9 ,ET2
 43300						STOP^
 43301	057652	254 04 0 00 057653 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43302	057653	254 00 0 00 057654 		JRST	.+1		;WITH JRST BACK^
 43303
 43304	057654	200 01 0 00 071066 	IOT1:	MOVE	1,[123456654321]	;CHECK DATAI STORING C(E)
 43305	057655	7 000 04 0 00 000001 		DATAI	1		;CONTENTS OF LOC 1
 43306	057656	316 01 0 00 071066 		CAMN	1,[123456654321]	;NOT MODIFIED
 43307						STOP^
 43308	057657	254 04 0 00 057660 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43309	057660	254 00 0 00 057661 		JRST	.+1		;WITH JRST BACK^
 43310
 43311	057661	200 01 0 00 071066 	IOT2:	MOVE	1,[123456654321]	;CHECK CONI STOR THE CONTENTS OF "E" NOT SET OR
 43312	057662	7 000 24 0 00 000001 		CONI	1		;SAC INH NOT SET - CONTENTS OF LOC 1
 43313	057663	316 01 0 00 071066 		CAMN	1,[123456654321]	;NOT MODIFIED
 43314						STOP^
 43315	057664	254 04 0 00 057665 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43316	057665	254 00 0 00 057666 		JRST	.+1		;WITH JRST BACK^
 43317
 43318	057666	474 00 0 00 000000 	IOT3:	SETO			;CHECK SAC INH FOR
 43319	057667	7 000 24 0 00 000001 		CONI	1		;CONI LOC 0
 43320	057670	312 00 0 00 070254 		CAME	[-1]		;MODIFIED
 43321						STOP^
 43322	057671	254 04 0 00 057672 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43323	057672	254 00 0 00 057673 		JRST	.+1		;WITH JRST BACK^
 43324
 43325	057673	7 774 20 0 00 000000 	IOT4:	CONO	LAST,0		;CLEAR LAST DEV (774)
 43326	057674	7 774 24 0 00 000002 		CONI	LAST,2
 43327	057675	306 02 0 00 000002 		CAIN	2,2		;IOT GOT E OF LAST INST.
 43328						STOP^
 43329	057676	254 04 0 00 057677 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43330	057677	254 00 0 00 057700 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 13
DFKAA8	MAC	13-Jan-89 10:22		IOT TESTING

 43331	057700	7 774 14 0 00 070253 	IOT5:	DATAO	LAST,[0]	;AR CLR FAILED ON
 43332	057701	7 774 04 0 00 000003 		DATAI	LAST,3		;DATAI
 43333	057702	306 03 0 00 000003 		CAIN	3,3		;GET E AS DATA
 43334						STOP^
 43335	057703	254 04 0 00 057704 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43336	057704	254 00 0 00 057705 		JRST	.+1		;WITH JRST BACK^
 43337
 43338						TSET^
 43339			057705			%X=.			;DEFINE %X TO SAVE
 43340	057705	201 00 0 00 057705 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43341	057706	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43342	057707	400 00 0 00 000000 	IOT6:	SETZ			;CONSZ FAILED TO SKIP
 43343	057710	7 000 30 0 00 000000 		CONSZ			;CHECK PC CLOCK ENABLE AND AD=0 ON IOT CONSZ
 43344						STOP^
 43345	057711	254 04 0 00 057712 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43346	057712	254 00 0 00 057713 		JRST	.+1		;WITH JRST BACK^
 43347
 43348						TBOTH^
 43349						TGET^
 43350	057713	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43351	057714	302 00 0 00 057705 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43352						STOP2^^
 43353	057715	254 04 0 00 057716 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43354	057716	254 00 0 00 057717 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43355
 43356						TSET^^
 43357			057717			%X=.			;DEFINE %X TO SAVE
 43358	057717	201 00 0 00 057717 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43359	057720	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43360	057721	7 774 20 0 00 000000 	IOT7:	CONO	LAST,0		;CONSZ FAILED TO SKIP
 43361	057722	7 774 30 0 00 700000 		CONSZ	LAST,700000	;CHECK PC CLK EN AT ET2 ON IOT CONSZ
 43362						STOP^
 43363	057723	254 04 0 00 057724 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43364	057724	254 00 0 00 057725 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 14
DFKAA8	MAC	13-Jan-89 10:22		IOT TESTING

 43365						TBOTH^
 43366						TGET^
 43367	057725	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43368	057726	302 00 0 00 057717 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43369						STOP2^^
 43370	057727	254 04 0 00 057730 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43371	057730	254 00 0 00 057731 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43372
 43373						TSET^^
 43374			057731			%X=.			;DEFINE %X TO SAVE
 43375	057731	201 00 0 00 057731 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43376	057732	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43377	057733	7 774 20 0 00 000000 	IOT8:	CONO	LAST,0		;CONSO SKIPPED CHK PC CLK EN(0)
 43378	057734	7 774 34 0 00 000000 		CONSO	LAST,0		;AD=0, IOT CONSO
 43379	057735	334 00 0 00 000000 		SKIPA			;IOT CONSZ
 43380						STOP^
 43381	057736	254 04 0 00 057737 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43382	057737	254 00 0 00 057740 		JRST	.+1		;WITH JRST BACK^
 43383
 43384						TBOTH^
 43385						TGET^
 43386	057740	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43387	057741	302 00 0 00 057731 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43388						STOP2^^
 43389	057742	254 04 0 00 057743 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43390	057743	254 00 0 00 057744 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43391
 43392						TSET^^
 43393			057744			%X=.			;DEFINE %X TO SAVE
 43394	057744	201 00 0 00 057744 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43395	057745	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43396	057746	400 01 0 00 000000 	IOT9:	SETZ	1,		;CHK AD+1 TO BOTH ON IOT
 43397	057747	7 774 10 0 00 000001 		BLKO	LAST,1		;BLK, IF C(E)=0 THEN AD+1
 43398	057750	334 00 0 00 000000 		SKIPA			;BOTH OR ARFMAD(1) FAILED
 43399	057751	255 00 0 00 000000 		JFCL			;IF IR 12 FAILED TO SET
 43400	057752	312 01 0 00 070251 		CAME	1,[XWD 1,1]	;PROGRAM BLOWS MIND
 43401						STOP^
 43402	057753	254 04 0 00 057754 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43403	057754	254 00 0 00 057755 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15
DFKAA8	MAC	13-Jan-89 10:22		IOT TESTING

 43404						TBOTH^
 43405						TGET^
 43406	057755	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43407	057756	302 00 0 00 057744 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43408						STOP2^^
 43409	057757	254 04 0 00 057760 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43410	057760	254 00 0 00 057761 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43411
 43412						TSET^^
 43413			057761			%X=.			;DEFINE %X TO SAVE
 43414	057761	201 00 0 00 057761 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43415	057762	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43416	057763	255 00 0 00 000000 	IOT10:	JFCL
 43417						TBOTH^
 43418						TGET^
 43419	057764	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43420	057765	302 00 0 00 057761 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43421						STOP2^^
 43422	057766	254 04 0 00 057767 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43423	057767	254 00 0 00 057770 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43424
 43425						TSET^^
 43426			057770			%X=.			;DEFINE %X TO SAVE
 43427	057770	201 00 0 00 057770 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43428	057771	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43429	057772	400 01 0 00 000000 	IOT11:	SETZ	1,		;BLKO PC CLK EN AT ET2 FAILED
 43430	057773	7 774 10 0 00 000001 		BLKO	LAST,1		;BLKO SHOULD SKIP
 43431						STOP^
 43432	057774	254 04 0 00 057775 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43433	057775	254 00 0 00 057776 		JRST	.+1		;WITH JRST BACK^
 43434
 43435						TBOTH^
 43436						TGET^
 43437	057776	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43438	057777	302 00 0 00 057770 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43439						STOP2^^
 43440	060000	254 04 0 00 060001 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43441	060001	254 00 0 00 060002 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43442
 43443						TSET^^
 43444			060002			%X=.			;DEFINE %X TO SAVE
 43445	060002	201 00 0 00 060002 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43446	060003	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43447	060004	474 01 0 00 000000 	IOT12:	SETO	1,		;BLKO PREFORMED A SKIP
 43448	060005	7 774 10 0 00 000001 		BLKO	LAST,1		;PC CLK EN ASSERTED?
 43449	060006	334 00 0 00 000000 		SKIPA
 43450						STOP^
 43451	060007	254 04 0 00 060010 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43452	060010	254 00 0 00 060011 		JRST	.+1		;WITH JRST BACK^
 43453
 43454	060011	320 00 0 00 060012 	IOT13:	JUMP	.+1		;NEVER DO 13
 43455
 43456	060012	7 004 20 0 00 010000 	IOT14:	CONO	PI,10000	;CLR PI SYSTEM
 43457	060013	7 000 20 0 00 000077 		CONO	77		;SET SOME CPA BITS
 43458	060014	7 000 24 0 00 000000 		CONI	0		;IF FAILED EITHER CONO FAILED
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 15-1
DFKAA8	MAC	13-Jan-89 10:22		IOT TESTING

 43459	060015	336 00 0 00 000000 		SKIPN	0		;IO SET OR CONI FAILED READ
 43460						STOP^
 43461	060016	254 04 0 00 060017 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43462	060017	254 00 0 00 060020 		JRST	.+1		;WITH JRST BACK^
 43463									;OR ARRT OR ARLT EN OR AR SIGN
 43464									;SMEAR OR CPA SELECT NOT ASSERTED
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 16
DFKAA8	MAC	13-Jan-89 10:22		TEST APR FLAGS

 43465					SUBTTL	TEST APR FLAGS
 43466
 43467	060020	7 000 20 0 00 000000 	IOT15:	CONO			;APR CLOCK PIA FAILED EITHER
 43468	060021	7 000 20 0 00 000001 		CONO	1		;TO SET OR BE READ
 43469	060022	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 35 CLOCK
 43470	060023	606 00 0 00 000001 		TRNN	1
 43471						STOP^
 43472	060024	254 04 0 00 060025 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43473	060025	254 00 0 00 060026 		JRST	.+1		;WITH JRST BACK^
 43474
 43475	060026	7 000 20 0 00 000000 	IOT15A:	CONO			;APR CLOCK PIA FAILED EITHER
 43476	060027	7 000 20 0 00 000002 		CONO	2		;TO SET OR BE READ
 43477	060030	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 34 CLOCK
 43478	060031	606 00 0 00 000002 		TRNN	2
 43479						STOP^
 43480	060032	254 04 0 00 060033 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43481	060033	254 00 0 00 060034 		JRST	.+1		;WITH JRST BACK^
 43482
 43483	060034	7 000 20 0 00 000000 	IOT16:	CONO			;APR CLOCK PIA FAILED EITHER
 43484	060035	7 000 20 0 00 000004 		CONO	4		;TO SET OR BE READ
 43485	060036	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 33 CLOCK
 43486	060037	606 00 0 00 000004 		TRNN	4		;
 43487						STOP^
 43488	060040	254 04 0 00 060041 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43489	060041	254 00 0 00 060042 		JRST	.+1		;WITH JRST BACK^
 43490
 43491	060042	700 04 0 00 267760 	IOT16A:	CLRAPR
 43492	060043	7 000 20 0 00 010020 		CONO	APR,LSCASD	;TO SET OR BE READ
 43493	060044	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 32 ERROR
 43494	060045	606 00 0 00 000020 		TRNN	LCASWD
 43495						STOP^
 43496	060046	254 04 0 00 060047 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43497	060047	254 00 0 00 060050 		JRST	.+1		;WITH JRST BACK^
 43498
 43499	060050	700 04 0 00 267760 	IOT17:	CLRAPR			;APR ERROR PIA FAILED EITHER
 43500	060051	7 000 20 0 00 010040 		CONO	APR,LSPWRF		;TO SET OR BE READ
 43501	060052	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 31 ERROR
 43502	060053	606 00 0 00 000040 		TRNN	LPWRFL
 43503						STOP^
 43504	060054	254 04 0 00 060055 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43505	060055	254 00 0 00 060056 		JRST	.+1		;WITH JRST BACK^
 43506
 43507	060056	700 04 0 00 267760 	IOT17A:	CLRAPR			;APR ERROR PIA FAILED EITHER
 43508	060057	7 000 20 0 00 011000 		CONO	APR,LSIOPF		;TO SET OR BE READ
 43509	060060	7 000 24 0 00 000000 		CONI			;CHECK APR PIA 30 ERROR
 43510	060061	606 00 0 00 001000 		TRNN	LIOPFE
 43511						STOP^
 43512	060062	254 04 0 00 060063 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43513	060063	254 00 0 00 060064 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 17
DFKAA8	MAC	13-Jan-89 10:22		TEST APR FLAGS

 43514	060064	700 04 0 00 267760 	IOT18:	CLRAPR
 43515	060065	7 000 20 0 00 010400 		CONO	APR,LSPAER
 43516	060066	7 000 24 0 00 000000 		CONI	APR,
 43517	060067	606 00 0 00 000400 		TRNN	LPARER
 43518						STOP^
 43519	060070	254 04 0 00 060071 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43520	060071	254 00 0 00 060072 		JRST	.+1		;WITH JRST BACK^
 43521	060072	700 04 0 00 267760 		CLRAPR
 43522	060073	7 000 20 0 00 012000 		CONO	APR,LSNXER
 43523	060074	7 000 24 0 00 000000 		CONI	APR,
 43524	060075	606 00 0 00 002000 		TRNN	LNXMER
 43525						STOP^
 43526	060076	254 04 0 00 060077 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43527	060077	254 00 0 00 060100 		JRST	.+1		;WITH JRST BACK^
 43528	060100	700 04 0 00 267760 		CLRAPR
 43529	060101	7 000 20 0 00 014000 		CONO	APR,LSSBER
 43530	060102	7 000 24 0 00 000000 		CONI	APR,
 43531	060103	606 00 0 00 004000 		TRNN	LSBUSE
 43532						STOP^
 43533	060104	254 04 0 00 060105 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43534	060105	254 00 0 00 060106 		JRST	.+1		;WITH JRST BACK^
 43535	060106	700 04 0 00 267760 		CLRAPR
 43536
 43537	060107	7 000 20 0 00 000001 	IOT18A:	CONO	1
 43538	060110	7 000 20 0 00 000000 		CONO
 43539	060111	7 000 24 0 00 000000 		CONI
 43540	060112	602 00 0 00 000001 		TRNE	1
 43541						STOP^
 43542	060113	254 04 0 00 060114 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43543	060114	254 00 0 00 060115 		JRST	.+1		;WITH JRST BACK^
 43544	060115	7 000 20 0 00 000002 	IOT19:	CONO	2		;APR PIA 34 CLOCK
 43545	060116	7 000 20 0 00 000000 		CONO			;FAILED TO CLEAR
 43546	060117	7 000 24 0 00 000000 		CONI
 43547	060120	602 00 0 00 000002 		TRNE	2
 43548						STOP^
 43549	060121	254 04 0 00 060122 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43550	060122	254 00 0 00 060123 		JRST	.+1		;WITH JRST BACK^
 43551
 43552	060123	7 000 20 0 00 000004 	IOT20:	CONO	4		;APR PIA 33 CLOCK
 43553	060124	7 000 20 0 00 000000 		CONO			;FAILED TO CLEAR
 43554	060125	7 000 24 0 00 000000 		CONI
 43555	060126	602 00 0 00 000004 		TRNE	4
 43556						STOP^
 43557	060127	254 04 0 00 060130 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43558	060130	254 00 0 00 060131 		JRST	.+1		;WITH JRST BACK^
 43559
 43560	060131	7 000 20 0 00 010020 	IOT21:	CONO	APR,LSCASD		;APR PIA 32 ERROR
 43561	060132	7 000 20 0 00 020020 		CONO	APR,LCCASD		;FAILED TO CLEAR
 43562	060133	7 000 24 0 00 000000 		CONI
 43563	060134	602 00 0 00 000020 		TRNE	LCASWD
 43564						STOP^
 43565	060135	254 04 0 00 060136 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43566	060136	254 00 0 00 060137 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 18
DFKAA8	MAC	13-Jan-89 10:22		TEST APR FLAGS

 43567	060137	7 000 20 0 00 010040 	IOT22:	CONO	APR,LSPWRF		;APR PIA 31 ERROR
 43568	060140	7 000 20 0 00 020040 		CONO	APR,LCPWRF		;FAILED TO CLEAR
 43569	060141	7 000 24 0 00 000000 		CONI
 43570	060142	602 00 0 00 000040 		TRNE	LPWRFL
 43571						STOP^
 43572	060143	254 04 0 00 060144 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43573	060144	254 00 0 00 060145 		JRST	.+1		;WITH JRST BACK^
 43574
 43575	060145	7 000 20 0 00 011000 	IOT23:	CONO	APR,LSIOPF		;APR PIA 30 ERROR
 43576	060146	7 000 20 0 00 021000 		CONO	APR,LCIOPF		;FAILED TO CLEAR
 43577	060147	7 000 24 0 00 000000 		CONI
 43578	060150	602 00 0 00 001000 		TRNE	LIOPFE
 43579						STOP^
 43580	060151	254 04 0 00 060152 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43581	060152	254 00 0 00 060153 		JRST	.+1		;WITH JRST BACK^
 43582	060153	7 000 20 0 00 010400 		CONO	APR,LSPAER
 43583	060154	7 000 20 0 00 020400 		CONO	APR,LCPAER
 43584	060155	7 000 24 0 00 000000 		CONI
 43585	060156	602 00 0 00 000400 		TRNE	LPARER
 43586	060157	7 000 20 0 00 012000 		CONO	APR,LSNXER
 43587	060160	7 000 20 0 00 022000 		CONO	APR,LCNXER
 43588	060161	7 000 24 0 00 000000 		CONI
 43589	060162	602 00 0 00 002000 		TRNE	LNXMER
 43590	060163	7 000 20 0 00 014000 		CONO	APR,LSSBER
 43591	060164	7 000 20 0 00 024000 		CONO	APR,LCSBER
 43592	060165	7 000 24 0 00 000000 		CONI
 43593	060166	602 00 0 00 004000 		TRNE	LSBUSE
 43594						STOP^
 43595	060167	254 04 0 00 060170 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43596	060170	254 00 0 00 060171 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 19
DFKAA8	MAC	13-Jan-89 10:22		TEST APR FLAGS

 43597						TBOTH^
 43598						TGET^
 43599	060171	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43600	060172	302 00 0 00 060002 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43601						STOP2^^
 43602	060173	254 04 0 00 060174 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43603	060174	254 00 0 00 060175 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43604
 43605						TSET^^
 43606			060175			%X=.			;DEFINE %X TO SAVE
 43607	060175	201 00 0 00 060175 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43608	060176	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43609	060177	7 000 20 0 00 000007 	IOT24:	CONO	7		;SET SOME FLAGS
 43610	060200	7 000 34 0 00 000000 		CONSO			;CONSO FAILED CK PC CLOCK ENABLE
 43611	060201	334 00 0 00 000000 		SKIPA			;INH
 43612						STOP^
 43613	060202	254 04 0 00 060203 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43614	060203	254 00 0 00 060204 		JRST	.+1		;WITH JRST BACK^
 43615
 43616						TBOTH^
 43617						TGET^
 43618	060204	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43619	060205	302 00 0 00 060175 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43620						STOP2^^
 43621	060206	254 04 0 00 060207 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43622	060207	254 00 0 00 060210 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43623
 43624						TSET^^
 43625			060210			%X=.			;DEFINE %X TO SAVE
 43626	060210	201 00 0 00 060210 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43627	060211	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43628	060212	7 000 20 0 00 000007 	IOT25:	CONO	7		;SET SOME FLAGS
 43629	060213	7 000 34 0 00 000007 		CONSO	7		;CONSO FAILED CH PC CLOCK ENABLE
 43630						STOP^
 43631	060214	254 04 0 00 060215 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43632	060215	254 00 0 00 060216 		JRST	.+1		;WITH JRST BACK^
 43633
 43634						TBOTH^
 43635						TGET^
 43636	060216	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43637	060217	302 00 0 00 060210 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43638						STOP2^^
 43639	060220	254 04 0 00 060221 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43640	060221	254 00 0 00 060222 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43641
 43642						TSET^^
 43643			060222			%X=.			;DEFINE %X TO SAVE
 43644	060222	201 00 0 00 060222 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43645	060223	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43646	060224	7 000 20 0 00 000007 	IOT26:	CONO	7		;CONSZ FAILED
 43647	060225	7 000 30 0 00 000007 		CONSZ	7		;CK PC CLOCK ENABLE IF AD=0
 43648	060226	334 00 0 00 000000 		SKIPA			;AND IOT TIME
 43649						STOP^
 43650	060227	254 04 0 00 060230 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43651	060230	254 00 0 00 060231 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 20
DFKAA8	MAC	13-Jan-89 10:22		TEST APR FLAGS

 43652						TBOTH^
 43653						TGET^
 43654	060231	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43655	060232	302 00 0 00 060222 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43656						STOP2^^
 43657	060233	254 04 0 00 060234 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43658	060234	254 00 0 00 060235 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43659
 43660						TSET^^
 43661			060235			%X=.			;DEFINE %X TO SAVE
 43662	060235	201 00 0 00 060235 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43663	060236	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43664	060237	254 00 0 00 060267 		JRST	IOT31A
 43665	060240	7 000 20 0 00 004000 	IOT27:	CONO	CLKDIS		;DISABLE CLOCK THEN ENABLE
 43666	060241	7 000 20 0 00 002000 		CONO	CLKENB		;FAILS IF CLOCK ENABLE NOT SET.
 43667	060242	7 000 34 0 00 002000 		CONSO	2000		;SET
 43668						STOP^
 43669	060243	254 04 0 00 060244 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43670	060244	254 00 0 00 060245 		JRST	.+1		;WITH JRST BACK^
 43671	060245	254 00 0 00 060246 		JRST	.+1
 43672
 43673	060246	7 000 20 0 00 002000 	IOT28:	CONO	2000		;CK CLK EN FOR NOT
 43674	060247	7 000 20 0 00 004000 		CONO	4000		;CLEARING
 43675	060250	7 000 30 0 00 002000 		CONSZ	2000
 43676						STOP^
 43677	060251	254 04 0 00 060252 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43678	060252	254 00 0 00 060253 		JRST	.+1		;WITH JRST BACK^
 43679
 43680					;THE NEXT TWO TESTS ARE NOT DONE IF WE ARE DOING
 43681					;MARGINS, BECAUSE THE DATAO IN THE NEXT TEST WILL CLEAR
 43682					;THE MARGIN WORD, AND THE TEST FOLLOWING MAY NOT BE ASSURED
 43683					;THAT THE CONSOLE SWITCHES 30-35 WILL BE = 0
 43684
 43685	060253	332 00 0 00 030055 	IOT29:	SKIPE	MARGIN		;ARE DOING MARGINS?
 43686	060254	254 00 0 00 060267 		JRST	IOT31A		;YEP SKIP THIS
 43687	060255	7 000 20 0 00 000077 		CONO	APR,77		;SET SOME BITS
 43688	060256	7 000 14 0 00 000000 		DATAO	APR,0		;TRY TO CLEAR VIA DATAO
 43689	060257	7 000 34 0 00 000077 		CONSO	APR,77		;BITS SHOULD STILL BE SET
 43690						STOP^
 43691	060260	254 04 0 00 060261 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43692	060261	254 00 0 00 060262 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 21
DFKAA8	MAC	13-Jan-89 10:22		TEST APR FLAGS

 43693	060262	7 000 20 0 00 000077 	IOT30:	CONO	APR,77		;SET SOME CPA BITS
 43694	060263	7 000 04 0 00 000000 		DATAI	APR,0		;GET DATA SWITCHES
 43695	060264	602 00 0 00 000077 		TRNE	0,77		;DATAI DECODED AS CONI
 43696						STOP^
 43697	060265	254 04 0 00 060266 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43698	060266	254 00 0 00 060267 		JRST	.+1		;WITH JRST BACK^
 43699
 43700	060267				IOT31A:	TBOTH^
 43701						TGET^
 43702	060267	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43703	060270	302 00 0 00 060235 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43704						STOP2^^
 43705	060271	254 04 0 00 060272 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43706	060272	254 00 0 00 060273 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43707
 43708						TSET^^
 43709			060273			%X=.			;DEFINE %X TO SAVE
 43710	060273	201 00 0 00 060273 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43711	060274	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43712	060275	254 02 1 00 060276 	IOT31:	JRSTF	@.+1		;SET BIS FLAG VIA JRSTF
 43713	060276	000000	060277			BIS,.+1			;BYTF6 AND NEW PC
 43714	060277	7 774 14 0 00 000000 		DATAO	LAST,		;TRY TO CLEAR BIS FLAG VIA DATAO
 43715	060300	265 00 0 00 060301 		JSP	.+1		;GET CPU FLAGS(BIS) SHOULD BE CLEAR
 43716	060301	603 00 0 00 020000 		TLNE	BIS		;AT ET2 OF THE IOT
 43717						STOP^
 43718	060302	254 04 0 00 060303 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43719	060303	254 00 0 00 060304 		JRST	.+1		;WITH JRST BACK^
 43720						TGET^
 43721	060304	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43722	060305	302 00 0 00 060273 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43723						STOP2^^
 43724	060306	254 04 0 00 060307 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43725	060307	254 00 0 00 060310 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43726	060310	255 00 0 00 000000 	IOT32:	JFCL
 43727	060311	254 00 0 00 060312 		JRST	IOT33B
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 22
DFKAA8	MAC	13-Jan-89 10:22		TEST PI FLAGS

 43728					SUBTTL	TEST PI FLAGS
 43729
 43730	060312	7 000 20 0 00 000007 	IOT33B:	CONO	7		;CONO PI MODIFIED
 43731	060313	7 004 20 0 00 000000 		CONO	PI,0		;CPU AS A DEVICE
 43732	060314	7 000 34 0 00 000007 		CONSO	7		;CPA SELECT IS CONFUSED
 43733						STOP^
 43734	060315	254 04 0 00 060316 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43735	060316	254 00 0 00 060317 		JRST	.+1		;WITH JRST BACK^
 43736	060317	7 000 20 0 00 000000 		CONO	0		;RESET BITS
 43737
 43738	060320	7 004 20 0 00 000200 	IOT34:	CONO	PI,200		;CHK WHY PI ON
 43739	060321	7 004 24 0 00 000000 		CONI	PI,		;FLOP NOT SET
 43740	060322	606 00 0 00 000200 		TRNN	200
 43741						STOP^
 43742	060323	254 04 0 00 060324 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43743	060324	254 00 0 00 060325 		JRST	.+1		;WITH JRST BACK^
 43744
 43745	060325	7 004 20 0 00 000200 	IOT35:	CONO	PI,200		;CHK WHY PI ON
 43746	060326	7 004 20 0 00 000400 		CONO	PI,400		;NOT CLEARED
 43747	060327	7 004 24 0 00 000000 		CONI	PI,		;
 43748	060330	602 00 0 00 000200 		TRNE	200
 43749						STOP^
 43750	060331	254 04 0 00 060332 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43751	060332	254 00 0 00 060333 		JRST	.+1		;WITH JRST BACK^
 43752
 43753	060333				IOT36:
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 23
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 43754					SUBTTL	BASIC PI SYSTEM TESTING
 43755
 43756					;BEGIN TESTING THE PI SYSTEM
 43757						BLURB^
 43758					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 43759					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 43760					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 43761					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 43762					^
 43763					;AND THE PROGRAM WILL HALT POINTING TO THE INTERUPTED ADRESS.
 43764	060333	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 43765
 43766
 43767	060334	7 004 20 0 00 002001 	IOT38:	CONO	PI,2001		;PI CHANNEL 7
 43768	060335	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43769	060336	606 00 0 00 000001 		TRNN	1		;
 43770						STOP^
 43771	060337	254 04 0 00 060340 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43772	060340	254 00 0 00 060341 		JRST	.+1		;WITH JRST BACK^
 43773
 43774	060341	7 004 20 0 00 002001 	IOT39:	CONO	PI,2001		;PI CHANNEL 7
 43775	060342	7 004 20 0 00 001001 		CONO	PI,1001		;FAILED TO CLEAR
 43776	060343	7 000 24 0 00 000000 		CONI
 43777	060344	602 00 0 00 000001 		TRNE	1
 43778						STOP^
 43779	060345	254 04 0 00 060346 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43780	060346	254 00 0 00 060347 		JRST	.+1		;WITH JRST BACK^
 43781
 43782	060347	7 004 20 0 00 002002 	IOT40:	CONO	PI,2002		;PI CHANNEL 6
 43783	060350	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43784	060351	606 00 0 00 000002 		TRNN	2
 43785						STOP^
 43786	060352	254 04 0 00 060353 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43787	060353	254 00 0 00 060354 		JRST	.+1		;WITH JRST BACK^
 43788
 43789	060354	7 004 20 0 00 002002 	IOT41:	CONO	PI,2002		;PI CHANNEL 6
 43790	060355	7 004 20 0 00 001002 		CONO	PI,1002		;FAILED TO CLEAR
 43791	060356	7 004 24 0 00 000000 		CONI	PI,
 43792	060357	602 00 0 00 000002 		TRNE	2
 43793						STOP^
 43794	060360	254 04 0 00 060361 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43795	060361	254 00 0 00 060362 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 24
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 43796	060362	7 004 20 0 00 002004 	IOT42:	CONO	PI,2004		;PI CHANNEL 5
 43797	060363	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43798	060364	606 00 0 00 000004 		TRNN	4
 43799						STOP^
 43800	060365	254 04 0 00 060366 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43801	060366	254 00 0 00 060367 		JRST	.+1		;WITH JRST BACK^
 43802
 43803	060367	7 004 20 0 00 002004 	IOT43:	CONO	PI,2004		;PI CHANNEL 5
 43804	060370	7 004 20 0 00 001004 		CONO	PI,1004		;FAILED TO CLEAR
 43805	060371	7 004 24 0 00 000000 		CONI	PI,
 43806	060372	602 00 0 00 000004 		TRNE	4
 43807						STOP^
 43808	060373	254 04 0 00 060374 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43809	060374	254 00 0 00 060375 		JRST	.+1		;WITH JRST BACK^
 43810
 43811	060375	7 004 20 0 00 002010 	IOT44:	CONO	PI,2010		;PI CHANNEL 4
 43812	060376	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43813	060377	606 00 0 00 000010 		TRNN	10
 43814						STOP^
 43815	060400	254 04 0 00 060401 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43816	060401	254 00 0 00 060402 		JRST	.+1		;WITH JRST BACK^
 43817
 43818	060402	7 004 20 0 00 002010 	IOT45:	CONO	PI,2010		;PI CHAN 4
 43819	060403	7 004 20 0 00 001010 		CONO	PI,1010		;FAILED TO CLEAR
 43820	060404	7 004 24 0 00 000000 		CONI	PI,
 43821	060405	602 00 0 00 000010 		TRNE	10
 43822						STOP^
 43823	060406	254 04 0 00 060407 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43824	060407	254 00 0 00 060410 		JRST	.+1		;WITH JRST BACK^
 43825
 43826	060410	7 004 20 0 00 002020 	IOT46:	CONO	PI,2020		;PI CHAN 3
 43827	060411	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43828	060412	606 00 0 00 000020 		TRNN	20
 43829						STOP^
 43830	060413	254 04 0 00 060414 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43831	060414	254 00 0 00 060415 		JRST	.+1		;WITH JRST BACK^
 43832
 43833	060415	7 004 20 0 00 002020 	IOT47:	CONO	PI,2020		;PI CHAN 3
 43834	060416	7 004 20 0 00 001020 		CONO	PI,1020		;FAILED TO CLEAR
 43835	060417	7 004 24 0 00 000000 		CONI	PI,
 43836	060420	602 00 0 00 000010 		TRNE	10
 43837						STOP^
 43838	060421	254 04 0 00 060422 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43839	060422	254 00 0 00 060423 		JRST	.+1		;WITH JRST BACK^
 43840
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 25
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 43841	060423	7 004 20 0 00 002040 	IOT48:	CONO	PI,2040		;PI CHAN 2
 43842	060424	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43843	060425	606 00 0 00 000040 		TRNN	40
 43844						STOP^
 43845	060426	254 04 0 00 060427 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43846	060427	254 00 0 00 060430 		JRST	.+1		;WITH JRST BACK^
 43847
 43848	060430	7 004 20 0 00 002040 	IOT49:	CONO	PI,2040		;PI CHAN 2
 43849	060431	7 004 20 0 00 001040 		CONO	PI,1040		;FAILED TO CLR
 43850	060432	7 004 24 0 00 000000 		CONI	PI,
 43851	060433	602 00 0 00 000040 		TRNE	40
 43852						STOP^
 43853	060434	254 04 0 00 060435 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43854	060435	254 00 0 00 060436 		JRST	.+1		;WITH JRST BACK^
 43855
 43856	060436	7 004 20 0 00 002100 	IOT50:	CONO	PI,2100		;PI CHAN 1
 43857	060437	7 004 24 0 00 000000 		CONI	PI,		;FAILED TO SET
 43858	060440	606 00 0 00 000100 		TRNN	100
 43859						STOP^
 43860	060441	254 04 0 00 060442 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43861	060442	254 00 0 00 060443 		JRST	.+1		;WITH JRST BACK^
 43862
 43863	060443	7 004 20 0 00 002100 	IOT51:	CONO	PI,2100		;PI CHAN 1
 43864	060444	7 004 20 0 00 001100 		CONO	PI,1100		;FAILED TO CLEAR
 43865	060445	7 004 24 0 00 000000 		CONI	PI,
 43866	060446	602 00 0 00 000100 		TRNE	100
 43867						STOP^
 43868	060447	254 04 0 00 060450 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43869	060450	254 00 0 00 060451 		JRST	.+1		;WITH JRST BACK^
 43870
 43871	060451	255 00 0 00 000000 	IOTXYZ:	JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 43872			040000			X=40000
 43873						BLURB^
 43874					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 43875					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 43876					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 43877					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 43878					^
 43879	060452	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 43880					PIOT00:	REPEAT	7,
 43881					<	PINO	X
 43882						X=X_-1>
 43883						PINO	X^
 43884
 43885					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43886					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43887
 43888						TSET^
 43889			060453			%X=.			;DEFINE %X TO SAVE
 43890	060453	201 00 0 00 060453 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43891	060454	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43892	060455				..0001:	CLRBTH^
 43893	060455	700 04 0 00 267760 		CLRAPR
 43894	060456	700 14 0 00 031577 		CLRPI^
 43895	060457	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43896						WATINT^
 43897	060460	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 43898	060461	367 13 0 00 060461 		SOJG	13,.		;AND WAIT^
 43899	060462	7 004 30 0 00 040000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43900						STOP^
 43901	060463	254 04 0 00 060464 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43902	060464	254 00 0 00 060465 		JRST	.+1		;WITH JRST BACK^
 43903						TGET^
 43904	060465	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43905	060466	302 00 0 00 060453 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43906						STOP2^^
 43907	060467	254 04 0 00 060470 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43908	060470	254 00 0 00 060471 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43909					^
 43910			020000			X=X_-1
 43911						PINO	X^
 43912
 43913					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43914					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43915
 43916						TSET^
 43917			060471			%X=.			;DEFINE %X TO SAVE
 43918	060471	201 00 0 00 060471 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43919	060472	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43920	060473				..0002:	CLRBTH^
 43921	060473	700 04 0 00 267760 		CLRAPR
 43922	060474	700 14 0 00 031577 		CLRPI^
 43923	060475	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43924						WATINT^
 43925	060476	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 43926	060477	367 13 0 00 060477 		SOJG	13,.		;AND WAIT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-1
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 43927	060500	7 004 30 0 00 020000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43928						STOP^
 43929	060501	254 04 0 00 060502 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43930	060502	254 00 0 00 060503 		JRST	.+1		;WITH JRST BACK^
 43931						TGET^
 43932	060503	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43933	060504	302 00 0 00 060471 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43934						STOP2^^
 43935	060505	254 04 0 00 060506 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43936	060506	254 00 0 00 060507 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43937					^
 43938			010000			X=X_-1
 43939						PINO	X^
 43940
 43941					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43942					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43943
 43944						TSET^
 43945			060507			%X=.			;DEFINE %X TO SAVE
 43946	060507	201 00 0 00 060507 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43947	060510	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43948	060511				..0003:	CLRBTH^
 43949	060511	700 04 0 00 267760 		CLRAPR
 43950	060512	700 14 0 00 031577 		CLRPI^
 43951	060513	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43952						WATINT^
 43953	060514	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 43954	060515	367 13 0 00 060515 		SOJG	13,.		;AND WAIT^
 43955	060516	7 004 30 0 00 010000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43956						STOP^
 43957	060517	254 04 0 00 060520 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43958	060520	254 00 0 00 060521 		JRST	.+1		;WITH JRST BACK^
 43959						TGET^
 43960	060521	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43961	060522	302 00 0 00 060507 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43962						STOP2^^
 43963	060523	254 04 0 00 060524 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43964	060524	254 00 0 00 060525 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43965					^
 43966			004000			X=X_-1
 43967						PINO	X^
 43968
 43969					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43970					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43971
 43972						TSET^
 43973			060525			%X=.			;DEFINE %X TO SAVE
 43974	060525	201 00 0 00 060525 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 43975	060526	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 43976	060527				..0004:	CLRBTH^
 43977	060527	700 04 0 00 267760 		CLRAPR
 43978	060530	700 14 0 00 031577 		CLRPI^
 43979	060531	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 43980						WATINT^
 43981	060532	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-2
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 43982	060533	367 13 0 00 060533 		SOJG	13,.		;AND WAIT^
 43983	060534	7 004 30 0 00 004000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 43984						STOP^
 43985	060535	254 04 0 00 060536 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 43986	060536	254 00 0 00 060537 		JRST	.+1		;WITH JRST BACK^
 43987						TGET^
 43988	060537	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 43989	060540	302 00 0 00 060525 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 43990						STOP2^^
 43991	060541	254 04 0 00 060542 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 43992	060542	254 00 0 00 060543 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 43993					^
 43994			002000			X=X_-1
 43995						PINO	X^
 43996
 43997					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 43998					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 43999
 44000						TSET^
 44001			060543			%X=.			;DEFINE %X TO SAVE
 44002	060543	201 00 0 00 060543 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44003	060544	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44004	060545				..0005:	CLRBTH^
 44005	060545	700 04 0 00 267760 		CLRAPR
 44006	060546	700 14 0 00 031577 		CLRPI^
 44007	060547	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 44008						WATINT^
 44009	060550	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44010	060551	367 13 0 00 060551 		SOJG	13,.		;AND WAIT^
 44011	060552	7 004 30 0 00 002000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44012						STOP^
 44013	060553	254 04 0 00 060554 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44014	060554	254 00 0 00 060555 		JRST	.+1		;WITH JRST BACK^
 44015						TGET^
 44016	060555	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44017	060556	302 00 0 00 060543 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44018						STOP2^^
 44019	060557	254 04 0 00 060560 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44020	060560	254 00 0 00 060561 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44021					^
 44022			001000			X=X_-1
 44023						PINO	X^
 44024
 44025					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 44026					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 44027
 44028						TSET^
 44029			060561			%X=.			;DEFINE %X TO SAVE
 44030	060561	201 00 0 00 060561 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44031	060562	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44032	060563				..0006:	CLRBTH^
 44033	060563	700 04 0 00 267760 		CLRAPR
 44034	060564	700 14 0 00 031577 		CLRPI^
 44035	060565	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 44036						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 26-3
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44037	060566	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44038	060567	367 13 0 00 060567 		SOJG	13,.		;AND WAIT^
 44039	060570	7 004 30 0 00 001000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44040						STOP^
 44041	060571	254 04 0 00 060572 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44042	060572	254 00 0 00 060573 		JRST	.+1		;WITH JRST BACK^
 44043						TGET^
 44044	060573	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44045	060574	302 00 0 00 060561 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44046						STOP2^^
 44047	060575	254 04 0 00 060576 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44048	060576	254 00 0 00 060577 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44049					^
 44050			000400			X=X_-1
 44051						PINO	X^
 44052
 44053					;ENABLE THE PI SYSTEM. AND EXPECT NO INTERRUPTS. THEN TEST THAT THE
 44054					;HOLD FLOP FOR EACH CHANNEL IS NOT SET.
 44055
 44056						TSET^
 44057			060577			%X=.			;DEFINE %X TO SAVE
 44058	060577	201 00 0 00 060577 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44059	060600	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44060	060601				..0007:	CLRBTH^
 44061	060601	700 04 0 00 267760 		CLRAPR
 44062	060602	700 14 0 00 031577 		CLRPI^
 44063	060603	7 004 20 0 00 000200 		CONO	PI,PION		;ENABLE PI AND ,EXPECT NO INTERRUPTS
 44064						WATINT^
 44065	060604	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44066	060605	367 13 0 00 060605 		SOJG	13,.		;AND WAIT^
 44067	060606	7 004 30 0 00 000400 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44068						STOP^
 44069	060607	254 04 0 00 060610 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44070	060610	254 00 0 00 060611 		JRST	.+1		;WITH JRST BACK^
 44071						TGET^
 44072	060611	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44073	060612	302 00 0 00 060577 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44074						STOP2^^
 44075	060613	254 04 0 00 060614 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44076	060614	254 00 0 00 060615 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44077					^
 44078			000200			X=X_-1
 44079	060615	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44080						BLURB^
 44081					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 44082					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 44083					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 44084					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 44085					^
 44086
 44087	060616	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 44088			040000			X=40000
 44089			000100			Y=100
 44090	060617				PIOT01:
 44091						REPEAT	7,<
 44092						PIYES	Y,X
 44093						X=X_-1
 44094						Y=Y_-1
 44095					>
 44096
 44097						PIYES	Y,X^
 44098
 44099					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44100					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44101					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44102
 44103						TSET^
 44104			060617			%X=.			;DEFINE %X TO SAVE
 44105	060617	201 00 0 00 060617 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44106	060620	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44107	060621				..0010:	CLRBTH^
 44108	060621	700 04 0 00 267760 		CLRAPR
 44109	060622	700 14 0 00 031577 		CLRPI^
 44110	060623	7 004 20 0 00 004100 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44111						WATINT^
 44112	060624	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44113	060625	367 13 0 00 060625 		SOJG	13,.		;AND WAIT^
 44114	060626	7 004 30 0 00 040000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44115						STOP^
 44116	060627	254 04 0 00 060630 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44117	060630	254 00 0 00 060631 		JRST	.+1		;WITH JRST BACK^
 44118						TGET^
 44119	060631	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44120	060632	302 00 0 00 060617 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44121						STOP2^^
 44122	060633	254 04 0 00 060634 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44123	060634	254 00 0 00 060635 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44124					^
 44125			020000			X=X_-1
 44126			000040			Y=Y_-1
 44127
 44128
 44129						PIYES	Y,X^
 44130
 44131					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44132					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44133					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44134
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-1
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44135						TSET^
 44136			060635			%X=.			;DEFINE %X TO SAVE
 44137	060635	201 00 0 00 060635 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44138	060636	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44139	060637				..0011:	CLRBTH^
 44140	060637	700 04 0 00 267760 		CLRAPR
 44141	060640	700 14 0 00 031577 		CLRPI^
 44142	060641	7 004 20 0 00 004040 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44143						WATINT^
 44144	060642	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44145	060643	367 13 0 00 060643 		SOJG	13,.		;AND WAIT^
 44146	060644	7 004 30 0 00 020000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44147						STOP^
 44148	060645	254 04 0 00 060646 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44149	060646	254 00 0 00 060647 		JRST	.+1		;WITH JRST BACK^
 44150						TGET^
 44151	060647	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44152	060650	302 00 0 00 060635 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44153						STOP2^^
 44154	060651	254 04 0 00 060652 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44155	060652	254 00 0 00 060653 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44156					^
 44157			010000			X=X_-1
 44158			000020			Y=Y_-1
 44159
 44160
 44161						PIYES	Y,X^
 44162
 44163					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44164					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44165					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44166
 44167						TSET^
 44168			060653			%X=.			;DEFINE %X TO SAVE
 44169	060653	201 00 0 00 060653 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44170	060654	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44171	060655				..0012:	CLRBTH^
 44172	060655	700 04 0 00 267760 		CLRAPR
 44173	060656	700 14 0 00 031577 		CLRPI^
 44174	060657	7 004 20 0 00 004020 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44175						WATINT^
 44176	060660	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44177	060661	367 13 0 00 060661 		SOJG	13,.		;AND WAIT^
 44178	060662	7 004 30 0 00 010000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44179						STOP^
 44180	060663	254 04 0 00 060664 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44181	060664	254 00 0 00 060665 		JRST	.+1		;WITH JRST BACK^
 44182						TGET^
 44183	060665	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44184	060666	302 00 0 00 060653 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44185						STOP2^^
 44186	060667	254 04 0 00 060670 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44187	060670	254 00 0 00 060671 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44188					^
 44189			004000			X=X_-1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-2
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44190			000010			Y=Y_-1
 44191
 44192
 44193						PIYES	Y,X^
 44194
 44195					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44196					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44197					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44198
 44199						TSET^
 44200			060671			%X=.			;DEFINE %X TO SAVE
 44201	060671	201 00 0 00 060671 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44202	060672	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44203	060673				..0013:	CLRBTH^
 44204	060673	700 04 0 00 267760 		CLRAPR
 44205	060674	700 14 0 00 031577 		CLRPI^
 44206	060675	7 004 20 0 00 004010 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44207						WATINT^
 44208	060676	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44209	060677	367 13 0 00 060677 		SOJG	13,.		;AND WAIT^
 44210	060700	7 004 30 0 00 004000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44211						STOP^
 44212	060701	254 04 0 00 060702 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44213	060702	254 00 0 00 060703 		JRST	.+1		;WITH JRST BACK^
 44214						TGET^
 44215	060703	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44216	060704	302 00 0 00 060671 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44217						STOP2^^
 44218	060705	254 04 0 00 060706 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44219	060706	254 00 0 00 060707 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44220					^
 44221			002000			X=X_-1
 44222			000004			Y=Y_-1
 44223
 44224
 44225						PIYES	Y,X^
 44226
 44227					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44228					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44229					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44230
 44231						TSET^
 44232			060707			%X=.			;DEFINE %X TO SAVE
 44233	060707	201 00 0 00 060707 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44234	060710	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44235	060711				..0014:	CLRBTH^
 44236	060711	700 04 0 00 267760 		CLRAPR
 44237	060712	700 14 0 00 031577 		CLRPI^
 44238	060713	7 004 20 0 00 004004 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44239						WATINT^
 44240	060714	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44241	060715	367 13 0 00 060715 		SOJG	13,.		;AND WAIT^
 44242	060716	7 004 30 0 00 002000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44243						STOP^
 44244	060717	254 04 0 00 060720 		HALT	.+1		;INSTRUCTION FAILED REPLACE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-3
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44245	060720	254 00 0 00 060721 		JRST	.+1		;WITH JRST BACK^
 44246						TGET^
 44247	060721	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44248	060722	302 00 0 00 060707 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44249						STOP2^^
 44250	060723	254 04 0 00 060724 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44251	060724	254 00 0 00 060725 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44252					^
 44253			001000			X=X_-1
 44254			000002			Y=Y_-1
 44255
 44256
 44257						PIYES	Y,X^
 44258
 44259					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44260					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44261					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44262
 44263						TSET^
 44264			060725			%X=.			;DEFINE %X TO SAVE
 44265	060725	201 00 0 00 060725 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44266	060726	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44267	060727				..0015:	CLRBTH^
 44268	060727	700 04 0 00 267760 		CLRAPR
 44269	060730	700 14 0 00 031577 		CLRPI^
 44270	060731	7 004 20 0 00 004002 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44271						WATINT^
 44272	060732	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44273	060733	367 13 0 00 060733 		SOJG	13,.		;AND WAIT^
 44274	060734	7 004 30 0 00 001000 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44275						STOP^
 44276	060735	254 04 0 00 060736 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44277	060736	254 00 0 00 060737 		JRST	.+1		;WITH JRST BACK^
 44278						TGET^
 44279	060737	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44280	060740	302 00 0 00 060725 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44281						STOP2^^
 44282	060741	254 04 0 00 060742 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44283	060742	254 00 0 00 060743 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44284					^
 44285			000400			X=X_-1
 44286			000001			Y=Y_-1
 44287
 44288
 44289						PIYES	Y,X^
 44290
 44291					;SET REQUESTS FOR EACH CHANNEL BUT DO NOT SET PI ACTIVE.
 44292					;INTERRUPTS SHOULD NOT OCCUR, AND THE INTERRUPT IN PROGRESS
 44293					;FLAG SHOULD NOT BE SET FOR THE CHANNEL BEING TESTED
 44294
 44295						TSET^
 44296			060743			%X=.			;DEFINE %X TO SAVE
 44297	060743	201 00 0 00 060743 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44298	060744	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44299	060745				..0016:	CLRBTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 27-4
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44300	060745	700 04 0 00 267760 		CLRAPR
 44301	060746	700 14 0 00 031577 		CLRPI^
 44302	060747	7 004 20 0 00 004001 		CONO	PI,REQSET+Y	;SET CHANNEL REQUEST BUT NOT ACTIVE
 44303						WATINT^
 44304	060750	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44305	060751	367 13 0 00 060751 		SOJG	13,.		;AND WAIT^
 44306	060752	7 004 30 0 00 000400 		CONSZ	PI,X		;CHECK WHY INT. IN PROGRESS IS SET.
 44307						STOP^
 44308	060753	254 04 0 00 060754 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44309	060754	254 00 0 00 060755 		JRST	.+1		;WITH JRST BACK^
 44310						TGET^
 44311	060755	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44312	060756	302 00 0 00 060743 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44313						STOP2^^
 44314	060757	254 04 0 00 060760 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44315	060760	254 00 0 00 060761 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44316					^
 44317			000200			X=X_-1
 44318			000000			Y=Y_-1
 44319
 44320	060761	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44321						BLURB^
 44322					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 44323					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 44324					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 44325					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 44326					^
 44327
 44328	060762	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 44329			000100			X=100
 44330	060763				PIOT02:
 44331						REPEAT	7,<
 44332						PIONOF	X
 44333						X=X_-1
 44334					>
 44335
 44336						PIONOF	X^
 44337
 44338					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44339					;AND THAT AN INTERUPT DOES NOT OCCUR
 44340
 44341					BLURB1^
 44342					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44343					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44344					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44345					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44346					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44347					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44348					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44349					^
 44350
 44351						TSET^
 44352			060763			%X=.			;DEFINE %X TO SAVE
 44353	060763	201 00 0 00 060763 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44354	060764	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44355	060765				..0017:	CLRBTH^
 44356	060765	700 04 0 00 267760 		CLRAPR
 44357	060766	700 14 0 00 031577 		CLRPI^
 44358	060767	7 004 20 0 00 004100 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44359	060770	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44360	060771	7 004 20 0 00 010100 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44361						WATINT^
 44362	060772	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44363	060773	367 13 0 00 060773 		SOJG	13,.		;AND WAIT^
 44364	060774	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44365						STOP^
 44366	060775	254 04 0 00 060776 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44367	060776	254 00 0 00 060777 		JRST	.+1		;WITH JRST BACK^
 44368						TGET^
 44369	060777	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44370	061000	302 00 0 00 060763 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44371						STOP2^^
 44372	061001	254 04 0 00 061002 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44373	061002	254 00 0 00 061003 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44374					^
 44375			000040			X=X_-1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-1
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44376
 44377
 44378						PIONOF	X^
 44379
 44380					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44381					;AND THAT AN INTERUPT DOES NOT OCCUR
 44382
 44383					BLURB1^
 44384					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44385					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44386					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44387					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44388					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44389					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44390					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44391					^
 44392
 44393						TSET^
 44394			061003			%X=.			;DEFINE %X TO SAVE
 44395	061003	201 00 0 00 061003 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44396	061004	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44397	061005				..0020:	CLRBTH^
 44398	061005	700 04 0 00 267760 		CLRAPR
 44399	061006	700 14 0 00 031577 		CLRPI^
 44400	061007	7 004 20 0 00 004040 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44401	061010	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44402	061011	7 004 20 0 00 010040 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44403						WATINT^
 44404	061012	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44405	061013	367 13 0 00 061013 		SOJG	13,.		;AND WAIT^
 44406	061014	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44407						STOP^
 44408	061015	254 04 0 00 061016 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44409	061016	254 00 0 00 061017 		JRST	.+1		;WITH JRST BACK^
 44410						TGET^
 44411	061017	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44412	061020	302 00 0 00 061003 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44413						STOP2^^
 44414	061021	254 04 0 00 061022 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44415	061022	254 00 0 00 061023 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44416					^
 44417			000020			X=X_-1
 44418
 44419
 44420						PIONOF	X^
 44421
 44422					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44423					;AND THAT AN INTERUPT DOES NOT OCCUR
 44424
 44425					BLURB1^
 44426					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44427					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44428					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44429					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44430					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-2
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44431					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44432					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44433					^
 44434
 44435						TSET^
 44436			061023			%X=.			;DEFINE %X TO SAVE
 44437	061023	201 00 0 00 061023 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44438	061024	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44439	061025				..0021:	CLRBTH^
 44440	061025	700 04 0 00 267760 		CLRAPR
 44441	061026	700 14 0 00 031577 		CLRPI^
 44442	061027	7 004 20 0 00 004020 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44443	061030	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44444	061031	7 004 20 0 00 010020 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44445						WATINT^
 44446	061032	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44447	061033	367 13 0 00 061033 		SOJG	13,.		;AND WAIT^
 44448	061034	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44449						STOP^
 44450	061035	254 04 0 00 061036 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44451	061036	254 00 0 00 061037 		JRST	.+1		;WITH JRST BACK^
 44452						TGET^
 44453	061037	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44454	061040	302 00 0 00 061023 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44455						STOP2^^
 44456	061041	254 04 0 00 061042 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44457	061042	254 00 0 00 061043 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44458					^
 44459			000010			X=X_-1
 44460
 44461
 44462						PIONOF	X^
 44463
 44464					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44465					;AND THAT AN INTERUPT DOES NOT OCCUR
 44466
 44467					BLURB1^
 44468					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44469					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44470					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44471					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44472					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44473					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44474					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44475					^
 44476
 44477						TSET^
 44478			061043			%X=.			;DEFINE %X TO SAVE
 44479	061043	201 00 0 00 061043 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44480	061044	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44481	061045				..0022:	CLRBTH^
 44482	061045	700 04 0 00 267760 		CLRAPR
 44483	061046	700 14 0 00 031577 		CLRPI^
 44484	061047	7 004 20 0 00 004010 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44485	061050	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-3
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44486	061051	7 004 20 0 00 010010 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44487						WATINT^
 44488	061052	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44489	061053	367 13 0 00 061053 		SOJG	13,.		;AND WAIT^
 44490	061054	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44491						STOP^
 44492	061055	254 04 0 00 061056 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44493	061056	254 00 0 00 061057 		JRST	.+1		;WITH JRST BACK^
 44494						TGET^
 44495	061057	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44496	061060	302 00 0 00 061043 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44497						STOP2^^
 44498	061061	254 04 0 00 061062 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44499	061062	254 00 0 00 061063 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44500					^
 44501			000004			X=X_-1
 44502
 44503
 44504						PIONOF	X^
 44505
 44506					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44507					;AND THAT AN INTERUPT DOES NOT OCCUR
 44508
 44509					BLURB1^
 44510					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44511					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44512					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44513					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44514					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44515					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44516					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44517					^
 44518
 44519						TSET^
 44520			061063			%X=.			;DEFINE %X TO SAVE
 44521	061063	201 00 0 00 061063 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44522	061064	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44523	061065				..0023:	CLRBTH^
 44524	061065	700 04 0 00 267760 		CLRAPR
 44525	061066	700 14 0 00 031577 		CLRPI^
 44526	061067	7 004 20 0 00 004004 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44527	061070	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44528	061071	7 004 20 0 00 010004 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44529						WATINT^
 44530	061072	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44531	061073	367 13 0 00 061073 		SOJG	13,.		;AND WAIT^
 44532	061074	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44533						STOP^
 44534	061075	254 04 0 00 061076 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44535	061076	254 00 0 00 061077 		JRST	.+1		;WITH JRST BACK^
 44536						TGET^
 44537	061077	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44538	061100	302 00 0 00 061063 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44539						STOP2^^
 44540	061101	254 04 0 00 061102 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-4
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44541	061102	254 00 0 00 061103 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44542					^
 44543			000002			X=X_-1
 44544
 44545
 44546						PIONOF	X^
 44547
 44548					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44549					;AND THAT AN INTERUPT DOES NOT OCCUR
 44550
 44551					BLURB1^
 44552					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44553					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
 44554					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44555					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44556					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44557					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44558					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44559					^
 44560
 44561						TSET^
 44562			061103			%X=.			;DEFINE %X TO SAVE
 44563	061103	201 00 0 00 061103 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44564	061104	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44565	061105				..0024:	CLRBTH^
 44566	061105	700 04 0 00 267760 		CLRAPR
 44567	061106	700 14 0 00 031577 		CLRPI^
 44568	061107	7 004 20 0 00 004002 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44569	061110	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44570	061111	7 004 20 0 00 010002 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44571						WATINT^
 44572	061112	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44573	061113	367 13 0 00 061113 		SOJG	13,.		;AND WAIT^
 44574	061114	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44575						STOP^
 44576	061115	254 04 0 00 061116 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44577	061116	254 00 0 00 061117 		JRST	.+1		;WITH JRST BACK^
 44578						TGET^
 44579	061117	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44580	061120	302 00 0 00 061103 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44581						STOP2^^
 44582	061121	254 04 0 00 061122 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44583	061122	254 00 0 00 061123 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44584					^
 44585			000001			X=X_-1
 44586
 44587
 44588						PIONOF	X^
 44589
 44590					;CHECK THAT PICLR CLEARS THE REQUEST FLOP
 44591					;AND THAT AN INTERUPT DOES NOT OCCUR
 44592
 44593					BLURB1^
 44594					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH EXECUTES A HALT
 44595					;POINTING TO THE CHANNEL WHICH CAUSED THE REQUEST.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 28-5
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44596					;OR THE CHANNEL WHICH CAUSED THE INCORRECT INTERRUPT. THE PARTICULAR
 44597					;INTERRUPT TRAP ADRESS FOR THE INTERRUPT LEVEL BEING TESTED MAY NOT
 44598					;ALWAYS HAVE A JSP TO A HALT IN CASE WE ARE TESTING FOR REAL
 44599					;INTERRUPTS ON THAT CHANNEL. IN THIS CASE ONLY THE TRAP FOR THAT 
 44600					;PARTICULAR CHANNEL WILL BE LEGAL. ALL OTHERS WILL HALT.
 44601					^
 44602
 44603						TSET^
 44604			061123			%X=.			;DEFINE %X TO SAVE
 44605	061123	201 00 0 00 061123 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44606	061124	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44607	061125				..0025:	CLRBTH^
 44608	061125	700 04 0 00 267760 		CLRAPR
 44609	061126	700 14 0 00 031577 		CLRPI^
 44610	061127	7 004 20 0 00 004001 		CONO	PI,REQSET+X	;SET REQ. BUT NOT ACTIVE
 44611	061130	400 00 0 00 000000 		SETZ			;THEN CLEAR REQUEST THEN SET ACTIVE
 44612	061131	7 004 20 0 00 010001 		CONO	PI,PICLR+X	;PI RESET FAILED TO CLEAR PIR FLAG.
 44613						WATINT^
 44614	061132	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 44615	061133	367 13 0 00 061133 		SOJG	13,.		;AND WAIT^
 44616	061134	332 00 0 00 000000 		SKIPE			;MOVEI EXEC OUT OF INTERRUPT CH.?
 44617						STOP^
 44618	061135	254 04 0 00 061136 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44619	061136	254 00 0 00 061137 		JRST	.+1		;WITH JRST BACK^
 44620						TGET^
 44621	061137	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44622	061140	302 00 0 00 061123 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44623						STOP2^^
 44624	061141	254 04 0 00 061142 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44625	061142	254 00 0 00 061143 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44626					^
 44627			000000			X=X_-1
 44628
 44629	061143	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44630						BLURB^
 44631					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 44632					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 44633					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 44634					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 44635					^
 44636					;TEST THE SETTING AND CLEARING OF THE PI FLOPS WITHOUT CREATING INTERRUPTS
 44637					;THE TEST WILL HALT IF AN INTERRUPT OCCURS AND THE CHANNEL NUMBER OF THE
 44638					;INTERRUPT WILL BE STORED IN AC0
 44639
 44640
 44641	061144	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 44642
 44643	061145				BIGPI1:	PITEST	100^
 44644
 44645					;TEST SETTING OF CHANNEL FLOP
 44646
 44647						TSET^
 44648			061145			%X=.			;DEFINE %X TO SAVE
 44649	061145	201 00 0 00 061145 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44650	061146	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44651	061147				..0026:	CLRBTH^
 44652	061147	700 04 0 00 267760 		CLRAPR
 44653	061150	700 14 0 00 031577 		CLRPI^
 44654	061151	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;PION FAILED TO SET
 44655	061152	7 004 34 0 00 000100 		CONSO	PI,100
 44656						STOP^
 44657	061153	254 04 0 00 061154 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44658	061154	254 00 0 00 061155 		JRST	.+1		;WITH JRST BACK^
 44659						TBOTH^
 44660						TGET^
 44661	061155	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44662	061156	302 00 0 00 061145 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44663						STOP2^^
 44664	061157	254 04 0 00 061160 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44665	061160	254 00 0 00 061161 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44666
 44667						TSET^^
 44668			061161			%X=.			;DEFINE %X TO SAVE
 44669	061161	201 00 0 00 061161 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44670	061162	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44671						CLRBTH^
 44672	061163	700 04 0 00 267760 		CLRAPR
 44673	061164	700 14 0 00 031577 		CLRPI^
 44674					;TEST CLEARING OF CHANNEL FLOP
 44675	061165	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;CHECK PIO CLR
 44676	061166	7 004 20 0 00 001100 		CONO	PI,CHNOFF+100	;TURN OFF CHANNELS
 44677	061167	7 004 30 0 00 000100 		CONSZ	PI,100		;CHECK WHY FLOP NOT CLEAR
 44678						STOP^
 44679	061170	254 04 0 00 061171 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44680	061171	254 00 0 00 061172 		JRST	.+1		;WITH JRST BACK^
 44681						TBOTH^
 44682						TGET^
 44683	061172	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44684	061173	302 00 0 00 061161 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-1
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44685						STOP2^^
 44686	061174	254 04 0 00 061175 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44687	061175	254 00 0 00 061176 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44688
 44689						TSET^^
 44690			061176			%X=.			;DEFINE %X TO SAVE
 44691	061176	201 00 0 00 061176 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44692	061177	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44693						CLRBTH^
 44694	061200	700 04 0 00 267760 		CLRAPR
 44695	061201	700 14 0 00 031577 		CLRPI^
 44696					;CHECK RESETING OF PI SYSTEM
 44697	061202	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;CHECK THAT PI RESET CLEARS
 44698	061203	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 44699	061204	7 004 30 0 00 000100 		CONSZ	PI,100
 44700						STOP^
 44701	061205	254 04 0 00 061206 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44702	061206	254 00 0 00 061207 		JRST	.+1		;WITH JRST BACK^
 44703						TBOTH^
 44704						TGET^
 44705	061207	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44706	061210	302 00 0 00 061176 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44707						STOP2^^
 44708	061211	254 04 0 00 061212 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44709	061212	254 00 0 00 061213 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44710
 44711						TSET^^
 44712			061213			%X=.			;DEFINE %X TO SAVE
 44713	061213	201 00 0 00 061213 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44714	061214	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44715						CLRBTH^
 44716	061215	700 04 0 00 267760 		CLRAPR
 44717	061216	700 14 0 00 031577 		CLRPI^
 44718					;TEST THAT CONO ONLY SETS PION
 44719	061217	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 44720	061220	7 004 30 0 00 000100 		CONSZ	PI,100		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 44721						STOP^
 44722	061221	254 04 0 00 061222 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44723	061222	254 00 0 00 061223 		JRST	.+1		;WITH JRST BACK^
 44724						TBOTH^
 44725						TGET^
 44726	061223	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44727	061224	302 00 0 00 061213 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44728						STOP2^^
 44729	061225	254 04 0 00 061226 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44730	061226	254 00 0 00 061227 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44731
 44732						TSET^^
 44733			061227			%X=.			;DEFINE %X TO SAVE
 44734	061227	201 00 0 00 061227 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44735	061230	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44736						CLRBTH^
 44737	061231	700 04 0 00 267760 		CLRAPR
 44738	061232	700 14 0 00 031577 		CLRPI^
 44739					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-2
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44740	061233	7 004 20 0 00 002100 		CONO	PI,CHNON+100	;TEST PIO CLR
 44741	061234	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 44742	061235	7 004 34 0 00 000100 		CONSO	PI,100		;BE SET
 44743						STOP^
 44744	061236	254 04 0 00 061237 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44745	061237	254 00 0 00 061240 		JRST	.+1		;WITH JRST BACK^
 44746						TGET^
 44747	061240	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44748	061241	302 00 0 00 061227 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44749						STOP2^^
 44750	061242	254 04 0 00 061243 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44751	061243	254 00 0 00 061244 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44752					^
 44753
 44754	061244				BIGPI2:	PITEST	40^
 44755
 44756					;TEST SETTING OF CHANNEL FLOP
 44757
 44758						TSET^
 44759			061244			%X=.			;DEFINE %X TO SAVE
 44760	061244	201 00 0 00 061244 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44761	061245	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44762	061246				..0027:	CLRBTH^
 44763	061246	700 04 0 00 267760 		CLRAPR
 44764	061247	700 14 0 00 031577 		CLRPI^
 44765	061250	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;PION FAILED TO SET
 44766	061251	7 004 34 0 00 000040 		CONSO	PI,40
 44767						STOP^
 44768	061252	254 04 0 00 061253 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44769	061253	254 00 0 00 061254 		JRST	.+1		;WITH JRST BACK^
 44770						TBOTH^
 44771						TGET^
 44772	061254	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44773	061255	302 00 0 00 061244 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44774						STOP2^^
 44775	061256	254 04 0 00 061257 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44776	061257	254 00 0 00 061260 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44777
 44778						TSET^^
 44779			061260			%X=.			;DEFINE %X TO SAVE
 44780	061260	201 00 0 00 061260 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44781	061261	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44782						CLRBTH^
 44783	061262	700 04 0 00 267760 		CLRAPR
 44784	061263	700 14 0 00 031577 		CLRPI^
 44785					;TEST CLEARING OF CHANNEL FLOP
 44786	061264	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;CHECK PIO CLR
 44787	061265	7 004 20 0 00 001040 		CONO	PI,CHNOFF+40	;TURN OFF CHANNELS
 44788	061266	7 004 30 0 00 000040 		CONSZ	PI,40		;CHECK WHY FLOP NOT CLEAR
 44789						STOP^
 44790	061267	254 04 0 00 061270 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44791	061270	254 00 0 00 061271 		JRST	.+1		;WITH JRST BACK^
 44792						TBOTH^
 44793						TGET^
 44794	061271	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-3
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44795	061272	302 00 0 00 061260 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44796						STOP2^^
 44797	061273	254 04 0 00 061274 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44798	061274	254 00 0 00 061275 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44799
 44800						TSET^^
 44801			061275			%X=.			;DEFINE %X TO SAVE
 44802	061275	201 00 0 00 061275 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44803	061276	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44804						CLRBTH^
 44805	061277	700 04 0 00 267760 		CLRAPR
 44806	061300	700 14 0 00 031577 		CLRPI^
 44807					;CHECK RESETING OF PI SYSTEM
 44808	061301	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;CHECK THAT PI RESET CLEARS
 44809	061302	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 44810	061303	7 004 30 0 00 000040 		CONSZ	PI,40
 44811						STOP^
 44812	061304	254 04 0 00 061305 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44813	061305	254 00 0 00 061306 		JRST	.+1		;WITH JRST BACK^
 44814						TBOTH^
 44815						TGET^
 44816	061306	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44817	061307	302 00 0 00 061275 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44818						STOP2^^
 44819	061310	254 04 0 00 061311 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44820	061311	254 00 0 00 061312 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44821
 44822						TSET^^
 44823			061312			%X=.			;DEFINE %X TO SAVE
 44824	061312	201 00 0 00 061312 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44825	061313	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44826						CLRBTH^
 44827	061314	700 04 0 00 267760 		CLRAPR
 44828	061315	700 14 0 00 031577 		CLRPI^
 44829					;TEST THAT CONO ONLY SETS PION
 44830	061316	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 44831	061317	7 004 30 0 00 000040 		CONSZ	PI,40		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 44832						STOP^
 44833	061320	254 04 0 00 061321 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44834	061321	254 00 0 00 061322 		JRST	.+1		;WITH JRST BACK^
 44835						TBOTH^
 44836						TGET^
 44837	061322	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44838	061323	302 00 0 00 061312 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44839						STOP2^^
 44840	061324	254 04 0 00 061325 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44841	061325	254 00 0 00 061326 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44842
 44843						TSET^^
 44844			061326			%X=.			;DEFINE %X TO SAVE
 44845	061326	201 00 0 00 061326 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44846	061327	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44847						CLRBTH^
 44848	061330	700 04 0 00 267760 		CLRAPR
 44849	061331	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-4
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44850					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 44851	061332	7 004 20 0 00 002040 		CONO	PI,CHNON+40	;TEST PIO CLR
 44852	061333	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 44853	061334	7 004 34 0 00 000040 		CONSO	PI,40		;BE SET
 44854						STOP^
 44855	061335	254 04 0 00 061336 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44856	061336	254 00 0 00 061337 		JRST	.+1		;WITH JRST BACK^
 44857						TGET^
 44858	061337	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44859	061340	302 00 0 00 061326 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44860						STOP2^^
 44861	061341	254 04 0 00 061342 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44862	061342	254 00 0 00 061343 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44863					^
 44864
 44865	061343				BIGPI3:	PITEST	20^
 44866
 44867					;TEST SETTING OF CHANNEL FLOP
 44868
 44869						TSET^
 44870			061343			%X=.			;DEFINE %X TO SAVE
 44871	061343	201 00 0 00 061343 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44872	061344	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44873	061345				..0030:	CLRBTH^
 44874	061345	700 04 0 00 267760 		CLRAPR
 44875	061346	700 14 0 00 031577 		CLRPI^
 44876	061347	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;PION FAILED TO SET
 44877	061350	7 004 34 0 00 000020 		CONSO	PI,20
 44878						STOP^
 44879	061351	254 04 0 00 061352 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44880	061352	254 00 0 00 061353 		JRST	.+1		;WITH JRST BACK^
 44881						TBOTH^
 44882						TGET^
 44883	061353	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44884	061354	302 00 0 00 061343 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44885						STOP2^^
 44886	061355	254 04 0 00 061356 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44887	061356	254 00 0 00 061357 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44888
 44889						TSET^^
 44890			061357			%X=.			;DEFINE %X TO SAVE
 44891	061357	201 00 0 00 061357 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44892	061360	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44893						CLRBTH^
 44894	061361	700 04 0 00 267760 		CLRAPR
 44895	061362	700 14 0 00 031577 		CLRPI^
 44896					;TEST CLEARING OF CHANNEL FLOP
 44897	061363	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;CHECK PIO CLR
 44898	061364	7 004 20 0 00 001020 		CONO	PI,CHNOFF+20	;TURN OFF CHANNELS
 44899	061365	7 004 30 0 00 000020 		CONSZ	PI,20		;CHECK WHY FLOP NOT CLEAR
 44900						STOP^
 44901	061366	254 04 0 00 061367 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44902	061367	254 00 0 00 061370 		JRST	.+1		;WITH JRST BACK^
 44903						TBOTH^
 44904						TGET^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-5
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44905	061370	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44906	061371	302 00 0 00 061357 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44907						STOP2^^
 44908	061372	254 04 0 00 061373 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44909	061373	254 00 0 00 061374 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44910
 44911						TSET^^
 44912			061374			%X=.			;DEFINE %X TO SAVE
 44913	061374	201 00 0 00 061374 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44914	061375	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44915						CLRBTH^
 44916	061376	700 04 0 00 267760 		CLRAPR
 44917	061377	700 14 0 00 031577 		CLRPI^
 44918					;CHECK RESETING OF PI SYSTEM
 44919	061400	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;CHECK THAT PI RESET CLEARS
 44920	061401	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 44921	061402	7 004 30 0 00 000020 		CONSZ	PI,20
 44922						STOP^
 44923	061403	254 04 0 00 061404 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44924	061404	254 00 0 00 061405 		JRST	.+1		;WITH JRST BACK^
 44925						TBOTH^
 44926						TGET^
 44927	061405	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44928	061406	302 00 0 00 061374 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44929						STOP2^^
 44930	061407	254 04 0 00 061410 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44931	061410	254 00 0 00 061411 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44932
 44933						TSET^^
 44934			061411			%X=.			;DEFINE %X TO SAVE
 44935	061411	201 00 0 00 061411 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44936	061412	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44937						CLRBTH^
 44938	061413	700 04 0 00 267760 		CLRAPR
 44939	061414	700 14 0 00 031577 		CLRPI^
 44940					;TEST THAT CONO ONLY SETS PION
 44941	061415	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 44942	061416	7 004 30 0 00 000020 		CONSZ	PI,20		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 44943						STOP^
 44944	061417	254 04 0 00 061420 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44945	061420	254 00 0 00 061421 		JRST	.+1		;WITH JRST BACK^
 44946						TBOTH^
 44947						TGET^
 44948	061421	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44949	061422	302 00 0 00 061411 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44950						STOP2^^
 44951	061423	254 04 0 00 061424 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44952	061424	254 00 0 00 061425 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44953
 44954						TSET^^
 44955			061425			%X=.			;DEFINE %X TO SAVE
 44956	061425	201 00 0 00 061425 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44957	061426	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44958						CLRBTH^
 44959	061427	700 04 0 00 267760 		CLRAPR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-6
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 44960	061430	700 14 0 00 031577 		CLRPI^
 44961					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 44962	061431	7 004 20 0 00 002020 		CONO	PI,CHNON+20	;TEST PIO CLR
 44963	061432	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 44964	061433	7 004 34 0 00 000020 		CONSO	PI,20		;BE SET
 44965						STOP^
 44966	061434	254 04 0 00 061435 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44967	061435	254 00 0 00 061436 		JRST	.+1		;WITH JRST BACK^
 44968						TGET^
 44969	061436	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44970	061437	302 00 0 00 061425 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44971						STOP2^^
 44972	061440	254 04 0 00 061441 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44973	061441	254 00 0 00 061442 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44974					^
 44975
 44976	061442				BIGPI4:	PITEST	10^
 44977
 44978					;TEST SETTING OF CHANNEL FLOP
 44979
 44980						TSET^
 44981			061442			%X=.			;DEFINE %X TO SAVE
 44982	061442	201 00 0 00 061442 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 44983	061443	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 44984	061444				..0031:	CLRBTH^
 44985	061444	700 04 0 00 267760 		CLRAPR
 44986	061445	700 14 0 00 031577 		CLRPI^
 44987	061446	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;PION FAILED TO SET
 44988	061447	7 004 34 0 00 000010 		CONSO	PI,10
 44989						STOP^
 44990	061450	254 04 0 00 061451 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 44991	061451	254 00 0 00 061452 		JRST	.+1		;WITH JRST BACK^
 44992						TBOTH^
 44993						TGET^
 44994	061452	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 44995	061453	302 00 0 00 061442 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 44996						STOP2^^
 44997	061454	254 04 0 00 061455 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 44998	061455	254 00 0 00 061456 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 44999
 45000						TSET^^
 45001			061456			%X=.			;DEFINE %X TO SAVE
 45002	061456	201 00 0 00 061456 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45003	061457	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45004						CLRBTH^
 45005	061460	700 04 0 00 267760 		CLRAPR
 45006	061461	700 14 0 00 031577 		CLRPI^
 45007					;TEST CLEARING OF CHANNEL FLOP
 45008	061462	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;CHECK PIO CLR
 45009	061463	7 004 20 0 00 001010 		CONO	PI,CHNOFF+10	;TURN OFF CHANNELS
 45010	061464	7 004 30 0 00 000010 		CONSZ	PI,10		;CHECK WHY FLOP NOT CLEAR
 45011						STOP^
 45012	061465	254 04 0 00 061466 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45013	061466	254 00 0 00 061467 		JRST	.+1		;WITH JRST BACK^
 45014						TBOTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-7
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45015						TGET^
 45016	061467	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45017	061470	302 00 0 00 061456 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45018						STOP2^^
 45019	061471	254 04 0 00 061472 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45020	061472	254 00 0 00 061473 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45021
 45022						TSET^^
 45023			061473			%X=.			;DEFINE %X TO SAVE
 45024	061473	201 00 0 00 061473 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45025	061474	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45026						CLRBTH^
 45027	061475	700 04 0 00 267760 		CLRAPR
 45028	061476	700 14 0 00 031577 		CLRPI^
 45029					;CHECK RESETING OF PI SYSTEM
 45030	061477	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;CHECK THAT PI RESET CLEARS
 45031	061500	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45032	061501	7 004 30 0 00 000010 		CONSZ	PI,10
 45033						STOP^
 45034	061502	254 04 0 00 061503 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45035	061503	254 00 0 00 061504 		JRST	.+1		;WITH JRST BACK^
 45036						TBOTH^
 45037						TGET^
 45038	061504	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45039	061505	302 00 0 00 061473 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45040						STOP2^^
 45041	061506	254 04 0 00 061507 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45042	061507	254 00 0 00 061510 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45043
 45044						TSET^^
 45045			061510			%X=.			;DEFINE %X TO SAVE
 45046	061510	201 00 0 00 061510 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45047	061511	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45048						CLRBTH^
 45049	061512	700 04 0 00 267760 		CLRAPR
 45050	061513	700 14 0 00 031577 		CLRPI^
 45051					;TEST THAT CONO ONLY SETS PION
 45052	061514	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45053	061515	7 004 30 0 00 000010 		CONSZ	PI,10		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45054						STOP^
 45055	061516	254 04 0 00 061517 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45056	061517	254 00 0 00 061520 		JRST	.+1		;WITH JRST BACK^
 45057						TBOTH^
 45058						TGET^
 45059	061520	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45060	061521	302 00 0 00 061510 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45061						STOP2^^
 45062	061522	254 04 0 00 061523 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45063	061523	254 00 0 00 061524 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45064
 45065						TSET^^
 45066			061524			%X=.			;DEFINE %X TO SAVE
 45067	061524	201 00 0 00 061524 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45068	061525	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45069						CLRBTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-8
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45070	061526	700 04 0 00 267760 		CLRAPR
 45071	061527	700 14 0 00 031577 		CLRPI^
 45072					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45073	061530	7 004 20 0 00 002010 		CONO	PI,CHNON+10	;TEST PIO CLR
 45074	061531	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45075	061532	7 004 34 0 00 000010 		CONSO	PI,10		;BE SET
 45076						STOP^
 45077	061533	254 04 0 00 061534 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45078	061534	254 00 0 00 061535 		JRST	.+1		;WITH JRST BACK^
 45079						TGET^
 45080	061535	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45081	061536	302 00 0 00 061524 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45082						STOP2^^
 45083	061537	254 04 0 00 061540 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45084	061540	254 00 0 00 061541 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45085					^
 45086
 45087	061541				BIGPI5:	PITEST	4^
 45088
 45089					;TEST SETTING OF CHANNEL FLOP
 45090
 45091						TSET^
 45092			061541			%X=.			;DEFINE %X TO SAVE
 45093	061541	201 00 0 00 061541 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45094	061542	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45095	061543				..0032:	CLRBTH^
 45096	061543	700 04 0 00 267760 		CLRAPR
 45097	061544	700 14 0 00 031577 		CLRPI^
 45098	061545	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;PION FAILED TO SET
 45099	061546	7 004 34 0 00 000004 		CONSO	PI,4
 45100						STOP^
 45101	061547	254 04 0 00 061550 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45102	061550	254 00 0 00 061551 		JRST	.+1		;WITH JRST BACK^
 45103						TBOTH^
 45104						TGET^
 45105	061551	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45106	061552	302 00 0 00 061541 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45107						STOP2^^
 45108	061553	254 04 0 00 061554 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45109	061554	254 00 0 00 061555 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45110
 45111						TSET^^
 45112			061555			%X=.			;DEFINE %X TO SAVE
 45113	061555	201 00 0 00 061555 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45114	061556	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45115						CLRBTH^
 45116	061557	700 04 0 00 267760 		CLRAPR
 45117	061560	700 14 0 00 031577 		CLRPI^
 45118					;TEST CLEARING OF CHANNEL FLOP
 45119	061561	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;CHECK PIO CLR
 45120	061562	7 004 20 0 00 001004 		CONO	PI,CHNOFF+4	;TURN OFF CHANNELS
 45121	061563	7 004 30 0 00 000004 		CONSZ	PI,4		;CHECK WHY FLOP NOT CLEAR
 45122						STOP^
 45123	061564	254 04 0 00 061565 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45124	061565	254 00 0 00 061566 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-9
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45125						TBOTH^
 45126						TGET^
 45127	061566	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45128	061567	302 00 0 00 061555 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45129						STOP2^^
 45130	061570	254 04 0 00 061571 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45131	061571	254 00 0 00 061572 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45132
 45133						TSET^^
 45134			061572			%X=.			;DEFINE %X TO SAVE
 45135	061572	201 00 0 00 061572 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45136	061573	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45137						CLRBTH^
 45138	061574	700 04 0 00 267760 		CLRAPR
 45139	061575	700 14 0 00 031577 		CLRPI^
 45140					;CHECK RESETING OF PI SYSTEM
 45141	061576	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;CHECK THAT PI RESET CLEARS
 45142	061577	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45143	061600	7 004 30 0 00 000004 		CONSZ	PI,4
 45144						STOP^
 45145	061601	254 04 0 00 061602 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45146	061602	254 00 0 00 061603 		JRST	.+1		;WITH JRST BACK^
 45147						TBOTH^
 45148						TGET^
 45149	061603	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45150	061604	302 00 0 00 061572 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45151						STOP2^^
 45152	061605	254 04 0 00 061606 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45153	061606	254 00 0 00 061607 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45154
 45155						TSET^^
 45156			061607			%X=.			;DEFINE %X TO SAVE
 45157	061607	201 00 0 00 061607 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45158	061610	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45159						CLRBTH^
 45160	061611	700 04 0 00 267760 		CLRAPR
 45161	061612	700 14 0 00 031577 		CLRPI^
 45162					;TEST THAT CONO ONLY SETS PION
 45163	061613	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45164	061614	7 004 30 0 00 000004 		CONSZ	PI,4		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45165						STOP^
 45166	061615	254 04 0 00 061616 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45167	061616	254 00 0 00 061617 		JRST	.+1		;WITH JRST BACK^
 45168						TBOTH^
 45169						TGET^
 45170	061617	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45171	061620	302 00 0 00 061607 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45172						STOP2^^
 45173	061621	254 04 0 00 061622 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45174	061622	254 00 0 00 061623 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45175
 45176						TSET^^
 45177			061623			%X=.			;DEFINE %X TO SAVE
 45178	061623	201 00 0 00 061623 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45179	061624	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-10
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45180						CLRBTH^
 45181	061625	700 04 0 00 267760 		CLRAPR
 45182	061626	700 14 0 00 031577 		CLRPI^
 45183					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45184	061627	7 004 20 0 00 002004 		CONO	PI,CHNON+4	;TEST PIO CLR
 45185	061630	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45186	061631	7 004 34 0 00 000004 		CONSO	PI,4		;BE SET
 45187						STOP^
 45188	061632	254 04 0 00 061633 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45189	061633	254 00 0 00 061634 		JRST	.+1		;WITH JRST BACK^
 45190						TGET^
 45191	061634	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45192	061635	302 00 0 00 061623 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45193						STOP2^^
 45194	061636	254 04 0 00 061637 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45195	061637	254 00 0 00 061640 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45196					^
 45197
 45198	061640				BIGPI6:	PITEST	2^
 45199
 45200					;TEST SETTING OF CHANNEL FLOP
 45201
 45202						TSET^
 45203			061640			%X=.			;DEFINE %X TO SAVE
 45204	061640	201 00 0 00 061640 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45205	061641	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45206	061642				..0033:	CLRBTH^
 45207	061642	700 04 0 00 267760 		CLRAPR
 45208	061643	700 14 0 00 031577 		CLRPI^
 45209	061644	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;PION FAILED TO SET
 45210	061645	7 004 34 0 00 000002 		CONSO	PI,2
 45211						STOP^
 45212	061646	254 04 0 00 061647 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45213	061647	254 00 0 00 061650 		JRST	.+1		;WITH JRST BACK^
 45214						TBOTH^
 45215						TGET^
 45216	061650	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45217	061651	302 00 0 00 061640 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45218						STOP2^^
 45219	061652	254 04 0 00 061653 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45220	061653	254 00 0 00 061654 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45221
 45222						TSET^^
 45223			061654			%X=.			;DEFINE %X TO SAVE
 45224	061654	201 00 0 00 061654 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45225	061655	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45226						CLRBTH^
 45227	061656	700 04 0 00 267760 		CLRAPR
 45228	061657	700 14 0 00 031577 		CLRPI^
 45229					;TEST CLEARING OF CHANNEL FLOP
 45230	061660	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;CHECK PIO CLR
 45231	061661	7 004 20 0 00 001002 		CONO	PI,CHNOFF+2	;TURN OFF CHANNELS
 45232	061662	7 004 30 0 00 000002 		CONSZ	PI,2		;CHECK WHY FLOP NOT CLEAR
 45233						STOP^
 45234	061663	254 04 0 00 061664 		HALT	.+1		;INSTRUCTION FAILED REPLACE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-11
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45235	061664	254 00 0 00 061665 		JRST	.+1		;WITH JRST BACK^
 45236						TBOTH^
 45237						TGET^
 45238	061665	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45239	061666	302 00 0 00 061654 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45240						STOP2^^
 45241	061667	254 04 0 00 061670 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45242	061670	254 00 0 00 061671 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45243
 45244						TSET^^
 45245			061671			%X=.			;DEFINE %X TO SAVE
 45246	061671	201 00 0 00 061671 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45247	061672	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45248						CLRBTH^
 45249	061673	700 04 0 00 267760 		CLRAPR
 45250	061674	700 14 0 00 031577 		CLRPI^
 45251					;CHECK RESETING OF PI SYSTEM
 45252	061675	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;CHECK THAT PI RESET CLEARS
 45253	061676	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45254	061677	7 004 30 0 00 000002 		CONSZ	PI,2
 45255						STOP^
 45256	061700	254 04 0 00 061701 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45257	061701	254 00 0 00 061702 		JRST	.+1		;WITH JRST BACK^
 45258						TBOTH^
 45259						TGET^
 45260	061702	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45261	061703	302 00 0 00 061671 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45262						STOP2^^
 45263	061704	254 04 0 00 061705 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45264	061705	254 00 0 00 061706 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45265
 45266						TSET^^
 45267			061706			%X=.			;DEFINE %X TO SAVE
 45268	061706	201 00 0 00 061706 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45269	061707	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45270						CLRBTH^
 45271	061710	700 04 0 00 267760 		CLRAPR
 45272	061711	700 14 0 00 031577 		CLRPI^
 45273					;TEST THAT CONO ONLY SETS PION
 45274	061712	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45275	061713	7 004 30 0 00 000002 		CONSZ	PI,2		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45276						STOP^
 45277	061714	254 04 0 00 061715 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45278	061715	254 00 0 00 061716 		JRST	.+1		;WITH JRST BACK^
 45279						TBOTH^
 45280						TGET^
 45281	061716	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45282	061717	302 00 0 00 061706 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45283						STOP2^^
 45284	061720	254 04 0 00 061721 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45285	061721	254 00 0 00 061722 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45286
 45287						TSET^^
 45288			061722			%X=.			;DEFINE %X TO SAVE
 45289	061722	201 00 0 00 061722 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-12
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45290	061723	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45291						CLRBTH^
 45292	061724	700 04 0 00 267760 		CLRAPR
 45293	061725	700 14 0 00 031577 		CLRPI^
 45294					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45295	061726	7 004 20 0 00 002002 		CONO	PI,CHNON+2	;TEST PIO CLR
 45296	061727	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45297	061730	7 004 34 0 00 000002 		CONSO	PI,2		;BE SET
 45298						STOP^
 45299	061731	254 04 0 00 061732 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45300	061732	254 00 0 00 061733 		JRST	.+1		;WITH JRST BACK^
 45301						TGET^
 45302	061733	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45303	061734	302 00 0 00 061722 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45304						STOP2^^
 45305	061735	254 04 0 00 061736 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45306	061736	254 00 0 00 061737 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45307					^
 45308
 45309	061737				BIGPI7:	PITEST	1^
 45310
 45311					;TEST SETTING OF CHANNEL FLOP
 45312
 45313						TSET^
 45314			061737			%X=.			;DEFINE %X TO SAVE
 45315	061737	201 00 0 00 061737 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45316	061740	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45317	061741				..0034:	CLRBTH^
 45318	061741	700 04 0 00 267760 		CLRAPR
 45319	061742	700 14 0 00 031577 		CLRPI^
 45320	061743	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;PION FAILED TO SET
 45321	061744	7 004 34 0 00 000001 		CONSO	PI,1
 45322						STOP^
 45323	061745	254 04 0 00 061746 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45324	061746	254 00 0 00 061747 		JRST	.+1		;WITH JRST BACK^
 45325						TBOTH^
 45326						TGET^
 45327	061747	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45328	061750	302 00 0 00 061737 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45329						STOP2^^
 45330	061751	254 04 0 00 061752 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45331	061752	254 00 0 00 061753 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45332
 45333						TSET^^
 45334			061753			%X=.			;DEFINE %X TO SAVE
 45335	061753	201 00 0 00 061753 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45336	061754	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45337						CLRBTH^
 45338	061755	700 04 0 00 267760 		CLRAPR
 45339	061756	700 14 0 00 031577 		CLRPI^
 45340					;TEST CLEARING OF CHANNEL FLOP
 45341	061757	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;CHECK PIO CLR
 45342	061760	7 004 20 0 00 001001 		CONO	PI,CHNOFF+1	;TURN OFF CHANNELS
 45343	061761	7 004 30 0 00 000001 		CONSZ	PI,1		;CHECK WHY FLOP NOT CLEAR
 45344						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-13
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45345	061762	254 04 0 00 061763 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45346	061763	254 00 0 00 061764 		JRST	.+1		;WITH JRST BACK^
 45347						TBOTH^
 45348						TGET^
 45349	061764	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45350	061765	302 00 0 00 061753 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45351						STOP2^^
 45352	061766	254 04 0 00 061767 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45353	061767	254 00 0 00 061770 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45354
 45355						TSET^^
 45356			061770			%X=.			;DEFINE %X TO SAVE
 45357	061770	201 00 0 00 061770 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45358	061771	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45359						CLRBTH^
 45360	061772	700 04 0 00 267760 		CLRAPR
 45361	061773	700 14 0 00 031577 		CLRPI^
 45362					;CHECK RESETING OF PI SYSTEM
 45363	061774	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;CHECK THAT PI RESET CLEARS
 45364	061775	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45365	061776	7 004 30 0 00 000001 		CONSZ	PI,1
 45366						STOP^
 45367	061777	254 04 0 00 062000 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45368	062000	254 00 0 00 062001 		JRST	.+1		;WITH JRST BACK^
 45369						TBOTH^
 45370						TGET^
 45371	062001	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45372	062002	302 00 0 00 061770 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45373						STOP2^^
 45374	062003	254 04 0 00 062004 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45375	062004	254 00 0 00 062005 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45376
 45377						TSET^^
 45378			062005			%X=.			;DEFINE %X TO SAVE
 45379	062005	201 00 0 00 062005 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45380	062006	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45381						CLRBTH^
 45382	062007	700 04 0 00 267760 		CLRAPR
 45383	062010	700 14 0 00 031577 		CLRPI^
 45384					;TEST THAT CONO ONLY SETS PION
 45385	062011	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45386	062012	7 004 30 0 00 000001 		CONSZ	PI,1		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45387						STOP^
 45388	062013	254 04 0 00 062014 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45389	062014	254 00 0 00 062015 		JRST	.+1		;WITH JRST BACK^
 45390						TBOTH^
 45391						TGET^
 45392	062015	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45393	062016	302 00 0 00 062005 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45394						STOP2^^
 45395	062017	254 04 0 00 062020 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45396	062020	254 00 0 00 062021 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45397
 45398						TSET^^
 45399			062021			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-14
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45400	062021	201 00 0 00 062021 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45401	062022	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45402						CLRBTH^
 45403	062023	700 04 0 00 267760 		CLRAPR
 45404	062024	700 14 0 00 031577 		CLRPI^
 45405					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45406	062025	7 004 20 0 00 002001 		CONO	PI,CHNON+1	;TEST PIO CLR
 45407	062026	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45408	062027	7 004 34 0 00 000001 		CONSO	PI,1		;BE SET
 45409						STOP^
 45410	062030	254 04 0 00 062031 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45411	062031	254 00 0 00 062032 		JRST	.+1		;WITH JRST BACK^
 45412						TGET^
 45413	062032	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45414	062033	302 00 0 00 062021 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45415						STOP2^^
 45416	062034	254 04 0 00 062035 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45417	062035	254 00 0 00 062036 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45418					^
 45419
 45420	062036				BIGPIX:	PITEST	177^
 45421
 45422					;TEST SETTING OF CHANNEL FLOP
 45423
 45424						TSET^
 45425			062036			%X=.			;DEFINE %X TO SAVE
 45426	062036	201 00 0 00 062036 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45427	062037	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45428	062040				..0035:	CLRBTH^
 45429	062040	700 04 0 00 267760 		CLRAPR
 45430	062041	700 14 0 00 031577 		CLRPI^
 45431	062042	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;PION FAILED TO SET
 45432	062043	7 004 34 0 00 000177 		CONSO	PI,177
 45433						STOP^
 45434	062044	254 04 0 00 062045 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45435	062045	254 00 0 00 062046 		JRST	.+1		;WITH JRST BACK^
 45436						TBOTH^
 45437						TGET^
 45438	062046	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45439	062047	302 00 0 00 062036 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45440						STOP2^^
 45441	062050	254 04 0 00 062051 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45442	062051	254 00 0 00 062052 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45443
 45444						TSET^^
 45445			062052			%X=.			;DEFINE %X TO SAVE
 45446	062052	201 00 0 00 062052 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45447	062053	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45448						CLRBTH^
 45449	062054	700 04 0 00 267760 		CLRAPR
 45450	062055	700 14 0 00 031577 		CLRPI^
 45451					;TEST CLEARING OF CHANNEL FLOP
 45452	062056	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;CHECK PIO CLR
 45453	062057	7 004 20 0 00 001177 		CONO	PI,CHNOFF+177	;TURN OFF CHANNELS
 45454	062060	7 004 30 0 00 000177 		CONSZ	PI,177		;CHECK WHY FLOP NOT CLEAR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-15
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45455						STOP^
 45456	062061	254 04 0 00 062062 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45457	062062	254 00 0 00 062063 		JRST	.+1		;WITH JRST BACK^
 45458						TBOTH^
 45459						TGET^
 45460	062063	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45461	062064	302 00 0 00 062052 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45462						STOP2^^
 45463	062065	254 04 0 00 062066 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45464	062066	254 00 0 00 062067 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45465
 45466						TSET^^
 45467			062067			%X=.			;DEFINE %X TO SAVE
 45468	062067	201 00 0 00 062067 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45469	062070	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45470						CLRBTH^
 45471	062071	700 04 0 00 267760 		CLRAPR
 45472	062072	700 14 0 00 031577 		CLRPI^
 45473					;CHECK RESETING OF PI SYSTEM
 45474	062073	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;CHECK THAT PI RESET CLEARS
 45475	062074	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45476	062075	7 004 30 0 00 000177 		CONSZ	PI,177
 45477						STOP^
 45478	062076	254 04 0 00 062077 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45479	062077	254 00 0 00 062100 		JRST	.+1		;WITH JRST BACK^
 45480						TBOTH^
 45481						TGET^
 45482	062100	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45483	062101	302 00 0 00 062067 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45484						STOP2^^
 45485	062102	254 04 0 00 062103 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45486	062103	254 00 0 00 062104 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45487
 45488						TSET^^
 45489			062104			%X=.			;DEFINE %X TO SAVE
 45490	062104	201 00 0 00 062104 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45491	062105	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45492						CLRBTH^
 45493	062106	700 04 0 00 267760 		CLRAPR
 45494	062107	700 14 0 00 031577 		CLRPI^
 45495					;TEST THAT CONO ONLY SETS PION
 45496	062110	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45497	062111	7 004 30 0 00 000177 		CONSZ	PI,177		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45498						STOP^
 45499	062112	254 04 0 00 062113 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45500	062113	254 00 0 00 062114 		JRST	.+1		;WITH JRST BACK^
 45501						TBOTH^
 45502						TGET^
 45503	062114	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45504	062115	302 00 0 00 062104 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45505						STOP2^^
 45506	062116	254 04 0 00 062117 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45507	062117	254 00 0 00 062120 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45508
 45509						TSET^^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-16
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45510			062120			%X=.			;DEFINE %X TO SAVE
 45511	062120	201 00 0 00 062120 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45512	062121	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45513						CLRBTH^
 45514	062122	700 04 0 00 267760 		CLRAPR
 45515	062123	700 14 0 00 031577 		CLRPI^
 45516					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45517	062124	7 004 20 0 00 002177 		CONO	PI,CHNON+177	;TEST PIO CLR
 45518	062125	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45519	062126	7 004 34 0 00 000177 		CONSO	PI,177		;BE SET
 45520						STOP^
 45521	062127	254 04 0 00 062130 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45522	062130	254 00 0 00 062131 		JRST	.+1		;WITH JRST BACK^
 45523						TGET^
 45524	062131	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45525	062132	302 00 0 00 062120 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45526						STOP2^^
 45527	062133	254 04 0 00 062134 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45528	062134	254 00 0 00 062135 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45529					^
 45530
 45531	062135				BIGPIY:	PITEST	125^
 45532
 45533					;TEST SETTING OF CHANNEL FLOP
 45534
 45535						TSET^
 45536			062135			%X=.			;DEFINE %X TO SAVE
 45537	062135	201 00 0 00 062135 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45538	062136	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45539	062137				..0036:	CLRBTH^
 45540	062137	700 04 0 00 267760 		CLRAPR
 45541	062140	700 14 0 00 031577 		CLRPI^
 45542	062141	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;PION FAILED TO SET
 45543	062142	7 004 34 0 00 000125 		CONSO	PI,125
 45544						STOP^
 45545	062143	254 04 0 00 062144 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45546	062144	254 00 0 00 062145 		JRST	.+1		;WITH JRST BACK^
 45547						TBOTH^
 45548						TGET^
 45549	062145	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45550	062146	302 00 0 00 062135 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45551						STOP2^^
 45552	062147	254 04 0 00 062150 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45553	062150	254 00 0 00 062151 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45554
 45555						TSET^^
 45556			062151			%X=.			;DEFINE %X TO SAVE
 45557	062151	201 00 0 00 062151 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45558	062152	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45559						CLRBTH^
 45560	062153	700 04 0 00 267760 		CLRAPR
 45561	062154	700 14 0 00 031577 		CLRPI^
 45562					;TEST CLEARING OF CHANNEL FLOP
 45563	062155	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;CHECK PIO CLR
 45564	062156	7 004 20 0 00 001125 		CONO	PI,CHNOFF+125	;TURN OFF CHANNELS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-17
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45565	062157	7 004 30 0 00 000125 		CONSZ	PI,125		;CHECK WHY FLOP NOT CLEAR
 45566						STOP^
 45567	062160	254 04 0 00 062161 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45568	062161	254 00 0 00 062162 		JRST	.+1		;WITH JRST BACK^
 45569						TBOTH^
 45570						TGET^
 45571	062162	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45572	062163	302 00 0 00 062151 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45573						STOP2^^
 45574	062164	254 04 0 00 062165 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45575	062165	254 00 0 00 062166 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45576
 45577						TSET^^
 45578			062166			%X=.			;DEFINE %X TO SAVE
 45579	062166	201 00 0 00 062166 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45580	062167	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45581						CLRBTH^
 45582	062170	700 04 0 00 267760 		CLRAPR
 45583	062171	700 14 0 00 031577 		CLRPI^
 45584					;CHECK RESETING OF PI SYSTEM
 45585	062172	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;CHECK THAT PI RESET CLEARS
 45586	062173	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45587	062174	7 004 30 0 00 000125 		CONSZ	PI,125
 45588						STOP^
 45589	062175	254 04 0 00 062176 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45590	062176	254 00 0 00 062177 		JRST	.+1		;WITH JRST BACK^
 45591						TBOTH^
 45592						TGET^
 45593	062177	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45594	062200	302 00 0 00 062166 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45595						STOP2^^
 45596	062201	254 04 0 00 062202 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45597	062202	254 00 0 00 062203 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45598
 45599						TSET^^
 45600			062203			%X=.			;DEFINE %X TO SAVE
 45601	062203	201 00 0 00 062203 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45602	062204	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45603						CLRBTH^
 45604	062205	700 04 0 00 267760 		CLRAPR
 45605	062206	700 14 0 00 031577 		CLRPI^
 45606					;TEST THAT CONO ONLY SETS PION
 45607	062207	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45608	062210	7 004 30 0 00 000125 		CONSZ	PI,125		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45609						STOP^
 45610	062211	254 04 0 00 062212 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45611	062212	254 00 0 00 062213 		JRST	.+1		;WITH JRST BACK^
 45612						TBOTH^
 45613						TGET^
 45614	062213	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45615	062214	302 00 0 00 062203 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45616						STOP2^^
 45617	062215	254 04 0 00 062216 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45618	062216	254 00 0 00 062217 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45619
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-18
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45620						TSET^^
 45621			062217			%X=.			;DEFINE %X TO SAVE
 45622	062217	201 00 0 00 062217 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45623	062220	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45624						CLRBTH^
 45625	062221	700 04 0 00 267760 		CLRAPR
 45626	062222	700 14 0 00 031577 		CLRPI^
 45627					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45628	062223	7 004 20 0 00 002125 		CONO	PI,CHNON+125	;TEST PIO CLR
 45629	062224	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45630	062225	7 004 34 0 00 000125 		CONSO	PI,125		;BE SET
 45631						STOP^
 45632	062226	254 04 0 00 062227 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45633	062227	254 00 0 00 062230 		JRST	.+1		;WITH JRST BACK^
 45634						TGET^
 45635	062230	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45636	062231	302 00 0 00 062217 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45637						STOP2^^
 45638	062232	254 04 0 00 062233 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45639	062233	254 00 0 00 062234 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45640					^
 45641
 45642	062234				BIGPIZ:	PITEST	52^
 45643
 45644					;TEST SETTING OF CHANNEL FLOP
 45645
 45646						TSET^
 45647			062234			%X=.			;DEFINE %X TO SAVE
 45648	062234	201 00 0 00 062234 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45649	062235	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45650	062236				..0037:	CLRBTH^
 45651	062236	700 04 0 00 267760 		CLRAPR
 45652	062237	700 14 0 00 031577 		CLRPI^
 45653	062240	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;PION FAILED TO SET
 45654	062241	7 004 34 0 00 000052 		CONSO	PI,52
 45655						STOP^
 45656	062242	254 04 0 00 062243 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45657	062243	254 00 0 00 062244 		JRST	.+1		;WITH JRST BACK^
 45658						TBOTH^
 45659						TGET^
 45660	062244	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45661	062245	302 00 0 00 062234 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45662						STOP2^^
 45663	062246	254 04 0 00 062247 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45664	062247	254 00 0 00 062250 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45665
 45666						TSET^^
 45667			062250			%X=.			;DEFINE %X TO SAVE
 45668	062250	201 00 0 00 062250 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45669	062251	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45670						CLRBTH^
 45671	062252	700 04 0 00 267760 		CLRAPR
 45672	062253	700 14 0 00 031577 		CLRPI^
 45673					;TEST CLEARING OF CHANNEL FLOP
 45674	062254	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;CHECK PIO CLR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-19
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45675	062255	7 004 20 0 00 001052 		CONO	PI,CHNOFF+52	;TURN OFF CHANNELS
 45676	062256	7 004 30 0 00 000052 		CONSZ	PI,52		;CHECK WHY FLOP NOT CLEAR
 45677						STOP^
 45678	062257	254 04 0 00 062260 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45679	062260	254 00 0 00 062261 		JRST	.+1		;WITH JRST BACK^
 45680						TBOTH^
 45681						TGET^
 45682	062261	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45683	062262	302 00 0 00 062250 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45684						STOP2^^
 45685	062263	254 04 0 00 062264 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45686	062264	254 00 0 00 062265 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45687
 45688						TSET^^
 45689			062265			%X=.			;DEFINE %X TO SAVE
 45690	062265	201 00 0 00 062265 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45691	062266	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45692						CLRBTH^
 45693	062267	700 04 0 00 267760 		CLRAPR
 45694	062270	700 14 0 00 031577 		CLRPI^
 45695					;CHECK RESETING OF PI SYSTEM
 45696	062271	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;CHECK THAT PI RESET CLEARS
 45697	062272	7 004 20 0 00 010000 		CONO	PI,PICLR	;PI SYSTEM
 45698	062273	7 004 30 0 00 000052 		CONSZ	PI,52
 45699						STOP^
 45700	062274	254 04 0 00 062275 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45701	062275	254 00 0 00 062276 		JRST	.+1		;WITH JRST BACK^
 45702						TBOTH^
 45703						TGET^
 45704	062276	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45705	062277	302 00 0 00 062265 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45706						STOP2^^
 45707	062300	254 04 0 00 062301 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45708	062301	254 00 0 00 062302 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45709
 45710						TSET^^
 45711			062302			%X=.			;DEFINE %X TO SAVE
 45712	062302	201 00 0 00 062302 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45713	062303	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45714						CLRBTH^
 45715	062304	700 04 0 00 267760 		CLRAPR
 45716	062305	700 14 0 00 031577 		CLRPI^
 45717					;TEST THAT CONO ONLY SETS PION
 45718	062306	7 004 20 0 00 002000 		CONO	PI,CHNON	;TEST PIO SET
 45719	062307	7 004 30 0 00 000052 		CONSZ	PI,52		;CHECK WHY CONO SET FLAGS WHITHOUT AN IOB BIT
 45720						STOP^
 45721	062310	254 04 0 00 062311 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45722	062311	254 00 0 00 062312 		JRST	.+1		;WITH JRST BACK^
 45723						TBOTH^
 45724						TGET^
 45725	062312	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45726	062313	302 00 0 00 062302 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45727						STOP2^^
 45728	062314	254 04 0 00 062315 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45729	062315	254 00 0 00 062316 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 29-20
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45730
 45731						TSET^^
 45732			062316			%X=.			;DEFINE %X TO SAVE
 45733	062316	201 00 0 00 062316 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45734	062317	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45735						CLRBTH^
 45736	062320	700 04 0 00 267760 		CLRAPR
 45737	062321	700 14 0 00 031577 		CLRPI^
 45738					;CHECK THAT CONO DOES NOT CLEAR ACTIVE
 45739	062322	7 004 20 0 00 002052 		CONO	PI,CHNON+52	;TEST PIO CLR
 45740	062323	7 004 20 0 00 001000 		CONO	PI,CHNOFF	;MAYBE RESET OCCURED - BIT SHOULD STILL
 45741	062324	7 004 34 0 00 000052 		CONSO	PI,52		;BE SET
 45742						STOP^
 45743	062325	254 04 0 00 062326 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45744	062326	254 00 0 00 062327 		JRST	.+1		;WITH JRST BACK^
 45745						TGET^
 45746	062327	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45747	062330	302 00 0 00 062316 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45748						STOP2^^
 45749	062331	254 04 0 00 062332 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45750	062332	254 00 0 00 062333 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45751					^
 45752
 45753	062333	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45754						BLURB^
 45755					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 45756					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 45757					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 45758					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 45759					^
 45760					;CHECK THE SETTING AND CLEARING OF THE HOLD FLOPS
 45761
 45762
 45763	062334	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 45764			040000			X=40000
 45765			000100			Y=100
 45766					PIOT03:	REPEAT	7,<
 45767						PIHCLR	Y,X
 45768						X=X_-1
 45769						Y=Y_-1
 45770					>
 45771
 45772						PIHCLR	Y,X^
 45773
 45774					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45775
 45776						TSET^
 45777			062335			%X=.			;DEFINE %X TO SAVE
 45778	062335	201 00 0 00 062335 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45779	062336	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45780	062337				..0040:	CLRBTH^
 45781	062337	700 04 0 00 267760 		CLRAPR
 45782	062340	700 14 0 00 031577 		CLRPI^
 45783	062341	7 004 20 0 00 004300 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45784						WATINT^
 45785	062342	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45786	062343	367 13 0 00 062343 		SOJG	13,.		;AND WAIT^
 45787	062344	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45788	062345	7 004 30 0 00 040000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45789						STOP^
 45790	062346	254 04 0 00 062347 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45791	062347	254 00 0 00 062350 		JRST	.+1		;WITH JRST BACK^
 45792						TGET^
 45793	062350	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45794	062351	302 00 0 00 062335 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45795						STOP2^^
 45796	062352	254 04 0 00 062353 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45797	062353	254 00 0 00 062354 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45798					^
 45799			020000			X=X_-1
 45800			000040			Y=Y_-1
 45801
 45802
 45803						PIHCLR	Y,X^
 45804
 45805					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45806
 45807						TSET^
 45808			062354			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30-1
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45809	062354	201 00 0 00 062354 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45810	062355	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45811	062356				..0041:	CLRBTH^
 45812	062356	700 04 0 00 267760 		CLRAPR
 45813	062357	700 14 0 00 031577 		CLRPI^
 45814	062360	7 004 20 0 00 004240 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45815						WATINT^
 45816	062361	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45817	062362	367 13 0 00 062362 		SOJG	13,.		;AND WAIT^
 45818	062363	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45819	062364	7 004 30 0 00 020000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45820						STOP^
 45821	062365	254 04 0 00 062366 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45822	062366	254 00 0 00 062367 		JRST	.+1		;WITH JRST BACK^
 45823						TGET^
 45824	062367	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45825	062370	302 00 0 00 062354 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45826						STOP2^^
 45827	062371	254 04 0 00 062372 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45828	062372	254 00 0 00 062373 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45829					^
 45830			010000			X=X_-1
 45831			000020			Y=Y_-1
 45832
 45833
 45834						PIHCLR	Y,X^
 45835
 45836					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45837
 45838						TSET^
 45839			062373			%X=.			;DEFINE %X TO SAVE
 45840	062373	201 00 0 00 062373 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45841	062374	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45842	062375				..0042:	CLRBTH^
 45843	062375	700 04 0 00 267760 		CLRAPR
 45844	062376	700 14 0 00 031577 		CLRPI^
 45845	062377	7 004 20 0 00 004220 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45846						WATINT^
 45847	062400	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45848	062401	367 13 0 00 062401 		SOJG	13,.		;AND WAIT^
 45849	062402	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45850	062403	7 004 30 0 00 010000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45851						STOP^
 45852	062404	254 04 0 00 062405 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45853	062405	254 00 0 00 062406 		JRST	.+1		;WITH JRST BACK^
 45854						TGET^
 45855	062406	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45856	062407	302 00 0 00 062373 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45857						STOP2^^
 45858	062410	254 04 0 00 062411 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45859	062411	254 00 0 00 062412 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45860					^
 45861			004000			X=X_-1
 45862			000010			Y=Y_-1
 45863
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30-2
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45864
 45865						PIHCLR	Y,X^
 45866
 45867					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45868
 45869						TSET^
 45870			062412			%X=.			;DEFINE %X TO SAVE
 45871	062412	201 00 0 00 062412 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45872	062413	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45873	062414				..0043:	CLRBTH^
 45874	062414	700 04 0 00 267760 		CLRAPR
 45875	062415	700 14 0 00 031577 		CLRPI^
 45876	062416	7 004 20 0 00 004210 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45877						WATINT^
 45878	062417	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45879	062420	367 13 0 00 062420 		SOJG	13,.		;AND WAIT^
 45880	062421	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45881	062422	7 004 30 0 00 004000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45882						STOP^
 45883	062423	254 04 0 00 062424 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45884	062424	254 00 0 00 062425 		JRST	.+1		;WITH JRST BACK^
 45885						TGET^
 45886	062425	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45887	062426	302 00 0 00 062412 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45888						STOP2^^
 45889	062427	254 04 0 00 062430 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45890	062430	254 00 0 00 062431 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45891					^
 45892			002000			X=X_-1
 45893			000004			Y=Y_-1
 45894
 45895
 45896						PIHCLR	Y,X^
 45897
 45898					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45899
 45900						TSET^
 45901			062431			%X=.			;DEFINE %X TO SAVE
 45902	062431	201 00 0 00 062431 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45903	062432	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45904	062433				..0044:	CLRBTH^
 45905	062433	700 04 0 00 267760 		CLRAPR
 45906	062434	700 14 0 00 031577 		CLRPI^
 45907	062435	7 004 20 0 00 004204 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45908						WATINT^
 45909	062436	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45910	062437	367 13 0 00 062437 		SOJG	13,.		;AND WAIT^
 45911	062440	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45912	062441	7 004 30 0 00 002000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45913						STOP^
 45914	062442	254 04 0 00 062443 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45915	062443	254 00 0 00 062444 		JRST	.+1		;WITH JRST BACK^
 45916						TGET^
 45917	062444	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45918	062445	302 00 0 00 062431 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30-3
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45919						STOP2^^
 45920	062446	254 04 0 00 062447 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45921	062447	254 00 0 00 062450 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45922					^
 45923			001000			X=X_-1
 45924			000002			Y=Y_-1
 45925
 45926
 45927						PIHCLR	Y,X^
 45928
 45929					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45930
 45931						TSET^
 45932			062450			%X=.			;DEFINE %X TO SAVE
 45933	062450	201 00 0 00 062450 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45934	062451	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45935	062452				..0045:	CLRBTH^
 45936	062452	700 04 0 00 267760 		CLRAPR
 45937	062453	700 14 0 00 031577 		CLRPI^
 45938	062454	7 004 20 0 00 004202 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45939						WATINT^
 45940	062455	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45941	062456	367 13 0 00 062456 		SOJG	13,.		;AND WAIT^
 45942	062457	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
 45943	062460	7 004 30 0 00 001000 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45944						STOP^
 45945	062461	254 04 0 00 062462 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45946	062462	254 00 0 00 062463 		JRST	.+1		;WITH JRST BACK^
 45947						TGET^
 45948	062463	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45949	062464	302 00 0 00 062450 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45950						STOP2^^
 45951	062465	254 04 0 00 062466 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45952	062466	254 00 0 00 062467 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45953					^
 45954			000400			X=X_-1
 45955			000001			Y=Y_-1
 45956
 45957
 45958						PIHCLR	Y,X^
 45959
 45960					;CHECK THAT PICLR CLEARS THE HOLD FLOP
 45961
 45962						TSET^
 45963			062467			%X=.			;DEFINE %X TO SAVE
 45964	062467	201 00 0 00 062467 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 45965	062470	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 45966	062471				..0046:	CLRBTH^
 45967	062471	700 04 0 00 267760 		CLRAPR
 45968	062472	700 14 0 00 031577 		CLRPI^
 45969	062473	7 004 20 0 00 004201 		CONO	PI,REQSET+PION+Y	;CAUSE INT. TO SET HOLD
 45970						WATINT^
 45971	062474	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 45972	062475	367 13 0 00 062475 		SOJG	13,.		;AND WAIT^
 45973	062476	7 004 20 0 00 010000 		CONO	PI,PICLR	;THEN CLEAR VIA PI RESET
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 30-4
DFKAA8	MAC	13-Jan-89 10:22		BASIC PI SYSTEM TESTING

 45974	062477	7 004 30 0 00 000400 		CONSZ	PI,X		;HOLD FLOP FAILED TO CLEAR.
 45975						STOP^
 45976	062500	254 04 0 00 062501 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 45977	062501	254 00 0 00 062502 		JRST	.+1		;WITH JRST BACK^
 45978						TGET^
 45979	062502	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 45980	062503	302 00 0 00 062467 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 45981						STOP2^^
 45982	062504	254 04 0 00 062505 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 45983	062505	254 00 0 00 062506 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 45984					^
 45985			000200			X=X_-1
 45986			000000			Y=Y_-1
 45987
 45988	062506	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT TESTING WITH REAL INTERRUPTS

 45989					SUBTTL	INTERRUPT TESTING WITH REAL INTERRUPTS
 45990
 45991					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 45992					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 45993					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 45994
 45995					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 45996	062507	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 45997	062510	700 14 0 00 031577 		CLRPI
 45998	062511	700 04 0 00 267760 		CLRAPR
 45999	062512	200 00 0 00 071067 		MOVE	[JSP UUO]	;SET TRAP TO HALT
 46000	062513	202 00 0 00 000041 		MOVEM	41		;IN THE UUO TRAP LOCATION
 46001	062514	200 00 0 00 071070 		MOVE	[JSP TRP0A]	;SET PROPER RECOVERY INST.
 46002	062515	202 00 0 00 000042 		MOVEM	42		;INTO CH1 TRAP
 46003	062516	7 004 20 0 00 002300 		CONO	PI,2300		;TURN ON CHAN1
 46004	062517	7 000 20 0 00 112001 		CONO	APR,LENXER!LSNXER!LAPRP1	;CAUSE CACHE SWP DONE AND CHAN
 46005						STUCK^
 46006						WATINT^
 46007	062520	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46008	062521	367 13 0 00 062521 		SOJG	13,.		;AND WAIT^
 46009	062522	254 00 0 00 062522 		JRST	.		;LOOOP ON SELF^
 46010	062523				TRP0A:	TRPCHK^
 46011	062523	332 00 0 00 030042 	..0047:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46012	062524	254 00 0 00 062527 		JRST	.+3		;DONT IF STAND ALONE
 46013	062525	254 02 1 00 062526 		JRSTF	@.+1		;AND RESTORE THEM
 46014	062526	000000	062527			USERF,.+1		;NEW PC AND FLAGS^
 46015	062527	700 14 0 00 031577 		CLRPI
 46016	062530	700 04 0 00 267760 		CLRAPR
 46017					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46018					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46019					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46020					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46021	062531	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46022	062532	200 00 0 00 071071 		MOVE	[JSP TRP1A]	;RECOVERY INSTRUCTION INTO
 46023	062533	202 00 0 00 000044 		MOVEM	44		;PROPER CHAN TRAP (2)
 46024	062534	7 004 20 0 00 002240 		CONO	PI,2240		;TURN CHAN 2 ON
 46025	062535	7 000 20 0 00 114002 		CONO	APR,LESBER!LSSBER!LAPRP2	;CAUSE CACHE SWP DONE AND CHN ON
 46026						STUCK^
 46027						WATINT^
 46028	062536	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46029	062537	367 13 0 00 062537 		SOJG	13,.		;AND WAIT^
 46030	062540	254 00 0 00 062540 		JRST	.		;LOOOP ON SELF^
 46031	062541				TRP1A:	TRPCHK^
 46032	062541	332 00 0 00 030042 	..0050:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46033	062542	254 00 0 00 062545 		JRST	.+3		;DONT IF STAND ALONE
 46034	062543	254 02 1 00 062544 		JRSTF	@.+1		;AND RESTORE THEM
 46035	062544	000000	062545			USERF,.+1		;NEW PC AND FLAGS^
 46036	062545	700 14 0 00 031577 		CLRPI
 46037	062546	700 04 0 00 267760 		CLRAPR
 46038					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46039					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46040					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46041					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46042	062547	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46043	062550	200 00 0 00 071072 		MOVE	[JSP TRP2A]	;RECOVERY INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 31-1
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT TESTING WITH REAL INTERRUPTS

 46044	062551	202 00 0 00 000046 		MOVEM	46		;INTO PROPER CHAN TRAP (3)
 46045	062552	7 004 20 0 00 002220 		CONO	PI,2220		;TURN CHAN 3 ON
 46046	062553	7 000 20 0 00 110403 		CONO	APR,LEPAER!LSPAER!LAPRP3		;CAUSE CACHE SWP DONE AND CHAN ON
 46047						STUCK^
 46048						WATINT^
 46049	062554	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46050	062555	367 13 0 00 062555 		SOJG	13,.		;AND WAIT^
 46051	062556	254 00 0 00 062556 		JRST	.		;LOOOP ON SELF^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 32
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT TESTING WITH REAL INTERRUPTS

 46052	062557				TRP2A:	TRPCHK^
 46053	062557	332 00 0 00 030042 	..0051:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46054	062560	254 00 0 00 062563 		JRST	.+3		;DONT IF STAND ALONE
 46055	062561	254 02 1 00 062562 		JRSTF	@.+1		;AND RESTORE THEM
 46056	062562	000000	062563			USERF,.+1		;NEW PC AND FLAGS^
 46057	062563	700 14 0 00 031577 		CLRPI
 46058	062564	700 04 0 00 267760 		CLRAPR
 46059					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46060					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46061					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46062					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46063	062565	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46064	062566	200 00 0 00 071073 		MOVE	[JSP TRP3A]	;RECOVERY INSTRUCTION
 46065	062567	202 00 0 00 000050 		MOVEM	50		;INTO PROPER CHAN TRAP (4)
 46066	062570	7 004 20 0 00 002210 		CONO	PI,2210		;TURN CHAN 4 ON
 46067	062571	7 000 20 0 00 111004 		CONO	APR,LEIOPF!LSIOPF!LAPRP4		;CAUSE CACHE SWP DONE AND CHAN ON
 46068						STUCK^
 46069						WATINT^
 46070	062572	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46071	062573	367 13 0 00 062573 		SOJG	13,.		;AND WAIT^
 46072	062574	254 00 0 00 062574 		JRST	.		;LOOOP ON SELF^
 46073	062575				TRP3A:	TRPCHK^
 46074	062575	332 00 0 00 030042 	..0052:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46075	062576	254 00 0 00 062601 		JRST	.+3		;DONT IF STAND ALONE
 46076	062577	254 02 1 00 062600 		JRSTF	@.+1		;AND RESTORE THEM
 46077	062600	000000	062601			USERF,.+1		;NEW PC AND FLAGS^
 46078	062601	700 14 0 00 031577 		CLRPI
 46079	062602	700 04 0 00 267760 		CLRAPR
 46080					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46081					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46082					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46083					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46084	062603	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46085	062604	200 00 0 00 071074 		MOVE	[JSP TRP4A]	;RECOVERY INSTRUCTION
 46086	062605	202 00 0 00 000052 		MOVEM	52		;INTO PROPER CHAN TRAP (5)
 46087	062606	7 004 20 0 00 002204 		CONO	PI,2204		;TURN CHAN 5 ON
 46088	062607	7 000 20 0 00 110025 		CONO	APR,LECASD!LSCASD!LAPRP5		;CAUSE CACHE SWP DONE AND CHAN ON
 46089						STUCK^
 46090						WATINT^
 46091	062610	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46092	062611	367 13 0 00 062611 		SOJG	13,.		;AND WAIT^
 46093	062612	254 00 0 00 062612 		JRST	.		;LOOOP ON SELF^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 33
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT TESTING WITH REAL INTERRUPTS

 46094	062613				TRP4A:	TRPCHK^
 46095	062613	332 00 0 00 030042 	..0053:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46096	062614	254 00 0 00 062617 		JRST	.+3		;DONT IF STAND ALONE
 46097	062615	254 02 1 00 062616 		JRSTF	@.+1		;AND RESTORE THEM
 46098	062616	000000	062617			USERF,.+1		;NEW PC AND FLAGS^
 46099	062617	700 14 0 00 031577 		CLRPI
 46100	062620	700 04 0 00 267760 		CLRAPR
 46101
 46102					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46103					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46104					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46105					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46106	062621	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46107	062622	200 00 0 00 071075 		MOVE	[JSP TRP5A]	;RECOVERY INSTRUCTION
 46108	062623	202 00 0 00 000054 		MOVEM	54		;INTO PROPER CHAN TRAP (6)
 46109	062624	7 004 20 0 00 002202 		CONO	PI,2202		;TURN CHAN 6 ON
 46110	062625	7 000 20 0 00 110046 		CONO	APR,LEPWRF!LSPWRF!LAPRP6	;CAUSE CACHE SWP DONE AND CHAN ON
 46111						STUCK^
 46112						WATINT^
 46113	062626	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46114	062627	367 13 0 00 062627 		SOJG	13,.		;AND WAIT^
 46115	062630	254 00 0 00 062630 		JRST	.		;LOOOP ON SELF^
 46116	062631				TRP5A:	TRPCHK^
 46117	062631	332 00 0 00 030042 	..0054:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46118	062632	254 00 0 00 062635 		JRST	.+3		;DONT IF STAND ALONE
 46119	062633	254 02 1 00 062634 		JRSTF	@.+1		;AND RESTORE THEM
 46120	062634	000000	062635			USERF,.+1		;NEW PC AND FLAGS^
 46121	062635	700 14 0 00 031577 		CLRPI
 46122	062636	700 04 0 00 267760 		CLRAPR
 46123					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46124					;TEST PROPER TRAP WHEN INTERRUPTING ON EACH CHANNEL
 46125					;VIA THE CACHE SWEEP DONE FLAG--ILLEGAL TRAPS HALT--NO TRAP LOOPS
 46126					;THE HALT POINTS TO THE CHANNEL THOUGHT TO BE REQUESTED
 46127	062637	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46128	062640	200 00 0 00 071076 		MOVE	[JSP TRP6A]	;RECOVERY INSTRUCTION
 46129	062641	202 00 0 00 000056 		MOVEM	56		;INTO PROPER CHAN TRAP (7)
 46130	062642	7 004 20 0 00 002201 		CONO	PI,2201		;TURN CHAN 7 ON
 46131	062643	7 000 20 0 00 110047 		CONO	APR,LEPWRF!LSPWRF!LAPRP7	;CASUE CACHE SWP DONE AND CHAN ON
 46132						STUCK^
 46133						WATINT^
 46134	062644	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46135	062645	367 13 0 00 062645 		SOJG	13,.		;AND WAIT^
 46136	062646	254 00 0 00 062646 		JRST	.		;LOOOP ON SELF^
 46137	062647				TRP6A:	TRPCHK^
 46138	062647	332 00 0 00 030042 	..0055:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46139	062650	254 00 0 00 062653 		JRST	.+3		;DONT IF STAND ALONE
 46140	062651	254 02 1 00 062652 		JRSTF	@.+1		;AND RESTORE THEM
 46141	062652	000000	062653			USERF,.+1		;NEW PC AND FLAGS^
 46142
 46143	062653	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 34
DFKAA8	MAC	13-Jan-89 10:22		INTERNAL INTERRUPT REQUEST TESTING

 46144					SUBTTL	INTERNAL INTERRUPT REQUEST TESTING
 46145
 46146					;CHECK THE ABILITY TO GENERATE PI REQUESTS VIA PROGRAM REQEST ON ALL
 46147					;CHANNELS.
 46148	062654	265 00 0 00 062655 		JSP	.+1		;GET FLAGS
 46149	062655	603 00 0 00 010000 		TLNE	USERF		;USER MODE BIT ON
 46150	062656	254 00 0 00 062657 		JRST	.+1		;DONT DO IF USER MODE!
 46151
 46152						CLRBTH^
 46153	062657	700 04 0 00 267760 		CLRAPR
 46154	062660	700 14 0 00 031577 		CLRPI^
 46155					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46156	062661	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46157	062662	700 14 0 00 031577 		CLRPI
 46158	062663	700 04 0 00 267760 		CLRAPR
 46159						TRAP	<JSP CKI01>,42^
 46160	062664	200 00 0 00 071077 		MOVE	[JSP CKI01]		;SET TRAP INSTRUCTION
 46161	062665	202 00 0 00 000042 		MOVEM	42		;INTO TRAP LOCATION^
 46162	062666	7 004 20 0 00 006300 		CONO	PI,6300		;INTERRUPT ON CH1
 46163						STUCK^
 46164						WATINT^
 46165	062667	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46166	062670	367 13 0 00 062670 		SOJG	13,.		;AND WAIT^
 46167	062671	254 00 0 00 062671 		JRST	.		;LOOOP ON SELF^
 46168					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46169	062672				CKI01:	TRPCHK^
 46170	062672	332 00 0 00 030042 	..0056:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46171	062673	254 00 0 00 062676 		JRST	.+3		;DONT IF STAND ALONE
 46172	062674	254 02 1 00 062675 		JRSTF	@.+1		;AND RESTORE THEM
 46173	062675	000000	062676			USERF,.+1		;NEW PC AND FLAGS^
 46174	062676	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46175	062677	700 14 0 00 031577 		CLRPI
 46176	062700	700 04 0 00 267760 		CLRAPR
 46177						TRAP	<JSP CKI02>,44^
 46178	062701	200 00 0 00 071100 		MOVE	[JSP CKI02]		;SET TRAP INSTRUCTION
 46179	062702	202 00 0 00 000044 		MOVEM	44		;INTO TRAP LOCATION^
 46180	062703	7 004 20 0 00 006240 		CONO	PI,6240		;INTERRUPT ON CH 2
 46181						STUCK^
 46182						WATINT^
 46183	062704	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46184	062705	367 13 0 00 062705 		SOJG	13,.		;AND WAIT^
 46185	062706	254 00 0 00 062706 		JRST	.		;LOOOP ON SELF^
 46186					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 35
DFKAA8	MAC	13-Jan-89 10:22		INTERNAL INTERRUPT REQUEST TESTING

 46187	062707				CKI02:	TRPCHK^
 46188	062707	332 00 0 00 030042 	..0057:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46189	062710	254 00 0 00 062713 		JRST	.+3		;DONT IF STAND ALONE
 46190	062711	254 02 1 00 062712 		JRSTF	@.+1		;AND RESTORE THEM
 46191	062712	000000	062713			USERF,.+1		;NEW PC AND FLAGS^
 46192	062713	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46193	062714	700 14 0 00 031577 		CLRPI
 46194	062715	700 04 0 00 267760 		CLRAPR
 46195						TRAP	<JSP CKI03>,46^
 46196	062716	200 00 0 00 071101 		MOVE	[JSP CKI03]		;SET TRAP INSTRUCTION
 46197	062717	202 00 0 00 000046 		MOVEM	46		;INTO TRAP LOCATION^
 46198	062720	7 004 20 0 00 006220 		CONO	PI,6220		;INTERRUPT ON CH 3
 46199						STUCK^
 46200						WATINT^
 46201	062721	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46202	062722	367 13 0 00 062722 		SOJG	13,.		;AND WAIT^
 46203	062723	254 00 0 00 062723 		JRST	.		;LOOOP ON SELF^
 46204					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 36
DFKAA8	MAC	13-Jan-89 10:22		INTERNAL INTERRUPT REQUEST TESTING

 46205	062724				CKI03:	TRPCHK^
 46206	062724	332 00 0 00 030042 	..0060:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46207	062725	254 00 0 00 062730 		JRST	.+3		;DONT IF STAND ALONE
 46208	062726	254 02 1 00 062727 		JRSTF	@.+1		;AND RESTORE THEM
 46209	062727	000000	062730			USERF,.+1		;NEW PC AND FLAGS^
 46210	062730	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46211	062731	700 14 0 00 031577 		CLRPI
 46212	062732	700 04 0 00 267760 		CLRAPR
 46213						TRAP	<JSP CKI04>,50^
 46214	062733	200 00 0 00 071102 		MOVE	[JSP CKI04]		;SET TRAP INSTRUCTION
 46215	062734	202 00 0 00 000050 		MOVEM	50		;INTO TRAP LOCATION^
 46216	062735	7 004 20 0 00 006210 		CONO	PI,6210		;INTERRUPT ON CH 4
 46217						STUCK^
 46218						WATINT^
 46219	062736	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46220	062737	367 13 0 00 062737 		SOJG	13,.		;AND WAIT^
 46221	062740	254 00 0 00 062740 		JRST	.		;LOOOP ON SELF^
 46222					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46223	062741				CKI04:	TRPCHK^
 46224	062741	332 00 0 00 030042 	..0061:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46225	062742	254 00 0 00 062745 		JRST	.+3		;DONT IF STAND ALONE
 46226	062743	254 02 1 00 062744 		JRSTF	@.+1		;AND RESTORE THEM
 46227	062744	000000	062745			USERF,.+1		;NEW PC AND FLAGS^
 46228	062745	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46229	062746	700 14 0 00 031577 		CLRPI
 46230	062747	700 04 0 00 267760 		CLRAPR
 46231						TRAP	<JSP CKI05>,52^
 46232	062750	200 00 0 00 071103 		MOVE	[JSP CKI05]		;SET TRAP INSTRUCTION
 46233	062751	202 00 0 00 000052 		MOVEM	52		;INTO TRAP LOCATION^
 46234	062752	7 004 20 0 00 006204 		CONO	PI,6204		;INTERRUPT ON CH 5
 46235						STUCK^
 46236						WATINT^
 46237	062753	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46238	062754	367 13 0 00 062754 		SOJG	13,.		;AND WAIT^
 46239	062755	254 00 0 00 062755 		JRST	.		;LOOOP ON SELF^
 46240					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46241	062756				CKI05:	TRPCHK^
 46242	062756	332 00 0 00 030042 	..0062:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46243	062757	254 00 0 00 062762 		JRST	.+3		;DONT IF STAND ALONE
 46244	062760	254 02 1 00 062761 		JRSTF	@.+1		;AND RESTORE THEM
 46245	062761	000000	062762			USERF,.+1		;NEW PC AND FLAGS^
 46246	062762	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46247	062763	700 14 0 00 031577 		CLRPI
 46248	062764	700 04 0 00 267760 		CLRAPR
 46249						TRAP	<JSP CKI06>,54^
 46250	062765	200 00 0 00 071104 		MOVE	[JSP CKI06]		;SET TRAP INSTRUCTION
 46251	062766	202 00 0 00 000054 		MOVEM	54		;INTO TRAP LOCATION^
 46252	062767	7 004 20 0 00 006202 		CONO	PI,6202		;INTERRUPT ON CH 6
 46253						STUCK^
 46254						WATINT^
 46255	062770	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46256	062771	367 13 0 00 062771 		SOJG	13,.		;AND WAIT^
 46257	062772	254 00 0 00 062772 		JRST	.		;LOOOP ON SELF^
 46258					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 37
DFKAA8	MAC	13-Jan-89 10:22		INTERNAL INTERRUPT REQUEST TESTING

 46259	062773				CKI06:	TRPCHK^
 46260	062773	332 00 0 00 030042 	..0063:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46261	062774	254 00 0 00 062777 		JRST	.+3		;DONT IF STAND ALONE
 46262	062775	254 02 1 00 062776 		JRSTF	@.+1		;AND RESTORE THEM
 46263	062776	000000	062777			USERF,.+1		;NEW PC AND FLAGS^
 46264	062777	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46265	063000	700 14 0 00 031577 		CLRPI
 46266	063001	700 04 0 00 267760 		CLRAPR
 46267						TRAP	<JSP CKI07>,56^
 46268	063002	200 00 0 00 071105 		MOVE	[JSP CKI07]		;SET TRAP INSTRUCTION
 46269	063003	202 00 0 00 000056 		MOVEM	56		;INTO TRAP LOCATION^
 46270	063004	7 004 20 0 00 006201 		CONO	PI,6201		;INTERRUPT ON CH 7
 46271						STUCK^
 46272						WATINT^
 46273	063005	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46274	063006	367 13 0 00 063006 		SOJG	13,.		;AND WAIT^
 46275	063007	254 00 0 00 063007 		JRST	.		;LOOOP ON SELF^
 46276					;IF PI HANGS OR BLOWS UP THEN SEE 'PII' PRINT OR 'PIR' PRINT
 46277	063010				CKI07:	TRPCHK^
 46278	063010	332 00 0 00 030042 	..0064:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46279	063011	254 00 0 00 063014 		JRST	.+3		;DONT IF STAND ALONE
 46280	063012	254 02 1 00 063013 		JRSTF	@.+1		;AND RESTORE THEM
 46281	063013	000000	063014			USERF,.+1		;NEW PC AND FLAGS^
 46282	063014	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46283	063015	264 00 0 00 070072 		CLRTRP
 46284	063016	700 14 0 00 031577 		CLRPI
 46285	063017	700 04 0 00 267760 		CLRAPR
 46286	063020	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38
DFKAA8	MAC	13-Jan-89 10:22		PRIORITY TESTING

 46287					SUBTTL	PRIORITY TESTING
 46288					;THIS TEST CHECKS TO SEE IF INTERRUPTS RECOGNIZE THE PROPER PRIORITY
 46289					;IMPROPER TRAPS WILL HALT - NO TRAPS WILL CAUSE PROGRAM TO HANG
 46290					;IF PROGRAM STUCK THEN REPLACE "JRST ." WITH JRST BACK TO MULT7
 46291					;IF PROGRAM HALTS THEN REPLACE "JSP" IN INTERRUPT LOCATION
 46292					;TO "JSP" TO ROUTINE WHICH CAUSED THE TRAP +1
 46293					;FOR EXAMPLE IF ROUTINE TRAPPED TO LOCATION '50' IN 50
 46294					;YOU WOULD PUT A JSP 17, TO "MULTX ROUTINE+3
 46295
 46296	063021				MULTI:	CLRBT1^
 46297	063021	700 04 0 00 267760 		CLRAPR
 46298	063022	700 14 0 00 031577 		CLRPI^
 46299	063023	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46300						TRAP	<JSP	MULT6>,56^
 46301	063024	200 00 0 00 071106 		MOVE	[JSP	MULT6]		;SET TRAP INSTRUCTION
 46302	063025	202 00 0 00 000056 		MOVEM	56		;INTO TRAP LOCATION^
 46303	063026	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46304						SBWAIT	7^
 46305	063027	7 000 20 0 00 114007 	..0065:	CONO	APR,LESBER!LSSBER!7
 46306						STUCK^^
 46307						WATINT^
 46308	063030	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46309	063031	367 13 0 00 063031 		SOJG	13,.		;AND WAIT^
 46310	063032	254 00 0 00 063032 		JRST	.		;LOOOP ON SELF^
 46311	063033				MULT6:	TRPCHK^
 46312	063033	332 00 0 00 030042 	..0066:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46313	063034	254 00 0 00 063037 		JRST	.+3		;DONT IF STAND ALONE
 46314	063035	254 02 1 00 063036 		JRSTF	@.+1		;AND RESTORE THEM
 46315	063036	000000	063037			USERF,.+1		;NEW PC AND FLAGS^
 46316	063037	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46317						TRAP	<JSP	MULT5>,54^
 46318	063040	200 00 0 00 071107 		MOVE	[JSP	MULT5]		;SET TRAP INSTRUCTION
 46319	063041	202 00 0 00 000054 		MOVEM	54		;INTO TRAP LOCATION^
 46320	063042	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46321						SBWAIT	6^
 46322	063043	7 000 20 0 00 114006 	..0067:	CONO	APR,LESBER!LSSBER!6
 46323						STUCK^^
 46324						WATINT^
 46325	063044	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46326	063045	367 13 0 00 063045 		SOJG	13,.		;AND WAIT^
 46327	063046	254 00 0 00 063046 		JRST	.		;LOOOP ON SELF^
 46328	063047				MULT5:	TRPCHK^
 46329	063047	332 00 0 00 030042 	..0070:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46330	063050	254 00 0 00 063053 		JRST	.+3		;DONT IF STAND ALONE
 46331	063051	254 02 1 00 063052 		JRSTF	@.+1		;AND RESTORE THEM
 46332	063052	000000	063053			USERF,.+1		;NEW PC AND FLAGS^
 46333	063053	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46334						TRAP	<JSP	MULT4>,52^
 46335	063054	200 00 0 00 071110 		MOVE	[JSP	MULT4]		;SET TRAP INSTRUCTION
 46336	063055	202 00 0 00 000052 		MOVEM	52		;INTO TRAP LOCATION^
 46337	063056	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46338						SBWAIT	5^
 46339	063057	7 000 20 0 00 114005 	..0071:	CONO	APR,LESBER!LSSBER!5
 46340						STUCK^^
 46341						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38-1
DFKAA8	MAC	13-Jan-89 10:22		PRIORITY TESTING

 46342	063060	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46343	063061	367 13 0 00 063061 		SOJG	13,.		;AND WAIT^
 46344	063062	254 00 0 00 063062 		JRST	.		;LOOOP ON SELF^
 46345	063063				MULT4:	TRPCHK^
 46346	063063	332 00 0 00 030042 	..0072:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46347	063064	254 00 0 00 063067 		JRST	.+3		;DONT IF STAND ALONE
 46348	063065	254 02 1 00 063066 		JRSTF	@.+1		;AND RESTORE THEM
 46349	063066	000000	063067			USERF,.+1		;NEW PC AND FLAGS^
 46350	063067	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46351						TRAP	<JSP	MULT3>,50^
 46352	063070	200 00 0 00 071111 		MOVE	[JSP	MULT3]		;SET TRAP INSTRUCTION
 46353	063071	202 00 0 00 000050 		MOVEM	50		;INTO TRAP LOCATION^
 46354	063072	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46355						SBWAIT	4^
 46356	063073	7 000 20 0 00 114004 	..0073:	CONO	APR,LESBER!LSSBER!4
 46357						STUCK^^
 46358						WATINT^
 46359	063074	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46360	063075	367 13 0 00 063075 		SOJG	13,.		;AND WAIT^
 46361	063076	254 00 0 00 063076 		JRST	.		;LOOOP ON SELF^
 46362	063077				MULT3:	TRPCHK^
 46363	063077	332 00 0 00 030042 	..0074:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46364	063100	254 00 0 00 063103 		JRST	.+3		;DONT IF STAND ALONE
 46365	063101	254 02 1 00 063102 		JRSTF	@.+1		;AND RESTORE THEM
 46366	063102	000000	063103			USERF,.+1		;NEW PC AND FLAGS^
 46367	063103	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46368						TRAP	<JSP	MULT2>,46^
 46369	063104	200 00 0 00 071112 		MOVE	[JSP	MULT2]		;SET TRAP INSTRUCTION
 46370	063105	202 00 0 00 000046 		MOVEM	46		;INTO TRAP LOCATION^
 46371	063106	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46372						SBWAIT	3^
 46373	063107	7 000 20 0 00 114003 	..0075:	CONO	APR,LESBER!LSSBER!3
 46374						STUCK^^
 46375						WATINT^
 46376	063110	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46377	063111	367 13 0 00 063111 		SOJG	13,.		;AND WAIT^
 46378	063112	254 00 0 00 063112 		JRST	.		;LOOOP ON SELF^
 46379	063113				MULT2:	TRPCHK^
 46380	063113	332 00 0 00 030042 	..0076:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46381	063114	254 00 0 00 063117 		JRST	.+3		;DONT IF STAND ALONE
 46382	063115	254 02 1 00 063116 		JRSTF	@.+1		;AND RESTORE THEM
 46383	063116	000000	063117			USERF,.+1		;NEW PC AND FLAGS^
 46384	063117	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46385						TRAP	<JSP	MULT1>,44^
 46386	063120	200 00 0 00 071113 		MOVE	[JSP	MULT1]		;SET TRAP INSTRUCTION
 46387	063121	202 00 0 00 000044 		MOVEM	44		;INTO TRAP LOCATION^
 46388	063122	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46389						SBWAIT	2^
 46390	063123	7 000 20 0 00 114002 	..0077:	CONO	APR,LESBER!LSSBER!2
 46391						STUCK^^
 46392						WATINT^
 46393	063124	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46394	063125	367 13 0 00 063125 		SOJG	13,.		;AND WAIT^
 46395	063126	254 00 0 00 063126 		JRST	.		;LOOOP ON SELF^
 46396	063127				MULT1:	TRPCHK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 38-2
DFKAA8	MAC	13-Jan-89 10:22		PRIORITY TESTING

 46397	063127	332 00 0 00 030042 	..0100:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46398	063130	254 00 0 00 063133 		JRST	.+3		;DONT IF STAND ALONE
 46399	063131	254 02 1 00 063132 		JRSTF	@.+1		;AND RESTORE THEM
 46400	063132	000000	063133			USERF,.+1		;NEW PC AND FLAGS^
 46401	063133	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46402						TRAP	<JSP	MULT0>,42^
 46403	063134	200 00 0 00 071114 		MOVE	[JSP	MULT0]		;SET TRAP INSTRUCTION
 46404	063135	202 00 0 00 000042 		MOVEM	42		;INTO TRAP LOCATION^
 46405	063136	7 004 20 0 00 002377 		CONO	PI,CHNON+PION+177	;TURN ON PI SYSTEM
 46406						SBWAIT	1^
 46407	063137	7 000 20 0 00 114001 	..0101:	CONO	APR,LESBER!LSSBER!1
 46408						STUCK^^
 46409						WATINT^
 46410	063140	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46411	063141	367 13 0 00 063141 		SOJG	13,.		;AND WAIT^
 46412	063142	254 00 0 00 063142 		JRST	.		;LOOOP ON SELF^
 46413	063143				MULT0:	TRPCHK^
 46414	063143	332 00 0 00 030042 	..0102:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46415	063144	254 00 0 00 063147 		JRST	.+3		;DONT IF STAND ALONE
 46416	063145	254 02 1 00 063146 		JRSTF	@.+1		;AND RESTORE THEM
 46417	063146	000000	063147			USERF,.+1		;NEW PC AND FLAGS^
 46418	063147	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46419						CLRBTH^
 46420	063150	700 04 0 00 267760 		CLRAPR
 46421	063151	700 14 0 00 031577 		CLRPI^
 46422	063152	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46423					SUBTTL	DUAL REQUEST TESTING
 46424					;TEST THAT INTERRUPTING ON 2 CHANNELS AT ONCE TRAPS
 46425					;TO THE CORRECT TRAP. TEST IS DONE ON ALL POSSIBLE CHANNELS I.E.
 46426					;7,1 7,2 7,3 7,4 7,5 7,6 6,1 6,2...ETC
 46427
 46428
 46429	063153				C2A:	TSET^
 46430			063153			%X=.			;DEFINE %X TO SAVE
 46431	063153	201 00 0 00 063153 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46432	063154	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46433						XCHN2	C2B,42,101^
 46434
 46435					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46436					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46437					;IF ERROR OCCURS CHECK "PIN" PRINT
 46438
 46439						TRPCHK^
 46440	063155	332 00 0 00 030042 	..0103:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46441	063156	254 00 0 00 063161 		JRST	.+3		;DONT IF STAND ALONE
 46442	063157	254 02 1 00 063160 		JRSTF	@.+1		;AND RESTORE THEM
 46443	063160	000000	063161			USERF,.+1		;NEW PC AND FLAGS^
 46444						CLRBTH^
 46445	063161	700 04 0 00 267760 		CLRAPR
 46446	063162	700 14 0 00 031577 		CLRPI^
 46447	063163	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46448	063164	200 00 0 00 071115 		MOVE	[JSP C2B]		;SET UP FOR CORRECT
 46449	063165	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 46450	063166	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46451	063167	7 004 20 0 00 004101 		CONO	PI,REQSET!101	;REQUEST INTERRUPT ON TWO CHANNELS
 46452						STUCK^
 46453						WATINT^
 46454	063170	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46455	063171	367 13 0 00 063171 		SOJG	13,.		;AND WAIT^
 46456	063172	254 00 0 00 063172 		JRST	.		;LOOOP ON SELF^
 46457					^
 46458	063173				C2B:	TBOTH^
 46459						TGET^
 46460	063173	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46461	063174	302 00 0 00 063153 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46462						STOP2^^
 46463	063175	254 04 0 00 063176 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46464	063176	254 00 0 00 063177 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46465
 46466						TSET^^
 46467			063177			%X=.			;DEFINE %X TO SAVE
 46468	063177	201 00 0 00 063177 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46469	063200	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46470						XCHN2	C2C,44,41^
 46471
 46472					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46473					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46474					;IF ERROR OCCURS CHECK "PIN" PRINT
 46475
 46476						TRPCHK^
 46477	063201	332 00 0 00 030042 	..0104:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-1
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46478	063202	254 00 0 00 063205 		JRST	.+3		;DONT IF STAND ALONE
 46479	063203	254 02 1 00 063204 		JRSTF	@.+1		;AND RESTORE THEM
 46480	063204	000000	063205			USERF,.+1		;NEW PC AND FLAGS^
 46481						CLRBTH^
 46482	063205	700 04 0 00 267760 		CLRAPR
 46483	063206	700 14 0 00 031577 		CLRPI^
 46484	063207	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46485	063210	200 00 0 00 071116 		MOVE	[JSP C2C]		;SET UP FOR CORRECT
 46486	063211	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 46487	063212	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46488	063213	7 004 20 0 00 004041 		CONO	PI,REQSET!41	;REQUEST INTERRUPT ON TWO CHANNELS
 46489						STUCK^
 46490						WATINT^
 46491	063214	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46492	063215	367 13 0 00 063215 		SOJG	13,.		;AND WAIT^
 46493	063216	254 00 0 00 063216 		JRST	.		;LOOOP ON SELF^
 46494					^
 46495	063217				C2C:	TBOTH^
 46496						TGET^
 46497	063217	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46498	063220	302 00 0 00 063177 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46499						STOP2^^
 46500	063221	254 04 0 00 063222 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46501	063222	254 00 0 00 063223 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46502
 46503						TSET^^
 46504			063223			%X=.			;DEFINE %X TO SAVE
 46505	063223	201 00 0 00 063223 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46506	063224	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46507						XCHN2	C2D,46,21^
 46508
 46509					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46510					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46511					;IF ERROR OCCURS CHECK "PIN" PRINT
 46512
 46513						TRPCHK^
 46514	063225	332 00 0 00 030042 	..0105:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46515	063226	254 00 0 00 063231 		JRST	.+3		;DONT IF STAND ALONE
 46516	063227	254 02 1 00 063230 		JRSTF	@.+1		;AND RESTORE THEM
 46517	063230	000000	063231			USERF,.+1		;NEW PC AND FLAGS^
 46518						CLRBTH^
 46519	063231	700 04 0 00 267760 		CLRAPR
 46520	063232	700 14 0 00 031577 		CLRPI^
 46521	063233	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46522	063234	200 00 0 00 071117 		MOVE	[JSP C2D]		;SET UP FOR CORRECT
 46523	063235	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 46524	063236	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46525	063237	7 004 20 0 00 004021 		CONO	PI,REQSET!21	;REQUEST INTERRUPT ON TWO CHANNELS
 46526						STUCK^
 46527						WATINT^
 46528	063240	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46529	063241	367 13 0 00 063241 		SOJG	13,.		;AND WAIT^
 46530	063242	254 00 0 00 063242 		JRST	.		;LOOOP ON SELF^
 46531					^
 46532	063243				C2D:	TBOTH^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-2
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46533						TGET^
 46534	063243	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46535	063244	302 00 0 00 063223 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46536						STOP2^^
 46537	063245	254 04 0 00 063246 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46538	063246	254 00 0 00 063247 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46539
 46540						TSET^^
 46541			063247			%X=.			;DEFINE %X TO SAVE
 46542	063247	201 00 0 00 063247 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46543	063250	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46544						XCHN2	C2E,50,11^
 46545
 46546					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46547					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46548					;IF ERROR OCCURS CHECK "PIN" PRINT
 46549
 46550						TRPCHK^
 46551	063251	332 00 0 00 030042 	..0106:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46552	063252	254 00 0 00 063255 		JRST	.+3		;DONT IF STAND ALONE
 46553	063253	254 02 1 00 063254 		JRSTF	@.+1		;AND RESTORE THEM
 46554	063254	000000	063255			USERF,.+1		;NEW PC AND FLAGS^
 46555						CLRBTH^
 46556	063255	700 04 0 00 267760 		CLRAPR
 46557	063256	700 14 0 00 031577 		CLRPI^
 46558	063257	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46559	063260	200 00 0 00 071120 		MOVE	[JSP C2E]		;SET UP FOR CORRECT
 46560	063261	202 00 0 00 000050 		MOVEM	50		;INTERRUPT TRAP
 46561	063262	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46562	063263	7 004 20 0 00 004011 		CONO	PI,REQSET!11	;REQUEST INTERRUPT ON TWO CHANNELS
 46563						STUCK^
 46564						WATINT^
 46565	063264	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46566	063265	367 13 0 00 063265 		SOJG	13,.		;AND WAIT^
 46567	063266	254 00 0 00 063266 		JRST	.		;LOOOP ON SELF^
 46568					^
 46569	063267				C2E:	TBOTH^
 46570						TGET^
 46571	063267	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46572	063270	302 00 0 00 063247 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46573						STOP2^^
 46574	063271	254 04 0 00 063272 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46575	063272	254 00 0 00 063273 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46576
 46577						TSET^^
 46578			063273			%X=.			;DEFINE %X TO SAVE
 46579	063273	201 00 0 00 063273 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46580	063274	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46581						XCHN2	C2F,52,5^
 46582
 46583					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46584					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46585					;IF ERROR OCCURS CHECK "PIN" PRINT
 46586
 46587						TRPCHK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-3
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46588	063275	332 00 0 00 030042 	..0107:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46589	063276	254 00 0 00 063301 		JRST	.+3		;DONT IF STAND ALONE
 46590	063277	254 02 1 00 063300 		JRSTF	@.+1		;AND RESTORE THEM
 46591	063300	000000	063301			USERF,.+1		;NEW PC AND FLAGS^
 46592						CLRBTH^
 46593	063301	700 04 0 00 267760 		CLRAPR
 46594	063302	700 14 0 00 031577 		CLRPI^
 46595	063303	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46596	063304	200 00 0 00 071121 		MOVE	[JSP C2F]		;SET UP FOR CORRECT
 46597	063305	202 00 0 00 000052 		MOVEM	52		;INTERRUPT TRAP
 46598	063306	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46599	063307	7 004 20 0 00 004005 		CONO	PI,REQSET!5	;REQUEST INTERRUPT ON TWO CHANNELS
 46600						STUCK^
 46601						WATINT^
 46602	063310	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46603	063311	367 13 0 00 063311 		SOJG	13,.		;AND WAIT^
 46604	063312	254 00 0 00 063312 		JRST	.		;LOOOP ON SELF^
 46605					^
 46606	063313				C2F:	TBOTH^
 46607						TGET^
 46608	063313	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46609	063314	302 00 0 00 063273 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46610						STOP2^^
 46611	063315	254 04 0 00 063316 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46612	063316	254 00 0 00 063317 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46613
 46614						TSET^^
 46615			063317			%X=.			;DEFINE %X TO SAVE
 46616	063317	201 00 0 00 063317 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46617	063320	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46618						XCHN2	C2G,54,3^
 46619
 46620					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46621					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46622					;IF ERROR OCCURS CHECK "PIN" PRINT
 46623
 46624						TRPCHK^
 46625	063321	332 00 0 00 030042 	..0110:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46626	063322	254 00 0 00 063325 		JRST	.+3		;DONT IF STAND ALONE
 46627	063323	254 02 1 00 063324 		JRSTF	@.+1		;AND RESTORE THEM
 46628	063324	000000	063325			USERF,.+1		;NEW PC AND FLAGS^
 46629						CLRBTH^
 46630	063325	700 04 0 00 267760 		CLRAPR
 46631	063326	700 14 0 00 031577 		CLRPI^
 46632	063327	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46633	063330	200 00 0 00 071122 		MOVE	[JSP C2G]		;SET UP FOR CORRECT
 46634	063331	202 00 0 00 000054 		MOVEM	54		;INTERRUPT TRAP
 46635	063332	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46636	063333	7 004 20 0 00 004003 		CONO	PI,REQSET!3	;REQUEST INTERRUPT ON TWO CHANNELS
 46637						STUCK^
 46638						WATINT^
 46639	063334	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46640	063335	367 13 0 00 063335 		SOJG	13,.		;AND WAIT^
 46641	063336	254 00 0 00 063336 		JRST	.		;LOOOP ON SELF^
 46642					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-4
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46643	063337				C2G:	TBOTH^
 46644						TGET^
 46645	063337	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46646	063340	302 00 0 00 063317 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46647						STOP2^^
 46648	063341	254 04 0 00 063342 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46649	063342	254 00 0 00 063343 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46650
 46651						TSET^^
 46652			063343			%X=.			;DEFINE %X TO SAVE
 46653	063343	201 00 0 00 063343 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46654	063344	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46655						XCHN2	C2H,42,102^
 46656
 46657					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46658					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46659					;IF ERROR OCCURS CHECK "PIN" PRINT
 46660
 46661						TRPCHK^
 46662	063345	332 00 0 00 030042 	..0111:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46663	063346	254 00 0 00 063351 		JRST	.+3		;DONT IF STAND ALONE
 46664	063347	254 02 1 00 063350 		JRSTF	@.+1		;AND RESTORE THEM
 46665	063350	000000	063351			USERF,.+1		;NEW PC AND FLAGS^
 46666						CLRBTH^
 46667	063351	700 04 0 00 267760 		CLRAPR
 46668	063352	700 14 0 00 031577 		CLRPI^
 46669	063353	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46670	063354	200 00 0 00 071123 		MOVE	[JSP C2H]		;SET UP FOR CORRECT
 46671	063355	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 46672	063356	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46673	063357	7 004 20 0 00 004102 		CONO	PI,REQSET!102	;REQUEST INTERRUPT ON TWO CHANNELS
 46674						STUCK^
 46675						WATINT^
 46676	063360	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46677	063361	367 13 0 00 063361 		SOJG	13,.		;AND WAIT^
 46678	063362	254 00 0 00 063362 		JRST	.		;LOOOP ON SELF^
 46679					^
 46680	063363				C2H:	TBOTH^
 46681						TGET^
 46682	063363	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46683	063364	302 00 0 00 063343 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46684						STOP2^^
 46685	063365	254 04 0 00 063366 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46686	063366	254 00 0 00 063367 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46687
 46688						TSET^^
 46689			063367			%X=.			;DEFINE %X TO SAVE
 46690	063367	201 00 0 00 063367 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46691	063370	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46692						XCHN2	C2I,44,42^
 46693
 46694					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46695					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46696					;IF ERROR OCCURS CHECK "PIN" PRINT
 46697
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-5
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46698						TRPCHK^
 46699	063371	332 00 0 00 030042 	..0112:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46700	063372	254 00 0 00 063375 		JRST	.+3		;DONT IF STAND ALONE
 46701	063373	254 02 1 00 063374 		JRSTF	@.+1		;AND RESTORE THEM
 46702	063374	000000	063375			USERF,.+1		;NEW PC AND FLAGS^
 46703						CLRBTH^
 46704	063375	700 04 0 00 267760 		CLRAPR
 46705	063376	700 14 0 00 031577 		CLRPI^
 46706	063377	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46707	063400	200 00 0 00 071124 		MOVE	[JSP C2I]		;SET UP FOR CORRECT
 46708	063401	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 46709	063402	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46710	063403	7 004 20 0 00 004042 		CONO	PI,REQSET!42	;REQUEST INTERRUPT ON TWO CHANNELS
 46711						STUCK^
 46712						WATINT^
 46713	063404	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46714	063405	367 13 0 00 063405 		SOJG	13,.		;AND WAIT^
 46715	063406	254 00 0 00 063406 		JRST	.		;LOOOP ON SELF^
 46716					^
 46717	063407				C2I:	TBOTH^
 46718						TGET^
 46719	063407	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46720	063410	302 00 0 00 063367 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46721						STOP2^^
 46722	063411	254 04 0 00 063412 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46723	063412	254 00 0 00 063413 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46724
 46725						TSET^^
 46726			063413			%X=.			;DEFINE %X TO SAVE
 46727	063413	201 00 0 00 063413 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46728	063414	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46729						XCHN2	C2J,46,22^
 46730
 46731					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46732					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46733					;IF ERROR OCCURS CHECK "PIN" PRINT
 46734
 46735						TRPCHK^
 46736	063415	332 00 0 00 030042 	..0113:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46737	063416	254 00 0 00 063421 		JRST	.+3		;DONT IF STAND ALONE
 46738	063417	254 02 1 00 063420 		JRSTF	@.+1		;AND RESTORE THEM
 46739	063420	000000	063421			USERF,.+1		;NEW PC AND FLAGS^
 46740						CLRBTH^
 46741	063421	700 04 0 00 267760 		CLRAPR
 46742	063422	700 14 0 00 031577 		CLRPI^
 46743	063423	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46744	063424	200 00 0 00 071125 		MOVE	[JSP C2J]		;SET UP FOR CORRECT
 46745	063425	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 46746	063426	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46747	063427	7 004 20 0 00 004022 		CONO	PI,REQSET!22	;REQUEST INTERRUPT ON TWO CHANNELS
 46748						STUCK^
 46749						WATINT^
 46750	063430	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46751	063431	367 13 0 00 063431 		SOJG	13,.		;AND WAIT^
 46752	063432	254 00 0 00 063432 		JRST	.		;LOOOP ON SELF^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-6
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46753					^
 46754	063433				C2J:	TBOTH^
 46755						TGET^
 46756	063433	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46757	063434	302 00 0 00 063413 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46758						STOP2^^
 46759	063435	254 04 0 00 063436 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46760	063436	254 00 0 00 063437 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46761
 46762						TSET^^
 46763			063437			%X=.			;DEFINE %X TO SAVE
 46764	063437	201 00 0 00 063437 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46765	063440	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46766						XCHN2	C2K,50,12^
 46767
 46768					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46769					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46770					;IF ERROR OCCURS CHECK "PIN" PRINT
 46771
 46772						TRPCHK^
 46773	063441	332 00 0 00 030042 	..0114:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46774	063442	254 00 0 00 063445 		JRST	.+3		;DONT IF STAND ALONE
 46775	063443	254 02 1 00 063444 		JRSTF	@.+1		;AND RESTORE THEM
 46776	063444	000000	063445			USERF,.+1		;NEW PC AND FLAGS^
 46777						CLRBTH^
 46778	063445	700 04 0 00 267760 		CLRAPR
 46779	063446	700 14 0 00 031577 		CLRPI^
 46780	063447	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46781	063450	200 00 0 00 071126 		MOVE	[JSP C2K]		;SET UP FOR CORRECT
 46782	063451	202 00 0 00 000050 		MOVEM	50		;INTERRUPT TRAP
 46783	063452	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46784	063453	7 004 20 0 00 004012 		CONO	PI,REQSET!12	;REQUEST INTERRUPT ON TWO CHANNELS
 46785						STUCK^
 46786						WATINT^
 46787	063454	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46788	063455	367 13 0 00 063455 		SOJG	13,.		;AND WAIT^
 46789	063456	254 00 0 00 063456 		JRST	.		;LOOOP ON SELF^
 46790					^
 46791	063457				C2K:	TBOTH^
 46792						TGET^
 46793	063457	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46794	063460	302 00 0 00 063437 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46795						STOP2^^
 46796	063461	254 04 0 00 063462 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46797	063462	254 00 0 00 063463 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46798
 46799						TSET^^
 46800			063463			%X=.			;DEFINE %X TO SAVE
 46801	063463	201 00 0 00 063463 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46802	063464	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46803						XCHN2	C2L,52,6^
 46804
 46805					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46806					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46807					;IF ERROR OCCURS CHECK "PIN" PRINT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-7
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46808
 46809						TRPCHK^
 46810	063465	332 00 0 00 030042 	..0115:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46811	063466	254 00 0 00 063471 		JRST	.+3		;DONT IF STAND ALONE
 46812	063467	254 02 1 00 063470 		JRSTF	@.+1		;AND RESTORE THEM
 46813	063470	000000	063471			USERF,.+1		;NEW PC AND FLAGS^
 46814						CLRBTH^
 46815	063471	700 04 0 00 267760 		CLRAPR
 46816	063472	700 14 0 00 031577 		CLRPI^
 46817	063473	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46818	063474	200 00 0 00 071127 		MOVE	[JSP C2L]		;SET UP FOR CORRECT
 46819	063475	202 00 0 00 000052 		MOVEM	52		;INTERRUPT TRAP
 46820	063476	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46821	063477	7 004 20 0 00 004006 		CONO	PI,REQSET!6	;REQUEST INTERRUPT ON TWO CHANNELS
 46822						STUCK^
 46823						WATINT^
 46824	063500	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46825	063501	367 13 0 00 063501 		SOJG	13,.		;AND WAIT^
 46826	063502	254 00 0 00 063502 		JRST	.		;LOOOP ON SELF^
 46827					^
 46828	063503				C2L:	TBOTH^
 46829						TGET^
 46830	063503	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46831	063504	302 00 0 00 063463 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46832						STOP2^^
 46833	063505	254 04 0 00 063506 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46834	063506	254 00 0 00 063507 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46835
 46836						TSET^^
 46837			063507			%X=.			;DEFINE %X TO SAVE
 46838	063507	201 00 0 00 063507 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46839	063510	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46840						XCHN2	C2M,42,104^
 46841
 46842					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46843					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46844					;IF ERROR OCCURS CHECK "PIN" PRINT
 46845
 46846						TRPCHK^
 46847	063511	332 00 0 00 030042 	..0116:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46848	063512	254 00 0 00 063515 		JRST	.+3		;DONT IF STAND ALONE
 46849	063513	254 02 1 00 063514 		JRSTF	@.+1		;AND RESTORE THEM
 46850	063514	000000	063515			USERF,.+1		;NEW PC AND FLAGS^
 46851						CLRBTH^
 46852	063515	700 04 0 00 267760 		CLRAPR
 46853	063516	700 14 0 00 031577 		CLRPI^
 46854	063517	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46855	063520	200 00 0 00 071130 		MOVE	[JSP C2M]		;SET UP FOR CORRECT
 46856	063521	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 46857	063522	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46858	063523	7 004 20 0 00 004104 		CONO	PI,REQSET!104	;REQUEST INTERRUPT ON TWO CHANNELS
 46859						STUCK^
 46860						WATINT^
 46861	063524	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46862	063525	367 13 0 00 063525 		SOJG	13,.		;AND WAIT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-8
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46863	063526	254 00 0 00 063526 		JRST	.		;LOOOP ON SELF^
 46864					^
 46865	063527				C2M:	TBOTH^
 46866						TGET^
 46867	063527	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46868	063530	302 00 0 00 063507 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46869						STOP2^^
 46870	063531	254 04 0 00 063532 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46871	063532	254 00 0 00 063533 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46872
 46873						TSET^^
 46874			063533			%X=.			;DEFINE %X TO SAVE
 46875	063533	201 00 0 00 063533 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46876	063534	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46877						XCHN2	C2N,44,44^
 46878
 46879					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46880					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46881					;IF ERROR OCCURS CHECK "PIN" PRINT
 46882
 46883						TRPCHK^
 46884	063535	332 00 0 00 030042 	..0117:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46885	063536	254 00 0 00 063541 		JRST	.+3		;DONT IF STAND ALONE
 46886	063537	254 02 1 00 063540 		JRSTF	@.+1		;AND RESTORE THEM
 46887	063540	000000	063541			USERF,.+1		;NEW PC AND FLAGS^
 46888						CLRBTH^
 46889	063541	700 04 0 00 267760 		CLRAPR
 46890	063542	700 14 0 00 031577 		CLRPI^
 46891	063543	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46892	063544	200 00 0 00 071131 		MOVE	[JSP C2N]		;SET UP FOR CORRECT
 46893	063545	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 46894	063546	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46895	063547	7 004 20 0 00 004044 		CONO	PI,REQSET!44	;REQUEST INTERRUPT ON TWO CHANNELS
 46896						STUCK^
 46897						WATINT^
 46898	063550	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46899	063551	367 13 0 00 063551 		SOJG	13,.		;AND WAIT^
 46900	063552	254 00 0 00 063552 		JRST	.		;LOOOP ON SELF^
 46901					^
 46902	063553				C2N:	TBOTH^
 46903						TGET^
 46904	063553	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46905	063554	302 00 0 00 063533 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46906						STOP2^^
 46907	063555	254 04 0 00 063556 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46908	063556	254 00 0 00 063557 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46909
 46910						TSET^^
 46911			063557			%X=.			;DEFINE %X TO SAVE
 46912	063557	201 00 0 00 063557 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46913	063560	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46914						XCHN2	C2O,46,24^
 46915
 46916					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46917					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-9
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46918					;IF ERROR OCCURS CHECK "PIN" PRINT
 46919
 46920						TRPCHK^
 46921	063561	332 00 0 00 030042 	..0120:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46922	063562	254 00 0 00 063565 		JRST	.+3		;DONT IF STAND ALONE
 46923	063563	254 02 1 00 063564 		JRSTF	@.+1		;AND RESTORE THEM
 46924	063564	000000	063565			USERF,.+1		;NEW PC AND FLAGS^
 46925						CLRBTH^
 46926	063565	700 04 0 00 267760 		CLRAPR
 46927	063566	700 14 0 00 031577 		CLRPI^
 46928	063567	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46929	063570	200 00 0 00 071132 		MOVE	[JSP C2O]		;SET UP FOR CORRECT
 46930	063571	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 46931	063572	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46932	063573	7 004 20 0 00 004024 		CONO	PI,REQSET!24	;REQUEST INTERRUPT ON TWO CHANNELS
 46933						STUCK^
 46934						WATINT^
 46935	063574	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 46936	063575	367 13 0 00 063575 		SOJG	13,.		;AND WAIT^
 46937	063576	254 00 0 00 063576 		JRST	.		;LOOOP ON SELF^
 46938					^
 46939	063577				C2O:	TBOTH^
 46940						TGET^
 46941	063577	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46942	063600	302 00 0 00 063557 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46943						STOP2^^
 46944	063601	254 04 0 00 063602 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46945	063602	254 00 0 00 063603 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46946
 46947						TSET^^
 46948			063603			%X=.			;DEFINE %X TO SAVE
 46949	063603	201 00 0 00 063603 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46950	063604	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46951						XCHN2	C2P,50,14^
 46952
 46953					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46954					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46955					;IF ERROR OCCURS CHECK "PIN" PRINT
 46956
 46957						TRPCHK^
 46958	063605	332 00 0 00 030042 	..0121:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46959	063606	254 00 0 00 063611 		JRST	.+3		;DONT IF STAND ALONE
 46960	063607	254 02 1 00 063610 		JRSTF	@.+1		;AND RESTORE THEM
 46961	063610	000000	063611			USERF,.+1		;NEW PC AND FLAGS^
 46962						CLRBTH^
 46963	063611	700 04 0 00 267760 		CLRAPR
 46964	063612	700 14 0 00 031577 		CLRPI^
 46965	063613	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 46966	063614	200 00 0 00 071133 		MOVE	[JSP C2P]		;SET UP FOR CORRECT
 46967	063615	202 00 0 00 000050 		MOVEM	50		;INTERRUPT TRAP
 46968	063616	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 46969	063617	7 004 20 0 00 004014 		CONO	PI,REQSET!14	;REQUEST INTERRUPT ON TWO CHANNELS
 46970						STUCK^
 46971						WATINT^
 46972	063620	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-10
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 46973	063621	367 13 0 00 063621 		SOJG	13,.		;AND WAIT^
 46974	063622	254 00 0 00 063622 		JRST	.		;LOOOP ON SELF^
 46975					^
 46976	063623				C2P:	TBOTH^
 46977						TGET^
 46978	063623	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 46979	063624	302 00 0 00 063603 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 46980						STOP2^^
 46981	063625	254 04 0 00 063626 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 46982	063626	254 00 0 00 063627 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 46983
 46984						TSET^^
 46985			063627			%X=.			;DEFINE %X TO SAVE
 46986	063627	201 00 0 00 063627 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 46987	063630	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 46988						XCHN2	C2Q,42,110^
 46989
 46990					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 46991					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 46992					;IF ERROR OCCURS CHECK "PIN" PRINT
 46993
 46994						TRPCHK^
 46995	063631	332 00 0 00 030042 	..0122:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 46996	063632	254 00 0 00 063635 		JRST	.+3		;DONT IF STAND ALONE
 46997	063633	254 02 1 00 063634 		JRSTF	@.+1		;AND RESTORE THEM
 46998	063634	000000	063635			USERF,.+1		;NEW PC AND FLAGS^
 46999						CLRBTH^
 47000	063635	700 04 0 00 267760 		CLRAPR
 47001	063636	700 14 0 00 031577 		CLRPI^
 47002	063637	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47003	063640	200 00 0 00 071134 		MOVE	[JSP C2Q]		;SET UP FOR CORRECT
 47004	063641	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 47005	063642	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47006	063643	7 004 20 0 00 004110 		CONO	PI,REQSET!110	;REQUEST INTERRUPT ON TWO CHANNELS
 47007						STUCK^
 47008						WATINT^
 47009	063644	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47010	063645	367 13 0 00 063645 		SOJG	13,.		;AND WAIT^
 47011	063646	254 00 0 00 063646 		JRST	.		;LOOOP ON SELF^
 47012					^
 47013	063647				C2Q:	TBOTH^
 47014						TGET^
 47015	063647	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47016	063650	302 00 0 00 063627 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47017						STOP2^^
 47018	063651	254 04 0 00 063652 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47019	063652	254 00 0 00 063653 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47020
 47021						TSET^^
 47022			063653			%X=.			;DEFINE %X TO SAVE
 47023	063653	201 00 0 00 063653 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47024	063654	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47025						XCHN2	C2R,44,50^
 47026
 47027					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-11
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 47028					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47029					;IF ERROR OCCURS CHECK "PIN" PRINT
 47030
 47031						TRPCHK^
 47032	063655	332 00 0 00 030042 	..0123:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47033	063656	254 00 0 00 063661 		JRST	.+3		;DONT IF STAND ALONE
 47034	063657	254 02 1 00 063660 		JRSTF	@.+1		;AND RESTORE THEM
 47035	063660	000000	063661			USERF,.+1		;NEW PC AND FLAGS^
 47036						CLRBTH^
 47037	063661	700 04 0 00 267760 		CLRAPR
 47038	063662	700 14 0 00 031577 		CLRPI^
 47039	063663	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47040	063664	200 00 0 00 071135 		MOVE	[JSP C2R]		;SET UP FOR CORRECT
 47041	063665	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 47042	063666	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47043	063667	7 004 20 0 00 004050 		CONO	PI,REQSET!50	;REQUEST INTERRUPT ON TWO CHANNELS
 47044						STUCK^
 47045						WATINT^
 47046	063670	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47047	063671	367 13 0 00 063671 		SOJG	13,.		;AND WAIT^
 47048	063672	254 00 0 00 063672 		JRST	.		;LOOOP ON SELF^
 47049					^
 47050	063673				C2R:	TBOTH^
 47051						TGET^
 47052	063673	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47053	063674	302 00 0 00 063653 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47054						STOP2^^
 47055	063675	254 04 0 00 063676 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47056	063676	254 00 0 00 063677 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47057
 47058						TSET^^
 47059			063677			%X=.			;DEFINE %X TO SAVE
 47060	063677	201 00 0 00 063677 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47061	063700	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47062						XCHN2	C2S,46,30^
 47063
 47064					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47065					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47066					;IF ERROR OCCURS CHECK "PIN" PRINT
 47067
 47068						TRPCHK^
 47069	063701	332 00 0 00 030042 	..0124:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47070	063702	254 00 0 00 063705 		JRST	.+3		;DONT IF STAND ALONE
 47071	063703	254 02 1 00 063704 		JRSTF	@.+1		;AND RESTORE THEM
 47072	063704	000000	063705			USERF,.+1		;NEW PC AND FLAGS^
 47073						CLRBTH^
 47074	063705	700 04 0 00 267760 		CLRAPR
 47075	063706	700 14 0 00 031577 		CLRPI^
 47076	063707	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47077	063710	200 00 0 00 071136 		MOVE	[JSP C2S]		;SET UP FOR CORRECT
 47078	063711	202 00 0 00 000046 		MOVEM	46		;INTERRUPT TRAP
 47079	063712	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47080	063713	7 004 20 0 00 004030 		CONO	PI,REQSET!30	;REQUEST INTERRUPT ON TWO CHANNELS
 47081						STUCK^
 47082						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-12
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 47083	063714	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47084	063715	367 13 0 00 063715 		SOJG	13,.		;AND WAIT^
 47085	063716	254 00 0 00 063716 		JRST	.		;LOOOP ON SELF^
 47086					^
 47087	063717				C2S:	TBOTH^
 47088						TGET^
 47089	063717	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47090	063720	302 00 0 00 063677 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47091						STOP2^^
 47092	063721	254 04 0 00 063722 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47093	063722	254 00 0 00 063723 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47094
 47095						TSET^^
 47096			063723			%X=.			;DEFINE %X TO SAVE
 47097	063723	201 00 0 00 063723 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47098	063724	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47099						XCHN2	C2T,42,120^
 47100
 47101					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47102					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47103					;IF ERROR OCCURS CHECK "PIN" PRINT
 47104
 47105						TRPCHK^
 47106	063725	332 00 0 00 030042 	..0125:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47107	063726	254 00 0 00 063731 		JRST	.+3		;DONT IF STAND ALONE
 47108	063727	254 02 1 00 063730 		JRSTF	@.+1		;AND RESTORE THEM
 47109	063730	000000	063731			USERF,.+1		;NEW PC AND FLAGS^
 47110						CLRBTH^
 47111	063731	700 04 0 00 267760 		CLRAPR
 47112	063732	700 14 0 00 031577 		CLRPI^
 47113	063733	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47114	063734	200 00 0 00 071137 		MOVE	[JSP C2T]		;SET UP FOR CORRECT
 47115	063735	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 47116	063736	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47117	063737	7 004 20 0 00 004120 		CONO	PI,REQSET!120	;REQUEST INTERRUPT ON TWO CHANNELS
 47118						STUCK^
 47119						WATINT^
 47120	063740	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47121	063741	367 13 0 00 063741 		SOJG	13,.		;AND WAIT^
 47122	063742	254 00 0 00 063742 		JRST	.		;LOOOP ON SELF^
 47123					^
 47124	063743				C2T:	TBOTH^
 47125						TGET^
 47126	063743	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47127	063744	302 00 0 00 063723 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47128						STOP2^^
 47129	063745	254 04 0 00 063746 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47130	063746	254 00 0 00 063747 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47131
 47132						TSET^^
 47133			063747			%X=.			;DEFINE %X TO SAVE
 47134	063747	201 00 0 00 063747 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47135	063750	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47136						XCHN2	C2U,44,60^
 47137
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-13
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 47138					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47139					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47140					;IF ERROR OCCURS CHECK "PIN" PRINT
 47141
 47142						TRPCHK^
 47143	063751	332 00 0 00 030042 	..0126:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47144	063752	254 00 0 00 063755 		JRST	.+3		;DONT IF STAND ALONE
 47145	063753	254 02 1 00 063754 		JRSTF	@.+1		;AND RESTORE THEM
 47146	063754	000000	063755			USERF,.+1		;NEW PC AND FLAGS^
 47147						CLRBTH^
 47148	063755	700 04 0 00 267760 		CLRAPR
 47149	063756	700 14 0 00 031577 		CLRPI^
 47150	063757	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47151	063760	200 00 0 00 071140 		MOVE	[JSP C2U]		;SET UP FOR CORRECT
 47152	063761	202 00 0 00 000044 		MOVEM	44		;INTERRUPT TRAP
 47153	063762	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47154	063763	7 004 20 0 00 004060 		CONO	PI,REQSET!60	;REQUEST INTERRUPT ON TWO CHANNELS
 47155						STUCK^
 47156						WATINT^
 47157	063764	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47158	063765	367 13 0 00 063765 		SOJG	13,.		;AND WAIT^
 47159	063766	254 00 0 00 063766 		JRST	.		;LOOOP ON SELF^
 47160					^
 47161	063767				C2U:	TBOTH^
 47162						TGET^
 47163	063767	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47164	063770	302 00 0 00 063747 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47165						STOP2^^
 47166	063771	254 04 0 00 063772 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47167	063772	254 00 0 00 063773 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47168
 47169						TSET^^
 47170			063773			%X=.			;DEFINE %X TO SAVE
 47171	063773	201 00 0 00 063773 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47172	063774	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47173						XCHN2	C2V,42,140^
 47174
 47175					;REQUEST INTERRUPTS ON 2 CHANNELS AT ONCE TO SEE IF THEY TRAP
 47176					;TO THE CORRECT (I.E. HIGHEST PRIORITY) CHANNEL.
 47177					;IF ERROR OCCURS CHECK "PIN" PRINT
 47178
 47179						TRPCHK^
 47180	063775	332 00 0 00 030042 	..0127:	SKIPE	MONFLG		;RESET FLAGS IF IN MONITOR
 47181	063776	254 00 0 00 064001 		JRST	.+3		;DONT IF STAND ALONE
 47182	063777	254 02 1 00 064000 		JRSTF	@.+1		;AND RESTORE THEM
 47183	064000	000000	064001			USERF,.+1		;NEW PC AND FLAGS^
 47184						CLRBTH^
 47185	064001	700 04 0 00 267760 		CLRAPR
 47186	064002	700 14 0 00 031577 		CLRPI^
 47187	064003	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47188	064004	200 00 0 00 071141 		MOVE	[JSP C2V]		;SET UP FOR CORRECT
 47189	064005	202 00 0 00 000042 		MOVEM	42		;INTERRUPT TRAP
 47190	064006	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47191	064007	7 004 20 0 00 004140 		CONO	PI,REQSET!140	;REQUEST INTERRUPT ON TWO CHANNELS
 47192						STUCK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 39-14
DFKAA8	MAC	13-Jan-89 10:22		DUAL REQUEST TESTING

 47193						WATINT^
 47194	064010	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47195	064011	367 13 0 00 064011 		SOJG	13,.		;AND WAIT^
 47196	064012	254 00 0 00 064012 		JRST	.		;LOOOP ON SELF^
 47197					^
 47198	064013	255 00 0 00 000000 		JFCL
 47199	064014				C2V:	TGET^
 47200	064014	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47201	064015	302 00 0 00 063773 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47202						STOP2^^
 47203	064016	254 04 0 00 064017 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47204	064017	254 00 0 00 064020 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47205						CLRBTH^
 47206	064020	700 04 0 00 267760 		CLRAPR
 47207	064021	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47208					SUBTTL	BASIC NO-SKIP TESTING
 47209					;TEST THE PREFORMANCE OF NO SKIPPING INSTRUCTIONS IN THE INTERRUPT LOCATIONS
 47210					;OUT OF EACH POSSIBLE INTERRUPT LOCATION
 47211
 47212			000100			X=100
 47213			000042			Y=42
 47214					SKIPNO:	REPEAT	7,<
 47215						PSKPA	Y,X
 47216						PSKPB	Y,X
 47217						Y=Y+2
 47218						X=X_-1
 47219					>
 47220
 47221						PSKPA	Y,X^
 47222
 47223					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47224					;AN INTERRUPT INSTRUCTION.
 47225
 47226						CLRBTH^
 47227	064022	700 04 0 00 267760 		CLRAPR
 47228	064023	700 14 0 00 031577 		CLRPI^
 47229	064024	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47230	064025	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47231	064026	202 00 0 00 000042 		MOVEM	Y		;INTO TRAP LOCATION
 47232	064027	200 00 0 00 071143 		MOVE	[JSP 1,..0130]	;SECOND TRAP INSTRUCTION
 47233	064030	202 00 0 00 000043 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47234	064031	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47235	064032	7 004 20 0 00 006300 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47236
 47237					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47238
 47239						WATINT^
 47240	064033	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47241	064034	367 13 0 00 064034 		SOJG	13,.		;AND WAIT^
 47242						STOP^
 47243	064035	254 04 0 00 064036 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47244	064036	254 00 0 00 064037 		JRST	.+1		;WITH JRST BACK^
 47245	064037				..0130:	CLRBTH^
 47246	064037	700 04 0 00 267760 		CLRAPR
 47247	064040	700 14 0 00 031577 		CLRPI^
 47248	064041	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47249						STOP^
 47250	064042	254 04 0 00 064043 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47251	064043	254 00 0 00 064044 		JRST	.+1		;WITH JRST BACK^
 47252					^
 47253						PSKPB	Y,X^
 47254
 47255					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47256					;THE INTERRUPT.
 47257
 47258						CLRBTH^
 47259	064044	700 04 0 00 267760 		CLRAPR
 47260	064045	700 14 0 00 031577 		CLRPI^
 47261	064046	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47262	064047	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-1
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47263	064050	202 00 0 00 000042 		MOVEM	Y		;INTO TRAP LOCATION
 47264	064051	200 00 0 00 071145 		MOVE	[JSP 1,..0131]	;SECOND TRAP INSTRUCTION
 47265	064052	202 00 0 00 000043 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47266	064053	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47267	064054	7 004 20 0 00 006300 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47268
 47269					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47270
 47271						WATINT^
 47272	064055	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47273	064056	367 13 0 00 064056 		SOJG	13,.		;AND WAIT^
 47274						STOP^
 47275	064057	254 04 0 00 064060 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47276	064060	254 00 0 00 064061 		JRST	.+1		;WITH JRST BACK^
 47277	064061				..0131:	CLRBTH^
 47278	064061	700 04 0 00 267760 		CLRAPR
 47279	064062	700 14 0 00 031577 		CLRPI^
 47280	064063	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47281						STOP^
 47282	064064	254 04 0 00 064065 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47283	064065	254 00 0 00 064066 		JRST	.+1		;WITH JRST BACK^
 47284					^
 47285			000044			Y=Y+2
 47286			000040			X=X_-1
 47287
 47288
 47289						PSKPA	Y,X^
 47290
 47291					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47292					;AN INTERRUPT INSTRUCTION.
 47293
 47294						CLRBTH^
 47295	064066	700 04 0 00 267760 		CLRAPR
 47296	064067	700 14 0 00 031577 		CLRPI^
 47297	064070	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47298	064071	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47299	064072	202 00 0 00 000044 		MOVEM	Y		;INTO TRAP LOCATION
 47300	064073	200 00 0 00 071146 		MOVE	[JSP 1,..0132]	;SECOND TRAP INSTRUCTION
 47301	064074	202 00 0 00 000045 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47302	064075	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47303	064076	7 004 20 0 00 006240 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47304
 47305					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47306
 47307						WATINT^
 47308	064077	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47309	064100	367 13 0 00 064100 		SOJG	13,.		;AND WAIT^
 47310						STOP^
 47311	064101	254 04 0 00 064102 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47312	064102	254 00 0 00 064103 		JRST	.+1		;WITH JRST BACK^
 47313	064103				..0132:	CLRBTH^
 47314	064103	700 04 0 00 267760 		CLRAPR
 47315	064104	700 14 0 00 031577 		CLRPI^
 47316	064105	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47317						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-2
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47318	064106	254 04 0 00 064107 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47319	064107	254 00 0 00 064110 		JRST	.+1		;WITH JRST BACK^
 47320					^
 47321						PSKPB	Y,X^
 47322
 47323					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47324					;THE INTERRUPT.
 47325
 47326						CLRBTH^
 47327	064110	700 04 0 00 267760 		CLRAPR
 47328	064111	700 14 0 00 031577 		CLRPI^
 47329	064112	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47330	064113	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47331	064114	202 00 0 00 000044 		MOVEM	Y		;INTO TRAP LOCATION
 47332	064115	200 00 0 00 071147 		MOVE	[JSP 1,..0133]	;SECOND TRAP INSTRUCTION
 47333	064116	202 00 0 00 000045 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47334	064117	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47335	064120	7 004 20 0 00 006240 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47336
 47337					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47338
 47339						WATINT^
 47340	064121	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47341	064122	367 13 0 00 064122 		SOJG	13,.		;AND WAIT^
 47342						STOP^
 47343	064123	254 04 0 00 064124 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47344	064124	254 00 0 00 064125 		JRST	.+1		;WITH JRST BACK^
 47345	064125				..0133:	CLRBTH^
 47346	064125	700 04 0 00 267760 		CLRAPR
 47347	064126	700 14 0 00 031577 		CLRPI^
 47348	064127	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47349						STOP^
 47350	064130	254 04 0 00 064131 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47351	064131	254 00 0 00 064132 		JRST	.+1		;WITH JRST BACK^
 47352					^
 47353			000046			Y=Y+2
 47354			000020			X=X_-1
 47355
 47356
 47357						PSKPA	Y,X^
 47358
 47359					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47360					;AN INTERRUPT INSTRUCTION.
 47361
 47362						CLRBTH^
 47363	064132	700 04 0 00 267760 		CLRAPR
 47364	064133	700 14 0 00 031577 		CLRPI^
 47365	064134	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47366	064135	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47367	064136	202 00 0 00 000046 		MOVEM	Y		;INTO TRAP LOCATION
 47368	064137	200 00 0 00 071150 		MOVE	[JSP 1,..0134]	;SECOND TRAP INSTRUCTION
 47369	064140	202 00 0 00 000047 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47370	064141	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47371	064142	7 004 20 0 00 006220 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47372
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-3
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47373					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47374
 47375						WATINT^
 47376	064143	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47377	064144	367 13 0 00 064144 		SOJG	13,.		;AND WAIT^
 47378						STOP^
 47379	064145	254 04 0 00 064146 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47380	064146	254 00 0 00 064147 		JRST	.+1		;WITH JRST BACK^
 47381	064147				..0134:	CLRBTH^
 47382	064147	700 04 0 00 267760 		CLRAPR
 47383	064150	700 14 0 00 031577 		CLRPI^
 47384	064151	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47385						STOP^
 47386	064152	254 04 0 00 064153 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47387	064153	254 00 0 00 064154 		JRST	.+1		;WITH JRST BACK^
 47388					^
 47389						PSKPB	Y,X^
 47390
 47391					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47392					;THE INTERRUPT.
 47393
 47394						CLRBTH^
 47395	064154	700 04 0 00 267760 		CLRAPR
 47396	064155	700 14 0 00 031577 		CLRPI^
 47397	064156	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47398	064157	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47399	064160	202 00 0 00 000046 		MOVEM	Y		;INTO TRAP LOCATION
 47400	064161	200 00 0 00 071151 		MOVE	[JSP 1,..0135]	;SECOND TRAP INSTRUCTION
 47401	064162	202 00 0 00 000047 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47402	064163	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47403	064164	7 004 20 0 00 006220 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47404
 47405					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47406
 47407						WATINT^
 47408	064165	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47409	064166	367 13 0 00 064166 		SOJG	13,.		;AND WAIT^
 47410						STOP^
 47411	064167	254 04 0 00 064170 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47412	064170	254 00 0 00 064171 		JRST	.+1		;WITH JRST BACK^
 47413	064171				..0135:	CLRBTH^
 47414	064171	700 04 0 00 267760 		CLRAPR
 47415	064172	700 14 0 00 031577 		CLRPI^
 47416	064173	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47417						STOP^
 47418	064174	254 04 0 00 064175 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47419	064175	254 00 0 00 064176 		JRST	.+1		;WITH JRST BACK^
 47420					^
 47421			000050			Y=Y+2
 47422			000010			X=X_-1
 47423
 47424
 47425						PSKPA	Y,X^
 47426
 47427					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-4
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47428					;AN INTERRUPT INSTRUCTION.
 47429
 47430						CLRBTH^
 47431	064176	700 04 0 00 267760 		CLRAPR
 47432	064177	700 14 0 00 031577 		CLRPI^
 47433	064200	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47434	064201	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47435	064202	202 00 0 00 000050 		MOVEM	Y		;INTO TRAP LOCATION
 47436	064203	200 00 0 00 071152 		MOVE	[JSP 1,..0136]	;SECOND TRAP INSTRUCTION
 47437	064204	202 00 0 00 000051 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47438	064205	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47439	064206	7 004 20 0 00 006210 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47440
 47441					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47442
 47443						WATINT^
 47444	064207	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47445	064210	367 13 0 00 064210 		SOJG	13,.		;AND WAIT^
 47446						STOP^
 47447	064211	254 04 0 00 064212 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47448	064212	254 00 0 00 064213 		JRST	.+1		;WITH JRST BACK^
 47449	064213				..0136:	CLRBTH^
 47450	064213	700 04 0 00 267760 		CLRAPR
 47451	064214	700 14 0 00 031577 		CLRPI^
 47452	064215	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47453						STOP^
 47454	064216	254 04 0 00 064217 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47455	064217	254 00 0 00 064220 		JRST	.+1		;WITH JRST BACK^
 47456					^
 47457						PSKPB	Y,X^
 47458
 47459					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47460					;THE INTERRUPT.
 47461
 47462						CLRBTH^
 47463	064220	700 04 0 00 267760 		CLRAPR
 47464	064221	700 14 0 00 031577 		CLRPI^
 47465	064222	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47466	064223	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47467	064224	202 00 0 00 000050 		MOVEM	Y		;INTO TRAP LOCATION
 47468	064225	200 00 0 00 071153 		MOVE	[JSP 1,..0137]	;SECOND TRAP INSTRUCTION
 47469	064226	202 00 0 00 000051 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47470	064227	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47471	064230	7 004 20 0 00 006210 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47472
 47473					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47474
 47475						WATINT^
 47476	064231	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47477	064232	367 13 0 00 064232 		SOJG	13,.		;AND WAIT^
 47478						STOP^
 47479	064233	254 04 0 00 064234 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47480	064234	254 00 0 00 064235 		JRST	.+1		;WITH JRST BACK^
 47481	064235				..0137:	CLRBTH^
 47482	064235	700 04 0 00 267760 		CLRAPR
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-5
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47483	064236	700 14 0 00 031577 		CLRPI^
 47484	064237	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47485						STOP^
 47486	064240	254 04 0 00 064241 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47487	064241	254 00 0 00 064242 		JRST	.+1		;WITH JRST BACK^
 47488					^
 47489			000052			Y=Y+2
 47490			000004			X=X_-1
 47491
 47492
 47493						PSKPA	Y,X^
 47494
 47495					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47496					;AN INTERRUPT INSTRUCTION.
 47497
 47498						CLRBTH^
 47499	064242	700 04 0 00 267760 		CLRAPR
 47500	064243	700 14 0 00 031577 		CLRPI^
 47501	064244	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47502	064245	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47503	064246	202 00 0 00 000052 		MOVEM	Y		;INTO TRAP LOCATION
 47504	064247	200 00 0 00 071154 		MOVE	[JSP 1,..0140]	;SECOND TRAP INSTRUCTION
 47505	064250	202 00 0 00 000053 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47506	064251	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47507	064252	7 004 20 0 00 006204 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47508
 47509					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47510
 47511						WATINT^
 47512	064253	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47513	064254	367 13 0 00 064254 		SOJG	13,.		;AND WAIT^
 47514						STOP^
 47515	064255	254 04 0 00 064256 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47516	064256	254 00 0 00 064257 		JRST	.+1		;WITH JRST BACK^
 47517	064257				..0140:	CLRBTH^
 47518	064257	700 04 0 00 267760 		CLRAPR
 47519	064260	700 14 0 00 031577 		CLRPI^
 47520	064261	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47521						STOP^
 47522	064262	254 04 0 00 064263 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47523	064263	254 00 0 00 064264 		JRST	.+1		;WITH JRST BACK^
 47524					^
 47525						PSKPB	Y,X^
 47526
 47527					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47528					;THE INTERRUPT.
 47529
 47530						CLRBTH^
 47531	064264	700 04 0 00 267760 		CLRAPR
 47532	064265	700 14 0 00 031577 		CLRPI^
 47533	064266	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47534	064267	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47535	064270	202 00 0 00 000052 		MOVEM	Y		;INTO TRAP LOCATION
 47536	064271	200 00 0 00 071155 		MOVE	[JSP 1,..0141]	;SECOND TRAP INSTRUCTION
 47537	064272	202 00 0 00 000053 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-6
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47538	064273	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47539	064274	7 004 20 0 00 006204 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47540
 47541					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47542
 47543						WATINT^
 47544	064275	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47545	064276	367 13 0 00 064276 		SOJG	13,.		;AND WAIT^
 47546						STOP^
 47547	064277	254 04 0 00 064300 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47548	064300	254 00 0 00 064301 		JRST	.+1		;WITH JRST BACK^
 47549	064301				..0141:	CLRBTH^
 47550	064301	700 04 0 00 267760 		CLRAPR
 47551	064302	700 14 0 00 031577 		CLRPI^
 47552	064303	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47553						STOP^
 47554	064304	254 04 0 00 064305 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47555	064305	254 00 0 00 064306 		JRST	.+1		;WITH JRST BACK^
 47556					^
 47557			000054			Y=Y+2
 47558			000002			X=X_-1
 47559
 47560
 47561						PSKPA	Y,X^
 47562
 47563					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47564					;AN INTERRUPT INSTRUCTION.
 47565
 47566						CLRBTH^
 47567	064306	700 04 0 00 267760 		CLRAPR
 47568	064307	700 14 0 00 031577 		CLRPI^
 47569	064310	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47570	064311	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47571	064312	202 00 0 00 000054 		MOVEM	Y		;INTO TRAP LOCATION
 47572	064313	200 00 0 00 071156 		MOVE	[JSP 1,..0142]	;SECOND TRAP INSTRUCTION
 47573	064314	202 00 0 00 000055 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47574	064315	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47575	064316	7 004 20 0 00 006202 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47576
 47577					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47578
 47579						WATINT^
 47580	064317	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47581	064320	367 13 0 00 064320 		SOJG	13,.		;AND WAIT^
 47582						STOP^
 47583	064321	254 04 0 00 064322 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47584	064322	254 00 0 00 064323 		JRST	.+1		;WITH JRST BACK^
 47585	064323				..0142:	CLRBTH^
 47586	064323	700 04 0 00 267760 		CLRAPR
 47587	064324	700 14 0 00 031577 		CLRPI^
 47588	064325	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47589						STOP^
 47590	064326	254 04 0 00 064327 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47591	064327	254 00 0 00 064330 		JRST	.+1		;WITH JRST BACK^
 47592					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-7
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47593						PSKPB	Y,X^
 47594
 47595					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47596					;THE INTERRUPT.
 47597
 47598						CLRBTH^
 47599	064330	700 04 0 00 267760 		CLRAPR
 47600	064331	700 14 0 00 031577 		CLRPI^
 47601	064332	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47602	064333	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47603	064334	202 00 0 00 000054 		MOVEM	Y		;INTO TRAP LOCATION
 47604	064335	200 00 0 00 071157 		MOVE	[JSP 1,..0143]	;SECOND TRAP INSTRUCTION
 47605	064336	202 00 0 00 000055 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47606	064337	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47607	064340	7 004 20 0 00 006202 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47608
 47609					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47610
 47611						WATINT^
 47612	064341	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47613	064342	367 13 0 00 064342 		SOJG	13,.		;AND WAIT^
 47614						STOP^
 47615	064343	254 04 0 00 064344 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47616	064344	254 00 0 00 064345 		JRST	.+1		;WITH JRST BACK^
 47617	064345				..0143:	CLRBTH^
 47618	064345	700 04 0 00 267760 		CLRAPR
 47619	064346	700 14 0 00 031577 		CLRPI^
 47620	064347	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47621						STOP^
 47622	064350	254 04 0 00 064351 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47623	064351	254 00 0 00 064352 		JRST	.+1		;WITH JRST BACK^
 47624					^
 47625			000056			Y=Y+2
 47626			000001			X=X_-1
 47627
 47628
 47629						PSKPA	Y,X^
 47630
 47631					;TEST THAT AOSE DOES NOT DISMISS INTERRUPTS, OR SKIP WHEN EXECUTED AS
 47632					;AN INTERRUPT INSTRUCTION.
 47633
 47634						CLRBTH^
 47635	064352	700 04 0 00 267760 		CLRAPR
 47636	064353	700 14 0 00 031577 		CLRPI^
 47637	064354	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47638	064355	200 00 0 00 071142 		MOVE	[AOSE 0]	;PI TRAP INSTRUCTION
 47639	064356	202 00 0 00 000056 		MOVEM	Y		;INTO TRAP LOCATION
 47640	064357	200 00 0 00 071160 		MOVE	[JSP 1,..0144]	;SECOND TRAP INSTRUCTION
 47641	064360	202 00 0 00 000057 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47642	064361	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47643	064362	7 004 20 0 00 006201 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47644
 47645					;IF WE FALL THROUGH THEN THE INTERRUPT WAS DISMISSED WHEN THE AOS FAILED
 47646
 47647						WATINT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 40-8
DFKAA8	MAC	13-Jan-89 10:22		BASIC NO-SKIP TESTING

 47648	064363	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47649	064364	367 13 0 00 064364 		SOJG	13,.		;AND WAIT^
 47650						STOP^
 47651	064365	254 04 0 00 064366 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47652	064366	254 00 0 00 064367 		JRST	.+1		;WITH JRST BACK^
 47653	064367				..0144:	CLRBTH^
 47654	064367	700 04 0 00 267760 		CLRAPR
 47655	064370	700 14 0 00 031577 		CLRPI^
 47656	064371	302 00 0 00 000002 		CAIE	2		;ONLY ONE AOSE PREFORMED?
 47657						STOP^
 47658	064372	254 04 0 00 064373 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47659	064373	254 00 0 00 064374 		JRST	.+1		;WITH JRST BACK^
 47660					^
 47661						PSKPB	Y,X^
 47662
 47663					;CHECK THAT SKIPE DOES NOT SKIP, OR MODIFY THE AC, OR DISMISS
 47664					;THE INTERRUPT.
 47665
 47666						CLRBTH^
 47667	064374	700 04 0 00 267760 		CLRAPR
 47668	064375	700 14 0 00 031577 		CLRPI^
 47669	064376	264 00 0 00 070103 		HALTPI			;FILL INTERRUPT LOCATIONS WITH HALTS
 47670	064377	200 00 0 00 071144 		MOVE	[SKIPE 0,0]	;PI TRAP INSTRUCTION(SHOULD NOT SKIP)
 47671	064400	202 00 0 00 000056 		MOVEM	Y		;INTO TRAP LOCATION
 47672	064401	200 00 0 00 071161 		MOVE	[JSP 1,..0145]	;SECOND TRAP INSTRUCTION
 47673	064402	202 00 0 00 000057 		MOVEM	Y+1		;INTO SECOND PI INSTRUCTION
 47674	064403	201 00 0 00 000001 		MOVEI	1		;SET AC TO NON ZERO
 47675	064404	7 004 20 0 00 006201 		CONO	PI,REQSET!PION!CHNON!X ;REQUEST INTERRUPT ON CH X
 47676
 47677					;IF WE FALL THROUGH TO HERE, THEN THE INT. WAS DISMISSED AND SHOULDN'T HAVE BEEN
 47678
 47679						WATINT^
 47680	064405	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47681	064406	367 13 0 00 064406 		SOJG	13,.		;AND WAIT^
 47682						STOP^
 47683	064407	254 04 0 00 064410 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47684	064410	254 00 0 00 064411 		JRST	.+1		;WITH JRST BACK^
 47685	064411				..0145:	CLRBTH^
 47686	064411	700 04 0 00 267760 		CLRAPR
 47687	064412	700 14 0 00 031577 		CLRPI^
 47688	064413	302 00 0 00 000001 		CAIE	1		;JUMPE SHOULD HAVE NOT MODIFIED THE AC
 47689						STOP^
 47690	064414	254 04 0 00 064415 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47691	064415	254 00 0 00 064416 		JRST	.+1		;WITH JRST BACK^
 47692					^
 47693			000060			Y=Y+2
 47694			000000			X=X_-1
 47695
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41
DFKAA8	MAC	13-Jan-89 10:22		TEST THE ABILITY TO DISMISS INTERRUPTS

 47696					SUBTTL	TEST THE ABILITY TO DISMISS INTERRUPTS
 47697					;CHECK THAT "JEN" DISMISSES INTERRUPTS
 47698
 47699
 47700			000042			X=42
 47701			000100			Z1=100
 47702					JENDIS:	REPEAT	7,<
 47703						PIDIS	X,Z1
 47704					
 47705						X=X+2
 47706						Z1=Z1_-1
 47707					>
 47708
 47709						PIDIS	X,Z1^
 47710
 47711					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47712
 47713						TSET^
 47714			064416			%X=.			;DEFINE %X TO SAVE
 47715	064416	201 00 0 00 064416 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47716	064417	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47717	064420	200 00 0 00 071162 	..0146:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47718	064421	202 00 0 00 000042 		MOVEM	X		;INTO X
 47719	064422	7 004 20 0 00 006300 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47720						WATINT^
 47721	064423	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47722	064424	367 13 0 00 064424 		SOJG	13,.		;AND WAIT^
 47723	064425	254 00 0 00 064430 		JRST	.+3
 47724	064426	7 004 20 0 00 022300 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47725	064427	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47726	064430	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47727						STOP^
 47728	064431	254 04 0 00 064432 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47729	064432	254 00 0 00 064433 		JRST	.+1		;WITH JRST BACK^
 47730						TGET^
 47731	064433	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47732	064434	302 00 0 00 064416 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47733						STOP2^^
 47734	064435	254 04 0 00 064436 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47735	064436	254 00 0 00 064437 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47736						CLRBTH^
 47737	064437	700 04 0 00 267760 		CLRAPR
 47738	064440	700 14 0 00 031577 		CLRPI^
 47739					^
 47740
 47741			000044			X=X+2
 47742			000040			Z1=Z1_-1
 47743
 47744
 47745						PIDIS	X,Z1^
 47746
 47747					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47748
 47749						TSET^
 47750			064441			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41-1
DFKAA8	MAC	13-Jan-89 10:22		TEST THE ABILITY TO DISMISS INTERRUPTS

 47751	064441	201 00 0 00 064441 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47752	064442	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47753	064443	200 00 0 00 071163 	..0147:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47754	064444	202 00 0 00 000044 		MOVEM	X		;INTO X
 47755	064445	7 004 20 0 00 006240 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47756						WATINT^
 47757	064446	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47758	064447	367 13 0 00 064447 		SOJG	13,.		;AND WAIT^
 47759	064450	254 00 0 00 064453 		JRST	.+3
 47760	064451	7 004 20 0 00 022240 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47761	064452	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47762	064453	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47763						STOP^
 47764	064454	254 04 0 00 064455 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47765	064455	254 00 0 00 064456 		JRST	.+1		;WITH JRST BACK^
 47766						TGET^
 47767	064456	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47768	064457	302 00 0 00 064441 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47769						STOP2^^
 47770	064460	254 04 0 00 064461 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47771	064461	254 00 0 00 064462 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47772						CLRBTH^
 47773	064462	700 04 0 00 267760 		CLRAPR
 47774	064463	700 14 0 00 031577 		CLRPI^
 47775					^
 47776
 47777			000046			X=X+2
 47778			000020			Z1=Z1_-1
 47779
 47780
 47781						PIDIS	X,Z1^
 47782
 47783					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47784
 47785						TSET^
 47786			064464			%X=.			;DEFINE %X TO SAVE
 47787	064464	201 00 0 00 064464 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47788	064465	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47789	064466	200 00 0 00 071164 	..0150:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47790	064467	202 00 0 00 000046 		MOVEM	X		;INTO X
 47791	064470	7 004 20 0 00 006220 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47792						WATINT^
 47793	064471	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47794	064472	367 13 0 00 064472 		SOJG	13,.		;AND WAIT^
 47795	064473	254 00 0 00 064476 		JRST	.+3
 47796	064474	7 004 20 0 00 022220 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47797	064475	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47798	064476	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47799						STOP^
 47800	064477	254 04 0 00 064500 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47801	064500	254 00 0 00 064501 		JRST	.+1		;WITH JRST BACK^
 47802						TGET^
 47803	064501	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47804	064502	302 00 0 00 064464 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47805						STOP2^^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41-2
DFKAA8	MAC	13-Jan-89 10:22		TEST THE ABILITY TO DISMISS INTERRUPTS

 47806	064503	254 04 0 00 064504 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47807	064504	254 00 0 00 064505 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47808						CLRBTH^
 47809	064505	700 04 0 00 267760 		CLRAPR
 47810	064506	700 14 0 00 031577 		CLRPI^
 47811					^
 47812
 47813			000050			X=X+2
 47814			000010			Z1=Z1_-1
 47815
 47816
 47817						PIDIS	X,Z1^
 47818
 47819					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47820
 47821						TSET^
 47822			064507			%X=.			;DEFINE %X TO SAVE
 47823	064507	201 00 0 00 064507 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47824	064510	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47825	064511	200 00 0 00 071165 	..0151:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47826	064512	202 00 0 00 000050 		MOVEM	X		;INTO X
 47827	064513	7 004 20 0 00 006210 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47828						WATINT^
 47829	064514	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47830	064515	367 13 0 00 064515 		SOJG	13,.		;AND WAIT^
 47831	064516	254 00 0 00 064521 		JRST	.+3
 47832	064517	7 004 20 0 00 022210 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47833	064520	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47834	064521	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47835						STOP^
 47836	064522	254 04 0 00 064523 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47837	064523	254 00 0 00 064524 		JRST	.+1		;WITH JRST BACK^
 47838						TGET^
 47839	064524	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47840	064525	302 00 0 00 064507 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47841						STOP2^^
 47842	064526	254 04 0 00 064527 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47843	064527	254 00 0 00 064530 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47844						CLRBTH^
 47845	064530	700 04 0 00 267760 		CLRAPR
 47846	064531	700 14 0 00 031577 		CLRPI^
 47847					^
 47848
 47849			000052			X=X+2
 47850			000004			Z1=Z1_-1
 47851
 47852
 47853						PIDIS	X,Z1^
 47854
 47855					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47856
 47857						TSET^
 47858			064532			%X=.			;DEFINE %X TO SAVE
 47859	064532	201 00 0 00 064532 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47860	064533	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41-3
DFKAA8	MAC	13-Jan-89 10:22		TEST THE ABILITY TO DISMISS INTERRUPTS

 47861	064534	200 00 0 00 071166 	..0152:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47862	064535	202 00 0 00 000052 		MOVEM	X		;INTO X
 47863	064536	7 004 20 0 00 006204 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47864						WATINT^
 47865	064537	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47866	064540	367 13 0 00 064540 		SOJG	13,.		;AND WAIT^
 47867	064541	254 00 0 00 064544 		JRST	.+3
 47868	064542	7 004 20 0 00 022204 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47869	064543	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47870	064544	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47871						STOP^
 47872	064545	254 04 0 00 064546 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47873	064546	254 00 0 00 064547 		JRST	.+1		;WITH JRST BACK^
 47874						TGET^
 47875	064547	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47876	064550	302 00 0 00 064532 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47877						STOP2^^
 47878	064551	254 04 0 00 064552 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47879	064552	254 00 0 00 064553 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47880						CLRBTH^
 47881	064553	700 04 0 00 267760 		CLRAPR
 47882	064554	700 14 0 00 031577 		CLRPI^
 47883					^
 47884
 47885			000054			X=X+2
 47886			000002			Z1=Z1_-1
 47887
 47888
 47889						PIDIS	X,Z1^
 47890
 47891					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47892
 47893						TSET^
 47894			064555			%X=.			;DEFINE %X TO SAVE
 47895	064555	201 00 0 00 064555 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47896	064556	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47897	064557	200 00 0 00 071167 	..0153:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47898	064560	202 00 0 00 000054 		MOVEM	X		;INTO X
 47899	064561	7 004 20 0 00 006202 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47900						WATINT^
 47901	064562	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47902	064563	367 13 0 00 064563 		SOJG	13,.		;AND WAIT^
 47903	064564	254 00 0 00 064567 		JRST	.+3
 47904	064565	7 004 20 0 00 022202 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47905	064566	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47906	064567	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47907						STOP^
 47908	064570	254 04 0 00 064571 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47909	064571	254 00 0 00 064572 		JRST	.+1		;WITH JRST BACK^
 47910						TGET^
 47911	064572	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47912	064573	302 00 0 00 064555 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47913						STOP2^^
 47914	064574	254 04 0 00 064575 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47915	064575	254 00 0 00 064576 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 41-4
DFKAA8	MAC	13-Jan-89 10:22		TEST THE ABILITY TO DISMISS INTERRUPTS

 47916						CLRBTH^
 47917	064576	700 04 0 00 267760 		CLRAPR
 47918	064577	700 14 0 00 031577 		CLRPI^
 47919					^
 47920
 47921			000056			X=X+2
 47922			000001			Z1=Z1_-1
 47923
 47924
 47925						PIDIS	X,Z1^
 47926
 47927					;CHECK THAT X JEN WILL DISMISS INTERUPTS ON ALL CHANNELS
 47928
 47929						TSET^
 47930			064600			%X=.			;DEFINE %X TO SAVE
 47931	064600	201 00 0 00 064600 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 47932	064601	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 47933	064602	200 00 0 00 071170 	..0154:	MOVE	[JSP 1,.+6]	;PUT THE PI TRAP INSTRUCTION
 47934	064603	202 00 0 00 000056 		MOVEM	X		;INTO X
 47935	064604	7 004 20 0 00 006201 		CONO	PI,CHNON+PION+REQSET+Z1	;TURN ON PI AND REQEST ON CH Z1
 47936						WATINT^
 47937	064605	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47938	064606	367 13 0 00 064606 		SOJG	13,.		;AND WAIT^
 47939	064607	254 00 0 00 064612 		JRST	.+3
 47940	064610	7 004 20 0 00 022201 		CONO	PI,CHNON+PION+LRQCLR+Z1	;TURN OF INTERRUPT REQUEST
 47941	064611	254 12 1 00 000001 		JEN	@1		;DISMISS THE INTERRUPT
 47942	064612	7 004 30 0 00 077400 		CONSZ	PI,77400	;NO REQUESTS SHOULD BE SET
 47943						STOP^
 47944	064613	254 04 0 00 064614 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47945	064614	254 00 0 00 064615 		JRST	.+1		;WITH JRST BACK^
 47946						TGET^
 47947	064615	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 47948	064616	302 00 0 00 064600 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 47949						STOP2^^
 47950	064617	254 04 0 00 064620 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 47951	064620	254 00 0 00 064621 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 47952						CLRBTH^
 47953	064621	700 04 0 00 267760 		CLRAPR
 47954	064622	700 14 0 00 031577 		CLRPI^
 47955					^
 47956
 47957			000060			X=X+2
 47958			000000			Z1=Z1_-1
 47959
 47960	064623	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42
DFKAA8	MAC	13-Jan-89 10:22		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG

 47961					SUBTTL	TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG
 47962					;TEST THAT THE CACHE SWEEP DONE FLAG WILL NOT CAUSE AN INTERRUPT WHEN ENABLED AND
 47963					;NO APR CACHE SWEEP DONE FLAG CHANNEL IS SET..
 47964						BLURB^
 47965					;LOCATIONS 40-60 CONTAIN A JSP TO A ROUTINE WHICH STORES
 47966					;THE CHANNEL NUMBER OF THE INTERRUPT INTO 0
 47967					;THEREFORE IF AN INTERRUPT OCCURS THEN LOCATION
 47968					;ZERO WILL CONTAIN THE NUMBER OF THE INTERRUPT CHANNEL TRAP ADRESS
 47969					^
 47970	064624				CKCK0:	CLRBTH^
 47971	064624	700 04 0 00 267760 		CLRAPR
 47972	064625	700 14 0 00 031577 		CLRPI^
 47973	064626	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 47974	064627	400 00 0 00 000000 		SETZ			;CLEAR 0
 47975	064630	7 004 20 0 00 002377 		CONO	PI,CHNON!PION!177	;TURN ON PI SYSTEM
 47976						CONO	APR,LESBER!LSSBER!LENXER!LSNXER!LEPWRF!LSPWRF!LEIOPF!LSIOPF!LEPAER!LSPAER!LE
 47977	064631	7 000 20 0 00 117460 	CASD!LSCASD	;ENABLE THE CACHE SWEEP DONE FLAG
 47978						WATINT^
 47979	064632	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 47980	064633	367 13 0 00 064633 		SOJG	13,.		;AND WAIT^
 47981	064634	332 00 0 00 000000 		SKIPE			;AC0=0
 47982						STOP^
 47983	064635	254 04 0 00 064636 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 47984	064636	254 00 0 00 064637 		JRST	.+1		;WITH JRST BACK^
 47985
 47986
 47987					;TEST THAT THE CACHE SWEEP DONE FLAG WILL NOT INTERRUPT WITHOUT CACHE SWEEP DONE FLAG ENABLE
 47988					 SET
 47989					;ON ALL CHANNELS
 47990
 47991			000001			X=1
 47992					CKCK1:	REPEAT	7,<
 47993					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 47994					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 47995					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 47996					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 47997						CLRBTH
 47998						TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 47999						SETZ	0,		;INSURE ZERO AC0.
 48000						CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48001						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48002					CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48003						WATINT
 48004						SKIPE			;AC0=0
 48005						STOP
 48006						X=X+1
 48007					>
 48008
 48009					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48010					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48011					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48012					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48013						CLRBTH^
 48014	064637	700 04 0 00 267760 		CLRAPR
 48015	064640	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42-1
DFKAA8	MAC	13-Jan-89 10:22		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG

 48016	064641	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48017	064642	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48018	064643	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48019						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48020	064644	7 000 20 0 00 057461 	CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48021						WATINT^
 48022	064645	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48023	064646	367 13 0 00 064646 		SOJG	13,.		;AND WAIT^
 48024	064647	332 00 0 00 000000 		SKIPE			;AC0=0
 48025						STOP^
 48026	064650	254 04 0 00 064651 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48027	064651	254 00 0 00 064652 		JRST	.+1		;WITH JRST BACK^
 48028			000002			X=X+1
 48029
 48030
 48031					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48032					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48033					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48034					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48035						CLRBTH^
 48036	064652	700 04 0 00 267760 		CLRAPR
 48037	064653	700 14 0 00 031577 		CLRPI^
 48038	064654	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48039	064655	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48040	064656	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48041						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48042	064657	7 000 20 0 00 057462 	CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48043						WATINT^
 48044	064660	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48045	064661	367 13 0 00 064661 		SOJG	13,.		;AND WAIT^
 48046	064662	332 00 0 00 000000 		SKIPE			;AC0=0
 48047						STOP^
 48048	064663	254 04 0 00 064664 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48049	064664	254 00 0 00 064665 		JRST	.+1		;WITH JRST BACK^
 48050			000003			X=X+1
 48051
 48052
 48053					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48054					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48055					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48056					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48057						CLRBTH^
 48058	064665	700 04 0 00 267760 		CLRAPR
 48059	064666	700 14 0 00 031577 		CLRPI^
 48060	064667	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48061	064670	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48062	064671	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48063						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48064	064672	7 000 20 0 00 057463 	CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48065						WATINT^
 48066	064673	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48067	064674	367 13 0 00 064674 		SOJG	13,.		;AND WAIT^
 48068	064675	332 00 0 00 000000 		SKIPE			;AC0=0
 48069						STOP^
 48070	064676	254 04 0 00 064677 		HALT	.+1		;INSTRUCTION FAILED REPLACE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42-2
DFKAA8	MAC	13-Jan-89 10:22		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG

 48071	064677	254 00 0 00 064700 		JRST	.+1		;WITH JRST BACK^
 48072			000004			X=X+1
 48073
 48074
 48075					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48076					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48077					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48078					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48079						CLRBTH^
 48080	064700	700 04 0 00 267760 		CLRAPR
 48081	064701	700 14 0 00 031577 		CLRPI^
 48082	064702	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48083	064703	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48084	064704	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48085						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48086	064705	7 000 20 0 00 057464 	CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48087						WATINT^
 48088	064706	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48089	064707	367 13 0 00 064707 		SOJG	13,.		;AND WAIT^
 48090	064710	332 00 0 00 000000 		SKIPE			;AC0=0
 48091						STOP^
 48092	064711	254 04 0 00 064712 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48093	064712	254 00 0 00 064713 		JRST	.+1		;WITH JRST BACK^
 48094			000005			X=X+1
 48095
 48096
 48097					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48098					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48099					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48100					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48101						CLRBTH^
 48102	064713	700 04 0 00 267760 		CLRAPR
 48103	064714	700 14 0 00 031577 		CLRPI^
 48104	064715	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48105	064716	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48106	064717	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48107						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48108	064720	7 000 20 0 00 057465 	CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48109						WATINT^
 48110	064721	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48111	064722	367 13 0 00 064722 		SOJG	13,.		;AND WAIT^
 48112	064723	332 00 0 00 000000 		SKIPE			;AC0=0
 48113						STOP^
 48114	064724	254 04 0 00 064725 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48115	064725	254 00 0 00 064726 		JRST	.+1		;WITH JRST BACK^
 48116			000006			X=X+1
 48117
 48118
 48119					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48120					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48121					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48122					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48123						CLRBTH^
 48124	064726	700 04 0 00 267760 		CLRAPR
 48125	064727	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 42-3
DFKAA8	MAC	13-Jan-89 10:22		TICKLE THE INTERRUPT SYSTEM WITH THE CACHE SWEEP DONE FLAG

 48126	064730	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48127	064731	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48128	064732	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48129						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48130	064733	7 000 20 0 00 057466 	CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48131						WATINT^
 48132	064734	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48133	064735	367 13 0 00 064735 		SOJG	13,.		;AND WAIT^
 48134	064736	332 00 0 00 000000 		SKIPE			;AC0=0
 48135						STOP^
 48136	064737	254 04 0 00 064740 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48137	064740	254 00 0 00 064741 		JRST	.+1		;WITH JRST BACK^
 48138			000007			X=X+1
 48139
 48140
 48141					;THE PROGRAM WILL WAIT FOR THE CACHE SWEEP DONE FLAG TO INTERRUPT ON EACH CHANNEL
 48142					;WITHOUT CACHE SWEEP DONE FLAG ENABLE SET. IF AC0 BECOMES NON-ZERO THE PROGRAM WILL
 48143					;HALT AND AC0 HAS THE NUMBER OF THE CHANNEL THAT THE INTERRUPT OCCURED
 48144					;ON. NO INTERRUPTS SHOULD OCCUR DURING THIS TEST.
 48145						CLRBTH^
 48146	064741	700 04 0 00 267760 		CLRAPR
 48147	064742	700 14 0 00 031577 		CLRPI^
 48148	064743	264 00 0 00 070120 		TRPPI			;FILL INTERRUPT LOCATIONS WITH TRAPS
 48149	064744	400 00 0 00 000000 		SETZ	0,		;INSURE ZERO AC0.
 48150	064745	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;ENABLE PI'S
 48151						CONO	APR,LDSBER!LSSBER!LDNXER!LSNXER!LDPWRF!LSPWRF!LDIOPF!LSIOPF!LDPAER!LSPAER!LD
 48152	064746	7 000 20 0 00 057467 	CASD!LSCASD!X	;DISABLE THE CACHE SWEEP DONE FLAG AN SET CH X
 48153						WATINT^
 48154	064747	201 13 0 00 001000 		MOVEI	13,1000		;SET UP LOOP OF TEN TO WAIT FOR INT.
 48155	064750	367 13 0 00 064750 		SOJG	13,.		;AND WAIT^
 48156	064751	332 00 0 00 000000 		SKIPE			;AC0=0
 48157						STOP^
 48158	064752	254 04 0 00 064753 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48159	064753	254 00 0 00 064754 		JRST	.+1		;WITH JRST BACK^
 48160			000010			X=X+1
 48161
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48162					SUBTTL	TEST VARIOUS RESETS
 48163
 48164					;TRY TO RESET THE PI BITS VIA CONO RESET TO THE APR
 48165	064754				RESET1:	CLRBTH^
 48166	064754	700 04 0 00 267760 		CLRAPR
 48167	064755	700 14 0 00 031577 		CLRPI^
 48168	064756	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177	;TURN ON PI SYSTEM
 48169	064757	7 000 20 0 00 200000 		CONO	APR,IOCLR	;RESET THE I/O BUS
 48170	064760	7 004 34 0 00 000377 		CONSO	PI,PION!177	;ALL PI BITS SHOULD STILL BE SET
 48171						STOP^
 48172	064761	254 04 0 00 064762 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48173	064762	254 00 0 00 064763 		JRST	.+1		;WITH JRST BACK^
 48174
 48175					;TRY TO RESET THE APR WITH A RESET TO THE PI.
 48176	064763				RESET2:	CLRBTH^
 48177	064763	700 04 0 00 267760 		CLRAPR
 48178	064764	700 14 0 00 031577 		CLRPI^
 48179	064765	7 000 20 0 00 000007 		CONO	APR,7		;SET CLOCK AND ERROR PIA'S
 48180	064766	7 004 20 0 00 010000 		CONO	PI,PICLR	;CLEAR THE PI SYSTEM
 48181	064767	7 000 34 0 00 000007 		CONSO	APR,7		;AND APR BITS SHOULD STILL BE SET
 48182						STOP^
 48183	064770	254 04 0 00 064771 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48184	064771	254 00 0 00 064772 		JRST	.+1		;WITH JRST BACK^
 48185
 48186			000001			X=1
 48187					RESET3:	REPEAT	^D18,<
 48188					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48189						CLRBTH
 48190						CONO	PI,PION!CHNON!177
 48191						CONO	APR,7		;TURN ON PI AND APR BITS
 48192						CONO	LAST,X		;SEND AND IOB BIT OUT
 48193						CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48194						CAIE	7,377
 48195						STOP
 48196						CONI	APR,6		;APR BITS SHOULD BE SET
 48197						CAIE	6,7
 48198						STOP
 48199						X=X_1			;NEXT BIT
 48200					>
 48201
 48202					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48203						CLRBTH^
 48204	064772	700 04 0 00 267760 		CLRAPR
 48205	064773	700 14 0 00 031577 		CLRPI^
 48206	064774	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48207	064775	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48208	064776	7 774 20 0 00 000001 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48209	064777	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48210	065000	302 07 0 00 000377 		CAIE	7,377
 48211						STOP^
 48212	065001	254 04 0 00 065002 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48213	065002	254 00 0 00 065003 		JRST	.+1		;WITH JRST BACK^
 48214	065003	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48215	065004	302 06 0 00 000007 		CAIE	6,7
 48216						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43-1
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48217	065005	254 04 0 00 065006 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48218	065006	254 00 0 00 065007 		JRST	.+1		;WITH JRST BACK^
 48219			000002			X=X_1			;NEXT BIT
 48220
 48221
 48222					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48223						CLRBTH^
 48224	065007	700 04 0 00 267760 		CLRAPR
 48225	065010	700 14 0 00 031577 		CLRPI^
 48226	065011	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48227	065012	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48228	065013	7 774 20 0 00 000002 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48229	065014	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48230	065015	302 07 0 00 000377 		CAIE	7,377
 48231						STOP^
 48232	065016	254 04 0 00 065017 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48233	065017	254 00 0 00 065020 		JRST	.+1		;WITH JRST BACK^
 48234	065020	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48235	065021	302 06 0 00 000007 		CAIE	6,7
 48236						STOP^
 48237	065022	254 04 0 00 065023 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48238	065023	254 00 0 00 065024 		JRST	.+1		;WITH JRST BACK^
 48239			000004			X=X_1			;NEXT BIT
 48240
 48241
 48242					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48243						CLRBTH^
 48244	065024	700 04 0 00 267760 		CLRAPR
 48245	065025	700 14 0 00 031577 		CLRPI^
 48246	065026	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48247	065027	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48248	065030	7 774 20 0 00 000004 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48249	065031	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48250	065032	302 07 0 00 000377 		CAIE	7,377
 48251						STOP^
 48252	065033	254 04 0 00 065034 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48253	065034	254 00 0 00 065035 		JRST	.+1		;WITH JRST BACK^
 48254	065035	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48255	065036	302 06 0 00 000007 		CAIE	6,7
 48256						STOP^
 48257	065037	254 04 0 00 065040 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48258	065040	254 00 0 00 065041 		JRST	.+1		;WITH JRST BACK^
 48259			000010			X=X_1			;NEXT BIT
 48260
 48261
 48262					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48263						CLRBTH^
 48264	065041	700 04 0 00 267760 		CLRAPR
 48265	065042	700 14 0 00 031577 		CLRPI^
 48266	065043	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48267	065044	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48268	065045	7 774 20 0 00 000010 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48269	065046	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48270	065047	302 07 0 00 000377 		CAIE	7,377
 48271						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43-2
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48272	065050	254 04 0 00 065051 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48273	065051	254 00 0 00 065052 		JRST	.+1		;WITH JRST BACK^
 48274	065052	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48275	065053	302 06 0 00 000007 		CAIE	6,7
 48276						STOP^
 48277	065054	254 04 0 00 065055 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48278	065055	254 00 0 00 065056 		JRST	.+1		;WITH JRST BACK^
 48279			000020			X=X_1			;NEXT BIT
 48280
 48281
 48282					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48283						CLRBTH^
 48284	065056	700 04 0 00 267760 		CLRAPR
 48285	065057	700 14 0 00 031577 		CLRPI^
 48286	065060	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48287	065061	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48288	065062	7 774 20 0 00 000020 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48289	065063	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48290	065064	302 07 0 00 000377 		CAIE	7,377
 48291						STOP^
 48292	065065	254 04 0 00 065066 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48293	065066	254 00 0 00 065067 		JRST	.+1		;WITH JRST BACK^
 48294	065067	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48295	065070	302 06 0 00 000007 		CAIE	6,7
 48296						STOP^
 48297	065071	254 04 0 00 065072 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48298	065072	254 00 0 00 065073 		JRST	.+1		;WITH JRST BACK^
 48299			000040			X=X_1			;NEXT BIT
 48300
 48301
 48302					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48303						CLRBTH^
 48304	065073	700 04 0 00 267760 		CLRAPR
 48305	065074	700 14 0 00 031577 		CLRPI^
 48306	065075	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48307	065076	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48308	065077	7 774 20 0 00 000040 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48309	065100	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48310	065101	302 07 0 00 000377 		CAIE	7,377
 48311						STOP^
 48312	065102	254 04 0 00 065103 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48313	065103	254 00 0 00 065104 		JRST	.+1		;WITH JRST BACK^
 48314	065104	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48315	065105	302 06 0 00 000007 		CAIE	6,7
 48316						STOP^
 48317	065106	254 04 0 00 065107 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48318	065107	254 00 0 00 065110 		JRST	.+1		;WITH JRST BACK^
 48319			000100			X=X_1			;NEXT BIT
 48320
 48321
 48322					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48323						CLRBTH^
 48324	065110	700 04 0 00 267760 		CLRAPR
 48325	065111	700 14 0 00 031577 		CLRPI^
 48326	065112	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43-3
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48327	065113	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48328	065114	7 774 20 0 00 000100 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48329	065115	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48330	065116	302 07 0 00 000377 		CAIE	7,377
 48331						STOP^
 48332	065117	254 04 0 00 065120 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48333	065120	254 00 0 00 065121 		JRST	.+1		;WITH JRST BACK^
 48334	065121	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48335	065122	302 06 0 00 000007 		CAIE	6,7
 48336						STOP^
 48337	065123	254 04 0 00 065124 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48338	065124	254 00 0 00 065125 		JRST	.+1		;WITH JRST BACK^
 48339			000200			X=X_1			;NEXT BIT
 48340
 48341
 48342					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48343						CLRBTH^
 48344	065125	700 04 0 00 267760 		CLRAPR
 48345	065126	700 14 0 00 031577 		CLRPI^
 48346	065127	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48347	065130	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48348	065131	7 774 20 0 00 000200 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48349	065132	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48350	065133	302 07 0 00 000377 		CAIE	7,377
 48351						STOP^
 48352	065134	254 04 0 00 065135 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48353	065135	254 00 0 00 065136 		JRST	.+1		;WITH JRST BACK^
 48354	065136	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48355	065137	302 06 0 00 000007 		CAIE	6,7
 48356						STOP^
 48357	065140	254 04 0 00 065141 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48358	065141	254 00 0 00 065142 		JRST	.+1		;WITH JRST BACK^
 48359			000400			X=X_1			;NEXT BIT
 48360
 48361
 48362					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48363						CLRBTH^
 48364	065142	700 04 0 00 267760 		CLRAPR
 48365	065143	700 14 0 00 031577 		CLRPI^
 48366	065144	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48367	065145	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48368	065146	7 774 20 0 00 000400 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48369	065147	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48370	065150	302 07 0 00 000377 		CAIE	7,377
 48371						STOP^
 48372	065151	254 04 0 00 065152 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48373	065152	254 00 0 00 065153 		JRST	.+1		;WITH JRST BACK^
 48374	065153	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48375	065154	302 06 0 00 000007 		CAIE	6,7
 48376						STOP^
 48377	065155	254 04 0 00 065156 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48378	065156	254 00 0 00 065157 		JRST	.+1		;WITH JRST BACK^
 48379			001000			X=X_1			;NEXT BIT
 48380
 48381
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43-4
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48382					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48383						CLRBTH^
 48384	065157	700 04 0 00 267760 		CLRAPR
 48385	065160	700 14 0 00 031577 		CLRPI^
 48386	065161	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48387	065162	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48388	065163	7 774 20 0 00 001000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48389	065164	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48390	065165	302 07 0 00 000377 		CAIE	7,377
 48391						STOP^
 48392	065166	254 04 0 00 065167 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48393	065167	254 00 0 00 065170 		JRST	.+1		;WITH JRST BACK^
 48394	065170	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48395	065171	302 06 0 00 000007 		CAIE	6,7
 48396						STOP^
 48397	065172	254 04 0 00 065173 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48398	065173	254 00 0 00 065174 		JRST	.+1		;WITH JRST BACK^
 48399			002000			X=X_1			;NEXT BIT
 48400
 48401
 48402					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48403						CLRBTH^
 48404	065174	700 04 0 00 267760 		CLRAPR
 48405	065175	700 14 0 00 031577 		CLRPI^
 48406	065176	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48407	065177	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48408	065200	7 774 20 0 00 002000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48409	065201	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48410	065202	302 07 0 00 000377 		CAIE	7,377
 48411						STOP^
 48412	065203	254 04 0 00 065204 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48413	065204	254 00 0 00 065205 		JRST	.+1		;WITH JRST BACK^
 48414	065205	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48415	065206	302 06 0 00 000007 		CAIE	6,7
 48416						STOP^
 48417	065207	254 04 0 00 065210 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48418	065210	254 00 0 00 065211 		JRST	.+1		;WITH JRST BACK^
 48419			004000			X=X_1			;NEXT BIT
 48420
 48421
 48422					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48423						CLRBTH^
 48424	065211	700 04 0 00 267760 		CLRAPR
 48425	065212	700 14 0 00 031577 		CLRPI^
 48426	065213	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48427	065214	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48428	065215	7 774 20 0 00 004000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48429	065216	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48430	065217	302 07 0 00 000377 		CAIE	7,377
 48431						STOP^
 48432	065220	254 04 0 00 065221 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48433	065221	254 00 0 00 065222 		JRST	.+1		;WITH JRST BACK^
 48434	065222	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48435	065223	302 06 0 00 000007 		CAIE	6,7
 48436						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43-5
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48437	065224	254 04 0 00 065225 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48438	065225	254 00 0 00 065226 		JRST	.+1		;WITH JRST BACK^
 48439			010000			X=X_1			;NEXT BIT
 48440
 48441
 48442					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48443						CLRBTH^
 48444	065226	700 04 0 00 267760 		CLRAPR
 48445	065227	700 14 0 00 031577 		CLRPI^
 48446	065230	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48447	065231	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48448	065232	7 774 20 0 00 010000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48449	065233	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48450	065234	302 07 0 00 000377 		CAIE	7,377
 48451						STOP^
 48452	065235	254 04 0 00 065236 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48453	065236	254 00 0 00 065237 		JRST	.+1		;WITH JRST BACK^
 48454	065237	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48455	065240	302 06 0 00 000007 		CAIE	6,7
 48456						STOP^
 48457	065241	254 04 0 00 065242 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48458	065242	254 00 0 00 065243 		JRST	.+1		;WITH JRST BACK^
 48459			020000			X=X_1			;NEXT BIT
 48460
 48461
 48462					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48463						CLRBTH^
 48464	065243	700 04 0 00 267760 		CLRAPR
 48465	065244	700 14 0 00 031577 		CLRPI^
 48466	065245	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48467	065246	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48468	065247	7 774 20 0 00 020000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48469	065250	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48470	065251	302 07 0 00 000377 		CAIE	7,377
 48471						STOP^
 48472	065252	254 04 0 00 065253 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48473	065253	254 00 0 00 065254 		JRST	.+1		;WITH JRST BACK^
 48474	065254	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48475	065255	302 06 0 00 000007 		CAIE	6,7
 48476						STOP^
 48477	065256	254 04 0 00 065257 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48478	065257	254 00 0 00 065260 		JRST	.+1		;WITH JRST BACK^
 48479			040000			X=X_1			;NEXT BIT
 48480
 48481
 48482					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48483						CLRBTH^
 48484	065260	700 04 0 00 267760 		CLRAPR
 48485	065261	700 14 0 00 031577 		CLRPI^
 48486	065262	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48487	065263	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48488	065264	7 774 20 0 00 040000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48489	065265	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48490	065266	302 07 0 00 000377 		CAIE	7,377
 48491						STOP^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43-6
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48492	065267	254 04 0 00 065270 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48493	065270	254 00 0 00 065271 		JRST	.+1		;WITH JRST BACK^
 48494	065271	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48495	065272	302 06 0 00 000007 		CAIE	6,7
 48496						STOP^
 48497	065273	254 04 0 00 065274 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48498	065274	254 00 0 00 065275 		JRST	.+1		;WITH JRST BACK^
 48499			100000			X=X_1			;NEXT BIT
 48500
 48501
 48502					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48503						CLRBTH^
 48504	065275	700 04 0 00 267760 		CLRAPR
 48505	065276	700 14 0 00 031577 		CLRPI^
 48506	065277	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48507	065300	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48508	065301	7 774 20 0 00 100000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48509	065302	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48510	065303	302 07 0 00 000377 		CAIE	7,377
 48511						STOP^
 48512	065304	254 04 0 00 065305 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48513	065305	254 00 0 00 065306 		JRST	.+1		;WITH JRST BACK^
 48514	065306	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48515	065307	302 06 0 00 000007 		CAIE	6,7
 48516						STOP^
 48517	065310	254 04 0 00 065311 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48518	065311	254 00 0 00 065312 		JRST	.+1		;WITH JRST BACK^
 48519			200000			X=X_1			;NEXT BIT
 48520
 48521
 48522					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48523						CLRBTH^
 48524	065312	700 04 0 00 267760 		CLRAPR
 48525	065313	700 14 0 00 031577 		CLRPI^
 48526	065314	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
 48527	065315	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48528	065316	7 774 20 0 00 200000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48529	065317	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48530	065320	302 07 0 00 000377 		CAIE	7,377
 48531						STOP^
 48532	065321	254 04 0 00 065322 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48533	065322	254 00 0 00 065323 		JRST	.+1		;WITH JRST BACK^
 48534	065323	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48535	065324	302 06 0 00 000007 		CAIE	6,7
 48536						STOP^
 48537	065325	254 04 0 00 065326 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48538	065326	254 00 0 00 065327 		JRST	.+1		;WITH JRST BACK^
 48539			400000			X=X_1			;NEXT BIT
 48540
 48541
 48542					;TRY TO RESET THE PI AND APR VIA A CONO BIT TO DEVICE 774
 48543						CLRBTH^
 48544	065327	700 04 0 00 267760 		CLRAPR
 48545	065330	700 14 0 00 031577 		CLRPI^
 48546	065331	7 004 20 0 00 002377 		CONO	PI,PION!CHNON!177
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 43-7
DFKAA8	MAC	13-Jan-89 10:22		TEST VARIOUS RESETS

 48547	065332	7 000 20 0 00 000007 		CONO	APR,7		;TURN ON PI AND APR BITS
 48548	065333	7 774 20 0 00 400000 		CONO	LAST,X		;SEND AND IOB BIT OUT
 48549	065334	7 004 24 0 00 000007 		CONI	PI,7		;PI BITS SHOULD STILL BE SET
 48550	065335	302 07 0 00 000377 		CAIE	7,377
 48551						STOP^
 48552	065336	254 04 0 00 065337 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48553	065337	254 00 0 00 065340 		JRST	.+1		;WITH JRST BACK^
 48554	065340	7 000 24 0 00 000006 		CONI	APR,6		;APR BITS SHOULD BE SET
 48555	065341	302 06 0 00 000007 		CAIE	6,7
 48556						STOP^
 48557	065342	254 04 0 00 065343 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48558	065343	254 00 0 00 065344 		JRST	.+1		;WITH JRST BACK^
 48559		000001	000000			X=X_1			;NEXT BIT
 48560
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT OUT OF INDIRECT LOOP

 48561					SUBTTL	INTERRUPT OUT OF INDIRECT LOOP
 48562
 48563						INDPI	42,1^
 48564
 48565					;GET OURSELVES INTO 42 TIGHT INDIRECT LOOP.
 48566					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48567					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48568					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48569
 48570						TSET^
 48571			065344			%X=.			;DEFINE %X TO SAVE
 48572	065344	201 00 0 00 065344 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48573	065345	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48574	065346	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48575	065347	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48576	065350	200 10 0 00 071171 		MOVE	10,[JSP 1,..0155]	;INTERRUPT TRAP INSTRUCTION
 48577	065351	202 10 0 00 000042 		MOVEM	10,42		;STORE FOR INTERRUPT REQUEST
 48578						CLRBT1^
 48579	065352	700 04 0 00 267760 		CLRAPR
 48580	065353	700 14 0 00 031577 		CLRPI^
 48581	065354	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48582	065355	7 000 20 0 00 114001 		CONO	APR,LESBER!LSSBER!1	;ENABLE AND SET S BUS ERRORS,ENABLE CH 1
 48583	065356	254 00 1 00 065356 		JRST	@.		;LOOP
 48584	065357	254 04 0 00 065360 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48585	065360				..0155:	TGET^
 48586	065360	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48587	065361	302 00 0 00 065344 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48588						STOP2^^
 48589	065362	254 04 0 00 065363 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48590	065363	254 00 0 00 065364 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48591	065364	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48592	065365	302 01 0 00 065356 		CAIE	1,..0155-2		;WAS CORRECT PC STORED?
 48593						STOP^
 48594	065366	254 04 0 00 065367 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48595	065367	254 00 0 00 065370 		JRST	.+1		;WITH JRST BACK^
 48596	065370	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48597	065371	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48598						CLRBTH^
 48599	065372	700 04 0 00 267760 		CLRAPR
 48600	065373	700 14 0 00 031577 		CLRPI^
 48601					^
 48602
 48603						INDPI	44,2^
 48604
 48605					;GET OURSELVES INTO 44 TIGHT INDIRECT LOOP.
 48606					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48607					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48608					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48609
 48610						TSET^
 48611			065374			%X=.			;DEFINE %X TO SAVE
 48612	065374	201 00 0 00 065374 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48613	065375	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48614	065376	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48615	065377	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44-1
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT OUT OF INDIRECT LOOP

 48616	065400	200 10 0 00 071172 		MOVE	10,[JSP 1,..0156]	;INTERRUPT TRAP INSTRUCTION
 48617	065401	202 10 0 00 000044 		MOVEM	10,44		;STORE FOR INTERRUPT REQUEST
 48618						CLRBT1^
 48619	065402	700 04 0 00 267760 		CLRAPR
 48620	065403	700 14 0 00 031577 		CLRPI^
 48621	065404	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48622	065405	7 000 20 0 00 114002 		CONO	APR,LESBER!LSSBER!2	;ENABLE AND SET S BUS ERRORS,ENABLE CH 2
 48623	065406	254 00 1 00 065406 		JRST	@.		;LOOP
 48624	065407	254 04 0 00 065410 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48625	065410				..0156:	TGET^
 48626	065410	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48627	065411	302 00 0 00 065374 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48628						STOP2^^
 48629	065412	254 04 0 00 065413 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48630	065413	254 00 0 00 065414 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48631	065414	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48632	065415	302 01 0 00 065406 		CAIE	1,..0156-2		;WAS CORRECT PC STORED?
 48633						STOP^
 48634	065416	254 04 0 00 065417 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48635	065417	254 00 0 00 065420 		JRST	.+1		;WITH JRST BACK^
 48636	065420	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48637	065421	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48638						CLRBTH^
 48639	065422	700 04 0 00 267760 		CLRAPR
 48640	065423	700 14 0 00 031577 		CLRPI^
 48641					^
 48642
 48643						INDPI	46,3^
 48644
 48645					;GET OURSELVES INTO 46 TIGHT INDIRECT LOOP.
 48646					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48647					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48648					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48649
 48650						TSET^
 48651			065424			%X=.			;DEFINE %X TO SAVE
 48652	065424	201 00 0 00 065424 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48653	065425	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48654	065426	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48655	065427	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48656	065430	200 10 0 00 071173 		MOVE	10,[JSP 1,..0157]	;INTERRUPT TRAP INSTRUCTION
 48657	065431	202 10 0 00 000046 		MOVEM	10,46		;STORE FOR INTERRUPT REQUEST
 48658						CLRBT1^
 48659	065432	700 04 0 00 267760 		CLRAPR
 48660	065433	700 14 0 00 031577 		CLRPI^
 48661	065434	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48662	065435	7 000 20 0 00 114003 		CONO	APR,LESBER!LSSBER!3	;ENABLE AND SET S BUS ERRORS,ENABLE CH 3
 48663	065436	254 00 1 00 065436 		JRST	@.		;LOOP
 48664	065437	254 04 0 00 065440 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48665	065440				..0157:	TGET^
 48666	065440	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48667	065441	302 00 0 00 065424 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48668						STOP2^^
 48669	065442	254 04 0 00 065443 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48670	065443	254 00 0 00 065444 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44-2
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT OUT OF INDIRECT LOOP

 48671	065444	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48672	065445	302 01 0 00 065436 		CAIE	1,..0157-2		;WAS CORRECT PC STORED?
 48673						STOP^
 48674	065446	254 04 0 00 065447 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48675	065447	254 00 0 00 065450 		JRST	.+1		;WITH JRST BACK^
 48676	065450	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48677	065451	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48678						CLRBTH^
 48679	065452	700 04 0 00 267760 		CLRAPR
 48680	065453	700 14 0 00 031577 		CLRPI^
 48681					^
 48682
 48683						INDPI	50,4^
 48684
 48685					;GET OURSELVES INTO 50 TIGHT INDIRECT LOOP.
 48686					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48687					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48688					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48689
 48690						TSET^
 48691			065454			%X=.			;DEFINE %X TO SAVE
 48692	065454	201 00 0 00 065454 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48693	065455	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48694	065456	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48695	065457	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48696	065460	200 10 0 00 071174 		MOVE	10,[JSP 1,..0160]	;INTERRUPT TRAP INSTRUCTION
 48697	065461	202 10 0 00 000050 		MOVEM	10,50		;STORE FOR INTERRUPT REQUEST
 48698						CLRBT1^
 48699	065462	700 04 0 00 267760 		CLRAPR
 48700	065463	700 14 0 00 031577 		CLRPI^
 48701	065464	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48702	065465	7 000 20 0 00 114004 		CONO	APR,LESBER!LSSBER!4	;ENABLE AND SET S BUS ERRORS,ENABLE CH 4
 48703	065466	254 00 1 00 065466 		JRST	@.		;LOOP
 48704	065467	254 04 0 00 065470 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48705	065470				..0160:	TGET^
 48706	065470	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48707	065471	302 00 0 00 065454 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48708						STOP2^^
 48709	065472	254 04 0 00 065473 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48710	065473	254 00 0 00 065474 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48711	065474	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48712	065475	302 01 0 00 065466 		CAIE	1,..0160-2		;WAS CORRECT PC STORED?
 48713						STOP^
 48714	065476	254 04 0 00 065477 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48715	065477	254 00 0 00 065500 		JRST	.+1		;WITH JRST BACK^
 48716	065500	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48717	065501	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48718						CLRBTH^
 48719	065502	700 04 0 00 267760 		CLRAPR
 48720	065503	700 14 0 00 031577 		CLRPI^
 48721					^
 48722
 48723						INDPI	52,5^
 48724
 48725					;GET OURSELVES INTO 52 TIGHT INDIRECT LOOP.
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44-3
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT OUT OF INDIRECT LOOP

 48726					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48727					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48728					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48729
 48730						TSET^
 48731			065504			%X=.			;DEFINE %X TO SAVE
 48732	065504	201 00 0 00 065504 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48733	065505	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48734	065506	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48735	065507	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48736	065510	200 10 0 00 071175 		MOVE	10,[JSP 1,..0161]	;INTERRUPT TRAP INSTRUCTION
 48737	065511	202 10 0 00 000052 		MOVEM	10,52		;STORE FOR INTERRUPT REQUEST
 48738						CLRBT1^
 48739	065512	700 04 0 00 267760 		CLRAPR
 48740	065513	700 14 0 00 031577 		CLRPI^
 48741	065514	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48742	065515	7 000 20 0 00 114005 		CONO	APR,LESBER!LSSBER!5	;ENABLE AND SET S BUS ERRORS,ENABLE CH 5
 48743	065516	254 00 1 00 065516 		JRST	@.		;LOOP
 48744	065517	254 04 0 00 065520 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48745	065520				..0161:	TGET^
 48746	065520	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48747	065521	302 00 0 00 065504 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48748						STOP2^^
 48749	065522	254 04 0 00 065523 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48750	065523	254 00 0 00 065524 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48751	065524	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48752	065525	302 01 0 00 065516 		CAIE	1,..0161-2		;WAS CORRECT PC STORED?
 48753						STOP^
 48754	065526	254 04 0 00 065527 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48755	065527	254 00 0 00 065530 		JRST	.+1		;WITH JRST BACK^
 48756	065530	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48757	065531	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48758						CLRBTH^
 48759	065532	700 04 0 00 267760 		CLRAPR
 48760	065533	700 14 0 00 031577 		CLRPI^
 48761					^
 48762
 48763						INDPI	54,6^
 48764
 48765					;GET OURSELVES INTO 54 TIGHT INDIRECT LOOP.
 48766					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48767					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48768					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48769
 48770						TSET^
 48771			065534			%X=.			;DEFINE %X TO SAVE
 48772	065534	201 00 0 00 065534 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48773	065535	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48774	065536	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48775	065537	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48776	065540	200 10 0 00 071176 		MOVE	10,[JSP 1,..0162]	;INTERRUPT TRAP INSTRUCTION
 48777	065541	202 10 0 00 000054 		MOVEM	10,54		;STORE FOR INTERRUPT REQUEST
 48778						CLRBT1^
 48779	065542	700 04 0 00 267760 		CLRAPR
 48780	065543	700 14 0 00 031577 		CLRPI^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44-4
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT OUT OF INDIRECT LOOP

 48781	065544	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48782	065545	7 000 20 0 00 114006 		CONO	APR,LESBER!LSSBER!6	;ENABLE AND SET S BUS ERRORS,ENABLE CH 6
 48783	065546	254 00 1 00 065546 		JRST	@.		;LOOP
 48784	065547	254 04 0 00 065550 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48785	065550				..0162:	TGET^
 48786	065550	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48787	065551	302 00 0 00 065534 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48788						STOP2^^
 48789	065552	254 04 0 00 065553 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48790	065553	254 00 0 00 065554 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48791	065554	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48792	065555	302 01 0 00 065546 		CAIE	1,..0162-2		;WAS CORRECT PC STORED?
 48793						STOP^
 48794	065556	254 04 0 00 065557 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48795	065557	254 00 0 00 065560 		JRST	.+1		;WITH JRST BACK^
 48796	065560	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48797	065561	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48798						CLRBTH^
 48799	065562	700 04 0 00 267760 		CLRAPR
 48800	065563	700 14 0 00 031577 		CLRPI^
 48801					^
 48802
 48803						INDPI	56,7^
 48804
 48805					;GET OURSELVES INTO 56 TIGHT INDIRECT LOOP.
 48806					;AND SEE IF WE ARE ABLE TO INTERRUPT OUT OF IT.
 48807					;THE LOOP IS DONE TEN TIMES. EACH TIME THE INTERRUPT IS DISMISSED AND
 48808					;WE WILL RETURN TO THE "JRST @." INSTRUCTION.
 48809
 48810						TSET^
 48811			065564			%X=.			;DEFINE %X TO SAVE
 48812	065564	201 00 0 00 065564 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48813	065565	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48814	065566	201 10 0 00 000012 		MOVEI	10,^D10		;TIMES TO DO THIS TEST
 48815	065567	202 10 0 00 071347 		MOVEM	10,COUNTX#	;STORE IT
 48816	065570	200 10 0 00 071177 		MOVE	10,[JSP 1,..0163]	;INTERRUPT TRAP INSTRUCTION
 48817	065571	202 10 0 00 000056 		MOVEM	10,56		;STORE FOR INTERRUPT REQUEST
 48818						CLRBT1^
 48819	065572	700 04 0 00 267760 		CLRAPR
 48820	065573	700 14 0 00 031577 		CLRPI^
 48821	065574	7 004 20 0 00 002377 		CONO	PI,2377		;TURN ON PI AND CHANNELS
 48822	065575	7 000 20 0 00 114007 		CONO	APR,LESBER!LSSBER!7	;ENABLE AND SET S BUS ERRORS,ENABLE CH 7
 48823	065576	254 00 1 00 065576 		JRST	@.		;LOOP
 48824	065577	254 04 0 00 065600 		HALT	.+1		;ERROR IF HERE  (GOT OUT OF INDIRECT LOOP)
 48825	065600				..0163:	TGET^
 48826	065600	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48827	065601	302 00 0 00 065564 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48828						STOP2^^
 48829	065602	254 04 0 00 065603 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48830	065603	254 00 0 00 065604 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48831	065604	405 01 0 00 777777 		ANDI	1,-1		;MASK PC BITS
 48832	065605	302 01 0 00 065576 		CAIE	1,..0163-2		;WAS CORRECT PC STORED?
 48833						STOP^
 48834	065606	254 04 0 00 065607 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 48835	065607	254 00 0 00 065610 		JRST	.+1		;WITH JRST BACK^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 44-5
DFKAA8	MAC	13-Jan-89 10:22		INTERRUPT OUT OF INDIRECT LOOP

 48836	065610	372 00 0 00 071347 		SOSE	COUNTX		;LOOP TEST
 48837	065611	254 12 1 00 000001 		JEN	@1		;DISMISS INTERRUPT
 48838						CLRBTH^
 48839	065612	700 04 0 00 267760 		CLRAPR
 48840	065613	700 14 0 00 031577 		CLRPI^
 48841					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 45
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 48842					SUBTTL	LOCAL UUO TESTING (LUUO)
 48843
 48844					;TEST UUO'S IN RANGE 1-37
 48845					;TEST TO SEE THAT UUO TRAPS CORRECTLY AND THAT PC
 48846					;OF UUO IS CORRECT AND THAT UUO STORED IN 40 IS ALSO CORRECT
 48847					;MONITOR UUO'S ARE NOT TESTED.
 48848
 48849					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48850					;MA SPECIAL BITS NOT SETTING
 48851					;AD MAGIC # 40 @ET1
 48852					;XCTF SET AT FETCH CYCLE
 48853					;AR IR ENABLE @ET1
 48854					;AR SIGN SMEAR
 48855					;AD MAGIC NUMBER ENABLE
 48856					;AB AD EN @ET1
 48857					;INSTRUCTION FETCH @ET2
 48858
 48859	065614				UUO01:	XUUO	1B8,UUO02^
 48860
 48861					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48862					;ARE CORRECT.
 48863
 48864		001000	000000			MLUUO==1B8		;THE UUO TO BE EXECUTED
 48865						TSET^
 48866			065614			%X=.			;DEFINE %X TO SAVE
 48867	065614	201 00 0 00 065614 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48868	065615	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48869	065616	200 00 0 00 071200 	..0164:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48870	065617	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48871	065620	001000	000000			1B8			;EXECUTE A UUO
 48872	065621	254 04 0 00 065622 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48873	065622	201 02 0 00 065621 		MOVEI	2,.-1		;GET UUO PC
 48874	065623	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48875	065624	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48876	065625	254 04 0 00 065626 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 48877	065626	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 48878	065627	312 00 0 00 070317 		CAME	0,[1B8!0]		;CORRECT UUO STORED IN 40?
 48879	065630	334 00 0 00 000000 		SKIPA			;NO
 48880	065631	254 00 0 00 065640 		JRST	UUO02		;TESTS OK !
 48881						STOP1^
 48882	065632	254 04 0 00 065633 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 48883	065633	254 00 0 00 065634 		JRST	.+1		;INTO RIGHT HALF OF 40^
 48884						TGET^
 48885	065634	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48886	065635	302 00 0 00 065614 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48887						STOP2^^
 48888	065636	254 04 0 00 065637 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48889	065637	254 00 0 00 065640 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48890					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 46
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 48891					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48892					;MA SPECIAL BITS NOT SETTING
 48893					;AD MAGIC # 40 @ET1
 48894					;XCTF SET AT FETCH CYCLE
 48895					;AR IR ENABLE @ET1
 48896					;AR SIGN SMEAR
 48897					;AD MAGIC NUMBER ENABLE
 48898					;AB AD EN @ET1
 48899					;INSTRUCTION FETCH @ET2
 48900	065640				UUO02:	XUUO	2B8,UUO03^
 48901
 48902					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48903					;ARE CORRECT.
 48904
 48905		002000	000000			MLUUO==2B8		;THE UUO TO BE EXECUTED
 48906						TSET^
 48907			065640			%X=.			;DEFINE %X TO SAVE
 48908	065640	201 00 0 00 065640 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48909	065641	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48910	065642	200 00 0 00 071201 	..0165:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48911	065643	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48912	065644	002000	000000			2B8			;EXECUTE A UUO
 48913	065645	254 04 0 00 065646 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48914	065646	201 02 0 00 065645 		MOVEI	2,.-1		;GET UUO PC
 48915	065647	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48916	065650	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48917	065651	254 04 0 00 065652 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 48918	065652	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 48919	065653	312 00 0 00 070320 		CAME	0,[2B8!0]		;CORRECT UUO STORED IN 40?
 48920	065654	334 00 0 00 000000 		SKIPA			;NO
 48921	065655	254 00 0 00 065664 		JRST	UUO03		;TESTS OK !
 48922						STOP1^
 48923	065656	254 04 0 00 065657 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 48924	065657	254 00 0 00 065660 		JRST	.+1		;INTO RIGHT HALF OF 40^
 48925						TGET^
 48926	065660	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48927	065661	302 00 0 00 065640 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48928						STOP2^^
 48929	065662	254 04 0 00 065663 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48930	065663	254 00 0 00 065664 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48931					^
 48932					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48933					;MA SPECIAL BITS NOT SETTING
 48934					;AD MAGIC # 40 @ET1
 48935					;XCTF SET AT FETCH CYCLE
 48936					;AR IR ENABLE @ET1
 48937					;AR SIGN SMEAR
 48938					;AD MAGIC NUMBER ENABLE
 48939					;AB AD EN @ET1
 48940					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 47
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 48941	065664				UUO03:	XUUO	3B8,UUO04^
 48942
 48943					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48944					;ARE CORRECT.
 48945
 48946		003000	000000			MLUUO==3B8		;THE UUO TO BE EXECUTED
 48947						TSET^
 48948			065664			%X=.			;DEFINE %X TO SAVE
 48949	065664	201 00 0 00 065664 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48950	065665	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48951	065666	200 00 0 00 071202 	..0166:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48952	065667	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48953	065670	003000	000000			3B8			;EXECUTE A UUO
 48954	065671	254 04 0 00 065672 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48955	065672	201 02 0 00 065671 		MOVEI	2,.-1		;GET UUO PC
 48956	065673	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48957	065674	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48958	065675	254 04 0 00 065676 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 48959	065676	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 48960	065677	312 00 0 00 071203 		CAME	0,[3B8!0]		;CORRECT UUO STORED IN 40?
 48961	065700	334 00 0 00 000000 		SKIPA			;NO
 48962	065701	254 00 0 00 065710 		JRST	UUO04		;TESTS OK !
 48963						STOP1^
 48964	065702	254 04 0 00 065703 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 48965	065703	254 00 0 00 065704 		JRST	.+1		;INTO RIGHT HALF OF 40^
 48966						TGET^
 48967	065704	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 48968	065705	302 00 0 00 065664 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 48969						STOP2^^
 48970	065706	254 04 0 00 065707 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 48971	065707	254 00 0 00 065710 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 48972					^
 48973					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 48974					;MA SPECIAL BITS NOT SETTING
 48975					;AD MAGIC # 40 @ET1
 48976					;XCTF SET AT FETCH CYCLE
 48977					;AR IR ENABLE @ET1
 48978					;AR SIGN SMEAR
 48979					;AD MAGIC NUMBER ENABLE
 48980					;AB AD EN @ET1
 48981					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 48
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 48982	065710				UUO04:	XUUO	4B8,UUO05^
 48983
 48984					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 48985					;ARE CORRECT.
 48986
 48987		004000	000000			MLUUO==4B8		;THE UUO TO BE EXECUTED
 48988						TSET^
 48989			065710			%X=.			;DEFINE %X TO SAVE
 48990	065710	201 00 0 00 065710 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 48991	065711	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 48992	065712	200 00 0 00 071204 	..0167:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 48993	065713	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 48994	065714	004000	000000			4B8			;EXECUTE A UUO
 48995	065715	254 04 0 00 065716 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 48996	065716	201 02 0 00 065715 		MOVEI	2,.-1		;GET UUO PC
 48997	065717	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 48998	065720	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 48999	065721	254 04 0 00 065722 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49000	065722	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49001	065723	312 00 0 00 070321 		CAME	0,[4B8!0]		;CORRECT UUO STORED IN 40?
 49002	065724	334 00 0 00 000000 		SKIPA			;NO
 49003	065725	254 00 0 00 065734 		JRST	UUO05		;TESTS OK !
 49004						STOP1^
 49005	065726	254 04 0 00 065727 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49006	065727	254 00 0 00 065730 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49007						TGET^
 49008	065730	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49009	065731	302 00 0 00 065710 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49010						STOP2^^
 49011	065732	254 04 0 00 065733 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49012	065733	254 00 0 00 065734 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49013					^
 49014					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49015					;MA SPECIAL BITS NOT SETTING
 49016					;AD MAGIC # 40 @ET1
 49017					;XCTF SET AT FETCH CYCLE
 49018					;AR IR ENABLE @ET1
 49019					;AR SIGN SMEAR
 49020					;AD MAGIC NUMBER ENABLE
 49021					;AB AD EN @ET1
 49022					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 49
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49023	065734				UUO05:	XUUO	5B8,UUO06^
 49024
 49025					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49026					;ARE CORRECT.
 49027
 49028		005000	000000			MLUUO==5B8		;THE UUO TO BE EXECUTED
 49029						TSET^
 49030			065734			%X=.			;DEFINE %X TO SAVE
 49031	065734	201 00 0 00 065734 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49032	065735	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49033	065736	200 00 0 00 071205 	..0170:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49034	065737	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49035	065740	005000	000000			5B8			;EXECUTE A UUO
 49036	065741	254 04 0 00 065742 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49037	065742	201 02 0 00 065741 		MOVEI	2,.-1		;GET UUO PC
 49038	065743	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49039	065744	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49040	065745	254 04 0 00 065746 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49041	065746	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49042	065747	312 00 0 00 071206 		CAME	0,[5B8!0]		;CORRECT UUO STORED IN 40?
 49043	065750	334 00 0 00 000000 		SKIPA			;NO
 49044	065751	254 00 0 00 065760 		JRST	UUO06		;TESTS OK !
 49045						STOP1^
 49046	065752	254 04 0 00 065753 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49047	065753	254 00 0 00 065754 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49048						TGET^
 49049	065754	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49050	065755	302 00 0 00 065734 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49051						STOP2^^
 49052	065756	254 04 0 00 065757 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49053	065757	254 00 0 00 065760 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49054					^
 49055					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49056					;MA SPECIAL BITS NOT SETTING
 49057					;AD MAGIC # 40 @ET1
 49058					;XCTF SET AT FETCH CYCLE
 49059					;AR IR ENABLE @ET1
 49060					;AR SIGN SMEAR
 49061					;AD MAGIC NUMBER ENABLE
 49062					;AB AD EN @ET1
 49063					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 50
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49064	065760				UUO06:	XUUO	6B8,UUO07^
 49065
 49066					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49067					;ARE CORRECT.
 49068
 49069		006000	000000			MLUUO==6B8		;THE UUO TO BE EXECUTED
 49070						TSET^
 49071			065760			%X=.			;DEFINE %X TO SAVE
 49072	065760	201 00 0 00 065760 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49073	065761	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49074	065762	200 00 0 00 071207 	..0171:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49075	065763	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49076	065764	006000	000000			6B8			;EXECUTE A UUO
 49077	065765	254 04 0 00 065766 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49078	065766	201 02 0 00 065765 		MOVEI	2,.-1		;GET UUO PC
 49079	065767	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49080	065770	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49081	065771	254 04 0 00 065772 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49082	065772	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49083	065773	312 00 0 00 071210 		CAME	0,[6B8!0]		;CORRECT UUO STORED IN 40?
 49084	065774	334 00 0 00 000000 		SKIPA			;NO
 49085	065775	254 00 0 00 066004 		JRST	UUO07		;TESTS OK !
 49086						STOP1^
 49087	065776	254 04 0 00 065777 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49088	065777	254 00 0 00 066000 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49089						TGET^
 49090	066000	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49091	066001	302 00 0 00 065760 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49092						STOP2^^
 49093	066002	254 04 0 00 066003 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49094	066003	254 00 0 00 066004 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49095					^
 49096					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49097					;MA SPECIAL BITS NOT SETTING
 49098					;AD MAGIC # 40 @ET1
 49099					;XCTF SET AT FETCH CYCLE
 49100					;AR IR ENABLE @ET1
 49101					;AR SIGN SMEAR
 49102					;AD MAGIC NUMBER ENABLE
 49103					;AB AD EN @ET1
 49104					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 51
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49105	066004				UUO07:	XUUO	7B8,UUO10^
 49106
 49107					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49108					;ARE CORRECT.
 49109
 49110		007000	000000			MLUUO==7B8		;THE UUO TO BE EXECUTED
 49111						TSET^
 49112			066004			%X=.			;DEFINE %X TO SAVE
 49113	066004	201 00 0 00 066004 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49114	066005	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49115	066006	200 00 0 00 071211 	..0172:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49116	066007	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49117	066010	007000	000000			7B8			;EXECUTE A UUO
 49118	066011	254 04 0 00 066012 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49119	066012	201 02 0 00 066011 		MOVEI	2,.-1		;GET UUO PC
 49120	066013	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49121	066014	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49122	066015	254 04 0 00 066016 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49123	066016	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49124	066017	312 00 0 00 071212 		CAME	0,[7B8!0]		;CORRECT UUO STORED IN 40?
 49125	066020	334 00 0 00 000000 		SKIPA			;NO
 49126	066021	254 00 0 00 066030 		JRST	UUO10		;TESTS OK !
 49127						STOP1^
 49128	066022	254 04 0 00 066023 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49129	066023	254 00 0 00 066024 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49130						TGET^
 49131	066024	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49132	066025	302 00 0 00 066004 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49133						STOP2^^
 49134	066026	254 04 0 00 066027 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49135	066027	254 00 0 00 066030 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49136					^
 49137					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49138					;MA SPECIAL BITS NOT SETTING
 49139					;AD MAGIC # 40 @ET1
 49140					;XCTF SET AT FETCH CYCLE
 49141					;AR IR ENABLE @ET1
 49142					;AR SIGN SMEAR
 49143					;AD MAGIC NUMBER ENABLE
 49144					;AB AD EN @ET1
 49145					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 52
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49146	066030				UUO10:	XUUO	10B8,UUO11^
 49147
 49148					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49149					;ARE CORRECT.
 49150
 49151		010000	000000			MLUUO==10B8		;THE UUO TO BE EXECUTED
 49152						TSET^
 49153			066030			%X=.			;DEFINE %X TO SAVE
 49154	066030	201 00 0 00 066030 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49155	066031	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49156	066032	200 00 0 00 071213 	..0173:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49157	066033	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49158	066034	010000	000000			10B8			;EXECUTE A UUO
 49159	066035	254 04 0 00 066036 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49160	066036	201 02 0 00 066035 		MOVEI	2,.-1		;GET UUO PC
 49161	066037	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49162	066040	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49163	066041	254 04 0 00 066042 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49164	066042	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49165	066043	312 00 0 00 070322 		CAME	0,[10B8!0]		;CORRECT UUO STORED IN 40?
 49166	066044	334 00 0 00 000000 		SKIPA			;NO
 49167	066045	254 00 0 00 066054 		JRST	UUO11		;TESTS OK !
 49168						STOP1^
 49169	066046	254 04 0 00 066047 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49170	066047	254 00 0 00 066050 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49171						TGET^
 49172	066050	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49173	066051	302 00 0 00 066030 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49174						STOP2^^
 49175	066052	254 04 0 00 066053 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49176	066053	254 00 0 00 066054 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49177					^
 49178					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49179					;MA SPECIAL BITS NOT SETTING
 49180					;AD MAGIC # 40 @ET1
 49181					;XCTF SET AT FETCH CYCLE
 49182					;AR IR ENABLE @ET1
 49183					;AR SIGN SMEAR
 49184					;AD MAGIC NUMBER ENABLE
 49185					;AB AD EN @ET1
 49186					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 53
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49187	066054				UUO11:	XUUO	11B8,UUO12^
 49188
 49189					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49190					;ARE CORRECT.
 49191
 49192		011000	000000			MLUUO==11B8		;THE UUO TO BE EXECUTED
 49193						TSET^
 49194			066054			%X=.			;DEFINE %X TO SAVE
 49195	066054	201 00 0 00 066054 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49196	066055	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49197	066056	200 00 0 00 071214 	..0174:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49198	066057	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49199	066060	011000	000000			11B8			;EXECUTE A UUO
 49200	066061	254 04 0 00 066062 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49201	066062	201 02 0 00 066061 		MOVEI	2,.-1		;GET UUO PC
 49202	066063	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49203	066064	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49204	066065	254 04 0 00 066066 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49205	066066	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49206	066067	312 00 0 00 071215 		CAME	0,[11B8!0]		;CORRECT UUO STORED IN 40?
 49207	066070	334 00 0 00 000000 		SKIPA			;NO
 49208	066071	254 00 0 00 066100 		JRST	UUO12		;TESTS OK !
 49209						STOP1^
 49210	066072	254 04 0 00 066073 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49211	066073	254 00 0 00 066074 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49212						TGET^
 49213	066074	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49214	066075	302 00 0 00 066054 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49215						STOP2^^
 49216	066076	254 04 0 00 066077 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49217	066077	254 00 0 00 066100 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49218					^
 49219					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49220					;MA SPECIAL BITS NOT SETTING
 49221					;AD MAGIC # 40 @ET1
 49222					;XCTF SET AT FETCH CYCLE
 49223					;AR IR ENABLE @ET1
 49224					;AR SIGN SMEAR
 49225					;AD MAGIC NUMBER ENABLE
 49226					;AB AD EN @ET1
 49227					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 54
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49228	066100				UUO12:	XUUO	12B8,UUO13^
 49229
 49230					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49231					;ARE CORRECT.
 49232
 49233		012000	000000			MLUUO==12B8		;THE UUO TO BE EXECUTED
 49234						TSET^
 49235			066100			%X=.			;DEFINE %X TO SAVE
 49236	066100	201 00 0 00 066100 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49237	066101	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49238	066102	200 00 0 00 071216 	..0175:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49239	066103	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49240	066104	012000	000000			12B8			;EXECUTE A UUO
 49241	066105	254 04 0 00 066106 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49242	066106	201 02 0 00 066105 		MOVEI	2,.-1		;GET UUO PC
 49243	066107	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49244	066110	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49245	066111	254 04 0 00 066112 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49246	066112	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49247	066113	312 00 0 00 071217 		CAME	0,[12B8!0]		;CORRECT UUO STORED IN 40?
 49248	066114	334 00 0 00 000000 		SKIPA			;NO
 49249	066115	254 00 0 00 066124 		JRST	UUO13		;TESTS OK !
 49250						STOP1^
 49251	066116	254 04 0 00 066117 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49252	066117	254 00 0 00 066120 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49253						TGET^
 49254	066120	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49255	066121	302 00 0 00 066100 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49256						STOP2^^
 49257	066122	254 04 0 00 066123 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49258	066123	254 00 0 00 066124 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49259					^
 49260					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49261					;MA SPECIAL BITS NOT SETTING
 49262					;AD MAGIC # 40 @ET1
 49263					;XCTF SET AT FETCH CYCLE
 49264					;AR IR ENABLE @ET1
 49265					;AR SIGN SMEAR
 49266					;AD MAGIC NUMBER ENABLE
 49267					;AB AD EN @ET1
 49268					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 55
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49269	066124				UUO13:	XUUO	13B8,UUO14^
 49270
 49271					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49272					;ARE CORRECT.
 49273
 49274		013000	000000			MLUUO==13B8		;THE UUO TO BE EXECUTED
 49275						TSET^
 49276			066124			%X=.			;DEFINE %X TO SAVE
 49277	066124	201 00 0 00 066124 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49278	066125	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49279	066126	200 00 0 00 071220 	..0176:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49280	066127	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49281	066130	013000	000000			13B8			;EXECUTE A UUO
 49282	066131	254 04 0 00 066132 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49283	066132	201 02 0 00 066131 		MOVEI	2,.-1		;GET UUO PC
 49284	066133	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49285	066134	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49286	066135	254 04 0 00 066136 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49287	066136	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49288	066137	312 00 0 00 071221 		CAME	0,[13B8!0]		;CORRECT UUO STORED IN 40?
 49289	066140	334 00 0 00 000000 		SKIPA			;NO
 49290	066141	254 00 0 00 066150 		JRST	UUO14		;TESTS OK !
 49291						STOP1^
 49292	066142	254 04 0 00 066143 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49293	066143	254 00 0 00 066144 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49294						TGET^
 49295	066144	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49296	066145	302 00 0 00 066124 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49297						STOP2^^
 49298	066146	254 04 0 00 066147 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49299	066147	254 00 0 00 066150 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49300					^
 49301					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49302					;MA SPECIAL BITS NOT SETTING
 49303					;AD MAGIC # 40 @ET1
 49304					;XCTF SET AT FETCH CYCLE
 49305					;AR IR ENABLE @ET1
 49306					;AR SIGN SMEAR
 49307					;AD MAGIC NUMBER ENABLE
 49308					;AB AD EN @ET1
 49309					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 56
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49310	066150				UUO14:	XUUO	14B8,UUO15^
 49311
 49312					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49313					;ARE CORRECT.
 49314
 49315		014000	000000			MLUUO==14B8		;THE UUO TO BE EXECUTED
 49316						TSET^
 49317			066150			%X=.			;DEFINE %X TO SAVE
 49318	066150	201 00 0 00 066150 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49319	066151	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49320	066152	200 00 0 00 071222 	..0177:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49321	066153	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49322	066154	014000	000000			14B8			;EXECUTE A UUO
 49323	066155	254 04 0 00 066156 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49324	066156	201 02 0 00 066155 		MOVEI	2,.-1		;GET UUO PC
 49325	066157	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49326	066160	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49327	066161	254 04 0 00 066162 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49328	066162	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49329	066163	312 00 0 00 071223 		CAME	0,[14B8!0]		;CORRECT UUO STORED IN 40?
 49330	066164	334 00 0 00 000000 		SKIPA			;NO
 49331	066165	254 00 0 00 066174 		JRST	UUO15		;TESTS OK !
 49332						STOP1^
 49333	066166	254 04 0 00 066167 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49334	066167	254 00 0 00 066170 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49335						TGET^
 49336	066170	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49337	066171	302 00 0 00 066150 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49338						STOP2^^
 49339	066172	254 04 0 00 066173 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49340	066173	254 00 0 00 066174 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49341					^
 49342					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49343					;MA SPECIAL BITS NOT SETTING
 49344					;AD MAGIC # 40 @ET1
 49345					;XCTF SET AT FETCH CYCLE
 49346					;AR IR ENABLE @ET1
 49347					;AR SIGN SMEAR
 49348					;AD MAGIC NUMBER ENABLE
 49349					;AB AD EN @ET1
 49350					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 57
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49351	066174				UUO15:	XUUO	15B8,UUO16^
 49352
 49353					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49354					;ARE CORRECT.
 49355
 49356		015000	000000			MLUUO==15B8		;THE UUO TO BE EXECUTED
 49357						TSET^
 49358			066174			%X=.			;DEFINE %X TO SAVE
 49359	066174	201 00 0 00 066174 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49360	066175	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49361	066176	200 00 0 00 071224 	..0200:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49362	066177	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49363	066200	015000	000000			15B8			;EXECUTE A UUO
 49364	066201	254 04 0 00 066202 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49365	066202	201 02 0 00 066201 		MOVEI	2,.-1		;GET UUO PC
 49366	066203	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49367	066204	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49368	066205	254 04 0 00 066206 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49369	066206	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49370	066207	312 00 0 00 071225 		CAME	0,[15B8!0]		;CORRECT UUO STORED IN 40?
 49371	066210	334 00 0 00 000000 		SKIPA			;NO
 49372	066211	254 00 0 00 066220 		JRST	UUO16		;TESTS OK !
 49373						STOP1^
 49374	066212	254 04 0 00 066213 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49375	066213	254 00 0 00 066214 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49376						TGET^
 49377	066214	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49378	066215	302 00 0 00 066174 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49379						STOP2^^
 49380	066216	254 04 0 00 066217 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49381	066217	254 00 0 00 066220 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49382					^
 49383					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49384					;MA SPECIAL BITS NOT SETTING
 49385					;AD MAGIC # 40 @ET1
 49386					;XCTF SET AT FETCH CYCLE
 49387					;AR IR ENABLE @ET1
 49388					;AR SIGN SMEAR
 49389					;AD MAGIC NUMBER ENABLE
 49390					;AB AD EN @ET1
 49391					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 58
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49392	066220				UUO16:	XUUO	16B8,UUO17^
 49393
 49394					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49395					;ARE CORRECT.
 49396
 49397		016000	000000			MLUUO==16B8		;THE UUO TO BE EXECUTED
 49398						TSET^
 49399			066220			%X=.			;DEFINE %X TO SAVE
 49400	066220	201 00 0 00 066220 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49401	066221	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49402	066222	200 00 0 00 071226 	..0201:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49403	066223	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49404	066224	016000	000000			16B8			;EXECUTE A UUO
 49405	066225	254 04 0 00 066226 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49406	066226	201 02 0 00 066225 		MOVEI	2,.-1		;GET UUO PC
 49407	066227	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49408	066230	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49409	066231	254 04 0 00 066232 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49410	066232	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49411	066233	312 00 0 00 071227 		CAME	0,[16B8!0]		;CORRECT UUO STORED IN 40?
 49412	066234	334 00 0 00 000000 		SKIPA			;NO
 49413	066235	254 00 0 00 066244 		JRST	UUO17		;TESTS OK !
 49414						STOP1^
 49415	066236	254 04 0 00 066237 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49416	066237	254 00 0 00 066240 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49417						TGET^
 49418	066240	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49419	066241	302 00 0 00 066220 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49420						STOP2^^
 49421	066242	254 04 0 00 066243 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49422	066243	254 00 0 00 066244 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49423					^
 49424					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49425					;MA SPECIAL BITS NOT SETTING
 49426					;AD MAGIC # 40 @ET1
 49427					;XCTF SET AT FETCH CYCLE
 49428					;AR IR ENABLE @ET1
 49429					;AR SIGN SMEAR
 49430					;AD MAGIC NUMBER ENABLE
 49431					;AB AD EN @ET1
 49432					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 59
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49433	066244				UUO17:	XUUO	17B8,UUO20^
 49434
 49435					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49436					;ARE CORRECT.
 49437
 49438		017000	000000			MLUUO==17B8		;THE UUO TO BE EXECUTED
 49439						TSET^
 49440			066244			%X=.			;DEFINE %X TO SAVE
 49441	066244	201 00 0 00 066244 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49442	066245	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49443	066246	200 00 0 00 071230 	..0202:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49444	066247	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49445	066250	017000	000000			17B8			;EXECUTE A UUO
 49446	066251	254 04 0 00 066252 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49447	066252	201 02 0 00 066251 		MOVEI	2,.-1		;GET UUO PC
 49448	066253	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49449	066254	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49450	066255	254 04 0 00 066256 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49451	066256	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49452	066257	312 00 0 00 071231 		CAME	0,[17B8!0]		;CORRECT UUO STORED IN 40?
 49453	066260	334 00 0 00 000000 		SKIPA			;NO
 49454	066261	254 00 0 00 066270 		JRST	UUO20		;TESTS OK !
 49455						STOP1^
 49456	066262	254 04 0 00 066263 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49457	066263	254 00 0 00 066264 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49458						TGET^
 49459	066264	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49460	066265	302 00 0 00 066244 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49461						STOP2^^
 49462	066266	254 04 0 00 066267 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49463	066267	254 00 0 00 066270 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49464					^
 49465					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49466					;MA SPECIAL BITS NOT SETTING
 49467					;AD MAGIC # 40 @ET1
 49468					;XCTF SET AT FETCH CYCLE
 49469					;AR IR ENABLE @ET1
 49470					;AR SIGN SMEAR
 49471					;AD MAGIC NUMBER ENABLE
 49472					;AB AD EN @ET1
 49473					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 60
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49474	066270				UUO20:	XUUO	20B8,UUO21^
 49475
 49476					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49477					;ARE CORRECT.
 49478
 49479		020000	000000			MLUUO==20B8		;THE UUO TO BE EXECUTED
 49480						TSET^
 49481			066270			%X=.			;DEFINE %X TO SAVE
 49482	066270	201 00 0 00 066270 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49483	066271	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49484	066272	200 00 0 00 071232 	..0203:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49485	066273	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49486	066274	020000	000000			20B8			;EXECUTE A UUO
 49487	066275	254 04 0 00 066276 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49488	066276	201 02 0 00 066275 		MOVEI	2,.-1		;GET UUO PC
 49489	066277	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49490	066300	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49491	066301	254 04 0 00 066302 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49492	066302	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49493	066303	312 00 0 00 070323 		CAME	0,[20B8!0]		;CORRECT UUO STORED IN 40?
 49494	066304	334 00 0 00 000000 		SKIPA			;NO
 49495	066305	254 00 0 00 066314 		JRST	UUO21		;TESTS OK !
 49496						STOP1^
 49497	066306	254 04 0 00 066307 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49498	066307	254 00 0 00 066310 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49499						TGET^
 49500	066310	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49501	066311	302 00 0 00 066270 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49502						STOP2^^
 49503	066312	254 04 0 00 066313 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49504	066313	254 00 0 00 066314 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49505					^
 49506					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49507					;MA SPECIAL BITS NOT SETTING
 49508					;AD MAGIC # 40 @ET1
 49509					;XCTF SET AT FETCH CYCLE
 49510					;AR IR ENABLE @ET1
 49511					;AR SIGN SMEAR
 49512					;AD MAGIC NUMBER ENABLE
 49513					;AB AD EN @ET1
 49514					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 61
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49515	066314				UUO21:	XUUO	21B8,UUO22^
 49516
 49517					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49518					;ARE CORRECT.
 49519
 49520		021000	000000			MLUUO==21B8		;THE UUO TO BE EXECUTED
 49521						TSET^
 49522			066314			%X=.			;DEFINE %X TO SAVE
 49523	066314	201 00 0 00 066314 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49524	066315	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49525	066316	200 00 0 00 071233 	..0204:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49526	066317	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49527	066320	021000	000000			21B8			;EXECUTE A UUO
 49528	066321	254 04 0 00 066322 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49529	066322	201 02 0 00 066321 		MOVEI	2,.-1		;GET UUO PC
 49530	066323	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49531	066324	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49532	066325	254 04 0 00 066326 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49533	066326	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49534	066327	312 00 0 00 071234 		CAME	0,[21B8!0]		;CORRECT UUO STORED IN 40?
 49535	066330	334 00 0 00 000000 		SKIPA			;NO
 49536	066331	254 00 0 00 066340 		JRST	UUO22		;TESTS OK !
 49537						STOP1^
 49538	066332	254 04 0 00 066333 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49539	066333	254 00 0 00 066334 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49540						TGET^
 49541	066334	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49542	066335	302 00 0 00 066314 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49543						STOP2^^
 49544	066336	254 04 0 00 066337 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49545	066337	254 00 0 00 066340 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49546					^
 49547					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49548					;MA SPECIAL BITS NOT SETTING
 49549					;AD MAGIC # 40 @ET1
 49550					;XCTF SET AT FETCH CYCLE
 49551					;AR IR ENABLE @ET1
 49552					;AR SIGN SMEAR
 49553					;AD MAGIC NUMBER ENABLE
 49554					;AB AD EN @ET1
 49555					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 62
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49556	066340				UUO22:	XUUO	22B8,UUO23^
 49557
 49558					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49559					;ARE CORRECT.
 49560
 49561		022000	000000			MLUUO==22B8		;THE UUO TO BE EXECUTED
 49562						TSET^
 49563			066340			%X=.			;DEFINE %X TO SAVE
 49564	066340	201 00 0 00 066340 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49565	066341	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49566	066342	200 00 0 00 071235 	..0205:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49567	066343	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49568	066344	022000	000000			22B8			;EXECUTE A UUO
 49569	066345	254 04 0 00 066346 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49570	066346	201 02 0 00 066345 		MOVEI	2,.-1		;GET UUO PC
 49571	066347	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49572	066350	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49573	066351	254 04 0 00 066352 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49574	066352	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49575	066353	312 00 0 00 071236 		CAME	0,[22B8!0]		;CORRECT UUO STORED IN 40?
 49576	066354	334 00 0 00 000000 		SKIPA			;NO
 49577	066355	254 00 0 00 066364 		JRST	UUO23		;TESTS OK !
 49578						STOP1^
 49579	066356	254 04 0 00 066357 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49580	066357	254 00 0 00 066360 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49581						TGET^
 49582	066360	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49583	066361	302 00 0 00 066340 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49584						STOP2^^
 49585	066362	254 04 0 00 066363 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49586	066363	254 00 0 00 066364 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49587					^
 49588					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49589					;MA SPECIAL BITS NOT SETTING
 49590					;AD MAGIC # 40 @ET1
 49591					;XCTF SET AT FETCH CYCLE
 49592					;AR IR ENABLE @ET1
 49593					;AR SIGN SMEAR
 49594					;AD MAGIC NUMBER ENABLE
 49595					;AB AD EN @ET1
 49596					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 63
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49597	066364				UUO23:	XUUO	23B8,UUO24^
 49598
 49599					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49600					;ARE CORRECT.
 49601
 49602		023000	000000			MLUUO==23B8		;THE UUO TO BE EXECUTED
 49603						TSET^
 49604			066364			%X=.			;DEFINE %X TO SAVE
 49605	066364	201 00 0 00 066364 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49606	066365	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49607	066366	200 00 0 00 071237 	..0206:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49608	066367	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49609	066370	023000	000000			23B8			;EXECUTE A UUO
 49610	066371	254 04 0 00 066372 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49611	066372	201 02 0 00 066371 		MOVEI	2,.-1		;GET UUO PC
 49612	066373	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49613	066374	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49614	066375	254 04 0 00 066376 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49615	066376	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49616	066377	312 00 0 00 071240 		CAME	0,[23B8!0]		;CORRECT UUO STORED IN 40?
 49617	066400	334 00 0 00 000000 		SKIPA			;NO
 49618	066401	254 00 0 00 066410 		JRST	UUO24		;TESTS OK !
 49619						STOP1^
 49620	066402	254 04 0 00 066403 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49621	066403	254 00 0 00 066404 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49622						TGET^
 49623	066404	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49624	066405	302 00 0 00 066364 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49625						STOP2^^
 49626	066406	254 04 0 00 066407 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49627	066407	254 00 0 00 066410 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49628					^
 49629					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49630					;MA SPECIAL BITS NOT SETTING
 49631					;AD MAGIC # 40 @ET1
 49632					;XCTF SET AT FETCH CYCLE
 49633					;AR IR ENABLE @ET1
 49634					;AR SIGN SMEAR
 49635					;AD MAGIC NUMBER ENABLE
 49636					;AB AD EN @ET1
 49637					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 64
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49638	066410				UUO24:	XUUO	24B8,UUO25^
 49639
 49640					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49641					;ARE CORRECT.
 49642
 49643		024000	000000			MLUUO==24B8		;THE UUO TO BE EXECUTED
 49644						TSET^
 49645			066410			%X=.			;DEFINE %X TO SAVE
 49646	066410	201 00 0 00 066410 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49647	066411	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49648	066412	200 00 0 00 071241 	..0207:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49649	066413	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49650	066414	024000	000000			24B8			;EXECUTE A UUO
 49651	066415	254 04 0 00 066416 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49652	066416	201 02 0 00 066415 		MOVEI	2,.-1		;GET UUO PC
 49653	066417	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49654	066420	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49655	066421	254 04 0 00 066422 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49656	066422	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49657	066423	312 00 0 00 071242 		CAME	0,[24B8!0]		;CORRECT UUO STORED IN 40?
 49658	066424	334 00 0 00 000000 		SKIPA			;NO
 49659	066425	254 00 0 00 066434 		JRST	UUO25		;TESTS OK !
 49660						STOP1^
 49661	066426	254 04 0 00 066427 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49662	066427	254 00 0 00 066430 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49663						TGET^
 49664	066430	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49665	066431	302 00 0 00 066410 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49666						STOP2^^
 49667	066432	254 04 0 00 066433 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49668	066433	254 00 0 00 066434 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49669					^
 49670					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49671					;MA SPECIAL BITS NOT SETTING
 49672					;AD MAGIC # 40 @ET1
 49673					;XCTF SET AT FETCH CYCLE
 49674					;AR IR ENABLE @ET1
 49675					;AR SIGN SMEAR
 49676					;AD MAGIC NUMBER ENABLE
 49677					;AB AD EN @ET1
 49678					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 65
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49679	066434				UUO25:	XUUO	25B8,UUO26^
 49680
 49681					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49682					;ARE CORRECT.
 49683
 49684		025000	000000			MLUUO==25B8		;THE UUO TO BE EXECUTED
 49685						TSET^
 49686			066434			%X=.			;DEFINE %X TO SAVE
 49687	066434	201 00 0 00 066434 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49688	066435	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49689	066436	200 00 0 00 071243 	..0210:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49690	066437	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49691	066440	025000	000000			25B8			;EXECUTE A UUO
 49692	066441	254 04 0 00 066442 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49693	066442	201 02 0 00 066441 		MOVEI	2,.-1		;GET UUO PC
 49694	066443	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49695	066444	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49696	066445	254 04 0 00 066446 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49697	066446	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49698	066447	312 00 0 00 071244 		CAME	0,[25B8!0]		;CORRECT UUO STORED IN 40?
 49699	066450	334 00 0 00 000000 		SKIPA			;NO
 49700	066451	254 00 0 00 066460 		JRST	UUO26		;TESTS OK !
 49701						STOP1^
 49702	066452	254 04 0 00 066453 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49703	066453	254 00 0 00 066454 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49704						TGET^
 49705	066454	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49706	066455	302 00 0 00 066434 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49707						STOP2^^
 49708	066456	254 04 0 00 066457 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49709	066457	254 00 0 00 066460 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49710					^
 49711					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49712					;MA SPECIAL BITS NOT SETTING
 49713					;AD MAGIC # 40 @ET1
 49714					;XCTF SET AT FETCH CYCLE
 49715					;AR IR ENABLE @ET1
 49716					;AR SIGN SMEAR
 49717					;AD MAGIC NUMBER ENABLE
 49718					;AB AD EN @ET1
 49719					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 66
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49720	066460				UUO26:	XUUO	26B8,UUO27^
 49721
 49722					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49723					;ARE CORRECT.
 49724
 49725		026000	000000			MLUUO==26B8		;THE UUO TO BE EXECUTED
 49726						TSET^
 49727			066460			%X=.			;DEFINE %X TO SAVE
 49728	066460	201 00 0 00 066460 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49729	066461	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49730	066462	200 00 0 00 071245 	..0211:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49731	066463	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49732	066464	026000	000000			26B8			;EXECUTE A UUO
 49733	066465	254 04 0 00 066466 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49734	066466	201 02 0 00 066465 		MOVEI	2,.-1		;GET UUO PC
 49735	066467	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49736	066470	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49737	066471	254 04 0 00 066472 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49738	066472	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49739	066473	312 00 0 00 071246 		CAME	0,[26B8!0]		;CORRECT UUO STORED IN 40?
 49740	066474	334 00 0 00 000000 		SKIPA			;NO
 49741	066475	254 00 0 00 066504 		JRST	UUO27		;TESTS OK !
 49742						STOP1^
 49743	066476	254 04 0 00 066477 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49744	066477	254 00 0 00 066500 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49745						TGET^
 49746	066500	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49747	066501	302 00 0 00 066460 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49748						STOP2^^
 49749	066502	254 04 0 00 066503 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49750	066503	254 00 0 00 066504 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49751					^
 49752					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49753					;MA SPECIAL BITS NOT SETTING
 49754					;AD MAGIC # 40 @ET1
 49755					;XCTF SET AT FETCH CYCLE
 49756					;AR IR ENABLE @ET1
 49757					;AR SIGN SMEAR
 49758					;AD MAGIC NUMBER ENABLE
 49759					;AB AD EN @ET1
 49760					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 67
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49761	066504				UUO27:	XUUO	27B8,UUO30^
 49762
 49763					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49764					;ARE CORRECT.
 49765
 49766		027000	000000			MLUUO==27B8		;THE UUO TO BE EXECUTED
 49767						TSET^
 49768			066504			%X=.			;DEFINE %X TO SAVE
 49769	066504	201 00 0 00 066504 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49770	066505	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49771	066506	200 00 0 00 071247 	..0212:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49772	066507	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49773	066510	027000	000000			27B8			;EXECUTE A UUO
 49774	066511	254 04 0 00 066512 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49775	066512	201 02 0 00 066511 		MOVEI	2,.-1		;GET UUO PC
 49776	066513	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49777	066514	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49778	066515	254 04 0 00 066516 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49779	066516	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49780	066517	312 00 0 00 071250 		CAME	0,[27B8!0]		;CORRECT UUO STORED IN 40?
 49781	066520	334 00 0 00 000000 		SKIPA			;NO
 49782	066521	254 00 0 00 066530 		JRST	UUO30		;TESTS OK !
 49783						STOP1^
 49784	066522	254 04 0 00 066523 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49785	066523	254 00 0 00 066524 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49786						TGET^
 49787	066524	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49788	066525	302 00 0 00 066504 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49789						STOP2^^
 49790	066526	254 04 0 00 066527 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49791	066527	254 00 0 00 066530 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49792					^
 49793					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49794					;MA SPECIAL BITS NOT SETTING
 49795					;AD MAGIC # 40 @ET1
 49796					;XCTF SET AT FETCH CYCLE
 49797					;AR IR ENABLE @ET1
 49798					;AR SIGN SMEAR
 49799					;AD MAGIC NUMBER ENABLE
 49800					;AB AD EN @ET1
 49801					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 68
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49802	066530				UUO30:	XUUO	30B8,UUO31^
 49803
 49804					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49805					;ARE CORRECT.
 49806
 49807		030000	000000			MLUUO==30B8		;THE UUO TO BE EXECUTED
 49808						TSET^
 49809			066530			%X=.			;DEFINE %X TO SAVE
 49810	066530	201 00 0 00 066530 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49811	066531	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49812	066532	200 00 0 00 071251 	..0213:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49813	066533	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49814	066534	030000	000000			30B8			;EXECUTE A UUO
 49815	066535	254 04 0 00 066536 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49816	066536	201 02 0 00 066535 		MOVEI	2,.-1		;GET UUO PC
 49817	066537	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49818	066540	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49819	066541	254 04 0 00 066542 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49820	066542	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49821	066543	312 00 0 00 071252 		CAME	0,[30B8!0]		;CORRECT UUO STORED IN 40?
 49822	066544	334 00 0 00 000000 		SKIPA			;NO
 49823	066545	254 00 0 00 066554 		JRST	UUO31		;TESTS OK !
 49824						STOP1^
 49825	066546	254 04 0 00 066547 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49826	066547	254 00 0 00 066550 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49827						TGET^
 49828	066550	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49829	066551	302 00 0 00 066530 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49830						STOP2^^
 49831	066552	254 04 0 00 066553 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49832	066553	254 00 0 00 066554 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49833					^
 49834					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49835					;MA SPECIAL BITS NOT SETTING
 49836					;AD MAGIC # 40 @ET1
 49837					;XCTF SET AT FETCH CYCLE
 49838					;AR IR ENABLE @ET1
 49839					;AR SIGN SMEAR
 49840					;AD MAGIC NUMBER ENABLE
 49841					;AB AD EN @ET1
 49842					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 69
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49843	066554				UUO31:	XUUO	31B8,UUO32^
 49844
 49845					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49846					;ARE CORRECT.
 49847
 49848		031000	000000			MLUUO==31B8		;THE UUO TO BE EXECUTED
 49849						TSET^
 49850			066554			%X=.			;DEFINE %X TO SAVE
 49851	066554	201 00 0 00 066554 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49852	066555	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49853	066556	200 00 0 00 071253 	..0214:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49854	066557	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49855	066560	031000	000000			31B8			;EXECUTE A UUO
 49856	066561	254 04 0 00 066562 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49857	066562	201 02 0 00 066561 		MOVEI	2,.-1		;GET UUO PC
 49858	066563	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49859	066564	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49860	066565	254 04 0 00 066566 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49861	066566	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49862	066567	312 00 0 00 071254 		CAME	0,[31B8!0]		;CORRECT UUO STORED IN 40?
 49863	066570	334 00 0 00 000000 		SKIPA			;NO
 49864	066571	254 00 0 00 066600 		JRST	UUO32		;TESTS OK !
 49865						STOP1^
 49866	066572	254 04 0 00 066573 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49867	066573	254 00 0 00 066574 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49868						TGET^
 49869	066574	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49870	066575	302 00 0 00 066554 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49871						STOP2^^
 49872	066576	254 04 0 00 066577 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49873	066577	254 00 0 00 066600 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49874					^
 49875					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49876					;MA SPECIAL BITS NOT SETTING
 49877					;AD MAGIC # 40 @ET1
 49878					;XCTF SET AT FETCH CYCLE
 49879					;AR IR ENABLE @ET1
 49880					;AR SIGN SMEAR
 49881					;AD MAGIC NUMBER ENABLE
 49882					;AB AD EN @ET1
 49883					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 70
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49884	066600				UUO32:	XUUO	32B8,UUO33^
 49885
 49886					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49887					;ARE CORRECT.
 49888
 49889		032000	000000			MLUUO==32B8		;THE UUO TO BE EXECUTED
 49890						TSET^
 49891			066600			%X=.			;DEFINE %X TO SAVE
 49892	066600	201 00 0 00 066600 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49893	066601	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49894	066602	200 00 0 00 071255 	..0215:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49895	066603	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49896	066604	032000	000000			32B8			;EXECUTE A UUO
 49897	066605	254 04 0 00 066606 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49898	066606	201 02 0 00 066605 		MOVEI	2,.-1		;GET UUO PC
 49899	066607	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49900	066610	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49901	066611	254 04 0 00 066612 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49902	066612	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49903	066613	312 00 0 00 071256 		CAME	0,[32B8!0]		;CORRECT UUO STORED IN 40?
 49904	066614	334 00 0 00 000000 		SKIPA			;NO
 49905	066615	254 00 0 00 066624 		JRST	UUO33		;TESTS OK !
 49906						STOP1^
 49907	066616	254 04 0 00 066617 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49908	066617	254 00 0 00 066620 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49909						TGET^
 49910	066620	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49911	066621	302 00 0 00 066600 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49912						STOP2^^
 49913	066622	254 04 0 00 066623 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49914	066623	254 00 0 00 066624 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49915					^
 49916					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49917					;MA SPECIAL BITS NOT SETTING
 49918					;AD MAGIC # 40 @ET1
 49919					;XCTF SET AT FETCH CYCLE
 49920					;AR IR ENABLE @ET1
 49921					;AR SIGN SMEAR
 49922					;AD MAGIC NUMBER ENABLE
 49923					;AB AD EN @ET1
 49924					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 71
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49925	066624				UUO33:	XUUO	33B8,UUO34^
 49926
 49927					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49928					;ARE CORRECT.
 49929
 49930		033000	000000			MLUUO==33B8		;THE UUO TO BE EXECUTED
 49931						TSET^
 49932			066624			%X=.			;DEFINE %X TO SAVE
 49933	066624	201 00 0 00 066624 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49934	066625	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49935	066626	200 00 0 00 071257 	..0216:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49936	066627	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49937	066630	033000	000000			33B8			;EXECUTE A UUO
 49938	066631	254 04 0 00 066632 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49939	066632	201 02 0 00 066631 		MOVEI	2,.-1		;GET UUO PC
 49940	066633	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49941	066634	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49942	066635	254 04 0 00 066636 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49943	066636	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49944	066637	312 00 0 00 071260 		CAME	0,[33B8!0]		;CORRECT UUO STORED IN 40?
 49945	066640	334 00 0 00 000000 		SKIPA			;NO
 49946	066641	254 00 0 00 066650 		JRST	UUO34		;TESTS OK !
 49947						STOP1^
 49948	066642	254 04 0 00 066643 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49949	066643	254 00 0 00 066644 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49950						TGET^
 49951	066644	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49952	066645	302 00 0 00 066624 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49953						STOP2^^
 49954	066646	254 04 0 00 066647 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49955	066647	254 00 0 00 066650 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49956					^
 49957					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49958					;MA SPECIAL BITS NOT SETTING
 49959					;AD MAGIC # 40 @ET1
 49960					;XCTF SET AT FETCH CYCLE
 49961					;AR IR ENABLE @ET1
 49962					;AR SIGN SMEAR
 49963					;AD MAGIC NUMBER ENABLE
 49964					;AB AD EN @ET1
 49965					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 72
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 49966	066650				UUO34:	XUUO	34B8,UUO35^
 49967
 49968					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 49969					;ARE CORRECT.
 49970
 49971		034000	000000			MLUUO==34B8		;THE UUO TO BE EXECUTED
 49972						TSET^
 49973			066650			%X=.			;DEFINE %X TO SAVE
 49974	066650	201 00 0 00 066650 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 49975	066651	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 49976	066652	200 00 0 00 071261 	..0217:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 49977	066653	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 49978	066654	034000	000000			34B8			;EXECUTE A UUO
 49979	066655	254 04 0 00 066656 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 49980	066656	201 02 0 00 066655 		MOVEI	2,.-1		;GET UUO PC
 49981	066657	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 49982	066660	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 49983	066661	254 04 0 00 066662 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 49984	066662	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 49985	066663	312 00 0 00 071262 		CAME	0,[34B8!0]		;CORRECT UUO STORED IN 40?
 49986	066664	334 00 0 00 000000 		SKIPA			;NO
 49987	066665	254 00 0 00 066674 		JRST	UUO35		;TESTS OK !
 49988						STOP1^
 49989	066666	254 04 0 00 066667 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 49990	066667	254 00 0 00 066670 		JRST	.+1		;INTO RIGHT HALF OF 40^
 49991						TGET^
 49992	066670	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 49993	066671	302 00 0 00 066650 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 49994						STOP2^^
 49995	066672	254 04 0 00 066673 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 49996	066673	254 00 0 00 066674 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 49997					^
 49998					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 49999					;MA SPECIAL BITS NOT SETTING
 50000					;AD MAGIC # 40 @ET1
 50001					;XCTF SET AT FETCH CYCLE
 50002					;AR IR ENABLE @ET1
 50003					;AR SIGN SMEAR
 50004					;AD MAGIC NUMBER ENABLE
 50005					;AB AD EN @ET1
 50006					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 73
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 50007	066674				UUO35:	XUUO	35B8,UUO36^
 50008
 50009					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 50010					;ARE CORRECT.
 50011
 50012		035000	000000			MLUUO==35B8		;THE UUO TO BE EXECUTED
 50013						TSET^
 50014			066674			%X=.			;DEFINE %X TO SAVE
 50015	066674	201 00 0 00 066674 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50016	066675	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50017	066676	200 00 0 00 071263 	..0220:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 50018	066677	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 50019	066700	035000	000000			35B8			;EXECUTE A UUO
 50020	066701	254 04 0 00 066702 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 50021	066702	201 02 0 00 066701 		MOVEI	2,.-1		;GET UUO PC
 50022	066703	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 50023	066704	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 50024	066705	254 04 0 00 066706 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 50025	066706	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 50026	066707	312 00 0 00 071264 		CAME	0,[35B8!0]		;CORRECT UUO STORED IN 40?
 50027	066710	334 00 0 00 000000 		SKIPA			;NO
 50028	066711	254 00 0 00 066720 		JRST	UUO36		;TESTS OK !
 50029						STOP1^
 50030	066712	254 04 0 00 066713 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50031	066713	254 00 0 00 066714 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50032						TGET^
 50033	066714	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50034	066715	302 00 0 00 066674 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50035						STOP2^^
 50036	066716	254 04 0 00 066717 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50037	066717	254 00 0 00 066720 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50038					^
 50039					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 50040					;MA SPECIAL BITS NOT SETTING
 50041					;AD MAGIC # 40 @ET1
 50042					;XCTF SET AT FETCH CYCLE
 50043					;AR IR ENABLE @ET1
 50044					;AR SIGN SMEAR
 50045					;AD MAGIC NUMBER ENABLE
 50046					;AB AD EN @ET1
 50047					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 74
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 50048	066720				UUO36:	XUUO	36B8,UUO37^
 50049
 50050					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 50051					;ARE CORRECT.
 50052
 50053		036000	000000			MLUUO==36B8		;THE UUO TO BE EXECUTED
 50054						TSET^
 50055			066720			%X=.			;DEFINE %X TO SAVE
 50056	066720	201 00 0 00 066720 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50057	066721	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50058	066722	200 00 0 00 071265 	..0221:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 50059	066723	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 50060	066724	036000	000000			36B8			;EXECUTE A UUO
 50061	066725	254 04 0 00 066726 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 50062	066726	201 02 0 00 066725 		MOVEI	2,.-1		;GET UUO PC
 50063	066727	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 50064	066730	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 50065	066731	254 04 0 00 066732 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 50066	066732	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 50067	066733	312 00 0 00 071266 		CAME	0,[36B8!0]		;CORRECT UUO STORED IN 40?
 50068	066734	334 00 0 00 000000 		SKIPA			;NO
 50069	066735	254 00 0 00 066744 		JRST	UUO37		;TESTS OK !
 50070						STOP1^
 50071	066736	254 04 0 00 066737 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50072	066737	254 00 0 00 066740 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50073						TGET^
 50074	066740	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50075	066741	302 00 0 00 066720 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50076						STOP2^^
 50077	066742	254 04 0 00 066743 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50078	066743	254 00 0 00 066744 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50079					^
 50080					;POSSIBLE CAUSES OF FAILURES IN LUUO FLOW.
 50081					;MA SPECIAL BITS NOT SETTING
 50082					;AD MAGIC # 40 @ET1
 50083					;XCTF SET AT FETCH CYCLE
 50084					;AR IR ENABLE @ET1
 50085					;AR SIGN SMEAR
 50086					;AD MAGIC NUMBER ENABLE
 50087					;AB AD EN @ET1
 50088					;INSTRUCTION FETCH @ET2
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 75
DFKAA8	MAC	13-Jan-89 10:22		LOCAL UUO TESTING (LUUO)

 50089	066744				UUO37:	XUUO	37B8,UUOPC^
 50090
 50091					;EXECUTE AN LUUO AND CHECK THAT THE UUO AND PC STORED
 50092					;ARE CORRECT.
 50093
 50094		037000	000000			MLUUO==37B8		;THE UUO TO BE EXECUTED
 50095						TSET^
 50096			066744			%X=.			;DEFINE %X TO SAVE
 50097	066744	201 00 0 00 066744 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50098	066745	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50099	066746	200 00 0 00 071267 	..0222:	MOVE	0,[JSP	1,.+4]	;TRAP INSTRUCTION
 50100	066747	202 00 0 00 000041 		MOVEM	0,41		;IN TO 41
 50101	066750	037000	000000			37B8			;EXECUTE A UUO
 50102	066751	254 04 0 00 066752 		HALT	.+1		;UUO DID NOT TRAP TO FORTY
 50103	066752	201 02 0 00 066751 		MOVEI	2,.-1		;GET UUO PC
 50104	066753	405 01 0 00 777777 		ANDI	1,-1		;MASK FLAGS OUT
 50105	066754	312 01 0 00 000002 		CAME	1,2		;PC CORRECT ?
 50106	066755	254 04 0 00 066756 		HALT	.+1		;PC OF UUO NOT = TO PC STORED
 50107	066756	200 00 0 00 000040 		MOVE	0,40		;GET UUO !
 50108	066757	312 00 0 00 071270 		CAME	0,[37B8!0]		;CORRECT UUO STORED IN 40?
 50109	066760	334 00 0 00 000000 		SKIPA			;NO
 50110	066761	254 00 0 00 066771 		JRST	UUOPC		;TESTS OK !
 50111						STOP1^
 50112	066762	254 04 0 00 066763 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50113	066763	254 00 0 00 066764 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50114						TGET^
 50115	066764	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50116	066765	302 00 0 00 066744 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50117						STOP2^^
 50118	066766	254 04 0 00 066767 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50119	066767	254 00 0 00 066770 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50120					^
 50121
 50122	066770	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50123					SUBTTL	TEST UUO STORING CORRECTLY
 50124					;TEST THE MA PORTION OF THE UUO TO SEE IF BITS 18-35 ARE STORED CORRECTLY
 50125					;ROUTINE ROTATES A BIT LEFT THROUGH THE MA OF THE UUO
 50126					;THEN DOES ALTERNATING PATTERN, ALL ONES AND ALL ZEROS
 50127
 50128			000001			X=1
 50129	066771				UUOPC:
 50130	066771				UUOPCA:
 50131						REPEAT	^D18,<
 50132						XUUOA	X
 50133						X=X_1
 50134					>
 50135
 50136						XUUOA	X^
 50137
 50138					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50139
 50140			000001			EFIELD==X		;"E" WE ARE TESTING FOR
 50141						TSET^
 50142			066771			%X=.			;DEFINE %X TO SAVE
 50143	066771	201 00 0 00 066771 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50144	066772	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50145	066773	200 00 0 00 071271 	..0223:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50146	066774	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50147	066775	001000	000001			1B8!X			;EXECUTE A UUO
 50148	066776	254 04 0 00 066777 	..0224:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50149	066777	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50150	067000	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50151	067001	302 00 0 00 000001 		CAIE	X		;MA BITS CORRECT?
 50152	067002				..0225:	STOP1^
 50153	067002	254 04 0 00 067003 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50154	067003	254 00 0 00 067004 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50155						TGET^
 50156	067004	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50157	067005	302 00 0 00 066771 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50158						STOP2^^
 50159	067006	254 04 0 00 067007 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50160	067007	254 00 0 00 067010 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50161					^
 50162			000002			X=X_1
 50163
 50164
 50165						XUUOA	X^
 50166
 50167					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50168
 50169			000002			EFIELD==X		;"E" WE ARE TESTING FOR
 50170						TSET^
 50171			067010			%X=.			;DEFINE %X TO SAVE
 50172	067010	201 00 0 00 067010 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50173	067011	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50174	067012	200 00 0 00 071272 	..0226:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50175	067013	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50176	067014	001000	000002			1B8!X			;EXECUTE A UUO
 50177	067015	254 04 0 00 067016 	..0227:	HALT	.+1		;UUO DIDN'T TRAP TO 40
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-1
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50178	067016	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50179	067017	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50180	067020	302 00 0 00 000002 		CAIE	X		;MA BITS CORRECT?
 50181	067021				..0230:	STOP1^
 50182	067021	254 04 0 00 067022 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50183	067022	254 00 0 00 067023 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50184						TGET^
 50185	067023	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50186	067024	302 00 0 00 067010 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50187						STOP2^^
 50188	067025	254 04 0 00 067026 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50189	067026	254 00 0 00 067027 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50190					^
 50191			000004			X=X_1
 50192
 50193
 50194						XUUOA	X^
 50195
 50196					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50197
 50198			000004			EFIELD==X		;"E" WE ARE TESTING FOR
 50199						TSET^
 50200			067027			%X=.			;DEFINE %X TO SAVE
 50201	067027	201 00 0 00 067027 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50202	067030	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50203	067031	200 00 0 00 071273 	..0231:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50204	067032	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50205	067033	001000	000004			1B8!X			;EXECUTE A UUO
 50206	067034	254 04 0 00 067035 	..0232:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50207	067035	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50208	067036	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50209	067037	302 00 0 00 000004 		CAIE	X		;MA BITS CORRECT?
 50210	067040				..0233:	STOP1^
 50211	067040	254 04 0 00 067041 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50212	067041	254 00 0 00 067042 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50213						TGET^
 50214	067042	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50215	067043	302 00 0 00 067027 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50216						STOP2^^
 50217	067044	254 04 0 00 067045 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50218	067045	254 00 0 00 067046 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50219					^
 50220			000010			X=X_1
 50221
 50222
 50223						XUUOA	X^
 50224
 50225					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50226
 50227			000010			EFIELD==X		;"E" WE ARE TESTING FOR
 50228						TSET^
 50229			067046			%X=.			;DEFINE %X TO SAVE
 50230	067046	201 00 0 00 067046 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50231	067047	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50232	067050	200 00 0 00 071274 	..0234:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-2
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50233	067051	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50234	067052	001000	000010			1B8!X			;EXECUTE A UUO
 50235	067053	254 04 0 00 067054 	..0235:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50236	067054	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50237	067055	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50238	067056	302 00 0 00 000010 		CAIE	X		;MA BITS CORRECT?
 50239	067057				..0236:	STOP1^
 50240	067057	254 04 0 00 067060 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50241	067060	254 00 0 00 067061 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50242						TGET^
 50243	067061	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50244	067062	302 00 0 00 067046 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50245						STOP2^^
 50246	067063	254 04 0 00 067064 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50247	067064	254 00 0 00 067065 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50248					^
 50249			000020			X=X_1
 50250
 50251
 50252						XUUOA	X^
 50253
 50254					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50255
 50256			000020			EFIELD==X		;"E" WE ARE TESTING FOR
 50257						TSET^
 50258			067065			%X=.			;DEFINE %X TO SAVE
 50259	067065	201 00 0 00 067065 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50260	067066	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50261	067067	200 00 0 00 071275 	..0237:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50262	067070	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50263	067071	001000	000020			1B8!X			;EXECUTE A UUO
 50264	067072	254 04 0 00 067073 	..0240:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50265	067073	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50266	067074	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50267	067075	302 00 0 00 000020 		CAIE	X		;MA BITS CORRECT?
 50268	067076				..0241:	STOP1^
 50269	067076	254 04 0 00 067077 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50270	067077	254 00 0 00 067100 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50271						TGET^
 50272	067100	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50273	067101	302 00 0 00 067065 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50274						STOP2^^
 50275	067102	254 04 0 00 067103 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50276	067103	254 00 0 00 067104 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50277					^
 50278			000040			X=X_1
 50279
 50280
 50281						XUUOA	X^
 50282
 50283					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50284
 50285			000040			EFIELD==X		;"E" WE ARE TESTING FOR
 50286						TSET^
 50287			067104			%X=.			;DEFINE %X TO SAVE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-3
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50288	067104	201 00 0 00 067104 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50289	067105	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50290	067106	200 00 0 00 071276 	..0242:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50291	067107	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50292	067110	001000	000040			1B8!X			;EXECUTE A UUO
 50293	067111	254 04 0 00 067112 	..0243:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50294	067112	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50295	067113	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50296	067114	302 00 0 00 000040 		CAIE	X		;MA BITS CORRECT?
 50297	067115				..0244:	STOP1^
 50298	067115	254 04 0 00 067116 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50299	067116	254 00 0 00 067117 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50300						TGET^
 50301	067117	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50302	067120	302 00 0 00 067104 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50303						STOP2^^
 50304	067121	254 04 0 00 067122 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50305	067122	254 00 0 00 067123 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50306					^
 50307			000100			X=X_1
 50308
 50309
 50310						XUUOA	X^
 50311
 50312					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50313
 50314			000100			EFIELD==X		;"E" WE ARE TESTING FOR
 50315						TSET^
 50316			067123			%X=.			;DEFINE %X TO SAVE
 50317	067123	201 00 0 00 067123 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50318	067124	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50319	067125	200 00 0 00 071277 	..0245:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50320	067126	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50321	067127	001000	000100			1B8!X			;EXECUTE A UUO
 50322	067130	254 04 0 00 067131 	..0246:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50323	067131	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50324	067132	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50325	067133	302 00 0 00 000100 		CAIE	X		;MA BITS CORRECT?
 50326	067134				..0247:	STOP1^
 50327	067134	254 04 0 00 067135 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50328	067135	254 00 0 00 067136 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50329						TGET^
 50330	067136	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50331	067137	302 00 0 00 067123 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50332						STOP2^^
 50333	067140	254 04 0 00 067141 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50334	067141	254 00 0 00 067142 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50335					^
 50336			000200			X=X_1
 50337
 50338
 50339						XUUOA	X^
 50340
 50341					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50342
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-4
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50343			000200			EFIELD==X		;"E" WE ARE TESTING FOR
 50344						TSET^
 50345			067142			%X=.			;DEFINE %X TO SAVE
 50346	067142	201 00 0 00 067142 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50347	067143	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50348	067144	200 00 0 00 071300 	..0250:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50349	067145	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50350	067146	001000	000200			1B8!X			;EXECUTE A UUO
 50351	067147	254 04 0 00 067150 	..0251:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50352	067150	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50353	067151	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50354	067152	302 00 0 00 000200 		CAIE	X		;MA BITS CORRECT?
 50355	067153				..0252:	STOP1^
 50356	067153	254 04 0 00 067154 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50357	067154	254 00 0 00 067155 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50358						TGET^
 50359	067155	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50360	067156	302 00 0 00 067142 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50361						STOP2^^
 50362	067157	254 04 0 00 067160 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50363	067160	254 00 0 00 067161 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50364					^
 50365			000400			X=X_1
 50366
 50367
 50368						XUUOA	X^
 50369
 50370					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50371
 50372			000400			EFIELD==X		;"E" WE ARE TESTING FOR
 50373						TSET^
 50374			067161			%X=.			;DEFINE %X TO SAVE
 50375	067161	201 00 0 00 067161 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50376	067162	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50377	067163	200 00 0 00 071301 	..0253:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50378	067164	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50379	067165	001000	000400			1B8!X			;EXECUTE A UUO
 50380	067166	254 04 0 00 067167 	..0254:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50381	067167	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50382	067170	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50383	067171	302 00 0 00 000400 		CAIE	X		;MA BITS CORRECT?
 50384	067172				..0255:	STOP1^
 50385	067172	254 04 0 00 067173 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50386	067173	254 00 0 00 067174 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50387						TGET^
 50388	067174	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50389	067175	302 00 0 00 067161 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50390						STOP2^^
 50391	067176	254 04 0 00 067177 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50392	067177	254 00 0 00 067200 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50393					^
 50394			001000			X=X_1
 50395
 50396
 50397						XUUOA	X^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-5
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50398
 50399					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50400
 50401			001000			EFIELD==X		;"E" WE ARE TESTING FOR
 50402						TSET^
 50403			067200			%X=.			;DEFINE %X TO SAVE
 50404	067200	201 00 0 00 067200 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50405	067201	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50406	067202	200 00 0 00 071302 	..0256:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50407	067203	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50408	067204	001000	001000			1B8!X			;EXECUTE A UUO
 50409	067205	254 04 0 00 067206 	..0257:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50410	067206	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50411	067207	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50412	067210	302 00 0 00 001000 		CAIE	X		;MA BITS CORRECT?
 50413	067211				..0260:	STOP1^
 50414	067211	254 04 0 00 067212 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50415	067212	254 00 0 00 067213 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50416						TGET^
 50417	067213	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50418	067214	302 00 0 00 067200 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50419						STOP2^^
 50420	067215	254 04 0 00 067216 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50421	067216	254 00 0 00 067217 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50422					^
 50423			002000			X=X_1
 50424
 50425
 50426						XUUOA	X^
 50427
 50428					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50429
 50430			002000			EFIELD==X		;"E" WE ARE TESTING FOR
 50431						TSET^
 50432			067217			%X=.			;DEFINE %X TO SAVE
 50433	067217	201 00 0 00 067217 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50434	067220	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50435	067221	200 00 0 00 071303 	..0261:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50436	067222	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50437	067223	001000	002000			1B8!X			;EXECUTE A UUO
 50438	067224	254 04 0 00 067225 	..0262:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50439	067225	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50440	067226	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50441	067227	302 00 0 00 002000 		CAIE	X		;MA BITS CORRECT?
 50442	067230				..0263:	STOP1^
 50443	067230	254 04 0 00 067231 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50444	067231	254 00 0 00 067232 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50445						TGET^
 50446	067232	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50447	067233	302 00 0 00 067217 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50448						STOP2^^
 50449	067234	254 04 0 00 067235 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50450	067235	254 00 0 00 067236 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50451					^
 50452			004000			X=X_1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-6
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50453
 50454
 50455						XUUOA	X^
 50456
 50457					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50458
 50459			004000			EFIELD==X		;"E" WE ARE TESTING FOR
 50460						TSET^
 50461			067236			%X=.			;DEFINE %X TO SAVE
 50462	067236	201 00 0 00 067236 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50463	067237	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50464	067240	200 00 0 00 071304 	..0264:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50465	067241	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50466	067242	001000	004000			1B8!X			;EXECUTE A UUO
 50467	067243	254 04 0 00 067244 	..0265:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50468	067244	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50469	067245	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50470	067246	302 00 0 00 004000 		CAIE	X		;MA BITS CORRECT?
 50471	067247				..0266:	STOP1^
 50472	067247	254 04 0 00 067250 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50473	067250	254 00 0 00 067251 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50474						TGET^
 50475	067251	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50476	067252	302 00 0 00 067236 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50477						STOP2^^
 50478	067253	254 04 0 00 067254 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50479	067254	254 00 0 00 067255 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50480					^
 50481			010000			X=X_1
 50482
 50483
 50484						XUUOA	X^
 50485
 50486					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50487
 50488			010000			EFIELD==X		;"E" WE ARE TESTING FOR
 50489						TSET^
 50490			067255			%X=.			;DEFINE %X TO SAVE
 50491	067255	201 00 0 00 067255 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50492	067256	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50493	067257	200 00 0 00 071305 	..0267:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50494	067260	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50495	067261	001000	010000			1B8!X			;EXECUTE A UUO
 50496	067262	254 04 0 00 067263 	..0270:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50497	067263	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50498	067264	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50499	067265	302 00 0 00 010000 		CAIE	X		;MA BITS CORRECT?
 50500	067266				..0271:	STOP1^
 50501	067266	254 04 0 00 067267 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50502	067267	254 00 0 00 067270 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50503						TGET^
 50504	067270	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50505	067271	302 00 0 00 067255 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50506						STOP2^^
 50507	067272	254 04 0 00 067273 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-7
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50508	067273	254 00 0 00 067274 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50509					^
 50510			020000			X=X_1
 50511
 50512
 50513						XUUOA	X^
 50514
 50515					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50516
 50517			020000			EFIELD==X		;"E" WE ARE TESTING FOR
 50518						TSET^
 50519			067274			%X=.			;DEFINE %X TO SAVE
 50520	067274	201 00 0 00 067274 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50521	067275	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50522	067276	200 00 0 00 071306 	..0272:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50523	067277	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50524	067300	001000	020000			1B8!X			;EXECUTE A UUO
 50525	067301	254 04 0 00 067302 	..0273:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50526	067302	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50527	067303	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50528	067304	302 00 0 00 020000 		CAIE	X		;MA BITS CORRECT?
 50529	067305				..0274:	STOP1^
 50530	067305	254 04 0 00 067306 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50531	067306	254 00 0 00 067307 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50532						TGET^
 50533	067307	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50534	067310	302 00 0 00 067274 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50535						STOP2^^
 50536	067311	254 04 0 00 067312 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50537	067312	254 00 0 00 067313 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50538					^
 50539			040000			X=X_1
 50540
 50541
 50542						XUUOA	X^
 50543
 50544					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50545
 50546			040000			EFIELD==X		;"E" WE ARE TESTING FOR
 50547						TSET^
 50548			067313			%X=.			;DEFINE %X TO SAVE
 50549	067313	201 00 0 00 067313 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50550	067314	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50551	067315	200 00 0 00 071307 	..0275:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50552	067316	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50553	067317	001000	040000			1B8!X			;EXECUTE A UUO
 50554	067320	254 04 0 00 067321 	..0276:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50555	067321	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50556	067322	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50557	067323	302 00 0 00 040000 		CAIE	X		;MA BITS CORRECT?
 50558	067324				..0277:	STOP1^
 50559	067324	254 04 0 00 067325 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50560	067325	254 00 0 00 067326 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50561						TGET^
 50562	067326	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-8
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50563	067327	302 00 0 00 067313 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50564						STOP2^^
 50565	067330	254 04 0 00 067331 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50566	067331	254 00 0 00 067332 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50567					^
 50568			100000			X=X_1
 50569
 50570
 50571						XUUOA	X^
 50572
 50573					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50574
 50575			100000			EFIELD==X		;"E" WE ARE TESTING FOR
 50576						TSET^
 50577			067332			%X=.			;DEFINE %X TO SAVE
 50578	067332	201 00 0 00 067332 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50579	067333	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50580	067334	200 00 0 00 071310 	..0300:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50581	067335	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50582	067336	001000	100000			1B8!X			;EXECUTE A UUO
 50583	067337	254 04 0 00 067340 	..0301:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50584	067340	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50585	067341	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50586	067342	302 00 0 00 100000 		CAIE	X		;MA BITS CORRECT?
 50587	067343				..0302:	STOP1^
 50588	067343	254 04 0 00 067344 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50589	067344	254 00 0 00 067345 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50590						TGET^
 50591	067345	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50592	067346	302 00 0 00 067332 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50593						STOP2^^
 50594	067347	254 04 0 00 067350 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50595	067350	254 00 0 00 067351 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50596					^
 50597			200000			X=X_1
 50598
 50599
 50600						XUUOA	X^
 50601
 50602					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50603
 50604			200000			EFIELD==X		;"E" WE ARE TESTING FOR
 50605						TSET^
 50606			067351			%X=.			;DEFINE %X TO SAVE
 50607	067351	201 00 0 00 067351 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50608	067352	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50609	067353	200 00 0 00 071311 	..0303:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50610	067354	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50611	067355	001000	200000			1B8!X			;EXECUTE A UUO
 50612	067356	254 04 0 00 067357 	..0304:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50613	067357	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50614	067360	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50615	067361	302 00 0 00 200000 		CAIE	X		;MA BITS CORRECT?
 50616	067362				..0305:	STOP1^
 50617	067362	254 04 0 00 067363 		HALT	.+1		;UUO FAILED TO STORE MA BITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-9
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50618	067363	254 00 0 00 067364 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50619						TGET^
 50620	067364	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50621	067365	302 00 0 00 067351 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50622						STOP2^^
 50623	067366	254 04 0 00 067367 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50624	067367	254 00 0 00 067370 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50625					^
 50626			400000			X=X_1
 50627
 50628
 50629						XUUOA	X^
 50630
 50631					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50632
 50633			400000			EFIELD==X		;"E" WE ARE TESTING FOR
 50634						TSET^
 50635			067370			%X=.			;DEFINE %X TO SAVE
 50636	067370	201 00 0 00 067370 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50637	067371	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50638	067372	200 00 0 00 071312 	..0306:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50639	067373	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50640	067374	001000	400000			1B8!X			;EXECUTE A UUO
 50641	067375	254 04 0 00 067376 	..0307:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50642	067376	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50643	067377	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50644	067400	302 00 0 00 400000 		CAIE	X		;MA BITS CORRECT?
 50645	067401				..0310:	STOP1^
 50646	067401	254 04 0 00 067402 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50647	067402	254 00 0 00 067403 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50648						TGET^
 50649	067403	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50650	067404	302 00 0 00 067370 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50651						STOP2^^
 50652	067405	254 04 0 00 067406 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50653	067406	254 00 0 00 067407 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50654					^
 50655		000001	000000			X=X_1
 50656
 50657			777777			X=777777
 50658						XUUOA	X^
 50659
 50660					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50661
 50662			777777			EFIELD==X		;"E" WE ARE TESTING FOR
 50663						TSET^
 50664			067407			%X=.			;DEFINE %X TO SAVE
 50665	067407	201 00 0 00 067407 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50666	067410	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50667	067411	200 00 0 00 071313 	..0311:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50668	067412	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50669	067413	001000	777777			1B8!X			;EXECUTE A UUO
 50670	067414	254 04 0 00 067415 	..0312:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50671	067415	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50672	067416	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-10
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50673	067417	302 00 0 00 777777 		CAIE	X		;MA BITS CORRECT?
 50674	067420				..0313:	STOP1^
 50675	067420	254 04 0 00 067421 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50676	067421	254 00 0 00 067422 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50677						TGET^
 50678	067422	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50679	067423	302 00 0 00 067407 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50680						STOP2^^
 50681	067424	254 04 0 00 067425 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50682	067425	254 00 0 00 067426 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50683					^
 50684
 50685			000000			X=0
 50686						XUUOA	X^
 50687
 50688					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50689
 50690			000000			EFIELD==X		;"E" WE ARE TESTING FOR
 50691						TSET^
 50692			067426			%X=.			;DEFINE %X TO SAVE
 50693	067426	201 00 0 00 067426 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50694	067427	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50695	067430	200 00 0 00 071314 	..0314:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50696	067431	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50697	067432	001000	000000			1B8!X			;EXECUTE A UUO
 50698	067433	254 04 0 00 067434 	..0315:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50699	067434	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50700	067435	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50701	067436	302 00 0 00 000000 		CAIE	X		;MA BITS CORRECT?
 50702	067437				..0316:	STOP1^
 50703	067437	254 04 0 00 067440 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50704	067440	254 00 0 00 067441 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50705						TGET^
 50706	067441	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50707	067442	302 00 0 00 067426 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50708						STOP2^^
 50709	067443	254 04 0 00 067444 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50710	067444	254 00 0 00 067445 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50711					^
 50712
 50713			252525			X=252525
 50714						XUUOA	X^
 50715
 50716					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50717
 50718			252525			EFIELD==X		;"E" WE ARE TESTING FOR
 50719						TSET^
 50720			067445			%X=.			;DEFINE %X TO SAVE
 50721	067445	201 00 0 00 067445 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50722	067446	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50723	067447	200 00 0 00 071315 	..0317:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50724	067450	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50725	067451	001000	252525			1B8!X			;EXECUTE A UUO
 50726	067452	254 04 0 00 067453 	..0320:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50727	067453	200 00 0 00 000040 		MOVE	0,40		;GET UUO
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 76-11
DFKAA8	MAC	13-Jan-89 10:22		TEST UUO STORING CORRECTLY

 50728	067454	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50729	067455	302 00 0 00 252525 		CAIE	X		;MA BITS CORRECT?
 50730	067456				..0321:	STOP1^
 50731	067456	254 04 0 00 067457 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50732	067457	254 00 0 00 067460 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50733						TGET^
 50734	067460	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50735	067461	302 00 0 00 067445 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50736						STOP2^^
 50737	067462	254 04 0 00 067463 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50738	067463	254 00 0 00 067464 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50739					^
 50740
 50741			525252			X=525252
 50742						XUUOA	X^
 50743
 50744					;CHECK THE "E" OF THE UUO STORED IS CORRECT.
 50745
 50746			525252			EFIELD==X		;"E" WE ARE TESTING FOR
 50747						TSET^
 50748			067464			%X=.			;DEFINE %X TO SAVE
 50749	067464	201 00 0 00 067464 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50750	067465	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50751	067466	200 00 0 00 071316 	..0322:	MOVE	[JRST	.+4]	;SET A TRAP INSTRUCTION
 50752	067467	202 00 0 00 000041 		MOVEM	41		;INTO 41
 50753	067470	001000	525252			1B8!X			;EXECUTE A UUO
 50754	067471	254 04 0 00 067472 	..0323:	HALT	.+1		;UUO DIDN'T TRAP TO 40
 50755	067472	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50756	067473	405 00 0 00 777777 		ANDI	0,-1		;MASK OUT UUO FOR MA BITS
 50757	067474	302 00 0 00 525252 		CAIE	X		;MA BITS CORRECT?
 50758	067475				..0324:	STOP1^
 50759	067475	254 04 0 00 067476 		HALT	.+1		;UUO FAILED TO STORE MA BITS
 50760	067476	254 00 0 00 067477 		JRST	.+1		;INTO RIGHT HALF OF 40^
 50761						TGET^
 50762	067477	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50763	067500	302 00 0 00 067464 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50764						STOP2^^
 50765	067501	254 04 0 00 067502 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50766	067502	254 00 0 00 067503 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50767					^
 50768			000000			X=0
 50769	067503	255 00 0 00 000000 		JFCL
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 77
DFKAA8	MAC	13-Jan-89 10:22		TEST CLEARING OF INDEX AND INDIRECT BITS ON UUO

 50770					SUBTTL	TEST CLEARING OF INDEX AND INDIRECT BITS ON UUO
 50771
 50772					;TEST THAT THE INDEX BITS ARE CLEARED WHEN EXECUTING A UUO
 50773
 50774	067504				UUOIND:	CLRBTH^
 50775	067504	700 04 0 00 267760 		CLRAPR
 50776	067505	700 14 0 00 031577 		CLRPI^
 50777	067506	400 17 0 00 000000 		SETZ	17,		;CLEAR INDEX FIELD
 50778	067507	200 00 0 00 071317 		MOVE	[JRST .+4]	;SET UP UUO TRAP INSTR.
 50779	067510	202 00 0 00 000041 		MOVEM	41		;INTO TRAP LOCATION
 50780	067511	001017	000000			1B8!(17)		;EXECUTE A UUO WITH INDEXING
 50781	067512	254 04 0 00 067513 		HALT	.+1		;UUO DID NOT TRAP
 50782	067513	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50783	067514	603 00 0 00 000017 		TLNE	0,17		;INDEX FIELD CLEAR?
 50784						STOP^
 50785	067515	254 04 0 00 067516 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50786	067516	254 00 0 00 067517 		JRST	.+1		;WITH JRST BACK^
 50787
 50788					;TEST THAT THE INDIRECT BIT IS CLEARED WHEN EXECUTING A UUO
 50789
 50790	067517				UUOINX:	CLRBTH^
 50791	067517	700 04 0 00 267760 		CLRAPR
 50792	067520	700 14 0 00 031577 		CLRPI^
 50793	067521	403 17 0 00 000000 		SETZB	17,0		;CLEAR INDEX FIELD
 50794	067522	200 00 0 00 071320 		MOVE	[JRST .+4]	;SET UUO TRAP INSTR.
 50795	067523	202 00 0 00 000041 		MOVEM	41		;INTO TRAP LOCATION
 50796	067524	001020	000017			1B8!@17			;EXECUTE A UUO WITH INDIRECTING
 50797	067525	254 04 0 00 067526 		HALT	.+1		;UUO DID NOT TRAP
 50798	067526	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50799	067527	603 00 0 00 000020 		TLNE	0,20		;INDIRECT BIT CLEAR?
 50800						STOP^
 50801	067530	254 04 0 00 067531 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50802	067531	254 00 0 00 067532 		JRST	.+1		;WITH JRST BACK^
 50803
 50804					;TEST THAT BOTH INDEX AND INDIRECT BITS CLEAR WHEN EXECUTING A UUO
 50805
 50806	067532				UUOBTH:	CLRBTH^
 50807	067532	700 04 0 00 267760 		CLRAPR
 50808	067533	700 14 0 00 031577 		CLRPI^
 50809	067534	403 17 0 00 000000 		SETZB	17,0		;CLEAR INDEX FIELD
 50810	067535	200 00 0 00 071321 		MOVE	[JRST .+4]	;SET UP TRAP INSTR.
 50811	067536	202 00 0 00 000041 		MOVEM	41		;INTO TRAP LOCATION
 50812	067537	001037	000017			1B8!@17(17)		;EXECUTE WITH INDIRECT AND INDEX
 50813	067540	254 04 0 00 067541 		HALT	.+1		;UUO DID NOT TRAP
 50814	067541	200 00 0 00 000040 		MOVE	0,40		;GET UUO
 50815	067542	603 00 0 00 000037 		TLNE	0,37		;INDIRECT OR INDEX BITS STILL SET?
 50816						STOP^
 50817	067543	254 04 0 00 067544 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50818	067544	254 00 0 00 067545 		JRST	.+1		;WITH JRST BACK^
 50819
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78
DFKAA8	MAC	13-Jan-89 10:22		TEST UUOS OUT OF FAST MEMORY

 50820					SUBTTL	TEST UUOS OUT OF FAST MEMORY
 50821
 50822						FMUUO	0^
 50823
 50824					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50825					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50826					;CORRECT PC.
 50827
 50828			000000			AC=0			;TESTED AC
 50829
 50830						TSET^
 50831			067545			%X=.			;DEFINE %X TO SAVE
 50832	067545	201 00 0 00 067545 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50833	067546	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50834	067547	200 00 0 00 070317 		MOVE	0,[XWD 1000,0]	;SET UP UUO INTO AC 0 TO EXECUTE
 50835	067550	200 13 0 00 071322 		MOVE	13,[JSP 11,..0325] ;SET UP UUO TRAP INSTRUCTION
 50836	067551	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50837	067552	200 01 0 00 071323 		MOVE	0+1,[JRST ..0326] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50838	067553	254 00 0 00 000000 		JRST	0		;GO EXECUTE  UUO
 50839	067554	254 04 0 00 067555 	..0326:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50840	067555	254 00 0 00 067556 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50841	067556	405 11 0 00 777777 	..0325:	ANDI	11,-1		;MASK FLAGS
 50842	067557	302 11 0 00 000001 		CAIE	11,0+1		;PC STORED SHOULD = 0 +1
 50843						STOP^
 50844	067560	254 04 0 00 067561 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50845	067561	254 00 0 00 067562 		JRST	.+1		;WITH JRST BACK^
 50846						TGET^
 50847	067562	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50848	067563	302 00 0 00 067545 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50849						STOP2^^
 50850	067564	254 04 0 00 067565 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50851	067565	254 00 0 00 067566 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50852					^
 50853
 50854						FMUUO	1^
 50855
 50856					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50857					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50858					;CORRECT PC.
 50859
 50860			000001			AC=1			;TESTED AC
 50861
 50862						TSET^
 50863			067566			%X=.			;DEFINE %X TO SAVE
 50864	067566	201 00 0 00 067566 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50865	067567	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50866	067570	200 01 0 00 070317 		MOVE	1,[XWD 1000,0]	;SET UP UUO INTO AC 1 TO EXECUTE
 50867	067571	200 13 0 00 071324 		MOVE	13,[JSP 11,..0327] ;SET UP UUO TRAP INSTRUCTION
 50868	067572	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50869	067573	200 02 0 00 071325 		MOVE	1+1,[JRST ..0330] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50870	067574	254 00 0 00 000001 		JRST	1		;GO EXECUTE  UUO
 50871	067575	254 04 0 00 067576 	..0330:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50872	067576	254 00 0 00 067577 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50873	067577	405 11 0 00 777777 	..0327:	ANDI	11,-1		;MASK FLAGS
 50874	067600	302 11 0 00 000002 		CAIE	11,1+1		;PC STORED SHOULD = 1 +1
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78-1
DFKAA8	MAC	13-Jan-89 10:22		TEST UUOS OUT OF FAST MEMORY

 50875						STOP^
 50876	067601	254 04 0 00 067602 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50877	067602	254 00 0 00 067603 		JRST	.+1		;WITH JRST BACK^
 50878						TGET^
 50879	067603	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50880	067604	302 00 0 00 067566 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50881						STOP2^^
 50882	067605	254 04 0 00 067606 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50883	067606	254 00 0 00 067607 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50884					^
 50885
 50886						FMUUO	2^
 50887
 50888					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50889					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50890					;CORRECT PC.
 50891
 50892			000002			AC=2			;TESTED AC
 50893
 50894						TSET^
 50895			067607			%X=.			;DEFINE %X TO SAVE
 50896	067607	201 00 0 00 067607 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50897	067610	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50898	067611	200 02 0 00 070317 		MOVE	2,[XWD 1000,0]	;SET UP UUO INTO AC 2 TO EXECUTE
 50899	067612	200 13 0 00 071326 		MOVE	13,[JSP 11,..0331] ;SET UP UUO TRAP INSTRUCTION
 50900	067613	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50901	067614	200 03 0 00 071327 		MOVE	2+1,[JRST ..0332] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50902	067615	254 00 0 00 000002 		JRST	2		;GO EXECUTE  UUO
 50903	067616	254 04 0 00 067617 	..0332:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50904	067617	254 00 0 00 067620 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50905	067620	405 11 0 00 777777 	..0331:	ANDI	11,-1		;MASK FLAGS
 50906	067621	302 11 0 00 000003 		CAIE	11,2+1		;PC STORED SHOULD = 2 +1
 50907						STOP^
 50908	067622	254 04 0 00 067623 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50909	067623	254 00 0 00 067624 		JRST	.+1		;WITH JRST BACK^
 50910						TGET^
 50911	067624	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50912	067625	302 00 0 00 067607 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50913						STOP2^^
 50914	067626	254 04 0 00 067627 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50915	067627	254 00 0 00 067630 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50916					^
 50917
 50918						FMUUO	4^
 50919
 50920					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50921					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50922					;CORRECT PC.
 50923
 50924			000004			AC=4			;TESTED AC
 50925
 50926						TSET^
 50927			067630			%X=.			;DEFINE %X TO SAVE
 50928	067630	201 00 0 00 067630 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50929	067631	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78-2
DFKAA8	MAC	13-Jan-89 10:22		TEST UUOS OUT OF FAST MEMORY

 50930	067632	200 04 0 00 070317 		MOVE	4,[XWD 1000,0]	;SET UP UUO INTO AC 4 TO EXECUTE
 50931	067633	200 13 0 00 071330 		MOVE	13,[JSP 11,..0333] ;SET UP UUO TRAP INSTRUCTION
 50932	067634	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50933	067635	200 05 0 00 071331 		MOVE	4+1,[JRST ..0334] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50934	067636	254 00 0 00 000004 		JRST	4		;GO EXECUTE  UUO
 50935	067637	254 04 0 00 067640 	..0334:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50936	067640	254 00 0 00 067641 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50937	067641	405 11 0 00 777777 	..0333:	ANDI	11,-1		;MASK FLAGS
 50938	067642	302 11 0 00 000005 		CAIE	11,4+1		;PC STORED SHOULD = 4 +1
 50939						STOP^
 50940	067643	254 04 0 00 067644 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50941	067644	254 00 0 00 067645 		JRST	.+1		;WITH JRST BACK^
 50942						TGET^
 50943	067645	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50944	067646	302 00 0 00 067630 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50945						STOP2^^
 50946	067647	254 04 0 00 067650 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50947	067650	254 00 0 00 067651 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50948					^
 50949
 50950						FMUUO	5^
 50951
 50952					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 50953					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50954					;CORRECT PC.
 50955
 50956			000005			AC=5			;TESTED AC
 50957
 50958						TSET^
 50959			067651			%X=.			;DEFINE %X TO SAVE
 50960	067651	201 00 0 00 067651 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50961	067652	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50962	067653	200 05 0 00 070317 		MOVE	5,[XWD 1000,0]	;SET UP UUO INTO AC 5 TO EXECUTE
 50963	067654	200 13 0 00 071332 		MOVE	13,[JSP 11,..0335] ;SET UP UUO TRAP INSTRUCTION
 50964	067655	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50965	067656	200 06 0 00 071333 		MOVE	5+1,[JRST ..0336] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50966	067657	254 00 0 00 000005 		JRST	5		;GO EXECUTE  UUO
 50967	067660	254 04 0 00 067661 	..0336:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 50968	067661	254 00 0 00 067662 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 50969	067662	405 11 0 00 777777 	..0335:	ANDI	11,-1		;MASK FLAGS
 50970	067663	302 11 0 00 000006 		CAIE	11,5+1		;PC STORED SHOULD = 5 +1
 50971						STOP^
 50972	067664	254 04 0 00 067665 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 50973	067665	254 00 0 00 067666 		JRST	.+1		;WITH JRST BACK^
 50974						TGET^
 50975	067666	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 50976	067667	302 00 0 00 067651 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 50977						STOP2^^
 50978	067670	254 04 0 00 067671 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 50979	067671	254 00 0 00 067672 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 50980					^
 50981
 50982						FMUUO	10^
 50983
 50984					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78-3
DFKAA8	MAC	13-Jan-89 10:22		TEST UUOS OUT OF FAST MEMORY

 50985					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 50986					;CORRECT PC.
 50987
 50988			000010			AC=10			;TESTED AC
 50989
 50990						TSET^
 50991			067672			%X=.			;DEFINE %X TO SAVE
 50992	067672	201 00 0 00 067672 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 50993	067673	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 50994	067674	200 10 0 00 070317 		MOVE	10,[XWD 1000,0]	;SET UP UUO INTO AC 10 TO EXECUTE
 50995	067675	200 13 0 00 071334 		MOVE	13,[JSP 11,..0337] ;SET UP UUO TRAP INSTRUCTION
 50996	067676	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 50997	067677	200 11 0 00 071335 		MOVE	10+1,[JRST ..0340] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 50998	067700	254 00 0 00 000010 		JRST	10		;GO EXECUTE  UUO
 50999	067701	254 04 0 00 067702 	..0340:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 51000	067702	254 00 0 00 067703 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 51001	067703	405 11 0 00 777777 	..0337:	ANDI	11,-1		;MASK FLAGS
 51002	067704	302 11 0 00 000011 		CAIE	11,10+1		;PC STORED SHOULD = 10 +1
 51003						STOP^
 51004	067705	254 04 0 00 067706 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51005	067706	254 00 0 00 067707 		JRST	.+1		;WITH JRST BACK^
 51006						TGET^
 51007	067707	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51008	067710	302 00 0 00 067672 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51009						STOP2^^
 51010	067711	254 04 0 00 067712 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51011	067712	254 00 0 00 067713 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51012					^
 51013
 51014						FMUUO	12^
 51015
 51016					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 51017					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 51018					;CORRECT PC.
 51019
 51020			000012			AC=12			;TESTED AC
 51021
 51022						TSET^
 51023			067713			%X=.			;DEFINE %X TO SAVE
 51024	067713	201 00 0 00 067713 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51025	067714	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51026	067715	200 12 0 00 070317 		MOVE	12,[XWD 1000,0]	;SET UP UUO INTO AC 12 TO EXECUTE
 51027	067716	200 13 0 00 071336 		MOVE	13,[JSP 11,..0341] ;SET UP UUO TRAP INSTRUCTION
 51028	067717	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 51029	067720	200 13 0 00 071337 		MOVE	12+1,[JRST ..0342] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 51030	067721	254 00 0 00 000012 		JRST	12		;GO EXECUTE  UUO
 51031	067722	254 04 0 00 067723 	..0342:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 51032	067723	254 00 0 00 067724 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 51033	067724	405 11 0 00 777777 	..0341:	ANDI	11,-1		;MASK FLAGS
 51034	067725	302 11 0 00 000013 		CAIE	11,12+1		;PC STORED SHOULD = 12 +1
 51035						STOP^
 51036	067726	254 04 0 00 067727 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51037	067727	254 00 0 00 067730 		JRST	.+1		;WITH JRST BACK^
 51038						TGET^
 51039	067730	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 78-4
DFKAA8	MAC	13-Jan-89 10:22		TEST UUOS OUT OF FAST MEMORY

 51040	067731	302 00 0 00 067713 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51041						STOP2^^
 51042	067732	254 04 0 00 067733 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51043	067733	254 00 0 00 067734 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51044					^
 51045
 51046						FMUUO	17^
 51047
 51048					;EXECUTE UUO'S OUT OF FAST MEMORY LOCATIONS 0,1,2,4,5,10,12, AND 17
 51049					;CHECK FIRST THAT THE UUO TRAPPED AND SECONDLY THAT IT STORED THE
 51050					;CORRECT PC.
 51051
 51052			000017			AC=17			;TESTED AC
 51053
 51054						TSET^
 51055			067734			%X=.			;DEFINE %X TO SAVE
 51056	067734	201 00 0 00 067734 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51057	067735	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51058	067736	200 17 0 00 070317 		MOVE	17,[XWD 1000,0]	;SET UP UUO INTO AC 17 TO EXECUTE
 51059	067737	200 13 0 00 071340 		MOVE	13,[JSP 11,..0343] ;SET UP UUO TRAP INSTRUCTION
 51060	067740	202 13 0 00 000041 		MOVEM	13,41		;INTO LOCATION 41
 51061	067741	200 00 0 00 071341 		MOVE	17+1,[JRST ..0344] ;SET UP TRAP INSTRUCTION INCASE UUO DOES NOT TRAP
 51062	067742	254 00 0 00 000017 		JRST	17		;GO EXECUTE  UUO
 51063	067743	254 04 0 00 067744 	..0344:	HALT	.+1		;UUO DID NOT TRAP FROM FAST MEMORY
 51064	067744	254 00 0 00 067745 		JRST	.+1		;LOOP TO %FMUUO IF ERROR
 51065	067745	405 11 0 00 777777 	..0343:	ANDI	11,-1		;MASK FLAGS
 51066	067746	302 11 0 00 000020 		CAIE	11,17+1		;PC STORED SHOULD = 17 +1
 51067						STOP^
 51068	067747	254 04 0 00 067750 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51069	067750	254 00 0 00 067751 		JRST	.+1		;WITH JRST BACK^
 51070						TGET^
 51071	067751	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51072	067752	302 00 0 00 067734 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51073						STOP2^^
 51074	067753	254 04 0 00 067754 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51075	067754	254 00 0 00 067755 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51076					^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 79
DFKAA8	MAC	13-Jan-89 10:22		SIMPLE MUUO TEST

 51077					SUBTTL	SIMPLE MUUO TEST
 51078					;TEST MONITOR UUO "0" TO SEE IF IT TRAPS AT ALL
 51079					;TRAPPING TO 40 CAUSES IT TO HALT. TRAPPING TO SUPERVISOR KERNAL PUBLIC
 51080					;OR CONCEALED IS ALLOWED AND IS CONSIERED CORRECT.
 51081
 51082						TSET^
 51083			067755			%X=.			;DEFINE %X TO SAVE
 51084	067755	201 00 0 00 067755 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51085	067756	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51086	067757	265 00 0 00 067760 		JSP	.+1		;GET FLAGS
 51087	067760	603 00 0 00 010000 		TLNE	USERF		;IF USER MODE THEN EXIT
 51088	067761	254 00 0 00 070027 		JRST	USRIO0		;SKIP IF USER MODE TO USER IO TEST
 51089
 51090						CLRBTH^
 51091	067762	700 04 0 00 267760 		CLRAPR
 51092	067763	700 14 0 00 031577 		CLRPI^
 51093	067764	201 00 0 00 070007 	XMUUO:	MOVEI	XMUPC		;SET UP A TRAP FOR MONITOR UUO
 51094	067765	202 00 0 00 000430 		MOVEM	LKNTRP		;INTO ALL POSSIBLE TRAP LOCATIONS
 51095	067766	202 00 0 00 000431 		MOVEM	LKTRP
 51096	067767	202 00 0 00 000432 		MOVEM	LSNTRP
 51097	067770	202 00 0 00 000433 		MOVEM	LSTRP
 51098	067771	202 00 0 00 000434 		MOVEM	LCNTRP
 51099	067772	202 00 0 00 000435 		MOVEM	LCTRP
 51100	067773	202 00 0 00 000436 		MOVEM	LPNTRP
 51101	067774	202 00 0 00 000437 		MOVEM	LPTRP
 51102	067775	476 00 0 00 000424 		SETOM	LMUUO		;SET THE TRAP LOCATIONS
 51103	067776	476 00 0 00 000425 		SETOM	LMUUO+1		;TO ENABLE CHECKING
 51104	067777	200 00 0 00 071342 		MOVE	[JRST	MUHLT]	;SET UP A LUUO TRAP HALT
 51105	070000	202 00 0 00 000041 		MOVEM	41
 51106	070001	402 00 0 00 070002 		SETZM	.+1		;MAKE A MUUO IN THE NEXT LOCATION
 51107	070002	000000	000000		XMUUO0:	0			;THIS IS A MONITOR UUO
 51108	070003	254 04 0 00 070004 		HALT	.+1		;THE UUO DIDN'T TRAP
 51109	070004	254 04 0 00 070005 		HALT	.+1		;MUUO SKIPPED?
 51110	070005	254 04 0 00 070006 	MUHLT:	HALT	.+1		;UUO TRAPPED TO 40(DECODE AS LUUO?)
 51111	070006	254 04 0 00 070007 		HALT	.+1		;SPARE HALT
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 80
DFKAA8	MAC	13-Jan-89 10:22		SIMPLE MUUO TEST

 51112	070007				XMUPC:	TGET^
 51113	070007	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51114	070010	302 00 0 00 067755 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51115						STOP2^^
 51116	070011	254 04 0 00 070012 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51117	070012	254 00 0 00 070013 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51118	070013	332 00 0 00 000424 		SKIPE	LMUUO		;MON UUO "0" DIDN'T STORE A ZERO
 51119						STOP^
 51120	070014	254 04 0 00 070015 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51121	070015	254 00 0 00 070016 		JRST	.+1		;WITH JRST BACK^
 51122	070016	550 00 0 00 000425 		HRRZ	LMUUO+1		;GET THE STORED PC
 51123	070017	302 00 0 00 070003 		CAIE	XMUUO0+1	;DID WE STORE THE CORRECT PC?
 51124						STOP^
 51125	070020	254 04 0 00 070021 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51126	070021	254 00 0 00 070022 		JRST	.+1		;WITH JRST BACK^
 51127	070022	255 00 0 00 000000 		JFCL
 51128						TGET^
 51129	070023	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51130	070024	302 00 0 00 067755 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51131						STOP2^^
 51132	070025	254 04 0 00 070026 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51133	070026	254 00 0 00 070027 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 81
DFKAA8	MAC	13-Jan-89 10:22		TEST THE USER IOT BIT

 51134					SUBTTL	TEST THE USER IOT BIT
 51135					;CHECK CLEARING AND SETTING OF THE USER IOT BIT
 51136
 51137	070027				USRIO0:	TSET^
 51138			070027			%X=.			;DEFINE %X TO SAVE
 51139	070027	201 00 0 00 070027 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51140	070030	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51141						CLRBTH^
 51142	070031	700 04 0 00 267760 		CLRAPR
 51143	070032	700 14 0 00 031577 		CLRPI^
 51144	070033	336 00 0 00 030042 		SKIPN	MONFLG		;IN SPECIAL USER MODE?
 51145	070034	254 00 0 00 070070 		JRST	ENDIT		;YES LOOP TEST
 51146	070035	254 02 1 00 070036 		JRSTF	@.+1		;CLEAR BITS
 51147	070036	000000	070037			0,,.+1			;PC AND FLAGS
 51148	070037	265 00 0 00 070040 		JSP	.+1		;CHECK WHY USER I/O FLAG IS SET
 51149	070040	603 00 0 00 004000 		TLNE	EXIOT		;SHOULD BE CLEAR VIA JRSTF
 51150						STOP^
 51151	070041	254 04 0 00 070042 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51152	070042	254 00 0 00 070043 		JRST	.+1		;WITH JRST BACK^
 51153						TGET^
 51154	070043	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51155	070044	302 00 0 00 070027 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51156						STOP2^^
 51157	070045	254 04 0 00 070046 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51158	070046	254 00 0 00 070047 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51159	070047	336 00 0 00 030042 		SKIPN	MONFLG		;IN USER MODE?
 51160	070050	254 00 0 00 070070 		JRST	ENDIT		;YES CANNOT SET USER IO FLAG
 51161									;IN USER MODE
 51162
 51163	070051				USRIO1:	TSET^
 51164			070051			%X=.			;DEFINE %X TO SAVE
 51165	070051	201 00 0 00 070051 		MOVEI	%X		;SAVE THIS PC IN CASE OF WILD TRANSFER
 51166	070052	202 00 0 00 071350 		MOVEM	TNUMB#		;BECAUSE OF PC MOD OR INTERRUPT^
 51167						CLRBTH^
 51168	070053	700 04 0 00 267760 		CLRAPR
 51169	070054	700 14 0 00 031577 		CLRPI^
 51170	070055	400 00 0 00 000000 		SETZ	0		;CLEAR 0
 51171	070056	200 01 0 00 071343 		MOVE	1,[1B6!.+2]	;FLAGS AND PC
 51172	070057	254 02 0 01 000000 		JRSTF	(1)		;USER I/O FLAG DID
 51173	070060	265 00 0 00 070061 		JSP	.+1		;NOT SET
 51174	070061	607 00 0 00 004000 		TLNN	EXIOT		;CHECK WHY BIT IS NOT SET
 51175						STOP^
 51176	070062	254 04 0 00 070063 		HALT	.+1		;INSTRUCTION FAILED REPLACE
 51177	070063	254 00 0 00 070064 		JRST	.+1		;WITH JRST BACK^
 51178						TGET^
 51179	070064	200 00 0 00 071350 		MOVE	TNUMB		;GET LAST PC STORED AND CHECK TO SEE
 51180	070065	302 00 0 00 070051 		CAIE	%X		;IF ITS WHERE WE REALLY SHOULD BE
 51181						STOP2^^
 51182	070066	254 04 0 00 070067 		HALT	.+1		;HALT IF WE SHOULDN'T BE HERE
 51183	070067	254 00 0 00 070070 		JRST	.+1		;WILD TRANSFER CAUSED THIS HALT.^
 51184
 51185	070070	402 00 0 00 071350 	ENDIT:	SETZM	TNUMB		;CLEAR TEST NUMBER FLAG
 51186	070071	254 00 0 00 030057 		JRST	BEGEND		;GO TO BEG/END SEQUENCE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 82
DFKAA8	MAC	13-Jan-89 10:22		IOT/PI/APR SUBROUTINES

 51187					SUBTTL	IOT/PI/APR SUBROUTINES
 51188
 51189					;HERE ARE SOME USEFUL SUBROUTINES FOR THE DIAGNOSTIC
 51190
 51191					;THIS ROUTINE CLEARS ALL THE TRAP LOCATIONS(42-56)
 51192
 51193	070072	000000	000000		TRPCLR:	0			;FOR PC RETURN
 51194	070073	202 15 0 00 071353 		MOVEM	15,XAC15#	;SAVE AC15
 51195	070074	201 15 0 00 000042 		MOVEI	15,42
 51196	070075	402 00 1 00 000015 		SETZM	@15		;CLEAR LOCATION
 51197	070076	271 15 0 00 000001 		ADDI	15,1		;BUMP POINTER
 51198	070077	307 15 0 00 000056 		CAIG	15,56		;DONE LAST?
 51199	070100	254 00 0 00 070075 		JRST	.-3		;LOOP
 51200	070101	200 15 0 00 071353 		MOVE	15,XAC15	;RESTORE AC15
 51201	070102	254 00 1 00 070072 		JRST	@TRPCLR
 51202
 51203					;THIS ROUTINE PUTS A JSP TO A HALT INTO EACH TRAP LOCATION (42-57)
 51204
 51205	070103	000000	000000		HALTPI:	0			;FOR RETURN PC
 51206	070104	202 00 0 00 071351 		MOVEM	0,XAC0#		;SAVE AC0
 51207	070105	202 01 0 00 071352 		MOVEM	1,XAC1#		;SAVE AC1
 51208	070106	200 00 0 00 071344 		MOVE	[JSP 1,HLTCK]	;PUT JSP INTO EACH TRAP LOCATION
 51209	070107	201 01 0 00 000042 		MOVEI	1,42		;IN CASE INCORRECT INTERRUPT
 51210	070110	202 00 1 00 000001 		MOVEM	@1		;STORE
 51211	070111	271 00 0 00 000002 		ADDI	2
 51212	070112	271 01 0 00 000002 		ADDI	1,2
 51213	070113	305 01 0 00 000060 		CAIGE	1,60		;DONE?
 51214	070114	254 00 0 00 070110 		JRST	.-4
 51215	070115	200 00 0 00 071351 		MOVE	0,XAC0		;RESTORE AC0
 51216	070116	200 01 0 00 071352 		MOVE	1,XAC1		;AND AC1
 51217	070117	254 00 1 00 070103 		JRST	@HALTPI		;RETURN
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 83
DFKAA8	MAC	13-Jan-89 10:22		IOT/PI/APR SUBROUTINES

 51218					;THIS ROUTINE PUTS A JSP INTO EACH INTERRUPT LOCATION WHICH WILL
 51219					;IGNORE INTERRUPTS..
 51220
 51221	070120	000000	000000		TRAPPI:	0			;FOR JSR
 51222	070121	202 00 0 00 071351 		MOVEM	0,XAC0#		;SAVE AC0
 51223	070122	202 01 0 00 071352 		MOVEM	1,XAC1#		;SAVE AC1
 51224	070123	200 00 0 00 071345 		MOVE	[JSP 1,TRPFIL]	;SET UP TRAP INSTRUCTION
 51225	070124	201 01 0 00 000042 		MOVEI	1,42
 51226	070125	202 00 1 00 000001 		MOVEM	@1
 51227	070126	271 01 0 00 000002 		ADDI	1,2
 51228	070127	271 00 0 00 000002 		ADDI	0,2		;STORAGE POINTER
 51229	070130	305 01 0 00 000060 		CAIGE	1,60		;DONE?
 51230	070131	254 00 0 00 070125 		JRST	.-4		;NO LOOP
 51231	070132	200 00 0 00 071351 		MOVE	0,XAC0		;RESTORE AC0
 51232	070133	200 01 0 00 071352 		MOVE	1,XAC1		;AND AC1
 51233	070134	254 00 1 00 070120 		JRST	@TRAPPI		;RETURN
 51234
 51235					;THIS ROUTINE PLACES THE VALUE OF THE CHANNEL WHICH INTERRUPTED INTO
 51236					;AC0. IT DOES NOTHING ELSE (IT EFFECTIVLY IGNORES THE INTERRUPT).
 51237
 51238	070135	201 00 0 00 000001 	TRPFIL:	MOVEI	1		;POINTER
 51239	070136	254 00 0 00 070154 		JRST	TPEND
 51240	070137	201 00 0 00 000002 		MOVEI	2
 51241	070140	254 00 0 00 070154 		JRST	TPEND
 51242	070141	201 00 0 00 000003 		MOVEI	3
 51243	070142	254 00 0 00 070154 		JRST	TPEND
 51244	070143	201 00 0 00 000004 		MOVEI	4
 51245	070144	254 00 0 00 070154 		JRST	TPEND
 51246	070145	201 00 0 00 000005 		MOVEI	5
 51247	070146	254 00 0 00 070154 		JRST	TPEND
 51248	070147	201 00 0 00 000006 		MOVEI	6
 51249	070150	254 00 0 00 070154 		JRST	TPEND
 51250	070151	201 00 0 00 000007 		MOVEI	7
 51251	070152	254 00 0 00 070154 		JRST	TPEND
 51252	070153	254 04 0 00 070154 		HALT	TPEND		;"JRST @" OR "JRSTF @" FAILS
 51253
 51254	070154	332 00 0 00 030042 	TPEND:	SKIPE	MONFLG		;IN USER MODE?
 51255	070155	254 00 1 00 000001 		JRST	@1		;RETURN
 51256	070156	254 02 1 00 000001 		JRSTF	@1		;RESTORE FLAGS
 51257	070157	254 04 0 00 070157 		HALT	.		;JRST @ OR JRSTF FAILS ?
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 84
DFKAA8	MAC	13-Jan-89 10:22		IOT/PI/APR SUBROUTINES

 51258					;THIS ROUTINE PLACES THE VALUE OF THE CHANNEL WHICH INTERRUPTED
 51259					;INTO AC0. AFTER WHICH IT WILL HALT. THIS ROUTINE IS CALLED WHENEVER AN
 51260					;INTERRUPT OCCURS ON AN INCORRECT CHANNEL.
 51261	070160	201 00 0 00 000001 	HLTCK:	MOVEI	1
 51262	070161	254 04 1 00 000001 		HALT	@1
 51263	070162	201 00 0 00 000002 		MOVEI	2
 51264	070163	254 04 1 00 000001 		HALT	@1
 51265	070164	201 00 0 00 000003 		MOVEI	3
 51266	070165	254 04 1 00 000001 		HALT	@1
 51267	070166	201 00 0 00 000004 		MOVEI	4
 51268	070167	254 04 1 00 000001 		HALT	@1
 51269	070170	201 00 0 00 000005 		MOVEI	5
 51270	070171	254 04 1 00 000001 		HALT	@1
 51271	070172	201 00 0 00 000006 		MOVEI	6
 51272	070173	254 04 1 00 000001 		HALT	@1
 51273	070174	201 00 0 00 000007 		MOVEI	7
 51274	070175	254 04 1 00 000007 		HALT	@7
 51275	070176	474 00 0 00 000000 		SETO	0
 51276	070177	254 04 0 00 070177 		HALT	.		;SHOULD NEVER GET HERE
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 85
DFKAA8	MAC	13-Jan-89 10:22		IOT/PI/APR TRAP ROUTINES

 51277					SUBTTL	IOT/PI/APR TRAP ROUTINES
 51278
 51279					;HERE LIE THE VARIOUS TRAPS  TRAPS HERE REPRESENT ERRORS
 51280					;NOT CHECKED IN THE DIAGNOSTIC. THE LISTING SHOWS THE CAUSE OF THE
 51281					;TRAP.
 51282
 51283	070200	254 04 0 00 070200 	UUO:	HALT	.		;ERROR-UUO (LOC 0 HAS PC OF UUO)
 51284	070201	254 04 1 00 000425 	MACHTP:	HALT	@425		;KERNAL NO TRAP
 51285	070202	254 04 1 00 000425 		HALT	@425		;KERNAL TRAP
 51286	070203	254 04 1 00 000425 		HALT	@425		;SUPERVISOR NO TRAP
 51287	070204	254 04 1 00 000425 		HALT	@425		;SUPERVISOR TRAP
 51288	070205	254 04 1 00 000425 		HALT	@425		;CONCEAL NO TRAP
 51289	070206	254 04 1 00 000425 		HALT	@425		;CONCEAL TRAP
 51290	070207	254 04 1 00 000425 		HALT	@425		;PUBLIC NO TRAP
 51291	070210	254 04 1 00 000425 		HALT	@425		;PUBLIC TRAP
 51292
 51293	070211	254 04 0 00 070211 	TABLE:	HALT	.		;PAGE FAILURE TRAP
 51294	070212	255 00 0 00 000000 		JFCL			;IGNORE ARITHMETIC TRAPS
 51295	070213	254 04 0 00 070213 		HALT	.
 51296	070214	254 04 0 00 070214 		HALT	.
 51297	070215	777777	777777			-1			;IF UUO THEN NOT =O-1
 51298	070216	777777	777777			-1
 51299	070217	000000	000000			0
 51300	070220	000000	000000			0
 51301	070221	000000	070201			MACHTP
 51302	070222	000000	070202			MACHTP+1
 51303	070223	000000	070203			MACHTP+2
 51304	070224	000000	070204			MACHTP+3
 51305	070225	000000	070205			MACHTP+4
 51306	070226	000000	070206			MACHTP+5
 51307	070227	000000	070207			MACHTP+6
 51308	070230	000000	070210			MACHTP+7
 51309
 51310	070231	000000	000000		TRPSET:	0			;FOR JSR
 51311	070232	202 00 0 00 071351 		MOVEM	0,XAC0#		;SAVE AC0
 51312	070233	202 01 0 00 071352 		MOVEM	1,XAC1#		;SAVE AC1
 51313	070234	202 16 0 00 071354 		MOVEM	16,XAC16#	;SAVE AC16
 51314	070235	201 00 0 00 070211 		MOVEI	0,TABLE		;TRAP TABLE POINTER
 51315	070236	201 01 0 00 000420 		MOVEI	1,420		;STORAGE ADRESS
 51316	070237	200 16 1 00 000000 		MOVE	16,@0		;PUT TRAP WORD INTO
 51317	070240	202 16 0 01 000000 		MOVEM	16,(1)		;TRAP LOCATION
 51318	070241	271 00 0 00 000001 		ADDI	0,1		;BUMP
 51319	070242	271 01 0 00 000001 		ADDI	1,1		;POINTERS
 51320	070243	302 01 0 00 000440 		CAIE	1,440		;DONE LAST
 51321	070244	254 00 0 00 070237 		JRST	.-5		;NO KEEP LOOPING
 51322	070245	200 00 0 00 071351 		MOVE	0,XAC0		;RESTORE AC0
 51323	070246	200 01 0 00 071352 		MOVE	1,XAC1		;AND AC1
 51324	070247	200 16 0 00 071354 		MOVE	16,XAC16	;AND AC16
 51325	070250	254 00 1 00 070231 		JRST	@TRPSET		;RETURN TO CALLER
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51326					SUBTTL	*STOR* RESERVED STORAGE, JULY 19,1977
 51327
 51328					;PROGRAM LITERALS
 51329
 51330						XLIST
 51331					IFNDEF	$LPAPER,<LIST>
 51332	070251					LIT
 51333	070251	000001	000001
 51334	070252	254 00 0 00 030742 
 51335	070253	000000	000000
 51336	070254	777777	777777
 51337	070255	377777	777777
 51338	070256	400000	000000
 51339	070257	777000	000000
 51340	070260	000377	000000
 51341	070261	000000	177000
 51342	070262	000000	000777
 51343	070263	000000	600000
 51344	070264	000400	000000
 51345	070265	000000	000001
 51346	070266	000000	000002
 51347	070267	000000	000004
 51348	070270	000000	000010
 51349	070271	000000	000020
 51350	070272	000000	000040
 51351	070273	000000	000100
 51352	070274	000000	000200
 51353	070275	000000	000400
 51354	070276	000000	001000
 51355	070277	000000	002000
 51356	070300	000000	004000
 51357	070301	000000	010000
 51358	070302	000000	020000
 51359	070303	000000	040000
 51360	070304	000000	100000
 51361	070305	000000	200000
 51362	070306	000000	400000
 51363	070307	000001	000000
 51364	070310	000002	000000
 51365	070311	000004	000000
 51366	070312	000010	000000
 51367	070313	000020	000000
 51368	070314	000040	000000
 51369	070315	000100	000000
 51370	070316	000200	000000
 51371	070317	001000	000000
 51372	070320	002000	000000
 51373	070321	004000	000000
 51374	070322	010000	000000
 51375	070323	020000	000000
 51376	070324	040000	000000
 51377	070325	100000	000000
 51378	070326	200000	000000
 51379	070327	000000	001234
 51380	070330	000000	777777
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-1
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51381	070331	777777	000000
 51382	070332	707070	707070
 51383	070333	777777	777776
 51384	070334	777777	777775
 51385	070335	777777	777773
 51386	070336	777777	777767
 51387	070337	777777	777757
 51388	070340	777777	777737
 51389	070341	777777	777677
 51390	070342	777777	777577
 51391	070343	777777	777377
 51392	070344	777777	776777
 51393	070345	777777	775777
 51394	070346	777777	773777
 51395	070347	777777	767777
 51396	070350	777777	757777
 51397	070351	777777	737777
 51398	070352	777777	677777
 51399	070353	777777	577777
 51400	070354	777777	377777
 51401	070355	777776	777777
 51402	070356	777775	777777
 51403	070357	777773	777777
 51404	070360	777767	777777
 51405	070361	777757	777777
 51406	070362	777737	777777
 51407	070363	777677	777777
 51408	070364	777577	777777
 51409	070365	777377	777777
 51410	070366	776777	777777
 51411	070367	775777	777777
 51412	070370	773777	777777
 51413	070371	767777	777777
 51414	070372	757777	777777
 51415	070373	737777	777777
 51416	070374	677777	777777
 51417	070375	577777	777777
 51418	070376	123456	765432
 51419	070377	123456	000000
 51420	070400	000000	123456
 51421	070401	600000	000000
 51422	070402	700000	000000
 51423	070403	740000	000000
 51424	070404	760000	000000
 51425	070405	770000	000000
 51426	070406	774000	000000
 51427	070407	776000	000000
 51428	070410	777400	000000
 51429	070411	777600	000000
 51430	070412	777700	000000
 51431	070413	777740	000000
 51432	070414	777760	000000
 51433	070415	777770	000000
 51434	070416	777774	000000
 51435	070417	777776	000000
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-2
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51436	070420	777777	400000
 51437	070421	777777	600000
 51438	070422	777777	700000
 51439	070423	777777	740000
 51440	070424	777777	760000
 51441	070425	777777	770000
 51442	070426	777777	774000
 51443	070427	777777	776000
 51444	070430	777777	777000
 51445	070431	777777	777400
 51446	070432	777777	777600
 51447	070433	777777	777700
 51448	070434	777777	777740
 51449	070435	777777	777760
 51450	070436	777777	777770
 51451	070437	777777	777774
 51452	070440	000002	000002
 51453	070441	000004	000004
 51454	070442	000010	000010
 51455	070443	000020	000020
 51456	070444	000040	000040
 51457	070445	000100	000100
 51458	070446	000200	000200
 51459	070447	000400	000400
 51460	070450	001000	001000
 51461	070451	002000	002000
 51462	070452	004000	004000
 51463	070453	010000	010000
 51464	070454	020000	020000
 51465	070455	040000	040000
 51466	070456	100000	100000
 51467	070457	200000	200000
 51468	070460	400000	400000
 51469	070461	777776	777776
 51470	070462	777775	777775
 51471	070463	777773	777773
 51472	070464	777767	777767
 51473	070465	777757	777757
 51474	070466	777737	777737
 51475	070467	777677	777677
 51476	070470	777577	777577
 51477	070471	777377	777377
 51478	070472	776777	776777
 51479	070473	775777	775777
 51480	070474	773777	773777
 51481	070475	767777	767777
 51482	070476	757777	757777
 51483	070477	737777	737777
 51484	070500	677777	677777
 51485	070501	577777	577777
 51486	070502	377777	377777
 51487	070503	000001	777776
 51488	070504	777776	000001
 51489	070505	000002	777775
 51490	070506	777775	000002
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-3
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51491	070507	000004	777773
 51492	070510	777773	000004
 51493	070511	000010	777767
 51494	070512	777767	000010
 51495	070513	000020	777757
 51496	070514	777757	000020
 51497	070515	000040	777737
 51498	070516	777737	000040
 51499	070517	000100	777677
 51500	070520	777677	000100
 51501	070521	000200	777577
 51502	070522	777577	000200
 51503	070523	000400	777377
 51504	070524	777377	000400
 51505	070525	001000	776777
 51506	070526	776777	001000
 51507	070527	002000	775777
 51508	070530	775777	002000
 51509	070531	004000	773777
 51510	070532	773777	004000
 51511	070533	010000	767777
 51512	070534	767777	010000
 51513	070535	020000	757777
 51514	070536	757777	020000
 51515	070537	040000	737777
 51516	070540	737777	040000
 51517	070541	100000	677777
 51518	070542	677777	100000
 51519	070543	200000	577777
 51520	070544	577777	200000
 51521	070545	400000	377777
 51522	070546	377777	400000
 51523	070547	000000	707070
 51524	070550	707070	777777
 51525	070551	070707	777777
 51526	070552	070707	070710
 51527	070553	777777	777772
 51528	070554	777777	777766
 51529	070555	777777	777756
 51530	070556	777777	777736
 51531	070557	777777	777676
 51532	070560	777777	777576
 51533	070561	777777	777376
 51534	070562	777777	776776
 51535	070563	777777	775776
 51536	070564	777777	773776
 51537	070565	777777	767776
 51538	070566	777777	757776
 51539	070567	777777	737776
 51540	070570	777777	677776
 51541	070571	777777	577776
 51542	070572	777777	377776
 51543	070573	777775	777776
 51544	070574	777773	777776
 51545	070575	777767	777776
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-4
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51546	070576	777757	777776
 51547	070577	777737	777776
 51548	070600	777677	777776
 51549	070601	777577	777776
 51550	070602	777377	777776
 51551	070603	776777	777776
 51552	070604	775777	777776
 51553	070605	773777	777776
 51554	070606	767777	777776
 51555	070607	757777	777776
 51556	070610	737777	777776
 51557	070611	677777	777776
 51558	070612	577777	777776
 51559	070613	377777	777776
 51560	070614	252525	252525
 51561	070615	254 04 0 00 046573 
 51562	070616	201 01 0 00 050047 
 51563	070617	201 01 0 00 000001 
 51564	070620	201 01 0 00 777777 
 51565	070621	256 00 0 00 070620 
 51566	070622	256 00 0 00 070621 
 51567	070623	256 00 0 00 070622 
 51568	070624	256 00 0 00 070623 
 51569	070625	200 01 0 00 070254 
 51570	070626	334 00 0 00 000000 
 51571	070627	310 00 0 00 000000 
 51572	070630	201 01 0 00 001234 
 51573	070631	050454	050453
 51574	070632	050463	050462
 51575	070633	254 00 0 00 050526 
 51576	070634	000001	000002
 51577	070635	135531	246642
 51578	070636	135246	246135
 51579	070637	123456	123456
 51580	070640	777000	707070
 51581	070641	777000	000777
 51582	070642	123000	000456
 51583	070643	121212	000000
 51584	070644	777350	777776
 51585	070645	000767	777777
 51586	070646	777010	000000
 51587	070647	000777	770077
 51588	070650	123456	246123
 51589	070651	123000	006100
 51590	070652	000100	777600
 51591	070653	123456	246135
 51592	070654	123456	040104
 51593	070655	123321	456654
 51594	070656	770077	007770
 51595	070657	003300	450004
 51596	070660	123456	663322
 51597	070661	777000	700770
 51598	070662	000456	063002
 51599	070663	123456	777776
 51600	070664	010203	123450
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-5
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51601	070665	000777	123456
 51602	070666	000777	517067
 51603	070667	707077	555666
 51604	070670	624421	230254
 51605	070671	707070	123456
 51606	070672	707070	767577
 51607	070673	123456	777666
 51608	070674	777001	123470
 51609	070675	777457	777676
 51610	070676	777000	123456
 51611	070677	000777	050321
 51612	070700	777007	771100
 51613	070701	063202	123477
 51614	070702	000570	004200
 51615	070703	707070	123426
 51616	070704	070707	777032
 51617	070705	123456	123457
 51618	070706	707633	121212
 51619	070707	153512	775132
 51620	070710	000777	654321
 51621	070711	654321	012345
 51622	070712	777000	123477
 51623	070713	000777	775701
 51624	070714	707070	707072
 51625	070715	707777	757372
 51626	070716	777777	070707
 51627	070717	777777	133777
 51628	070720	707070	070706
 51629	070721	777777	707777
 51630	070722	123456	770077
 51631	070723	777001	123324
 51632	070724	654777	657753
 51633	070725	123456	707070
 51634	070726	123456	123422
 51635	070727	707070	717171
 51636	070730	123422	000000
 51637	070731	123456	707076
 51638	070732	707076	000000
 51639	070733	123456	777777
 51640	070734	123456	135724
 51641	070735	765432	246135
 51642	070736	246135	777777
 51643	070737	123123	456765
 51644	070740	456765	777777
 51645	070741	707076	777777
 51646	070742	765432	777777
 51647	070743	365432	123456
 51648	070744	365432	000000
 51649	070745	123456	701234
 51650	070746	123123	246135
 51651	070747	123123	123123
 51652	070750	777777	701234
 51653	070751	765432	107654
 51654	070752	777777	765432
 51655	070753	777777	123456
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-6
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51656	070754	076543	654321
 51657	070755	076543	654323
 51658	070756	076547	654321
 51659	070757	123456	701034
 51660	070760	123454	701234
 51661	070761	252525	707070
 51662	070762	020406	501210
 51663	070763	654321	076543
 51664	070764	754321	076543
 51665	070765	023456	701234
 51666	070766	076543	657321
 51667	070767	120456	701234
 51668	070770	121052	000204
 51669	070771	701234	123456
 51670	070772	654321	076547
 51671	070773	123456	701230
 51672	070774	077543	654321
 51673	070775	123456	700234
 51674	070776	123456	701237
 51675	070777	123456	701134
 51676	071000	123756	701234
 51677	071001	123455	701234
 51678	071002	624426	553711
 51679	071003	774777	777777
 51680	071004	371173	006244
 51681	071005	123456	701334
 51682	071006	123456	070234
 51683	071007	123457	070234
 51684	071010	123457	701234
 51685	071011	373577	707274
 51686	071012	176543	654321
 51687	071013	000016	541320
 51688	071014	000001	000017
 51689	071015	312 00 0 00 000001 
 51690	071016	256 00 0 00 071015 
 51691	071017	256 00 0 00 071016 
 51692	071020	254 00 0 00 056716 
 51693	071021	265 03 0 00 056723 
 51694	071022	256 00 0 00 071021 
 51695	071023	256 00 0 00 071022 
 51696	071024	270 06 0 04 000001 
 51697	071025	331 01 0 00 000002 
 51698	071026	331 03 0 00 000006 
 51699	071027	777776	000005
 51700	071030	253 03 0 00 056767 
 51701	071031	777777	000006
 51702	071032	253 03 0 00 056775 
 51703	071033	000000	000007
 51704	071034	172737	405060
 51705	071035	525252	525252
 51706	071036	230703	603700
 51707	071037	023070	360370
 51708	071040	007603	607062
 51709	071041	200760	360706
 51710	071042	074076	004616
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-7
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51711	071043	074161	440174
 51712	071044	770037	600377
 51713	071045	307036	037007
 51714	071046	700376	003772
 51715	071047	776003	760077
 51716	071050	760037	600770
 51717	071051	076036	070627
 51718	071052	160740	760176
 51719	071053	007740	077646
 51720	071054	400774	017601
 51721	071055	740741	614577
 51722	071056	000000	000252
 51723	071057	000000	000525
 51724	071060	000000	000230
 51725	071061	000000	017777
 51726	071062	000000	005252
 51727	071063	000000	012525
 51728	071064	000000	004616
 51729	071065	000000	000174
 51730	071066	123456	654321
 51731	071067	265 00 0 00 070200 
 51732	071070	265 00 0 00 062523 
 51733	071071	265 00 0 00 062541 
 51734	071072	265 00 0 00 062557 
 51735	071073	265 00 0 00 062575 
 51736	071074	265 00 0 00 062613 
 51737	071075	265 00 0 00 062631 
 51738	071076	265 00 0 00 062647 
 51739	071077	265 00 0 00 062672 
 51740	071100	265 00 0 00 062707 
 51741	071101	265 00 0 00 062724 
 51742	071102	265 00 0 00 062741 
 51743	071103	265 00 0 00 062756 
 51744	071104	265 00 0 00 062773 
 51745	071105	265 00 0 00 063010 
 51746	071106	265 00 0 00 063033 
 51747	071107	265 00 0 00 063047 
 51748	071110	265 00 0 00 063063 
 51749	071111	265 00 0 00 063077 
 51750	071112	265 00 0 00 063113 
 51751	071113	265 00 0 00 063127 
 51752	071114	265 00 0 00 063143 
 51753	071115	265 00 0 00 063173 
 51754	071116	265 00 0 00 063217 
 51755	071117	265 00 0 00 063243 
 51756	071120	265 00 0 00 063267 
 51757	071121	265 00 0 00 063313 
 51758	071122	265 00 0 00 063337 
 51759	071123	265 00 0 00 063363 
 51760	071124	265 00 0 00 063407 
 51761	071125	265 00 0 00 063433 
 51762	071126	265 00 0 00 063457 
 51763	071127	265 00 0 00 063503 
 51764	071130	265 00 0 00 063527 
 51765	071131	265 00 0 00 063553 
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-8
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51766	071132	265 00 0 00 063577 
 51767	071133	265 00 0 00 063623 
 51768	071134	265 00 0 00 063647 
 51769	071135	265 00 0 00 063673 
 51770	071136	265 00 0 00 063717 
 51771	071137	265 00 0 00 063743 
 51772	071140	265 00 0 00 063767 
 51773	071141	265 00 0 00 064014 
 51774	071142	352 00 0 00 000000 
 51775	071143	265 01 0 00 064037 
 51776	071144	332 00 0 00 000000 
 51777	071145	265 01 0 00 064061 
 51778	071146	265 01 0 00 064103 
 51779	071147	265 01 0 00 064125 
 51780	071150	265 01 0 00 064147 
 51781	071151	265 01 0 00 064171 
 51782	071152	265 01 0 00 064213 
 51783	071153	265 01 0 00 064235 
 51784	071154	265 01 0 00 064257 
 51785	071155	265 01 0 00 064301 
 51786	071156	265 01 0 00 064323 
 51787	071157	265 01 0 00 064345 
 51788	071160	265 01 0 00 064367 
 51789	071161	265 01 0 00 064411 
 51790	071162	265 01 0 00 064426 
 51791	071163	265 01 0 00 064451 
 51792	071164	265 01 0 00 064474 
 51793	071165	265 01 0 00 064517 
 51794	071166	265 01 0 00 064542 
 51795	071167	265 01 0 00 064565 
 51796	071170	265 01 0 00 064610 
 51797	071171	265 01 0 00 065360 
 51798	071172	265 01 0 00 065410 
 51799	071173	265 01 0 00 065440 
 51800	071174	265 01 0 00 065470 
 51801	071175	265 01 0 00 065520 
 51802	071176	265 01 0 00 065550 
 51803	071177	265 01 0 00 065600 
 51804	071200	265 01 0 00 065622 
 51805	071201	265 01 0 00 065646 
 51806	071202	265 01 0 00 065672 
 51807	071203	003000	000000
 51808	071204	265 01 0 00 065716 
 51809	071205	265 01 0 00 065742 
 51810	071206	005000	000000
 51811	071207	265 01 0 00 065766 
 51812	071210	006000	000000
 51813	071211	265 01 0 00 066012 
 51814	071212	007000	000000
 51815	071213	265 01 0 00 066036 
 51816	071214	265 01 0 00 066062 
 51817	071215	011000	000000
 51818	071216	265 01 0 00 066106 
 51819	071217	012000	000000
 51820	071220	265 01 0 00 066132 
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-9
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51821	071221	013000	000000
 51822	071222	265 01 0 00 066156 
 51823	071223	014000	000000
 51824	071224	265 01 0 00 066202 
 51825	071225	015000	000000
 51826	071226	265 01 0 00 066226 
 51827	071227	016000	000000
 51828	071230	265 01 0 00 066252 
 51829	071231	017000	000000
 51830	071232	265 01 0 00 066276 
 51831	071233	265 01 0 00 066322 
 51832	071234	021000	000000
 51833	071235	265 01 0 00 066346 
 51834	071236	022000	000000
 51835	071237	265 01 0 00 066372 
 51836	071240	023000	000000
 51837	071241	265 01 0 00 066416 
 51838	071242	024000	000000
 51839	071243	265 01 0 00 066442 
 51840	071244	025000	000000
 51841	071245	265 01 0 00 066466 
 51842	071246	026000	000000
 51843	071247	265 01 0 00 066512 
 51844	071250	027000	000000
 51845	071251	265 01 0 00 066536 
 51846	071252	030000	000000
 51847	071253	265 01 0 00 066562 
 51848	071254	031000	000000
 51849	071255	265 01 0 00 066606 
 51850	071256	032000	000000
 51851	071257	265 01 0 00 066632 
 51852	071260	033000	000000
 51853	071261	265 01 0 00 066656 
 51854	071262	034000	000000
 51855	071263	265 01 0 00 066702 
 51856	071264	035000	000000
 51857	071265	265 01 0 00 066726 
 51858	071266	036000	000000
 51859	071267	265 01 0 00 066752 
 51860	071270	037000	000000
 51861	071271	254 00 0 00 066777 
 51862	071272	254 00 0 00 067016 
 51863	071273	254 00 0 00 067035 
 51864	071274	254 00 0 00 067054 
 51865	071275	254 00 0 00 067073 
 51866	071276	254 00 0 00 067112 
 51867	071277	254 00 0 00 067131 
 51868	071300	254 00 0 00 067150 
 51869	071301	254 00 0 00 067167 
 51870	071302	254 00 0 00 067206 
 51871	071303	254 00 0 00 067225 
 51872	071304	254 00 0 00 067244 
 51873	071305	254 00 0 00 067263 
 51874	071306	254 00 0 00 067302 
 51875	071307	254 00 0 00 067321 
DFKAA PDP-10 KL10 BASIC INSTRUCTION DIAGNOSTIC (1) VER 0,2	MACRO %53B(1254)-4 11:50 11-Nov-24 Page 1-10
STOR	KLM	13-Jan-89 11:46		*STOR* RESERVED STORAGE, JULY 19,1977

 51876	071310	254 00 0 00 067340 
 51877	071311	254 00 0 00 067357 
 51878	071312	254 00 0 00 067376 
 51879	071313	254 00 0 00 067415 
 51880	071314	254 00 0 00 067434 
 51881	071315	254 00 0 00 067453 
 51882	071316	254 00 0 00 067472 
 51883	071317	254 00 0 00 067513 
 51884	071320	254 00 0 00 067526 
 51885	071321	254 00 0 00 067541 
 51886	071322	265 11 0 00 067556 
 51887	071323	254 00 0 00 067554 
 51888	071324	265 11 0 00 067577 
 51889	071325	254 00 0 00 067575 
 51890	071326	265 11 0 00 067620 
 51891	071327	254 00 0 00 067616 
 51892	071330	265 11 0 00 067641 
 51893	071331	254 00 0 00 067637 
 51894	071332	265 11 0 00 067662 
 51895	071333	254 00 0 00 067660 
 51896	071334	265 11 0 00 067703 
 51897	071335	254 00 0 00 067701 
 51898	071336	265 11 0 00 067724 
 51899	071337	254 00 0 00 067722 
 51900	071340	265 11 0 00 067745 
 51901	071341	254 00 0 00 067743 
 51902	071342	254 00 0 00 070005 
 51903	071343	004000	070060
 51904	071344	265 01 0 00 070160 
 51905	071345	265 01 0 00 070135 
 51906						LIST
 51907	071346	000000	000000		ENDSLD:	0
 51908
 51909					IFDEF	DEBUG,<
 51910					PATCH:	BLOCK DEBUG		;PATCHING AREA
 51911					>
 51912
 51913					;PROGRAM VARIABLES
 51914	071347					VAR
 51915
 51916					IFDEF	PGMEND,<
 51917	071355	000000	000000		END:	0
 51918			030000			END	BEGIN	>

NO ERRORS DETECTED

PROGRAM BREAK IS 000000
ABSOLUTE BREAK IS 071356
CPU TIME USED 00:03.223

37P CORE USED

A00	   913#
A100	   968#
A1000	  1073#
A10000	  7703#
A10100	  8121#
A10200	  8544#
A10300	  8564#
A10400	  9471#
A10500	  9494#
A10600	  9515#
A10700	  9537#
A1100	  1088#
A11000	  9589#
A11100	 10702#
A11200	 11686#
A11300	 12587#
A11400	 13083#
A11500	 13763#
A11600	 13782#
A11700	 13797#
A1200	  1101#
A12000	 14465#
A12100	 14479#
A12200	 14502#
A12300	 14520#
A12400	 14538#
A12500	   914#
A12600	   958#
A12700	   950#
A1300	  1115#
A13000	  8578#
A13100	  2045#
A13200	 10721#
A13300	  9555#
A13400	  9573#
A13500	 13580#
A13600	 13597#
A13700	 13614#
A1400	  1129#
A14000	 13630#
A14100	 13647#
A14200	 13664#
A14300	 13680#
A14400	 13697#
A14500	 13714#
A14600	 13730#
A14700	 13747#
A1500	  1143#
A15000	   929#
A15100	   940#
A1600	  1157#
A1700	  1171#
A200	   981#
A2000	  1185#
A2100	  1199#
A2200	  1212#
A2300	  1226#
A2400	  1240#
A2500	  1254#
A2600	  1267#
A2700	  1281#
A300	   995#
A3000	  1295#
A3100	  1307#
A3200	  2012#
A3300	  2030#
A3400	  2058#
A3500	  2083#
A3600	  2101#
A3700	  2119#
A400	  1011#
A4000	  2170#
A4100	  2186#
A4200	  2331#
A4300	  2349#
A4400	  2367#
A4500	  2134#
A4600	  2149#
A4700	  2386#
A500	  1026#
A5000	  2402#
A5100	  2418#
A5200	  2433#
A5300	  2450#
A5400	  2470#
A5500	  2483#
A5600	  2843#
A5700	  3207#
A600	  1045#
A6000	  3223#
A6100	  3243#
A6200	  3261#
A6300	  3282#
A6400	  3295#
A6500	  4364#
A6600	  5144#
A6700	  5162#
A700	  1060#
A7000	  5182#
A7100	  5199#
A7200	  5215#
A7300	  5229#
A7400	  5969#
A7500	  6894#
A7600	  7672#
A7700	  7689#
ABORT	    96#
AC	  2184#	  2217	  2217#	  2218	  2218#	  2220	  2221	  2222	  2246	  2246#	  2247	  2249	  2250	  2251
	  2275	  2275#	  2276	  2278	  2279	  2280	  2304	  2304#	  2305	  2307	  2308	  2309	 31460#	 31461
	 31466	 31467	 31469	 31470	 31472	 31473	 31475	 31476	 31478	 31479	 31481	 31482	 31484	 31485
	 31487	 31488	 31490	 31491	 31493	 31494	 31495	 50828#	 50860#	 50892#	 50924#	 50956#	 50988#	 51020#
	 51052#
AC0	   703#
ALTMGO	   450#
AMCLRB	   364#
ANXM	   364#
APR	   800	   801	   802	 42946	 43492	 43500	 43508	 43515	 43516	 43522	 43523	 43529	 43530	 43560
	 43561	 43567	 43568	 43575	 43576	 43582	 43583	 43586	 43587	 43590	 43591	 43687	 43688	 43689
	 43693	 43694	 46004	 46025	 46046	 46067	 46088	 46110	 46131	 46305	 46322	 46339	 46356	 46373
	 46390	 46407	 47976	 48019	 48041	 48063	 48085	 48107	 48129	 48151	 48169	 48179	 48181	 48207
	 48214	 48227	 48234	 48247	 48254	 48267	 48274	 48287	 48294	 48307	 48314	 48327	 48334	 48347
	 48354	 48367	 48374	 48387	 48394	 48407	 48414	 48427	 48434	 48447	 48454	 48467	 48474	 48487
	 48494	 48507	 48514	 48527	 48534	 48547	 48554	 48582	 48622	 48662	 48702	 48742	 48782	 48822
AROV	   364#	 30464	 30661	 30665
AROVTP	   364#
AROVU	   364#
AST	   565#
ATSIN	   566#
B100	 14561#
B1000	 14701#
B10000	 19516#
B10100	 19536#
B10200	 19552#
B10300	 19567#
B10400	 19583#
B10500	 19599#
B10700	 19627#
B1100	 14717#
B11000	 19642#
B11100	 19658#
B11200	 19673#
B11300	 19689#
B11500	 19707#
B11600	 19729#
B11700	 19752#
B1200	 14733#
B12100	 19767#
B12200	 19784#
B12300	 19804#
B12400	 19828#
B12500	 19844#
B12600	 19863#
B12700	 19886#
B1300	 14754#
B13000	 19903#
B13100	 19921#
B13200	 19937#
B13300	 19963#
B13400	 19984#
B13600	 20002#
B1400	 14775#
B14000	 20018#
B14100	 20041#
B14200	 20063#
B14400	 20087#
B14500	 20103#
B14600	 20121#
B14700	 20136#
B1500	 14799#
B15000	 20160#
B15400	 20181#
B15500	 20198#
B15600	 20219#
B15700	 20235#
B1600	 14818#
B16000	 20257#
B16100	 20272#
B16200	 20289#
B16300	 20315#
B16400	 20337#
B16500	 20359#
B16600	 20374#
B16700	 20398#
B1700	 15746#
B17000	 20414#
B17300	 20432#
B17400	 20445#
B17700	 20459#
B200	 14582#
B2000	 16411#
B20000	 20471#
B20400	 20486#
B20600	 20501#
B20700	 20516#
B2100	 17080#
B21000	 20536#
B21100	 20557#
B21400	 20574#
B21500	 20608#
B21600	 20625#
B21700	 20643#
B2200	 17459#
B22200	 20660#
B22300	 20678#
B22400	 20701#
B22500	 20719#
B22600	 20736#
B22700	 20755#
B2300	 17839#
B23000	 20778#
B23200	 20799#
B23400	 20816#
B23600	 20832#
B23700	 20849#
B2400	 18314#
B24000	 20864#
B24300	 20886#
B24400	 20908#
B24500	 20925#
B24600	 20941#
B24700	 20957#
B2500	 18794#
B25000	 20978#
B25100	 20995#
B25200	 21011#
B25300	 21028#
B25400	 21044#
B25500	 21061#
B25600	 21077#
B25700	 21094#
B2600	 18818#
B26000	 21109#
B26100	 21126#
B26200	 21141#
B26300	 21157#
B26500	 21178#
B26600	 21199#
B26700	 21214#
B2700	 18838#
B27000	 21235#
B27100	 21255#
B27200	 21271#
B27300	 21286#
B27400	 21307#
B27500	 21322#
B27600	 21338#
B27700	 21353#
B300	 14607#
B3000	 18855#
B30000	 21369#
B30100	 21384#
B30400	 21405#
B30500	 21420#
B30600	 21441#
B30700	 21462#
B3100	 18871#
B31000	 21478#
B31100	 21493#
B31200	 21509#
B31300	 21524#
B31400	 21540#
B31500	 21555#
B31600	 21571#
B31700	 21586#
B3200	 18886#
B32000	 21602#
B32100	 21617#
B32200	 21641#
B32300	 21656#
B32600	 21677#
B32700	 21692#
B3300	 18907#
B33000	 21715#
B33100	 21736#
B33200	 21752#
B33300	 21768#
B33400	 21789#
B33500	 21810#
B33600	 21826#
B33700	 21842#
B34000	 21863#
B34100	 21879#
B34200	 21895#
B34300	 21910#
B34400	 21926#
B34500	 21941#
B34600	 21957#
B34700	 21972#
B3500	 18927#
B35000	 21988#
B35500	 22011#
B35600	 22036#
B35700	 22053#
B3600	 18950#
B36000	 22083#
B36100	 22099#
B36200	 22120#
B36300	 22140#
B36400	 22161#
B36500	 22181#
B36600	 22202#
B3700	 18964#
B37100	 22222#
B37200	 22244#
B37300	 22265#
B37400	 22281#
B37500	 22296#
B37600	 22312#
B37700	 22327#
B400	 14628#
B40000	 22343#
B40100	 22358#
B40200	 22374#
B40300	 22390#
B40400	 22407#
B40700	 22423#
B41000	 22445#
B41100	 22467#
B41200	 22484#
B41500	 22500#
B41600	 22522#
B42000	 22545#
B42200	 22562#
B42300	 22578#
B42500	 22603#
B42700	 22618#
B4300	 18979#
B43000	 22641#
B43100	 22663#
B43400	 22680#
B43500	 22695#
B43600	 22718#
B43700	 22738#
B4400	 19001#
B44000	 22761#
B44100	 22777#
B44200	 22795#
B44300	 22812#
B44500	 22835#
B44600	 22855#
B44700	 22872#
B4500	 19019#
B45000	 22887#
B45100	 22903#
B45200	 22918#
B45400	 22944#
B45500	 22972#
B45600	 23732#
B45700	 24494#
B4600	 19043#
B46000	 25289#
B4700	 19066#
B500	 14644#
B5000	 19087#
B5100	 19113#
B5200	 19141#
B5300	 19159#
B5500	 19175#
B5600	 19199#
B5700	 19215#
B600	 14664#
B6000	 19232#
B6100	 19253#
B6200	 19269#
B6300	 19292#
B6400	 19314#
B6500	 19331#
B6600	 19347#
B6700	 19364#
B700	 14680#
B7000	 19380#
B7100	 19404#
B7200	 19426#
B7300	 19442#
B7400	 19457#
B7500	 19473#
B7600	 19489#
BEGEND	   446#	 42934	 51186
BEGIN	    39	    40	   377#	   746	   868	 51918
BEGIN1	   393#	   447
BEGIOT	 42925#
BELL	   569#
BIGPI1	 44643#
BIGPI2	 44754#
BIGPI3	 44865#
BIGPI4	 44976#
BIGPI5	 45087#
BIGPI6	 45198#
BIGPI7	 45309#
BIGPIX	 45420#
BIGPIY	 45531#
BIGPIZ	 45642#
BIS	   364#	 32734	 32743	 32758	 32762	 32776	 32782	 32797	 32802	 41437	 41443	 43713	 43716
C100	 26093#
C1000	 27145#
C10000	 30679#
C10100	 30701#
C10200	 30722#
C10300	 30744#
C10400	 30762#
C10500	 30778#
C1100	 27487#
C11200	 30794#
C11300	 30809#
C11400	 30823#
C11500	 30838#
C11600	 30851#
C11700	 30865#
C1200	 27503#
C12000	 30880#
C12100	 30897#
C12200	 30933#
C12300	 30950#
C12301	 30987#
C12600	 31025#
C12700	 31040#
C1300	 27958#
C13100	 31054#
C13200	 31069#
C13300	 31084#
C13400	 31121#
C13600	 31160#
C13700	 31180#
C1400	 28416#
C14000	 31199#
C14100	 31223#
C14200	 31242#
C14500	 31269#
C14600	 31283#
C14700	 31298#
C1500	 28432#
C15000	 31311#
C15100	 31325#
C15200	 31340#
C15300	 31354#
C15400	 31368#
C15500	 31386#
C15600	 31401#
C15700	 31416#
C1600	 28887#
C16000	 31430#
C16100	 31445#
C16200	 31460#
C16201	 31508#
C16202	 31545#
C16400	 31584#
C16500	 31599#
C16600	 31613#
C16700	 31628#
C1700	 29352#
C17000	 31644#
C17100	 31666#
C17200	 31681#
C17300	 31697#
C17400	 31711#
C17500	 31727#
C17600	 31743#
C17700	 31759#
C200	 26109#
C2000	 29584#
C20000	 31774#
C20100	 31790#
C20200	 31804#
C20300	 31820#
C20400	 31842#
C20500	 31858#
C20600	 31874#
C20700	 31890#
C2100	 29814#
C21000	 31903#
C21100	 31921#
C21200	 31941#
C21300	 31960#
C21400	 31980#	 31983	 31986
C21500	 32000#	 32004	 32006
C21600	 32019#	 32022	 32023
C21700	 32035#	 32037	 32038
C2200	 29830#
C22000	 32062	 32101#
C22100	 32117#
C22200	 32132#
C22300	 32148#
C22400	 32163#
C22500	 32179#
C22600	 32195#
C22700	 32212#
C23000	 32231#
C23100	 32253#
C23200	 32274#
C23300	 32298#
C23400	 32319#
C23500	 32342#
C23600	 32363#	 32367
C23700	 32385#
C2400	 29846#
C24000	 32405#
C2410	 29855#
C24100	 32420#
C24200	 32437#
C24300	 32452#
C24400	 32467#
C24500	 32481#
C24600	 32498#
C24700	 32514#
C25000	 32532#
C25100	 32549#
C25200	 32567#
C25300	 32584#
C25400	 32602#
C25500	 32617#
C25600	 32630#
C25700	 32645#
C26200	 32662#
C26300	 32680#
C26400	 32696#
C26500	 32713#
C26600	 32732#
C26700	 32756#
C2700	 29870#
C27000	 32774#
C27001	 32795#
C2710	 29879#
C27100	 32815#
C27200	 41131#
C27300	 41147#
C27400	 41161#
C27500	 41177#
C27600	 41192#
C27700	 41209#
C2A	 46429#
C2B	 46448	 46458#
C2C	 46485	 46495#
C2D	 46522	 46532#
C2E	 46559	 46569#
C2F	 46596	 46606#
C2G	 46633	 46643#
C2H	 46670	 46680#
C2I	 46707	 46717#
C2J	 46744	 46754#
C2K	 46781	 46791#
C2L	 46818	 46828#
C2M	 46855	 46865#
C2N	 46892	 46902#
C2O	 46929	 46939#
C2P	 46966	 46976#
C2Q	 47003	 47013#
C2R	 47040	 47050#
C2S	 47077	 47087#
C2T	 47114	 47124#
C2U	 47151	 47161#
C2V	 47188	 47199#
C300	 26123#
C3000	 29893#
C30000	 41225#
C30100	 41243#
C30101	 41259#
C30200	 41276#
C30300	 41295#
C30400	 41315#
C30500	 41336#
C30600	 41353#
C3100	 29917#
C31000	 41370#
C3110	 29934#
C31100	 41384#
C31400	 41404#
C31500	 41418#
C31501	 41435#
C31502	 41456#
C31600	 41474#
C31700	 41489#
C3200	 29948#
C3210	 29957#
C32300	 41504#
C32400	 41519#
C32500	 41536#
C32600	 41554#
C3300	 29972#
C33100	 41571#
C33300	 41589#
C33310	 41599#
C33400	 41612#
C33401	 41629#
C33500	 41647#
C33600	 41663#
C33700	 41678#
C33701	 41696#
C3400	 29988#
C34000	 41714#
C34100	 41727#
C34200	 41739#
C34300	 41755#
C34400	 41773#
C34500	 41790#
C34600	 41807#
C34610	 41816#
C34700	 41829#
C34710	 41836#
C3500	 30005#
C35000	 41849#
C35100	 41866#
C35200	 41883#
C35300	 41900#
C35400	 41915#
C35500	 41934#
C35600	 41959#
C35700	 41982#
C3600	 30023#
C36000	 42004#
C36100	 42028#
C36200	 42051#
C36300	 42075#
C36400	 42098#
C36500	 42121#
C36600	 42143#
C36700	 42167#
C3700	 30039#
C37000	 42190#
C37100	 42214#
C37200	 42236#
C37300	 42258#
C37400	 42280#
C37500	 42303#
C37600	 42325#
C37700	 42348#
C400	 26138#
C4000	 30055#
C40000	 42370#
C40100	 42392#
C40200	 42414#
C40300	 42437#
C40400	 42459#
C40500	 42482#
C40600	 42505#
C40700	 42529#
C4100	 30073#
C41000	 42552#
C41100	 42576#
C41200	 42599#
C41300	 42623#
C41400	 42646#
C41500	 42670#
C41600	 42693#
C41700	 42717#
C4200	 30089#
C42000	 42740#
C42100	 42764#
C42200	 42787#
C42300	 42811#
C42400	 42834#
C42500	 42858#
C42600	 42881#
C42700	 42905#
C4300	 30107#
C4400	 30125#
C4500	 30141#
C4600	 30156#
C4700	 30171#
C500	 26155#
C5000	 30188#
C50000	 32842#
C50100	 32867#
C50110	 32890#
C50200	 32913#
C50300	 32928#
C50301	 32952#
C50400	 32981#
C50401	 33005#
C50410	 33034#
C50500	 33057#
C50501	 33071#
C50600	 33086#
C50700	 33111#
C50710	 33135#
C5100	 30204#
C51000	 33161#
C51100	 33177#
C51101	 33200#
C51200	 33228#
C51201	 33251#
C51300	 33283#
C51310	 33299#
C51320	 33315#
C51400	 33332#
C51410	 33347#
C51420	 33363#
C51500	 33379#
C51510	 33395#
C51520	 33410#
C51600	 33426#
C51610	 33442#
C51620	 33458#
C51700	 33473#
C51710	 33489#
C51720	 33505#
C5200	 30220#
C52000	 33521#
C52010	 33537#
C52020	 33554#
C52100	 33573#
C52110	 33590#
C52120	 33605#
C52200	 33623#
C52210	 33638#
C52220	 33655#
C52300	 33672#
C52310	 33686#
C52320	 33699#
C52400	 33714#
C52410	 33728#
C52420	 33742#
C52500	 33761#
C52510	 33784#
C52520	 33807#
C52600	 33832#
C52610	 33856#
C52620	 33880#
C52700	 33904#
C52710	 33928#
C52720	 33951#
C5300	 30237#
C53000	 33976#
C53010	 33999#
C53020	 34023#
C53100	 34046#
C53110	 34071#
C53120	 34094#
C53200	 34118#
C53210	 34141#
C53220	 34166#
C53300	 34189#
C53310	 34214#
C53320	 34238#
C53400	 34267#
C53401	 34300#
C53410	 34337#
C53420	 34370#
C53500	 34404#
C53510	 34437#
C53520	 34470#
C53600	 34503#
C53610	 34536#
C53620	 34568#
C53700	 34602#
C53710	 34634#
C53720	 34667#
C5400	 30254#
C54000	 34699#
C54010	 34733#
C54020	 34765#
C54100	 34798#
C54110	 34830#
C54120	 34864#
C54200	 34896#
C54210	 34930#
C54220	 34963#
C54300	 34997#
C54310	 35021#
C54320	 35044#
C54400	 35069#
C54410	 35093#
C54420	 35117#
C54500	 35141#
C54510	 35165#
C54520	 35188#
C54600	 35213#
C54610	 35236#
C54620	 35260#
C54700	 35283#
C54710	 35308#
C54720	 35331#
C5500	 30271#
C55000	 35355#
C55010	 35378#
C55020	 35402#
C55100	 35426#
C55110	 35450#
C55120	 35475#
C55200	 35504#
C55210	 35537#
C55211	 35570#
C55220	 35608#
C55300	 35643#
C55310	 35677#
C55320	 35710#
C55400	 35744#
C55410	 35777#
C55420	 35809#
C55500	 35843#
C55510	 35874#
C55520	 35907#
C55600	 35939#
C55610	 35973#
C55620	 36005#
C55700	 36038#
C55710	 36070#
C55720	 36104#
C5600	 30290#
C56000	 36136#
C56010	 36170#
C56020	 36203#
C56100	 36234#
C56200	 36256#
C56300	 36277#
C56400	 36298#
C56500	 36318#
C56600	 36340#
C56700	 36356#
C56701	 36380#
C5700	 30308#
C57000	 36407#
C57001	 36430#
C5701	 30325#
C5702	 30341#
C57100	 36457#
C57200	 36474#
C57300	 36497#
C57400	 36520#
C57500	 36534#
C57600	 36556#
C57700	 36578#
C600	 26503#
C6000	 30361#
C60000	 36595#
C60100	 36617#
C60200	 36641#
C60300	 36662#
C60400	 36677#
C60500	 36699#
C60600	 36715#
C60700	 36738#
C6100	 30378#
C61000	 36754#
C61100	 36777#
C61200	 36801#
C61300	 36817#
C61400	 36841#
C61500	 36864#
C61600	 36881#
C61700	 36903#
C6200	 30395#
C62000	 36927#
C62100	 36943#
C62200	 36967#
C62300	 36990#
C62400	 37007#
C62500	 37030#
C62600	 37054#
C62700	 37070#
C6300	 30416#
C63000	 37094#
C63100	 37117#
C63200	 37134#
C63300	 37157#
C63400	 37181#
C63500	 37196#
C63600	 37219#
C63700	 37245#
C6400	 30439#
C64000	 37262#
C64010	 37285#
C64100	 37310#
C64110	 37335#
C64200	 37359#
C64300	 37383#
C64310	 37409#
C64400	 37432#
C64500	 37457#
C64510	 37482#
C64600	 37506#
C64700	 37527#
C6500	 30462#
C65000	 37549#
C65100	 37563#
C65200	 37590#
C65210	 37615#
C65300	 37639#
C65400	 37663#
C65410	 37689#
C65500	 37712#
C65600	 37737#
C65610	 37762#
C65700	 37786#
C6600	 30481#
C66000	 37810#
C66010	 37837#
C66100	 37862#
C66110	 37887#
C66200	 37909#
C66300	 37925#
C66301	 37947#
C66400	 37976#
C66410	 38001#
C66411	 38026#
C66500	 38053#
C66600	 38079#
C66610	 38103#
C66700	 38126#
C6700	 30501#
C67000	 38147#
C67100	 38163#
C67200	 38187#
C67210	 38213#
C67300	 38238#
C67310	 38264#
C67400	 38289#
C67410	 38315#
C67500	 38343#
C67510	 38365#
C67600	 38387#
C67610	 38409#
C67700	 38430#
C67710	 38451#
C700	 26858#
C7000	 30518#
C70000	 38471#
C70010	 38492#
C70100	 38512#
C70110	 38533#
C70200	 38554#
C70210	 38575#
C70300	 38598#
C70310	 38628#
C70400	 38657#
C70410	 38686#
C70500	 38709#
C70510	 38739#
C70600	 38767#
C70610	 38790#
C70700	 38812#
C70710	 38835#
C7100	 30539#
C71000	 38859#
C71010	 38883#
C71100	 38907#
C71110	 38931#
C71200	 38954#
C71210	 38977#
C71300	 38999#
C71310	 39022#
C71400	 39045#
C71410	 39069#
C71500	 39093#
C71510	 39117#
C71600	 39140#
C71610	 39171#
C71700	 39203#
C71710	 39235#
C7200	 30561#
C72000	 39267#
C72010	 39299#
C72100	 39330#
C72110	 39366#
C72200	 39395#
C72210	 39425#
C72300	 39456#
C72310	 39488#
C72400	 39520#
C72410	 39552#
C72500	 39581#
C72510	 39604#
C72600	 39626#
C72610	 39649#
C72700	 39673#
C72710	 39697#
C7300	 30585#
C73000	 39721#
C73010	 39745#
C73100	 39768#
C73110	 39791#
C73200	 39813#
C73210	 39836#
C73300	 39859#
C73310	 39883#
C73400	 39907#
C73410	 39931#
C73500	 39954#
C73510	 39985#
C73600	 40017#
C73610	 40049#
C73700	 40081#
C73710	 40107#
C7400	 30606#
C74000	 40137#
C74100	 40167#
C74200	 40196#
C74210	 40226#
C74300	 40257#
C74310	 40289#
C74400	 40321#
C74410	 40353#
C74500	 40382#
C74510	 40405#
C74600	 40427#
C74610	 40450#
C74700	 40474#
C74710	 40498#
C7500	 30624#
C75000	 40522#
C75010	 40546#
C75100	 40569#
C75110	 40592#
C75200	 40614#
C75210	 40637#
C75300	 40660#
C75310	 40684#
C75400	 40708#
C75410	 40732#
C75500	 40757#
C75510	 40789#
C75600	 40821#
C75610	 40853#
C75700	 40884#
C75710	 40914#
C7600	 30639#
C76000	 40943#
C76010	 40973#
C76100	 41004#
C76110	 41036#
C76200	 41068#
C76210	 41100#
C7700	 30658#
CCA	   364#
CHAIN	   116#
CHNOFF	   364#	 42948	 44676	 44741	 44787	 44852	 44898	 44963	 45009	 45074	 45120	 45185	 45231	 45296
	 45342	 45407	 45453	 45518	 45564	 45629	 45675	 45740
CHNON	   364#	 44654	 44675	 44697	 44719	 44740	 44765	 44786	 44808	 44830	 44851	 44876	 44897	 44919
	 44941	 44962	 44987	 45008	 45030	 45052	 45073	 45098	 45119	 45141	 45163	 45184	 45209	 45230
	 45252	 45274	 45295	 45320	 45341	 45363	 45385	 45406	 45431	 45452	 45474	 45496	 45517	 45542
	 45563	 45585	 45607	 45628	 45653	 45674	 45696	 45718	 45739	 46303	 46320	 46337	 46354	 46371
	 46388	 46405	 46450	 46487	 46524	 46561	 46598	 46635	 46672	 46709	 46746	 46783	 46820	 46857
	 46894	 46931	 46968	 47005	 47042	 47079	 47116	 47153	 47190	 47235	 47267	 47303	 47335	 47371
	 47403	 47439	 47471	 47507	 47539	 47575	 47607	 47643	 47675	 47719	 47724	 47755	 47760	 47791
	 47796	 47827	 47832	 47863	 47868	 47899	 47904	 47935	 47940	 47975	 48018	 48040	 48062	 48084
	 48106	 48128	 48150	 48168	 48206	 48226	 48246	 48266	 48286	 48306	 48326	 48346	 48366	 48386
	 48406	 48426	 48446	 48466	 48486	 48506	 48526	 48546
CKCK0	 47970#
CKCK1	 47992#
CKI01	 46160	 46169#
CKI02	 46178	 46187#
CKI03	 46196	 46205#
CKI04	 46214	 46223#
CKI05	 46232	 46241#
CKI06	 46250	 46259#
CKI07	 46268	 46277#
CLK	   364#
CLKCLR	   364#
CLKDIS	   364#	 43665
CLKENB	   364#	 43666
CLKU	   364#
CLOCKF	   432#
CNTLC	   449#
CNTRP	   364#
COMMA	   558#
CONSW	   433#
COUNTX	 48575#	 48575	 48596	 48615#	 48615	 48636	 48655#	 48655	 48676	 48695#	 48695	 48716	 48735#	 48735
	 48756	 48775#	 48775	 48796	 48815#	 48815	 48836
CPOPJ	   453#
CPOPJ1	   451#
CRLF	   246	   247	   553#
CRLF2	   250	   251	   555#
CRY0	   364#	 30398	 30541	 30682	 30686	 32233	 32255	 32276	 32300	 32321	 41278	 41297	 41317	 41386
	 41391
CRY1	   364#	 30483	 30704	 30708
CSHFLG	   612#
CSHMEM	   613#
CTRP	   364#
CYCL60	   606#
DCK	   364#	 31225	 31229	 31244	 31253
DDT	   705#
DDTLNK	   130#	   391
DDTSRT	   391#
DEBUG	 51909
DECVER	     5#	    11	    26	   412
DF22F	   517#
DIAGMN	   380#
DIAGNO	   704#
DIAMON	   706#
DING	   102#
DOLLAR	   572#
DONG11	   707#	   847	   863
DSKUPD	   417
DTE	   711#	   847	   849	   863	   865
DTE0	   712#
DTE1	   713#
DTE2	   714#
DTE3	   715#
E217	 32072#	 32102
E217A	 32072	 32075#	 32103	 32134
E220	 32073#	 32118
E220A	 32073	 32078#
E220B	 32074#	 32078	 32119
E221	 32079#	 32079	 32081	 32133
E221A	 32075	 32080#
E221B	 32076#	 32080
E222	 32081#	 32149	 32150
E222A	 32077#	 32086
E223	 32089#	 32089	 32164	 32180	 32213
E223A	 32082#	 32093	 32165
E224A	 32083#	 32083	 32181
E225	 32085#	 32085	 32196
E225A	 32087	 32090#
E225B	 32088#	 32090	 32197
E226A	 32094#	 32094
E226B	 32092#	 32095	 32214
E50301	 32954	 32955	 32963	 32972#
E50401	 33007	 33008	 33016	 33025#
E51101	 33202	 33203	 33211	 33220#
E51201	 33253	 33254	 33261	 33270#
E53401	 34302	 34303	 34310	 34325#
E55211	 35572	 35573	 35581	 35596#
E56701	 36381	 36383	 36390	 36399#
E57001	 36432	 36433	 36440	 36449#
E66301	 37949	 37950	 37957	 37966#
E66411	 38028	 38029	 38037	 38046#
EFIELD	 50140#	 50169#	 50198#	 50227#	 50256#	 50285#	 50314#	 50343#	 50372#	 50401#	 50430#	 50459#	 50488#	 50517#
	 50546#	 50575#	 50604#	 50633#	 50662#	 50690#	 50718#	 50746#
END	 51917#
ENDFIX	   698#
ENDIT	 51145	 51160	 51185#
ENDSLD	 51907#
ERMORE	   466#
ERRPC	   437#
ERRTLS	   438#
ERSTOP	   105#
EXCASB	    33#	   415
EXCMEM	   364#
EXCPFW	   364#
EXIOT	   364#	 51149	 51174
FOV	   364#	 30503	 30520	 30563	 30725	 30729	 31162
FOVU	   364#
FRDLNK	   128#
FSELNK	   127#
FXU	   364#	 31182	 31186	 31201	 31210
HALTPI	 42943	 42943#	 51205#	 51217
HLTCK	 51208	 51261#
HYPEN	   563#
IADBRK	   364#
IADEXC	   364#
IADSTP	   364#
IADUSR	   364#
IAPRC1	   364#
IAPRE1	   364#
IASRTC	   364#
IASRTE	   364#
IASRTS	   364#
ICNSLL	   364#
ICNSLR	   364#
IDATAF	   364#
IEVNPR	   364#
IFMMAN	   364#
IINSTF	   364#
IIOPFC	   364#
IIOPFL	   364#
IMAINT	   364#
IMGINM	   364#
IMGNLO	   364#
IMGNOF	   364#
IMGNON	   364#
IMIPGD	   364#
IMLAPD	   364#
INHCSH	   113#
INHPAG	   110#
INXCLR	   364#
INXM	   364#
INXSTP	   364#
IOCLR	   364#	 48169
IOT0	 42932	 43295#
IOT1	 43304#
IOT10	 43416#
IOT11	 43429#
IOT12	 43447#
IOT13	 43454#
IOT14	 43456#
IOT15	 43467#
IOT15A	 43475#
IOT16	 43483#
IOT16A	 43491#
IOT17	 43499#
IOT17A	 43507#
IOT18	 43514#
IOT18A	 43537#
IOT19	 43544#
IOT2	 43311#
IOT20	 43552#
IOT21	 43560#
IOT22	 43567#
IOT23	 43575#
IOT24	 43609#
IOT25	 43628#
IOT26	 43646#
IOT27	 43665#
IOT28	 43673#
IOT29	 43685#
IOT3	 43318#
IOT30	 43693#
IOT31	 43712#
IOT31A	 43664	 43686	 43700#
IOT32	 43726#
IOT33B	 43727	 43730#
IOT34	 43738#
IOT35	 43745#
IOT36	 43753#
IOT38	 43767#
IOT39	 43774#
IOT4	 43325#
IOT40	 43782#
IOT41	 43789#
IOT42	 43796#
IOT43	 43803#
IOT44	 43811#
IOT45	 43818#
IOT46	 43826#
IOT47	 43833#
IOT48	 43841#
IOT49	 43848#
IOT5	 43331#
IOT50	 43856#
IOT51	 43863#
IOT6	 43342#
IOT7	 43360#
IOT8	 43377#
IOT9	 43396#
IOTXX	 43294#
IOTXXX	 43292#
IOTXYZ	 43871#
IP50HZ	   364#
IPAREN	   364#
IPARER	   364#
IPRSTP	   364#
IPWRFL	   364#
IPWRLO	   364#
IRQCLR	   364#
ISPDOF	   364#
ISPDON	   364#
ITERAT	    85#	   410
ITMDIS	   364#
ITMENB	   364#
ITMOEN	   364#
ITMOUT	   364#
ITMSET	   364#
ITRCH1	   470#
ITRCNT	   410#	   792	   821	   825	   833	   834	   838
IWRITE	   364#
JENDIS	 47702#
JOB41	   364#
JOBAPR	   364#
JOBCNI	   364#
JOBDDT	   364#
JOBFF	   364#
JOBOPC	   364#
JOBREL	   364#
JOBREN	   364#
JOBSA	   364#
JOBSYM	   364#
JOBTPC	   364#
JOBUSY	   364#
JOBUUO	   364#
JOBVER	   364#
KA10	   364
KAHZ50	   118#
KAIFLG	   427#
KI10	    35#	   364
KL10	    36#	   364
KL10P0	    37#	   364
KLFLG	   428#	   794	   812	   831
KLOLD	   326
KLTYP	   650#	   793	   804	   846	   848	   862	   864
KNTRP	   364#
KTRP	   364#
LAPRAL	   364#
LAPRP1	   364#	 46004
LAPRP2	   364#	 46025
LAPRP3	   364#	 46046
LAPRP4	   364#	 46067
LAPRP5	   364#	 46088
LAPRP6	   364#	 46110
LAPRP7	   364#	 46131
LAROVT	   364#
LAST	 42938#	 43325	 43326	 43331	 43332	 43360	 43361	 43377	 43378	 43397	 43430	 43448	 43714	 48208
	 48228	 48248	 48268	 48288	 48308	 48328	 48348	 48368	 48388	 48408	 48428	 48448	 48468	 48488
	 48508	 48528	 48548
LCADEN	   364#
LCADRP	   364#
LCASDE	   364#
LCASLD	   364#
LCASLO	   364#
LCASWB	   364#
LCASWD	   364#	 43494	 43563
LCCAER	   364#	 42947
LCCASD	   364#	 42946	 43561
LCHNOF	   364#
LCHNON	   364#
LCIOPF	   364#	 42946	 43576
LCNTRP	   364#	 51098
LCNTXT	   364#
LCNXER	   364#	 42946	 43587
LCPAER	   364#	 42946	 43583
LCPWRF	   364#	 42946	 43568
LCSAER	   364#	 42947
LCSBER	   364#	 42946	 43591
LCSLOA	   364#
LCSLOO	   364#
LCTRP	   364#	 51099
LCWSX	   364#
LDATAF	   364#
LDCAER	   364#	 42947
LDCASD	   364#	 42947	 48020	 48042	 48064	 48086	 48108	 48130	 48152
LDEXCB	   364#
LDIOPF	   364#	 42947	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LDLNK	   129#	   380	   382
LDNXER	   364#	 42947	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LDPAER	   364#	 42947	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LDPWRF	   364#	 42947	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LDSAER	   364#	 42947
LDSBER	   364#	 42946	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LDUSRB	   364#
LEBXMH	   364#
LEBXML	   364#
LECAER	   364#
LECASD	   364#	 46088	 47977
LEIOPF	   364#	 46067	 47976
LENXER	   364#	 46004	 47976
LEPAER	   364#	 46046	 47976
LEPWRF	   364#	 46110	 46131	 47976
LESAER	   364#
LESBER	   364#	 46025	 46305	 46322	 46339	 46356	 46373	 46390	 46407	 47976	 48582	 48622	 48662	 48702
	 48742	 48782	 48822
LEUPFW	   364#
LEVNCD	   364#
LEVNPA	   364#
LEVNPD	   364#
LEXCMP	   364#
LFLGCL	   364#
LFLGDS	   364#
LFLGEN	   364#
LFLGST	   364#
LFP	   567#
LINSTF	   364#
LINT	   364#
LIOCLR	   364#	 42946
LIOPFE	   364#	 43510	 43578
LIP	   364#
LKNTRP	   364#	 51094
LKTRP	   364#	 51095
LLACBL	   364#
LLDUSB	   364#
LLPRCN	   364#
LMBXMH	   364#
LMBXML	   364#
LMUUO	   364#	 51102	 51103	 51118	 51122
LMUUOP	   364#
LNXMEN	   364#
LNXMER	   364#	 43524	 43589
LOOPER	   104#
LPAREN	   364#
LPARER	   364#	 43517	 43585
LPDOVT	   364#
LPFWPC	   364#
LPGFTR	   364#
LPICH1	   364#
LPICH2	   364#
LPICH3	   364#
LPICH4	   364#
LPICH5	   364#
LPICH6	   364#
LPICH7	   364#
LPICHA	   364#
LPICLR	   364#
LPIIP1	   364#
LPIIP2	   364#
LPIIP3	   364#
LPIIP4	   364#
LPIIP5	   364#
LPIIP6	   364#
LPIIP7	   364#
LPIOFF	   364#
LPION	   364#
LPNTRP	   364#	 51100
LPRCH1	   364#
LPRCH2	   364#
LPRCH3	   364#
LPRCH4	   364#
LPRCH5	   364#
LPRCH6	   364#
LPRCH7	   364#
LPRFMH	   364#
LPRFML	   364#
LPTRP	   364#	 51101
LPWRFE	   364#
LPWRFL	   364#	 43502	 43570
LREQSE	   364#
LRQCLR	   364#	 42948	 47724	 47760	 47796	 47832	 47868	 47904	 47940
LSADEN	   364#
LSADRP	   364#
LSBSEN	   364#
LSBUSE	   364#	 43531	 43593
LSCAER	   364#
LSCASD	   364#	 43492	 43560	 46088	 47977	 48020	 48042	 48064	 48086	 48108	 48130	 48152
LSECMO	   364#
LSIOPF	   364#	 43508	 43575	 46067	 47976	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LSMODE	   364#
LSNTRP	   364#	 51096
LSNXER	   364#	 43522	 43586	 46004	 47976	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LSPAER	   364#	 43515	 43582	 46046	 47976	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LSPWRF	   364#	 43500	 43567	 46110	 46131	 47976	 48019	 48041	 48063	 48085	 48107	 48129	 48151
LSSAER	   364#
LSSBER	   364#	 43529	 43590	 46025	 46305	 46322	 46339	 46356	 46373	 46390	 46407	 47976	 48019	 48041
	 48063	 48085	 48107	 48129	 48151	 48582	 48622	 48662	 48702	 48742	 48782	 48822
LSTRP	   364#	 51097
LTBASH	   364#
LTBASL	   364#
LTRP3T	   364#
LTRPAE	   364#
LTRPEN	   364#
LUSCMP	   364#
LUUO	   364#
LUUO1	   497	   498
LUUO10	   497	   502
LUUO11	   497	   502
LUUO12	   497	   503
LUUO13	   497	   503
LUUO14	   497	   504
LUUO15	   497	   504
LUUO16	   497	   505
LUUO17	   497	   505
LUUO2	   497	   499
LUUO20	   497	   506
LUUO21	   497	   506
LUUO22	   497	   507
LUUO23	   497	   507
LUUO24	   497	   508
LUUO25	   497	   508
LUUO26	   497	   509
LUUO27	   497	   509
LUUO3	   497	   499
LUUO30	   497	   510
LUUO31	   497	   510
LUUO32	   497	   511
LUUO33	   497	   511
LUUO4	   497	   500
LUUO5	   497	   500
LUUO6	   497	   501
LUUO7	   497	   501
LUUOI	   364#
LWRITE	   364#
MACHTP	 51284#	 51301	 51302	 51303	 51304	 51305	 51306	 51307	 51308
MAPNEW	   518#
MARGIN	   440#	 43685
MCNVER	     4#	    11	    26	   412
MEMLOW	   520#
MEMMAP	   418
MEMSIZ	   521#
MEMTOT	   519#
MINUS	   562#
MLUUO	 48864#	 48905#	 48946#	 48987#	 49028#	 49069#	 49110#	 49151#	 49192#	 49233#	 49274#	 49315#	 49356#	 49397#
	 49438#	 49479#	 49520#	 49561#	 49602#	 49643#	 49684#	 49725#	 49766#	 49807#	 49848#	 49889#	 49930#	 49971#
	 50012#	 50053#	 50094#
MODDVC	   112#
MODDVL	    39#	   311	   413
MODDVU	    40#	   312	   414
MODLNK	   131#	   377
MONCTL	   430#	   841	   879
MONFLG	   429#	   786	   875	 42929	 46011	 46032	 46053	 46074	 46095	 46117	 46138	 46170	 46188	 46206
	 46224	 46242	 46260	 46278	 46312	 46329	 46346	 46363	 46380	 46397	 46414	 46440	 46477	 46514
	 46551	 46588	 46625	 46662	 46699	 46736	 46773	 46810	 46847	 46884	 46921	 46958	 46995	 47032
	 47069	 47106	 47143	 47180	 51144	 51159	 51254
MONTEN	   431#	   791	   827	   856
MONTYP	   644#
MPVU	   364#
MUHLT	 51104	 51110#
MULT0	 46403	 46413#
MULT1	 46386	 46396#
MULT2	 46369	 46379#
MULT3	 46352	 46362#
MULT4	 46335	 46345#
MULT5	 46318	 46328#
MULT6	 46301	 46311#
MULTI	 46296#
MUUO	   364#
MUUOPC	   364#
NB5300	 19133#
NOPNT	   100#
NXMU	   364#
OPRSEL	   114#
OPTIME	   532#
P	   157	   158	   159	   160	   364#	   452
PAG	   364#
PALERS	   106#
PARCLR	   364#
PARDIS	   364#
PAREA0	    78#
PAREA1	    79#	   408
PAREA2	    80#	   409
PAREA3	    81#	   406
PAREA4	    82#	   407
PAREA5	    83#	   419
PAREA6	    84#	   420
PAREA7	   419#
PAREA8	   420#
PARENB	   364#
PARU	   364#
PASCNT	   434#	   820
PDISF	   529#
PDLOVU	   364#
PDOVTP	   364#
PERIOD	   559#
PFSTRT	   386#
PGFTRP	   364#
PGMEND	    38#	 51916
PGMNAM	   411	   880	   883#
PI	   833	 42948	 43456	 43731	 43738	 43739	 43745	 43746	 43747	 43767	 43768	 43774	 43775	 43782
	 43783	 43789	 43790	 43791	 43796	 43797	 43803	 43804	 43805	 43811	 43812	 43818	 43819	 43820
	 43826	 43827	 43833	 43834	 43835	 43841	 43842	 43848	 43849	 43850	 43856	 43857	 43863	 43864
	 43865	 43895	 43899	 43923	 43927	 43951	 43955	 43979	 43983	 44007	 44011	 44035	 44039	 44063
	 44067	 44110	 44114	 44142	 44146	 44174	 44178	 44206	 44210	 44238	 44242	 44270	 44274	 44302
	 44306	 44358	 44360	 44400	 44402	 44442	 44444	 44484	 44486	 44526	 44528	 44568	 44570	 44610
	 44612	 44654	 44655	 44675	 44676	 44677	 44697	 44698	 44699	 44719	 44720	 44740	 44741	 44742
	 44765	 44766	 44786	 44787	 44788	 44808	 44809	 44810	 44830	 44831	 44851	 44852	 44853	 44876
	 44877	 44897	 44898	 44899	 44919	 44920	 44921	 44941	 44942	 44962	 44963	 44964	 44987	 44988
	 45008	 45009	 45010	 45030	 45031	 45032	 45052	 45053	 45073	 45074	 45075	 45098	 45099	 45119
	 45120	 45121	 45141	 45142	 45143	 45163	 45164	 45184	 45185	 45186	 45209	 45210	 45230	 45231
	 45232	 45252	 45253	 45254	 45274	 45275	 45295	 45296	 45297	 45320	 45321	 45341	 45342	 45343
	 45363	 45364	 45365	 45385	 45386	 45406	 45407	 45408	 45431	 45432	 45452	 45453	 45454	 45474
	 45475	 45476	 45496	 45497	 45517	 45518	 45519	 45542	 45543	 45563	 45564	 45565	 45585	 45586
	 45587	 45607	 45608	 45628	 45629	 45630	 45653	 45654	 45674	 45675	 45676	 45696	 45697	 45698
	 45718	 45719	 45739	 45740	 45741	 45783	 45787	 45788	 45814	 45818	 45819	 45845	 45849	 45850
	 45876	 45880	 45881	 45907	 45911	 45912	 45938	 45942	 45943	 45969	 45973	 45974	 46003	 46024
	 46045	 46066	 46087	 46109	 46130	 46162	 46180	 46198	 46216	 46234	 46252	 46270	 46303	 46320
	 46337	 46354	 46371	 46388	 46405	 46450	 46451	 46487	 46488	 46524	 46525	 46561	 46562	 46598
	 46599	 46635	 46636	 46672	 46673	 46709	 46710	 46746	 46747	 46783	 46784	 46820	 46821	 46857
	 46858	 46894	 46895	 46931	 46932	 46968	 46969	 47005	 47006	 47042	 47043	 47079	 47080	 47116
	 47117	 47153	 47154	 47190	 47191	 47235	 47267	 47303	 47335	 47371	 47403	 47439	 47471	 47507
	 47539	 47575	 47607	 47643	 47675	 47719	 47724	 47726	 47755	 47760	 47762	 47791	 47796	 47798
	 47827	 47832	 47834	 47863	 47868	 47870	 47899	 47904	 47906	 47935	 47940	 47942	 47975	 48018
	 48040	 48062	 48084	 48106	 48128	 48150	 48168	 48170	 48180	 48206	 48209	 48226	 48229	 48246
	 48249	 48266	 48269	 48286	 48289	 48306	 48309	 48326	 48329	 48346	 48349	 48366	 48369	 48386
	 48389	 48406	 48409	 48426	 48429	 48446	 48449	 48466	 48469	 48486	 48489	 48506	 48509	 48526
	 48529	 48546	 48549	 48581	 48621	 48661	 48701	 48741	 48781	 48821
PICHN1	   364#
PICHN2	   364#
PICHN3	   364#
PICHN4	   364#
PICHN5	   364#
PICHN6	   364#
PICHN7	   364#
PICHNA	   364#
PICLR	   364#	 42948	 44360	 44402	 44444	 44486	 44528	 44570	 44612	 44698	 44809	 44920	 45031	 45142
	 45253	 45364	 45475	 45586	 45697	 45787	 45818	 45849	 45880	 45911	 45942	 45973	 48180
PIOFF	   364#	 42948
PION	   364#	 43895	 43923	 43951	 43979	 44007	 44035	 44063	 45783	 45814	 45845	 45876	 45907	 45938
	 45969	 46303	 46320	 46337	 46354	 46371	 46388	 46405	 46450	 46487	 46524	 46561	 46598	 46635
	 46672	 46709	 46746	 46783	 46820	 46857	 46894	 46931	 46968	 47005	 47042	 47079	 47116	 47153
	 47190	 47235	 47267	 47303	 47335	 47371	 47403	 47439	 47471	 47507	 47539	 47575	 47607	 47643
	 47675	 47719	 47724	 47755	 47760	 47791	 47796	 47827	 47832	 47863	 47868	 47899	 47904	 47935
	 47940	 47975	 48018	 48040	 48062	 48084	 48106	 48128	 48150	 48168	 48170	 48206	 48226	 48246
	 48266	 48286	 48306	 48326	 48346	 48366	 48386	 48406	 48426	 48446	 48466	 48486	 48506	 48526
	 48546
PIOT00	 43880#
PIOT01	 44090#
PIOT02	 44330#
PIOT03	 45766#
PLIST	   598#	   598
PLISTE	   598	   600#
PLISTS	   599#
PLUS	   564#
PNTENB	   528#
PNTEXT	   407#
PNTFLG	   527#
PNTINH	   530#
PNTLPT	   101#
PNTNAM	   406#
PNTRP	   364#
PNTSPC	   531#
PTRP	   364#
PVPAGI	   625#
PWFCLR	   364#
QUEST	   570#
RADIX	   573#
RADLSC	   575#
RADLSP	   574#
RANDBS	   408#
REENTR	   388#
RELIAB	   108#
REPT	   364#
REPT1	   364#
REPTU	   486#
REQSET	   364#	 44110	 44142	 44174	 44206	 44238	 44270	 44302	 44358	 44400	 44442	 44484	 44526	 44568
	 44610	 45783	 45814	 45845	 45876	 45907	 45938	 45969	 46451	 46488	 46525	 46562	 46599	 46636
	 46673	 46710	 46747	 46784	 46821	 46858	 46895	 46932	 46969	 47006	 47043	 47080	 47117	 47154
	 47191	 47235	 47267	 47303	 47335	 47371	 47403	 47439	 47471	 47507	 47539	 47575	 47607	 47643
	 47675	 47719	 47755	 47791	 47827	 47863	 47899	 47935
RESET1	 48165#
RESET2	 48176#
RESET3	 48187#
RESRT1	   463#
RESRT2	   464#
RETURN	   395#	   829	   836	   857
RSTART	    97#
RTP	   568#
RUNFLG	   435#
SADR1	    66#	   384
SADR10	    75#	   400
SADR11	    76#	   401
SADR2	    67#	   386
SADR3	    68#	   388
SADR4	    69#
SADR5	    70#	   449
SADR6	    71#	   450
SADR7	    72#	   397
SADR8	    73#	   398
SADR9	    74#	   399
SBINIT	   170	   394#
SCOPE	   487#
SENSE1	   364#
SENSE2	   364#
SENSE3	   364#
SENSE4	   364#
SENSE5	   364#
SENSE6	   364#
SFSTRT	   384#
SKIPNO	 47214#
SLASH	   571#
SM10	   681#
SMLUSR	   364#
SN	  1304#	  1329	  1329#	  1348	  1348#	  1367	  1367#	  1386	  1386#	  1405	  1405#	  1424	  1424#	  1443
	  1443#	  1462	  1462#	  1481	  1481#	  1500	  1500#	  1519	  1519#	  1538	  1538#	  1557	  1557#	  1576
	  1576#	  1595	  1595#	  1614	  1614#	  1633	  1633#	  1652	  1652#	  1671	  1671#	  1690	  1690#	  1709
	  1709#	  1728	  1728#	  1747	  1747#	  1766	  1766#	  1785	  1785#	  1804	  1804#	  1823	  1823#	  1842
	  1842#	  1861	  1861#	  1880	  1880#	  1899	  1899#	  1918	  1918#	  1937	  1937#	  1956	  1956#	  1975
	  1975#	  1994	  1994#	  2183#	  2216	  2216#	  2245	  2245#	  2274	  2274#	  2303	  2303#	  2480#	  2504
	  2504#	  2523	  2523#	  2542	  2542#	  2561	  2561#	  2580	  2580#	  2599	  2599#	  2618	  2618#	  2637
	  2637#	  2656	  2656#	  2675	  2675#	  2694	  2694#	  2713	  2713#	  2732	  2732#	  2751	  2751#	  2770
	  2770#	  2789	  2789#	  2808	  2808#	  2827	  2827#	  2841#	  2865	  2865#	  2884	  2884#	  2903	  2903#
	  2922	  2922#	  2941	  2941#	  2960	  2960#	  2979	  2979#	  2998	  2998#	  3017	  3017#	  3036	  3036#
	  3055	  3055#	  3074	  3074#	  3093	  3093#	  3112	  3112#	  3131	  3131#	  3150	  3150#	  3169	  3169#
	  3188	  3188#	  3292#	  3325	  3325#	  3354	  3354#	  3383	  3383#	  3412	  3412#	  3441	  3441#	  3470
	  3470#	  3499	  3499#	  3528	  3528#	  3557	  3557#	  3586	  3586#	  3615	  3615#	  3644	  3644#	  3673
	  3673#	  3702	  3702#	  3731	  3731#	  3760	  3760#	  3789	  3789#	  3818	  3818#	  3847	  3847#	  3876
	  3876#	  3905	  3905#	  3934	  3934#	  3963	  3963#	  3992	  3992#	  4021	  4021#	  4050	  4050#	  4079
	  4079#	  4108	  4108#	  4137	  4137#	  4166	  4166#	  4195	  4195#	  4224	  4224#	  4253	  4253#	  4282
	  4282#	  4311	  4311#	  4340	  4340#	  4361#	  4387	  4387#	  4408	  4408#	  4429	  4429#	  4450	  4450#
	  4471	  4471#	  4492	  4492#	  4513	  4513#	  4534	  4534#	  4555	  4555#	  4576	  4576#	  4597	  4597#
	  4618	  4618#	  4639	  4639#	  4660	  4660#	  4681	  4681#	  4702	  4702#	  4723	  4723#	  4744	  4744#
	  4765	  4765#	  4786	  4786#	  4807	  4807#	  4828	  4828#	  4849	  4849#	  4870	  4870#	  4891	  4891#
	  4912	  4912#	  4933	  4933#	  4954	  4954#	  4975	  4975#	  4996	  4996#	  5017	  5017#	  5038	  5038#
	  5059	  5059#	  5080	  5080#	  5101	  5101#	  5122	  5122#	  5226#	  5251	  5251#	  5271	  5271#	  5291
	  5291#	  5311	  5311#	  5331	  5331#	  5351	  5351#	  5371	  5371#	  5391	  5391#	  5411	  5411#	  5431
	  5431#	  5451	  5451#	  5471	  5471#	  5491	  5491#	  5511	  5511#	  5531	  5531#	  5551	  5551#	  5571
	  5571#	  5591	  5591#	  5611	  5611#	  5631	  5631#	  5651	  5651#	  5671	  5671#	  5691	  5691#	  5711
	  5711#	  5731	  5731#	  5751	  5751#	  5771	  5771#	  5791	  5791#	  5811	  5811#	  5831	  5831#	  5851
	  5851#	  5871	  5871#	  5891	  5891#	  5911	  5911#	  5931	  5931#	  5951	  5951#	  5966#	  5996	  5996#
	  6021	  6021#	  6046	  6046#	  6071	  6071#	  6096	  6096#	  6121	  6121#	  6146	  6146#	  6171	  6171#
	  6196	  6196#	  6221	  6221#	  6246	  6246#	  6271	  6271#	  6296	  6296#	  6321	  6321#	  6346	  6346#
	  6371	  6371#	  6396	  6396#	  6421	  6421#	  6446	  6446#	  6471	  6471#	  6496	  6496#	  6521	  6521#
	  6546	  6546#	  6571	  6571#	  6596	  6596#	  6621	  6621#	  6646	  6646#	  6671	  6671#	  6696	  6696#
	  6721	  6721#	  6746	  6746#	  6771	  6771#	  6796	  6796#	  6821	  6821#	  6846	  6846#	  6871	  6871#
	  6891#	  6919	  6919#	  6940	  6940#	  6961	  6961#	  6982	  6982#	  7003	  7003#	  7024	  7024#	  7045
	  7045#	  7066	  7066#	  7087	  7087#	  7108	  7108#	  7129	  7129#	  7150	  7150#	  7171	  7171#	  7192
	  7192#	  7213	  7213#	  7234	  7234#	  7255	  7255#	  7276	  7276#	  7297	  7297#	  7318	  7318#	  7339
	  7339#	  7360	  7360#	  7381	  7381#	  7402	  7402#	  7423	  7423#	  7444	  7444#	  7465	  7465#	  7486
	  7486#	  7507	  7507#	  7528	  7528#	  7549	  7549#	  7570	  7570#	  7591	  7591#	  7612	  7612#	  7633
	  7633#	  7654	  7654#	  7700#	  7729	  7729#	  7751	  7751#	  7773	  7773#	  7795	  7795#	  7817	  7817#
	  7839	  7839#	  7861	  7861#	  7883	  7883#	  7905	  7905#	  7927	  7927#	  7949	  7949#	  7971	  7971#
	  7993	  7993#	  8015	  8015#	  8037	  8037#	  8059	  8059#	  8081	  8081#	  8103	  8103#	  8118#	  8147
	  8147#	  8169	  8169#	  8191	  8191#	  8213	  8213#	  8235	  8235#	  8257	  8257#	  8279	  8279#	  8301
	  8301#	  8323	  8323#	  8345	  8345#	  8367	  8367#	  8389	  8389#	  8411	  8411#	  8433	  8433#	  8455
	  8455#	  8477	  8477#	  8499	  8499#	  8521	  8521#	  8575#	  8607	  8607#	  8631	  8631#	  8655	  8655#
	  8679	  8679#	  8703	  8703#	  8727	  8727#	  8751	  8751#	  8775	  8775#	  8799	  8799#	  8823	  8823#
	  8847	  8847#	  8871	  8871#	  8895	  8895#	  8919	  8919#	  8943	  8943#	  8967	  8967#	  8991	  8991#
	  9015	  9015#	  9039	  9039#	  9063	  9063#	  9087	  9087#	  9111	  9111#	  9135	  9135#	  9159	  9159#
	  9183	  9183#	  9207	  9207#	  9231	  9231#	  9255	  9255#	  9279	  9279#	  9303	  9303#	  9327	  9327#
	  9351	  9351#	  9375	  9375#	  9399	  9399#	  9423	  9423#	  9447	  9447#	  9586#	  9626	  9626#	  9656
	  9656#	  9686	  9686#	  9716	  9716#	  9746	  9746#	  9776	  9776#	  9806	  9806#	  9836	  9836#	  9866
	  9866#	  9896	  9896#	  9926	  9926#	  9956	  9956#	  9986	  9986#	 10016	 10016#	 10046	 10046#	 10076
	 10076#	 10106	 10106#	 10136	 10136#	 10166	 10166#	 10196	 10196#	 10226	 10226#	 10256	 10256#	 10286
	 10286#	 10316	 10316#	 10346	 10346#	 10376	 10376#	 10406	 10406#	 10436	 10436#	 10466	 10466#	 10496
	 10496#	 10526	 10526#	 10556	 10556#	 10586	 10586#	 10616	 10616#	 10646	 10646#	 10676	 10676#	 10718#
	 10754	 10754#	 10780	 10780#	 10806	 10806#	 10832	 10832#	 10858	 10858#	 10884	 10884#	 10910	 10910#
	 10936	 10936#	 10962	 10962#	 10988	 10988#	 11014	 11014#	 11040	 11040#	 11066	 11066#	 11092	 11092#
	 11118	 11118#	 11144	 11144#	 11170	 11170#	 11196	 11196#	 11222	 11222#	 11248	 11248#	 11274	 11274#
	 11300	 11300#	 11326	 11326#	 11352	 11352#	 11378	 11378#	 11404	 11404#	 11430	 11430#	 11456	 11456#
	 11482	 11482#	 11508	 11508#	 11534	 11534#	 11560	 11560#	 11586	 11586#	 11612	 11612#	 11638	 11638#
	 11664	 11664#	 11683#	 11717	 11717#	 11742	 11742#	 11767	 11767#	 11792	 11792#	 11817	 11817#	 11842
	 11842#	 11867	 11867#	 11892	 11892#	 11917	 11917#	 11942	 11942#	 11967	 11967#	 11992	 11992#	 12017
	 12017#	 12042	 12042#	 12067	 12067#	 12092	 12092#	 12117	 12117#	 12142	 12142#	 12167	 12167#	 12192
	 12192#	 12217	 12217#	 12242	 12242#	 12267	 12267#	 12292	 12292#	 12317	 12317#	 12342	 12342#	 12367
	 12367#	 12392	 12392#	 12417	 12417#	 12442	 12442#	 12467	 12467#	 12492	 12492#	 12517	 12517#	 12542
	 12542#	 12567	 12567#	 12583#	 12619	 12619#	 12645	 12645#	 12671	 12671#	 12697	 12697#	 12723	 12723#
	 12749	 12749#	 12775	 12775#	 12801	 12801#	 12827	 12827#	 12853	 12853#	 12879	 12879#	 12905	 12905#
	 12931	 12931#	 12957	 12957#	 12983	 12983#	 13009	 13009#	 13035	 13035#	 13061	 13061#	 13079#	 13115
	 13115#	 13141	 13141#	 13167	 13167#	 13193	 13193#	 13219	 13219#	 13245	 13245#	 13271	 13271#	 13297
	 13297#	 13323	 13323#	 13349	 13349#	 13375	 13375#	 13401	 13401#	 13427	 13427#	 13453	 13453#	 13479
	 13479#	 13505	 13505#	 13531	 13531#	 13557	 13557#	 13794#	 13816	 13816#	 13834	 13834#	 13852	 13852#
	 13870	 13870#	 13888	 13888#	 13906	 13906#	 13924	 13924#	 13942	 13942#	 13960	 13960#	 13978	 13978#
	 13996	 13996#	 14014	 14014#	 14032	 14032#	 14050	 14050#	 14068	 14068#	 14086	 14086#	 14104	 14104#
	 14122	 14122#	 14140	 14140#	 14158	 14158#	 14176	 14176#	 14194	 14194#	 14212	 14212#	 14230	 14230#
	 14248	 14248#	 14266	 14266#	 14284	 14284#	 14302	 14302#	 14320	 14320#	 14338	 14338#	 14356	 14356#
	 14374	 14374#	 14392	 14392#	 14410	 14410#	 14428	 14428#	 14446	 14446#	 14815#	 14849	 14849#	 14876
	 14876#	 14903	 14903#	 14930	 14930#	 14957	 14957#	 14984	 14984#	 15011	 15011#	 15038	 15038#	 15065
	 15065#	 15092	 15092#	 15119	 15119#	 15146	 15146#	 15173	 15173#	 15200	 15200#	 15227	 15227#	 15254
	 15254#	 15281	 15281#	 15308	 15308#	 15355	 15355#	 15377	 15377#	 15399	 15399#	 15421	 15421#	 15443
	 15443#	 15465	 15465#	 15487	 15487#	 15509	 15509#	 15531	 15531#	 15553	 15553#	 15575	 15575#	 15597
	 15597#	 15619	 15619#	 15641	 15641#	 15663	 15663#	 15685	 15685#	 15707	 15707#	 15729	 15729#	 15743#
	 15765	 15765#	 15783	 15783#	 15801	 15801#	 15819	 15819#	 15837	 15837#	 15855	 15855#	 15873	 15873#
	 15891	 15891#	 15909	 15909#	 15927	 15927#	 15945	 15945#	 15963	 15963#	 15981	 15981#	 15999	 15999#
	 16017	 16017#	 16035	 16035#	 16053	 16053#	 16071	 16071#	 16089	 16089#	 16107	 16107#	 16125	 16125#
	 16143	 16143#	 16161	 16161#	 16179	 16179#	 16197	 16197#	 16215	 16215#	 16233	 16233#	 16251	 16251#
	 16269	 16269#	 16287	 16287#	 16305	 16305#	 16323	 16323#	 16341	 16341#	 16359	 16359#	 16377	 16377#
	 16395	 16395#	 16408#	 16430	 16430#	 16448	 16448#	 16466	 16466#	 16484	 16484#	 16502	 16502#	 16520
	 16520#	 16538	 16538#	 16556	 16556#	 16574	 16574#	 16592	 16592#	 16610	 16610#	 16628	 16628#	 16646
	 16646#	 16664	 16664#	 16682	 16682#	 16700	 16700#	 16718	 16718#	 16736	 16736#	 16754	 16754#	 16772
	 16772#	 16790	 16790#	 16808	 16808#	 16826	 16826#	 16844	 16844#	 16862	 16862#	 16880	 16880#	 16898
	 16898#	 16916	 16916#	 16934	 16934#	 16952	 16952#	 16970	 16970#	 16988	 16988#	 17006	 17006#	 17024
	 17024#	 17042	 17042#	 17060	 17060#	 17077#	 17102	 17102#	 17122	 17122#	 17142	 17142#	 17162	 17162#
	 17182	 17182#	 17202	 17202#	 17222	 17222#	 17242	 17242#	 17262	 17262#	 17282	 17282#	 17302	 17302#
	 17322	 17322#	 17342	 17342#	 17362	 17362#	 17382	 17382#	 17402	 17402#	 17422	 17422#	 17442	 17442#
	 17456#	 17481	 17481#	 17501	 17501#	 17521	 17521#	 17541	 17541#	 17561	 17561#	 17581	 17581#	 17601
	 17601#	 17621	 17621#	 17641	 17641#	 17661	 17661#	 17681	 17681#	 17701	 17701#	 17721	 17721#	 17741
	 17741#	 17761	 17761#	 17781	 17781#	 17801	 17801#	 17821	 17821#	 17835#	 17869	 17869#	 17894	 17894#
	 17919	 17919#	 17944	 17944#	 17969	 17969#	 17994	 17994#	 18019	 18019#	 18044	 18044#	 18069	 18069#
	 18094	 18094#	 18119	 18119#	 18144	 18144#	 18169	 18169#	 18194	 18194#	 18219	 18219#	 18244	 18244#
	 18269	 18269#	 18294	 18294#	 18310#	 18344	 18344#	 18369	 18369#	 18394	 18394#	 18419	 18419#	 18444
	 18444#	 18469	 18469#	 18494	 18494#	 18519	 18519#	 18544	 18544#	 18569	 18569#	 18594	 18594#	 18619
	 18619#	 18644	 18644#	 18669	 18669#	 18694	 18694#	 18719	 18719#	 18744	 18744#	 18769	 18769#	 22969#
	 22994	 22994#	 23014	 23014#	 23034	 23034#	 23054	 23054#	 23074	 23074#	 23094	 23094#	 23114	 23114#
	 23134	 23134#	 23154	 23154#	 23174	 23174#	 23194	 23194#	 23214	 23214#	 23234	 23234#	 23254	 23254#
	 23274	 23274#	 23294	 23294#	 23314	 23314#	 23334	 23334#	 23373	 23373#	 23393	 23393#	 23413	 23413#
	 23433	 23433#	 23453	 23453#	 23473	 23473#	 23493	 23493#	 23513	 23513#	 23533	 23533#	 23553	 23553#
	 23573	 23573#	 23593	 23593#	 23613	 23613#	 23633	 23633#	 23653	 23653#	 23673	 23673#	 23693	 23693#
	 23713	 23713#	 23731#	 23754	 23754#	 23774	 23774#	 23794	 23794#	 23814	 23814#	 23834	 23834#	 23854
	 23854#	 23874	 23874#	 23894	 23894#	 23914	 23914#	 23934	 23934#	 23954	 23954#	 23974	 23974#	 23994
	 23994#	 24014	 24014#	 24034	 24034#	 24054	 24054#	 24074	 24074#	 24094	 24094#	 24133	 24133#	 24153
	 24153#	 24173	 24173#	 24193	 24193#	 24213	 24213#	 24233	 24233#	 24253	 24253#	 24273	 24273#	 24293
	 24293#	 24313	 24313#	 24333	 24333#	 24353	 24353#	 24373	 24373#	 24393	 24393#	 24413	 24413#	 24433
	 24433#	 24453	 24453#	 24473	 24473#	 24491#	 24518	 24518#	 24539	 24539#	 24560	 24560#	 24581	 24581#
	 24602	 24602#	 24623	 24623#	 24644	 24644#	 24665	 24665#	 24686	 24686#	 24707	 24707#	 24728	 24728#
	 24749	 24749#	 24770	 24770#	 24791	 24791#	 24812	 24812#	 24833	 24833#	 24854	 24854#	 24874	 24874#
	 24913	 24913#	 24934	 24934#	 24955	 24955#	 24976	 24976#	 24997	 24997#	 25018	 25018#	 25039	 25039#
	 25060	 25060#	 25081	 25081#	 25102	 25102#	 25123	 25123#	 25144	 25144#	 25165	 25165#	 25186	 25186#
	 25207	 25207#	 25228	 25228#	 25249	 25249#	 25269	 25269#	 25286#	 25313	 25313#	 25334	 25334#	 25355
	 25355#	 25376	 25376#	 25397	 25397#	 25418	 25418#	 25439	 25439#	 25460	 25460#	 25481	 25481#	 25502
	 25502#	 25523	 25523#	 25544	 25544#	 25565	 25565#	 25586	 25586#	 25607	 25607#	 25628	 25628#	 25649
	 25649#	 25670	 25670#	 25709	 25709#	 25730	 25730#	 25751	 25751#	 25772	 25772#	 25793	 25793#	 25814
	 25814#	 25835	 25835#	 25856	 25856#	 25877	 25877#	 25898	 25898#	 25919	 25919#	 25940	 25940#	 25961
	 25961#	 25982	 25982#	 26003	 26003#	 26024	 26024#	 26045	 26045#	 26066	 26066#	 26147#	 26213	 26213#
	 26231	 26231#	 26249	 26249#	 26267	 26267#	 26285	 26285#	 26303	 26303#	 26321	 26321#	 26339	 26339#
	 26357	 26357#	 26375	 26375#	 26393	 26393#	 26411	 26411#	 26429	 26429#	 26447	 26447#	 26465	 26465#
	 26483	 26483#	 26495#	 26577	 26577#	 26596	 26596#	 26615	 26615#	 26634	 26634#	 26653	 26653#	 26672
	 26672#	 26691	 26691#	 26710	 26710#	 26729	 26729#	 26748	 26748#	 26767	 26767#	 26786	 26786#	 26805
	 26805#	 26824	 26824#	 26843	 26843#	 26855#	 26878	 26878#	 26896	 26896#	 26914	 26914#	 26932	 26932#
	 26950	 26950#	 26968	 26968#	 26986	 26986#	 27004	 27004#	 27022	 27022#	 27040	 27040#	 27058	 27058#
	 27076	 27076#	 27094	 27094#	 27112	 27112#	 27130	 27130#	 27142#	 27170	 27170#	 27191	 27191#	 27212
	 27212#	 27233	 27233#	 27254	 27254#	 27275	 27275#	 27296	 27296#	 27317	 27317#	 27338	 27338#	 27359
	 27359#	 27380	 27380#	 27401	 27401#	 27422	 27422#	 27443	 27443#	 27464	 27464#	 27500#	 27531	 27531#
	 27555	 27555#	 27579	 27579#	 27603	 27603#	 27627	 27627#	 27651	 27651#	 27675	 27675#	 27699	 27699#
	 27723	 27723#	 27747	 27747#	 27771	 27771#	 27795	 27795#	 27819	 27819#	 27843	 27843#	 27867	 27867#
	 27891	 27891#	 27915	 27915#	 27939	 27939#	 27955#	 27986	 27986#	 28010	 28010#	 28034	 28034#	 28058
	 28058#	 28082	 28082#	 28106	 28106#	 28130	 28130#	 28154	 28154#	 28178	 28178#	 28202	 28202#	 28226
	 28226#	 28250	 28250#	 28274	 28274#	 28298	 28298#	 28322	 28322#	 28346	 28346#	 28370	 28370#	 28394
	 28394#	 28429#	 28460	 28460#	 28484	 28484#	 28508	 28508#	 28532	 28532#	 28556	 28556#	 28580	 28580#
	 28604	 28604#	 28628	 28628#	 28652	 28652#	 28676	 28676#	 28700	 28700#	 28724	 28724#	 28748	 28748#
	 28772	 28772#	 28796	 28796#	 28820	 28820#	 28844	 28844#	 28868	 28868#	 28884#	 28915	 28915#	 28939
	 28939#	 28963	 28963#	 28987	 28987#	 29011	 29011#	 29035	 29035#	 29059	 29059#	 29083	 29083#	 29107
	 29107#	 29131	 29131#	 29155	 29155#	 29179	 29179#	 29203	 29203#	 29227	 29227#	 29251	 29251#	 29275
	 29275#	 29299	 29299#	 29323	 29323#	 29341#	 29363	 29363#	 29377	 29377#	 29391	 29391#	 29405	 29405#
	 29419	 29419#	 29433	 29433#	 29447	 29447#	 29461	 29461#	 29475	 29475#	 29489	 29489#	 29503	 29503#
	 29517	 29517#	 29531	 29531#	 29545	 29545#	 29559	 29559#	 29574#	 29595	 29595#	 29609	 29609#	 29623
	 29623#	 29637	 29637#	 29651	 29651#	 29665	 29665#	 29679	 29679#	 29693	 29693#	 29707	 29707#	 29721
	 29721#	 29735	 29735#	 29749	 29749#	 29763	 29763#	 29777	 29777#	 29791	 29791#
SNTRP	   364#
SPACE	   560#
SRTDDT	   390#
START	   378	   789	   798	   813	   817	   871#
START1	   397#
START2	   398#
START3	   399#
START4	   400#
START5	   401#
STARTA	    66	    67	    68	    69	    70	    71	    72	    73	    74	    75	    76	   393	   815	   826
	   835	   842	   852	   878	   881	   904#
STRP	   364#
SUBLNK	   132#	   394
SWPTAB	   687#
SWTEXR	   409#
SYSEXR	   382#
TAB	   561#
TABLE	 51293#	 51314
TESTPC	   436#
TICKS	   439#
TN0	   364#
TN1	   364#
TNUMB	 43341#	 43341	 43350	 43359#	 43359	 43367	 43376#	 43376	 43386	 43395#	 43395	 43406	 43415#	 43415
	 43419	 43428#	 43428	 43437	 43446#	 43446	 43599	 43608#	 43608	 43618	 43627#	 43627	 43636	 43645#
	 43645	 43654	 43663#	 43663	 43702	 43711#	 43711	 43721	 43891#	 43891	 43904	 43919#	 43919	 43932
	 43947#	 43947	 43960	 43975#	 43975	 43988	 44003#	 44003	 44016	 44031#	 44031	 44044	 44059#	 44059
	 44072	 44106#	 44106	 44119	 44138#	 44138	 44151	 44170#	 44170	 44183	 44202#	 44202	 44215	 44234#
	 44234	 44247	 44266#	 44266	 44279	 44298#	 44298	 44311	 44354#	 44354	 44369	 44396#	 44396	 44411
	 44438#	 44438	 44453	 44480#	 44480	 44495	 44522#	 44522	 44537	 44564#	 44564	 44579	 44606#	 44606
	 44621	 44650#	 44650	 44661	 44670#	 44670	 44683	 44692#	 44692	 44705	 44714#	 44714	 44726	 44735#
	 44735	 44747	 44761#	 44761	 44772	 44781#	 44781	 44794	 44803#	 44803	 44816	 44825#	 44825	 44837
	 44846#	 44846	 44858	 44872#	 44872	 44883	 44892#	 44892	 44905	 44914#	 44914	 44927	 44936#	 44936
	 44948	 44957#	 44957	 44969	 44983#	 44983	 44994	 45003#	 45003	 45016	 45025#	 45025	 45038	 45047#
	 45047	 45059	 45068#	 45068	 45080	 45094#	 45094	 45105	 45114#	 45114	 45127	 45136#	 45136	 45149
	 45158#	 45158	 45170	 45179#	 45179	 45191	 45205#	 45205	 45216	 45225#	 45225	 45238	 45247#	 45247
	 45260	 45269#	 45269	 45281	 45290#	 45290	 45302	 45316#	 45316	 45327	 45336#	 45336	 45349	 45358#
	 45358	 45371	 45380#	 45380	 45392	 45401#	 45401	 45413	 45427#	 45427	 45438	 45447#	 45447	 45460
	 45469#	 45469	 45482	 45491#	 45491	 45503	 45512#	 45512	 45524	 45538#	 45538	 45549	 45558#	 45558
	 45571	 45580#	 45580	 45593	 45602#	 45602	 45614	 45623#	 45623	 45635	 45649#	 45649	 45660	 45669#
	 45669	 45682	 45691#	 45691	 45704	 45713#	 45713	 45725	 45734#	 45734	 45746	 45779#	 45779	 45793
	 45810#	 45810	 45824	 45841#	 45841	 45855	 45872#	 45872	 45886	 45903#	 45903	 45917	 45934#	 45934
	 45948	 45965#	 45965	 45979	 46432#	 46432	 46460	 46469#	 46469	 46497	 46506#	 46506	 46534	 46543#
	 46543	 46571	 46580#	 46580	 46608	 46617#	 46617	 46645	 46654#	 46654	 46682	 46691#	 46691	 46719
	 46728#	 46728	 46756	 46765#	 46765	 46793	 46802#	 46802	 46830	 46839#	 46839	 46867	 46876#	 46876
	 46904	 46913#	 46913	 46941	 46950#	 46950	 46978	 46987#	 46987	 47015	 47024#	 47024	 47052	 47061#
	 47061	 47089	 47098#	 47098	 47126	 47135#	 47135	 47163	 47172#	 47172	 47200	 47716#	 47716	 47731
	 47752#	 47752	 47767	 47788#	 47788	 47803	 47824#	 47824	 47839	 47860#	 47860	 47875	 47896#	 47896
	 47911	 47932#	 47932	 47947	 48573#	 48573	 48586	 48613#	 48613	 48626	 48653#	 48653	 48666	 48693#
	 48693	 48706	 48733#	 48733	 48746	 48773#	 48773	 48786	 48813#	 48813	 48826	 48868#	 48868	 48885
	 48909#	 48909	 48926	 48950#	 48950	 48967	 48991#	 48991	 49008	 49032#	 49032	 49049	 49073#	 49073
	 49090	 49114#	 49114	 49131	 49155#	 49155	 49172	 49196#	 49196	 49213	 49237#	 49237	 49254	 49278#
	 49278	 49295	 49319#	 49319	 49336	 49360#	 49360	 49377	 49401#	 49401	 49418	 49442#	 49442	 49459
	 49483#	 49483	 49500	 49524#	 49524	 49541	 49565#	 49565	 49582	 49606#	 49606	 49623	 49647#	 49647
	 49664	 49688#	 49688	 49705	 49729#	 49729	 49746	 49770#	 49770	 49787	 49811#	 49811	 49828	 49852#
	 49852	 49869	 49893#	 49893	 49910	 49934#	 49934	 49951	 49975#	 49975	 49992	 50016#	 50016	 50033
	 50057#	 50057	 50074	 50098#	 50098	 50115	 50144#	 50144	 50156	 50173#	 50173	 50185	 50202#	 50202
	 50214	 50231#	 50231	 50243	 50260#	 50260	 50272	 50289#	 50289	 50301	 50318#	 50318	 50330	 50347#
	 50347	 50359	 50376#	 50376	 50388	 50405#	 50405	 50417	 50434#	 50434	 50446	 50463#	 50463	 50475
	 50492#	 50492	 50504	 50521#	 50521	 50533	 50550#	 50550	 50562	 50579#	 50579	 50591	 50608#	 50608
	 50620	 50637#	 50637	 50649	 50666#	 50666	 50678	 50694#	 50694	 50706	 50722#	 50722	 50734	 50750#
	 50750	 50762	 50833#	 50833	 50847	 50865#	 50865	 50879	 50897#	 50897	 50911	 50929#	 50929	 50943
	 50961#	 50961	 50975	 50993#	 50993	 51007	 51025#	 51025	 51039	 51057#	 51057	 51071	 51085#	 51085
	 51113	 51129	 51140#	 51140	 51154	 51166#	 51166	 51179	 51185
TOTALS	    98#
TPEND	 51239	 51241	 51243	 51245	 51247	 51249	 51251	 51252	 51254#
TRAPPI	 42942	 51221#	 51233
TRP0A	 46001	 46010#
TRP1A	 46022	 46031#
TRP2A	 46043	 46052#
TRP3A	 46064	 46073#
TRP3TP	   364#
TRP4A	 46085	 46094#
TRP5A	 46107	 46116#
TRP6A	 46128	 46137#
TRPCLR	 42944	 51193#	 51201
TRPENB	   364#
TRPFIL	 51224	 51238#
TRPSET	 43295	 51310#	 51325
TTNBRF	   619#
TTYFIL	   535#
TTYSPD	   536#
TXTINH	   109#
UOLIP	   364#
UOUSR	   364#
USER	   426#	   782	   785	   787	   788	   822	   871#	   871	   874	   876	   877	 42925	 42928	 42930
	 42931
USERF	    44#	   364#	   784	   873	 42927	 46014	 46035	 46056	 46077	 46098	 46120	 46141	 46149	 46173
	 46191	 46209	 46227	 46245	 46263	 46281	 46315	 46332	 46349	 46366	 46383	 46400	 46417	 46443
	 46480	 46517	 46554	 46591	 46628	 46665	 46702	 46739	 46776	 46813	 46850	 46887	 46924	 46961
	 46998	 47035	 47072	 47109	 47146	 47183	 51087
USRASB	    34#	   416
USRCMP	   364#
USRCRF	   545#
USRIO0	 51088	 51137#
USRIO1	 51163#
USRLFF	   544#
USRPFW	   364#
UUO	 45999	 51283#
UUO01	 48859#
UUO02	 48880	 48900#
UUO03	 48921	 48941#
UUO04	 48962	 48982#
UUO05	 49003	 49023#
UUO06	 49044	 49064#
UUO07	 49085	 49105#
UUO10	 49126	 49146#
UUO11	 49167	 49187#
UUO12	 49208	 49228#
UUO13	 49249	 49269#
UUO14	 49290	 49310#
UUO15	 49331	 49351#
UUO16	 49372	 49392#
UUO17	 49413	 49433#
UUO20	 49454	 49474#
UUO21	 49495	 49515#
UUO22	 49536	 49556#
UUO23	 49577	 49597#
UUO24	 49618	 49638#
UUO25	 49659	 49679#
UUO26	 49700	 49720#
UUO27	 49741	 49761#
UUO30	 49782	 49802#
UUO31	 49823	 49843#
UUO32	 49864	 49884#
UUO33	 49905	 49925#
UUO34	 49946	 49966#
UUO35	 49987	 50007#
UUO36	 50028	 50048#
UUO37	 50069	 50089#
UUOBTH	 50806#
UUODIS	   498#
UUOEXT	   454#
UUOIND	 50774#
UUOINX	 50790#
UUOPC	 50110	 50129#
UUOPCA	 50130#
UUORTN	   455#
UUOSKP	   452#
X	 43872#	 43899	 43910	 43910#	 43927	 43938	 43938#	 43955	 43966	 43966#	 43983	 43994	 43994#	 44011
	 44022	 44022#	 44039	 44050	 44050#	 44067	 44078	 44078#	 44088#	 44114	 44125	 44125#	 44146	 44157
	 44157#	 44178	 44189	 44189#	 44210	 44221	 44221#	 44242	 44253	 44253#	 44274	 44285	 44285#	 44306
	 44317	 44317#	 44329#	 44358	 44360	 44375	 44375#	 44400	 44402	 44417	 44417#	 44442	 44444	 44459
	 44459#	 44484	 44486	 44501	 44501#	 44526	 44528	 44543	 44543#	 44568	 44570	 44585	 44585#	 44610
	 44612	 44627	 44627#	 45764#	 45788	 45799	 45799#	 45819	 45830	 45830#	 45850	 45861	 45861#	 45881
	 45892	 45892#	 45912	 45923	 45923#	 45943	 45954	 45954#	 45974	 45985	 45985#	 47212#	 47235	 47267
	 47286	 47286#	 47303	 47335	 47354	 47354#	 47371	 47403	 47422	 47422#	 47439	 47471	 47490	 47490#
	 47507	 47539	 47558	 47558#	 47575	 47607	 47626	 47626#	 47643	 47675	 47694	 47694#	 47700#	 47718
	 47741	 47741#	 47754	 47777	 47777#	 47790	 47813	 47813#	 47826	 47849	 47849#	 47862	 47885	 47885#
	 47898	 47921	 47921#	 47934	 47957	 47957#	 47991#	 48020	 48028	 48028#	 48042	 48050	 48050#	 48064
	 48072	 48072#	 48086	 48094	 48094#	 48108	 48116	 48116#	 48130	 48138	 48138#	 48152	 48160	 48160#
	 48186#	 48208	 48219	 48219#	 48228	 48239	 48239#	 48248	 48259	 48259#	 48268	 48279	 48279#	 48288
	 48299	 48299#	 48308	 48319	 48319#	 48328	 48339	 48339#	 48348	 48359	 48359#	 48368	 48379	 48379#
	 48388	 48399	 48399#	 48408	 48419	 48419#	 48428	 48439	 48439#	 48448	 48459	 48459#	 48468	 48479
	 48479#	 48488	 48499	 48499#	 48508	 48519	 48519#	 48528	 48539	 48539#	 48548	 48559	 48559#	 50128#
	 50140	 50147	 50151	 50162	 50162#	 50169	 50176	 50180	 50191	 50191#	 50198	 50205	 50209	 50220
	 50220#	 50227	 50234	 50238	 50249	 50249#	 50256	 50263	 50267	 50278	 50278#	 50285	 50292	 50296
	 50307	 50307#	 50314	 50321	 50325	 50336	 50336#	 50343	 50350	 50354	 50365	 50365#	 50372	 50379
	 50383	 50394	 50394#	 50401	 50408	 50412	 50423	 50423#	 50430	 50437	 50441	 50452	 50452#	 50459
	 50466	 50470	 50481	 50481#	 50488	 50495	 50499	 50510	 50510#	 50517	 50524	 50528	 50539	 50539#
	 50546	 50553	 50557	 50568	 50568#	 50575	 50582	 50586	 50597	 50597#	 50604	 50611	 50615	 50626
	 50626#	 50633	 50640	 50644	 50655	 50655#	 50657#	 50662	 50669	 50673	 50685#	 50690	 50697	 50701
	 50713#	 50718	 50725	 50729	 50741#	 50746	 50753	 50757	 50768#
XAC0	 51206#	 51206	 51215	 51222#	 51222	 51231	 51311#	 51311	 51322
XAC1	 51207#	 51207	 51216	 51223#	 51223	 51232	 51312#	 51312	 51323
XAC15	 51194#	 51194	 51200
XAC16	 51313#	 51313	 51324
XMUPC	 51093	 51112#
XMUUO	 51093#
XMUUO0	 51107#	 51123
XX	 22970#	 22995	 22995#	 22996	 22996#	 22997	 22999	 23015	 23015#	 23016	 23017	 23019	 23035	 23035#
	 23036	 23037	 23039	 23055	 23055#	 23056	 23057	 23059	 23075	 23075#	 23076	 23077	 23079	 23095
	 23095#	 23096	 23097	 23099	 23115	 23115#	 23116	 23117	 23119	 23135	 23135#	 23136	 23137	 23139
	 23155	 23155#	 23156	 23157	 23159	 23175	 23175#	 23176	 23177	 23179	 23195	 23195#	 23196	 23197
	 23199	 23215	 23215#	 23216	 23217	 23219	 23235	 23235#	 23236	 23237	 23239	 23255	 23255#	 23256
	 23257	 23259	 23275	 23275#	 23276	 23277	 23279	 23295	 23295#	 23296	 23297	 23299	 23315	 23315#
	 23316	 23317	 23319	 23335	 23335#	 23336	 23337	 23339	 23349#	 23374	 23374#	 23375	 23375#	 23376
	 23378	 23394	 23394#	 23395	 23396	 23398	 23414	 23414#	 23415	 23416	 23418	 23434	 23434#	 23435
	 23436	 23438	 23454	 23454#	 23455	 23456	 23458	 23474	 23474#	 23475	 23476	 23478	 23494	 23494#
	 23495	 23496	 23498	 23514	 23514#	 23515	 23516	 23518	 23534	 23534#	 23535	 23536	 23538	 23554
	 23554#	 23555	 23556	 23558	 23574	 23574#	 23575	 23576	 23578	 23594	 23594#	 23595	 23596	 23598
	 23614	 23614#	 23615	 23616	 23618	 23634	 23634#	 23635	 23636	 23638	 23654	 23654#	 23655	 23656
	 23658	 23674	 23674#	 23675	 23676	 23678	 23694	 23694#	 23695	 23696	 23698	 23714	 23714#	 23715
	 23716	 23718	 23755	 23755#	 23756	 23756#	 23758	 23759	 23775	 23775#	 23776	 23778	 23779	 23795
	 23795#	 23796	 23798	 23799	 23815	 23815#	 23816	 23818	 23819	 23835	 23835#	 23836	 23838	 23839
	 23855	 23855#	 23856	 23858	 23859	 23875	 23875#	 23876	 23878	 23879	 23895	 23895#	 23896	 23898
	 23899	 23915	 23915#	 23916	 23918	 23919	 23935	 23935#	 23936	 23938	 23939	 23955	 23955#	 23956
	 23958	 23959	 23975	 23975#	 23976	 23978	 23979	 23995	 23995#	 23996	 23998	 23999	 24015	 24015#
	 24016	 24018	 24019	 24035	 24035#	 24036	 24038	 24039	 24055	 24055#	 24056	 24058	 24059	 24075
	 24075#	 24076	 24078	 24079	 24095	 24095#	 24096	 24098	 24099	 24109#	 24134	 24134#	 24135	 24135#
	 24137	 24138	 24154	 24154#	 24155	 24157	 24158	 24174	 24174#	 24175	 24177	 24178	 24194	 24194#
	 24195	 24197	 24198	 24214	 24214#	 24215	 24217	 24218	 24234	 24234#	 24235	 24237	 24238	 24254
	 24254#	 24255	 24257	 24258	 24274	 24274#	 24275	 24277	 24278	 24294	 24294#	 24295	 24297	 24298
	 24314	 24314#	 24315	 24317	 24318	 24334	 24334#	 24335	 24337	 24338	 24354	 24354#	 24355	 24357
	 24358	 24374	 24374#	 24375	 24377	 24378	 24394	 24394#	 24395	 24397	 24398	 24414	 24414#	 24415
	 24417	 24418	 24434	 24434#	 24435	 24437	 24438	 24454	 24454#	 24455	 24457	 24458	 24474	 24474#
	 24475	 24477	 24478	 24492#	 24519	 24519#	 24520	 24520#	 24521	 24522	 24523	 24540	 24540#	 24541
	 24542	 24543	 24544	 24561	 24561#	 24562	 24563	 24564	 24565	 24582	 24582#	 24583	 24584	 24585
	 24586	 24603	 24603#	 24604	 24605	 24606	 24607	 24624	 24624#	 24625	 24626	 24627	 24628	 24645
	 24645#	 24646	 24647	 24648	 24649	 24666	 24666#	 24667	 24668	 24669	 24670	 24687	 24687#	 24688
	 24689	 24690	 24691	 24708	 24708#	 24709	 24710	 24711	 24712	 24729	 24729#	 24730	 24731	 24732
	 24733	 24750	 24750#	 24751	 24752	 24753	 24754	 24771	 24771#	 24772	 24773	 24774	 24775	 24792
	 24792#	 24793	 24794	 24795	 24796	 24813	 24813#	 24814	 24815	 24816	 24817	 24834	 24834#	 24835
	 24836	 24837	 24838	 24855	 24855#	 24856	 24857	 24858	 24859	 24875	 24875#	 24876	 24877	 24887#
	 24914	 24914#	 24915	 24915#	 24916	 24917	 24918	 24935	 24935#	 24936	 24937	 24938	 24939	 24956
	 24956#	 24957	 24958	 24959	 24960	 24977	 24977#	 24978	 24979	 24980	 24981	 24998	 24998#	 24999
	 25000	 25001	 25002	 25019	 25019#	 25020	 25021	 25022	 25023	 25040	 25040#	 25041	 25042	 25043
	 25044	 25061	 25061#	 25062	 25063	 25064	 25065	 25082	 25082#	 25083	 25084	 25085	 25086	 25103
	 25103#	 25104	 25105	 25106	 25107	 25124	 25124#	 25125	 25126	 25127	 25128	 25145	 25145#	 25146
	 25147	 25148	 25149	 25166	 25166#	 25167	 25168	 25169	 25170	 25187	 25187#	 25188	 25189	 25190
	 25191	 25208	 25208#	 25209	 25210	 25211	 25212	 25229	 25229#	 25230	 25231	 25232	 25233	 25250
	 25250#	 25251	 25252	 25253	 25254	 25270	 25270#	 25271	 25272	 25273	 25287#	 25314	 25314#	 25315
	 25315#	 25316	 25317	 25318	 25335	 25335#	 25336	 25337	 25338	 25339	 25356	 25356#	 25357	 25358
	 25359	 25360	 25377	 25377#	 25378	 25379	 25380	 25381	 25398	 25398#	 25399	 25400	 25401	 25402
	 25419	 25419#	 25420	 25421	 25422	 25423	 25440	 25440#	 25441	 25442	 25443	 25444	 25461	 25461#
	 25462	 25463	 25464	 25465	 25482	 25482#	 25483	 25484	 25485	 25486	 25503	 25503#	 25504	 25505
	 25506	 25507	 25524	 25524#	 25525	 25526	 25527	 25528	 25545	 25545#	 25546	 25547	 25548	 25549
	 25566	 25566#	 25567	 25568	 25569	 25570	 25587	 25587#	 25588	 25589	 25590	 25591	 25608	 25608#
	 25609	 25610	 25611	 25612	 25629	 25629#	 25630	 25631	 25632	 25633	 25650	 25650#	 25651	 25652
	 25653	 25654	 25671	 25671#	 25672	 25673	 25683#	 25710	 25710#	 25711	 25711#	 25712	 25713	 25714
	 25731	 25731#	 25732	 25733	 25734	 25735	 25752	 25752#	 25753	 25754	 25755	 25756	 25773	 25773#
	 25774	 25775	 25776	 25777	 25794	 25794#	 25795	 25796	 25797	 25798	 25815	 25815#	 25816	 25817
	 25818	 25819	 25836	 25836#	 25837	 25838	 25839	 25840	 25857	 25857#	 25858	 25859	 25860	 25861
	 25878	 25878#	 25879	 25880	 25881	 25882	 25899	 25899#	 25900	 25901	 25902	 25903	 25920	 25920#
	 25921	 25922	 25923	 25924	 25941	 25941#	 25942	 25943	 25944	 25945	 25962	 25962#	 25963	 25964
	 25965	 25966	 25983	 25983#	 25984	 25985	 25986	 25987	 26004	 26004#	 26005	 26006	 26007	 26008
	 26025	 26025#	 26026	 26027	 26028	 26029	 26046	 26046#	 26047	 26048	 26049	 26050	 26067	 26067#
	 26068	 26069	 26070	 26071	 29343#	 29365	 29365#	 29366	 29368	 29379	 29379#	 29380	 29382	 29393
	 29393#	 29394	 29396	 29407	 29407#	 29408	 29410	 29421	 29421#	 29422	 29424	 29435	 29435#	 29436
	 29438	 29449	 29449#	 29450	 29452	 29463	 29463#	 29464	 29466	 29477	 29477#	 29478	 29480	 29491
	 29491#	 29492	 29494	 29505	 29505#	 29506	 29508	 29519	 29519#	 29520	 29522	 29533	 29533#	 29534
	 29536	 29547	 29547#	 29548	 29550	 29561	 29561#	 29562	 29564	 29576#	 29597	 29597#	 29598	 29599
	 29611	 29611#	 29612	 29613	 29625	 29625#	 29626	 29627	 29639	 29639#	 29640	 29641	 29653	 29653#
	 29654	 29655	 29667	 29667#	 29668	 29669	 29681	 29681#	 29682	 29683	 29695	 29695#	 29696	 29697
	 29709	 29709#	 29710	 29711	 29723	 29723#	 29724	 29725	 29737	 29737#	 29738	 29739	 29751	 29751#
	 29752	 29753	 29765	 29765#	 29766	 29767	 29779	 29779#	 29780	 29781	 29793	 29793#	 29794	 29795
Y	 44089#	 44110	 44126	 44126#	 44142	 44158	 44158#	 44174	 44190	 44190#	 44206	 44222	 44222#	 44238
	 44254	 44254#	 44270	 44286	 44286#	 44302	 44318	 44318#	 45765#	 45783	 45800	 45800#	 45814	 45831
	 45831#	 45845	 45862	 45862#	 45876	 45893	 45893#	 45907	 45924	 45924#	 45938	 45955	 45955#	 45969
	 45986	 45986#	 47213#	 47231	 47233	 47263	 47265	 47285	 47285#	 47299	 47301	 47331	 47333	 47353
	 47353#	 47367	 47369	 47399	 47401	 47421	 47421#	 47435	 47437	 47467	 47469	 47489	 47489#	 47503
	 47505	 47535	 47537	 47557	 47557#	 47571	 47573	 47603	 47605	 47625	 47625#	 47639	 47641	 47671
	 47673	 47693	 47693#
YY	 12585#	 12620	 12620#	 12621	 12622	 12622#	 12625	 12646	 12646#	 12647	 12648	 12651	 12672	 12672#
	 12673	 12674	 12677	 12698	 12698#	 12699	 12700	 12703	 12724	 12724#	 12725	 12726	 12729	 12750
	 12750#	 12751	 12752	 12755	 12776	 12776#	 12777	 12778	 12781	 12802	 12802#	 12803	 12804	 12807
	 12828	 12828#	 12829	 12830	 12833	 12854	 12854#	 12855	 12856	 12859	 12880	 12880#	 12881	 12882
	 12885	 12906	 12906#	 12907	 12908	 12911	 12932	 12932#	 12933	 12934	 12937	 12958	 12958#	 12959
	 12960	 12963	 12984	 12984#	 12985	 12986	 12989	 13010	 13010#	 13011	 13012	 13015	 13036	 13036#
	 13037	 13038	 13041	 13062	 13062#	 13063	 13064	 13067	 13081#	 13116	 13116#	 13117	 13118	 13118#
	 13122	 13142	 13142#	 13143	 13144	 13148	 13168	 13168#	 13169	 13170	 13174	 13194	 13194#	 13195
	 13196	 13200	 13220	 13220#	 13221	 13222	 13226	 13246	 13246#	 13247	 13248	 13252	 13272	 13272#
	 13273	 13274	 13278	 13298	 13298#	 13299	 13300	 13304	 13324	 13324#	 13325	 13326	 13330	 13350
	 13350#	 13351	 13352	 13356	 13376	 13376#	 13377	 13378	 13382	 13402	 13402#	 13403	 13404	 13408
	 13428	 13428#	 13429	 13430	 13434	 13454	 13454#	 13455	 13456	 13460	 13480	 13480#	 13481	 13482
	 13486	 13506	 13506#	 13507	 13508	 13512	 13532	 13532#	 13533	 13534	 13538	 13558	 13558#	 13559
	 13560	 13564	 17837#	 17871	 17871#	 17873	 17873#	 17874	 17876	 17896	 17896#	 17898	 17899	 17901
	 17921	 17921#	 17923	 17924	 17926	 17946	 17946#	 17948	 17949	 17951	 17971	 17971#	 17973	 17974
	 17976	 17996	 17996#	 17998	 17999	 18001	 18021	 18021#	 18023	 18024	 18026	 18046	 18046#	 18048
	 18049	 18051	 18071	 18071#	 18073	 18074	 18076	 18096	 18096#	 18098	 18099	 18101	 18121	 18121#
	 18123	 18124	 18126	 18146	 18146#	 18148	 18149	 18151	 18171	 18171#	 18173	 18174	 18176	 18196
	 18196#	 18198	 18199	 18201	 18221	 18221#	 18223	 18224	 18226	 18246	 18246#	 18248	 18249	 18251
	 18271	 18271#	 18273	 18274	 18276	 18296	 18296#	 18298	 18299	 18301	 18312#	 18346	 18346#	 18348
	 18348#	 18349	 18351	 18371	 18371#	 18373	 18374	 18376	 18396	 18396#	 18398	 18399	 18401	 18421
	 18421#	 18423	 18424	 18426	 18446	 18446#	 18448	 18449	 18451	 18471	 18471#	 18473	 18474	 18476
	 18496	 18496#	 18498	 18499	 18501	 18521	 18521#	 18523	 18524	 18526	 18546	 18546#	 18548	 18549
	 18551	 18571	 18571#	 18573	 18574	 18576	 18596	 18596#	 18598	 18599	 18601	 18621	 18621#	 18623
	 18624	 18626	 18646	 18646#	 18648	 18649	 18651	 18671	 18671#	 18673	 18674	 18676	 18696	 18696#
	 18698	 18699	 18701	 18721	 18721#	 18723	 18724	 18726	 18746	 18746#	 18748	 18749	 18751	 18771
	 18771#	 18773	 18774	 18776
Z1	 47701#	 47719	 47724	 47742	 47742#	 47755	 47760	 47778	 47778#	 47791	 47796	 47814	 47814#	 47827
	 47832	 47850	 47850#	 47863	 47868	 47886	 47886#	 47899	 47904	 47922	 47922#	 47935	 47940	 47958
	 47958#
ZZ	  1305#	  1330	  1330#	  1331	  1331#	  1332	  1349	  1349#	  1350	  1351	  1368	  1368#	  1369	  1370
	  1387	  1387#	  1388	  1389	  1406	  1406#	  1407	  1408	  1425	  1425#	  1426	  1427	  1444	  1444#
	  1445	  1446	  1463	  1463#	  1464	  1465	  1482	  1482#	  1483	  1484	  1501	  1501#	  1502	  1503
	  1520	  1520#	  1521	  1522	  1539	  1539#	  1540	  1541	  1558	  1558#	  1559	  1560	  1577	  1577#
	  1578	  1579	  1596	  1596#	  1597	  1598	  1615	  1615#	  1616	  1617	  1634	  1634#	  1635	  1636
	  1653	  1653#	  1654	  1655	  1672	  1672#	  1673	  1674	  1691	  1691#	  1692	  1693	  1710	  1710#
	  1711	  1712	  1729	  1729#	  1730	  1731	  1748	  1748#	  1749	  1750	  1767	  1767#	  1768	  1769
	  1786	  1786#	  1787	  1788	  1805	  1805#	  1806	  1807	  1824	  1824#	  1825	  1826	  1843	  1843#
	  1844	  1845	  1862	  1862#	  1863	  1864	  1881	  1881#	  1882	  1883	  1900	  1900#	  1901	  1902
	  1919	  1919#	  1920	  1921	  1938	  1938#	  1939	  1940	  1957	  1957#	  1958	  1959	  1976	  1976#
	  1977	  1978	  1995	  1995#	  1996	  1997	  2481#	  2505	  2505#	  2506	  2506#	  2508	  2524	  2524#
	  2525	  2527	  2543	  2543#	  2544	  2546	  2562	  2562#	  2563	  2565	  2581	  2581#	  2582	  2584
	  2600	  2600#	  2601	  2603	  2619	  2619#	  2620	  2622	  2638	  2638#	  2639	  2641	  2657	  2657#
	  2658	  2660	  2676	  2676#	  2677	  2679	  2695	  2695#	  2696	  2698	  2714	  2714#	  2715	  2717
	  2733	  2733#	  2734	  2736	  2752	  2752#	  2753	  2755	  2771	  2771#	  2772	  2774	  2790	  2790#
	  2791	  2793	  2809	  2809#	  2810	  2812	  2828	  2828#	  2829	  2831	  2866	  2866#	  2868	  2885
	  2885#	  2887	  2904	  2904#	  2906	  2923	  2923#	  2925	  2942	  2942#	  2944	  2961	  2961#	  2963
	  2980	  2980#	  2982	  2999	  2999#	  3001	  3018	  3018#	  3020	  3037	  3037#	  3039	  3056	  3056#
	  3058	  3075	  3075#	  3077	  3094	  3094#	  3096	  3113	  3113#	  3115	  3132	  3132#	  3134	  3151
	  3151#	  3153	  3170	  3170#	  3172	  3189	  3189#	  3191	  3293#	  3326	  3326#	  3327	  3327#	  3329
	  3355	  3355#	  3356	  3358	  3384	  3384#	  3385	  3387	  3413	  3413#	  3414	  3416	  3442	  3442#
	  3443	  3445	  3471	  3471#	  3472	  3474	  3500	  3500#	  3501	  3503	  3529	  3529#	  3530	  3532
	  3558	  3558#	  3559	  3561	  3587	  3587#	  3588	  3590	  3616	  3616#	  3617	  3619	  3645	  3645#
	  3646	  3648	  3674	  3674#	  3675	  3677	  3703	  3703#	  3704	  3706	  3732	  3732#	  3733	  3735
	  3761	  3761#	  3762	  3764	  3790	  3790#	  3791	  3793	  3819	  3819#	  3820	  3822	  3848	  3848#
	  3849	  3851	  3877	  3877#	  3878	  3880	  3906	  3906#	  3907	  3909	  3935	  3935#	  3936	  3938
	  3964	  3964#	  3965	  3967	  3993	  3993#	  3994	  3996	  4022	  4022#	  4023	  4025	  4051	  4051#
	  4052	  4054	  4080	  4080#	  4081	  4083	  4109	  4109#	  4110	  4112	  4138	  4138#	  4139	  4141
	  4167	  4167#	  4168	  4170	  4196	  4196#	  4197	  4199	  4225	  4225#	  4226	  4228	  4254	  4254#
	  4255	  4257	  4283	  4283#	  4284	  4286	  4312	  4312#	  4313	  4315	  4341	  4341#	  4342	  4344
	  4362#	  4388	  4388#	  4389	  4389#	  4390	  4409	  4409#	  4410	  4411	  4430	  4430#	  4431	  4432
	  4451	  4451#	  4452	  4453	  4472	  4472#	  4473	  4474	  4493	  4493#	  4494	  4495	  4514	  4514#
	  4515	  4516	  4535	  4535#	  4536	  4537	  4556	  4556#	  4557	  4558	  4577	  4577#	  4578	  4579
	  4598	  4598#	  4599	  4600	  4619	  4619#	  4620	  4621	  4640	  4640#	  4641	  4642	  4661	  4661#
	  4662	  4663	  4682	  4682#	  4683	  4684	  4703	  4703#	  4704	  4705	  4724	  4724#	  4725	  4726
	  4745	  4745#	  4746	  4747	  4766	  4766#	  4767	  4768	  4787	  4787#	  4788	  4789	  4808	  4808#
	  4809	  4810	  4829	  4829#	  4830	  4831	  4850	  4850#	  4851	  4852	  4871	  4871#	  4872	  4873
	  4892	  4892#	  4893	  4894	  4913	  4913#	  4914	  4915	  4934	  4934#	  4935	  4936	  4955	  4955#
	  4956	  4957	  4976	  4976#	  4977	  4978	  4997	  4997#	  4998	  4999	  5018	  5018#	  5019	  5020
	  5039	  5039#	  5040	  5041	  5060	  5060#	  5061	  5062	  5081	  5081#	  5082	  5083	  5102	  5102#
	  5103	  5104	  5123	  5123#	  5124	  5125	  5227#	  5252	  5252#	  5253	  5253#	  5255	  5272	  5272#
	  5273	  5275	  5292	  5292#	  5293	  5295	  5312	  5312#	  5313	  5315	  5332	  5332#	  5333	  5335
	  5352	  5352#	  5353	  5355	  5372	  5372#	  5373	  5375	  5392	  5392#	  5393	  5395	  5412	  5412#
	  5413	  5415	  5432	  5432#	  5433	  5435	  5452	  5452#	  5453	  5455	  5472	  5472#	  5473	  5475
	  5492	  5492#	  5493	  5495	  5512	  5512#	  5513	  5515	  5532	  5532#	  5533	  5535	  5552	  5552#
	  5553	  5555	  5572	  5572#	  5573	  5575	  5592	  5592#	  5593	  5595	  5612	  5612#	  5613	  5615
	  5632	  5632#	  5633	  5635	  5652	  5652#	  5653	  5655	  5672	  5672#	  5673	  5675	  5692	  5692#
	  5693	  5695	  5712	  5712#	  5713	  5715	  5732	  5732#	  5733	  5735	  5752	  5752#	  5753	  5755
	  5772	  5772#	  5773	  5775	  5792	  5792#	  5793	  5795	  5812	  5812#	  5813	  5815	  5832	  5832#
	  5833	  5835	  5852	  5852#	  5853	  5855	  5872	  5872#	  5873	  5875	  5892	  5892#	  5893	  5895
	  5912	  5912#	  5913	  5915	  5932	  5932#	  5933	  5935	  5952	  5952#	  5953	  5955	  5967#	  5997
	  5997#	  5998	  5998#	  5999	  6022	  6022#	  6023	  6024	  6047	  6047#	  6048	  6049	  6072	  6072#
	  6073	  6074	  6097	  6097#	  6098	  6099	  6122	  6122#	  6123	  6124	  6147	  6147#	  6148	  6149
	  6172	  6172#	  6173	  6174	  6197	  6197#	  6198	  6199	  6222	  6222#	  6223	  6224	  6247	  6247#
	  6248	  6249	  6272	  6272#	  6273	  6274	  6297	  6297#	  6298	  6299	  6322	  6322#	  6323	  6324
	  6347	  6347#	  6348	  6349	  6372	  6372#	  6373	  6374	  6397	  6397#	  6398	  6399	  6422	  6422#
	  6423	  6424	  6447	  6447#	  6448	  6449	  6472	  6472#	  6473	  6474	  6497	  6497#	  6498	  6499
	  6522	  6522#	  6523	  6524	  6547	  6547#	  6548	  6549	  6572	  6572#	  6573	  6574	  6597	  6597#
	  6598	  6599	  6622	  6622#	  6623	  6624	  6647	  6647#	  6648	  6649	  6672	  6672#	  6673	  6674
	  6697	  6697#	  6698	  6699	  6722	  6722#	  6723	  6724	  6747	  6747#	  6748	  6749	  6772	  6772#
	  6773	  6774	  6797	  6797#	  6798	  6799	  6822	  6822#	  6823	  6824	  6847	  6847#	  6848	  6849
	  6872	  6872#	  6873	  6874	  6892#	  6920	  6920#	  6921	  6921#	  6922	  6923	  6941	  6941#	  6942
	  6943	  6944	  6962	  6962#	  6963	  6964	  6965	  6983	  6983#	  6984	  6985	  6986	  7004	  7004#
	  7005	  7006	  7007	  7025	  7025#	  7026	  7027	  7028	  7046	  7046#	  7047	  7048	  7049	  7067
	  7067#	  7068	  7069	  7070	  7088	  7088#	  7089	  7090	  7091	  7109	  7109#	  7110	  7111	  7112
	  7130	  7130#	  7131	  7132	  7133	  7151	  7151#	  7152	  7153	  7154	  7172	  7172#	  7173	  7174
	  7175	  7193	  7193#	  7194	  7195	  7196	  7214	  7214#	  7215	  7216	  7217	  7235	  7235#	  7236
	  7237	  7238	  7256	  7256#	  7257	  7258	  7259	  7277	  7277#	  7278	  7279	  7280	  7298	  7298#
	  7299	  7300	  7301	  7319	  7319#	  7320	  7321	  7322	  7340	  7340#	  7341	  7342	  7343	  7361
	  7361#	  7362	  7363	  7364	  7382	  7382#	  7383	  7384	  7385	  7403	  7403#	  7404	  7405	  7406
	  7424	  7424#	  7425	  7426	  7427	  7445	  7445#	  7446	  7447	  7448	  7466	  7466#	  7467	  7468
	  7469	  7487	  7487#	  7488	  7489	  7490	  7508	  7508#	  7509	  7510	  7511	  7529	  7529#	  7530
	  7531	  7532	  7550	  7550#	  7551	  7552	  7553	  7571	  7571#	  7572	  7573	  7574	  7592	  7592#
	  7593	  7594	  7595	  7613	  7613#	  7614	  7615	  7616	  7634	  7634#	  7635	  7636	  7637	  7655
	  7655#	  7656	  7657	  7658	  7701#	  7730	  7730#	  7731	  7731#	  7733	  7752	  7752#	  7753	  7755
	  7774	  7774#	  7775	  7777	  7796	  7796#	  7797	  7799	  7818	  7818#	  7819	  7821	  7840	  7840#
	  7841	  7843	  7862	  7862#	  7863	  7865	  7884	  7884#	  7885	  7887	  7906	  7906#	  7907	  7909
	  7928	  7928#	  7929	  7931	  7950	  7950#	  7951	  7953	  7972	  7972#	  7973	  7975	  7994	  7994#
	  7995	  7997	  8016	  8016#	  8017	  8019	  8038	  8038#	  8039	  8041	  8060	  8060#	  8061	  8063
	  8082	  8082#	  8083	  8085	  8104	  8104#	  8105	  8107	  8119#	  8148	  8148#	  8149	  8149#	  8151
	  8170	  8170#	  8171	  8173	  8192	  8192#	  8193	  8195	  8214	  8214#	  8215	  8217	  8236	  8236#
	  8237	  8239	  8258	  8258#	  8259	  8261	  8280	  8280#	  8281	  8283	  8302	  8302#	  8303	  8305
	  8324	  8324#	  8325	  8327	  8346	  8346#	  8347	  8349	  8368	  8368#	  8369	  8371	  8390	  8390#
	  8391	  8393	  8412	  8412#	  8413	  8415	  8434	  8434#	  8435	  8437	  8456	  8456#	  8457	  8459
	  8478	  8478#	  8479	  8481	  8500	  8500#	  8501	  8503	  8522	  8522#	  8523	  8525	  8576#	  8608
	  8608#	  8609	  8609#	  8610	  8611	  8612	  8632	  8632#	  8633	  8634	  8635	  8636	  8656	  8656#
	  8657	  8658	  8659	  8660	  8680	  8680#	  8681	  8682	  8683	  8684	  8704	  8704#	  8705	  8706
	  8707	  8708	  8728	  8728#	  8729	  8730	  8731	  8732	  8752	  8752#	  8753	  8754	  8755	  8756
	  8776	  8776#	  8777	  8778	  8779	  8780	  8800	  8800#	  8801	  8802	  8803	  8804	  8824	  8824#
	  8825	  8826	  8827	  8828	  8848	  8848#	  8849	  8850	  8851	  8852	  8872	  8872#	  8873	  8874
	  8875	  8876	  8896	  8896#	  8897	  8898	  8899	  8900	  8920	  8920#	  8921	  8922	  8923	  8924
	  8944	  8944#	  8945	  8946	  8947	  8948	  8968	  8968#	  8969	  8970	  8971	  8972	  8992	  8992#
	  8993	  8994	  8995	  8996	  9016	  9016#	  9017	  9018	  9019	  9020	  9040	  9040#	  9041	  9042
	  9043	  9044	  9064	  9064#	  9065	  9066	  9067	  9068	  9088	  9088#	  9089	  9090	  9091	  9092
	  9112	  9112#	  9113	  9114	  9115	  9116	  9136	  9136#	  9137	  9138	  9139	  9140	  9160	  9160#
	  9161	  9162	  9163	  9164	  9184	  9184#	  9185	  9186	  9187	  9188	  9208	  9208#	  9209	  9210
	  9211	  9212	  9232	  9232#	  9233	  9234	  9235	  9236	  9256	  9256#	  9257	  9258	  9259	  9260
	  9280	  9280#	  9281	  9282	  9283	  9284	  9304	  9304#	  9305	  9306	  9307	  9308	  9328	  9328#
	  9329	  9330	  9331	  9332	  9352	  9352#	  9353	  9354	  9355	  9356	  9376	  9376#	  9377	  9378
	  9379	  9380	  9400	  9400#	  9401	  9402	  9403	  9404	  9424	  9424#	  9425	  9426	  9427	  9428
	  9448	  9448#	  9449	  9450	  9451	  9452	  9587#	  9627	  9627#	  9628	  9628#	  9629	  9631	  9657
	  9657#	  9658	  9659	  9661	  9687	  9687#	  9688	  9689	  9691	  9717	  9717#	  9718	  9719	  9721
	  9747	  9747#	  9748	  9749	  9751	  9777	  9777#	  9778	  9779	  9781	  9807	  9807#	  9808	  9809
	  9811	  9837	  9837#	  9838	  9839	  9841	  9867	  9867#	  9868	  9869	  9871	  9897	  9897#	  9898
	  9899	  9901	  9927	  9927#	  9928	  9929	  9931	  9957	  9957#	  9958	  9959	  9961	  9987	  9987#
	  9988	  9989	  9991	 10017	 10017#	 10018	 10019	 10021	 10047	 10047#	 10048	 10049	 10051	 10077
	 10077#	 10078	 10079	 10081	 10107	 10107#	 10108	 10109	 10111	 10137	 10137#	 10138	 10139	 10141
	 10167	 10167#	 10168	 10169	 10171	 10197	 10197#	 10198	 10199	 10201	 10227	 10227#	 10228	 10229
	 10231	 10257	 10257#	 10258	 10259	 10261	 10287	 10287#	 10288	 10289	 10291	 10317	 10317#	 10318
	 10319	 10321	 10347	 10347#	 10348	 10349	 10351	 10377	 10377#	 10378	 10379	 10381	 10407	 10407#
	 10408	 10409	 10411	 10437	 10437#	 10438	 10439	 10441	 10467	 10467#	 10468	 10469	 10471	 10497
	 10497#	 10498	 10499	 10501	 10527	 10527#	 10528	 10529	 10531	 10557	 10557#	 10558	 10559	 10561
	 10587	 10587#	 10588	 10589	 10591	 10617	 10617#	 10618	 10619	 10621	 10647	 10647#	 10648	 10649
	 10651	 10677	 10677#	 10678	 10679	 10681	 10719#	 10755	 10755#	 10756	 10756#	 10758	 10759	 10781
	 10781#	 10782	 10784	 10785	 10807	 10807#	 10808	 10810	 10811	 10833	 10833#	 10834	 10836	 10837
	 10859	 10859#	 10860	 10862	 10863	 10885	 10885#	 10886	 10888	 10889	 10911	 10911#	 10912	 10914
	 10915	 10937	 10937#	 10938	 10940	 10941	 10963	 10963#	 10964	 10966	 10967	 10989	 10989#	 10990
	 10992	 10993	 11015	 11015#	 11016	 11018	 11019	 11041	 11041#	 11042	 11044	 11045	 11067	 11067#
	 11068	 11070	 11071	 11093	 11093#	 11094	 11096	 11097	 11119	 11119#	 11120	 11122	 11123	 11145
	 11145#	 11146	 11148	 11149	 11171	 11171#	 11172	 11174	 11175	 11197	 11197#	 11198	 11200	 11201
	 11223	 11223#	 11224	 11226	 11227	 11249	 11249#	 11250	 11252	 11253	 11275	 11275#	 11276	 11278
	 11279	 11301	 11301#	 11302	 11304	 11305	 11327	 11327#	 11328	 11330	 11331	 11353	 11353#	 11354
	 11356	 11357	 11379	 11379#	 11380	 11382	 11383	 11405	 11405#	 11406	 11408	 11409	 11431	 11431#
	 11432	 11434	 11435	 11457	 11457#	 11458	 11460	 11461	 11483	 11483#	 11484	 11486	 11487	 11509
	 11509#	 11510	 11512	 11513	 11535	 11535#	 11536	 11538	 11539	 11561	 11561#	 11562	 11564	 11565
	 11587	 11587#	 11588	 11590	 11591	 11613	 11613#	 11614	 11616	 11617	 11639	 11639#	 11640	 11642
	 11643	 11665	 11665#	 11666	 11668	 11669	 11684#	 11718	 11718#	 11719	 11719#	 11720	 11721	 11722
	 11743	 11743#	 11744	 11745	 11746	 11747	 11768	 11768#	 11769	 11770	 11771	 11772	 11793	 11793#
	 11794	 11795	 11796	 11797	 11818	 11818#	 11819	 11820	 11821	 11822	 11843	 11843#	 11844	 11845
	 11846	 11847	 11868	 11868#	 11869	 11870	 11871	 11872	 11893	 11893#	 11894	 11895	 11896	 11897
	 11918	 11918#	 11919	 11920	 11921	 11922	 11943	 11943#	 11944	 11945	 11946	 11947	 11968	 11968#
	 11969	 11970	 11971	 11972	 11993	 11993#	 11994	 11995	 11996	 11997	 12018	 12018#	 12019	 12020
	 12021	 12022	 12043	 12043#	 12044	 12045	 12046	 12047	 12068	 12068#	 12069	 12070	 12071	 12072
	 12093	 12093#	 12094	 12095	 12096	 12097	 12118	 12118#	 12119	 12120	 12121	 12122	 12143	 12143#
	 12144	 12145	 12146	 12147	 12168	 12168#	 12169	 12170	 12171	 12172	 12193	 12193#	 12194	 12195
	 12196	 12197	 12218	 12218#	 12219	 12220	 12221	 12222	 12243	 12243#	 12244	 12245	 12246	 12247
	 12268	 12268#	 12269	 12270	 12271	 12272	 12293	 12293#	 12294	 12295	 12296	 12297	 12318	 12318#
	 12319	 12320	 12321	 12322	 12343	 12343#	 12344	 12345	 12346	 12347	 12368	 12368#	 12369	 12370
	 12371	 12372	 12393	 12393#	 12394	 12395	 12396	 12397	 12418	 12418#	 12419	 12420	 12421	 12422
	 12443	 12443#	 12444	 12445	 12446	 12447	 12468	 12468#	 12469	 12470	 12471	 12472	 12493	 12493#
	 12494	 12495	 12496	 12497	 12518	 12518#	 12519	 12520	 12521	 12522	 12543	 12543#	 12544	 12545
	 12546	 12547	 12568	 12568#	 12569	 12570	 12571	 12572	 12584#	 12621	 12621#	 12623	 12623#	 12624
	 12647	 12647#	 12649	 12650	 12673	 12673#	 12675	 12676	 12699	 12699#	 12701	 12702	 12725	 12725#
	 12727	 12728	 12751	 12751#	 12753	 12754	 12777	 12777#	 12779	 12780	 12803	 12803#	 12805	 12806
	 12829	 12829#	 12831	 12832	 12855	 12855#	 12857	 12858	 12881	 12881#	 12883	 12884	 12907	 12907#
	 12909	 12910	 12933	 12933#	 12935	 12936	 12959	 12959#	 12961	 12962	 12985	 12985#	 12987	 12988
	 13011	 13011#	 13013	 13014	 13037	 13037#	 13039	 13040	 13063	 13063#	 13065	 13066	 13080#	 13117
	 13117#	 13119	 13119#	 13120	 13143	 13143#	 13145	 13146	 13169	 13169#	 13171	 13172	 13195	 13195#
	 13197	 13198	 13221	 13221#	 13223	 13224	 13247	 13247#	 13249	 13250	 13273	 13273#	 13275	 13276
	 13299	 13299#	 13301	 13302	 13325	 13325#	 13327	 13328	 13351	 13351#	 13353	 13354	 13377	 13377#
	 13379	 13380	 13403	 13403#	 13405	 13406	 13429	 13429#	 13431	 13432	 13455	 13455#	 13457	 13458
	 13481	 13481#	 13483	 13484	 13507	 13507#	 13509	 13510	 13533	 13533#	 13535	 13536	 13559	 13559#
	 13561	 13562	 13795#	 13817	 13817#	 13818	 13818#	 13819	 13820	 13835	 13835#	 13836	 13837	 13838
	 13853	 13853#	 13854	 13855	 13856	 13871	 13871#	 13872	 13873	 13874	 13889	 13889#	 13890	 13891
	 13892	 13907	 13907#	 13908	 13909	 13910	 13925	 13925#	 13926	 13927	 13928	 13943	 13943#	 13944
	 13945	 13946	 13961	 13961#	 13962	 13963	 13964	 13979	 13979#	 13980	 13981	 13982	 13997	 13997#
	 13998	 13999	 14000	 14015	 14015#	 14016	 14017	 14018	 14033	 14033#	 14034	 14035	 14036	 14051
	 14051#	 14052	 14053	 14054	 14069	 14069#	 14070	 14071	 14072	 14087	 14087#	 14088	 14089	 14090
	 14105	 14105#	 14106	 14107	 14108	 14123	 14123#	 14124	 14125	 14126	 14141	 14141#	 14142	 14143
	 14144	 14159	 14159#	 14160	 14161	 14162	 14177	 14177#	 14178	 14179	 14180	 14195	 14195#	 14196
	 14197	 14198	 14213	 14213#	 14214	 14215	 14216	 14231	 14231#	 14232	 14233	 14234	 14249	 14249#
	 14250	 14251	 14252	 14267	 14267#	 14268	 14269	 14270	 14285	 14285#	 14286	 14287	 14288	 14303
	 14303#	 14304	 14305	 14306	 14321	 14321#	 14322	 14323	 14324	 14339	 14339#	 14340	 14341	 14342
	 14357	 14357#	 14358	 14359	 14360	 14375	 14375#	 14376	 14377	 14378	 14393	 14393#	 14394	 14395
	 14396	 14411	 14411#	 14412	 14413	 14414	 14429	 14429#	 14430	 14431	 14432	 14447	 14447#	 14448
	 14449	 14450	 14816#	 14850	 14850#	 14851	 14851#	 14852	 14877	 14877#	 14878	 14879	 14904	 14904#
	 14905	 14906	 14931	 14931#	 14932	 14933	 14958	 14958#	 14959	 14960	 14985	 14985#	 14986	 14987
	 15012	 15012#	 15013	 15014	 15039	 15039#	 15040	 15041	 15066	 15066#	 15067	 15068	 15093	 15093#
	 15094	 15095	 15120	 15120#	 15121	 15122	 15147	 15147#	 15148	 15149	 15174	 15174#	 15175	 15176
	 15201	 15201#	 15202	 15203	 15228	 15228#	 15229	 15230	 15255	 15255#	 15256	 15257	 15282	 15282#
	 15283	 15284	 15309	 15309#	 15310	 15311	 15327#	 15356	 15356#	 15357	 15357#	 15358	 15378	 15378#
	 15379	 15380	 15400	 15400#	 15401	 15402	 15422	 15422#	 15423	 15424	 15444	 15444#	 15445	 15446
	 15466	 15466#	 15467	 15468	 15488	 15488#	 15489	 15490	 15510	 15510#	 15511	 15512	 15532	 15532#
	 15533	 15534	 15554	 15554#	 15555	 15556	 15576	 15576#	 15577	 15578	 15598	 15598#	 15599	 15600
	 15620	 15620#	 15621	 15622	 15642	 15642#	 15643	 15644	 15664	 15664#	 15665	 15666	 15686	 15686#
	 15687	 15688	 15708	 15708#	 15709	 15710	 15730	 15730#	 15731	 15732	 15744#	 15766	 15766#	 15767
	 15767#	 15769	 15784	 15784#	 15785	 15787	 15802	 15802#	 15803	 15805	 15820	 15820#	 15821	 15823
	 15838	 15838#	 15839	 15841	 15856	 15856#	 15857	 15859	 15874	 15874#	 15875	 15877	 15892	 15892#
	 15893	 15895	 15910	 15910#	 15911	 15913	 15928	 15928#	 15929	 15931	 15946	 15946#	 15947	 15949
	 15964	 15964#	 15965	 15967	 15982	 15982#	 15983	 15985	 16000	 16000#	 16001	 16003	 16018	 16018#
	 16019	 16021	 16036	 16036#	 16037	 16039	 16054	 16054#	 16055	 16057	 16072	 16072#	 16073	 16075
	 16090	 16090#	 16091	 16093	 16108	 16108#	 16109	 16111	 16126	 16126#	 16127	 16129	 16144	 16144#
	 16145	 16147	 16162	 16162#	 16163	 16165	 16180	 16180#	 16181	 16183	 16198	 16198#	 16199	 16201
	 16216	 16216#	 16217	 16219	 16234	 16234#	 16235	 16237	 16252	 16252#	 16253	 16255	 16270	 16270#
	 16271	 16273	 16288	 16288#	 16289	 16291	 16306	 16306#	 16307	 16309	 16324	 16324#	 16325	 16327
	 16342	 16342#	 16343	 16345	 16360	 16360#	 16361	 16363	 16378	 16378#	 16379	 16381	 16396	 16396#
	 16397	 16399	 16409#	 16431	 16431#	 16432	 16432#	 16433	 16449	 16449#	 16450	 16451	 16467	 16467#
	 16468	 16469	 16485	 16485#	 16486	 16487	 16503	 16503#	 16504	 16505	 16521	 16521#	 16522	 16523
	 16539	 16539#	 16540	 16541	 16557	 16557#	 16558	 16559	 16575	 16575#	 16576	 16577	 16593	 16593#
	 16594	 16595	 16611	 16611#	 16612	 16613	 16629	 16629#	 16630	 16631	 16647	 16647#	 16648	 16649
	 16665	 16665#	 16666	 16667	 16683	 16683#	 16684	 16685	 16701	 16701#	 16702	 16703	 16719	 16719#
	 16720	 16721	 16737	 16737#	 16738	 16739	 16755	 16755#	 16756	 16757	 16773	 16773#	 16774	 16775
	 16791	 16791#	 16792	 16793	 16809	 16809#	 16810	 16811	 16827	 16827#	 16828	 16829	 16845	 16845#
	 16846	 16847	 16863	 16863#	 16864	 16865	 16881	 16881#	 16882	 16883	 16899	 16899#	 16900	 16901
	 16917	 16917#	 16918	 16919	 16935	 16935#	 16936	 16937	 16953	 16953#	 16954	 16955	 16971	 16971#
	 16972	 16973	 16989	 16989#	 16990	 16991	 17007	 17007#	 17008	 17009	 17025	 17025#	 17026	 17027
	 17043	 17043#	 17044	 17045	 17061	 17061#	 17062	 17063	 17078#	 17103	 17103#	 17104	 17104#	 17105
	 17107	 17123	 17123#	 17124	 17125	 17127	 17143	 17143#	 17144	 17145	 17147	 17163	 17163#	 17164
	 17165	 17167	 17183	 17183#	 17184	 17185	 17187	 17203	 17203#	 17204	 17205	 17207	 17223	 17223#
	 17224	 17225	 17227	 17243	 17243#	 17244	 17245	 17247	 17263	 17263#	 17264	 17265	 17267	 17283
	 17283#	 17284	 17285	 17287	 17303	 17303#	 17304	 17305	 17307	 17323	 17323#	 17324	 17325	 17327
	 17343	 17343#	 17344	 17345	 17347	 17363	 17363#	 17364	 17365	 17367	 17383	 17383#	 17384	 17385
	 17387	 17403	 17403#	 17404	 17405	 17407	 17423	 17423#	 17424	 17425	 17427	 17443	 17443#	 17444
	 17445	 17447	 17457#	 17482	 17482#	 17483	 17483#	 17484	 17486	 17502	 17502#	 17503	 17504	 17506
	 17522	 17522#	 17523	 17524	 17526	 17542	 17542#	 17543	 17544	 17546	 17562	 17562#	 17563	 17564
	 17566	 17582	 17582#	 17583	 17584	 17586	 17602	 17602#	 17603	 17604	 17606	 17622	 17622#	 17623
	 17624	 17626	 17642	 17642#	 17643	 17644	 17646	 17662	 17662#	 17663	 17664	 17666	 17682	 17682#
	 17683	 17684	 17686	 17702	 17702#	 17703	 17704	 17706	 17722	 17722#	 17723	 17724	 17726	 17742
	 17742#	 17743	 17744	 17746	 17762	 17762#	 17763	 17764	 17766	 17782	 17782#	 17783	 17784	 17786
	 17802	 17802#	 17803	 17804	 17806	 17822	 17822#	 17823	 17824	 17826	 17836#	 17870	 17870#	 17872
	 17872#	 17874	 17876	 17895	 17895#	 17897	 17899	 17901	 17920	 17920#	 17922	 17924	 17926	 17945
	 17945#	 17947	 17949	 17951	 17970	 17970#	 17972	 17974	 17976	 17995	 17995#	 17997	 17999	 18001
	 18020	 18020#	 18022	 18024	 18026	 18045	 18045#	 18047	 18049	 18051	 18070	 18070#	 18072	 18074
	 18076	 18095	 18095#	 18097	 18099	 18101	 18120	 18120#	 18122	 18124	 18126	 18145	 18145#	 18147
	 18149	 18151	 18170	 18170#	 18172	 18174	 18176	 18195	 18195#	 18197	 18199	 18201	 18220	 18220#
	 18222	 18224	 18226	 18245	 18245#	 18247	 18249	 18251	 18270	 18270#	 18272	 18274	 18276	 18295
	 18295#	 18297	 18299	 18301	 18311#	 18345	 18345#	 18347	 18347#	 18349	 18351	 18370	 18370#	 18372
	 18374	 18376	 18395	 18395#	 18397	 18399	 18401	 18420	 18420#	 18422	 18424	 18426	 18445	 18445#
	 18447	 18449	 18451	 18470	 18470#	 18472	 18474	 18476	 18495	 18495#	 18497	 18499	 18501	 18520
	 18520#	 18522	 18524	 18526	 18545	 18545#	 18547	 18549	 18551	 18570	 18570#	 18572	 18574	 18576
	 18595	 18595#	 18597	 18599	 18601	 18620	 18620#	 18622	 18624	 18626	 18645	 18645#	 18647	 18649
	 18651	 18670	 18670#	 18672	 18674	 18676	 18695	 18695#	 18697	 18699	 18701	 18720	 18720#	 18722
	 18724	 18726	 18745	 18745#	 18747	 18749	 18751	 18770	 18770#	 18772	 18774	 18776	 26148#	 26158
	 26158#	 26159	 26160	 26160#	 26161	 26162	 26162#	 26163	 26164	 26164#	 26165	 26166	 26166#	 26167
	 26168	 26168#	 26169	 26170	 26170#	 26171	 26172	 26172#	 26173	 26174	 26174#	 26175	 26176	 26176#
	 26177	 26178	 26178#	 26179	 26180	 26180#	 26181	 26182	 26182#	 26183	 26184	 26184#	 26185	 26186
	 26186#	 26187	 26188	 26188#	 26189	 26191#	 26214	 26214#	 26215	 26232	 26232#	 26233	 26250	 26250#
	 26251	 26268	 26268#	 26269	 26286	 26286#	 26287	 26304	 26304#	 26305	 26322	 26322#	 26323	 26340
	 26340#	 26341	 26358	 26358#	 26359	 26376	 26376#	 26377	 26394	 26394#	 26395	 26412	 26412#	 26413
	 26430	 26430#	 26431	 26448	 26448#	 26449	 26466	 26466#	 26467	 26484	 26484#	 26485	 26496#	 26507
	 26507#	 26508	 26509	 26510	 26510#	 26511	 26512	 26513	 26513#	 26514	 26515	 26516	 26516#	 26517
	 26518	 26519	 26519#	 26520	 26521	 26522	 26522#	 26523	 26524	 26525	 26525#	 26526	 26527	 26528
	 26528#	 26529	 26530	 26531	 26531#	 26532	 26533	 26534	 26534#	 26535	 26536	 26537	 26537#	 26538
	 26539	 26540	 26540#	 26541	 26542	 26543	 26543#	 26544	 26545	 26546	 26546#	 26547	 26548	 26549
	 26549#	 26550	 26551	 26553#	 26578	 26578#	 26579	 26597	 26597#	 26598	 26616	 26616#	 26617	 26635
	 26635#	 26636	 26654	 26654#	 26655	 26673	 26673#	 26674	 26692	 26692#	 26693	 26711	 26711#	 26712
	 26730	 26730#	 26731	 26749	 26749#	 26750	 26768	 26768#	 26769	 26787	 26787#	 26788	 26806	 26806#
	 26807	 26825	 26825#	 26826	 26844	 26844#	 26845	 26856#	 26879	 26879#	 26880	 26881	 26897	 26897#
	 26898	 26899	 26915	 26915#	 26916	 26917	 26933	 26933#	 26934	 26935	 26951	 26951#	 26952	 26953
	 26969	 26969#	 26970	 26971	 26987	 26987#	 26988	 26989	 27005	 27005#	 27006	 27007	 27023	 27023#
	 27024	 27025	 27041	 27041#	 27042	 27043	 27059	 27059#	 27060	 27061	 27077	 27077#	 27078	 27079
	 27095	 27095#	 27096	 27097	 27113	 27113#	 27114	 27115	 27131	 27131#	 27132	 27133	 27143#	 27171
	 27171#	 27172	 27173	 27174	 27192	 27192#	 27193	 27194	 27195	 27213	 27213#	 27214	 27215	 27216
	 27234	 27234#	 27235	 27236	 27237	 27255	 27255#	 27256	 27257	 27258	 27276	 27276#	 27277	 27278
	 27279	 27297	 27297#	 27298	 27299	 27300	 27318	 27318#	 27319	 27320	 27321	 27339	 27339#	 27340
	 27341	 27342	 27360	 27360#	 27361	 27362	 27363	 27381	 27381#	 27382	 27383	 27384	 27402	 27402#
	 27403	 27404	 27405	 27423	 27423#	 27424	 27425	 27426	 27444	 27444#	 27445	 27446	 27447	 27465
	 27465#	 27466	 27467	 27468	 27501#	 27532	 27532#	 27533	 27533#	 27535	 27538	 27556	 27556#	 27557
	 27559	 27562	 27580	 27580#	 27581	 27583	 27586	 27604	 27604#	 27605	 27607	 27610	 27628	 27628#
	 27629	 27631	 27634	 27652	 27652#	 27653	 27655	 27658	 27676	 27676#	 27677	 27679	 27682	 27700
	 27700#	 27701	 27703	 27706	 27724	 27724#	 27725	 27727	 27730	 27748	 27748#	 27749	 27751	 27754
	 27772	 27772#	 27773	 27775	 27778	 27796	 27796#	 27797	 27799	 27802	 27820	 27820#	 27821	 27823
	 27826	 27844	 27844#	 27845	 27847	 27850	 27868	 27868#	 27869	 27871	 27874	 27892	 27892#	 27893
	 27895	 27898	 27916	 27916#	 27917	 27919	 27922	 27940	 27940#	 27941	 27943	 27946	 27956#	 27987
	 27987#	 27988	 27988#	 27990	 27993	 28011	 28011#	 28012	 28014	 28017	 28035	 28035#	 28036	 28038
	 28041	 28059	 28059#	 28060	 28062	 28065	 28083	 28083#	 28084	 28086	 28089	 28107	 28107#	 28108
	 28110	 28113	 28131	 28131#	 28132	 28134	 28137	 28155	 28155#	 28156	 28158	 28161	 28179	 28179#
	 28180	 28182	 28185	 28203	 28203#	 28204	 28206	 28209	 28227	 28227#	 28228	 28230	 28233	 28251
	 28251#	 28252	 28254	 28257	 28275	 28275#	 28276	 28278	 28281	 28299	 28299#	 28300	 28302	 28305
	 28323	 28323#	 28324	 28326	 28329	 28347	 28347#	 28348	 28350	 28353	 28371	 28371#	 28372	 28374
	 28377	 28395	 28395#	 28396	 28398	 28401	 28430#	 28461	 28461#	 28462	 28462#	 28464	 28467	 28485
	 28485#	 28486	 28488	 28491	 28509	 28509#	 28510	 28512	 28515	 28533	 28533#	 28534	 28536	 28539
	 28557	 28557#	 28558	 28560	 28563	 28581	 28581#	 28582	 28584	 28587	 28605	 28605#	 28606	 28608
	 28611	 28629	 28629#	 28630	 28632	 28635	 28653	 28653#	 28654	 28656	 28659	 28677	 28677#	 28678
	 28680	 28683	 28701	 28701#	 28702	 28704	 28707	 28725	 28725#	 28726	 28728	 28731	 28749	 28749#
	 28750	 28752	 28755	 28773	 28773#	 28774	 28776	 28779	 28797	 28797#	 28798	 28800	 28803	 28821
	 28821#	 28822	 28824	 28827	 28845	 28845#	 28846	 28848	 28851	 28869	 28869#	 28870	 28872	 28875
	 28885#	 28916	 28916#	 28917	 28917#	 28919	 28922	 28940	 28940#	 28941	 28943	 28946	 28964	 28964#
	 28965	 28967	 28970	 28988	 28988#	 28989	 28991	 28994	 29012	 29012#	 29013	 29015	 29018	 29036
	 29036#	 29037	 29039	 29042	 29060	 29060#	 29061	 29063	 29066	 29084	 29084#	 29085	 29087	 29090
	 29108	 29108#	 29109	 29111	 29114	 29132	 29132#	 29133	 29135	 29138	 29156	 29156#	 29157	 29159
	 29162	 29180	 29180#	 29181	 29183	 29186	 29204	 29204#	 29205	 29207	 29210	 29228	 29228#	 29229
	 29231	 29234	 29252	 29252#	 29253	 29255	 29258	 29276	 29276#	 29277	 29279	 29282	 29300	 29300#
	 29301	 29303	 29306	 29324	 29324#	 29325	 29327	 29330	 29342#	 29364	 29364#	 29366	 29367	 29368
	 29378	 29378#	 29380	 29381	 29382	 29392	 29392#	 29394	 29395	 29396	 29406	 29406#	 29408	 29409
	 29410	 29420	 29420#	 29422	 29423	 29424	 29434	 29434#	 29436	 29437	 29438	 29448	 29448#	 29450
	 29451	 29452	 29462	 29462#	 29464	 29465	 29466	 29476	 29476#	 29478	 29479	 29480	 29490	 29490#
	 29492	 29493	 29494	 29504	 29504#	 29506	 29507	 29508	 29518	 29518#	 29520	 29521	 29522	 29532
	 29532#	 29534	 29535	 29536	 29546	 29546#	 29548	 29549	 29550	 29560	 29560#	 29562	 29563	 29564
	 29575#	 29596	 29596#	 29598	 29599	 29600	 29610	 29610#	 29612	 29613	 29614	 29624	 29624#	 29626
	 29627	 29628	 29638	 29638#	 29640	 29641	 29642	 29652	 29652#	 29654	 29655	 29656	 29666	 29666#
	 29668	 29669	 29670	 29680	 29680#	 29682	 29683	 29684	 29694	 29694#	 29696	 29697	 29698	 29708
	 29708#	 29710	 29711	 29712	 29722	 29722#	 29724	 29725	 29726	 29736	 29736#	 29738	 29739	 29740
	 29750	 29750#	 29752	 29753	 29754	 29764	 29764#	 29766	 29767	 29768	 29778	 29778#	 29780	 29781
	 29782	 29792	 29792#	 29794	 29795	 29796
$$420	   756#
$$421	   757#
$$422	   758#
$$423	   759#
$$424	   760#
$$425	   761#
$$426	   762#
$$427	   763#
$$430	   764#
$$431	   765#
$$432	   766#
$$433	   767#
$$434	   768#
$$435	   769#
$$436	   770#
$$437	   771#
$$500	   774#
$$501	   775#
$$502	   776#
$$503	   777#
$$BEGI	   742#
$$DTE0	   808	   847#
$$DTE1	   809	   849#
$$DTE2	   810	   863#
$$DTE3	   811	   865#
$$LOC	   739#	   778
$$MUUO	   656#
$$OUTE	   662#
$$STAR	   742	   743	   782#
$$TAX1	   674#
$$TAX2	   675#
$$TOGG	   668#
$$UUO	   639#
$ACC0	   477#
$BEGEN	   751#
$BEND1	   447#
$BEND2	   448#
$CHRIN	   538#
$CRLF	   540#
$DDT	   720#
$DEVCH	   364#
$DSKUP	   417#
$DTCHR	   732#
$DTCI	   726#
$DTCLK	   725#	   806
$DTCMD	   729#	   844	   860
$DTF11	   728#
$DTFLG	   724#	   805	   845	   850	   861	   866
$DTMTD	   733#
$DTMTI	   734#
$DTOPR	   731#	   807
$DTSEQ	   730#
$DTSWR	   736#
$DTT11	   727#
$DVCH1	   364#
$DVOFF	   534#
$EMODE	   415#
$FFF	   542#
$IBUF	   590#
$INEXT	   592#
$INNM	   591#
$ITRHL	   458#
$ITRX1	   459#
$LPAPE	 51331
$MMAP	   418#
$MODVL	   413#
$MODVU	   414#
$OBUF	   581#
$ONETM	   441#
$OUTEX	   583#
$OUTNM	   582#
$PAPER	   364
$PARER	   465#
$PNAME	   411#
$PSHER	   469#
$PVER	   412#
$RSRTX	   461#
$RSRTY	   462#
$SPAG1	   481#
$SPB1	   816	   822#
$SPBEN	   751	   820#
$SPBEX	   823	   831#
$SPBKL	   832	   838#
$SPBUS	   825#
$SPEC	   748	   815#
$SPKLD	   839	   856#
$START	   378#
$STD	   719#	   746#
$STKIL	   791#
$STKL	   800#
$STL	   721#
$STM	   722#	   748#
$SVAPR	   479#
$SVPAG	   480#
$SVPI	   478#
$SVUPC	   484#
$SVUUO	   483#
$TABF	   541#
$TTCHR	   537#
$TWCNT	   533#
$TYPNB	   539#
$UMODE	   416#
$UORTX	   456#
$USRHL	   460#
$UUOER	   457#	   498
$VTF	   543#
%ACTFL	   490#
%ACTUL	   491#
%COREC	   489#
%CORFL	   488#
%DISCR	   492#
%ERHI1	   631#
%ERHI2	   632#
%ERHI3	   633#
%X	 43339#	 43340	 43351	 43357#	 43358	 43368	 43374#	 43375	 43387	 43393#	 43394	 43407	 43413#	 43414
	 43420	 43426#	 43427	 43438	 43444#	 43445	 43600	 43606#	 43607	 43619	 43625#	 43626	 43637	 43643#
	 43644	 43655	 43661#	 43662	 43703	 43709#	 43710	 43722	 43889#	 43890	 43905	 43917#	 43918	 43933
	 43945#	 43946	 43961	 43973#	 43974	 43989	 44001#	 44002	 44017	 44029#	 44030	 44045	 44057#	 44058
	 44073	 44104#	 44105	 44120	 44136#	 44137	 44152	 44168#	 44169	 44184	 44200#	 44201	 44216	 44232#
	 44233	 44248	 44264#	 44265	 44280	 44296#	 44297	 44312	 44352#	 44353	 44370	 44394#	 44395	 44412
	 44436#	 44437	 44454	 44478#	 44479	 44496	 44520#	 44521	 44538	 44562#	 44563	 44580	 44604#	 44605
	 44622	 44648#	 44649	 44662	 44668#	 44669	 44684	 44690#	 44691	 44706	 44712#	 44713	 44727	 44733#
	 44734	 44748	 44759#	 44760	 44773	 44779#	 44780	 44795	 44801#	 44802	 44817	 44823#	 44824	 44838
	 44844#	 44845	 44859	 44870#	 44871	 44884	 44890#	 44891	 44906	 44912#	 44913	 44928	 44934#	 44935
	 44949	 44955#	 44956	 44970	 44981#	 44982	 44995	 45001#	 45002	 45017	 45023#	 45024	 45039	 45045#
	 45046	 45060	 45066#	 45067	 45081	 45092#	 45093	 45106	 45112#	 45113	 45128	 45134#	 45135	 45150
	 45156#	 45157	 45171	 45177#	 45178	 45192	 45203#	 45204	 45217	 45223#	 45224	 45239	 45245#	 45246
	 45261	 45267#	 45268	 45282	 45288#	 45289	 45303	 45314#	 45315	 45328	 45334#	 45335	 45350	 45356#
	 45357	 45372	 45378#	 45379	 45393	 45399#	 45400	 45414	 45425#	 45426	 45439	 45445#	 45446	 45461
	 45467#	 45468	 45483	 45489#	 45490	 45504	 45510#	 45511	 45525	 45536#	 45537	 45550	 45556#	 45557
	 45572	 45578#	 45579	 45594	 45600#	 45601	 45615	 45621#	 45622	 45636	 45647#	 45648	 45661	 45667#
	 45668	 45683	 45689#	 45690	 45705	 45711#	 45712	 45726	 45732#	 45733	 45747	 45777#	 45778	 45794
	 45808#	 45809	 45825	 45839#	 45840	 45856	 45870#	 45871	 45887	 45901#	 45902	 45918	 45932#	 45933
	 45949	 45963#	 45964	 45980	 46430#	 46431	 46461	 46467#	 46468	 46498	 46504#	 46505	 46535	 46541#
	 46542	 46572	 46578#	 46579	 46609	 46615#	 46616	 46646	 46652#	 46653	 46683	 46689#	 46690	 46720
	 46726#	 46727	 46757	 46763#	 46764	 46794	 46800#	 46801	 46831	 46837#	 46838	 46868	 46874#	 46875
	 46905	 46911#	 46912	 46942	 46948#	 46949	 46979	 46985#	 46986	 47016	 47022#	 47023	 47053	 47059#
	 47060	 47090	 47096#	 47097	 47127	 47133#	 47134	 47164	 47170#	 47171	 47201	 47714#	 47715	 47732
	 47750#	 47751	 47768	 47786#	 47787	 47804	 47822#	 47823	 47840	 47858#	 47859	 47876	 47894#	 47895
	 47912	 47930#	 47931	 47948	 48571#	 48572	 48587	 48611#	 48612	 48627	 48651#	 48652	 48667	 48691#
	 48692	 48707	 48731#	 48732	 48747	 48771#	 48772	 48787	 48811#	 48812	 48827	 48866#	 48867	 48886
	 48907#	 48908	 48927	 48948#	 48949	 48968	 48989#	 48990	 49009	 49030#	 49031	 49050	 49071#	 49072
	 49091	 49112#	 49113	 49132	 49153#	 49154	 49173	 49194#	 49195	 49214	 49235#	 49236	 49255	 49276#
	 49277	 49296	 49317#	 49318	 49337	 49358#	 49359	 49378	 49399#	 49400	 49419	 49440#	 49441	 49460
	 49481#	 49482	 49501	 49522#	 49523	 49542	 49563#	 49564	 49583	 49604#	 49605	 49624	 49645#	 49646
	 49665	 49686#	 49687	 49706	 49727#	 49728	 49747	 49768#	 49769	 49788	 49809#	 49810	 49829	 49850#
	 49851	 49870	 49891#	 49892	 49911	 49932#	 49933	 49952	 49973#	 49974	 49993	 50014#	 50015	 50034
	 50055#	 50056	 50075	 50096#	 50097	 50116	 50142#	 50143	 50157	 50171#	 50172	 50186	 50200#	 50201
	 50215	 50229#	 50230	 50244	 50258#	 50259	 50273	 50287#	 50288	 50302	 50316#	 50317	 50331	 50345#
	 50346	 50360	 50374#	 50375	 50389	 50403#	 50404	 50418	 50432#	 50433	 50447	 50461#	 50462	 50476
	 50490#	 50491	 50505	 50519#	 50520	 50534	 50548#	 50549	 50563	 50577#	 50578	 50592	 50606#	 50607
	 50621	 50635#	 50636	 50650	 50664#	 50665	 50679	 50692#	 50693	 50707	 50720#	 50721	 50735	 50748#
	 50749	 50763	 50831#	 50832	 50848	 50863#	 50864	 50880	 50895#	 50896	 50912	 50927#	 50928	 50944
	 50959#	 50960	 50976	 50991#	 50992	 51008	 51023#	 51024	 51040	 51055#	 51056	 51072	 51083#	 51084
	 51114	 51130	 51138#	 51139	 51155	 51164#	 51165	 51180
..0001	 43892#
..0002	 43920#
..0003	 43948#
..0004	 43976#
..0005	 44004#
..0006	 44032#
..0007	 44060#
..0010	 44107#
..0011	 44139#
..0012	 44171#
..0013	 44203#
..0014	 44235#
..0015	 44267#
..0016	 44299#
..0017	 44355#
..0020	 44397#
..0021	 44439#
..0022	 44481#
..0023	 44523#
..0024	 44565#
..0025	 44607#
..0026	 44651#
..0027	 44762#
..0030	 44873#
..0031	 44984#
..0032	 45095#
..0033	 45206#
..0034	 45317#
..0035	 45428#
..0036	 45539#
..0037	 45650#
..0040	 45780#
..0041	 45811#
..0042	 45842#
..0043	 45873#
..0044	 45904#
..0045	 45935#
..0046	 45966#
..0047	 46011#
..0050	 46032#
..0051	 46053#
..0052	 46074#
..0053	 46095#
..0054	 46117#
..0055	 46138#
..0056	 46170#
..0057	 46188#
..0060	 46206#
..0061	 46224#
..0062	 46242#
..0063	 46260#
..0064	 46278#
..0065	 46305#
..0066	 46312#
..0067	 46322#
..0070	 46329#
..0071	 46339#
..0072	 46346#
..0073	 46356#
..0074	 46363#
..0075	 46373#
..0076	 46380#
..0077	 46390#
..0100	 46397#
..0101	 46407#
..0102	 46414#
..0103	 46440#
..0104	 46477#
..0105	 46514#
..0106	 46551#
..0107	 46588#
..0110	 46625#
..0111	 46662#
..0112	 46699#
..0113	 46736#
..0114	 46773#
..0115	 46810#
..0116	 46847#
..0117	 46884#
..0120	 46921#
..0121	 46958#
..0122	 46995#
..0123	 47032#
..0124	 47069#
..0125	 47106#
..0126	 47143#
..0127	 47180#
..0130	 47232	 47245#
..0131	 47264	 47277#
..0132	 47300	 47313#
..0133	 47332	 47345#
..0134	 47368	 47381#
..0135	 47400	 47413#
..0136	 47436	 47449#
..0137	 47468	 47481#
..0140	 47504	 47517#
..0141	 47536	 47549#
..0142	 47572	 47585#
..0143	 47604	 47617#
..0144	 47640	 47653#
..0145	 47672	 47685#
..0146	 47717#
..0147	 47753#
..0150	 47789#
..0151	 47825#
..0152	 47861#
..0153	 47897#
..0154	 47933#
..0155	 48576	 48585#	 48592
..0156	 48616	 48625#	 48632
..0157	 48656	 48665#	 48672
..0160	 48696	 48705#	 48712
..0161	 48736	 48745#	 48752
..0162	 48776	 48785#	 48792
..0163	 48816	 48825#	 48832
..0164	 48869#
..0165	 48910#
..0166	 48951#
..0167	 48992#
..0170	 49033#
..0171	 49074#
..0172	 49115#
..0173	 49156#
..0174	 49197#
..0175	 49238#
..0176	 49279#
..0177	 49320#
..0200	 49361#
..0201	 49402#
..0202	 49443#
..0203	 49484#
..0204	 49525#
..0205	 49566#
..0206	 49607#
..0207	 49648#
..0210	 49689#
..0211	 49730#
..0212	 49771#
..0213	 49812#
..0214	 49853#
..0215	 49894#
..0216	 49935#
..0217	 49976#
..0220	 50017#
..0221	 50058#
..0222	 50099#
..0223	 50145#
..0224	 50148#
..0225	 50152#
..0226	 50174#
..0227	 50177#
..0230	 50181#
..0231	 50203#
..0232	 50206#
..0233	 50210#
..0234	 50232#
..0235	 50235#
..0236	 50239#
..0237	 50261#
..0240	 50264#
..0241	 50268#
..0242	 50290#
..0243	 50293#
..0244	 50297#
..0245	 50319#
..0246	 50322#
..0247	 50326#
..0250	 50348#
..0251	 50351#
..0252	 50355#
..0253	 50377#
..0254	 50380#
..0255	 50384#
..0256	 50406#
..0257	 50409#
..0260	 50413#
..0261	 50435#
..0262	 50438#
..0263	 50442#
..0264	 50464#
..0265	 50467#
..0266	 50471#
..0267	 50493#
..0270	 50496#
..0271	 50500#
..0272	 50522#
..0273	 50525#
..0274	 50529#
..0275	 50551#
..0276	 50554#
..0277	 50558#
..0300	 50580#
..0301	 50583#
..0302	 50587#
..0303	 50609#
..0304	 50612#
..0305	 50616#
..0306	 50638#
..0307	 50641#
..0310	 50645#
..0311	 50667#
..0312	 50670#
..0313	 50674#
..0314	 50695#
..0315	 50698#
..0316	 50702#
..0317	 50723#
..0320	 50726#
..0321	 50730#
..0322	 50751#
..0323	 50754#
..0324	 50758#
..0325	 50835	 50841#
..0326	 50837	 50839#
..0327	 50867	 50873#
..0330	 50869	 50871#
..0331	 50899	 50905#
..0332	 50901	 50903#
..0333	 50931	 50937#
..0334	 50933	 50935#
..0335	 50963	 50969#
..0336	 50965	 50967#
..0337	 50995	 51001#
..0340	 50997	 50999#
..0341	 51027	 51033#
..0342	 51029	 51031#
..0343	 51059	 51065#
..0344	 51061	 51063#
.JB41	   364#
.JBAPR	   364#
.JBCNI	   364#
.JBDDT	   364#
.JBFF	   364#
.JBOPC	   364#
.JBREL	   364#
.JBREN	   364#
.JBSA	   364#
.JBSYM	   364#
.JBTPC	   364#
.JBUSY	   364#
.JBUUO	   364#
.JBVER	   364#

BLURB	 42952#	 43757	 43873	 44080	 44321	 44630	 45754	 47964
BLURB1	 42958#	 44341	 44383	 44425	 44467	 44509	 44551	 44593
CFLUSH	   282#
CINVAL	   281#
CLOKOP	   276#
CLRAPR	 42947#	 43491	 43499	 43507	 43514	 43521	 43528	 43535	 43893	 43921	 43949	 43977	 44005	 44033
	 44061	 44108	 44140	 44172	 44204	 44236	 44268	 44300	 44356	 44398	 44440	 44482	 44524	 44566
	 44608	 44652	 44672	 44694	 44716	 44737	 44763	 44783	 44805	 44827	 44848	 44874	 44894	 44916
	 44938	 44959	 44985	 45005	 45027	 45049	 45070	 45096	 45116	 45138	 45160	 45181	 45207	 45227
	 45249	 45271	 45292	 45318	 45338	 45360	 45382	 45403	 45429	 45449	 45471	 45493	 45514	 45540
	 45560	 45582	 45604	 45625	 45651	 45671	 45693	 45715	 45736	 45781	 45812	 45843	 45874	 45905
	 45936	 45967	 45998	 46016	 46037	 46058	 46079	 46100	 46122	 46153	 46158	 46176	 46194	 46212
	 46230	 46248	 46266	 46285	 46297	 46420	 46445	 46482	 46519	 46556	 46593	 46630	 46667	 46704
	 46741	 46778	 46815	 46852	 46889	 46926	 46963	 47000	 47037	 47074	 47111	 47148	 47185	 47206
	 47227	 47246	 47259	 47278	 47295	 47314	 47327	 47346	 47363	 47382	 47395	 47414	 47431	 47450
	 47463	 47482	 47499	 47518	 47531	 47550	 47567	 47586	 47599	 47618	 47635	 47654	 47667	 47686
	 47737	 47773	 47809	 47845	 47881	 47917	 47953	 47971	 48014	 48036	 48058	 48080	 48102	 48124
	 48146	 48166	 48177	 48204	 48224	 48244	 48264	 48284	 48304	 48324	 48344	 48364	 48384	 48404
	 48424	 48444	 48464	 48484	 48504	 48524	 48544	 48579	 48599	 48619	 48639	 48659	 48679	 48699
	 48719	 48739	 48759	 48779	 48799	 48819	 48839	 50775	 50791	 50807	 51091	 51142	 51168
CLRBT1	 43160#	 46296	 48578	 48618	 48658	 48698	 48738	 48778	 48818
CLRBTH	 43156#	 43892	 43920	 43948	 43976	 44004	 44032	 44060	 44107	 44139	 44171	 44203	 44235	 44267
	 44299	 44355	 44397	 44439	 44481	 44523	 44565	 44607	 44651	 44671	 44693	 44715	 44736	 44762
	 44782	 44804	 44826	 44847	 44873	 44893	 44915	 44937	 44958	 44984	 45004	 45026	 45048	 45069
	 45095	 45115	 45137	 45159	 45180	 45206	 45226	 45248	 45270	 45291	 45317	 45337	 45359	 45381
	 45402	 45428	 45448	 45470	 45492	 45513	 45539	 45559	 45581	 45603	 45624	 45650	 45670	 45692
	 45714	 45735	 45780	 45811	 45842	 45873	 45904	 45935	 45966	 46152	 46419	 46444	 46481	 46518
	 46555	 46592	 46629	 46666	 46703	 46740	 46777	 46814	 46851	 46888	 46925	 46962	 46999	 47036
	 47073	 47110	 47147	 47184	 47205	 47226	 47245	 47258	 47277	 47294	 47313	 47326	 47345	 47362
	 47381	 47394	 47413	 47430	 47449	 47462	 47481	 47498	 47517	 47530	 47549	 47566	 47585	 47598
	 47617	 47634	 47653	 47666	 47685	 47736	 47772	 47808	 47844	 47880	 47916	 47952	 47970	 48013
	 48035	 48057	 48079	 48101	 48123	 48145	 48165	 48176	 48203	 48223	 48243	 48263	 48283	 48303
	 48323	 48343	 48363	 48383	 48403	 48423	 48443	 48463	 48483	 48503	 48523	 48543	 48598	 48638
	 48678	 48718	 48758	 48798	 48838	 50774	 50790	 50806	 51090	 51141	 51167
CLRPI	 42948#	 43894	 43922	 43950	 43978	 44006	 44034	 44062	 44109	 44141	 44173	 44205	 44237	 44269
	 44301	 44357	 44399	 44441	 44483	 44525	 44567	 44609	 44653	 44673	 44695	 44717	 44738	 44764
	 44784	 44806	 44828	 44849	 44875	 44895	 44917	 44939	 44960	 44986	 45006	 45028	 45050	 45071
	 45097	 45117	 45139	 45161	 45182	 45208	 45228	 45250	 45272	 45293	 45319	 45339	 45361	 45383
	 45404	 45430	 45450	 45472	 45494	 45515	 45541	 45561	 45583	 45605	 45626	 45652	 45672	 45694
	 45716	 45737	 45782	 45813	 45844	 45875	 45906	 45937	 45968	 45997	 46015	 46036	 46057	 46078
	 46099	 46121	 46154	 46157	 46175	 46193	 46211	 46229	 46247	 46265	 46284	 46298	 46421	 46446
	 46483	 46520	 46557	 46594	 46631	 46668	 46705	 46742	 46779	 46816	 46853	 46890	 46927	 46964
	 47001	 47038	 47075	 47112	 47149	 47186	 47207	 47228	 47247	 47260	 47279	 47296	 47315	 47328
	 47347	 47364	 47383	 47396	 47415	 47432	 47451	 47464	 47483	 47500	 47519	 47532	 47551	 47568
	 47587	 47600	 47619	 47636	 47655	 47668	 47687	 47738	 47774	 47810	 47846	 47882	 47918	 47954
	 47972	 48015	 48037	 48059	 48081	 48103	 48125	 48147	 48167	 48178	 48205	 48225	 48245	 48265
	 48285	 48305	 48325	 48345	 48365	 48385	 48405	 48425	 48445	 48465	 48485	 48505	 48525	 48545
	 48580	 48600	 48620	 48640	 48660	 48680	 48700	 48720	 48740	 48760	 48780	 48800	 48820	 48840
	 50776	 50792	 50808	 51092	 51143	 51169
CLRTRP	 42944#	 46283
CWRTBI	   283#
DROPDV	   243#
ENDUUO	   289#	   446
EOPUUO	   290#	   448
ERLOOP	   334#
ERLP1	   335#
ERLP2	   336#
ERRHLT	   177#
ERROR	   343#
ERROR1	   354#
ERUUO	   333#
EXECUT	 43102#
EXIT	   828
FATAL	   176#
FMUUO	 43239#	 50822	 50854	 50886	 50918	 50950	 50982	 51014	 51046
FRD36	   318#
FRD8	   319#
FREAD	   317#
FSELEC	   316#
GET	   160#
GO	   157#
HALT	   162#	   467	   756	   758	   759	   763	   777	   868	   915	   931	   942	   952	   959	   971
	   984	   998	  1015	  1030	  1049	  1063	  1077	  1091	  1105	  1119	  1132	  1146	  1161	  1175
	  1188	  1202	  1216	  1229	  1243	  1257	  1270	  1284	  1298	  1335	  1354	  1373	  1392	  1411
	  1430	  1449	  1468	  1487	  1506	  1525	  1544	  1563	  1582	  1601	  1620	  1639	  1658	  1677
	  1696	  1715	  1734	  1753	  1772	  1791	  1810	  1829	  1848	  1867	  1886	  1905	  1924	  1943
	  1962	  1981	  2000	  2015	  2033	  2048	  2064	  2089	  2107	  2125	  2138	  2152	  2177	  2224
	  2230	  2253	  2259	  2282	  2288	  2311	  2317	  2335	  2354	  2372	  2390	  2406	  2422	  2437
	  2454	  2474	  2511	  2530	  2549	  2568	  2587	  2606	  2625	  2644	  2663	  2682	  2701	  2720
	  2739	  2758	  2777	  2796	  2815	  2834	  2871	  2890	  2909	  2928	  2947	  2966	  2985	  3004
	  3023	  3042	  3061	  3080	  3099	  3118	  3137	  3156	  3175	  3194	  3211	  3227	  3247	  3265
	  3286	  3334	  3340	  3363	  3369	  3392	  3398	  3421	  3427	  3450	  3456	  3479	  3485	  3508
	  3514	  3537	  3543	  3566	  3572	  3595	  3601	  3624	  3630	  3653	  3659	  3682	  3688	  3711
	  3717	  3740	  3746	  3769	  3775	  3798	  3804	  3827	  3833	  3856	  3862	  3885	  3891	  3914
	  3920	  3943	  3949	  3972	  3978	  4001	  4007	  4030	  4036	  4059	  4065	  4088	  4094	  4117
	  4123	  4146	  4152	  4175	  4181	  4204	  4210	  4233	  4239	  4262	  4268	  4291	  4297	  4320
	  4326	  4349	  4355	  4396	  4417	  4438	  4459	  4480	  4501	  4522	  4543	  4564	  4585	  4606
	  4627	  4648	  4669	  4690	  4711	  4732	  4753	  4774	  4795	  4816	  4837	  4858	  4879	  4900
	  4921	  4942	  4963	  4984	  5005	  5026	  5047	  5068	  5089	  5110	  5131	  5149	  5166	  5186
	  5204	  5220	  5259	  5279	  5299	  5319	  5339	  5359	  5379	  5399	  5419	  5439	  5459	  5479
	  5499	  5519	  5539	  5559	  5579	  5599	  5619	  5639	  5659	  5679	  5699	  5719	  5739	  5759
	  5779	  5799	  5819	  5839	  5859	  5879	  5899	  5919	  5939	  5959	  6004	  6029	  6054	  6079
	  6104	  6129	  6154	  6179	  6204	  6229	  6254	  6279	  6304	  6329	  6354	  6379	  6404	  6429
	  6454	  6479	  6504	  6529	  6554	  6579	  6604	  6629	  6654	  6679	  6704	  6729	  6754	  6779
	  6804	  6829	  6854	  6879	  6926	  6947	  6968	  6989	  7010	  7031	  7052	  7073	  7094	  7115
	  7136	  7157	  7178	  7199	  7220	  7241	  7262	  7283	  7304	  7325	  7346	  7367	  7388	  7409
	  7430	  7451	  7472	  7493	  7514	  7535	  7556	  7577	  7598	  7619	  7640	  7661	  7676	  7694
	  7737	  7759	  7781	  7803	  7825	  7847	  7869	  7891	  7913	  7935	  7957	  7979	  8001	  8023
	  8045	  8067	  8089	  8111	  8155	  8177	  8199	  8221	  8243	  8265	  8287	  8309	  8331	  8353
	  8375	  8397	  8419	  8441	  8463	  8485	  8507	  8529	  8549	  8569	  8616	  8640	  8664	  8688
	  8712	  8736	  8760	  8784	  8808	  8832	  8856	  8880	  8904	  8928	  8952	  8976	  9000	  9024
	  9048	  9072	  9096	  9120	  9144	  9168	  9192	  9216	  9240	  9264	  9288	  9312	  9336	  9360
	  9384	  9408	  9432	  9456	  9477	  9500	  9521	  9543	  9560	  9578	  9635	  9665	  9695	  9725
	  9755	  9785	  9815	  9845	  9875	  9905	  9935	  9965	  9995	 10025	 10055	 10085	 10115	 10145
	 10175	 10205	 10235	 10265	 10295	 10325	 10355	 10385	 10415	 10445	 10475	 10505	 10535	 10565
	 10595	 10625	 10655	 10685	 10706	 10763	 10789	 10815	 10841	 10867	 10893	 10919	 10945	 10971
	 10997	 11023	 11049	 11075	 11101	 11127	 11153	 11179	 11205	 11231	 11257	 11283	 11309	 11335
	 11361	 11387	 11413	 11439	 11465	 11491	 11517	 11543	 11569	 11595	 11621	 11647	 11673	 11726
	 11751	 11776	 11801	 11826	 11851	 11876	 11901	 11926	 11951	 11976	 12001	 12026	 12051	 12076
	 12101	 12126	 12151	 12176	 12201	 12226	 12251	 12276	 12301	 12326	 12351	 12376	 12401	 12426
	 12451	 12476	 12501	 12526	 12551	 12576	 12629	 12655	 12681	 12707	 12733	 12759	 12785	 12811
	 12837	 12863	 12889	 12915	 12941	 12967	 12993	 13019	 13045	 13071	 13125	 13151	 13177	 13203
	 13229	 13255	 13281	 13307	 13333	 13359	 13385	 13411	 13437	 13463	 13489	 13515	 13541	 13567
	 13586	 13603	 13620	 13636	 13653	 13670	 13686	 13703	 13720	 13736	 13751	 13768	 13786	 13823
	 13841	 13859	 13877	 13895	 13913	 13931	 13949	 13967	 13985	 14003	 14021	 14039	 14057	 14075
	 14093	 14111	 14129	 14147	 14165	 14183	 14201	 14219	 14237	 14255	 14273	 14291	 14309	 14327
	 14345	 14363	 14381	 14399	 14417	 14435	 14453	 14469	 14483	 14505	 14523	 14542	 14564	 14587
	 14610	 14633	 14647	 14669	 14684	 14706	 14721	 14737	 14757	 14778	 14803	 14856	 14883	 14910
	 14937	 14964	 14991	 15018	 15045	 15072	 15099	 15126	 15153	 15180	 15207	 15234	 15261	 15288
	 15315	 15362	 15384	 15406	 15428	 15450	 15472	 15494	 15516	 15538	 15560	 15582	 15604	 15626
	 15648	 15670	 15692	 15714	 15736	 15771	 15789	 15807	 15825	 15843	 15861	 15879	 15897	 15915
	 15933	 15951	 15969	 15987	 16005	 16023	 16041	 16059	 16077	 16095	 16113	 16131	 16149	 16167
	 16185	 16203	 16221	 16239	 16257	 16275	 16293	 16311	 16329	 16347	 16365	 16383	 16401	 16436
	 16454	 16472	 16490	 16508	 16526	 16544	 16562	 16580	 16598	 16616	 16634	 16652	 16670	 16688
	 16706	 16724	 16742	 16760	 16778	 16796	 16814	 16832	 16850	 16868	 16886	 16904	 16922	 16940
	 16958	 16976	 16994	 17012	 17030	 17048	 17066	 17109	 17129	 17149	 17169	 17189	 17209	 17229
	 17249	 17269	 17289	 17309	 17329	 17349	 17369	 17389	 17409	 17429	 17449	 17488	 17508	 17528
	 17548	 17568	 17588	 17608	 17628	 17648	 17668	 17688	 17708	 17728	 17748	 17768	 17788	 17808
	 17828	 17878	 17903	 17928	 17953	 17978	 18003	 18028	 18053	 18078	 18103	 18128	 18153	 18178
	 18203	 18228	 18253	 18278	 18303	 18353	 18378	 18403	 18428	 18453	 18478	 18503	 18528	 18553
	 18578	 18603	 18628	 18653	 18678	 18703	 18728	 18753	 18778	 18797	 18821	 18841	 18859	 18875
	 18890	 18911	 18931	 18953	 18967	 18983	 19005	 19023	 19047	 19070	 19091	 19117	 19145	 19163
	 19179	 19203	 19219	 19236	 19257	 19273	 19296	 19318	 19335	 19351	 19368	 19384	 19408	 19430
	 19446	 19461	 19477	 19493	 19520	 19540	 19556	 19571	 19587	 19603	 19631	 19646	 19662	 19677
	 19693	 19711	 19733	 19756	 19770	 19788	 19808	 19832	 19848	 19868	 19891	 19908	 19926	 19942
	 19968	 19989	 20007	 20023	 20046	 20068	 20092	 20108	 20126	 20141	 20165	 20186	 20203	 20224
	 20238	 20261	 20276	 20293	 20318	 20341	 20362	 20377	 20401	 20417	 20436	 20449	 20462	 20474
	 20490	 20504	 20520	 20540	 20561	 20578	 20612	 20629	 20647	 20664	 20682	 20705	 20723	 20740
	 20759	 20782	 20803	 20820	 20836	 20853	 20868	 20890	 20912	 20929	 20945	 20961	 20982	 20999
	 21015	 21032	 21048	 21065	 21081	 21098	 21113	 21130	 21145	 21161	 21182	 21203	 21218	 21239
	 21259	 21275	 21290	 21311	 21326	 21342	 21357	 21373	 21388	 21409	 21424	 21445	 21466	 21482
	 21497	 21513	 21528	 21544	 21559	 21575	 21590	 21606	 21621	 21645	 21660	 21681	 21696	 21719
	 21740	 21756	 21772	 21793	 21814	 21830	 21846	 21867	 21883	 21899	 21914	 21930	 21945	 21961
	 21976	 21992	 22016	 22041	 22058	 22088	 22103	 22124	 22144	 22165	 22185	 22206	 22226	 22248
	 22269	 22285	 22300	 22316	 22331	 22347	 22362	 22378	 22394	 22411	 22427	 22449	 22471	 22488
	 22504	 22526	 22549	 22566	 22582	 22607	 22622	 22645	 22667	 22684	 22699	 22721	 22742	 22765
	 22781	 22799	 22816	 22839	 22858	 22875	 22890	 22906	 22923	 22949	 23001	 23021	 23041	 23061
	 23081	 23101	 23121	 23141	 23161	 23181	 23201	 23221	 23241	 23261	 23281	 23301	 23321	 23341
	 23380	 23400	 23420	 23440	 23460	 23480	 23500	 23520	 23540	 23560	 23580	 23600	 23620	 23640
	 23660	 23680	 23700	 23720	 23761	 23781	 23801	 23821	 23841	 23861	 23881	 23901	 23921	 23941
	 23961	 23981	 24001	 24021	 24041	 24061	 24081	 24101	 24140	 24160	 24180	 24200	 24220	 24240
	 24260	 24280	 24300	 24320	 24340	 24360	 24380	 24400	 24420	 24440	 24460	 24480	 24525	 24546
	 24567	 24588	 24609	 24630	 24651	 24672	 24693	 24714	 24735	 24756	 24777	 24798	 24819	 24840
	 24861	 24880	 24920	 24941	 24962	 24983	 25004	 25025	 25046	 25067	 25088	 25109	 25130	 25151
	 25172	 25193	 25214	 25235	 25256	 25276	 25320	 25341	 25362	 25383	 25404	 25425	 25446	 25467
	 25488	 25509	 25530	 25551	 25572	 25593	 25614	 25635	 25656	 25676	 25716	 25737	 25758	 25779
	 25800	 25821	 25842	 25863	 25884	 25905	 25926	 25947	 25968	 25989	 26010	 26031	 26052	 26073
	 26097	 26112	 26126	 26141	 26217	 26235	 26253	 26271	 26289	 26307	 26325	 26343	 26361	 26379
	 26397	 26415	 26433	 26451	 26469	 26487	 26581	 26600	 26619	 26638	 26657	 26676	 26695	 26714
	 26733	 26752	 26771	 26790	 26809	 26828	 26847	 26883	 26901	 26919	 26937	 26955	 26973	 26991
	 27009	 27027	 27045	 27063	 27081	 27099	 27117	 27135	 27176	 27197	 27218	 27239	 27260	 27281
	 27302	 27323	 27344	 27365	 27386	 27407	 27428	 27449	 27470	 27493	 27540	 27564	 27588	 27612
	 27636	 27660	 27684	 27708	 27732	 27756	 27780	 27804	 27828	 27852	 27876	 27900	 27924	 27948
	 27995	 28019	 28043	 28067	 28091	 28115	 28139	 28163	 28187	 28211	 28235	 28259	 28283	 28307
	 28331	 28355	 28379	 28403	 28422	 28469	 28493	 28517	 28541	 28565	 28589	 28613	 28637	 28661
	 28685	 28709	 28733	 28757	 28781	 28805	 28829	 28853	 28877	 28924	 28948	 28972	 28996	 29020
	 29044	 29068	 29092	 29116	 29140	 29164	 29188	 29212	 29236	 29260	 29284	 29308	 29332	 29370
	 29384	 29398	 29412	 29426	 29440	 29454	 29468	 29482	 29496	 29510	 29524	 29538	 29552	 29566
	 29602	 29616	 29630	 29644	 29658	 29672	 29686	 29700	 29714	 29728	 29742	 29756	 29770	 29784
	 29798	 29818	 29834	 29851	 29857	 29875	 29881	 29905	 29930	 29936	 29953	 29959	 29972	 29976
	 29994	 30011	 30029	 30044	 30060	 30077	 30094	 30111	 30129	 30145	 30160	 30176	 30193	 30209
	 30226	 30243	 30260	 30278	 30297	 30315	 30330	 30346	 30366	 30383	 30403	 30426	 30449	 30469
	 30488	 30508	 30526	 30549	 30571	 30591	 30612	 30628	 30645	 30667	 30688	 30710	 30731	 30752
	 30764	 30780	 30798	 30813	 30827	 30841	 30854	 30869	 30884	 30901	 30907	 30914	 30921	 30938
	 30954	 30960	 30967	 30974	 30991	 30997	 31004	 31011	 31029	 31044	 31058	 31073	 31089	 31095
	 31102	 31109	 31126	 31132	 31139	 31146	 31169	 31188	 31212	 31231	 31255	 31272	 31287	 31301
	 31314	 31329	 31344	 31357	 31372	 31390	 31405	 31420	 31434	 31449	 31497	 31513	 31519	 31526
	 31533	 31550	 31556	 31563	 31570	 31588	 31603	 31617	 31632	 31649	 31655	 31670	 31685	 31701
	 31715	 31732	 31748	 31764	 31778	 31794	 31808	 31826	 31846	 31862	 31879	 31894	 31905	 31928
	 31948	 31967	 31988	 32008	 32025	 32041	 32105	 32121	 32136	 32152	 32167	 32183	 32199	 32216
	 32241	 32263	 32285	 32308	 32330	 32348	 32353	 32364	 32369	 32392	 32411	 32421	 32426	 32443
	 32457	 32472	 32482	 32487	 32500	 32504	 32516	 32520	 32538	 32555	 32573	 32589	 32607	 32621
	 32635	 32650	 32668	 32684	 32700	 32717	 32745	 32764	 32784	 32804	 32823	 32848	 32854	 32873
	 32879	 32895	 32901	 32917	 32934	 32940	 32959	 32966	 32987	 32993	 33012	 33019	 33040	 33046
	 33061	 33076	 33092	 33098	 33117	 33123	 33141	 33147	 33165	 33183	 33189	 33207	 33214	 33233
	 33239	 33257	 33264	 33286	 33303	 33319	 33335	 33350	 33367	 33382	 33398	 33413	 33430	 33445
	 33461	 33476	 33493	 33508	 33525	 33541	 33557	 33577	 33593	 33610	 33627	 33642	 33658	 33675
	 33689	 33703	 33718	 33731	 33745	 33764	 33770	 33789	 33795	 33812	 33818	 33837	 33843	 33860
	 33866	 33885	 33891	 33908	 33914	 33932	 33938	 33956	 33962	 33980	 33986	 34003	 34009	 34027
	 34033	 34051	 34057	 34075	 34081	 34098	 34104	 34122	 34128	 34146	 34152	 34170	 34176	 34194
	 34200	 34219	 34225	 34242	 34248	 34272	 34278	 34284	 34306	 34313	 34319	 34343	 34349	 34355
	 34376	 34382	 34388	 34410	 34416	 34422	 34442	 34448	 34454	 34476	 34482	 34488	 34508	 34514
	 34520	 34541	 34547	 34553	 34574	 34580	 34586	 34607	 34613	 34619	 34639	 34645	 34651	 34672
	 34678	 34684	 34705	 34711	 34717	 34738	 34744	 34750	 34770	 34776	 34782	 34803	 34809	 34815
	 34836	 34842	 34848	 34869	 34875	 34881	 34902	 34908	 34914	 34936	 34942	 34948	 34968	 34974
	 34980	 35001	 35007	 35025	 35031	 35049	 35055	 35074	 35080	 35097	 35103	 35122	 35128	 35145
	 35151	 35169	 35175	 35193	 35199	 35217	 35223	 35240	 35246	 35264	 35270	 35288	 35294	 35312
	 35318	 35335	 35341	 35359	 35365	 35383	 35389	 35406	 35412	 35431	 35437	 35455	 35461	 35479
	 35485	 35509	 35515	 35521	 35543	 35549	 35555	 35577	 35584	 35590	 35615	 35621	 35627	 35650
	 35656	 35662	 35682	 35688	 35694	 35717	 35723	 35729	 35749	 35755	 35761	 35782	 35788	 35794
	 35815	 35821	 35827	 35848	 35854	 35860	 35879	 35885	 35891	 35912	 35918	 35924	 35945	 35951
	 35957	 35978	 35984	 35990	 36010	 36016	 36022	 36043	 36049	 36055	 36076	 36082	 36088	 36109
	 36115	 36121	 36142	 36148	 36154	 36176	 36182	 36188	 36208	 36214	 36220	 36239	 36245	 36261
	 36267	 36281	 36287	 36302	 36308	 36322	 36328	 36344	 36361	 36367	 36386	 36393	 36412	 36418
	 36436	 36443	 36461	 36480	 36486	 36503	 36509	 36524	 36539	 36545	 36561	 36567	 36583	 36600
	 36606	 36623	 36629	 36646	 36652	 36666	 36682	 36688	 36703	 36721	 36727	 36742	 36760	 36766
	 36783	 36789	 36806	 36823	 36829	 36847	 36853	 36869	 36886	 36892	 36909	 36915	 36932	 36949
	 36955	 36973	 36979	 36995	 37013	 37019	 37036	 37042	 37059	 37076	 37082	 37100	 37106	 37122
	 37140	 37146	 37163	 37169	 37185	 37202	 37208	 37225	 37231	 37249	 37267	 37273	 37290	 37296
	 37316	 37322	 37341	 37347	 37364	 37370	 37388	 37394	 37415	 37421	 37437	 37443	 37463	 37469
	 37488	 37494	 37511	 37517	 37532	 37538	 37553	 37569	 37575	 37596	 37602	 37621	 37627	 37644
	 37650	 37669	 37675	 37695	 37701	 37717	 37723	 37743	 37749	 37768	 37774	 37791	 37797	 37816
	 37822	 37843	 37849	 37867	 37873	 37893	 37899	 37913	 37930	 37936	 37953	 37960	 37981	 37987
	 38007	 38013	 38033	 38040	 38058	 38064	 38084	 38090	 38109	 38115	 38131	 38137	 38151	 38168
	 38174	 38193	 38199	 38219	 38225	 38244	 38250	 38270	 38276	 38295	 38301	 38321	 38327	 38346
	 38352	 38369	 38375	 38390	 38396	 38413	 38419	 38433	 38439	 38454	 38460	 38474	 38480	 38495
	 38501	 38515	 38521	 38537	 38543	 38557	 38563	 38579	 38585	 38602	 38608	 38614	 38633	 38639
	 38645	 38661	 38667	 38673	 38690	 38696	 38713	 38719	 38725	 38744	 38750	 38756	 38772	 38778
	 38795	 38801	 38817	 38823	 38840	 38846	 38863	 38869	 38888	 38894	 38911	 38917	 38936	 38942
	 38958	 38964	 38981	 38987	 39003	 39009	 39026	 39032	 39049	 39055	 39074	 39080	 39097	 39103
	 39122	 39128	 39146	 39152	 39158	 39177	 39183	 39189	 39208	 39214	 39220	 39241	 39247	 39253
	 39272	 39278	 39284	 39305	 39311	 39317	 39335	 39341	 39347	 39353	 39371	 39377	 39383	 39400
	 39406	 39412	 39430	 39436	 39442	 39461	 39467	 39473	 39494	 39500	 39506	 39525	 39531	 39537
	 39558	 39564	 39570	 39586	 39592	 39609	 39615	 39631	 39637	 39654	 39660	 39677	 39683	 39702
	 39708	 39725	 39731	 39750	 39756	 39772	 39778	 39795	 39801	 39817	 39823	 39840	 39846	 39863
	 39869	 39888	 39894	 39911	 39917	 39936	 39942	 39960	 39966	 39972	 39991	 39997	 40003	 40022
	 40028	 40034	 40055	 40061	 40067	 40086	 40092	 40113	 40119	 40125	 40142	 40148	 40154	 40172
	 40178	 40184	 40201	 40207	 40213	 40231	 40237	 40243	 40262	 40268	 40274	 40295	 40301	 40307
	 40326	 40332	 40338	 40359	 40365	 40371	 40387	 40393	 40410	 40416	 40432	 40438	 40455	 40461
	 40478	 40484	 40503	 40509	 40526	 40532	 40551	 40557	 40573	 40579	 40596	 40602	 40618	 40624
	 40641	 40647	 40664	 40670	 40689	 40695	 40712	 40718	 40737	 40743	 40762	 40768	 40774	 40795
	 40801	 40807	 40826	 40832	 40838	 40860	 40866	 40872	 40889	 40895	 40901	 40919	 40925	 40931
	 40948	 40954	 40960	 40978	 40984	 40990	 41009	 41015	 41021	 41042	 41048	 41054	 41073	 41079
	 41085	 41106	 41112	 41118	 41135	 41151	 41165	 41181	 41196	 41213	 41229	 41248	 41263	 41284
	 41306	 41325	 41341	 41355	 41359	 41374	 41393	 41406	 41409	 41420	 41424	 41445	 41460	 41478
	 41494	 41509	 41525	 41542	 41560	 41577	 41595	 41601	 41617	 41633	 41652	 41668	 41684	 41701
	 41717	 41730	 41741	 41742	 41744	 41757	 41758	 41762	 41779	 41796	 41812	 41819	 41832	 41839
	 41851	 41852	 41855	 41870	 41890	 41906	 41924	 41937	 41938	 41940	 41944	 41964	 41970	 41987
	 41993	 42010	 42016	 42034	 42040	 42057	 42063	 42081	 42087	 42103	 42109	 42126	 42132	 42149
	 42155	 42173	 42179	 42196	 42202	 42220	 42226	 42241	 42247	 42264	 42270	 42286	 42292	 42309
	 42315	 42331	 42337	 42354	 42360	 42375	 42381	 42398	 42404	 42420	 42426	 42443	 42449	 42465
	 42471	 42488	 42494	 42511	 42517	 42535	 42541	 42558	 42564	 42582	 42588	 42605	 42611	 42629
	 42635	 42652	 42658	 42676	 42682	 42699	 42705	 42723	 42729	 42746	 42752	 42770	 42776	 42793
	 42799	 42817	 42823	 42840	 42846	 42864	 42870	 42887	 42893	 42911	 42917	 43301	 43308	 43315
	 43322	 43329	 43335	 43345	 43353	 43363	 43370	 43381	 43389	 43402	 43409	 43422	 43432	 43440
	 43451	 43461	 43472	 43480	 43488	 43496	 43504	 43512	 43519	 43526	 43533	 43542	 43549	 43557
	 43565	 43572	 43580	 43595	 43602	 43613	 43621	 43631	 43639	 43650	 43657	 43669	 43677	 43691
	 43697	 43705	 43718	 43724	 43734	 43742	 43750	 43771	 43779	 43786	 43794	 43800	 43808	 43815
	 43823	 43830	 43838	 43845	 43853	 43860	 43868	 43901	 43907	 43929	 43935	 43957	 43963	 43985
	 43991	 44013	 44019	 44041	 44047	 44069	 44075	 44116	 44122	 44148	 44154	 44180	 44186	 44212
	 44218	 44244	 44250	 44276	 44282	 44308	 44314	 44366	 44372	 44408	 44414	 44450	 44456	 44492
	 44498	 44534	 44540	 44576	 44582	 44618	 44624	 44657	 44664	 44679	 44686	 44701	 44708	 44722
	 44729	 44744	 44750	 44768	 44775	 44790	 44797	 44812	 44819	 44833	 44840	 44855	 44861	 44879
	 44886	 44901	 44908	 44923	 44930	 44944	 44951	 44966	 44972	 44990	 44997	 45012	 45019	 45034
	 45041	 45055	 45062	 45077	 45083	 45101	 45108	 45123	 45130	 45145	 45152	 45166	 45173	 45188
	 45194	 45212	 45219	 45234	 45241	 45256	 45263	 45277	 45284	 45299	 45305	 45323	 45330	 45345
	 45352	 45367	 45374	 45388	 45395	 45410	 45416	 45434	 45441	 45456	 45463	 45478	 45485	 45499
	 45506	 45521	 45527	 45545	 45552	 45567	 45574	 45589	 45596	 45610	 45617	 45632	 45638	 45656
	 45663	 45678	 45685	 45700	 45707	 45721	 45728	 45743	 45749	 45790	 45796	 45821	 45827	 45852
	 45858	 45883	 45889	 45914	 45920	 45945	 45951	 45976	 45982	 46463	 46500	 46537	 46574	 46611
	 46648	 46685	 46722	 46759	 46796	 46833	 46870	 46907	 46944	 46981	 47018	 47055	 47092	 47129
	 47166	 47203	 47243	 47250	 47275	 47282	 47311	 47318	 47343	 47350	 47379	 47386	 47411	 47418
	 47447	 47454	 47479	 47486	 47515	 47522	 47547	 47554	 47583	 47590	 47615	 47622	 47651	 47658
	 47683	 47690	 47728	 47734	 47764	 47770	 47800	 47806	 47836	 47842	 47872	 47878	 47908	 47914
	 47944	 47950	 47983	 48026	 48048	 48070	 48092	 48114	 48136	 48158	 48172	 48183	 48212	 48217
	 48232	 48237	 48252	 48257	 48272	 48277	 48292	 48297	 48312	 48317	 48332	 48337	 48352	 48357
	 48372	 48377	 48392	 48397	 48412	 48417	 48432	 48437	 48452	 48457	 48472	 48477	 48492	 48497
	 48512	 48517	 48532	 48537	 48552	 48557	 48584	 48589	 48594	 48624	 48629	 48634	 48664	 48669
	 48674	 48704	 48709	 48714	 48744	 48749	 48754	 48784	 48789	 48794	 48824	 48829	 48834	 48872
	 48876	 48882	 48888	 48913	 48917	 48923	 48929	 48954	 48958	 48964	 48970	 48995	 48999	 49005
	 49011	 49036	 49040	 49046	 49052	 49077	 49081	 49087	 49093	 49118	 49122	 49128	 49134	 49159
	 49163	 49169	 49175	 49200	 49204	 49210	 49216	 49241	 49245	 49251	 49257	 49282	 49286	 49292
	 49298	 49323	 49327	 49333	 49339	 49364	 49368	 49374	 49380	 49405	 49409	 49415	 49421	 49446
	 49450	 49456	 49462	 49487	 49491	 49497	 49503	 49528	 49532	 49538	 49544	 49569	 49573	 49579
	 49585	 49610	 49614	 49620	 49626	 49651	 49655	 49661	 49667	 49692	 49696	 49702	 49708	 49733
	 49737	 49743	 49749	 49774	 49778	 49784	 49790	 49815	 49819	 49825	 49831	 49856	 49860	 49866
	 49872	 49897	 49901	 49907	 49913	 49938	 49942	 49948	 49954	 49979	 49983	 49989	 49995	 50020
	 50024	 50030	 50036	 50061	 50065	 50071	 50077	 50102	 50106	 50112	 50118	 50148	 50153	 50159
	 50177	 50182	 50188	 50206	 50211	 50217	 50235	 50240	 50246	 50264	 50269	 50275	 50293	 50298
	 50304	 50322	 50327	 50333	 50351	 50356	 50362	 50380	 50385	 50391	 50409	 50414	 50420	 50438
	 50443	 50449	 50467	 50472	 50478	 50496	 50501	 50507	 50525	 50530	 50536	 50554	 50559	 50565
	 50583	 50588	 50594	 50612	 50617	 50623	 50641	 50646	 50652	 50670	 50675	 50681	 50698	 50703
	 50709	 50726	 50731	 50737	 50754	 50759	 50765	 50781	 50785	 50797	 50801	 50813	 50817	 50839
	 50844	 50850	 50871	 50876	 50882	 50903	 50908	 50914	 50935	 50940	 50946	 50967	 50972	 50978
	 50999	 51004	 51010	 51031	 51036	 51042	 51063	 51068	 51074	 51108	 51109	 51110	 51111	 51116
	 51120	 51125	 51132	 51151	 51157	 51176	 51182	 51252	 51257	 51262	 51264	 51266	 51268	 51270
	 51272	 51274	 51276	 51283	 51284	 51285	 51286	 51287	 51288	 51289	 51290	 51291	 51293	 51295
	 51296
HALTPI	 42943	 43764	 44641	 45996	 46021	 46042	 46063	 46084	 46106	 46127	 46156	 46174	 46192	 46210
	 46228	 46246	 46264	 46282	 46299	 46316	 46333	 46350	 46367	 46384	 46401	 46418	 46447	 46484
	 46521	 46558	 46595	 46632	 46669	 46706	 46743	 46780	 46817	 46854	 46891	 46928	 46965	 47002
	 47039	 47076	 47113	 47150	 47187	 47229	 47261	 47297	 47329	 47365	 47397	 47433	 47465	 47501
	 47533	 47569	 47601	 47637	 47669
INDPI	 43261#	 48563	 48603	 48643	 48683	 48723	 48763	 48803
JEN	   164#	 47725	 47761	 47797	 47833	 47869	 47905	 47941	 48597	 48637	 48677	 48717	 48757	 48797
	 48837
JRSTF	   163#	 43712	 46013	 46034	 46055	 46076	 46097	 46119	 46140	 46172	 46190	 46208	 46226	 46244
	 46262	 46280	 46314	 46331	 46348	 46365	 46382	 46399	 46416	 46442	 46479	 46516	 46553	 46590
	 46627	 46664	 46701	 46738	 46775	 46812	 46849	 46886	 46923	 46960	 46997	 47034	 47071	 47108
	 47145	 47182	 51146	 51172	 51256
MAPADR	   299#
MAPCNK	   300#
MAPMEM	   296#
MAPPNT	   302#
MAPSET	   301#
MEMSEG	   298#
MEMZRO	   297#
MODPCP	   309#
MODPCU	   308#
MTROP	   277#
NAME	     8#	    11
PBELL	   252#
PCRL	   246#
PCRL2	   250#
PCRL2F	   251#
PCRLF	   247#
PFORCE	   254#
PGMINT	   170#
PIDIS	 43047#	 47709	 47745	 47781	 47817	 47853	 47889	 47925
PIHCLR	 43017#	 45772	 45803	 45834	 45865	 45896	 45927	 45958
PINO	 42990#	 43883	 43911	 43939	 43967	 43995	 44023	 44051
PIONOF	 43030#	 44336	 44378	 44420	 44462	 44504	 44546	 44588
PITEST	 43064#	 44643	 44754	 44865	 44976	 45087	 45198	 45309	 45420	 45531	 45642
PIYES	 43003#	 44097	 44129	 44161	 44193	 44225	 44257	 44289
PJRST	   161#
PMSG	   256#
PMSGF	   259#
PNT1	   212#
PNT11	   226#
PNT11F	   227#
PNT1F	   213#
PNT2	   214#
PNT2F	   215#
PNT3	   216#
PNT3F	   217#
PNT4	   218#
PNT4F	   219#
PNT5	   220#
PNT5F	   221#
PNT6	   222#
PNT6F	   223#
PNT7	   224#
PNT7F	   225#
PNTA	   198#
PNTADF	   229#
PNTADR	   228#
PNTAF	   199#
PNTAL	   200#
PNTALF	   201#
PNTCHF	   211#
PNTCHR	   210#
PNTCI	   208#
PNTCIF	   209#
PNTCW	   244#
PNTCWF	   245#
PNTDCF	   237#
PNTDEC	   236#
PNTDS	   238#
PNTDSF	   239#
PNTHW	   232#
PNTHWF	   233#
PNTMGN	   323#
PNTMSF	   205#
PNTMSG	   204#
PNTNM	   240#
PNTOCF	   235#
PNTOCS	   234#
PNTOCT	   230#
PNTOTF	   231#
PNTSIX	   241#
PNTSXF	   242#
PSIXL	   202#
PSIXLF	   203#
PSIXM	   206#
PSIXMF	   207#
PSKPA	 43195#	 47221	 47289	 47357	 47425	 47493	 47561	 47629
PSKPB	 43217#	 47253	 47321	 47389	 47457	 47525	 47593	 47661
PSP	   248#
PSPF	   249#
PUT	   159#
REPTUO	   337#
RTN	   158#	   454
S	    88#
SBWAIT	 43172#	 46304	 46321	 46338	 46355	 46372	 46389	 46406
SFLAG	    60#	 30396	 30418	 30441	 30462	 30481	 30501	 30518	 30539	 30561	 30659	 30680	 30702	 30723
	 30744	 31160	 31180	 31199	 31204	 31223	 31242	 31247	 32231	 32253	 32274	 32298	 32319	 32342
	 32732	 32737	 32756	 32774	 32795	 32815	 41276	 41295	 41315	 41384	 41435
SIXBTZ	   265#
STOP	    52#	   970	   983	   997	  1014	  1029	  1048	  1062	  1076	  1090	  1104	  1118	  1131	  1145
	  1160	  1174	  1187	  1201	  1215	  1228	  1242	  1256	  1269	  1283	  1297	  1334	  1353	  1372
	  1391	  1410	  1429	  1448	  1467	  1486	  1505	  1524	  1543	  1562	  1581	  1600	  1619	  1638
	  1657	  1676	  1695	  1714	  1733	  1752	  1771	  1790	  1809	  1828	  1847	  1866	  1885	  1904
	  1923	  1942	  1961	  1980	  1999	  2014	  2032	  2047	  2063	  2088	  2106	  2124	  2137	  2151
	  2176	  2223	  2229	  2252	  2258	  2281	  2287	  2310	  2316	  2334	  2353	  2371	  2389	  2405
	  2421	  2436	  2453	  2473	  2510	  2529	  2548	  2567	  2586	  2605	  2624	  2643	  2662	  2681
	  2700	  2719	  2738	  2757	  2776	  2795	  2814	  2833	  2870	  2889	  2908	  2927	  2946	  2965
	  2984	  3003	  3022	  3041	  3060	  3079	  3098	  3117	  3136	  3155	  3174	  3193	  3210	  3226
	  3246	  3264	  3285	  3333	  3339	  3362	  3368	  3391	  3397	  3420	  3426	  3449	  3455	  3478
	  3484	  3507	  3513	  3536	  3542	  3565	  3571	  3594	  3600	  3623	  3629	  3652	  3658	  3681
	  3687	  3710	  3716	  3739	  3745	  3768	  3774	  3797	  3803	  3826	  3832	  3855	  3861	  3884
	  3890	  3913	  3919	  3942	  3948	  3971	  3977	  4000	  4006	  4029	  4035	  4058	  4064	  4087
	  4093	  4116	  4122	  4145	  4151	  4174	  4180	  4203	  4209	  4232	  4238	  4261	  4267	  4290
	  4296	  4319	  4325	  4348	  4354	  4395	  4416	  4437	  4458	  4479	  4500	  4521	  4542	  4563
	  4584	  4605	  4626	  4647	  4668	  4689	  4710	  4731	  4752	  4773	  4794	  4815	  4836	  4857
	  4878	  4899	  4920	  4941	  4962	  4983	  5004	  5025	  5046	  5067	  5088	  5109	  5130	  5148
	  5165	  5185	  5203	  5219	  5258	  5278	  5298	  5318	  5338	  5358	  5378	  5398	  5418	  5438
	  5458	  5478	  5498	  5518	  5538	  5558	  5578	  5598	  5618	  5638	  5658	  5678	  5698	  5718
	  5738	  5758	  5778	  5798	  5818	  5838	  5858	  5878	  5898	  5918	  5938	  5958	  6003	  6028
	  6053	  6078	  6103	  6128	  6153	  6178	  6203	  6228	  6253	  6278	  6303	  6328	  6353	  6378
	  6403	  6428	  6453	  6478	  6503	  6528	  6553	  6578	  6603	  6628	  6653	  6678	  6703	  6728
	  6753	  6778	  6803	  6828	  6853	  6878	  6925	  6946	  6967	  6988	  7009	  7030	  7051	  7072
	  7093	  7114	  7135	  7156	  7177	  7198	  7219	  7240	  7261	  7282	  7303	  7324	  7345	  7366
	  7387	  7408	  7429	  7450	  7471	  7492	  7513	  7534	  7555	  7576	  7597	  7618	  7639	  7660
	  7675	  7693	  7736	  7758	  7780	  7802	  7824	  7846	  7868	  7890	  7912	  7934	  7956	  7978
	  8000	  8022	  8044	  8066	  8088	  8110	  8154	  8176	  8198	  8220	  8242	  8264	  8286	  8308
	  8330	  8352	  8374	  8396	  8418	  8440	  8462	  8484	  8506	  8528	  8548	  8568	  8615	  8639
	  8663	  8687	  8711	  8735	  8759	  8783	  8807	  8831	  8855	  8879	  8903	  8927	  8951	  8975
	  8999	  9023	  9047	  9071	  9095	  9119	  9143	  9167	  9191	  9215	  9239	  9263	  9287	  9311
	  9335	  9359	  9383	  9407	  9431	  9455	  9476	  9499	  9520	  9542	  9559	  9577	  9634	  9664
	  9694	  9724	  9754	  9784	  9814	  9844	  9874	  9904	  9934	  9964	  9994	 10024	 10054	 10084
	 10114	 10144	 10174	 10204	 10234	 10264	 10294	 10324	 10354	 10384	 10414	 10444	 10474	 10504
	 10534	 10564	 10594	 10624	 10654	 10684	 10705	 10762	 10788	 10814	 10840	 10866	 10892	 10918
	 10944	 10970	 10996	 11022	 11048	 11074	 11100	 11126	 11152	 11178	 11204	 11230	 11256	 11282
	 11308	 11334	 11360	 11386	 11412	 11438	 11464	 11490	 11516	 11542	 11568	 11594	 11620	 11646
	 11672	 11725	 11750	 11775	 11800	 11825	 11850	 11875	 11900	 11925	 11950	 11975	 12000	 12025
	 12050	 12075	 12100	 12125	 12150	 12175	 12200	 12225	 12250	 12275	 12300	 12325	 12350	 12375
	 12400	 12425	 12450	 12475	 12500	 12525	 12550	 12575	 12628	 12654	 12680	 12706	 12732	 12758
	 12784	 12810	 12836	 12862	 12888	 12914	 12940	 12966	 12992	 13018	 13044	 13070	 13124	 13150
	 13176	 13202	 13228	 13254	 13280	 13306	 13332	 13358	 13384	 13410	 13436	 13462	 13488	 13514
	 13540	 13566	 13585	 13602	 13619	 13635	 13652	 13669	 13685	 13702	 13719	 13735	 13750	 13767
	 13785	 13822	 13840	 13858	 13876	 13894	 13912	 13930	 13948	 13966	 13984	 14002	 14020	 14038
	 14056	 14074	 14092	 14110	 14128	 14146	 14164	 14182	 14200	 14218	 14236	 14254	 14272	 14290
	 14308	 14326	 14344	 14362	 14380	 14398	 14416	 14434	 14452	 14468	 14482	 14504	 14522	 14541
	 14563	 14586	 14609	 14632	 14646	 14668	 14683	 14705	 14720	 14736	 14756	 14777	 14802	 14855
	 14882	 14909	 14936	 14963	 14990	 15017	 15044	 15071	 15098	 15125	 15152	 15179	 15206	 15233
	 15260	 15287	 15314	 15361	 15383	 15405	 15427	 15449	 15471	 15493	 15515	 15537	 15559	 15581
	 15603	 15625	 15647	 15669	 15691	 15713	 15735	 15770	 15788	 15806	 15824	 15842	 15860	 15878
	 15896	 15914	 15932	 15950	 15968	 15986	 16004	 16022	 16040	 16058	 16076	 16094	 16112	 16130
	 16148	 16166	 16184	 16202	 16220	 16238	 16256	 16274	 16292	 16310	 16328	 16346	 16364	 16382
	 16400	 16435	 16453	 16471	 16489	 16507	 16525	 16543	 16561	 16579	 16597	 16615	 16633	 16651
	 16669	 16687	 16705	 16723	 16741	 16759	 16777	 16795	 16813	 16831	 16849	 16867	 16885	 16903
	 16921	 16939	 16957	 16975	 16993	 17011	 17029	 17047	 17065	 17108	 17128	 17148	 17168	 17188
	 17208	 17228	 17248	 17268	 17288	 17308	 17328	 17348	 17368	 17388	 17408	 17428	 17448	 17487
	 17507	 17527	 17547	 17567	 17587	 17607	 17627	 17647	 17667	 17687	 17707	 17727	 17747	 17767
	 17787	 17807	 17827	 17877	 17902	 17927	 17952	 17977	 18002	 18027	 18052	 18077	 18102	 18127
	 18152	 18177	 18202	 18227	 18252	 18277	 18302	 18352	 18377	 18402	 18427	 18452	 18477	 18502
	 18527	 18552	 18577	 18602	 18627	 18652	 18677	 18702	 18727	 18752	 18777	 18796	 18820	 18840
	 18858	 18874	 18889	 18910	 18930	 18952	 18966	 18982	 19004	 19022	 19046	 19069	 19090	 19116
	 19144	 19162	 19178	 19202	 19218	 19235	 19256	 19272	 19295	 19317	 19334	 19350	 19367	 19383
	 19407	 19429	 19445	 19460	 19476	 19492	 19519	 19539	 19555	 19570	 19586	 19602	 19630	 19645
	 19661	 19676	 19692	 19710	 19732	 19755	 19769	 19787	 19807	 19831	 19847	 19867	 19890	 19907
	 19925	 19941	 19967	 19988	 20006	 20022	 20045	 20067	 20091	 20107	 20125	 20140	 20164	 20185
	 20202	 20223	 20237	 20260	 20275	 20292	 20317	 20340	 20361	 20376	 20400	 20416	 20435	 20448
	 20461	 20473	 20489	 20503	 20519	 20539	 20560	 20577	 20611	 20628	 20646	 20663	 20681	 20704
	 20722	 20739	 20758	 20781	 20802	 20819	 20835	 20852	 20867	 20889	 20911	 20928	 20944	 20960
	 20981	 20998	 21014	 21031	 21047	 21064	 21080	 21097	 21112	 21129	 21144	 21160	 21181	 21202
	 21217	 21238	 21258	 21274	 21289	 21310	 21325	 21341	 21356	 21372	 21387	 21408	 21423	 21444
	 21465	 21481	 21496	 21512	 21527	 21543	 21558	 21574	 21589	 21605	 21620	 21644	 21659	 21680
	 21695	 21718	 21739	 21755	 21771	 21792	 21813	 21829	 21845	 21866	 21882	 21898	 21913	 21929
	 21944	 21960	 21975	 21991	 22015	 22040	 22057	 22087	 22102	 22123	 22143	 22164	 22184	 22205
	 22225	 22247	 22268	 22284	 22299	 22315	 22330	 22346	 22361	 22377	 22393	 22410	 22426	 22448
	 22470	 22487	 22503	 22525	 22548	 22565	 22581	 22606	 22621	 22644	 22666	 22683	 22698	 22720
	 22740	 22763	 22779	 22798	 22815	 22838	 22857	 22874	 22889	 22905	 22922	 22948	 23000	 23020
	 23040	 23060	 23080	 23100	 23120	 23140	 23160	 23180	 23200	 23220	 23240	 23260	 23280	 23300
	 23320	 23340	 23379	 23399	 23419	 23439	 23459	 23479	 23499	 23519	 23539	 23559	 23579	 23599
	 23619	 23639	 23659	 23679	 23699	 23719	 23760	 23780	 23800	 23820	 23840	 23860	 23880	 23900
	 23920	 23940	 23960	 23980	 24000	 24020	 24040	 24060	 24080	 24100	 24139	 24159	 24179	 24199
	 24219	 24239	 24259	 24279	 24299	 24319	 24339	 24359	 24379	 24399	 24419	 24439	 24459	 24479
	 24524	 24545	 24566	 24587	 24608	 24629	 24650	 24671	 24692	 24713	 24734	 24755	 24776	 24797
	 24818	 24839	 24860	 24879	 24919	 24940	 24961	 24982	 25003	 25024	 25045	 25066	 25087	 25108
	 25129	 25150	 25171	 25192	 25213	 25234	 25255	 25275	 25319	 25340	 25361	 25382	 25403	 25424
	 25445	 25466	 25487	 25508	 25529	 25550	 25571	 25592	 25613	 25634	 25655	 25675	 25715	 25736
	 25757	 25778	 25799	 25820	 25841	 25862	 25883	 25904	 25925	 25946	 25967	 25988	 26009	 26030
	 26051	 26072	 26096	 26111	 26125	 26140	 26216	 26234	 26252	 26270	 26288	 26306	 26324	 26342
	 26360	 26378	 26396	 26414	 26432	 26450	 26468	 26486	 26580	 26599	 26618	 26637	 26656	 26675
	 26694	 26713	 26732	 26751	 26770	 26789	 26808	 26827	 26846	 26882	 26900	 26918	 26936	 26954
	 26972	 26990	 27008	 27026	 27044	 27062	 27080	 27098	 27116	 27134	 27175	 27196	 27217	 27238
	 27259	 27280	 27301	 27322	 27343	 27364	 27385	 27406	 27427	 27448	 27469	 27492	 27539	 27563
	 27587	 27611	 27635	 27659	 27683	 27707	 27731	 27755	 27779	 27803	 27827	 27851	 27875	 27899
	 27923	 27947	 27994	 28018	 28042	 28066	 28090	 28114	 28138	 28162	 28186	 28210	 28234	 28258
	 28282	 28306	 28330	 28354	 28378	 28402	 28421	 28468	 28492	 28516	 28540	 28564	 28588	 28612
	 28636	 28660	 28684	 28708	 28732	 28756	 28780	 28804	 28828	 28852	 28876	 28923	 28947	 28971
	 28995	 29019	 29043	 29067	 29091	 29115	 29139	 29163	 29187	 29211	 29235	 29259	 29283	 29307
	 29331	 29369	 29383	 29397	 29411	 29425	 29439	 29453	 29467	 29481	 29495	 29509	 29523	 29537
	 29551	 29565	 29601	 29615	 29629	 29643	 29657	 29671	 29685	 29699	 29713	 29727	 29741	 29755
	 29769	 29783	 29797	 29817	 29833	 29850	 29856	 29874	 29880	 29904	 29929	 29935	 29952	 29958
	 29975	 29993	 30010	 30028	 30043	 30059	 30076	 30093	 30110	 30128	 30144	 30159	 30175	 30192
	 30208	 30225	 30242	 30259	 30277	 30296	 30314	 30329	 30345	 30365	 30382	 30402	 30425	 30448
	 30468	 30487	 30507	 30525	 30548	 30570	 30590	 30610	 30627	 30644	 30666	 30687	 30709	 30730
	 30751	 30763	 30779	 30797	 30812	 30826	 30840	 30853	 30868	 30883	 30900	 30906	 30913	 30920
	 30937	 30953	 30959	 30966	 30973	 30990	 30996	 31003	 31010	 31028	 31043	 31057	 31072	 31088
	 31094	 31101	 31108	 31125	 31131	 31138	 31145	 31168	 31187	 31211	 31230	 31254	 31271	 31286
	 31300	 31313	 31328	 31343	 31356	 31371	 31389	 31404	 31419	 31433	 31448	 31496	 31512	 31518
	 31525	 31532	 31549	 31555	 31562	 31569	 31587	 31602	 31616	 31631	 31648	 31654	 31669	 31684
	 31700	 31714	 31731	 31747	 31763	 31777	 31793	 31807	 31825	 31845	 31861	 31878	 31893	 31904
	 31927	 31947	 31966	 31987	 32007	 32024	 32040	 32104	 32120	 32135	 32151	 32166	 32182	 32198
	 32215	 32240	 32262	 32284	 32307	 32329	 32352	 32368	 32391	 32410	 32425	 32442	 32456	 32471
	 32486	 32503	 32519	 32537	 32554	 32572	 32588	 32606	 32620	 32634	 32649	 32667	 32683	 32699
	 32716	 32744	 32763	 32783	 32803	 32822	 32847	 32853	 32872	 32878	 32894	 32900	 32916	 32933
	 32939	 32958	 32965	 32986	 32992	 33011	 33018	 33039	 33045	 33060	 33075	 33091	 33097	 33116
	 33122	 33140	 33146	 33164	 33182	 33188	 33206	 33213	 33232	 33238	 33256	 33263	 33285	 33302
	 33318	 33334	 33349	 33366	 33381	 33397	 33412	 33429	 33444	 33460	 33475	 33492	 33507	 33524
	 33540	 33556	 33576	 33592	 33609	 33626	 33641	 33657	 33674	 33688	 33702	 33717	 33730	 33744
	 33763	 33769	 33788	 33794	 33811	 33817	 33836	 33842	 33859	 33865	 33884	 33890	 33907	 33913
	 33931	 33937	 33955	 33961	 33979	 33985	 34002	 34008	 34026	 34032	 34050	 34056	 34074	 34080
	 34097	 34103	 34121	 34127	 34145	 34151	 34169	 34175	 34193	 34199	 34218	 34224	 34241	 34247
	 34271	 34277	 34283	 34305	 34312	 34318	 34342	 34348	 34354	 34375	 34381	 34387	 34409	 34415
	 34421	 34441	 34447	 34453	 34475	 34481	 34487	 34507	 34513	 34519	 34540	 34546	 34552	 34573
	 34579	 34585	 34606	 34612	 34618	 34638	 34644	 34650	 34671	 34677	 34683	 34704	 34710	 34716
	 34737	 34743	 34749	 34769	 34775	 34781	 34802	 34808	 34814	 34835	 34841	 34847	 34868	 34874
	 34880	 34901	 34907	 34913	 34935	 34941	 34947	 34967	 34973	 34979	 35000	 35006	 35024	 35030
	 35048	 35054	 35073	 35079	 35096	 35102	 35121	 35127	 35144	 35150	 35168	 35174	 35192	 35198
	 35216	 35222	 35239	 35245	 35263	 35269	 35287	 35293	 35311	 35317	 35334	 35340	 35358	 35364
	 35382	 35388	 35405	 35411	 35430	 35436	 35454	 35460	 35478	 35484	 35508	 35514	 35520	 35542
	 35548	 35554	 35576	 35583	 35589	 35614	 35620	 35626	 35649	 35655	 35661	 35681	 35687	 35693
	 35716	 35722	 35728	 35748	 35754	 35760	 35781	 35787	 35793	 35814	 35820	 35826	 35847	 35853
	 35859	 35878	 35884	 35890	 35911	 35917	 35923	 35944	 35950	 35956	 35977	 35983	 35989	 36009
	 36015	 36021	 36042	 36048	 36054	 36075	 36081	 36087	 36108	 36114	 36120	 36141	 36147	 36153
	 36175	 36181	 36187	 36207	 36213	 36219	 36238	 36244	 36260	 36266	 36280	 36286	 36301	 36307
	 36321	 36327	 36343	 36360	 36366	 36385	 36392	 36411	 36417	 36435	 36442	 36460	 36479	 36485
	 36502	 36508	 36523	 36538	 36544	 36560	 36566	 36582	 36599	 36605	 36622	 36628	 36645	 36651
	 36665	 36681	 36687	 36702	 36720	 36726	 36741	 36759	 36765	 36782	 36788	 36805	 36822	 36828
	 36846	 36852	 36868	 36885	 36891	 36908	 36914	 36931	 36948	 36954	 36972	 36978	 36994	 37012
	 37018	 37035	 37041	 37058	 37075	 37081	 37099	 37105	 37121	 37139	 37145	 37162	 37168	 37184
	 37201	 37207	 37224	 37230	 37248	 37266	 37272	 37289	 37295	 37315	 37321	 37340	 37346	 37363
	 37369	 37387	 37393	 37414	 37420	 37436	 37442	 37462	 37468	 37487	 37493	 37510	 37516	 37531
	 37537	 37552	 37568	 37574	 37595	 37601	 37620	 37626	 37643	 37649	 37668	 37674	 37694	 37700
	 37716	 37722	 37742	 37748	 37767	 37773	 37790	 37796	 37815	 37821	 37842	 37848	 37866	 37872
	 37892	 37898	 37912	 37929	 37935	 37952	 37959	 37980	 37986	 38006	 38012	 38032	 38039	 38057
	 38063	 38083	 38089	 38108	 38114	 38130	 38136	 38150	 38167	 38173	 38192	 38198	 38218	 38224
	 38243	 38249	 38269	 38275	 38294	 38300	 38320	 38326	 38345	 38351	 38368	 38374	 38389	 38395
	 38412	 38418	 38432	 38438	 38453	 38459	 38473	 38479	 38494	 38500	 38514	 38520	 38536	 38542
	 38556	 38562	 38578	 38584	 38601	 38607	 38613	 38632	 38638	 38644	 38660	 38666	 38672	 38689
	 38695	 38712	 38718	 38724	 38743	 38749	 38755	 38771	 38777	 38794	 38800	 38816	 38822	 38839
	 38845	 38862	 38868	 38887	 38893	 38910	 38916	 38935	 38941	 38957	 38963	 38980	 38986	 39002
	 39008	 39025	 39031	 39048	 39054	 39073	 39079	 39096	 39102	 39121	 39127	 39145	 39151	 39157
	 39176	 39182	 39188	 39207	 39213	 39219	 39240	 39246	 39252	 39271	 39277	 39283	 39304	 39310
	 39316	 39334	 39340	 39346	 39352	 39370	 39376	 39382	 39399	 39405	 39411	 39429	 39435	 39441
	 39460	 39466	 39472	 39493	 39499	 39505	 39524	 39530	 39536	 39557	 39563	 39569	 39585	 39591
	 39608	 39614	 39630	 39636	 39653	 39659	 39676	 39682	 39701	 39707	 39724	 39730	 39749	 39755
	 39771	 39777	 39794	 39800	 39816	 39822	 39839	 39845	 39862	 39868	 39887	 39893	 39910	 39916
	 39935	 39941	 39959	 39965	 39971	 39990	 39996	 40002	 40021	 40027	 40033	 40054	 40060	 40066
	 40085	 40091	 40112	 40118	 40124	 40141	 40147	 40153	 40171	 40177	 40183	 40200	 40206	 40212
	 40230	 40236	 40242	 40261	 40267	 40273	 40294	 40300	 40306	 40325	 40331	 40337	 40358	 40364
	 40370	 40386	 40392	 40409	 40415	 40431	 40437	 40454	 40460	 40477	 40483	 40502	 40508	 40525
	 40531	 40550	 40556	 40572	 40578	 40595	 40601	 40617	 40623	 40640	 40646	 40663	 40669	 40688
	 40694	 40711	 40717	 40736	 40742	 40761	 40767	 40773	 40794	 40800	 40806	 40825	 40831	 40837
	 40859	 40865	 40871	 40888	 40894	 40900	 40918	 40924	 40930	 40947	 40953	 40959	 40977	 40983
	 40989	 41008	 41014	 41020	 41041	 41047	 41053	 41072	 41078	 41084	 41105	 41111	 41117	 41134
	 41150	 41164	 41180	 41195	 41212	 41228	 41247	 41262	 41283	 41305	 41324	 41340	 41358	 41373
	 41392	 41408	 41423	 41444	 41459	 41477	 41493	 41508	 41524	 41541	 41559	 41576	 41594	 41600
	 41616	 41632	 41651	 41667	 41683	 41700	 41716	 41729	 41743	 41761	 41778	 41795	 41811	 41818
	 41831	 41838	 41854	 41869	 41889	 41904	 41923	 41943	 41963	 41969	 41986	 41992	 42009	 42015
	 42033	 42039	 42056	 42062	 42080	 42086	 42102	 42108	 42125	 42131	 42148	 42154	 42172	 42178
	 42195	 42201	 42219	 42225	 42240	 42246	 42263	 42269	 42285	 42291	 42308	 42314	 42330	 42336
	 42353	 42359	 42374	 42380	 42397	 42403	 42419	 42425	 42442	 42448	 42464	 42470	 42487	 42493
	 42510	 42516	 42534	 42540	 42557	 42563	 42581	 42587	 42604	 42610	 42628	 42634	 42651	 42657
	 42675	 42681	 42698	 42704	 42722	 42728	 42745	 42751	 42769	 42775	 42792	 42798	 42816	 42822
	 42839	 42845	 42863	 42869	 42886	 42892	 42910	 42916	 43109#	 43300	 43307	 43314	 43321	 43328
	 43334	 43344	 43362	 43380	 43401	 43431	 43450	 43460	 43471	 43479	 43487	 43495	 43503	 43511
	 43518	 43525	 43532	 43541	 43548	 43556	 43564	 43571	 43579	 43594	 43612	 43630	 43649	 43668
	 43676	 43690	 43696	 43717	 43733	 43741	 43749	 43770	 43778	 43785	 43793	 43799	 43807	 43814
	 43822	 43829	 43837	 43844	 43852	 43859	 43867	 43900	 43928	 43956	 43984	 44012	 44040	 44068
	 44115	 44147	 44179	 44211	 44243	 44275	 44307	 44365	 44407	 44449	 44491	 44533	 44575	 44617
	 44656	 44678	 44700	 44721	 44743	 44767	 44789	 44811	 44832	 44854	 44878	 44900	 44922	 44943
	 44965	 44989	 45011	 45033	 45054	 45076	 45100	 45122	 45144	 45165	 45187	 45211	 45233	 45255
	 45276	 45298	 45322	 45344	 45366	 45387	 45409	 45433	 45455	 45477	 45498	 45520	 45544	 45566
	 45588	 45609	 45631	 45655	 45677	 45699	 45720	 45742	 45789	 45820	 45851	 45882	 45913	 45944
	 45975	 47242	 47249	 47274	 47281	 47310	 47317	 47342	 47349	 47378	 47385	 47410	 47417	 47446
	 47453	 47478	 47485	 47514	 47521	 47546	 47553	 47582	 47589	 47614	 47621	 47650	 47657	 47682
	 47689	 47727	 47763	 47799	 47835	 47871	 47907	 47943	 47982	 48025	 48047	 48069	 48091	 48113
	 48135	 48157	 48171	 48182	 48211	 48216	 48231	 48236	 48251	 48256	 48271	 48276	 48291	 48296
	 48311	 48316	 48331	 48336	 48351	 48356	 48371	 48376	 48391	 48396	 48411	 48416	 48431	 48436
	 48451	 48456	 48471	 48476	 48491	 48496	 48511	 48516	 48531	 48536	 48551	 48556	 48593	 48633
	 48673	 48713	 48753	 48793	 48833	 50784	 50800	 50816	 50843	 50875	 50907	 50939	 50971	 51003
	 51035	 51067	 51119	 51124	 51150	 51175
STOP1	 43113#	 48881	 48922	 48963	 49004	 49045	 49086	 49127	 49168	 49209	 49250	 49291	 49332	 49373
	 49414	 49455	 49496	 49537	 49578	 49619	 49660	 49701	 49742	 49783	 49824	 49865	 49906	 49947
	 49988	 50029	 50070	 50111	 50152	 50181	 50210	 50239	 50268	 50297	 50326	 50355	 50384	 50413
	 50442	 50471	 50500	 50529	 50558	 50587	 50616	 50645	 50674	 50702	 50730	 50758
STOP2	 42971#	 43352	 43369	 43388	 43408	 43421	 43439	 43601	 43620	 43638	 43656	 43704	 43723	 43906
	 43934	 43962	 43990	 44018	 44046	 44074	 44121	 44153	 44185	 44217	 44249	 44281	 44313	 44371
	 44413	 44455	 44497	 44539	 44581	 44623	 44663	 44685	 44707	 44728	 44749	 44774	 44796	 44818
	 44839	 44860	 44885	 44907	 44929	 44950	 44971	 44996	 45018	 45040	 45061	 45082	 45107	 45129
	 45151	 45172	 45193	 45218	 45240	 45262	 45283	 45304	 45329	 45351	 45373	 45394	 45415	 45440
	 45462	 45484	 45505	 45526	 45551	 45573	 45595	 45616	 45637	 45662	 45684	 45706	 45727	 45748
	 45795	 45826	 45857	 45888	 45919	 45950	 45981	 46462	 46499	 46536	 46573	 46610	 46647	 46684
	 46721	 46758	 46795	 46832	 46869	 46906	 46943	 46980	 47017	 47054	 47091	 47128	 47165	 47202
	 47733	 47769	 47805	 47841	 47877	 47913	 47949	 48588	 48628	 48668	 48708	 48748	 48788	 48828
	 48887	 48928	 48969	 49010	 49051	 49092	 49133	 49174	 49215	 49256	 49297	 49338	 49379	 49420
	 49461	 49502	 49543	 49584	 49625	 49666	 49707	 49748	 49789	 49830	 49871	 49912	 49953	 49994
	 50035	 50076	 50117	 50158	 50187	 50216	 50245	 50274	 50303	 50332	 50361	 50390	 50419	 50448
	 50477	 50506	 50535	 50564	 50593	 50622	 50651	 50680	 50708	 50736	 50764	 50849	 50881	 50913
	 50945	 50977	 51009	 51041	 51073	 51115	 51131	 51156	 51181
STUCK	 43168#	 46005	 46026	 46047	 46068	 46089	 46111	 46132	 46163	 46181	 46199	 46217	 46235	 46253
	 46271	 46306	 46323	 46340	 46357	 46374	 46391	 46408	 46452	 46489	 46526	 46563	 46600	 46637
	 46674	 46711	 46748	 46785	 46822	 46859	 46896	 46933	 46970	 47007	 47044	 47081	 47118	 47155
	 47192
SWITCH	   271#
TBOTH	 42985#	 43348	 43365	 43384	 43404	 43417	 43435	 43597	 43616	 43634	 43652	 43700	 44659	 44681
	 44703	 44724	 44770	 44792	 44814	 44835	 44881	 44903	 44925	 44946	 44992	 45014	 45036	 45057
	 45103	 45125	 45147	 45168	 45214	 45236	 45258	 45279	 45325	 45347	 45369	 45390	 45436	 45458
	 45480	 45501	 45547	 45569	 45591	 45612	 45658	 45680	 45702	 45723	 46458	 46495	 46532	 46569
	 46606	 46643	 46680	 46717	 46754	 46791	 46828	 46865	 46902	 46939	 46976	 47013	 47050	 47087
	 47124	 47161
TGET	 42980#	 43349	 43366	 43385	 43405	 43418	 43436	 43598	 43617	 43635	 43653	 43701	 43720	 43903
	 43931	 43959	 43987	 44015	 44043	 44071	 44118	 44150	 44182	 44214	 44246	 44278	 44310	 44368
	 44410	 44452	 44494	 44536	 44578	 44620	 44660	 44682	 44704	 44725	 44746	 44771	 44793	 44815
	 44836	 44857	 44882	 44904	 44926	 44947	 44968	 44993	 45015	 45037	 45058	 45079	 45104	 45126
	 45148	 45169	 45190	 45215	 45237	 45259	 45280	 45301	 45326	 45348	 45370	 45391	 45412	 45437
	 45459	 45481	 45502	 45523	 45548	 45570	 45592	 45613	 45634	 45659	 45681	 45703	 45724	 45745
	 45792	 45823	 45854	 45885	 45916	 45947	 45978	 46459	 46496	 46533	 46570	 46607	 46644	 46681
	 46718	 46755	 46792	 46829	 46866	 46903	 46940	 46977	 47014	 47051	 47088	 47125	 47162	 47199
	 47730	 47766	 47802	 47838	 47874	 47910	 47946	 48585	 48625	 48665	 48705	 48745	 48785	 48825
	 48884	 48925	 48966	 49007	 49048	 49089	 49130	 49171	 49212	 49253	 49294	 49335	 49376	 49417
	 49458	 49499	 49540	 49581	 49622	 49663	 49704	 49745	 49786	 49827	 49868	 49909	 49950	 49991
	 50032	 50073	 50114	 50155	 50184	 50213	 50242	 50271	 50300	 50329	 50358	 50387	 50416	 50445
	 50474	 50503	 50532	 50561	 50590	 50619	 50648	 50677	 50705	 50733	 50761	 50846	 50878	 50910
	 50942	 50974	 51006	 51038	 51070	 51112	 51128	 51153	 51178
TRAP	 43164#	 46159	 46177	 46195	 46213	 46231	 46249	 46267	 46300	 46317	 46334	 46351	 46368	 46385
	 46402
TRPCHK	 43175#	 46010	 46031	 46052	 46073	 46094	 46116	 46137	 46169	 46187	 46205	 46223	 46241	 46259
	 46277	 46311	 46328	 46345	 46362	 46379	 46396	 46413	 46439	 46476	 46513	 46550	 46587	 46624
	 46661	 46698	 46735	 46772	 46809	 46846	 46883	 46920	 46957	 46994	 47031	 47068	 47105	 47142
	 47179
TRPPI	 42942#	 43879	 44087	 44328	 45763	 47973	 48016	 48038	 48060	 48082	 48104	 48126	 48148
TSET	 42975#	 43338	 43356	 43373	 43392	 43412	 43425	 43443	 43605	 43624	 43642	 43660	 43708	 43888
	 43916	 43944	 43972	 44000	 44028	 44056	 44103	 44135	 44167	 44199	 44231	 44263	 44295	 44351
	 44393	 44435	 44477	 44519	 44561	 44603	 44647	 44667	 44689	 44711	 44732	 44758	 44778	 44800
	 44822	 44843	 44869	 44889	 44911	 44933	 44954	 44980	 45000	 45022	 45044	 45065	 45091	 45111
	 45133	 45155	 45176	 45202	 45222	 45244	 45266	 45287	 45313	 45333	 45355	 45377	 45398	 45424
	 45444	 45466	 45488	 45509	 45535	 45555	 45577	 45599	 45620	 45646	 45666	 45688	 45710	 45731
	 45776	 45807	 45838	 45869	 45900	 45931	 45962	 46429	 46466	 46503	 46540	 46577	 46614	 46651
	 46688	 46725	 46762	 46799	 46836	 46873	 46910	 46947	 46984	 47021	 47058	 47095	 47132	 47169
	 47713	 47749	 47785	 47821	 47857	 47893	 47929	 48570	 48610	 48650	 48690	 48730	 48770	 48810
	 48865	 48906	 48947	 48988	 49029	 49070	 49111	 49152	 49193	 49234	 49275	 49316	 49357	 49398
	 49439	 49480	 49521	 49562	 49603	 49644	 49685	 49726	 49767	 49808	 49849	 49890	 49931	 49972
	 50013	 50054	 50095	 50141	 50170	 50199	 50228	 50257	 50286	 50315	 50344	 50373	 50402	 50431
	 50460	 50489	 50518	 50547	 50576	 50605	 50634	 50663	 50691	 50719	 50747	 50830	 50862	 50894
	 50926	 50958	 50990	 51022	 51054	 51082	 51137	 51163
TTALTM	   192#
TTICHR	   185#
TTICLR	   195#
TTICNV	   190#
TTIDEC	   189#
TTINO	   187#
TTIOCT	   188#
TTIYES	   186#
TTLOOK	   191#
TTSIXB	   193#
TTYINP	   194#
WATINT	 42967#	 43896	 43924	 43952	 43980	 44008	 44036	 44064	 44111	 44143	 44175	 44207	 44239	 44271
	 44303	 44361	 44403	 44445	 44487	 44529	 44571	 44613	 45784	 45815	 45846	 45877	 45908	 45939
	 45970	 46006	 46027	 46048	 46069	 46090	 46112	 46133	 46164	 46182	 46200	 46218	 46236	 46254
	 46272	 46307	 46324	 46341	 46358	 46375	 46392	 46409	 46453	 46490	 46527	 46564	 46601	 46638
	 46675	 46712	 46749	 46786	 46823	 46860	 46897	 46934	 46971	 47008	 47045	 47082	 47119	 47156
	 47193	 47239	 47271	 47307	 47339	 47375	 47407	 47443	 47475	 47511	 47543	 47579	 47611	 47647
	 47679	 47720	 47756	 47792	 47828	 47864	 47900	 47936	 47978	 48021	 48043	 48065	 48087	 48109
	 48131	 48153
XCHN2	 43180#	 46433	 46470	 46507	 46544	 46581	 46618	 46655	 46692	 46729	 46766	 46803	 46840	 46877
	 46914	 46951	 46988	 47025	 47062	 47099	 47136	 47173
XUUO	 43117#	 48859	 48900	 48941	 48982	 49023	 49064	 49105	 49146	 49187	 49228	 49269	 49310	 49351
	 49392	 49433	 49474	 49515	 49556	 49597	 49638	 49679	 49720	 49761	 49802	 49843	 49884	 49925
	 49966	 50007	 50048	 50089
XUUOA	 43139#	 50136	 50165	 50194	 50223	 50252	 50281	 50310	 50339	 50368	 50397	 50426	 50455	 50484
	 50513	 50542	 50571	 50600	 50629	 50658	 50686	 50714	 50742
   