SUBTTL	ARITHMETIC RELIABILITY DIAGNOSTIC

;INITIALIZING AND CONTROL SEQUENCE

SFSRT1:	SETZM	ERRTLS
	SETZM	PASCNT
	SETZM	TICKS
	SETZM	TSTIMR#
	JRST	BEGIN

START:	PGMINT			;INITIALIZE SUBROUTINES
	SETZM	PNTSIM#
	SETZM	LINCNT#
	MOVEI	<^D32*^D1024>-1
	MOVEM	VMEM#
	MOVE	[JSR PNTTOT]
	MOVEM	HNGERR		;SETUP HUNG FOR TOTALS
	SKIPN	USER		;IF USER, USE TIME OF DAY IN JIFFIES
	JRST	.+3
	CALL	1,[SIXBIT/TIMER/]
	MOVEM	1,RANDBS
	SWITCH
	TRNN	RANBAS		;SPECIFY RANDOM NUMBER BASE ?
	JRST	STARTA		;NO
	MOVEI	[ASCIZ/
SPECIFY BASE RANDOM NUMBER - /]
	PNTALF
	TTIOCT
	JRST	.-3
	MOVEM	0,RANDBS	;INIT RANDOM NUMBER GENERATOR
STARTA:	SWITCH
	TRNE	ENTDDT		;ENTER DDT SWITCH SET ?
	JRST	DDTSRT		;YES
	MOVE	RA,RANDBS
	SKIPE	USER		;USER MODE ?
	JRST	STARTD		;YES
	TRNE	INHCLK		;EXEC, INHIBIT CLOCK INTERRUPTS ?
	JRST	STARTC		;YES
	MOVE	1,[JRST ITRCLK]	;SETUP INTERRUPT ROUTINE FOR CLOCK
	MOVEM	1,$ITRHL
	MOVEI	^D60
	SKIPE	CYCL60
	MOVEI	^D50
	MOVEM	HERTZ#		;50 OR 60 CYCLE
	MOVE	[JSR ITRCH1]	;SETUP ALL CHANNELS
	MOVEM	42
	MOVEM	44
	MOVEM	46
	MOVEM	50
	MOVEM	52
	MOVEM	54
	MOVEM	56
	CONO	APR,CLKENB!CLKCLR!AAPRC1
	CONO	PI,PARENB!CHNON!PION!PICHNA
	JRST	STARTD

STARTC:	CONO	PI,PICLR!CHNOFF!PIOFF
	CONO	APR,AAPRC1
	CONO	PI,PARENB!CHNON!PION!PICHN1
STARTD:	SETOM	FIXF#		;SET TEST CONTROL FLAGS TO RUN ALL
	SETOM	FLTF#
	SETOM	BYTF#
	SETOM	FASTF#
	SETOM	SLOWF#
	MOVEI	ACSP,JA		;SETUP SIMULATED AC POINTER
	MOVEI	1,6
	MOVEM	1,RTIME#

	SWITCH			;SETUP TEST CONTROL FLAGS
	TRNE	INHFXD
	SETZM	FIXF		;FIXED POINT INHIBITED
	TRNE	INHFP
	SETZM	FLTF		;FLOATING POINT INHIBITED
	TRNE	INHBYT
	SETZM	BYTF		;BYTE'S INHIBITED
	TRNE	SLOW
	SETZM	FASTF		;SIMULATION COMPARISON ONLY
	TRNE	FAST
	SETZM	SLOWF		;INSTRUCTION RESULT COMPARE ONLY
	TLNN	RELIAB		;RELIABILITY MODE ?
	SETZM	RTIME		;NO, FAST CYCLE OPERATION
	SETCA
	TRNE	INHFXD!INHFP!INHBYT
	JRST	.+4
	MOVEI	[ASCIZ/
OPERATOR INHIBIT OF ALL TESTS
/]
	PNTALF
	ERRHLT

	TRNE	SLOW!FAST
	JRST	BEGFX		;START TESTING
	MOVEI	[ASCIZ/
OPERATOR INHIBIT OF BOTH FAST AND SLOW
/]
	PNTALF
	ERRHLT

TSTEND:	MOVS	10,RANDBS	;GENERATE NEW BASE RANDOM NUMBER
	MULI	10,6065
	DIV	10,[377777,,777741]
	SKIPN	11		;IF 0, MAKE RANDOM BASE = 1
	MOVEI	11,1
	MOVEM	11,RANDBS
	SWITCH
	TLNE	RSTART!TOTALS
	JSR	PNTTOT		;TOTALS SW SET
	JRST	BEGEND
PGMNAM:	ASCIZ/
PDP-10 KA10 ARITHMETIC RELIABILITY DIAGNOSTIC [DAKDA]
/

;CLOSE LOGICAL OUTPUT FILE, USER MODE

RENTR1:	JSR	PNTTOT		;PRINT TOTALS
	DROPDV
	CALL	[SIXBIT/EXIT/]


DDTEX:	JRST	DDTSRT
;TESTING SEQUENCE
;FIXED POINT ARITHMETIC OPERATIONS

BEGFX:	SETZM	CNTL
	SKIPN	FIXF
	JRST	BEGFP		;DON'T TEST FIXED
	SKIPN	FASTF
	JRST	FXS		;FIXED POINT, SLOW ONLY

;FIXED POINT FAST
;COMPARE RESULTS OF MUL,DIV,ADD REMAINDER WITH ORIGINAL

FXF:	MOVEI	LOP,^D160
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	FSTMDI
	CAI	FIXEDI+4(CNTR)	;FIXED POINT INTERGERS
	JSR	FSTMD
	CAI	FIXED+2(CNTR)	;FIXED POINT
	SOJG	LOP,FXF+2

;FIXED POINT SLOW
;COMPARE MACHINE RESULTS AGAINST SIMULATION

FXS:	SKIPN	SLOWF
	JRST	BEGFP		;DON'T RUN
	MOVEI	LOP,4
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	MD
	CAI	FIXEDI+10(CNTR)	;FIXED POINT INTERGERS
	JSR	MD
	CAI	FIXED+10(CNTR)	;FIXED POINT
	SOJG	LOP,FXS+4
;TESTING SEQUENCE
;FLOATING POINT ARITHMETIC OPERATIONS

BEGFP:	SKIPN	FLTF
	JRST	BEGBYT		;DON'T TEST FLOATING
	SKIPN	FASTF
	JRST	FPS		;FLOATING POINT, SLOW ONLY

;FLOATING POINT FAST
;COMPARE RESULTS OF DIV THEN MUL

FPF:	MOVEI	LOP,^D160
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	FSTFP		;FLOATING POINT
	CAI	FPMD+4(CNTR)
	SOJG	LOP,.-2

;FLOATING POINT SLOW
;COMPARE MACHINE RESULTS AGAINST SIMULATION

FPS:	SKIPN	SLOWF
	JRST	BEGBYT
	MOVEI	LOP,4
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	MD		;FLOATING POINT ADD/SUB
	CAI	FPAS+10(CNTR)
	JSR	MD		;FLOATING POINT SUB/MUL
	CAI	FPSM+10(CNTR)
	JSR	MD		;FLOATING POINT MUL/DIV
	CAI	FPMD+10(CNTR)
	JSR	MD		;DFN/UFA AND RI MODE
	CAI	MISCFP+10(CNTR)
	JSR	MD		;THE L MODE
	CAI	FPL+10(CNTR)
	SOJG	LOP,FPS+4


;TESTING SEQUENCE
;BYTE INSTRUCTION, COMPARE WITH SIMULATION

BEGBYT:	SKIPN	BYTF
	JRST	TSTEND		;DON'T TEST BYTE
	MOVEI	LOP,^D30
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	BYTE		;SIM AND CHECK BYTES
	CAI	BYTES+5(CNTR)
	SOJG	LOP,.-2

	JRST	TSTEND
;TEST OF IMUL AND IDIV
;DIVIDE THEN MULTIPLY AND ADD REMAINDER

FSTMDI:	0
	MOVE	IT,@.-1		;POINT TO INST
	HRROI	CNTR,-4
FSMDI1:	JSR	RANNOV		;RANDOM, OV NOT POSSIBLE
	SETZM	CNTL
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JFCL	10,FSMDI2	;OV SET, DIVIDE ERROR
	XCT	@IT		;MULTIPLY
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	JFCL	10,FSMDI2	;MUL OR DIV ERROR
	ADD	AC,DIVAC+1
	CAME	AC,RA		;LOOK FOR ORIG
FSMDI2:	JSR	FSTER		;ERROR
	AOJL	CNTR,FSMDI1	;NEXT PAIR
	JRST	@FSTMDI		;EXIT
;TEST OF MUL AND DIV
;DIVIDE THEN MULTIPLY AND ADD REMAINDER

FSTMD:	0
	MOVE	IT,@.-1		;POINT TO INST
	HRROI	CNTR,-2
FSTMD1:	JSR	RANNOV		;RANDOM, OV NOT POSSIBLE
	SETZM	CNTL
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JFCL	10,FSTMD2	;OV SET, DIVIDE ERROR
	JRST	2,@[XWD 0,.+1]	;CLEAR FLAGS
	XCT	@IT		;MULTIPLY
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	JSP	.+1
	MOVEM	SECFLG#
	JFCL	10,FSTMD2	;MUL OR DIV ERROR
	JFCL	17,.+1
	ADD	AC+1,DIVAC+1
	JFCL	2,CRYFIX	;THE CRY 1 FLAG
	JFCL	4,CRY0FX
	CAMN	AC,RA
	CAME	AC+1,RA+1
FSTMD2:	JSR	FSTER		;MUL OR DIV ERROR
	AOJL	CNTR,FSTMD1	;NEXT PAIR
	JRST	@FSTMD		;EXIT

CRYFIX:	TLC	AC+1,400000
	AOJA	AC,FSTMD2-3

CRY0FX:	TLC	AC+1,400000
	SOJA	AC,FSTMD2-2
;TEST OF FLOATING POINT
;FP DIV THEN FP MUL

FSTFP:	0
	MOVE	IT,@.-1		;POINT TO A FP INSTRUCTION
	HRROI	CNTR,-4		;4 ITEMS
FSTFP1:	JSR	RANORM		;NORMALIZED RANDOM NUMBERS
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	FLAGS,FSTFLG#
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JSR	DOINS		;DO A FMP
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	CAME	AC,RA
	JRST	FSTFP3		;POSSIBLE ERROR
FSTFP2:	AOJL	CNTR,FSTFP1	;NEXT PAIR
	JRST	@FSTFP		;EXIT

FSTFP3:	MOVEM	FLAGS,SECFLG	;SAVE SECOND FLAGS
	MOVE	FLAGS,FSTFLG
	MOVE	AC		;RESULT NOT EQUAL TO ORIGINAL
	SUBI	1		;IF LARGER OR SMALLER
	CAMN	RA		;COMPARE IT
	JRST	FSTFP2		;OK
	SUBI	1
	CAMN	RA
	JRST	FSTFP2		;OK
	ADDI	3
	CAMN	RA
	JRST	FSTFP2		;OK
	ADDI	1
	CAME	RA
FSTFP4:	JSR	FSTER		;ERROR, FIND WHAT FAILED
	JRST	FSTFP2		;OK
;TEST OF BYTE INSTRUCTIONS
;COMPARE MACHINE RESULTS WITH SIMULATION

BYTE:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-5		;5 ITEMS
BYTE1:	JSR	RANDOM		;GENERATE RANDOM NUMBERS
	MOVSI	CNTL,BYT	;FLAG FOR PRINTER
	LSH	RA+2,-^D30	;MAKE A BYTE
	LSH	AC+2,-^D24	;POINTER
	ANDI	AC+2,77		;IF THE POINTER (RIGHT HALF)
	TRNN	CNTR,2
	CAMG	AC+2,RA+2	;WILL BE INCREMENTED
	TRO	AC+2,10000	;POINT TO AC
	TRO	RA+2,100	;IF NO INCREMENT
	ROT	RA+2,^D30	;POINT TO AC+1
	ROT	AC+2,^D24
	ADDB	AC+2,RA+2	;THE POINTER IN RA+2, AC+2
	JSR	SIMIT		;SIMULATE
	JSR	DOIT		;XCT
	AOJL	CNTR,BYTE1	;ITERATE
	JRST	@BYTE		;EXIT


;PERFORM THE MACHINE INSTRUCTION

DOINS:	0
	JRST	2,@[XWD 0,.+1]	;CLEAR FLAGS
	XCT	@IT
	JSP	.+1		;SAVE FLAGS
	HLLM	FLAGS		;IN FLAG REGISTR
	JRST	@DOINS

;HALT AND SAVE AC'S

GOING:	0
	CONI	APR,$SVAPR
	CONI	PI,$SVPI
	CONO	PI,PIOFF
	MOVEM	0,$ACC0
	MOVE	0,GOING
	MOVEM	0,ITRCH1
	HALT	BEGIN
;TEST INSTRUCTION BY COMPARING MACHINE RESULTS
;WITH SIMULATION RESULTS

MD:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-10	;GROUPS OF 8
MD1:	JSR	RANDOM		;GENERATE RANDOM NUMBERS
	HLLZS	CNTL		;CLEAR CONTROL SWITCHES
	JSR	SIMIT		;SIMULATE INSTRUCTION
	JSR	DOIT		;XCT INSTRUCTION
	AOJL	CNTR,MD1	;ITERATE
	JRST	@MD		;EXIT

;SIMULATE THE INSTRUCTION

SIMIT:	0
	SAVEM	RA,1
	SINST	@IT		;SIMULATE, RESULTS IN ACS
	JRST	@SIMIT

;COMPARE MACHINE RESULTS AGAINST SIMULATOR

CHECK:	0
	HLR	FLAGS,PCSAV#
	TLZ	FLAGS,USERF	;CLEAR MISC
	MOVS	FLAGS
	CAME	FLAGS		;COMPARE FLAGS
	HRRI	CNTL,FLAGS
	CAME	AC+3,4(ACSP)	;COMPARE AC+3
	HRRI	CNTL,AC+3
	CAME	AC+2,3(ACSP)	;COMPARE AC+2
	HRRI	CNTL,AC+2
	CAME	AC+1,2(ACSP)	;COMPARE AC+1
	HRRI	CNTL,AC+1
CHECK1:	CAME	AC,1(ACSP)	;COMPARE AC
	HRRI	CNTL,AC
	JRST	@CHECK
;PERFORM THE INSTRUCTION

DOIT:	0
	JSR	DOINS		;XCT THE INSTRUCTION
	TLNN	CNTL,ER		;BYPASS IF ERROR
	JSR	CHECK		;CHECK FOR VALID DATA
	TRNN	CNTL,-1
	JRST	@DOIT		;EXIT, NO ERRORS
	SKIPN	USER
DOIT1:	DATAO	PI,(CNTL)	;LOAD MI WITH FAILURE
	TLOE	CNTL,ER		;SET ERROR FLAG
	JRST	DOIT4		;SEE IF PRINT ALL ERRORS
	JSR	TTLPNT
	MOVEI	[ASCIZ/
**********
SIMULATION COMPARISION FAILURE
/]
	PNTAL
	JSR	RESULT		;PRINT MACHINE RESULTS
	JSR	SIMPNT		;PRINT SIMULATION

DOIT2:	MOVEM	CNTL,SAVCNT#	;SAVE CNTL
	TRZ	CNTL,-1		;CLEAR RIGHT HALF
	JSR	CHECK
	MOVE	AC,RA
	MOVE	AC+1,RA+1
	MOVE	AC+2,RA+2
	MOVE	AC+3,RA+3
	SWITCH			;READ SWITCHES
	TLNE	ERSTOP		;HALT AND SAVE AC'S?
	JSR	GOING		;YES
	TLNE	LOOPER		;LOOP ON ERROR SWITCH SET?
	JRST	.+4		;YES
	JSR	DOIT3		;NO, GO RING BELL
	TLZ	CNTL,ER		;CLEAR ER FLAG
	JRST	@DOIT		;AND CONT WITH PROG
	TRNE	CNTL,-1		;HAD AN ERROR?
	JSR	DOIT3		;YES, GO RING BELL
	MOVE	CNTL,SAVCNT	;RESTORE CNTL
	JRST	DOIT+1		;CYCLE ERROR

DOIT3:	0
	TLNN	DING		;RING BELL ON ERROR ?
	JRST	@DOIT3		;NO
	MOVEI	BELL
	PNTAF			;RING TTY BELL
	JRST	@DOIT3
;DETERMINE IF FIRST OR SECOND OPERATION CAUSED FAILURE

FSTER:	0
	SETZM	FAIL1#
	SUBI	CNTR,1		;POINT TO FIRST INSTRUCTION
	JSR	SIMIT		;SIMULATE
	MOVE	AC,DIVAC	;RESTORE FIRST RESULTS
	MOVE	AC+1,DIVAC+1
	MOVE	AC+2,DIVAC+2
	MOVE	AC+3,DIVAC+3
	TRZ	CNTL,-1
	JSR	CHECK		;CHECK SIM VS ACTUAL
	TRNN	CNTL,-1
	AOJA	CNTR,FSTER2	;LOOKS LIKE SECOND OP FAILED

FSTER1:	JSR	TTLPNT
	MOVEI	[ASCIZ/
**********
INSTRUCTION COMPARISION FAILURE
/]
	PNTAL
	JSR	RESULTS		;FIRST OP FAILED, PRINT RESULTS
	SAVEM	RA,1
	JSR	SIMPNT		;PRINT SIMULATION
	TLO	CNTL,ER		;SET ER FLAG
	JSR	DOIT		;SCOPE LOOP
	SKIPN	FAIL1		;FIRST OP FAILURE ?
	AOJGE	CNTR,GG		;YES, INC CNTR; IF JUMP PROG LOST
	JRST	@FSTER		;EXIT

FSTER2:	SETOM	FAIL1
	MOVE	RA,DIVAC
	MOVE	RA+1,DIVAC+1
	MOVE	RA+2,DIVAC+2
	MOVE	AC+3,DIVAC+3
	MOVE	AC,MULAC
	MOVE	AC+1,MULAC+1
	MOVE	AC+2,MULAC+2
	MOVE	AC+3,MULAC+3
	JSR	SIMIT		;SIMULATE SECOND OP
	HLL	FLAGS,SECFLG	;GET FLAGS FROM SECOND OP
	JSR	CHECK		;CHECK SIM VS ACTUAL
	TRNE	CNTL,-1		;DID SECOND FAIL ?
	JRST	FSTER1		;YES, PRINT RESULTS
	JRST	@FSTER		;NO, SIM SAYS BOTH OK...CONTINUE
;SIMULATE SINGLE INSTRUCTION, NO PRINTOUT

SIMNST:	MOVE	[XWD 1,SAVAC+1]
	BLT	SAVAC+17
	HRRZ	$SVUUO		;SETUP PC
	MOVEM	INPC
	GO	SMNST1		;GO TO SIMULATOR

SIMEXT:	MOVE	PC		;SAVE PC FLAGS
	MOVEM	PCSAV
	MOVS	[XWD 1,SAVAC+1]
	BLT	17
	JRST	UUOEXT		;EXIT UUO

;SIMULATE SINGLE INSTRUCTION, PRINT STATES

SIMMT:	MOVE	[XWD 1,SAVAC+1]
	BLT	SAVAC+17
	HRRZ	$SVUUO		;SETUP PC
	MOVEM	INPC
	GO	SMMT1		;GO TO SIMULATOR

	JRST	SIMEXT		;SAVE FLAGS, EXIT UUO

;CHECK PRINT ALL ERRORS SWITCH

DOIT4:	SWITCH
	TLNN	PALERS		;PRINT ALL ERRORS ?
	JRST	DOIT2		;NO, DON'T PRINT...NOT FIRST
	JRST	DOIT1+3

;PRINT PROGRAM TITLE AND PASS COUNT

TTLPNT:	0
	AOS	ERRTLS
	PCRL
	MOVEI	PGMNAM
	PNTAL
	MOVEI	[ASCIZ/TEST PASS COUNT = /]
	PNTAL
	MOVE	PASCNT
	PNTDEC
	JSR	RUNTIM		;PRINT RUN TIME
	JRST	@TTLPNT

PCR:	PCRL
	RTN
PCR1:	PNTCI	14
	RTN
;RANDOM NUMBER GENERATION
;THREE RANDOM IN AC,AC+1,AC+2
;A COPY ALSO IN RA,RA+1,RA+2

RANDOM:	0
	MOVE	AC,RA
	ADD	AC,[543217335216]
	ROT	AC,-1
	EQVB	AC,RA		;RANDOM 1
	MOVS	AC+1,RA
	ADD	AC+1,[165742176525]
	ROT	AC+1,-1
	EQVB	AC+1,RA+1	;RANDOM 2
	MOVS	AC+2,RA+1
	ADD	AC+2,[147532173543]
	ROT	AC+2,-1
	EQVB	AC+2,RA+2	;RANDOM 3
	MOVS	AC+3,RA+2
	ADD	AC+3,[731341527517]
	ROT	AC+3,-1
	EQVB	AC+3,RA+3	;RANDOM 4
	JRST	@RANDOM

;RANDOM NUMBER GENERATION
;OVERFLOW NOT POSSIBLE FOR DIVIDE

RANNOV:	0
	JSR	RANDOM
	MOVM	AC+2
	MOVMM	RA,TEMP#
	CAMN	TEMP
	JRST	RANNOV+1	;DIVISOR=HI DIVIDEND
	CAML	TEMP
	JRST	.+3
	EXCH	AC,AC+2		;DIVISOR SMALLER, EXCHANGE
	EXCH	RA,RA+2		;TO MAKE LARGER
	JUMPE	RA+2,RANNOV+1
	TRNN	AC+2,-1
	JRST	RANNOV+1	;REJECT IF 0 FOR IDIV1
	TLZ	AC+1,400000
	TLNE	AC,400000
	TLO	AC+1,400000
	MOVEM	AC+1,RA+1
	JRST	@RANNOV
;RANDOM NUMBER GENERATION
;NORMALIZED RANDOM FOR FLOATING POINT

RANORM:	0
	JSR	RANDOM
	NORM	RA+3,AC+3
	NORM	RA+2,AC+2
	NORM	RA+1,AC+1
	NORM	RA,AC
	JRST	@RANORM
GG:	MOVEI	[ASCIZ/
INTERNAL PROGRAM PROBLEM, SUGGEST RELOAD, RESTART !
/]
	PNTALF
	ERRHLT

;SIMULATE AND PRINT THE INSTRUCTION

SIMPNT:	0
	SAVEM	RA,1
	SMT	@IT		;SIMULATE AND PRINT
	JRST	@SIMPNT


;PRINT FAST TEST FAILURE RESULTS

RESULT:	0
	SETOM	PNTSPC		;SET TO SPACE AFTER OCTALS
	MOVEI	[ASCIZ/
FLAGS FROM MACH & SIMULATE   /]
	PNTAL
	MOVE	FLAGS
	PNTHW
RSLTS1:	MOVEI	[ASCIZ/
MACHINE RESULTS IN AC,AC+1,E   /]
	TLNE	CNTL,BYT	;BYTE ERROR
	MOVEI	[ASCIZ/
MACHINE RESULTS IN AC,POINTER,E   /]
	PNTAL
	MOVE	AC
	PNTOCT			;PRINT MACHINE AC
	TLNE	CNTL,BYT
	EXCH	AC+1,AC+2
	MOVE	AC+1
	PNTOCT			;PRINT AC+1
	MOVE	AC+2
	PNTOCT			;PRINT AC+2, (E)
	MOVEI	CRLF
	PNTA
	JRST	@RESULT
;THE INSTRUCTIONS TESTED

;INTERGER FIXED POINT
FIXEDI:	IDIV	AC,AC+2
	IMUL	AC,AC+2
	IDIVI	AC,(AC+2)
	IMULI	AC,(AC+2)
	IDIVM	AC,AC+2
	IMULM	AC,AC+2
	IDIVB	AC,AC+2
	IMULB	AC,AC+2

;MULTIPLY AND DIVIDE
FIXED:	DIV	AC,AC+2
	MUL	AC,AC+2
	DIVI	AC,(AC+2)
	MULI	AC,(AC+2)
	MULM	AC,AC+2
	DIVM	AC,AC+2
	MULB	AC,AC+2
	DIVB	AC,AC+2

;FLOATING POINT: ADD, SUBTRACT
FPAS:	FAD	AC,AC+2
	FSB	AC,AC+2
	FADR	AC,AC+2
	FSBR	AC,AC+2
	FADM	AC,AC+2
	FADB	AC,AC+2
	FADRM	AC,AC+2
	FADRB	AC,AC+2

;FLOATING POINT: SUBTRACT, MULTIPLY
FPSM:	FSBM	AC,AC+2
	FSBB	AC,AC+2
	FSBRM	AC,AC+2
	FSBRB	AC,AC+2
	FMPM	AC,AC+2
	FMPB	AC,AC+2
	FMPRM	AC,AC+2
	FMPRB	AC,AC+2

;FLOATING POINT: MULTIPLY, DIVIDE
FPMD:	FMP	AC,AC+2
	FDV	AC,AC+2
	FMPR	AC,AC+2
	FDVR	AC,AC+2
	FDVM	AC,AC+2
	FDVB	AC,AC+2
	FDVRM	AC,AC+2
	FDVRB	AC,AC+2
;FLOATING POINT: MISCELLANEOUS
MISCFP:	UFA	AC,AC+2
	DFN	AC,AC+2
	UFA	AC,AC+2
	FSC	AC,(AC+2)
	FADRI	AC,(AC+2)
	FSBRI	AC,(AC+2)
	FMPRI	AC,(AC+2)
	FDVRI	AC,(AC+2)

;FLOATING POINT: LONG MODE
FPL:	FADL	AC,AC+2
	FSBL	AC,AC+2
	FMPL	AC,AC+2
	FDVL	AC,AC+2
	FMPL	AC,AC+2
	FDVL	AC,AC+2
	FADL	AC,AC+2
	FSBL	AC,AC+2

;BYTES
BYTES:	IBP	AC+2
	ILDB	AC,AC+2
	IDPB	AC,AC+2
	LDB	AC,AC+2
	DPB	AC,AC+2


;TEST STORAGE

SAVAC:	BLOCK	20

DIVAC:	BLOCK	4

MULAC:	BLOCK	4
;CLOCK SERVICE ROUTINES

RUNTIM:	0
	SKIPE	USER
	JRST	@RUNTIM
	CONO	APR,CLKDIS!AAPRC1	;DISABLE CLOCK
	JSR	TSTIMA			;PRINT RUN TIME
	CONO	APR,CLKENB!CLKCLR!AAPRC1
	JRST	@RUNTIM

ITRCLK:	CONSO	APR,CLK
	JRST	$ITRHL+1	;NOT CLOCK
	AOS	TICKS		;INC CLOCK COUNTER
	MOVEM	0,CLKAC0#
	MOVEM	1,CLKAC1#
	JSR	TSTIME		;CHECK AND PRINT TIME
	MOVE	1,RA
	ANDI	1,7
	SKIPN	1
	AOS	1		;SETUP CLOCK ON RANDOM CHANNEL
	CONO	APR,CLKENB!CLKCLR(1)
	MOVE	0,CLKAC0
	MOVE	1,CLKAC1
	JEN	@ITRCH1

PNTTOT:	0
	SKIPE	USER		;NO TIME IF USER
	JRST	.+4
	SWITCH
	TRNN	INHCLK		;NO TIME IF CLOCK INHIBITED
	JSR	RUNTIM		;PRINT RUN TIME
	MOVEI	[ASCIZ/
TOTAL PASSES = /]
	PNTAL
	MOVE	PASCNT
	PNTDEC
	MOVEI	[ASCIZ/
TOTAL ERRORS = /]
	PNTAL
	MOVE	ERRTLS
	PNTDEC
	MOVEI	[ASCIZ/
BASE RANDOM NUMBER = /]
	PNTAL
	MOVE	RANDBS
	PNTHW
	PCRL2
	SWITCH
	TLNN	RSTART		;RESTART PROGRAM ?
	JRST	@PNTTOT		;NO, CONTINUE
	JRST	SFSRT1		;YES, RESTART AS STAND-ALONE
;TEST RUN TIME ROUTINE
;PRINTS TIME AT HALF HOUR INTERVALS OR WHEN REQUESTED

TSTIME:	0
	MOVE	TICKS
	SUB	TSTIMR		;HAS HALF HOUR PASSED ?
	MOVE	1,HERTZ
	CAIE	1,^D60
	JRST	TSTIMB		;50 CYCLE
	CAIGE	^D<60*60*30>
	JRST	@TSTIME		;NOT HALF HOUR YET
TSTIMC:	SETOM	TIMFRC#
	JSR	TSTIMA
	JRST	@TSTIME

TSTIMA:	0
	SKIPE	PNTFLG		;INTERRUPTED OUT OF PRINT ROUTINE ?
	JRST	@TSTIMA		;YES, DO NEXT CLOCK
	MOVEM	1,SAVAC1#
	MOVEI	[ASCIZ/
RUN TIME = /]
	PNTALF
	MOVE	TICKS		;GET TIME
	SKIPE	TIMFRC		;REQUESTED TIME ?
	MOVEM	TSTIMR		;IF SO, DON'T UPDATE 1/2 HR COMPARE
	IDIV	HERTZ		;CONVERT TO SECONDS
	IDIVI	^D<60*60>	;CONVERT TO HOURS
	MOVEM	1,TIMAC1#	;SAVE MIN:SEC
	PNTDCF			;PRINT HOURS
	PNTCIF	":"
	MOVE	TIMAC1
	IDIVI	^D60
	MOVEM	1,TIMAC1
	PNTDCF			;PRINT MINUTES
	PNTCIF	":"
	MOVE	TIMAC1
	PNTDCF			;PRINT SECONDS
	PCRLF
	SETZM	TIMFRC
	MOVE	1,SAVAC1
	JRST	@TSTIMA

TSTIMB:	CAIGE	^D<60*60*25>	;50 HZ HALF HOUR ?
	JRST	@TSTIME		;NO
	JRST	TSTIMC
