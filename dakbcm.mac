;INITIALIZE UUO HANDLER

START:	PGMINT			;INITIALIZE SUBROUTINES
	MOVE	0,RANDBS	;EXEC, SETUP RANDOM BASE
	SKIPE	USER		;USER, USE TIME OF DAY IN JIFFIES
	CALL	0,[SIXBIT/TIMER/]
	MOVEM	0,RAN		;SETUP RANDOM BASE

;INITIALIZE COMPLEXITY TABLE

	A=0
STARTA:	SETZM	CMPLXT		;STORE A TABLE OF POWERS OF 2
	MOVEI	1,1		;OR 0.
	SWITCH
	TLNN	RELIAB		;FAST CYCLE SWITCH SET ?
	SETZM	1		;YES, STORE ZERO'S
	REPEAT	7,
<	MOVEM	1,CMPLXT+1+A
	LSH	1,1
	A=A+1>

;INITIALIZE RUN TIME

	MOVEI	1,1
	TLNE	RELIAB		;FAST CYCLE SWITCH SET ?
	MOVEI	1,7		;NO, MULTIPLY RUNNING TIME
	MOVEM	1,RTIME		;STORE IN RTIME

	JRST	TRC4		;GO PERFORM DIAGNOSTIC

RENTR1:	DROPDV			;CLOSE LOGICAL OUTPUT FILE
	CALL	[SIXBIT .EXIT.]

PGMNAM:	ASCIZ?
PDP-10  KA10 BASIC INSTRUCTION RELIABILITY TEST 3 (DAKBC)
(TESTS, HALF WORD, ADD/SUB, JFFO, ETC.)
?

;CONSTANTS

RTIME:	0
CMPLXT:	BLOCK	20
SUBTTL	DIAGNOSTIC SECTION
	LALL

TSTLFT:	2000000000
TLFT1:	4000000000
TLFT2:	10000000000

;TEST TRC, TRCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION.

	AC=11
TRC4:	SETUP	100,0
TRC5:	RANDOM
TRC6:	TRC	AC,-1		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRC SKIPPED.
	TRCA	AC,-1		;SHOULD SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD  STILL=RAN NUM.
	EERRI	,-1
	LOOP 	TRC5,TRC6

;TEST TRC, TRCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=4
TRCA4:	SETUP	100,0
TRCA5:	RANDOM
TRCA6:	SETOB	AC1,RAN1	;SET C(AC) TO -1.
	TRC	AC1,(AC)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRC SKIPPED.
	TRCA	AC1,(AC)	;SHOULD SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD STILL=-1
	ERRI	RAN1,(AC)
	LOOP	TRCA5,TRCA6

;TEST TRC, TRCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION.

	AC=5
TRC7:	SETUP	100,0
TRC8:	RANDOM
TRC9:	SETCM	AC1,AC		;MAKE "E"=COMP OF C(AC)
	TRC	AC,(AC1)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRC SKIPPED.
	TRCA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=RAN NUM.
	EERRI	,(AC1)
	LOOP	TRC8,TRC9

;TEST TRC, TRCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=6
TRCA7:	SETUP	100,0
TRCA8:	RANDOM
TRCA9:	MOVE	AC1,AC		;MAKE "E"=C(AC).
	TRC	AC,(AC1)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRC SKIPPED.
	TRCA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC)SHOULD=RAN NUM
	ERRI	AC1,(AC1)
	LOOP	TRCA8,TRCA9

;TEST TRCE, TRCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=7
TRCE1:	SETUP	100,0
TRCE2:	RANDOM
TRCE3:	TRCN	AC,0		;E+C(AC)R=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRCN SKIPPED.
	TRCE	AC,0		;E+C(AC)R=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD STILL=RAN.
	EERRI	,0
	LOOP	TRCE2,TRCE3

;TEST TRCE, TRCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=10
TRCEA1:	SETUP	100,0
TRCEA2:	RANDOM
	TRNN	AC,-1		;RIGHT HALF OF AC CLR?
	JRST	TRCEA2		;YES. GO GEN A NEW RAN NUM.
TRCEA3:	SETZB	AC1,RAN1	;CLEAR C(AC).
	TRCN	AC1,(AC)	;E+C(AC)R=0.  NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRCN SKIPPED.
	TRCN	AC1,(AC)	;E+C(AC)R NOT=0.  SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD=0 AGAIN
	ERRI	RAN1,(AC)
	TRCE	AC1,(AC)	;E+C(AC)R=0 .SKIP
	ER	AC1,[ASCII /TST/]
	TRCE	AC1,(AC)	;E+C(AC)R NOT=0  NO SKIP
	CAME	AC1,[0]		;C(AC) SHOULD=0 AGAIN
	ERRI	RAN1,(AC)
	LOOP	TRCEA2,TRCEA3

;TEST TRCE, TRCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=10
TRCE4:	SETUP	100,0
TRCE5:	RANDOM
TRCE6:	IORI	AC,2		;MAKE C(AC) HAVE AT LEAST ONE BIT.
	MOVEI	AC1,(AC)	;CHECK TO MAKE
	CAIN	AC1,-1		;SURE C(AC)R DOES NOT = -1.
	JRST	TRCE5		;REJECT IF IT DOES.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	TRCE	AC,-1		;E+C(AC)R NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRCE SKIPPED.
	TRCN	AC,-1		;E+C(AC)R NOT=0.  SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,-1
	LOOP	TRCE5,TRCE6

;TEST TRCE, TRCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO-1 CONDITION.

	AC=3
TRCEA4:	SETUP	100,0
TRCEA5:	RANDOM
TRCEA6:	IORI	AC,4		;MAKE E HAVE AT LEAST ONE BIT.
	SETOB	AC1,RAN1	;SET C(AC) TO A -1.
	TRCE	AC1,(AC)	;E+C(AC)R NOT=0  NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRCE SKIPPED.
	TRCE	AC1,(AC)	;E+C(AC)R=0.  SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD=ORIG C(AC)
	ERRI	RAN1,(AC)
	TRCN	AC1,(AC)	;E+C(AC)R NOT=0. SKIP
	ER	AC1,[ASCII /TST/]
	TRCN	AC1,(AC)	;E+C(AC)R=0 NO SKIP
	CAME	AC1,[-1]	;C(AC) SHOULD=ORIG. C(AC).
	ERRI	RAN1,(AC)
	LOOP	TRCEA5,TRCEA6

;TEST TRCE, TRCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=3
TRCN1:	SETUP	100,0
TRCN2:	RANDOM
TRCN3:	IORI	AC,40		;MAKE C(AC) HAVE AT LEAST ONE BIT.
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR.
	MOVE	AC1,AC		;MAKE "E" = C(AC).
	TRCE	AC,(AC1)	;E+C (AC) R NOT=0  NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRCE SKIPPED.
	TRCE	AC,(AC1)	;E+C (AC)R=0  SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	AC1,(AC1)
	TRCN	AC,(AC1)	;E+C(AC)R NOT=0  SKIP
	ER	AC,[ASCII /TST/]
	TRCN	AC,(AC1)	;E+C (AC)R=0. NO SKIP
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	AC1,(AC1)
	LOOP	TRCN2,TRCN3
;TEST TRCE, TRCN. CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC WITH E = TO A FLOATING
;ONE AND C(AC) = RAN. NUM. WITH THAT BIT CLEAR.

	AC=2
TRCNA:	SETUP	40,0
	MOVEI	AC1,1		;SETUP E TO HAVE ONE BIT.
TRCNB:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES. REINITIALIZE E.
TRCNC:	ANDCM	AC,AC1		;CLEAR BIT IN AC.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	TRCN	AC,(AC1)	;E + C(AC)R = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRCN SKIPPED.
	TRCN	AC,(AC1)	;E + C(AC)R NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	TRCE	AC,(AC1)	;E + C(AC)R = 0...SKIP.
	ER	AC,[ASCII /TST/]
	TRCE	AC,(AC1)	;E + C(AC)R NOT = 0...NO SKIP.
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	LOOP	TRCNB,TRCNC

;TEST TLN, TLNA  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR 0 TO RAN CONDITION.

	AC=3
TLN1:	SETUP	100,0
TLN2:	RANDOM
TLN3:	TLN	AC,0		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLN SKIPPED.
	TLNA	AC,0		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI	,0
	LOOP	TLN2,TLN3

;TEST TLN, TLNA  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO 0 CONDITION

	AC=4
TLN4:	SETUP	100,0
TLN5:	RANDOM
TLN6:	SETZB	AC1,RAN1	;CLEAR C(AC)
	TLN	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLN SKIPPED.
	TLNA	AC1,(AC)	;SHOULD SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD=ORIG C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLN5,TLN6

;TEST TLN, TLNA.  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR -1 TO RAN CONDITION

	AC=5
TLN7:	SETUP	100,0
TLN8:	RANDOM
TLN9:	TLN	AC,-1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLN SKIPPED.
	TLNA	AC,-1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG.  C(AC)
	EERRI	,-1
	LOOP	TLN8,TLN9

;TEST TLN, TLNA.  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN  TO -1 CONDITION

	AC=6
TLNA1:	SETUP	100,0
TLNA2:	RANDOM
TLNA3:	SETOB	AC1,RAN1	;SET C(AC) TO=-1
	TLN	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLN SKIPPED.
	TLNA	AC1,(AC)	;SHOULD SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,RAN1	;C(AC) SHOULD=ORIG C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLNA2,TLNA3

;TEST TLN, TLNA.  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO RAN CONDITION

	AC=7
TLNA4:	SETUP	100,0
TLNA5:	RANDOM
TLNA6:	MOVE	AC1,AC		;MAKE "E"=C(AC)
	TLN	AC,(AC1)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLN SKIPPED.
	TLNA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	ERRI	AC1,(AC1)
	LOOP	TLNA5,TLNA6

;TEST TLN, TLNA.  CHECK FOR SKIP/NO SKIP AND
;NO DATA  CHANGE IN AC FOR RAN1 TO RAN CONDITION.

	AC=10
TLNA7:	SETUP	100,0
TLNA8:	RANDOM
TLNA9:	MOVE	AC1,AC		;MAKE "E"
	ROT	AC1,11		;A DIFFERENT RANDOM NUM
	TLN	AC,(AC1)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLN SKIPPED.
	TLNA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI	,(AC1)
	LOOP	TLNA8,TLNA9

;TEST TLNE, TLNN  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR 0 TO RAN CONDITION

	AC=11
TLNE1:	SETUP	100,0
TLNE2:	RANDOM
TLNE3:	TLNN	AC,0		;E+C(AC)L=0.  NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLNN SKIPPED.
	TLNE	AC,0		;E+C(AC)L=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI	,0
	LOOP	TLNE2,TLNE3

;TEST TLNE, TLNN.  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO 0 CONDITION

	AC=4
TLNE4:	SETUP	100,0
TLNE5:	RANDOM
TLNE6:	SETZB	AC1,RAN1	;CLEAR C(AC)
	TLNN	AC1,(AC)	;E+C(AC)L=0  NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLNN SKIPPED.
	TLNE	AC1,(AC)	;E+C(AC)L=0.  SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,RAN1	;C(AC) SHOULD=ORIG. C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLNE5,TLNE6

;TEST TLNE, TLNN, CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR -1 TO RAN CONDITION

	AC=5
TLNE7:	SETUP	100,0
TLNE8:	RANDOM
TLNE9:	IOR	AC,TSTLFT	;MAKE C(AC)L HAVE A BIT
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	TLNE	AC,-1		;E+C(AC)L NOT=0 NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLNE SKIPPED.
	TLNN	AC,-1		;E+C(AC)L NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,-1
	LOOP	TLNE8,TLNE9

;TEST TLNE, TLNN.  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO -1 CONDITION

	AC=6
TLNN1:	SETUP	100,0
TLNN2:	RANDOM
	IORI	AC,2		;MAKE "E" HAVE A BIT.
TLNN3:	SETOB	AC1,RAN1	;MAKE C(AC)=-1
	TLNE	AC1,(AC)	;E+C(AC)L NOT=0 NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLNE SKIPPED.
	TLNN	AC1,(AC)	;E+C(AC)L NOT=0. SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,RAN1	;C(AC) SHOULD=ORIG C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLNN2,TLNN3

;TEST TLNE, TLNN.  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN TO RAN CONDITION

	AC=7
TLNN4:	SETUP	100,0
TLNN5:	RANDOM
TLNN6:	IOR	AC,TSTLFT	;MAKE C(AC)L HAVE A BIT
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	MOVS	AC1,AC		;MAKE "E"=C(AC)L.
	TLNE	AC,(AC1)	;E+C(AC)L NOT=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLNE SKIPPED.
	TLNN	AC,(AC1)	;E+C(AC)L NOT=0.  SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	LOOP	TLNN5,TLNN6

;TEST TLNE, TLNN.  CHECK FOR SKIP/NO SKIP AND
;NO DATA CHANGE IN AC FOR RAN1 TO RAN CONDITION

	AC=10
TLNN7:	SETUP	100,0
TLNN8:	RANDOM
TLNN9:	IOR	AC,[XWD 100,100];MAKE C(AC) + E HAVE A BIT.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	MOVE	AC1,AC		;MAKE E A DIFF. RAN. NUM.
	TLNE	AC,(AC1)	;E+C (AC)L NOT=0. NO SKIP,
	JRST	.+2
	ER	AC,[ASCII /TST/];TLNE SKIPPED.
	TLNN	AC,(AC1)	;E+C(AC)L NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	LOOP	TLNN8,TLNN9

;TEST TLZ, TLZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=10
TLZ1:	SETUP	100,0
TLZ2:	RANDOM
TLZ3:	TLZ	AC,0		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLZ SKIPPED.
	TLZA	AC,0		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD STILL=RAN NUM
	EERRI	,0
	LOOP	TLZ2,TLZ3

;TEST TLZ, TLZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=3
TLZ4:	SETUP	100,0
TLZ5:	RANDOM
TLZ6:	SETZB	AC1,RAN1	;CLEAR C(AC).
	TLZ	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLZ SKIPPED.
	TLZA	AC1,(AC)	;SHOULD SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,RAN1	;C(AC) SHOULD STILL=0
	ERRI	RAN1,(AC)
	LOOP	TLZ5,TLZ6

;TEST TLZ, TLZA CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=3
TLZ7:	SETUP	100,0
TLZ8:	RANDOM
TLZ9:	MOVE	AC1,AC		;SIMULATE
	ANDI	AC1,-1		;A TLZ AC,-1.
	TLZ	AC,-1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLZ SKIPPED.
	TLZA	AC,-1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	EERRI	,-1
	LOOP	TLZ8,TLZ9

;TEST TLZ, TLZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION

	AC=2
TLZA1:	SETUP	100,0
TLZA2:	RANDOM
TLZA3:	SETOB	AC1,RAN1	;MAKE C(AC)=-1
	MOVSI	AC2,(AC)	;SIMULATE A
	SETCA	AC2,		;TLZ
	TLZ	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/]
;CORRECT DATA IN AC FOR NOT RAN1 TO RAN CONDITION.

	AC=4
TLZA7:	SETUP	100,0
TLZA8:	RANDOM
TLZA9:	MOVE	AC1,AC		;MAKE "E"
	ROT	AC1,11		;=A DIFFEREND VAND NUM
	MOVSI	AC2,(AC1)	;SIMULATE
	ANDCA	AC2,AC		;A TLZ
	TLZ	AC,(AC1)	;SHOULD NOT SKIP,
	JRST	.+2
	ER	AC,[ASCII /TST/];TLZ SKIPPED.
	TLZA	AC,(AC1)	;SHOULD SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERRI	,(AC1)
	LOOP	TLZA8,TLZA9

;TEST TLZE, TLZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=5
TLZE1:	SETUP	100,0
TLZE2:	RANDOM
TLZE3:	TLZN	AC,0		;E+C(AC)L=0.  NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLZN SKIPPED.
	TLZE	AC,0		;E+C(AC)L=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG. C(AC).
	EERRI	,0
	LOOP	TLZE2,TLZE3

;TEST TLZE, TLZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=6
TLZE4:	SETUP	100,0
TLZE5:	RANDOM
TLZE6:	SETZB	AC1,RAN1	;CLEAR C(AC)
	TLZN	AC1,(AC)	;E+C(AC)L=0. NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLZN SKIPPED.
	TLZE	AC1,(AC)	;E+C(AC)L=0. SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD=ORIG. C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLZE5,TLZE6

;TEST TLZE, TLZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION.

	AC=7
TLZE7:	SETUP	100,0
TLZE8:	RANDOM
TLZE9:	IOR	AC,TLFT1	;SET A BIT IN LEFT SIDE OF AC.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC2,AC		;SIMULATE
	ANDI	AC2,-1		;A TLZ AC,-1
	TLZE	AC,-1		;E+C(AC)L NOT = 0..NO SKIP.
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,-1
	MOVE	AC,RAN1		;RESTORE AC.
	TLZN	AC,-1		;E+C(AC)L NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,-1
	LOOP	TLZE8,TLZE9

;TEST TLZE, TLZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO-1 CONDITION

	AC=10
TLZN1:	SETUP	100,0
TLZN2:	RANDOM
TLZN3:	IORI	AC,400		;SET A BIT IN E.
	SETOB	AC1,RAN1	;MAKE C(AC) =-1
	MOVSI	AC2,(AC)	;SIMULATE
	SETCA	AC2,		;A TLZ
	TLZE	AC1,(AC)	;E+C(AC) L NOT=0  NO SKIP
	CAME	AC1,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC)
	SETO	AC1,		;RESTORE AC TO A-1
	TLZN	AC1,(AC)
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC)
	LOOP	TLZN2,TLZN3

;TEST TLZE, TLZN CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=11
TLZN4:	SETUP	100,0
TLZN5:	RANDOM
TLZN6:	IOR	AC,TLFT2	;SET A BIT IN LEFT SIDE OF AC.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVS	AC1,AC		;MAKE E = C(AC)L.
	MOVE	AC2,AC		;SIMULATE
	ANDI	AC2,-1		;A TLZ
	TLZE	AC,(AC1)	;E+C(AC)L NOT=0.  NO SKIP.
	CAME	AC,AC2		;C(AC) SHOULD=SIM.  ANS
	ERRI	RAN1,(AC1)
	MOVS	AC,AC1		;RESTORE AC.
	TLZN	AC,(AC1)	;E+C(AC)L NOT=0  SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM.  ANS
	ERRI	RAN1,(AC1)
	LOOP	TLZN5,TLZN6

;TEST TLZE, TLZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION.

	AC=4
TLZN7:	SETUP	100,1
TLZN8:	RANDOM
TLZN9:	IOR	AC,[XWD 10000,10000];SET A BIT IN C(AC) + E.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC1,AC		;MAKE E = A DIFF. RAN NUM.
	MOVSI	AC2,(AC1)	;SIMULATE
	ANDCA	AC2,AC		;A TLZ.
	TLZE	AC,(AC1)	;E+C(AC)L NOT = 0...NO SKIP.
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC1)
	MOVE	AC,RAN1		;RESTORE AC.
	TLZN	AC,(AC1)	;E+C(AC)L NOT=0. SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC1)
	LOOP	TLZN8,TLZN9

;TEST TLO, TLOA  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION.

	AC=5
TLO1:	SETUP	100,0
TLO2:	RANDOM
TLO3:	TLO	AC,0		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLO SKIPPED.
	TLOA	AC,0		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI
	LOOP	TLO2,TLO3

;TEST TLO, TLOA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=6
TLO4:	SETUP	100,0
TLO5:	RANDOM
TLO6:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVSI	AC2,(AC)	;SIMULATE TLO.
	TLO	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLO SKIPPED.
	TLOA	AC1,(AC)	;SHOULD SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC)
	LOOP	TLO5,TLO6

;TEST TLO, TLOA  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=7
TLO7:	SETUP	100,0
TLO8:	RANDOM
TLO9:	MOVE	AC1,AC		;SIMULATE
	IOR	AC1,[XWD -1,0]	;A TLO AC,-1.
	TLO	AC,-1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLO SKIPPED.
	TLOA	AC,-1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	EERRI	,-1
	LOOP	TLO8,TLO9

;TEST TLO, TLOA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=10
TLOA1:	SETUP	100,0
TLOA2:	RANDOM
TLOA3:	SETOB	AC1,RAN1	;MAKE C(AC)=-1.
	TLO	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLO SKIPPED.
	TLOA	AC1,(AC)	;SHOULD SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD STILL=-1
	ERRI	RAN1,(AC)
	LOOP	 TLOA2,TLOA3

;TEST TLO, TLOA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=2
TLOA4:	SETUP	100,0
TLOA5:	RANDOM
TLOA6:	MOVS	AC1,AC		;MAKE "E"=C(AC)L.
	TLO	AC,(AC1)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLO SKIPPED.
	TLOA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG. C(AC)
	EERRI	,(AC1)
	LOOP	TLOA5,TLOA6

;TEST TLO, TLOA.  CHECK FOR SKIPNO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION

	AC=2
TLOA7:	SETUP	100,0
TLOA8:	RANDOM
TLOA9:	MOVE	AC1,AC		;MAKE "E"
	ROT	AC1,11		;=A DIFFERENT RAN  NUM
	MOVSI	AC2,(AC1)	;SIMULATE
	IOR	AC2,AC		;A TLO
	TLO	AC,(AC1)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLO SKIPPED.
	TLOA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERRI	,(AC1)
	LOOP	TLOA8,TLOA9

;TEST TLOE, TLON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION.

	AC=2
TLOE1:	SETUP	100,0
TLOE2:	RANDOM
TLOE3:	TLON	AC,0		;E+C(AC)=0.  NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLON SKIPPED.
	TLOE	AC,0		;E+C(AC)=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG. C(AC)
	EERRI
	LOOP	TLOE2,TLOE3

;TEST TLOE, TLON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=3
TLOE4:	SETUP	100,0
TLOE5:	RANDOM
TLOE6:	IORI	AC,20000	;SET A BIT IN E.
	SETZB	AC1,RAN1	;CLEAR AC.
	MOVSI	AC2,(AC)	;SIMULATE A TLO
	TLOE	AC1,(AC)	;E+C(AC)L=0.  SKIP
	ER	AC1,[ASCII /TST/]
	TLON	AC1,(AC)	;E+C(AC)L NOT=0. SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC)
	LOOP	TLOE5,TLOE6

;TEST TLOE, TLON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION.

	AC=2
TLOE7:	SETUP	100,0
TLOE8:	RANDOM
TLOE9:	IOR	AC,TSTLFT	;SET A BIT IN LEFT SIDE OF AC.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVSI	AC1,-1		;SIMULATE
	IOR	AC1,AC		;A TLO.
	TLOE	AC,-1		;E+C(AC)L NOT=0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLOE SKIPPED.
	TLON	AC,-1		;E+C(AC)L NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC1
	ERRI	RAN1,-1
	LOOP	TLOE8,TLOE9

;TEST TLOE, TLON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=3
TLON1:	SETUP	100,0
TLON2:	RANDOM
TLON3:	IORI	AC,10		;SET A BIT IN E
	SETOB	AC1,RAN1	;SET C(AC) TO=-1.
	TLOE	AC1,(AC)	;E+C(AC)L NOT =0.  NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLOE SKIPPED.
	TLON	AC1,(AC)	;E+C(AC)L NOT=0  SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD STILL=-1.
	ERRI	RAN1,(AC)
	LOOP	TLON2,TLON3

;TEST TLOE, TLON.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=4
TLON4:	SETUP	100,0
TLON5:	RANDOM
TLON6:	IOR	AC,TLFT1	;SET A BIT IN LEFT SIDE OF AC.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	MOVS	AC1,AC		;MAKE E = C(AC)L.
	TLOE	AC,(AC1)	;E+C(AC)L NOT=0.  NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLOE SKIPPED.
	TLON	AC,(AC1)	;E+C(AC)L NOT=0  SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	LOOP	TLON5,TLON6

;TEST TLOE, TLON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION.

	AC=5
	TLON7:	SETUP	100,1
TLON8:	RANDOM
TLON9:	IOR	AC,[XWD 400000,400000];SET A BIT IN AC + E.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC1,AC		;MAKE E A DIFF RAN NUM.
	MOVSI	AC2,(AC1)	;SIMULATE
	IOR	AC2,AC		;A TLO
	TLOE	AC,(AC1)	;E+C(AC)L NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLOE SKIPPED.
	TLON	AC,(AC1)	;E+C(AC)L NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2
	ERRI	RAN1,(AC1)	;C(AC) SHOULD=SIM. ANS
	LOOP	TLON8,TLON9

;TEST TLC, TLCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=6
TLC1:	SETUP	100,0
TLC2:	RANDOM
TLC3:	TLC	AC,0		;SHOULD NOT SKIP,.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLC SKIPPED.
	TLCA	AC,0		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT HAVE CHANGED
	EERRI
	LOOP	TLC2,TLC3

;TEST TLC, TLCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0. CONDITION.

	AC=7
TLC4:	SETUP	100,0
TLC5:	RANDOM
TLC6:	SETZB	AC1,RAN1	;CLEAR AC
	TLC	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLC SKIPPED.
	TLCA	AC1,(AC)	;SHOULD SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD=ORIG C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLC5,TLC6
;TEST TLC, TLCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=10
TLC7:	SETUP	100,0
TLC8:	RANDOM
TLC9:	TLC	AC,-1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLC SKIPPED.
	TLCA	AC,-1
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI	,-1
	LOOP	TLC8,TLC9

;TEST TLC, TLCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION

	AC=3
TLCA1:	SETUP	100,0
TLCA2:	RANDOM
TLCA3:	SETOB	AC1,RAN1	;MAKE C(AC) = -1.
	TLC	AC1,(AC)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLC SKIPPED.
	TLCA	AC1,(AC)	;SHOULD SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD=ORIG. C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLCA2,TLCA3

;TEST TLC, TLCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=2
TLCA4:	SETUP	100,0
TLCA5:	RANDOM
TLCA6:	MOVS	AC1,AC		;MAKE "E"=C(AC)L.
	TLC	AC,(AC1)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLC SKIPPED.
	TLCA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI	,(AC1)
	LOOP	TLCA5,TLCA6

;TEST TLC, TLCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN

	AC=3
TLCA7:	SETUP	100,0
TLCA8:	RANDOM
TLCA9:	SETCM	AC1,AC		;MAKE "E"=
	MOVS	AC1,AC1		;1'S COMP OF C(AC)L.
	TLC	AC,(AC1)	;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLC SKIPPED.
	TLCA	AC,(AC1)	;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI	,(AC1)
	LOOP	TLCA8,TLCA9

;TEST TLCE, TLCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=4
TLCE1:	SETUP	100,0
TLCE2:	RANDOM
TLCE3:	TLCN	AC,0		;E+C(AC)L=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLCN SKIPPED.
	TLCE	AC,0		;E+C(AC)L=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC).
	EERRI	,0
	LOOP	TLCE2,TLCE3

;TEST TLCE, TLCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=5
TLCE4:	SETUP	100,0
TLCE5:	RANDOM
TLCE6:	IORI	AC,1		;MAKE SURE A BIT IS SET IN E.
	SETZB	AC1,RAN1	;CLEAR C(AC).
	TLCN	AC1,(AC)	;E+C(AC)L=0.  NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TLCN SKIPPED.
	TLCN	AC1,(AC)	;E+C(AC)L NOT=0.  SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD=ORIG C(AC).
	ERRI	RAN1,(AC)
	TLCE	AC1,(AC)	;E+C(AC)L=0. SKIP
	ER	AC1,[ASCII /TST/]
	TLCE	AC1,(AC)	;E+C(AC)L NOT=0  NO SKIP
	CAME	AC1,[0]		;C(AC) SHOULD=ORIG. C(AC)
	ERRI	RAN1,(AC)
	LOOP	TLCE5,TLCE6

;TEST TLCE, TLCN  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=6
TLCE7:	SETUP	100,0
TLCE8:	RANDOM
TLCE9:	IOR	AC,TSTLFT	;SET A BIT IN AC LEFT.
	MOVS	AC1,AC		;CHECK TO MAKE
	MOVEI	AC1,(AC1)	;SURE C(AC)L DOES
	CAIN	AC1,-1		;NOT = -1.
	JRST	TLCE8		;REJECT IF IT DOES.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	TLCE	AC,-1		;E+C(AC) L NOT=0.  NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLCE SKIPPED.
	TLCN	AC,-1		;E+C(AC)L NOT=0.  SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,-1
	LOOP	TLCE8,TLCE9

;TEST TLCE, TLCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO-1 CONDITION

	AC=7
TLCN1:	SETUP	100,0
TLCN2:	RANDOM
TLCN3:	IORI	AC,4		;SET A BIT IN E.
	SETOB	AC1,RAN1	;MAKE C(AC)=-1
	TLCN	AC1,(AC)	;E+C(AC)L NOT=0. SKIP
	ER	AC1,[ASCII /TST/]
	TLCE	AC1,(AC)	;E+C(AC)L=0. SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD=ORIG C(AC).
	ERRI	RAN1,(AC)
	LOOP	TLCN2,TLCN3

;TEST TLCE, TLCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=10
TLCN4:	SETUP	100,0
TLCN5:	RANDOM
TLCN6:	IOR	AC,TLFT1	;MAKE SURE A BIT IS SET IN AC LEFT.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	MOVS	AC1,AC		;MAKE "E"=C(AC)L
	TLCE	AC,(AC1)	;E+C(AC)L NOT=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TLCE SKIPPED.
	TLCE	AC,(AC1)	;E+C(AC)L=0 SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	TLCN	AC,(AC1)	;E+C(AC)L NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	TLCN	AC,(AC1)	;E+C(AC)L=0. NO SKIP
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	LOOP	TLCN5,TLCN6

;TEST TLCE, TLCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR E = TO A FLOATING ONE
;AND C(AC) = RAN. NUM. WITH THAT BIT CLEAR.

	AC=11
TLCN7:	SETUP	100,0
	MOVEI	AC1,1		;SETUP E TO HAVE ONE BIT.
TLCN8:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES. REINITAILIZE E.
TLCN9:	MOVS	AC2,AC1		;CLEAR THAT
	ANDCM	AC,AC2		;BIT IN AC.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	TLCN	AC,(AC1)	;E + C(AC)L = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TLCN SKIPPED.
	TLCN	AC,(AC1)	;E + C(AC)L NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	TLCE	AC,(AC1)	;E + C(AC)L = 0...SKIP.
	ER	AC,[ASCII /TST/]
	TLCE	AC,(AC1)	;E + C(AC)L NOT = 0...NO SKIP.
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,(AC1)
	LOOP	TLCN8,TLCN9


;TEST SETZB.  CHECK C(AC)=C(E), AND C(AC)=CORRECT DATA
;RAN TO RAN1.

	AC=2
SETZB1:	SETUP	100,0
SETZB2:	RANDOM
SETZB3:	MOVSS	RAN1,AC		;C(AC) = SEC. RAN. NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN NUM
	SETZB	AC,AC1		;DO A SETZB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,[0]		;C(AC) SHOULD=0.
	EERR	,RAN1
	LOOP	SETZB2,SETZB3

;TEST ANDB.  CHECK C(AC)=C(E), AND C(AC)=CORRECT DATA
;RAN TO RAN1

	AC=3
ANDB1:	SETUP	200,1
ANDB2:	RANDOM
ANDB3:	MOVSS	RAN1,AC		;C(AC) = SEC. RAN. NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN NUM
	MOVE	AC2,RAN		;SIMULATE
	ORCB	AC2,AC		;AN
	SETCA	AC2,		;"AND" INST.
	ANDB	AC,AC1		;DO AN ANDB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E)
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	ANDB2,ANDB3

;TEST ANDCAB.  CHECK FOR C(AC)=C(E) AND C(AC)=CORRECT DATA.
;RAN TO RAN1

	AC=2
ANCAB1:	SETUP	200,1
ANCAB2:	RANDOM
ANCAB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM
	MOVE	AC2,RAN		;SIMULATE
	ORCA	AC2,AC		;AN
	SETCA	AC2,		;ANDCA INST.
	ANDCAB	AC,AC1		;DO AN ANDCAB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E)
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	ANCAB2,ANCAB3

;TEST SETMB. CHECK FOR C(AC)=C(E), AND C(AC)=CORRECT DATA.
;RAN TO RAN1.

	AC=4
SETMB1:	SETUP	100,0
SETMB2:	RANDOM
SETMB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC1,RAN
	SETMB	AC,AC1		;DO SETMB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E)
	EERR	,RAN1
	CAME	AC,RAN		;C(AC) SHOULD=ORIG. C(E)
	EERR	,RAN1
	LOOP	SETMB2,SETMB3

;TEST ANDCMB  CHECK FOR C(AC)=C(E), AND CORRECT DATA IN AC.
;RAN TO RAN1.

	AC=4
ANCMB1:	SETUP	200,1
ANCMB2:	RANDOM
ANCMB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)-1'ST RAN NUM
	MOVE	AC2,RAN		;SIMULATE
	ORCM	AC2,AC		;AN
	SETCA	AC2,		;ANDCM INST.
	ANDCMB	AC,AC1		;DO ANDCMB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	ANCMB2,ANCMB3

;TEST SETAB.  CHECK FOR C(AC)=C(E), AND C(E)=CORRECT DATA
;RAN TO RAN1.

	AC=5
SETAB1:	SETUP	100,0
SETAB2:	RANDOM
SETAB3:	MOVSS	RAN1,AC		;C(AC) =SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM.
	SETAB	AC,AC1		;DO A SETAB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC1,RAN1	;C(E) SHOULD=ORIG. C(AC).
	EERR	,RAN1
	LOOP	SETAB2,SETAB3

;TEST XORB.  CHECK FOR C(AC)=C(E),AND CORRECT DATA IN AC.
;RAN TO RAN1.

	AC=6
XORB1:	SETUP	200,1
XORB2:	RANDOM
XORB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM
	MOVE	AC2,RAN		;SIMULATE
	EQV	AC2,AC		;AN
	SETCA	AC2,		;XOR INST.
	XORB	AC,AC1		;DO AN XORB INST
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	XORB2,XORB3

;TEST IORB.  CHECK FOR C(AC)=C(E), AND C(AC)=CORRECT DATA.
;RAN TO RAN1.

	AC=7
IORB1:	SETUP	200,1
IORB2:	RANDOM
IORB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM.
	MOVE	AC2,RAN		;SIMULATE
	ANDCM	AC2,AC		;AN
	XOR	AC2,AC		;IOR INST.
	IORB	AC,AC1		;DO AN IORB INST
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	IORB2,IORB3

;TEST ANDCBB.  CHECK C(AC)=C(E), AND C(AC)=CORRECT DATA.
;RAN TO RAN1

	AC=10
ANCBB1:	SETUP	200,1
ANCBB2:	RANDOM
ANCBB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(AC)=1'ST RAN. NUM
	MOVE	AC2,RAN		;SIMULATE
	IOR	AC2,AC		;AN
	SETCA	AC2,		;ANDCB INST
	ANDCBB	AC,AC1		;DO AN ANDCBB INST
	CAME	AC,AC1		;C(AC) SHOULD=C(E)
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	ANCBB2,ANCBB3

;TEST EQVB.  CHECK FOR C(AC)=C(E), AND CORRECT DATA IN AC.
;RAN TO RAN1

	AC=11
EQVB1:	SETUP	200,1
EQVB2:	RANDOM
EQVB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM.
	MOVE	AC2,RAN		;SIMULATE
	XOR	AC2,AC		;AN
	SETCA	AC2,		;EQV INST1
	EQVB	AC,AC1		;NO AN EQVB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	EQVB2,EQVB3

;TEST SETCAB.  CHECK FOR C(AC)=C(E), AND C(AC)=CORRECT DATA.
;RAN TO RAN1

	AC=4
STCAB1:	SETUP	100,0
STCAB2:	RANDOM
STCAB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM
	SETCM	AC2,AC		;SIMULATE A SETCA INST.
	SETCAB	AC,AC1		;DO SETCAB INST
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	STCAB2,STCAB3

;TEST ORCAB.  CHECK FOR C(AC)=C(E), AND C(AC)=CORRECT DATA
;RAN TO RAN1

	AC=5
ORCAB1:	SETUP	200,1
ORCAB2:	RANDOM
ORCAB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E) =1'ST RAN. NUM
	SETCM	AC2,AC		;SIMULATE
	IOR	AC2,RAN		;AN ORCA INST.
	ORCAB	AC,AC1		;DO AN ORCAB INST
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	ORCAB2,ORCAB3

;TEST SETCMB.  CHECK FOR C(AC)=C(E), AND C(AC)=CORRECT DATA
;RAN TO RAN1

	AC=6
STCMB1:	SETUP	100,0
STCMB2:	RANDOM
STCMB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN NUM.
	MOVE	AC2,RAN		;SIMULATE
	SETCA	AC2,		;A SETCM INST.
	SETCMB	AC,AC1		;DO A SETCMB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	STCMB2,STCMB3

;TEST ORCMB.  CHECK FOR C(AC)=C(E), AND C(AC)=CORRECT DATA.
;RAN TO RAN1

	AC=7
ORCMB1:	SETUP	200,1
ORCMB2:	RANDOM
ORCMB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM
	MOVE	AC2,RAN		;SIMULATE
	ANDCM	AC2,AC		;AN
	SETCA	AC2,		;ORCM INST.
	ORCMB	AC,AC1		;DO AN ORCMB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	ORCMB2,ORCMB3

;TEST ORCBB. CHECK FOR C(AC)=C(E), AND C(AC)=CORRECT DATA
;RAN TO RAN1.

	AC=10
ORCBB1:	SETUP	200,1
ORCBB2:	RANDOM
ORCBB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN NUM
	MOVE	AC2,RAN		;SIMULATE
	AND	AC2,AC		;AN
	SETCA	AC2,		;ORCB INST.
	ORCBB	AC,AC1		;DO AN ORCBB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	ORCBB2,ORCBB3

;TEST SETOB.  CHECK FOR C(AC)=C(E), AND C(AC)=-1.
;RAN TO RAN1

	AC=10
STOB1:	SETUP	100,0
STOB2:	RANDOM
STOB3:	MOVSS	RAN1,AC		;C(AC) = SEC RAN NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM
	SETOB	AC,AC1		;DO A SETOB INST.
	CAME	AC,AC1		;C(AC) SHOULD=C(E).
	EERR	,RAN1
	CAME	AC,[-1]		;C(AC) SHOULD=-1
	EERR	,RAN1
	LOOP	STOB2,STOB3

;TEST HLL. CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=3
HLL1:	SETUP	100,0
HLL2:	RANDOM
HLL3:	ROT	AC,11		;MAKE C(AC) A DIFFERENT RAN NUM.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVEI	AC1,(AC)	;SIMULATE
	MOVS	AC2,RAN		;A
	TLO	AC1,(AC2)	;HLL.
	HLL	AC,RAN		;DO HLL.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC1,RAN1
	LOOP	HLL2,HLL3

;TEST HLLI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=3
HLLI1:	SETUP	100,0
HLLI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
HLLI3:	ROT	AC,11		;MAKE C(AC) DIFF. RAN. NUM.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVEI	AC1,(AC)	;SIMULATE A HLLI.
	HLLI	AC,(AC2)	;DO HLLI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HLLI2,HLLI3

;TEST HLLM.  CHECK C(E) FOR CORRECT DATA.
;RAN1 TO RAN1.

	AC=3
HLLM1:	SETUP	100,0
HLLM2:	RANDOM
	MOVE	AC3,RAN		;SAVE C(AC) IN CASE OF ERROR.
HLLM3:	ROT	AC,11		;MAKE C (E) A DIFFERENT RAN NUM
	MOVEM	AC,RAN1		;SAVE IN CASE OF ERROR
	MOVEI	AC1,(AC)	;SIMULATE
	MOVS	AC2,RAN		;A
	TLO	AC1,(AC2)	;HLLM
	HLLM	AC3,AC		;DO HLLM.
	CAME	AC1,AC		;C(E) SHOULD=SIM ANS
	ERRM	RAN1,AC3
	LOOP	HLLM2,HLLM3


;TEST HLLS.
;CHECK C(E), C(E) SHOULD NOT CHANGE, AND CORRECT
;LOADING OF C(E) INTO AC.
;RAN TO RAN.

	AC=4
HLLS1:	SETUP	100,0
HLLS2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN FOR FUTURE COMPARE.
HLLS3:	SETOB	AC1,RAN1	;MAKE C (AC)=-1
	HLLS	AC1,AC		;DO HLLS
	CAME	AC1,AC		;C(AC) SHOULD=C(E)
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD = ORIG C(AC).
	EERRM	,RAN1
	LOOP	HLLS2,HLLS3

;TEST HRR. CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=5
HRR1:	SETUP	100,0
HRR2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN ANOTHER AC.
HRR3:	ROT	AC,11		;MAKE C(AC) A DIFFERENT RAN NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC1,AC		;SIMULATE
	TRZ	AC1,-1		;A
	TRO	AC1,(AC2)	;HRR.
	HRR	AC,RAN		;DO HRR
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HRR2,HRR3

;TEST HRRI. CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=6
HRRI1:	SETUP	100,0
HRRI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
HRRI3:	ROT	AC,11		;MAKE C(AC)=DIFFERENT RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF AN ERROR
	MOVE	AC1,AC		;SIMULATE
	TRZ	AC1,-1		;A
	TRO	AC1,(AC2)	;HRRI.
	HRRI	AC,(AC2)	;DO HRRI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HRRI2,HRRI3

;TEST HRRM. CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN1

	AC=7
HRRM1:	SETUP	100,0
HRRM2:	RANDOM
	MOVE	AC2,RAN		;SAVE C(AC).
HRRM3:	ROT	AC,11		;MAKE C(E)=DIFFERENT RAN. NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVE	AC1,AC		;SIMULATE
	TRZ	AC1,-1		;A
	TRO	AC1,(AC2)	;HRRM.
	HRRM	AC2,AC		;DO HRRM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS.
	ERRM	RAN1,RAN
	LOOP	HRRM2,HRRM3

;TEST HRRS.  CHECK C(E) FOR NOT CHANGING, AND
;CORRECT STORING OF C(E) INTO AC.
;RAN TO RAN

	AC=10
HRRS1:	SETUP	100,0
HRRS2:	RANDOM
	MOVE	AC2,RAN		;SAVE C(AC).
HRRS3:	SETOB	AC1,RAN1	;SET C(AC)=-1
	HRRS	AC1,AC		;DO HRRS
	CAME	AC1,AC		;C(AC) SHOULD=C(E)
	ERRM	AC2,RAN1
	CAME	AC2,AC		;C(E) SHOULD = ORIG. C(E).
	ERRM	AC2,RAN1
	LOOP	HRRS2,HRRS3

;TEST HRL.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=11
HRL1:	SETUP	140,0
HRL2:	RANDOM
	MOVE	AC2,RAN		;SAVE C(E).
HRL3:	ROT	AC,11		;C(AC)=SECOND RANDOM NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR.
	MOVSI	AC1,(AC2)	;SIMULATE
	TRO	AC1,(AC)	;A HRL
	HRL	AC,RAN		;DO HRL
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HRL2,HRL3

;TEST HRLI.  CHECK C(AC)FOR CORRECT DATA.
;RAN TO RAN1

	AC=4
HRLI1:	SETUP	140,0
HRLI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
HRLI3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR.
	MOVSI	AC1,(AC2)	;SIMULATE
	TRO	AC1,(AC)	;A HRLI
	HRLI	AC,(AC2)	;DO HRLI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HRLI2,HRLI3

;TEST HRLM.  CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN1

	AC=5
HRLM1:	SETUP	140,0
HRLM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLM3:	ROT	AC,11		;C(E)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVSI	AC1,(AC2)	;SIMULATE
	TRO	AC1,(AC)	;A HRLM
	HRLM	AC2,AC		;DO HRLM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS.
	ERRM	RAN1,RAN
	LOOP	HRLM2,HRLM3

;TEST HRLS.  CHECK C(E) FOR CORRECT DATA, AND
;CORRECT STORING OF C(E) INTO AC.
;RAN TO RAN

	AC=6
HRLS1:	SETUP	140,0
HRLS2:	RANDOM
HRLS3:	SETOB	AC1,RAN1	;SET C(AC) TO -1
	MOVSI	AC2,(AC)	;SIMULATE
	TRO	AC2,(AC)	;A HRLS
	HRLS	AC1,AC		;DO HRLS
	CAME	AC1,AC		;C(AC) SHOULD=C(F) AFTER HRLS
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS
	EERRM	,RAN1
	LOOP	HRLS2,HRLS3

;TEST HLR.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=7
HLR1:	SETUP	140,0
HLR2:	RANDOM
HLR3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVE	AC1,AC		;SIMULATE
	TRZ	AC1,-1		;A
	MOVS	AC2,RAN		;HLR
	TRO	AC1,(AC2)	;INST
	HLR	AC,RAN		;DO HLR
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	HLR2,HLR3

;TEST HLRI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=10
HLRI1:	SETUP	140,0
HLRI2:	RANDOM
	MOVE	AC3,RAN		;SAVE RAN IN AN AC.
HLRI3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVE	AC1,AC		;SIMULATE
	TRZ	AC1,-1		;A HLRI
	HLRI	AC,(AC3)	;DO HLRI.
	CAME	AC,AC1		;C(AC) SHOULD=SIMULATED ANS
	ERRI	RAN1,(AC3)
	LOOP	HLRI2,HLRI3

;TEST HLRM  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1.

	AC=10
HLRM1:	SETUP	100,0
HLRM2:	RANDOM
	MOVE	AC3,RAN		;SAVE RAN IN AN AC.
HLRM3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVE	AC1,AC		;SIMULATE
	TRZ	AC1,-1		;A
	MOVS	AC2,RAN		;HLRM
	TRO	AC1,(AC2)	;INST
	HLRM	AC3,AC		;DO HLRM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HLRM2,HLRM3

;TEST HLRS.  CHECK C(E) FOR CORRECT DATA, AND
;CORRECT STORING OF C(E) INTO AC
;RAN TO RAN.

	AC=2
HLRS1:	SETUP	140,0
HLRS2:	RANDOM
HLRS3:	SETOB	AC1,RAN1	;SAVE IN CASE OF ERROR
	MOVE	AC2,AC		;SIMULATE
	TRZ	AC2,-1		;A
	MOVS	AC3,AC		;HLRS
	TLZ	AC3,-1
	IOR	AC2,AC3		;INST
	HLRS	AC1,AC		;DO HLRS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HLRS
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS.
	EERRM	,RAN1
	LOOP	HLRS2,HLRS3

;TEST HLLZ.  CHECK C(AC) FOR  CORRECT DATA
;RAN TO RAN1.

	AC=3
HLLZ1:	SETUP	200,0
HLLZ2:	RANDOM
HLLZ3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TRZ	AC1,-1		;A HLLZ
	HLLZ	AC,RAN		;DO HLLZ
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	HLLZ2,HLLZ3

;TEST HLLZI.  CHECK C(AC) FOR 0
;RAN TO RAN1

	AC=2
HLLZI1:	SETUP	200,0
HLLZI2:	RANDOM
	MOVE	AC1,RAN		;SAVE RAN IN AN AC.
HLLZI3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	HLLZI	AC,(AC1)	;DO HLLZI.
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,(AC1)
	LOOP	HLLZI2,HLLZI3

;TEST HLLZM.  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1

	AC=3
HLLZM1:	SETUP	200,0
HLLZM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLLZM3:	ROT	AC,11		;C(E)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TRZ	AC1,-1		;A HLLZM
	HLLZM	AC2,AC		;DO HLLZM.
	CAME	AC1,AC		;C(E) SHOULD=SIM.ANS
	ERRM	RAN1,RAN
	LOOP	HLLZM2,HLLZM3

;TEST HLLZS.  CHECK C(E) FOR CORRECT DATA, AND
;CORRECT STORING OF C(E) INTO AC.
;RAN TO RAN.

	AC=4
HLLZS1:	SETUP	200,0
HLLZS2:	RANDOM
HLLZS3:	SETOB	AC1,RAN1	;SET C(AC) TO A -1
	MOVE	AC2,AC		;SIMULATE
	TRZ	AC2,-1		;A HLLZS
	HLLZS	AC1,AC		;DO HLLZS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HLLZS
	EERRM	,RAN1
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	EERRM	,RAN1
	LOOP	HLLZS2,HLLZS3

;TEST HRRZ.  CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1

	AC=5
HRRZ1:	SETUP	200,0
HRRZ2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRRZ3:	ROT	AC,11		;C(AC)=SECOND RAND NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVEI	AC1,(AC2)	;SIMULATE A HRRZ INST.
	HRRZ	AC,RAN		;DO HRRZ
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HRRZ2,HRRZ3

;TEST HRRZI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=6
HRRZI1:	SETUP	200,0
HRRZI2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRRZI3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVEI	AC1,(AC2)	;SIMULATE A HRRZI INST.
	HRRZI	AC,(AC2)	;DO HRRZI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HRRZI2,HRRZI3

;TEST HRRZM.  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1

	AC=7
HRRZM1:	SETUP	200,0
HRRZM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRRZM3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE IN CASE OF ERROR
	MOVEI	AC1,(AC2)	;SIMULATE A HRRZM INST.
	HRRZM	AC2,AC		;DO HRRZM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HRRZM2,HRRZM3

;TEST HRRZS.  CHECK C(E) FOR CORRECT DATA, AND
;CORRECT STORING OF C(E) INTO AC.
;RAN TO RAN.

	AC=10
HRRZS1:	SETUP	200,0
HRRZS2:	RANDOM
HRRZS3:	SETOB	AC1,RAN1	;SETC(AC) TO A-1
	MOVEI	AC2,(AC)	;SIMULATE A HRRZS
	HRRZS	AC1,AC		;DO HRRZS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HRRZS
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS
	EERRM	,RAN1
	LOOP	HRRZS2,HRRZS3

;TEST HLLO. CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=11
HLLO1:	SETUP	200,0
HLLO2:	RANDOM
HLLO3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC1,RAN		;SIMULATE
	TRO	AC1,-1		;A HLLO
	HLLO	AC,RAN		;DO HLLO
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	HLLO2,HLLO3


;TEST HLLOI  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=4
HLLOI1:	SETUP	200,0
HLLOI2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLLOI3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	SETZ	AC1,		;SIMULATE
	TRO	AC1,-1		;A HLLOI
	HLLOI	AC,(AC2)	;DO HLLOI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HLLOI2,HLLOI3

;TEST HLLOM. CHECK C(E) FOR CORRECT DATA
;RAN TO RAO1

	AC=5
HLLOM1:	SETUP	200,0
HLLOM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLLOM3:	ROT	AC,11		;C(E) =SECOND RANDOM NUM.
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TRO	AC1,-1		;A HLLOM
	HLLOM	AC2,AC		;DO A HLLOM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HLLOM2,HLLOM3

;TEST HLLOS.  CHECK C(E) FOR CORRECT DATA, AND
;CORRECT STORING OF C(E) INTO AC.
;RAN TO RAN

	AC=6
HLLOS1:	SETUP	200,0
HLLOS2:	RANDOM
HLLOS3:	SETOB	AC1,RAN1	;SET C(AC) TO A -1
	MOVE	AC2,AC		;SIMULATE
	TRO	AC2,-1		;A HLLOS
	HLLOS	AC1,AC		;DO HLLOS
	CAME	AC1,AC		;C(AC) SHOULD=C(AC) AFTER HLLOS
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM ANS
	EERRM	,RAN1
	LOOP	HLLOS2,HLLOS3

;TEST HRRO.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=7
HRRO1:	SETUP	200,0
HRRO2:	RANDOM
HRRO3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TLO	AC1,-1		;A HRRO
	HRRO	AC,RAN		;DO HRRO
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	HRRO2,HRRO3

;TEST HRROI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=10
HRROI1:	SETUP	200,0
HRROI2:	RANDOM
	MOVE	AC3,RAN		;SAVE RAN IN AN AC.
HRROI3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TLO	AC1,-1		;A HRROI
	HRROI	AC,(AC3)	;DO HRROI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC3)
	LOOP	HRROI2,HRROI3

;TEST HRROM.  CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN1

	AC=10
HRROM1:	SETUP	200,0
HRROM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRROM3:	ROT	AC,11		;C(E)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TLO	AC1,-1		;A HRROM
	HRROM	AC2,AC		;DO HRROM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HRROM2,HRROM3

;TEST HRROS.  CHECK C(E) FOR CORRECT DATA, AND
;CORRECT STORING OF C(E) INTO AC.
;RAN TO RAN

	AC=2
HRROS1:	SETUP	200,0
HRROS2:	RANDOM
HRROS3:	SETOB	AC1,RAN1	;SET C(AC) TO A -1
	MOVE	AC2,AC		;SIMULATE
	TLO	AC2,-1		;A HRROS
	HRROS	AC1,AC		;DO HRROS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HRROS
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS
	EERRM	,RAN1
	LOOP	HRROS2,HRROS3

;TEST HRLO.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=3
HRLO1:	SETUP	200,1
HRLO2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLO3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVSI	AC1,(AC2)	;SIMULATE
	TRO	AC1,-1		;A HRLO
	HRLO	AC,RAN		;DO HRLO
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HRLO2,HRLO3

;TEST HRLOI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=2
HRLOI1:	SETUP	200,1
HRLOI2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLOI3:	ROT	AC,11		;C(AC)=SECOND RANDOM NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVSI	AC1,(AC2)	;SIMULATE
	TRO	AC1,-1		;A HRLOI
	HRLOI	AC,(AC2)	;DO HRLOI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HRLOI2,HRLOI3

;TEST HRLOM.  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1

	AC=3
HRLOM1:	SETUP	200,1
HRLOM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLOM3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVSI	AC1,(AC2)	;SIMULATE
	TRO	AC1,-1		;A HRLOM
	HRLOM	AC2,AC		;DO HRLOM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HRLOM2,HRLOM3

;TEST HRLOS.  CHECK C(E) FOR CORRECT DATA AND IF
;C(AC) IS BEING LOADED WITH C(E) FOR RAN TO RAN CONDITION.

	AC=4
HRLOS1:	SETUP	200,1
HRLOS2:	RANDOM
HRLOS3:	SETOB	AC1,RAN1	;SET C(AC) TO A -1
	MOVSI	AC2,(AC)	;SIMULATE
	TRO	AC2,-1		;A HRLOS
	HRLOS	AC1,AC		;DO HRLOS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HRLOS
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS
	EERRM	,RAN1
	LOOP	HRLOS2,HRLOS3

;TEST HLLE.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=5
HLLE1:	SETUP	200,2
HLLE2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLLE3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TRZ	AC1,-1		;A
	TLNE	AC2,400000	;HLLE
	TRO	AC1,-1		;INST
	HLLE	AC,RAN		;DO HLLE
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HLLE2,HLLE3

;TEST HLLEI.  CHECK C(AC) FOR 0
;RAN TO RAN1

	AC=6
HLLEI1:	SETUP	200,2
HLLEI2:	RANDOM
	MOVE	AC1,RAN		;SAVE RAN IN AN AC.
HLLEI3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	HLLEI	AC,(AC1)	;DO HLLEI.
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,(AC1)
	LOOP	HLLEI2,HLLEI3

;TEST HLLEM.  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1.

	AC=7
HLLEM1:	SETUP	200,2
HLLEM2:	RANDOM
	MOVE	AC2,RAN		;SAVE AC IN AN AC.
HLLEM3:	ROT	AC,11		;C(E)=SECOND RANDOM NUMBER
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TRZ	AC1,-1		;A
	TLNE	AC2,400000	;HLLEM
	TRO	AC1,-1		;INST
	HLLEM	AC2,AC		;DO HLLEM.
	CAME	AC1,AC		;C(E) SHOULD=SIM ANS
	ERRM	RAN1,RAN
	LOOP	HLLEM2,HLLEM3

;TEST HLLES.  CHECK C(E) FOR CORRECT DATA AND
;PROPER STORING THE C(E) INTO C(AC) FOR RAN TO RAN CONDITION

	AC=10
HLLES1:	SETUP	200,2
HLLES2:	RANDOM
HLLES3:	SETOB	AC1,RAN1	;SET C(AC)=-1
	MOVE	AC2,AC		;SIMULATE
	TRZ	AC2,-1		;A
	TLNE	AC,400000	;HLLES
	TRO	AC2,-1		;INST
	HLLES	AC1,AC		;DO HLLES
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HLLES
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD= SIM. ANS
	EERRM	,RAN1
	LOOP	HLLES2,HLLES3

;TEST HRRE.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=11
HRRE1:	SETUP	200,2
HRRE2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRRE3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TLZ	AC1,-1		;A
	TRNE	AC2,400000	;HRRE
	TLO	AC1,-1		;INST
	HRRE	AC,RAN		;DO HRRE
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HRRE2,HRRE3

;TEST HRREI. CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=4
HRREI1:	SETUP	200,2
HRREI2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRREI3:	ROT	AC,11		;C(AC)=SECOND RANDOM NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TLZ	AC1,-1		;A
	TRNE	AC2,400000	;HRREI
	TLO	AC1,-1		;INST
	HRREI	AC,(AC2)	;DO HRREI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HRREI2,HRREI3

;TEST HRREM  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1

	AC=5
HRREM1:	SETUP	200,2
HRREM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRREM3:	ROT	AC,11		;C(E)=SECOND RAN NUMBER
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC1,RAN		;SIMULATE
	TLZ	AC1,-1		;A
	TRNE	AC2,400000	;HRREM
	TLO	AC1,-1		;INST
	HRREM	AC2,AC		;DO HRREM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HRREM2,HRREM3

;TEST HRRES.  CHECK C(E) FOR CORRECT DATA AND
;PROPER STORING OF C(E) INTO AC FOR RAN TO RAN CONDITION

	AC=6
HRRES1:	SETUP	200,2
HRRES2:	RANDOM
HRRES3:	SETOB	AC1,RAN1	;SET C(AC) TO -1
	MOVE	AC2,AC		;SIMULATE
	TLZ	AC2,-1		;A
	TRNE	AC,400000	;HRRES
	TLO	AC2,-1		;INST
	HRRES	AC1,AC		;DO HRRES
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HRRES
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD = SIM. ANS.
	EERRM	,RAN1
	LOOP	HRRES2,HRRES3

;TEST HRLZ.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=7
HRLZ1:	SETUP	200,1
HRLZ2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLZ3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVSI	AC1,(AC2)	;SIMULATE A HRLZ INST.
	HRLZ	AC,RAN		;DO HRLZ
	CAME	AC,AC1		;C(E) SHOULD=SIM.ANS
	ERR	AC2,RAN1
	LOOP	HRLZ2,HRLZ3

;TEST HRLZI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=10
HRLZI1:	SETUP	200,1
HRLZI2:	RANDOM
	MOVE	AC3,RAN		;SAVE RAN IN AN AC.
HRLZI3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVSI	AC1,(AC3)	;SIMULATE A HRLZI INST.
	HRLZI	AC,(AC3)	;DO HRLZI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC3)
	LOOP	HRLZI2,HRLZI3

;TEST HRLZM. CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN1

	AC=10
HRLZM1:	SETUP	200,1
HRLZM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLZM3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVSI	AC1,(AC2)	;SIMULATE A HRLZM INST.
	HRLZM	AC2,AC		;DO HRLZM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS.
	ERRM	RAN1,RAN
	LOOP	HRLZM2,HRLZM3

;TEST HRLZS.  CHECK C(E) FOR CORRECT DATA AND
;PROPER STORING OF C(E) INTO AC FOR RAN TO RAN CONDITION

	AC=2
HRLZS1:	SETUP	200,1
HRLZS2:	RANDOM
	MOVE	AC3,RAN		;SAVE RAN IN AN AC.
HRLZS3:	SETOB	AC1,RAN1	;SET C(AC) TO -1
	MOVSI	AC2,(AC3)	;SIMULATE A HRLZ INST.
	HRLZS	AC1,AC		;DO HRLZS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HRLZS
	ERRM	AC3,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM ANS
	ERRM	AC3,RAN1
	LOOP	HRLZS2,HRLZS3

;TEST HLRZ CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=3
HLRZ1:	SETUP	200,1
HLRZ2:	RANDOM
HLRZ3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIMULATE
	TLZ	AC1,-1		;A HLRZ INST.
	HLRZ	AC,RAN		;DO HLRZ
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	HLRZ2,HLRZ3

;TEST HLRZI.  CHECK C(AC) FOR 0
;RAN TO RAN1.

	AC=3
HLRZI1:	SETUP	200,1
HLRZI2:	RANDOM
	MOVE	AC1,RAN		;SAVE RAN IN AN AC.
HLRZI3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C (AC) IN CASE OF ERROR
	HLRZI	AC,(AC1)	;DO HLRZI.
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,(AC1)
	LOOP	HLRZI2,HLRZI3

;TEST HLRZM.  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1

	AC=3
HLRZM1:	SETUP	200,1
HLRZM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLRZM3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIMULATE
	TLZ	AC1,-1		;A HLRZ INST
	HLRZM	AC2,AC		;DO A HLRZM.
	CAME	AC1,AC		;C(E) SHOULD=SIM ANS
	ERRM	RAN1,RAN
	LOOP	HLRZM2,HLRZM3

;TEST HLRZS. CHECK C(E) FOR CORRECT DATA AND
;PROPER STORING C(E) INTO AC FOR RAN TO RAN CONDITION

	AC=4
HLRZS1:	SETUP	200,1
HLRZS2:	RANDOM
HLRZS3:	SETOB	AC1,RAN1	;SET C(AC) TO = -1
	MOVS	AC2,AC		;SIMULATE
	TLZ	AC2,-1		;A HLRZ
	HLRZS	AC1,AC		;DO HLRZS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HLRZS
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS.
	EERRM	,RAN1
	LOOP	HLRZS2,HLRZS3

;TEST HLRO CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=5
HLRO1:	SETUP	200,1
HLRO2:	RANDOM
HLRO3:	ROT	AC,11
	MOVE	RAN1,AC		;C(AC)=SECOND RAND. NUM
	MOVS	AC1,RAN		;SIMULAE
	TLO	AC1,-1		;A HLRO
	HLRO	AC,RAN		;DO HLRO
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	EERR	,RAN1
	LOOP	HLRO2,HLRO3

;TEST HLROI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=6
HLROI1:	SETUP	200,1
HLROI2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLROI3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVSI	AC1,-1		;SIMULATE A HLROI
	HLROI	AC,(AC2)	;DO HLROI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HLROI2,HLROI3

;TEST HLROM CHECK C(E) FOR CORRECT DATA.
;RAN TO RAN1

	AC=7
HLROM1:	SETUP	200,1
HLROM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLROM3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIMULATE
	TLO	AC1,-1		;A HLRO
	HLROM	AC2,AC		;DO HLROM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HLROM2,HLROM3

;TEST HLROS.  CHECK C(E) FOR CORRECT DATA AND
;PROPER STORING OF C(E) INTO AC FOR RAN TO RAN CONDITION

	AC=10
HLROS1:	SETUP	200,1
HLROS2:	RANDOM
HLROS3:	SETOB	AC1,RAN1	;SET C(AC) TO ALL ONES
	MOVS	AC2,AC		;SIMULATE
	TLO	AC2,-1		;A HLRO
	HLROS	AC1,AC		;DO HLROS
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HLROS.
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS
	EERRM	,RAN1
	LOOP	HLROS2,HLROS3

;TEST HRLE  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1.

	AC=11
HRLE1:	SETUP	200,4
HRLE2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLE3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIULATE
	TRZ	AC1,-1		;A
	TRNE	AC2,400000	;HRLE
	TRO	AC1,-1		;INST
	HRLE	AC,RAN		;NO HRLE
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HRLE2,HRLE3

;TEST HRLEI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=4
HRLEI1:	SETUP	200,4
HRLEI2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLEI3:	ROT	AC,11		;C(AC)=SECOND RAN NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIMULATE
	TRZ	AC1,-1		;A
	TRNE	AC2,400000	;HRLE
	TRO	AC1,-1		;INST
	HRLEI	AC,(AC2)	;DO HRLEI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC2)
	LOOP	HRLEI2,HRLEI3

;TEST HRLEM.  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1

	AC=5
HRLEM1:	SETUP	200,4
HRLEM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HRLEM3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIMULATE
	TRZ	AC1,-1		;A
	TRNE	AC2,400000	;HRLE
	TRO	AC1,-1		;INST
	HRLEM	AC2,AC		;DO HRLEM.
	CAME	AC1,AC		;C(AC) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HRLEM2,HRLEM3

;TEST HRLES.  CHECK C(E) FOR CORRECT DATA AND
;PROPER STORING OF C(E) INTO AC FOR RAN TO RAN CONDITION

	AC=6
HRLES1:	SETUP	200,4
HRLES2:	RANDOM
HRLES3:	SETOB	AC1,RAN1	;SET C(AC) TO ALL ONES.
	MOVS	AC2,AC		;SIMULATE
	TRZ	AC2,-1		;A
	TRNE	AC,400000	;HRLE
	TRO	AC2,-1		;INST
	HRLES	AC1,AC		;DO HRLES
	CAME	AC1,AC		;C(AC) HOULD=C(E) AFTER HRLES.
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM. ANS
	EERRM	,RAN1
	LOOP	HRLES2,HRLES3

;TEST HLRE CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=7
HLRE1:	SETUP	200,4
HLRE2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLRE3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIMULATE
	TLZ	AC1,-1		;A
	TLNE	AC2,400000	;HLRE
	TLO	AC1,-1		;INST
	HLRE	AC,RAN		;DO HLRE
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS
	ERR	AC2,RAN1
	LOOP	HLRE2,HLRE3

;TEST HLREI.  CHECK C(AC) FOR 0
;RAN TO RAN1

	AC=10
HLREI1:	SETUP	200,4
HLREI2:	RANDOM
	MOVE	AC1,RAN		;SAVE RAN IN AN AC.
HLREI3:	ROT	AC,1		;C(AC)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	HLREI	AC,(AC1)	;DO HLREI INST.
	CAME	AC,[0]		;C(AC) SHOULD = 0.
	ERRI	RAN1,(AC1)
	LOOP	HLREI2,HLREI3

;TEST HLREM.  CHECK C(E) FOR CORRECT DATA
;RAN TO RAN1

	AC=10
HLREM1:	SETUP	200,4
HLREM2:	RANDOM
	MOVE	AC2,RAN		;SAVE RAN IN AN AC.
HLREM3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVS	AC1,RAN		;SIMULATE
	TLZ	AC1,-1		;A
	TLNE	AC2,400000	;HLRE
	TLO	AC1,-1		;INST
	HLREM	AC2,AC		;DO HLREM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS
	ERRM	RAN1,RAN
	LOOP	HLREM2,HLREM3

;TEST HLRES.  CHECK C(E) FOR CORRECT DATA AND
;PROPER STORING OF C(E) INTO AC FOR RAN TO RAN CONDITION

	AC=2
HLRES1:	SETUP	200,4
HLRES2:	RANDOM
HLRES3:	SETOB	AC1,RAN1	;SET C(E) TO ALL ONES
	MOVS	AC2,AC		;SIMULATE
	TLZ	AC2,-1		;A
	TLNE	AC,400000	;HLRE
	TLO	AC2,-1		;INST
	HLRES	AC1,AC		;DO HLRES
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER HLRES
	EERRM	,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM ANS
	EERRM	,RAN1
	LOOP	HLRES2,HLRES3

DEFINE ADSBSM <
	MOVE	AC1,AC		;PUT SEC. NUM. INTO AC1.
	MOVE	AC3,AC1		;PUT SEC. NUM. INTO AC3 AND
	AND	AC3,AC2		;"AND" IT WITH 1ST NUM..PRODUCE CRY BIT.
	XOR	AC1,AC2		;PRODUCE SAME 1'S + 0'S AN ADD WOULD
				;PRODUCE, WITHOUT CARRY BITS.
	LSH	AC3,1		;SHIFT CRY BIT(S) TO LINE UP WITH NEXT BIT(S).
	MOVE	AC4,AC1		;SAVE FOR FUTURE "AND".
	TDCN	AC1,AC3		;A 0,1 CONDITION (NO FURTHUR CARRY)
	JRST	.+3		;WILL LEAVE WITH ANY CRY BIT(S) SET,
	AND	AC3,AC4		;OTHERWISE IT WILL COMP. THE CRY BIT(S) AND
	JRST	.-5		;PRODUCE OTHER CRY BIT(S). >

;TEST ADD.  CHECK FOR CORRECT DATA IN AC BY
;SIMULATING AN ADD, DOING AN ADD, AND COMPARING C(AC) WITH
;SIMULATED ANS.
;RAN TO RAN1.
	AC=3
ADDA1:	SETUP	200,2
ADDA2:	RANDOM
ADDA3:	MOVSS	RAN1,AC		;C(AC)=SECOND RAN. NUM.
	MOVE	AC2,RAN		;PUT 1ST NUM. INTO AC2.
;SIMULATE AN ADD INSTRUCTION.
	ADSBSM
	ADD	AC,RAN		;DO AN ADD.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	ADDA2,ADDA3
;TEST ADDM. CHECK FOR CORRECT DATA IN E BY
;SIMULATING AN ADDM, DOING AN ADDM, AND COMPARING C(E)
;WITH SIMULATED ANS.
;RAN TO RAN1.
	AC=2
ADDMA1:	SETUP	200,2
ADDMA2:	RANDOM
	MOVE	AC5,RAN		;SAVE RAN IN AN AC.
ADDMA3:	MOVSS	RAN1,AC		;C(E)=SECOND RAN NUM.
	MOVE	AC2,RAN		;PUT 1ST NUMBER INTO AC2
;SIMULATE AN ADD INSTRUCTION
	ADSBSM
	ADDM	AC5,AC		;DO AN ADDM.
	CAME	AC1,AC		;C(E) SHOULD=SIM. ANS.
	ERRM	RAN1,RAN
	LOOP	ADDMA2,ADDMA3

;TEST ADDI.  CHECK FOR CORRECT DATA IN AC BY
;SIMULATING AN ADDI, DOING AN ADDI, AND COMPARING
;C(AC) WITH SIMULATED ANS.
;RAN TO RAN1 CONDITION
	AC=3
ADDIA1:	SETUP	200,2
ADDIA2:	RANDOM
	MOVE	AC5,RAN		;SAVE RAN IN AN AC.
ADDIA3:	MOVSS	RAN1,AC		;C(AC)=SECOND RAN. NUM.
	MOVEI	AC2,(AC5)	;PUT 1ST NUM INTO AC2.
;SIMULATE ADDI INSTRUCTION
	ADSBSM
	ADDI	AC,(AC5)	;DO AN ADDI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS.
	ERRI	RAN1,(AC5)
	LOOP	ADDIA2,ADDIA3
;TEST ADDB. CHECK FOR C(E)=C(AC), AND CORRECT DATA IN AC
;BY SIMULATING AN ADD, DOING AN ADDB, AND COMPARING C(AC)
;WITH SIMULATED ANS.
;RAN TO RAN1 CONDITION.
	AC=4
ADDBA1:	SETUP	200,2
ADDBA2:	RANDOM
ADDBA3:	MOVSS	RAN1,AC		;C(AC)=SECOND RAN NUM.
	MOVE	AC5,RAN		;PUT 1ST NUM INTO C(E).
	MOVE	AC2,RAN		;PUT C(E) (1ST NUM.) INTO AC2.
;SIMULATE AN ADD INSTRUCTION
	ADSBSM
	ADDB	AC,AC5		;DO AN ADDB.
	CAME	AC,AC5		;C(AC) SHOULD=C(E)
	EERR	,RAN1
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	ADDBA2,ADDBA3

;TEST SUB. CHECK FOR CORRECT DATA IN AC BY
;SIMULATING A SUB, DOING A SUB, AND COMPARING C(AC)
;WITH THE SIMULATED ANSWER
;RAN TO RAN1
	AC=5
SUBA1:	SETUP	200,2
SUBA2:	RANDOM
SUBA3:	MOVSS	RAN1,AC		;C(AC)=SECOND RAN. NUM.
	MOVN	AC2,RAN		;PUT 2'S COMP OF 1ST NUM INTO AC2.
;SIMULATE A SUB INSTRUCTION
	ADSBSM
	SUB	AC,RAN		;DO A SUB.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS.
	EERR	,RAN1
	LOOP	SUBA2,SUBA3

;TEST SUBM. CHECK FOR CORRECT DATA IN E BY
;SIMULATING A SUBM, DOING A SUBM, AND COMPARING C(E)
;WITH THE SIMULATED ANSWER
;RAN TO RAN1.
	AC=6
SUBMA1:	SETUP	200,2
SUBMA2:	RANDOM
SUBMA3:	MOVSS	RAN1,AC		;C(AC)=SECOND RAN. NUM.
	MOVE	AC5,RAN		;C(E)=1ST RAN. NUM.
	MOVN	AC2,AC5		;PUT 1ST RAN. NUM INTO AC2
;SIMULATE A SUB INSTRUCTION
	ADSBSM
	SUBM	AC,AC5		;DO A SUBM.
	CAME	AC1,AC5		;C(E) SHOULD=SIM. ANS.
	EERRM	,RAN1
	LOOP	SUBMA2,SUBMA3

;TEST SUBI.  CHECK FOR CORRECT DATA IN AC BY
;SIMULATING A SUBI, DOING A SUBI, AND COMPARING
;C(AC) WITH THE SIMULATED ANSWER
;RAN TO RAN1
	AC=7
SUBIA1:	SETUP	200,2
SUBIA2:	RANDOM
	MOVE	AC5,RAN		;SAVE RAN IN AN AC.
SUBIA3:	MOVSS	RAN1,AC		;C(AC)=SECOND RAN. NUM.
	MOVNI	AC2,(AC5)	;PUT 2'S COMP OF 1ST RAN NUM INTO AC2.
;SIMULATE A SUB INSTRUCTION
	ADSBSM
	SUBI	AC,(AC5)	;DO A SUBI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM. ANS.
	ERRI	RAN1,(AC5)
	LOOP	SUBIA2,SUBIA3
;TEST SUBB.  CHECK FOR C(AC)=C(E), AND CORRECT DATA
;IN AC BY SIMULATING A SUB, DOING A SUBB, AND COMPARING
;C(AC) WITH SIMULATED ANSWER.
;RAN TO RAN1 CONDITION.
	AC=10
SUBBA1:	SETUP	200,2
SUBBA2:	RANDOM
SUBBA3:	MOVSS	RAN1,AC		;C(AC)=SECOND RAN. NUM.
	MOVE	AC5,RAN		;C(E)=1ST RAN. NUM.
	MOVN	AC2,AC5		;PUT 2'S COMP OF 1ST NUM. INTO C2
;SIMULATE A SUB INSTRUCTION
	ADSBSM
	SUBB	AC,AC5		;DO A SUBB.
	CAME	AC,AC5		;C(AC) SHOULD=C(E)
	EERR	,RAN1
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	EERR	,RAN1
	LOOP	SUBBA2,SUBBA3

;TEST AOBJP. CHECK FOR CORRECT DATA IN AC.
;C(AC) = RAN.

	AC=2
ABJP1:	SETUP	100,0
ABJP2:	RANDOM
ABJP3:	MOVE	AC1,AC		;SIMULATE
	ADD	AC1,[XWD 1,1]	;AN AOBJP INST.
	TRNN	AC1,777777	;IF CARRY ACROSS OCCURS
	SUB	AC1,[XWD 1,0]	;DELETE CARRY 18 TO 17 EFFECT
	AOBJP	AC,.+1		;DO AN AOBJP INST.
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	EERRI	,.-1
	LOOP	ABJP2,ABJP3


;TEST AOBJN. CHEC C(AC) FOR CORRECT DATA.
;C(AC) = RAN.

	AC=3
ABJN1:	SETUP	100,0
ABJN2:	RANDOM
ABJN3:	MOVE	AC1,AC		;SIMULATE
	ADD	AC1,[XWD 1,1]	;AN AOBJN.
	TRNN	AC1,777777	;IF CARRY ACROSS OCCURS
	SUB	AC1,[XWD 1,0]	;DELETE CARRY 18 TO 17 EFFECT
	AOBJN	AC,.+1		;DO AN AOBJN INST.
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	EERRI	,.-1
	LOOP	ABJN2,ABJN3


;TEST AOBJN, AOBJP. CHECK FOR JUMP/ NO JUMP AND
;CORRECT DAT IN AC.
;C(AC) = RAN.

	AC=2
ABJP1A:	SETUP	100,0
ABJP1B:	RANDOM
ABJP1C:	TDZ	AC,[XWD 400002,2];MAKE C(AC) SO AOBJP WILL ALWAYS JUMP.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC1,AC		;SIMULATE AN
	ADD	AC1,[XWD 2,2]	;AOBJP INST.
	AOBJN	AC,.+2		;C(AC) IS POS...NO JUMP.
	AOBJP	AC,.+2		;C(AC) IS POS...JUMP.
	ER	AC,[ASCII /AOBJP/]
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,.-1
	LOOP	ABJP1B,ABJP1C


;TEST AOBJP, AOBJN. CHECK FOR JUMP/ NO JUMP AND
;CORRECT DATA IN AC.
;C(AC) = RAN.

	AC=3
ABJN1A:	SETUP	100,0
ABJN1B:	RANDOM
ABJN1C:	TDZ	AC,[XWD 2,2]	;MAKE C(AC) SO
	TLO	AC,400000	;AOBJN WILL ALWAYS JUMP.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC1,AC		;SIMULATE AN
	ADD	AC1,[XWD 2,2]	;AOBJN INST.
	AOBJP	AC,.+2		;C(AC) IS NEG...NO JUMP.
	AOBJN	AC,.+2		;C(AC) IS NEG...JUMP.
	ER	AC,[ASCII /AOBJN/]
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,.-1
	LOOP	ABJN1B,ABJN1C


;TEST AOBJP. CHECK TO SEE THAT AOBJP STOPS JUMPING
;AT THE RIGHT TIME.
;C(AC) = (377677,377677) ON FIRST AOBJP.

	AC=4
ABJP2A:	SETUP	1,0
ABJP2B:	MOVE	AC,[XWD 377677,377677]
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	AOBJP	AC,.		;STAY HERE UNTIL C(AC) IS NEG.
	CAME	AC,[XWD 400000,400000];C(AC) SHOULD = THIS CONSTANT.
	ERROR	AC,[XWD 400000,400000]
	SOJG	AC-1,ABJP2B	;ITERATION COUNTER.
	JUMPL	AC-1,ABJP2B	;LOOP ON ERROR SWITCH.
;TEST AOBJN. CHECK TO SEE THAT AOBJN STOPS JUMPING
;AT THE RIGHT TIME.
;C(AC) = (777700,777700) ON FIRST AOBJN.

	AC=5
ABJN2A:	SETUP	1,0
ABJN2B:	MOVE	AC,[XWD -100,-100]
	AOBJN	AC,.		;STAY HERE UNTIL C(AC) IS POS.
	CAME	AC,[XWD 1,0]	;C(AC) SHOULD = THIS CONSTANT.
	ERROR	AC,[XWD 1,0]	;(WITH CARRY FROM RH TO LH)
	SOJG	AC-1,ABJN2B	;ITERATION COUNTER.
	JUMPL	AC-1,ABJN2B	;LOOP ON ERROR SWITCH.
;JFFO RELIABILITY TEST

YY=1
	AC=10
RAN1=15
JFOT0:	MOVEI	5,5
	MOVEM	5,ERRLOP
	MOVEI	0,1000
	MOVEM	0,JFCNTR#
JFOT0A:	RANDOM
	ROT	AC,1
	EQVB	AC,RAN1
JFOT1:	MOVE	2,RAN
	SETZB	3,4
	SKIPE	2
JFOT2:	TLNE	2,400000
	JRST	JFOT3
	ROT	2,1
	MOVEI	4,1
	AOJA	3,JFOT2
JFOT3:	MOVE	1,RAN
	MOVE	2,RAN1
	JFFO	1,@JFTAB(4)
	SKIPE	RAN
	ERM	1,YY		;C(AC) HAD A BIT SET SO PC SHOULD
	JUMPL	5,JFOT1	;HAVE GONE TO E.
	JRST	JFOND

JFOT4:	SKIPE	2		;C(AC+1) GET CLEARED?
	ERM	2,YY+1		;NO.
	JRST	JFOT6
JFOT5:	CAME	2,3		;C(AC+1) GET CORECT NUMBER OF LEADING ZERO BITS IN AC?
	ERM	2,YY+2		;NO.
JFOT6:	JUMPL	5,JFOT1
	JRST	JFOND
JFTAB:	XWD	0,JFOT4
	XWD	0,JFOT5

K1:	252525252525

JFOND:	SOSE	JFCNTR		;DECREMENT JFFO RAN NUM CNT.
	JRST	JFOT0A		;CONTINUE IF NON 0.



	JRST	BEGEND		;REPEAT TEST
   