;MAINDEC-10-SMPREB

MCNVER=0
DECVER=2

	XLIST
DEFINE	NAME	(MCNVER,DECVER),<

TITLE	SMPREB	DECSYSTEM 2020 DIAGNOSTICS PRE-BOOT PROGRAM, VER MCNVER,DECVER>
	LIST
	LALL

NAME	\MCNVER,\DECVER

;*JOHN R. KIRCHOFF

	NOSYM

INTERN	SMPREB		;LET EXTERNAL PROGRAM KNOW WHERE THIS IS
SMPREB:			;INTERNAL REFERENCE ADDRESS
INTERN	SMPEND		;INTERNAL REFERENCE END ADDRESS

PHASE	1000		;THE PRE-BOOT IS REALLY AT LOC 1000
SUBTTL	PARAMETERS

; ********************************************************************

; THIS PROGRAM IS THE PRE-BOOT FOR THE DIAGNOSTICS DISK LOADER AND
; FOR BOOTCHECK II.  THE PROGRAM PERFORMS A BASIC VERIFICATION OF THE
; KS-10 CPU BEFORE TRYING TO LOAD THE PRIMARY LOADER OR BOOTCHECK II
; CODE.

; THIS WILL ALSO GIVE A VERY PRESCRIBED SEQUENCE OF OPERATIONS TO BE
; DEBUGGED IF THIS CODE DOES NOT RUN TO COMPLETION.

;DEFINITIONS FOR SM10

BOORG=1000	;START OF HARDWARE BOOT

OPDEF	WRUBR	[701B8+3B12]	;WRITE USER BASE REGISTER
OPDEF	RDIO	[712B8]		;READ I/O
OPDEF	WRIO	[713B8]		;WRITE I/O

UBAP0=	763000	;ADDRESS OF UNIBUS MAP
UBSTAT=	763100	;ADDRESS OF UNIBUS STATUS

KPALIVE=31	;KEEP-ALIVE & STATUS WORD
MSRH=	36	;RH-11 BASE ADDRESS
MSDRIVE=37	;DRIVE NUMBER
MSSLAVE=40	;SLAVE & FORMAT

RIPST=21	;READ IN PRESET
RDATA=71	;READ DATA
RDY=200		;READY
MCPE=20000	;MASS I/O CONTROL BUS PARITY ERROR
TRE=40000	;TRANSFER ERROR
SC=100000	;SPECIAL CONDITION
FMT22=10000	;FORMAT 22 (FORMAT BIT)

RHCLR=	40	;CONTROLLER CLEAR

;REGISTER DEFINITIONS

RPCS1=	00	;CONTROL AND STATUS 1
RPWC=	02	;WORD COUNT REGISTER
RPBA=	04	;UNIBUS ADDRESS REGISTER
RPDA=	06	;DESIRED SECTOR/TRACK ADDRESS REGISTER
RPCS2=	10	;CONTROL AND STATUS 2
RPDS=	12	;DRIVE STATUS
RPER1=	14	;ERROR 1
RPER2=	40	;ERROR 2
RPER3=	42	;ERROR 3
RPOF=	32	;OFFSET REGISTER
RPDC=	34	;DESIRED CYLINDER REGISTER
RPFC=	6	;MAGTAPE FRAME COUNTER
RPTC=	32	;MAGTAPE TAPE CONTROL

UNV36X=100000	;UNIBUS 36 BIT TRANSFER BIT
UBVBIT==40000	;UNIBUS VALID BIT

;PRE-BOOT AC DEFINITIONS

T1=1		;TEMPS
T2=2
T3=3
T4=4
T5=5

P1=6

PBMADR=1
PBLIM=2
PBBITS=3
PBERR=4
SUBTTL	PRE-BOOT PROGRAM TO BE WRITTEN ON THE DISK

PBSTRT:!JRST	PBSTAR

PBHLT0:!HALT	.		;TRIED TO OVERLOAD PRE-BOOT
PBHLT1:!HALT	.		;DISK RETRY FAILURE
PBHLT2:!HALT	.		;NO RH-11 BASE ADDRESS
PBHLT3:!HALT	.		;RESERVED

PBPAGP:!123456,,PBPAG		;CODE,,POINTER TO DISK ADR & MEM ADR POINTERS
BC2RES:	0			;BC2 RESTART ADDRESS, 0 FOR DISK

;VERIFY ACCUMULATOR AC0

PBSTAR:!SETZM	0		;SET AC 0 TO ALL ZEROS
	SKIPE			;SHOULD CAUSE A SKIP
	HALT	.		;ERROR, DIDN'T SKIP
	SKIPN			;THIS SHOULD NOT SKIP
	SKIPA			;WHICH COMES HERE AND THEN SKIPS
	HALT	.		;ERROR, EITHER SKIPN OR SKIPA FAILED
	CAME	0,PBZERO
	HALT	.		;ERROR, DOES NOT COMPARE

	SETOM	0		;SET AC 0 TO ALL ONES
	SKIPN			;SHOULD CAUSE A SKIP
	HALT	.		;ERROR, DIDN'T SKIP
	SKIPE			;THIS SHOULD NOT SKIP
	JUMPN	0,.+2		;BUT THIS JUMP SHOULD JUMP
	HALT	.		;ERROR, EITHER SKIPE OR JUMPN FAILED
	JUMPG	0,.+2		;THIS SHOULD NOT JUMP
	JUMPL	0,.+2		;THIS ONE SHOULD JUMP
	HALT	.		;ERROR, EITHER JUMPG OR JUMPL FAILED
	CAME	0,PBMONE
	HALT	.		;ERROR, DOES NOT COMPARE

	SETCMM	0		;COMPLEMENT AC0
	JUMPE	0,.+2		;THIS JUMP SHOULD JUMP
	HALT	.		;ERROR, DATA WRONG OR JUMP DIDN'T JUMP
	CAME	0,PBZERO
	HALT	.		;ERROR, DOES NOT COMPARE

;VERIFY BASIC CPU OPERATION

	SETZ	0,		;CLEAR AC0
	ADDI	0,1		;ADD ONE
	CAIE	0,1		;DID IT ADD CORRECTLY ?
	HALT	.		;ERROR, CPU CAN'T ADD
	CAIN	0,1		;THIS COMPARE SHOULDN'T SKIP
	JUMPN	0,.+2		;BUT THIS JUMP SHOULD
	HALT	.		;ERROR, EITHER CAIN OR JUMPN FAILED
	JUMPL	0,.+2		;THIS SHOULD NOT JUMP
	JUMPG	0,.+2		;THIS ONE SHOULD JUMP
	HALT	.		;ERROR, EITHER JUMPL OR JUMPG FAILED

	ADDI	0,1		;ADD ONE AGAIN
	CAIE	0,2		;SHOULD NOW BE TWO
	HALT	.		;ERROR, CPU CAN'T ADD

	SUBI	0,2		;SUBTRACT TWO
	CAIE	0,0		;SHOULD NOW BE ZERO AGAIN
	HALT	.		;ERROR, CPU CAN'T SUBTRACT EITHER

	AOS	0		;ADD ONE A DIFFERENT WAY
	CAIE	0,1		;THIS SHOULD GIVE A ONE
	HALT	.		;ERROR, CPU STILL CAN'T ADD

	MOVSS	0,0		;SWAP AC0
	CAME	0,PBLONE	;DID IT SWAP CORRECTLY ?
	HALT	.		;NO, ERROR

	MOVNI	0,2000		;GENERATE A NEGATIVE NUMBER (BOOT WORD COUNT)
	CAME	0,PBNEG		;SHOULD GIVE A MINUS 2000
	HALT	.		;DIDN'T, ERROR

	SETZ	0,		;ZERO AC0
	IORI	0,140000	;OR IN SAME BITS AS UBVBIT AND UNV36X
	CAME	0,PBIOR		;ARE THE CORRECT BIT SET ?
	HALT	.		;NO, ERROR

	MOVEI	0,2		;START WITH A TWO
	SOJLE	0,.+2		;SUBTRACT ONE BUT SHOULD NOT JUMP
	SKIPA			;WHICH SHOULD COME HERE AND SKIP
	HALT	.		;ERROR, SOJLE MUST HAVE JUMPED
	CAIE	0,1		;DID SUBTRACT WORK ?
	HALT	.		;NO, ERROR
	SOJLE	0,.+2		;DO IT AGAIN, THIS SHOULD JUMP
	HALT	.		;DIDN'T, ERROR

;VERIFY BASIC ADDITION

	SETZ	0,		;CLEAR AC 0
	ADD	0,PBONES	;ADD A SET OF OCTAL ONES
	CAME	0,PBONES	;DID IT ADD CORRECTLY ?
	HALT	.		;ERROR, CPU CAN'T ADD

	ADD	0,PBONES	;ADD A SET OF OCTAL ONES AGAIN
	CAME	0,PBTWOS	;SHOULD GIVE A SET OF OCTAL TWOS
	HALT	.		;ERROR

	ADD	0,PBONES	;ADD AGAIN
	CAME	0,PBTHRE	;SHOULD GIVE A SET OF OCTAL THREES
	HALT	.		;ERROR

	ADD	0,PBONES	;ADD AGAIN
	CAME	0,PBFOUR	;SHOULD GIVE A SET OF OCTAL FOURS
	HALT	.		;ERROR

	ADD	0,PBONES	;ADD AGAIN
	CAME	0,PBFIVE	;SHOULD GIVE A SET OF OCTAL FIVES
	HALT	.		;ERROR

	ADD	0,PBONES	;ADD AGAIN
	CAME	0,PBSIX		;SHOULD GIVE A SET OF OCTAL SIXES
	HALT	.		;ERROR

	ADD	0,PBONES	;ADD AGAIN
	CAME	0,PBMONE	;SHOULD GIVE A SET OF OCTAL SEVENS
	HALT	.		;ERROR

	ADDI	0,1		;ADD JUST A ONE
	JUMPE	0,.+2		;COMPARE IT A DIFFERENT WAY
	HALT	.		;DIDN'T GIVE A FULL WORD OF ZEROS

;VERIFY AOBJN ADDITION AND JUMP TRANSFER

	AOBJN	0,.+2		;ADD 1 TO BOTH HALVES OF THE WORD
	CAME	0,PB11		;GIVE THE RIGHT ANSWER AND NO JUMP ?
	HALT	.		;NO, ERROR

	SETO	0,		;PRESET AC 0 TO -1
	AOBJN	0,.+2		;GIVE THE RIGHT ANSWER AND NO JUMP ?
	CAME	0,PBZERO
	HALT	.		;NO, ERROR

	MOVE	0,PBSIX		;VERIFY THAT AOBJN DOES JUMP
	AOBJN	0,.+2
	HALT	.		;ERROR, DIDN'T DO THE JUMP

;VERIFY ACCUMULATOR ADDRESSING

	MOVEI	0,0		;LOAD EACH AC WITH ITS OWN ADDRESS
	MOVEI	1,1
	MOVEI	2,2
	MOVEI	3,3
	MOVEI	4,4
	MOVEI	5,5
	MOVEI	6,6
	MOVEI	7,7
	MOVEI	10,10
	MOVEI	11,11
	MOVEI	12,12
	MOVEI	13,13
	MOVEI	14,14
	MOVEI	15,15
	MOVEI	16,16
	MOVEI	17,17

	CAIE	17,17		;VERIFY THAT EACH AC ADDRESSES CORRECTLY
	HALT	.		;ERROR
	CAIE	16,16
	HALT	.
	CAIE	15,15
	HALT	.
	CAIE	14,14
	HALT	.
	CAIE	13,13
	HALT	.
	CAIE	12,12
	HALT	.
	CAIE	11,11
	HALT	.
	CAIE	10,10
	HALT	.
	CAIE	7,7
	HALT	.
	CAIE	6,6
	HALT	.
	CAIE	5,5
	HALT	.
	CAIE	4,4
	HALT	.
	CAIE	3,3
	HALT	.
	CAIE	2,2
	HALT	.
	CAIE	1,1
	HALT	.
	CAIE	0,0
	HALT	.

;VERIFY ACCUMULATOR INDEXING

	CAME	1,(1)		;SHOULD COMPARE AC1 AGAINST CONTENTS OF AC1
	HALT	.		;ERROR
	CAME	2,(2)
	HALT	.
	CAME	3,(3)
	HALT	.
	CAME	4,(4)
	HALT	.
	CAME	5,(5)
	HALT	.
	CAME	6,(6)
	HALT	.
	CAME	7,(7)
	HALT	.
	CAME	10,(10)
	HALT	.
	CAME	11,(11)
	HALT	.
	CAME	12,(12)
	HALT	.
	CAME	13,(13)
	HALT	.
	CAME	14,(14)
	HALT	.
	CAME	15,(15)
	HALT	.
	CAME	16,(16)
	HALT	.
	CAME	17,(17)
	HALT	.

;VERIFY INDIRECT ADDRESSING

	MOVE	0,@17		;FETCH THE CONTENTS OF AC17
	CAIE	0,17		;SHOULD BE 17
	HALT	.		;WASN'T, ERROR

;VERIFY INDIRECT AND INDEXING

	MOVE	0,@4(3)		;SHOULD FETCH THE CONTENTS OF AC7
	CAIE	0,7		;CONTENTS OF 4 PLUS CONTENTS OF 3
	HALT	.		;DIDN'T, ERROR

;VERIFY ACCUMULATOR AC17

	SETZM	17		;SET ZEROS TO AC17
	CAME	17,PBZERO	;IS IT CORRECT ?
	HALT	.		;NO, COULD BE ABOUT ANYTHING

	SETOM	17		;SET ONES TO AC17
	CAME	17,PBMONE	;IS IT CORRECT ?
	HALT	.		;NO, COULD BE ABOUT ANYTHING

;VERIFY ACCUMULATOR DATA STORAGE

	MOVSI	17,-17
	CAME	17,PB17		;DID MOVE SWAPPED IMMEDIATE WORK ?
	HALT	.		;NO, ERROR

	SETOM	(17)		;SET ONES TO AC'S 0 TO 16
	AOBJN	17,.-1

	MOVSI	17,-17
	SETCMM	(17)		;COMPLEMENT AC, SHOULD THEN BE ZERO
	SKIPE	(17)
	HALT	.		;WASN'T, STILL COULD BE ABOUT ANYTHING
	AOBJN	17,.-3
	SETZM	17

;VERIFY SUBROUTINE CALLING

	JRSTF	@.+1		;CLEAR PROCESSOR FLAGS
		0,,.+1
	JSR	.+3		;TRANSFER TO SUBROUTINE
PBJSR:!	HALT	.		;DIDN'T TRANSFER

	JRST	.+7		;CONTINUE AFTER SUBROUTINE FROM HERE

	0			;SAVED PC STORAGE
	MOVE	0,.-1		;GET SAVED PC
	CAME	0,PBSPC		;DID CORRECT PC GET STORED ?
	HALT	.		;NO, ERROR
	AOS	PBJSR+2		;PLUS ONE TO PC TO SKIP HALT
	JRSTF	@PBJSR+2	;NOW CONTINUE BACK IN MAINLINE

;VERIFY BIT TESTS USED IN PRE-BOOT

	MOVEI	0,200		;SAME BIT AS DISK READY
	TRNN	0,200		;SHOULD SKIP
	HALT	.		;ERROR, DIDN'T
	TRNE	0,200		;SHOULD NOT SKIP
	JUMPA	.+2		;WHICH COMES HERE AND JUMPA SHOULD JUMP
	HALT	.		;EITHER TRNE OR JUMPA FAILED
	CAIE	0,200		;DO IMMEDIATE MODE COMPARE
	HALT	.		;ERROR, DOES NOT COMPARE

	MOVEI	0,40000		;SAME BIT AS TRE ERROR
	TRNN	0,40000		;SHOULD SKIP
	HALT	.		;ERROR, DIDN'T
	TRNE	0,40000		;SHOULD NOT SKIP
	JUMPA	.+2		;WHICH COMES HERE AND JUMPA SHOULD JUMP
	HALT	.		;EITHER TRNE OR JUMPA FAILED
	CAIE	0,40000		;DO IMMEDIATE MODE COMPARE
	HALT	.		;ERROR, DOES NOT COMPARE

;SAVE BOOT DISK PARAMETERS

	MOVE	0,MSRH		;GET DISK ADDRESS
	MOVEM	0,PBRHSV
	SKIPN	0
	JRST	PBHLT2		;NO RH-11 BASE ADDRESS ?
	HLLM	0,PBUBP0	;SETUP UBA MAP POINTER
	HLLM	0,PBUBST	;SETUP UBA STATUS POINTER

	MOVE	0,KPALIVE
	MOVEM	0,PBKPAL	;SAVE KEEP-ALIVE WORD

	MOVE	0,MSDRIVE
	MOVEM	0,PBDRSV	;SAVE DRIVE SELECTION

;VERIFY XOR INSTRUCTION

	SETZ	0,		;XOR 0 WITH 0
	XOR	0,0
	CAIE	0,0		;SHOULD GIVE ALL ZEROS
	HALT	.		;DIDN'T, ERROR

	SETO	0,		;XOR -1 WITH -1
	XOR	0,0
	CAIE	0,0		;SHOULD GIVE ALL ZEROS
	HALT	.		;DIDN'T, ERROR

	SETO	1,		;ALL ONES TO AC1
	XOR	0,1		;XOR 0 AND -1
	CAME	0,PBMONE	;SHOULD GIVE ALL ONES
	HALT	.		;DIDN'T, ERROR

	SETZ	1,		;ALL ZEROS TO AC1
	XOR	0,1		;XOR -1 AND 0
	CAME	0,PBMONE	;SHOULD GIVE ALL ONES
	HALT	.		;DIDN'T, ERROR

;VERIFY MEMORY FROM 20 TO 777

	MOVEI	PBMADR,20	;TEST MEMORY 20 TO 777 FOR ONES
	MOVEI	PBLIM,777
	SETOM	PBBITS
	JSR	PBTST1		;DO MEMORY TEST

	MOVEI	PBMADR,20	;TEST MEMORY 20 TO 777 FOR ADDRESS
	MOVEI	PBLIM,777
	JSR	PBTST2		;DO MEMORY TEST

	MOVEI	PBMADR,20	;TEST MEMORY 20 TO 777 FOR ZEROS
	MOVEI	PBLIM,777
	SETZM	PBBITS
	JSR	PBTST1		;DO MEMORY TEST

;VERIFY MEMORY FROM 2000 TO END OF 32K

	MOVEI	PBMADR,2000	;TEST MEMORY 2000 TO 77777 FOR ONES
	MOVEI	PBLIM,77777
	SETOM	PBBITS
	JSR	PBTST1		;DO MEMORY TEST

	MOVEI	PBMADR,2000	;TEST MEMORY 2000 TO 77777 FOR ADDRESS
	MOVEI	PBLIM,77777
	JSR	PBTST2		;DO MEMORY TEST

	MOVEI	PBMADR,2000	;TEST MEMORY 2000 TO 77777 FOR ZEROS
	MOVEI	PBLIM,77777
	SETZM	PBBITS
	JSR	PBTST1		;DO MEMORY TEST

	JRST	PBSTA1		;NOW GO LOAD FROM DISK

;MEMORY DATA SUBROUTINE

PBTST1:!	0
	MOVEM	PBBITS,(PBMADR)	;MOVE DATA TO MEMORY
	MOVE	PBERR,(PBMADR)	;READ DATA BACK FROM MEMORY
	XOR	PBERR,PBBITS	;XOR DATA, WILL BE ZERO IF NO ERROR
	JUMPE	PBERR,.+2
	HALT	.		;MEMORY DATA ERROR
	CAIGE	PBMADR,(PBLIM)	;COMPLETED MEMORY SECTION ?
	AOJA	PBMADR,PBTST1+1	;NO, CONTINUE TO NEXT ADDRESS
	JRSTF	@PBTST1		;YES, RETURN TO MAIN LINE

;MEMORY ADDRESS SUBROUTINE

PBTST2:!	0
	MOVE	PBBITS,PBMADR	;SETUP ADDRESS AS TEST DATA
	MOVEM	PBBITS,(PBMADR)	;MOVE DATA TO MEMORY
	MOVE	PBERR,(PBMADR)	;READ DATA BACK FROM MEMORY
	CAME	PBBITS,PBERR	;DATA WILL BE THE SAME IF NO ERROR
	HALT	.		;MEMORY DATA ERROR
	CAIGE	PBMADR,(PBLIM)	;COMPLETED MEMORY SECTION ?
	AOJA	PBMADR,PBTST2+1	;NO, CONTINUE TO NEXT ADDRESS
	JRSTF	@PBTST2		;YES, RETURN TO MAIN LINE

;NOW GO LOAD LOAD FROM THE DISK

PBSTA1:!MOVE	P1,PBRHSV

	MOVEI	T1,RHCLR
	WRIO	T1,RPCS2(P1)	;CLEAR CONTROLLER

	MOVE	T1,PBDRSV
	WRIO	T1,RPCS2(P1)	;SELECT DRIVE

	MOVEI	T1,RIPST	;DO READIN PRESET
	WRIO	T1,RPCS1(P1)	;WRITE REGISTER
	RDIO	T2,RPDS(P1)	;CHECK READY?
	TRNN	T2,RDY		;WAIT FOR READY
	JRST	.-2		;NO -- CONTINUE WAIT

	MOVEI	T3,PBPAG	;FIND THE OFFSET STUFF
	MOVEI	T5,^D10		;SET RETRY COUNT

;READ BOOT PAGES FROM THE DISK INTO MEMORY

PBREAD:!MOVE	T4,0(T3)	;FIND THE DISK ADDRESS
	JUMPL	T4,PBDONE	;QUIT IF ALL DONE WITH PAGES

	AOS	T3		;POINT TO BLOCK ENTRIES
	WRIO	T4,RPDA(P1)	;SET DISK ADDRESS
	MOVSS	T4		;FIND CYL ADDRESS
	WRIO	T4,RPDC(P1)	;SET CYL ADDRESS

	MOVNI	T4,2000		;READ A PAGE (WORD COUNT)
	WRIO	T4,RPWC(P1)	;SET WORD COUNT

	SETZ	T4,		;CLEAR CURRENT ADDRESS REGISTER
	WRIO	T4,RPBA(P1)	;SET UNIBUS ADDRESS TO 0

	MOVE	T4,0(T3)	;FIND THE CORE ADDRESS
	AOS	T3		;POINT TO NEXT ENTRY
	CAIN	T4,1		;CAN'T OVERLOAD PRE-BOOT
	JRST	PBBADR		;PAGE 1 REQUESTED TO BE LOADED ?

	IORI	T4,UBVBIT!UNV36X
	WRIO	T4,@PBUBP0	;SET UP UNIBUS ADAPTOR PAGE 0

	MOVEI	T4,RDATA	;SET GO
	WRIO	T4,RPCS1(P1)	;WAIT FOR GO
	RDIO	T4,RPCS1(P1)
	TRNN	T4,RDY
	JRST	.-2		;HO HUM WAIT

	TRNN	T4,TRE!MCPE	;CHECK ERROR CONDITION SUMMARY
	JRST	PBREAD		;DO NEXT PAGE

	SUBI	T3,2		;BACKUP TO SAME ENTRY
	SOJLE	T5,PBFAIL	;TRY AGAIN TILL RETRY RUNS OUT

;DISK ERROR RETRY

PBRTRY:!MOVEI	T1,RHCLR	;ERROR, CLEAR & TRY AGAIN
	WRIO	T1,RPCS2(P1)	;CLEAR CONTROLLER

	MOVE	T1,PBDRSV
	WRIO	T1,RPCS2(P1)	;SELECT DRIVE

	JRST	PBREAD		;TRY AGAIN

;PRE-BOOT ERROR, TRIED TO OVERLOAD PAGE 1

PBBADR:!MOVEI	17,PBHLT0	;SET HALT ADDRESS
	SUBI	T3,2		;POINT TO FAILING ENTRY
	JRST	.+2

;PRE-BOOT ERROR, DISK TRANSFER ERROR AND EXCEEDED RETRY LIMIT

PBFAIL:!MOVEI	17,PBHLT1	;SET HALT ADDRESS
	MOVE	(T3)
	MOVEM	100		;SAVE 8080 DISK ADDRESS
	MOVE	1(T3)
	MOVEM	101		;SAVE MEMORY PAGE ADDRESS

	MOVEM	T3,102		;SAVE SELECTION PICKUP POINTER

	RDIO	RPCS1(P1)
	MOVEM	103		;SAVE CONTROL AND STATUS 1
	RDIO	RPCS2(P1)
	MOVEM	104		;SAVE CONTROL AND STATUS 2
	RDIO	RPDS(P1)
	MOVEM	105		;SAVE DRIVE STATUS
	RDIO	RPER1(P1)
	MOVEM	106		;SAVE ERROR 1
	RDIO	RPER2(P1)
	MOVEM	107		;SAVE ERROR 2
	RDIO	RPER3(P1)
	MOVEM	110		;SAVE ERROR 3

	RDIO	@PBUBP0
	MOVEM	111		;SAVE UBA PAGING RAM LOC 0
	RDIO	@PBUBST
	MOVEM	112		;SAVE UBA STATUS REG

	MOVE	PBVER
	MOVEM	113		;SAVE PRE-BOOT VERSION

	MOVE	PBRHSV
	MOVEM	MSRH		;REINSTALL RH-11 BASE ADDRESS
	MOVE	PBDRSV
	MOVEM	MSDRIVE		;REINSTALL DRIVE NUMBER
	MOVE	PBKPAL
	MOVEM	KPALIVE		;REINSTALL KEEP-ALIVE

	JRST	@17		;HALT AT APPROPRIATE HALT

;CLEAR ALL ACCUMULATOR BLOCKS

PBDONE:!MOVE	1(T3)		;GET START ADDRESS
	MOVEM	20		;SAVE

	WRUBR	PBACB7
	JSR	PBWRAC		;CLEAR AC BLOCK 7

	WRUBR	PBACB6
	JSR	PBWRAC		;CLEAR AC BLOCK 6

	WRUBR	PBACB5
	JSR	PBWRAC		;CLEAR AC BLOCK 5

	WRUBR	PBACB4
	JSR	PBWRAC		;CLEAR AC BLOCK 4

	WRUBR	PBACB3
	JSR	PBWRAC		;CLEAR AC BLOCK 3

	WRUBR	PBACB2
	JSR	PBWRAC		;CLEAR AC BLOCK 2

	WRUBR	PBACB1
	JSR	PBWRAC		;CLEAR AC BLOCK 1

	WRUBR	PBACB0
	JSR	PBWRAC		;CLEAR AC BLOCK 0

;REINSTALL 8080 PARAMETERS

	MOVE	PBRHSV
	MOVEM	MSRH		;REINSTALL RH-11 BASE ADDRESS
	MOVE	PBDRSV
	MOVEM	MSDRIVE		;REINSTALL DRIVE NUMBER
	MOVE	PBKPAL
	MOVEM	KPALIVE		;REINSTALL KEEP-ALIVE

;NOW START CODE JUST READ IN

	SETZ
	JRST	@20		;NOW START BOOT

;AC BLOCK CLEAR SUBROUTINE

PBWRAC:!0
	MOVSI	17,-17
	SETZM	(17)		;ZERO AC'S
	AOBJN	17,.-1
	SETZM	17
	JRSTF	@PBWRAC

;PRE-BOOT PARAMETERS AND STORAGE

PBZERO:!0			;CONSTANT ZERO TEST WORD
PBMONE:!-1			;CONSTANT ONE TEST WORD
PBLONE:!1,,0			;CONSTANT LEFT HALF ONE
PBNEG:!	-2000			;CONSTANT MINUS 2000
PBIOR:!	0,,140000		;CONSTANT FOR IORI CHECK
PBONES:!111111,,111111		;CONSTANT ONES TEST WORD
PBTWOS:!222222,,222222		;CONSTANT TWOS TEST WORD
PBTHRE:!333333,,333333		;CONSTANT THREES TEST WORD
PBFOUR:!444444,,444444		;CONSTANT FOURS TEST WORD
PBFIVE:!555555,,555555		;CONSTANT FIVES TEST WORD
PBSIX:!	666666,,666666		;CONSTANT SIXES TEST WORD
PB11:!	1,,1			;CONSTANT ONE IN EACH HALF
PB17:!	-17,,0			;CONSTANT AC'S AOBJN POINTER
PBSPC:!	0,,PBJSR		;CONSTANT FOR SUBROUTINE TEST PC

PBACB7:!	1B0!7B8		;WRUBR ARGUMENTS
PBACB6:!	1B0!6B8
PBACB5:!	1B0!5B8
PBACB4:!	1B0!4B8
PBACB3:!	1B0!3B8
PBACB2:!	1B0!2B8
PBACB1:!	1B0!1B8
PBACB0:!	1B0!0B8

PBKPAL:!	0		;KEEP-ALIVE & STATUS WORD
PBRHSV:!	0		;RH-11 BASE ADDRESS
PBDRSV:!	0		;DRIVE NUMBER

PBVER:!	MCNVER,,DECVER		;PRE-BOOT VERSION

PBUBP0:!	1,,763000	;ADDRESS OF FIRST WINDOW
PBUBST:!	1,,763100	;ADDRESS OF UBA STATUS

SMPBPG:
PBPAG:!		0		;DISK ADDRESS AND MEMORY ADDRESS POINTERS
PBPAGX:!	BLOCK	114	;STORAGE BLOCK
	DEPHASE
SMPEND:	0			;ENDING REFERENCE ADDRESS
	END
   