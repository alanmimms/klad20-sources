	SUBTTL	DATA PATH TEST - PART 1

DEFTST	MCODE4
	TEST	197,TEST MICROBUS PARITY CHECKING NETWORK
;*WRITE SELECTED PATTERNS TO REG 4 TO VERIFY THE PROPER OPERATION
;*OF THE MICROBUS PARITY CHECKING NETWORK.

;*WRITE REG 0 TO CLEAR FLAGS
;*WRITE PATTERN TO REG 4
;*CHECK THAT "UB PE FLAG" DID NOT SET

	LDMAR	0			;CLEAR MAR
	LDMEM	1			;SET ADDITIONAL PRINT ROUTINE NUM
	GOSUB	SETPNT
	LDBR	6			;SET LOOP COUNT MINUS ONE
	MOVB	AC1
	LDMAR	UBPAR			;SET MAR TO FIRST DATA PATTERN
PARLP:	MOVB	REG0			;WRITE REG 0 TO CLEAR "UB PE FLAG"
	MOVMEM	MCLO			;WRITE PATTERN
	GOSUB	SETDAT			;SETUP DATA FOR ADD PNT ROUTINE
	DATI	REG0,BR			;READ REG 0 FOR "UB PE FLAG"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	PARLP,"UB PE FLAG" SET WHEN GOOD PARITY WAS WRITTEN TO REG 4,,PNT
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	PARLP			;ELSE,CONTINUE

	REPEAT	TST
	TEST	198,TEST REGISTER 1
;*TEST WRITING AND READING REGISTER 1.
;*BITS 7-4 ARE READ ONLY BITS WHICH ARE NORMALLY ZERO.

;*WRITE ZEROS TO BITS 3-0.
;*CHECK THAT BITS 3-0 READ BACK AS ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZEROS BITS 3-0
	MOVMEM	REG1
	DATI	REG1,AC0		;READ REG 1
	LDBR	17			;SET MASK OF TEST BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;CHECK FOR ALL ZEROS
	JMPZ	.+2			;JUMP IF ITS ZERO
	ERRORM	TST,CAN NOT WRITE ZEROS TO BITS 3-0 OF REG 1

;*WRITE ONES TO BITS 3-0.
;*CHECK THAT BITS 3-0 READ BACK AS ONES.

REG1A:	LDMEM	17			;WRITE ONES TO BITS 3-0
	MOVMEM	REG1
	DATI	REG1,AC0		;READ REG 1
	LANDMR	AC0			;ISOLATE TEST BITS IN AC0
	OSM	AC0			;CHECK FOR BITS 0,1=1'S
	JMPZ	.+2			;JUMP IF ONES
	ERRORM	REG1A,CAN NOT WRITE ONES TO BITS 3-0 OF REG 1
;*DO A MICROBUS INIT.
;*CHECK THAT BITS 3-0 ARE CLEARED.

	GOSUB	INITL			;DO A MICROBUS INIT
	DATI	REG1,AC0		;READ REG 1
	LDBR	17			;SET MASK OF TEST BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF REG 1 CLEARED.
	ERRORM	REG1A,CAN NOT CLEAR BITS 3-0 IN REG 1,
DIAG DID A MICROBUS INIT
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO BITS 3-0 OF REG 1.
;*READ BACK REG 1 FOR THE WRITTEN PATTERN.

	LDBR	7			;SETUP LOOP COUNT
	MOVB	AC1
	LDMAR	FLTZ1			;SET MAR TO FIRST DATA PATTERN
FLT1:	MOVMEM	REG1			;WRITE PATTERN INTO REG 1
	DATI	REG1,AC0		;READ DATA BACK
	LDBR	17			;SET MASK OF TEST BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;COMPARE ACTUAL TO CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT1,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 1
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	FLT1			;ELSE, CONTINUE

	REPEAT	TST
	TEST	199,TEST REGISTER 2
;*TEST WRITING AND READING REGISTER 2.
;*BITS 7 AND 6 ARE READ ONLY.

;*WRITE ZEROS TO BITS 5-0 OF REG 2.
;*CHECK THAT THEY READ BACK AS ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZERO TO REG 2
	MOVMEM	REG2
	DATI	REG2,AC0		;READ REG 2
	LDBR	77			;SET MASK OF WRITEABLE BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERRORM	TST,CANNOT WRITE ALL ZEROS TO BITS 5-0 REG 2
;*WRITE ONES TO BITS 5-0 OF REG 2.
;*CHECK THAT THEY READ BACK AS ONES.

REG2A:	LDMEM	77			;WRITE ONES TO REG2
	MOVMEM	REG2
	DATI	REG2,AC0		;READ REG 2
	LANDMR	AC0			;ISOLATE WRITEABLE BITS IN AC0
	OSM	AC0			;CHECK FOR BITS 6-0=1'S
	JMPZ	.+2			;JUMP IF ALL 1'S
	ERRORM	REG2A,CANNOT WRITE ALL ONES TO BITS 5-0 REG 2
;*DO A MICROBUS INIT.
;*CHECK THAT BITS 5-0 ARE CLEARED.

	GOSUB	INITL			;DO A MICROBUS INIT
	DATI	REG2,AC0		;READ REG 2
	LDBR	77			;SET MASK OF CLEARABLE BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;CHECK IF THEY CLEARED
	JMPZ	.+2			;JUMP IF THEY DID
	ERRORM	REG2A,CANNOT CLEAR BITS 5-0 OF REG 2,
DIAG DID A MICROBUS INIT
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO BITS 5-0 OF REG 2.
;*READ BACK REG 2 FOR THE WRITTEN PATTERN.

	LDBR	^D11			;SETUP LOOP COUNT
	MOVB	AC1
	LDMAR	FLTZ2			;SET MAR TO FIRST DATA PATTERN
FLT2:	MOVMEM	REG2			;WRITE PATTERN TO REG2
	DATI	REG2,AC0		;READ BACK REG2
	LDBR	77			;SET MASK OF WRITEABLE BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT2,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 2
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR.
	JMPZ	.+2			;JUMP IF DONE
	JMP	FLT2			;ELSE, CONTINUE

	REPEAT	TST
	TEST	200,TEST REGISTER 4 (MCLO)
;*TEST WRITING AND READING REGISTER 4.

;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZEROS TO REG 4
	MOVMEM	MCLO
	DATI	MCLO,AC0		;READ REG 4
	OSM	AC0			;CHECK IF ITS ALL ZEROS
	JMPZ	.+2			;JUMP IF ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO REG 4
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ONES.

REG4A:	LDMEM	-1			;WRITE ONES TO REG 4
	MOVMEM	MCLO
	DATI	MCLO,AC0		;READ REG 4
	OSM	AC0			;CHECK FOR ALL ONES
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG4A,CAN NOT WRITE ALL ONES TO REG 4
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*READ IT BACK FOR THE WRITTEN PATTERN.

	LDBR	^D15			;SET LOOP COUNT MINUS ONE
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR TO FIRST PATTERN
FLT4:	MOVMEM	MCLO			;WRITE PATTERN TO REG 4
	DATI	MCLO,AC0		;READ REG 4
	OSM	AC0			;COMPARE TO EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT4,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 4
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	FLT4			;ELSE, CONTINUE

	REPEAT	TST
	TEST	201,TEST REGISTER 5 (MCHI)
;*TEST WRITING AND READING REGISTER 5.

;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZEROS TO REG 5
	MOVMEM	MCHI
	DATI	MCHI,AC0		;READ REG 5
	OSM	AC0			;CHECK IF ITS ALL ZEROS
	JMPZ	.+2			;JUMP IF ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO REG 5
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ONES.

REG5A:	LDMEM	-1			;WRITE ONES TO REG 5
	MOVMEM	MCHI
	DATI	MCHI,AC0		;READ REG 5
	OSM	AC0			;CHECK FOR ALL ONES
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG5A,CAN NOT WRITE ALL ONES TO REG 5
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*READ IT BACK FOR THE WRITTEN PATTERN.

	LDBR	^D15			;SET LOOP COUNT MINUS ONE
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR TO FIRST PATTERN
FLT5:	MOVMEM	MCHI			;WRITE PATTERN TO REG 5
	DATI	MCHI,AC0		;READ REG 5
	OSM	AC0			;COMPARE TO EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT5,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 5
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	FLT5			;ELSE, CONTINUE

	REPEAT	TST
	TEST	202,TEST REGISTER 6 (BCLO)
;*TEST WRITING AND READING REGISTER 6.

;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZEROS TO REG 6
	MOVMEM	BCLO
	DATI	BCLO,AC0		;READ REG 6
	OSM	AC0			;CHECK IF ITS ALL ZEROS
	JMPZ	.+2			;JUMP IF ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO REG 6
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ONES.

REG6A:	LDMEM	-1			;WRITE ONES TO REG 6
	MOVMEM	BCLO
	DATI	BCLO,AC0		;READ REG 6
	OSM	AC0			;CHECK FOR ALL ONES
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG6A,CAN NOT WRITE ALL ONES TO REG 6
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*READ IT BACK FOR THE WRITTEN PATTERN.

	LDBR	^D15			;SET LOOP COUNT MINUS ONE
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR TO FIRST PATTERN
FLT6:	MOVMEM	BCLO			;WRITE PATTERN TO REG 6
	DATI	BCLO,AC0		;READ REG 6
	OSM	AC0			;COMPARE TO EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT6,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 6
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	FLT6			;ELSE, CONTINUE

	REPEAT	TST
	TEST	203,TEST REGISTER 7 (BCHI)
;*TEST WRITING AND READING REGISTER 7.

;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZEROS TO REG 7
	MOVMEM	BCHI
	DATI	BCHI,AC0		;READ REG 7
	OSM	AC0			;CHECK IF ITS ALL ZEROS
	JMPZ	.+2			;JUMP IF ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO REG 7
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ONES.

REG7A:	LDMEM	-1			;WRITE ONES TO REG 7
	MOVMEM	BCHI
	DATI	BCHI,AC0		;READ REG 7
	OSM	AC0			;CHECK FOR ALL ONES
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG7A,CAN NOT WRITE ALL ONES TO REG 7
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*READ IT BACK FOR THE WRITTEN PATTERN.

	LDBR	^D15			;SET LOOP COUNT MINUS ONE
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR TO FIRST PATTERN
FLT7:	MOVMEM	BCHI			;WRITE PATTERN TO REG 7
	DATI	BCHI,AC0		;READ REG 7
	OSM	AC0			;COMPARE TO EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT7,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 7
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	FLT7			;ELSE, CONTINUE

	REPEAT	TST
	TEST	204,TEST UNUSED READ ONLY BITS
;*CHECK THAT ALL UNUSED READ-ONLY BITS ARE READ AS ZEROS.
;*THE BITS ARE:
;*	7-4	IN REG 0
;*	7-4,0	IN REG 3
;*	7	IN REG 15
;*	7	IN REG 16
;*	7,6	IN REG 17

	DATI	REG0,AC0		;READ REG 0
	LDBR	17			;SET MASK OF NON ZERO BITS
	LANDB	AC0,MEM			;ZERO UNUSED BITS IN CORRECT DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF UNUSED BITS ALL ZERO
	ERROR	TST,BITS 7-4 IN REG 0 ARE NOT ALL ZEROS
UNUSE1:	DATI	REG3,AC0		;READ REG 3
	LDBR	16			;SET MASK OF NON ZERO BITS
	LANDB	AC0,MEM			;ZERO UNUSED BITS IN CORRECT DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF UNUSED BITS ALL ZERO
	ERROR	UNUSE1,BITS 7-4 AND 0 IN REG 3 ARE NOT ALL ZEROS
UNUSE2:	DATI	REG15,AC0		;READ REG 15
	LDBR	177			;SET MASK OF NON ZERO BITS
	LANDB	AC0,MEM			;ZERO UNUSED BITS IN CORRECT DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF UNUSED BITS ALL ZERO
	ERROR	UNUSE2,BIT 7 IN REG 15 IS NOT ZERO
UNUSE3:	DATI	REG16,AC0		;READ REG 16
	LDBR	177			;SET MASK OF NON ZERO BITS
	LANDB	AC0,MEM			;ZERO UNUSED BITS IN CORRECT DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF UNUSED BITS ALL ZERO
	ERROR	UNUSE3,BIT 7 IN REG 16 IS NOT ZERO
UNUSE4:	DATI	REG17,AC0		;READ REG 17
	LDBR	77			;SET MASK OF NON ZERO BITS
	LANDB	AC0,MEM			;ZERO UNUSED BITS IN CORRECT DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF UNUSED BITS ALL ZERO
	ERROR	UNUSE4,BITS 7 AND 6 IN REG 17 ARE NOT ALL ZEROS
	REPEAT	TST
	TEST	205,TEST SETTING AND CLEARING OF "CLR RUN"
;*TEST THAT THE "CLR RUN" FLOP CAN BE DIRECTLY SET AND CLEARED AND THAT
;*IT CAN BE SET AND CLEARED USING THE CLOCKED INPUTS.

;*CLEAR "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*DO A HS DP INIT.
;*CHECK THAT "CLR RUN" IS SET.

	LDBR	0			;CLEAR "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	REG1
	MOVB	HSDPIN			;DO A HS DP INIT
	LDBR	373			;SET MASK OF ALL BUT "NOT CLR RUN" BIT
	MOVB	AC0			;MOVE MASK TO AC0
	DATI	REG16,BR		;READ REG 16
	LORCB	AC0			;IF BIT IS CLEARED, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF CLEARED (CLR RUN = 1)
	ERROR	TST,"CLR RUN" DID NOT SET AFTER A HS DP INIT
;*GENERATE A "SET RUN" PULSE.
;*CHECK THAT "CLR RUN" IS CLEARED.

CLRUN1:	MOVB	SETRUN			;GENERATE A "SET RUN" PULSE
	DATI	REG16,BR		;READ REG 16
	SHR				;RIGHT ADJUST "NOT CLR RUN" BIT
	SHR
	JMPB0	.+2			;JUMP IF SET (CLR RUN=0)
	ERROR	TST,"CLR RUN" DID NOT CLEAR AFTER A "SET RUN"
;*DO A HS DP INIT.
;*CHECK THAT "CLR RUN" IS SET.

CLRUN2:	MOVB	HSDPIN			;DO A HS DP INIT
	LDBR	373			;SET MASK OF ALL BUT "NOT CLR RUN" BIT
	MOVB	AC0			;MOVE MASK TO AC0
	DATI	REG16,BR		;READ REG 16
	LORCB	AC0			;IF BIT IS CLEARED, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF CLEARED (CLR RUN = 1)
	ERROR	CLRUN1,"CLR RUN" DID NOT SET AFTER A HS DP INIT
;*SET "DX HIGH SPEED" AND GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "CLR RUN" IS CLEARED.

	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG16,BR		;READ REG 16
	SHR				;RIGHT ADJUST "NOT CLR RUN" BIT
	SHR
	JMPB0	.+2			;JUMP IF SET (CLR RUN = 0)
	ERROR	CLRUN2,"CLR RUN" DID NOT CLEAR,
<DIAG SET "DX HIGH SPEED" AND "CLR RUN"
THEN GENERATED A SINGLE STEP PULSE>
;*CLEAR "DX HIGH SPEED" AND GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "CLR RUN" IS SET.

CLRUN3:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	MOVB	SETRUN			;GENERATE A "SET RUN" PULSE
	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	LDBR	373			;SET MASK OF ALL BUT "NOT CLR RUN" BIT
	MOVB	AC0			;MOVE MASK TO AC0
	DATI	REG16,BR		;READ REG 16
	LORCB	AC0			;IF BIT IS CLEARED, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF CLEARED (CLR RUN = 1)
	ERROR	CLRUN3,"CLR RUN" DID NOT SET,
<DIAG CLEARED "CLR RUN" AND "DX HIGH SPEED"
THEN GENERATED A SINGLE STEP PULSE>
	REPEAT	TST
	TEST	206,TEST SETTING AND CLEARING OF "RUN"
;*TEST THE DIRECT SETTING AND CLEARING OF "RUN" USING THE "SET RUN"
;*AND "CLR RUN" PULSES, RESPECTIVELY.

;*ENABLE SINGLE STEPPING TO STOP THE BASE CLOCK.
;*GENERATE A "SET RUN" PULSE.
;*CHECK THAT "RUN" IS SET.

	MOVB	SETRUN			;GENERATE A "SET RUN" PULSE
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;MOVE "NOT RUN" BIT INTO BIT 4
	JMPB4	.+2			;JUMP IF SET (RUN = 0)
	JMP	.+2			;JUMP IF CLEAR (RUN = 1)
	ERROR	TST,"RUN" DID NOT SET AFTER A "SET RUN" PULSE
;*DO A HS DP INIT.
;*CHECK THAT "RUN" IS CLEARED.

RUN1:	MOVB	HSDPIN			;GENERATE "CLR RUN"
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;MOVE "NOT RUN" BIT INTO BIT 4
	JMPB4	.+2			;JUMP IF SET (RUN = 0)
	ERROR	TST,"RUN" DID NOT CLEAR AFTER A HS DP INIT
;*GENERATE A "SET RUN" PULSE.
;*CHECK THAT "RUN" IS SET.

	MOVB	SETRUN			;GENERATE A "SET RUN" PULSE
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;MOVE "NOT RUN" BIT INTO BIT 4
	JMPB4	.+2			;JUMP IF SET (RUN = 0)
	JMP	.+2			;JUMP IF CLEAR (RUN = 1)
	ERROR	RUN1,"RUN" DID NOT SET AFTER A "SET RUN" PULSE
	REPEAT	TST
	TEST	207,TEST DF CLOCK PHASES
;*VERIFY THAT THE DF CLOCK PHASES CYCLE CORRECTLY (USING SINGLE
;*STEP MODE).  ALSO CHECK THAT CLEARING "RUN" STOPS THE CLOCK WITH
;*CLK PH 0 = 0, CLK PH 1 = 0.

;*ENABLE BASE CLOCK AND CLEAR "DX HIGH SPEED" TO CLEAR "RUN".
;*CHECK THAT THE CLOCK PHASES ARE CLEARED.

	LDMAR	0			;RESET MAR TO ZERO
	LDBR	BCLKEN			;ENABLE THE BASE CLOCK
	MOVB	REG1
	DATI	REG16,AC0		;READ REG 16
	LDBR	DFCPH1+DFCPH0		;SET MASK OF DF CLK PHASE BITS
	LANDBR	AC0			;ISOLATE PHASE BITS
	LDMEM	0			;SET EXPECTED STATES
	OSM	AC0			;COMPARE ACTUAL WITH EXPECTED
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	TST,DF CLOCK PHASES DID NOT BOTH CLEAR,
<DIAG ENABLED BASE CLOCK AND CLEARED "DX HIGH SPEED".
CORRECT AND ACTUAL ARE REG 16 WITH PHASE BITS MASKED>
;*ENABLE SINGLE STEPPING AND SET "RUN".
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT CLOCK PHASES ADVANCE CORRECTLY.

	LDMAR	CLKPHF			;SET MAR TO FIRST EXPECTED PHASE STATE
	LDBR	0			;ENABLE SINGLE STEP MODE
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG16,AC0		;READ REG 16
	LDBR	DFCPH1+DFCPH0		;SET MASK OF DF CLK PHASE BITS
	LANDBR	AC0			;ISOLATE THE PHASE BITS
	OSM	AC0,I			;CHECK CLK PHASE STATES
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	TST,CLOCK PHASES DID NOT ADVANCE CORRECTLY,
<DIAG CLEARED CLOCK AND SET "RUN" THEN GENERATED A SINGLE STEP PULSE.
CORRECT AND ACTUAL ARE REG 16 WITH PHASE BITS MASKED>
;*DO A HS DP INIT TO CLEAR "RUN".
;*GENERATE 3 SINGLE STEP PULSES.
;*CHECK THAT CLOCK PHASES ADVANCE CORRECTLY AFTER EACH PULSE.

	MOVB	HSDPIN			;CLEAR "RUN"
	LDBR	2			;SET LOOP COUNT MINUS 1
	MOVB	AC1
CLKLP1:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG16,AC0		;READ REG 16
	LDBR	DFCPH1+DFCPH0		;SET MASK OF DF CLK PHASE BITS
	LANDBR	AC0			;ISOLATE THE PHASE BITS
	OSM	AC0			;CHECK CLK PHASE STATES
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	TST,CLOCK PHASES DID NOT ADVANCE CORRECTLY,
<DIAG CLEARED CLOCK AND SET "RUN" THEN GENERATED SINGLE STEP PULSES.
CORRECT AND ACTUAL ARE REG 16 WITH PHASE BITS MASKED>
	DECR	AC1,I			;DEC LOOP COUNT AND INC STATUS ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	CLKLP1			;ELSE, CONTINUE

;*SET "RUN" AND GENERATE A "LOAD ROM DATA" PULSE.
;*CHECK THAT "CLK PH 0" IS SET.

	MOVB	SETRUN			;SET "RUN"
DFCLK1:	MOVB	LDRMDA			;GEN LOAD ROM DATA PULSE (SETS CLK PH 0)
	DATI	REG16,BR		;READ REG 16 FOR "CLK PH 0"
	JMPB4	.+2			;JUMP IF IT SET CORRECTLY
	ERROR	DFCLK1,"CLK PH 0" DID NOT SET AFTER A "LD ROM DATA" PULSE
	REPEAT	TST
	TEST	208,TEST REGISTER 10 (DFRMAD)
;*TEST WRITING AND READING REGISTER 10.

;*CLEAR "DX HIGH SPEED" AND ENABLE BASE CLOCK TO CLEAR "CLK PH 0".
;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDBR	BCLKEN			;CLEAR "DX HIGH SPEED" AND ENABLE BASE CLK
	MOVB	REG1
	LDMEM	0			;SETUP DATA
	MOVMEM	DFRMAD			;WRITE ZEROS TO REG 10
	DATI	DFRMAD,AC0		;READ REG 10
	OSM	AC0			;CHECK IF ITS ALL ZEROS
	JMPZ	.+2			;JUMP IF ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO REG 10
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ONES.

REG10A:	LDMEM	-1			;WRITE ONES TO REG 10
	MOVMEM	DFRMAD
	DATI	DFRMAD,AC0		;READ REG 10
	OSM	AC0			;CHECK FOR ALL ONES
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG10A,CAN NOT WRITE ALL ONES TO REG 10
;*DO A MICROBUS INIT.
;*CHECK THAT ALL BITS GET CLEARED.

	GOSUB	INITL			;GO DO A MICROBUS INIT
	DATI	DFRMAD,AC0		;READ REG 10
	OSM	AC0			;CHECK IF IT CLEARED
	JMPZ	.+2			;JUMP IF IT DID
	ERRORM	REG10A,CAN NOT CLEAR REG 10 WITH A MICROBUS INIT
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*READ IT BACK FOR THE WRITTEN PATTERN.

	LDBR	^D15			;SET LOOP COUNT MINUS ONE
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR TO FIRST PATTERN
FLT10:	MOVMEM	DFRMAD			;WRITE PATTERN TO REG 10
	DATI	DFRMAD,AC0		;READ REG 10
	OSM	AC0			;COMPARE TO EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT10,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 10
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	FLT10			;ELSE, CONTINUE

	REPEAT	TST
	TEST	209,TEST CONTENTS OF DF ROM
;*VERIFY THAT EACH ROM LOCATION CONTAINS THE CORRECT DATA.

;*CLEAR CLOCK PHASES.
;*CLEAR "DX HIGH SPEED".
;*LOAD THE ROM ADDRESS.
;*GENERATE A "LOAD ROM DATA" PULSE TO LATCH ROM DATA 15-0.
;*SET "DX HIGH SPEED".
;*LOAD ROM ADDRESS AGAIN TO CLOCK ROM DATA 19-16 INTO ADDRESS BITS 3-0.
;*CHECK THAT BITS 19-0 OF ROM DATA ARE CORRECT.

	LDMAR	0			;CLEAR MAR
	LDMARX	0			;CLEAR MAR EXT BITS
	LDMEM	2			;SETUP ADD PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDBR	BCLKEN			;ENABLE BASE CLK AND CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	0			;SET FIRST ROM ADDR =0
	MOVB	AC1
	MOVB	AC3			;SET MAR EXT BITS COUNTER TO 0
	MOVB	REG2			;CLEAR ROM ADDR BIT 8
	LDBR	ROMDAT			;SETUP ADDR OF ROM DATA TABLE
	MOVB	AC2
ROMLP:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	MOV	AC1,BR			;PUT ROM ADDR INTO BR
	MOVB	DFRMAD			;SET BITS 7-0 OF ADDR
	MOVB	LDRMDA			;CLOCK ROM DATA 15-0 INTO FLOPS
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOV	AC1,BR			;PUT ROM ADDR INTO BR AGAIN
	MOVB	DFRMAD			;GEN A LOAD ROM ADDR PULSE, CLOCKS
					;DATA BITS 19-16 INTO 3-0 OF ADDR
	DATI	REG2,AC5		;READ ROM ADDR BIT 8
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	RMADR8			;SET MASK FOR ADDR BIT 8
	LANDB	AC5,BR			;ISOLATE IT
	MOVB	MPGP5			;STORE IT FOR PRINTOUT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	DATI	RMDALO,AC0		;READ BITS 7-0 OF ROM LOC
	DATI	RMDAHI,AC5		;READ BITS 15-8 OF ROM LOC
	DATI	DFRMAD,AC4		;READ BITS 19-16 OF ROM LOC AS
	LDBR	17			;BITS 3-0 OF ROM ADDR
	LANDBR	AC4
	GOSUB	STRDAT			;GO SETUP CORRECT AND ACTUAL DATA
	MOV	AC2,MAR			;SET MAR TO ROM DATA TABLE ENTRY
	MOV	AC3,MARX		;SET MAR EXT BITS
	OSM	AC0,I			;COMPARE BITS 7-0 WITH EXPECTED
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	ROMERR			;ELSE, REPORT ERROR
	OSM	AC5,I			;COMPARE BITS 15-8 WITH EXPECTED
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	ROMERR			;ELSE, REPORT ERROR
	OSM	AC4			;COMPARE BITS 19-16 WITH EXPECTED
	JMPZ	.+2			;JUMP IF CORRECT
ROMERR:	ERROR	ROMLP,INCORRECT ROM DATA,,PNT
	DATI	REG2,BR			;READ ROM ADDR BIT 8
	JMPB0	ISSET			;JUMP IF IT'S SET
	INCR	AC1			;INC BITS 7-0 OF ADDRESS
	JMPC	SET8			;JUMP IF THEY OVERFLOWED, SET BIT 8
	LDBR	(377-ZERADR)		;SET CONSTANT TO PRODUCE CARRY WHEN
	ADB	AC1,BR			;ADDR IS PAST NON ZERO DATA
	JMPC	ROMLP			;JUMP IF INTO ZERO DATA
ADVPTR:	LDBR	3			;ADVANCE DATA TABLE PTR TO NEXT ENTRY
	ADBR	AC2			;EACH ENTRY IS 3 WORDS LONG
	JMPC	.+2			;JUMP IF OVERFLOW OF MEM ADDR
	JMP	ROMLP			;ELSE CONTINUE
	INCR	AC3			;INC MAR EXT BITS COUNTER
	JMP	ROMLP			;CONTINUE

SET8:	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	JMP	ROMLP			;CONTINUE

ISSET:	INCR	AC1			;INC BITS 7-0 OF ADDR
	JMPC	ROMFIN			;JUMP IF OVERFLOW, DONE
	LDBR	(400-DIAGAD)		;SET CONSTANT TO PRODUCE CARRY WHEN
	ADB	AC1,BR			;WHEN REACH NONZERO DATA
	JMPC	ADVPTR			;JUMP IF INTO NONZERO DATA
	JMP	ROMLP			;ELSE, USE ZERO DATA FOR COMPARE

ROMFIN:	REPEAT	TST
	TEST	210,TEST GENERATION OF "FMTR END XFER"
;*CLEAR CLOCK PHASES.
;*CLEAR "RUN" AND "ROM 00".
;*CLEAR "SLVE WOR END XFER" ON CB BOARD.
;*CHECK THAT "FMTR END XFER" IS NOT SET.

	LDBR	BCLKEN			;ENABLE BASE CLK AND CLEAR "DX HIGH SPEED"
	MOVB	REG1
	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;CLEAR "RUN"
	LDBR	RMADR8			;SET ROM ADR BIT 8
	MOVB	REG2
	LDBR	ZEROS			;SET ROM ADR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 00"=0
	GOSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	DATI	REG3,AC0		;READ REG 3
	SHL	AC0,BR			;MOVE "NOT FMTR END XFER" BIT TO BIT 7
	JMPB4	.+2			;JUMP IF SET ("FMTR END XFER" = 0)
	ERROR	TST,"FMTR END XFER" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "RUN" AND "SLVE WOR END XFER" AND "ROM 00"
;*SET "SLVE WOR END XFER".
;*CHECK THAT "FMTR END XFER" IS SET.

FEX1:	GOSUB	SWEX			;GO SET "SLVE WOR END XFER"
	DATI	REG3,AC0		;READ REG 3
	SHL	AC0,BR			;MOVE "NOT FMTR END XFER" BIT TO BIT 7
	JMPB4	.+2			;JUMP IF SET ("FMTR END XFER" = 0)
	JMP	.+2			;JUMP IF CLEAR ("FMTR END XFER" = 1)
	ERROR	FEX1,"FMTR END XFER" DID NOT SET,
DIAG SET "SLVE WOR END XFER" AND CLEARED "RUN" AND "ROM 00"
;*SET "RUN".
;*CHECK THAT "FMTR END XFER" IS CLEAR.

FEX2:	MOVB	SETRUN			;SET "RUN"
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,AC0		;READ REG 3
	SHL	AC0,BR			;MOVE "NOT FMTR END XFER" BIT TO BIT 7
	JMPB4	.+2			;JUMP IF SET ("FMTR END XFER" = 0)
	ERROR	FEX2,"FMTR END XFER" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "RUN" AND "SLVE WOR END XFER" AND CLEARED "ROM 00"
;*SET "ROM 00" AND CLEAR "RUN".
;*CHECK THAT "FMTR END XFER" IS CLEAR.

FEX3:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	MOVB	HSDPIN			;CLEAR "RUN"
	LDBR	ONES			;LOAD ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 00"=1
	LDBR	DXHISP			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,AC0		;READ REG 3
	SHL	AC0,BR			;MOVE "NOT FMTR END XFER" BIT TO BIT 7
	JMPB4	.+2			;JUMP IF SET ("FMTR END XFER" = 0)
	ERROR	FEX3,"FMTR END XFER" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "SLVE WOR END XFER" AND "ROM 00" AND CLEARED "RUN"
	GOSUB	INITL			;GO DO A MICROBUS INIT
	REPEAT	TST
	TEST	211,TEST "EXTEND RUN"
;*TEST THAT "EXTEND RUN" SETS WHEN AND ONLY WHEN 
;*	(1) "SLVE END XFER" IS NEGATED, AND
;*	(2) "CLK PH 1" IS ASSERTED, AND
;*	(3) ROM SHIFT COUNT = 7.
;*ALSO, CHECK THAT IT CLEARS WHEN "CC 0" CLEARS OR WHEN "HS DP INIT"
;*IS ASSERTED.

;*CLEAR CLOCK PHASES.
;*CLEAR "SLVE END XFER".
;*LOAD ROM ADDR FOR SHIFT COUNT =7.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEP.
;*CHECK THAT "EXTEND RUN" IS NOT SET YET.

	GOSUB	INITL			;DO A MICROBUS INIT
	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	DSHF7			;SET SHIFT COUNT=7
	MOVB	DFRMAD
	GOSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"EXTEND RUN" SET WITH "CLK PH 1" CLEARED,
DIAG CLEARED "SLVE END XFER" AND SET SHIFT COUNT=7
;*SET "RUN".
;*GENERATE 2 SINGLE STEP PULSES TO SET "CLK PH 1".
;*CHECK THAT "EXTEND RUN" IS SET.

	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE2			;GENERATE 2 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"EXTEND RUN" DID NOT SET,
<DIAG CLEARED "SLVE END XFER",
SET SHIFT COUNT = 7, AND
SET "CLK PH 1">
;*GENERATE 2 MORE SINGLE STEP PULSES TO CLEAR "CLK PH 1".
;*CHECK THAT "EXTEND RUN" STAYS SET.

	GOSUB	PULSE2			;GENERATE 2 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"EXTEND RUN" DIDN'T STAY SET,
DIAG SET "EXTEND RUN" THEN CLEARED "CLK PH 1"
;*SET ROM ADDR FOR "CC 0"=0 AND SHIFT COUNT=0.
;*SET "RUN".
;*GENERATE A SINGLE STEP PULSE TO SET "CC 0"=0.
;*CHECK THAT "EXTEND RUN" IS CLEARED.

	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	CC0			;SET "ROM 00"=0
	MOVB	DFRMAD
	MOVB	SETRUN			;SET "RUN"
	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"EXTEND RUN" DIDN'T CLEAR WHEN "CC 0" CLEARED
;*SET "EXTEND RUN" AGAIN.
;*WRITE TO REG 17.
;*CHECK THAT "EXTEND RUN" IS CLEARED.

EXRUN0:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	DSHF7			;SET SHIFT CNT=7
	MOVB	DFRMAD
	GOSUB	ENSS			;ENABLE SINGLE STEP AND SET "DX HIGH SPEED"
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;GENERATE 4 SINGLE STEP PULSES
	MOVB	REG17			;WRITE TO REG 17
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	EXRUN1,"EXTEND RUN" DIDN'T CLEAR AFTER WRITING REG 17
;*SET "EXTEND RUN" AGAIN.
;*DO A HS DP INIT.
;*CHECK THAT "EXTEND RUN" IS CLEARED.

EXRUN1:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	DSHF7			;SET SHIFT CNT=7
	MOVB	DFRMAD
	GOSUB	ENSS			;ENABLE SINGLE STEP AND SET "DX HIGH SPEED"
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;GENERATE 4 SINGLE STEP PULSES
EXRUN2:	MOVB	HSDPIN			;DO A HS DP INIT
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	EXRUN1,"EXTEND RUN" DIDN'T CLEAR AFTER HS DP INIT
;*SET "SLVE END XFER".
;*SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES.
;*CHECK THAT "EXTEND RUN" DIDN'T SET.

	GOSUB	SWEX			;GO SET "SLVE END XFER" ON CB BOARD
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;SET AND CLEAR "CLK PH 1"
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	EXRUN2,"EXTEND RUN" SET WITH "SLVE END XFER" ASSERTED
;*CLEAR "SLVE END XFER".
;*SET ROM ADDR FOR SHIFT COUNT= 17.
;*SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES.
;* CHECK THAT "EXTEND RUN" DIDN'T SET.

EXRUN3:	MOVB	HSDPIN			;INSURE "EXTEND RUN" IS CLEARED
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	DSHF17			;SET ROM ADDR FOR SHFT CNT=17
	MOVB	DFRMAD
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;GENERATE 4 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	EXRUN3,"EXTEND RUN" SET WITH SHIFT COUNT=17
;*SET ROM ADDR FOR SHIFT COUNT= 3.
;*SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES.
;* CHECK THAT "EXTEND RUN" DIDN'T SET.

EXRUN4:	MOVB	HSDPIN			;INSURE "EXTEND RUN" IS CLEARED
	LDBR	DSHF3			;SET ROM ADDR FOR SHFT CNT=3
	MOVB	DFRMAD
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;GENERATE 4 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	EXRUN4,"EXTEND RUN" SET WITH SHIFT COUNT=3
;*SET ROM ADDR FOR SHIFT COUNT= 5.
;*SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES.
;* CHECK THAT "EXTEND RUN" DIDN'T SET.

EXRUN5:	MOVB	HSDPIN			;INSURE "EXTEND RUN" IS CLEARED
	LDBR	DSHF5			;SET ROM ADDR FOR SHFT CNT=5
	MOVB	DFRMAD
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;GENERATE 4 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	EXRUN5,"EXTEND RUN" SET WITH SHIFT COUNT=5
;*SET ROM ADDR FOR SHIFT COUNT= 6.
;*SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES.
;* CHECK THAT "EXTEND RUN" DIDN'T SET.

EXRUN6:	MOVB	HSDPIN			;INSURE "EXTEND RUN" IS CLEARED
	LDBR	DSHF6			;SET ROM ADDR FOR SHFT CNT=6
	MOVB	DFRMAD
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;GENERATE 4 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;LEFT ADJUST "EXTEND RUN"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	EXRUN6,"EXTEND RUN" SET WITH SHIFT COUNT=6
	REPEAT	TST
	TEST	212,TEST "SLVE REQ" USING "DIAG SLVE REQ"
;*SET "DIAG SLVE REQ".
;*CHECK THAT "SLVE REQ" IS SET.

	LDBR	DSLVRQ			;SET "DIAG SLVE REQ"
	MOVB	REG1
	DATI	REG1,AC0		;READ REG 1
	SHL	AC0,BR			;LEFT ADJUST "SLVE REQ"
	JMPB7	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"SLVE REQ" DIDN'T SET WHEN "DIAG SLVE REQ" WAS SET
;*CLEAR "DIAG SLVE REQ".
;*CHECK THAT "SLVE REQ" IS CLEARED.

	LDBR	0			;CLEAR "DIAG SLVE REQ"
	MOVB	REG1
	DATI	REG1,AC0		;READ REG 1
	SHL	AC0,BR			;LEFT ADJUST "SLVE REQ"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE REQ" DIDN'T CLEAR WHEN "DIAG SLVE REQ" WAS CLEARED
;*SET "DIAG SLVE REQ".
;*CHECK THAT "SLVE REQ" IS SET.

	LDBR	DSLVRQ			;SET "DIAG SLVE REQ"
	MOVB	REG1
	DATI	REG1,AC0		;READ REG 1
	SHL	AC0,BR			;LEFT ADJUST "SLVE REQ"
	JMPB7	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"SLVE REQ" DIDN'T SET WHEN "DIAG SLVE REQ" WAS SET
	LDBR	0			;CLEAR "DIAG SLVE REQ"
	MOVB	REG1

	REPEAT	TST
	JUMP	NXTBNK			;JUMP TO NEXT BANK OF CRAM
	.LOC	2000
NXTBNK:
	TEST	213,TEST "SLVE RDY" FLOPS
;*CHECK THE DIRECT SETTING AND CLEARING OF "SLVE RDY", "SLVE RDY DLY 1",
;*AND "SLVE RDY DLY 2" BY "DEV RD INIT" AND "DEV WR INIT", RESPECTIVELY.
;*SET "DIR TO MSTR" AND DO A HS DP INIT.
;*CHECK THAT ALL THE "SLVE RDY" FLOPS ARE SET.

	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;DO A HS DP INIT, GENS "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	JMPB0	.+2			;JUMP IF "SLVE RDY" SET, SHOULD HAVE
	ERROR	TST,"SLVE RDY" DIDN'T SET,
DIAG GENERATED A "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 1"
	JMPB0	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	TST,"SLVE RDY DLY 1" DIDN'T SET,
DIAG GENERATED A "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 2"
	SHR
	JMPB0	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	TST,"SLVE RDY DLY 2" DIDN'T SET,
DIAG GENERATED A "DEV RD INIT"
;*CLEAR "DIR TO MSTR" AND DO A HS DP INIT.
;*CHECK THAT ALL THE "SLVE RDY" FLOPS ARE CLEARED.

SRD1:	GOSUB	DEVWR			;SET DEVICE WRITE
	MOVB	HSDPIN			;DO A HS DP INIT, GENS "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	JMPB0	.+2			;JUMP IF "SLVE RDY" SET, SHOULDN'T HAVE
	JMP	.+2			;JUMP IF IT CLEARED
	ERROR	TST,"SLVE RDY" DIDN'T CLEAR,
DIAG GENERATED A "DEV WR INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 1"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;JUMP IF IT CLEARED
	ERROR	TST,"SLVE RDY DLY 1" DIDN'T CLEAR,
DIAG GENERATED A "DEV WR INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 2"
	SHR
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;JUMP IF IT CLEARED
	ERROR	TST,"SLVE RDY DLY 2" DIDN'T CLEAR,
DIAG GENERATED A "DEV WR INIT"
;*SET "DIR TO MSTR" AND DO A HS DP INIT.
;*CHECK THAT ALL THE "SLVE RDY" FLOPS ARE SET.

	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;DO A HS DP INIT, GENS "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	JMPB0	.+2			;JUMP IF "SLVE RDY" SET, SHOULD HAVE
	ERROR	SRD1,"SLVE RDY" DIDN'T SET,
DIAG GENERATED A "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 1"
	JMPB0	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	SRD1,"SLVE RDY DLY 1" DIDN'T SET,
DIAG GENERATED A "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 2"
	SHR
	JMPB0	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	SRD1,"SLVE RDY DLY 2" DIDN'T SET,
DIAG GENERATED A "DEV RD INIT"
	REPEAT	TST
	TEST	214,TEST SLVE SIDE HANDSHAKING LOGIC
;*CLEAR "DIAG SLVE REQ".
;*CHECK THAT "SLVE ACK" IS CLEARED.

	LDBR	0			;CLEAR "DIAG SLVE REQ"
	MOVB	REG1
	DATI	REG1,BR			;READ REG 1 FOR "SLVE ACK"
	JMPB4	.+2			;JUMP IF SET
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE ACK" DID NOT CLEAR WHEN "DIAG SLVE REQ" CLEARED
;*SET "SLVE RDY DLY 2" WITH A "DEV RD INIT".
;*CHECK THAT "SLVE REQ HLDOFF" IS CLEARED.

	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	DATI	REG2,AC0		;READ REG 2
	SHL	AC0,BR			;LEFT ADJUST "SLVE REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE REQ HLDOFF" DIDN'T CLEAR AFTER HS DP INIT
;*SET "DIAG SLVE REQ".
;*CHECK THAT "SLVE ACK" IS SET AND "SLVE RDY" IS CLEARED.

	LDBR	DSLVRQ			;SET "DIAG SLVE REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG1,BR			;READ REG 1 FOR "SLVE ACK"
	JMPB4	.+2			;JUMP IF IT SET
	ERROR	TST,"SLVE ACK" DID NOT SET,
DIAG SET "SLVE RDY DLY 2" AND "DIAG SLVE REQ"
	DATI	REG17,BR		;READ REG 17
	JMPB0	.+2			;JUMP IF "SLVE RDY" IS SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE RDY" DIDN'T CLEAR,
DIAG SET "SLVE RDY" THEN GENERATED "SLVE ACK"
;*CLEAR "DIAG SLVE REQ".
;*CHECK THAT "SLVE ACK" IS CLEARED AND "SLVE REQ HLDOFF" IS SET.

	LDBR	0			;CLEAR "DIAG SLVE REQ"
	MOVB	REG1
	DATI	REG1,BR			;READ REG 1 FOR "SLVE ACK"
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE ACK" DID NOT CLEAR WHEN "DIAG SLVE REQ" CLEARED
	DATI	REG2,AC0		;READ REG 2
	SHL	AC0,BR			;LEFT ADJUST "SLVE REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"SLVE REQ HLDOFF" DIDN'T SET,
DIAG SET "SLVE RDY DLY 2" THEN SET AND CLEARED "DIAG SLVE REQ"
;*SET "DIAG SLVE REQ".
;*CHECK THAT "SLVE ACK" DID NOT SET.

	LDBR	DSLVRQ			;SET "DIAG SLVE REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG1,BR			;READ REG 1 FOR "SLVE ACK"
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE ACK" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "SLVE REQ HLDOFF" THEN SET "DIAG SLVE REQ"
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "SLVE RDY DLY 1" IS CLEARED.

	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 1"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE RDY DLY 1" DIDN'T CLEAR,
<DIAG SET "SLVE RDY DLY 1" THEN CLEARED "SLVE RDY" AND
GENERATED A SINGLE STEP PULSE>
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "SLVE RDY DLY 2" IS CLEARED.

	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG17,BR		;READ REG 17
	SHR				;RIGHT ADJUST "SLVE RDY DLY 2"
	SHR
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE RDY DLY 2" DIDN'T CLEAR,
<DIAG SET "SLVE RDY DLY 2" THEN CLEARED "SLVE RDY DLY 1" AND
GENERATED A SINGLE STEP PULSE>
;*CHECK THAT "SLVE REQ HLDOFF" IS CLEARED.

	DATI	REG2,AC0		;READ REG 2
	SHL	AC0,BR			;LEFT ADJUST "SLVE REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"SLVE REQ HLDOFF" DIDN'T CLEAR,
DIAG SET "SLVE REQ HLDOFF" THEN CLEARED "SLVE RDY DLY 2"
;*SET "SLVE REQ HLDOFF" THEN DO A HS DP INIT.
;*CHECK THAT "SLVE REQ HLDOFF" IS CLEARED.

SHND:	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	DSLVRQ			;SET "DIAG SLVE REQ"
	MOVB	REG1
	LDBR	0			;CLEAR "DIAG SLVE REQ"
	MOVB	REG1
	MOVB	HSDPIN			;DO AN INIT TO CLEAR "SLVE REQ HLDOFF"
	DATI	REG2,AC0		;READ REG 2
	SHL	AC0,BR			;LEFT ADJUST "SLVE REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	SHND,"SLVE REQ HLDOFF" DIDN'T CLEAR,
DIAG SET "SLVE REQ HLDOFF" THEN DID A HS DP INIT
	REPEAT	TST
	TEST	215,TEST "MSTR REQ" USING "DIAG MSTR REQ"
;*SET "DIAG MSTR REQ".
;*CHECK THAT "MSTR REQ" IS SET.

	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET, SHOULD BE
	ERROR	TST,"MSTR REQ" DIDN'T SET WHEN "DIAG MSTR REQ" WAS SET
;*CLEAR "DIAG MSTR REQ".
;*CHECK THAT "MSTR REQ" IS CLEARED.

	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR REQ" DIDN'T CLEAR WHEN "DIAG MSTR REQ" WAS CLEARED
;*SET "DIAG MSTR REQ".
;*CHECK THAT "MSTR REQ" IS SET.

	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET, SHOULD BE
	ERROR	TST,"MSTR REQ" DIDN'T SET WHEN "DIAG MSTR REQ" WAS SET
	REPEAT	TST
	TEST	216,TEST "MSTR RDY" FLOPS
;*CHECK THE DIRECT SETTING AND CLEARING OF "MSTR RDY", "MSTR RDY DLY 1",
;* AND "MSTR RDY DLY 2" BY "DEV WR INIT" AND "DEV RD INIT", RESPECTIVELY.

;*CLEAR "DIR TO MSTR" AND DO A HS DP INIT.
;*CHECK THAT ALL THE "MSTR RDY" FLOPS ARE SET.

	LDBR	0			;ENABLE SINGLE STEP MODE
	MOVB	REG1
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;DO A HS DP INIT, GENS "DEV WR INIT"
	DATI	REG17,AC0		;READ REG 17
	SHL	AC0,BR			;MOVE "MSTR RDY" TO BIT 4
	JMPB4	.+2			;JUMP IF "MSTR RDY" SET, SHOULD HAVE
	ERROR	TST,"MSTR RDY" DIDN'T SET,
DIAG GENERATED A "DEV WR INIT"
	DATI	REG17,BR		;READ REG 17
	JMPB4	.+2			;JUMP IF "MSTR RDY DLY 1" SET, SHOULD HAVE
	ERROR	TST,"MSTR RDY DLY 1" DIDN'T SET,
DIAG GENERATED A "DEV WR INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;MOVE "MSTR RDY DLY 2" TO BIT 4
	JMPB4	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	TST,"MSTR RDY DLY 2" DIDN'T SET,
DIAG GENERATED A "DEV WR INIT"
;*SET "DIR TO MSTR" AND DO A HS DP INIT.
;*CHECK THAT ALL THE "MSTR RDY" FLOPS ARE CLEARED.

MRD1:	JMPSUB	DEVRD			;SET DEVICE READ
	MOVB	HSDPIN			;DO A HS DP INIT, GENS "DEV RD INIT"
	DATI	REG17,AC0		;READ REG 17
	SHL	AC0,BR			;MOVE "MSTR RDY" TO BIT 4
	JMPB4	.+2			;JUMP IF "MSTR RDY" SET, SHOULDN'T HAVE
	JMP	.+2			;JUMP IF IT CLEARED
	ERROR	TST,"MSTR RDY" DIDN'T CLEAR,
DIAG GENERATED A "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	JMPB4	.+2			;JUMP IF "MSTR RDY DLY 1" SET, SHOULDN'T HAVE
	JMP	.+2			;JUMP IF IT CLEARED
	ERROR	TST,"MSTR RDY DLY 1" DIDN'T CLEAR,
DIAG GENERATED A "DEV RD INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;MOVE "MSTR RDY DLY 2" TO BIT 4
	JMPB4	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;JUMP IF IT CLEARED
	ERROR	TST,"MSTR RDY DLY 2" DIDN'T CLEAR,
DIAG GENERATED A "DEV RD INIT"
;*CLEAR "DIR TO MSTR" AND DO A HS DP INIT.
;*CHECK THAT ALL THE "MSTR RDY" FLOPS ARE SET.

	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;DO A HS DP INIT, GENS "DEV WR INIT"
	DATI	REG17,AC0		;READ REG 17
	SHL	AC0,BR			;MOVE "MSTR RDY" TO BIT 4
	JMPB4	.+2			;JUMP IF "MSTR RDY" SET, SHOULD HAVE
	ERROR	MRD1,"MSTR RDY" DIDN'T SET,
DIAG GENERATED A "DEV WR INIT"
	DATI	REG17,BR		;READ REG 17
	JMPB4	.+2			;JUMP IF "MSTR RDY DLY 1" SET, SHOULD HAVE
	ERROR	MRD1,"MSTR RDY DLY 1" DIDN'T SET,
DIAG GENERATED A "DEV WR INIT"
	DATI	REG17,BR		;READ REG 17
	SHR				;MOVE "MSTR RDY DLY 2" TO BIT 4
	JMPB4	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	MRD1,"MSTR RDY DLY 2" DIDN'T SET,
DIAG GENERATED A "DEV WR INIT"
	REPEAT	TST
	TEST	217,TEST MSTR SIDE HANDSHAKING LOGIC
;*CLEAR "DIAG MSTR REQ".
;*CHECK THAT "MSTR ACK" IS CLEARED.

	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	DATI	REG1,BR			;READ REG 1 FOR "MSTR ACK"
	SHR				;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF SET
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR ACK" DID NOT CLEAR WHEN "DIAG MSTR REQ" CLEARED
;*SET "MSTR RDY DLY 2" WITH A "DEV WR INIT".
;*CHECK THAT "MSTR REQ HLDOFF" IS CLEARED.

	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	DATI	REG2,BR			;READ REG2 FOR "MSTR REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR REQ HLDOFF" DIDN'T CLEAR AFTER HS DP INIT
;*SET "DIAG MSTR REQ".
;*CHECK THAT "MSTR ACK" IS SET AND "MSTR RDY" IS CLEARED.

	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG1,BR			;READ REG 1 FOR "MSTR ACK"
	SHR				;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF IT SET
	ERROR	TST,"MSTR ACK" DID NOT SET,
DIAG SET "MSTR RDY DLY 2" AND "DIAG MSTR REQ"
	DATI	REG17,AC0		;READ REG 17
	SHL	AC0,BR			;MOVE "MSTR RDY" TO BIT 4
	JMPB4	.+2			;JUMP IF "MSTR RDY" IS SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR RDY" DIDN'T CLEAR,
DIAG SET "MSTR RDY" THEN GENERATED "MSTR ACK"
;*CLEAR "DIAG MSTR REQ".
;*CHECK THAT "MSTR ACK" IS CLEARED AND "MSTR REQ HLDOFF" IS SET.

	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	DATI	REG1,BR			;READ REG 1 FOR "MSTR ACK"
	SHR				;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR ACK" DID NOT CLEAR WHEN "DIAG MSTR REQ" CLEARED
	DATI	REG2,BR			;READ REG2 FOR "MSTR REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"MSTR REQ HLDOFF" DIDN'T SET,
DIAG SET "MSTR RDY DLY 2" THEN SET AND CLEARED "DIAG MSTR REQ"
;*SET "DIAG MSTR REQ".
;*CHECK THAT "MSTR ACK" DID NOT SET.

	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG1,BR			;READ REG 1 FOR "MSTR ACK"
	SHR				;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR ACK" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "MSTR REQ HLDOFF" THEN SET "DIAG MSTR REQ"
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "MSTR RDY DLY 1" IS CLEARED.

	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG17,BR		;READ REG 17
	JMPB4	.+2			;JUMP IF "MSTR RDY DLY 1" SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR RDY DLY 1" DIDN'T CLEAR,
<DIAG SET "MSTR RDY DLY 1" THEN CLEARED "MSTR RDY" AND
GENERATED A SINGLE STEP PULSE>
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "MSTR RDY DLY 2" IS CLEARED.

	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG17,BR		;READ REG 17
	SHR				;MOVE "MSTR RDY DLY 2" TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR RDY DLY 2" DIDN'T CLEAR,
<DIAG SET "MSTR RDY DLY 2" THEN CLEARED "MSTR RDY DLY 1" AND
GENERATED A SINGLE STEP PULSE>
;*CHECK THAT "MSTR REQ HLDOFF" IS CLEARED.

	DATI	REG2,BR			;READ REG2 FOR "MSTR REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MSTR REQ HLDOFF" DIDN'T CLEAR,
DIAG SET "MSTR REQ HLDOFF" THEN CLEARED "MSTR RDY DLY 2"
;*SET "MSTR REQ HLDOFF" THEN DO A HS DP INIT.
;*CHECK THAT "MSTR REQ HLDOFF" IS CLEARED.

MHND:	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	MOVB	HSDPIN			;DO AN INIT TO CLEAR "MSTR REQ HLDOFF"
	DATI	REG2,BR			;READ REG2 FOR "MSTR REQ HLDOFF"
	JMPB7	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	MHND,"MSTR REQ HLDOFF" DIDN'T CLEAR,
DIAG SET "MSTR REQ HLDOFF" THEN DID A HS DP INIT
	REPEAT	TST
	TEST	218,TEST GENERATION OF "LD ROM ADDR 3-0"
;*TEST THAT ROM DATA BITS 19-16 ARE CLOCKED INTO ROM ADDR BITS 3-0 WHEN
;*"CLK PH 0" SETS (THIS GENERATES "LD ROM ADR TE" PULSE).

;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR TO POINT TO LOC WITH BITS 19-16 ALL ONES.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*SET "RUN".
;*GENERATE A SINGLE STEP PULSE TO SET "CLK PH 0".
;*CHECK THAT ROM ADDR BITS 3-0 ARE ALL ONES.

	LDBR	BCLKEN			;CLEAR "DX HIGH SPEED" AND ENABLE BASE CLK
	MOVB	REG1
	LDBR	RMADR8			;SET ROM ADR BIT 8
	MOVB	REG2
	LDBR	ONES			;SET ROM ADR TO POINT TO LOC WITH
	MOVB	DFRMAD			;ALL ONES
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	SETRUN			;SET "RUN"
	MOVB	CLKPLS			;SET "CLK PH 0"
	NOP				;DELAY BEFORE DOING DATI
	DATI	DFRMAD,AC0		;READ ROM ADDR
	LDMEM	ONES!17			;SET EXPECTED ROM ADR VALUE
	OSM	AC0			;CHECK IF NEW ADDR IS CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	TST,ROM ADDR BITS 3-0 DIDN'T LOAD,
<DIAG LOADED ROM ADDR THEN SET "DX HIGH SPEED" AND
GENERATED "CLK PH 0">
	REPEAT	TST
	TEST	219,TEST "RUN DATA"
;*CLEAR CLOCK PHASES AND "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*CLEAR "MSTR RDY DLY 2" WITH A "DEV RD INIT".
;*SET "ROM 01".
;*CHECK THAT "RUN DATA" IS NOT SET.

	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	0			;CLEAR "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	REG1
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;CLEAR "MSTR RDY DLY 2"
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	CC2			;SET "ROM 01"
	MOVB	DFRMAD
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	JMP	.+2			;JUMP IF CLEARED (RUN DATA=1)
	ERROR	TST,"RUN DATA" DIDN'T SET,
DIAG CLEARED "MSTR RDY DLY 2" AND SET "ROM 01"
;*CLEAR "ROM 01".
;*CHECK THAT "RUN DATA" IS SET.

RNDAT1:	LDBR	ZEROS			;CLEAR ROM 01
	MOVB	DFRMAD
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT1,"RUN DATA" DIDN'T CLEAR,
DIAG CLEARED THE ROM BITS AND "MSTR RDY DLY 2"
;*SET "ROM 01" AND "MSTR RDY DLY 2".
;*CHECK THAT "RUN DATA" IS NOT SET.

RNDAT2:	LDBR	CC2			;SET ROM 01
	MOVB	DFRMAD
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT2,"RUN DATA" DIDN'T CLEAR,
DIAG SET "ROM 01" AND THEN SET "MSTR RDY DLY 2"
;*SET "ROM 02", "SLVE RDY DLY 2" IS ALREADY CLEARED.
;*CHECK THAT "RUN DATA" IS SET.

RNDAT3:	LDBR	CC4			;SET ROM 02
	MOVB	DFRMAD
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	JMP	.+2			;JUMP IF CLEARED (RUN DATA=1)
	ERROR	RNDAT3,"RUN DATA" DIDN'T SET,
DIAG CLEARED "SLVE RDY DLY 2" AND SET "ROM 02"
;*SET "SLVE RDY DLY 2".
;*CHECK THAT "RUN DATA" IS CLEARED.

RNDAT4:	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT4,"RUN DATA" DIDN'T CLEAR,
DIAG SET "ROM 02" AND THEN SET "SLVE RDY DLY 2"
;*SET "ROM 02" AND "ROM 00" AND "SLVE END XFER".
;*CHECK THAT "RUN DATA" IS SET.

RNDAT5:	LDBR	CC5			;SET ROM 02 & 00
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	SWEX			;SET "SLVE END XFER"
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	JMP	.+2			;JUMP IF CLEARED (RUN DATA=1)
	ERROR	RNDAT5,"RUN DATA" DIDN'T SET,
DIAG SET "SLVE END XFER" AND "ROM 00" AND "ROM 02"
;*CLEAR "ROM 00".
;*CHECK THAT "RUN DATA" IS CLEARED.

RNDAT6:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	CC4			;SET ROM 02 AND CLEAR ROM 00
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT6,"RUN DATA" DIDN'T CLEAR,
DIAG SET "SLVE END XFER" AND "ROM 02" BUT CLEARED "ROM 00"
;*SET "ROM 00" AND CLEAR "ROM 02"
;*CHECK THAT "RUN DATA" IS CLEARED.

RNDAT7:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	CC1			;SET ROM 00 AND CLEAR ROM 02
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT7,"RUN DATA" DIDN'T CLEAR,
DIAG SET "SLVE END XFER" AND "ROM 00" BUT CLEARED "ROM 02"
;*SET "ROM 02" AND CLEAR "SLVE END XFER".
;*CHECK THAT "RUN DATA" IS CLEARED.

RNDAT8:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	CC5			;SET ROM 00 & 02
	MOVB	DFRMAD
	JMPSUB	CLRSEX			;GO CLEAR "SLVE END XFER"
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT8,"RUN DATA" DIDN'T CLEAR,
DIAG SET "ROM 02" AND "ROM 00" AND CLEARED "SLVE END XFER"
;*SET "EXTEND RUN", "SLVE END XFER", AND "ROM 02".
;*CHECK THAT "RUN DATA" IS SET.

RNDAT9:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	DSHF7			;SET ROM ADDR FOR SHIFT CNT=7
	MOVB	DFRMAD
	JMPSUB	CLRSEX			;CLEAR "SLVE END XFER"
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE4			;GENERATE 4 SINGLE STEP PULSES
	LDBR	CC4			;SET ROM 02
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	SWEX			;SET "SLVE END XFER"
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	JMP	.+2			;JUMP IF CLEARED (RUN DATA=1)
	ERROR	RNDAT9,"RUN DATA" DIDN'T SET,
<DIAG SET "EXTEND RUN", "SLVE END XFER", AND "ROM 02">
;*CLEAR "SLVE END XFER".
;*CHECK THAT "RUN DATA" CLEARS.

RNDT10:	JMPSUB	CLRSEX			;CLEAR "SLVE END XFER"
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT7,"RUN DATA" DIDN'T CLEAR,
DIAG SET "EXTEND RUN" AND "ROM 02" AND CLEARED "SLVE END XFER"
;*SET "SLVE END XFER" AND CLEAR "ROM 02".
;*CHECK THAT "RUN DATA" IS CLEARED.

RNDT11:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	CC0			;CLEAR "ROM 02"
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	SWEX			;SET "SLVE END XFER"
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;LEFT ADJUST "NOT RUN DATA" BIT
	JMPB7	.+2			;JUMP IF SET (RUN DATA=0)
	ERROR	RNDAT7,"RUN DATA" DIDN'T CLEAR,
DIAG SET "EXTEND RUN" AND "SLVE END XFER" AND CLEARED "ROM 02"
	REPEAT	TST
	TEST	220,TEST CLOCKING OF "RUN"
;*TEST THAT "RUN" SETS AND CLEARS CORRECTLY USING THE CLOCKED INPUTS.

;*CLEAR "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*SET "RUN DATA".
;*SET "DX HIGH SPEED".
;*GENERATE 2 SINGLE STEP PULSES.
;*CHECK THAT "RUN" IS SET.

	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	0			;CLEAR "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	REG1
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;GENERATE "DEV RD INIT", SET "SLVE RDY DLY 2"
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	ONES			;SET ALL ROM BITS
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	CLKPLS			;CLEAR "CLR RUN"
	MOVB	CLKPLS			;CLOCK "RUN" FLOP
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;MOVE "NOT RUN" BIT INTO BIT 4
	JMPB4	.+2			;JUMP IF SET (RUN = 0)
	JMP	.+2			;JUMP IF CLEARED (RUN=1)
	ERROR	TST,"RUN" DID NOT SET,
<DIAG CLEARED "RUN" AND SET "RUN DATA" THEN
GENERATED 2 SINGLE STEP PULSES>
;*CLEAR "RUN DATA" AND GENERATE A "SET RUN" PULSE.
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "RUN" IS CLEARED.

RUNA:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	0			;ENABLE SINGLE STEPPING
	MOVB	REG1
	LDBR	ZEROS			;LOAD ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;ROM BITS CLEARED
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	DATI	REG16,AC0		;READ REG 16
	SHL	AC0,BR			;MOVE "NOT RUN" BIT INTO BIT 4
	JMPB4	.+2			;JUMP IF SET (RUN = 0)
	ERROR	RUNA,"RUN" DID NOT CLEAR,
<DIAG CLEARED "RUN DATA" AND SET "RUN" THEN
GENERATED A SINGLE STEP PULSE>
	REPEAT	TST
	TEST	221,TEST SETTING AND CLEARING OF "EN MUX/DEMUX"
;*CLEAR "DX HIGH SPEED" AND ENABLE BASE CLOCK.
;*CHECK THAT "EN MUX/DEMUX" IS CLEARED.

	LDBR	BCLKEN			;ENABLE THE BASE CLOCK
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;MOVE "NOT EN MUX/DEMUX" TO BIT 4
	JMPB4	.+2			;JUMP IF SET (EN MUX/DEMUX = 0)
	ERROR	TST,<"EN MUX/DEMUX" DID NOT CLEAR WITH DF CLOCK
PHASES CLEARED>
;*ENABLE SINGLE STEPPING AND SET "RUN".
;*GENERATE 2 SINGLE STEP PULSES TO SET "CLK PH 1".
;*CHECK THAT "EN MUX/DEMUX" IS NOT SET YET.

	LDBR	0			;ENABLE SINGLE STEP MODE
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE2			;GENERATE 2 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;MOVE "NOT EN MUX/DEMUX" TO BIT 4
	JMPB4	.+2			;JUMP IF SET (EN MUX/DEMUX = 0)
	ERROR	TST,"EN MUX/DEMUX" SET BEFORE IT SHOULD HAVE,
<DIAG CLEARED CLOCK PHASES THEN GENERATED
2 SINGLE STEP PULSES>
;*GENERATE A SINGLE STEP PULSE TO CLOCK "EN MUX/DEMUX" FLOP.
;*CHECK THAT "EN MUX/DEMUX" IS SET.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;MOVE "NOT EN MUX/DEMUX" TO BIT 4
	JMPB4	.+2			;JUMP IF SET (EN MUX/DEMUX = 0)
	JMP	.+2			;JUMP IF CLEAR (EN MUX/DEMUX = 1)
	ERROR	TST,"EN MUX/DEMUX" DID NOT SET,
<DIAG CLEARED CLOCK PHASES THEN GENERATED
3 SINGLE STEP PULSES>
;*GENERATE A SINGLE STEP PULSE TO CLEAR "CLK PH 1".
;*CHECK THAT "EN MUX/DEMUX" IS CLEARED.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,AC0		;READ REG 15
	SHL	AC0,BR			;MOVE "NOT EN MUX/DEMUX" TO BIT 4
	JMPB4	.+2			;JUMP IF SET (EN MUX/DEMUX = 0)
	ERROR	TST,"EN MUX/DEMUX" DID NOT CLEAR,
<DIAG CLEARED CLOCK PHASES THEN GENERATED
4 AND 1/2 SINGLE STEP PULSES>
	REPEAT	TST
	TEST	222,TEST GENERATION OF "LD CB"
;*CLEAR CLOCK PHASES AND "SLVE RDY" FLOPS.
;*SET "ROM 02".
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*CLEAR "CLR RUN".
;*CHECK THAT "LD CB" IS SET.

	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	JMPSUB	DEVWR			;SET DEVICE WRITE
	MOVB	HSDPIN			;CLEAR "SLVE RDY" FLOPS
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	CC4			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02" = 1
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	SETRUN			;SET "RUN" AND CLEAR "CLR RUN"
	DATI	REG15,BR		;READ REG 15 FOR "LD CB" BIT
	JMPB4	.+2			;JUMP IF SET
	ERROR	TST,"LD CB" DID NOT SET,
DIAG CLEARED CLOCK PHASES AND "CLR RUN" AND SET "ROM 02"
;*GENERATE A SINGLE STEP PULSE TO SET "CLK PH 0".
;*CHECK THAT "LD CB" IS CLEARED.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,BR		;READ REG 15 FOR "LD CB" BIT
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"LD CB" DID NOT CLEAR,
<DIAG CLEARED CLOCK PHASES AND "CLR RUN" AND SET "ROM 02" THEN
GENERATED A SINGLE STEP PULSE>
;*CHECK THAT "SLVE RDY" IS SET.

	DATI	REG17,BR		;READ REG 17
	JMPB0	.+2			;JUMP IF "SLVE RDY" SET, SHOULD HAVE
	ERROR	TST,"SLVE RDY" DIDN'T SET,
DIAG SET AND CLEARED "LD CB"
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "SLVE RDY DLY 1" IS SET.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG17,BR		;READ REG 17
	SHR				;MOVE "SLVE RDY DLY 1" TO BIT 0
	JMPB0	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	TST,"SLVE RDY DLY 1" DIDN'T SET,
DIAG SET "SLVE RDY" THEN GENERATED A SINGLE STEP PULSE
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "LD CB" DID NOT SET.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,BR		;READ REG 15 FOR "LD CB" BIT
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"LD CB" SET WHEN IT SHOULDN'T HAVE,
<DIAG CLEARED CLOCK PHASES AND "CLR RUN" AND SET "ROM 02" THEN
GENERATED 3 SINGLE STEP PULSES>
;*CHECK THAT "SLVE RDY DLY 2" IS SET.

	DATI	REG17,BR		;READ REG 17
	SHR				;MOVE "SLVE RDY DLY 2" TO BIT 0
	SHR
	JMPB0	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	TST,"SLVE RDY DLY 2" DIDN'T SET,
DIAG SET "SLVE RDY DLY 1" THEN GENERATED A SINGLE STEP PULSE
;*CLEAR CLOCK PHASES.
;*CLEAR "ROM 02" AND "CLR RUN".
;*CHECK THAT "LD CB" IS NOT SET.

	MOVB	CLKPLS			;CLEAR CLOCK PHASES
LDCB1:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	ZEROS			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02"=0
	MOVB	SETRUN			;SET "RUN"
	DATI	REG15,BR		;READ REG 15 FOR "LD CB" BIT
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	LDCB1,<"LD CB" SET WITH "ROM 02" AND
"CLR RUN" AND CLOCK PHASES CLEARED>
;*SET "ROM 02" AND "CLR RUN".
;*CHECK THAT "LD CB" IS NOT SET.

LDCB2:	LDBR	CC4			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02"=1
	MOVB	HSDPIN			;CLEAR "RUN" AND SET "CLR RUN"
	DATI	REG15,BR		;READ REG 15 FOR "LD CB" BIT
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	LDCB2,<"LD CB" SET WITH "ROM 02" AND
"CLR RUN" SET AND CLOCK PHASES CLEARED>
	REPEAT	TST
	TEST	223,TEST GENERATION OF "LD SB"
;*CLEAR CLOCK PHASES AND "MSTR RDY" FLOPS.
;*SET "ROM 01".
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*CLEAR "CLR RUN".
;*CHECK THAT "LD SB" IS SET.

	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	JMPSUB	DEVRD			;SET DEVICE READ
	MOVB	HSDPIN			;CLEAR "MSTR RDY" FLOPS
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	CC2			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 01" = 1
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	SETRUN			;SET "RUN" AND CLEAR "CLR RUN"
	DATI	REG15,BR		;READ REG 15
	SHR				;MOVE "LD SB" BIT TO BIT 4
	JMPB4	.+2			;JUMP IF SET
	ERROR	TST,"LD SB" DID NOT SET,
DIAG CLEARED CLOCK PHASES AND "CLR RUN" AND SET "ROM 01"
;*GENERATE A SINGLE STEP PULSE TO SET "CLK PH 0".
;*CHECK THAT "LD SB" IS CLEARED.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,BR		;READ REG 15
	SHR				;MOVE "LD SB" BIT TO BIT 4
	JMPB4	.+2			;JUMP IF SET
	JMP	.+2			;JUMP IF CLEAR
	ERROR	TST,"LD SB" DID NOT CLEAR,
<DIAG CLEARED CLOCK PHASES AND "CLR RUN" AND SET "ROM 01" THEN
GENERATED A SINGLE STEP PULSE>
;*CHECK THAT "MSTR RDY" IS SET.

	DATI	REG17,AC0		;READ REG 17
	SHL	AC0,BR			;MOVE "MSTR RDY" TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"MSTR RDY" DIDN'T SET,
DIAG SET AND CLEARED "LD SB"
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "MSTR RDY DLY 1" IS SET.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG17,BR		;READ REG 17
	JMPB4	.+2			;JUMP IF "MSTR RDY DLY 1" SET, SHOULD BE
	ERROR	TST,"MSTR RDY DLY 1" DIDN'T SET,
DIAG SET "MSTR RDY" THEN GENERATED A SINGLE STEP PULSE
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "LD SB" DID NOT SET.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,BR		;READ REG 15
	SHR				;MOVE "LD SB" BIT TO BIT 4
	JMPB4	.+2			;JUMP IF SET
	JMP	.+2			;JUMP IF CLEAR
	ERROR	TST,"LD SB" SET WHEN IT SHOULDN'T HAVE,
<DIAG CLEARED CLOCK PHASES AND "CLR RUN" AND SET "ROM 01" THEN
GENERATED 3 SINGLE STEP PULSES>
;*CHECK THAT "MSTR RDY DLY 2" IS SET.

	DATI	REG17,BR		;READ REG 17
	SHR				;MOVE "MSTR RDY DLY 2" INTO BIT 4
	JMPB4	.+2			;JUMP IF "MSTR RDY DLY 2" SET, SHOULD BE
	ERROR	TST,"MSTR RDY DLY 2" DIDN'T SET,
DIAG SET "MSTR RDY DLY 1" THEN GENERATED A SINGLE STEP PULSE
;*CLEAR CLOCK PHASES.
;*CLEAR "ROM 01" AND "CLR RUN".
;*CHECK THAT "LD SB" IS NOT SET.

	MOVB	CLKPLS			;CLEAR CLOCK PHASES
LDSB1:	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	ZEROS			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 01"=0
	MOVB	SETRUN			;CLEAR "CLR RUN"
	DATI	REG15,BR		;READ REG 15
	SHR				;MOVE "LD SB" BIT TO BIT 4
	JMPB4	.+2			;JUMP IF SET
	JMP	.+2			;JUMP IF CLEAR
	ERROR	LDSB1,<"LD SB" SET WITH "ROM 01" AND
"CLR RUN" AND CLOCK PHASES CLEARED>
;*SET "ROM 01" AND "CLR RUN".
;*CHECK THAT "LD SB" IS NOT SET.

LDSB2:	LDBR	CC2			;SET ROM ADR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 01"=1
	MOVB	HSDPIN			;SET "CLR RUN"
	DATI	REG15,BR		;READ REG 15
	SHR				;MOVE "LD SB" BIT TO BIT 4
	JMPB4	.+2			;JUMP IF SET
	JMP	.+2			;JUMP IF CLEAR
	ERROR	LDSB1,<"LD SB" SET WITH "ROM 01" AND
"CLR RUN" SET AND CLOCK PHASES CLEARED>
	REPEAT	TST
	TEST	224,TEST GENERATION OF "CLR AR"
;*CLEAR CLOCK PHASES.
;*SET "ROM 03".
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*SET "RUN" AND GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "CLR AR" IS NOT SET.

	LDBR	BCLKEN			;CLEAR "DX HIGH SPEED" AND ENABLE BASE CLOCK
	MOVB	REG1
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	CC8			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 03" = 1
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,AC0		;READ REG 15
	LDBR	373			;SET MASK OF ALL BUT "NOT CLR AR" BIT
	LORB	AC0			;IF BIT IS SET, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF SET (CLR AR = 0)
	ERROR	TST,"CLR AR" SET BEFORE IT SHOULD HAVE,
<DIAG CLEARED CLOCK PHASES AND SET "ROM 03" THEN
GENERATED A SINGLE STEP PULSE>
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "CLR AR" IS SET.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	LDBR	373			;SET MASK OF ALL BUT "NOT CLR AR" BIT
	MOVB	AC0			;MOVE MASK TO AC0
	DATI	REG15,BR		;READ REG 15
	LORCB	AC0			;IF BIT IS CLEARED, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF CLEARED (CLR AR = 1)
	ERROR	TST,"CLR AR" DID NOT SET,
<DIAG CLEARED CLOCK PHASES AND SET "ROM 03" THEN
GENERATED 2 SINGLE STEP PULSES>
;*GENERATE A SINGLE STEP PULSE.
;*CHECK THAT "CLR AR" IS CLEARED.

	JMPSUB	PULSE1			;GENERATE A SINGLE STEP PULSE
	DATI	REG15,AC0		;READ REG 15
	LDBR	373			;SET MASK OF ALL BUT "NOT CLR AR" BIT
	LORB	AC0			;IF BIT IS SET, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF SET (CLR AR = 0)
	ERROR	TST,"CLR AR" DID NOT CLEAR,
<DIAG CLEARED CLOCK PHASES AND SET "ROM 03" THEN
GENERATED 3 SINGLE STEP PULSES>
;*CLEAR CLOCK PHASES AND "ROM 03".
;*SET "RUN" AND GENERATE 2 SINGLE STEP PULSES.
;*CHECK THAT "CLR AR" IS NOT SET.

CLRAR1:	LDBR	BCLKEN			;ENABLE BASE CLOCK
	MOVB	REG1
	LDBR	ZEROS			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 03"=0
	LDBR	DXHISP			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN
	JMPSUB	PULSE2			;GENERATE 2 SINGLE STEP PULSES
	DATI	REG15,AC0		;READ REG 15
	LDBR	373			;SET MASK OF ALL BUT "NOT CLR AR" BIT
	LORB	AC0			;IF BIT IS SET, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF SET (CLR AR = 0)
	ERROR	CLRAR1,"CLR AR" SET WHEN IT SHOULDN'T HAVE,
<DIAG CLEARED CLOCK PHASES AND "ROM 03" THEN
GENERATED 2 SINGLE STEP PULSES>
	REPEAT	TST
	JMP	END			;JUMP AROUND SUBROUTINES

;DO A MICROBUS INIT AND CLEAR THE MAR AND ITS EXT BITS.
INITL:	LDBR	INIT+22			;SET INIT
	MOVB	IOSEL
	LDBR	22			;CLR INIT & SELECT DP
	MOVB	IOSEL
	LDMAR	0			;PUT MEMORY ADDRESS TO 0
	LDMEM	0			;CLR MEMORY LOC. 0
	RETURN

;CLEAR THE "DATA TO DEVICE" BIT.
DEVRD:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;SETUP FOR A DEVICE READ
	MOVB	MPSCR1
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN

;SET THE "DATA TO DEVICE" BIT.
DEVWR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	DTD			;SETUP FOR A DEVICE WRITE
	MOVB	MPSCR1
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN

;GENERATE FROM 2-4 SINGLE STEPS PULSES.
PULSE4:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE3:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE2:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE1:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	RETURN

;STORE THE ADDITIONAL PNT ROUTINE NUMBER IN THE RH OF GP REG 3.
;IT IS ASSUMED TO BE IN THE CURRENT MEMORY LOCATION.
SETPNT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP6			;STORE ADDITIONAL PNT ROUTINE NUMBER
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN

;STORE ERROR PRINTOUT DATA IN RH OF GP REG 2.
;IT IS ASSUMED TO BE IN THE CURRENT MEMORY LOCATION.
SETDAT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP4			;STORE DATA
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN

;ENABLE SINGLE STEPPING AND SET "DX HIGH SPEED".
ENSS:	LDBR	0			;ENABLE SINGLE STEP
	MOVB	REG1
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	RETURN

;STORE 20-BIT CORRECT AND ACTUAL DATA FOR ERROR PRINTOUTS.
;CORRECT IS ASSUMED TO BE IN MEMORY POINTED TO BY AC2 (MAR VALUE) AND
;AC3 (MARX VALUE).  ACTUAL IS ASSUMED TO BE IN AC0 (7-0), AC5 (15-8), AND
;AC4 (19-16).
STRDAT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC0,BR			;STORE DATA BITS 7-0 FOR PRINTOUT
	MOVB	MPGP14
	MOV	AC5,BR			;STORE DATA BITS 15-8 FOR PRINTOUT
	MOVB	MPGP15
	MOV	AC4,BR			;STORE DATA BITS 19-16 FOR PRINTOUT
	MOVB	MPGP17
	MOV	AC1,BR			;STORE ROM ADDR 7-0 FOR PRINTOUT
	MOVB	MPGP4
	MOV	AC2,MAR			;SET MAR TO POINT TO CORRECT DATA
	MOV	AC3,MARX		;SET MAR EXT BITS
	MOVMEM	MPGP12,I		;STORE IT FOR PRINTOUT
	MOVMEM	MPGP13,I		;STORE IT FOR PRINTOUT
	MOVMEM	MPGP16			;STORE IT FOR PRINTOUT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN

;SET "SLVE WOR END XFER" ON THE CB BOARD.  "DATA TO DEVICE" IS ASSUMED
;TO BE CLEARED.
SWEX:	LDBR	33			;SELECT	CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN

;CLEAR "SLVE WOR END XFER" ON THE CB BOARD.
CLRSEX:	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;CLEAR "STA IN"
	MOVB	TOR0
	LDBR	0			;CLEAR LOOP ENABLE
	MOVB	CSR1
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN
END:	.ECRAM
	.MEM
	0				;FIRST MEM LOC IS FOR SCRATCH
UBPAR:	0
	56
	127
	144
	272
	311
	375
CLKPHF:	20
	60
	40
	0
FLTZ1:	16
	15
	13
	7
	1
	2
	4
	10
FLTZ2:	76
	75
	73
	67
	57
	37
	1
	2
	4
	10
	20
	40
FLTZ:	376
	375
	373
	367
	357
	337
	277
	177
	1
	2
	4
	10
	20
	40
	100
	200
ROMDAT:	372				;ROM ADDR 0
	257
	1
	374				;ROM ADDR 1
	57
	2
	14				;ROM ADDR 2
	314
	3
	362				;ROM ADDR 3
	303
	4
	374				;ROM ADDR 4
	117
	5
	14				;ROM ADDR 5
	0
	0
	0				;ROM ADDR 6
	0
	0
	0				;ROM ADDR 7
	0
	0
	375				;ROM ADDR 10
	257
	11
	364				;ROM ADDR 11
	57
	12
	5				;ROM ADDR 12
	314
	13
	373				;ROM ADDR 13
	303
	14
	365				;ROM ADDR 14
	117
	15
	5				;ROM ADDR 15
	160
	16
	373				;ROM ADDR 16
	257
	11
	0				;ROM ADDR 17
	0
	0
	374				;ROM ADDR 20
	117
	1
	365				;ROM ADDR 21
	303
	2
	13				;ROM ADDR 22
	314
	3
	365				;ROM ADDR 23
	57
	4
	365				;ROM ADDR 24
	257
	5
	13				;ROM ADDR 25
	0
	0
	0				;ROM ADDR 26
	0
	0
	13				;ROM ADDR 27
	0
	4
	372				;ROM ADDR 30
	257
	11
	374				;ROM ADDR 31
	57
	12
	14				;ROM ADDR 32
	314
	13
	362				;ROM ADDR 33
	303
	14
	374				;ROM ADDR 34
	117
	15
	374				;ROM ADDR 35
	0
	16
	14				;ROM ADDR 36
	0
	10
	0				;ROM ADDR 37
	0
	0
	374				;ROM ADDR 40
	257
	1
	365				;ROM ADDR 41
	57
	2
	5				;ROM ADDR 42
	314
	3
	373				;ROM ADDR 43
	303
	4
	365				;ROM ADDR 44
	117
	5
	365				;ROM ADDR 45
	0
	6
	13				;ROM ADDR 46
	0
	0
	0				;ROM ADDR 47
	0
	0
	374				;ROM ADDR 50
	0
	11
	365				;ROM ADDR 51
	117
	12
	365				;ROM ADDR 52
	303
	13
	13				;ROM ADDR 53
	314
	14
	365				;ROM ADDR 54
	57
	15
	365				;ROM ADDR 55
	257
	16
	13				;ROM ADDR 56
	0
	10
	13				;ROM ADDR 57
	0
	15
	372				;ROM ADDR 60
	257
	1
	374				;ROM ADDR 61
	57
	2
	14				;ROM ADDR 62
	314
	3
	362				;ROM ADDR 63
	303
	4
	374				;ROM ADDR 64
	117
	5
	14				;ROM ADDR 65
	357
	6
	362				;ROM ADDR 66
	340
	7
	374				;ROM ADDR 67
	157
	10
	314				;ROM ADDR 70
	337
	11
	62				;ROM ADDR 71
	320
	12
	374				;ROM ADDR 72
	217
	13
	374				;ROM ADDR 73
	17
	14
	14				;ROM ADDR 74
	0
	0
	0				;ROM ADDR 75
	0
	0
	0				;ROM ADDR 76
	0
	0
	0				;ROM ADDR 77
	0
	0
	374				;ROM ADDR 100
	257
	1
	365				;ROM ADDR 101
	57
	2
	5				;ROM ADDR 102
	314
	3
	373				;ROM ADDR 103
	303
	4
	365				;ROM ADDR 104
	117
	5
	5				;ROM ADDR 105
	357
	6
	373				;ROM ADDR 106
	340
	7
	365				;ROM ADDR 107
	157
	10
	305				;ROM ADDR 110
	337
	11
	73				;ROM ADDR 111
	320
	12
	365				;ROM ADDR 112
	217
	13
	365				;ROM ADDR 113
	17
	14
	13				;ROM ADDR 114
	0
	0
	0				;ROM ADDR 115
	0
	0
	0				;ROM ADDR 116
	0
	0
	0				;ROM ADDR 117
	0
	0
	374				;ROM ADDR 120
	17
	1
	365				;ROM ADDR 121
	217
	2
	65				;ROM ADDR 122
	320
	3
	313				;ROM ADDR 123
	337
	4
	365				;ROM ADDR 124
	157
	5
	365				;ROM ADDR 125
	340
	6
	13				;ROM ADDR 126
	357
	7
	365				;ROM ADDR 127
	117
	10
	365				;ROM ADDR 130
	303
	11
	13				;ROM ADDR 131
	314
	12
	365				;ROM ADDR 132
	57
	13
	365				;ROM ADDR 133
	257
	14
	13				;ROM ADDR 134
	0
	0
	0				;ROM ADDR 135
	0
	0
	13				;ROM ADDR 136
	0
	5
	13				;ROM ADDR 137
	0
	13
	372				;ROM ADDR 140
	303
	1
	374				;ROM ADDR 141
	143
	2
	374				;ROM ADDR 142
	3
	3
	14				;ROM ADDR 143
	0
	4
	372				;ROM ADDR 144
	303
	5
	374				;ROM ADDR 145
	143
	6
	374				;ROM ADDR 146
	3
	7
	14				;ROM ADDR 147
	0
	0
	374				;ROM ADDR 150
	303
	11
	365				;ROM ADDR 151
	143
	12
	365				;ROM ADDR 152
	3
	13
	13				;ROM ADDR 153
	0
	14
	375				;ROM ADDR 154
	303
	15
	365				;ROM ADDR 155
	143
	16
	365				;ROM ADDR 156
	3
	17
	13				;ROM ADDR 157
	0
	10
	374				;ROM ADDR 160
	3
	1
	365				;ROM ADDR 161
	143
	2
	365				;ROM ADDR 162
	303
	3
	13				;ROM ADDR 163
	0
	4
	375				;ROM ADDR 164
	3
	5
	365				;ROM ADDR 165
	143
	6
	365				;ROM ADDR 166
	303
	7
	13				;ROM ADDR 167
	0
	0
	0				;ROM ADDR 170
	0
	0
	0				;ROM ADDR 171
	0
	0
	0				;ROM ADDR 172
	0
	0
	0				;ROM ADDR 173
	0
	0
	0				;ROM ADDR 174
	0
	0
	0				;ROM ADDR 175
	0
	0
	13				;ROM ADDR 176
	0
	5
	13				;ROM ADDR 177
	0
	6
	372				;ROM ADDR 200
	267
	1
	374				;ROM ADDR 201
	107
	2
	214				;ROM ADDR 202
	367
	3
	162				;ROM ADDR 203
	360
	4
	374				;ROM ADDR 204
	207
	5
	374				;ROM ADDR 205
	37
	6
	14				;ROM ADDR 206
	0
	0
	0				;ROM ADDR 207
	0
	0
	374				;ROM ADDR 210
	267
	11
	365				;ROM ADDR 211
	107
	12
	205				;ROM ADDR 212
	367
	13
	173				;ROM ADDR 213
	360
	14
	365				;ROM ADDR 214
	207
	15
	365				;ROM ADDR 215
	37
	16
	13				;ROM ADDR 216
	0
	10
	0				;ROM ADDR 217
	0
	0
	374				;ROM ADDR 220
	37
	1
	365				;ROM ADDR 221
	207
	2
	165				;ROM ADDR 222
	360
	3
	213				;ROM ADDR 223
	367
	4
	365				;ROM ADDR 224
	107
	5
	365				;ROM ADDR 225
	267
	6
	13				;ROM ADDR 226
	0
	0
	13				;ROM ADDR 227
	0
	5
	372				;ROM ADDR 230
	267
	11
	374				;ROM ADDR 231
	107
	12
	214				;ROM ADDR 232
	367
	13
	162				;ROM ADDR 233
	360
	14
	374				;ROM ADDR 234
	207
	15
	374				;ROM ADDR 235
	27
	16
	14				;ROM ADDR 236
	0
	10
	0				;ROM ADDR 237
	0
	0
	374				;ROM ADDR 240
	267
	1
	365				;ROM ADDR 241
	107
	2
	205				;ROM ADDR 242
	367
	3
	173				;ROM ADDR 243
	360
	4
	365				;ROM ADDR 244
	207
	5
	365				;ROM ADDR 245
	27
	6
	13				;ROM ADDR 246
	0
	0
	0				;ROM ADDR 247
	0
	0
	374				;ROM ADDR 250
	27
	11
	365				;ROM ADDR 251
	207
	12
	165				;ROM ADDR 252
	360
	13
	213				;ROM ADDR 253
	367
	14
	365				;ROM ADDR 254
	107
	15
	365				;ROM ADDR 255
	267
	16
	13				;ROM ADDR 256
	0
	10
	13				;ROM ADDR 257
	0
	15
	372				;ROM ADDR 260
	217
	1
	374				;ROM ADDR 261
	17
	2
	14				;ROM ADDR 262
	0
	0
	0				;ROM ADDR 263
	0
	0
	374				;ROM ADDR 264
	217
	5
	365				;ROM ADDR 265
	17
	6
	13				;ROM ADDR 266
	0
	4
	0				;ROM ADDR 267
	0
	0
	374				;ROM ADDR 270
	17
	11
	365				;ROM ADDR 271
	217
	12
	13				;ROM ADDR 272
	0
	10
	0				;ROM ADDR 273
	0
	0
	372				;ROM ADDR 274
	17
	15
	374				;ROM ADDR 275
	217
	16
	14				;ROM ADDR 276
	0
	14
	0				;ROM ADDR 277
	0
	0
	374				;ROM ADDR 300
	17
	1
	365				;ROM ADDR 301
	217
	2
	13				;ROM ADDR 302
	0
	0
	0				;ROM ADDR 303
	0
	0
	374				;ROM ADDR 304
	217
	5
	365				;ROM ADDR 305
	17
	6
	13				;ROM ADDR 306
	0
	4
	0				;ROM ADDR 307
	0
	0
	372				;ROM ADDR 310
	237
	11
	374				;ROM ADDR 311
	17
	12
	14				;ROM ADDR 312
	0
	13
	372				;ROM ADDR 313
	237
	14
	374				;ROM ADDR 314
	17
	15
	14				;ROM ADDR 315
	0
	10
	0				;ROM ADDR 316
	0
	0
	0				;ROM ADDR 317
	0
	0
	374				;ROM ADDR 320
	237
	1
	365				;ROM ADDR 321
	17
	2
	13				;ROM ADDR 322
	0
	3
	375				;ROM ADDR 323
	237
	4
	365				;ROM ADDR 324
	17
	5
	13				;ROM ADDR 325
	0
	0
	0				;ROM ADDR 326
	0
	0
	0				;ROM ADDR 327
	0
	0
	374				;ROM ADDR 330
	17
	11
	365				;ROM ADDR 331
	237
	12
	13				;ROM ADDR 332
	0
	13
	375				;ROM ADDR 333
	17
	14
	365				;ROM ADDR 334
	237
	15
	13				;ROM ADDR 335
	0
	10
	0				;ROM ADDR 336
	0
	0
	13				;ROM ADDR 337
	0
	14
	0				;ROM ADDR 340-707
	0
	0
	374				;ROM ADDR 710
	17
	11
	365				;ROM ADDR 711
	217
	12
	65				;ROM ADDR 712
	320
	13
	13				;ROM ADDR 713
	0
	10
	62				;ROM ADDR 714
	320
	15
	374				;ROM ADDR 715
	217
	16
	374				;ROM ADDR 716
	17
	17
	14				;ROM ADDR 717
	0
	14
	0				;ROM ADDR 720
	0
	0
	377				;ROM ADDR 721
	377
	17
	0				;ROM ADDR 722
	0
	2
	2				;ROM ADDR 723
	0
	3
	4				;ROM ADDR 724
	0
	4
	5				;ROM ADDR 725
	0
	5
	10				;ROM ADDR 726
	0
	6
	11				;ROM ADDR 727
	0
	7
	31				;ROM ADDR 730
	0
	10
	51				;ROM ADDR 731
	0
	11
	111				;ROM ADDR 732
	0
	12
	211				;ROM ADDR 733
	0
	13
	11				;ROM ADDR 734
	1
	14
	11				;ROM ADDR 735
	2
	15
	11				;ROM ADDR 736
	4
	16
	11				;ROM ADDR 737
	10
	17
	375				;ROM ADDR 740
	17
	0
	375				;ROM ADDR 741
	37
	1
	375				;ROM ADDR 742
	57
	2
	375				;ROM ADDR 743
	77
	3
	375				;ROM ADDR 744
	117
	4
	375				;ROM ADDR 745
	137
	5
	375				;ROM ADDR 746
	157
	6
	375				;ROM ADDR 747
	177
	7
	375				;ROM ADDR 750
	217
	10
	375				;ROM ADDR 751
	237
	11
	375				;ROM ADDR 752
	257
	12
	375				;ROM ADDR 753
	277
	13
	375				;ROM ADDR 754
	317
	14
	375				;ROM ADDR 755
	337
	15
	375				;ROM ADDR 756
	357
	16
	375				;ROM ADDR 757
	377
	17
	373				;ROM ADDR 760
	17
	0
	373				;ROM ADDR 761
	37
	1
	373				;ROM ADDR 762
	57
	2
	373				;ROM ADDR 763
	77
	3
	373				;ROM ADDR 764
	117
	4
	373				;ROM ADDR 765
	137
	5
	373				;ROM ADDR 766
	157
	6
	373				;ROM ADDR 767
	177
	7
	373				;ROM ADDR 770
	217
	10
	373				;ROM ADDR 771
	237
	11
	373				;ROM ADDR 772
	257
	12
	373				;ROM ADDR 773
	277
	13
	373				;ROM ADDR 774
	317
	14
	373				;ROM ADDR 775
	337
	15
	373				;ROM ADDR 776
	357
	16
	373				;ROM ADDR 777
	377
	17
.END
   