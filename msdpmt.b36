%TITLE 'STIRS TESTS FOR M8621 (DPM) BOARD'

MODULE MSDPMT	(
		LANGUAGE(BLISS36)
		) =

BEGIN

!
!			  COPYRIGHT (C) 1979 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.  
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
!
! ABSTRACT:
!
!	THIS MODULE CONTAIN THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
!	(STIRS) DIAGNOSTIC FOR THE M8621 (DPM) BOARD.  IT ALSO CONTAINS SEVERAL
!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
!	'MSDPMD' MODULES TO PRODUCE THE 'MSDPM.EXE' FILE.
!
! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
!
! AUTHOR: ARON INSINGA, CREATION DATE: 01-SEP-78
!
! MODIFIED BY:
!
!	ARON INSINGA, 23-MAY-79; VERSION 0.1
!	ARON INSINGA, 09-NOV-79; VERSION 1.1
!	ARON INSINGA, 23-MAR-80; VERSION 1.2
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    SPEC_DIALOGUE: NOVALUE,		! SPECIAL FEATURES DIALOGUE
    SPEC_ASK: NOVALUE,			! SPECIAL FEATURES ASKER
    SPEC_PRT,				! SPECIAL FEATURES PRINTER
    TEST_INIT: NOVALUE,			! INITIALIZE STATE OF KS10
    PF_DISPATCH,			! DETERMINE CAUSE OF PAGE FAIL
    PF_TRAP,				! REINITIALIZE AFTER PAGE FAIL
    PF_NAME,				! MAP PF_TRAP CODE TO A STRING
    SERIAL,				! SERIALLY GET THE VALUE IN Q
    SCAD_Q,				! GET SCAD VALUE OUT OF Q
    TST1: NOVALUE,			! DBM MUX #,,# STUCK
    TST2: NOVALUE,			! DBM MUX DP-SWAPPED STUCK
    TST3: NOVALUE,			! DBM MUX DP STUCK
    TST4: NOVALUE,			! SCAD A, SCADA S# STUCK
    TST5: NOVALUE,			! SCAD DECREMENT 0, 1, 1777
    TST6: NOVALUE,			! SCAD DOUBLE 0, 1777
    TST7: NOVALUE,			! SC STUCK
    TST8: NOVALUE,			! SCADA PTR44
    TST9: NOVALUE,			! SCADA BYTES STUCK
    TST10: NOVALUE,			! SCAD OR, B, FE STUCK
    TST11: NOVALUE,			! SCADB DP SHIFT STUCK
    TST12: NOVALUE,			! SCADB DP SIZE STUCK
    TST13: NOVALUE,			! SCADB DP EXP 0, 1777, 1000, 777
    TST14: NOVALUE,			! DBM MUX BYTES STUCK
    TST15: NOVALUE,			! DBM MUX BYTE INSERT STUCK
    TST16: NOVALUE,			! SCAD AND STUCK
    TST17: NOVALUE,			! SCAD 0, 1777 ADD, SUB, SUBB
    TST18: NOVALUE,			! VMA EASY BITS STUCK HIGH, LOW
    TST19: NOVALUE,			! DBM MUX EXP STUCK
    TST20: NOVALUE,			! MORE VMA FLAGS STUCK
    TST21: NOVALUE,			! READ & WRITE AC0 VIA VMA
    TST22: NOVALUE,			! ASK MMC IF ACCESS WAS TO M[0]
    TST23: NOVALUE,			! READ 0, -1 FROM MEM LOC 0
    TST24: NOVALUE,			! WRITE 0, -1 TO MEM LOC 0
    TST25: NOVALUE,			! DPM ADDR STUCK LOW (PHYSICAL)
    TST26: NOVALUE,			! -VMA STUCK LOW
    TST27: NOVALUE,			! MEM BITS (# CONTROL)
    TST28: NOVALUE,			! MEM BITS (DP CONTROL)
    TST29: NOVALUE,			! MEM BITS (DROM CONTROL)
    TST30: NOVALUE,			! MEM EN: #<16:17> &C.
    TST31: NOVALUE,			! BUS REQUEST A (DPM MUX SEL 2)
    TST32: NOVALUE,			! PT I/O, DPM MUX ADR IN
    TST33: NOVALUE,			! PT ADR
    TST34: NOVALUE,			! PT VALID, WRITABLE
    TST35: NOVALUE,			! VMA USER, VMA PREV LOGIC
    TST36: NOVALUE,			! PT USER & EXEC/USER PF
    TST37: NOVALUE,			! WRITABLE ON, WRITE-TEST OFF PF
    TST38: NOVALUE,			! NXM PF
    TST39: NOVALUE,			! BAD DATA PF
    TST40: NOVALUE,			! PAGING OK
    TST41: NOVALUE,			! PT SWEEP
    TST42: NOVALUE,			! CD BASIC OPERATION, ENABLES
    TST43: NOVALUE,			! CD RAM DATA I/O PINS
    TST44: NOVALUE,			! CD RAM ADDR PINS STUCK
    TST45: NOVALUE,			! CD SWEEP
    TST46: NOVALUE,			! CD COMPARATOR OUT STUCK HIGH
    TST47: NOVALUE,			! CD VALID STUCK HIGH
    TST48: NOVALUE,			! PT RAM (PAGE #, USER)
    TST49: NOVALUE,			! PT RAM (VALID, WRITABLE)
    TST50: NOVALUE,			! CD RAM (PAGE #, USER)
    TST51: NOVALUE,			! CD RAM (VALID)
    TST52: NOVALUE,			! PT RAM (CACHABLE)
    TST53: NOVALUE,			! MEMORY BUS PARITY ERROR
    TST54: NOVALUE,			! APR FLAGS
    TST55: NOVALUE,			! APR ENABLES
    TST56: NOVALUE,			! PT PARITY PINS
    TST57: NOVALUE,			! PT RAM (PARITY)
    TST58: NOVALUE,			! CD PARITY PINS
    TST59: NOVALUE,			! CD RAM (PARITY)
    TST60: NOVALUE,			! PXCT REG & MUX
    TST61: NOVALUE,			! PXCT TO XR PREV
    TST62: NOVALUE,			! SC SIGN
    TST63: NOVALUE,			! FE SIGN
    TST64: NOVALUE,			! MSEC OUTPUTS
    TST65: NOVALUE;			! MSEC TIMING

!
! INCLUDE FILES:
!

REQUIRE
    'KSU.R36';			! KS-10 MICROCODE MACROS

REQUIRE
    'STIRSD.R36';		! COMMON STIRS DECLARATIONS

REQUIRE
    'CSLMAC.R36';		! CSL INTERFACE MACROS

REQUIRE
    'REGBIT.R36';		! 8080 REGISTER BIT-NAMES

!
! MACROS:
!

MACRO
    POWER_OF_2(X) = (((X) AND ((X)-1)) EQL 0) %,	! FAMOUS "C" HACK
    SINGLE_BIT(X,Y) = POWER_OF_2((X) XOR (Y)) %,	! 1 BIT DIFFERS
    IFN = IF 0 NEQ %,					! IF NON-ZERO
    N_FLD3 = 0,12 %,					! CRAM # LOW
    N_FLD4 = 12,6 %,					! CRAM # HIGH
    SET_CRAM_ADR = SETNXT %,				! CONSOLE DISP
    LOAD_TST_U = LOADUC(TST_U_ADR,TST_U) %,		! TEST U-CODE
    CYCLE(N) = TICK(4 * (N)) %,				! T-CLK: 4 MAINT
    V_AC_DP = U_DBUS_DP U_RAM_AC U_FMWRITE %,		! AC0 <-- DP
    V_AC_DBM = U_DBUS_DBM U_RAM_AC U_FMWRITE %,		! AC0 <-- DBM
    V_D_AC = U_DBUS_RAM U_RAM_AC %,			! D <-- AC0
    V_DP_0 = U_A_T1 U_LSRC_0A U_ALU_AND %,		! DP <-- 0
    V_DP__1 = U_A_T1 U_B_T1 U_LSRC_AB U_ALU_XNOR %,	! DP <-- -1
    V_DP_D = U_LSRC_D0 U_ALU_OR %,			! DP <-- D
    V_DP_Q = U_LSRC_0Q U_ALU_OR %,			! DP <-- Q
    V_DP_T0 = U_A_T0 U_LSRC_0A U_ALU_OR %,		! DP <-- T0
    V_DP_T1 = U_A_T1 U_LSRC_0A U_ALU_OR %,		! DP <-- T1
    V_DP_R(X) = U_A(X) U_LSRC_0A U_ALU_OR %,		! DP <-- R(X)
    V_SCAD_0 = U_SN(0) U_SCADA_SN U_SCAD_A %,		! SCAD <-- 0
    V_SCAD__1 = U_SN(1777) U_SCADA_SN U_SCAD_A %,	! SCAD <-- 1777
    V_D_N(N) = 	U_N(N) U_DBM_N U_DBUS_DBM %,		! D <-- #,,#
    V_DP_NN(N) = V_D_N(N) U_LSRC_D0 U_ALU_OR %,		! DP <-- #,,#
    V_DP_N(N) =						! DP <-- 0,,#
	V_D_N(N) U_A_BRX U_LSRC_0A U_RSRC_D0 U_ALU_OR %,
    V_GEN = U_GENR U_GENL %,
    V_CHK = U_CHKR U_CHKL %,
    ERROR_LOOP(LOOPN) =
	DO (ZORK = .ZORK) WHILE %NAME(LOOP,LOOPN): %,
    EXIT_LOOP(LOOPN,ERRN) =
	IFN LOOP_CHK(ERRN) THEN LEAVE %NAME(LOOP,LOOPN) WITH 1 %,
    PAGING_ON =
	(SET_CRAM_ADR(PE1_ADR); CP_NOSS(2)) %,
    PAGING_OFF =
	(SET_CRAM_ADR(PE0_ADR); CP_NOSS(2)) %;

!
! EQUATED SYMBOLS:
!

GLOBAL BIND
    MSGFIL = UPLIT(%SIXBIT 'MSDPM',%SIXBIT 'MSG'),
    PRGNAM = UPLIT(%ASCIZ 'KS10 STIMULUS-RESPONSE DIAGNOSTIC FOR THE M8621/DPM BOARD');

GLOBAL LITERAL
    TEST_VERSION = 1,		! PDP-10 DIAGNOSTIC-STYLE VERSION #
    TEST_EDIT = 2;		! PDP-10 DIAGNOSTIC-STYLE PATCH #

LITERAL
    O1777 = %O'1777',		! 10-BIT (SCAD) -1
    O1776 = %O'1776',		! 10-BIT (SCAD) -2
    O7777 = %O'7777';		! PAGE-FAIL U-TRAP CRAM ADDR

!
! OWN STORAGE:
!

OWN
    K_MEM,			! MEMORY SIZE IN K-WORDS
    MAX_MEM_ADR,		! ADDRESS OF LAST WORD IN MEMORY
    MAX_PAG: VECTOR[2],		! LAST PAGE IN MEMORY; COMPLEMENT
    INH_CD_RAM: INITIAL(1),	! INHIBIT CACHE DIRECTORY RAM TEST
    INH_PT_RAM: INITIAL(1),	! INHIBIT PAGE TABLE RAM TEST
    FORCE_MODE: VECTOR[2]	! FORCE EXEC/USER # FIELD 4
	INITIAL(%O'20', %O'40'),
    FORCE_NAME: VECTOR[2]	! NAME FOR MODE WE GET INTO
	INITIAL(UPLIT(%ASCIZ 'EXEC'), UPLIT(%ASCIZ 'USER')),
    ERRINFO: VECTOR[15],	! ERROR MESSAGE VARIABLES
    ZORK: INITIAL(69);		! KEEP COMPILER HAPPY (DUMMY)

!
! BUILT-IN FUNCTIONS:
!

BUILTIN
    FIRSTONE;			! BLISSIFICATED JFFO

GLOBAL ROUTINE SPEC_DIALOGUE: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	ONCE-ONLY TEST-SPECIFIC INITIALIZATION DIALOGUE
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	ASK FOR MEMORY SIZE (IN K-WORDS)
!
! IMPLICIT OUTPUTS:
!
!	SET K_MEM TO MEMORY SIZE IN K-WORDS
!	SET MAX_MEM_ADR TO ADDRESS OF LAST MEMORY LOCATION
!	SET MAX_PAG[0] TO PAGE NUMBER OF LAST PAGE IN MEMORY
!	SET MAX_PAG[1] TO PAGE NUMBER OF LAST PAGE IN MEMORY
!	    WHICH IS THE COMPLEMENT OF MAX_PAG[0]
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    K_MEM = MEMSIZE();	! ASK USER ABOUT CONFIGURATION
    MAX_MEM_ADR = ((.K_MEM - 1) ^ 10) OR 1023;
    MAX_PAG[0] = .MAX_MEM_ADR ^ (-9);
    MAX_PAG[1] = (NOT .MAX_PAG[0]) AND ((1 ^ (36 - FIRSTONE(.MAX_PAG[0]))) - 1);

    END;

GLOBAL ROUTINE SPEC_ASK: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	SPECIAL-FEATURES-ACTIVATED ASKER
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	INH_CD_RAM IS SET IF WE SHOULD INHIBIT CACHE DIRECTORY RAM TEST
!	INH_PT_RAM IS SET IF WE SHOULD INHIBIT PAGE TABLE RAM TEST
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    REGISTER
	AC0 = 0;

    PRT_TXT_F('INHIBIT CACHE DIRECTORY RAM CONTENTS TESTING? ');
    INH_CD_RAM = TTI_YES;

    PRT_TXT_F('INHIBIT PAGE TABLE RAM CONTENTS TESTING? ');
    INH_PT_RAM = TTI_YES;

    END;

GLOBAL ROUTINE SPEC_PRT =

!++
! FUNCTIONAL DESCRIPTION:
!
!	SPECIAL-FEATURES-ACTIVATED PRINTER
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	IT WE DIDN'T PRINT ANYTHING THEN 1 ELSE 0
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    REGISTER
	AC0 = 0;

    IFN .INH_CD_RAM
    THEN
	PTXT_CRLF_F('CACHE DIRECTORY RAM CONTENTS TESTING INHIBITED');

    IFN .INH_PT_RAM
    THEN
	PTXT_CRLF_F('PAGE TABLE RAM CONTENTS TESTING INHIBITED');

    (.INH_CD_RAM OR .INH_PT_RAM)

    END;

!
! EQUATED SYMBOLS:
!
! THIS SHOULD BE IN 'TEST_INIT', BUT IS INCLUDED
! HERE SO THAT THE REST OF THE WORLD WILL SEE IT
!

    BIND
	SU_ADR = %O'0',		! SU = SERIAL_U
	SU = PLIT
	    (
%(0000)%    U_B_T1 V_DP_Q U_DEST_Q_MUL2 U_SKIP_DP0 U,
%(0001)%    U_B_T1 V_DP_Q U_DEST_Q_MUL2 U_SKIP_DP0 U
	    ),
	TIU = PLIT
	    (
%(3700)%    U_J(3701) V_DP_0 U_SPEC_LDACBLK U,
%(3701)%    U_J(3702) V_DP_0 U_DBUS_DP U_SPEC_LOADIR U,
%(3702)%    U_J(3703) V_DP__1 V_AC_DP U,
%(3703)%    U_J(3704) V_D_AC V_DP_D U_B_AR U_DEST_AD U,
%(3704)%    U_J(3705) U_A_AR U_B_ARX U_LSRC_0A U_ALU_OR U_DEST_AD U,
%(3705)%    U_J(3706) U_A_ARX U_B_ARX U_LSRC_AB U_ALU_ADD U_DEST_AD U,
%(3706)%    U_J(3707) U_A_ARX U_ALU_XNOR U_LSRC_0A V_AC_DP U,
%(3707)%    U_J(3710) V_D_AC V_DP_D U_B_BR U_DEST_AD U,
%(3710)%    U_J(3711) V_DP_0 U_B_BRX U_DEST_AD U_SPEC_APR_EN U,
%(3711)%    U_J(3712) V_DP_0 U_DBM_N U_N(0) U_SPEC_FLAGS U,
%(3712)%    U_J(3713) U_SPEC_CLRCLK U,
%(3713)%    U_J(3714) V_DP__1 U_SPEC_LDPI U,
%(3714)%    U_J(3714) V_DP_0 U_SPEC_MEMCLR U
	    ),
	TIU_ADR = %O'3700',	! TIU = TEST_INIT_U
	TIU_CNT = 18,		! EXTRA CLOCK PULSE NEEDED
				! + 5 MORE TO CLEAR ALLEGED PAGE FAILS?
	TIU_MEMCLR = TIU_ADR + %O'14',	! BASMAJI FUCKS WITH THIS
	PFU_ADR = %O'3757',	! PFU = PAGE_FAIL_U
	PE0_ADR = %O'3761',	! PE0 = PAGING_ENABLE_0
	PE1_ADR = %O'3763',	! PE1 = PAGING_ENABLE_1
	PFU = PLIT
	    (
%(3757)%    U_J(3760) U_SKIP_INT U,	! FIND REASON FOR PAGE FAIL
%(3760)%    U_DBM_PF_DISP U_DBUS_DBM V_DP_D U_DISP_DP_LEFT U,
%(3761)%    U_J(3762) V_DP_0 U,		! DISABLE PAGING
%(3762)%    V_DP_0 U_SPEC_APR_EN U,
%(3763)%    U_J(3764) V_DP_N(10000) U,	! ENABLE PAGING
%(3764)%    V_DP_N(10000) U_SPEC_APR_EN U
	    ),
	PHU_ADR = %O'3777',	! PHU = PAGE_HANG_U
	PHU = PLIT
	    (
%(7777)%    U_J(7777) U_NO_CLKR U_NO_CLKL U
	    );

GLOBAL ROUTINE TEST_INIT: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	ONCE-ONLY INITIALIZATIONS FOR ALL TESTS
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	ERROR REPORTING IS ENABLED
!	AN 'MR' (MASTER RESET) IS DONE
!	THE MILLISECOND CLOCK MICRO-INTERRUPT IS DISABLED
!	THE SERIAL & INITIALIZATION MICROCODE IS LOADED
!	AC BLOCK NUMBER = 0
!	IR = 0
!	USER FLAG = 0
!	USER I/O FLAG = 0
!	CLEAR MILLISECOND CLOCK
!	PI LEVEL = 7 (NON-INTERRUPTABLE)
!
!	THE FOLLOWING REGISTERS IN THE 2901 ARE SACRED TO THE WORLD:
!	AR (2901 REG 3) = 3777777777777.0 = -1
!	    ((D_INPUT XOR AR) EQL 0) EQV (D_INPUT EQL 777777777777)
!	ARX (2901 REG 4) = 3777777777776.0 = -2
!	    ((D_INPUT XOR ARX) EQL 0) EQV (D_INPUT EQL 777777777776)
!	BR (2901 REG 5) = 0000000000001.0 = 1
!	BRX (2901 REG 6) = 0000000000000.0 = 0
!
!--

    BEGIN

    RPT_ERR_FLAG = 0;
    MR();			! DO A RESET TO RESET MOST OF THE WORLD
    WRT212(0);			! CLEAR CSL EXECUTE
    TE(0);			! DISABLE MSEC CLK MICRO-INTERRUPTS
    CE(0);			! DISABLE CACHE
    SEND_NUL();			! FLUSH IT DOWN THE TUBES (DO IT NOW!)
    RPT_ERR_FLAG = 1;
    SC_0();			! TURN OFF SOFT CRAM ERROR RECOVERY
    PE(0);			! SET PARITY DETECTION FLAG BITS
				!   1: DP, PAGE TABLE; 2: CRAM; 4: ?
    MEM_DEPOSIT(0,6969696969);	! ANYTHING TO GET VALID PARITY IN LOC 0
    LOADUC(SU_ADR,SU);		! SHIFT DATA OUT 2901 SIGN-BIT
    LOADUC(TIU_ADR,TIU);	! RANDOM INITIALIZATION STUFF
    LOADUC(PFU_ADR,PFU);	! PAGE FAULT; DETERMINE CAUSE
    LOADUC(PHU_ADR,PHU);	! PAGE FAULT; DIE CONSISTANTLY
    SET_CRAM_ADR(TIU_ADR);
    CP_NOSS(TIU_CNT);
    PAGING_OFF;
    SEND_NUL();			! FLUSH IT DOWN THE TUBES (DO IT NOW!)

    END;

ROUTINE PF_DISPATCH =

!++
! FUNCTIONAL DESCRIPTION:
!
!	DETERMINE CAUSE OF PAGE FAIL
!
!	THE REAL PAGE FAIL DISPATCH DOESN'T WORK -- WE
!	HAVE TO FAKE IT JUST LIKE THE KS10 MICROCODE BY
!	ROUTING THE PAGE FAIL CODE THROUGH THE ADDER
!	AND DISPATCHING ON THE DATA PATH (LEFT)
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	PAGE FAIL DISPATCH ADDRESS
!
! SIDE EFFECTS:
!
!	THE PAGE FAIL DISPATCH MICROCODE IS EXECUTED
!
!--

    BEGIN

    SET_CRAM_ADR(PFU_ADR);

    IF STEP_U_NEXT(1)		! U-CODE SKIP SETS LOW BIT OF CRAM ADDR
    THEN
	-1			! INTERRUPT REQUEST
    ELSE
	STEP_U_NEXT(1)		! SOME OTHER CAUSE

    END;

ROUTINE PF_TRAP =

!++
! FUNCTIONAL DESCRIPTION:
!
!	DETERMINE CAUSE OF, AND REINITIALIZE AFTER, PAGE FAIL
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	PAGE FAIL DISPATCH ADDRESS
!
! SIDE EFFECTS:
!
!	AN 'MR' (MASTER RESET) IS DONE
!	THE 'TEST_INIT' MICROCODE IS REEXECUTED
!
!--

    BEGIN

    LOCAL
	PF_CAUSE;

    PF_CAUSE = PF_DISPATCH();	! FIND OUT WHY IT HAPPENED
    MR();			! DO A RESET TO RESET MOST OF THE WORLD
    SET_CRAM_ADR(TIU_ADR);	!   AND DO ALL OF THE OTHER CRAP AGAIN
    CP_NOSS(TIU_CNT);
    SEND_NUL();			! FLUSH IT DOWN THE TUBES (DO IT NOW!)

    .PF_CAUSE

    END;

ROUTINE PF_NAME(PF_CAUSE) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TRANSLATE PAGE FAIL DISPATCH TO A MEANINGFUL STRING
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	ADDRESS OF ASCIZ STRING DESCRIBING PAGE FAIL CAUSE
!	SEE KS10 U-CODE AT LABEL 'PFD' (SEQUENCE 7968)
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    CASE .PF_CAUSE FROM -1 TO %O'17' OF
	SET
	[-1]:		UPLIT(%ASCIZ 'INTERRUPT REQUEST');
	[%O'01']:	UPLIT(%ASCIZ 'INTERRUPT OR TIMEOUT');
	[%O'03']:	UPLIT(%ASCIZ 'BAD DATA');
	[%O'05']:	UPLIT(%ASCIZ 'NXM ERROR');
	[%O'07']:	UPLIT(%ASCIZ 'NXM AND BAD DATA');
	[%O'10']:	UPLIT(%ASCIZ 'WRITE VIOLATION');
	[%O'11']:	UPLIT(%ASCIZ 'NO PAGE FAIL OCCURED');
	[%O'12']:	UPLIT(%ASCIZ 'PAGE NOT VALID');
	[%O'13']:	UPLIT(%ASCIZ 'EXEC/USER MISMATCH');
	[INRANGE]:	UPLIT(%ASCIZ 'UNKNOWN PAGE FAIL DISPATCH');
	[OUTRANGE]:	UPLIT(%ASCIZ 'INVALID PAGE FAIL DISPATCH');
	TES

    END;

ROUTINE SERIAL( %( SKIP_COUNT, )% EXAMINE_COUNT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	SHIFT Q LEFT 2+SKIP_COUNT BITS TO GET BIT #SKIP_COUNT IN 2901 SIGN.
!	SHIFT Q LEFT EXAMINE_COUNT TIMES, CHECKING THE SIGN BIT
!	AND RECONSTRUCTING THE VALUE.
!
! FORMAL PARAMETERS:
!
!	EXAMINE_COUNT IS THE NUMBER OF BITS IN THE FIELD WE WANT
!
! IMPLICIT INPUTS:
!
!	CRAM ADDRESS SHOULD BE AT 0
!	THE NUMBER WE WANT IS IN Q
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	THE FIELD THAT WAS IN Q, RIGHT JUSTIFIED
!
! SIDE EFFECTS:
!
!	Q IS MUNGED UP
!
!--

    BEGIN

    LOCAL
	Q_REG;

    Q_REG = 0;
    CP_NOSS(2 %( + .SKIP_COUNT )% );
    INCR Q_BIT_NUMBER FROM 1 TO .EXAMINE_COUNT DO
	Q_REG = (.Q_REG^1) OR STEP_U_NEXT(1);

    .Q_REG

    END;

ROUTINE SCAD_Q =

!++
! FUNCTIONAL DESCRIPTION:
!
!	USE SERIAL TO GET THE VALUE OF Q AND PICK THE SCAD
!	VALUE OUT OF THE HIGH HALF AND REARRANGE THE BITS.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE OUTPUT OF THE SCAD HAS BEEN LOADED INTO Q
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	VALUE OF THE OUTPUT OF THE SCAD THAT WAS IN Q
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	CEREAL_VAL,
	SCAD_VAL;

    CEREAL_VAL = SERIAL(18);
    SCAD_VAL = 0;
    SCAD_VAL<9,1> = .CEREAL_VAL<0,1>;
    SCAD_VAL<0,9> = .CEREAL_VAL<9,9>;

    .SCAD_VAL

    END;

GLOBAL ROUTINE TST1: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 THRU THE #,,# INPUT TO DBM MUX
!	PASS -1 THRU THE #,,# INPUT TO DBM MUX
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_CP = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'4',
	TST_U = PLIT
	    (
%(0004)%    U_N(0) U_DBM_N U_DBUS_DBM V_DP_D U_DEST_Q_AD U_SKIP_ADEQ0 U,
%(0005)%    U_J(6) U_N(777777) U_DBM_N U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0006)%    U_A_AR U_LSRC_AQ U_ALU_XOR U_SKIP_ADEQ0 U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 1, 0,
	    TUA_1, 2, -1
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    IF STEP_U_NEXT(.INFO[.SUBTEST,INFO_CP]) EQL 0
	    THEN
	    (
		ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
		ACT = SERIAL(36);
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,12,ERRINFO
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 FROM #-FIELD THRU DBM MUX
!*RESPONSE:
!*	OUTPUT OF DBM MUX SHOULD BE \O0

!]ERROR 1
!]DBM_N NTWK

!]NO ERROR 1
!]DBM_N NTWK

!]ERROR 2
!]DBM_SEL_N NTWK

!]NO ERROR 2
!]DBM_SEL_N NTWK

    END;

GLOBAL ROUTINE TST2: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 THRU THE DP-SWAPPED INPUT TO DBM MUX
!	PASS -1 THRU THE DP-SWAPPED INPUT TO DBM MUX
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_CP = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'13',
	TST_U = PLIT
	    (
%(0013)%    U_J(14) V_DP_0 U_DBM_DP_SWAP V_AC_DBM U,
%(0014)%    V_D_AC V_DP_D U_DEST_Q_AD U_SKIP_ADEQ0 U,
%(0015)%    U_J(16) V_DP__1 U_DBM_DP_SWAP V_AC_DBM U,
%(0016)%    U_J(17) V_D_AC V_DP_D U_DEST_Q_AD U,
%(0017)%    U_ALU_XOR U_LSRC_AQ U_A_AR U_SKIP_ADEQ0 U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 2;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 2, 0,
	    TUA_1, 3, -1
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    IF STEP_U_NEXT(.INFO[.SUBTEST,INFO_CP]) EQL 0
	    THEN
	    (
		ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
		ACT = SERIAL(36);
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,12,ERRINFO
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 ONTO DP-SWAPPED AND THRU DBM MUX
!*RESPONSE:
!*	OUTPUT OF DBM MUX SHOULD BE \O0

!]ERROR 1
!]DBM_DP_SWAP NTWK

!]NO ERROR 1
!]DBM_DP_SWAP NTWK

!]ERROR 2
!]DBM_SEL_DP_SWAP NTWK

!]NO ERROR 2
!]DBM_SEL_DP_SWAP NTWK

    END;

GLOBAL ROUTINE TST3: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 THRU THE DP INPUT TO DBM MUX
!	PASS -1 THRU THE DP INPUT TO DBM MUX
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_CP = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'26',
	TST_U = PLIT
	    (
%(0026)%    U_J(27) V_DP_0 U_DBM_DP V_AC_DBM U,
%(0027)%    V_D_AC V_DP_D U_DEST_Q_AD U_SKIP_ADEQ0 U,
%(0030)%    U_J(31) V_DP__1 U_DBM_DP_SWAP V_AC_DBM U,
%(0031)%    U_J(32) V_D_AC V_DP_D U_DEST_Q_AD U,
%(0032)%    U_ALU_XOR U_LSRC_AQ U_A_AR U_SKIP_ADEQ0 U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 2;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 2, 0,
	    TUA_1, 3, -1
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    IF STEP_U_NEXT(.INFO[.SUBTEST,INFO_CP]) EQL 0
	    THEN
	    (
		ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
		ACT = SERIAL(36);
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,12,ERRINFO
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 ONTO DP AND THRU DBM MUX
!*RESPONSE:
!*	OUTPUT OF DBM MUX SHOULD BE \O0

!]ERROR 1
!]DBM_DP NTWK

!]NO ERROR 1
!]DBM_DP NTWK

!]ERROR 2
!]DBM_SEL_DP NTWK

!]NO ERROR 2
!]DBM_SEL_DP NTWK

    END;

GLOBAL ROUTINE TST4: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 FROM SCAD # THRU A-MUX TO Q
!	PASS 1777 FROM SCAD # THRU A-MUX TO Q
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_CP = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'37',
	TST_U = PLIT
	    (
%(0037)%    V_SCAD_0 U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0040)%    V_SCAD__1 U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 1, 0,
	    TUA_1, 1, O1777
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(.INFO[.SUBTEST,INFO_CP]);
	    ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = SCAD_Q();
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,12,ERRINFO
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	PASS \O0 FROM # THRU SCAD A-MUX AND SCAD
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O0

!]ERROR 1
!]SCAD_A SCADA_SN DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_A SCADA_SN DBM_SCAD NTWK

!]ERROR 2
!]SCAD_A SCADA_SEL_SN DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_A SCADA_SEL_SN DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST5: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 FROM SCAD # TO A-MUX TO SCAD AND DECREMENT
!	PASS 1 FROM SCAD # TO A-MUX TO SCAD AND DECREMENT
!	PASS 1777 FROM SCAD # TO A-MUX TO SCAD AND DECREMENT
!
!--

    BEGIN

    MACRO
	INFO_N = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'41',
	TST_U = PLIT
	    (
%(0041)%    U_SN(0) U_SCADA_SN U_SCAD_A_DEC U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0042)%    U_SN(1) U_SCADA_SN U_SCAD_A_DEC U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0043)%    U_SN(1777) U_SCADA_SN U_SCAD_A_DEC U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    );

    OWN
	INFO: BLOCKVECTOR[3,2] INITIAL
	(
	    0, O1777,
	    1, 0,
	    O1777, O1776
	);

    LOAD_TST_U;
    OK = 1;

    INCR SUBTEST FROM 0 TO 2 DO
	ERROR_LOOP(1)
	(
	    ERRINFO[0] = .INFO[.SUBTEST,INFO_N];
	    ERRINFO[1] = COR = .INFO[.SUBTEST,INFO_COR];
	    SET_CRAM_ADR(TST_U_ADR + .SUBTEST);
	    CP(1);
	    ACT = SCAD_Q();
	    IF .ACT NEQ .COR
	    THEN
	    (
		ERRCAS(1,1,.COR,.ACT,4,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	PASS \O0 FROM # TO SCAD AND DECREMENT
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O1

!]ERROR 1
!]SCAD_A_DEC SCADA_SN SCADA_SEL_SN DBM_SCAD DBM_SEL_SCAD NTWK

!]NO ERROR 1
!]SCAD_A_DEC SCADA_SN SCADA_SEL_SN DBM_SCAD DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST6: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 FROM SCAD # TO A-MUX TO SCAD AND DOUBLE
!	PASS 1777 FROM SCAD # TO A-MUX TO SCAD AND DOUBLE
!
!--

    BEGIN

    MACRO
	INFO_N = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'44',
	TST_U = PLIT
	    (
%(0044)%    U_SN(0) U_SCADA_SN U_SCAD_A_MUL2 U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0045)%    U_SN(1777) U_SCADA_SN U_SCAD_A_MUL2 U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    );

    OWN
	INFO: BLOCKVECTOR[2,2] INITIAL
	(
	    0, 0,
	    O1777, O1776
	);

    LOAD_TST_U;
    OK = 1;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    ERRINFO[0] = .INFO[.SUBTEST,INFO_COR];
	    ERRINFO[1] = COR = .INFO[.SUBTEST,INFO_COR];
	    SET_CRAM_ADR(TST_U_ADR + .SUBTEST);
	    CP(1);
	    ACT = SCAD_Q();
	    IF .ACT NEQ .COR
	    THEN
	    (
		ERRCAS(1,1,.COR,.ACT,4,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	PASS \O0 FROM # TO SCAD AND DOUBLE
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O1

!]ERROR 1
!]SCAD_A_MUL2 SCADA_SN SCADA_SEL_SN DBM_SCAD DBM_SEL_SCAD NTWK

!]NO ERROR 1
!]SCAD_A_MUL2 SCADA_SN SCADA_SEL_SN DBM_SCAD DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST7: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0 INTO SC, THEN PASS IT THRU SCAD
!	LOAD 1777 INTO SC, THEN PASS IT THRU SCAD
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'46',
	TST_U = PLIT
	    (
%(0046)%    U_J(50) V_SCAD_0 U_LOADSC U,
%(0047)%    U_J(50) V_SCAD__1 U_LOADSC U,
%(0050)%    U_SCADA_SC U_SCAD_A U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    OWN
	INFO: BLOCKVECTOR[2,2] INITIAL
	(
	    TUA_0, 0,
	    TUA_1, O1777
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = SCAD_Q();
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,4,ERRINFO		! VERSION 1.1
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 INTO SC, THEN PASS IT THRU SCAD
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O0

!]ERROR 1
!]SCAD_A SC SCADA_SC SCADA_SN DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_A SC SCADA_SC SCADA_SN DBM_SCAD NTWK

!]ERROR 2
!]SCAD_A SC_EN SCADA_SEL_SC SCADA_SEL_SN DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_A SC_EN SCADA_SEL_SC SCADA_SEL_SN DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST8: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 44 FROM SCADA TO Q WITH 0 ON DP, 0 IN SC
!	PASS 44 FROM SCADA TO Q WITH -1 ON DP, 1777 IN SC
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_DP = 2,0,36,0 %,
	INFO_SC = 3,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'54',
	TST_U = PLIT
	    (
%(0054)%    U_J(55) V_SCAD_0 U_LOADSC U,
%(0055)%    U_J(60) V_DP_0 U_SCADA_PTR44 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0056)%    U_J(57) V_SCAD__1 U_LOADSC U,
%(0057)%    U_J(60) V_DP__1 U_SCADA_PTR44 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0060)%    V_D_AC V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 2;

    OWN
	INFO: BLOCKVECTOR[2,4] INITIAL
	(
	    TUA_0, %O'0440', 0, 0,
	    TUA_1, %O'1447', -1, O1777
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(3);
	    ERRINFO[1] = .INFO[.SUBTEST,INFO_DP];
	    ERRINFO[2] = .INFO[.SUBTEST,INFO_SC];
	    ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = SCAD_Q();
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,4,ERRINFO		! VERSION 1.1
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	GET POINTER 44 FROM SCADA WITH \O1 ON DP, \O2 IN SC
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O0

!]ERROR 1
!]SCAD_A SCADA_44 SC SCADA_SC SCADA_SN DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_A SCADA_44 SC SCADA_SC SCADA_SN DBM_SCAD NTWK

!]ERROR 2
!]SCAD_A SCADA_SEL_44 SC_EN SCADA_SEL_SC SCADA_SEL_SN DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_A SCADA_SEL_44 SC_EN SCADA_SEL_SC SCADA_SEL_SN DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST9: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 ON DP THRU SCADA BYTES
!	PASS -1 ON DP THRU SCADA BYTES
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_DP = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT,
	COR_BYTE,
	ACT_BYTE,
	COR_PTR,
	ACT_PTR;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'63',
	TST_U = PLIT
	    (
%(0063)%    U_J(75) V_DP_0 U_SCADA_BYTE5 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0064)%    U_J(75) V_DP_0 U_SCADA_BYTE4 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0065)%    U_J(75) V_DP_0 U_SCADA_BYTE3 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0066)%    U_J(75) V_DP_0 U_SCADA_BYTE2 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0067)%    U_J(75) V_DP_0 U_SCADA_BYTE1 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0070)%    U_J(75) V_DP__1 U_SCADA_BYTE5 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0071)%    U_J(75) V_DP__1 U_SCADA_BYTE4 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0072)%    U_J(75) V_DP__1 U_SCADA_BYTE3 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0073)%    U_J(75) V_DP__1 U_SCADA_BYTE2 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0074)%    U_J(75) V_DP__1 U_SCADA_BYTE1 U_SCAD_A U_DBM_SCAD V_AC_DBM U,
%(0075)%    V_D_AC V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 5;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 0, 0,
	    TUA_1, -1, -2
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    ERRINFO[1] = .INFO[.SUBTEST,INFO_DP];
	    ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = 0;
	    ACT_PTR = POINT(ACT,36,7);
	    INCR BYTE_NUMBER FROM 0 TO 4 DO
	    (
		SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA] + .BYTE_NUMBER);
		CP(2);
		REPLACEI(ACT_PTR,SERIAL(7));
	    );
	    IF .ACT NEQ .COR
	    THEN
	    (
		ERMCAS(1,.COR,.ACT,12,ERRINFO);
		OK = 0;
		COR_PTR = POINT(COR,36,7);
		ACT_PTR = POINT(ACT,36,7);
		INCR BYTE_NUMBER FROM 0 TO 4 DO
		(
		    COR_BYTE = SCANI(COR_PTR);
		    ACT_BYTE = SCANI(ACT_PTR);
		    FAILURE(.BYTE_NUMBER*2+SINGLE_BIT(.COR_BYTE,.ACT_BYTE)+1);
		);
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN INCR I FROM 1 TO 10 DO NOERR(.I);

!*MESSAGE 1
!*STIMULUS:
!*	PUT \O1 ON DP AND PICK UP EACH BYTE FROM SCADA
!*RESPONSE:
!*	WORD REBUILT FROM 5 BYTES SHOULD BE \O0

!]ERROR 1
!]SCAD_A SCADA_44 SCADA_BYTE1 DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_A SCADA_44 SCADA_BYTE1 DBM_SCAD NTWK

!]ERROR 2
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE1 DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE1 DBM_SEL_SCAD NTWK

!]ERROR 3
!]SCAD_A SCADA_44 SCADA_BYTE2 DBM_SCAD NTWK

!]NO ERROR 3
!]SCAD_A SCADA_44 SCADA_BYTE2 DBM_SCAD NTWK

!]ERROR 4
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE2 DBM_SEL_SCAD NTWK

!]NO ERROR 4
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE2 DBM_SEL_SCAD NTWK

!]ERROR 5
!]SCAD_A SCADA_44 SCADA_BYTE3 DBM_SCAD NTWK

!]NO ERROR 5
!]SCAD_A SCADA_44 SCADA_BYTE3 DBM_SCAD NTWK

!]ERROR 6
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE3 DBM_SEL_SCAD NTWK

!]NO ERROR 6
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE3 DBM_SEL_SCAD NTWK

!]ERROR 7
!]SCAD_A SCADA_44 SCADA_BYTE4 DBM_SCAD NTWK

!]NO ERROR 7
!]SCAD_A SCADA_44 SCADA_BYTE4 DBM_SCAD NTWK

!]ERROR 8
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE4 DBM_SEL_SCAD NTWK

!]NO ERROR 8
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE4 DBM_SEL_SCAD NTWK

!]ERROR 9
!]SCAD_A SCADA_44 SCADA_BYTE5 DBM_SCAD NTWK

!]NO ERROR 9
!]SCAD_A SCADA_44 SCADA_BYTE5 DBM_SCAD NTWK

!]ERROR 10
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE5 DBM_SEL_SCAD NTWK

!]NO ERROR 10
!]SCAD_A SCADA_SEL_44 SCADA_SEL_BYTE5 DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST10: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0 INTO FE, THEN PASS IT THRU SCAD BY OR'ING WITH 0
!	LOAD 1777 INTO FE, THEN PASS IT THRU SCAD BY OR'ING WITH 0
!	LOAD 0 INTO FE, THEN OR WITH 1777
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_FE = 2,0,36,0 %,
	INFO_A = 3,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1700',
	TST_U = PLIT
	    (
%(1700)%    U_J(1702) V_SCAD_0 U_LOADFE U,
%(1701)%    U_J(1702) V_SCAD__1 U_LOADFE U,
%(1702)%    U_SCADA_SN U_SCADB_FE U_SCAD_OR U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(1703)%    U_J(1704) V_SCAD_0 U_LOADFE U,
%(1704)%    U_SN(1777) U_SCADA_SN U_SCADB_FE U_SCAD_OR U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1,
	TUA_2 = TST_U_ADR + 3;

    OWN
	INFO: BLOCKVECTOR[3,4] INITIAL
	(
	    TUA_0, 0, 0, 0,
	    TUA_1, O1777, O1777, 0,
	    TUA_2, O1777, 0, O1777
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 2 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ERRINFO[2] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = SCAD_Q();
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_FE];
		ERRINFO[1] = .INFO[.SUBTEST,INFO_A];
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,4,ERRINFO		! VERSION 1.1
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 INTO FE; OR WITH \O1
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O2

!]ERROR 1
!]SCAD_OR SCADB_FE SCADA_SN SCAD_A SCADA_SC SC FE DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_OR SCADB_FE SCADA_SN SCAD_A SCADA_SC SC FE DBM_SCAD NTWK

!]ERROR 2
!]SCAD_OR SCADB_SEL_FE SCADA_SEL_SN SCAD_A SCADA_SEL_SC SC_EN FE_EN DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_OR SCADB_SEL_FE SCADA_SEL_SN SCAD_A SCADA_SEL_SC SC_EN FE_EN DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST11: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0 ONTO DP AND PASS SCADB SHIFT THRU
!	LOAD -1 ONTO DP AND PASS SCADB SHIFT THRU
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_DP = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'104',
	TST_U = PLIT
	    (
%(0104)%    U_J(106) V_DP_0 U_SN(0) U_SCADA_SN U_SCADB_SHIFT U_SCAD_OR U_DBM_SCAD V_AC_DBM U,
%(0105)%    U_J(106) V_DP__1 U_SN(0) U_SCADA_SN U_SCADB_SHIFT U_SCAD_OR U_DBM_SCAD V_AC_DBM U,
%(0106)%    V_D_AC V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 0, 0,
	    TUA_1, O1777, -1
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ERRINFO[1] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = SCAD_Q();
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_DP];
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,4,ERRINFO		! VERSION 1.1
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 ONTO DP; PASS IT THRU SCADB SHIFT-COUNT
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O1

!]ERROR 1
!]SCAD_OR SCADB_SHIFT SCADA_SN DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_OR SCADB_SHIFT SCADA_SN DBM_SCAD NTWK

!]ERROR 2
!]SCAD_OR SCADB_SEL_SHIFT SCADA_SEL_SN DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_OR SCADB_SEL_SHIFT SCADA_SEL_SN DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST12: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0 ONTO DP AND PASS SCADB SIZE THRU
!	LOAD -1 ONTO DP AND PASS SCADB SIZE THRU
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_DP = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'111',
	TST_U = PLIT
	    (
%(0111)%    U_J(113) U_SN(0) U_SCADA_SN U_SCADB_SIZE U_SCAD_OR U_DBM_SCAD V_AC_DBM U,
%(0112)%    U_J(113) V_DP__1 U_SN(0) U_SCADA_SN U_SCADB_SIZE U_SCAD_OR U_DBM_SCAD V_AC_DBM U,
%(0113)%    V_D_AC V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 0, 0,
	    TUA_1, %O'0770', -1
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ERRINFO[1] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = SCAD_Q();
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_DP];
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,4,ERRINFO		! VERSION 1.1
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 ONTO DP, PASS THRU SCADB BYTE-SIZE
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O1

!]ERROR 1
!]SCAD_OR SCADB_SIZE SCADA_SN DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_OR SCADB_SIZE SCADA_SN DBM_SCAD NTWK

!]ERROR 2
!]SCAD_OR SCADB_SEL_SIZE SCADA_SEL_SN DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_OR SCADB_SEL_SIZE SCADA_SEL_SN DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST13: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0 ONTO DP AND PASS SCADB EXP THRU
!	LOAD -1 ONTO DP AND PASS SCADB EXP THRU
!	LOAD 400000,,400000 ONTO DP AND PASS SCADB EXP THRU
!	LOAD 377777,,377777 ONTO DP AND PASS SCADB EXP THRU
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_CP = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %,
	INFO_DP = 3,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'116',
	TST_U = PLIT
	    (
%(0116)%    U_J(123) V_DP_0 U_SN(0) U_SCADA_SN U_SCADB_EXP U_SCAD_OR U_DBM_SCAD V_AC_DBM U,
%(0117)%    U_J(123) V_DP__1 U_SN(0) U_SCADA_SN U_SCADB_EXP U_SCAD_OR U_DBM_SCAD V_AC_DBM U,
%(0120)%    U_J(122) U_N(400000) U_DBM_N U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0121)%    U_J(122) U_N(377777) U_DBM_N U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0122)%    U_J(123) V_DP_Q U_SN(0) U_SCADA_SN U_SCADB_EXP U_SCAD_OR U_DBM_SCAD V_AC_DBM U,
%(0123)%    V_D_AC V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1,
	TUA_2 = TST_U_ADR + 2,
	TUA_3 = TST_U_ADR + 3;

    OWN
	INFO: BLOCKVECTOR[4,4] INITIAL
	(
	    TUA_0, 2, 0, 0,
	    TUA_1, 2, 0, -1,
	    TUA_2, 3, %O'377', %O'400000400000',
	    TUA_3, 3, %O'377', %O'377777377777'
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 3 DO
	ERROR_LOOP(1)
	(
	    ERRINFO[1] = COR = .INFO[.SUBTEST,INFO_COR];
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(.INFO[.SUBTEST,INFO_CP]);
	    ACT = SCAD_Q();
	    IF .ACT NEQ .COR
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_DP];
		ERRCAS(1,1,.COR,.ACT,4,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 ONTO DP, PASS THRU SCADB EXP
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O1

!]ERROR 1
!]SCADB_EXP SCAD_OR SCADA_SN SCADA_SEL_SN DBM_SCAD DBM_SEL_SCAD NTWK

!]NO ERROR 1
!]SCADB_EXP SCAD_OR SCADA_SN SCADA_SEL_SN DBM_SCAD DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST14: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0 ONTO DP & SCAD; PASS THRU BYTES INPUT TO DBM MUX
!	LOAD -1 ONTO DP & SCAD; PASS THRU BYTES INPUT TO DBM MUX
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_CP = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'131',
	TST_U = PLIT
	    (
%(0131)%    U_J(132) V_DP_0 V_SCAD_0 U_DBM_BYTES V_AC_DBM U,
%(0132)%    V_D_AC V_DP_D U_DEST_Q_AD U_SKIP_ADEQ0 U,
%(0133)%    U_J(134) V_DP__1 V_SCAD__1 U_DBM_BYTES V_AC_DBM U,
%(0134)%    U_J(135) V_D_AC V_DP_D U_DEST_Q_AD U,
%(0135)%    U_A_AR U_LSRC_AQ U_ALU_XOR U_SKIP_ADEQ0 U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 2;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 2, 0,
	    TUA_1, 3, -1
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    IF STEP_U_NEXT(.INFO[.SUBTEST,INFO_CP]) EQL 0
	    THEN
	    (
		ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
		ACT = SERIAL(36);
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,12,ERRINFO
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 ONTO DP & SCAD; PASS THRU BYTES INPUT TO DBM MUX
!*RESPONSE:
!*	OUTPUT OF DBM MUX SHOULD BE \O1

!]ERROR 1
!]DBM_BYTES SCADA_SN SCADA_SEL_SN SCAD_A NTWK

!]NO ERROR 1
!]DBM_BYTES SCADA_SN SCADA_SEL_SN SCAD_A NTWK

!]ERROR 2
!]DBM_SEL_BYTES SCADA_SN SCADA_SEL_SN SCAD_A NTWK

!]NO ERROR 2
!]DBM_SEL_BYTES SCADA_SN SCADA_SEL_SN SCAD_A NTWK

    END;

GLOBAL ROUTINE TST15: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD -1 ONTO DP, 0 THRU SCAD; INSERT INTO ALL BYTES
!	LOAD 0 ONTO DP, 1777 THRU SCAD; INSERT INTO ALL BYTES
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_DP = 2,0,36,0 %,
	INFO_SCAD = 3,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'140',
	TST_U = PLIT
	    (
%(0140)%    U_J(141) U_A_T0 U_B_T0 U_LSRC_AB U_ALU_XNOR U_DEST_AD U,
%(0141)%    U_J(142) V_SCAD_0 U_DBM_DP U_BYTE_1 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0142)%    U_J(143) V_SCAD_0 U_DBM_DP U_BYTE_2 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0143)%    U_J(144) V_SCAD_0 U_DBM_DP U_BYTE_3 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0144)%    U_J(145) V_SCAD_0 U_DBM_DP U_BYTE_4 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0145)%    U_J(146) V_SCAD_0 U_DBM_DP U_BYTE_5 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0146)%    U_J(147) V_DP_T0 U_DEST_Q_AD U,
%(0147)%    U_A_AR U_LSRC_AQ U_ALU_ADD U_SKIP_ADEQ0 U,
%(0150)%    U_J(151) U_B_T0 U_LSRC_0B U_ALU_AND U_DEST_AD U,
%(0151)%    U_J(152) V_SCAD__1 U_DBM_DP U_BYTE_1 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0152)%    U_J(153) V_SCAD__1 U_DBM_DP U_BYTE_2 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0153)%    U_J(154) V_SCAD__1 U_DBM_DP U_BYTE_3 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0154)%    U_J(155) V_SCAD__1 U_DBM_DP U_BYTE_4 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0155)%    U_J(156) V_SCAD__1 U_DBM_DP U_BYTE_5 U_DBUS_DBM U_A_T0 U_B_T0 V_DP_D U_DEST_A U,
%(0156)%    U_J(157) V_DP_T0 U_DEST_Q_AD U,
%(0157)%    U_A_ARX U_LSRC_AQ U_ALU_XOR U_SKIP_ADEQ0 U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 8;

    OWN
	INFO: BLOCKVECTOR[2,4] INITIAL
	(
	    TUA_0, 1, -1, 0,
	    TUA_1, -2, 0, O1777
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    IF STEP_U_NEXT(8) EQL 0
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_DP];
		ERRINFO[1] = .INFO[.SUBTEST,INFO_SCAD];
		ERRINFO[2] = COR = .INFO[.SUBTEST,INFO_COR];
		ACT = SERIAL(36);
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR<1,35>,.ACT<1,35>) THEN 1 ELSE 2),
		    1,.COR,.ACT,12,ERRINFO
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 ONTO DP, \O1 THRU SCAD; INSERT INTO ALL BYTES
!*RESPONSE:
!*	OUTPUT OF DBM MUX SHOULD BE \O2

!]ERROR 1
!]DBM_BYTES35 SCADA_SN SCADA_SEL_SN SCAD_A NTWK

!]NO ERROR 1
!]DBM_BYTES35 SCADA_SN SCADA_SEL_SN SCAD_A NTWK

!]ERROR 2
!]DBM_SEL_BYTES35 SCADA_SN SCADA_SEL_SN SCAD_A NTWK

!]NO ERROR 2
!]DBM_SEL_BYTES35 SCADA_SN SCADA_SEL_SN SCAD_A NTWK

    END;

GLOBAL ROUTINE TST16: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 1777 INTO FE, THEN AND WITH 0
!	LOAD 0 INTO FE, THEN AND WITH 1777
!	LOAD 1777 INTO FE, THEN AND WITH 1777
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_FE = 2,0,36,0 %,
	INFO_A = 3,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'204',
	TST_U = PLIT
	    (
%(0204)%    U_J(205) V_SCAD__1 U_LOADFE U,
%(0205)%    U_SN(0) U_SCADA_SN U_SCADB_FE U_SCAD_AND U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0206)%    U_J(210) V_SCAD_0 U_LOADFE U,
%(0207)%    U_J(210) V_SCAD__1 U_LOADFE U,
%(0210)%    U_SN(1777) U_SCADA_SN U_SCADB_FE U_SCAD_AND U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 2,
	TUA_2 = TST_U_ADR + 3;

    OWN
	INFO: BLOCKVECTOR[3,4] INITIAL
	(
	    TUA_0, 0, O1777, 0,
	    TUA_1, 0, 0, O1777,
	    TUA_2, O1777, O1777, O1777
	);

    OK = 1;
    LOAD_TST_U;

    INCR SUBTEST FROM 0 TO 2 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ERRINFO[0] = COR = .INFO[.SUBTEST,INFO_COR];
	    ACT = SCAD_Q();
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_FE];
		ERRINFO[1] = .INFO[.SUBTEST,INFO_A];
		ERRCAS
		(
		    (IF SINGLE_BIT(.COR,.ACT) THEN 1 ELSE 2),
		    1,.COR,.ACT,4,ERRINFO
		);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    EXIT_LOOP(1,2);
	    0
	);

    IFN .OK
    THEN
    (
	NOERR(1);
	NOERR(2);
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O0 INTO FE, THEN AND WITH \O1
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O2

!]ERROR 1
!]SCAD_AND SCADB_FE SCADA_SN SCAD_A SCADA_SC SC FE DBM_SCAD NTWK

!]NO ERROR 1
!]SCAD_AND SCADB_FE SCADA_SN SCAD_A SCADA_SC SC FE DBM_SCAD NTWK

!]ERROR 2
!]SCAD_AND SCADB_SEL_FE SCADA_SEL_SN SCAD_A SCADA_SEL_SC SC_EN FE_EN DBM_SEL_SCAD NTWK

!]NO ERROR 2
!]SCAD_AND SCADB_SEL_FE SCADA_SEL_SN SCAD_A SCADA_SEL_SC SC_EN FE_EN DBM_SEL_SCAD NTWK

    END;

GLOBAL ROUTINE TST17: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0, 1777 INTO SC, FE AND DO SCAD ADD, SUB, AND SUBB
!	PUT RESULTS IN Q AND EXAMINE WITH SERIAL
!	(ON SECOND THOUGHT, THIS IS NOT THE FASTEST ORDERING)
!
!--

    BEGIN

    MACRO
	INFO_FUNC = 0,0,36,0 %,
	INFO_A = 1,0,36,0 %,
	INFO_B = 2,0,36,0 %,
	INFO_CORR = 3,0,36,0 %;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'220',
	TST_U = PLIT
	    (
%(0220)%    V_SCAD_0 U_LOADSC U,
%(0221)%    V_SCAD_0 U_LOADFE U,
%(0222)%    V_SCAD__1 U_LOADSC U,
%(0223)%    V_SCAD__1 U_LOADFE U,
%(0224)%    U_SCADA_SC U_SCADB_FE U_SCAD_ADD U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0225)%    U_SCADA_SC U_SCADB_FE U_SCAD_SUB U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0226)%    U_SCADA_SC U_SCADB_FE U_SCAD_SUBB U_DBM_SCAD U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_SC_0 = TST_U_ADR + 0,
	TUA_FE_0 = TST_U_ADR + 1,
	TUA_SC__1 = TST_U_ADR + 2,
	TUA_FE__1 = TST_U_ADR + 3,
	TUA_ADD = TST_U_ADR + 4,
	TUA_SUB = TST_U_ADR + 5,
	TUA_SUBB = TST_U_ADR + 6;

    LOCAL
	OK_ADD,
	OK_SUB,
	OK_SUBB,
	SCAD_VAL;

    OWN
	INFO: BLOCKVECTOR[12,4] INITIAL
	    (
	    TUA_ADD, TUA_SC_0, TUA_FE_0, 0,
	    TUA_ADD, TUA_SC_0, TUA_FE__1, O1777,
	    TUA_ADD, TUA_SC__1, TUA_FE_0, O1777,
	    TUA_ADD, TUA_SC__1, TUA_FE__1, O1776,
	    TUA_SUB, TUA_SC_0, TUA_FE_0, 0,
	    TUA_SUB, TUA_SC_0, TUA_FE__1, 1,
	    TUA_SUB, TUA_SC__1, TUA_FE_0, O1777,
	    TUA_SUB, TUA_SC__1, TUA_FE__1, 0,
	    TUA_SUBB, TUA_SC_0, TUA_FE_0, O1777,
	    TUA_SUBB, TUA_SC_0, TUA_FE__1, 0,
	    TUA_SUBB, TUA_SC__1, TUA_FE_0, O1776,
	    TUA_SUBB, TUA_SC__1, TUA_FE__1, O1777
	    );

    LOAD_TST_U;
    OK_ADD = 1;
    OK_SUB = 1;
    OK_SUBB = 1;

    INCR ERRN FROM 0 TO 11 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.ERRN,INFO_A]);
	    CP(2);		! EXTRA CLOCK PULSE NEEDED
	    SET_CRAM_ADR(.INFO[.ERRN,INFO_B]);
	    CP(2);		! EXTRA CLOCK PULSE NEEDED
	    SET_CRAM_ADR(.INFO[.ERRN,INFO_FUNC]);
	    CP(1);
	    SCAD_VAL = SCAD_Q();
	    IF .SCAD_VAL NEQ .INFO[.ERRN,INFO_CORR]
	    THEN
	    (
		ERRINFO[0] =
		    (IF .INFO[.ERRN,INFO_A] EQL TUA_SC_0 THEN 0 ELSE O1777);
		ERRINFO[1] =
		    (IF .INFO[.ERRN,INFO_B] EQL TUA_FE_0 THEN 0 ELSE O1777);
		ERRINFO[2] = .INFO[.ERRN,INFO_CORR];
		ERRINFO[3] =
		(
		    CASE .ERRN/4 FROM 0 TO 2 OF
			SET
			[0]: (OK_ADD = 0; UPLIT(%ASCIZ 'ADD'));
			[1]: (OK_SUB = 0; UPLIT(%ASCIZ 'SUB'));
			[2]: (OK_SUBB = 0; UPLIT(%ASCIZ 'SUBB'));
			TES
		);
		ERRCAS(.ERRN/4+1,1,.INFO[.ERRN,INFO_CORR],.SCAD_VAL,4,ERRINFO);
	    );
	    EXIT_LOOP(1,.ERRN/4+1);
	    0
	);

    IFN .OK_ADD THEN NOERR(1);
    IFN .OK_SUB THEN NOERR(2);
    IFN .OK_SUBB THEN NOERR(3);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD SC WITH \O0, LOAD FE WITH \O1, SCAD \S3
!*RESPONSE:
!*	OUTPUT OF SCAD SHOULD BE \O2

!]ERROR 1
!]SCAD_ADD SC SC_EN SCADA_SC FE FE_EN SCADB_FE DBM_SCAD DBM_SEL_SCAD SCADA_SN SCADA_SEL_SN NTWK

!]NO ERROR 1
!]SCAD_ADD SC SC_EN SCADA_SC FE FE_EN SCADB_FE DBM_SCAD DBM_SEL_SCAD SCADA_SN SCADA_SEL_SN NTWK

!]ERROR 2
!]SCAD_SUB SC SC_EN SCADA_SC FE FE_EN SCADB_FE DBM_SCAD DBM_SEL_SCAD SCADA_SN SCADA_SEL_SN NTWK

!]NO ERROR 2
!]SCAD_SUB SC SC_EN SCADA_SC FE FE_EN SCADB_FE DBM_SCAD DBM_SEL_SCAD SCADA_SN SCADA_SEL_SN NTWK

!]ERROR 3
!]SCAD_SUBB SC SC_EN SCADA_SC FE FE_EN SCADB_FE DBM_SCAD DBM_SEL_SCAD SCADA_SN SCADA_SEL_SN NTWK

!]NO ERROR 3
!]SCAD_SUBB SC SC_EN SCADA_SC FE FE_EN SCADB_FE DBM_SCAD DBM_SEL_SCAD SCADA_SN SCADA_SEL_SN NTWK

    END;

GLOBAL ROUTINE TST18: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	LOAD 0 INTO VMA AND SEE IF EASY BITS ARE 0
!	LOAD -1 INTO VMA AND SEE IF EASY BITS (EXCEPT 1, 6) ARE 1
!	EASY BITS ARE 0:2, 6, 8:35
!	BITS WHICH ARE NOT "EASY" ARE ASSUMED TO BE OK HERE
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_DP = 2,0,36,0 %,
	INFO_N = 3,0,36,0 %,
	INFO_VALUE = 4,0,36,0 %;

    LOCAL
	DIF,
	ALL_DIF,
	ACT,
	COR;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'230',
	TST_U = PLIT
	    (
%(0230)%    U_J(232) U_N(501020) V_DP_0 U_SPEC_SWEEP U,
%(0231)%    U_J(232) U_N(20) V_DP__1 U_SPEC_SWEEP U,
%(0232)%    U_DBM_VMA U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1,
	VMA_EASY_MASK = %O'072000000000',	! EASY BITS 0
						! NOT-EASY BITS 1
	VMA_EASY_VALU = %O'501777777777';	! EASY BITS 1 BUT GND 0
						! NOT-EASY BITS 0

    OWN
	INFO: BLOCKVECTOR[2,5] INITIAL
	(
	    TUA_0, 0,  0, %O'501020',             0,
	    TUA_1, 1, -1,     %O'20', VMA_EASY_VALU
	),
	VMA_ERROR_FIELD: VECTOR[6] INITIAL
	(
	    %O'400000000000',	! USER
	    %O'100000000000',	! FETCH
	    %O'001000000000',	! PHYS
	    %O'000400000000',	! PREV
	    %O'000360000000',	! CYCLE (I/O, WRU, VECTOR, I/O BYTE)
	    %O'000017777777'	! VMA
	);

    LOAD_TST_U;
    ALL_DIF = 0;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ACT = SERIAL(36);
	    COR = (.ACT AND VMA_EASY_MASK) OR .INFO[.SUBTEST,INFO_VALUE];
	    DIF = .COR XOR .ACT;
	    ALL_DIF = .ALL_DIF OR .DIF;
	    IF .ACT NEQ .COR
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_COR];
		ERRINFO[1] = .INFO[.SUBTEST,INFO_DP];
		ERRINFO[2] = .INFO[.SUBTEST,INFO_N];
		ERMCAS(1,.COR,.ACT,12,ERRINFO);
		INCR ERRN FROM 0 TO 5 DO
		    IFN (.DIF AND .VMA_ERROR_FIELD[.ERRN])
		    THEN
			FAILURE(.ERRN + 2);
	    );
	    INCR ERRN FROM 2 TO 7 DO
		EXIT_LOOP(1,.ERRN);
	    0
	);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O1 INTO VMA (SWEEP LATCH) AND THRU DBM MUX WITH #=\O2
!*RESPONSE:
!*	DBM OUTPUT BITS 0, 2, 8:35 SHOULD BE \O0
!*	DBM OUTPUT BITS 1, 6 SHOULD BE 0

    IF .ALL_DIF EQL 0
    THEN
	NOERR(1)
    ELSE
	INCR ERRN FROM 0 TO 5 DO
	    IF (.ALL_DIF AND .VMA_ERROR_FIELD[.ERRN]) EQL 0
	    THEN
		NOERR(.ERRN + 2);

!]NO ERROR 1
!]VMA_USER_DP VMA_FETCH_DP VMA_PHYS_DP VMA_PREV_DP VMA_CYCLE_DP VMA DBM_VMA SPEC_SWEEP NTWK

!]ERROR 2
!]VMA_USER_DP DBM_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 2
!]VMA_USER_DP NTWK

!]ERROR 3
!]VMA_FETCH_DP DBM_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 3
!]VMA_FETCH_DP NTWK

!]ERROR 4
!]VMA_PHYS_DP DBM_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 4
!]VMA_PHYS_DP NTWK

!]ERROR 5
!]VMA_PREV_DP DBM_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 5
!]VMA_PREV_DP NTWK

!]ERROR 6
!]VMA_CYCLE_DP DBM_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 6
!]VMA_CYCLE_DP NTWK

!]ERROR 7
!]VMA DBM_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 7
!]VMA NTWK

    END;

GLOBAL ROUTINE TST19: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	PASS 0 THRU THE EXP HALFWORD INPUT TO DBM MUX
!	PASS -1 THRU THE EXP HALFWORD INPUT TO DBM MUX
!
!--

    BEGIN

    LOCAL
	EXP_VAL,
	OK;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'240',
	TST_U = PLIT
	    (
%(0240)%    U_J(242) V_DP_0 V_SCAD_0 U_DBM_EXP V_AC_DBM U,
%(0241)%    U_J(242) V_DP__1 V_SCAD__1 U_DBM_EXP V_AC_DBM U,
%(0242)%    V_D_AC V_DP_D U_DEST_Q_AD U_NO_CLKR U_SKIP_ADLEQ0 U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    LOAD_TST_U;
    OK = 1;

    ERROR_LOOP(1)
    (
	SET_CRAM_ADR(TUA_0);
	IF STEP_U_NEXT(2) EQL 0
	THEN
	(
	    ERRCAS(1,1,0,SERIAL(18),6,OK);
	    OK = 0;
	);
	EXIT_LOOP(1,1);
	0
    );

!*MESSAGE 1
!*STIMULUS:
!*	LOAD 0 FROM DP, SCAD THRU DBM MUX EXP INPUT
!*RESPONSE:
!*	OUTPUT OF DBM MUX LEFT HALFWORD SHOULD BE 0

    ERROR_LOOP(2)
    (
	SET_CRAM_ADR(TUA_1);
	CP(2);
	EXP_VAL = SERIAL(18);
	IF .EXP_VAL NEQ %O'377777'
	THEN
	(
	    ERRCAS(1,2,%O'377777',.EXP_VAL,6,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(2,1);
	0
    );

    IFN .OK THEN NOERR(1);

!*MESSAGE 2
!*STIMULUS:
!*	LOAD -1 FROM DP, SCAD THRU DBM MUX EXP INPUT
!*RESPONSE:
!*	OUTPUT OF DBM MUX LEFT HALFWORD SHOULD BE 377777

!]ERROR 1
!]DBM_EXP DBM_SEL_EXP SCAD_A SCADA_SN NTWK

!]NO ERROR 1
!]DBM_EXP DBM_SEL_EXP SCAD_A SCADA_SN NTWK

    END;

GLOBAL ROUTINE TST20: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK VMA FLAG BITS 0, 2, 8, 10:13 DBM MUX INPUTS STUCK HIGH/LOW
!	OTHER BITS ARE ASSUMED TO BE OK HERE
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_DBM028 = 1,0,36,0 %,
	INFO_DP = 2,0,36,0 %,
	INFO_N = 3,0,36,0 %,
	INFO_VALU = 4,0,36,0 %;

    LOCAL
	DIF,
	ALL_DIF,
	ACT,
	COR;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'250',
	TST_U = PLIT
	    (
%(0250)%    U_J(252) U_N(0) V_DP__1 U_SPEC_SWEEP U,
%(0251)%    U_J(252) U_N(501000) V_DP_0 U_SPEC_SWEEP U,
%(0252)%    U_DBM_VMA U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1,
	VMA_EASY_MASK = %O'27641',	! EASY BITS 0
					! NOT-EASY BITS 1
	VMA_EASY_VALU = %O'50100';	! EASY BITS 1 BUT GND 0
					! NOT-EASY BITS 0

    OWN
	VMA_ERROR_FIELD: VECTOR[4] INITIAL	! VMA FLAGS BITS 0:14
	(
	    %O'40000',
	    %O'10000',
	    %O'00100',
	    %O'00036'
	),
	INFO: BLOCKVECTOR[2,5] INITIAL
	(
	    TUA_0, 0, -1,          0,             0,
	    TUA_1, 1,  0, %O'501000', VMA_EASY_VALU
	);

    LOAD_TST_U;
    ALL_DIF = 0;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ACT = SERIAL(15);
	    COR = (.ACT AND VMA_EASY_MASK) OR .INFO[.SUBTEST,INFO_VALU];
	    DIF = .COR XOR .ACT;
	    ALL_DIF = .ALL_DIF OR .DIF;
	    IF .ACT NEQ .COR
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_N];
		ERRINFO[1] = .INFO[.SUBTEST,INFO_DP];
		ERRINFO[2] = .INFO[.SUBTEST,INFO_DBM028];
		ERMCAS(1,.COR,.ACT,5,ERRINFO);
		INCR ERRN FROM 0 TO 3 DO
		    IFN (.DIF AND .VMA_ERROR_FIELD[.ERRN])
		    THEN
			FAILURE(.ERRN + 2);
	    );
	    INCR ERRN FROM 2 TO 5 DO
		EXIT_LOOP(1,.ERRN);
	    0
	);

    IF .ALL_DIF EQL 0
    THEN
	NOERR(1)
    ELSE
	INCR ERRN FROM 0 TO 3 DO
	    IF (.ALL_DIF AND .VMA_ERROR_FIELD[.ERRN]) EQL 0
	    THEN
		NOERR(.ERRN + 2);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD 0 INTO VMA BITS 0, 2, 8 (SWEEP LATCH)
!*	AND THRU DBM MUX WITH # = \O0; DP = \O1
!*RESPONSE:
!*	DBM OUTPUT BITS 0, 2, 8 SHOULD BE \O2
!*	DBM OUTPUT BITS 10:13 SHOULD BE 0
!*CORRECT & ACTUAL ARE VMA FLAGS BITS 0:14

!]NO ERROR 1
!]VMA_USER_N VMA_FETCH_N VMA_PHYS_N VMA_CYCLE_N NTWK

!]ERROR 2
!]VMA_USER_N DBM_VMA DBM_SEL_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 2
!]VMA_USER_N NTWK

!]ERROR 3
!]VMA_FETCH_N DBM_VMA DBM_SEL_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 3
!]VMA_FETCH_N NTWK

!]ERROR 4
!]VMA_PHYS_N DBM_VMA DBM_SEL_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 4
!]VMA_PHYS_N NTWK

!]ERROR 5
!]VMA_CYCLE_N DBM_VMA DBM_SEL_VMA SPEC_SWEEP VMA_SWEEP NTWK

!]NO ERROR 5
!]VMA_CYCLE_N NTWK

    END;

GLOBAL ROUTINE TST21: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TRY TO READ & WRITE AC0 VIA VMA
!	FAILS IF FORCE RAMFILE IS SOMEHOW STUCK "OFF"
!	(OR ANY OF "VMA <18:31> L" ARE STUCK HIGH)
!
!--

    BEGIN

    LOCAL
	LOC_0_VAL;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'260',
	TST_U = PLIT
	    (
%(0260)%    U_J(261) V_DP__1 V_AC_DP U,
%(0261)%    U_J(262) V_DP_0 U_MEM U_N(10012) U,
%(0262)%    V_DP_0 U_MEM U_N(2) U,
%(0263)%    U_J(264) V_DP_0 V_AC_DP U,
%(0264)%    U_J(265) V_DP_0 U_MEM U_N(40012) U,
%(0265)%    U_MEM U_N(2) U_DBM_MEM U_DBUS_DBM V_DP_D U_DEST_Q_AD U_SKIP_ADEQ0 U
	    ),
	TUA_W = TST_U_ADR + 0,
	TUA_R = TST_U_ADR + 3;

    LOAD_TST_U;
    ERROR_LOOP(1)
    (
	MEM_DEPOSIT(0,-1);
	SET_CRAM_ADR(TUA_W);
	CP(3);
	LOC_0_VAL = MEM_EXAMINE(0);
	IF .LOC_0_VAL NEQ -1
	THEN
	    ERRCA(1,-1,.LOC_0_VAL,12)
	ELSE
	    NOERR(1);
	EXIT_LOOP(1,1);
	0
    );

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOC 0
!*	KS10:	WRITE -1 TO AC0 VIA IR AC FIELD
!*		LOAD 0 INTO VMA, THEN WRITE 0 TO AC0 VIA VMA
!*	8080:	READ MEM LOC 0
!*RESPONSE:
!*	MEM LOC 0 SHOULD BE -1

!]ERROR 1
!]MEM_WRITE_N FORCE AC_REF VMA_ALL_N STOP MEM_EN NTWK

!]NO ERROR 1
!]MEM_WRITE_N NTWK

    ERROR_LOOP(2)
    (
	MEM_DEPOSIT(0,-1);
	SET_CRAM_ADR(TUA_R);
	IF STEP_U_NEXT(3) NEQ 1
	THEN
	    ERRCA(2,0,SERIAL(36),12)
	ELSE
	    NOERR(2);
	EXIT_LOOP(2,2);
	0
    );

!*MESSAGE 2
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOC 0
!*	KS10:	WRITE 0 TO AC0 VIA IR AC FIELD
!*		LOAD 0 INTO THE VMA, THEN READ AC0 VIA VMA
!*RESPONSE:
!*	AC0 SHOULD BE 0

!]ERROR 2
!]MEM_READ_N FORCE AC_REF VMA_ALL_N STOP MEM_EN NTWK

!]NO ERROR 2
!]MEM_READ_N NTWK

    END;

GLOBAL ROUTINE TST22: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CAUSE ERROR AT M[0] AND ASK MMC WHERE IT WAS REALLY AT
!
!--

    BEGIN

    LOCAL
	MEM_ADR;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'270',
	TST_U = PLIT
	    (
%(0270)%    U_J(271) V_DP_0 U_MEM U_N(13012) U,
%(0271)%    U_J(272) V_DP_0 U_MEM U_N(2) U,
%(0272)%    U_J(273) V_DP_0 U_MEM U_N(43012) U,
%(0273)%    U_MEM U_N(2) U
	    );

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;
    ERROR_LOOP(1)
    (
	DI(100000,376);		! SET MMC ECC FORCE BITS
	SET_CRAM_ADR(TST_U_ADR);
	CP(4);
	IFN (RD_301 AND %O'100')
	THEN
	    ERRS(1,2,ERRINFO)
	ELSE
	(
	    MEM_ADR = EI(100000) AND %O'17777777';	! GET ERROR ADDRESS
	    IFN .MEM_ADR
	    THEN
		ERRCAS(1,1,0,.MEM_ADR,8,ERRINFO)
	    ELSE
		NOERR(1);
	);
	MR();			! CLEAR FORCE BITS
	EXIT_LOOP(1,1);
	0
    );

    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	DEPOSIT 0 TO MEM LOC 0 (WITH WRONG ECC)
!*		READ MEM LOC 0 (CAUSING AN ERROR)
!*	8080:	READ I/O REGISTER 100000 BITS <14:35>
!*RESPONSE:
!*	SHOULD GET 0 (ADDR OF LAST ERROR)

!*MESSAGE 2
!*STIMULUS:
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	DEPOSIT 0 TO MEM LOC 0 (WITH WRONG ECC)
!*		READ MEM LOC 0 (CAUSING AN ERROR)
!*RESPONSE:
!*	REFERENCE WAS MADE TO NXM (NOT MEM LOC 0)

!]ERROR 1
!]BUS_ALL BUS_MUX_VMA VMA_ALL_N FORCE AC_REF STOP MEM_EN BUS_REQ MEM_READ_N MEM_WRITE_N NTWK

!]NO ERROR 1
!]MEM_READ_N MEM_WRITE_N BUS_REQ MEM_EN NTWK

    END;

GLOBAL ROUTINE TST23: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TRY TO READ 0 & -1 FROM MEM LOC 0
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_TICKS = 1,0,36,0 %,
	INFO_COR = 2,0,36,0 %;

    LOCAL
	COR,
	ACT,
	OK;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'300',
	TST_U = PLIT
	    (
%(0300)%    U_J(301) V_DP__1 V_AC_DP U,
%(0301)%    U_J(302) V_DP_0 U_MEM U_N(43012) U,
%(0302)%    U_MEM U_N(2) U_DBM_MEM U_DBUS_DBM V_DP_D U_DEST_Q_AD U_SKIP_ADEQ0 U,
%(0303)%    U_J(304) V_DP_0 V_AC_DP U,
%(0304)%    U_J(305) V_DP_0 U_MEM U_N(43012) U,
%(0305)%    U_J(306) U_MEM U_N(2) U_DBM_MEM U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0306)%    U_A_AR U_LSRC_AQ U_ALU_XOR U_SKIP_ADEQ0 U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 3;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, 3,  0,
	    TUA_1, 4, -1
	);

    LOAD_TST_U;
    OK = 1;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    COR = .INFO[.SUBTEST,INFO_COR];
	    MEM_DEPOSIT(0,NOT .COR);
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    IF STEP_U_NEXT(.INFO[.SUBTEST,INFO_TICKS])
	    THEN
	    (
		ACT = SERIAL(36);
		ERRINFO[0] = .COR;
		ERRINFO[1] = NOT .COR;
		ERRCAS(1,1,.COR,.ACT,12,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE \O0 TO MEM LOC 0
!*	KS10:	WRITE \O1 TO AC0 VIA IR AC FIELD
!*		LOAD 0 INTO THE VMA, THEN READ MEM LOC 0
!*RESPONSE:
!*	SHOULD GET \O0

!]ERROR 1
!]BUS_R DBM_MEM DBM_SEL_MEM BUS_MUX_VMA BUS_ALL VMA_ALL_N MEM_EN BUS_REQ MEM_READ_N NTWK

!]NO ERROR 1
!]BUS_R NTWK

    END;

GLOBAL ROUTINE TST24: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TRY TO WRITE 0 & -1 TO MEM LOC 0
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %;

    LOCAL
	OK,
	COR,
	ACT;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'310',
	TST_U = PLIT
	    (
%(0310)%    U_J(311) V_DP_0 U_MEM U_N(13012) U,
%(0311)%    V_DP__1 U_MEM U_N(2) U_DBUS_DP U,
%(0312)%    U_J(313) V_DP_0 U_MEM U_N(13012) U,
%(0313)%    V_DP_0 U_MEM U_N(2) U_DBUS_DP U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 2;

    OWN
	INFO: BLOCKVECTOR[2,2] INITIAL
	(
	    TUA_0, -1,
	    TUA_1, 0
	);

    LOAD_TST_U;
    OK = 1;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    COR = .INFO[.SUBTEST,INFO_COR];
	    MEM_DEPOSIT(0,.COR);
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ACT = MEM_EXAMINE(0);
	    IF .ACT NEQ .COR
	    THEN
	    (
		ERRINFO[0] = .COR;
		ERRCAS(1,1,.COR,.ACT,12,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE 0 TO MEM LOC 0
!*	KS10:	WRITE \O0 TO MEM LOC 0
!*	8080:	READ MEM LOC 0
!*RESPONSE:
!*	SHOULD GET \O0

!]ERROR 1
!]BUS_T BUS_MUX_DP BUS_MUX_VMA BUS_ALL VMA_ALL_N MEM_EN BUS_REQ MEM_WRITE_N NTWK

!]NO ERROR 1
!]BUS_T BUS_MUX_DP NTWK

    END;

GLOBAL ROUTINE TST25: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	WRITE TO M[2**I] TO CHECK FOR DPM ADDR BITS STUCK LOW
!	HAVE THE 'PHYSICAL' BIT ON TO ALWAYS ACCESS REAL MEMORY
!
!--

    BEGIN

    LOCAL
	LOC,
	VAL,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'320',
	TST_U = PLIT
	    (
%(0320)%    U_J(321) V_DP_N(1) U_B_T0 U_DEST_AD U,
%(0321)%    U_J(322) V_DP_T0 U_MEM U_N(11016) U,
%(0322)%    U_J(323) V_DP__1 U_MEM U_N(2) U,
%(0323)%    U_J(321) U_A_T0 U_B_T0 U_LSRC_AB U_ALU_ADD U_DEST_AD U
	    );

    LOAD_TST_U;
    OK = 1;
    SET_CRAM_ADR(TST_U_ADR);
    CP(1);

    ERROR_LOOP(1)
    (
	MEM_DEPOSIT(0,0);
	LOC = 1;
	WHILE .LOC LEQ .MAX_MEM_ADR DO
	(
	    MEM_DEPOSIT(.LOC,0);
	    CP(3);
	    VAL = MEM_EXAMINE(.LOC);
	    IF .VAL NEQ -1
	    THEN
	    (
		ERRINFO[0] = .LOC;
		ERRINFO[1] = MEM_EXAMINE(0);
		ERRCAS(1,1,-1,.VAL,12,ERRINFO);
		OK = 0;
		MEM_DEPOSIT(0,0);
	    );
	    LOC = .LOC ^ 1;
	);
	EXIT_LOOP(1,1);
	0
    );

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE 0 TO MEM LOCS 0, \O0
!*	KS10:	WRITE -1 TO PHYSICAL EXTENDED MEM LOC \O0
!*	8080:	READ MEM LOCS 0, \O0
!*RESPONSE:
!*	MEM LOC 0 SHOULD BE 0 (IT IS \O1)
!*	MEM LOC \O0 SHOULD BE -1

!]ERROR 1
!]AC_REF FORCE BUS_T BUS_MUX_DP BUS_MUX_VMA BUS_ALL VMA_ALL_N MEM_EN BUS_REQ MEM_WRITE_N NTWK

!]NO ERROR 1
!] NTWK

    END;

GLOBAL ROUTINE TST26: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	WRITE TO M[2**I] TO CHECK FOR -VMA (AC REF) BITS STUCK LOW
!	HAVE THE 'PHYSICAL' BIT OFF TO ACCESS REAL MEMORY,
!	    OR AC 0 IF THE BIT IS STUCK
!	NOTE THAT EXTENDED VMA BITS AREN'T CHECKED
!
!--

    BEGIN

    LOCAL
	LOC,
	VAL,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'330',
	TST_U = PLIT
	    (
%(0330)%    U_J(331) V_DP_N(20) U_B_T0 U_DEST_AD U,
%(0331)%    U_J(332) V_DP_T0 U_MEM U_N(10016) U,
%(0332)%    U_J(333) V_DP__1 U_MEM U_N(2) U,
%(0333)%    U_J(331) U_A_T0 U_B_T0 U_LSRC_AB U_ALU_ADD U_DEST_AD U
	    );

    LOAD_TST_U;
    OK = 1;
    SET_CRAM_ADR(TST_U_ADR);
    CP(1);

    ERROR_LOOP(1)
    (
	MEM_DEPOSIT(0,0);
	LOC = 16;
	WHILE (.LOC LEQ .MAX_MEM_ADR) AND (.LOC LEQ %O'777777') DO
	(
	    MEM_DEPOSIT(.LOC,0);
	    CP(3);
	    VAL = MEM_EXAMINE(.LOC);
	    IF .VAL NEQ -1
	    THEN
	    (
		ERRINFO[0] = .LOC;
		ERRINFO[1] = MEM_EXAMINE(0);
		ERRCAS(1,1,-1,.VAL,12,ERRINFO);
		OK = 0;
		MEM_DEPOSIT(0,0);
	    );
	    LOC = .LOC ^ 1;
	);
	EXIT_LOOP(1,1);
	0
    );

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE 0 TO MEM LOCS 0, \O0
!*	KS10:	WRITE -1 TO EXTENDED MEM LOC \O0
!*	8080:	READ MEM LOCS 0, \O0
!*RESPONSE:
!*	MEM LOC 0 SHOULD BE 0 (IT IS \O1)
!*	MEM LOC \O0 SHOULD BE -1

!]ERROR 1
!]AC_REF FORCE BUS_T BUS_MUX_DP BUS_MUX_VMA BUS_ALL VMA_ALL_N MEM_EN BUS_REQ MEM_WRITE_N NTWK

!]NO ERROR 1
!] NTWK

    END;

GLOBAL ROUTINE TST27: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	DO MEMORY CYCLES AND TRY TO CAPTURE THE 'MEM' BITS
!	LOAD THEM FROM THE MAGIC NUMBER FIELD (#)
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_NAM = 2,0,36,0 %;

    LOCAL
	COR,
	ACT,
	ALL_DIF;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'340',
	TST_U = PLIT
	    (
%(0340)%    U_MEM U_N(2) U_DBM_VMA U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0341)%    U_J(340) V_DP_0 U_MEM U_N(11012) U,
%(0342)%    U_J(340) V_DP_0 U_MEM U_N(43012) U,
%(0343)%    U_J(340) V_DP_0 U_MEM U_N(21012) U
	    ),
	TUA_W = TST_U_ADR + 1,
	TUA_R = TST_U_ADR + 2,
	TUA_WT = TST_U_ADR + 3;

    OWN
	INFO: BLOCKVECTOR[3,3] INITIAL
	(
	    TUA_W,  %O'04', UPLIT(%ASCIZ 'WRITE'),
	    TUA_R,  %O'21', UPLIT(%ASCIZ 'READ'),
	    TUA_WT, %O'10', UPLIT(%ASCIZ 'WRITE TEST')
	);

    LOAD_TST_U;
    ALL_DIF = 0;

    INCR SUBTEST FROM 0 TO 2 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(2);
	    ACT = SERIAL(8) AND %O'37';
	    COR = .INFO[.SUBTEST,INFO_COR];
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_NAM];
		ERMCAS(1,.COR,.ACT,2,ERRINFO);
		ALL_DIF = .ALL_DIF OR (.COR XOR .ACT);
		INCR ERRN FROM 0 TO 4 DO
		    IF .COR<.ERRN,1> NEQ .ACT<.ERRN,1>
		    THEN
			FAILURE(.ERRN + 1);
	    );
	    INCR ERRN FROM 1 TO 5 DO
		EXIT_LOOP(1,.ERRN);
	    0
	);

    INCR ERRN FROM 0 TO 4 DO
	IF .ALL_DIF<.ERRN,1> EQL 0 THEN NOERR(.ERRN + 1);

!*MESSAGE 1
!*STIMULUS:
!*	\S0 TO MEM LOC 0 CONTROLLED BY #
!*RESPONSE:
!*	READ VMA DURING MEMORY CYCLE
!*	CORRECT & ACTUAL ARE VMA<3:7>

!]ERROR 1
!]DBM_VMA_MEM DBM_SEL_VMA MEM_CAC_INH_N NTWK

!]NO ERROR 1
!]MEM_CAC_INH_N NTWK

!]ERROR 2
!]DBM_VMA_MEM DBM_SEL_VMA NTWK

!]NO ERROR 2
!] NTWK

!]ERROR 3
!]DBM_VMA_MEM DBM_SEL_VMA MEM_WRITE_N NTWK

!]NO ERROR 3
!]MEM_WRITE_N NTWK

!]ERROR 4
!]DBM_VMA_MEM DBM_SEL_VMA MEM_WR_TEST_N NTWK

!]NO ERROR 4
!]MEM_WR_TEST_N NTWK

!]ERROR 5
!]DBM_VMA_MEM DBM_SEL_VMA MEM_READ_N NTWK

!]NO ERROR 5
!]MEM_READ_N NTWK

    END;

GLOBAL ROUTINE TST28: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	DO MEMORY CYCLES AND TRY TO CAPTURE THE 'MEM' BITS
!	LOAD THEM FROM THE DATA PATH
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_NAM = 2,0,36,0 %;

    LOCAL
	COR,
	ACT,
	ALL_DIF;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'350',
	TST_U = PLIT
	    (
%(0350)%    U_J(351) U_A_BRX U_B_T0 U_LSRC_0B U_RSRC_0A U_ALU_OR U_MEM U_N(32) U,
%(0351)%    U_MEM U_N(2) U_DBM_VMA U_DBUS_DBM V_DP_D U_DEST_Q_AD U,
%(0352)%    U_J(350) U_DBM_N U_DBUS_DBM V_DP_D U_B_T0 U_DEST_AD U_N(11000) U,
%(0353)%    U_J(350) U_DBM_N U_DBUS_DBM V_DP_D U_B_T0 U_DEST_AD U_N(43000) U,
%(0354)%    U_J(350) U_DBM_N U_DBUS_DBM V_DP_D U_B_T0 U_DEST_AD U_N(21000) U
	    ),
	TUA_W = TST_U_ADR + 2,
	TUA_R = TST_U_ADR + 3,
	TUA_WT = TST_U_ADR + 4;

    OWN
	INFO: BLOCKVECTOR[3,3] INITIAL
	(
	    TUA_W,  %O'04', UPLIT(%ASCIZ 'WRITE'),
	    TUA_R,  %O'21', UPLIT(%ASCIZ 'READ'),
	    TUA_WT, %O'10', UPLIT(%ASCIZ 'WRITE TEST')
	);

    LOAD_TST_U;
    ALL_DIF = 0;

    INCR SUBTEST FROM 0 TO 2 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(3);
	    ACT = SERIAL(8) AND %O'37';
	    COR = .INFO[.SUBTEST,INFO_COR];
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_NAM];
		ERMCAS(1,.COR,.ACT,2,ERRINFO);
		ALL_DIF = .ALL_DIF OR (.COR XOR .ACT);
		INCR ERRN FROM 0 TO 4 DO
		    IF .COR<.ERRN,1> NEQ .ACT<.ERRN,1>
		    THEN
			FAILURE(.ERRN + 1);
	    );
	    INCR ERRN FROM 1 TO 5 DO
		EXIT_LOOP(1,.ERRN);
	    0
	);

    INCR ERRN FROM 0 TO 4 DO
	IF .ALL_DIF<.ERRN,1> EQL 0 THEN NOERR(.ERRN + 1);

!*MESSAGE 1
!*STIMULUS:
!*	\S0 TO MEM LOC 0 CONTROLLED BY DP
!*RESPONSE:
!*	READ VMA DURING MEMORY CYCLE
!*	CORRECT & ACTUAL ARE VMA<3:7>

!]ERROR 1
!]DBM_VMA_MEM DBM_SEL_VMA MEM_CAC_INH_DP NTWK

!]NO ERROR 1
!]MEM_CAC_INH_DP NTWK

!]ERROR 2
!]DBM_VMA_MEM DBM_SEL_VMA NTWK

!]NO ERROR 2
!] NTWK

!]ERROR 3
!]DBM_VMA_MEM DBM_SEL_VMA MEM_WRITE_DP NTWK

!]NO ERROR 3
!]MEM_WRITE_DP NTWK

!]ERROR 4
!]DBM_VMA_MEM DBM_SEL_VMA MEM_WR_TEST_DP NTWK

!]NO ERROR 4
!]MEM_WR_TEST_DP NTWK

!]ERROR 5
!]DBM_VMA_MEM DBM_SEL_VMA MEM_READ_DP NTWK

!]NO ERROR 5
!]MEM_READ_DP NTWK

    END;

GLOBAL ROUTINE TST29: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	START MEMORY CYCLES AND TRY TO CAPTURE THE 'MEM' BITS
!	LOAD THEM FROM THE DROM
!	DROM[124] = 0300,1567,0100
!	DROM[277] = 0017,1561,1700
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_COR = 1,0,36,0 %,
	INFO_OPCODE = 2,0,36,0 %;

    LOCAL
	COR,
	ACT,
	ALL_DIF;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'360',
	TST_U = PLIT
	    (
%(0360)%    U_J(362) U_N(277000) U_DBM_N U_DBUS_DBM U_SPEC_LOADIR U,
%(0361)%    U_J(362) U_N(124000) U_DBM_N U_DBUS_DBM U_SPEC_LOADIR U,
%(0362)%    U_J(363) U_N(42) U_MEM V_DP_0 U,
%(0363)%    U_SPEC_MEMCLR U_DBM_VMA U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    OWN
	INFO: BLOCKVECTOR[2,3] INITIAL
	(
	    TUA_0, %O'30', %O'277',
	    TUA_1, %O'00', %O'124'
	);

    LOAD_TST_U;
    ALL_DIF = 0;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    CP(3);
	    ACT = SERIAL(8) AND %O'37';
	    COR = .INFO[.SUBTEST,INFO_COR];
	    IF .COR NEQ .ACT
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST,INFO_OPCODE];
		ERMCAS(1,.COR,.ACT,2,ERRINFO);
		ALL_DIF = .ALL_DIF OR (.COR XOR .ACT);
		INCR ERRN FROM 0 TO 4 DO
		    IF .COR<.ERRN,1> NEQ .ACT<.ERRN,1>
		    THEN
			FAILURE(.ERRN + 1);
	    );
	    INCR ERRN FROM 1 TO 5 DO
		EXIT_LOOP(1,.ERRN);
	    0
	);

    INCR ERRN FROM 0 TO 4 DO
	IF .ALL_DIF<.ERRN,1> EQL 0 THEN NOERR(.ERRN + 1);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD OPCODE \O0 INTO THE IR
!*	START A MEMORY CYCLE CONTROLLED BY DROM
!*	ABORT THE MEMORY CYCLE
!*RESPONSE:
!*	READ VMA DURING MEMORY CYCLE
!*	CORRECT & ACTUAL ARE VMA<3:7>

!]ERROR 1
!]DBM_VMA_MEM DBM_SEL_VMA MEM_CAC_INH_DRO NTWK

!]NO ERROR 1
!]MEM_CAC_INH_DRO NTWK

!]ERROR 2
!]DBM_VMA_MEM DBM_SEL_VMA NTWK

!]NO ERROR 2
!] NTWK

!]ERROR 3
!]DBM_VMA_MEM DBM_SEL_VMA MEM_WRITE_DRO NTWK

!]NO ERROR 3
!]MEM_WRITE_DRO NTWK

!]ERROR 4
!]DBM_VMA_MEM DBM_SEL_VMA MEM_WR_TEST_DRO NTWK

!]NO ERROR 4
!]MEM_WR_TEST_DRO NTWK

!]ERROR 5
!]DBM_VMA_MEM DBM_SEL_VMA MEM_READ_DRO NTWK

!]NO ERROR 5
!]MEM_READ_DRO NTWK

    END;

GLOBAL ROUTINE TST30: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK STUCK BITS ON E612 WHICH GENERATES DPM5 MEM EN L
!	DROM[124] = 0300,1567,0100
!	DROM[277] = 0017,1561,1700
!
!--

    BEGIN

    MACRO
	INFO_INI_ADR = 0,0,36,0 %,
	INFO_TST_ADR = 1,0,36,0 %,
	INFO_N = 2,0,36,0 %,
	INFO_MEM = 3,0,36,0 %,
	INFO_COND = 4,0,36,0 %,
	INFO_CORR = 5,0,36,0 %;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'370',
	TST_U = PLIT
	    (
%(0370)%    U_N(277000) U_DBM_N U_DBUS_DBM U_SPEC_LOADIR U,
%(0371)%    U_N(124000) U_DBM_N U_DBUS_DBM U_SPEC_LOADIR U,
%(0372)%    U_J(373) V_DP_0 U_MEM U_N(13011) U,
%(0373)%    V_DP_0 U_MEM U_N(1) U,
%(0374)%    U_J(375) V_DP_0 U_N(13013) U,
%(0375)%    V_DP_0 U_N(3) U,
%(0376)%    U_J(377) V_DP_0 U_MEM U_N(13010) U,
%(0377)%    V_DP_0 U_MEM U_N(0) U,
%(0400)%    U_J(401) V_DP_0 U_MEM U_N(13012) U,
%(0401)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA = TST_U_ADR;

    LOCAL
	OK,
	VAL;

    OWN
	INFO: BLOCKVECTOR[5,6] INITIAL
	    (
	    TUA+0, TUA+2, %O'13011', 1, 1,  0, 
	    0,     TUA+4, %O'13013', 0, 1, -1, 
	    0,     TUA+6, %O'13010', 1, 1, -1, 
	    TUA+1, TUA+4, %O'13011', 1, 0, -1, 
	    0,     TUA+8, %O'13012', 1, 0,  0
	    );

    LOAD_TST_U;
    OK = 1;

    INCR ERRN FROM 0 TO 4 DO
	ERROR_LOOP(1)
	(
	    IFN .INFO[.ERRN,INFO_INI_ADR]
	    THEN
	    (
		SET_CRAM_ADR(.INFO[.ERRN,INFO_INI_ADR]);
		CP(2);		! EXTRA CLOCK PULSE NEEDED
	    );
	    MEM_DEPOSIT(0,-1);
	    SET_CRAM_ADR(.INFO[.ERRN,INFO_TST_ADR]);
	    CP(2);
	    VAL = MEM_EXAMINE(0);
	    IF .VAL NEQ .INFO[.ERRN,INFO_CORR]
	    THEN
	    (
		ERRINFO[0] = .INFO[.ERRN,INFO_N];
		ERRINFO[1] = .INFO[.ERRN,INFO_MEM];
		ERRINFO[2] = .INFO[.ERRN,INFO_COND];
		ERRINFO[3] = .INFO[.ERRN,INFO_CORR];
		ERRCAS(1,1,.INFO[.ERRN,INFO_CORR],.VAL,12,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOC 0
!*	KS10:	CONDITIONALLY WRITE 0 TO MEM LOC 0
!*		TO START CYCLE, #=\O0, MEM=\O1, DROM COND FUNC=\O2
!*	8080:	READ MEM LOC 0
!*RESPONSE:
!*	MEM LOC 0 SHOULD BE \O3

!]ERROR 1
!]N_ALL BUS_ALL BUS_MUX_VMA BUS_MUX_DP VMA_ALL_N MEM_WRITE_N MEM_CAC_INH_N FORCE AC_REF MEM_EN NTWK

!]NO ERROR 1
!]MEM_EN NTWK

    END;

GLOBAL ROUTINE TST31: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST BUS REQUEST INPUT TO DPM MUX SEL 2 FOR STUCK HIGH/LOW
!
!--

    BEGIN

    LOCAL
	VAL,
	LOC,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'410',
	TST_U = PLIT
	    (
%(0410)%    U_J(412) V_DP_N(1) U_B_T0 U_DEST_AD U,
%(0411)%    U_J(412) U_A_T0 U_B_T0 U_LSRC_AB U_ALU_ADD U_DEST_AD U,
%(0412)%    U_J(413) V_DP_0 U_MEM U_N(13012) U,
%(0413)%    U_J(412) V_DP_T0 U_MEM U_N(2) U
	    ),
	TUA_NXT = TST_U_ADR + 1;

    LOAD_TST_U;
    OK = 1;
    SET_CRAM_ADR(TST_U_ADR);
    CP(1);
    LOC = 1;

    WHILE .LOC LEQ .MAX_MEM_ADR DO
	ERROR_LOOP(1)
	(
	    ERRINFO[0] = .LOC;
	    MEM_DEPOSIT(0,-1);
	    MEM_DEPOSIT(.LOC,-1);
	    CP(2);

	    VAL = MEM_EXAMINE(0);
	    IF .VAL NEQ .LOC
	    THEN
	    (
		ERRCAS(1,1,.LOC,.VAL,12,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);

	    VAL = MEM_EXAMINE(.LOC);
	    IF .VAL NEQ -1
	    THEN
	    (
		ERRCAS(1,2,-1,.VAL,12,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,2);

	    LOC = .LOC ^ 1;
	    SET_CRAM_ADR(TUA_NXT);
	    CP(1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOCS 0, \O0
!*	KS10:	WRITE \O0 TO MEM LOC 0
!*	8080:	READ MEM LOC 0
!*RESPONSE:
!*	MEM LOC 0 SHOULD BE \O0

!*MESSAGE 2
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOCS 0, \O0
!*	KS10:	WRITE 1 TO MEM LOC 0
!*	8080:	READ MEM LOC \O0
!*RESPONSE:
!*	MEM LOC \O0 SHOULD BE -1

!]ERROR 1
!]BUS_REQ_A BUS_ALL BUS_MUX_VMA BUS_MUX_DP VMA_ALL_N MEM_WRITE_N MEM_CAC_INH_N FORCE AC_REF MEM_EN NTWK

!]NO ERROR 1
!]BUS_REQ_A  NTWK

    END;

GLOBAL ROUTINE TST32: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE DATA INPUTS/OUTPUTS AND DPM MUX ADDRESS INPUTS
!	CAUSE ECC ERROR AT VMA 377777 AND THEN 777777
!	MAPPED TO PMA 777, 1777, 2777, 4777, ..., MAX_MEM_ADR
!	THIS ALSO CHECKS PAGE FAIL LOGIC (WRITABLE AND WRITE-TEST ON)
!
!--

    BEGIN

    LOCAL
	OK,
	VMA,
	CURR_PAGE,
	NEXT_PAGE,
	COR_MEM_ADR,
	ACT_MEM_ADR,
	CRAM_ADR;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'420',
	TST_U = PLIT
	    (
%(0420)%    U_J(422) V_DP_N(377777) U_B_T0 U_DEST_AD U,
%(0421)%    U_J(422) V_DP_N(777777) U_B_T0 U_DEST_AD U,
%(0422)%    U_J(423) V_DP_T0 U_MEM U_N(3010) U_SPEC_LDPAGE U,
%(0423)%    U_J(0) V_DP_N(440000) U,	! J, #<6:17> CHANGE
%(0424)%    U_J(425) V_DP_T0 U_MEM U_N(32012) U,
%(0425)%    U_J(426) V_DP_0 U_MEM U_N(2) U,
%(0426)%    U_J(427) V_DP_T0 U_MEM U_N(42012) U,
%(0427)%    U_J(0) U_MEM U_N(2) U	! J CHANGES
	    ),
	TUA_PAG = TST_U_ADR + 3,	! WHERE TO DIDDLE PAGE MAP
	TUA_PE1 = TST_U_ADR + 3,	! WHERE TO ENABLE PAGING
	TUA_CONT = TST_U_ADR + 4,	! WHERE TO CONTINUE AFTER THAT
	TUA_PE0 = TST_U_ADR + 7;	! WHERE TO DISABLE PAGING

    LOAD_TST_U;
    SET_CRAM_ADR(TUA_PE1);
    MOD_FLD(0,PE1_ADR);
    SET_CRAM_ADR(TUA_PE0);
    MOD_FLD(0,PE0_ADR);

    RPT_ERR_FLAG = 0;
    OK = 1;
    CURR_PAGE = 0;			! START AT PAGE 0
    NEXT_PAGE = %O'1000';		! NEXT PAGE WILL BE 1
    WHILE .CURR_PAGE LEQ .MAX_MEM_ADR DO
    (
	VMA = %O'377777';		! DO VMA<18> = 0 SIDE FIRST
	ERRINFO[0] = COR_MEM_ADR = .CURR_PAGE OR %O'777';
	ERRINFO[1] = %O'440000' OR (.CURR_PAGE^(-9));
	SET_CRAM_ADR(TUA_PAG);		! U-WORD TO DIDDLE TO
	MOD_FLD(3,.CURR_PAGE^(-9));	!  DO THIS PHYSICAL PAGE
	INCR PAIR_SIDE FROM 0 TO 1 DO
	(
	    ERRINFO[2] = .VMA;
	    ERRINFO[3] = .VMA ^ (-9);	! PAGE NUMBER
	    ERROR_LOOP(1)
	    (
		DI(100000,376);			! SET MMC FORCE BITS
		SET_CRAM_ADR(TST_U_ADR+.PAIR_SIDE);	! START FOR THIS SIDE
		CP(5);				! SET UP & ENABLE PAGING
		SET_CRAM_ADR(TUA_CONT);		! COME BACK TO WORK...
		CP(6);				!   AND DISABLE PAGING
		CRAM_ADR = STEP_U_NEXT(9);	! DO IT AND CHECK...
		IF .CRAM_ADR EQL O7777		! IF -1 WE HAD PAGE FAIL
		THEN
		(
		    ERRINFO[4] = PF_TRAP();
		    ERRINFO[5] = PF_NAME(.ERRINFO[4]);
		    ERRS(1,1,ERRINFO);
		    OK = 0;
		)
		ELSE
		    IFN (RD_301 AND %O'100')	! IF BIT SET WE HIT NXM
		    THEN
		    (
			ERRS(1,2,ERRINFO);
			OK = 0;
			MR();			! CLEAR MMC ERR HOLD BIT
		    )
		    ELSE
		    (
			ACT_MEM_ADR = EI(100000) AND %O'17777777';	! ERR ADDR
			MR();			! CLEAR MMC ERR HOLD BIT
			IF .ACT_MEM_ADR NEQ .COR_MEM_ADR
			THEN
			(
			    ERRCAS(1,3,.COR_MEM_ADR,.ACT_MEM_ADR,8,ERRINFO);
			    OK = 0;
			);
		    );
		EXIT_LOOP(1,1);
		0
	    );
	    VMA = %O'777777';	! DO OTHER SIDE OF RAMS
	);
	CURR_PAGE = .NEXT_PAGE;
	NEXT_PAGE = .NEXT_PAGE ^ 1;
    );

    IFN .OK THEN NOERR(1);

    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	LOAD \O1 INTO PAGE TABLE LOC \O3
!*		DEPOSIT 0 TO VIRTUAL MEM LOC \O2 (WITH WRONG ECC)
!*		READ VIRTUAL MEM LOC \O2 (CAUSING AN ERROR)
!*RESPONSE:
!*	PAGE FAIL U-TRAP TO CRAM ADDR 7777 (SHOULDN'T HAPPEN)
!*	PAGE FAIL CODE \O4 (\S5)

!*MESSAGE 2
!*STIMULUS:
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	LOAD \O1 INTO PAGE TABLE LOC \O3
!*		DEPOSIT 0 TO VIRTUAL MEM LOC \O2 (WITH WRONG ECC)
!*		READ VIRTUAL MEM LOC \O2 (CAUSING AN ERROR)
!*RESPONSE:
!*	REFERENCE WAS MADE TO NXM (NOT MEM LOC 0)

!*MESSAGE 3
!*STIMULUS:
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	LOAD \O1 INTO PAGE TABLE LOC \O3
!*		DEPOSIT 0 TO VIRTUAL MEM LOC \O2 (WITH WRONG ECC)
!*		READ VIRTUAL MEM LOC \O2 (CAUSING AN ERROR)
!*	8080:	READ I/O REGISTER 100000 BITS <14:35>
!*RESPONSE:
!*	SHOULD GET \O0 (PHYSICAL ADDR OF LAST ERROR)

!]ERROR 1
!]PT_IO PT_VAL_WRT PT_USR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]PT_IO NTWK

    END;

GLOBAL ROUTINE TST33: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE ADDRESS LINES
!	CAUSE ECC ERROR ON PAGES 0,1,2,4,10,20,40,100,200
!	MAPPED TO PHYSICAL PAGES 0,1,2,3,4,5,6,7,10
!	FOR EACH SIDE OF THE RAM PAIRS (+0,+400)
!
!--

    BEGIN

    LOCAL
	PTE,
	VMA,
	COR_PMA,
	ACT_PMA,
	OK;

    OWN
	INFO: VECTOR[18] INITIAL	! VIRTUAL PAGE NUMBERS TO TEST
	    (
	    %O'000', %O'400',
	    %O'001', %O'401',
	    %O'002', %O'402',
	    %O'004', %O'404',
	    %O'010', %O'410',
	    %O'020', %O'420',
	    %O'040', %O'440',
	    %O'100', %O'500',
	    %O'200', %O'600'
	    );

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'440',
	TST_U = PLIT
	    (
%(0440)%    U_J(0) V_DP_N(0) U_B_T0 U_DEST_AD U,	! J, #<0:17> CHANGE
%(0441)%    U_J(442) V_DP_T0 U_MEM U_N(3010) U_SPEC_LDPAGE U,
%(0442)%    V_DP_N(440000) U,	! #<6:17> CHANGES
%(0443)%    U_J(444) V_DP_T0 U_MEM U_N(12012) U,
%(0444)%    U_J(445) V_DP_0 U_MEM U_N(2) U,
%(0445)%    U_J(446) V_DP_T0 U_MEM U_N(42012) U,
%(0446)%    U_MEM U_N(2) U
	    ),
	TUA_VMA = TST_U_ADR + 0,	! WHERE TO DIDDLE VMA TO USE
	TUA_PAG = TST_U_ADR + 2,	! WHERE TO DIDDLE PAGE MAP
	TUA_TST = TST_U_ADR + 3;	! WHERE TO START TEST ITSELF

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;
    OK = 1;

    SET_CRAM_ADR(TUA_VMA);		! FIX J FIELD FOR LOADING
    MOD_FLD(0,TUA_VMA+1);		!   THE PAGE TABLE

    INCR ERRN FROM 0 TO 17 DO		! LOAD THE PAGE TABLE
    (
	VMA = (.INFO[.ERRN] ^ 9) + %O'777';
	PTE = %O'440000' OR .ERRN;
	SET_CRAM_ADR(TUA_PAG);
	MOD_FLD(3,.PTE<N_FLD3>);	! DIDDLE #<6:17>
	SET_CRAM_ADR(TUA_VMA);
	MOD_FLD(3,.VMA<N_FLD3>);	! DIDDLE #<6:17>
	MOD_FLD(4,.VMA<N_FLD4>);	! DIDDLE #<0:5>; ZAP OTHER BITS
	CP(4);			! STUFF THE ENTRY IN THE PAGE TABLE
				! EXTRA CLOCK PULSE NEEDED (REALLY!!!)
    );

    PAGING_ON;

    SET_CRAM_ADR(TUA_VMA);		! FIX J FIELD FOR
    MOD_FLD(0,TUA_TST);			!   THE TESTS

    INCR ERRN FROM 0 TO 17 DO		! DO THE TESTS
    (
	ERRINFO[0] = COR_PMA = (.ERRN ^ 9) + %O'777';
	ERRINFO[1] = VMA = (.INFO[.ERRN] ^ 9) + %O'777';
	ERRINFO[2] = PTE = %O'440000' OR .ERRN;
	ERRINFO[3] = .INFO[.ERRN];
	SET_CRAM_ADR(TUA_VMA);
	MOD_FLD(3,.VMA<N_FLD3>);	! DIDDLE #<6:17>
	MOD_FLD(4,.VMA<N_FLD4>);	! DIDDLE #<0:5>; ZAP OTHER BITS
	ERROR_LOOP(1)
	(
	    DI(100000,376);		! SET MMC FORCE BITS
	    SET_CRAM_ADR(TUA_VMA);
	    				! EXTRA CLOCK PULSE NEEDED...
	    IF STEP_U_NEXT(6) EQL O7777	! IF -1 WE HAD PAGE FAIL
	    THEN
	    (
		ERRINFO[4] = PF_TRAP();
		ERRINFO[5] = PF_NAME(.ERRINFO[4]);
		ERRS(1,1,ERRINFO);
		PAGING_ON;
	    )
	    ELSE
		IFN (RD_301 AND %O'100')	! IF BIT SET WE HIT NXM
		THEN
		(
		    ERRS(1,2,ERRINFO);
		    MR();		! CLEAR MMC ERR HOLD BIT
		)
		ELSE
		(
		    ACT_PMA = EI(100000) AND %O'17777777';	! ERR ADDR
		    MR();		! CLEAR MMC ERR HOLD BIT
		    IF .ACT_PMA NEQ .COR_PMA
		    THEN
		    (
			ERRCAS(1,3,.COR_PMA,.ACT_PMA,8,ERRINFO);
			OK = 0;
		    );
		);
	    EXIT_LOOP(1,1);
	    0
	);
    );

    IFN .OK THEN NOERR(1);

    PAGING_OFF;
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	DEPOSIT 0 TO VIRTUAL MEM LOC \O1 (WITH WRONG ECC)
!*		READ VIRTUAL MEM LOC \O1 (CAUSING AN ERROR)
!*RESPONSE:
!*	PAGE FAIL U-TRAP TO CRAM ADDR 7777 (SHOULDN'T HAPPEN)
!*	PAGE FAIL CODE \O4 (\S5)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	DEPOSIT 0 TO VIRTUAL MEM LOC \O1 (WITH WRONG ECC)
!*		READ VIRTUAL MEM LOC \O1 (CAUSING AN ERROR)
!*RESPONSE:
!*	REFERENCE WAS MADE TO NXM (NOT MEM LOC 0)

!*MESSAGE 3
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*	8080:	DEPOSIT 376 TO I/O REGISTER 100000
!*		(SETTING ALL MMC ECC FORCE BITS)
!*	KS10:	DEPOSIT 0 TO VIRTUAL MEM LOC \O1 (WITH WRONG ECC)
!*		READ VIRTUAL MEM LOC \O1 (CAUSING AN ERROR)
!*	8080:	READ I/O REGISTER 100000 BITS <14:35>
!*RESPONSE:
!*	SHOULD GET \O0 (PHYSICAL ADDR OF LAST ERROR)

!]ERROR 1
!]PT_ADR PT_IO PT_VAL_WRT PT_USR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]PT_ADR SPEC_PAGE NTWK

    END;

GLOBAL ROUTINE TST34: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE VALID, WRITABLE PINS
!	FOR EACH SIDE OF THE RAM PAIRS (0,400)
!	THIS ALSO CHECKS PAGE FAIL LOGIC (WRITABLE OFF, WRITE-TEST ON)
!
!--

    BEGIN

    MACRO
	PF_INFO_CAUSE = 0,0,36,0 %,	! CORRECT PAGE FAIL CAUSE
	PF_INFO_PTE = 1,0,36,0 %;	! PAGE TABLE ENTRY FOR TEST

    LOCAL
	PTE,
	VMA,
	COR_PF_CAUSE,
	ACT_PF_CAUSE,
	OK;

    OWN
	VMA_INFO: VECTOR[2] INITIAL
	    (%O'000777', %O'400777'),	! LAST LOC FIRST PAGE EACH SIDE
	PF_INFO: BLOCKVECTOR[2,2] INITIAL
	    (
	    %O'12', %O'040000',		! INVALID, WRITABLE
	    %O'10', %O'400000'		! VALID, UNWRITABLE
	    );

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'460',
	TST_U = PLIT
	    (
%(0460)%    U_J(0) V_DP_N(0777) U_B_T0 U_DEST_AD U,	! J, #<0:6> CHANGE
%(0461)%    U_J(462) V_DP_T0 U_MEM U_N(3010) U_SPEC_LDPAGE U,
%(0462)%    V_DP_N(0) U,	! #<0:17> CHANGES
%(0463)%    U_J(464) V_DP_T0 U_MEM U_N(32012) U,
%(0464)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_VMA = TST_U_ADR + 0,	! WHERE TO DIDDLE VMA TO USE
	TUA_PAG = TST_U_ADR + 2,	! WHERE TO DIDDLE PAGE MAP
	TUA_TST = TST_U_ADR + 3;	! WHERE TO START TEST ITSELF

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;
    OK = 1;

    INCR SUBTEST FROM 0 TO 1 DO		! INVALIDS THEN UNWRITABLES
    (
	SET_CRAM_ADR(TUA_VMA);		! FIX J FIELD FOR LOADING
	MOD_FLD(0,TUA_VMA+1);		!   THE PAGE TABLE
	ERRINFO[2] = PTE = .PF_INFO[.SUBTEST,PF_INFO_PTE];
	ERRINFO[6] = COR_PF_CAUSE = .PF_INFO[.SUBTEST,PF_INFO_CAUSE];
	ERRINFO[7] = PF_NAME(.ERRINFO[6]);

	INCR SIDE FROM 0 TO 1 DO	! SET UP BOTH SIDES (SWEEP?)
	(
	    VMA = .VMA_INFO[.SIDE];
	    SET_CRAM_ADR(TUA_PAG);
	    MOD_FLD(3,.PTE<N_FLD3>);	! DIDDLE #<6:17>
	    MOD_FLD(4,.PTE<N_FLD4>);	! DIDDLE #<0:5>; ZAP OTHER BITS
	    SET_CRAM_ADR(TUA_VMA);
	    MOD_FLD(4,.VMA<N_FLD4>);	! DIDDLE #<0:5>; ZAP OTHER BITS
	    CP(4);			! STUFF THE ENTRY IN THE PAGE TABLE
					! EXTRA CLOCK PULSE NEEDED
	);

	SET_CRAM_ADR(TUA_VMA);		! FIX J FIELD FOR
	MOD_FLD(0,TUA_TST);		!   THE TESTS

	INCR SIDE FROM 0 TO 1 DO	! BOTH SIDES
	(
	    ERRINFO[1] = VMA = .VMA_INFO[.SIDE];
	    ERRINFO[3] = .VMA ^ (-9);
	    SET_CRAM_ADR(TUA_VMA);
	    MOD_FLD(4,.VMA<N_FLD4>);	! DIDDLE #<0:5>; ZAP OTHER BITS
	    ERROR_LOOP(1)
	    (
		PAGING_ON;
		SET_CRAM_ADR(TUA_VMA);
		IF STEP_U_NEXT(4) EQL O7777	! EXTRA CLOCK PULSE?
		THEN
		(
		    ERRINFO[4] = ACT_PF_CAUSE = PF_TRAP();
		    ERRINFO[5] = PF_NAME(.ERRINFO[4]);
		    IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
		    THEN
		    (
			ERRCAS(1,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
			OK = 0;
		    );
		)
		ELSE
		(
		    ERRS(1,2,ERRINFO);
		    OK = 0;
		);
		EXIT_LOOP(1,1);
		0
	    );
	);

	PAGING_OFF;
    );

    IFN .OK THEN NOERR(1);

    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*		WRITE/WRITE TEST TO VIRTUAL ADDR \O1 (CAUSING AN ERROR)
!*RESPONSE:
!*	PAGE FAIL U-TRAP TO CRAM ADDR 7777
!*	CORRECT: PAGE FAIL CODE \O6 (\S7)
!*	ACTUAL:  PAGE FAIL CODE \O4 (\S5)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*		WRITE/WRITE TEST TO VIRTUAL ADDR \O1 (CAUSING AN ERROR)
!*RESPONSE:
!*	SHOULD GET PAGE FAIL U-TRAP TO CRAM ADDR 7777 (DIDN'T)
!*	CORRECT: PAGE FAIL CODE \O6 (\S7)

!]ERROR 1
!]PT_VAL_WRT PT_IO PF_WT PF_CODE PT_USR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]PT_VAL_WRT NTWK

    END;

GLOBAL ROUTINE TST35: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST VMA USER, VMA PREV
!	THIS LOADS LOTS OF U-CODE (SOMEDAY IT MAY DO MODIFY-FIELDS)
!
!--

    BEGIN

    MACRO
	INFO_COR_PREV = 0,0,36,0 %,	! CORRECT VMA PREVIOUS
	INFO_COR_USER = 1,0,36,0 %,	! CORRECT VMA USER
	INFO_EXECUTE = 2,0,36,0 %,	! CSL EXECUTE
	INFO_USER = 3,0,36,0 %,		! DPE USER
	INFO_PCU = 4,0,36,0 %,		! DPE PCU
	INFO_SPEC = 5,0,36,0 %,		! U-CODE SPEC FIELD
	INFO_N = 6,0,36,0 %;		! #

    LOCAL
	CSL_EXECUTE,
	VMA,
	ACT_PREV,
	ACT_USER,
	COR_PREV,
	COR_USER,
	OK;

    OWN
	INFO: BLOCKVECTOR[11,7] INITIAL
	    (
	    1, 1, 1, 0, 1, %O'00', %O'203110',
	    1, 0, 1, 0, 0, %O'16', %O'203010',
	    0, 0, 1, 0, 1, %O'00', %O'203010',
	    0, 1, 1, 0, 0, %O'00', %O'603010',
	    0, 0, 1, 0, 0, %O'00', %O'303010',
	    0, 0, 1, 1, 0, %O'00', %O'203010',
	    0, 1, 1, 1, 0, %O'00', %O'303010',
	    0, 1, 0, 1, 0, %O'00', %O'003010',
	    0, 0, 0, 0, 0, %O'00', %O'003010',
	    0, 0, 1, 1, 0, %O'00', %O'003010',
	    0, 0, 0, 1, 0, %O'00', %O'203010'
	    );

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'470',
	TST_U = PLIT
	    (
%(0470)%    V_D_N(400) V_DP_D U_SPEC_LDPXCT U,		! A PXCT BIT ON
%(0471)%    U_J(521) V_DP_0 U_SPEC_PXCT_OFF U,		! PXCT BITS OFF
%(0472)%    U_DBM_VMA U_DBUS_DBM V_DP_D U_DEST_Q_AD U,	! SAVE FLAGS
%(0473)%    U_J(474) V_D_N(004404) V_DP_D U_SPEC_FLAGS U,
%(0474)%    U_J(472) U_N(203110) U_MEM U,
%(0475)%    U_J(476) V_D_N(000004) V_DP_D U_SPEC_FLAGS U,
%(0476)%    U_J(472) U_N(203010) U_MEM U_SPEC_PREV U,
%(0477)%    U_J(500) V_D_N(004404) V_DP_D U_SPEC_FLAGS U,
%(0500)%    U_J(472) U_N(203010) U_MEM U,
%(0501)%    U_J(502) V_D_N(000004) V_DP_D U_SPEC_FLAGS U,
%(0502)%    U_J(472) U_N(603010) U_MEM U,
%(0503)%    U_J(504) V_D_N(000004) V_DP_D U_SPEC_FLAGS U,
%(0504)%    U_J(472) U_N(303010) U_MEM U,
%(0505)%    U_J(506) V_D_N(010004) V_DP_D U_SPEC_FLAGS U,
%(0506)%    U_J(472) U_N(203010) U_MEM U,
%(0507)%    U_J(510) V_D_N(010004) V_DP_D U_SPEC_FLAGS U,
%(0510)%    U_J(472) U_N(303010) U_MEM U,
%(0511)%    U_J(512) V_D_N(010004) V_DP_D U_SPEC_FLAGS U,
%(0512)%    U_J(472) U_N(003010) U_MEM U,
%(0513)%    U_J(514) V_D_N(000004) V_DP_D U_SPEC_FLAGS U,
%(0514)%    U_J(472) U_N(003010) U_MEM U,
%(0515)%    U_J(516) V_D_N(010004) V_DP_D U_SPEC_FLAGS U,
%(0516)%    U_J(472) U_N(003010) U_MEM U,
%(0517)%    U_J(520) V_D_N(010004) V_DP_D U_SPEC_FLAGS U,
%(0520)%    U_J(472) U_N(203010) U_MEM U,
%(0521)%    V_D_N(4) V_DP_D U_SPEC_FLAGS U
	    ),
	TUA_INIT = TST_U_ADR + 0,
	TUA_FINI = TST_U_ADR + 1,
	TUA_BASE = TST_U_ADR + 3;

    LOAD_TST_U;
    SET_CRAM_ADR(TUA_INIT);
    CP(2);			! EXTRA CLOCK PULSE NEEDED?
    OK = 1;

    INCR SUBTEST FROM 0 TO 10 DO
	ERROR_LOOP(1)
	(
	    ERRINFO[0] = CSL_EXECUTE = .INFO[.SUBTEST,INFO_EXECUTE];
	    ERRINFO[1] = COR_PREV = .INFO[.SUBTEST,INFO_COR_PREV];
	    ERRINFO[2] = COR_USER = .INFO[.SUBTEST,INFO_COR_USER];
	    ERRINFO[5] = .INFO[.SUBTEST,INFO_USER];
	    ERRINFO[6] = .INFO[.SUBTEST,INFO_PCU];
	    ERRINFO[7] = .INFO[.SUBTEST,INFO_N];
	    ERRINFO[8] = .INFO[.SUBTEST,INFO_SPEC];
	    WRT212(.CSL_EXECUTE * 2);
	    SET_CRAM_ADR(TUA_BASE + (.SUBTEST * 2));
	    CP(3);
	    VMA = SERIAL(10);
	    ERRINFO[3] = ACT_PREV = .VMA<0,1>;
	    ERRINFO[4] = ACT_USER = .VMA<9,1>;
	    IF (.ACT_PREV NEQ .COR_PREV) OR (.ACT_USER NEQ .COR_USER)
	    THEN
	    (
		ERRS(1,1,ERRINFO);
		OK = 0;
	    );
	    MR();		! DON'T GO AWAY IN USER MODE
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

    SET_CRAM_ADR(TUA_FINI);	! TURN PXCT & FLAGS BACK OFF
    CP(3);			! EXTRA CLOCK PULSE NEEDED?
    WRT212(0);			! TURN CSL EXECUTE BACK OFF

!*MESSAGE 1
!*STIMULUS:
!*	CSL EXECUTE = \O0
!*	DPE USER = \O5, DPE PCU = \O6
!*	# = \O7, SPEC FIELD = \O8, LOAD VMA FLAGS
!*RESPONSE:
!*	CORRECT: PREV = \O1, USER = \O2
!*	ACTUAL:  PREV = \O3, USER = \O4

!]ERROR 1
!]VMA_USER_PREV SPEC_PREV SPEC_PXCT MEM_EN N_ALL VMA_EN DBM_VMA_MEM DBM_SEL_VMA NTWK

!]NO ERROR 1
!]VMA_USER_DP VMA_USER_N VMA_PREV_DP VMA_PREV_N SPEC_PXCT_OFF SPEC_PREV NTWK

    END;

GLOBAL ROUTINE TST36: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE USER PINS & EXEC/USER MISMATCH PAGE FAIL
!	FOR EACH SIDE OF THE RAM PAIRS (0,400)
!
!--

    BEGIN

    LOCAL
	VMA,
	COR_PF_CAUSE,
	ACT_PF_CAUSE,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'540',
	TST_U = PLIT
	    (
%(0540)%    V_DP_N(000777) U_B_T0 U_DEST_AD U,
%(0541)%    V_DP_N(400777) U_B_T0 U_DEST_AD U,
%(0542)%    U_J(544) V_DP_T0 U_MEM U_N(203010) U_SPEC_LDPAGE U,
%(0543)%    U_J(544) V_DP_T0 U_MEM U_N(403010) U_SPEC_LDPAGE U,
%(0544)%    V_DP_N(400000) U,
%(0545)%    U_J(547) V_DP_T0 U_MEM U_N(232012) U,
%(0546)%    U_J(547) V_DP_T0 U_MEM U_N(432012) U,
%(0547)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_LDVMA = TST_U_ADR + 0,	! LOAD VMA TO USE INTO T0
	TUA_LDPAG = TST_U_ADR + 2,	! LOAD PAGE TABLE ENTRY
	TUA_WRITE = TST_U_ADR + 5;	! WRITE, TO SEE HOW IT FAILS

    LOAD_TST_U;
    OK = 1;

    INCR SIDE FROM 0 TO 1 DO
    (
	ERRINFO[0] = VMA = (.SIDE ^ 17) OR %O'777';
	ERRINFO[1] = .VMA<9,9>;
	SET_CRAM_ADR(TUA_LDVMA + .SIDE);
	CP(2);			! EXTRA CLOCK PULSE NEEDED
	INCR PAGE_USER FROM 0 TO 1 DO
	(
	    ERRINFO[2] = .PAGE_USER;
	    SET_CRAM_ADR(TUA_LDPAG + .PAGE_USER);
	    CP(3);		! EXTRA CLOCK PULSE NEEDED
	    INCR WRITE_USER FROM 0 TO 1 DO
	    (
		ERRINFO[3] = .WRITE_USER;
		ERRINFO[4] = COR_PF_CAUSE =
		(
		    IF .PAGE_USER EQL .WRITE_USER
		    THEN
			%O'10'
		    ELSE
			%O'13'
		);
		ERRINFO[5] = PF_NAME(.COR_PF_CAUSE);
		ERROR_LOOP(1)
		(
		    PAGING_ON;
		    SET_CRAM_ADR(TUA_WRITE + .WRITE_USER);
		    IF STEP_U_NEXT(3) EQL O7777	! EXTRA CLOCK PULSE
		    THEN
		    (
			ERRINFO[6] = ACT_PF_CAUSE = PF_TRAP();
			ERRINFO[7] = PF_NAME(.ACT_PF_CAUSE);
			IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
			THEN
			(
			    ERRCAS(1,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
			    OK = 0;
			);
		    )
		    ELSE
		    (
			ERRS(1,2,ERRINFO);
			OK = 0;
		    );
		    PAGING_OFF;
		    EXIT_LOOP(1,1);
		    0
		);
	    );
	);
    );

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD 400000 INTO PAGE TABLE LOC \O1, USER = \O2
!*		WRITE/WRITE TEST TO VIRTUAL ADDR \O0, USER = \O3
!*RESPONSE:
!*	PAGE FAIL U-TRAP TO CRAM ADDR 7777
!*	CORRECT: PAGE FAIL CODE \O4 (\S5)
!*	ACTUAL:  PAGE FAIL CODE \O6 (\S7)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	LOAD 400000 INTO PAGE TABLE LOC \O1, USER = \O2
!*		WRITE/WRITE TEST TO VIRTUAL ADDR \O0, USER = \O3
!*RESPONSE:
!*	PAGE FAIL U-TRAP TO CRAM ADDR 7777 (DIDN'T)
!*	CORRECT: PAGE FAIL CODE \O4 (\S5)

!]ERROR 1
!]PT_USR PT_IO PT_VAL_WRT PT_USR PT_MESS N_ALL PF_CODE NTWK

!]NO ERROR 1
!]PT_USR NTWK

    END;

GLOBAL ROUTINE TST37: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK PAGE FAIL LOGIC (WRITABLE ON, WRITE-TEST OFF)
!
!--

    BEGIN

    LOCAL
	VMA,
	COR_PF_CAUSE,
	ACT_PF_CAUSE,
	CRAM_ADR,
	MEM_VAL;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'550',
	TST_U = PLIT
	    (
%(0550)%    U_J(551) V_DP_N(000777) U_B_T0 U_DEST_AD U,
%(0551)%    U_J(552) V_DP_T0 U_MEM U_N(203010) U_SPEC_LDPAGE U,
%(0552)%    V_DP_N(440000) U,
%(0553)%    U_J(554) V_DP_T0 U_MEM U_N(212012) U,
%(0554)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_LDPAG = TST_U_ADR + 0,	! LOAD PAGE TABLE ENTRY
	TUA_WRITE = TST_U_ADR + 3;	! WRITE, TO SEE IF IT FAILS

    LOAD_TST_U;
    ERRINFO[1] = COR_PF_CAUSE = %O'11';	! 74148: EN = L --> Q1,Q2,Q4 = H
    ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
    ERROR_LOOP(1)
    (
	DM(777,'-1');			! SET LOCATION (%STRING HACK!)
	SET_CRAM_ADR(TUA_LDPAG);	! LOAD THE PAGE TABLE
	CP(4);				! EXTRA CLOCK PULSE
	PAGING_ON;
	SET_CRAM_ADR(TUA_WRITE);	! WRITE THE LOCATION (THE TEST)
	CRAM_ADR = STEP_U_NEXT(3);	!   AND REMEMBER WHAT HAPPENED
	ERRINFO[0] = MEM_VAL = EM(777);	! SEE IF IT GOT WRITTEN
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .CRAM_ADR EQL O7777
	THEN
	    ERRS(1,1,ERRINFO)
	ELSE
	    IFN .MEM_VAL
	    THEN
		ERRS(1,2,ERRINFO)	! DIDN'T WRITE
	    ELSE
		IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
		THEN
		    ERRS(1,3,ERRINFO)	! WRONG DEFAULT PF CAUSE
		ELSE
		    NOERR(1);		! SUCCESS
	PAGING_OFF;
	EXIT_LOOP(1,1);
	0
    );

!*MESSAGE 1
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOC 777
!*	KS10:	LOAD 440000 INTO PAGE TABLE LOC 0
!*		WRITE 0 TO MEM LOC 777 WITH WRITE-TEST OFF
!*RESPONSE:
!*	MEM LOC 777 SHOULD BE 0 (BUT IT IS \O0)
!*	SHOULD NOT GET PAGE FAIL TRAP (BUT IT DID)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 2
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOC 777
!*	KS10:	LOAD 440000 INTO PAGE TABLE LOC 0
!*		WRITE 0 TO MEM LOC 777 WITH WRITE-TEST OFF
!*RESPONSE:
!*	MEM LOC 777 SHOULD BE 0 (BUT IT IS \O0)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 3
!*STIMULUS:
!*	8080:	WRITE -1 TO MEM LOC 777
!*	KS10:	LOAD 440000 INTO PAGE TABLE LOC 0
!*		WRITE 0 TO MEM LOC 777 WITH WRITE-TEST OFF
!*RESPONSE:
!*	MEM LOC 777 SHOULD BE 0 (IT IS)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!]ERROR 1
!]PT_VAL_WRT PT_IO PF_WT PF_CODE PT_USR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]PF_WT NTWK

    END;

GLOBAL ROUTINE TST38: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK PAGE FAIL LOGIC (NXM ERROR)
!	    CAUSE AN NXM ERROR AND SEE IF WE GET THE
!		PF TRAP AND CORRECT DISPATCH
!	    INSURE THAT THE ERROR PERSISTS WITHOUT SPEC/MEM CLR
!	    INSURE THAT THE ERROR IS CLEARED BY SPEC/MEM CLR
!
!--

    BEGIN

    LOCAL
	COR_PF_CAUSE,
	ACT_PF_CAUSE,
	CRAM_ADR,
	MEM_VAL,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'560',
	TST_U = PLIT
	    (
%(0560)%    U_J(561) V_DP__1 U_MEM U_N(403010) U_SPEC_LDPAGE U,
%(0561)%    V_DP_N(443777) U,
%(0562)%    U_J(563) V_DP__1 U_MEM U_N(430012) U,
%(0563)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_LDPAG = TST_U_ADR + 0,	! LOAD PAGE TABLE ENTRY
	TUA_WRITE = TST_U_ADR + 2;	! WRITE, TO SEE HOW IT FAILS

    IF  .MAX_MEM_ADR GTR %O'3777777'	! BE SURE WE HAVE AN NXM LOC
    THEN
	RETURN;				! NO, SO FORGET THIS TEST
					!   WITHOUT ANY ERROR ANALYSIS
    LOAD_TST_U;
    OK = 1;
    RPT_ERR_FLAG = 0;

    SET_CRAM_ADR(TUA_LDPAG);		! LOAD THE PAGE TABLE
    CP(3);				! EXTRA CLOCK PULSE
    ERROR_LOOP(1)
    (
	PAGING_ON;

	SET_CRAM_ADR(TUA_WRITE);	! DO THE TEST
	CRAM_ADR = STEP_U_NEXT(3);	!   AND REMEMBER WHAT HAPPENED
	ERRINFO[1] = COR_PF_CAUSE = %O'05';	! NXM "PAGE FAIL" DISPATCH
	ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
	ERRINFO[3] = ACT_PF_CAUSE = PF_DISPATCH();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .CRAM_ADR NEQ O7777
	THEN
	    ERRS(1,2,ERRINFO)		! NO "PAGE FAIL" TRAP HAPPENED
	ELSE
	    IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	    THEN
	    (
				! NOT NXM "PAGE FAIL" DISPATCH
		ERRCAS(1,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
		OK = 0;
	    );

	SET_CRAM_ADR(O7777);	! THIS U-CODE DOES NOTHING
	CP(3);			!    LET CLOCKS GO A WHILE
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
				! NXM FLAG DIDN'T STAY SET
	    ERRCAS(1,3,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);

	ERRINFO[1] = COR_PF_CAUSE = %O'11';	! NO PAGE FAIL
	ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
	ERRINFO[3] = ACT_PF_CAUSE = PF_DISPATCH();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
	    ERRCAS(1,4,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
				! DIDN'T CLEAR NXM FLAG
	    OK = 0;
	);

	SET_CRAM_ADR(TIU_ADR);	! MAKE IT GO AWAY
	CP(TIU_CNT);
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
				! NXM FLAG DIDN'T STAY CLEAR
	    ERRCAS(1,5,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);

	PAGING_OFF;
	EXIT_LOOP(1,1);
	0
    );

    IFN .OK THEN NOERR(1);

    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD 443777 INTO PAGE TABLE LOC 777
!*		WRITE 0 TO VIRTUAL MEM LOC 777777
!*RESPONSE:
!*	SHOULD GET PAGE FAIL TRAP
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	LOAD 443777 INTO PAGE TABLE LOC 777
!*		WRITE 0 TO VIRTUAL MEM LOC 777777
!*RESPONSE:
!*	SHOULD GET PAGE FAIL TRAP (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 3
!*STIMULUS:
!*	KS10:	CAUSE NXM ERROR, DO NOTHING, SEE IF IT STAYS
!*RESPONSE:
!*	PAGE FAIL CONDITION SHOULD STAY (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 4
!*STIMULUS:
!*	KS10:	CAUSE NXM ERROR AND THEN DO SPEC/MEM CLR
!*RESPONSE:
!*	SHOULD CLEAR PAGE FAIL TRAP CONDITION (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 5
!*STIMULUS:
!*	KS10:	CAUSE NXM ERROR, CLEAR IT (SPEC/MEM CLR),
!*		DO NOTHING, SEE IF IT STAYS AWAY
!*RESPONSE:
!*	PAGE FAIL CONDITION SHOULD STAY AWAY (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!]ERROR 1
!]PT_VAL_WRT PT_IO PF_NXM SPEC_MEMCLR_NXM PF_CODE PT_USR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]PF_NXM SPEC_MEMCLR_NXM NTWK

    END;

GLOBAL ROUTINE TST39: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK PAGE FAIL LOGIC (BAD DATA ERROR)
!	    CAUSE A BAD DATA ERROR AND SEE IF WE GET THE
!		PF TRAP AND CORRECT DISPATCH
!	    INSURE THAT THE ERROR PERSISTS WITHOUT SPEC/MEM CLR
!	    INSURE THAT THE ERROR IS CLEARED BY SPEC/MEM CLR
!
!--

    BEGIN

    LOCAL
	COR_PF_CAUSE,
	ACT_PF_CAUSE,
	CRAM_ADR,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'570',
	TST_U = PLIT
	    (
%(0570)%    U_J(571) V_DP_N(777) U_B_T0 U_DEST_AD U,
%(0571)%    U_J(572) V_DP_T0 U_MEM U_N(403010) U_SPEC_LDPAGE U,
%(0572)%    V_DP_N(460000) U,
%(0573)%    U_J(574) V_DP_T0 U_MEM U_N(442012) U,
%(0574)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_LDPAG = TST_U_ADR + 0,	! LOAD PAGE TABLE ENTRY
	TUA_READ = TST_U_ADR + 3;	! READ, TO SEE HOW IT FAILS

    LOAD_TST_U;
    OK = 1;
    RPT_ERR_FLAG = 0;

    SET_CRAM_ADR(TUA_LDPAG);		! LOAD THE PAGE TABLE
    CP(4);				! EXTRA CLOCK PULSE
    ERROR_LOOP(1)
    (
	DI(100000,176);			! SET MMC ECC FORCE BITS --
					! EVEN NUMBER OF BITS ON GETS AN
					! UNCORRECTABLE DOUBLE-BIT ERROR
	DM(777,0);			! MAKE ECC BAD AT A LOCATION
	PAGING_ON;

	SET_CRAM_ADR(TUA_READ);		! DO THE TEST
	CRAM_ADR = STEP_U_NEXT(3);	!   AND REMEMBER WHAT HAPPENED
	ERRINFO[1] = COR_PF_CAUSE = %O'03';	! BAD DATA "PAGE FAIL" DISPATCH
	ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
	ERRINFO[3] = ACT_PF_CAUSE = PF_DISPATCH();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .CRAM_ADR NEQ O7777
	THEN
	(
	    ERRS(1,2,ERRINFO);		! NO "PAGE FAIL" TRAP HAPPENED
	    OK = 0;
	)
	ELSE
	    IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	    THEN
	    (
				! NOT BAD DATA "PAGE FAIL" DISPATCH
		ERRCAS(1,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
		OK = 0;
	    );

	SET_CRAM_ADR(O7777);	! THIS U-CODE DOES NOTHING
	CP(3);			!    BUT LET THE CLOCKS GO A WHILE
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
				! BAD DATA FLAG DIDN'T STAY SET
	    ERRCAS(1,3,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);

	ERRINFO[1] = COR_PF_CAUSE = %O'11';	! NO PAGE FAIL
	ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
	ERRINFO[3] = ACT_PF_CAUSE = PF_DISPATCH();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
				! DIDN'T CLEAR BAD DATA FLAG
	    ERRCAS(1,4,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);

	SET_CRAM_ADR(TIU_ADR);	! MAKE IT GO AWAY
	CP(TIU_CNT);
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
				! BAD DATA FLAG DIDN'T STAY CLEAR
	    ERRCAS(1,5,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);

	PAGING_OFF;
	EXIT_LOOP(1,1);
	0
    );

    IFN .OK THEN NOERR(1);

    DM(777,0);			! MAKE ECC GOOD AGAIN
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	8080:	DEPOSIT 176 TO I/O REGISTER 100000
!*		(SETTING EVEN NUMBER OF MMC ECC FORCE BITS)
!*		DEPOSIT 0 TO PHYSICAL MEM LOC 777 (WITH WRONG ECC)
!*	KS10:	LOAD 460000 INTO PAGE TABLE LOC 0
!*		READ VIRTUAL MEM LOC 777 (CAUSING DOUBLE-BIT ERROR)
!*RESPONSE:
!*	SHOULD GET PAGE FAIL TRAP
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 2
!*STIMULUS:
!*	8080:	DEPOSIT 176 TO I/O REGISTER 100000
!*		(SETTING EVEN NUMBER OF MMC ECC FORCE BITS)
!*		DEPOSIT 0 TO PHYSICAL MEM LOC 777 (WITH WRONG ECC)
!*	KS10:	LOAD 460000 INTO PAGE TABLE LOC 0
!*		READ VIRTUAL MEM LOC 777 (CAUSING DOUBLE-BIT ERROR)
!*RESPONSE:
!*	SHOULD GET PAGE FAIL TRAP (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 3
!*STIMULUS:
!*	KS10:	CAUSE BAD DATA ERROR, DO NOTHING, SEE IF IT STAYS
!*RESPONSE:
!*	PAGE FAIL CONDITION SHOULD STAY (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 4
!*STIMULUS:
!*	KS10:	CAUSE BAD DATA ERROR AND THEN DO SPEC/MEM CLR
!*RESPONSE:
!*	SHOULD CLEAR PAGE FAIL TRAP CONDITION (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 5
!*STIMULUS:
!*	KS10:	CAUSE BAD DATA ERROR, CLEAR IT (SPEC/MEM CLR),
!*		DO NOTHING, SEE IF IT STAYS AWAY
!*RESPONSE:
!*	PAGE FAIL CONDITION SHOULD STAY AWAY (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!]ERROR 1
!]PT_VAL_WRT PT_IO PF_WT PF_CODE PT_USR PT_MESS N_ALL PF_BAD SPEC_MEMCLR_BAD NTWK

!]NO ERROR 1
!]PF_BAD SPEC_MEMCLR_BAD NTWK

    END;

GLOBAL ROUTINE TST40: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK DPM PAGING OK ENABLING CONDITIONS GATE
!
!--

    BEGIN

    LOCAL
	COR_PF_CAUSE,
	ACT_PF_CAUSE,
	CRAM_ADR,
	OK;

    LABEL
	LOOP1,
	LOOP2,
	LOOP3,
	LOOP4;

    BIND
	TST_U_ADR = %O'600',
	TST_U = PLIT
	    (
%(0600)%    U_J(601) V_DP_0 U_MEM U_N(403010) U_SPEC_LDPAGE U,
%(0601)%    U_J(602) V_DP_0 U,
%(0602)%    U_J(604) V_DP_N(777) U_B_T0 U_DEST_AD U,
%(0603)%    U_J(604) V_DP_0 U_B_T0 U_DEST_AD U,
%(0604)%    U_J(607) V_DP_T0 U_MEM U_N(430012) U,
%(0605)%    U_J(606) V_DP_0 U_B_T0 U_DEST_AD U,
%(0606)%    U_J(607) V_DP_T0 U_MEM U_N(431012) U,
%(0607)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_LDPAG = TST_U_ADR + 0,	! LOAD PAGE TABLE ENTRY
	TUA_ACVMA = TST_U_ADR + 3,	! LOAD VMA WITH 0 (AN AC)
	TUA_PHYSVMA = TST_U_ADR + 5;	! DO PHYSICAL WRITE TO 0

    LOAD_TST_U;
    OK = 1;
    PAGING_ON;
    ERROR_LOOP(1)
    (
	SET_CRAM_ADR(TUA_LDPAG);	! LOAD PAGE TABLE, DO TEST
	CP(6);
	ERRINFO[0] = %O'777';
	ERRINFO[1] = COR_PF_CAUSE = %O'12';
	ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
	    ERRCAS(1,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(1,1);
	0
    );

    PAGING_ON;
    ERROR_LOOP(2)
    (
	SET_CRAM_ADR(TUA_ACVMA);	! JUST DO TEST
	CP(4);
	ERRINFO[0] = 0;
	ERRINFO[1] = COR_PF_CAUSE = %O'11';
	ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
	    ERRCAS(1,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(2,1);
	0
    );

    PAGING_ON;
    ERROR_LOOP(3)
    (
	SET_CRAM_ADR(TUA_PHYSVMA);	! JUST DO TEST
	CP(4);
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
	    ERRCAS(2,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(3,1);
	0
    );
    PAGING_OFF;				! ALL ELSE IS SAME AS BEFORE

    ERROR_LOOP(4)
    (
	SET_CRAM_ADR(TUA_ACVMA);	! JUST DO TEST
	CP(4);
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	THEN
	(
	    ERRCAS(3,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(4,1);
	0
    );

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	TURN PAGING ON AND LOAD 0 INTO PAGE TABLE LOC 0
!*		WRITE TO MEM LOC \O0 AND CHECK PAGE FAIL CODE
!*RESPONSE:
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	TURN PAGING ON AND LOAD 0 INTO PAGE TABLE LOC 0
!*		PHYSICAL WRITE TO MEM LOC \O0 AND CHECK PAGE FAIL CODE
!*RESPONSE:
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 3
!*STIMULUS:
!*	KS10:	LOAD 0 INTO PAGE TABLE LOC 0 AND TURN PAGING OFF
!*		WRITE TO MEM LOC \O0 AND CHECK PAGE FAIL CODE
!*RESPONSE:
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!]ERROR 1
!]PT_VAL_WRT PT_IO PF_WT PF_CODE PT_USR PT_MESS N_ALL PF_OK NTWK

!]NO ERROR 1
!]PF_OK NTWK

    END;

GLOBAL ROUTINE TST41: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK SWEEP WHEN WRITING TO PAGE TABLE
!
!--

    BEGIN

    LOCAL
	COR_PF_CAUSE,
	ACT_PF_CAUSE,
	CRAM_ADR;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'610',
	TST_U = PLIT
	    (
%(0610)%    U_J(611) V_DP_N(400000) U_B_T0 U_DEST_AD U,
%(0611)%    U_J(612) V_DP_T0 U_MEM U_N(403010) U_SPEC_LDPAGE U,
%(0612)%    U_J(613) V_DP_N(400000) U,	! VALID, UNWRITABLE
%(0613)%    U_J(614) V_DP_0 U_MEM U_N(403010) U_SPEC_SWEEP U,
%(0614)%    U_J(615) V_DP_0 U_SPEC_LDPAGE U,
%(0615)%    U_J(616) V_DP_N(040000) U,	! INVALID, WRITABLE
%(0616)%    U_J(617) V_DP_T0 U_MEM U_N(430012) U,
%(0617)%    V_DP_0 U_MEM U_N(2) U
	    );

    LOAD_TST_U;

    PAGING_ON;
    ERROR_LOOP(1)
    (
	SET_CRAM_ADR(TST_U_ADR);
	CRAM_ADR = STEP_U_NEXT(9);
	ERRINFO[1] = COR_PF_CAUSE = %O'12';
	ERRINFO[2] = PF_NAME(.COR_PF_CAUSE);
	ERRINFO[3] = ACT_PF_CAUSE = PF_TRAP();
	ERRINFO[4] = PF_NAME(.ACT_PF_CAUSE);
	IF .CRAM_ADR NEQ O7777 THEN
	    ERRCAS(1,2,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO)
	ELSE
	    IF .ACT_PF_CAUSE NEQ .COR_PF_CAUSE
	    THEN
		ERRCAS(1,1,.COR_PF_CAUSE,.ACT_PF_CAUSE,2,ERRINFO)
	    ELSE
		NOERR(1);
	EXIT_LOOP(1,1);
	0
    );
    PAGING_OFF;

!*MESSAGE 1
!*STIMULUS:
!*	MAKE PAGE 400 VALID & UNWRITABLE WITH MEM & #
!*	MAKE PAGE 0 INVALID & WRITABLE WITH SWEEP
!*	WRITE TO MEM LOC 400000
!*RESPONSE:
!*	SHOULD GET PAGE FAIL TRAP (DID)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!*MESSAGE 2
!*STIMULUS:
!*	MAKE PAGE 400 VALID & UNWRITABLE WITH MEM & #
!*	MAKE PAGE 0 INVALID & WRITABLE WITH SWEEP
!*	WRITE TO MEM LOC 400000
!*RESPONSE:
!*	SHOULD GET PAGE FAIL TRAP (DIDN'T)
!*	CORRECT: PAGE FAIL \O1 (\S2)
!*	ACTUAL:  PAGE FAIL \O3 (\S4)

!]ERROR 1
!]VMA_SWEEP_PT VMA_SWEEP SPEC_SWEEP PT_VAL_WRT PT_IO PF_WT PF_CODE PT_USR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]VMA_SWEEP_PT NTWK

    END;

GLOBAL ROUTINE TST42: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK BASIC CACHE OPERATION, ENABLES
!	    FINAL CRAM ADR = 0: ALU NOT = 0: HIT
!	    FINAL CRAM ADR = 1: ALU = 0: MISS
!	    ALSO DOES PAGE TABLE RAM CACHABLE PINS
!
!--

    BEGIN

    MACRO
	INFO_COR_ADR = 0,0,36,0 %,	! FINAL CRAM ADR
	INFO_CE = 1,0,36,0 %,		! CSL CACHE ENABLE
	INFO_PAGING = 2,0,36,0 %,	! PAGING ON
	INFO_N_VMA = 3,0,18,0 %,	! VMA IN TOTO
	INFO_N_PMA = 3,0,9,0 %,		! PMA (VMA MAPPED TO PAGE 0)
	INFO_N_VMA_FLD3 = 3,0,12,0 %,	! #<6:17> FOR VMA
	INFO_N_VMA_FLD4 = 3,12,6,0 %,	! #<0:5> FOR VMA
	INFO_N_PAG_FLD3 = 4,0,12,0 %,	! #<6:17> FOR PAGE TABLE
	INFO_N_PAG_FLD4 = 4,12,6,0 %,	! #<0:5> FOR PAGE TABLE
	INFO_N_REF_FLD3 = 5,0,12,0 %,	! #<6:17> FOR MEMORY REFERENCE
	INFO_N_REF_FLD4 = 5,12,6,0 %,	! #<0:5> FOR MEMORY REFERENCE
	INFO_DESCR = 6,0,36,0 %;	! DESCRIPTION

    LOCAL
	VMA,
	PMA,
	ACT_PF_CAUSE,
	CRAM_ADR,
	COR_CRAM_ADR,
	OK;

    OWN
	HIT_MSG: VECTOR[2] INITIAL
	    (
	    UPLIT(%ASCIZ '-1 (CACHE HIT)'),
	    UPLIT(%ASCIZ '0 (CACHE MISS)')
	    ),
	INFO: BLOCKVECTOR[11,7] INITIAL
	    (
	    0, 1, 1, %O'000777', %O'460000', %O'440012', UPLIT(%ASCIZ 'CACHE ENABLED, USER'),
	    0, 1, 1, %O'400777', %O'460000', %O'440012', UPLIT(%ASCIZ 'CACHE ENABLED, USER'),
	    0, 1, 1, %O'000377', %O'460000', %O'440012', UPLIT(%ASCIZ 'CACHE ENABLED, USER'),
	    0, 1, 1, %O'000777', %O'460000', %O'240012', UPLIT(%ASCIZ 'CACHE ENABLED, EXEC'),
	    0, 1, 1, %O'000377', %O'460000', %O'240012', UPLIT(%ASCIZ 'CACHE ENABLED, EXEC'),
	    1, 0, 1, %O'000777', %O'460000', %O'440012', UPLIT(%ASCIZ 'CACHE DISABLED'),
	    1, 1, 0, %O'000777', %O'460000', %O'440012', UPLIT(%ASCIZ 'PAGING DISABLED'),
	    1, 1, 1, %O'000777', %O'460000', %O'442012', UPLIT(%ASCIZ 'MEM CACHE INHIBIT'),
	    1, 1, 1, %O'000777', %O'460000', %O'441012', UPLIT(%ASCIZ 'MEM PHYSICAL'),
	    1, 1, 1, %O'000777', %O'440000', %O'440012', UPLIT(%ASCIZ 'PAGE UNCACHABLE'),
	    1, 1, 1, %O'400777', %O'440000', %O'440012', UPLIT(%ASCIZ 'PAGE UNCACHABLE')
	    );

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'630',
	TST_U = PLIT
	    (
%(0630)%    U_J(631) V_DP_N(000777) U_B_T0 U_DEST_AD U,		! #
%(0631)%    U_J(632) V_DP_T0 U_MEM U_N(001010) U_SPEC_LDPAGE U,	! #
%(0632)%    U_J(633) V_DP_N(460000) U,				! #
%(0633)%    U_J(634) V_DP_T0 U_MEM U_N(030012) U,		! #
%(0634)%    V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(0635)%    U_J(636) V_DP_T0 U_MEM U_N(040012) U,		! #
%(0636)%    V_DP_D U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_PAGVMA = TST_U_ADR + 1,
	TUA_PAG = TST_U_ADR + 2,
	TUA_WRITE = TST_U_ADR + 3,
	TUA_READ = TST_U_ADR + 5;

    LOAD_TST_U;
    OK = 1;

    INCR ERRN FROM 0 TO 10 DO
	ERROR_LOOP(1)
	(
	    ERRINFO[2] = .INFO[.ERRN,INFO_DESCR];
	    ERRINFO[0] = PMA = .INFO[.ERRN,INFO_N_PMA];
	    ERRINFO[3] = VMA = .INFO[.ERRN,INFO_N_VMA];
	    ERRINFO[4] = .VMA<9,9>;	! PAGE
	    COR_CRAM_ADR = .INFO[.ERRN,INFO_COR_ADR];
	    ERRINFO[5] = .HIT_MSG[.COR_CRAM_ADR];

	    CE(.INFO[.ERRN,INFO_CE]);	! ENABLE/DISABLE CACHE

	    IFN .INFO[.ERRN,INFO_PAGING]
	    THEN
		PAGING_ON
	    ELSE
		PAGING_OFF;

	    SET_CRAM_ADR(TUA_PAG);
	    MOD_FLD(3,.INFO[.ERRN,INFO_N_PAG_FLD3]);
	    MOD_FLD(4,.INFO[.ERRN,INFO_N_PAG_FLD4]);

	    ! USER/EXEC HACKS
	    SET_CRAM_ADR(TUA_PAGVMA);
	    MOD_FLD(4,.INFO[.ERRN,INFO_N_REF_FLD4] AND %O'70');
	    SET_CRAM_ADR(TUA_WRITE);
	    MOD_FLD(4,(.INFO[.ERRN,INFO_N_REF_FLD4] AND %O'70') OR 3);

	    SET_CRAM_ADR(TST_U_ADR);
	    MOD_FLD(3,.INFO[.ERRN,INFO_N_VMA_FLD3]);
	    MOD_FLD(4,.INFO[.ERRN,INFO_N_VMA_FLD4]);
	    CP(5);
	    MEM_DEPOSIT(.PMA,0);

	    SET_CRAM_ADR(TUA_READ);
	    MOD_FLD(3,.INFO[.ERRN,INFO_N_REF_FLD3]);
	    MOD_FLD(4,.INFO[.ERRN,INFO_N_REF_FLD4]);
	    CRAM_ADR = STEP_U_NEXT(2);
	    IF .CRAM_ADR NEQ .COR_CRAM_ADR
	    THEN
	    (
		ERRS(1,1,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
    );

    IFN .OK THEN NOERR(1);

    CE(0);			! PUT IT BACK
    PAGING_OFF;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	TEST CACHE ENABLE CONDITION: \S2
!*		MAP PAGE \O4 TO PAGE 0
!*		WRITE -1 TO VIRTUAL MEM LOC \O3
!*	8080:	WRITE 0 TO PHYSICAL MEM LOC \O0
!*	KS10:	READ VIRTUAL MEM LOC \O3
!*RESPONSE:
!*	SHOULD GET \S5; DIDN'T

!]ERROR 1
!]CD_HIT PT_CAC CD_ADR CD_IO CD_CMP PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]CD_HIT PT_CAC NTWK

    END;

GLOBAL ROUTINE TST43: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK CACHE DIR RAM DATA I/O PINS
!	    FINAL CRAM ADR = 0: ALU NOT = 0: HIT
!	    FINAL CRAM ADR = 1: ALU = 0: MISS
!
!--

    BEGIN

    LOCAL
	VMA,
	CRAM_ADR;

    OWN
	PMA: VECTOR[2] INITIAL(%O'377', %O'777'),
	ALL_PAGE_BITS: VECTOR[2] INITIAL(%O'777000', 0),
	PAGE_BIT: VECTOR[9] INITIAL(1^9,1^10,1^11,1^12,1^13,1^14,1^15,1^16,1^17);

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'640',
	TST_U = PLIT
	    (
%(0640)%    U_J(641) V_DP_N(000777) U_B_T0 U_DEST_AD U,	! #<6:17> CHANGES
%(0641)%    U_J(642) V_DP_T0 U_MEM U_N(401010) U_SPEC_LDPAGE U,
%(0642)%    U_J(643) V_DP_N(460000) U,
%(0643)%    U_J(644) V_DP_T0 U_MEM U_N(430012) U,
%(0644)%    V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(0645)%    U_J(646) V_DP_T0 U_MEM U_N(440012) U,
%(0646)%    V_DP_D U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_REF = TST_U_ADR + 5;

    LOAD_TST_U;
    PAGING_ON;
    CE(1);
    INCR SIDE FROM 0 TO 1 DO
	INCR BITNO FROM 0 TO 8 DO
	    INCR BITVAL FROM 0 TO 1 DO
		ERROR_LOOP(1)
		(
		    ERRINFO[0] = .PMA[.SIDE];

		    VMA = (.PAGE_BIT[.BITNO] XOR .ALL_PAGE_BITS[.BITVAL]) OR .PMA[.SIDE];
		    ERRINFO[3] = .VMA;
		    ERRINFO[1] = .VMA<9,9>;

		    SET_CRAM_ADR(TST_U_ADR);
		    MOD_FLD(3,.VMA<N_FLD3>);
		    MOD_FLD(4,.VMA<N_FLD4>);
		    CP(5);
		    MEM_DEPOSIT(.PMA,0);

		    SET_CRAM_ADR(TUA_REF);
		    CRAM_ADR = STEP_U_NEXT(2);
		    IFN .CRAM_ADR	! HIT: 0; MISS: 1
		    THEN
			ERRS(1,1,ERRINFO)
		    ELSE
			NOERR(1);
		    EXIT_LOOP(1,1);
		    0
		);
    CE(0);			! PUT IT BACK
    PAGING_OFF;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	TEST CACHE DIRECTORY RAM DATA I/O PINS
!*		MAP PAGE \O1 TO PAGE 0
!*		WRITE -1 TO VIRTUAL MEM LOC \O3
!*	8080:	WRITE 0 TO PHYSICAL MEM LOC \O0
!*	KS10:	READ VIRTUAL MEM LOC \O3
!*RESPONSE:
!*	SHOULD GET -1 (CACHE HIT); DIDN'T

!]ERROR 1
!]CD_HIT PT_CAC CD_ADR CD_IO CD_CMP PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]CD_IO NTWK

    END;

GLOBAL ROUTINE TST44: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST CACHE DIRECTORY RAM ADDRESS LINES
!	FOR LOCATIONS (0,1,2,4,10,...,200) + (1000,1400):
!	MAP TO PAGE 1, WRITE VMA TO M[VMA], ZERO M (8080), READ M[VMA]
!	IF A PIN IS STUCK, M[0] = M[2**N] (WHICH IS WHICH: HIGH OR LOW)
!
!--

    BEGIN

    LOCAL
	VMA;

    OWN
	INFO: VECTOR[18] INITIAL
	    (
	    %O'1000', %O'1400',
	    %O'1001', %O'1401',
	    %O'1002', %O'1402',
	    %O'1004', %O'1404',
	    %O'1010', %O'1410',
	    %O'1020', %O'1420',
	    %O'1040', %O'1440',
	    %O'1100', %O'1500',
	    %O'1200', %O'1600'
	    );

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'650',
	TST_U = PLIT
	    (
%(0650)%    U_J(651) V_DP_N(1000) U_B_T0 U_DEST_AD U,	! J,# CHANGE
%(0651)%    U_J(652) V_DP_T0 U_MEM U_N(1010) U_SPEC_LDPAGE U,
%(0652)%    U_J(653) V_DP_N(460001) U,
%(0653)%    U_J(654) V_DP_T0 U_MEM U_N(30012) U,
%(0654)%    V_DP_T0 U_DBUS_DP U_MEM U_N(2) U,
%(0655)%    U_J(656) V_DP_T0 U_MEM U_N(40012) U,
%(0656)%    U_J(657) V_DP_D U_DBM_MEM U_DBUS_DBM U_DEST_Q_AD U_MEM U_N(2) U,
%(0657)%    U_A_T0 U_LSRC_AQ U_ALU_XOR U_SKIP_ADEQ0 U
	    );

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;
    PAGING_ON;
    CE(1);
    SET_CRAM_ADR(TST_U_ADR);	! FIX J FIELD FOR WRITING
    MOD_FLD(0,TST_U_ADR+1);	!     AND LOADING THE PAGE TABLE

    INCR ERRN FROM 0 TO 17 DO
    (
	VMA = .INFO[.ERRN];
	SET_CRAM_ADR(TST_U_ADR);
	MOD_FLD(3,.VMA<N_FLD3>);
	CP(6);			! FRIGGING EXTRA CLOCK GETS H-TO-L FOR WRITE

    );

    SET_CRAM_ADR(TST_U_ADR);	! FIX J FIELD FOR READING
    MOD_FLD(0,TST_U_ADR+5);

    ! WRITE 0'S ALL OVER PHY PAGE 1 FROM THE 8080 (BYPASS CACHE)
    DM(1000,0);
    SEND_NUL();
    DN(0);
    REPEAT(%O'376');
    DM(1400,0);
    SEND_NUL();
    DN(0);
    REPEAT(%O'376');

    INCR ERRN FROM 0 TO 17 DO
    (
	VMA = .INFO[.ERRN];
	SET_CRAM_ADR(TST_U_ADR);
	MOD_FLD(3,.VMA<N_FLD3>);
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(TST_U_ADR);
	    IF STEP_U_NEXT(4) EQL 0
	    THEN
	    (
		ERRINFO[0] = .VMA;
		ERRCAS(1,1,.VMA,SERIAL(36),12,ERRINFO);
	    )
	    ELSE
		NOERR(1);
	    EXIT_LOOP(1,1);
	    0
	);
    );

    CE(0);
    PAGING_OFF;
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	CHECK CACHE DIRECTORY RAM ADDRESS LINES
!*	KS10:	MAP PHYSICAL PAGE 1 TO VIRTUAL PAGE 1
!*		WRITE \O0 TO VIRTUAL MEM LOC \O0 (CACHE ENABLED)
!*		... FOR LOCS 0 AND 2**N FOR EACH SIDE OF RAM PAIRS
!*	8080:	ZERO PHYSICAL PAGE 1
!*RESPONSE:
!*	KS10:	READ VIRTUAL MEM LOC \O0

!]ERROR 1
!]CD_HIT PT_CAC CD_ADR CD_IO CD_CMP PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]CD_ADR NTWK

    END;

GLOBAL ROUTINE TST45: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST CACHE DIRECTORY SWEEP OPERATION
!
!--

    BEGIN

    LOCAL
	VMA;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'660',
	TST_U = PLIT
	    (
%(0660)%    U_J(661) V_DP_N(1377) U_B_T0 U_DEST_AD U,
%(0661)%    U_J(662) V_DP_N(1777) U_B_T1 U_DEST_AD U,
%(0662)%    U_J(663) V_DP_T0 U_MEM U_N(1010) U_SPEC_LDPAGE U,
%(0663)%    U_J(664) V_DP_N(460001) U,
%(0664)%    U_J(665) V_DP_T1 U_MEM U_N(30012) U,
%(0665)%    U_J(666) V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(0666)%    U_J(667) V_DP_T0 U_MEM U_N(30012) U_SPEC_CLRCSH U,
%(0667)%    U_J(670) V_DP_0 U_DBUS_DP U_MEM U_N(2) U,
%(0670)%    U_J(671) V_DP_T1 U_MEM U_N(40012) U,
%(0671)%    U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    );

    LOAD_TST_U;

    PAGING_ON;
    CE(1);
    ERROR_LOOP(1)
    (
	SET_CRAM_ADR(TST_U_ADR);
	IF STEP_U_NEXT(10) EQL 0
	THEN
	    ERR(1)
	ELSE
	    NOERR(1);
	EXIT_LOOP(1,1);
	0
    );

    CE(0);
    PAGING_OFF;

!*MESSAGE 1
!*STIMULUS:
!*	MAP PAGE 1 TO PAGE 1
!*	WRITE -1 TO MEM LOC 1777
!*	WRITE 0 TO MEM LOC 1377 WITH SWEEP SET
!*	READ MEM LOC 1777, SKIP IF 0
!*RESPONSE:
!*	SHOULD SKIP (BUT IT DIDN'T)

!]ERROR 1
!]VMA_SWEEP_CD VMA_SWEEP SPEC_SWEEP CD_HIT CD_ADR CD_IO CD_CMP PT_CAC PT_USR PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]VMA_SWEEP_CD NTWK

    END;

GLOBAL ROUTINE TST46: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK CACHE HIT COMPARATORS' OUTPUTS STUCK HIGH
!
!--

    BEGIN

    LOCAL
	CRAM_ADR,
	OK;

    OWN
	INFO: VECTOR[2] INITIAL(%O'400777', %O'20777');

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'700',
	TST_U = PLIT
	    (
%(0700)%    U_J(701) V_DP_N(400777) U_B_T0 U_DEST_AD U,	! # CHANGES
%(0701)%    U_J(702) V_DP_N(000777) U_B_T1 U_DEST_AD U,
%(0702)%    U_J(703) V_DP_T0 U_MEM U_N(1010) U_SPEC_LDPAGE U,
%(0703)%    U_J(704) V_DP_N(460000) U,
%(0704)%    U_J(705) V_DP_T1 U_MEM U_N(1010) U_SPEC_LDPAGE U,
%(0705)%    U_J(706) V_DP_N(460000) U,
%(0706)%    U_J(707) V_DP_T0 U_MEM U_N(30012) U,
%(0707)%    V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(0710)%    U_J(711) V_DP_T1 U_MEM U_N(40012) U,
%(0711)%    U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_VMA = TST_U_ADR + 0,
	TUA_TST = TST_U_ADR + 8;

    LOAD_TST_U;
    OK = 1;
    PAGING_ON;
    CE(1);

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(TUA_VMA);
	    MOD_FLD(4,.INFO[.SUBTEST] ^ (-12));	! VMA LOW BITS STAY OK
	    CP(8);
	    DM(777,0);
	    SET_CRAM_ADR(TUA_TST);
	    CRAM_ADR = STEP_U_NEXT(2);
	    IF .CRAM_ADR NEQ 1			! 1: SKIP: GOT 0: OK
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST];		! CHANGING VMA
		ERRINFO[1] = .INFO[.SUBTEST] ^ (-9);	! PAGE #
		ERRS(1,1,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

    CE(0);
    PAGING_OFF;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	MAP PAGES \O1 AND 0 TO PAGE 0
!*		WRITE -1 TO VIRTUAL MEM LOC \O0
!*	8080:	WRITE 0 TO PHYSICAL MEM LOC 777
!*	KS10:	READ VIRTUAL MEM LOC 777, SKIP IF 0
!*RESPONSE:
!*	KS10:	SHOULD SKIP = GOT 0 = CACHE MISS (DIDN'T)

!]ERROR 1
!]CD_HIT CD_ADR CD_IO CD_CMP PT_CAC PT_USR PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!] NTWK

    END;

GLOBAL ROUTINE TST47: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK CACHE DIR CACHE VALID PINS STUCK HIGH
!
!--

    BEGIN

    LOCAL
	OK,
	CRAM_ADR;

    OWN
	INFO: VECTOR[2] INITIAL(%O'777', %O'377');

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'720',
	TST_U = PLIT
	    (
%(0720)%    U_J(721) V_DP_N(777) U_B_T0 U_DEST_AD U,	! # CHANGES
%(0721)%    U_J(722) V_DP_T0 U_MEM U_N(1010) U_SPEC_LDPAGE U,
%(0722)%    U_J(723) V_DP_N(460000) U,
%(0723)%    U_J(724) V_DP_T0 U_MEM U_N(31012) U,
%(0724)%    V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(0725)%    U_J(726) V_DP_T0 U_MEM U_N(40012) U,
%(0726)%    U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_VMA = TST_U_ADR + 0,
	TUA_TST = TST_U_ADR + 5;

    LOAD_TST_U;
    OK = 1;
    CE(1);
    PAGING_ON;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(TUA_VMA);
	    MOD_FLD(3,.INFO[.SUBTEST]);		! VMA HIGH BITS STAY OK
	    CP(5);
	    MEM_DEPOSIT(.INFO[.SUBTEST],0);
	    SET_CRAM_ADR(TUA_TST);
	    CRAM_ADR = STEP_U_NEXT(2);
	    IF .CRAM_ADR NEQ 1			! 1: SKIP: GOT 0: OK
	    THEN
	    (
		ERRINFO[0] = .INFO[.SUBTEST];		! CHANGING VMA
		ERRS(1,1,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

    CE(0);
    PAGING_OFF;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	MAP PAGE 0 TO PAGE 0
!*		WRITE -1 TO PHYSICAL MEM LOC \O0
!*	8080:	WRITE 0 TO PHYSICAL MEM LOC \O0
!*	KS10:	READ VIRTUAL MEM LOC \O0, SKIP IF 0
!*RESPONSE:
!*	KS10:	SHOULD SKIP = GOT 0 = CACHE MISS (DIDN'T)

!]ERROR 1
!]CD_VAL CD_HIT PT_CAC CD_ADR CD_IO CD_CMP PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]CD_VAL NTWK

    END;

GLOBAL ROUTINE TST48: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE RAM CONTENTS
!	CAUSE ECC ERROR ON EVERY VIRTUAL PAGE
!	MAPPED TO PHYSICAL PAGES MAX_PAG[0], MAX_PAG[1]
!	ALSO CHECKS FOR VALID OR WRITABLE BEING STUCK LOW
!	ALSO TESTS USER STUCK HIGH OR STUCK LOW
!
!	2901 REGISTER USAGE:
!	     0	VMA
!	     1	PTE
!	     2	PMA
!	    11	VMA FLAGS, VMA TO R/W MMC STATUS
!	    12	PMA MASK FOR MMC STATUS
!	    13	FORCE BITS FOR MMC STATUS
!
!--

    BEGIN

    LOCAL
	DAT,
	PTE,
	VMA,
	COR_PMA,
	ACT_PMA,
	TICKS,
	CRAM_ADR,
	LOOPING,
	PMA_HIGH_BIT,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'730',
	TST_U = PLIT
	    (
%(0730)%    U_J(731) V_DP_N(440000) U_B(1) U_DEST_AD U,	! #<6:17>
%(0731)%    U_J(732) V_DP_NN(377777) U_B(2) U_DEST_AD U_NO_CLKL U,	! #<0:17>
%(0732)%    U_J(733) V_DP_NN(0) U_B(2) U_DEST_AD U_NO_CLKR U,	! #<6:17>
%(0733)%    U_J(734) V_DP_N(777) U_B(0) U_DEST_AD U,
%(0734)%    U_J(735) V_DP_NN(400376) U_B(13) U_DEST_AD U,
%(0735)%    U_J(736) V_DP_NN(100000) U_B(11) U_DEST_AD U_NO_CLKL U,
%(0736)%    U_J(737) V_DP_NN(17) U_B(12) U_DEST_AD U_NO_CLKR U,
%(0737)%    U_J(741) V_DP_NN(777777) U_B(12) U_DEST_AD U_NO_CLKL U,
%(0740)%    U_J(741) V_D_N(1000) U_A(0) U_B(0) U_ALU_ADD U_DEST_AD U_LSRC_0A U_RSRC_DA U,
%(0741)%    U_J(742) V_DP_NN(211200) U_B(11) U_DEST_AD U_NO_CLKR U,
%(0742)%    U_J(743) V_DP_R(11) U_MEM U_N(36) U,
%(0743)%    U_J(744) V_DP_R(13) U_MEM U_N(2) U,
%(0744)%    U_J(745) V_DP_R(0) U_MEM U_N(003010) U_SPEC_LDPAGE U,	! #<0:5>
%(0745)%    U_J(746) V_DP_R(1) U,
%(0746)%    U_J(747) V_DP_R(0) U_MEM U_N(032012) U,	! #<0:5>
%(0747)%    U_J(750) V_DP_0 U_MEM U_N(2) U,
%(0750)%    U_J(751) V_DP_R(0) U_MEM U_N(042012) U,	! #<0:5>
%(0751)%    U_J(752) U_MEM U_N(2) U,
%(0752)%    U_J(753) V_DP_NN(241200) U_B(11) U_DEST_AD U_NO_CLKR U,
%(0753)%    U_J(754) V_DP_R(11) U_MEM U_N(36) U,
%(0754)%    U_J(755) U_DBM_MEM U_DBUS_DBM U_LSRC_DA U_A(12) U_ALU_AND U_DEST_Q_AD U_MEM U_N(2) U,
%(0755)%    U_LSRC_AQ U_A(2) U_ALU_XOR U_SKIP_ADEQ0 U
	    ),
	TUA_PAG = TST_U_ADR + 0,	! WHERE TO DIDDLE PAGE MAP
	TUA_VMA = TST_U_ADR + %O'10',	! WHERE TO INCREMENT VMA
	TUA_TST = TST_U_ADR + %O'11';	! WHERE TO RESTART TEST

    IFN .INH_PT_RAM THEN RETURN;	! FORGET IT IF HE SAID TO

    LOAD_TST_U;
    PMA_HIGH_BIT = 0;
    RPT_ERR_FLAG = 0;
    OK = 1;

    PAGING_ON;

    INCR PHY_PAG FROM 0 TO 1 DO		! STUCK LOW, THEN STUCK HIGH
    (
	DAT = .MAX_PAG[.PHY_PAG];
	ERRINFO[0] = COR_PMA = (.DAT ^ 9) OR %O'777';
	ERRINFO[2] = PTE = %O'440000' OR .DAT;

	ERRINFO[6] = .FORCE_NAME[.PHY_PAG];	! TEST USER RAM BIT TOO
	SET_CRAM_ADR(TUA_TST+3);
	MOD_FLD(4,.FORCE_MODE[.PHY_PAG]);	! #<0:5>
	SET_CRAM_ADR(TUA_TST+5);
	MOD_FLD(4,.FORCE_MODE[.PHY_PAG] OR 3);	! #<0:5>
	SET_CRAM_ADR(TUA_TST+7);
	MOD_FLD(4,.FORCE_MODE[.PHY_PAG] OR 4);	! #<0:5>

	SET_CRAM_ADR(TUA_PAG+1);		! LOW 18 BITS OF PMA
	MOD_FLD(3,.COR_PMA<N_FLD3>);		! #<6:17>
	MOD_FLD(4,.COR_PMA<N_FLD4>);		! #<0:5>

	IF .COR_PMA<18,12> NEQ .PMA_HIGH_BIT
	THEN
	(
	    SET_CRAM_ADR(TUA_PAG+2);		! HIGH BIT OF PMA
	    PMA_HIGH_BIT = .COR_PMA<18,12>;
	    MOD_FLD(3,.PMA_HIGH_BIT);		! #<6:17>
	);

	SET_CRAM_ADR(TUA_PAG);
	MOD_FLD(3,.PTE<N_FLD3>);			! #<6:17>

	INCR VIR_PAG FROM 0 TO %O'777' DO	! DO THE WHOLE THING
	(
	    ERRINFO[3] = .VIR_PAG;
	    ERRINFO[1] = VMA = (.VIR_PAG ^ 9) OR %O'777';
	    IFN .VIR_PAG
	    THEN
	    (
		SET_CRAM_ADR(TUA_VMA);
		TICKS = 14;
	    )
	    ELSE
		TICKS = 21;
	    LOOPING = 0;		! FIRST TIME THROUGH ERROR LOOP
	    ERROR_LOOP(1)
	    (
		IFN .LOOPING THEN SET_CRAM_ADR(TUA_TST);
		CRAM_ADR = STEP_U_NEXT(.TICKS);
		IF .CRAM_ADR EQL O7777	! IF -1 WE HAD PAGE FAIL
		THEN
		(
		    ERRINFO[4] = PF_TRAP();
		    ERRINFO[5] = PF_NAME(.ERRINFO[4]);
		    ERRS(1,1,ERRINFO);
		    PAGING_ON;
		)
		ELSE
		    IF .CRAM_ADR EQL 0	! 1: SKIP: XOR=0: MATCH
		    THEN
		    (
			ACT_PMA = EI(100000) AND %O'17777777';
			ERRCAS(1,2,.COR_PMA,.ACT_PMA,8,ERRINFO);
			OK = 0;
		    );
		LOOPING = 1;
		TICKS = 13;
		EXIT_LOOP(1,1);
		0
	    );
	);
    );

    IFN .OK THEN NOERR(1);

    PAGING_OFF;
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O2 INTO PAGE TABLE LOC \O3 (\S6)
!*	DEPOSIT 376 TO I/O REGISTER 100000
!*	(SETTING ALL MMC ECC FORCE BITS)
!*	DEPOSIT 0 TO VIRTUAL MEM LOC \O1 (WITH WRONG ECC) (\S6)
!*	READ VIRTUAL MEM LOC \O1 (CAUSING AN ERROR) (\S6)
!*RESPONSE:
!*	PAGE FAIL U-TRAP TO CRAM ADDR 7777 (SHOULDN'T HAPPEN)
!*	PAGE FAIL CODE \O4 (\S5)

!*MESSAGE 2
!*STIMULUS:
!*	LOAD \O2 INTO PAGE TABLE LOC \O3 (\S6)
!*	DEPOSIT 376 TO I/O REGISTER 100000
!*	(SETTING ALL MMC ECC FORCE BITS)
!*	DEPOSIT 0 TO VIRTUAL MEM LOC \O1 (WITH WRONG ECC) (\S6)
!*	READ VIRTUAL MEM LOC \O1 (CAUSING AN ERROR) (\S6)
!*	READ I/O REGISTER 100000 BITS <14:35>
!*RESPONSE:
!*	SHOULD GET \O0 (PHYSICAL ADDR OF LAST ERROR)

!]ERROR 1
!]PT_RAM_PAG_USR PT_IO PT_VAL_WRT PT_USR PT_MESS NTWK

!]NO ERROR 1
!]PT_RAM_PAG_USR NTWK

    END;

GLOBAL ROUTINE TST49: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE RAM CONTENTS
!	VALID OR WRITABLE STUCK HIGH
!
!--

    BEGIN

    MACRO
	INFO_PTE = 0,0,18,0 %,		! # FOR PAGE TABLE ENTRY
	INFO_PTE_FLD4 = 0,12,6,0 %,	! #<0:5>
	INFO_PF_CAUSE = 1,0,36,0 %;	! CORRECT PAGE FAIL CAUSE

    LOCAL
	COR_PF_CAUSE,
	VMA,
	TICKS,
	CRAM_ADR,
	LOOPING,
	OK;

    OWN
	INFO: BLOCKVECTOR[2,2] INITIAL
	(
	    %O'040000', %O'12',		! INVALID
	    %O'400000', %O'10'		! UNWRITABLE
	);

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'760',
	TST_U = PLIT
	    (
%(0760)%    U_J(761) V_DP_N(440000) U_B(1) U_DEST_AD U,	! #
%(0761)%    U_J(763) V_DP_N(777) U_B(0) U_DEST_AD U,
%(0762)%    U_J(763) V_D_N(1000) U_A(0) U_B(0) U_ALU_ADD U_DEST_AD U_LSRC_0A U_RSRC_DA U,
%(0763)%    U_J(764) V_DP_R(0) U_MEM U_N(3010) U_SPEC_LDPAGE U,	! #
%(0764)%    U_J(765) V_DP_R(1) U,
%(0765)%    U_J(766) V_DP_R(0) U_MEM U_N(32012) U,	! #
%(0766)%    U_J(7777) V_DP_0 U_MEM U_N(2) U	! J IN CASE NO PF
	    ),
	TUA_PAG = TST_U_ADR + 0,	! WHERE TO DIDDLE PAGE MAP
	TUA_VMA = TST_U_ADR + 2,	! WHERE TO INCREMENT VMA
	TUA_TST = TST_U_ADR + 3;	! WHERE TO RESTART TEST

    IFN .INH_PT_RAM THEN RETURN;	! FORGET IT IF HE SAID TO

    LOAD_TST_U;
    OK = 1;
    RPT_ERR_FLAG = 0;

    SET_CRAM_ADR(PHU_ADR);
    MOD_FLD(0,PFU_ADR+1);		! ALWAYS DISPATCH (DON'T HANG)
    PAGING_ON;

    INCR SUBTEST FROM 0 TO 1 DO
    (
	ERRINFO[2] = .INFO[.SUBTEST,INFO_PTE];
	SET_CRAM_ADR(TUA_PAG);
	MOD_FLD(4,.INFO[.SUBTEST,INFO_PTE_FLD4]);

	ERRINFO[8] = COR_PF_CAUSE = .INFO[.SUBTEST,INFO_PF_CAUSE];
	ERRINFO[9] = PF_NAME(.ERRINFO[8]);

	INCR VIR_PAG FROM 0 TO %O'777' DO	! DO THE WHOLE THING
	(
	    ERRINFO[3] = .VIR_PAG;
	    VMA = (.VIR_PAG ^ 9) OR %O'777';
	    IFN .VIR_PAG
	    THEN
	    (
		SET_CRAM_ADR(TUA_VMA);
		TICKS = 7;
	    )
	    ELSE
		TICKS = 8;
	    LOOPING = 0;		! FIRST TIME THROUGH ERROR LOOP
	    ERROR_LOOP(1)
	    (
		IFN .LOOPING THEN SET_CRAM_ADR(TUA_TST);
		ERRINFO[4] = CRAM_ADR = STEP_U_NEXT(.TICKS);
		ERRINFO[5] = PF_NAME(.ERRINFO[4]);
		IF .CRAM_ADR NEQ .COR_PF_CAUSE
		THEN
		(
		    ERRS(1,1,ERRINFO);
		    OK = 0;
		);
		! PAGE FAIL RE-INIT
		MR();
		SET_CRAM_ADR(TIU_ADR);
		CP_NOSS(TIU_CNT);
		PAGING_ON;
		! GET READY TO DO IT OVER (IF ERROR OCCURED)
		LOOPING = 1;
		TICKS = 6;
		EXIT_LOOP(1,1);
		0
	    );
	);
    );

    IFN .OK THEN NOERR(1);

    PAGING_OFF;
    SET_CRAM_ADR(PHU_ADR);
    MOD_FLD(0,O7777);		! GO BACK TO HANGING AS USUAL
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	LOAD \O2 INTO PAGE TABLE LOC \O3
!*	DEPOSIT 0 TO VIRTUAL MEM LOC 777
!*	DO A PAGE FAIL DISPATCH
!*RESPONSE:
!*	CORRECT: PAGE FAIL CODE \O8 (\S9)
!*	ACTUAL:  PAGE FAIL CODE \O4 (\S5)

!]ERROR 1
!]PT_RAM_VAL_WRT PT_IO PT_VAL_WRT PT_USR PT_MESS PF_CODE NTWK

!]NO ERROR 1
!]PT_RAM_VAL_WRT NTWK

    END;

GLOBAL ROUTINE TST50: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST CACHE DIRECTORY RAM CONTENTS
!	CACHE HIT TEST AT EACH LOC ON PAGES 1, 776
!	ALSO CHECKS FOR VALID BEING STUCK LOW
!	ALSO TESTS USER STUCK HIGH OR STUCK LOW
!
!--

    BEGIN

    LOCAL
	VMA,
	PF_CAUSE,
	CRAM_ADR,
	TICKS,
	LOOPING;

    OWN
	VIR_PAG: VECTOR[2] INITIAL(1, %O'776');

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'770',
	TST_U = PLIT
	    (
%(0770)%    U_J(775) U_A_BR U_B(0) U_LSRC_AB U_ALU_ADD U_DEST_AD U,	! J
%(0771)%    U_J(777) U_A_BR U_B(0) U_LSRC_AB U_ALU_ADD U_DEST_AD U,
%(0772)%    U_J(773) V_DP_N(1000) U_B(0) U_DEST_AD U,		! J, #
%(0773)%    U_J(774) V_DP_R(0) U_MEM U_N(1010) U_SPEC_LDPAGE U,	! #
%(0774)%    U_J(775) V_DP_N(460001) U,
%(0775)%    U_J(776) V_DP_R(0) U_MEM U_N(10012) U,		! #
%(0776)%    U_J(770) V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(0777)%    U_J(1000) V_DP_R(0) U_MEM U_N(40012) U,		! #
%(1000)%    U_J(770) V_DP_D U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_J = TST_U_ADR + 0,		! JUMP TO AFTER INCR'NG VMA
	TUA_VMA = TST_U_ADR + 2,	! VMA TO USE
	TUA_LD_PT = TST_U_ADR + 3,	! # TO LOAD PAGE TABLE
	TUA_WRITE = TST_U_ADR + 5,	! # TO DO THE WRITE
	TUA_READ = TST_U_ADR + 7;	! # TO DO THE READ

    IFN .INH_CD_RAM THEN RETURN;	! FORGET IT IF HE SAID TO

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;

    PAGING_ON;
    CE(1);				! MAKE THE CACHE WORK

    INCR ERRN FROM 0 TO 1 DO
    (
	ERRINFO[0] = .VIR_PAG[.ERRN];
	VMA = .VIR_PAG[.ERRN] ^ 9;
	ERRINFO[5] = .FORCE_NAME[.ERRN];

	SET_CRAM_ADR(TUA_READ);
	MOD_FLD(4,.FORCE_MODE[.ERRN] + 4);

	SET_CRAM_ADR(TUA_WRITE);
	MOD_FLD(4,.FORCE_MODE[.ERRN] + 1);

	SET_CRAM_ADR(TUA_LD_PT);
	MOD_FLD(4,.FORCE_MODE[.ERRN]);

	SET_CRAM_ADR(TUA_J);
	MOD_FLD(0,TUA_WRITE);

	SET_CRAM_ADR(TUA_VMA);
	MOD_FLD(0,TUA_LD_PT);
	MOD_FLD(3,.VMA<N_FLD3>);
	MOD_FLD(4,.VMA<N_FLD4>);

	CP(3 + (3 * 512));	! WRITE -1 ALL OVER PAGE FROM KS10

	! WRITE 0'S ALL OVER PHY PAGE 1 FROM THE 8080 (BYPASS CACHE)
	DM(1000,0);
	SEND_NUL();
	DN(0);
	REPEAT(%O'376');
	DM(1400,0);
	SEND_NUL();
	DN(0);
	REPEAT(%O'376');

	SET_CRAM_ADR(TUA_J);
	MOD_FLD(0,TUA_READ);

	SET_CRAM_ADR(TUA_VMA);
	MOD_FLD(0,TUA_READ);

	INCR OFFSET FROM 0 TO %O'777' DO	! SEE IF WE GET HITS
	(
	    ERRINFO[1] = .VMA + .OFFSET;
	    ERRINFO[2] = %O'1000' + .OFFSET;
	    LOOPING = 0;
	    ERROR_LOOP(1)
	    (
		IFN .LOOPING
		THEN
		(
		    SET_CRAM_ADR(TUA_READ);
		    TICKS = 2;
		)
		ELSE
		    TICKS = 3;
		CRAM_ADR = STEP_U_NEXT(.TICKS);
		IF .CRAM_ADR EQL O7777		! SHOULDN'T PAGE FAIL
		THEN
		(
		    ERRINFO[3] = PF_TRAP();
		    ERRINFO[4] = PF_NAME(.ERRINFO[3]);
		    ERRS(1,2,ERRINFO);
		    PAGING_ON;
		    CE(1);			! MAKE THE CACHE WORK
		    SET_CRAM_ADR(TUA_J);
		)
		ELSE
		    IF .CRAM_ADR		! SKIPPING SETS LOW BIT
		    THEN
			ERRS(1,1,ERRINFO)
		    ELSE
			NOERR(1);
		LOOPING = 1;
		EXIT_LOOP(1,1);
		0
	    );
	);
    );

    PAGING_OFF;
    CE(0);			! MAKE THE CACHE QUIT
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	MAP PAGE \O0 TO PAGE 1, \S5 MODE
!*		WRITE -1 TO VIR MEM LOC \O1
!*	8080:	WRITE 0 TO PHY MEM LOC \O2
!*	KS10:	READ VIR MEM LOC \O1
!*RESPONSE:
!*	SHOULD GET -1 (CACHE HIT); DON'T

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	MAP PAGE \O0 TO PAGE 1, \S5 MODE
!*		WRITE -1 TO VIR MEM LOC \O1
!*	8080:	WRITE 0 TO PHY MEM LOC \O2
!*	KS10:	READ VIR MEM LOC \O1
!*RESPONSE:
!*	SHOULD GET -1 (CACHE HIT) BUT PAGE FAIL HAPPENED
!*	PAGE FAIL CODE \O3 (\S4)

!]ERROR 1
!]CD_RAM_PAG_USR CD_HIT PT_CAC CD_ADR CD_IO CD_CMP PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]CD_RAM_PAG_USR NTWK

    END;

GLOBAL ROUTINE TST51: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST CACHE DIRECTORY RAM CONTENTS
!	CACHE ENTRY VALID STUCK HIGH AT EACH LOC ON PAGE 1
!
!--

    BEGIN

    LOCAL
	PF_CAUSE,
	CRAM_ADR,
	TICKS,
	LOOPING;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1010',
	TST_U = PLIT
	    (
%(1010)%    U_J(1015) U_A_BR U_B(0) U_LSRC_AB U_ALU_ADD U_DEST_AD U,	! J
%(1011)%    U_J(1017) U_A_BR U_B(0) U_LSRC_AB U_ALU_ADD U_DEST_AD U,
%(1012)%    U_J(1013) V_DP_N(1000) U_B(0) U_DEST_AD U,			! J
%(1013)%    U_J(1014) V_DP_R(0) U_MEM U_N(1010) U_SPEC_LDPAGE U,
%(1014)%    U_J(1015) V_DP_N(460001) U,
%(1015)%    U_J(1016) V_DP_R(0) U_MEM U_N(11012) U,
%(1016)%    U_J(1010) V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(1017)%    U_J(1020) V_DP_R(0) U_MEM U_N(40012) U,
%(1020)%    U_J(1010) V_DP_D U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_J = TST_U_ADR + 0,		! JUMP TO AFTER INCR'NG VMA
	TUA_VMA = TST_U_ADR + 2,	! VMA TO USE
	TUA_LD_PT = TST_U_ADR + 3,	! # TO LOAD PAGE TABLE
	TUA_WRITE = TST_U_ADR + 5,	! # TO DO THE WRITE
	TUA_READ = TST_U_ADR + 7;	! # TO DO THE READ

    IFN .INH_CD_RAM THEN RETURN;	! FORGET IT IF HE SAID TO

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;

    PAGING_ON;
    CE(1);				! MAKE THE CACHE WORK

    SET_CRAM_ADR(TUA_J);
    MOD_FLD(0,TUA_WRITE);

    SET_CRAM_ADR(TUA_VMA);
    MOD_FLD(0,TUA_LD_PT);

    CP(3 + (3 * 512));	! WRITE -1 ALL OVER PAGE FROM KS10

    ! WRITE 0'S ALL OVER PHY PAGE 1 FROM THE 8080(BYPASS CACHE)
    DM(1000,0);
    SEND_NUL();
    DN(0);
    REPEAT(%O'376');
    DM(1400,0);
    SEND_NUL();
    DN(0);
    REPEAT(%O'376');

    SET_CRAM_ADR(TUA_J);
    MOD_FLD(0,TUA_READ);

    SET_CRAM_ADR(TUA_VMA);
    MOD_FLD(0,TUA_READ);

    INCR OFFSET FROM 0 TO %O'777' DO	! SEE IF WE GET HITS
    (
	ERRINFO[1] = ERRINFO[2] = %O'1000' + .OFFSET;
	LOOPING = 0;
	ERROR_LOOP(1)
	(
	    IFN .LOOPING
	    THEN
	    (
		SET_CRAM_ADR(TUA_READ);
		TICKS = 2;
	    )
	    ELSE
		TICKS = 3;
	    CRAM_ADR = STEP_U_NEXT(.TICKS);
	    IF .CRAM_ADR EQL O7777		! SHOULDN'T PAGE FAIL
	    THEN
	    (
		ERRINFO[3] = PF_TRAP();
		ERRINFO[4] = PF_NAME(.ERRINFO[3]);
		ERRS(1,2,ERRINFO);
		PAGING_ON;
		CE(1);			! MAKE THE CACHE WORK
		SET_CRAM_ADR(TUA_J);
	    )
	    ELSE
		IF .CRAM_ADR<0,1> EQL 0	! SKIPPING SETS LOW BIT
	        THEN
		    ERRS(1,1,ERRINFO)
		ELSE
		    NOERR(1);
	    LOOPING = 1;
	    EXIT_LOOP(1,1);
	    0
	);
    );

    PAGING_OFF;
    CE(0);			! MAKE THE CACHE QUIT
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	MAP PAGE 1 TO PAGE 1
!*		WRITE -1 TO PHY MEM LOC \O1
!*	8080:	WRITE 0 TO PHY MEM LOC \O2
!*	KS10:	READ VIR MEM LOC \O1
!*RESPONSE:
!*	SHOULD GET 0 (CACHE MISS); DON'T

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	MAP PAGE 1 TO PAGE 1
!*		WRITE -1 TO PHY MEM LOC \O1
!*	8080:	WRITE 0 TO PHY MEM LOC \O2
!*	KS10:	READ VIR MEM LOC \O1
!*RESPONSE:
!*	SHOULD GET 0 (CACHE MISS) BUT PAGE FAIL HAPPENED
!*	PAGE FAIL CODE \O3 (\S4)

!]ERROR 1
!]CD_RAM_VAL CD_HIT PT_CAC CD_ADR CD_IO CD_CMP PT_IO PT_ADR PT_MESS N_ALL NTWK

!]NO ERROR 1
!]CD_RAM_VAL NTWK

    END;

GLOBAL ROUTINE TST52: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE RAM CONTENTS
!	CACHABLE STUCK HIGH OR LOW
!
!--

    BEGIN

    LOCAL
	PF_CAUSE,
	VMA,
	TICKS,
	CRAM_ADR,
	LOOPING,
	OK;

    OWN
	PTE: INITIAL(%O'440000'),
	INFO: VECTOR[2] INITIAL
	(
	    UPLIT(%ASCIZ '-1 (CACHE MISS)'),
	    UPLIT(%ASCIZ '0 (CACHE HIT)')
	);

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1020',
	TST_U = PLIT
	    (
%(1020)%    U_J(1023) V_D_N(1000) U_A(0) U_B(0) U_ALU_ADD U_DEST_AD U_LSRC_0A U_RSRC_DA U,
%(1021)%    U_J(1023) V_D_N(1000) U_A(0) U_B(0) U_ALU_ADD U_DEST_AD U_LSRC_0A U_RSRC_DA U,
%(1022)%    U_J(1023) V_DP_N(777) U_B(0) U_DEST_AD U,
%(1023)%    U_J(1024) V_DP_R(0) U_MEM U_N(3010) U_SPEC_LDPAGE U,
%(1024)%    U_J(1025) V_DP_N(460000) U,			! #
%(1025)%    U_J(1026) V_DP_R(0) U_MEM U_N(30012) U,
%(1026)%    U_J(1027) V_DP__1 U_DBUS_DP U_MEM U_N(2) U,
%(1027)%    U_J(1030) V_DP_R(0) U_MEM U_N(40012) U,
%(1030)%    U_J(1020) U_MEM U_N(2) V_DP_D U_SKIP_ADEQ0 U_DBM_MEM U_DBUS_DBM U
	    ),
	TUA_PAG = TST_U_ADR + 4,	! WHERE TO DIDDLE PAGE MAP
	TUA_VMA = TST_U_ADR + 2,	! WHERE TO INCREMENT VMA
	TUA_TST = TST_U_ADR + 3;	! WHERE TO RESTART TEST

    IFN .INH_PT_RAM THEN RETURN;	! FORGET IT IF HE SAID TO

    LOAD_TST_U;
    OK = 1;
    RPT_ERR_FLAG = 0;
    CE(1);				! LET THE CACHE WORK IT IT WANTS

    PAGING_ON;

    INCR SUBTEST FROM 0 TO 1 DO
    (
	ERRINFO[1] = .INFO[.SUBTEST];

	PTE<13,1> = .SUBTEST;		! PAGE CACHABLE BIT
	ERRINFO[2] = .PTE;
	SET_CRAM_ADR(TUA_PAG);
	MOD_FLD(4,.PTE<N_FLD4>);

	SET_CRAM_ADR(TUA_VMA);

	INCR VIR_PAG FROM 0 TO %O'777' DO	! DO THE WHOLE THING
	(
	    ERRINFO[3] = .VIR_PAG;
	    ERRINFO[0] = VMA = (.VIR_PAG ^ 9) OR %O'777';
	    LOOPING = 0;		! FIRST TIME THROUGH ERROR LOOP
	    ERROR_LOOP(1)
	    (
		IF .LOOPING EQL 0
		THEN
		    TICKS = 5
		ELSE
		(
		    SET_CRAM_ADR(TUA_TST);
		    TICKS = 4;
		);
		CP(.TICKS);			! GET PAST WRITE
		DM(777,0);			! ZAP IN MAIN MEMORY
		CRAM_ADR = STEP_U_NEXT(2);	! READ IT BACK
		IF .CRAM_ADR EQL O7777
		THEN
		(
		    ERRINFO[4] = PF_TRAP();
		    ERRINFO[5] = PF_NAME(.ERRINFO[4]);
		    ERRS(1,1,ERRINFO);
		    OK = 0;
		    PAGING_ON;
		)
		ELSE
		    IF .SUBTEST EQL .CRAM_ADR<0,1>
		    THEN
		    (
			ERRINFO[6] = .SUBTEST;
			ERRINFO[7] = .CRAM_ADR<0,1>;
			ERRS(1,2,ERRINFO);
			OK = 0;
		    );
		! GET READY TO DO IT OVER (IF ERROR OCCURED)
		LOOPING = 1;
		EXIT_LOOP(1,1);
		0
	    );
	);
    );

    IFN .OK THEN NOERR(1);

    CE(0);			! MAKE THE CACHE GO AWAY AGAIN
    PAGING_OFF;
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*		DEPOSIT -1 TO VIRTUAL MEM LOC \O0
!*	8080:	DEPOSIT 0 TO PHYSICAL MEM LOC 777
!*	KS10:	READ VIRTUAL MEM LOC \O0
!*RESPONSE:
!*	SHOULD GET \S1 (BUT GOT PAGE FAIL)
!*	PAGE FAIL CODE \O4 (\S5)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*		DEPOSIT -1 TO VIRTUAL MEM LOC \O0
!*	8080:	DEPOSIT 0 TO PHYSICAL MEM LOC 777
!*	KS10:	READ VIRTUAL MEM LOC \O0
!*RESPONSE:
!*	SHOULD GET \S1 (BUT DIDN'T)

! THERE USED TO BE A "PT_ALL" BELOW, BUT I THINK IT OUGHT TO BE "N_ALL"

!]ERROR 1
!]PT_RAM_CAC CD_IO CD_CMP CD_HIT PT_IO PT_ADR PT_CAC PT_MESS N_ALL NTWK

!]NO ERROR 1
!]PT_RAM_CAC NTWK

    END;

GLOBAL ROUTINE TST53: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	CHECK FOR MEMORY BUS PARITY ERRORS
!
!--

    BEGIN

    LOCAL
	OK,
	COM_ADR_ERR,
	TICKS,
	CRAM_ADR,
	PAR_ERR,
	NXT_DAT,
	DAT,
	LOOPING;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'1040',
	TST_U = PLIT
	    (
%(1040)%    U_J(1042) V_DP_R(5) U_B_T0 U_DEST_AD_DIV2 U,	! BR = 5
%(1041)%    U_J(1042) U_A_T0 U_B_T0 U_LSRC_AB U_ALU_ADD U_DEST_AD U,
%(1042)%    U_J(1043) V_DP_0 U_MEM U_N(11012) U,
%(1043)%    U_J(1044) V_DP_T0 U_DBUS_DP U_MEM U_N(2) U,
%(1044)%    U_J(1045) V_DP_0 U_MEM U_N(41012) U,
%(1045)%    U_J(1046) U_MEM U_N(2) U_DBM_MEM U_DBUS_DBM V_CHK U,
%(1046)%    U_J(1041) U						! NOP
	    ),
	TUA_INIT = TST_U_ADR + 0,	! INITIALIZE DATA TO WRITE
	TUA_NEXT = TST_U_ADR + 1,	! SHIFT DATA UP TO NEXT BIT
	TUA_TST = TST_U_ADR + 2;	! RESTART TEST (FOR LOOPING)

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;
    COM_ADR_ERR = 0;			! ALL IS WELL (SO FAR)

    ERROR_LOOP(1)
    (
	SET_CRAM_ADR(TUA_INIT);		! WORRY ABOUT COM/ADR PAR ERR
	CP(2);
	PAR_ERR = RD_100;
	IFN ((NOT .PAR_ERR) AND %O'14')
	THEN
	(
	    COM_ADR_ERR = 1;		! REMEMBER THAT WE LOST
	    ERRINFO[6] = .PAR_ERR<2,1>;	! DP PE L
	    ERRINFO[7] = .PAR_ERR<3,1>;	! MEM PE L
	    ERRS(1,1,ERRINFO);
	    MR();			! CLEAR FAULT
	);
	EXIT_LOOP(1,1);
	0
    );
    IFN .COM_ADR_ERR THEN RETURN;	! FATAL, GIVE UP

    SET_CRAM_ADR(TUA_INIT);		! START THE REAL TEST
    DAT = 0;
    NXT_DAT = 1;

    INCR ERRN FROM 0 TO 36 DO		! 0, THEN 2**N FOR N=0 TO 35
    (
	LOOPING = 0;			! FIRST TIME THROUGH ERROR LOOP
	ERRINFO[0] = .DAT;
	DAT = .NXT_DAT;
	NXT_DAT = .NXT_DAT ^ 1;

	ERROR_LOOP(2)
	(
	    IF .LOOPING EQL 0
	    THEN
		TICKS = 3
	    ELSE
	    (
		SET_CRAM_ADR(TUA_TST);
		TICKS = 2;
	    );

	    INCR RW FROM 0 TO 1 DO	! WRITE, THEN READ
	    (
		CRAM_ADR = STEP_U_NEXT(.TICKS);		! GET PAST WRITE
		PAR_ERR = RD_100;
		IFN ((NOT .PAR_ERR) AND %O'14')
		THEN
		(
		    ERRINFO[6] = .PAR_ERR<2,1>;	! DP PE L
		    ERRINFO[7] = .PAR_ERR<3,1>;	! MEM PE L
		    ERRS(1,2 + .RW,ERRINFO);
		    MR();				! CLEAR FAULT
		    SET_CRAM_ADR			! MR SCREWS IT
			(TUA_TST + (IF .RW THEN 2 ELSE 0));
		    OK = 0;
		);
		TICKS = 3;
	    );
	    LOOPING = 1;
	    EXIT_LOOP(2,(.ERRN + 2));
	    0
	);
    );

    IFN .OK THEN NOERR(1);

    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	WRITE TO PHYSICAL MEM LOC 0
!*		STOP AFTER COMMAND/ADDRESS CYCLE
!*RESPONSE:
!*	SHOULDN'T INDICATE PARITY ERROR (BUT IT DID)
!*	MEM PARITY ERROR L = \O7; DP PARITY ERROR L = \O6

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	WRITE \U0 TO PHYSICAL MEM LOC 0
!*	8080:	READ REGISTER 100
!*RESPONSE:
!*	SHOULDN'T INDICATE PARITY ERROR (BUT IT DID)
!*	MEM PARITY ERROR L = \O7; DP PARITY ERROR L = \O6

!*MESSAGE 3
!*STIMULUS:
!*	KS10:	WRITE \U0 TO PHYSICAL MEM LOC 0
!*		READ FROM PHYSICAL MEM LOC 0
!*	8080:	READ REGISTER 100
!*RESPONSE:
!*	SHOULDN'T INDICATE PARITY ERROR (BUT IT DID)
!*	MEM PARITY ERROR L = \O7; DP PARITY ERROR L = \O6

!]ERROR 1
!]BUS_PAR BUS_ALL BUS_MUX NTWK

!]NO ERROR 1
!]BUS_PAR NTWK

    END;

GLOBAL ROUTINE TST54: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	APR FLAGS
!
!	(ORIGINALLY WRITTEN BY JEAN BASMAJI)
!
!--

    BEGIN

    LOCAL
	OK,
	ACT_APR;

    LABEL
	LOOP1,
	LOOP2,
	LOOP3,
	LOOP4,
	LOOP5,
	LOOP6,
	LOOP7,
	LOOP8;

BIND
    TST_U_ADR = %O'2000',
    TST_U_1 = PLIT
	(
%(2000)%    U_J(2001) V_DP_N(7760) U_DEST_AD U_SPEC_APRFLAGS U,
%(2001)%    U_J(2002) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2002)%    U_ALU_XOR U_A(0) U_LSRC_AQ U_SKIP_ADEQ0 U
	),
    TST_U_2 = PLIT
	(
%(2000)%    U_J(2001) V_DP_N(7760) U_DEST_AD U,
%(2001)%    U_J(2002) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2002)%    U_ALU_XOR U_A(0) U_LSRC_AQ U_SKIP_ADEQ0 U
	),
    TST_U_3_4 = PLIT
	(
%(2000)%    U_J(2001) V_DP_N(7760) U_DEST_AD U, ! 4 ONLY
%(2001)%    U_J(2002) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2002)%    U_ALU_AND U_A(0) U_LSRC_AQ U_SKIP_ADEQ0 U
	),
    TST_U_5 = PLIT
	(
%(2000)%    U_J(2001) V_DP_N(0) U_SPEC_APRFLAGS U,
%(2001)%    U_J(2002) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2002)%    U_ALU_AND U_A(0) U_LSRC_AQ U_SKIP_ADEQ0 U
	),
    TST_U_6 = PLIT
	(
%(2000)%    U_J(2001) V_DP_N(100) U_DEST_AD U,
%(2001)%    U_J(2002) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2002)%    U_ALU_XOR U_A(0) U_LSRC_AQ U_SKIP_ADEQ0 U
	),
    TST_U_7 = PLIT
	(
%(2000)%    U_J(2003) V_DP_N(400) U_DEST_AD U,
%(2001)%    U_J(2002) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2002)%    U_ALU_XOR U_A(0) U_LSRC_AQ U_SKIP_ADEQ0 U,
%(2003)%    U_J(2004) V_DP__1 U_MEM U_N(43016) U,
%(2004)%    U_J(2001) U_MEM U_N(2) U
	),
    TST_U_8 = PLIT
	(
%(2000)%    U_J(2003) V_DP_N(200) U_DEST_AD U,
%(2001)%    U_J(2002) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2002)%    U_J(2003) U_N(400) U_ALU_XOR U_A(0) U_LSRC_AQ U_SKIP_ADEQ0 U,
%(2003)%    U_J(2004) V_DP_0 U_MEM U_N(43012) U,
%(2004)%    U_J(2001) U_MEM U_N(2) U
	);

    OK = 1;
    RPT_ERR_FLAG = 0;

    LOADUC(TST_U_ADR,TST_U_1);

    ERROR_LOOP(1)
    (
	WRT205(CLR_INT);		! RESET INTERRUPT-10 BIT
	SET_CRAM_ADR(TST_U_ADR);
	ACT_APR = STEP_U_NEXT(3);
	IF .ACT_APR EQL 0
	THEN
	(
	    ERRCAS(1,1,%O'7760',SERIAL(36),12,ERRINFO);	! DIDN'T SKIP
	    OK = 0;
	)
	ELSE
	(
	    ACT_APR = RD_301;
	    IF (.ACT_APR AND TEN_INT) EQL 0
	    THEN
	    (
		ERRCAS(1,2,(.ACT_APR OR TEN_INT),.ACT_APR,3,ERRINFO);
		OK = 0;
	    );
	);
	EXIT_LOOP(1,1);
	0
    );

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD APR FLAGS FROM DP WITH 7760
!*		READ APR FLAGS VIA DBM
!*RESPONSE:
!*	APR FLAGS SHOULD BE SET

!*MESSAGE 2
!*STIMULUS:
!*	8080:	CLEAR INTERRUPT-10 BIT IN REG 205
!*	KS10:	LOAD APR FLAGS FROM DP WITH 7760
!*	8080:	EXAMINE INTERRUPT-10 APR FLAG
!*RESPONSE:
!*	INTERRUPT-10 SHOULD BE SET

    LOADUC(TST_U_ADR,TST_U_2);

    ERROR_LOOP(2)
    (
	SET_CRAM_ADR(TST_U_ADR);
	ACT_APR = STEP_U_NEXT(3);
	IF .ACT_APR EQL 0
	THEN
	(
	    ERRCAS(1,3,%O'7760',SERIAL(36),12,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(2,1);
	0
    );

!*MESSAGE 3
!*STIMULUS:
!*	LOAD APR FLAGS FROM DP WITH 7760
!*	LOAD APR FROM PREVIOUS ???
!*	CHECK TO SEE IF THEY STAY SET
!*RESPONSE:
!*	THEY SHOULD STAY SET

    LOADUC(TST_U_ADR,TST_U_3_4);

    ERROR_LOOP(3)
    (
	MR();
	SET_CRAM_ADR(TST_U_ADR + 1);
	ACT_APR = STEP_U_NEXT(2);
	IF .ACT_APR EQL 0
	THEN
	(
	    ACT_APR = SERIAL(36) AND NOT %O'4000';	! VERSION 1.2
	    IF .ACT_APR NEQ 0 THEN
	    (
		ERRCAS(1,4,0,.ACT_APR,12,ERRINFO);
		OK = 0;
	    );
	);
	EXIT_LOOP(3,1);
	0
    );

!*MESSAGE 4
!*STIMULUS:
!*	LOAD APR FLAGS FROM DP WITH 7760
!*	DO A MASTER RESET
!*RESPONSE:
!*	APR FLAGS SHOULD BE CLEARED

    ERROR_LOOP(4)
    (
	SET_CRAM_ADR(TST_U_ADR);
	ACT_APR = STEP_U_NEXT(3);
	IF .ACT_APR EQL 0
	THEN
	(
	    ACT_APR = SERIAL(36) AND NOT %O'4000';	! VERSION 1.2
	    IF .ACT_APR NEQ 0 THEN
	    (
		ERRCAS(1,5,0,.ACT_APR,12,ERRINFO);
		OK = 0;
	    );
	);
	EXIT_LOOP(4,1);
	0
    );

!*MESSAGE 5
!*STIMULUS:
!*	DO A MASTER RESET TO CLEAR THE APR FLAGS
!*	LOAD FROM PREVIOUS ???
!*RESPONSE:
!*	APR FLAGS SHOULD STAY CLEAR

    LOADUC(TST_U_ADR,TST_U_5);

    ERROR_LOOP(5)
    (
	WRT205(CLR_INT);		! RESET INTERRUPT-10
	SET_CRAM_ADR(TST_U_ADR);
	ACT_APR = STEP_U_NEXT(3);
	IF .ACT_APR EQL 0
	THEN
	(
	    ACT_APR = SERIAL(36) AND NOT %O'4000';	! VERSION 1.2
	    IF .ACT_APR NEQ 0 THEN
	    (
		ERRCAS(1,6,0,.ACT_APR,12,ERRINFO);
		OK = 0;
	    );
	)
	ELSE
	(
	    ACT_APR = RD_301;
	    IFN (.ACT_APR AND TEN_INT)	! CHECK INTERRUPT-10 BIT
	    THEN
	    (
		ERRCAS(5,7,(.ACT_APR XOR TEN_INT),.ACT_APR,3,ERRINFO);
		OK = 0;
	    );
	);
	EXIT_LOOP(5,1);
	0
    );

!*MESSAGE 6
!*STIMULUS:
!*	LOAD APR FLAGS FROM DP WITH 0
!*	READ APR FLAGS VIA DBM
!*RESPONSE:
!*	APR FLAGS SHOULD BE CLEAR

!*MESSAGE 7
!*STIMULUS:
!*	8080:	CLEAR INTERRUPT-10 BIT IN REG 205
!*	KS10:	LOAD APR FLAGS FROM DP WITH 0
!*	8080:	EXAMINE INTERRUPT-10 APR FLAG
!*RESPONSE:
!*	INTERRUPT-10 SHOULD BE CLEAR

    LOADUC(TST_U_ADR,TST_U_6);

    ERROR_LOOP(6)
    (
	DI(100000,222);			! GET MMC CORECTED DATA
	DM(0,0);
	EM(0);
	SET_CRAM_ADR(TST_U_ADR);
	ACT_APR = STEP_U_NEXT(3);
	IF .ACT_APR EQL 0
	THEN
	(
	    ERRCAS(1,8,%O'100',SERIAL(36),12,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(6,1);
	0
    );

!*MESSAGE 8
!*STIMULUS:
!*	8080:	SET MMC FORCE BITS TO GET CORRECTABLE ECC ERROR
!*		DEPOSIT 0 TO PHYSICAL MEM LOC 0
!*	KS10:	READ PHYSICAL MEM LOC 0
!*		READ APR FLAGS
!*RESPONSE:
!*	MMC CORRECTED DATA APR FLAG SHOULD BE ASSERTED

    LOADUC(TST_U_ADR,TST_U_7);

    ERROR_LOOP(7)
    (
	SET_CRAM_ADR(TST_U_ADR);
	ACT_APR = STEP_U_NEXT(5);
	IF .MAX_MEM_ADR GTR %O'3777777'	! BE SURE WE HAVE AN NXM LOC
	THEN
	    OK = 0			! WE DON'T, SO WE CAN'T BE OK
	ELSE
	    IF .ACT_APR EQL 0
	    THEN
	    (
		ERRCAS(1,9,%O'400',SERIAL(36),12,ERRINFO);
		OK = 0;
	    );
	EXIT_LOOP(7,1);
	0
    );

!*MESSAGE 9
!*STIMULUS:
!*	LOAD VMA WITH -1 AND PERFORM A MEMORY READ
!*RESPONSE:
!*	NXM APR FLAG SHOULD BE ASSERTED

    SET_CRAM_ADR(TIU_MEMCLR);
    CP_NOSS(3);			! SINGLE STEP CLEARS MEMORY CYCLE

    LOADUC(TST_U_ADR,TST_U_8);

    ERROR_LOOP(8)
    (
	DI(100000,176);
	DM(0,0);
	SET_CRAM_ADR(TST_U_ADR);
	ACT_APR = STEP_U_NEXT(5);
	IF .ACT_APR EQL 0
	THEN
	(
	    ERRCAS(1,10,%O'400',SERIAL(36),12,ERRINFO);
	    OK = 0;
	);
	EXIT_LOOP(8,1);
	0
    );

!*MESSAGE 10
!*STIMULUS:
!*	8080:	SET MMC FORCE BITS TO GET UNCORRECTABLE ECC ERROR
!*		DEPOSIT 0 TO PHYSICAL MEM LOC 0
!*	KS10:	READ PHYSICAL MEM LOC 0
!*		READ APR FLAGS
!*RESPONSE:
!*	MMC BAD DATA ERR APR FLAG SHOULD BE ASSERTED

    IFN .OK THEN NOERR(1);

    SET_CRAM_ADR(TIU_MEMCLR);
    CP_NOSS(5);			! CLEAR ALL INTERRUPTS
    RPT_ERR_FLAG = 1;

!]ERROR 1
!]APR DBM_APR DBM_SEL_APR NTWK

!]NO ERROR 1
!]APR DBM_APR DBM_SEL_APR NTWK

    END;

GLOBAL ROUTINE TST55: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	APR ENABLES
!
!	(ORIGINALLY WRITTEN BY JEAN BASMAJI)
!
!--

    BEGIN

    MACRO
	INFO_FLAGS = 0,0,36,0 %,	! # TO LOAD APR FLAGS
	INFO_FLAGS_F3 = 0,0,12,0 %,
	INFO_FLAGS_F4 = 0,12,6,0 %,
	INFO_ENABLES = 1,0,36,0 %,	! # TO LOAD APR ENABLES
	INFO_ENABLES_F3 = 1,0,12,0 %,
	INFO_ENABLES_F4 = 1,12,6,0 %,
	INFO_TICKS = 2,0,36,0 %,	! # CLOCK PULSES ???
	INFO_COR = 3,0,36,0 %;		! CORRECT ???

    LOCAL
	OK,
	LOOPING;

    OWN
	INFO: BLOCKVECTOR[11,4] INITIAL
	(
	    %O'4000',  %O'4000',  5, %O'10',
	    %O'2000',  %O'2000',  5, %O'10',
	    %O'1000',  %O'1000',  5, %O'10',
	    %O'400',   %O'400',   5, %O'10',
	    %O'200',   %O'200',   5, %O'10',
	    %O'100',   %O'100',   5, %O'10',
	    %O'40',    %O'40',    5, %O'10',
	    %O'20',    %O'20',    5, %O'10',
	    %O'30010', %O'30010', 5, %O'10',
	    0,         %O'7760',  4, 0,
	    %O'7760',  0,         4, 0
	);

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'2005',
	TST_U = PLIT
	    (
%(2005)%    U_J(2006) V_DP_N(4000) U_SPEC_APRFLAGS U,	! #
%(2006)%    U_J(2007) V_DP_N(4000) U_SPEC_APR_EN U,	! #
%(2007)%    U_J(2010) V_DP_N(10) U_B(0) U_DEST_AD U,	! #
%(2010)%    U_J(2011) U_A(0) U_ALU_AND U_LSRC_DA U_DEST_Q_AD U_DBUS_DBM U_DBM_APR_FLAGS U,
%(2011)%    U_A(0) U_ALU_XOR U_LSRC_AQ U_SKIP_ADEQ0 U
	    );

    LOAD_TST_U;
    OK = 1;
    RPT_ERR_FLAG = 0;

    INCR ERRN FROM 0 TO 10 DO
    (
	ERRINFO[0] = .INFO[.ERRN,INFO_FLAGS];
	ERRINFO[1] = .INFO[.ERRN,INFO_ENABLES];

	IF .ERRN GTR 0
	THEN
	(
	    MOD_FLD(3,.INFO[.ERRN,INFO_FLAGS_F3]);
	    IF .INFO[.ERRN-1,INFO_FLAGS_F4] NEQ .INFO[.ERRN,INFO_FLAGS_F4]
	    THEN
		MOD_FLD(4,.INFO[.ERRN,INFO_FLAGS_F4]);

	    SET_CRAM_ADR(TST_U_ADR + 1);
	    MOD_FLD(3,.INFO[.ERRN,INFO_ENABLES_F3]);
	    IF .INFO[.ERRN-1,INFO_ENABLES_F4] NEQ .INFO[.ERRN,INFO_ENABLES_F4]
	    THEN
		MOD_FLD(4,.INFO[.ERRN,INFO_ENABLES_F4]);

	    IF .ERRN EQL 9
	    THEN
	    (
		LC(2007);
		MOD_FLD(4,3);
	    )
	    ELSE
		IF .ERRN EQL 10
		THEN
		(
		    LC(2010);
		    MOD_FLD(0,0);
		    MOD_FLD(1,%O'6607');
		    MOD_FLD(2,2);
		);
	);

	LOOPING = 0;
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(TST_U_ADR);
	    IF STEP_U_NEXT(.INFO[.ERRN,INFO_TICKS]) EQL 0
	    THEN
	    (
		ERRCAS(1,1,.INFO[.ERRN,INFO_COR],SERIAL(36),12,ERRINFO);
		OK = 0;
	    );
	    LOOPING = 1;
	    EXIT_LOOP(1,1);
	    0
	);
    );
    RPT_ERR_FLAG = 1;

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	LOAD APR FLAGS FROM DP WITH \O0
!*	LOAD APR ENABLES FROM DP WITH \O1
!*	READ APR FLAGS VIA DBM
!*	CHECK BITS 22 (TRAP), 23 (PAGE), 32 (IRQ)
!*RESPONSE:

!]ERROR 1
!]APR_EN DBM_APR_EN DBM_SEL_APR_EN APR NTWK

!]NO ERROR 1
!]APR_EN DBM_APR_EN DBM_SEL_APR_EN NTWK

    END;

GLOBAL ROUTINE TST56: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE DATA INPUTS/OUTPUTS PARITY CHECKING
!	WRITE (& CHECK FOR DP PAR ERR) AT VMA 377777
!	MAPPED TO PMA 777, 1777, 2777, 4777, ..., MAX_MEM_ADR
!	(WITH WRITABLE AND WRITE-TEST ON)
!
!--

    BEGIN

    MACRO
	INFO_PTE = 0,0,36,0 %,		! PAGE TABLE ENTRY
	INFO_PTE_FLD3 = 0,0,12,0 %,
	INFO_PTE_FLD4 = 0,12,6,0 %,
	INFO_VMA = 1,0,36,0 %,		! VMA TO USE (FLD 3 SAME)
	INFO_VMA_FLD4 = 1,12,6,0 %,
	INFO_USER = 2,0,36,0 %;		! USER BIT FOR IT ALL

    LOCAL
	ERRN,
	VMA,
	CURR_PAGE,
	COR_MEM_ADR,
	ACT_MEM_ADR,
	CRAM_ADR,
	OLD_PTE,
	OLD_VMA,
	OLD_USER,
	OK;

    OWN
	INFO: BLOCKVECTOR[18,3] INITIAL
	(
	    %O'440000', %O'377777', 0,	! LEFT PT RAM PARITY PINS
	    %O'440001', %O'377777', 0,	! LEFT PT RAM PARITY PINS
	    %O'460000', %O'777777', 0,	! CACHABLE
	    %O'440000', %O'777777', 0,	! RIGHT PT RAM PARITY PINS
	    %O'440001', %O'777777', 0,	! RIGHT PT RAM PARITY PINS
	    %O'440002', %O'777777', 0,
	    %O'440004', %O'777777', 0,
	    %O'440010', %O'777777', 0,
	    %O'440020', %O'777777', 0,
	    %O'440040', %O'777777', 0,
	    %O'440100', %O'777777', 0,
	    %O'440200', %O'777777', 0,
	    %O'440400', %O'777777', 0,
	    %O'441000', %O'777777', 0,
	    %O'442000', %O'777777', 0,
	    %O'400000', %O'777777', 0,	! UNWRITABLE
	    %O'440000', %O'777777', 1,	! USER
	    %O'000000', %O'777777', 0	! INVALID
	);

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1050',
	TST_U = PLIT
	    (
%(1050)%    U_J(1051) V_DP_N(377777) U_B_T0 U_DEST_AD U,	! #
%(1051)%    U_J(1052) V_DP_T0 U_MEM U_N(203010) U_SPEC_LDPAGE U,	! #
%(1052)%    U_J(1053) V_DP_N(440000) U,				! #
%(1053)%    U_J(1054) V_DP_T0 U_MEM U_N(242012) U,		! #
%(1054)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_VMA = TST_U_ADR + 0,	! WHERE TO FIX VMA PAGE #
	TUA_LDPAG = TST_U_ADR + 1,	! WHERE TO FIX # TO LOAD PTE
	TUA_PAG = TST_U_ADR + 2,	! WHERE TO FIX PAGE TABLE ENTRY
	TUA_READ = TST_U_ADR + 3;	! WHERE TO FIX # TO DO READ

    LOAD_TST_U;

    PAGING_ON;
    OLD_PTE = .INFO[0,INFO_PTE];
    OLD_VMA = .INFO[0,INFO_VMA];
    OLD_USER = .INFO[0,INFO_USER];
    RPT_ERR_FLAG = 0;
    OK = 1;

    INCR ERRN FROM 0 TO 17 DO
	IF .INFO[.ERRN,INFO_PTE_FLD3] LEQ (.MAX_MEM_ADR ^ (-9))
	THEN
	(
	    ERRINFO[0] = .FORCE_NAME[.INFO[.ERRN,INFO_USER]];
	    ERRINFO[1] = .INFO[.ERRN,INFO_PTE];
	    ERRINFO[2] = VMA = .INFO[.ERRN,INFO_VMA];
	    ERRINFO[3] = .VMA ^ (-9);		! PAGE NUMBER

	    IF .OLD_PTE NEQ .INFO[.ERRN,INFO_PTE]
	    THEN
	    (
		SET_CRAM_ADR(TUA_PAG);
		IF .OLD_PTE<N_FLD3> NEQ .INFO[.ERRN,INFO_PTE_FLD3]
		THEN
		    MOD_FLD(3,.INFO[.ERRN,INFO_PTE_FLD3]);
		IF .OLD_PTE<N_FLD4> NEQ .INFO[.ERRN,INFO_PTE_FLD4]
		THEN
		    MOD_FLD(4,.INFO[.ERRN,INFO_PTE_FLD4]);
		OLD_PTE = .INFO[.ERRN,INFO_PTE];
	    );

	    IF .OLD_USER NEQ .INFO[.ERRN,INFO_USER]
	    THEN
	    (
		OLD_USER = .INFO[.ERRN,INFO_USER];
		SET_CRAM_ADR(TUA_LDPAG);
		MOD_FLD(4,.FORCE_MODE[.OLD_USER]);
		SET_CRAM_ADR(TUA_READ);
		MOD_FLD(4,(.FORCE_MODE[.OLD_USER] OR 4));
	    );

	    IF .OLD_VMA NEQ .INFO[.ERRN,INFO_VMA]
	    THEN
	    (
		OLD_VMA = .INFO[.ERRN,INFO_VMA];
		SET_CRAM_ADR(TUA_VMA);
		MOD_FLD(4,.OLD_VMA<N_FLD4>);
	    );

	    ERROR_LOOP(1)
	    (
		SET_CRAM_ADR(TST_U_ADR);
		CP(5);
		IF (RD_303 AND 1) EQL 0	! RAM PARITY ERROR?
		THEN
		(
		    ERRS(1,1,ERRINFO);
		    OK = 0;
		    MR();		! CLEAR THE FAULT
		);

		EXIT_LOOP(1,1);
		0
	    );
	);

    IFN .OK THEN NOERR(1);

    RPT_ERR_FLAG = 1;
    PAGING_OFF;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD \O1 INTO PAGE TABLE LOC \O3, \S0 MODE
!*		READ VIRTUAL MEM LOC \O2, \S0 MODE
!*	8080:	READ REGISTER 303 BIT 0 (RAM PARITY ERROR)
!*RESPONSE:
!*	SHOULD BE 0 TO INDICATE NO PARITY ERROR (BUT IT WASN'T)

!]ERROR 1
!]PT_PAR PT_PAR_GEN PAR_ERR BUS_T BUS_R BUS_PAR NTWK

!]NO ERROR 1
!]PT_PAR PT_PAR_GEN NTWK

    END;

GLOBAL ROUTINE TST57: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PAGE TABLE RAM CONTENTS
!	PAGE PARITY STUCK HIGH/LOW
!
!--

    BEGIN

    LOCAL
	VMA,
	PTE,
	TICKS,
	LOOPING,
	OK;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1060',
	TST_U = PLIT
	    (
%(1060)%    U_J(1061) V_DP_N(440000) U_B(1) U_DEST_AD U,	! #
%(1061)%    U_J(1063) V_DP_N(777) U_B(0) U_DEST_AD U,
%(1062)%    U_J(1063) V_D_N(1000) U_A(0) U_B(0) U_ALU_ADD U_DEST_AD U_LSRC_0A U_RSRC_DA U,
%(1063)%    U_J(1064) V_DP_R(0) U_MEM U_N(3010) U_SPEC_LDPAGE U,
%(1064)%    U_J(1065) V_DP_R(1) U,
%(1065)%    U_J(1066) V_DP_R(0) U_MEM U_N(32012) U,
%(1066)%    V_DP_0 U_MEM U_N(2) U
	    ),
	TUA_PAG = TST_U_ADR + 0,	! WHERE TO DIDDLE PAGE MAP
	TUA_VMA = TST_U_ADR + 2,	! WHERE TO INCREMENT VMA
	TUA_TST = TST_U_ADR + 3;	! WHERE TO RESTART TEST

    IFN .INH_PT_RAM THEN RETURN;	! FORGET IT IF HE SAID TO

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;
    OK = 1;
    SET_CRAM_ADR(PHU_ADR);
    PAGING_ON;

    INCR SUBTEST FROM 0 TO 1 DO		! CHECK FOR STUCK HIGH & LOW
    (
	SET_CRAM_ADR(TUA_PAG);		! WE START RUNNING HERE, TOO
	ERRINFO[2] = PTE = %O'440000' OR .SUBTEST;
	IFN .SUBTEST		! LOADED U-CODE MAPS TO PAGE 0
	THEN
	    MOD_FLD(3,.PTE<N_FLD3>);

	INCR VIR_PAG FROM 0 TO %O'777' DO	! DO THE WHOLE THING
	(
	    ERRINFO[3] = .VIR_PAG;
	    ERRINFO[0] = VMA = (.VIR_PAG ^ 9) OR %O'777';
	    IFN .VIR_PAG
	    THEN
	    (
		SET_CRAM_ADR(TUA_VMA);
		TICKS = 7;
	    )
	    ELSE
		TICKS = 8;
	    LOOPING = 0;		! FIRST TIME THROUGH ERROR LOOP
	    ERROR_LOOP(1)
	    (
		IFN .LOOPING THEN SET_CRAM_ADR(TUA_TST);
		CP(.TICKS);
		IF (RD_303 AND 1) EQL 0
		THEN
		(
		    ERRS(1,1,ERRINFO);
		    OK = 0;
		);
		! GET READY TO DO IT OVER (IF ERROR OCCURED)
		LOOPING = 1;
		TICKS = 6;
		EXIT_LOOP(1,1);
		0
	    );
	);
    );

    IFN .OK THEN NOERR(1);

    PAGING_OFF;
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD \O2 INTO PAGE TABLE LOC \O3
!*		DEPOSIT 0 TO VIRTUAL MEM LOC \O0
!*	8080:	READ REGISTER 303 BIT 0 (RAM PARITY ERROR)
!*RESPONSE:
!*	SHOULD BE 0 TO INDICATE NO PARITY ERROR (BUT IT WASN'T)

!]ERROR 1
!]PT_RAM_PAR PT_PAR PT_PAR_GEN PAR_ERR BUS_T BUS_R BUS_PAR NTWK

!]NO ERROR 1
!]PT_RAM_PAR PT_PAR PT_PAR_GEN NTWK

    END;

GLOBAL ROUTINE TST58: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST CACHE DIRECTORY DATA INPUTS/OUTPUTS PARITY CHECKING
!	WRITE AND READ AT VARIOUS VMA VALUES MAPPED TO PAGE 0
!
!--

    BEGIN

    MACRO
	INFO_USER = 0,0,36,0 %,		! USER BIT FOR IT ALL
	INFO_VMA = 1,0,36,0 %,		! VMA TO USE
	INFO_VMA_FLD3 = 1,0,12,0 %,
	INFO_VMA_FLD4 = 1,12,6,0 %;

    LOCAL
	OK,
	VMA,
	PMA,
	CRAM_ADR,
	OLD_VMA,
	OLD_USER;

    OWN
	INFO: BLOCKVECTOR[13,2] INITIAL
	(
	    1, %O'000377',
	    0, %O'000377',
	    0, %O'000777',
	    0, %O'001377',
	    0, %O'001777',
	    0, %O'002377',
	    0, %O'004377',
	    0, %O'010377',
	    0, %O'020377',
	    0, %O'040377',
	    0, %O'100377',
	    0, %O'200377',
	    0, %O'400377'
	);

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1070',
	TST_U = PLIT
	    (
%(1070)%    U_J(1071) V_DP_N(000377) U_B_T0 U_DEST_AD U,	! #
%(1071)%    U_J(1072) V_DP_T0 U_MEM U_N(403010) U_SPEC_LDPAGE U,	! #
%(1072)%    U_J(1073) V_DP_N(460000) U,
%(1073)%    U_J(1074) V_DP_T0 U_MEM U_N(430012) U,		! #
%(1074)%    V_DP__1 U_MEM U_N(2) U,
%(1075)%    U_J(1076) V_DP_T0 U_MEM U_N(440012) U,		! #
%(1076)%    V_DP_D U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_VMA = TST_U_ADR + 0,	! WHERE TO FIX VMA PAGE #
	TUA_LDPAG = TST_U_ADR + 1,	! WHERE TO FIX # TO LOAD PTE
	TUA_WRITE = TST_U_ADR + 3,	! WHERE TO FIX # TO DO WRITE
	TUA_READ = TST_U_ADR + 5;	! WHERE TO FIX # TO DO READ

    LOAD_TST_U;
    OK = 1;

    PAGING_ON;
    CE(1);				! TURN CACHE ON
    OLD_VMA = .INFO[0,INFO_VMA];
    OLD_USER = .INFO[0,INFO_USER];
    RPT_ERR_FLAG = 0;
    INCR ERRN FROM 0 TO 12 DO
    (
	ERRINFO[0] = .FORCE_NAME[.INFO[.ERRN,INFO_USER]];
	ERRINFO[2] = VMA = .INFO[.ERRN,INFO_VMA];
	ERRINFO[1] = PMA = .VMA<0,9>;	! MAPPED TO PAGE 0
	ERRINFO[3] = .VMA<9,9>;		! PAGE NUMBER

	IF .OLD_USER NEQ .INFO[.ERRN,INFO_USER]
	THEN
	(
	    OLD_USER = .INFO[.ERRN,INFO_USER];
	    SET_CRAM_ADR(TUA_LDPAG);
	    MOD_FLD(4,.FORCE_MODE[.OLD_USER]);
	    SET_CRAM_ADR(TUA_WRITE);
	    MOD_FLD(4,(.FORCE_MODE[.OLD_USER] OR 3));
	    SET_CRAM_ADR(TUA_READ);
	    MOD_FLD(4,(.FORCE_MODE[.OLD_USER] OR 4));
	);

	IF .OLD_VMA NEQ .INFO[.ERRN,INFO_VMA]
	THEN
	(
	    SET_CRAM_ADR(TUA_VMA);
	    IF .OLD_VMA<N_FLD3> NEQ .INFO[.ERRN,INFO_VMA_FLD3]
	    THEN
		MOD_FLD(3,.INFO[.ERRN,INFO_VMA_FLD3]);
	    IF .OLD_VMA<N_FLD4> NEQ .INFO[.ERRN,INFO_VMA_FLD4]
	    THEN
		MOD_FLD(4,.INFO[.ERRN,INFO_VMA_FLD4]);
	    OLD_VMA = .INFO[.ERRN,INFO_VMA];
	);

	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(TST_U_ADR);
	    CP(6);			! WRITE -1 TO MEM; EXTRA TICK?
	    MEM_DEPOSIT(.PMA,0);	! DIDDLE MEM BUT NOT CACHE
	    SET_CRAM_ADR(TUA_READ);
	    CRAM_ADR = STEP_U_NEXT(2);
	    IF (RD_303 AND 1) EQL 0	! RAM PARITY ERROR?
	    THEN
	    (
		ERRS(1,1,ERRINFO);
		MR();			! CLEAR FAULT
		OK = 0;
	    )
	    ELSE
		IFN .CRAM_ADR	! FAULT: MISS: READ 0: ALU=0: SKIP: ADR=1
		THEN
		(
		    ERRS(1,2,ERRINFO);
		    MR();		! CLEAR FAULT
		    OK = 0;
		);

	    EXIT_LOOP(1,1);
	    0
	);
    );

    IFN .OK THEN NOERR(1);

    RPT_ERR_FLAG = 1;
    PAGING_OFF;
    CE(0);			! TURN CACHE OFF

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD 460000 INTO PAGE TABLE LOC \O3, \S0 MODE
!*		WRITE, THEN READ VIRTUAL MEM LOC \O2, \S0 MODE
!*	8080:	READ REGISTER 303 BIT 0 (RAM PARITY ERROR)
!*RESPONSE:
!*	SHOULD BE 0 TO INDICATE NO PARITY ERROR (BUT IT WASN'T)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	LOAD 460000 INTO PAGE TABLE LOC \O3, \S0 MODE
!*		WRITE -1 TO VIRTUAL MEM LOC \O2, \S0 MODE
!*	8080:	WRITE 0 TO PHYSICAL MEM LOC \O1
!*	KS10:	READ VIRTUAL MEM LOC \O2, \S0 MODE
!*RESPONSE:
!*	SHOULD GET 0 (CACHE HIT); DIDN'T (CACHE DIR PAR ERR?)

!]ERROR 1
!]CD_PAR PAR_ERR N_ALL PT_IO PT_CAC CD_IO CD_CMP CD_HIT PT_MESS NTWK

!]NO ERROR 1
!]CD_PAR NTWK

    END;

GLOBAL ROUTINE TST59: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST CACHE DIRECTORY RAM CONTENTS PARITY BIT TEST
!
!--

    BEGIN

    MACRO
	INFO_USER = 0,0,36,0 %,		! USER BIT FOR IT ALL
	INFO_VMA = 1,0,36,0 %,		! VMA TO USE
	INFO_VMA_FLD3 = 1,0,12,0 %,
	INFO_VMA_FLD4 = 1,12,6,0 %;

    LOCAL
	VMA,
	PMA,
	CRAM_ADR,
	OLD_VMA,
	LOOPING;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1100',
	TST_U = PLIT
	    (
%(1100)%    U_J(1101) V_DP_N(002000) U_B_T0 U_DEST_AD U,	! #
%(1101)%    U_J(1102) V_DP_T0 U_MEM U_N(3010) U_SPEC_LDPAGE U,
%(1102)%    U_J(1103) V_DP_N(460001) U,
%(1103)%    U_J(1104) V_DP_T0 U_MEM U_N(30012) U,
%(1104)%    V_DP__1 U_MEM U_N(2) U,
%(1105)%    U_J(1106) V_DP_T0 U_MEM U_N(40012) U,
%(1106)%    V_DP_D U_DBM_MEM U_DBUS_DBM U_SKIP_ADEQ0 U_MEM U_N(2) U
	    ),
	TUA_VMA = TST_U_ADR + 0,	! WHERE TO FIX VMA PAGE #
	TUA_READ = TST_U_ADR + 5;	! WHERE TO START READ

    IFN .INH_CD_RAM THEN RETURN;	! FORGET IT IF HE SAID TO

    LOAD_TST_U;

    PAGING_ON;
    CE(1);				! TURN CACHE ON
    OLD_VMA = %O'2000';
    RPT_ERR_FLAG = 0;

    INCR ERRN FROM 0 TO %O'1777' DO	! EACH LOC, 2 PAGES (HIGH, LOW)
    (
	ERRINFO[2] = VMA = %O'2000' OR .ERRN;
	ERRINFO[1] = PMA = .VMA<0,9> OR %O'1000';	! MAP TO PAGE 1
	ERRINFO[3] = .VMA<9,9>;		! PAGE NUMBER

	IF .OLD_VMA NEQ .VMA
	THEN
	(
	    SET_CRAM_ADR(TUA_VMA);
	    IF .OLD_VMA<N_FLD3> NEQ .VMA<N_FLD3> THEN MOD_FLD(3,.VMA<N_FLD3>);
	    IF .OLD_VMA<N_FLD4> NEQ .VMA<N_FLD4> THEN MOD_FLD(4,.VMA<N_FLD4>);
	    OLD_VMA = .VMA
	);

	LOOPING = 0;
	ERROR_LOOP(1)
	(
	    IFN .LOOPING THEN SET_CRAM_ADR(TST_U_ADR);
	    CP(6);			! WRITE -1 TO MEM; EXTRA TICK?
	    MEM_DEPOSIT(.PMA,0);	! DIDDLE MEM BUT NOT CACHE
	    SET_CRAM_ADR(TUA_READ);
	    CRAM_ADR = STEP_U_NEXT(2);
	    IF (RD_303 AND 1) EQL 0	! RAM PARITY ERROR?
	    THEN
	    (
		ERRS(1,1,ERRINFO);
		MR();			! CLEAR FAULT
	    )
	    ELSE
		IFN .CRAM_ADR	! FAULT: MISS: READ 0: ALU=0: SKIP: ADR=1
		THEN
		(
		    ERRS(1,2,ERRINFO);
		    MR();		! CLEAR FAULT
		)
		ELSE
		    NOERR(1);
	    LOOPING = 1;
	    EXIT_LOOP(1,1);
	    0
	);
    );

    RPT_ERR_FLAG = 1;
    PAGING_OFF;
    CE(0);			! TURN CACHE OFF

!*MESSAGE 1
!*STIMULUS:
!*	KS10:	LOAD 460001 INTO PAGE TABLE LOC \O3
!*		WRITE, THEN READ VIRTUAL MEM LOC \O2
!*	8080:	READ REGISTER 303 BIT 0 (RAM PARITY ERROR)
!*RESPONSE:
!*	SHOULD BE 0 TO INDICATE NO PARITY ERROR (BUT IT WASN'T)

!*MESSAGE 2
!*STIMULUS:
!*	KS10:	LOAD 460001 INTO PAGE TABLE LOC \O3
!*		WRITE -1 TO VIRTUAL MEM LOC \O2
!*	8080:	WRITE 0 TO PHYSICAL MEM LOC \O1
!*	KS10:	READ VIRTUAL MEM LOC \O2
!*RESPONSE:
!*	SHOULD GET 0 (CACHE HIT); DIDN'T (CACHE DIR PAR ERR?)

!]ERROR 1
!]CD_RAM_PAR CD_PAR PAR_ERR N_ALL PT_IO PT_CAC CD_IO CD_CMP CD_HIT PT_MESS NTWK

!]NO ERROR 1
!]CD_RAM_PAR NTWK

    END;

GLOBAL ROUTINE TST60: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PREVIOUS EXECUTE (PXCT) REGISTER & MUX
!
!--

    BEGIN

    MACRO
	INFO_PXCT = 0,0,36,0 %,
	INFO_PXCT_BITS = 0,0,1,0 %,
	INFO_PXCT_ON = 0,1,1,0 %,
	INFO_PXCT_FLD3 = 1,0,36,0 %,
	INFO_PXCT_SEL = 1,6,3,0 %,
	INFO_VMA_PREV = 2,0,36,0 %;

    LOCAL
	OK,
	OLD_PXCT,
	VMA_PREV,
	LOOPING;

    OWN
	INFO: BLOCKVECTOR[17,3] INITIAL
	(
	    0, %O'3010', 0,
	    0, %O'3110', 0,
	    0, %O'3210', 0,
	    0, %O'3310', 0,
	    0, %O'3410', 0,
	    0, %O'3510', 0,
	    0, %O'3610', 0,
	    0, %O'3710', 0,
	    1, %O'3010', 0,
	    1, %O'3110', 1,
	    1, %O'3210', 1,
	    1, %O'3310', 1,
	    1, %O'3410', 1,
	    1, %O'3510', 1,
	    1, %O'3610', 1,
	    1, %O'3710', 1,
	    2, %O'3710', 0
	);

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1120',
	TST_U = PLIT
	    (
%(1120)%    V_DP_0 U_SPEC_LDPXCT U,
%(1121)%    V_DP__1 U_SPEC_LDPXCT U,
%(1122)%    V_DP__1 U_SPEC_PXCT_OFF U,
%(1123)%    U_J(1124) U_MEM U_N(3010) U,	! #<9:11>
%(1124)%    U_DBM_VMA U_DBUS_DBM V_DP_D U_DEST_Q_AD U
	    ),
	TUA_INIT = TST_U_ADR + 0,	! LOAD REGISTER
	TUA_NEXT = TST_U_ADR + 3;	! DO NEXT SELECT

    LOAD_TST_U;
    OK = 1;

    RPT_ERR_FLAG = 0;
    INCR ERRN FROM 0 TO 16 DO
    (
	LOOPING = 0;
	IF (.ERRN EQL 0) OR (.INFO[.ERRN,INFO_PXCT] NEQ .OLD_PXCT)
	THEN
	(
	    SET_CRAM_ADR(TUA_INIT + .INFO[.ERRN,INFO_PXCT]);
	    CP(2);
	);
	OLD_PXCT = .INFO[.ERRN,INFO_PXCT];
	SET_CRAM_ADR(TUA_NEXT);
	IFN .ERRN THEN MOD_FLD(3,.INFO[.ERRN,INFO_PXCT_FLD3]);
	ERROR_LOOP(1)
	(
	    IFN .LOOPING THEN SET_CRAM_ADR(TUA_NEXT);
	    VMA_PREV = STEP_U_NEXT(14);		! (CP(2); SERIAL(9,1))
	    IF .VMA_PREV NEQ .INFO[.ERRN,INFO_VMA_PREV]
	    THEN
	    (
		ERRINFO[0] = .INFO[.ERRN,INFO_PXCT_BITS];
		ERRINFO[1] = .INFO[.ERRN,INFO_PXCT_SEL];
		ERRINFO[2] = .INFO[.ERRN,INFO_VMA_PREV];
		ERRINFO[3] = .VMA_PREV;
		ERRINFO[4] = .INFO[.ERRN,INFO_PXCT_ON];
		ERRS(1,1,ERRINFO);
		OK = 0;
	    );
	    LOOPING = 1;
	    EXIT_LOOP(1,1);
	    0
	);
    );

    IFN .OK THEN NOERR(1);

    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	SET ALL PXCT BITS TO \O0, PXCT ON = \O4
!*	LOAD VMA, PXCT SEL #<9:11> = \O1
!*RESPONSE:
!*	VMA PREV SHOULD BE \O2 BUT IT WAS \O3

!]ERROR 1
!]PXCT PXCT_MUX DBM_VMA DBM_SEL_VMA SPEC_PXCT_EN SPEC_PXCT_OFF NTWK

!]NO ERROR 1
!]PXCT PXCT_MUX DBM_VMA DBM_SEL_VMA SPEC_PXCT_EN SPEC_PXCT_OFF NTWK

    END;

GLOBAL ROUTINE TST61: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	TEST PREVIOUS EXECUTE (PXCT) MUX OUTPUT TO DPE BOARD
!
!--

    BEGIN

    LOCAL
	OK,
	CRAM_ADR;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'1130',
	TST_U = PLIT
	    (
%(1130)%    U_J(1131) V_DP_NN(100) U_SPEC_LDACBLK U,	! CUR=0, PREV=1
%(1131)%    U_J(1132) V_DP_0 U_DBUS_DP U_FMWRITE U_RAM_N U_N(0) U,
%(1132)%    V_DP__1 U_DBUS_DP U_FMWRITE U_RAM_N U_N(20) U,
%(1133)%    U_J(1135) V_DP__1 U_SPEC_LDPXCT U,
%(1134)%    U_J(1135) V_DP_0 U_SPEC_PXCT_OFF U,
%(1135)%    U_J(1136) V_DP_0 U_DBUS_DP U_SPEC_LOADXR U_N(700) U,
%(1135)%    U_RAM_XR U_DBUS_RAM V_DP_D U_SKIP_ADEQ0 U
	    ),
	TUA_INIT = TST_U_ADR + 0,	! LOAD AC BLK & AC
	TUA_TEST = TST_U_ADR + 3;	! DO THE TESTS

    LOAD_TST_U;
    OK = 1;

    SET_CRAM_ADR(TUA_INIT);
    CP(4);
    INCR ERRN FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    SET_CRAM_ADR(TUA_TEST + .ERRN);
	    CRAM_ADR = STEP_U_NEXT(3);
	    IF .CRAM_ADR NEQ .ERRN
	    THEN
	    (
		ERRINFO[0] = (NOT .ERRN) AND 1;
		ERRINFO[1] = - .ERRN;
		ERRS(1,1,ERRINFO);
		OK = 0;
	    );
	    EXIT_LOOP(1,1);
	    0
	);

    IFN .OK THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	SET CURRENT AC BLOCK TO 0; PREVIOUS AC BLOCK TO 1
!*	SET AC0 BLOCK 0 TO 0; AC0 BLOCK 1 TO -1
!*	SET XR PREVIOUS TO \O0 AND READ XR0
!*RESPONSE:
!*	SHOULD GET \O1 (BUT DIDN'T)

!]ERROR 1
!]PXCT PXCT_MUX_DPE SPEC_PXCT_EN SPEC_PXCT_OFF NTWK

!]NO ERROR 1
!]PXCT PXCT_MUX_DPE SPEC_PXCT_EN SPEC_PXCT_OFF NTWK

    END;

GLOBAL ROUTINE TST62: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	SC SIGN TEST
!
!	(ORIGINALLY WRITTEN BY RICH MURATORI)
!
!--

    BEGIN

    LOCAL
	ACTUAL,
	OK;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'3000',
	TST_U = PLIT
	    (
%(3000)%    U_J(3002) U_LOADSC U_SCADA_SN U_SN(0) U_SCAD_A U,
%(3001)%    U_J(3002) U_LOADSC U_SCADA_SN U_SN(1000) U_SCAD_A U,
%(3002)%    U_SKIP_SC U
	    ),
	TUA_0 = TST_U_ADR + 0,		! CLEAR THE BIT
	TUA_1 = TST_U_ADR + 1;		! SET THE BIT

    LOAD_TST_U;
    OK = 1;

    ERROR_LOOP(1)
    (

	SET_CRAM_ADR(TUA_1);		! WE WILL SET THE SC SIGN BIT
	ACTUAL = STEP_U_NEXT(2);	! EXECUTE SC SIGN BIT SKIP
	IF .ACTUAL EQL 0		! DID WE TAKE SKIP?
	THEN
	(
	    ERRCAS(1,1,1,.ACTUAL,4,ERRINFO);	! NO, REPORT ERROR
	    OK = 0;
	);
	EXIT_LOOP(1,1);
	0
    );

!*MESSAGE 1
!*STIMULUS:
!*	SET 'DPM SC SIGN'; JUMP TO 0 AND SKIP ON SC SIGN
!*RESPONSE:
!*	NEXT CRAM ADDRESS SHOULD BE 1 (BUT IT WASN'T)

    ERROR_LOOP(2)
    (

	SET_CRAM_ADR(TUA_0);		! WE WILL CLEAR THE SC SIGN BIT
	ACTUAL = STEP_U_NEXT(2);	! EXECUTE SC SIGN BIT SKIP
	IFN .ACTUAL		! DID WE TAKE SKIP?
	THEN
	(
	    ERRCAS(1,2,0,.ACTUAL,4,ERRINFO);	! YES, REPORT ERROR
	    OK = 0;
	);
	EXIT_LOOP(2,1);
	0
    );

    IFN .OK THEN NOERR(1);

!*MESSAGE 2
!*STIMULUS:
!*	CLEAR 'DPM SC SIGN'; JUMP TO 0 AND SKIP ON SC SIGN
!*RESPONSE:
!*	NEXT CRAM ADDRESS SHOULD BE 0 (BUT IT WASN'T)

!]ERROR 1
!]SCAD_A SC_EN SC_SIGN SCADA_SN SCADA_SEL_SN NTWK

!]NO ERROR 1
!]SCAD_A SC_EN SC_SIGN SCADA_SN SCADA_SEL_SN NTWK

    END;

GLOBAL ROUTINE TST63: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
!	CORRECTLY.  SPECIFICALLY, THAT 'CRA/M CLK ENABLE' NEGATES AND 'DPE/M
!	CLK ENABLE' ASSERTS WHEN 'CRM2 MULTI SHIFT' AND 'FE SIGN' ARE ASSERTED.
!
!	THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
!	CORRECTLY.  SPECIFICALLY, THAT 'DPE/M CLK ENABLE' NEGATES AND 'CRA/M
!	CLK ENABLE' ASSERTS WHEN 'CRM2 MULTI SHIFT' IS ASSERTED AND 'FE SIGN'
!
!	(ORIGINALLY WRITTEN BY RICH MURATORI)
!
!--

    BEGIN

    MACRO
	INFO_TUA = 0,0,36,0 %,
	INFO_TICKS = 1,0,36,0 %,
	INFO_SN = 2,0,36,0 %,
	INFO_CR = 3,0,36,0 %,
	INFO_CR_MSG = 4,0,36,0 %,
	INFO_DP = 5,0,36,0 %,
	INFO_DP_MSG = 6,0,36,0 %;

    LOCAL
	OK,
	TEMP;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'3010',
	TST_U = PLIT
	    (
%(3010)%    U_J(3012) U_T(0) U_LOADFE U_SCAD_A U_SCADA_SN U_SN(1000) U,
%(3011)%    U_J(3012) U_T(0) U_LOADFE U_SCAD_A U_SCADA_SN U_SN(0) U,
%(3012)%    U_T(0) U_MULTI_SHIFT U
	    ),
	TUA_0 = TST_U_ADR + 0,
	TUA_1 = TST_U_ADR + 1;

    OWN
	INFO: BLOCKVECTOR[2,7] INITIAL
	(
	    TUA_0, 16, %O'1000',          0, 1,           0, 2,
	    TUA_1,  9, %O'0000', CR_CLK_ENB, 3, DP_CLK_ENBL, 4
	);

    LOAD_TST_U;
    OK = 1;

    INCR SUBTEST FROM 0 TO 1 DO
	ERROR_LOOP(1)
	(
	    MR();
	    SET_CRAM_ADR(.INFO[.SUBTEST,INFO_TUA]);
	    SYNC_CLK();			! STOP CLOCK AND SYNC IT
	    WRT206(SINGLE_CLK);		! ASSERT 'SINGLE CLK'
	    CYCLE(4);			! EXECUTE 1ST MICRO-INSTR
	    WRT206(SINGLE_CLK);		! ASSERT 'SINGLE CLK'
	    TICK(.INFO[.SUBTEST,INFO_TICKS]);	! EXECUTE 2ND MICRO-INSTR
	    TEMP = RD_303;		! READ STATES OF CLOCK ENABLES

	    ! CRA M CLK ENABLE
	    IF (.TEMP AND CR_CLK_ENB) NEQ .INFO[.SUBTEST,INFO_CR]
	    THEN
	    (
		ERRS(1,.INFO[.SUBTEST,INFO_CR_MSG],ERRINFO);
		OK = 0;
	    );

	    EXIT_LOOP(1,1);

	    ! DPE M CLK ENABLE
	    IF (.TEMP AND DP_CLK_ENBL) NEQ .INFO[.SUBTEST,INFO_DP]
	    THEN
	    (
		ERRS(1,.INFO[.SUBTEST,INFO_DP_MSG],ERRINFO);
		OK = 0;
	    );

	    EXIT_LOOP(1,1);

	    0
	);

    IFN .OK THEN NOERR(1);

    MR();

!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 1.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.'MULTI SHIFT' AND
!*			  'FE SIGN' SHOULD ASSERT 'FS (1)'.  THIS WILL
!*			  HOLD 'ENABLE (1)' ASSERTED AND CAUSE 'CRA/M
!*			  CLK ENABLE' TO NEGATE WHILE 'DPE/M CLK ENABLE'
!*			  IS ASSERTED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T NEGATE.

!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 1.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.'MULTI SHIFT' AND
!*			  'FE SIGN' SHOULD ASSERT 'FS (1)'.  THIS WILL
!*			  HOLD 'ENABLE (1)' ASSERTED AND CAUSE 'CRA/M
!*			  CLK ENABLE' TO NEGATE WHILE 'DPE/M CLK ENABLE'
!*			  IS ASSERTED.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T STAY ASSERTED.

!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 0.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.

!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 0.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T NEGATE.

!]ERROR 1
!]FE_SIGN FE_EN SCAD_A_DEC SCADA_SN SCADA_SEL_SN NTWK

!]NO ERROR 1
!]FE_SIGN FE_EN NTWK

    END;

GLOBAL ROUTINE TST64: NOVALUE =

!++
! FUNCTIONAL DISCREPTION:
!
!	MSEC COUNTER OUTPUT PINS
!
!	(ORIGINALLY WRITTEN BY JEAN BASMAJI)
!
!--

    BEGIN

    LOCAL
	OK,
	RCVDATA;

    LABEL
	LOOP1,
	LOOP2;

    BIND
	TST_U_ADR = %O'2020',
	TST_U = PLIT
		(
%(2020)%    U_J(2020) U_ALU_AND U_LSRC_DQ U_DEST_Q_AD U_DBUS_DBM U_DBM_MSEC U_SKIP_ADEQ0 U,
%(2021)%    U_J(2021) U,
%(2022)%    U_J(2020) V_DP_N(7774) U_DEST_Q_AD U
		);

    LOAD_TST_U;
    RPT_ERR_FLAG = 0;
    OK = 1;

    ERRINFO[0] = UPLIT(%ASCIZ'HIGH');
    ERROR_LOOP(1)
    (
	SET_CRAM_ADR(TST_U_ADR + 2);
	CS();				! START THE CLOCK
	WAIT(1000);			! WAIT FOR AT LEAST 1 MILLISECOND
	CH();				! STOP THE CLOCK
	IF EX_NXT NEQ (TST_U_ADR + 1)	! DID WE SKIP
	THEN
	(
	    SET_CRAM_ADR(0);
	    ERRCAS(1,1,0,SERIAL(36),12,ERRINFO);	! NO 
	    OK = 0;
	);
	EXIT_LOOP(1,1);
	0
    );

    SET_CRAM_ADR(TST_U_ADR);
    MOD_FLD(5,%O'5662');		! MODIFY ALU TO 5
    ERRINFO[0] = UPLIT(%ASCIZ'LOW');
    ERROR_LOOP(2)
    (
	SET_CRAM_ADR(TST_U_ADR + 2);
	CS();				! START THE CLOCK
	WAIT(1000);			! WAIT AT LEAST 1 MILLISECOND
	CH();				! STOP THE CLOCK
	IF EX_NXT NEQ (TST_U_ADR + 1)	! DID WE SKIP?
	THEN
	(
	    SET_CRAM_ADR(0);		! SET FOR SERIAL
	    RCVDATA = SERIAL(36) XOR %O'7774';
	    ERRCAS(1,1,%O'7774',.RCVDATA,12,ERRINFO);	! NO 
	    OK = 0;
	);
	EXIT_LOOP(2,1);
	0
    );

    IFN .OK THEN NOERR(1);
    RPT_ERR_FLAG = 1;

!*MESSAGE 1
!*STIMULUS:
!*	CHECK OUTPUT PINS OF MILLISECOND COUNTER FOR STUCK \S0
!*RESPONSE:
!*	GET THE MILLISECOND COUNTER OUTPUT THROUGH DBM BITS 24:33

!]ERROR 1
!]MSEC DBM_MSEC NTWK

!]NO ERROR 1
!]MSEC DBM_MSEC NTWK

    END;

GLOBAL ROUTINE TST65: NOVALUE =

!++
! FUNCTIONAL DISCREPTION:
!
!	MILISECOND COUNTER TIMING
!
!	(ORIGINALLY WRITTEN BY JEAN BASMAJI)
!
!--

    BEGIN

    LOCAL
	RCVDATA;

    LABEL
	LOOP1;

    BIND
	TST_U_ADR = %O'2030',
	TST_U = PLIT
	    (
%(2030)%    U_J(2030) U_ALU_AND U_LSRC_DA U_DBUS_DBM U_DBM_MSEC U_SKIP_ADEQ0 U_LOADFE U_N(510000) U,
%(2031)%    U_J(2032) U_LOADFE U_N(510000) U,
%(2032)%    U_J(2032) U_ALU_AND U_LSRC_DA U_DBUS_DBM U_DBM_MSEC U_SKIP_ADEQ0 U_LOADFE U_N(410001) U,
%(2033)%    U_J(2033) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_DBM_SCAD U_N(110000) U,
%(2034)%    U_J(2030) V_DP_N(3774) U_DEST_AD U
		);

    LOAD_TST_U;
    ERROR_LOOP(1)
    (
	SET_CRAM_ADR(TST_U_ADR + 4);
	CS();				! START THE CLOCK
	WAIT(1000);			! WAIT AT LEAST 1 MILLISECOND
	CH();				! STOP THE CLOCK
	SET_CRAM_ADR(0);		! SET UP FOR SERIAL
	RCVDATA = SCAD_Q();		! GET THE SCAD
	IF ((.RCVDATA GEQ 660) AND (.RCVDATA LEQ 672))	! WITHIN 1%?
	THEN
	    NOERR(1)
	ELSE
	    ERR(1);
	EXIT_LOOP(1,1);
	0
    );

!*MESSAGE 1
!*STIMULUS:
!*	CHECK MILLISECOND COUNTER TIMING
!*RESPONSE:
!*	THE MILLISECOND COUNTER IS OFF BY MORE THAN 1%

!]ERROR 1
!]MSEC_FREQ DBM_MSEC NTWK

!]NO ERROR 1
!]MSEC_FREQ DBM_MSEC NTWK

    END;

END
ELUDOM
  