	SUBTTL	CHANNEL BUS INTERFACE TEST - PART 1

DEFTST	MCODE2
	TEST	154,TEST MICROBUS PARITY CHECKING NETWORK
;*WRITE TO INTERFACE WITH SPECIAL DATA PATTERNS DESIGNED TO TEST THE 74S280
;*PARITY CHECKING CHIP.
;*THIS WILL CHECK THAT THE MICROBUS PARITY NETWORK DETECTS CORRECT PARITY
;*ON WRITES (DETECTION OF BAD PARITY ON WRITES WAS TESTED PREVIOUSLY).

;*CLEAR "UB PE FLAG" IN REG 0.
;*WRITE THE DATA PATTERN TO REG 2.
;*CHECK THE "UB PE FLAG" IS NOT SET.

	LDMEM	1			;SET ADDITIONAL PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDBR	^D17			;SETUP LOOP COUNT MINUS 1
	MOVB	AC0
	LDMAR	PATS			;SET MAR TO FIRST DATA PATTERN
PAR2A:	LDBR	CLRFLG			;CLEAR REG 0 - UB PE FLAG
	MOVB	CSR0
	MOVMEM	CBILO			;WRITE PATTERN TO INTERFACE
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP12			;STORE DATA FOR PRINTOUT
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	DATI	CSR0,BR			;READ REG 0 INTO BR
	JMPB4	.+2			;JUMP IF "UB PE FLAG" SET
	JMP	.+2			;ELSE, RESULTS OKAY
	ERROR	PAR2A,UB PARITY ERROR DETECTED,,PNT
	DECR	AC0,I			;DEC LOOP CNT AND INC MAR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	PAR2A			;ELSE, CONTINUE

	GOSUB	INITL			;CLEAR REGS
	REPEAT	TST
	TEST	155,TEST REGISTER 1 (CSR1)
;*TEST WRITING AND READING REGISTER 1.
;*WRITING A ONE TO "ON LINE" MAY ENABLE THE BUS DRIVERS WHICH IS UNACCEPTABLE
;*WHEN A CONTROL UNIT.  THEREFORE, DEFER TESTING OF THAT BIT UNTIL LATER
;*WHEN DRIVERS CAN BE DISABLED BY SETTING "CU RESET".

;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT BITS 7-2,0 ARE ZERO.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZEROS TO REG 1
	MOVMEM	CSR1
	DATI	CSR1,AC0		;READ REG 1
	OSM	AC0			;COMPARE DATA WITH EXPECTED
	JMPZ	.+2			;JUMP IF DATA CORRECT
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO REG 1
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT BITS 7-2,0 ARE ONES.

REG1A:	LDMEM	375			;WRITE ONES INTO REG 1
	MOVMEM	CSR1
	DATI	CSR1,AC0		;READ REG 1
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF DATA CORRECT
	ERRORM	REG1A,<CAN NOT WRITE ALL ONES TO BITS 7-2,0 OF REG 1>
;*DO A MICROBUS INIT.
;*CHECK THAT BITS 7-2,0 ARE ZERO.

	GOSUB	INITL			;DO A MICROBUS INIT
	DATI	CSR1,AC0		;READ REG 1
	OSM	AC0			;COMPARE DATA WITH EXPECTED
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	REG1A,CAN NOT CLEAR ALL BIT(S) IN REG 1,
DIAG DID A MICROBUS INIT
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*CHECK THAT THE PATTERN GOT WRITTEN CORRECTLY.

	LDBR	^D13			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZA			;SET MAR TO FIRST PATTERN
FLT1:	MOVMEM	CSR1			;WRITE REG 1 WITH FLOATING PATTERN
	DATI	CSR1,AC0		;READ IT BACK
	OSM	AC0			;COMPARE WITH PATTERN WRITTEN
	JMPZ	.+2			;JUMP IF READ DATA IS CORRECT
	ERRORM	FLT1,FLOATING ONES/ZEROS FAILED,
DIAG WROTE REG 1
	DECR	AC1,I			;DEC LOOP CNT AND INC MAR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT1			;ELSE, CONTINUE

	REPEAT	TST
	TEST	156,NO INTERRUPT TEST
;*TEST THAT A MICROBUS INIT CLEARS ALL INTERRUPTS.

	GOSUB	INITL			;DO A MICROBUS INIT
	JMPI	ZRTN			;JUMP IF INTERRUPT IS PRESENT
	JMPZ	.+2			;JUMP IF INTERRUPT JUMP WAS TAKEN
	JMP	.+2			;ELSE, NO INTERRUPTS
	ERROR	TST,UNEXPECTED INTERRUPT OCCURRED,
DIAG DID A MICROBUS INIT AND SET CHAN MODE
	REPEAT	TST
	TEST	157,TEST REGISTER 2 (TOR0)
;*TEST WRITING AND READING REGISTER 2.

;*WRITE A ONE TO THE "TMR EN" BIT (THIS STARTS TIMER).
;*CHECK THAT "TMR EN" SETS.

	LDMAR	0			;CLEAR MAR
	LDBR	TMREN			;START TIMER AND ENABLE INTERRUPT
	MOVB	TOR0
	DATI	TOR0,BR			;READ REG 2
	SHR				;RIGHT ADJUST "TMR EN" BIT
	SHR
	JMPB0	.+2			;JUMP IF IT SET OKAY
	ERROR	TST,"TMR EN" BIT DID NOT SET
;*WAIT FOR 20 MS THEN CHECK THAT TIMER HASN'T TIMED OUT.

	GOSUB	WAIT			;GO WAIT FOR APPROX. 20 MS
	DATI	CSR0,AC0		;READ TIME OUT BIT
	SHL	AC0,BR			;LEFT ADJUST IT
	JMPB7	.+2			;JUMP IF IT SET TOO SOON
	JMP	.+2			;ELSE, CONTINUE
	ERROR	TST,"TIME OUT" FLAG SET TOO SOON,
DIAG STARTED TIMER THEN WAITED APPROX 20 MS
;*WAIT FOR ANOTHER 20 MS, THEN CHECK THAT THE "TIME OUT" BIT HAS SET.

	GOSUB	WAIT			;GO WAIT ANOTHER 20 MS
	DATI	CSR0,AC0		;READ TIME OUT BIT
	SHL	AC0,BR			;LEFT ADJUST IT
	JMPB7	.+2			;JUMP IF IT SET CORRECTLY
	ERROR	TST,"TIME OUT" FLAG DID NOT SET AFTER 40 MS
;*CHECK THAT "TIME OUT" CAUSES AN INTERRUPT.

	JMPI	ZRTN			;JUMP IF INTERRUPT OCCURRED
	JMPZ	.+2			;JUMP IF INTERRUPT JUMP WAS TAKEN
	ERROR	TST,"TIME OUT" FLAG DID NOT CAUSE AN INTERRUPT
;*CLEAR "TMR EN" (THIS STARTS TIMER AGAIN).
;*CHECK THAT IT CLEARS.

REG2A:	LDBR	0			;CLEAR "TMR EN"
	MOVB	TOR0
	DATI	TOR0,BR			;READ REG 2
	SHR				;RIGHT ADJUST "TMR EN" BIT
	SHR
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	REG2A,"TMR EN" BIT DID NOT CLEAR
;*WAIT 40 MS FOR TIMER TO TIME OUT.
;*CHECK THAT "TIME OUT" FLAG DOES NOT SET.

	GOSUB	WAIT			;WAIT 20 MS
	GOSUB	WAIT			;WAIT 20 MS
	DATI	CSR0,AC0		;READ REG 0
	SHL	AC0,BR			;LEFT ADJUST IT
	JMPB7	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	REG2A,"TIME OUT" FLAG SET WITH "TMR EN" CLEARED
;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ZEROS.

REG2B:	LDMEM	0			;WRITE ZEROS TO REG 2
	MOVMEM	TOR0
	DATI	TOR0,AC0		;READ REG 2
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERRORM	REG2B,CAN NOT WRITE ALL ZEROS TO REG 2
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT ALL BITS ARE ONES.

REG2C:	LDMEM	-1			;WRITE ONES TO REG 2
	MOVMEM	TOR0
	DATI	TOR0,AC0		;READ REG 2
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG2C,CAN NOT WRITE ALL ONES TO REG 2
;*DO A MICROBUS INIT.
;*CHECK THAT ALL BITS CLEARED.

	GOSUB	INITL			;DO A MICROBUS INIT
	DATI	TOR0,AC0		;READ REG 2
	OSM	AC0			;ALL BITS ZERO?
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERRORM	REG2C,CAN NOT CLEAR ALL BIT(S) IN REGISTER 2,
DIAG DID A MICROBUS INIT
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*CHECK THAT THE PATTERN GOT WRITTEN CORRECTLY.

	LDBR	^D15			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR TO FIRST PATTERN
FLT2:	MOVMEM	TOR0			;WRITE REG 2 WITH FLOATING PATTERN
	DATI	TOR0,AC0		;READ REG 2
	OSM	AC0			;CHECK FOR CORRECT DATA
	JMPZ	.+2			;JUMP IF DATA CORRECT
	ERRORM	FLT2,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 2
	DECR	AC1,I			;DEC. AC1 AND INC. PATTERN ADDR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT2			;ELSE, CONTINUE

	REPEAT	TST
	TEST	158,TEST REGISTER 3 (TOR1)
;*TEST WRITING AND READING REGISTER 3.
;*BITS 2-0 ARE READ ONLY BITS.

;*WRITE ZEROS TO THE REGISTER.
;*CHECK THAT BITS 7-3 ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	0			;WRITE ZEROS TO REG 3
	MOVMEM	TOR1
	DATI	TOR1,AC0		;READ REG 3
	LDBR	370			;SET MASK OF WRITEABLE BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF ZEROS
	ERRORM	TST,CAN NOT WRITE ZEROS TO BITS 7-3 OF REG 3
;*WRITE ONES TO THE REGISTER.
;*CHECK THAT BITS 7-3 ARE ONES.

REG3A:	LDMEM	370			;WRITE ONES TO BITS 2-7 OF REG 3
	MOVMEM	TOR1
	DATI	TOR1,AC0		;READ BACK REG 3
	LANDMR	AC0			;ISOLATE THE WRITEABLE BITS
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG3A,CAN NOT WRITE ONES TO BITS 7-3 OF REG 3
;*DO A MICROBUS INIT.
;*CHECK THAT BITS 7-3 ARE CLEARED.

	GOSUB	INITL			;DO A MICROBUS INIT
	DATI	TOR1,AC0		;READ REG 3
	LDBR	370			;SET MASK OF CLEARABLE BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;CHECK IF ALL BITS GOT ZEROED
	JMPZ	.+2			;JUMP IF THEY DID
	ERRORM	REG3A,CAN NOT CLEAR BITS 7-3 OF REG 3,
DIAG DID A MICROBUS INIT
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE REGISTER.
;*CHECK THAT THE PATTERN GOT WRITTEN CORRECTLY.

	LDBR	^D9			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZD			;SET MAR TO FIRST PATTERN
FLT3:	MOVMEM	TOR1			;WRITE REG 3 WITH FLOATING PATTERN
	DATI	TOR1,AC0		;READ IT BACK
	LDBR	370			;SET MASK OF WRITEABLE BITS
	LANDBR	AC0			;ISOLATE THEM IN AC0
	OSM	AC0			;COMPARE WITH PATTERN WRITTEN
	JMPZ	.+2			;JUMP IF READ DATA IS CORRECT
	ERRORM	FLT3,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 3
	DECR	AC1,I			;DEC LOOP CNT AND INC MAR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT3			;ELSE, CONTINUE

	REPEAT	TST
	TEST	159,TEST REGISTER 4 (TAGIN0)
;*WRITE REGISTER 2 AND READ REGISTER 4.
;*WITH LOOP ENABLE SET, BITS 7,6,4,3,1,0 OF REG 2 ARE READ BACK IN REG 4.
;*BIT 2 SHOULD ALWAYS BE ZERO.
;*WITH NO BUS EXTENSION, BIT 5 SHOULD ALWAYS BE ZERO.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*WRITE ZEROS TO REG 2.
;*CHECK THAT LOOPED BACK BITS IN REG 4 ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDBR	LOOPEN			;SET LOOP ENABLE FOR THIS TEST
	MOVB	CSR1
	LDMEM	0			;CLEAR REG 2
	MOVMEM	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	TAGIN0,AC0		;READ REG 4
	OSM	AC0			;COMPARE WITH EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT (LOOPED BACK BITS = ZEROS)
	ERRORM	TST,CAN NOT READ ALL LOOPED-BACK BITS ZEROS,
DIAG CLEARED REG 2 AND READ REG 4 WITH LOOP ENABLED
;*WRITE ONES TO REG 2.
;*CHECK THAT LOOPED BACK BITS IN REG 4 ARE ONES.

REG4A:	LDMEM	333			;SET LOAD DATA
	MOVMEM	TOR0
	NOP				;DELAY BEFORE DOING DATI
	DATI	TAGIN0,AC0		;READ REG 4
	OSM	AC0			;COMPARE WITH EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT (LOOPED-BACK BITS = ONES)
	ERRORM	REG4A,CAN NOT READ ALL LOOPED-BACK BITS ONES,
DIAG WROTE ONES TO REG 2 AND READ REG 4 WITH LOOP ENABLED
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO THE LOOPED BACK BITS
;*IN REG 2.
;*READ BACK REG 4 FOR THE PATTERN.

	LDBR	^D11			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZB			;SET MAR TO FLOATING PATTERNS
FLT4:	MOVMEM	TOR0			;LOAD REG 2 WITH PATTERN
	NOP				;DELAY BEFORE DOING DATI
	DATI	TAGIN0,AC0		;READ REG 4
	OSM	AC0			;COMPARE WITH EXPECTED DATA PATTERN
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT4,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 2 AND READ REG 4 WITH LOOP ENABLED
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT4			;ELSE, CONTINUE

	REPEAT	TST
	TEST	160,TEST REGISTER 5 (TAGIN1)
;*WRITE REGISTER 3 AND READ REGISTER 5.
;*WITH LOOP ENABLE SET, BITS 7-4 OF REG 3 ARE READ BACK IN REG 5.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*WRITE ZEROS TO REG 3.
;*CHECK THAT LOOPED BACK BITS IN REG 5 ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDBR	LOOPEN			;SET LOOP ENABLE FOR THIS TEST
	MOVB	CSR1
	LDMEM	0			;WRITE ZEROS TO REG 3
	MOVMEM	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TAGIN1,AC0		;READ REG 5
	LDBR	360			;MASK OUT SP ADR BITS
	LANDBR	AC0
	OSM	AC0			;COMPARE WITH EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT (LOOPED-BACK BITS = ZEROS)
	ERRORM	TST,CAN NOT READ ALL LOOPED-BACK BITS ZEROS,
DIAG CLEARED REG 3 AND READ REG 5 WITH LOOP ENABLED
;*WRITE ONES TO REG 3.
;*CHECK THAT LOOPED BACK BITS IN REG 5 ARE ONES.

REG5A:	LDMEM	360			;WRITE ONES TO LOOPED-BACK BITS IN REG 3
	MOVMEM	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TAGIN1,AC0		;READ REG 5
	LANDMR	AC0			;MASK OUT SP ADR BITS
	OSM	AC0			;COMPARE WITH EXPECTED DATA
	JMPZ	.+2			;JUMP IF CORRECT (LOOPED-BACK BITS = ONES)
	ERRORM	REG5A,CAN NOT READ ALL LOOPED-BACK BITS ONES,
DIAG WROTE ONES TO REG 3 AND READ REG 5 WITH LOOP ENABLED
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO LOOPED BACK BITS
;*IN REG 3.
;*READ BACK REG 5 FOR PATTERN.

	LDBR	^D7			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZC			;SET MAR TO FIRST PATTERN
FLT5:	MOVMEM	TOR1			;WRITE PATTERN TO REG 3
	NOP				;DELAY BEFORE DOING DATI
	DATI	TAGIN1,AC0		;READ REG 5
	LDBR	360			;MASK OUT SP ADR BITS
	LANDBR	AC0
	OSM	AC0			;COMPARE WITH PATTERN WRITTEN
	JMPZ	.+2			;JUMP IF READ DATA IS CORRECT
	ERRORM	FLT5,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 3 AND READ REG 5 WITH LOOP ENABLED
	DECR	AC1,I			;DEC AC1 AND INC MAR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT5			;ELSE, CONTINUE

	REPEAT	TST
	TEST	161,TEST REGISTER 5 (SPADR)
;*TEST WRITING AND READING BITS 3-0 OF REG 5 (SP ADR BITS).
;*LOOP ENABLE IS NOT SET FOR THIS TEST.
;*THE "CHAN MODE" BIT MUST BE SET TO ALLOW READING OF SP ADR BITS.

;*WRITE ZEROS TO BITS 3-0.
;*CHECK THAT BITS 3-0 ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDBR	CHANL			;SET "CHAN MODE"
	MOVB	CSR1
	LDMEM	0			;WRITE ZEROS INTO BITS 3-0 OF REG 5
	MOVMEM	SPADR
	DATI	SPADR,AC0		;READ BACK SP ADR BITS IN REG 5
	LDBR	17			;SETUP BIT MASK FOR SP ADR BITS
	LANDBR	AC0			;ISOLATE THE SP ADR BITS
	OSM	AC0			;CHECK IF ALL ZEROS
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO BITS 3-0 OF REG 5
;*WRITE ONES TO BITS 3-0 OF REG 5.
;*CHECK THAT BITS 3-0 OF REG 5 ARE ONES.

REG5AA:	LDMEM	17			;SETUP BIT MASK FOR SP ADR BITS
	MOVMEM	SPADR			;WRITE ONES INTO SP ADR BITS
	DATI	SPADR,AC0		;READ REG 5
	LANDMR	AC0			;ISOLATE SP ADR BITS
	OSM	AC0			;CHECK IF ALL ONES
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG5AA,CAN NOT WRITE ALL ONES TO BITS 3-0 OF REG 5
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO BITS 3-0 OF REG 5.
;*READ BACK BITS 3-0 OF REG 5 FOR THE PATTERN.

	LDBR	^D7			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZE			;SET MAR TO FIRST PATTERN
FLT5A:	MOVMEM	SPADR			;WRITE PATTERN TO BITS 3-0 OF REG 5
	DATI	SPADR,AC0		;READ REG 5
	LDBR	17			;SETUP BIT MASK FOR SP ADR BITS
	LANDBR	AC0			;ISOLATE SP ADR BITS
	OSM	AC0			;CHECK FOR CORRECT PATTERN
	JMPZ	.+2			;JUMP IF CORRECT PATTERN
	ERRORM	FLT5A,FLOATING ZEROS/ONES FAILED,
DIAG WROTE BITS 3-0 OF REG 5
	DECR	AC1,I			;DEC LOOP COUNT AND INC MAR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT5A			;ELSE,CONTINUE

	REPEAT	TST
	TEST	162,TEST REGISTER 11 (BORLO) AND REGISTER 7 (CBILO)
;*WRITE REGISTER 11 AND READ REGISTER 7 FOR THE COMPLEMENT OF REGISTER 0.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*WRITE ZEROS TO REG 11.
;*CHECK THAT REG 7 IS ALL ONES.

	LDMAR	0			;CLEAR MAR
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	0			;WRITE ZEROS TO REG 11
	MOVB	BORLO
	LDMEM	-1			;SETUP EXPECTED DATA
	DATI	CBILO,AC0		;READ REG 7
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERRORM	TST,CAN NOT WRITE ALL ZEROS TO REG 11,
DIAG WROTE ZEROS TO REG 11 AND READ REG 7 WITH LOOP ENABLED
;*WRITE ONES TO REG 11.
;*CHECK THAT REG 7 IS ALL ZEROS.

REG11A:	LDBR	-1			;WRITE ONES TO REG 11
	MOVB	BORLO
	LDMEM	0			;SETUP EXPECTED DATA
	DATI	CBILO,AC0		;READ REG 7
	OSM	AC0			;COMPARE DATA
	JMPZ	.+2			;JUMP IF ALL ONES
	ERRORM	REG11A,CAN NOT WRITE ALL ONES TO REG 11,
DIAG WROTE ONES TO REG 11 AND READ REG 7 WITH LOOP ENABLED
;*WRITE FLOATING ZEROS AND FLOATING ONES PATTERNS TO REG 11.
;*READ BACK REG 7 FOR THE COMPLEMENT OF THE PATTERN.

	LDBR	^D15			;SETUP LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	FLTZ			;SET MAR TO FIRST PATTERN
FLT11:	LDBR	0			;SETUP COMPLEMENT OF PATTERN
	MOVB	AC2
	LORCM	AC2,BR			;IN THE BR AND
	MOVB	BORLO			;WRITE IT TO REG 11
	NOP				;DELAY BEFORE DOING DATI
	DATI	CBILO,AC0		;READ REG 7
	OSM	AC0			;CHECK FOR CORRECT DATA
	JMPZ	.+2			;JUMP IF DATA CORRECT
	ERRORM	FLT11,FLOATING ZEROS/ONES FAILED,
DIAG WROTE REG 11 AND READ REG 7 WITH LOOP ENABLED
	DECR	AC1,I			;DEC. LOOP CNT AND INC. MAR.
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT11			;ELSE, CONTINUE

;*CLEAR LOOP ENABLE.
;*CHECK THAT REG 11 DOES NOT LOOP BACK TO REG 7.

REG11B:	LDBR	0			;CLEAR LOOP ENABLE
	MOVB	CSR1
	LDBR	252			;WRITE REG 11 WITH ALTERNATE 1'S & 0'S
	MOVB	BORLO
	LDMEM	125			;SET MEMORY TO COMPLEMENT OF THAT
	DATI	CBILO,AC0		;READ REG 7
	OSM	AC0			;CHECK FOR LOOPED BACK DATA
	JMPZ	.+2			;JUMP IF DATA WAS LOOPED BACK
	JMP	.+2			;ELSE, RESULTS OKAY
	ERRORM	REG11B,REG 11 DATA LOOPED BACK TO REG 7 WITHOUT LOOP ENABLED
	REPEAT	TST
	TEST	163,TEST REGISTER 6 (DRLO)
;*TEST THAT ONES, ZEROS, FLOATING ZEROS AND FLOATING ONES PATTERNS CAN BE CLOCKED
;*INTO THE DRLO REGISTER (7-0).
;*LOOP ENABLE IS SET FOR THIS OPERATION.

;*CLEAR "DATA TO DEVICE".
;*WRITE COMPLEMENT OF PATTERN TO REG 11.
;*GENERATE A "CLOCK DR" PULSE.
;*READ REG 6 FOR PATTERN.

	GOSUB	DEVRD			;SETUP FOR A DEVICE READ
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	^D17			;SET LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	PATS			;SET MAR TO FIRST PATTERN
FLT6:	LDBR	0			;SETUP COMPLEMENT OF PATTERN IN
	MOVB	AC2
	LORCM	AC2,BR			;BR THEN
	MOVB	BORLO			;WRITE IT TO REG 11
	MOVB	CLKDRL			;CLOCK THE DR REG
	NOP				;DELAY BEFORE DOING DATI
	DATI	DRLO,AC0		;READ DATA FROM DR REG
	OSM	AC0			;COMPARE WITH EXPECTED PATTERN
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	FLT6,DATA PATTERN ERROR,
DIAG CLOCKED DATA FROM BORLO INTO THE DR REG USING LOOP BACK
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF ALL DONE
	JMP	FLT6			;ELSE, CONTINUE

	REPEAT TST
	JUMP	NXTBNK			;JUMP TO NEXT BANK OF CRAM
	.LOC	2000
NXTBNK:
	TEST	164,TEST LOADING OF DRLO FROM SLVE DATA LINES
;*TEST THAT CLOCKING DRLO WITH "DATA TO DEV" SET LOADS DRLO WITH
;*SLVE DATA LINES DATA.  THE ACTUAL SLVE DATA LINES DATA CANNOT BE READ
;*DIRECTLY.  HOWEVER, IF THE DATA PATH BOARDS ARE FUNCTIONING CORRECTLY,
;*A MICROBUS INIT SHOULD SET THEM TO ALL ONES.

;*CLEAR "DATA TO DEV".
;*DO A MICROBUS INIT.
;*CLOCK ALL ZEROS INTO DRLO FROM BORLO.
;*SET "DATA TO DEV".
;*CLOCK DRLO.
;*CHECK THAT DRLO CONTAINS ALL ONES.

	JMPSUB	DEVRD			;SETUP DEVICE READ
	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDMEM	-1			;LOAD BORLO WITH ALL ONES
	MOVMEM	BORLO
	MOVB	CLKDRL			;CLOCK ALL ZEROS INTO DRLO
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	CLKDRL			;CLOCK DRLO
	NOP				;DELAY BEFORE DOING DATI
	DATI	DRLO,AC0		;READ DRLO
	JMPZ	.+2			;JUMP IF DRLO IS ALL ONES
	ERRORM	TST,DATA PATH DATA DID NOT LOAD INTO DRLO REG,
<DIAG DID A MICROBUS INIT, LOADED DRLO WITH ALL ZEROS, THEN
SET "DATA TO DEVICE" AND CLOCKED DRLO.>
	REPEAT	TST
	TEST	165,TEST "ON LINE"
;*TEST THAT THE "ON LINE" BIT CAN BE SET AND CLEARED.
;*TO INHIBIT TURNING ON THE CHANNEL BUS DRIVERS SET "CU RESET".

;*WRITE ONES TO REG 16.
;*WRITE A ONE TO "ON LINE".
;*CHECK THAT IT SET.

	LDBR	7			;WRITE ONES TO REG 16 TO SET "CU RESET"
	MOVB	CUSTAT
	LDBR	CURSEN			;SET "CU RESET EN"
	MOVB	TOR1
	LDBR	ONLINE			;SET "ON LINE"
	MOVB	CSR1
	DATI	CSR1,BR			;READ "ON LINE"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,CANNOT WRITE A ONE TO "ON LINE"
;*CLEAR "ON LINE".
;*CHECK THAT IT GOT CLEARED.

	LDBR	0			;CLEAR "ONLINE"
	MOVB	CSR1
	DATI	CSR1,BR			;READ "ON LINE"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,CANNOT WRITE A ZERO TO "ON LINE"
	GOSUB	WAIT			;WAIT BEFORE SETTING LOOPEN OR CHAN MODE
	LDBR	0			;CLEAR "CU RESET"
	MOVB	CUSTAT
	MOVB	TOR1			;CLEAR "CU RESET EN"
	REPEAT	TST
	TEST	166,TEST GENERATION OF "SLVE END XFER"
;*TEST THAT "SLVE END XFER" SETS WHEN AND ONLY WHEN
;*"STA IN" AND "DX HIGH SPEED" ARE ASSERTED AND "DATA TO DEV" IS CLEARED.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "DATA TO DEV".
;*SET "DIAG HIGH SPEED" AND "STA IN".
;*CHECK THAT "SLVE END XFER" IS ASSERTED.

	JMPSUB	DEVRD			;SETUP DEVICE READ.
	LDBR	DIHISP+LOOPEN		;SET "DIAG HIGH SPEED" AND LOOP ENABLE.
	MOVB	CSR1
	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
	JMPSUB	RDSEX			;READ "SLVE END XFER" RIGHT ADJUSTED
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"SLVE END XFER" DIDN'T SET,
DIAG SET "STA IN" AND "DX HIGH SPEED" AND CLEARED "DATA TO DEVICE"
;*CLEAR "STA IN".
;*CHECK THAT "SLVE END XFER" IS CLEARED.

SEX1:	LDBR	0			;CLEAR "STA IN"
	MOVB	TOR0
	JMPSUB	RDSEX			;READ "SLVE END XFER" RIGHT ADJUSTED
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SEX1,"SLVE END XFER" DIDN'T CLEAR,
DIAG SET "DX HIGH SPEED" AND CLEARED "STA IN" AND "DATA TO DEVICE"
;*SET "STA IN" AND CLEAR "HIGH SPEED".
;*CHECK THAT "SLVE END XFER" IS CLEARED.

SEX2:	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
	LDBR	LOOPEN			;CLEAR "DX HIGH SPEED"
	MOVB	CSR1
	JMPSUB	RDSEX			;READ "SLVE END XFER" RIGHT ADJUSTED
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SEX2,"SLVE END XFER" DIDN'T CLEAR,
DIAG SET "STA IN" AND CLEARED "DX HIGH SPEED" AND "DATA TO DEVICE"
;*SET "HIGH SPEED" AND "DATA TO DEV".
;*CHECK THAT "SLVE END XFER" IS CLEARED.

SEX3:	LDBR	DIHISP+LOOPEN		;SET "DX HIGH SPEED"
	MOVB	CSR1
	JMPSUB	DEVWR			;SET "DATA TO DEVICE"
	JMPSUB	RDSEX			;READ "SLVE END XFER" RIGHT ADJUSTED	
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERROR	SEX3,"SLVE END XFER" DIDN'T CLEAR,
DIAG SET "STA IN" AND "DX HIGH SPEED" AND "DATA TO DEVICE"
	REPEAT	TST

	TEST	167,TEST "DIS IN" INTERRUPT
;*TEST THAT AN INTERRUPT OCCURS WHEN AND ONLY WHEN "DIS IN" IS
;*RECEIVED WITH CHANNEL MODE SET.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*SET CHANNEL MODE AND "DIS IN".
;*CHECK FOR AN INTERRUPT.

	LDBR	CLRFLG			;CLEAR REG 0 INTERRUPT FLAGS
	MOVB	CSR0
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	DISINL			;SET "DIS IN"
	MOVB	TOR1
	JMPI	ZRTNH			;JMP IF INTERRUPT OCCURRED
	JMPZ	.+2			;JMP IF TOOK INTERRUPT JMP
	ERROR	TST,NO INTERRUPT OCCURRED WHEN "DIS IN" SET IN CHANNEL MODE
;*SET "OPL IN" AND "REQ IN" TO INSURE "CU RESET" INTERRUPT IS CLEARED.
;*CLEAR CHANNEL MODE.
;*CHECK THAT INTERRUPT GOES AWAY.

	LDBR	OPLINL			;SET "OPL IN"
	MOVB	TOR0
	LDBR	REQINL+DISINL		;SET "REQ IN"
	MOVB	TOR1
	LDBR	LOOPEN			;CLEAR CHANNEL MODE
	MOVB	CSR1
	JMPI	ZRTNH			;JMP IF INTERRUPT STILL THERE
	JMPZ	.+2			;JMP IF TOOK INTERRUPT JMP
	JMP	.+2
	ERROR	TST,INTERRUPT OCCURRED WHEN "DIS IN" SET WITH CHANNEL 
MODE CLEARED
;*SET CHANNEL MODE AND CLEAR "DIS IN"
;*CHECK THAT NO INTERRUPT OCCURS

DIS1:	LDBR	0			;CLEAR "DIS IN"
	MOVB	TOR1
	LDBR	LOOPEN+CHANL		;SET CHANNEL MODE
	MOVB	CSR1
	JMPI	ZRTNH			;JMP IF INTERRUPT OCCURRED
	JMPZ	.+2			;JMP IF TOOK INTERRUPT JMP
	JMP	.+2
	ERROR	DIS1,INTERRUPT OCCURRED WITH CHANNEL MODE SET AND 
"DIS IN" CLEARED
	REPEAT	TST

	TEST	168,TEST CHANNEL MODE HIGH SPEED WRITE XFER
;*SIMULATE A HIGH SPEED, DEVICE WRITE TRANSFER IN THE CHANNEL MODE.
;*VERIFY THAT THE CORRECT SIGNALS ARE GENERATED AT THE APPROPRIATE TIMES.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*SET "DATA TO DEVICE", "CHANNEL MODE", THEN "HIGH SPEED".
;*CHECK THAT "CU INIT" DID NOT GET SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	DIHISP+LOOPEN+CHANL	;SET "HIGH SPEED"
	MOVB	CSR1
	LDBR	0			;LOAD ZEROS INTO BORLO
	MOVB	BORLO
	MOVB	CLKDRL			;CLOCK ONES INTO DRLO
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	RDCUIN			;GO READ "CU INIT"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE OKAY
	ERROR	TST,"CU INIT" SET WHEN IT SHOULDN'T HAVE,
DIAG SET CHANNEL MODE THEN SET "HIGH SPEED"
;*SET "DAT IN".
;*CHECK THAT "ST DATA REQ", "DATA REQ DLY", AND "SLVE REQ" ARE SET.
;*CHECK THAT "DIS SLVE REQ", "DR READY", AND "TO DAT OUT" ARE NOT SET.

	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	JMPSUB	RDSDRQ			;READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF IT SET.
	ERROR	TST,"ST DATA REQ" DIDN'T SET WHEN "DAT IN" SET
	JMPSUB	RDRDLY			;READ "NOT DATA REQ DLY"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"DATA REQ DLY" DIDN'T SET WHEN "DAT IN" SET
	JMPSUB	RDDSRQ			;READ "NOT DIS SLVE REQ"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"DIS SLVE REQ" SET WHEN "DAT IN" SET IN CHANNEL MODE
	JMPSUB	RDSLRQ			;READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"SLVE REQ" DIDN'T SET WHEN "DAT IN" SET,
<"CHANNEL MODE", "HIGH SPEED" AND "DATA TO DEVICE" ARE SET>
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DR READY" SET BEFORE IT SHOULD HAVE,
DIAG SET "CHANNEL MODE" AND "HIGH SPEED" THEN SET "DAT IN"
	DATI	TOR1,BR			;READ REG 4
	SHR				;RIGHT ADJUST "TO DAT OUT"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"TO DAT OUT" SET BEFORE IT SHOULD HAVE,
DIAG SET "CHANNEL MODE" AND "HIGH SPEED" THEN SET "DAT IN"
;*SET "SLVE ACK".

;*CHECK THAT "SLVE REQ" AND "DIAG SLVE ACK" GET CLEARED.
;*CHECK THAT "DR READY" AND "TO DAT OUT" GET SET.
;*CHECK THAT THE DRLO REG GETS CLOCKED.
;*CHECK THAT "2ND BYTE" DOESN'T GET SET.

	LDBR	DATINL+DISACK		;SET "DIAG SLVE ACK"
	MOVB	TOR1
	JMPSUB	RDSLRQ			;READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"SLVE REQ" DIDN'T CLEAR,
DIAG SET "SLVE REQ" THEN SET "DIAG SLVE ACK"
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"DR READY" DID NOT SET,
DIAG SET "SLVE REQ" THEN "DIAG SLVE ACK" WITH "DATA TO DEV" SET
	DATI	TOR1,BR			;READ REG 3
	SHR				;RIGHT ADJ "TO DAT OUT" BIT
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"TO DAT OUT" DID NOT SET,
DIAG SET "DAT IN" THEN SET "DR READY"
	LDMEM	0			;SET EXPECTED DATA
	DATI	DRLO,AC0		;READ DR
	JMPZ	.+2			;JUMP IF ONES STILL THERE
	JMP	.+2			;ELSE, IT GOT CLOCKED
	ERRORM	TST,"DRLO" REG DID NOT GET CLOCKED,
DIAG SET AND CLEARED "SLVE REQ" WITH "DATA TO DEVICE" SET
	JMPSUB	RD2BYT			;READ "2ND BYTE"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"2ND BYTE" SET WITH NO BUS EXTENSION BOARD,
DIAG SET "SLVE ACK DL75"
	DATI	TOR1,AC0		;READ REG 4
	SHL	AC0,BR			;MOVE "DIAG SLVE ACK" TO BIT 4
	JMPB4	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DIAG SLVE ACK" DIDN'T CLEAR,
DIAG SET "SLVE REQ" THEN SET "DIAG SLVE ACK"
;*CLEAR "DAT IN".
;*CHECK THAT "ST DATA REQ", "DATA REQ DLY", "DR READY", AND "TO DAT OUT" GET CLEARED.
;*CHECK THAT "END XFER" AND "CU RUN" DON'T SET.

	LDBR	0			;CLEAR "DAT IN"
	MOVB	TOR1
	JMPSUB	RDSDRQ			;READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"ST DATA REQ" DIDN'T CLEAR,
DIAG SET AND CLEARED "DAT IN"
	JMPSUB	RDRDLY			;READ "NOT DATA REQ DLY"
	JMPB0	.+2			;JUMP IF DIDN'T CLEAR
	ERROR	TST,"DATA REQ DLY" DIDN'T CLEAR,
DIAG SET "DATA REQ DLY" THEN CLEARED "ST DATA REQ"
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DR READY" DIDN'T CLEAR,
DIAG SET "DR READY" THEN CLEARED "DATA REQ DLY"
	DATI	TOR1,BR			;READ REG 4
	SHR				;RIGHT ADJUST "TO DAT OUT"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2
	ERROR	TST,"TO DAT OUT" DIDN'T CLEAR,
DIAG SET "TO DAT OUT" THEN CLEARED "DAT IN"
	DATI	CSR0,BR			;READ "END XFER"
	JMPB7	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"END XFER" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "DATA REQ DLY" WITH "SLVE END XFER" CLEARED
	LDBR	LOOPEN+DIHISP		;CLEAR CHANNEL MODE TO READ "CU RUN"
	MOVB	CSR1
	DATI	SPADR,AC0		;READ CU MODE BITS
	SHL	AC0,BR			;MOVE "CU RUN" TO BIT 4
	JMPB4	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"CU RUN" SET WHEN IT SHOULDN'T HAVE,
DIAG SET AND CLEAR "DATA REQ DLY" WITH "CU INIT" CLEARED
	REPEAT	TST

	TEST	169,TEST CHANNEL MODE HIGH SPEED READ XFER
;*SIMULATE A HIGH SPEED, DEVICE READ TRANSFER IN THE CHANNEL MODE.
;*VERIFY THAT THE CORRECT SIGNALS ARE GENERATED AT THE APPROPRIATE TIMES.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "DATA TO DEVICE".
;*SET "CHANNEL MODE" THEN "HIGH SPEED".
;*SET "SRV IN".
;*CHECK THAT "ST DATA REQ" AND "SLVE REQ" ARE SET.
;*CHECK THAT "DR READY" AND "TO SRV OUT" ARE NOT SET AND THAT
;*DRLO REG IS NOT CLOCKED.

	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	DEVRD			;CLEAR "DATA TO DEVICE"
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	DIHISP+LOOPEN+CHANL	;SET "HIGH SPEED"
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	JMPSUB	LOADDR			;GO LOAD DRLO WITH ZEROS
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	JMPSUB	RDSDRQ			;READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"ST DATA REQ" DIDN'T SET WHEN "SRV IN" SET
	JMPSUB	RDSLRQ			;READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF IT SET
	ERROR	TST,"SLVE REQ" DIDN'T SET WHEN "SRV IN" SET,
"CHANNEL MODE" AND "HIGH SPEED" ARE SET AND "DATA TO DEVICE" IS CLEARED
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DR READY" SET BEFORE IT SHOULD HAVE,
DIAG SET "CHANNEL MODE" AND "HIGH SPEED" THEN SET "SRV IN"
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"TO SRV OUT" SET WITH "DR READY" CLEARED,
DIAG SET "SRV IN"
	LDMEM	-1			;SET EXPECTED DATA
	DATI	DRLO,AC0		;READ DR REG
	JMPZ	.+2			;JUMP IF DRLO CLOCKED
	ERRORM	TST,"DRLO" REG DIDN'T GET CLOCKED,
DIAG SET "SRV IN" WITH "DATA TO DEV" CLEARED
;*SET "DIAG SLVE ACK".
;*CHECK THAT "DR READY" AND "TO SRV OUT" ARE SET.

	LDBR	DISACK+SRVINL		;SET "DIAG SLVE ACK"
	MOVB	TOR1
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"DR READY" DIDN'T SET,
<DIAG SET "SLVE REQ" THEN "DIAG SLVE ACK" WITH
"DATA TO DEV" CLEARED>
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"TO SRV OUT" DIDN'T SET,
DIAG SET "SRV IN" THEN SET "DR READY"
;*CLEAR "SRV IN".
;*CHECK THAT "ST DATA REQ" AND "TO SRV OUT" CLEAR.

	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	JMPSUB	RDSDRQ			;READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF IT DIDN'T CLEAR
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"ST DATA REQ" DIDN'T CLEAR,
DIAG SET AND CLEARED "SRV IN"
	DATI	TOR1,BR
	JMPB0	.+2
	JMP	.+2
	ERROR	TST,"TO SRV OUT" DIDN'T CLEAR,
DIAG SET "TO SRV OUT" THEN CLEARED "SRV IN"
	REPEAT	TST
	TEST	170,TEST CHANNEL MODE HIGH SPEED XFER TERMINATION
;*SIMULATE THE TERMINATION OF A HIGH SPEED, DEVICE READ XFER IN CHANNEL MODE.
;*VERIFY THAT THE CORRECT SIGNALS ARE GENERATED AT THE APPROPRIATE TIMES.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*CLEAR "DATA TO DEVICE", SET "CHANNEL MODE" THEN "HIGH SPEED".
;*SET "DAT IN".
;*SET "STA IN" TO SET "SLVE END XFER".
;*SET "DIAG SLVE ACK".
;*CLR "DAT IN" TO CLEAR "DATA REQ DLY".
;*CHECK THAT "END XFER" IS SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	DEVRD			;CLEAR "DATA TO DEVICE"
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN+DIHISP+CHANL	;SET "HIGH SPEED"
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	LDBR	STAINL			;SET "STA IN" TO SET "SLVE END XFER"
	MOVB	TOR0
	LDBR	0			;CLEAR "DAT IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "END XFER"
	JMPB7	.+2			;JUMP IF IT SET, SHOULD HAVE
	ERROR	TST,"END XFER" DIDN'T SET,
DIAG CLEARED "DATA REQ DLY" WITH "SLVE END XFER" SET
;*SET "DAT IN".
;*CHECK THAT "SLVE REQ" DOES NOT SET AND "DR READY" DOES SET.

	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	JMPSUB	RDSLRQ			;READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"SLVE REQ" SET WITH "SLVE END XFER" SET
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"DR READY" DIDN'T SET,
DIAG SET "DAT IN" WITH "END XFER" SET
;*CLEAR "DX HIGH SPEED"
;*CHECK THAT "END XFER" IS CLEARED.

	LDBR	LOOPEN+CHANL		;CLEAR "HIGH SPEED"
	MOVB	CSR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "END XFER"
	JMPB7	.+2			;JUMP IF STILL SET
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"END XFER" DIDN'T CLEAR WHEN "HIGH SPEED" CLEARED
;*TEST THAT "END XFER" TOGGLES.
;*CLEAR "DATA TO DEVICE", SET "CHANNEL MODE" THEN "HIGH SPEED".
;*SET "DAT IN".
;*SET "STA IN" TO SET "SLVE END XFER".
;*SET "DIAG SLVE ACK".
;*CLR "DAT IN" TO CLEAR "DATA REQ DLY" AND SET "END XFER".
;*SET AND CLEAR "DAT IN" TO CLOCK "END XFER" AGAIN.
;*CHECK THAT "END XFER" IS CLEARED.

EXFER1:	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	DEVRD			;CLEAR "DATA TO DEVICE"
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	LOOPEN+DIHISP+CHANL	;SET "HIGH SPEED"
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	LDBR	STAINL			;SET "STA IN" TO SET "SLVE END XFER"
	MOVB	TOR0
	LDBR	0			;CLEAR "DAT IN"
	MOVB	TOR1
	LDBR	DATINL			;SET "DAT IN"
	MOVB	TOR1
	LDBR	0			;CLEAR "DAT IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,BR			;READ "END XFER"
	JMPB7	.+2			;JUMP IF STILL SET
	JMP	.+2			;ELSE, OKAY
	ERROR	EXFER1,"END XFER" DIDN'T CLEAR,
DIAG SET "END XFER" THEN TOGGLED "DATA REQ DLY"
	REPEAT	TST

	TEST	171,TEST OVERLAPPING "SRV IN" AND "DAT IN"
;*SIMULATE THE RECEPTION OF "DAT IN" WITH "SRV IN" ALREADY SET AND VICE-VERSA.
;*CHECK THAT THESE CONDITIONS ARE PROCESSED CORRECTLY, I.E., THE SECOND SIGNAL RECEIVED
;*IS NOT PROCESSED UNTIL THE FIRST ONE CLEARS.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*SET "CHANNEL MODE" AND "HIGH SPEED".
;*SET "SRV IN".
;*SET "DIAG SLVE ACK".
;*SET "DAT IN".
;*CHECK THAT "TO DAT OUT" IS NOT SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE.
	MOVB	CSR1
	LDBR	LOOPEN+CHANL+DIHISP	;SET "HIGH SPEED"
	MOVB	CSR1
	JMPSUB	DEVWR			;SET DATA TO DEVICE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	DEVRD			;CLEAR DATA TO DEVICE
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	LDBR	DISACK+SRVINL		;SET "DIAG SLVE ACK"
	MOVB	TOR1
	LDBR	DATINL+SRVINL		;SET "DAT IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO DAT OUT"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF SET TOO SOON
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"TO DAT OUT" SET TOO SOON,
<DIAG SET "SRV IN", "DIAG SLVE ACK", THEN "DAT IN">
;*CLEAR "SRV IN".
;*CHECK THAT "ST DATA REQ" IS SET.

	LDBR	DATINL			;CLEAR "SRV IN"
	MOVB	TOR1
	JMPSUB	RDSDRQ			;READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"ST DATA REQ" DIDN'T SET,
DIAG SET "TO SRV OUT" THEN SET "DAT IN" AND CLEARED "SRV IN"
;*SET "DIAG SLVE ACK".
;*CHECK THAT "TO DAT OUT" IS SET.

	LDBR	DATINL+DISACK		;SET "DIAG SLVE ACK"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO DAT OUT"
	SHR				;RIGHT ADJUST IT
	JMPB0	.+2			;JUMP IF SET
	ERROR	TST,"TO DAT OUT" DIDN'T SET,
<DIAG SET "TO SRV OUT", SET "DAT IN", CLEARED "SRV IN" THEN
SET "DIAG SLVE ACK">
;*SET "SRV IN".
;*CHECK THAT "TO SRV OUT" DOES NOT SET.

	LDBR	SRVINL+DATINL		;SET "SRV IN"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"TO SRV OUT" SET TOO SOON,
DIAG SET "TO DAT OUT" THEN SET "SRV IN"
;*CLEAR "DAT IN".
;*CHECK THAT "ST DATA REQ" IS SET.

	LDBR	SRVINL			;CLEAR "DAT IN"
	MOVB	TOR1
	JMPSUB	RDSDRQ			;READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF SET OKAY
	ERROR	TST,"ST DATA REQ" DID NOT SET,
DIAG SET "TO DAT OUT" THEN SET "SRV IN" AND CLEARED "DAT IN"
;*SET "DIAG SLVE ACK".
;*CHECK THAT "TO SRV OUT" IS SET.

	LDBR	DISACK+SRVINL		;SET "DIAG SLVE ACK"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,BR			;READ "TO SRV OUT"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"TO SRV OUT" DIDN'T SET,
<DIAG SET "TO DAT OUT", SET "SRV IN", CLEARED "DAT IN" THEN
SET "DIAG SLVE ACK">
;*CLEAR "SRV IN".
;*CHECK THAT "ST DATA REQ" IS CLEARED.

	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	JMPSUB	RDSDRQ			;READ "ST DATA REQ"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"ST DATA REQ" DIDN'T CLEAR,
<DIAG SET AND CLEARED "TO DAT OUT" THEN SET "TO SRV OUT" AND
CLEARED "SRV IN">
	REPEAT	TST
	TEST	172,TEST CHANNEL MODE XFER WITH SCRATCH PAD ENABLED
;*SIMULATE A CHANNEL MODE WRITE XFER WITH THE SCRATCH PAD ENABLED.
;*CHECK THAT THE CORRECT SIGNALS ARE GENERATED AT THE APPROPRIATE TIMES.
;*LOOP ENABLE IS SET FOR THIS TEST.

;*SET "DATA TO DEVICE", "CHANNEL MODE" AND "SP EN".
;*CHECK THAT "DR READY" IS NOT SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
	JMPSUB	DEVWR			;SET "DATA TO DEVICE"
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	LOOPEN+SPEN+CHANL	;SET LOOP AND SP ENABLE AND
	MOVB	CSR1			;CHANNEL MODE
	JMPSUB	DPINIT			;DO A DATA PATH INIT
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF IT SET TOO SOON
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"DR READY" SET WHEN DIAG SET "SP EN"
;*SET "SRV IN".
;*CHECK THAT "DATA REQ DLY" AND "DR READY" GET SET AND
;*THAT "SLVE REQ" DOES NOT SET.

	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	JMPSUB	RDRDLY			;READ "NOT DATA REQ DLY"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"DATA REQ DLY" DIDN'T SET,
DIAG SET "SRV IN" WITH "CHANNEL MODE" AND "SP EN" SET
	JMPSUB	RDRRDY			;READ "DR READY"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"DR READY" DIDN'T SET,
DIAG SET "SRV IN" WITH "CHANNEL MODE" AND "SP EN" SET
	JMPSUB	RDSLRQ			;READ "SLVE REQ"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"SLVE REQ" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "SRV IN" WITH "HIGH SPEED" CLEARED
	REPEAT	TST
	TEST	173,TEST INHIBITING "DATA REQ"
;*TEST THAT "DATA REQ" DOES NOT GET GENERATED IF
;*	(1) "HIGH SPEED" AND "SP EN" ARE BOTH CLEARED, OR
;*	(2) "CHANNEL MODE" IS CLEARED AND "SLVE END XFER" IS SET
;*LOOP ENABLE IS SET FOR THIS TEST.

;*SET CHANNEL MODE.
;*SET "SRV IN".
;*CHECK THAT "DATA REQ DLY" DOES NOT SET.

	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CHANNEL MODE
	MOVB	CSR1
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	JMPSUB	RDRDLY			;READ "NOT DATA REQ DLY"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"DATA REQ DLY" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "SRV IN" WITH "HIGH SPEED" AND "SP EN" CLEARED
;*CLEAR "SRV IN".
;*SET "SLVE END XFER" BY SETTING "HIGH SPEED" AND "STA IN", AND CLEARING
;*"DATA TO DEVICE".
;*CLEAR "CHANNEL MODE".
;*SET "SRV IN".
;*CHECK THAT "DATA REQ DLY" DOES NOT SET.

DREQ1:	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	LDBR	LOOPEN+DIHISP+CHANL	;SET "HIGH SPEED"
	MOVB	CSR1
	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
	JMPSUB	DEVRD			;CLEAR "DATA TO DEVICE"
	LDBR	LOOPEN+DIHISP		;CLEAR "CHANNEL MODE"
	MOVB	CSR1
	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	JMPSUB	RDRDLY			;READ "NOT DATA REQ DLY"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	DREQ1,"DATA REQ DLY" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "SRV IN" WITH "SLVE END XFER" SET AND "CHANNEL MODE" CLEARED
	REPEAT	TST

	TEST	174,TEST "SLVE ACK" PROPAGATION
;*SET "DIAG SLVE ACK" WITH "SLVE REQ" CLEARED.
;*SLVE ACK SHOULD NOT PROPAGATE AND "DIAG SLVE ACK" SHOULD REMAIN SET

	JMPSUB	INITL			;CLEAR "SLVE REQ"
	LDBR	DISACK			;SET "DIAG SLVE ACK"
	MOVB	TOR1
	NOP				;DELAY BEFORE DOING DATI
	DATI	TOR1,AC0		;READ BACK "DIAG SLVE ACK"
	SHL	AC0,BR			;MOVE IT TO BIT 4
	JMPB4	.+2			;JUMP IF STILL SET, OKAY
	ERROR	TST,"DIAG SLVE ACK" GOT CLEARED,
DIAG CLEARED "SLVE REQ" THEN SET "DIAG SLVE ACK"
	REPEAT	TST
	JMP	END			;JUMP AROUND SUBROUTINES

ZRTNH:	RETURN	-1

INITL:	LDBR	INIT+33			;SET INIT
	MOVB	IOSEL
	LDBR	33			;CLR INIT & SELECT CB
	MOVB	IOSEL
	LDMAR	0			;PUT MEMORY ADDRESS TO 0
	LDMEM	0			;CLR MEMORY LOC. 0
	RETURN

;"WAIT" IS USED TO WAIT APPROX 20 MS.  IT CONSISTS OF AN INNER WAIT LOOP
;OF APPROX 960 NSEC AND AN OUTER LOOP OF APPROX 200 USEC.
WAIT:	LDBR	^D100			;SET OUTER LOOP WAIT COUNT
	MOVB	AC0
WAITO:	LDBR	^D207			;SET INNER LOOP WAIT COUNT
	MOVB	AC1
WAITI:	DECR	AC1			;DEC INNER LOOP COUNT
	JMPZ	.+2			;JUMP IF INNER LOOP TIMED OUT
	JMP	WAITI			;ELSE, CONTINUE
	DECR	AC0			;DEC OUTER LOOP COUNT
	JMPZ	.+2			;JUMP IF OUTER LOOP TIMED OUT
	JMP	WAITO			;ELSE CONTINUE
	RETURN

LOADDR:	LDBR	-1			;LOAD ONES INTO BORLO
	MOVB	BORLO
	MOVB	CLKDRL			;LOAD ZEROS INTO DRLO
	LDBR	0			;LOAD ZEROS INTO BORLO
	MOVB	BORLO
	RETURN


DEVRD:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;SETUP FOR A DEVICE READ
	MOVB	MPSCR1
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN

DEVWR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	DTD			;SETUP FOR A DEVICE WRITE
	MOVB	MPSCR1
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN

SETPNT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP6			;STORE ADDITIONAL PNT ROUTINE NUMBER
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN

RDBRP0:	LDBR	0			;SET "BOR P0" INDEX
	MOVB	SPADR
	JMP	RDIT

RDB0OD:	LDBR	2			;SET "BUS0 ODD PAR" INDEX
	MOVB	SPADR
	JMP	RDIT

RDSEX:	LDBR	3			;SET "SLVE END XFER" INDEX
	MOVB	SPADR
	JMP	RDIT

RDTSFF:	LDBR	4			;SET "TRA SEL FF" INDEX
	MOVB	SPADR
	JMP	RDIT

RDAMK1:	LDBR	5			;SET "ALLOW MK 1 OUT" INDEX
	MOVB	SPADR
	JMP	RDIT

RDODDE:	LDBR	6			;SET "ODD END" INDEX
	MOVB	SPADR
	JMP	RDIT

RD2BYT:	LDBR	7			;SET "2ND BYTE" INDEX
	MOVB	SPADR
	JMP	RDIT

RDRRDY:	LDBR	10			;SET "DR READY" INDEX
	MOVB	SPADR
	JMP	RDIT

RDSLRQ:	LDBR	11			;SET "SLVE REQ" INDEX
	MOVB	SPADR
	JMP	RDIT

RDRDLY:	LDBR	12			;SET "DATA RDY DLY" INDEX
	MOVB	SPADR
	JMP	RDIT

RDCUIN:	LDBR	13			;SET "CU INIT" INDEX
	MOVB	SPADR
	JMP	RDIT

RDENSD:	LDBR	14			;SET "EN SRV/DAT OUT" INDEX
	MOVB	SPADR
	JMP	RDIT

RDSDRQ:	LDBR	15			;SET "ST DATA REQ" INDEX
	MOVB	SPADR
	JMP	RDIT

RDDSRQ:	LDBR	16			;SET "NOT DIS SLVE REQ" INDEX
	MOVB	SPADR
	JMP	RDIT

RDDPPE:	LDBR	17			;SET "DP PE" INDEX
	MOVB	SPADR
	JMP	RDIT

RDIT:	DATI	TOR1,BR			;READ REG 3
	SHR				;RIGHT ADJUST DIAG MUX BIT
	SHR
	RETURN

DPINIT:	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	MOVB	HSDPIN			;DO A HS DP INIT
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	RETURN
END:	.ECRAM
.MEM
	0
PATS:	-1
	0
FLTZ:	376
	375
	373
	367
	357
	337
	277
	177
FLTO:	1
	2
	4
	10
	20
	40
	100
	200
FLTZA:	374
	371
	365
	355
	335
	235
	135
	1
	4
	10
	20
	40
	100
	200
FLTZB:	332
	331
	323
	313
	233
	133
	1
	2
	10
	20
	100
	200
FLTZC:	340
	320
	260
	160
	20
	40
	100
	200
FLTZD:	360
	350
	330
	270
	170
	10
	20
	40
	100
	200
FLTZE:	16
	15
	13
	7
	1
	2
	4
	10
FLTZF:	334
	332
	326
	316
	236
	136
	2
	4
	10
	20
	100
	200
FLTZG:	6
	5
	3
	1
	2
	4
EPATS:	11
	102
	220
	366
OPATS:	44
	157
	275
	333
RAMADR:	0
	1
	2
	4
	10
	-1
.END
    