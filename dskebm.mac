SUBTTL STARTUP CODE
	XLIST			;DON'T SHOW EDIT INFORMATION
;UPDATE THIS DECIMAL EDIT NUMBER EACH TIME THIS FILE IS EDITED.
MEDITNO==^D176
	DSKEBM	\MCNVER,\DECVER
	LIST
START:	PGMINT			;INIT SUBRTN PACKAGE
	MOVEM	P,GOODP		;SAVE A COPY OF THE GOOD STK PTR
	SETZM	PASCNT		;CLEAR PASS COUNT
STARTA:	WREBR	POFF		;LOAD EBR, INSURE PAGING IS OFF
	WRUBR	[XWRUBR]	;LOAD USER BASE REGISTER AND SET ACBLK#
	MOVE	P,GOODP		;NOW GET A COPY OF THE GOOD STK PTR
	SETZM	SAVFLG		;CLR FLAG
	SETZM	PMFLG		;CLR FLAG
	MOVE	0,[EPT,,UPT]	;GET BLT PTR
	BLT	0,UPT+777	;MAKE A COPY OF EPT IN UPT
	MOVEI	0,PFH		;GET ADDR OF PAGE FAIL HANDLER
	MOVEM	0,UPT+LPGFTR	;SAVE FOR HDW TO FIND
	GO	MUUOST		;RESET MUUO LOCATIONS

	MOVSI	TN,-NTESTS	;GET NEGATIVE COUNT OF TESTS TO LH
MLOOP:	MOVEM	TN,SAVETN	;SAVE CURRENT VALUE OF TEST COUNTER
	GO	TSTTAB(TN)	;RUN CURRENT TEST
	MOVE	TN,SAVETN	;RESTORE TEST COUNTER
	AOBJN	TN,MLOOP	;LOOP TILL DONE
	JRST	BEGEND		;ITERATE ENTIRE TEST

BEGERR:	JRST	FATALP		;GO REPORT FATAL ERROR
	ASCIZ\TEST NOT ENTERED CORRECTLY, PROBABLY A WILD JUMP\
ENDERR:	JRST	FATALP		;GO REPORT FATAL ERROR
	ASCIZ\TEST NOT ENDED CORRECTLY, PROBABLY A WILD JUMP\

SUBTTL ACCHK - CHECK THAT ALL AC BLOCKS ARE WORKING FIRST
S
;*ACCHK - ACCUMULATOR BLOCK CHECK
;*
;*THIS TEST VERIFIES THAT ALL 8 AC BLOCKS ARE WORKING CORRECTLY.
;*FIRST, EACH AC IN EACH BLOCK IS LOADED WITH THE BLOCK NUMBER IN
;*THE LEFT HALF, AND THE AC NUMBER IN THE RIGHT HALF. THUS A UNIQUE
;*NUMBER IS LOADED INTO EACH AC. THEN THE AC'S ARE CHECKED TO INSURE
;*THAT EACH AC CONTAINS THE PROPER NUMBER.
;*NEXT, AC 17 IS CHECKED TO INSURE THAT IT CAN HOLD ALL ZEROS, AND THEN
;*TO INSURE THAT IT CAN HOLD ALL ONES. THEN THAT ENTIRE BLOCK IS TESTED
;*TO INSURE THAT ALL THE ACS IN IT CAN HOLD BOTH ZEROS AND ONES. THEN
;*THE TEST IS REPEATED FOR EACH OF THE OTHER BLOCKS.

ELOOP==.
ACCHK:	BEGTST			;TEST STARTUP
	JSR	SAVREG		;SAVE THE GOOD ACS
BX==0
	REPEAT 8,
<ACX==0
	WRUBR	[1B0!<BX>B8]	;SET BLOCK NUMBER
	REPEAT ^D16,		;LOAD EACH AC WITH ITS BLOCK#,,AC#
<	MOVE ACX,[BX,,ACX]
ACX==ACX+1>
BX==BX+1>

BX==0
	REPEAT 8,
<ACX==0
	WRUBR	[1B0!<BX>B8]	;SET BLOCK NUMBER
	REPEAT ^D16,		;VERIFY EACH AC'S CONTENTS
<	CAME ACX,[BX,,ACX]
	JSR	ACX,AC1ERR
ACX==ACX+1>
BX==BX+1>

BX==0
	REPEAT 8,
<	WRUBR	[1B0!<BX>B8]	;SET BLOCK NUMBER
	SETO	17,		;SET AC 17 TO ALL ONES
	CAME	17,[-1]		;VERIFY
	JRST	AC2ERR		;GO REPORT ERROR
	SETZ	17,		;SET AC 17 TO ALL ZEROS
	SKIPE	17		;SKIP IF OK
	JRST	AC3ERR		;GO REPORT ERROR
	MOVSI	17,-17		;LOAD AOBJN PTR
	CAME	17,[-17,,0]	;VERIFY LOAD
	JRST	AC4ERR		;GO REPORT ERROR

	SETOM	0(17)		;SET AC TO ALL ONES
	AOBJN	17,.-1		;SET 0 THRU 16 TO ALL ONES

	MOVSI	17,-17		;LOAD AOBJN PTR
	SETCMM	0(17)		;COMPLEMENT AC
	SKIPE	0(17)		;VERIFY THAT IT WORKED
	JRST	AC5ERR		;GO REPORT ERROR
	AOBJN	17,.-3		;LOOP
BX==BX+1>
	JRST	ACEND		;FINISHED SUCCESSFULLY

AC1ERR:	0
	SETOM	ERFLG		;NOTE WE HAD AN ERROR
	RDUBR	DEADAC		;READ WHICH AC BLOCK WE'RE IN
	WRUBR	[1B0]		;GO TO BLOCK 0
	MOVEI	17,1		;NOTE TYPE OF ERROR
	MOVEM	17,ERFLG	;REMEMBER IT
ACEND:	WRUBR	[1B0]		;GO TO BLOCK 0
	JSR	RESREG		;RESTORE THE GOOD ACS
	SKIPE	ERFLG		;SKIP IF NO ERROR
	ERROR	(ELOOP,13,0,0,ACCUMULATOR TEST,,ACPNT)
	ENDTST

AC2ERR:	RDUBR	DEADAC		;READ WHICH AC BLK HAD ERROR
	WRUBR	[1B0]		;GO TO BLOCK 0
	MOVEI	17,2		;NOTE TYPE OF ERROR
	MOVEM	17,ERFLG	;REMEMBER TYPE
	JRST	ACEND		;GO SHOW ERROR

AC3ERR:	RDUBR	DEADAC		;READ AC BLOCK WE'RE IN
	WRUBR	[1B0]		;GO TO BLK 0
	MOVEI	17,3		;REMEMBER TYPE
	MOVEM	17,ERFLG	;SAVE IT
	JRST	ACEND		;GO SHOW ERROR

AC4ERR:	RDUBR	DEADAC		;READ AC BLK WE'RE IN
	WRUBR	[1B0]		;GO TO BLK 0
	MOVEI	17,4		;REMEMBER TYPE
	MOVEM	17,ERFLG	;SAVE IT
	JRST	ACEND		;GO SHOW ERROR

AC5ERR:	RDUBR	DEADAC		;READ AC BLK #
	WRUBR	[1B0]		;TO BLK 0
	MOVEM	17,BADAC	;REMEMBER BAD AC #
	MOVEI	17,5		;REMEMBER TYPE
	MOVEM	17,ERFLG	;SAVE IT
	JRST	ACEND		;GO SHOW ERROR

ACPNT:	PMSG	<^ERROR OCCURED IN AC BLOCK >
	LDB	0,[POINT 3,DEADAC,8]	;GET BLOCK NUMBER
	PNTOCS			;SHOW IT
	MOVE	1,ERFLG		;GET ERROR TYPE
	JRST	ERJTB(1)	;GO PRINT EXTRA INFO ON ERROR

ERJTB:	FATALE	<UNEXPECTED ERROR OCCURED IN ACCUMULATOR TEST>
	JRST	P1ERR		;PRINT ERROR FOR TYPE 1
	JRST	P2ERR
	JRST	P3ERR
	JRST	P4ERR
	JRST	P5ERR

P1ERR:	PMSG	<, AC >
	MOVE	1,AC1ERR	;GET ADDRESS OF ERROR
	LDB	0,[POINT 4,-1(1),13]	;GET AC THAT FAILED
	PNTOCS			;SHOW AC NUMBER
	PMSG	<, ADDRESSING FAILED.^>
	RTN			;DONE

P2ERR:	PMSG	<, AC 17 FAILED TO SET TO -1^>
	RTN			;DONE

P3ERR:	PMSG	<, AC 17 FAILED TO SET TO 0^>
	RTN			;DONE

P4ERR:	PMSG	<, AC 17 FAILED TO SET TO -17,,0^>
	RTN			;DONE

P5ERR:	PMSG	<, AC >
	HRRZ	1,BADAC		;GET NUMBER OF AC THAT FAILED
	MOVE	0,1		;COPY TO 0 TO PRINT
	PNTOCS			;SHOW IT
	PMSG	<, AC SHOULD HAVE BEEN ZERO, BUT WASN'T^>
	RTN			;DONE

SUBTTL PHYCHK - PHYSICAL ADDRESS CHECK

S
;*PHYCHK - PHYSICAL ADDRESS CHECK
;*
;*THIS TEST IS DESIGNED TO INSURE THAT NO CACHE HITS ARE RECEIVED WHEN
;*THE CACHE IS TURNED OFF.  OPERATION IS AS FOLLOWS: FIRST A PAGE OF
;*JFCLS IS LOADED INTO THE CACHE BY EXECUTING IT.  THEN THE SAME PAGE IS
;*EXECUTED AGAIN, WITH RDTIME'S BEFORE AND AFTER TO CHECK ON THE ELAPSED
;*TIME.  IF THE ELAPSED TIME IS GREATER THAN THE THRESHOLD, THEN CACHE
;*MISSES ARE INDICATED, AND IS THE EXPECTED RESULT.  IF, HOWEVER, THE
;*TIME IS BELOW THE THRESHOLD, IT INDICATES CACHE HITS, WHICH SHOULD NOT
;*HAPPEN WITH PAGING TURNED OFF (PHYSICAL ADDRESSES).

ELOOP==.			;ERRORS LOOP BACK TO HERE
PHYCHK:	BEGTST			;INITIATE TEST
	GO	SETLOP		;FILL TPAG WITH JFCLS
	MOVEI	A,TPAGPN	;GET PHYS PAGE NUMBER
	MOVEI	B,TPAGPN	;GET VIRTUAL PAGE NUMBER
	SETO	C,		;CACHEABLE
	SETZ	D,		;EXEC ADDR SPACE
	GO	PMAPRT		;MAP IN PHYS=VIRT PAGE
	SETO	D,		;USER ADDR SPACE
	GO	PMAPRT		;MAP PHYS=VIRTUAL
	JSR	SAVREG		;SAVE ALL OUR REGISTERS
	HRLZI	17,PHYPGM	;SETUP BLT PTR=PHYPGM,,0
	BLT	17,17		;LOAD ALL ACS
	JRST	PHYC1		;GO GET TIME FOR EXEC TEST

PHYC4:	DSUB	PHYR3,PHYR0	;GET ELAPSED TIME TO PHYR3,PHYR3+1
	DMOVEM	PHYR3,TIM1	;SAVE FOR LATER
	JSR	RESREG		;RESTORE OUR RESGISTERS
	GO	MUUOST		;GO RESET MUUO LOCATIONS
	DMOVE	A,TIM1		;GET RESULTS TO A,B
	SKIPE	A		;HI WD SHOULD BE ZERO
	FATALE<UNREALISTIC RDTIME RESULT>
	CAMG	B,MTHLD		;THRESHOLD (IN TICKS) WITH 4MHZ CLK
	ERROR	(ELOOP,13,0,B,PHYSICAL EXEC CACHE CHECK,
CACHE HITS WHEN MISSES EXPECTED)
	ENDTST			;TEST DONE

S
;*PHYPGM - AC PGM FOR PHYSICAL CACHE CHECK
;*
;*THIS AC PGM FIRST LOADS CACHE BY EXECUTING A PAGE OF JFCLS.  THEN THE
;*PAGE IS EXECUTED AGAIN WITH RDTIME'S BEFORE AND AFTER TO CHECK ELASPED
;*TIME.  CONTROL IS THEN RETURNED TO THE MAIN PROGRAM TO CHECK RESULTS.

PHYPGM:	PHASE	0		;ASSEMBLE FOR ACS

PHYR0:	0			;00 RDTIME RESULT GOES HERE
	0			;01 LO ORDER RDTIME RESULT
XRETAC:	0,,PHYC2		;02 (RETAC) RETURN ADDRESS
PHYR3:	0			;03 RDTIME RESULT
	0			;04 LO ORDER RESULT
	BLOCK	4		;05=>10 *UNUSED*
PHYC1:	WREBR	POFF		;11 (ENTRY) INSURE PAGING OFF
	JRST	TPAG		;12 GO LOAD CACHE
PHYC2:	MOVEI	RETAC,PHYC3	;13 READY RETURN ADDRESS
	RDTIME	PHYR0		;14 GET START TIME
	JRST	TPAG		;15 GO TIME CACHE
PHYC3:	RDTIME	PHYR3		;16 GET STOP TIME
	JRST	PHYC4		;17 (EXIT) BACK TO MAIN PROGRAM
	DEPHASE
SUBTTL CACCHK - CACHEABLE/UNCACHEABLE CHECK
S
;*CACCHK - CACHEABLE/UNCACHEABLE CHECK
;*
;*THIS TEST MAKES SURE THAT ALL EXEC MODE PAGES CAN BE MADE UNCACHEABLE
;*BY SETTING THE APPROPRIATE BIT IN THE PAGE MAP ENTRY.  THEN, THE TEST
;*INSURES THAT EACH PAGE CAN BE MADE CACHEABLE.  THEN THE ABOVE IS
;*REPEATED FOR USER MODE REFERENCES.  A FIVE AC BLOCK AC PROGRAM IS
;*USED, ONE OF THEM ACTUALLY DOES THE CACHE HIT/MISS TIMING, WHILE
;*ANOTHER CHECKS THE RESULTS, COUNTS THRU ALL ADDRESS, AND RESETS THE
;*FIRST BLOCK FOR ANOTHER PASS.  ONE BLOCK IS USED TO TURN ON PAGING AND
;*START THE TEST, ANOTHER IS THE ERROR EXIT BLOCK AND THE LAST IS THE
;*NORMAL EXIT BLOCK.  NOTE THAT BOTH THE TWO EXIT AC BLOCKS (ERROR AND
;*NORMAL) ARE NEEDED, BECAUSE PAGING MUST BE TURNED OFF BEFORE RETURNING
;*TO THE MAIN PROGRAM AS THE VIRTUAL PAGES ARE ALL MAPPED TO THE SAME
;*PHYSICAL PAGE, THAT BEING THE JFCL PAGE.

ELOOP==.			;ERRORS LOOP BACK TO HERE
CACCHK:	BEGTST			;INITIATE TEST
	SETOM	CACPAS		;INIT FLAG
	GO	SETLOP		;FILL TPAG WITH JFCLS
	JSR	SAVREG		;SAVE ALL OUR REGISTERS FOR NOW
	MOVEI	A,CRETAC	;GET ADDR TO GO TO ON MUUO
	MOVEM	A,UPT+KNTRP	;SETUP 1ST MUUO LOC
	MOVE	A,[UPT+KNTRP,,UPT+KTRP]	;SETUP BLT PTR
	BLT	A,UPT+PTRP	;SETUP ALL MUUO LOCS
	SETZ	C,		;UNCACHEABLE
	SETZ	D,		;EXEC ADDR SPACE
	MOVE	0,[CACOK1,,CACER1] ;GET ARG FOR SETUP ROUTINE
	JRST	CACSET		;GO DO TEST

;*CHKMSG - PRINT MESSAGE TO CHECK CACHE ENABLE FROM 8080.

CHKMSG:	PMSG	<PLEASE INSURE THAT THE CACHE IS ENABLED FROM THE 8080^>
	RTN			;DONE.

;*CACER1 - HERE WHEN EXEC UNCACHED PAGED GOT CACHE HITS

CACER1:	SETOM	ERFLG		;NOTE WE HAD AN ERROR
	WRUBR	[402100,,0]	;SET TO AC BLOCK CONTAINING ERR DATA
	MOVEM	CAC2LO,SVERDT	;SAVE ERROR DATA
CACOK1:	JSR	RESREG		;RESTORE THE ACS
	SKIPE	ERFLG		;SKIP IF NO ERROR
	ERROR	(ELOOP,13,0,SVERDT,USER/EXEC CACHEABLE/UNCACHEABLE TEST,
EXEC UNCACHED PAGE GOT CACHE HITS)
	SETZ	C,		;UNCACHEABLE
	SETO	D,		;USER ADDR SPACE
	MOVE	0,[CACOK2,,CACER2] ;GET ARG FOR SETUP ROUTINE
	JRST	CACSET		;GO DO TEST

;*CACER2 - HERE WHEN USER UNCACHED PAGE GOT CACHE HITS

CACER2:	SETOM	ERFLG		;NOTE WE HAD AN ERROR
	WRUBR	[402100,,0]	;SET TO AC BLOCK CONTAINING ERR DATA
	MOVEM	CAC2LO,SVERDT	;SAVE ERROR DATA
CACOK2:	JSR	XRSREG		;RESTORE THE ACS
	SKIPE	ERFLG		;SKIP IF NO ERROR
	ERROR	(ELOOP,13,0,SVERDT,USER/EXEC CACHEABLE/UNCACHEABLE TEST,
USER UNCACHED PAGE GOT CACHE HITS)
	SETO	C,		;CACHEABLE
	SETZ	D,		;EXEC ADDR SPACE
	MOVE	0,[CACOK3,,CACER3] ;GET ARG FOR SETUP ROUTINE
	JRST	CACSET		;GO DO TEST

;*CACER3 - HERE WHEN EXEC CACHED PAGE GOT CACHE MISSES

CACER3:	SETOM	ERFLG		;NOTE WE HAD AN ERROR
	WRUBR	[402100,,0]	;SET TO AC BLOCK CONTAINING ERR DATA
	MOVEM	CAC2LO,SVERDT	;SAVE ERROR DATA
CACOK3:	JSR	XRSREG		;RESTORE THE ACS
	SKIPE	ERFLG		;SKIP IF NO ERROR
	ERROR	(ELOOP,13,0,SVERDT,USER/EXEC CACHEABLE/UNCACHEABLE TEST,
EXEC CACHED PAGE GOT CACHE MISSES,CHKMSG)
	SETO	C,		;CACHEABLE
	SETO	D,		;USER ADDR SPACE
	MOVE	0,[CACOK4,,CACER4] ;GET ARG FOR SETUP ROUTINE
	JRST	CACSET		;GO DO TEST

;*CACER4 - HERE WHEN USER CACHED PAGE GOT CACHE MISSES

CACER4:	SETOM	ERFLG		;NOTE WE HAD AN ERROR
	WRUBR	[402100,,0]	;SET TO AC BLOCK CONTAINING ERR DATA
	MOVEM	CAC2LO,SVERDT	;SAVE ERROR DATA
CACOK4:	JSR	XRSREG		;RESTORE THE ACS
	SKIPE	ERFLG		;SKIP IF NO ERROR
	ERROR	(ELOOP,13,0,SVERDT,USER/EXEC CACHEABLE/UNCACHEABLE TEST,
USER CACHED PAGE GOT CACHE MISSES,CHKMSG)
	JSR	XRSREG		;RESTORE THE ACS FOR LAST TIME
	GO	MUUOST		;RESTORE MUUO TRAP LOCATIONS
	ENDTST			;DONE


;*CACSET - SETUP AC BLK PROGRAM IN ALL THE NECESSARY BLOCKS.
;ENTER WITH AC0 CONTAINING GOOD RETURN ADDR IN LH, BAD IN RH
;NOTE: THIS ROUTINE MODIFIES CERTAIN INSTRUCTIONS IN THE AC PGM
;DEPENDING ON THE PASS. IE NO MOD IF 1ST PASS, USER MODE IF 2ND OR 4TH,
;AND EXPECT HITS INSTEAD OF MISSES IF 3RD OR 4TH PASS.

CACSET:	MOVEM	0,SVARG		;SAVE GOOD AND BAD RETURN ADDRS
	MOVSI	E,-1000		;SETUP AOBJN POINTER
	MOVEI	A,TPAGPN	;PHYSICAL PAGE NUMBER IN A
CLOOP1:	HRRZ	B,E		;GET A VIRTUAL PAGE NUMBER
	GO	PMAPRT		;MAP IT IN
	AOBJN	E,CLOOP1	;LOOP TILL DONE

	SETZM	P2OR4		;INIT FLAG
	SETZM	P3OR4		;INIT FLAG
	AOS	A,CACPAS	;GET PASS COUNT
	TRNE	A,1		;CHECK FOR PASS 2 OR 4 (BINARY 1 OR 3)
	SETOM	P2OR4		;YES, NOTE IT.
	TRNE	A,2		;CHECK FOR PASS 3 OR 4 (BINARY 2 OR 3)
	SETOM	P3OR4		;YES, NOTE IT.
	WRUBR	[401000,,0]	;SET TO AC BLK1
	HRLZI	17,CACPG1	;SETUP BLT PTR = CACPG1,,0
	BLT	17,17		;LOAD ALL ACS
	SKIPE	P2OR4		;SKIP IF NOT PASS 2 OR 4
	HRLI	CACGO,USERF	;ELSE SET USER BIT IN DISPATCH ADDR
	WRUBR	[402000,,0]	;SET TO AC BLK1
	HRLZI	17,CACPG2	;BLT PTR = CACPG2,,0
	BLT	17,17		;LOAD ALL ACS
	SKIPE	P2OR4		;SKIP IF NOT PASS 2 OR 4
	MOVE	CAC2UE,[HRLI CAC2AD,USERF] ;CHANGE TO RUN IN USER MODE
	SKIPE	P3OR4		;SKIP IF NOT PASS 3 OR 4
	MOVE	CAC2CU,[CAIL CAC2LO,THLD] ;CHANGE TO EXPECT CACHE HITS
	WRUBR	[403000,,0]	;AC BLK 3
	MOVE	17,[CACPG3,,16]	;SHORT PGM
	BLT	17,17		;LOAD 16,17
	HLR	17,SVARG	;GET GOOD RET ADDR FROM LH(ARG)
	WRUBR	[404000,,0]	;AC BLK 4
	MOVE	17,[CACPG3,,16]	;PUT SAME PGM IN AC BLK 4
	BLT	17,17		;LOAD 16,17
	HRR	17,SVARG	;GET BAD RET ADDR FROM RH(ARG)
	WRUBR	[406000,,0]	;AC BLK 6
	MOVE	17,[CACPG6,,13]	;SHORT PGM
	BLT	17,17		;LOAD 13 TO 17
	WRUBR	[405000,,0]	;AC BLK 5 (START BLOCK)
	MOVE	17,[CACPG5,,14]	;SHORT PGM
	BLT	17,17		;LOAD 14,15,16,17
	SETZM	ERFLG		;NOTE NO ERROR ON THIS TEST YET
	JRST	CACST1		;GO START TEST

S
;*CACPG1 - CACCHK'S AC PROGRAM NUMBER ONE.
;*
;*	THIS AC BLOCK DOES THE ACTUAL TIMING TEST OF A GIVEN PAGE, TO
;*DETERMINE IF THAT PAGE HAD CACHE HITS OR CACHE MISSES.  FIRST, THE
;*JFCL PAGE IS EXECUTED TO LOAD THE CACHE.  NOTE THAT THE JRSTF THAT
;*EXITS THE AC BLOCK WILL GO INTO USER MODE IF THE BIT IS SET IN THE
;*DISPATCH ADDRESS.  THAT BIT WILL BE SET BY THE OTHER AC BLOCK PGM IF
;*THE USER ADDRESS SPACE IS BEING TESTED, AND WILL BE CLEAR IF EXEC ADDR
;*SPACE IS BEING TESTED.  THEN UPON RETURN FROM THE JFCL PAGE, THE MUUO
;*TRAP ADDR IS SET TO POINT TO THE RDTIME INSTR WHICH WILL CAUSE A MUUO
;*TRAP IF EXECUTED IN USER MODE.  THE MUUO TRAP CAUSES THE MACHINE TO GO
;*INTO EXEC MODE, THUS THE RDTIME INSTR SERVES THE DUAL PURPOSE OF BEING
;*A 'GO-EXEC' OPCODE, AS WELL AS ITS NORMAL USE.  THEN, THE RETURN
;*ADDRESS IS SETUP AGAIN TO A DIFFERENT PLACE.  THE CURRENT TIME IS
;*NOTED, AND THE JFCL PAGE IS EXECUTED AGAIN.  UPON RETURN, THE MUUO
;*TRAP ADDR IS AGAIN SET TO POINT TO THE RDTIME, THE TIME IS NOTED, AND
;*THE PREVIOUS TIME IS SUBTRACTED FROM THE CURRENT TIME.  AFTER THAT,
;*THE OTHER AC PROGRAM IS CALLED TO ANALYZE THE RESULT, AND TO SETUP FOR
;*NEXT TIME.
;*
;*ENTER WITH <WRUBR [401000,,0]>	FROM BLOCK 5,BLOCK 2

CACPG1:	PHASE	0		;ASSEMBLE FOR ACS

CACR0:	0			;00 1ST RDTIME GOES HERE
	0			;01 2ND WD OF 1ST RDTIME HERE
CRETAC:	JRST	CACP1A		;02 (RETAC) RET ADDR, 1ST WD 2ND RDTIME
CACGO:	1000			;03 DISPATCH ADDR, 2ND WD OF 2ND RDTIME
	0			;04 *UNUSED*
	0			;05 *UNUSED*
CACP1A:	HRRI	CRETAC,CACP1B	;06 SETUP MUUO RETURN
CACP1B:	RDTIME	CACR0		;07 GET START TIME
	HRRI	CRETAC,CACP1C	;10 SETUP RETURN FROM JFCL'S
	JRSTF	(CACGO)		;11 GO TIME JFCL'S
CACP1C:	HRRI	CRETAC,CACP1D	;12 SETUP MUUO RETURN
CACP1D:	RDTIME	CRETAC		;13 GET STOP TIME
	DSUB	CRETAC,CACR0	;14 GET ELAPSED TIME
	WRUBR	CACP1E		;15 (EXIT) TO OTHER BLOCK
	JRSTF	(CACGO)		;16 (ENTRY) FROM MAIN PGM, OTHER BLK
CACP1E:	402100,,0		;17 WRUBR DATA
	DEPHASE

S
;*CACPG2 - CACCHK'S AC PROGRAM NUMBER TWO
;*
;*THIS AC PGM IS RESPONSIBLE FOR CHECKING THE RESULTS OF THE TIMING TEST
;*DONE BY THE OTHER AC BLOCK.  FIRST, THE AC PGM INCREMENTS THE PAGE
;*NUMBER TO BE TESTED, AND CHECKS FOR DONE.  IF THE AC PGM IS DONE, THE
;*EXIT ADDRESS IS MODIFIED TO GO TO A AC BLOCK THAT WILL TURN OFF PAGING
;*AND RETURN TO THE MAIN PROGRAM FOR CLEANUP.  THEN THE TWO WORDS OF THE
;*RESULT OF THE TIMING TEST ARE OBTAINED FROM THE OTHER BLOCK.  THEN THE
;*FIRST WORD IS CHECKED FOR ZERO, AND THE SECOND WORD IS CHECKED AGAINST
;*THE THRESHOLD.  IF EITHER FAILS, THE EXIT ADDRESS IS MODIFIED TO GO TO
;*AN AC BLOCK THAT WILL TURN OFF PAGING, AND RETURN TO THE MAIN PROGRAM
;*TO REPORT THE ERROR.  NOTE THAT THE FIRST DISPATCH TO THE JFCL PAGE IS
;*A JRSTF.  THE DISPATCH ADDRESS WILL CONTAIN THE USER FLAG IF THAT TEST
;*IS BEING RUN (AS OPPOSED TO EXEC ADDR SPACE).  THEN THE DISPATCH ADDR
;*IS PUT INTO THE OTHER AC BLOCK WHICH IS THEN CALLED TO DO ITS FUNCION.
;*
;*ENTER WITH <WRUBR [402100,,0]>	FROM OTHER AC BLOCK

CACPG2:	PHASE	0		;ASSEMBLE FOR ACS

CAC2AD:	1000			;00 INITIAL ADDRESS TO TEST
CAC2HI:	0			;01 GETS HI ORDER TIME DIFFERENCE
CAC2LO:	0			;02 GETS LO ORDER TIME DIFF
CAC2ST:	ADDI	CAC2AD,1000	;03 READY NEXT PAGE NUMBER
	TLNE	CAC2AD,1	;04 SKIP IF NO OVERFLOW
	HRLZI	CAC2EX,403000	;05 ELSE DONE, CHANGE EXIT INFO
	UMOVE	CAC2HI,CRETAC	;06 GET HI ORDER TIM DIFF TO CAC2HI
	UMOVE	CAC2LO,CRETAC+1	;07 GET LO ORDER
	SKIPN	CAC2HI		;10 SKIP IF BAD, SHOULD BE EMPTY
CAC2CU:	CAIG	CAC2LO,THLD	;11 SKIP IF GOOD (CHANGED TO CAIL LATER)
	HRLZI	CAC2EX,404000	;12 BAD, CHG EXIT INFO
CAC2UE:	HRLI	CAC2AD,0	;13 SET USERF IF USER TEST (CHG'D LATER)
	UMOVEM	CAC2AD,CACGO	;14 SET DISPATCH ADDR IN OTHER BLOCK
	WRUBR	CAC2EX		;15 (EXIT) TO BLK 6,4,3
	JRST	CAC2ST		;16 (ENTRY) FROM MAIN PGM, OTHER BLK
CAC2EX:	406100,,0		;17 WRUBR WD
	DEPHASE

S
;*CACPG3 - THIS AC BLK PGM GETS LOADED INTO AC BLKS 3,4 AS AN EXIT PGM

CACPG3:	PHASE	16		;SHORT AC PGM

	WREBR	POFF		;16 TURN OFF PAGING
	JRST	.		;17 GETS EXIT ADDR WHEN LOADED
	DEPHASE

S
;*CACPG5 - THIS AC BLK PGM IS THE STARTUP BLK FOR THIS TEST
;*
;*THIS AC BLK TURNS ON PAGING AND THEN GOES TO START THE TEST.

CACPG5:	PHASE	14		;ASSEMBLE FOR AC 14

CACST1:	WREBR	PON		;14 (ENTRY FROM MAIN PGM) TURN ON PAGING
	WRUBR	CACUB1		;15 (EXIT TO BLOCK 1) CHG AC BLOCK NUM
	0			;16 *UNUSED*
CACUB1:	401100,,0		;17 WRUBR WD TO CHANGE TO BLOCK 1
	DEPHASE

S
;*CACPG6 - THIS AC BLK PGM RESETS AC BLK1 FOR THE NEXT PASS
;*
;*THIS AC BLK PUTS A JRST INSTRUCTION IN CRETAC IN BLK1

CACPG6:	PHASE	13		;ASSEMBLE FOR AC 13

CAC6IN:	JRST	CACP1A		;13 FIRST RETURN INSTRUCTION
CAC6ST:	UMOVEM	CAC6IN,CRETAC	;14 PLACE RETURN INSTRUCTION IN BLK1
	WRUBR	CAC6ND		;15 (EXIT) TO BLK1
	JRST	CAC6ST		;16 (ENTRY) FROM BLK 2
CAC6ND:	401100,,0		;17 WRUBR DATA
	DEPHASE
SUBTTL LOALIT - LOW ORDER ADDRESS LINE INTERFERENCE TEST
S
;*LOALIT - LOW ORDER ADDRESS LINE INTERFERENCE TEST
;*
;*THIS TEST DOES ADDRESS LINE INTERFERENCE CHECKING ON THE LOW ORDER
;*ADDRESS BITS (27-35).  ANY ERRORS ENCOUNTERED WILL BE REPORTED AND THE
;*TEST ABORTED.  SEE THE DESCRIPTION NEXT TO ACBLK1 FOR HOW THE TEST
;*WORKS.  THE TEST IS CALLED BY SETTING UP THE PAGE MAP FOR THE TEST,
;*LOADING THE SIX AC BLOCKS USED, AND JUMPING TO AC BLOCK 0.  THE TEST
;*WILL RETURN TO ONE OF THREE PLACES: %EOT FOR A SUCCESSFUL RETURN,
;*%ERR1 IF A READ ON THE OLD DATA FAILED, OR %ERR2 IF A READ ON THE NEW
;*DATA FAILED.  AFTER RETURN TO THE MAIN PROGRAM, THE WRITE THROUGH TEST
;*IS PERFORMED.  SINCE THE MEMORY SHOULD HAVE DIFFERENT INFORMATION IN
;*IT AS A RESULT OF THE WRITES TO CACHE AND WRITE THROUGHS TO MEMORY, IF
;*THE MEMORY CONTAINS THE EXPECTED DATA, THEN THE WRITE THROUGH FUNCTION
;*IS WORKING CORRECTLY.

ELOOP==.			;ERROR LOOPS BACK TO HERE
LOALIT:	BEGTST			;STARTUP TEST
	GO	SETPAG		;GO SETUP PAGE MAPS
	MOVEI	A,TPAGPN	;GET PHYSICAL PAGE NUMBER
	MOVEI	B,400		;VIRTUAL PAGE NUMBER
	SETOM	C		;CACHEABLE
	SETZM	D		;EXEC ADDRESS SPACE
	GO	PMAPRT		;MAP IN THE PAGE FOR THE TEST
	MOVEI	A,ERRRPN	;PHYSICAL PAGE NUMBER
	MOVEI	B,ERRRPN	;VIRTUAL PAGE NUMBER
	SETZM	C		;NOT CACHEABLE
	SETZM	D		;EXEC ADDRESS SPACE
	GO	PMAPRT		;GO MAP IN ERROR RETURN PAGE
	GO	SETLOP		;FILL TPAG WITH KNOWN DATA
	JSR	SAVREG		;GO SAVE OUR REGS
	WRUBR	[B0GO,,0]	;MAKE SURE WE'RE USING BLOCK 0
	HRLZI	17,ACBLK0	;SETUP ACBLK0,,0 AS BLT PTR
	BLT	17,17		;LOAD ALL 17 ACS
	WRUBR	[B1GO,,0]	;SET CURRENT AC BLK = 1
	HRLZI	17,ACBLK1	;SETUP ACBLK1,,0 AS BLT PTR
	BLT	17,17		;LOAD ALL 17 ACS
	WRUBR	[B2GO,,0]	;SET CURRENT=2
	HRLZI	17,ACBLK2	;SETUP BLT PTR
	BLT	17,17		;LOAD ALL 17 ACS
	WRUBR	[B3GO,,0]	;CURRENT=3
	HRLZI	17,ACBLK3	;BLT PTR
	BLT	17,17		;LOAD ALL 17
	WRUBR	[B4GO,,0]	;CURRENT=4
	HRLZI	17,ACBLK4	;BLT PTR
	BLT	17,17		;LOAD ALL 17
	WRUBR	[B5GO,,0]	;CURRENT=5
	HRLZI	17,ACBLK5	;BLT PTR
	BLT	17,17		;LOAD ALL 17
	WRUBR	[B6GO,,0]	;CURRENT=6
	HRLZI	17,ACBLK6	;BLT PTR
	BLT	17,17		;LOAD ALL 17
	WRUBR	[B0GO,,0]	;READY TO GO START TEST
	SETZM	ERFLG		;NOTE NO ERROR ON THIS TEST YET
	JRST	B0R16		;GO START TEST...

;HERE ON SUCCESSFUL COMPLETION OF TEST.

%EOT:	WRUBR	[B0GO,,0]	;SETUP TO USE AC BLK 0
	JSR	RESREG		;GO RESTORE OUR REGS
	MOVSI	B,-1000		;SETUP AOBJN PTR TO CHECK A FULL PAGE
EOTLP:	MOVE	A,TPAG(B)	;GET A WORD OF THE PAGE
	CAME	A,[-1]		;SKIP IF ONES AS EXPECTED
	ERROR	(ELOOP,13,[-1],A,CACHE WRITE THROUGH TEST,
ONES NOT WRITTEN TO MEMORY,%ERRW)
	SETZM	ERRPC		;PRINT ALL ERRORS
	AOBJN	B,EOTLP		;LOOP TILL DONE
	JRST	NOTSOJ		;GO LOOP ON ERROR IF WE HAD ONE

;*%ERRW - HERE ON ERROR ON WRITE THRU, TO PRINT EXTRA INFO

%ERRW:	PUT	0		;SAVE AC0
	PMSG<WORD ADDRESS OF WORD THAT DIDN'T GET WRITTEN TO MEMORY: >
	HRRZ	0,B		;GET ADDRESS
	PNTOCS			;SHOW THE ADDRESS
	PCRL
	GET	0		;RESTORE AC
	RTN			;DONE

;*%ERR1 - HERE IF FAILURE ON READ OF OLD DATA IN CURRENT LOCATION

	.PGE	ERRR		;PAGE ALIGN SO WE CAN MAP IT IN
%ERR1:	WREBR	POFF		;TURN OFF PAGING
	SETZM	%ERRFL		;CLEAR ERR FLAG TO NOTE READ FAILED
	MOVEM	B1R5,SVTSTI	;REMEMBER TEST INSTR THAT FAILED
	JRST	%ERR		;GO TO COMMON PRINT ROUTINE

;*%ERR2 - HERE IF FAILURE ON READ OF NEW DATA IN CURRENT LOCATION

%ERR2:	WREBR	POFF		;TURN OFF PAGING
	SETOM	%ERRFL		;SET ERR FLAG TO NOTE WRITE FAILED.
	MOVEM	B1R10,SVTSTI	;REMEMBER TEST INSTR THAT FAILED

;HERE TO PRINT ERROR

%ERR:	SETOM	ERFLG		;NOTE WE HAD AN ERROR
	MOVEM	ADDR,SVADDR	;REMEMBER LOCATION THAT FAILED
	MOVEM	ERR,SVERR	;REMEMBER DATA THAT FAILED
	JSR	RESREG		;RESTORE OUR REGS
	HLRZ	A,SVTSTI	;GET THE TEST INSTR OPCODE THAT FAILED
	SETZM	SBDATA		;ASSUME CORRECT DATA WAS ALL ZEROS
	CAIE	A,(AOJN ERR,)	;WAS ALL ONES EXPECTED?
	JRST	NOTAOJ		;N, GO SEE IF A SINGLE ONE EXPECTED
	SOS	SVERR		;Y, DECR DATA BECAUSE TEST INCR'D IT
	SETOM	SBDATA		;SET CORRECT DATA TO ALL ONES
	JRST	NOTSOJ		;OK, GO PRINT ERROR
NOTAOJ:	CAIE	A,(SOJN ERR,)	;WAS A SINGLE ONE EXPECTED?
	JRST	NOTSOJ		;N, GO PRINT ERROR
	AOS	SVERR		;Y, INCR DATA BECAUSE TEST DECR'D IT
	MOVEI	A,1		;GET A SINGLE ONE READY
	MOVEM	A,SBDATA	;SAVE CORRECT DATA
NOTSOJ:	SKIPE	%ERRFL		;SKIP IF FAILURE WAS ON READ
	JRST	WRFAIL		;ELSE GO SAY THAT WRITE FAILED
	SKIPE	ERFLG		;SKIP IF WE REALLY HAD NO ERROR
	ERROR	(ELOOP,13,SBDATA,SVERR,
LO ORDER ADDRESS LINE INTERFERENCE TEST,READ FAILED,%ERR3)
ELOALT:	ENDTST			;FINISH TEST

;HERE IF WRITE TO CACHE LOCATION FAILED

WRFAIL:	SKIPE	ERFLG		;SKIP IF REALLY HAD NO ERROR
	ERROR	(ELOOP,13,SBDATA,SVERR,
LO ORDER ADDRESS LINE INTERFERENCE TEST,WRITE FAILED,%ERR3)
	JRST	ELOALT		;GO FINISH TEST

;*%ERR3 - HERE TO PRINT EXTRA DATA ON THE ERROR

%ERR3:	PMSG	<ADDRESS WITHIN PAGE: >
	HRRZ	0,SVADDR	;GET ADDRESS
	ANDI	0,777		;SHOW ONLY ADDR WITHIN PAGE
	PNTOCS			;SHOW THE PAGE ADDR
	PCRL			;<CRLF>
	RTN			;DONE

S
;*ACBLK0 - THIS BLOCK IS THE STARTUP BLOCK FOR THE WHOLE TEST
;*
;*THIS BLK TURNS ON PAGING, THEN INITIALIZES PAGE 400 TO ALL ONES.
;*BLOCK 1 WILL BE INITIALIZED FOR THE FIRST PASS ALEADY.
;*
;*ENTER WITH <WRUBR [B0GO,,0]>, JRST B0R16 (FROM MAIN PGM)

B0GO==400000			;LH OF WRUBR WD TO ENTER THIS BLOCK
B0GO2==400700			;WRUBR WD TO CHG PREV AC BLK ONLY
B7GO==407700			;WRUBR WD TO ENTER BLOCK 7
ACBLK0:	PHASE	0		;ASSEMBLE FOR ACS

B0R0:	0			;00 *UNUSED*
B0R1:	-1000,,400000		;01 AOBJN PTR FOR INIT'G MEMORY
B0R2:	B0GO2,,0		;02 WRUBR DATA
B0R3:	WREBR	POFF		;03 INSTR TO TURN OFF PAGING
B0R4:	0			;04 ZERO TO BE SENT TO B7R0
B0R5:	JRST	%EOT		;05 EXIT INSTR FROM TEST FOR BLK7
B0R6:	WRUBR	B0R2		;06 SET PREV AC BLK
	UMOVEM	B0R3,B7R16	;07 INSTR TO TURN OFF PAGING INTO B7R16
	JFCL			;10 *UNUSED*
	UMOVEM	B0R5,B7R17	;11 PUT EXIT INSTR IN B7R17
	WREBR	PON		;12 TURN ON PAGING
B0R13:	SETOM	(B0R1)		;13 INIT A MEMORY LOCATION
	AOBJN	B0R1,B0R13	;14 LOOP TILL DONE
	WRUBR	B0R17		;15 (EXIT) TO BLK2
B0R16:	JRST	B0R6		;16 (ENTRY) FROM MAIN PROGRAM
B0R17:	B2GO,,0			;17 WRUBR DATA
	DEPHASE

S
;*ACBLK1 - MAIN LOOP THAT TESTS THE CACHE FOR ADDR INTERFERENCE
;*
;*FIRST THE OLD CONTENTS OF THE CURRENT ADDRESS ARE READ AND VERIFIED.
;*THEN, A NEW PATTERN IS WRITTEN, READ, AND VERIFIED.  THEN THE ADDRESS
;*IS INCREMENTED AND THE TEST IS REPEATED.  AFTER ALL ADDRESSES HAVE
;*BEEN READ AND VERIFIED, WRITTEN, READ AND VERIFIED, THE PATTERN BEING
;*WRITTEN IS CHANGED BY BLK2 AND BLK3 AND THE TEST IS REPEATED.
;*PATTERNS USED ARE: ALL ONES TO ALL ZEROS, ALL ZEROS TO ALL ONES, ALL
;*ONES TO A SINGLE ONE, AND A SINGLE ONE TO ALL ONES.  (IN SHORTER FORM:
;*-1 => 0, 0 => -1, -1 => 1, 1 => -1).  THE 4 PATTERN CHANGES SELECTED
;*GIVE THE PARITY NET BOTH EVEN AND ODD WORDS TO CHECK FOR PARITY ERRORS
;*ON.  AFTER ALL PATTERNS HAVE BEEN DONE, THE ADDRESS INCREMENT IS
;*CHANGED BY BLK4, SO THAT A DIFFERENT BIT IS INCREMENTED THE FASTEST,
;*WITH AN END-AROUND-CARRY.  THEN THE TEST IS REPEATED AGAIN, THRU ALL
;*PATTERNS.  AFTER EACH BIT HAS BEEN INCREMENTED THE FASTEST, THE TEST
;*IS CHANGED BY BLK 5, SO THAT ALL ADDRESS INCREMENTS BECOME ADDRESS
;*DECREMENTS AND THE ENTIRE TEST IS REPEATED AGAIN.  AFTER TEST IS
;*FINISHED, IT EXITS BACK TO THE MAIN PROGRAM.  IF ANY ERRORS ARE
;*ENCOUNTERED DURING THE TEST, THE TEST IS ABORTED, AND EXITS BACK TO
;*THE MAIN PROGRAM TO REPORT THE ERROR.
;*
;*ENTER WITH <WRUBR [B1GO,,0]>	(FROM BLK0, BLK3)

B1GO==401000			;WRUBR WD TO ENTER THIS BLOCK
ACBLK1:	PHASE	0		;ASSEMBLE FOR ACS

CNT:	0			;00 LOOP COUNT
ERR:	0			;01 FAILED DATA (MAYBE CHANGED)
ADDR:	400000			;02 CURRENT ADDR BEING TESTED
B1R3:	MOVEI	CNT,1000	;03 INIT LOOP COUNT
B1R4:	MOVE	ERR,(ADDR)	;04 READ ORIG CONTENTS
B1R5:	AOJN	ERR,%ERR1	;05* VERIFY OLD DATA. SET BY BLK3.
B1R6:	SETZM	(ADDR)		;06* WRITE NEW DATA. SET BY BLK2.
	MOVE	ERR,(ADDR)	;07 READ NEW CONTENTS
B1R10:	JUMPN	ERR,%ERR2	;10* VERIFY NEW DATA. SET BY BLK3.
B1R11:	ADDI	ADDR,1		;11* INCREMENT ADDRESS. SET BY BLK4.
B1R12:	TRZE	ADDR,377000	;12 CHK FOR AND CLR ANY OVERFLOW
B1R13:	ADDI	ADDR,1		;13* END-AROUND-CARRY. SET BY BLK5.
	SOJG	CNT,B1R4	;14 LOOP TILL DONE
	WRUBR	B1R17		;15 (EXIT) TO BLK2
	JRST	B1R3		;16 (ENTRY) FROM BLK0,BLK3
B1R17:	B2GO,,1			;17 WRUBR DATA, AND RH=1 FOR HRRZM
	DEPHASE

S
;*ACBLK2 - THIS BLK CHGS THE MEMORY WRITE PATTERN INSTR IN BLK1
;*
;*THIS AC BLK CHECKS A LOOP CNT, AND EITHER GOES TO BLK4 FOR RESET OF
;*LOOP COUNT AND CHANGE OF INCREMENT, OR CHANGES A MEMORY WRITE
;*INSTRUCTION IN B1R6 AND JUMPS TO BLK3 TO CHG THE TEST INSTRUCTIONS IN
;*BLK1.
;*
;*ENTER WITH <WRUBR [B2GO,,0]>	(FROM BLK1)

B2GO==402100			;WRUBR WD TO ENTER THIS BLOCK
ACBLK2:	PHASE	0		;ASSEMBLE FOR ACS

B2R0:	476552,,476402		;00 <SETOM><HRRZM><SETOM><SETZM>
B2R1:	Z	B1R17,(ADDR)	;01 TEMPLATE FOR B1R6
B2R2:	400000			;02 NEW START ADDR FOR BLK1
B2R3:	POINT	9,B2R1,8	;03 BYTE PTR FOR TEMPLATE OPCODE
B2R4:	4			;04 INITIAL LOOP CNT,RESET LATER
B2R5:	UMOVEM	B2R2,ADDR	;05 RESET START ADDR IN BLK1
	HRLZI	B2R17,B3GO	;06 SETUP NORMAL LOOP EXIT
	SOJGE	B2R4,B2R12	;07 CHK LOOP CNT, JMP IF MORE
	HRLZI	B2R17,B4GO	;10 SETUP ALTERNATE EXIT
	JRST	B2R15		;11 GO EXIT
B2R12:	DPB	B2R0,B2R3	;12 PUT OPCODE IN TEMPLATE
	ROT	B2R0,^D9	;13 READY NEXT OPCODE
	UMOVEM	B2R1,B1R6	;14 PUT INSTR IN PREV AC BLK
B2R15:	WRUBR	B2R17		;15 (EXIT) TO BLK3,BLK4
	JRST	B2R5		;16 (ENTRY) FROM BLK1,BLK4
B2R17:	0			;17 GETS WRUBR DATA
	DEPHASE

S
;*ACBLK3 - THIS BLK CHGS THE MEMORY TEST PATTERN INSTRS IN BLK1
;*
;*THIS AC BLK CHANGES TWO TEST INSTRUCTIONS IN B1R5,B1R10 TO TEST
;*DIFFERENT PATTERNS.  THEN THE AC BLK JUMPS BACK TO THE TEST IN BLK1.
;*
;*ENTER WITH <WRUBR [B3GO,,0]>	(FROM BLK2)

B3GO==403100			;WRUBR WD TO ENTER THIS BLOCK
ACBLK3:	PHASE	0		;ASSEMBLE FOR ACS

B3R0:	326346,,366346		;00 <JUMPN><AOJN><SOJN><AOJN> OPCODES
B3R1:	Z	ERR,%ERR1	;01 TEMPLATE FOR B1R5
B3R2:	Z	ERR,%ERR2	;02 TEMPLATE FOR B1R10
	0			;03 *UNUSED*
	0			;04 *UNUSED*
B3R5:	POINT	9,B3R1,8	;05 BYTE PTR FOR TEMPLATE OPCODE
B3R6:	POINT	9,B3R2,8	;06 BYTE PTR FOR TEMPLATE OPCODE
	0			;07 *UNUSED*
B3R10:	DPB	B3R0,B3R5	;10 PUT OPCODE IN TEMPLATE
	UMOVEM	B3R1,B1R5	;11 PUT INSTR IN PREV AC BLK
	ROT	B3R0,^D9	;12 READY NEXT OPCODE
	DPB	B3R0,B3R6	;13 PUT OPCODE IN TEMPLATE
	UMOVEM	B3R2,B1R10	;14 PUT INSTR IN PREV AC BLK
	WRUBR	B3R17		;15 (EXIT) TO BLK1
	JRST	B3R10		;16 (ENTRY) FROM BLK2
B3R17:	B1GO,,0			;17 WRUBR DATA
	DEPHASE

S
;*ACBLK4 - THIS AC BLK DOUBLES THE INCREMENT INSTR IN BLK1
;*
;*RESETS LOOP COUNT IN BLK2 FOR ANOTHER PASS THRU THE PATTERNS, AND SETS
;*UP A NEW ADDRESS INCREMENT IN BLK1.  THEN A RETURN IS MADE TO BLK2 IF
;*MORE TO DO, OR TO BLK5.  AFTER THE ASCENDING TEST IS DONE, BLK5
;*MODIFIES THIS BLOCK TO GO TO BLK7 INSTEAD OF BLK5, TO STOP THE TEST.
;*
;*ENTER WITH <WRUBR [B4GO,,0]>	(FROM BLK1,BLK2)

B4GO==404200			;WRUBR WD TO ENTER THIS BLOCK
B4GO2==404100			;WRUBR WD TO CHG PREV AC BLK ONLY
ACBLK4:	PHASE	0		;ASSEMBLE FOR ACS

	0			;00 *UNUSED*
B4R1:	ADDI	ADDR,1		;01 INCR INSTR FOR B1R11
	0			;02 *UNUSED*
B4R3:	0,,4			;03 DATA FOR B2R4
B4R4:	B4GO2,,0		;04 WRUBR DATA
B4R5:	HRLZI	B4R17,B2GO	;05 SETUP NORMAL EXIT DATA
	UMOVEM	B4R3,B2R4	;06 PUT DATA IN B2R4
	WRUBR	B4R4		;07 SETUP NEW PREVIOUS AC BLK
	ADDI	B4R1,(B4R1)	;10 DOUBLE THE INCREMENT
	UMOVEM	B4R1,B1R11	;12 PUT NEW INCR IN B1R11
	TRZE	B4R1,777000	;12 CHK FOR FINISHED
B4R13:	HRLZI	B4R17,B5GO	;13 DONE, CHG EXIT DATA
	JFCL			;14 *UNUSED*
	WRUBR	B4R17		;15 (EXIT) TO BLK2,BLK5,BLK7
	JRST	B4R5		;16 (ENTRY) FROM BLK1,BLK2
B4R17:	0			;17 GETS WRUBR DATA
	DEPHASE

S
;*ACBLK5 - THIS AC BLK SETUPS THE TEST FOR DESCENDING ADDRESSES
;*
;*THIS AC BLK CHGS THE ADDI INSTRS TO SUBI INSTRS IN B1R11, B1R13, B4R1
;*TO SETUP FOR DESCENDING ADDRESS TEST.  THEN JUMPS TO BLK6.
;*
;*ENTER WITH <WRUBR [B5GO,,0]>	(FROM BLK4)

B5GO==405100			;WRUBR WD TO ENTER THIS BLOCK
B5GO2==405400			;WRUBR WD TO CHG PREV AC BLK ONLY
ACBLK5:	PHASE	0		;ASSEMBLE FOR ACS

B5R0:	SUBI	ADDR,1		;00 INSTR FOR B1R11,B4R1
B5R1:	0,,400777		;01 NEW ADDR TO START TEST AT
B5R2:	HRLZI	B4R17,B7GO	;02 NEW EXIT INSTR FOR B4R13
B5R3:	B5GO2,,0		;03 WRUBR DATA TO CHG PREV AC BLK
B5R4:	ADDI	ADDR,777	;04 NEW INSTR FOR B1R13
B5R5:	TRNE	ADDR,377000	;05 NEW TEST INSTR FOR B2R12
B5R6:	UMOVEM	B5R0,B1R11	;06 PUT NEW INSTR IN B1R11
	UMOVEM	B5R4,B1R13	;07 PUT NEW INSTR IN B1R13
	UMOVEM	B5R1,ADDR	;10 PUT NEW START ADDR IN ADDR
	UMOVEM	B5R5,B1R12	;11 SETUP NEW TEST INSTR IN B2R12
	WRUBR	B5R3		;12 CHG PREV AC BLK
	UMOVEM	B5R0,B4R1	;13 PUT NEW INSTR IN B4R1
	UMOVEM	B5R2,B4R13	;14 PUT NEW EXIT INSTR IN B4R13
	WRUBR	B5R17		;15 (EXIT) TO BLK6
	JRST	B5R6		;16 (ENTRY) FROM BLK4
B5R17:	B6GO,,0			;17 WRUBR DATA
	DEPHASE

S
;*ACBLK6 - THIS AC BLK RESETS THE LOOP COUNT IN BLK2, THEN JUMPS TO IT.
;*
;*ENTER WITH <WRUBR [B6GO,,0]>	(FROM BLK5)

B6GO==406200			;WRUBR WD TO ENTER THIS BLOCK
ACBLK6:	PHASE	0		;ASSEMBLE FOR ACS

B6R0:	0,,4			;00 LOOP COUNT FOR B2R4
B6R1:	0,,400777		;01 NEW START ADDR FOR B2R2
	BLOCK	11		;02-12 *UNUSED*
B6R13:	UMOVEM	B6R0,B2R4	;13 RESET LOOP CNT IN B2R4
	UMOVEM	B6R1,B2R2	;14 NEW START ADDR FOR B2R2
	WRUBR	B6R17		;15 (EXIT) TO BLK2
	JRST	B6R13		;16 (ENTRY) FROM BLK5
B6R17:	B2GO,,0			;17 WRUBR WD
	DEPHASE


B7R0==0				;DEFINITIONS FOR BLK 7 (SETUP BY BLK0)
B7R16==16
B7R17==17
SUBTTL HOALIT - HIGH ORDER ADDRESS LINE INTERFERENCE TEST
S
;*HOALIT - HIGH ORDER ADDRESS LINE INTERFERENCE TEST
;*
;*THIS TEST DOES ADDRESS LINE INTERFERENCE CHECKING ON THE HIGH ORDER
;*ADDRESS BITS (18-26).  ANY ERRORS ENCOUNTERED WILL BE REPORTED AND THE
;*TEST ABORTED. 
;*
;*TEST OPERATION IS AS FOLLOWS: FIRST, THE CACHE IS LOADED WITH A PAGE
;*OF JFCLS FOR A GIVEN VIRTUAL PAGE NUMBER.  THEN, A DIFFERENT VIRTUAL
;*PAGE CONTAINING IDENTICAL DATA (JFCLS) IS EXECUTED, WITH RDTIME'S
;*BEFORE AND AFTER TO RECORD THE ELAPSED TIME FOR THE SECOND PASS.  THE
;*INTENTION IS THAT IF THERE IS A BAD ADDRESS LINE, THE SECOND PAGE WILL
;*LOOK THE SAME AS THE FIRST AND WILL GET CACHE HITS INSTEAD OF CACHE
;*MISSES.  THIS WILL SHOW UP IN THE TIMING OF THE EXECUTION OF THE
;*JFCLS.  IF THE TEST IS SUCCESSFUL, THE SECOND PAGE WILL TAKE LONGER
;*THAN THE THRESHOLD, WHICH SAYS THAT THE PAGE DID NOT GET ANY CACHE
;*HITS.  A TABLE IS USED TO DETERMINE WHICH PAGE NUMBERS TO TRY AGAINST
;*WHICH OTHER PAGE NUMBERS FOR OPTIMUM TESTING FOR BAD ADDRESS LINES.
;*ALSO INCLUDED IN THE TABLE ON PURPOSE ARE ENTRIES WHERE THE FIRST PAGE
;*NUMBER IS THE SAME AS THE SECOND.  IN THIS CASE THE TEST IS EXPECTED
;*TO GET CACHE HITS, AND THE RESULTS ARE INTERPRETED ACCORDINGLY.  IF
;*CACHE MISSES ARE ENCOUNTERED, IT IS AN ERROR BECAUSE THE CACHE
;*CONTAINS VALID DATA, AND SHOULD HAVE RESULTED IN CACHE HITS.

HOALIT:	BEGTST			;STARTUP TEST
	MOVSI	TN,-NPASSS	;SETUP AOBJN PTR FOR NUMBER OF PASSES
ELOOP==.			;ERROR LOOPS BACK TO HERE
	GO	SETLOP		;GO FILL A PAGE WITH JFCL'S
HOALOP:	MOVE	A,HOALTB(TN)	;GET ENTRY FROM TABLE
	MOVEM	A,CURPAS	;SAVE CURRENT PASS NUMBERS
	MOVEI	A,TPAGPN	;GET PHYS PAGE NUMBER
	HLRZ	B,CURPAS	;GET INITIAL VIRTUAL PAGE NUMBER
	SETO	C,		;CACHEABLE
	SETZ	D,		;EXEC ADDR SPACE
	GO	PMAPRT		;MAP IN INITIAL PAGE
	HRRZ	B,CURPAS	;SET SECONDARY VIRTUAL PAGE NUMBER
	GO	PMAPRT		;MAP IN SECONDARY PAGE
	JSR	SAVREG		;SAVE OUR ACS
	HRLZI	17,HOALPG	;SETUP BLT PTR = HOALPG,,0
	BLT	17,17		;LOAD ALL ACS WITH AC PGM
	HLRZ	RDT1W1,CURPAS	;GET PAGE NUMBER TO INITIAL PAGE
	HRRZ	RDT2W1,CURPAS	;GET PAGE NUMBER OF SECONDARY PAGE
	LSH	RDT1W1,9	;MAKE MEM ADDR INSTEAD OF PAGE NUMBER
	LSH	RDT2W1,9	;MAKE MEM ADDR
	JRST	HOAL1		;GO START TEST

HOALDN:	DMOVEM	RDT1W1,TIM1	;SAVE 1ST TIME READ IN MEMORY
	DMOVEM	RDT2W1,TIM2	;SAVE 2ND TIME READ IN MEMORY
	JSR	RESREG		;GET BACK OUR ACS
	DMOVE	A,TIM2		;GET LATER TIME (LARGER)
	DSUB	A,TIM1		;GET POSITIVE ELAPSED TIME
	SKIPE	A		;DIFF SHOULD BE LESS THAN 2^^36
	FATALE<UNREALISTIC RDTIME RESULT>
	MOVE	A,B		;GET LO ORDER RESULT TO A
	HLRZ	B,CURPAS	;GET INITIAL PAGE NUMBER
	HRRZ	C,CURPAS	;GET SECONDARY PAGE NUMBER
	MOVEM	A,SAVTIM	;SAVE TIME
	CAMG	A,MTHLD		;THRESHOLD (IN TICKS) WITH 4MHZ CLK
	JRST	HOALUN		;UNDER THRESHOLD
	CAMN	B,C		;SAME PAGE NUMBER FOR 1ST AND 2ND PASS?
	ERROR	(ELOOP,13,0,A,HI ORDER ADDRESS LINE INTERFERENCE TEST,
CACHE MISSES WHEN HITS EXPECTED,%ERR4)
	JRST	HOALNX		;GO DO NEXT PASS
HOALUN:	CAME	B,C		;SAME PAGE NUMBER?
	ERROR	(ELOOP,13,0,A,HI ORDER ADDRESS LINE INTERFERENCE TEST,
CACHE HITS WHEN MISSES EXPECTED,%ERR4)
HOALNX:	SETZM	ERRPC		;INSURE ERROR GETS PRINTED NEXT TIME
	AOBJN	TN,HOALOP	;GO DO NEXT PASS TILL DONE
	ENDTST			;FINISH TEST

;*%ERR4 - PRINT OUT CURRENT STATE IF HI ORDER ADDRESS LINE TEST FAILS

%ERR4:	PUT	0		;SAVE AC0
	PMSG<INITIAL PAGE = >
	HLRZ	0,CURPAS	;GET 1ST PAGE NUMBER
	PNTOCS			;SHOW IT
	PMSG<, SECONDARY PAGE = >
	HRRZ	0,CURPAS	;GET 2ND PAGE NUMBER
	PNTOCS			;SHOW IT TOO
	PMSG<, NSEC/JFCL = >
	MOVE	0,SAVTIM	;GET TICKS/PAGE
	IMULI	0,^D244		;TIMES NSEC/TIC GETS NSEC/PAGE
	LSH	0,-9		;DIV BY 1000 = JFCLS/PAGE GETS NSEC/JFCL
	PNTDEC			;SHOW NSEC/JFCL
	GET	0		;RESTORE AC
	PCRL
	RTN			;DONE

S
;*HOALPG - AC PGM TO TEST HI ORD ADDR LINES
;*
;*THIS AC BLK TURNS ON PAGING, RUNS THRU THE JFCL PAGE TO LOAD THE
;*CACHE, AND THEN SETS UP THE RETURN ADDR AGAIN.  THEN THE PGM READS THE
;*TIME, RUNS THE JFCL PAGE AGAIN, AND READS THE TIME AGAIN ON RETURN.
;*THEN PAGING IS TURNED OFF, AND CONTROL IS RETURNED TO THE MAIN PGM.

HOALPG:	PHASE	0		;ASSEMBLE FOR ACS

	0			;00 *UNUSED*
	0			;01 *UNUSED*
RETAC:	HOAL2			;02 GETS RETURN ADDR FROM JFCL PAGE
RDT1W1:	0			;03 1ST WD OF 1ST RDTIME RESULT,ST ADDR
RDT1W2:	0			;04 2ND WD OF 2ST RDTIME RESULT
RDT2W1:	0			;05 1ST WD OF 2ND RDTIME RESULT,ST ADDR
RDT2W2:	0			;06 2ND WD OF 2ND RDTIME RESULT
HOAL1:	WREBR	PON		;07 TURN ON PAGING
	JRST	(RDT1W1)	;10 DO JFCL'S 1ST TIME TO LOAD CACHE
HOAL2:	MOVEI	RETAC,HOAL3	;11 LOAD RETURN AC
	RDTIME	RDT1W1		;12 CHECK TIME BEFORE TEST
	JRST	(RDT2W1)	;13 GO CHK FOR CACHE HIT/MISS
HOAL3:	RDTIME	RDT2W1		;14 CHECK TIME AFTER TEST
	WREBR	POFF		;15 TURN OFF PAGING
	JRST	HOALDN		;16 DONE, BACK TO PGM
	0			;17 *UNUSED*
	DEPHASE			;BACK TO NORMAL ASSEMBLY
SUBTTL UECHEK - USER TO EXEC CACHE CHECK
S
;*UECHEK - USER TO EXEC CACHE CHECK
;*
;*THIS TEST IS DESIGNED TO CHECK THE USER TO EXEC TRANSITION OF THE
;*USER/EXEC SIGNAL IN THE CACHE HIT LOGIC.  IF THE TEST IS SUCCESSFUL,
;*THE SECOND TIME THE PAGE IS EXECUTED (IN EXEC MODE), CACHE MISSES ARE
;*EXPECTED.  IF THE TEST FAILS, AND CACHE HITS ARE FOUND, THE USER/EXEC
;*SIGNAL DID NOT MAKE THE PROPER TRANSITION FROM USER TO EXEC.  THIS
;*TEST IS DESIGNED TO BE USED IN CONJUNCTION WITH THE TEST CALLED
;*'EUCHEK' WHICH CHECKS THE OPPOSITE TRANSITION OF THE USER/EXEC SIGNAL.

ELOOP==.			;ERROR LOOPS TO HERE
UECHEK:	BEGTST			;STARTUP TEST
	GO	SETPAG		;SETUP PAGE MAPS
	GO	SETLOP		;FILL TPAG WITH JFCLS
	JSR	SAVREG		;SAVE OUR REGISTERS
	MOVEI	A,UEMUUO	;GET MUUO TRAP ADDR
	MOVEM	A,UPT+KNTRP	;SET IN 1ST MUUO TRAP LOC
	MOVE	A,[UPT+KNTRP,,UPT+KTRP]	;BLT PTR
	BLT	A,UPT+PTRP	;SETUP ALL MUUO TRAP LOCS
	MOVEI	A,TPAGPN	;PHYSICAL PAGE NUMBER
	MOVEI	B,TPAGPN	;VIRTUAL PAGE NUMBER
	SETO	C,		;CACHEABLE
	SETZ	D,		;EXEC MODE
	GO	PMAPRT		;MAP IN EXEC PAGE
	SETO	D,		;USER MODE
	GO	PMAPRT		;MAP IN USER PAGE
	HRLZI	17,UEPGM	;SETUP BLT PTR = UEPGM,,0
	BLT	17,17		;LOAD ALL ACS
	JRST	UEST		;GO RUN TEST

UEDONE:	DMOVEM	UER3,TIM1	;MOVE ELAPSED TIME TO MEMORY
	JSR	RESREG		;RESTORE OUR REGISTERS
	SKIPE	TIM1		;SKIP IF 1ST WORD IS ZERO
	FATALE<UNREALISTIC RDTIME RESULT>
	MOVE	A,TIM1+1	;LO ORDER WORD OF RESULT
	CAMG	A,MTHLD		;SHOULD BE OVER THRESHOLD
	ERROR	(ELOOP,13,0,A,USER TO EXEC CHECK,TIME OVER THRESHOLD)
	GO	MUUOST		;RESTORE MUUO TRAP LOCATIONS
	ENDTST			;DONE

S
;*UEPGM - AC BLOCK PROGRAM TO CHECK THE USER TO EXEC TRANSITION
;*
;*THIS PROGRAM STARTS OFF BY TURNING ON PAGING, AND THEN EXECUTING A
;*JRSTF INSTRUCTION THAT CHANGES TO USER MODE AND GOES OFF TO THE PAGE
;*OF JFCLS.  THE RETURN ADDRESS HAVING ALREADY BEEN SETUP, THE CONTROL
;*NOW RETURNS TO THE AC PGM.  UPON RETURN, THE NEW RETURN ADDRESS IS
;*SETUP, AND THEN AN ILLEGAL OPCODE (0) IS SETUP.  BECAUSE THE MUUO TRAP
;*LOCATIONS WERE PREVIOUSLY SETUP TO POINT TO THE NEXT INSTRUCTION,
;*RESULT IS A 'GO-EXEC' OPCODE.  NEXT THE TIME IS NOTED, AND THE JFCL
;*PAGE IS AGAIN CALLED.  UPON RETURN, THE PGM NOTES THE TIME, CALCULATES
;*THE DIFFERENCE BETWEEN THE STOP TIME AND THE START TIME, TURNS OFF
;*PAGING, AND THEN RETURNS TO THE MAIN PROGRAM FOR ANALYSIS.

UEPGM:	PHASE	0		;ASSEMBLE FOR ACS

UER0:	0			;00 1ST WD OF 1ST RDTIME
	0			;01 2ND WD OF 1ST RDTIME
UERET:	UERET1			;02 1ST RETURN ADDRESS
UER3:	0			;03 2ND RDTIME
UEGO:	USERF,,TPAG		;04 RDTIME, FLAGS+ADDR FOR USER DISPATCH
	0			;05 *UNUSED*
UEST:	WREBR	PON		;06 (ENTRY FROM MAIN PGM) TURN ON PAGING
	JRSTF	(UEGO)		;07 GO TO JFCLS IN USER MODE
UERET1:	MOVEI	UERET,UERET2	;10 SETUP NEW RETURN ADDR
	0			;11 ILLEGAL OPCODE (MUUO) INTO EXEC MODE
UEMUUO:	RDTIME	UER0		;12 NOTE START TIME
	JRST	TPAG		;13 GO RUN TIMING TEST
UERET2:	RDTIME	UER3		;14 NOTE STOP TIME
	DSUB	UER3,UER0	;15 CALC ELAPSED TIME
	WREBR	POFF		;16 TURN OFF PAGING
	JRST	UEDONE		;17 (EXIT) TO MAIN PROGRAM
	DEPHASE
SUBTTL EUCHEK - EXEC TO USER CACHE CHECK
S
;*EUCHEK - EXEC TO USER CACHE CHECK
;*
;*THIS TEST IS DESIGNED TO CHECK THE EXEC TO USER TRANSITION OF THE
;*USER/EXEC SIGNAL IN THE CACHE HIT LOGIC.  IF THE TEST IS SUCCESSFUL,
;*THE SECOND TIME THE PAGE IS EXECUTED (IN USER MODE), CACHE MISSES ARE
;*EXPECTED.  IF THE TEST FAILS, AND CACHE HITS ARE FOUND, THE USER/EXEC
;*SIGNAL DID NOT MAKE THE PROPER TRANSITION FROM EXEC TO USER.  THIS
;*TEST IS DESIGNED TO BE USED IN CONJUNCTION WITH THE TEST CALLED
;*'UECHEK' WHICH CHECKS THE OPPOSITE TRANSITION OF THE USER/EXEC SIGNAL.

ELOOP==.			;ERROR LOOPS TO HERE
EUCHEK:	BEGTST			;STARTUP TEST
	GO	SETPAG		;GO SETUP PAGE MAPS
	GO	SETLOP		;FILL TPAG WITH JFCLS
	JSR	SAVREG		;SAVE OUR REGISTERS
	MOVEI	A,EUMUUO	;GET MUUO TRAP ADDR
	MOVEM	A,UPT+KNTRP	;SET IN 1ST MUUO TRAP LOC
	MOVE	A,[UPT+KNTRP,,UPT+KTRP]	;BLT PTR
	BLT	A,UPT+PTRP	;SETUP ALL MUUO TRAP LOCS
	MOVEI	A,TPAGPN	;PHYSICAL PAGE NUMBER
	MOVEI	B,TPAGPN	;VIRTUAL PAGE NUMBER
	SETO	C,		;CACHEABLE
	SETZ	D,		;EXEC MODE
	GO	PMAPRT		;MAP IN EXEC PAGE
	SETO	D,		;USER MODE
	GO	PMAPRT		;MAP IN USER PAGE
	HRLZI	17,EUPGM	;SETUP BLT PTR = EUPGM,,0
	BLT	17,17		;LOAD ALL ACS
	JRST	EUST		;GO RUN TEST

EUDONE:	DMOVEM	EUR3,TIM1	;MOVE ELAPSED TIME TO MEMORY
	JSR	RESREG		;RESTORE OUR REGISTERS
	SKIPE	TIM1		;SKIP IF 1ST WORD IS ZERO
	FATALE<UNREALISTIC RDTIME RESULT>
	MOVE	A,TIM1+1	;LO ORDER WORD OF RESULT
	CAMG	A,MTHLD		;SHOULD BE OVER THRESHOLD
	ERROR	(ELOOP,13,0,A,EXEC TO USER CHECK,TIME OVER THRESHOLD)
	GO	MUUOST		;RESTORE MUUO TRAP LOCATIONS
	ENDTST			;DONE

S
;*EUPGM - AC BLOCK PROGRAM TO CHECK THE EXEC TO USER TRANSITION
;*
;*THIS PROGRAM STARTS BY TURNING ON PAGING, AND THEN GOING OFF TO THE
;*PAGE OF JFCLS.  THE RETURN ADDRESS HAS BEEN SETUP ALREADY.  UPON
;*RETURN, A NEW RETURN ADDRESS IS SETUP, THE TIME IS NOTED, AND A JRSTF
;*IS EXECUTED TO GO INTO USER MODE AND TO GO TO THE JFCL PAGE.  UPON
;*RETURN, THE TIME IS AGAIN NOTED, AND THE DIFFERENCE BETWEEN THE STOP
;*AND START TIMES IS CALCULATED.  THEN AN ILLEGAL OPCODE (0) IS EXECUTED
;*TO CAUSE AN MUUO TRAP TO THE EXEC.  HAVING PREVIOUSLY SETUP THE MUUO
;*TRAP LOCATIONS TO POINT TO THE NEXT INSTRUCTION IN THE AC PGM
;*EFFECTIVELY CREATES A 'GO-EXEC' OPCODE.  THEN PAGING IS TURNED OFF,
;*AND CONTROL IS RETURNED TO THE MAIN PROGRAM FOR ANALYSIS.

EUPGM:	PHASE	0		;ASSEMBLE FOR ACS

EUR0:	0			;00 1ST RDTIME
	0			;01 2ND WD OF 1ST RDTIME
EURET:	EURET1			;02 RETURN AC
EUR3:	0			;03 2ND RDTIME
EUGO:	USERF,,TPAG		;04 DISPATCH TO JFCL PAGE IN USER MODE
	0			;05 *UNUSED*
EUST:	WREBR	PON		;06 (ENTRY FROM MAIN PGM) TURN ON PAGING
	JRST	TPAG		;07 GO LOAD CACHE IN EXEC MODE
EURET1:	MOVEI	EURET,EURET2	;10 SETUP NEW RETURN ADDR
	RDTIME	EUR0		;11 NOTE START TIME
	JRSTF	(EUGO)		;12 GO TO JFCL'S IN USER MODE
EURET2:	RDTIME	EUR3		;13 NOTE STOP TIME
	DSUB	EUR3,EUR0	;14 CALC ELAPSED TIME
	0			;15 ILLEGAL OPCODE (MUUO) INTO EXEC MODE
EUMUUO:	WREBR	POFF		;16 PAGING OFF
	JRST	EUDONE		;17 (EXIT) TO MAIN PROGRAM
	DEPHASE
SUBTTL SUPPORT ROUTINES
S
;*MUUOST - SETUP MUUO HANDLER LOCATIONS

MUUOST:	PUT	A		;SAVE AC
	MOVEI	A,MUUOH		;GET TRAP ADDR
	MOVEM	A,UPT+KNTRP	;SETUP MUUO TRAP LOC
	MOVE	A,[UPT+KNTRP,,UPT+KTRP]	;SETUP BLT PTR
	BLT	A,UPT+PTRP	;SET UPT+KNTRP-UPT+PTRP = A(MUUOH)
	GET	A		;RESTORE AC
	RTN			;DONE

MUUOH:	WREBR	POFF		;MAKE SURE PAGING OFF
	MOVEM	P,MUOSVP	;SAVE CURRENT P
	SKIPN	SAVFLG		;SEE IF VALID P IN SAVACS+P
	ERRHLT			;LOSE...NO STACK PTR
	MOVE	P,SAVACS+P	;GET GOOD STK PTR
	PUT	0		;SAVE AC0
	PMSGF<?^? UNEXPECTED MUUO: >
	MOVE	0,EPT+MUUO	;GET MUUO
	PNTHWF			;PRINT IT
	PMSGF<, AT PC: >
	MOVE	0,EPT+MUUOPC	;GET PC OF MUUO
	PNTHWF			;SHOW IT
	PCRL			;<CRLF>
	GET	0		;RESTORE AC0
	MOVE	P,MUOSVP	;RESTORE P
	JRST	.GODDT		;GO DIE

S
;*PMAPRT - DOES USER/EXEC CACHEABLE/UNCACHEABLE VIRTUAL TO PHYS MAPPING.
;*
;*	ENTER WITH A=PHYS PAGE NUMBER (11 BITS, 0-3777)
;*		   B=VIRTUAL PAGE NUMBER (9 BITS, 0-777)
;*		   C=CACHEABLE/UNCACHEABLE (0=UNCACHEABLE)
;*		   D=USER/EXEC  (0=EXEC)

PMAPRT:	SKIPE	PMFLG		;ENTERED THIS ROUTINE WITHOUT EXITING?
	FATALE<BAD EXIT FROM PMAPRT> ;YES, LOSE
	SETOM	PMFLG		;NOTE WE ENTERED IT
	MOVEM	D,PMDTMP	;SAVE D TEMP
	MOVEM	C,PMCTMP	;SAVE C TEMP
	MOVEM	B,PMBTMP	;SAVE B TEMP
	CAILE	B,777		;LEGAL VIRTUAL PAGE NUMBER?
	FATALE<INVALID VIRTUAL PAGE NUMBER>
	HRRZI	D,500000	;MAPPING BITS (ACCESS,WRITEABLE)
	SKIPE	C		;IS PAGE SUPPOSED TO BE CACHEABLE?
	TRO	D,20000		;YES, ADD CACHEABLE BIT
	CAILE	A,3777		;VALID PHYSICAL PAGE NUMBER?
	FATALE<INVALID PHYSICAL PAGE NUMBER>
	OR	D,A		;PUT PHYS PAGE NUMBER IN TEMPLATE
	SKIPN	PMDTMP		;SKIP IF USER MAPPING
	JRST	EMAP		;ELSE SETUP FOR EXEC MAPPING
	MOVEI	C,UPT+0-<0/2>	;PUT ENTRIES AT START OF UPT
	JRST	MPMADD		;GO MAKE PAGE MAP ADDRESS

EMAP:	CAIGE	B,400		;IS PAGE 400-777?
	JRST	EMAP2		;NO
	MOVEI	C,EPT+200-<400/2> ;SETUP BASE ADDR
	JRST	MPMADD		;GO MAKE PAGE MAP ADDR

;HERE IF PAGE IS 0-377

EMAP2:	CAIGE	B,340		;IS PAGE 340-377?
	JRST	EMAP3		;NO
	MOVEI	C,UPT+400-<340/2> ;Y, SETUP BASE ADDR
	JRST MPMADD		;GO MAKE PAGE MAP ADDR

;HERE IF PAGE IS 0-337

EMAP3:	MOVEI	C,EPT+600-<0/2>	;VIRTUAL PAGE=0-337, SETUP BASE ADDR

;HERE TO MAKE PAGE MAP ADDR

MPMADD:	LSH	B,-1		;GET VIRT PAGE NUMBER/2
	ADD	C,B		;GET FINAL INDEX INTO EPT/UPT
	MOVE	B,PMBTMP	;RESTORE VIRTUAL ADDRESS
	TRNE	B,1		;SKIP IF EVEN ADDRESS
	JRST	ODDADD		;NO, ODD ADDR
	HRLM	D,(C)		;EVEN, SET LH OF PAGE TABLE LOC
	JRST	.+2		;SKIP ODD ENTRY
ODDADD:	HRRM	D,(C)		;ODD, SET RH OF PAGE TABLE LOC
	MOVE	C,PMCTMP	;RESTORE C
	MOVE	D,PMDTMP	;RESTORE D
	SETZM	PMFLG		;NOTE WE EXITED THIS ROUTINE
	RTN			;DONE

S
;*FATALP - PRINT OUT PC AND MSG UPON FATAL ERROR

FATALP:	WREBR	POFF		;INSURE PAGING IS OFF
	MOVEM	0,FATAL0	;SAVE PC+1  OF ERROR
	SOS	FATAL0		;MAKE IT PC OF ERROR
	MOVEM	1,FATAL1	;SAVE AC1 DURING PRINT OUT ROUTINE
	PMSG<?^? FATAL ERROR @ PC >
	MOVE	0,FATAL0	;GET PC OF ERROR
	PNTHWF			;PRINT IT
	PMSG<: >
	MOVE	1,FATAL0	;GET PC OF ERROR
	MOVE	1,(1)		;GET ADDR OF LITERAL
	MOVEI	0,1(1)		;GET ADDR OF ASCIZ STRING
	PNTALF			;PRINT THE STRING
	PCRL
	MOVE	1,FATAL1	;RESTORE AC1
	JRST	.GODDT		;GO OFF TO DDT TO DEBUG...

S
;*.GODDT - ROUTINE TO GO TO DDT ENTRY POINT

.GODDT:	WREBR	POFF		;INSURE PAGING OFF
	SKIPE	10000		;SKIP IF DDT NOT LOADED
	JRST	10000		;ELSE GO TO IT
	PMSGF<?^?DDT NOT LOADED?^>
DEAD:	ERRHLT			;STOP THE WORLD.
	JRST	DEAD		;CAN'T GET HERE

S
;*SETLOP - SETUP PAGE OF JFCLS FOR CACHE TIMING TEST

SETLOP:	MOVSI	A,(JFCL)	;GET JFCL OPCODE
	MOVEM	A,TPAG		;INIT 1ST LOC IN PAGE
	MOVE	A,[TPAG,,TPAG+1] ;SETUP BLT PTR
	BLT	A,TPAG+776	;SET ALL BUT LAST LOC TO JFCL
	MOVE	A,[JRST (RETAC)] ;GET LAST INSTR
	MOVEM	A,TPAG+777	;SETUP LAST INSTR IN PAGE
	RTN			;FINISHED

S
;*PFH - PAGE FAIL HANDLER

PFH:	WREBR	POFF		;INSURE PAGING OFF
	MOVEM	P,PFHSVP	;SAVE AC P DURING PAGE FAIL
	SKIPN	SAVFLG		;SEE IF VALID P IN SAVACS+P
	ERRHLT			;LOSE...NO STACK PTR
	MOVE	P,SAVACS+P	;GET GOOD STK PTR
	PUT	0		;SAVE AC0
	PMSG<?^? PFW = >
	MOVE	0,UPT+LEUPFW	;GET PAGE FAIL WORD
	PNTHWF			;SHOW PFW
	PMSG<, @ PC: >
	MOVE	0,UPT+LPFWPC	;GET PC OF PAGE FAIL
	PNTHWF			;SHOW PC
	PCRL			;<CRLF>
	GET	0		;RESTORE AC0
	MOVE	P,PFHSVP	;RESTORE AC P AFTER PAGE FAIL HANDLING
	JRST	.GODDT		;GO TO DDT
S
;*SAVREG - SAVE ALL ACS IN AREA CALLED SAVACS...CALLED WITH JSR SAVREG

SAVREG:	0			;FOR JSR RESULT
	SKIPE	SAVFLG		;SKIP IF SAVACS EMPTY
	FATALE<ATTEMPT TO SAVREG TWICE>
	MOVEM	17,SAVACS+17	;SAVE AC 17
	MOVEI	17,SAVACS	;SETUP BLT PTR = 0,,SAVACS
	BLT	17,SAVACS+16	;SAVE 0=>16 
	MOVE	17,SAVACS+17	;RESTORE AC 17
	SETOM	SAVFLG		;NOTE SAVACS FULL
	JRST	@SAVREG		;RETURN TO CALLER

S
;*RESREG - RESTORE ALL ACS FROM AREA CALLED SAVACS, CALL WITH JSR RESREG

RESREG:	0			;FOR JSR RESULT
	SKIPN	SAVFLG		;SKIP IF SAVACS FULL
	FATALE<ATTEMPT TO RESTORE GARBAGE FROM SAVACS>
	HRLZI	17,SAVACS	;SETUP BLT PTR = SAVACS,,0
	BLT	17,17		;RESTORE ALL 17 ACS
	SETZM	SAVFLG		;NOTE SAVACS EMPTY
	JRST	@RESREG		;RETURN TO CALLER

S
;*XRSREG - RESTORE REGS WITHOUT CLEARING FLAG

XRSREG:	0			;FOR JSR RESULT
	HRLZI	17,SAVACS	;SETUP BLT PTR = SAVACS,,0
	BLT	17,17		;RESTORE ALL 17 ACS
	JRST	@XRSREG		;RETURN TO CALLER

S
;*SETPAG - SETUP VIRTUAL PAGES FROM 0 TO END: TO MAP TO PHYSICAL

SETPAG:	MOVSI	E,-<END_-^D9>	;SETUP AOBJN PTR
	SETZB	C,D		;EXEC, UNCACHEABLE
SPLOOP:	HRRZ	A,E		;GET PHYSICAL PAGE NUMBER
	HRRZ	B,E		;GET VIRTUAL PAGE NUMBER
	GO	PMAPRT		;MAP IN THE PAGE
	AOBJN	E,SPLOOP	;TILL DONE
	RTN			;ALL DONE

;.CODE ENDS HERE
SUBTTL .STORAGE
	SALL
EDITNO:	TEDITN+MEDITN		;ASSEMBLE EDIT NUMBER INTO PGM
PGMNAM:	ASCIZ\DSKEB - KS10 CACHE DIAGNOSTIC
\
S
;*TSTTAB - THIS TABLE CONTAINS THE ADDRESSES OF THE TESTS TO BE RUN

TSTTAB:	JRST	ACCHK		;ACCUMULATOR CHECK
	JRST	PHYCHK		;PHYSICAL NON-CACHE CHECK
	JRST	CACCHK		;CHECK 'PAGE CACHEABLE' SIGNAL
	JRST	LOALIT		;LO ORDER ADDR LINE INTERFERENCE TEST
	JRST	HOALIT		;HI ORDER ADDR LINE INTERFERENCE TEST
	JRST	UECHEK		;USER TO EXEC TRANSITION
	JRST	EUCHEK		;EXEC TO USER TRANSITION
NTESTS==.-TSTTAB		;NUMBER OF TESTS TO RUN

HOALTB:	400,,400		;TABLE OF ADDRESS FOR INTERFERENCE CHK
	400,,401		;CHECK B23-26
	400,,402
	400,,404
	400,,410
	417,,417
	417,,416
	417,,415
	417,,413
	417,,407
	400,,420		;CHECK B19-B22
	400,,440
	400,,500
	400,,600
	760,,760
	760,,740
	760,,720
	760,,660
	760,,560
	460,,460		;CHECK B18
	460,,60
NPASSS==.-HOALTB

;*CONSTANTS
MTHLD:	THLD			;THRESHOLD FOR CACHED/UNCACHED
;SINGLE WORD STORAGE LOCATIONS ARE DEFINED HERE
	DS	<PFHSVP,PFHSV0,SBDATA,SVADDR,SVERR,SVTSTI,%ERRFL,MUOSVP>
	DS	<SAVFLG,FATAL0,FATAL1,SAVTIM,CURPAS,SAVETN,PMFLG,PMBTMP>
	DS	<PMCTMP,PMDTMP,CACPAS,P2OR4,P3OR4,SVARG,GOODP,SVERDT>
	DS	<ERFLG,DEADAC,BADAC>
;MULTIPLE WORD STORAGE BLOCKS ARE DEFINED HERE
	DB	SAVACS,20	;SAVES ACS DURING AC PGMS
	DB	TIM1,2		;A DOUBLE WORD LOC
	DB	TIM2,2		;ANOTHER DBL WD LOC
	.PGE	TPAG		;MAIN TEST PAGE
EPT==0
EPTPN==0			;PUT EPT AT PAGE 0
	.PGE	UPT		;USER PROCESS TABLE
	.PGE	LITS		;MAKE A PAGE FOR THE LITERALS
	XLIST
;;; LOCAL MODES: :::
;;; MODE:MACRO :::
;;; END: :::
    