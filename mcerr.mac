IF2	<PRINTX STARTING BINARY FILE>
	SEARCH	DX20CA			;READ THE CROSS ASSEMBLER

;MASSBUS REGISTER BIT DEFINITIONS

;STATUS & CONTROL REGISTER 1

MPSCR0== 0				;REGISTER NAME
	RUN==	  1			;RUN LINE FROM RH20
	GO==	  2			;GO BIT
	FN==	174			;FUNCTION CODE
	 F0==	  4			;FUNCTION BIT 0
	 F1==	 10			;FUNCTION BIT 1
	 F2==	 20			;FUNCTION BIT 2
	 F3==	 40			;FUNCTION BIT 3
	 F4==	100			;FUNCTION BIT 4
	WCLK==	200			;WRITE CLOCK LINE FROM RH20

;STATUS AND CONTROL REGISTER 2

MPSCR1== 1				;REGISTER NAME
	DONE==	  1			;DATA TRANSFER DONE (READ)
	EBL==	  1			;SET EBL (WRITE)
	EXC==	  2			;EXCEPTION LINE FROM RH20 (READ)
	CLRGO==	  2			;SET TO CLEAR GO (WRITE)
	CMPERR==  4			;COMPOSITE ERROR FLAG (READ)
	START==	  4			;START A DATA TRANSFER (WRITE)
	DTD==	 10			;DATA TO DEVICE
	OCC==	 20			;OCCUPIED
	ILF==	 40			;ILLEGAL FUNCTION
	MPERR==	100			;MICRO-PROCESSOR DETECTED ERROR FLAG
	ATA==	200			;ATTENTION

;ERROR CODE REGISTER

MPECR== 2				;REGISTER NAME

;DRIVE TYPE REGISTER

MPDTR== 3				;REGISTER NAME

;HARDWARE VERSION REGISTER

MPHVR== 4				;REGISTER NAME

;DATA BUFFER REGISTER 0

MPDB0== 5				;REGISTER NAME

;DATA BUFFER REGISTER 1

MPDB1== 6				;REGISTER NAME

;DATA BUFFER REGISTER 2

MPDB2== 7				;REGISTER NAME

	DB==	  3			;DATA BUFFER BITS 16 AND 17
	DBPAR==	  4			;PARITY BIT
	DBPARE== 10			;PARITY ERROR (READ)
	DBEVEN== 20			;DATA BUFFER EVEN PARITY CONTROL

;GENERAL PURPOSE REGISTERS

MPGP0==10				;REGISTER NAMES
MPGP1==11
MPGP2==12
MPGP3==13
MPGP4==14
MPGP5==15
MPGP6==16
MPGP7==17
MPGP10==20
MPGP11==21
MPGP12==22
MPGP13==23
MPGP14==24
MPGP15==25
MPGP16==26
MPGP17==27

;MP STATUS REGISTER

MPSTAT==36				;REGISTER NAME
	INT0==	  1			;INTERRUPT LINE 0
	INT1==	  2			;INTERRUPT LINE 1
	INT2==	  4			;INTERRUPT LINE 2
	INT3==	 10			;INTERRUPT LINE 3
	C==	 20			;CARRY BIT
	Z==	 40			;ZERO BIT

;I/O BANK SELECT REGISTER

IOSEL==37				;REGISTER NAME
	INADR==	  7			;INPUT BANK ADDRESS
	OUTADR== 70			;OUTPUT BANK ADDRESS
	SPRES==	100			;STACK POINTER RESET
	INIT==	200			;INITIALIZE
;THE FOLLOWING AC'S ARE USED BY THE ERROR HANDLER

;	AC7	FLAG REGISTER
;	AC6	REPEAT COUNTER
;	AC5	SAVE OF BR (DURING CALL ONLY)
;	AC4	SAVE OF I/O SELECT REGISTER (DURING CALL ONLY)
;	AC1	CORRECT DATA FOR ERRORA CALL
;	AC0	ACTUAL DATA FOR ERRORA AND ERRORM CALLS

;FLAG REGISTER BITS

;	BIT 7	ERROR LOOP
;	BIT 6	ERROR DETECTED
;	BIT 5	RELIABILITY MODE
;	4 - 0	LAST ERROR NUMBER

%TNUM==	-1				;SET TEST NUMBER TO -1 SO ENTIRE DRIVE REGISTER

%REQ==0
IFDEF	RHDATA,<%REQ==1>
IFDEF	CUADRS,<%REQ==1>
					;IS LOADED WITH TEST NUMBER ON FIRST TEST

DEFINE	DEFTST(PROG),<
DEFINE	TEST(E,NAME,X<;*>),<

	LALL
X'**********************************************************************
X PROG * TEST E *    NAME
X'**********************************************************************
	SALL

	IFN	<^D'E^!%TNUM>&177400,<
	IFG %TNUM,<DATI IOSEL,AC6	;;SAVE THE IOSEL REG>
	LDBR	11			;;GET DEVICE CODE FOR MASSBUS INTERFACE
	MOVB	IOSEL			;;LOAD INTO I/O SELECT REGISTER
	LDBR	^D'E_-8			;;GET HIGH ORDER BITS OF TEST NUMBER
	MOVB	MPGP1			;;LOAD INTO MASSBUS REG 20
	IFG %TNUM,<	MOV	AC6,BR	;;GET SAVED IOSEL REG
			MOVB	IOSEL	;;RESTORE IT>
	>
	LDBR	^D'E&377		;;GET LOW ORDER BITS OF TEST NUMBER
	GOINK	TESTI			;;GO INITIALIZE TEST
	%TNUM==^D'E			;;REMEMBER TEST NUMBER
	%EMES==0			;;CLEAR ERROR MESSAGE NUMBER
	TST==TST'E			;;REMEMBER TEST PC
	LALL

TST'E:	SALL
>>
PNT==200				;ADDITIONAL PRINT ROUTINE REQUEST FLAG
					;ERROR PRINT ROUTINE NUMBER MUST BE IN DXGP3

DEFINE	ERRMAC(ADR,LADR,PRTN,COR),<
	GOINK	ERRSET			;;GO SET ERROR DETECTED FLAG
	LPADR==ADR			;;REMEMBER ERROR LOOP ADDRESS
	CORF==<PRTN&PNT>!COR		;;REMEMBER IF CORRECT AND ACTUAL DATA
		LALL

	ERLOOP	LADR			;;IF ERROR, LOOP TO LADR
>

DEFINE	ERROR(LADR,MES1,MES2,PRTN<0>),<ERRMAC ERLP,LADR,PRTN,0>

DEFINE	ERRORM(LADR,MES1,MES2,PRTN<0>),<ERRMAC ERLPM,LADR,PRTN,100>

DEFINE	ERRORA(LADR,MES1,MES2,PRTN<0>),<ERRMAC ERLPA,LADR,PRTN,100>

DEFINE	ERRORD(LADR,MES1,MES2,PRTN<0>),<ERRMAC ERLPD,LADR,PRTN,40>

DEFINE	ERLOOP(ADR),<SALL
	IFN %EMES&<^-37>,<IF2 <
		LALL

		PRINTX ?TOO MANY ERROR MESSAGES IN ONE TEST
		SALL
	>>
	LDBR	CORF!%EMES		;;LOAD MESSAGE NUMBER
	GOINK	LPADR			;;GO TO ERROR HANDLER
	JMPZ	ADR			;;LOOP IF Z IS SET
	%EMES==%EMES+1			;;UPDATE THE MESSAGE NUMBER
>

DEFINE	REPEAT(RADR),<
	GOINK	REPTU			;;GO TO REPEAT ROUTINE
	JMPZ	RADR			;;REPEAT IF Z IS SET
>
IFDEF RHDATA,<
	DEFINE	WRITE,<GOINK	SETWRT	;;CALL ROUTINE TO SET UP RH20>
	DEFINE	READ,<GOINK	SETRD	;;CALL ROUTINE TO SET UP RH20>
	DEFINE	READB,<GOINK	SETRDB	;;CALL ROUTINE TO SET UP RH20>

	DEFINE	CHKRH(LADR,PRTN,CODE),<
		LDBR	<PRTN&PNT>!%EMES!CODE	;;SET UP CODE FOR EC REGISTER
		GOINK	CKTRM		;;CALL HOST TO CHECK TERMINATION OF RH20
		LALL

	ERRLOP	LADR			;;IF ERROR, LOOP TO LADR
		%EMES==%EMES+1
	>
	DEFINE	CHKTRM(LADR,MES1,MES2,PRTN<0>),<CHKRH LADR,PRTN,40>
	DEFINE	CHKERR(LADR,MES1,MES2,PRTN<0>),<CHKRH LADR,PRTN,140>

	DEFINE	ERRLOP(LADR),<SALL
		JMPZ	LADR		;;IF ERROR, LOOP TO LADR
	>
>
IFDEF	CUADRS,<
	DEFINE	SNDADR,<GOINK	SENDAD	;;CALL ROUTINE TO SEND CU ADDRESSES>
>
%ADRH==0				;;CLEAR HIGH ADDRESS REFERENCE FLAG

DEFINE	GOINK(ADR),<
	IFE	.&<^-1777>,<
		JMPSUB	ADR		;;GO TO ADDRESS IN LOW 1K
	>
	IFN	.&<^-1777>,<
		IFIDN <ADR><TESTI>,<
			JMPSUB	TESTIH
			%ADRH==%ADRH!1
		>
		IFIDN <ADR><LPADR>,<
			IFE <LPADR-ERLP>,<
				JMPSUB	ERLPH
				%ADRH==%ADRH!2
			>
			IFE <LPADR-ERLPM>,<
				JMPSUB	ERLPMH
				%ADRH==%ADRH!4
			>
			IFE <LPADR-ERLPA>,<
				JMPSUB	ERLPAH
				%ADRH==%ADRH!10
			>
			IFDEF CATAB,<
				IFE <LPADR-ERLPD>,<
					JMPSUB	ERLPDH
					%ADRH==%ADRH!400
				>
			>
		>
		IFIDN <ADR><ERRSET>,<
			JMPSUB	ERSETH
			%ADRH==%ADRH!20
		>
		IFIDN <ADR><REPTU>,<
			JMPSUB	REPTUH
			%ADRH==%ADRH!40
		>
		IFDEF RHDATA,<
			IFIDN <ADR><SETWRT>,<
				JMPSUB	STWRTH
				%ADRH==%ADRH!100
			>
			IFIDN <ADR><SETRD>,<
				JMPSUB	STRDH
				%ADRH==%ADRH!100
			>
			IFIDN <ADR><SETRDB>,<
				JMPSUB	STRDBH
				%ADRH==%ADRH!100
			>
			IFIDN <ADR><CKTRM>,<JMPSUB CKTRMH>
		>
		IFDEF CUADRS,<
			IFIDN <ADR><SENDAD>,<
				JMPSUB	SNDADH
				%ADRH==%ADRH!200
			>
		>
	>
>
DEFINE	.ECRAM,<
	IFE .&<^-1777>,<	JMP	BEGEND>
	IFN .&<^-1777>,<	JUMP	BEGEND>
	IFN %ADRH&1,<	TESTIH: MOVB	AC5
				JUMP	TEST0I>
	IFN %ADRH&2,<	ERLPH:	MOVB	AC5
				JUMP	ERLP0>
	IFN %ADRH&4,<	ERLPMH:	MOVB	AC5
				JUMP	ERLPM0>
	IFN %ADRH&10,<	ERLPAH: MOVB	AC5
				JUMP	ERLPA0>
	IFN %ADRH&20,<	ERSETH: JUMP	ERRSET>
	IFN %ADRH&40,<	REPTUH: JUMP	REPTU>
	IFN %ADRH&100,<	STWRTH:	LDBR	1
				JMP	CALLH
			STRDH:	LDBR	2
				JMP	CALLH
			STRDBH:	LDBR	3
			CALLH:	MOVB	AC5
				JUMP	CALL0
			CKTRMH:	MOVB	AC5
				JUMP	CKTRM0>
	IFN %ADRH&200,<	SNDADH:	LDBR	200
				MOVB	AC5
				JUMP	CALL0>
	IFN %ADRH&400,<	ERLPDH:	MOVB	AC5
				JUMP	ERLPD0>
>
;MICRO-DIAGNOSTIC START ROUTINE

	.INIT				;INITIALIZE THE CROSS ASSEMBLER
BEGIN:	LDBR	11			;SELECT THE MASSBUS
	MOVB	IOSEL			;INTERFACE
WAITGO:	DATI	MPSCR0,BR		;READ CONTROL REGISTER
	SHR				;SHIFT GO BIT TO BIT 0
	JMPB0	.+2			;JUMP AROUND IF GO IS SET
	JMP	WAITGO			;NOT YET, KEEP WAITING
	DATI	MPSCR0,BR		;READ THE FUNCTION CODE AGAIN
	SHR				;SHIFT RIGHT
	SHR				;SHIFT F0 TO BIT 0
	JMPB0	CMDF0			;JUMP IF F0 IS SET
	SHR				;SHIFT F1 TO BIT 0
	JMPB0	.+3			;JUMP IF RELIABILITY MODE REQUESTED
	LDBR	0			;SET UP FLAG REG WITH ALL ZEROS
	JMP	.+2
	LDBR	40			;SET RELIABILITY MODE FLAG
	MOVB	AC7			;PUT IN AC7
	LDBR	INIT+SPRES		;RESET THE DX20
	MOVB	IOSEL			;AND THE STACK POINTER
	LDBR	11			;SELECT THE MASSBUS
	MOVB	IOSEL			;INTERFACE AGAIN
	LDBR	0			;CLEAR RIGHT HALF OF DXGP3
	MOVB	MPGP6			;TO INDICATE NO ADDITIONAL ERROR PRINTER
	JMPSUB	OFFGO			;TURN OFF GO
	JMP	TSTART			;GO START THE FIRST TEST

CMDF0:	SHR				;SHIFT F1 TO BIT 0
	RETURN				;RETURN TO CALLER

OFFGO:	LDBR	0			;GET A ZERO
	MOVB	MPECR			;CLEAR ERROR CODE REGISTER
	DATI	MPSCR1,AC5		;READ STATUS REGISTER 1
	LDBR	DTD			;GET MASK OF DIRECTION BIT
	LANDBR	AC5			;KEEP ONLY THAT BIT
	LDBR	CLRGO			;GET BIT TO CLEAR GO
	LORB	AC5,BR			;COMBINE WITH COPY OF DTD
	MOVB	MPSCR1			;CLEAR GO AND ATA
	RETURN
;TEST INITIALIZATION

TEST0I:	MOV	AC5,BR			;GET TEST NUMBER BACK
TESTI:	LDMAR	0			;CLEAR MEMORY ADDRESS REGISTER
	LDMARX	0			;ALL BITS
	DATI	IOSEL,AC6		;SAVE IOSEL REG
	LDMEM	11			;GET DEVICE CODE FOR MASSBUS INTERFACE
	MOVMEM	IOSEL			;LOAD INTO I/O SELECT REGISTER
	MOVB	MPGP0			;WRITE TEST NUMBER INTO DXGP0
	MOV	AC6,BR			;GET SAVED IOSEL REG
	MOVB	IOSEL			;RESTORE IT
	LDBR	40			;GET MASK OF ONLY RELIABILITY BIT
	LANDBR	AC7			;CLEAR ERROR AND MESSAGE NUMBER BITS
	MOV	AC7,BR			;GET FLAGS
	SHR				;SHIFT RELIABILITY MODE BIT TO BR4
	JMPB4	.+3			;JUMP AROUND IF RELIABILITY MODE
	LDBR	0			;QUICK VERIFY, LOAD A ZERO COUNT
	JMP	.+2
	LDBR	RPTCNT-1		;GET REPEAT COUNT
	MOVB	AC6			;SAVE IN AC6
	RETURN				;NOW START THE TEST

;I/O SELECT REGISTER GENERAL ROUTINES

SAVIOS:	DATI	IOSEL,AC4		;SAVE I/O SELECT REGISTER IN AC4
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL			;GO I/O
NRTN:	RETURN

RESIOS:	MOV	AC4,BR			;GET SAVED I/O SELECT REGISTER
	MOVB	IOSEL			;RESTORE IT
	RETURN

;ROUTINE TO SET ATA AND/OR MPERR IN STATUS REGISTER
;ENTER WITH BITS TO SET IN BR

SETATA:	DATI	MPSCR1,AC5		;READ STATUS REGISTER
	LORBR	AC5			;SET REQUESTED BITS
	LDBR	ATA+MPERR+DTD		;GET MASK OF ONLY BITS TO SET
	LANDB	AC5,BR			;CLEAR OTHER BITS READ
	MOVB	MPSCR1			;WRITE INTO STATUS REGISTER
	RETURN
;ERROR HANDLER ROUTINES

ERRSET:	LDBR	300			;GET ERROR LOOP AND DETECTED FLAGS
	LORBR	AC7			;SET BOTH BITS IN FLAG REGISTER
	RETURN

;CHECK IF TO REPORT AN ERROR

ERRCHK:	MOV	AC7,BR			;GET FLAG REGISTER
IFNDEF .ERROR,<JMPB7	.+2>		;SKIP IF IN ERROR LOOP
IFDEF  .ERROR,<JMP	REPORT>		;REPORT ALL ERRORS
	RETURN	-1			;RETURN WITH Z SET TO CONTINUE TEST
	SHL	AC7,BR			;SHIFT ERROR DETECTED BIT TO BR7
	JMPB7	REPORT			;REPORT IT IF SET
	LDBR	37			;GET MASK FOR ERROR NUMBER
	LANDBR	AC5			;CLEAR CONTROL BITS IN CURRENT NUMBER
	LANDB	AC7,BR			;EXTRACT LAST ERROR NUMBER
	OSB	AC5			;COMPARE LAST AND CURRENT ERROR NUMBERS
	JMPZ	NOFAIL			;JUMP IF AT SAME ERROR
	RETURN	-1			;NO, RETURN WITH Z SET TO CONTINUE TEST
NOFAIL:	JMPSUB	SAVIOS			;SAVE I/O REGISTER, SELECT MASSBUS
	LDBR	ATA			;GET ATA BIT
	MOVB	AC5			;SAVE IN AC5
	RETURN				;RETURN WITH Z CLEAR TO SIGNAL END OF LOOP

REPORT:	JMPSUB	SAVIOS			;SAVE I/O REGISTER, SELECT MASSBUS
	MOV	AC5,BR			;GET ERROR NUMBER
	MOVB	MPECR			;PUT IN ERROR CODE REGISTER
	LDBR	240			;GET MASK OF LOOP AND RELIABILITY BITS
	LANDBR	AC7			;LEAVE ONLY THOSE TWO BITS IN FLAG REG
	LDBR	37			;GET MASK OF ERROR NUMBER
	LANDB	AC5,BR			;GET CURRENT NUMBER FROM AC5
	LORBR	AC7			;MERGE AND PUT IN FLAG REGISTER
	LDBR	ATA+MPERR		;GET ATA AND ERROR BITS
	MOVB	AC5			;SAVE IN AC5
	RETURN				;RETURN WITH Z CLEAR TO SIGNAL ERROR REPORT
ERLP:	MOVB	AC5			;SAVE MESSAGE NUMBER IN AC5
ERLP0:	JMPSUB	ERRCHK			;CHECK FOR ERROR
	JMPZ	NRTN			;NO, RETURN WITH Z CLEAR TO CONTINUE TEST
	JMP	ERRCOM			;GO TO COMMON ROUTINE

ERLPM:	MOVB	AC5			;SAVE MESSAGE NUMBER IN AC5
ERLPM0:	JMPSUB	ERRCHK			;CHECK FOR ERROR
	JMPZ	NRTN			;NO, RETURN WITH Z CLEAR TO CONTINUE TEST
	MOVMEM	MPGP4			;PUT CORRECT DATA IN RIGHT HALF OF DXGP2
	JMP	ERRCA			;JUMP AROUND

ERLPA:	MOVB	AC5			;SAVE MESSAGE NUMBER IN AC5
ERLPA0:	JMPSUB	ERRCHK			;CHECK FOR ERROR
	JMPZ	NRTN			;NO, RETURN WITH Z CLEAR TO CONTINUE TEST
	MOV	AC1,BR			;GET CORRECT DATA FROM AC1
	MOVB	MPGP4			;PUT IN RIGHT HALF OF DXGP2
ERRCA:	MOV	AC0,BR			;GET ACTUAL DATA FROM AC0
	MOVB	MPGP5			;PUT IN LEFT HALF OF DXGP2
ERRCOM:	MOV	AC5,BR			;GET BITS TO SET IN STATUS REGISTER
CHKLOP:	JMPSUB	SETATA			;GO SET THE BITS
CHKLP:	JMPSUB	WAITGO			;WAIT FOR GO TO SET
	JMPB0	ELOOPC			;JUMP IF TO CONTINUE
	JMPSUB	OFFGO			;TURN OFF GO
	JMPSUB	RESIOS			;RESTORE I/O SELECT REGISTER
ZRTN:	RETURN	-1			;RETURN WITH Z SET TO LOOP

ELOOPC:	JMPSUB	OFFGO			;TURN OFF GO
	JMPSUB	RESIOS			;RESTORE I/O SELECT REGISTER
	RETURN				;RETURN WITH Z CLEAR TO CONTINUE
XLIST
IFDEF	CATAB,<
LIST
ERLPD:	MOVB	AC5			;SAVE MESSAGE NUMBER IN AC5
ERLPD0:	JMPSUB	ERRCHK			;CHECK FOR ERROR
	JMPZ	NRTN			;NO, RETURN WITH Z CLEAR TO CONT TEST
	SHL	AC5,BR			;LEFT ADJUST MPERR BIT
	JMPB7	.+2			;JUMP IF REPORTING ERROR
	JMP	ERRCOM			;ELSE, JUST NOTIFY HOST
	MOV	AC0,BR			;STORE BYTE COUNT FOR PRINTOUT
	MOVB	MPGP7
	DECR	AC0			;DEC BYTE CNT FOR LOOP CNT
	LDBR	0			;CLEAR CONTROL BITS
	MOVB	MPGP6
	MOV	AC1,MAR			;SET CORRECT DATA ADDR
	MOVMEM	MPGP4			;STORE CORRECT DATA
	MOV	AC2,MAR			;SET ACTUAL DATA ADDRESS
	MOVMEM	MPGP5			;STORE ACTUAL DATA
	MOV	AC5,BR			;GET BITS TO SET IN STATUS REG
	JMPSUB	SETATA			;GO SET ATTEN PLUS OTHER BITS
ERLPD1:	DATI	MPGP6,BR		;READ CONTROL BIT REG
	JMPB0	.+2			;JUMP IF HOST SET DATA ACCEPTED BIT
	JMP	.-2			;ELSE, KEEP WAITING
	DECR	AC0			;DEC BYTE COUNT
	JMPZ	ERLPD2			;JUMP IF SENT ALL DATA
	INCR	AC1			;INC CORRECT DATA ADDR
	INCR	AC2			;INC ACTUAL DATA ADDR
	MOV	AC1,MAR			;SET CORRECT DATA ADDR
	MOVMEM	MPGP4			;STORE CORRECT DATA
	MOV	AC2,MAR			;SET ACTUAL DATA ADDRESS
	MOVMEM	MPGP5			;STORE ACTUAL DATA
	LDBR	0			;CLEAR ACCEPT BIT TO SIGNAL HOST
	MOVB	MPGP6			;THAT MORE DATA IS AVAILABLE
	JMP	ERLPD1			;GO WAIT FOR HOST TO ACCEPT

ERLPD2:	LDBR	2			;CLEAR ACCEPT BIT AND SET DONE BIT
	MOVB	MPGP6			;TO SIGNAL HOST
	JMP	CHKLP

XLIST
>
LIST
XLIST
IFN	%REQ,<
LIST
SENDAD:	LDBR	200			;SET UP CODE FOR HOST
	JMP	CALL
SETWRT:	LDBR	1			;SET UP CODE FOR HOST
	JMP	CALL
SETRD:	LDBR	2			;SET UP CODE FOR HOST
	JMP	CALL
SETRDB:	LDBR	3			;SET UP CODE FOR HOST
CALL:	MOVB	AC5			;SAVE CODE IN AC5
CALL0:	JMPSUB	SAVIOS			;SAVE I/O SELECT REG., SELECT MASSBUS
	MOV	AC5,BR			;GET CODE TO PASS TO HOST
	MOVB	MPECR			;WRITE INTO ERROR CODE REGISTER
	LDBR	ATA			;GET ATTENTION BIT
	JMPSUB	SETATA			;SET ATTENTION IN STATUS REGISTER
	JMPSUB	WAITGO			;WAIT FOR GO TO SET
	JMPSUB	OFFGO			;TURN GO OFF AGAIN
	JMPSUB	RESIOS			;RESTORE THE I/O SELECT REGISTER
	RETURN				;RETURN, RH20 IS SET UP

CKTRM:	MOVB	AC5			;SAVE MESSAGE NUMBER IN AC5
CKTRM0:	JMPSUB	SAVIOS			;SAVE I/O SELECT REG., SELECT MASSBUS
	MOV	AC5,BR			;GET MESSAGE NUMBER AGAIN
	MOVB	MPECR			;WRITE IT INTO ERROR CODE REGISTER
	LDBR	ATA			;GET ATTENTION BIT
	JMP	CHKLOP			;TELL HOST, DECIDE IF TO LOOP ON RESPONSE

XLIST
>
LIST
;REPEAT TEST ROUTINE

REPTU:	DECR	AC6			;DECREMENT REPEAT COUNT
	JMPZ	NRTN			;IF NOW -1, RETURN WITH Z CLEAR
	RETURN	-1			;RETURN WITH Z SET TO REPEAT TEST

;REPORT END OF DIAGNOSTIC WITH 0 ERROR CODE AND 0 TEST NUMBER

BEGEND:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL			;IN I/O SELECT REGISTER
	LDBR	0			;GET A ZERO
	MOVB	MPGP0			;MAKE TEST NUMBER 0
	MOVB	MPGP1			;TO SAY END OF DIAGNOSTIC
	LDBR	ATA			;GET ATTENTION BIT
	MOVB	MPSCR1			;SET IT
	JMPSUB	WAITGO			;WAIT FOR GO TO SET
	JMP	BEGIN			;START DIAGNOSTIC OVER AGAIN


TSTART:					;COME HERE TO START THE TESTING


    