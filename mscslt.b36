%TITLE 'STIRS TESTS FOR M8616 (CSL) BOARD'

MODULE MSCSLT	(
		LANGUAGE(BLISS36)
		) =

BEGIN

!
!			  COPYRIGHT (C) 1979 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
!
! ABSTRACT:
!
!	THIS MODULE CONTAINS THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
!	(STIRS) DIAGNOSTIC FOR THE M8616 (CSL) BOARD.  IT ALSO CONTAINS SEVERAL
!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
!	'MSCSLD' MODULES TO PRODUCE THE 'MSCSL.EXE' FILE.
!
! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
!
! AUTHOR: RICH MURATORI	, CREATION DATE: 23-MAY-79
!
! MODIFIED BY:
!
!	RICH MURATORI, 23-MAY-79; VERSION 0.1
!--
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	SPEC_DIALOGUE: NOVALUE,		!SPECIAL USER DIALOGUE
	SPEC_PRT,			!SPECIAL FEATURE PRINTING
	SPEC_ASK: NOVALUE,		!SPECIAL FEATURE QUESTIONS
	TEST_INIT: NOVALUE,		!INITIALIZATION ROUTINE
	CLEAR_CRAM: NOVALUE,		!CLEAR CRAM BITS IN CRAM LOC 0
	RESET_CRAM: NOVALUE,		!DO A 'CRA/M RESET'
	INIT : NOVALUE,			!DO A KS10 'RESET'
	ERR_CHK_4 : NOVALUE,		!CHECK 4-BIT DATA
	ERR_CHK_8 : NOVALUE,		!CHECK 8-BIT DATA
	TST1 : NOVALUE,			!TOGGLE 'RESET'
	TST2 : NOVALUE,			!TOGGLE 'BUS REQ' WITH CLOCK STOPPED
	TST3 : NOVALUE,			!'GRANT' NEGATING 'BUS REQ'
	TST4 : NOVALUE,			!'NEXM' GENERATION
	TST5 : NOVALUE,			!'GRANT' STUCK TOGGLING
	TST6 : NOVALUE,			!'NEXM' NOT ASSERTING WITH 'MEM' NEGATED
	TST7 : NOVALUE,			!TOGGLE 'R CLK ENB'
	TST8 : NOVALUE,			!SINGLE PULSING MAINT CLOCK
	TST9 : NOVALUE,			!RESETTING 'CLOSE LATCHS'
	TST10 : NOVALUE,		!'R CLK ENB' ASSERTION
	TST11 : NOVALUE,		!'R CLK ENB' NEGATION
	TST12 : NOVALUE,		!'R CLK ENB' NEGATION
	TST13 : NOVALUE,		!'LATCH DATA ENB (1)' NEGATION
	TST14 : NOVALUE,		!'BUS REQ' ASSERTING 'R CLK ENB'
	TST15 : NOVALUE,		!SINGLE PULSING CPU CLOCKS
	TST16 : NOVALUE,		!TURNING OFF CPU CLOCKING
	TST17 : NOVALUE,		!KS10 BUS CONTROL SIGNALS (COM/ADR LOCS)
	TST18 : NOVALUE,		!KS10 BUS CONTROL SIGNALS (DATA LOCS)
	TST19 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
	TST20 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
	TST21 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
	TST22 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
	TST23 : NOVALUE,		!'DATA ACK'
	TST24 : NOVALUE,		!BUS DATA 00-03 (COM/ADR LOCS)
	TST25 : NOVALUE,		!BUS DATA 00-03 (DATA LOCS)
	TST26 : NOVALUE,		!BUS DATA 04-11 (COM/ADR LOCS)
	TST27 : NOVALUE,		!BUS DATA 04-11 (DATA LOCS)
	TST28 : NOVALUE,		!BUS DATA 12-19 (COM/ADR LOCS)
	TST29 : NOVALUE,		!BUS DATA 12-19 (DATA LOCS)
	TST30 : NOVALUE,		!BUS DATA 20-27 (COM/ADR LOCS)
	TST31 : NOVALUE,		!BUS DATA 20-27 (DATA LOCS)
	TST32 : NOVALUE,		!BUS DATA 28-35 (COM/ADR LOCS)
	TST33 : NOVALUE,		!BUS DATA 28-35 (DATA LOCS)
	TST34 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
	TST35 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
	TST36 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
	TST37 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
	TST38 : NOVALUE,		!'STATUS RD (1)'
	TST39 : NOVALUE,		!'STATUS RD (1)'
	TST40 : NOVALUE,		!'STATUS RD (1)'
	TST41 : NOVALUE,		!'STATUS RD (1)'
	TST42 : NOVALUE,		!'STATUS RD (1)'
	TST43 : NOVALUE,		!'STATUS RD (1)'
	TST44 : NOVALUE,		!'STATUS RD (1)'
	TST45 : NOVALUE,		!'STATUS RD (1)'
	TST46 : NOVALUE,		!'STATUS RD (1)'
	TST47 : NOVALUE,		!CLOCKING DATA TO/FROM CRA BOARD
	TST48 : NOVALUE,		!'CRA R CLK\#20\' SIGNAL
	TST49 : NOVALUE,		!'CRA T CLK ENABLE' SIGNAL
	TST50 : NOVALUE,		!WRITING TO CRAM
	TST51 : NOVALUE,		!WRITING AND READING CRAM BITS 12-23
	TST52 : NOVALUE,		!WRITING AND READING CRAM BITS 24-35
	TST53 : NOVALUE,		!'CRA/M RESET' SIGNAL
	TST54 : NOVALUE,		!'CRAM WRITE' SIGNAL
	TST55 : NOVALUE,		!'CRAM ADR LOAD' SIGNAL
	TST56 : NOVALUE,		!RESETTING 'CRAM ADR LOAD'
	TST57 : NOVALUE,		!'HALT LOOP (1)' GENERATION
	TST58 : NOVALUE,		!'HALT LOOP (1)' GENERATION
	TST59 : NOVALUE,		!'HALT LOOP (1)' GENERATION
	TST60 : NOVALUE,		!'HALT LOOP (1)' GENERATION
	TST61 : NOVALUE,		!'HALT LOOP (1)' GENERATION
	TST62 : NOVALUE,		!'HALT LOOP (1)' GENERATION
	TST63 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
	TST64 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
	TST65 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
	TST66 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
	TST67 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
	TST68 : NOVALUE,		!KS10 BUS PARITY GENERATION
	TST69 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
	TST70 : NOVALUE,		!RESETTING 'CLK RUN'
	TST71 : NOVALUE,		!RESETTING 'CLK RUN'
	TST72 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
	TST73 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
	TST74 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
	TST75 : NOVALUE,		!'PE (1)' GENERATION
	TST76 : NOVALUE,		!'PE (1)' GENERATION
	TST77 : NOVALUE,		!'PE (1)' GENERATION
	TST78 : NOVALUE,		!'PE (1)' GENERATION
	TST79 : NOVALUE,		!'PE (1)' GENERATION
	TST80 : NOVALUE,		!'PE (1)' GENERATION
	TST81 : NOVALUE,		!'PE (1)' GENERATION
	TST82 : NOVALUE,		!'PE (1)' GENERATION
	TST83 : NOVALUE,		!CPU CLOCKING WITH 'PE (1)' ASSERTED
	TST84 : NOVALUE,		!KS10 BUS PARITY DETECTION
	TST85 : NOVALUE,		!PARITY ERROR LATCHES
	TST86 : NOVALUE,		!MEMORY PARITY ERROR
	TST87 : NOVALUE,		!TOGGLING '10 INT'
	TST88 : NOVALUE,		!ASSERTING '10 INT'
	TST89 : NOVALUE,		!FAST SHIFTING CONTROL LOGIC
	TST90 : NOVALUE,		!FAST SHIFTING CONTROL LOGIC
	TST91 : NOVALUE,		!FAST SHIFTING CONTROL LOGIC
	TST92 : NOVALUE,		!NO 'NEXM' ON 'EM' COMMAND
	TST93 : NOVALUE,		!TOGGLING 'INT 10'
	TST94 : NOVALUE,		!RESETTING 'INT 10' CONTROL LOGIC
	TST95 : NOVALUE,		!RESETTING 'INT 10' CONTROL LOGIC
	TST96 : NOVALUE,		!CPU CLOCKING WITH 'PAGE FAIL'
	TST97 : NOVALUE,		!'TRAP EN' ASSERTION
	TST98 : NOVALUE,		!'EXECUTE' SIGNAL ON CRA BOARD
	TST99 : NOVALUE,		!'CONTINUE' SIGNAL ON CRA BOARD
	TST100 : NOVALUE,		!'1 MSEC EN' TOGGLING
	TST101 : NOVALUE,		!'STACK RESET' SIGNAL
	TST102 : NOVALUE;		!CPU CLOCKING DURING MEMORY READ

!
! INCLUDE FILES:
!

REQUIRE 'REGBIT.R36';				!8080 I/O REGISTER BIT DEFINITIONS
REQUIRE 'KSU.R36';				!KS10 MICROCODE MACROS
REQUIRE 'CSLMAC.R36';				!'CSL' INTERFACE MACROS
REQUIRE 'STIRSD.R36';				!LINKAGE TO 'MSSTRC' DEFINITIONS

!
! MACROS:
!

MACRO

	V_AC_DP = U_DBUS_DP U_RAM_AC U_FMWRITE %,	! AC0 <-- DP
	V_D_AC = U_DBUS_RAM U_RAM_AC %,			! D <-- AC0
	V_DP_0 = U_A_T1 U_LSRC_0A U_ALU_AND %,		! DP <-- 0
	V_DP__1 = U_A_T1 U_B_T1 U_LSRC_AB U_ALU_XNOR %,	! DP <-- -1
	V_DP_D = U_LSRC_D0 U_ALU_OR %,			! DP <-- D
	CYCLE(CNT) = TICK(4*CNT)%,		!4 TICKS = 1 T-CLK CYCLE
	STOP_CLK  = WRT205(MNT_CLK_ENB)%;	!STOPS SYSTEM CLOCK

!
! EQUATED SYMBOLS:
!

GLOBAL BIND
	MSGFIL = UPLIT(%SIXBIT 'MSCSL',%SIXBIT 'MSG'),
	PRGNAM = UPLIT(%ASCIZ 'KS10 STIMULUS-RESPONSE DIAGNOSTIC FOR THE M8616 BOARD');

GLOBAL LITERAL
	TEST_VERSION = 1,			!VERSION NUMBER FOR THIS MODULE
	TEST_EDIT = 4;				!EDIT NUMBER FOR THIS MODULE

!
! OWN STORAGE:
!

OWN
	ERROR_FLAG;				!FLAG SET BY 'ERR_CHK_4' AND
						! 'ERR_CHK_8' WHEN ERROR IS DETECTED

!
! EXTERNAL REFERENCES:
!


GLOBAL ROUTINE SPEC_DIALOGUE: NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!
!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PERFORM ANY
!	SPECIAL USER DIALOGUE BEFORE THE ACTIVATED FEATURES ARE LISTED.
!	SINCE THIS TEST MODULE HAS NO SPECIAL DIALOGUE, THIS ROUTINE IS NUL.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
	BEGIN
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

GLOBAL ROUTINE SPEC_PRT =
!++
! FUNCTIONAL DESCRIPTION
!
!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PRINT ANY SPECIAL
!	PROGRAM FEATURES WHICH MAY BE ACTIVATED.  SINCE THIS TEST MODULE HAS NO
!	SPECIAL FEATURES, THE ROUTINE IS NUL.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
	BEGIN
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

GLOBAL ROUTINE SPEC_ASK: NOVALUE =
!++
! FUNCTIONAL DESCRIPTION
!
!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO ASK THE USER IF
!	HE/SHE WISHES TO ACTIVATE FEATURES WHICH ARE PECULIAR TO THIS TEST
!	MODULE.  SINCE THIS MODULE HAS NO SPECIAL FEATURES, THE ROUTINE IS NUL.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
	BEGIN
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

GLOBAL ROUTINE TEST_INIT: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE INITIALIZES THE DATA BASE AND THE KS10 UNDER TEST BEFORE
!	ANY TESTING IS DONE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	RPT_ERR_FLAG	= SET TO 0 TO INHIBIT REPORTING OF UNEXPECTED 8080
!			  ERROR RESPONSES.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	INITIALIZES KS10 BEING TESTED.
!
!--
	BEGIN

	BIND
		INIT_UCODE = PLIT(
U_J(1) V_DP_0 U_SPEC_LDACBLK U,
U_J(2) V_DP_0 U_DBUS_DP U_SPEC_LOADIR U,
U_J(3) V_DP__1 V_AC_DP U,
U_J(4) V_D_AC V_DP_D U_B_AR U_DEST_AD U,
U_J(5) U_A_AR U_B_ARX U_LSRC_0A U_ALU_OR U_DEST_AD U,
U_J(6) U_A_ARX U_B_ARX U_LSRC_AB U_ALU_ADD U_DEST_AD U,
U_J(7) U_A_ARX U_ALU_XNOR U_LSRC_0A V_AC_DP U,
U_J(10) V_D_AC V_DP_D U_B_BR U_DEST_AD U,
U_J(11) V_DP_0 U_B_BRX U_DEST_AD U_SPEC_APR_EN U,
U_J(12) V_DP_0 U_DBM_N U_N(0) U_SPEC_FLAGS U,
U_J(13) U_SPEC_CLRCLK U,
U_J(14) V_DP__1 U_SPEC_LDPI U,
U_J(14) V_DP_0 U_SPEC_MEMCLR U
	    );

!THE FOLLOWING CODE IS COMMENTED OUT PENDING FURTHER TESTING.  IT
!WAS ADDED IN AN ATTEMPT TO SOLVE THE PROBLEM OF HAVING TO DO A "BT"
!BEFORE RUNNING THIS STIRS AFTER POWERING UP.

!	BIND
!		BTCODE = PLIT(
!UPLIT(%ASCIZ 'LC0,DC20707400077770037377760724100'),
!UPLIT(%ASCIZ 'LC2,DC130707400000000000344732724502'),
!UPLIT(%ASCIZ 'LC13,DC530707000000010000355772724100'),
!UPLIT(%ASCIZ 'LC53,DC610707400000000000344732604700'),
!UPLIT(%ASCIZ 'LC61,DC710707000000010000377760754102'),
!UPLIT(%ASCIZ 'LC71,DC31707400000010000475772674102'),
!UPLIT(%ASCIZ 'LC3,DC1000707400060000037475772634100'),
!UPLIT(%ASCIZ 'LC100,DC1060707400002274000333720637302'),
!UPLIT(%ASCIZ 'LC106,DC1100727507000100000422660714100'),
!UPLIT(%ASCIZ 'LC110,DC1250747007000000000422720704100'),
!UPLIT(%ASCIZ 'LC125,DC1310727405000000000422720734100'),
!UPLIT(%ASCIZ 'LC131,DC1360707400002304000333720737300'),
!UPLIT(%ASCIZ 'LC136,DC1620707000003004000333720737302'),
!UPLIT(%ASCIZ 'LC162,DC2120707400003014000333720737300'),
!UPLIT(%ASCIZ 'LC212,DC2140707400014434000422720601300'),
!UPLIT(%ASCIZ 'LC214,DC2230707000014444000333720671302'),
!UPLIT(%ASCIZ 'LC223,DC2260707000000230071422720634142'),
!UPLIT(%ASCIZ 'LC226,DC2350707400003444000333720677302'),
!UPLIT(%ASCIZ 'LC235,DC2420707400003734000422720607300'),
!UPLIT(%ASCIZ 'LC242,DC2440707400003440000377760624100'),
!UPLIT(%ASCIZ 'LC244,DC3110707000003730000377760664100'),
!UPLIT(%ASCIZ 'LC311,DC100707100000100000011727664100'),
!UPLIT(%ASCIZ 'LC10,DC5603707000014441400377740641102'),
!UPLIT(%ASCIZ 'LC560,DC6203707400014431400377740651102'),
!UPLIT(%ASCIZ 'LC620,DC6211707400000000000444720604300'),
!UPLIT(%ASCIZ 'LC621,DC6220707000000000000011725654100'),
!UPLIT(%ASCIZ 'LC622,DC21323507000600000000011724644100'),
!UPLIT(%ASCIZ 'LC2132,DC40704010000000000444720604300'),
!UPLIT(%ASCIZ 'LC626,DC10704010000000000444720604300'),
!UPLIT(%ASCIZ 'LC561,DC21325507000614440000055744641100'),
!UPLIT(%ASCIZ 'LC565,DC6002707400014430000055745651102'),
!UPLIT(%ASCIZ 'LC600,DC6211707400000000000444720604300'),
!UPLIT(%ASCIZ 'LC601,DC21323507000600000000011723644102'),
!UPLIT(%ASCIZ 'LC605,DC33200707400014444000344724641000'),
!UPLIT(%ASCIZ 'LC3320,DC20704010014434000344725651002'),
!UPLIT(%ASCIZ 'LC12,DC3230707400000004000333720656302'),
!UPLIT(%ASCIZ 'LC323,DC3240707500000100000011727624102'),
!UPLIT(%ASCIZ 'LC324,DC2240607000300004060333720646342'),
!UPLIT(%ASCIZ 'LC224,DC3110707000000000000444720604300'),
!UPLIT(%ASCIZ 'LC2133,DC33210707000077770037455764444100'),
!UPLIT(%ASCIZ 'LC3321,DC40704010000000000011727654102'),
!UPLIT(%ASCIZ 'LC225,DC1402307400206560033655765604300'),
!UPLIT(%ASCIZ 'LC141,DC35731707000000000000422720744102'),
!UPLIT(%ASCIZ 'LC3573,DC35740707000000000000377474764002'),
!UPLIT(%ASCIZ 'LC3574,DC35750707200000000000244727364100'),
!UPLIT(%ASCIZ 'LC3575,DC35760707400000000000411734764100'),
!UPLIT(%ASCIZ 'LC3576,DC100744413000000000744736604302'),
!UPLIT(%ASCIZ 'LC151,DC3340707400001200000475772774102'),
!UPLIT(%ASCIZ 'LC334,DC3430747006000040000422720614102'),
!UPLIT(%ASCIZ 'LC343,DC1160707000000000000377760774102'),
!UPLIT(%ASCIZ 'LC116,DC36570707100010160021422720644100'),
!UPLIT(%ASCIZ 'LC3657,DC24762707500000020000333720774314'),
!UPLIT(%ASCIZ 'LC2476,DC36531707100010160023011727244100'),
!UPLIT(%ASCIZ 'LC3653,DC12704110000020000333720614316'),
!UPLIT(%ASCIZ 'LC2477,DC50717400000740000444720604300'),
!UPLIT(%ASCIZ 'LC5,DC40607000600000000444720604300'));
!
!	BIND
!		BT_CMD = PLIT(UPLIT(%ASCIZ 'LK20054,DK303,DN327,DN42,LK21327,DK76,DN6,DN62,DN172,DN40,DN315,DN276,DN22'),
!			UPLIT(%ASCIZ 'DN332,DN210,DN32,DN315,DN56,DN23,DN315,DN312,DN21,DN311'));
!
!	MAP BTCODE: VECTOR;
!	MAP BT_CMD: VECTOR;
!
	RPT_ERR_FLAG = 0;		!SET FLAG TO NOT REPORT 8080 CMD ERRORS
!	INCR I FROM 0 TO 1 BY 1 DO
!		SEND_LINE(.BT_CMD[.I],-1);
!	SEND_LINE(UPLIT(%ASCIZ 'X1'),-1);
	PE(0);				!TURN OFF 8080 PARITY DETECTION
	CH();				!MAKE SURE KS10 CPU IS HALTED
	SC_0();				!TURN OFF SOFT CRAM ERR RECOVERY
	DM(31,0);			!CLEAR KS10 KEEP ALIVE AND STATUS WORD
					! SO THAT 8080 DOESN'T TRY TO REBOOT
					! WHEN TESTS CAUSE 'HALTED' MESSAGE
	SEND_NUL();			!FORCE SENDING OF COMMAND LINE
	CHK_ERR_MSG(PAR_ERR);		!CHECK IN CASE 'PE (1)' IS STUCK
	LOAD_U(0,INIT_UCODE);		!LOAD INIT MICROCODE
!	INCR I FROM 0 TO (.BTCODE[-1] - 1) BY 1 DO
!		SEND_LINE(.BTCODE[.I],-1);
	SET_C(0);			!SET CRAM START ADDR TO ZERO
	CP_NOSS(18);			!EXECUTE IT WITH 5 EXTRA CLOCKS TO INSURE PAGE FAIL CLEARS
!	CS();				!START MICROCODE
	SEND_NUL();			!SEND CS CMD
!	CHK_ERR_MSG(HALTED);		!CHECK FOR 'HALTED' MESSAGE
!	CH();				!STOP MICROCODE
	CLEAR_CRAM();			!CLEAR CRAM BITS IN LOC 0
	WRT114(0);			!CLEAR KS10 BUS CONTROL BITS IN THE
	WRT115(0);			! CSL BOARD I/O BUFFERS
	SEND_NUL();			!FORCE SENDING OF COMMAND LINE
	END;

ROUTINE CLEAR_CRAM: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE DOES A MASTER RESET OF THE KS10 AND DEPOSITS ALL ZEROS
!	INTO LOCATION 0 OF THE CRAM.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	DOES A MASTER RESET OF THE KS10 AND DEPOSITS 0 INTO CRAM LOC 0.
!
!--
	BEGIN
	BIND
		DC_0 = UPLIT(%ASCIZ 'LC0,DC0');	!CMD STRING TO DEPOSIT ZEROS

	MR();				!DO A KS10 MASTER RESET
	SEND_LINE(DC_0,0);		!INSURE CRAM BITS ARE CLEARED
	END;

ROUTINE RESET_CRAM: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE IS CALLED TO TOGGLE THE 'CRA/M RESET' SIGNAL IN THE
!	KS10.  THIS CLEARS THE CRAM CONTROL BITS LATCHES.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	CONCATENATES A COMMAND STRING TO ASSERT AND NEGATE THE 'CRA/M RESET'
!	BIT IN 8080 REGISTER 204 ONTO THE CUMULATIVE COMMAND LINE.
!
!--
	BEGIN
	WRT204(CRAM_RESET);			!ASSERT CRA/M RESET
	WRT204(0);				!THEN NEGATE IT
	END;

ROUTINE INIT: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE CAUSES THE KS10 'RESET' SIGNAL TO BE TOGGLED.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	CAUSES A COMMAND STRING TO ASSERT AND NEGATE THE 'RESET' BIT IN 8080
!	REGISTER 100 TO BE CONCATENATED ONTO THE CUMULATIVE COMMAND STRING.
!
!--
	BEGIN

	SEND_NUL();			!MAKE SURE 'RESET' ASSERTING ANG CLEARING
					!GO ON THE SAME COMMAND LINE
	WRT100(RESET);			!ASSERT 'RESET'
	WRT100(0);			!NEGATE IT
	END;

ROUTINE ERR_CHK_4(CORRECT,ACTUAL): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE COMPARES 4 BITS WORTH OF CORRECT AND ACTUAL DATA.  IT
!	CHECKS FOR SINGLE BIT ERRORS, COMPLEMENTED DATA, AND MULTIPLE BIT
!	ERRORS.  IT IS CALLED BY THE TESTS WHICH CHECK THE KS10 BUS XCVRS.
!
! FORMAL PARAMETERS:
!
!	CORRECT		= 4 BITS OF CORRECT DATA
!	ACTUAL		= 4 BITS OF ACTUAL DATA
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	ERROR_FLAG	= -1 IF CORRECT IS NOT EQUAL TO ACTUAL.
!			  UNCHANGED OTHERWISE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	IF ERROR IS DETECTED, FAULT ISOLATION IS PERFORMED.
!
!--
	BEGIN
	LOCAL
		DISCREP;

	IF .ACTUAL EQL .CORRECT		!IS DATA CORRECT?
	THEN
		RETURN;			!YES, JUST RETURN
	ERROR_FLAG = -1;		!SET ERROR FLAG
	ERMCA(1,.CORRECT,.ACTUAL,3);	!REPORT ERROR
	DISCREP = .ACTUAL XOR .CORRECT;	!COMPUTE DISCREPANCIES

!CHECK FOR SINGLE BIT ERROR

	INCR J FROM 0 TO 3 BY 1 DO
		IF .DISCREP EQL 1^.J
		THEN
			BEGIN
			FAILURE(1+.J);	!DO FAULT ISOLATION
			RETURN;
			END;

!CHECK IF ACTUAL DATA IS COMPLEMENTED

	IF .DISCREP EQL %O'17'
	THEN
		BEGIN
		FAILURE(5);	!DO FAULT ISOLATION
		RETURN;
		END;

!IF WE GET THIS FAR THEN THE WHOLE WORD MUST BE INCORRECT

	FAILURE(6);	!DO FAULT ISOLATION
	END;

ROUTINE ERR_CHK_8(CORRECT,ACTUAL): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE COMPARES 8 BITS WORTH OF CORRECT AND ACTUAL DATA.  IT
!	CHECKS FOR SINGLE BIT ERRORS, COMPLEMENTED DATA, AND MULTIPLE BIT
!	ERRORS.  IT IS CALLED BY THE TESTS WHICH CHECK THE KS10 BUS XCVRS.
!
! FORMAL PARAMETERS:
!
!	CORRECT		= 8 BITS OF CORRECT DATA
!	ACTUAL		= 8 BITS OF ACTUAL DATA
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	ERROR_FLAG	= -1 IF CORRECT IS NOT EQUAL TO ACTUAL.
!			  UNCHANGED OTHERWISE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	IF ERROR IS DETECTED, FAULT ISOLATION IS PERFORMED.
!
!--
	BEGIN
	LOCAL
		DISCREP;

	IF .ACTUAL EQL .CORRECT		!IS DATA CORRECT?
	THEN
		RETURN;			!YES, JUST RETURN
	ERROR_FLAG = -1;		!SET ERROR FLAG
	ERMCA(1,.CORRECT,.ACTUAL,3);	!REPORT ERROR
	DISCREP = .ACTUAL XOR .CORRECT;	!COMPUTE DISCREPANCIES

!CHECK FOR SINGLE BIT ERROR

	INCR J FROM 0 TO 7 BY 1 DO
		IF .DISCREP EQL 1^.J
		THEN
			BEGIN
			FAILURE(1+.J);	!DO FAULT ISOLATION
			RETURN;
			END;

!CHECK IF ACTUAL DATA IS COMPLEMENTED

	IF .DISCREP EQL %O'377'
	THEN
		BEGIN
		FAILURE(9);	!DO FAULT ISOLATION
		RETURN;
		END;

!CHECK FOR HIGH ORDER FOUR BITS COMPLEMENTED

	IF .DISCREP EQL %O'360'
	THEN
		BEGIN
		FAILURE(10);	!DO FAULT ISOLATION
		RETURN;
		END;

!CHECK FOR LOW ORDER FOUR BITS COMPLEMENTED

	IF .DISCREP EQL %O'17'
	THEN
		BEGIN
		FAILURE(11);	!DO FAULT ISOLATION
		RETURN;
		END;

!CHECK FOR JUST HIGH ORDER FOUR BITS INCORRECT

	IF (.DISCREP AND %O'360') NEQ 0
	THEN
		BEGIN
		FAILURE(12);		!DO FAULT ISOLATION
		RETURN;
		END;

!CHECK FOR JUST LOW ORDER FOUR BITS INCORRECT

	IF (.DISCREP AND %O'17') NEQ 0
	THEN
		BEGIN
		FAILURE(13);		!DO FAULT ISOLATION
		RETURN;
		END;

!IF WE GET THIS FAR THEN THE WHOLE WORD MUST BE INCORRECT

	FAILURE(14);	!DO FAULT ISOLATION
	END;

GLOBAL ROUTINE TST1: NOVALUE =

!THIS TEST CHECKS THAT 'RESET' CAN BE ASSERTED AND NEGATED.
!SINCE THE 'RESET' FLOP CANNOT BE READ DIRECTLY 'R RESET' IS READ.
!'R RESET' IS THE PROPAGATION OF 'RESET' ONTO THE KS10 BUS AND BACK
!INTO THE 8646 RECEIVERS.
!AT THE SAME TIME THAT 'RESET' IS ASSERTED, 'PE DETECT' IS NEGATED.
!SO A CHECK IS MADE TO INSURE THAT 'PE (1)' IS NEGATED.

	BEGIN
	LABEL BLOCK1;
	LOCAL
		ERFLG,
		TEMP;
	BIND
		PTR = UPLIT(%ASCIZ 'LR100,DR0,DR200,ER102,LR100,DR0');
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,RP');

	ERFLG = 0;		!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	TEMP = .(SEND_LINE(PTR,1) + 1);		!SEND COMMANDS TO ASSERT AND READ 'R RESET'
	CHK_ERR_MSG(PAR_ERR);			!CHECK FOR 'PAR ERR' MESSAGE
	IF (.TEMP AND RRESET) EQL 0		!DID IT SET?
	THEN
		BEGIN
		ERR(1);				!NO, REPORT ERROR
		ERFLG = 1;			!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRT 100/0	- NEGATE 'RESET'
!*	WRT 100/200	- ASSERT 'CSL3 RESET L'.  THIS SHOULD ASSERT
!*			  'CSL5 RESET H' WHICH SHOULD ASSERT 'R RESET'.
!*RESPONSE:
!*	'R RESET' DIDN'T ASSERT
!]ERROR 1
!]WRT100 RST_LTCH RESETH RST_XCVR RCLKD TCLKA R_RESET RD_100 ADR1L_H ADR0L2_L NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (RD_102 AND RRESET) NEQ 0		!DID 'R RESET' CLEAR?
	THEN
		BEGIN
		ERR(2);			!NO , REPORT ERROR
		ERFLG = 1;		!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	WRT 100/0	- NEGATE 'RESET'
!*	WRT 100/200	- ASSERT 'CSL3 RESET L'.  THIS SHOULD ASSERT
!*			  'CSL5 RESET H' WHICH SHOULD ASSERT 'R RESET'.
!*	WRT 100/0	- NEGATE 'RESET'
!*RESPONSE:
!*	'R RESET' DIDN'T NEGATE
!]ERROR 2
!]RST1 PNL_RST RST_LTCH RESETH RST_XCVR RCLKD TCLKA R_RESET RD_100 ADR1L_H ADR0L2_L NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .ERFLG EQL 0		!IF HAD NO ERRORS THEN
	THEN
		NOERR(1);	!DO FAULT ISOLATION
!]NO ERROR 1
!]RESETH RST_XCVR TCLKA RCLKD R_RESET RD_100 ADR1L_H ADR0L2_L  PNL_RST RST1 RST_LTCH WRT100 NTWK

	IF ( RD_301 AND PE_1 ) NEQ 0		!IS 'PE (1)' CLEAR?
	THEN
		ERR(3);		!NO, REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	WRT 100/200		- ASSERT 'RESET' AND NEGATE 'PE DETECT'
!*	WRT 100/0		- NEGATE 'RESET'
!*RESPONSE:
!*	'PE (1)' IS ASSERTED ALTHOUGH 'PE DETECT' IS NEGATED.
!]ERROR 3
!]PE_LTCH PE NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST2: NOVALUE =

!THIS TEST CHECKS THAT THE 'BUS REQ' FLOP CAN BE ASSERTED AND NEGATED.
!SINCE IN NORMAL OPERATION 'BUS REQ' GETS CLEARED AUTOMATICALLY AFTER
!BEING SET, IT IS NECESSARY TO STOP THE CLOCK IN ORDER TO FREEZE THE
!FLOP IN THE ASSERTED STATE.

	BEGIN
	LOCAL
		ERFLG;
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR0,DR100,RP');

	INIT();					!ASSERT AND NEGATE 'RESET'
	STOP_CLK;				!STOP CLOCK
	ERFLG = 0;		!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT210(0);				!CLEAR BUS REQ
	WRT210(BUS_REQ);			!SET BUS REQ
	IF ( RD_301 AND BUSREQ ) EQL 0	!DID BUS REQ SET?
	THEN
		BEGIN
		ERR(1);		!NO, REPORT ERROR
		ERFLG = 1;	!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRT 205/100	- STOP CLOCK
!*	WRT 210/0	- NEGATE 'BUS REQ'
!*	WRT 210/100	- ASSERT 'BUS REQ'
!*RESPONSE:
!*	'BUS REQ' DIDN'T ASSERT
!]ERROR 1
!]WRT210 RESETB_L BUSREQ GRANT GRANT_1 BUS_ARB BUS_REQ RD_300 ADR0L2_H NTWK

	IF FLP_CHK(1,FLP_PTR)
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT210(0);				!CLEAR BUS REQ
	IF ( RD_301 AND BUSREQ ) NEQ 0	!DID BUS REQ CLEAR?
	THEN
		BEGIN
		ERR(2);		!NO, REPORT ERROR
		ERFLG = 1;	!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	WRT 205/100	- STOP CLOCK
!*	WRT 210/0	- NEGATE 'BUS REQ'
!*	WRT 210/100	- ASSERT 'BUS REQ'
!*	WRT 210/0	- NEGATE 'BUS REQ'
!*RESPONSE:
!*	'BUS REQ' DIDN'T NEGATE
!]ERROR 2
!]BUSREQ WRT210 BUS_REQ RD_300 ADR0L2_H NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERFLG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]RESETB_L BUSREQ BUS_REQ RD_300 ADR0L2_H WRT210 NTWK

	INIT();				!START CLOCK
	END;

GLOBAL ROUTINE TST3: NOVALUE =

!THIS TEST CHECKS THAT 'BUS REQ' GETS NEGATED AUTOMATICALLY AFTER IT IS
!ASSERTED.  ASSERTING 'BUS REQ' SHOULD CAUSE THE BUS ARBITRATOR TO
!GENERATE A 'GRANT' SIGNAL WHICH NEGATES THE 'BUS REQ' FLOP.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR100,RP');

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!ASSERT AND NEGATE 'RESET'
	WRT210(BUS_REQ);			!SET BUS REQ
	IF ( RD_301 AND BUSREQ ) NEQ 0	!DID BUS REQ CLEAR?
	THEN
		ERR(1)		!NO, REPORT ERROR
	ELSE
		NOERR(1);	!YES, DO FAULT ISOLATION ANYWAY
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 210/100	- ASSERT 'BUS REQ'
!*RESPONSE:
!*	'BUS REQ' DIDN'T NEGATE
!]ERROR 1
!]BUSREQ BUS_REQ REQ_CTL GRANT GRANT_1 BUS_ARB TCLKD TCLKC RCLKH RD_300 ADR0L2_H NTWK
!]NO ERROR 1
!]TCLKD TCLKC RCLKH NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST4: NOVALUE =

!THIS TEST CHECKS THAT 'NEXM' ASSERTS IF A BUS REQUEST IS MADE WITH
!'MEM' SET BUT WITHOUT SENDING A MEMORY COMMAND OVER THE BUS.
!AN ERROR WOULD INDICATE A FAILURE IN EITHER THE BUS ARBITRATOR LOGIC
!OR THE NEXM LOGIC.
!AFTER 'NEXM' IS ASSERTED, A 'WRT 114' PULSE IS GENERATED TO NEGATE IT.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR0,LR210,DR300,RP');
	LOCAL
		ERFLG;

	ERFLG = 0;		!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!ASSERT AND NEGATE 'RESET'
	WRT114(0);				!GENERATE WRT 114 PULSE TO CLEAR NEXM
	WRT210(MEM + BUS_REQ);		!SET 'MEM' AND BUS REQ
	IF ( RD_301 AND NEXM ) EQL 0		!DID NEXM SET?
	THEN
		BEGIN
		ERFLG = -1;	!SET ERROR FLAG
		ERR(1)		!NO, REPORT ERROR
		END
	ELSE
		NOERR(1);	!YES, DO FAULT ISOLATION
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/0 (TO NEGATE NEXM)
!*	WRT 210/300	- ASSERT 'MEM' AND 'BUS REQ'.
!*RESPONSE:
!*	'NEXM' DIDN'T ASSERT
!]ERROR 1
!]NEXM NEXM_LTCH RCLKD GRANT_1 MEM RESETL_L WRT210 WRT114 MEM_BUSY  RD_300 ADR0L2_H NTWK
!]NO ERROR 1
!]RESETL_L NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT114(0);				!GENERATE WRT 114 PULSE TO CLEAR NEXM
	IF ( RD_301 AND NEXM ) NEQ 0		!DID NEXM CLEAR?
	THEN
		BEGIN
		ERFLG = -1;	!SET ERROR FLAG
		ERR(2);		!NO, REPORT ERROR
		END;
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/0 (TO NEGATE NEXM)
!*	WRT 210/300	- ASSERT 'MEM' AND 'BUS REQ'
!*	WRT 114/0 (TO NEGATE NEXM)
!*RESPONSE:
!*	'NEXM' DIDN'T NEGATE
!]ERROR 2
!]WRT114 NEXM_LTCH NEXM RD_300 ADR0L2_H NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERFLG EQL 0
	THEN
		NOERR(2);
!]NO ERROR 2
!]NEXM RD_300 ADR0L2_H NTWK

	END;

GLOBAL ROUTINE TST5: NOVALUE =

!THIS TEST CHECKS THAT 'GRANT' IS NOT STUCK TOGGLING, I.E., ASSERTING
!AND NEGATING UNCONTROLLABLY.  THIS COULD HAPPEN IF 'CONSOLE REQ' IS
!STUCK ASSERTED.  THIS FAULT WOULD HAVE CAUSED THE PREVIOUS TEST TO
!FAIL AT NEGATING 'NEXM'.  IT WOULD HAVE ASSERTED AGAIN AUTOMATICALLY
!AFTER BEING NEGATED BY WRT 114.  IN THIS TEST, NEXM IS ASSERTED BUT
!BEFORE WRT 114 IS DONE, A RESET IS DONE.  THIS CLEARS 'MEM', WHICH
!PREVENTS A TOGGLING 'GRANT' FROM REASSERTING NEXM.
!SO, IF THE PREVIOUS TEST FAILS AND THIS ONE DOESN'T THEN 'GRANT' IS
!STUCK TOGGLING.  IF BOTH TESTS FAIL THEN 'GRANT' IS NOT STUCK TOGGLING.
!IF THE PREVIOUS TEST PASSES, THIS TEST WON'T BE RUN.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR300,LR100,DR200,DR0,LR114,DR0,RP');

	INIT();					!ASSERT AND NEGATE 'RESET'
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT210(MEM + BUS_REQ);		!SET 'MEM' AND BUS REQ
	INIT();					!ASSERT AND NEGATE 'RESET'
	WRT114(0);				!GENERATE WRT 114 PULSE TO CLEAR NEXM
	IF ( RD_301 AND NEXM ) NEQ 0		!DID NEXM CLEAR?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 210/300	- ASSERT 'MEM' AND 'BUS REQ'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/0 (TO NEGATE NEXM)
!*RESPONSE:
!*	NEXM DIDN'T NEGATE
!]ERROR 1
!]CONS_REQ NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST6: NOVALUE =

!THIS TEST CHECKS THAT 'NEXM' DOES NOT ASSERT IF 'MEM' IS NOT
!ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR0,LR210,DR100,RP');
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!ASSERT AND NEGATE 'RESET'
	WRT115(0);				!MAKE SURE 'COM/ADR' IS NEGATED
	WRT210(BUS_REQ);			!SET BUS REQ WITHOUT 'MEM'
	IF ( RD_301 AND NEXM ) NEQ 0		!DID NEXM STAY CLEARED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 115/0		- INSURE THAT 'COM/ADR' WILL BE NEGATED
!*	WRT 210/100	- ASSERT 'BUS REQ' WITHOUT 'MEM'.
!*RESPONSE:
!*	NEXM ASSERTED
!]ERROR 1
!]MEMH NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST7: NOVALUE =

!THIS TEST CHECKS THAT ASSERTING 'CLOSE LATCHS' CAUSES 'R CLK ENB' TO
!NEGATE AND VICE-VERSA.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,DR0,RP');
	LOCAL
		ERFLG;

	ERFLG = 0;		!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();			!DO A RESET
	WRT210(0);				!CLEAR CLOSE LATCHS
	WRT210(CLOSE_LATCH);			!SET CLOSE LATCHS
	IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
	THEN
		BEGIN
		ERR(1);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/0	- NEGATE 'CLOSE LATCHS'
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'. THIS SHOULD NEGATE
!*			 'R CLK ENB'.
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T ASSERT
!]ERROR 1
!]TCLKD TCLKB C_LTCH1 RCLK_ENB0 C_LTCHS R_CLK_ENB RD_302 ADR0L6_H NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT210(0);				!CLEAR CLOSE LATCHS
	IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB SET?
	THEN
		BEGIN
		ERR(2);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	WRT 210/0	- NEGATE 'CLOSE LATCHS'
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'. THIS SHOULD NEGATE
!*			 'R CLK ENB'.
!*	WRT 210/0	- NEGATE 'CLOSE LATCHS'. THIS SHOULD ASSERT
!*			  'R CLK ENB'.
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T NEGATE
!]ERROR 2
!]RCLK_ENB0 R_CLK_ENB LTCH_DATA_ENB C_LTCH1 C_LTCHS GRANT BUSREQ RD_302 ADR0L6_H NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	IF .ERFLG NEQ 0		!IF WE HAD NO ERRORS, THEN
	THEN
		NOERR(1);	!DO SOME FAULT ISOLATION
!]NO ERROR 1
!]C_LTCH1 C_LTCHS TCLKD TCLKB RD_302 ADR0L6_H RCLK_ENB0 NTWK

	END;

GLOBAL ROUTINE TST8: NOVALUE =

!THIS TEST CHECKS THAT THE SINGLE PULSING OF THE MAIN CLOCK WORKS.
!TO DO THIS, THE CLOCK IS STOPPED AND 'CLOSE LATCHS' IS ASSERTED.  THEN
!8 CLOCK TICKS ARE GENERATED.  IF 'R CLK ENB' DOESN'T NEGATE, THERE
!IS A FAULT.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	STOP_CLK;				!STOP THE CLOCK
	WRT210(CLOSE_LATCH);			!ASSERT CLOSE LATCHS
	IF ( RD_303 AND R_CLK_ENB0) NEQ 0	!DID 'R CLK ENB' NEGATE?
	THEN
		ERR(1);		!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 205/100	- STOP CLOCK
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'
!*RESPONSE:
!*	'R CLK ENB' NEGATED EVEN THOUGH CLOCK SHOULD HAVE BEEN STOPPED.
!]ERROR 1
!]MNT_ENBL NTWK
	TICK(8);				!GENERATE 8 CLOCK TICKS
	IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB NEGATE?
		THEN NOERR(1)			!YES
		ELSE ERR(2);			!NO
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 205/100	- STOP CLOCK
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'.
!*	GENERATE 8 CLOCK TICKS
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T ASSERT
!]ERROR 2
!]MNT_ENBL MNT_CLK NTWK
!]NO ERROR 1
!]MNT_ENBL MNT_CLK NTWK

	IF LOOP_CHK(2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	INIT();			!DO A RESET

	END;

GLOBAL ROUTINE TST9: NOVALUE =

!THIS TEST CHECKS THAT DOING A RESET WILL NEGATE 'CLOSE LATCHS'.  THE
!NEGATION OF 'CLOSE LATCHS' IS DETECTED BY THE ASSERTION OF 'R CLK ENB'.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,RP');

	INIT();			!DO A RESET
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT210(CLOSE_LATCH);			!SET CLOSE LATCHS
	INIT();					!DO A RESET
	IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB SET?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'. THIS SHOULD ASSERT
!*			  'R CLK ENB (0) H'.
!*	ASSERT AND NEGATE 'RESET'.  THIS SHOULD NEGATE 'CLOSE LATCHS',
!*		WHICH SHOULD CAUSE 'R CLK ENB (0) H' TO NEGATE.
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T NEGATE
!]ERROR 1
!]REG210 RESETB_H NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST10: NOVALUE =

!THIS TEST CHECKS THAT 'R CLK ENB' GETS ASSERTED WHEN 'LATCH DATA (1)'
!IS ASSERTED ALONG WITH A BUS REQUEST.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR103,RP');

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(BUS_REQ + LATCH_DATA + CLOSE_LATCH); !ATTEMPT TO SET R CLK ENB
	IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB SET?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 210/103   - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK
!*		        ENB (0) H'. ASSERTING 'BUS REQ' WILL CAUSE
!*		        'GRANT (1)' TO ASSERT. THIS TOGETHER WITH
!*		        'LATCH DATA SENT' SHOULD CAUSE 'R CLK ENB (0) H'
!*		        TO NEGATE.
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T NEGATE
!]ERROR 1
!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB DATA_ENB RTN_DATA LTCH_DATA GRANT_1 NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST11: NOVALUE =

!THIS TEST CHECKS THAT 'R CLK ENB' DOESN'T ASSERT ON A BUS REQUEST
!WHEN 'LATCH DATA (1)' IS NOT ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR101,RP');
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(BUS_REQ + CLOSE_LATCH);		!DON'T SET LATCH DATA (1)
	IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 210/101  - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK ENB
!*		       (0) H'.  ASSERTING 'BUS REQ' WILL ASSERT 'GRANT
!*		       (1)'.  BUT WITHOUT 'LATCH DATA SENT' ASSERTED,
!*		       'R CLK ENB (0) H' SHOULD STAY ASSERTED.
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T ASSERT
!]ERROR 1
!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB LTCH_DATA C_LTCHS C_LTCH1 NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST12: NOVALUE =

!THIS TEST CHECKS THAT 'R CLK ENB' DOESN'T ASSERT WHEN 'LATCH DATA (1)'
!IS ASSERTED WITHOUT A BUS REQUEST.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR3,RP');

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(LATCH_DATA + CLOSE_LATCH);		!DON'T SET BUS REQ
	IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 210/3  - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK ENB
!*		     (0) H'.  ASSERTING 'LATCH DATA SENT' WITHOUT 'BUS
!*		     REQ' SHOULD NOT CAUSE 'R CLK ENB (0) H' TO NEGATE.
!*RESPONSE:
!*	'R CLK ENB (0) H' NEGATED
!]ERROR 1
!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB GRANT_1 C_LTCHS C_LTCH1 NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST13: NOVALUE =

!THIS TEST CHECKS THAT GENERATING A 'WRT 210' SIGNAL NEGATES THE 'LATCH DATA
!ENB (1)' FLOP.  FIRST, 'R CLK ENB' IS ASSERTED BY ASSERTING 'LATCH DATA
!SENT' WITH A BUS REQUEST.  THEN 'LATCH DATA (1)' IS NEGATED.  THIS
!NEGATION GENERATES THE 'WRT 210' PULSE.  IF THE 'LATCH DATA ENB (1)' FLOP
!NEGATES, THEN 'R CLK ENB' NEGATES.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR103,DR1,RP');
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(BUS_REQ + LATCH_DATA + CLOSE_LATCH); !SET R CLK ENB
	WRT210(CLOSE_LATCH);			!CLEAR LATCH DATA (1)
	IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 210/103   - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK
!*		        ENB (0) H'. ASSERTING 'BUS REQ' WILL CAUSE
!*		        'GRANT (1)' TO ASSERT. THIS TOGETHER WITH
!*		        'LATCH DATA SENT' SHOULD CAUSE 'R CLK ENB (0) H'
!*		        TO NEGATE.
!*	WRT 210/1     - WRITING TO REG 210 SHOULD NEGATE 'LATCH DATA
!*		        SENT'.  THIS SHOULD ASSERT 'R CLK ENB (0) H'.
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T ASSERT
!]ERROR 1
!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB C_LTCH1 C_LTCHS NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST14: NOVALUE =

!THIS TEST CHECKS THAT THE ASSERTION OF 'BUS REQ' CAUSES 'R CLK ENB'
!TO ASSERT.  SINCE 'BUS REQ' IS A PULSE, THE CLOCK IS STOPPED FOR THIS
!TEST AND MAINTENANCE CLOCK PULSES ARE GENERATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR1,DR101,RP');

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!NEGATE 'R CLK ENB'
	SYNC_CLK();				!STOP THE CLOCK AND SYNC IT
	WRT210(BUS_REQ + CLOSE_LATCH);		!SET BUS REQ
	TICK(1);				!GENERATE A T CLK
	IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB ASSERT?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO ASSERT 'R CLK
!*			  ENB (0) H'.
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	WRT 210/101	- ASSERT 'BUS REQ'.
!*	ASSERT T CLK	- THIS SHOULD NEGATE 'R CLK ENB (0) H'.
!*RESPONSE:
!*	'R CLK ENB (0) H' DIDN'T NEGATE
!]ERROR 1
!]R_CLK_ENB NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	INIT();			!DO A RESET
	END;

GLOBAL ROUTINE TST15: NOVALUE =

!THIS TEST CHECKS THAT SINGLE CLOCKING OF THE CPU BOARDS WORKS
!CORRECTLY.  THAT IS, THE SIGNALS 'CRA/M CLK ENABLE' AND 'DPE/M CLK
!ENABLE' ASSERT AND NEGATE AT THE PROPER TIMES.  SINCE THESE SIGNALS
!ARE PULSES, THE TEST IS DONE WITH THE MAIN CLOCK STOPPED USING SINGLE
!CLOCK PULSES.

!FIRST, THE SINGLE CLK FLOP IS ASSERTED AND 2 T-CLK/R-CLK CYCLES
!ARE GENERATED.  BOTH ENABLE SIGNALS SHOULD ASSERT.

	BEGIN
	LOCAL
		CERFLG,
		DERFLG,
		DATA;
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');

	DERFLG = CERFLG = 0;	!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RESET_CRAM();				!DO A CRA/M RESET
	SYNC_CLK();				!STOP CLOCK AND SYNC IT
	WRT206(SINGLE_CLK);			!SETUP FOR SINGLE CLOCKING
	CYCLE(2);				!GENERATE 2 T-CLK/R-CLK CYCLES
	DATA = RD_303;			!GET READ DATA
	IF ( .DATA AND CR_CLK_ENB ) EQL 0	!DID CRA/M CLK ENABLE ASSERT
	THEN
		BEGIN
		ERRM(1);		!NO, REPORT ERROR
		CERFLG = -1;	!SET CRM CLK ENB ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
!*	GENERATE 2 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'CRA/M CLK
!*		ENABLE' TO ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF ( .DATA AND DP_CLK_ENBL ) NEQ 0	!DID DPE/M CLK ENABLE ASSERT?
	THEN
		BEGIN
		ERRM(2);		!NO, REPORT ERROR
		DERFLG = -1;	!SET DPE/M CLK ENB ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
!*	GENERATE 2 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'DPE/M CLK
!*		ENABLE' TO ASSERT.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T ASSERT

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

!NOW GENERATE A 3RD T-CLK/R-CLK CYCLE.  THIS SHOULD NEGATE THE ENABLES.

	CYCLE(1);				!GENERATE T CLK/R CLK CYCLE
	DATA = RD_303;			!GET READ DATA
	IF ( .DATA AND CR_CLK_ENB ) NEQ 0	!DID CRA/M CLK ENABLE NEGATE?
	THEN
		BEGIN
		ERRM(3);		!NO, REPORT ERROR
		CERFLG = -1;	!SET CRM CLK ENB ERROR FLAG
		END;
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'CRA/M CLK
!*		ENABLE' TO ASSERT THEN NEGATE.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T NEGATE

	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF ( .DATA AND DP_CLK_ENBL ) EQL 0	!DID DPE/M CLK ENABLE NEGATE?
	THEN
		BEGIN
		ERRM(4);		!NO, REPORT ERROR
		DERFLG = -1;	!SET DPE/M CLK ENB ERROR FLAG
		END;
!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'DPE/M CLK
!*		ENABLE' TO ASSERT THEN NEGATE.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T NEGATE

	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

!GENERATE A 4TH T CLK/R CLK CYCLE AND CHECK THAT THE ENABLES ARE STILL
!NEGATED.

	CYCLE(1);				!GENERATE T CLK/R CLK CYCLE
	DATA = RD_303;			!GET READ DATA
	IF ( .DATA AND CR_CLK_ENB ) NEQ 0	!DID CRA/M CLK ENABLE NEGATE?
	THEN
		BEGIN
		ERRM(5);		!NO, REPORT ERROR
		CERFLG = -1;	!SET CRM CLK ENB ERROR FLAG
		END;
!*MESSAGE 5
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
!*	GENERATE 4 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'CRA/M CLK
!*		ENABLE' TO ASSERT THEN NEGATE.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T STAY NEGATE

	IF FLP_CHK(5,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF ( .DATA AND DP_CLK_ENBL ) EQL 0	!DID DPE/M CLK ENABLE NEGATE?
	THEN
		BEGIN
		ERRM(6);		!NO, REPORT ERROR
		DERFLG = -1;	!SET DPE/M CLK ENB ERROR FLAG
		END;
!*MESSAGE 6
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
!*	GENERATE 4 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'DPE/M CLK
!*		ENABLE' TO ASSERT THEN NEGATE.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T STAY NEGATED.

	IF FLP_CHK(6,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

!CHECK IF ONLY 'CRA/M CLK ENABLE' FAILED.

	IF (.CERFLG NEQ 0) AND (.DERFLG EQL 0)
	THEN
		FAILURE(1);	!DO FAULT ISOLATION
!]ERROR 1
!]CR_CLK_ENB CLK_ENBS NTWK

!CHECK IF ONLY 'DPE/M CLK ENABLE' FAILED.

	IF (.CERFLG EQL 0) AND (.DERFLG NEQ 0)
	THEN
		FAILURE(2);	!DO FAULT ISOLATION
!]ERROR 2
!]DP_CLK_ENB CLK_ENBS PF_1 NTWK

!CHECK IF BOTH ENABLES FAILED

	IF (.CERFLG NEQ 0) AND (.DERFLG NEQ 0)
	THEN
		FAILURE(3);	!DO FAULT ISOLATION
!]ERROR 3
!]CLK_ENBS ENB SING_CLK CLK_RUN T_CLK WRT206 CSLBUF1 R_CLK NTWK

!CHECK IF WE HAD NO ERRORS

	IF (.CERFLG EQL 0) AND (.DERFLG EQL 0)
	THEN
		NOERR(1);	!DO FAULT ISOLATION
!]NO ERROR 1
!]SING_CLK WRT206 CSLBUF1 T_CLK R_CLK NTWK

	INIT();			!DO A RESET
	END;

GLOBAL ROUTINE TST16: NOVALUE =

!THIS TEST CHECKS THAT 'CRA/M CLK ENABLE' DOESN'T ASSERT IF 'SINGLE CLK'
!AND 'CLK RUN' ARE NEGATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR0,RP');

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RESET_CRAM();				!DO A CRA/M RESET
	SYNC_CLK();				!STOP CLOCK AND SYNC IT
	WRT206(0);				!NEGATE SINGLE CLK AND CLK RUN
	CYCLE(2);				!GENERATE 2 T CLK/R CLK CYCLES
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID CRA/M CLK ENABLE STAY NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	WRT 206/0
!*	GENERATE 2 T-CLK/R-CLK CYCLES. WITH 'SINGLE CLK' AND 'CLK RUN'
!*		NEGATED, 'CRA/M CLK ENABLE' SHOULDN'T ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED
!]ERROR 1
!]SING_CLK CLK_RUN ENB CLK_ENBS CR_CLK_ENB NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	INIT();			!DO A RESET

	END;

GLOBAL ROUTINE TST17: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS CONTROL SIGNALS ('COM/ADR CYCLE',
!ETC.) CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB
!AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR115,DR12,LR114,DR5,LR210,DR140,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR115,DR5,LR114,DR12,LR210,DR140,RP'));
	MAP
		FLP_PTR: VECTOR;

!SETUP BUS BITS 0-11 SO THAT THEY ARE NOT A VALID COMMAND.  SO WHEN
!COM/ADR IS ASSERTED, NOTHING WILL HAPPEN.

	WRT113(%O'10');				!SET BUS BITS 0-3 = 1000
	WRT112(%O'10');				!SET BUS BITS 0-3 = 1000
	WRT111(0);				!CLEAR BUS BITS 4-11
	WRT110(0);				!CLEAR BUS BITS 4-11
	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	SYNC_CLK();				!STOP CLOCK AND SYNC IT
	WRT115(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
	WRT114((NOT .CORRECT) AND %O'17');	!WRITE COMPLEMENT TO DATA LOCS
	WRT210(BUS_REQ + XMIT_ADR);		!SETUP TO CLOCK DATA
	TICK(10);				!CLOCK IT INTO RECEIVER
	ACTUAL = RD_102 AND %O'17';		!GET DATA FROM RECEIVERS
	ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	WRT 115/CORRECT DATA
!*	WRT 114/CORRECT DATA COMPLEMENTED
!*	WRT 210/140
!*	GENERATE 10 CLOCK TICKS
!*RESPONSE:
!*	KS10 BUS CONTROL SIGNALS ARE INCORRECT.  THEY ARE READ BACK
!*	FROM REGISTER 102.
!]ERROR 1
!]R_DATA CMD_XCVR CSLBUF2 NTWK
!]ERROR 2
!]R_IODATA CMD_XCVR CSLBUF0 NTWK
!]ERROR 3
!]R_COMADR CMD_XCVR CSLBUF1 NTWK
!]ERROR 4
!]R_BADATA CMD_XCVR CSLBUF3 NTWK
!]ERROR 5
!]ADR0L6_L DATA_CYC STAT_RD X_D1 XMIT_DATA CMD_XCVR NTWK
!]ERROR 6
!]WRT114 RD_100 ADR0L6_L ADR1L_H CMD_XCVR T_ENB XMIT_ADR NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]RD_100 ADR0L6_L ADR1L_H NTWK

!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS

	WRT114(0);
	WRT115(0);
	INIT();			!DO A RESET

	END;

GLOBAL ROUTINE TST18: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS CONTROL SIGNALS ('COM/ADR CYCLE',
!ETC.) CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB
!AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR12,LR115,DR5,LR210,DR140,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR5,LR115,DR12,LR210,DR140,RP'));
	MAP
		FLP_PTR: VECTOR;

!SETUP BUS BITS 0-11 SO THAT THEY ARE NOT A VALID COMMAND.  SO WHEN
!COM/ADR IS ASSERTED, NOTHING WILL HAPPEN.

	WRT113(%O'10');				!SET BUS BITS 0-3 = 1000
	WRT112(%O'10');				!SET BUS BITS 0-3 = 1000
	WRT111(0);				!CLEAR BUS BITS 4-11
	WRT110(0);				!CLEAR BUS BITS 4-11
	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	SYNC_CLK();				!STOP CLOCK AND SYNC IT
	WRT114(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
	WRT115((NOT .CORRECT) AND %O'17');	!WRITE COMPLEMENT TO COM/ADR LOCS
	WRT210(BUS_REQ + XMIT_DATA);		!SETUP TO CLOCK DATA
	TICK(14);				!CLOCK IT INTO RECEIVER
	ACTUAL = RD_102 AND %O'17';		!GET DATA FROM RECEIVERS
	ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
!*	WRT 114/CORRECT DATA
!*	WRT 115/CORRECT DATA COMPLEMENTED
!*	WRT 210/120
!*	GENERATE 10 CLOCK TICKS
!*RESPONSE:
!*	KS10 BUS CONTROL SIGNALS ARE INCORRECT.  THEY ARE READ BACK
!*	FROM REGISTER 102.
!]ERROR 1
!]R_DATA CMD_XCVR CSLBUF2 NTWK
!]ERROR 2
!]R_IODATA CMD_XCVR CSLBUF0 NTWK
!]ERROR 3
!]R_COMADR CMD_XCVR CSLBUF1 NTWK
!]ERROR 4
!]R_BADATA CMD_XCVR CSLBUF3 NTWK
!]ERROR 5
!]ADR0L6_H DATA_CYC CMD_XCVR NTWK
!]ERROR 6
!]WRT114 RD_100 ADR0L6_L ADR1L_H CMD_XCVR T_ENB XMIT_DATA NTWK
	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]RD_100 ADR0L6_L ADR1L_H ADR0L6_H NTWK

!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS

	WRT114(0);
	WRT115(0);
	INIT();			!DO A RESET

	END;

GLOBAL ROUTINE TST19: NOVALUE =

!THIS TEST CHECKS THAT 'DATA ACK' ASSERTS AND 'R CLK ENB' NEGATES WHEN
!A BUS REQUEST IS MADE WITH 'MEM' AND 'R DATA' ASSERTED.


	BEGIN
	LOCAL
		ERFLG;
	LABEL BLOCK1;
	BIND
		FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP'),
		FLP_PTR2 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP');

	ERFLG = 0;		!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
	WRT114(DATA_CYCLE);			!LOAD I/O BUFFER SO 'R DATA' WILL ASSERT
	WRT210(MEM + BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
	IF ( RD_301 AND DATA_ACK ) EQL 0	!DID 'DATA ACK' ASSERT?
	THEN
		BEGIN
		ERR(1);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)'.
!*			- 'R DATA' AND 'MEM' WILL ASSERT 'RETURN DATA'
!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL ASSERT
!*			  'DATA ACK'.
!*RESPONSE:
!*	'DATA ACK' DIDN'T ASSERT
!]ERROR 1
!]DATAACK RD_0 DATA_ACK DATA_ENB R_CLK_L RTN_DATA MEMH NTWK

	IF FLP_CHK(1,FLP_PTR1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID 'R CLK ENB' NEGATE?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
!*			  'R CLK ENB'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
!*			  ASSERT 'R CLK ENB'
!*			- 'R DATA' AND 'MEM' WILL ASSERT 'RETURN DATA'
!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL NEGATE
!*			  'R CLK ENB'.
!*RESPONSE:
!*	'R CLK ENB' DIDN'T NEGATE
!]ERROR 2
!]R_CLK_L DATA_ENB RTN_DATA NTWK

	IF FLP_CHK(2,FLP_PTR2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	RD_0;				!NEGATE 'DATA ACK'
	IF (RD_301 AND DATA_ACK) NEQ 0	!DID 'DATA ACK' NEGATE?
	THEN
		BEGIN
		ERR(3);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)'.
!*			- 'R DATA' AND 'MEM' WILL ASSERT 'RETURN DATA'
!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL ASSERT
!*			  'DATA ACK'.
!*	RD 0		- TO NEGATE 'DATA ACK'
!*RESPONSE:
!*	'DATA ACK' DIDN'T NEGATE.
!]ERROR 3
!]DATA_ACK DATA_ENB RD_0 DATAACK NTWK
	IF FLP_CHK(3,FLP_PTR1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

!IF WE HAD NO ERROR FOR 'DATA ACK' THEN DO FAULT ISOLATION

	IF .ERFLG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]R_CLK_L MEMH DATA_ACK DATAACK RD_0 NTWK

	END;

GLOBAL ROUTINE TST20: NOVALUE =

!THIS TEST CHECKS THAT 'DATA ACK' ASSERTS AND 'R CLK ENB' NEGATES WHEN
!A BUS REQUEST IS MADE WITH 'R I/O DATA' ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR123,RP'),
		FLP_PTR2 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR123,RP');
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
	WRT114(IO_DATA);			!LOAD I/O BUFFER SO 'R I/O DATA' WILL ASSERT
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
	IF ( RD_301 AND DATA_ACK ) EQL 0	!DID 'DATA ACK' ASSERT?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/2	- SO 'R I/O DATA' WILL ASSERT
!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)'.
!*			- 'R I/O DATA' WILL ASSERT 'RETURN DATA'
!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL ASSERT
!*			  'DATA ACK'.
!*RESPONSE:
!*	'DATA ACK' DIDN'T ASSERT
!]ERROR 1
!]DATAACK RD_0 DATA_ACK DATA_ENB R_CLK_L RTN_DATA NTWK

	IF FLP_CHK(1,FLP_PTR1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID 'R CLK ENB' NEGATE?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/2	- SO 'R I/O DATA' WILL ASSERT
!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
!*			  'R CLK ENB'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
!*			  ASSERT 'R CLK ENB'
!*			- 'R I/O DATA' WILL ASSERT 'RETURN DATA'
!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL NEGATE
!*			  'R CLK ENB'.
!*RESPONSE:
!*	'R CLK ENB' DIDN'T NEGATE
!]ERROR 2
!]R_CLK_L DATA_ENB RTN_DATA NTWK

	IF FLP_CHK(2,FLP_PTR2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST21: NOVALUE =

!THIS TEST CHECKS THAT 'DATA ACK' DOESN'T ASSERT AND 'R CLK ENB'
!DOESN'T NEGATE WHEN A BUS REQUEST IS MADE WITH 'MEM' AND 'R I/O DATA'
!NEGATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR123,RP');
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
	WRT114(DATA_CYCLE);			!LOAD I/O BUFFER SO 'R DATA' WILL ASSERT
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
	IF ( RD_301 AND DATA_ACK ) NEQ 0	!IS 'DATA ACK' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)'.
!*			- WITH 'MEM' AND 'R I/O DATA' NEGATED, 'RETURN
!*			  DATA' SHOULD NOT ASSERT.
!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
!*			  NOT ASSERT AND THEREFORE 'DATA ACK' WILL NOT
!*			  ASSERT.
!*RESPONSE:
!*	'DATA ACK' ASSERTED
!]ERROR 1
!]RTN_DATA DATA_ENB DATA_ACK DATAACK NTWK

	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID 'R CLK ENB' ASSERT?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
!*			  'R CLK ENB'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
!*			  ASSERT 'R CLK ENB'
!*			- WITH 'MEM' AND 'R I/O DATA' NEGATED, 'RETURN
!*			  DATA' SHOULD NOT ASSERT.
!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
!*			  NOT ASSERT AND THEREFORE 'R CLK ENB' WILL NOT
!*			  NEGATE.
!*RESPONSE:
!*	'R CLK ENB' NEGATED
!]ERROR 2
!]RTN_DATA DATA_ENB NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST22: NOVALUE =

!THIS TEST CHECKS THAT 'DATA ACK' DOESN'T ASSERT AND 'R CLK ENB'
!DOESN'T NEGATE WHEN A BUS REQUEST IS MADE WITH 'R DATA' AND
!'R I/O DATA' NEGATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP'),
		FLP_PTR2 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP');
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
	WRT114(0);				!LOAD I/O BUFFER SO 'R DATA' AND
						!'R I/O DATA' WILL NEGATE
	WRT210(MEM + BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
	IF ( RD_301 AND DATA_ACK ) NEQ 0	!IS 'DATA ACK' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/0	- SO 'R DATA' AND 'R I/O DATA' WILL NEGATE
!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)'.
!*			- WITH 'R DATA' AND 'R I/O DATA' NEGATED,
!*			  'RETURN DATA' SHOULD NOT ASSERT.
!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
!*			  NOT ASSERT AND THEREFORE 'DATA ACK' WILL NOT
!*			  ASSERT.
!*RESPONSE:
!*	'DATA ACK' ASSERTED
!]ERROR 1
!]RTN_DATA DATA_ENB DATA_ACK DATAACK NTWK

	IF FLP_CHK(1,FLP_PTR1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID 'R CLK ENB' ASSERT?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/0	- SO 'R DATA' AND 'R I/O DATA' WILL NEGATE
!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
!*			  'R CLK ENB'
!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
!*			  ASSERT 'R CLK ENB'
!*			- WITH 'R DATA' AND 'R I/O DATA' NEGATED,
!*			  'RETURN DATA' SHOULD NOT ASSERT.
!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
!*			  NOT ASSERT AND THEREFORE 'R CLK ENB' WILL NOT
!*			  NEGATE.
!*RESPONSE:
!*	'R CLK ENB' NEGATED
!]ERROR 2
!]RTN_DATA DATA_ENB NTWK

	IF FLP_CHK(2,FLP_PTR2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST23: NOVALUE =

!THIS TEST CHECKS THAT 'DATA ACK' DOESN'T ASSERT WHEN A BUS REQUEST IS
!MADE WITH 'LATCH DATA (1)' NEGATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR121,RP');
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
	WRT114(IO_DATA);			!LOAD I/O BUFFER SO 'R I/O DATA' WILL ASSERT
	WRT210(BUS_REQ + XMIT_DATA + CLOSE_LATCH); !START BUS REQUEST
	IF ( RD_301 AND DATA_ACK ) NEQ 0	!IS 'DATA ACK' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	RD 0		- TO NEGATE 'DATA ACK'
!*	WRT 114/2	- SO 'R I/O DATA' WILL ASSERT
!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
!*			- WITH 'LATCH DATA (1)' NEGATED, 'LATCH DATA
!*			  ENB (1)' WILL NOT ASSERT.
!*			- 'R I/O DATA' WILL ASSERT 'RETURN DATA'
!*			- WITH 'LATCH DATA ENB (1)' NEGATED, 'DATA ENB'
!*			  WILL NOT ASSERT AND THEREFORE 'DATA ACK' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'DATA ACK' ASSERTED
!]ERROR 1
!]DATA_ENB DATA_ACK DATAACK NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST24: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 00-03'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR113,DR12,LR112,DR5,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR113,DR5,LR112,DR12,LR210,DR141,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT113(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
	WRT112((NOT .CORRECT) AND %O'17');	!WRITE COMPLEMENT TO DATA LOCS
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH);	!CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_103 AND %O'17';		!GET DATA FROM RECEIVERS
	ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 113/CORRECT DATA
!*	WRT 112/CORRECT DATA COMPLEMENTED
!*	WRT 210/141
!*RESPONSE:
!*	'R DATA 00-03' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_03 BUS0_3 CSLBUF0 NTWK
!]ERROR 2
!]RDATA_02 BUS0_3 CSLBUF1 NTWK
!]ERROR 3
!]RDATA_01 BUS0_3 CSLBUF2 NTWK
!]ERROR 4
!]RDATA_00 BUS0_3 CSLBUF3 NTWK
!]ERROR 5
!]ADR0L6_L DATA_CYC STAT_RD X_D1 XMIT_DATA BUS0_3 NTWK
!]ERROR 6
!]WRT112 R_CLK_B RD_0 ADR0L6_H ADR1L_H BUS0_3 T_ENB XMIT_ADR NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]RD_0 ADR0L6_H ADR0L6_L WRT112 R_CLK_B NTWK

	END;

GLOBAL ROUTINE TST25: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 00-03'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR112,DR12,LR113,DR5,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR112,DR5,LR113,DR12,LR210,DR123,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 1 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
	WRT112(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
	WRT113((NOT .CORRECT) AND %O'17');	!WRITE THAT TO COM/ADR LOCS
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_103 AND %O'17';		!GET DATA FROM RECEIVERS
	ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/2		- LOAD BUFFER SO 'R I/O DATA' ASSERTS
!*	WRT 112/CORRECT DATA
!*	WRT 113/CORRECT DATA COMPLEMENTED
!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
!*				  AND 'DATA CYCLE'.  THIS GATES THE
!*				  CONTENTS OF THE DATA LOCATIONS ONTO
!*				  THE KS10 BUS.
!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
!*RESPONSE:
!*	'R DATA 00-03' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_03 BUS0_3 CSLBUF0 NTWK
!]ERROR 2
!]RDATA_02 BUS0_3 CSLBUF1 NTWK
!]ERROR 3
!]RDATA_01 BUS0_3 CSLBUF2 NTWK
!]ERROR 4
!]RDATA_00 BUS0_3 CSLBUF3 NTWK
!]ERROR 5
!]ADR0L6_H DATA_CYC BUS0_3 NTWK
!]ERROR 6
!]WRT112 R_CLK_B RD_0 ADR0L6_H ADR1L_H BUS0_3 T_ENB XMIT_DATA X_D1 NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]RD_0 ADR0L6_H ADR0L6_L WRT112 R_CLK_B NTWK

	END;

GLOBAL ROUTINE TST26: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 04-11'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR252,LR110,DR125,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR125,LR110,DR252,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR63,LR110,DR314,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR314,LR110,DR63,LR210,DR141,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT111(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
	WRT110((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_3 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 111/CORRECT DATA
!*	WRT 110/CORRECT DATA COMPLEMENTED
!*	WRT 210/141
!*RESPONSE:
!*	'R DATA 04-11' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_11 NTWK
!]ERROR 2
!]RDATA_10 NTWK
!]ERROR 3
!]RDATA_09 NTWK
!]ERROR 4
!]RDATA_08 NTWK
!]ERROR 5
!]RDATA_07 NTWK
!]ERROR 6
!]RDATA_06 NTWK
!]ERROR 7
!]RDATA_05 NTWK
!]ERROR 8
!]RDATA_04 NTWK
!]ERROR 9
!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
!]ERROR 10
!]BUS4_7 NTWK
!]ERROR 11
!]ADR0L6_L BUS8_11 NTWK
!]ERROR 12
!]BUS4_7 NTWK
!]ERROR 13
!]BUS8_11 NTWK
!]ERROR 14
!]WRT110 RD_0 T_ENB XMIT_ADR R_CLK_B NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]R_CLK_B RD_0 WRT110 ADR0L6_L NTWK

	END;

GLOBAL ROUTINE TST27: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 04-11'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR252,LR111,DR125,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR125,LR111,DR252,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR63,LR111,DR314,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR314,LR111,DR63,LR210,DR123,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
	WRT110(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
	WRT111((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_3 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
!*	WRT 110/CORRECT DATA
!*	WRT 111/CORRECT DATA COMPLEMENTED
!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
!*				  AND 'DATA CYCLE'.  THIS GATES THE
!*				  CONTENTS OF THE DATA LOCATIONS ONTO
!*				  THE KS10 BUS.
!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_11 NTWK
!]ERROR 2
!]RDATA_10 NTWK
!]ERROR 3
!]RDATA_09 NTWK
!]ERROR 4
!]RDATA_08 NTWK
!]ERROR 5
!]RDATA_07 NTWK
!]ERROR 6
!]RDATA_06 NTWK
!]ERROR 7
!]RDATA_05 NTWK
!]ERROR 8
!]RDATA_04 NTWK
!]ERROR 9
!]DATA_CYC NTWK
!]ERROR 10
!]BUS4_7 NTWK
!]ERROR 11
!]BUS8_11 NTWK
!]ERROR 12
!]BUS4_7 NTWK
!]ERROR 13
!]ADR0L6_L BUS8_11 NTWK
!]ERROR 14
!]WRT110 RD_0 T_ENB XMIT_DATA X_D1 R_CLK_B NTWK
	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]ADR0L6_L RD_0 WRT110 R_CLK_B NTWK

	END;

GLOBAL ROUTINE TST28: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 12-19'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR252,LR106,DR125,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR125,LR106,DR252,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR63,LR106,DR314,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR314,LR106,DR63,LR210,DR141,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT107(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
	WRT106((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_2 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/CORRECT DATA
!*	WRT 106/CORRECT DATA COMPLEMENTED
!*	WRT 210/141
!*RESPONSE:
!*	'R DATA 12-19' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_19 NTWK
!]ERROR 2
!]RDATA_18 NTWK
!]ERROR 3
!]RDATA_17 NTWK
!]ERROR 4
!]RDATA_16 NTWK
!]ERROR 5
!]RDATA_15 NTWK
!]ERROR 6
!]RDATA_14 NTWK
!]ERROR 7
!]RDATA_13 NTWK
!]ERROR 8
!]RDATA_12 NTWK
!]ERROR 9
!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
!]ERROR 10
!]BUS12_15 NTWK
!]ERROR 11
!]ADR0L6_L BUS16_19 NTWK
!]ERROR 12
!]T_ENB R_CLK_B BUS12_15 NTWK
!]ERROR 13
!]T_ENB_A R_CLK_A BUS16_19 NTWK
!]ERROR 14
!]WRT106 RD_0 NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]ADR0L6_L RD_0 WRT106 R_CLK_B R_CLK_A NTWK

	END;

GLOBAL ROUTINE TST29: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 12-19'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR252,LR107,DR125,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR125,LR107,DR252,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR63,LR107,DR314,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR314,LR107,DR63,LR210,DR123,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
	WRT106(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
	WRT107((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_2 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);		!GO COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
!*	WRT 106/CORRECT DATA
!*	WRT 107/CORRECT DATA COMPLEMENTED
!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
!*				  AND 'DATA CYCLE'.  THIS GATES THE
!*				  CONTENTS OF THE DATA LOCATIONS ONTO
!*				  THE KS10 BUS.
!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
!*RESPONSE:
!*	'R DATA 12-19' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_19 NTWK
!]ERROR 2
!]RDATA_18 NTWK
!]ERROR 3
!]RDATA_17 NTWK
!]ERROR 4
!]RDATA_16 NTWK
!]ERROR 5
!]RDATA_15 NTWK
!]ERROR 6
!]RDATA_14 NTWK
!]ERROR 7
!]RDATA_13 NTWK
!]ERROR 8
!]RDATA_12 NTWK
!]ERROR 9
!]DATA_CYC NTWK
!]ERROR 10
!]BUS12_15 NTWK
!]ERROR 11
!]BUS16_19 NTWK
!]ERROR 12
!]T_ENB R_CLK_B BUS12_15 NTWK
!]ERROR 13
!]ADR0L6_L T_ENB_A R_CLK_A BUS16_19 NTWK
!]ERROR 14
!]WRT106 RD_0 NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]ADR0L6_L RD_0 WRT106 R_CLK_B R_CLK_A NTWK

	END;

GLOBAL ROUTINE TST30: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 20-27'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR252,LR104,DR125,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR125,LR104,DR252,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR63,LR104,DR314,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR314,LR104,DR63,LR210,DR141,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT105(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
	WRT104((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_1 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 105/CORRECT DATA
!*	WRT 104/CORRECT DATA COMPLEMENTED
!*	WRT 210/141
!*RESPONSE:
!*	'R DATA 20-27' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_27 NTWK
!]ERROR 2
!]RDATA_26 NTWK
!]ERROR 3
!]RDATA_25 NTWK
!]ERROR 4
!]RDATA_24 NTWK
!]ERROR 5
!]RDATA_23 NTWK
!]ERROR 6
!]RDATA_22 NTWK
!]ERROR 7
!]RDATA_21 NTWK
!]ERROR 8
!]RDATA_20 NTWK
!]ERROR 9
!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
!]ERROR 10
!]BUS20_23 NTWK
!]ERROR 11
!]ADR0L6_L BUS24_27 NTWK
!]ERROR 12
!]BUS20_23 NTWK
!]ERROR 13
!]BUS24_27 NTWK
!]ERROR 14
!]R_CLK_A T_ENB_A WRT104 RD_0 NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]ADR0L6_L RD_0 WRT104 R_CLK_A NTWK

	END;

GLOBAL ROUTINE TST31: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 20-27'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR252,LR105,DR125,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR125,LR105,DR252,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR63,LR105,DR314,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR314,LR105,DR63,LR210,DR123,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
	WRT104(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
	WRT105((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_1 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
!*	WRT 104/CORRECT DATA
!*	WRT 105/CORRECT DATA COMPLEMENTED
!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
!*				  AND 'DATA CYCLE'.  THIS GATES THE
!*				  CONTENTS OF THE DATA LOCATIONS ONTO
!*				  THE KS10 BUS.
!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
!*RESPONSE:
!*	'R DATA 20-27' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_27 NTWK
!]ERROR 2
!]RDATA_26 NTWK
!]ERROR 3
!]RDATA_25 NTWK
!]ERROR 4
!]RDATA_24 NTWK
!]ERROR 5
!]RDATA_23 NTWK
!]ERROR 6
!]RDATA_22 NTWK
!]ERROR 7
!]RDATA_21 NTWK
!]ERROR 8
!]RDATA_20 NTWK
!]ERROR 9
!]DATA_CYC NTWK
!]ERROR 10
!]BUS20_23 NTWK
!]ERROR 11
!]BUS24_27 NTWK
!]ERROR 12
!]BUS20_23 NTWK
!]ERROR 13
!]ADR0L6_L BUS24_27 NTWK
!]ERROR 14
!]R_CLK_A T_ENB_A WRT104 RD_0 NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]ADR0L6_L RD_0 WRT104 R_CLK_A NTWK

	END;

GLOBAL ROUTINE TST32: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 28-35'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR252,LR102,DR125,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR125,LR102,DR252,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR63,LR102,DR314,LR210,DR141,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR314,LR102,DR63,LR210,DR141,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT103(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
	WRT104((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_0 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/CORRECT DATA
!*	WRT 102/CORRECT DATA COMPLEMENTED
!*	WRT 210/141
!*RESPONSE:
!*	'R DATA 28-35' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_35 NTWK
!]ERROR 2
!]RDATA_34 NTWK
!]ERROR 3
!]RDATA_33 NTWK
!]ERROR 4
!]RDATA_32 NTWK
!]ERROR 5
!]RDATA_31 NTWK
!]ERROR 6
!]RDATA_30 NTWK
!]ERROR 7
!]RDATA_29 NTWK
!]ERROR 8
!]RDATA_28 NTWK
!]ERROR 9
!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
!]ERROR 10
!]BUS28_31 NTWK
!]ERROR 11
!]ADR0L6_L BUS32_35 NTWK
!]ERROR 12
!]BUS28_31 NTWK
!]ERROR 13
!]BUS32_35 NTWK
!]ERROR 14
!]R_CLK_A T_ENB_A WRT102 RD_0 NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]RD_0 WRT102 ADR0L6_L R_CLK_A NTWK

	END;

GLOBAL ROUTINE TST33: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 28-35'
!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
!R CLK ENB AND DATA CYCLE.

	BEGIN
	LOCAL
		CORRECT,
		ACTUAL;
	OWN
		DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR252,LR103,DR125,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR125,LR103,DR252,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR63,LR103,DR314,LR210,DR123,RP'),
				UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR314,LR103,DR63,LR210,DR123,RP'));
	MAP
		FLP_PTR: VECTOR;

	ERROR_FLAG = 0;		!INIT ERROR FLAG
	INCR I FROM 0 TO 3 BY 1 DO
	BEGIN
	CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
	WRT102(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
	WRT103((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
	ACTUAL = RD_0 AND %O'377';		!GET DATA FROM RECEIVERS
	ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
!*	WRT 102/CORRECT DATA
!*	WRT 103/CORRECT DATA COMPLEMENTED
!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
!*				  AND 'DATA CYCLE'.  THIS GATES THE
!*				  CONTENTS OF THE DATA LOCATIONS ONTO
!*				  THE KS10 BUS.
!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
!*RESPONSE:
!*	'R DATA 28-35' DID NOT GET GATED ONTO THE BUS CORRECTLY.
!]ERROR 1
!]RDATA_35 NTWK
!]ERROR 2
!]RDATA_34 NTWK
!]ERROR 3
!]RDATA_33 NTWK
!]ERROR 4
!]RDATA_32 NTWK
!]ERROR 5
!]RDATA_31 NTWK
!]ERROR 6
!]RDATA_30 NTWK
!]ERROR 7
!]RDATA_29 NTWK
!]ERROR 8
!]RDATA_28 NTWK
!]ERROR 9
!]DATA_CYC NTWK
!]ERROR 10
!]BUS28_31 NTWK
!]ERROR 11
!]BUS32_35 NTWK
!]ERROR 12
!]BUS28_31 NTWK
!]ERROR 13
!]ADR0L6_L BUS32_35 NTWK
!]ERROR 14
!]R_CLK_A T_ENB_A WRT102 RD_0 NTWK

	IF FLP_CHK(1,.FLP_PTR[.I])
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION

	IF .ERROR_FLAG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]RD_0 WRT102 ADR0L6_L R_CLK_A NTWK

	END;

GLOBAL ROUTINE TST34: NOVALUE =

!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' ISN'T
!STUCK ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR1,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT106(%O'252');			!WRITE DATA TO DATA LOC
	WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
	WRT210(CLOSE_LATCH);			!CLOSE THE TRANSCEIVER LATCHES
	DATA = RD_2 AND %O'377';		!READ R DATA 12-19
	IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
		THEN ERRCA(1,0,.DATA,3);	!YES
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
!*	THEY SHOULDN'T HAVE BEEN.
!]ERROR 1
!]XMIT_ENBS NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
		THEN ERRCA(2,0,.DATA,3);	!YES
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
!*	HAVE BEEN.
!]ERROR 2
!]XMIT_ENBS NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL %O'120'			!WERE BITS 12-15 TRANSMITTED?
		THEN ERRCA(3,0,.DATA,3);	!YES
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
!]ERROR 3
!]XMIT_ENBS NTWK

	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
		THEN ERRCA(4,0,.DATA,3);	!YES
!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
!]ERROR 4
!]XMIT_ENBS NTWK

	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST35: NOVALUE =

!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' DON'T
!ASSERT WHEN 'XMIT DATA (1)' AND 'XMIT ADR (1)' ARE NEGATED DURING
!A BUS REQUEST.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR101,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT106(%O'252');			!WRITE DATA TO DATA LOC
	WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
	WRT210(BUS_REQ + CLOSE_LATCH);		!GENERATE BUS REQUEST AND CLOSE LATCHES
	DATA = RD_2 AND %O'377';		!READ R DATA 12-19
	IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
		THEN ERRCA(1,0,.DATA,3);	!YES
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
!*	THEY SHOULDN'T HAVE BEEN.
!]ERROR 1
!]XMIT_ENBS NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
		THEN ERRCA(2,0,.DATA,3);	!YES
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
!*	HAVE BEEN.
!]ERROR 2
!]XMIT_ENBS NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL 120			!WERE BITS 12-15 TRANSMITTED?
		THEN ERRCA(3,0,.DATA,3);	!YES
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
!]ERROR 3
!]XMIT_ENBS NTWK

	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
		THEN ERRCA(4,0,.DATA,3);	!YES
!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
!]ERROR 4
!]XMIT_ENBS NTWK

	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST36: NOVALUE =

!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' DON'T
!ASSERT WHEN 'XMIT DATA (1)' IS ASSERTED WITHOUT A BUS REQUEST.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR20,DR21,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT106(%O'252');			!WRITE DATA TO DATA LOC
	WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
	WRT210(XMIT_DATA);			!ASSERT 'XMIT DATA (1)'
	WRT210(XMIT_DATA + CLOSE_LATCH);	!NOW CLOSE THE LATCHES
	DATA = RD_2 AND %O'377';		!READ R DATA 12-19
	IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
		THEN ERRCA(1,0,.DATA,3);	!YES
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
!*	THEY SHOULDN'T HAVE BEEN.
!]ERROR 1
!]XMIT_ENBS NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
		THEN ERRCA(2,0,.DATA,3);	!YES
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
!*	HAVE BEEN.
!]ERROR 2
!]XMIT_ENBS NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL 120			!WERE BITS 12-15 TRANSMITTED?
		THEN ERRCA(3,0,.DATA,3);	!YES
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
!]ERROR 3
!]XMIT_ENBS NTWK

	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
		THEN ERRCA(4,0,.DATA,3);	!YES
!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
!]ERROR 4
!]XMIT_ENBS NTWK

	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST37: NOVALUE =

!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' DON'T
!ASSERT WHEN 'XMIT ADR (1)' IS ASSERTED WITHOUT A BUS REQUEST.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR40,DR41,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT106(%O'252');			!WRITE DATA TO DATA LOC
	WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
	WRT210(XMIT_ADR);			!ASSERT 'XMIT ADR (1)'
	WRT210(XMIT_ADR + CLOSE_LATCH);		!NOW CLOSE THE LATCHES
	DATA = RD_2 AND %O'377';		!READ R DATA 12-19
	IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
		THEN ERRCA(1,0,.DATA,3);	!YES
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
!*	THEY SHOULDN'T HAVE BEEN.
!]ERROR 1
!]XMIT_ENBS NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
		THEN ERRCA(2,0,.DATA,3);	!YES
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
!*	HAVE BEEN.
!]ERROR 2
!]XMIT_ENBS NTWK

	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL 120			!WERE BITS 12-15 TRANSMITTED?
		THEN ERRCA(3,0,.DATA,3);	!YES
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
!]ERROR 3
!]XMIT_ENBS NTWK

	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
		THEN ERRCA(4,0,.DATA,3);	!YES
!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
!*			  ALL ZEROS SHOULD BE TRANSMITTED.
!*RESPONSE:
!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
!]ERROR 4
!]XMIT_ENBS NTWK

	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST38: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' ASSERTS WHEN 'R COM/ADR' ASSERTS
!WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' ASSERTED AND 'R DATA 19'
!ASSERTED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
	WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 04-11'
	IF .DATA NEQ %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,%O'63',.DATA,3);	!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS.  THE 4TH CYCLE
!*			  WILL ASSERT 'STATUS RD (1)', WHICH WILL ASSERT
!*			  'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE 5TH
!*			  CYCLE SHOULD CLOCK THE DATA FROM THE DATA
!*			  LOCS ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS NOT THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS NOT ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST39: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
!ASSERTS WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' ASSERTED AND
!'R DATA 19' NEGATED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(0);				!NEGATE 'R DATA 19' IN COM/ADR LOC
	WRT106(0);				!NEGATE 'R DATA 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 04-11'
	IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/0	- NEGATE 'R DATA 19' IN COM/ADR LOC
!*	WRT 106/0	- NEGATE 'R DATA 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 19'
!*			  NEGATED, 'STATUS RD (1)' WILL NOT ASSERT ON
!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
!*			  ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST40: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
!ASSERTS WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' NEGATED AND
!'R DATA 19' ASSERTED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
	WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
	WRT113(0);				!NEGATE 'R DATA 00' IN COM/ADR LOC
	WRT112(0);				!NEGATE 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 4-11'
	IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
!*	WRT 113/0	- NEGATE 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/0	- NEGATE 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 00'
!*			  NEGATED, 'STATUS RD (1)' WILL NOT ASSERT ON
!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
!*			  ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST41: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WITH 'R COM/ADR'
!NEGATED WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' ASSERTED AND
!'R DATA 19' ASSERTED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
	WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(0);				!NEGATE 'R COM/ADR' IN COM/ADR LOC
	WRT114(0);				!NEGATE 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 04-11'
	IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/0	- NEGATE 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/0	- NEGATE 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS. WITH 'R COM/ADR'
!*			  NEGATED, 'STATUS RD (1)' WILL NOT ASSERT ON
!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
!*			  ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);

	END;

GLOBAL ROUTINE TST42: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
!ASSERTS WITH 'R DATA 14-17' = 10, 'R DATA 00' ASSERTED AND
!'R DATA 19' NEGATED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(%O'41');				!ASSERT 'R DATA 14 AND 19' IN COM/ADR LOC
	WRT106(%O'41');				!ASSERT 'R DATA 14 AND 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 04-11'
	IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/41	- ASSERT 'R DATA 14 AND 19' IN COM/ADR LOC
!*	WRT 106/41	- ASSERT 'R DATA 14 AND 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 14'
!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
!*			  ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST43: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
!ASSERTS WITH 'R DATA 14-17' = 4, 'R DATA 00' ASSERTED AND
!'R DATA 19' NEGATED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(%O'21');				!ASSERT 'R DATA 15 AND 19' IN COM/ADR LOC
	WRT106(%O'21');				!ASSERT 'R DATA 15 AND 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 04-11'
	IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/21	- ASSERT 'R DATA 15 AND 19' IN COM/ADR LOC
!*	WRT 106/21	- ASSERT 'R DATA 15 AND 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 15'
!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
!*			  ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST44: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
!ASSERTS WITH 'R DATA 14-17' = 2, 'R DATA 00' ASSERTED AND
!'R DATA 19' NEGATED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(%O'11');				!ASSERT 'R DATA 16 AND 19' IN COM/ADR LOC
	WRT106(%O'11');				!ASSERT 'R DATA 16 AND 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 04-11'
	IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/11	- ASSERT 'R DATA 16 AND 19' IN COM/ADR LOC
!*	WRT 106/11	- ASSERT 'R DATA 16 AND 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 16'
!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
!*			  ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST45: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
!ASSERTS WITH 'R DATA 14-17' = 1, 'R DATA 00' ASSERTED AND
!'R DATA 19' NEGATED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(5);				!ASSERT 'R DATA 17 AND 19' IN COM/ADR LOC
	WRT106(5);				!ASSERT 'R DATA 17 AND 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(%O'63');				!WRITE DATA TO 110
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	DATA = RD_3;				!READ 'R DATA 04-11'
	IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
	THEN
		ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/5	- ASSERT 'R DATA 17 AND 19' IN COM/ADR LOC
!*	WRT 106/5	- ASSERT 'R DATA 17 AND 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/63	- PUT TEST DATA IN BUFFER
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 17'
!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
!*			  ONTO THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
!*	'STATUS RD (1)' IS ASSERTED.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
	WRT210(0);
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST46: NOVALUE =

!THIS TEST CHECKS THAT 'STATUS RD (1)' IS NEGATED BY THE ASSERTION
!OF 'CLOSE LATCHS'. FIRST, 'STATUS RD (1)' IS ASSERTED.
!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
!THEN 'CLOSE LATCHS' IS ASSERTED.  THE NEGATION OF 'STATUS RD (1)'
!IS INFERRED BY THE FAILURE TO TRANSMIT DATA FROM I/O BUFFER 114 TO
!'R COM/ADR'.  THAT IS, 'R COM/ADR' NEGATES.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');

	LOCAL
		DATA;
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT210(CLOSE_LATCH);		!MAKE SURE 'STATUS RD (1)' NEGATES
	INIT();					!DO A RESET
	WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
	WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
	WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
	WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
	WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
	WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
	WRT110(0);				!NEGATE 'R DATA 4-11' IN DATA LOCS
	WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
	CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
	WRT210(CLOSE_LATCH);			!ASSERT 'CLOSE LATCHS'
	CYCLE(4);			!GENERATE 4 T-CLK/R-CLK CYCLES
	IF ( RD_102 AND RCOM_ADR ) NEQ 0	!DID 'STATUS RD (1)' NEGATE,
						!CLEARING 'R COM/ADR'?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 210/1	- MAKE SURE 'STATUS RD (1)' IS NEGATED
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
!*	WRT 110/0	- NEGATE 'R DATA 4-11' IN DATA LOCS
!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED
!*	WRT 210/120	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'.
!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
!*			  BUS AND INTO THE RECEIVERS.  THE 4TH CYCLE
!*			  WILL ASSERT 'STATUS RD (1)', WHICH WILL ASSERT
!*			  'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE 5TH
!*			  CYCLE SHOULD CLOCK THE DATA FROM THE DATA
!*			  LOCS ONTO THE BUS AND INTO THE RECEIVERS.
!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THE 2ND CYCLE ASSERTS FLOP E418
!*			  WHICH SHOULD NEGATE 'STATUS RD (1)'.  THIS
!*			  WILL NEGATE 'T ENB','T ENB A' AND 'DATA CYCLE'
!*			  ON THE 4TH CYCLE ZEROS SHOULD GET CLOCKED ONTO
!*			  THE BUS AND INTO THE RECEIVERS.
!*RESPONSE:
!*	'R COM/ADR' DIDN'T NEGATE.  THIS IMPLIES THAT 'T ENB',
!*	'T ENB A' AND 'DATA CYCLE' DID NOT NEGATE, WHICH IN TURN
!*	IMPLIES THAT 'STATUS RD (1)' DID NOT NEGATE.
!]ERROR 1
!]STAT_RD NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
	INIT();			!DO A RESET
	WRT114(0);
	WRT115(0);

	END;

GLOBAL ROUTINE TST47: NOVALUE =

!THIS TEST CHECKS THAT DATA CAN BE CLOCKED FROM THE CSL BOARD INTO THE
!THE TRANSCEIVERS ON THE CRA BOARD AND THEN READ BACK FROM THE CRA BOARD
!INTO THE CSL BOARD TRANSCEIVERS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR144,LR205,DR11,LR210,DR115,RP');

	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT103(%O'252');			!PUT DATA INTO I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA TRANSCEIVERS
	WRT205(%O'11');				!SET DIAG FN TO READ BUS BITS
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !GET DATA FROM CRA BOARD
	TEMP = RD_0;				!READ LATCHED DATA
	IF  .TEMP NEQ %O'252'		 !DID DATA MAKE THE ROUND TRIP?
	THEN
		ERRCA(1,%O'252',.TEMP,3); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/252		- SETUP DATA TO BE TRANSMITTED
!*	WRT 210/144		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
!*				  AND 'GRANT (1)'.
!*				- 'GRANT' AND 'XMIT ADR (1)' WILL CAUSE
!*				  THE TEST DATA TO BE GATED ONTO THE
!*				  KS10 BUS.
!*				- 'GRANT (1)' AND 'CRA R CLK' WILL CAUSE
!*				  THE TEST DATA TO BE LATCHED INTO THE
!*				  TRANSCEIVERS ON THE CRA BOARD.
!*	WRT 205/11		- SET DIAG FUNCTION BITS = 11
!*	WRT 210/115		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
!*				- 'GRANT' AND 'CRA T CLK ENB(1)' WILL
!*				  ASSERT 'CRA T CLK ENABLE' WHICH WILL
!*				  GATE THE CRA TRANSCEIVER DATA ONTO THE
!*				  KS10 BUS.
!*				- 'CLOSE LATCHS' WILL LATCH THAT DATA IN
!*				  THE CSL TRANSCEIVERS.
!*RESPONSE:
!*	THE DATA LATCHED IN THE CSL TRANSCEIVERS FOR DATA BITS 28-35
!*	(ER 0) IS NOT WHAT WAS TRANSMITTED.  EITHER 'CRA R CLK #20'
!*	OR 'CRA T CLK ENABLE' DID NOT ASSERT PROPERLY, OR THE DIAG FN
!*	BITS DID NOT GET SET CORRECTLY.
!]ERROR 1
!]CRA_R_CLK T_CLK_EN C_R_C_E C_T_C_E DFN_11 NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST48: NOVALUE =

!THIS TEST CHECKS THAT 'CRA R CLK\#20\' DOESN'T ASSERT WHEN 'CRA R
!CLK' IS NEGATED.  THIS IS DONE BY WRITING A DATA PATTERN TO THE CRA
!BOARD TRANSCEIVERS, THEN TRYING TO READ IT BACK WITHOUT ASSERTING
!'CRA R CLK'.  ALL ZEROS SHOULD BE READ BACK.
	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR252,LR210,DR144,LR103,DR125,LR205,DR11,LR210,DR140,DR111,RP');
	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT103(%O'252');			!PUT DATA INTO I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA TRANSCEIVERS
	WRT103(%O'125');
	WRT210(BUS_REQ + XMIT_ADR);		!ATTEMPT TO CLOCK DATA WITHOUT 'CRA R CLK'
	WRT205(%O'11');				!SET DIAG FN TO READ BUS BITS
	WRT210(BUS_REQ + CRA_T_CLK + CLOSE_LATCH);	!READ BACK WITHOUT 'CRA R CLK'
	TEMP = RD_0;				!READ LATCHED DATA
	IF  .TEMP NEQ %O'252'		 	!DID DATA GET READ BACK?
	THEN
		ERRCA(1,0,.TEMP,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/252		- SETUP DATA TO BE TRANSMITTED
!*	WRT 210/144		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
!*				  AND 'GRANT (1)'.
!*				- 'GRANT' AND 'XMIT ADR (1)' WILL CAUSE
!*				  THE TEST DATA TO BE GATED ONTO THE
!*				  KS10 BUS.
!*				- 'GRANT (1)' AND 'CRA R CLK' WILL CAUSE
!*				  THE TEST DATA TO BE LATCHED INTO THE
!*				  TRANSCEIVERS ON THE CRA BOARD.
!*	WRT 205/11		- SET DIAG FUNCTION BITS = 11
!*	WRT 210/111		- 'CRA T CLK ENB (1)' AND 'GRANT'
!*				  ASSERT 'CRA T CLK ENABLE'.  WITHOUT
!*				  'CRA R CLK', 'CRA T CLK C' SHOULD NOT
!*				  ASSERT AND ALL ZEROS WILL BE PLACED ON
!*				  THE KS10 BUS.
!*				- 'CLOSE LATCHS' WILL LATCH THAT DATA IN
!*				  THE CSL TRANSCEIVERS.
!*RESPONSE:
!*	THE DATA LATCHED IN THE CSL TRANSCEIVERS FOR DATA BITS 28-35
!*	(ER 0) IS WHAT WAS TRANSMITTED. THIS MEANS THAT 'CRA R CLK #20'
!*	ASSERTED WITHOUT 'CRA R CLK' BEING ASSERTED.
!]ERROR 1
!]C_R_C_E CRA_R_CLK NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST49: NOVALUE =

!THIS TEST CHECKS THAT THE 'CRA T CLK ENABLE' SIGNAL DOES NOT ASSERT
!WHEN 'GRANT' IS ASSERTED WITHOUT 'CRA T CLK ENB (1)'.
!THIS IS DONE BY CLOCKING DATA TO THE CRA BOARD THEN TRYING TO READ IT
!BACK WITHOUT ASSERTING 'CRA T CLK ENB (1)'.  IF THE DATA GETS READ
!BACK, THEN 'CRA T CLK ENABLE' WAS IMPROPERLY ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR205,DR11,LR210,DR144,DR105,RP');

	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT103(%O'252');			!PUT DATA INTO I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA TRANSCEIVERS
	WRT205(%O'11');				!SET DIAG FN TO READ BUS BITS
	WRT210(BUS_REQ + + CRA_R_CLK + CLOSE_LATCH);	!READ BACK WITHOUT'CRA T CLK ENB (1)'
	TEMP = RD_0;				!READ LATCHED DATA
	IF  .TEMP EQL %O'252'		 	!DID DATA GET READ BACK?
	THEN
		ERRCA(1,0,.TEMP,3);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/252		- SETUP DATA TO BE TRANSMITTED
!*	WRT 210/144		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
!*				  AND 'GRANT (1)'.
!*				- 'GRANT' AND 'XMIT ADR (1)' WILL CAUSE
!*				  THE TEST DATA TO BE GATED ONTO THE
!*				  KS10 BUS.
!*				- 'GRANT (1)' AND 'CRA R CLK' WILL CAUSE
!*				  THE TEST DATA TO BE LATCHED INTO THE
!*				  TRANSCEIVERS ON THE CRA BOARD.
!*	WRT 205/11		- SET DIAG FUNCTION BITS = 11
!*	WRT 210/105		- 'GRANT' ALONE SHOULD NOT
!*				  NOT ASSERT 'CRA T CLK ENABLE'.  SO ALL
!*				  ZEROS SHOULD BE ON THE KS10 BUS.
!*				- 'CLOSE LATCHS' WILL LATCH THAT DATA IN
!*				  THE CSL TRANSCEIVERS.
!*RESPONSE:
!*	THE DATA LATCHED IN THE CSL TRANSCEIVERS FOR DATA BITS 28-35
!*	(ER 0) IS WHAT WAS TRANSMITTED.  THIS MEANS THAT 'CRA T CLK
!*	ENABLE' GOT ASSERTED WITHOUT 'CRA T CLK ENB (1)' BEING ASSERTED.
!]ERROR 1
!]C_T_C_E T_CLK_EN NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST50: NOVALUE =

!THIS TEST CHECKS THAT DATA CAN BE WRITTEN INTO THE CRAM AND READ BACK.
!THIS REQUIRES CORRECT FUNCTIONING OF THE DIAG FN BITS AND THE 'CRAM
!WRITE' SIGNAL.  OTHER SIGNALS INVOLVED, SUCH AS THE 'SINGLE CLK', ARE
!TESTED BY PREVIOUS TESTS AND ARE ASSUMED TO BE FUNCTIONING CORRECTLY.
	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR144,LR204,DR40,DR0,LR206,DR2,LR210,DR115,RP');
	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT103(%O'125');			!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT205(0);				!SET DIAG FN = 0
	WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM
	WRT204(0);				!NEGATE WRITE SIGNAL
	WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 0-11
	TEMP = RD_0;				!GET BITS 4-11
	IF (.TEMP NEQ %O'125')			!DID CRAM GET WRITTEN?
	THEN
		ERRCA(1,%O'125',.TEMP,3) !NO, REPORT ERROR
	ELSE
		NOERR(1);		!ELSE, JUST DO ISOLATION
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/125		- PUT DATA INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
!*	WRT 205/0		- SET DIAG FN BITS = 0
!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
!*				  CRAM BITS 0-11.
!*	WRT 204/0		- NEGATE 'CRAM WRITE'
!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
!*				  CEIVERS.
!*RESPONSE:
!*	THE RAM DATA READ BACK WAS NOT WHAT SHOULD HAVE BEEN WRITTEN.
!*	THIS MEANS THAT EITHER THE DIAG FN BITS, THE 'CRAM WRITE'
!*	SIGNAL OR THE 'CRA/M RESET' SIGNAL ARE FAULTY.
!]ERROR 1
!]DFN_0 CRM_WRT WRT204 CSLBUF5 NTWK
!]NO ERROR 1
!]DFN_0 CRM_WRT WRT204 NTWK
	IF FLP_CHK(1,FLP_PTR1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST51: NOVALUE =

!THIS TEST CHECKS THAT DATA CAN BE WRITTEN INTO THE CRAM BITS 12-23 AND
!READ BACK.
!THIS REQUIRES CORRECT FUNCTIONING OF THE DIAG FN BITS AND THE 'CRAM
!WRITE' SIGNAL.  OTHER SIGNALS INVOLVED, SUCH AS THE 'SINGLE CLK', ARE
!TESTED BY PREVIOUS TESTS AND ARE ASSUMED TO BE FUNCTIONING CORRECTLY.
	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR205,DR4,LR210,DR115,RP');

	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();					!DO A RESET
	WRT103(%O'252');			!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT205(1);				!SET DIAG FN = 1
	WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM BITS 12-23
	WRT204(0);				!NEGATE WRITE SIGNAL
	WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
	WRT205(4);				!SET DIAG FN = 4
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 12-23
	TEMP = RD_0;				!GET BITS 16-23
	IF (.TEMP NEQ %O'252')			!DID CRAM GET WRITTEN?
	THEN
		ERRCA(1,%O'252',.TEMP,3); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/252		- PUT DATA INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
!*	WRT 205/1		- SET DIAG FN BITS = 1
!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
!*				  CRAM BITS 12-23.
!*	WRT 204/0		- NEGATE 'CRAM WRITE'
!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
!*	WRT 205/4		- SET DIAG FN = 4 TO READ BACK CRAM
!*				  BITS 12-23.
!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
!*				  CEIVERS.
!*RESPONSE:
!*	THE RAM DATA READ BACK WAS NOT WHAT SHOULD HAVE BEEN WRITTEN.
!*	THIS MEANS THAT EITHER THE DIAG FN BITS, THE 'CRAM WRITE'
!*	SIGNAL OR THE 'CRA/M RESET' SIGNAL ARE FAULTY.
!]ERROR 1
!]DFN_1 DFN_4 NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST52: NOVALUE =

!THIS TEST CHECKS THAT DATA CAN BE WRITTEN INTO THE CRAM BITS 24-35 AND
!READ BACK.
!THIS REQUIRES CORRECT FUNCTIONING OF THE DIAG FN BITS AND THE 'CRAM
!WRITE' SIGNAL.  OTHER SIGNALS INVOLVED, SUCH AS THE 'SINGLE CLK', ARE
!TESTED BY PREVIOUS TESTS AND ARE ASSUMED TO BE FUNCTIONING CORRECTLY.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR205,DR5,LR210,DR115,RP');
	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();					!DO A RESET
	WRT103(%O'125');			!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT205(2);				!SET DIAG FN = 2
	WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM BITS 24-35
	WRT204(0);				!NEGATE WRITE SIGNAL
	WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
	WRT205(5);				!SET DIAG FN = 5
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 24-35
	TEMP = RD_0;				!GET BITS 28-35
	IF (.TEMP NEQ %O'125')			!DID CRAM GET WRITTEN?
	THEN
		ERRCA(1,%O'125',.TEMP,3); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/125		- PUT DATA INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
!*	WRT 205/2		- SET DIAG FN BITS = 2
!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
!*				  CRAM BITS 24-35.
!*	WRT 204/0		- NEGATE 'CRAM WRITE'
!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
!*	WRT 205/5		- SET DIAG FN = 5 TO READ BACK CRAM
!*				  BITS 24-35.
!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
!*				  CEIVERS.
!*RESPONSE:
!*	THE RAM DATA READ BACK WAS NOT WHAT SHOULD HAVE BEEN WRITTEN.
!*	THIS MEANS THAT EITHER THE DIAG FN BITS, THE 'CRAM WRITE'
!*	SIGNAL OR THE 'CRA/M RESET' SIGNAL ARE FAULTY.
!]ERROR 1
!]DFN_2 DFN_5 NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST53: NOVALUE =

!THIS TEST CHECK THAT THE 'CRA/M RESET' SIGNAL CAN BE ASSERTED
!CORRECTLY.
!THIS IS DONE BY LATCHING ALL ONES INTO CRAM BITS 4-11, ASSERTING
!'CRA/M RESET', THEN READING THOSE BITS FOR ZERO.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR204,DR1,DR0,RP');
	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();					!DO A RESET
	WRT103(%O'777');			!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT205(0);				!SET DIAG FN = 0
	WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM BITS 4-11
	WRT204(0);				!NEGATE WRITE SIGNAL
	WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
	WRT204(CRAM_RESET);			!ASSERT 'CRA/M RESET'
	WRT204(0);				!NEGATE IT
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 0-11
	TEMP = RD_0;				!GET BITS 4-11
	IF (.TEMP NEQ 0)			!DID CRAM GET CLEARED?
	THEN
		ERRCA(1,0,.TEMP,3); !NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/777		- PUT DATA INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
!*	WRT 205/0		- SET DIAG FN BITS = 0
!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
!*				  CRAM BITS 0-11.
!*	WRT 204/0		- NEGATE 'CRAM WRITE'
!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
!*	WRT 204/1		- ASSERT 'CRA/M RESET'. THIS SHOULD
!*				  CLEAR ALL LATCHED CRAM BITS.
!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
!*				  CEIVERS.
!*RESPONSE:
!*	THE RAM DATA READ BACK WAS NOT ZEROS.  THIS MEANS THAT THE
!*	'CRA/M RESET' SIGNAL DID NOT GET ASSERTED.
!]ERROR 1
!]CRM_RESET WRT204 NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST54: NOVALUE =

!THIS TEST CHECKS THAT THE 'CRAM WRITE' SIGNAL IS NOT STUCK ASSERTED.
!THIS IS DONE BY WRITING A '125' INTO CRAM BITS 4-11 BY ASSERTING
!'CRAM WRITE', THEN CLOCKING A '252' INTO THE BUS BUFFER ON THE CRA
!BOARD (IF 'CRAM WRITE' IS STUCK ASSERTED, THIS NEW DATA WILL BE
!WRITTEN INTO BITS 4-11). CRAM BITS 4-11 ARE THEN READ BACK AND CHECKED
!THAT IT IS '125'.
	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR204,DR40,DR0,RP');
	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT103(%O'125');			!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT205(0);				!SET DIAG FN = 0
	WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM
	WRT204(0);				!NEGATE WRITE SIGNAL
	WRT103(%O'252');			!PUT NEW DATA INTO I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 0-11
	TEMP = RD_0;				!GET BITS 4-11
	IF (.TEMP EQL %O'252')			!DID CRAM BITS CHANGE?
	THEN
		ERRCA(1,%O'125',.TEMP,3); !YES
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/125		- PUT DATA INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
!*	WRT 205/0		- SET DIAG FN BITS = 0
!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
!*				  CRAM BITS 0-11.
!*	WRT 204/0		- NEGATE 'CRAM WRITE'
!*	WRT 103/252		- PUT DATA INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK DATA INTO CRA BUS BUFFER
!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
!*				  CEIVERS.
!*RESPONSE:
!*	THE CRAM BITS 4-11 GOT CHANGED FROM '125' TO '252' WITHOUT
!*	ASSERTING 'CRAM WRITE'.  THIS MEANS THAT 'CRAM WRITE' MUST BE
!*	STUCK ASSERTED.
!]ERROR 1
!]CRM_WRT NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST55: NOVALUE =

!THIS TEST CHECKS THAT THE 'CRAM ADR LOAD' SIGNAL WORKS CORRECTLY.
!THIS IS DONE BY WRITING ALL ONES TO THE CRA BUS BUFFER, ASSERTING
!'CRAM ADR LOAD', THEN READING BACK THAT ADDRESS THROUGH THE NEXT
!CRAM ADDRESS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR204,DR20,DR0,RP');
	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RESET_CRAM();				!RESET CRAM BITS
	WRT103(%O'377');			!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT204(CRAM_ADR_LD);			!LOAD DATA INTO DIAG ADDR
	WRT204(0);				!NEGATE LOAD SIGNAL
	WRT205(1);				!SET DIAG FN = 1
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ NEXT CRAM ADDR
	TEMP = RD_0;				!GET BITS 4-11
	IF (.TEMP EQL %O'377')			!DID DIAG ADDR GET LOADED?
		THEN NOERR(1)			!YES
		ELSE ERRCA(1,%O'377',.TEMP,3); !NO
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 103/377		- PUT DATA INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
!*	WRT 204/20		- ASSERT 'CRAM ADR LOAD'. THIS SHOULD
!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
!*				  'DIAG ADDR' BITS.
!*	WRT 204/0		- NEGATE 'CRAM ADR LOAD'
!*	WRT 205/1		- SET DIAG FN BITS = 1. THIS SELECT THE
!*				  NEXT CRAM ADDRESS TO BE READ.
!*	WRT 210/115		- CLOCK THE ADDRESS INTO THE CSL TRANS-
!*				  CEIVERS.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS BITS 4-11 WERE NOT READ BACK AS ALL ONES.
!*	THIS MEANS THAT THE 'CRAM ADR LOAD' SIGNAL IS FAULTY.
!]ERROR 1
!]CRM_ADR_LD DFN_1 NTWK
!]NO ERROR 1
!]CRM_ADR_LD DFN_1 NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST56: NOVALUE =

!THIS TEST CHECKS THAT THE 'RESET L' SIGNAL CLEARS THE 'CRAM ADR LOAD'
!SIGNAL.
!THIS IS DONE BY WRITING ALL ONES TO THE CRA BUS BUFFER, ASSERTING
!'CRAM ADR LOAD', WRITING ALL ZEROS TO THE CRA BUS BUFFER, TOGGLING 
!'RESET L', ASSERTING AND NEGATING 'CRAM ADR LOAD', THEN READING BACK
!THE NEXT CRAM ADDRESS.  IF 'RESET L' DOES NOT CLEAR 'CRAM ADR LOAD',
!THEN THE SECOND ASSERTION OF 'CRAM ADR LOAD' WILL NOT DO ANYTHING,
!I.E., THE ZERO DATA WILL NOT GET LOADED INTO THE NEXT CRAM ADDRESS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR204,DR20,LR100,DR200,DR0,RP');

	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RESET_CRAM();				!RESET CRAM BITS
	WRT103(%O'777');			!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	WRT204(CRAM_ADR_LD);			!LOAD DATA INTO DIAG ADDR
	WRT103(0);				!PUT DATA IN I/O BUFFER
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
	INIT();					!TOGGLE 'RESET L'
	WRT204(CRAM_ADR_LD);			!LOAD DATA INTO DIAG ADDR
	WRT204(0);				!NEGATE LOAD SIGNAL
	WRT205(1);				!SET DIAG FN = 1
	WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ NEXT CRAM ADDR
	TEMP = RD_0;				!GET BITS 4-11
	IF .TEMP NEQ 0			!DID DIAG ADDR GET ZEROED?
	THEN
		ERRCA(1,0,.TEMP,3); !NO
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 103/777		- PUT ONES INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK ONES INTO CRA BOARD TRANSCEIVERS
!*	WRT 204/20		- ASSERT 'CRAM ADR LOAD'. THIS SHOULD
!*				  CAUSE ONES TO BE WRITTEN INTO THE
!*				  'DIAG ADDR' BITS.
!*	WRT 103/0		- PUT ZEROES INTO CSL I/O BUFFER
!*	WRT 210/144		- CLOCK ZEROES TO CRA BOARD TRANSCEIVERS
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 204/20		- ASSERT 'CRAM ADR LOAD'. THIS SHOULD
!*				  CAUSE ZEROES TO BE WRITTEN INTO THE
!*				  'DIAG ADDR' BITS.
!*	WRT 204/0		- NEGATE 'CRAM ADR LOAD'
!*	WRT 205/1		- SET DIAG FN BITS = 1. THIS SELECT THE
!*				  NEXT CRAM ADDRESS TO BE READ.
!*	WRT 210/115		- CLOCK THE ADDRESS INTO THE CSL TRANS-
!*				  CEIVERS.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS BITS 4-11 WERE NOT READ BACK AS ZEROES.
!*	THIS MEANS THAT THE 'CRAM ADR LOAD' SIGNAL DID NOT GET CLEARED
!*	BY THE 'RESET L' SIGNAL.
!]ERROR 1
!]REG204 NTWK

	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST57: NOVALUE =

!THIS TEST CHECKS THAT 'HALT LOOP' ASSERTS WHEN 'CRM2 # 15B' AND
!'CPM CMD LD' ARE ASSERTED.


	BEGIN
	LABEL BLOCK1;
	LOCAL
		ERFLG;
	BIND
		UC_PTR = PLIT(U_SPEC_N U_N(4) U);

	ERFLG = 0;		!INIT ERROR FLAG
	INIT();			!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
	SEND_NUL();
	CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
	IF ( RD_300 AND HALT_LOOP) EQL 0	!DID 'HALT LOOP' ASSERT?
	THEN
		BEGIN
		ERR(1);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELD TO '10'
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
!*			  INTO THEIR LATCHES.
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
!*			  'CRAM CLK' AND 'SPEC' ASSERT 'CPM CMD LD'.
!*			  'CPM CMD LD' AND 'CRM2 # 15B' SHOULD ASSERT
!*			  'HALT LOOP'.
!*RESPONSE:
!*	'HALT LOOP' DID NOT ASSERT.
!]ERROR 1
!]HLT_LP CMD_LD CRAM_CLK HALT_LOOP NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	RESET_CRAM();				!RESET CRAM BITS
	INIT();					!DO A RESET
	IF ( RD_300 AND HALT_LOOP) NEQ 0	!DID 'HALT LOOP' NEGATE?
	THEN
		BEGIN
		ERR(2);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELD TO '10'
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
!*			  INTO THEIR LATCHES.
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
!*			  'CRAM CLK' AND 'SPEC' ASSERT 'CPM CMD LD'.
!*			  'CPM CMD LD' AND 'CRM2 # 15B' SHOULD ASSERT
!*			  'HALT LOOP'.
!*	RESET CRAM BITS
!*	ASSERT AND NEGATE RESET	- THIS SHOULD NEGATE 'HALT LOOP'
!*RESPONSE:
!*	'HALT LOOP' DID NOT NEGATE WHEN 'RESET' WAS TOGGLED.
!]ERROR 2
!]HLT_LP HALT_LOOP NTWK
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

!IF WE HAD NO ERRORS DO SOME FAULT ISOLATION

	IF .ERFLG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]HALT_LOOP NTWK

	CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0

	END;

GLOBAL ROUTINE TST58: NOVALUE =

!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T ASSERT WHEN 'CRM2 #
!15B' IS ASSERTED BUT 'CRA2 SPEC/CONSOLE' IS NEGATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT( U_N(4) U);

	INIT();			!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
	SEND_NUL();
	CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
	IF ( RD_300 AND HALT_LOOP) NEQ 0	!IS 'HALT LOOP' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO DEFAULT
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
!*			  INTO THEIR LATCHES.
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
!*			  WITH 'CRA2 SPEC/CONSOLE' NEGATED, 'CPM CMD LD'
!*			  SHOULD NOT ASSERT. SO, 'HALT LOOP (1)' SHOULD
!*			  NOT ASSERT.
!*RESPONSE:
!*	'HALT LOOP' ASSERTED.
!]ERROR 1
!]HLT_LP CMD_LD NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0

	END;

GLOBAL ROUTINE TST59: NOVALUE =

!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T ASSERT WHEN 'CRM2 #
!15B' IS NEGATED WITH 'CRA2 SPEC/CONSOLE' ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_SPEC_N U_N(0) U);

	INIT();			!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
	SEND_NUL();
	CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
	IF ( RD_300 AND HALT_LOOP) NEQ 0	!IS 'HALT LOOP' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	NEGATE CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
!*			  INTO THEIR LATCHES.
!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
!*			  WITH 'CRA2 SPEC/CONSOLE' ASSERTED,'CPM CMD LD'
!*			  ASSERT. BUT WITH 'CRM2 # 15B' NEGATED,
!*			  'HALT LOOP (1)' SHOULD NOT ASSERT.
!*RESPONSE:
!*	'HALT LOOP' ASSERTED.
!]ERROR 1
!]HLT_LP NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0

	END;

GLOBAL ROUTINE TST60: NOVALUE =

!THIS TEST CHECKS THAT 'HALT LOOP (1)' NEGATES WHEN 'CRM2 # 16B'
!AND 'CRA2 SPEC/CONSOLE' ARE ASSERTED WHEN 'CRAM CLK' ASSERTS.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT( U_J(1) U_SPEC_N U_N(4) U,
				U_SPEC_N U_N(2) U);

	INIT();			!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET NEXT ADDRESS TO 0
	INIT();					!DO A RESET
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO SET 'HALT LOOP'
	SEND_NUL();
	CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO CLEAR 'HALT LOOP'
	IF ( RD_300 AND HALT_LOOP) NEQ 0	!IS 'HALT LOOP' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CAUSES 'HALT
!*				  LOOP (1)' TO ASSERT.
!*	SET 'CRM2 # 16B' AND CLEAR 'CRM2 # 15B' AND SET 'SPEC' TO '10'
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM
!*				  CLK' AND CLOCK CRAM BITS INTO CONTROL
!*				  FLOPS ON CRA BOARD.  WITH 'CRA2 SPEC/
!*				  CONSOLE' ASSERTED, 'CPM CMD LD' SHOULD
!*				  ASSERT. BUT WITH 'CRM2 # 15B' NEGATED
!*				  AND 'CRM2 # 16B' ASSERTED, 'HALT LOOP
!*				  (1)' SHOULD NEGATE.
!*RESPONSE:
!*	'HALT LOOP' IS ASSERTED.
!]ERROR 1
!]HLT_LP CMD_LD CRAM_CLK NTWK

	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0

	END;

GLOBAL ROUTINE TST61: NOVALUE =

!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T NEGATE WHEN 'CRM2 # 16B'
!IS NEGATED AND 'CRA2 SPEC/CONSOLE' IS ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT( U_J(1) U_SPEC_N U_N(4) U,
				U_SPEC_N U_N(0) U);

	INIT();			!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET NEXT ADDRESS TO 0
	INIT();					!DO A RESET
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO SET 'HALT LOOP'
	SEND_NUL();
	CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
	IF ( RD_300 AND HALT_LOOP) EQL 0	!IS 'HALT LOOP' ASSERTED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CAUSES 'HALT
!*				  LOOP (1)' TO ASSERT.
!*	CLEAR 'CRM2 # 16B' AND 'CRM2 # 15B' AND SET 'SPEC' TO '10'
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM
!*				  CLK' AND CLOCK CRAM BITS INTO CONTROL
!*				  FLOPS ON CRA BOARD.  WITH 'CRA2 SPEC/
!*				  CONSOLE' ASSERTED, 'CPM CMD LD' SHOULD
!*				  ASSERT. BUT WITH 'CRM2 # 16B' NEGATED,
!*				  'HALT LOOP (1)' SHOULD NOT NEGATE.
!*RESPONSE:
!*	'HALT LOOP' NEGATED.
!]ERROR 1
!]HLT_LP NTWK

	IF LOOP_CHK(1)
	THEN
		LEAVE BLOCK1 WITH 1;
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0

	END;

GLOBAL ROUTINE TST62: NOVALUE =

!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T NEGATE WHEN 'CRM2 # 16B'
!IS ASSERTED BUT 'CRA2 SPEC/CONSOLE' IS NEGATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT( U_J(1) U_SPEC_N U_N(4) U,
				 U_N(2) U);

	INIT();			!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET NEXT ADDRESS TO 0
	INIT();					!DO A RESET
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO SET 'HALT LOOP'
	SEND_NUL();
	CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
	WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
	IF ( RD_300 AND HALT_LOOP) EQL 0	!IS 'HALT LOOP' ASSERTED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CAUSES 'HALT
!*				  LOOP (1)' TO ASSERT.
!*	SET 'CRM2 # 16B' AND CLEAR 'CRM2 # 15B' AND SET 'SPEC' TO '70'
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM
!*				  CLK' AND CLOCK CRAM BITS INTO CONTROL
!*				  FLOPS ON CRA BOARD.  WITH 'CRA2 SPEC/
!*				  CONSOLE' NEGATED, 'CPM CMD LD' SHOULD
!*				  NOT ASSERT. THEREFORE, 'HALT LOOP (1)'
!*				  SHOULD NOT NEGATE.
!*RESPONSE:
!*	'HALT LOOP' NEGATED.
!]ERROR 1
!]HLT_LP CMD_LD NTWK

	IF LOOP_CHK(1)
	THEN
		LEAVE BLOCK1 WITH 1;
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0

	END;

GLOBAL ROUTINE TST63: NOVALUE =

!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE'
!CONTROL FLOPS CAN BE ASSERTED.  THIS IS DONE BY ASSERTING THE FIRST
!STAGE FLOPS THEN GENERATING A SINGLE CLOCK PULSE TO TOGGLE 'ENABLE (0)'
!THEN A 'RESET' IS DONE TO CHECK THAT THE CONTROL FLOPS GET NEGATED.
	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,RP');
	LOCAL
		RUN_ERFLG,
		EXE_ERFLG,
		CON_ERFLG,
		TEMP;

	RUN_ERFLG = EXE_ERFLG = CON_ERFLG = 0;	!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
	WRT212(7);				!ASSERT 1ST STAGE FLOPS
	WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
	TEMP = RD_300;			!READ STATES OF FLOPS
	IF (.TEMP AND RUN_1 ) EQL 0		!DID 'RUN (1)' ASSERT?
	THEN
		BEGIN
		ERR(1);		!NO, REPORT ERROR
		RUN_ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
!*RESPONSE:
!*	'RUN (1)' DID NOT ASSERT.
!]ERROR 1
!]WRT212 RUN_1 RUN NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND EXECUTE_B ) EQL 0		!DID 'EXECUTE B' ASSERT?
	THEN
		BEGIN
		ERR(2);		!NO, REPORT ERROR
		EXE_ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
!*RESPONSE:
!*	'EXECUTE B' DID NOT ASSERT.
!]ERROR 2
!]WRT212 EXEC_B EXEC NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND CONTINUE_H ) EQL 0		!DID 'CONTINUE' ASSERT?
	THEN
		BEGIN
		ERR(3);		!NO, REPORT ERROR
		CON_ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
!*RESPONSE:
!*	'CONTINUE' DID NOT ASSERT.
!]ERROR 3
!]WRT212 CONT_H CONT NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	INIT();					!DO A RESET
	TEMP = RD_300;			!READ STATE OF FLOPS
	IF (.TEMP AND RUN_1) NEQ 0		!DID 'RUN (1)' NEGATE?
	THEN
		BEGIN
		ERR(4);		!NO, REPORT ERROR
		RUN_ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
!*	ASSERT AND NEGATE 'RESET'
!*RESPONSE:
!*	'RUN (1)' DID NOT NEGATE.
!]ERROR 4
!]RUN_1 RUN NTWK
	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND EXECUTE_B) NEQ 0		!DID 'EXECUTE B' NEGATE?
	THEN
		BEGIN
		ERR(5);		!NO, REPORT ERROR
		EXE_ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 5
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
!*	ASSERT AND NEGATE 'RESET'
!*RESPONSE:
!*	'EXECUTE B' DID NOT NEGATE.
!]ERROR 5
!]EXEC_B EXEC NTWK
	IF FLP_CHK(5,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND CONTINUE_H) NEQ 0		!DID 'CONTINUE' NEGATE?
	THEN
		BEGIN
		ERR(6);		!NO, REPORT ERROR
		CON_ERFLG = -1;		!SET ERROR FLAG
		END;
!*MESSAGE 6
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
!*	ASSERT AND NEGATE 'RESET'
!*RESPONSE:
!*	'CONTINUE' DID NOT NEGATE.
!]ERROR 6
!]CONT_H CONT NTWK
	IF FLP_CHK(6,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
!CHECK IF ANY OF THE SIGNALS WE IN ERROR.  IF NOT DO SOME ISOLATION.

	IF .RUN_ERFLG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]WRT212 RUN NTWK

	IF .EXE_ERFLG EQL 0
	THEN
		NOERR(2);
!]NO ERROR 2
!]WRT212 EXEC NTWK

	IF .CON_ERFLG EQL 0
	THEN
		NOERR(3);
!]NO ERROR 3
!]WRT212 CONT NTWK

	END;

GLOBAL ROUTINE TST64: NOVALUE =

!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE'
!CAN BE NEGATED BY NEGATING THERE DATA INPUTS AND CLOCKING THEM.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,LR212,DR0,LR206,DR2,RP');

	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
	WRT212(7);				!ASSERT 1ST STAGE FLOPS
	WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
	WRT212(0);				!NEGATE 1ST STAGE FLOPS
	WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
	TEMP = RD_300;			!READ STATES OF FLOPS
	IF (.TEMP AND RUN_1 ) NEQ 0		!DID 'RUN (1)' NEGATE?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
!*	WRT 212/0		- NEGATE 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
!*RESPONSE:
!*	'RUN (1)' DID NOT NEGATE.
!]ERROR 1
!]RUN_1 NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND EXECUTE_B ) NEQ 0		!DID 'EXECUTE B' NEGATE?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
!*	WRT 212/0		- NEGATE 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
!*RESPONSE:
!*	'EXECUTE B' DID NOT NEGATE.
!]ERROR 2
!]EXEC_B NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND CONTINUE_H ) NEQ 0		!DID 'CONTINUE' NEGATE?
	THEN
		ERR(3);		!NO, REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
!*	WRT 212/0		- NEGATE 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
!*RESPONSE:
!*	'CONTINUE' DID NOT NEGATE.
!]ERROR 3
!]CONT_H NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST65: NOVALUE =

!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE'
!NEGATE WHEN CRAM BITS 'CRM2 # 14B', 'CRM2 # 13B' AND 'CRM2 # 12B' ARE
!ASSERTED ALONG WITH 'CRA2 SPEC/CONSOLE' WHEN A CLOCK PULSE OCCURS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,DR2,RP');

	LOCAL
		TEMP;
	BIND
		UC_PTR = PLIT(U_SPEC_N U_N(70) U);

	INIT();					!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
	WRT212(7);				!ASSERT 1ST STAGE FLOPS
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
	TEMP = RD_300;			!READ STATES OF FLOPS
	IF (.TEMP AND RUN_1 ) NEQ 0		!DID 'RUN (1)' NEGATE?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM BIT 'CRM2 # 14B' AND SET 'SPEC' FIELD TO '10'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  CAUSE 'CPM CMD LD' TO ASSERT, WHICH
!*				  TOGETHER WITH 'CRM2 # 14B' WILL CLEAR
!*				  THE 1ST STAGE FLOP.  WHEN 'ENABLE (0)'
!*				  TOGGLES, THE 'RUN (1)' FLOP WON'T
!*				  ASSERT.
!*RESPONSE:
!*	'RUN (1)' DID NOT NEGATE.
!]ERROR 1
!]RUN_1 NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND EXECUTE_B ) NEQ 0		!DID 'EXECUTE B' NEGATE?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	SET CRAM BIT 'CRM2 # 13B' AND SET 'SPEC' FIELD TO '10'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  CAUSE 'CPM CMD LD' TO ASSERT, WHICH
!*				  TOGETHER WITH 'CRM2 # 13B' WILL CLEAR
!*				  THE 1ST STAGE FLOP.  WHEN 'ENABLE (0)'
!*				  TOGGLES, THE 'EXECUTE B' FLOP WON'T
!*				  ASSERT.
!*RESPONSE:
!*	'EXECUTE B' DID NOT NEGATE.
!]ERROR 2
!]EXEC_B NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND CONTINUE_H ) NEQ 0		!DID 'CONTINUE' NEGATE?
	THEN
		ERR(3);		!NO, REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	SET CRAM BIT 'CRM2 # 12B' AND SET 'SPEC' FIELD TO '10'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
!*				  CAUSE 'CPM CMD LD' TO ASSERT, WHICH
!*				  TOGETHER WITH 'CRM2 # 12B' WILL CLEAR
!*				  THE 1ST STAGE FLOP.  WHEN 'ENABLE (0)'
!*				  TOGGLES, THE 'CONTINUE' FLOP WON'T
!*				  ASSERT.
!*RESPONSE:
!*	'CONTINUE' DID NOT NEGATE.
!]ERROR 3
!]CONT_H NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST66: NOVALUE =

!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE' STILL
!ASSERTS WHEN CRAM BITS 'CRM2 # 14B', 'CRM2 # 13B' AND 'CRM2 # 12B' ARE
!NEGATED AND 'CRA2 SPEC/CONSOLE' IS ASSERTED WHEN A CLOCK PULSE OCCURS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,DR2,RP');

	LOCAL
		TEMP;
	BIND
		UC_PTR = PLIT(U_SPEC_N U_N(0) U);

	INIT();					!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
	WRT212(7);				!ASSERT 1ST STAGE FLOPS
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
	TEMP = RD_300;			!READ STATES OF FLOPS
	IF (.TEMP AND RUN_1 ) EQL 0		!DID 'RUN (1)' ASSERT?
	THEN
		ERR(1);			!NO
!*MESSAGE 1
!*STIMULUS:
!*	CLEAR CRAM BIT 'CRM2 # 14B' AND SET 'SPEC' FIELD TO '10'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
!*				  'ENABLE (0)' WHICH SHOULD ASSERT
!*				  'RUN (1)'.  SINCE 'CRM2 # 14B' IS
!*				  NEGATED, THE 1ST STAGE FLOP SHOULD NOT
!*				  GET NEGATED.
!*RESPONSE:
!*	'RUN (1)' DID NOT ASSERT.
!]ERROR 1
!]RUN_1 NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND EXECUTE_B ) EQL 0		!DID 'EXECUTE B' ASSERT?
	THEN
		ERR(2);			!NO
!*MESSAGE 2
!*STIMULUS:
!*	CLEAR CRAM BIT 'CRM2 # 13B' AND SET 'SPEC' FIELD TO '10'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
!*				  'ENABLE (0)' WHICH SHOULD ASSERT
!*				  'EXECUTE B'.  SINCE 'CRM2 # 13B' IS
!*				  NEGATED, THE 1ST STAGE FLOP SHOULD NOT
!*				  GET NEGATED.
!*RESPONSE:
!*	'EXECUTE B' DID NOT ASSERT.
!]ERROR 2
!]EXEC_B NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND CONTINUE_H ) EQL 0		!DID 'CONTINUE' ASSERT?
	THEN
		ERR(3);			!NO
!*MESSAGE 3
!*STIMULUS:
!*	CLEAR CRAM BIT 'CRM2 # 12B' AND SET 'SPEC' FIELD TO '10'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
!*				  'ENABLE (0)' WHICH SHOULD ASSERT
!*				  'CONTINUE'.  SINCE 'CRM2 # 12B' IS
!*				  NEGATED, THE 1ST STAGE FLOP SHOULD NOT
!*				  GET NEGATED.
!*RESPONSE:
!*	'CONTINUE' DID NOT ASSERT.
!]ERROR 3
!]CONT_H NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	INIT();					!DO A RESET

	END;

GLOBAL ROUTINE TST67: NOVALUE =

!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE' STILL
!ASSERTS WHEN CRAM BITS 'CRM2 # 14B', 'CRM2 # 13B' AND 'CRM2 # 12B' ARE
!ASSERTED AND 'CRA2 SPEC/CONSOLE' IS NEGATED WHEN A CLOCK PULSE OCCURS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,DR2,RP');

	LOCAL
		TEMP;
	BIND
		UC_PTR = PLIT( U_N(70) U);

	INIT();			!DO A RESET
	LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
	WRT212(7);				!ASSERT 1ST STAGE FLOPS
	WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
	WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
	TEMP = RD_300;			!READ STATES OF FLOPS
	IF (.TEMP AND RUN_1 ) EQL 0		!DID 'RUN (1)' ASSERT?
	THEN
		ERR(1);			!NO
!*MESSAGE 1
!*STIMULUS:
!*	SET CRAM BIT 'CRM2 # 14B' AND SET 'SPEC' FIELD TO '70'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
!*				  'ENABLE (0)' WHICH SHOULD ASSERT
!*				  'RUN (1)'.  SINCE 'CRA2 SPEC/CONSOLE'
!*				  IS NEGATED, THE 1ST STAGE FLOP SHOULD
!*				  NOT GET NEGATED.
!*RESPONSE:
!*	'RUN (1)' DID NOT ASSERT.
!]ERROR 1
!]RUN_1 NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND EXECUTE_B ) EQL 0		!DID 'EXECUTE B' ASSERT?
	THEN
		ERR(2);			!NO
!*MESSAGE 2
!*STIMULUS:
!*	SET CRAM BIT 'CRM2 # 13B' AND SET 'SPEC' FIELD TO '70'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
!*				  'ENABLE (0)' WHICH SHOULD ASSERT
!*				  'EXECUTE B'. SINCE 'CRA2 SPEC/CONSOLE'
!*				  IS NEGATED, THE 1ST STAGE FLOP SHOULD
!*				  NOT GET NEGATED.
!*RESPONSE:
!*	'EXECUTE B' DID NOT ASSERT.
!]ERROR 2
!]EXEC_B NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND CONTINUE_H ) EQL 0		!DID 'CONTINUE' ASSERT?
	THEN
		ERR(3);			!NO
!*MESSAGE 3
!*STIMULUS:
!*	SET CRAM BIT 'CRM2 # 12B' AND SET 'SPEC' FIELD TO '70'
!*	ASSERT AND NEGATE 'RESET'
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
!*				  BITS INTO THEIR LATCHES.
!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
!*				  'ENABLE (0)' WHICH SHOULD ASSERT
!*				  'CONTINUE'. SINCE 'CRA2 SPEC/CONSOLE'
!*				  IS NEGATED, THE 1ST STAGE FLOP SHOULD
!*				  NOT GET NEGATED.
!*RESPONSE:
!*	'CONTINUE' DID NOT ASSERT.
!]ERROR 3
!]CONT_H NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST68: NOVALUE =

!THIS TEST CHECKS THAT THE PARITY GENERATION NETWORKS FOR THE KS10 BUS
!WORK CORRECTLY.  SPECIFICALLY, IT CHECKS THAT THE PARITY GENERATORS
!IN THE 8646 TRANSCEIVERS AND THE 74S280 PARITY GEN CHIPS WORK CORRECTLY
!THIS IS DONE BY CLOCKING DATA PATTERNS THROUGH THE 8646 TRANSCEIVERS
!THEN LATCHING THE PATTERNS IN THE RECEIVE LATCHES.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR141,RP');
	LOCAL
		TEMP;

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	WRT103(%O'21');				!WRITE DATA PATTERN INTO BUFFERS
	WRT105(%O'21');
	WRT107(%O'20');
	WRT111(%O'21');
	WRT113(1);
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
	THEN
		ERR(1);			!NO
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/20		  R DATA 00-35 TO BE 042104010421
!*	WRT 111/21
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1-4 SHOULD ALL BE
!*				  ASSERTED AND SIGNALS TD18 AND TD19
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR RIGHT' IS ASSERTED.
!]ERROR 1
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
	THEN
		ERR(2);			!NO
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/20		  R DATA 00-35 TO BE 042104010421
!*	WRT 111/21
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1-4 SHOULD ALL BE
!*				  ASSERTED AND SIGNALS TD16 AND TD17
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR LEFT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR LEFT' IS ASSERTED.
!]ERROR 2
!]RPAR_LEFT R_PAR_LFT XMIT_PAR_LFT NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT103(1);				!CHANGE DATA PATTERN
	WRT107(%O'25');
	WRT111(%O'20');

	DO (0) WHILE
BLOCK2:
	BEGIN
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
	THEN
		ERR(3);			!NO
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/25		  R DATA 00-35 TO BE 042005210401
!*	WRT 111/20
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1,TPR3,TPR4 AND TD19
!*				  SHOULD BE ASSERTED. TPR2 AND TD18
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR RIGHT' IS ASSERTED.
!]ERROR 3
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
	THEN
		ERR(4);			!NO
!*MESSAGE 4
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/25		  R DATA 00-35 TO BE 042005210401
!*	WRT 111/20
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1,TPL3,TPL4 AND TD17
!*				  SHOULD BE ASSERTED. TPL2 AND TD16
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR LEFT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR LEFT' IS ASSERTED.
!]ERROR 4
!]R_PAR_LFT XMIT_PAR_LFT RPAR_LEFT NTWK
	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT105(%O'20');				!CHANGE DATA PATTERN
	WRT107(%O'37');
	WRT111(0);

	DO (0) WHILE
BLOCK3:
	BEGIN
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
	THEN
		ERR(5);			!NO
!*MESSAGE 5
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/37		  R DATA 00-35 TO BE 040007610001
!*	WRT 111/0
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1,TPR4,TD18 AND TD19
!*				  SHOULD BE ASSERTED. TPR2 AND TPR3
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR RIGHT' IS ASSERTED.
!]ERROR 5
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(5,FLP_PTR)
		THEN LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
	THEN
		ERR(6);			!NO
!*MESSAGE 6
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/37		  R DATA 00-35 TO BE 040007610001
!*	WRT 111/0
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1,TPL4,TD16 AND TD17
!*				  SHOULD BE ASSERTED. TPL2 AND TPL3
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR LEFT' IS ASSERTED.
!]ERROR 6
!]R_PAR_LFT XMIT_PAR_LFT RPAR_LEFT NTWK
	IF FLP_CHK(6,FLP_PTR)
		THEN LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT103(%O'21');				!CHANGE DATA PATTERN
	WRT107(%O'32');
	WRT111(1);

	DO (0) WHILE
BLOCK4:
	BEGIN
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
	THEN
		ERR(7);			!NO
!*MESSAGE 7
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/32		  R DATA 00-35 TO BE 040106410021
!*	WRT 111/0
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1,TPR2,TPR4 AND TD18
!*				  SHOULD BE ASSERTED. TPR3 AND TD19
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR RIGHT' IS ASSERTED.
!]ERROR 7
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(7,FLP_PTR)
		THEN LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
	THEN
		ERR(8);			!NO
!*MESSAGE 8
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/32		  R DATA 00-35 TO BE 040106410021
!*	WRT 111/0
!*	WRT 113/1
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1,TPL2,TPL4 AND TD16
!*				  SHOULD BE ASSERTED. TPL3 AND TD17
!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
!*				  'R PAR LEFT' TO BE NEGATED.
!*RESPONSE:
!*	'R PAR LEFT' IS ASSERTED.
!]ERROR 8
!]RPAR_LEFT R_PAR_LFT XMIT_PAR_LFT NTWK
	IF FLP_CHK(8,FLP_PTR)
		THEN LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT103(%O'20');				!CHANGE DATA PATTERN
	WRT105(0);
	WRT107(0);
	WRT113(0);

	DO (0) WHILE
BLOCK5:
	BEGIN
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
	THEN
		ERR(9);			!NO
!*MESSAGE 9
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/0		  R DATA 00-35 TO BE 000100000020
!*	WRT 111/1
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1,TPR3,TPR4,TD18 AND
!*				  TD19 SHOULD BE NEGATED. TPR3
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR RIGHT' IS NEGATED.
!]ERROR 9
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(9,FLP_PTR)
		THEN LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
	THEN
		ERR(10);			!NO
!*MESSAGE 10
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/0		  R DATA 00-35 TO BE 000100000020
!*	WRT 111/1
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1,TPL3,TPL4,TD16 AND
!*				  TD17 SHOULD BE NEGATED. TPL3
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR LEFT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR LEFT' IS NEGATED.
!]ERROR 10
!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
	IF FLP_CHK(10,FLP_PTR)
		THEN LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT105(1);				!CHANGE DATA PATTERN
	WRT107(5);
	WRT111(%O'21');

	DO (0) WHILE
BLOCK6:
	BEGIN
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
	THEN
		ERR(11);			!NO
!*MESSAGE 11
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/5		  R DATA 00-35 TO BE 002101200420
!*	WRT 111/21
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1,TPR4 AND TD18
!*				  SHOULD BE NEGATED. TPR2,TPR3 AND TD19
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR RIGHT' IS NEGATED.
!]ERROR 11
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(11,FLP_PTR)
		THEN LEAVE BLOCK6 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
	THEN
		ERR(12);			!NO
!*MESSAGE 12
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/5		  R DATA 00-35 TO BE 002101200420
!*	WRT 111/21
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1,TPL4 AND TD16
!*				  SHOULD BE NEGATED. TPL2,TPL3 AND TD17
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR LEFT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR LEFT' IS NEGATED.
!]ERROR 12
!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
	IF FLP_CHK(12,FLP_PTR)
		THEN LEAVE BLOCK6 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT103(0);				!CHANGE DATA PATTERN
	WRT107(%O'17');
	WRT111(%O'20');

	DO (0) WHILE
BLOCK7:
	BEGIN
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
	THEN
		ERR(13);			!NO
!*MESSAGE 13
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/17		  R DATA 00-35 TO BE 002003600400
!*	WRT 111/20
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1,TPR2 AND TPR4
!*				  SHOULD BE NEGATED. TPR3,TD18 AND TD19
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR RIGHT' IS NEGATED.
!]ERROR 13
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(13,FLP_PTR)
		THEN LEAVE BLOCK7 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
	THEN
		ERR(14);			!NO
!*MESSAGE 14
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/17		  R DATA 00-35 TO BE 002003600400
!*	WRT 111/20
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1,TPL2 AND TPL4
!*				  SHOULD BE NEGATED. TPL3,TD16 AND TD17
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR LEFT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR LEFT' IS NEGATED.
!]ERROR 14
!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
	IF FLP_CHK(14,FLP_PTR)
		THEN LEAVE BLOCK7 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	WRT105(0);				!CHANGE DATA PATTERN
	WRT107(%O'12');
	WRT111(0);

	DO (0) WHILE
BLOCK8:
	BEGIN
	WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
	TEMP = RD_103;			!READ STATE OF PARITY BITS
	IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
	THEN
		ERR(15);			!NO
!*MESSAGE 15
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/12		  R DATA 00-35 TO BE 000002400000
!*	WRT 111/0
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPR1,TPR2,TPR3,TPR4 AND
!*				  TD19 SHOULD BE NEGATED. TD18
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR RIGHT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR RIGHT' IS NEGATED.
!]ERROR 15
!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
	IF FLP_CHK(15,FLP_PTR)
		THEN LEAVE BLOCK8 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
	THEN
		ERR(16);			!NO
!*MESSAGE 16
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
!*	WRT 107/12		  R DATA 00-35 TO BE 000002400000
!*	WRT 111/0
!*	WRT 113/0
!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
!*				  THE SIGNALS TPL1,TPL2,TPL3,TPL4 AND
!*				  TD17 SHOULD BE NEGATED. TD16
!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
!*				  'R PAR LEFT' TO BE ASSERTED.
!*RESPONSE:
!*	'R PAR LEFT' IS NEGATED.
!]ERROR 16
!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
	IF FLP_CHK(16,FLP_PTR)
		THEN LEAVE BLOCK8 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST69: NOVALUE =

!THIS TEST CHECKS THAT THE KS10 CPU CLOCK ENABLE SIGNALS 'CRA/M CLK
!ENABLE' AND 'DPE/M CLK ENABLE', ASSERT AND NEGATE CORRECTLY WHEN
!'CLK RUN' IS ASSERTED AND 'CRA6 T00' AND 'CRA6 T01' ARE NEGATED.
!THIS TEST IS CONDUCTED IN SINGLE-PULSING MODE USING THE MAINTENANCE
!CLOCK FLOP TO PRODUCE CONTROLLED T-CLK/R-CLK SIGNALS.

	BEGIN
	LOCAL
		TEMP;
	BIND
		UC_PTR = PLIT(U_T(0) U);
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE WITH T00,T01 = 0
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	SYNC_CLK();				!SYNC T-CLKS/R-CLKS
	RESET_CRAM();				!NEGATE 'T00' AND 'T01'
	WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
	CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
	WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
	CYCLE(2);				!GENERATE 2 T CLKS
	TEMP = RD_303;
	IF ( .TEMP AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD UCODE WITH T00 = T01 = 0.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
!*				 TO ASSERT WHICH IN TURN CAUSES 'CRA/M
!*				 CLK ENABLE' TO ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 1
!]R_CLK CLK_ENBS ENB T_CNT_DN READ_DLY RD_DLY WRT_DLY CLK_RUN NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF ( .TEMP AND DP_CLK_ENBL ) NEQ 0	!DID 'DPE/M CLK ENABLE' ASSERT?
	THEN
		ERR(2);		!NO,REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD UCODE WITH T00 = T01 = 0.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T-CLK/R-CLK NEGATED STATE
!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
!*				 TO ASSERT WHICH IN TURN CAUSES 'DPE/M
!*				 CLK ENABLE' TO ASSERT.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 2
!]R_CLK PF_1 CLK_ENBS ENB T_CNT_DN READ_DLY RD_DLY WRT_DLY CLK_RUN NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CYCLE(1);				!GENERATE ANOTHER T-CLK CYCLE
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' NEGATE?
	THEN
		ERR(3);		!NO,REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	LOAD UCODE WITH T00 = T01 = 0.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T-CLK/R-CLK NEGATED STATE
!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
!*				 TO ASSERT THEN NEGATE WHICH SHOULD
!*				 CAUSE 'CRA/M CLK ENABLE' TO ASSERT THEN
!*				 NEGATE.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T NEGATE.
!]ERROR 3
!]R_CLK CLK_ENBS ENB SING_CLK NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CYCLE(1);				!GENERATE ANOTHER T-CLK CYCLE
	IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
	THEN
		ERR(4);		!NO,REPORT ERROR
!*MESSAGE 4
!*STIMULUS:
!*	LOAD UCODE WITH T00 = T01 = 0.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T-CLK/R-CLK NEGATED STATE
!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
!*				 TO ASSERT, NEGATE THEN ASSERT AGAIN.
!*				 THIS CAUSES 'CRA/M CLK ENABLE' TO
!*				 ASSERT, NEGATE THEN ASSERT AGAIN.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 4
!]R_CLK CLK_ENBS ENB T_CNT_DN READ_DLY RD_DLY WRT_DLY CLK_RUN NTWK
	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST70: NOVALUE =

!THIS TEST CHECKS THAT THE 'CLK RUN' PRE-FLOP, WHICH IS THE ONE WHICH
!THE 8080 ASSERTS TO ASSERT 'CLK RUN', GETS NEGATED BY 'RESETB'.  THIS
!IS DONE BY ASSERTING FLOP , DOING A RESET, THEN GENERATING 2 T-CLKS AND
!CHECKING THAT 'CRA/M CLK ENABLE' DOESN'T ASSERT.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR205,DR100,LR206,DR1,LR100,DR200,DR0,RP');

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	STOP_CLK;				!STOP T-CLKS/R-CLKS
	RESET_CRAM();				!NEGATE 'T00' AND 'T01'
	WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
	INIT();					!DO A RESET
	STOP_CLK;				!STOP T-CLKS/R-CLKS AGAIN
	CYCLE(2);				!GENERATE 2 T CLKS
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 205/100		- STOP CLOCKS
!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
!*	WRT 206/1		- ASSERT 'CLK RUN' PRE-FLOP
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 205/100		- STOP CLOCKS
!*	GENERATE 2 T-CLK/R-CLK CYCLES - SINCE THE 'CLK RUN' PRE-FLOP
!*				SHOULD BE NEGATED, 'ENABLE (1)' AND
!*				'CRA/M CLK ENABLE' SHOULDN'T ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED.
!]ERROR 1
!]CLK_ENBS ENB SING_CLK CLK_RUN NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST71: NOVALUE =

!THIS TEST CHECKS THAT THE 'CLK RUN' FLOP GETS NEGATED BY 'RESETB'.
!THIS IS DONE BY ASSERTING THE 'CLK RUN' PRE-FLOP, GENERATING 1 T-CLK,
!DOING A RESET, THEN GENERATING ANOTHER T-CLK AND CHECKING THAT
!'CRA/M CLK ENABLE' DOESN'T ASSERT.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR206,DR1,LR100,DR200,DR0,RP');

	DO (0) WHILE
BLOCK1:
	BEGIN
	INIT();					!DO A RESET
	STOP_CLK;				!STOP T-CLKS/R-CLKS
	RESET_CRAM();				!NEGATE 'T00' AND 'T01'
	WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
	CYCLE(1);				!GENERATE 1 T-CLK
	INIT();					!DO A RESET
	STOP_CLK;				!STOP T-CLKS/R-CLKS AGAIN
	CYCLE(1);				!GENERATE 1 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 205/100		- STOP CLOCKS
!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 1 T-CLK/R-CLK CYCLE	- THIS SHOULD ASSERT 'CLK RUN'
!*	ASSERT AND NEGATE 'RESET'
!*	WRT 205/100		- STOP CLOCKS
!*	GENERATE 1 T-CLK/R-CLK CYCLE - SINCE 'CLK RUN' SHOULD BE
!*				NEGATED 'ENABLE (1)' AND 'CRA/M CLK
!*				ENABLE' SHOULD NOT ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED.
!]ERROR 1
!]CLK_ENBS ENB CLK_RUN SING_CLK NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST72: NOVALUE =

!THIS TEST CHECKS THAT THE 'ENABLE (1)' SIGNAL FUNCTIONS CORRECTLY WHEN
!'CRA6 T00' IS NEGATED AND 'CRA6 T01' IS ASSERTED WITH 'CLK RUN'
!ASSERTED.  THIS CONDITION SHOULD CAUSE 'ENABLE (1)' TO ASSERT EVERY
!THIRD T-CLK/R-CLK CYCLE.  THE ASSERTION OF 'ENABLE (1)' IS INFERRED
!FROM THE ASSERTION OF 'CRA/M CLK ENABLE'.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');
	BIND
		UC_PTR = PLIT(U_T(1) U);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE SO 'T01' = 1
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	SYNC_CLK();				!SYNC T-CLKS/R-CLKS
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
	CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
	WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
	CYCLE(2);				!GENERATE 2 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T01' AND NEGATES 'T00'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THIS SHOULD CAUSE 'CLK RUN' TO
!*				  ASSERT ON THE FIRST CYCLE, THEN
!*				  'ENABLE (1)' AND 'CRA/M CLK ENABLE'
!*				  SHOULD ASSERT ON THE SECOND CYCLE.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 1
!]T_COUNT_DONE NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CYCLE(1);				!GENERATE 1 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' NEGATE?
	THEN
		ERR(2);		!NO,REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T01' AND NEGATES 'T00'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 3 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE ASSERTS 'CLK 
!*				RUN'. THE 2ND CYCLE ASSERTS 'ENABLE (1)'
!*				WHICH ASSERTS 'CRA/M CLK ENABLE'. THE
!*				3RD CYCLE SHOULD NEGATE 'T COUNT DONE
!*				(1)' AND 'CRA/M CLK ENABLE'.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T NEGATE.
!]ERROR 2
!]T_COUNT_DONE NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CYCLE(1);				!GENERATE 1 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
	THEN
		ERR(3);		!NO,REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T01' AND NEGATES 'T00'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 4 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE ASSERTS 'CLK
!*				RUN'. THE 2ND CYCLE ASSERTS 'ENABLE (1)'
!*				WHICH IN TURN ASSERTS 'CRA/M CLK ENABLE'
!*				THE 3RD CYCLE NEGATES 'T COUNT DONE (1)'
!*				AND 'CRA/M CLK ENABLE'. 'T COUNT DONE
!*				(1)' SHOULD STAY NEGATED ON THE 4TH
!*				CYCLE. THEREFORE, 'ENABLE (1)' AND
!*				'CRA/M CLK ENABLE' SHOULD STAY NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED.
!]ERROR 3
!]T_COUNT_DONE NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CYCLE(1);				!GENERATE 1 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
	THEN
		ERR(4);		!NO,REPORT ERROR
!*MESSAGE 4
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T01' AND NEGATES 'T00'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 5 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE ASSERTS 'CLK
!*				RUN'. THE 2ND CYCLE ASSERTS 'ENABLE (1)'
!*				WHICH IN TURN ASSERTS 'CRA/M CLK ENABLE'
!*				THE 3RD CYCLE NEGATES 'T COUNT DONE (1)'
!*				AND 'CRA/M CLK ENABLE'. 'T COUNT DONE
!*				(1)' SHOULD STAY NEGATED ON THE 4TH
!*				CYCLE. THEREFORE, 'ENABLE (1)' AND
!*				'CRA/M CLK ENABLE' SHOULD STAY NEGATED.
!*				THE 5TH CYCLE ASSERTS 'T COUNT DONE (1)'
!*				WHICH SHOULD CAUSE 'ENABLE (1)' AND
!*				'CRA/M CLK ENABLE' TO ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 4
!]T_COUNT_DONE NTWK
	IF FLP_CHK(4,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST73: NOVALUE =

!THIS TEST CHECKS THAT THE 'ENABLE (1)' SIGNAL FUNCTIONS CORRECTLY WHEN
!'CRA6 T01' IS NEGATED AND 'CRA6 T00' IS ASSERTED WITH 'CLK RUN'
!ASSERTED.  THIS CONDITION SHOULD CAUSE 'ENABLE (1)' TO ASSERT EVERY
!FOURTH T-CLK/R-CLK CYCLE, STARTING WITH THE 3RD CYCLE.  THE ASSERTION
!OF 'ENABLE (1)' IS INFERRED FROM THE ASSERTION OF 'CRA/M CLK ENABLE'.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_T(2) U);
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');

	LOAD_U(0,UC_PTR);			!LOAD UCODE SO 'T01' = 1
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	SYNC_CLK();				!SYNC T-CLKS/R-CLKS
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
	CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
	WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
	CYCLE(2);				!GENERATE 2 T-CLKS
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T00' AND NEGATES 'T01'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
!*				ASSERT 'ENABLE (1)' BECAUSE 'T COUNT
!*				DONE (1)' SHOULD STILL BE NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED PREMATURELY.  THIS IMPLIES THAT
!*	'T COUNT DONE (1)' MUST HAVE ASSERTED PREMATURELY.
!]ERROR 1
!]T_COUNT_DONE NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CYCLE(1);				!GENERATE 1 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
	THEN
		ERR(2);		!NO,REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T00' AND NEGATES 'T01'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 3 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
!*				ASSERT 'ENABLE (1)' BECAUSE 'T COUNT
!*				DONE (1)' SHOULD STILL BE NEGATED.  THE
!*				3RD CYCLE SHOULD ASSERT 'T COUNT DONE
!*				(1)', 'ENABLE (1)', AND 'CRA/M CLK
!*				ENABLE'.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.  THIS IMPLIES THAT 'T COUNT
!*	DONE (1)' PROBABLY DIDN'T ASSERT.
!]ERROR 2
!]T_COUNT_DONE NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST74: NOVALUE =

!THIS TEST CHECKS THAT THE 'ENABLE (1)' SIGNAL FUNCTIONS CORRECTLY WHEN
!'CRA6 T01' IS ASSERTED AND 'CRA6 T00' IS ASSERTED WITH 'CLK RUN'
!ASSERTED.  THIS CONDITION SHOULD CAUSE 'ENABLE (1)' TO ASSERT EVERY
!FIFTH T-CLK/R-CLK CYCLE, STARTING WITH THE 4TH CYCLE.  THE ASSERTION
!OF 'ENABLE (1)' IS INFERRED FROM THE ASSERTION OF 'CRA/M CLK ENABLE'.

	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_T(3) U);
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);			!LOAD UCODE SO 'T01' = 1
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	SYNC_CLK();				!SYNC T-CLKS/R-CLKS
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
	CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
	WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
	CYCLE(2);				!GENERATE 2 T-CLKS
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T00' AND 'T01'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
!*				ASSERT 'ENABLE (1)' BECAUSE 'T COUNT
!*				DONE (1)' SHOULD STILL BE NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED PREMATURELY.  THIS IMPLIES THAT
!*	'T COUNT DONE (1)' MUST HAVE ASSERTED PREMATURELY.
!]ERROR 1
!]T_COUNT_DONE NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	CYCLE(1);				!GENERATE 1 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
	THEN
		ERR(2);		!NO,REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T00' AND 'T01'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 3 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
!*				RUN' TO ASSERT. THE 2ND AND 3RD CYCLES
!*				DO NOT ASSERT 'ENABLE (1)' BECAUSE
!*				'T COUNT DONE (1)' SHOULD STILL BE
!*				NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED PREMATURELY.  THIS IMPLIES THAT
!*	'T COUNT DONE (1)' MUST HAVE ASSERTED PREMATURELY.
!]ERROR 2
!]T_COUNT_DONE NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	CYCLE(1);				!GENERATE 1 T-CLK
	IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
	THEN
		ERR(3);		!NO,REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
!*		'T00' AND 'T01'.
!*	ASSERT AND NEGATE 'RESET'
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 4 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
!*				RUN' TO ASSERT. THE 2ND AND 3RD CYCLES
!*				DO NOT ASSERT 'ENABLE (1)' BECAUSE
!*				'T COUNT DONE (1)' SHOULD STILL BE
!*				NEGATED. THE 4TH CYCLE SHOULD CAUSE
!*				'T COUNT DONE (1)' TO ASSERT, WHICH
!*				SHOULD CAUSE 'ENABLE (1)' AND 'CRA/M
!*				CLK ENABLE' TO ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.  THIS IMPLIES THAT 'T COUNT
!*	DONE (1)' PROBABLY DIDN'T ASSERT.
!]ERROR 3
!]T_COUNT_DONE NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST75: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' DOES NOT ASSERT WHEN THERE ARE NO
!PARITY ERRORS PRESENT AND 'PE DETECT' IS ASSERTED.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	RESET_CRAM();			!RESET THE CRAM BITS
	WRT100(RESET);			!ASSERT 'RESET'
	WRT100(PE_DET_ENB);		!NEGATE 'RESET' AND ASSERT 'PE DETECT'
	SEND_NUL();
	CHK_ERR_MSG(PAR_ERR);		!CHECK FOR UNEXPECTED PAR ERR MSG
	IF ( RD_301 AND PE_1) NEQ 0	!IS 'PE (1)' NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	RESET CRAM BITS
!*	WRT 100/200		- ASSERT 'RESET'
!*	WRT 100/100		- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*RESPONSE:
!*	'PE (1)' ASSERTED.  THIS IMPLIES THAT EITHER THERE IS AN
!*	UNEXPECTED PARITY ERROR SOMEWHERE OR THERE IS A FAULT IN THE
!*	PE DETECT LOGIC.
!]ERROR 1
!]PE PE_LTCH CPU_PE REC_BUS_PE NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST76: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT WHEN 'DP PE DETECT' IS
!ASSERTED BUT THERE IS NO DATA PATH PARITY ERROR, I.E., 'DPE4 PARITY ERR
!RIGHT', 'DPE4 PAR ERR LEFT', AND 'DPM6 DPM PAR ERR' ARE ALL NEGATED.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT100(RESET);				!ASSERT 'RESET'
	WRT100(PE_DET_ENB + DP_PE_DET);		!ASSERT 'DP PE DETECT' AND 'PE DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);			!JUST IN CASE WE GOT PE
	IF ( RD_301 AND PE_1 ) NEQ 0		!IS 'PE (1)' NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/120	- NEGATE 'RESET' AND ASSERT 'DP PE DETECT' AND
!*			  'PE DETECT'.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 1
!]PE PE_LTCH CPU_PE REC_BUS_PE DP_PAR_ERR RAM_ER_DLY NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST77: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT WHEN 'CRM DETECT' IS
!ASSERTED BUT THERE IS NO CRAM PARITY ERROR, I.E., 'CRM3 PARITY ERROR'
!AND 'CRA6 CRAM PARITY ERR' ARE BOTH NEGATED.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT100(RESET);				!ASSERT 'RESET'
	WRT100(PE_DET_ENB + CRM_PE_DET);		!ASSERT 'CRM DETECT' AND 'PE DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);			!JUST IN CASE WE GOT PE
	IF ( RD_301 AND PE_1 ) NEQ 0		!IS 'PE (1)' NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 204/1	- ASSERT 'CRA/M RESET'. THIS SHOULD NEGATE ALL
!*			  CRAM BITS, GIVING GOOD PARITY.
!*	WRT 204/0	- CLEAR 'CRA/M RESET'
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/140	- NEGATE 'RESET' AND ASSERT 'CRM DETECT' AND
!*			  'PE DETECT'.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 1
!]PE PE_LTCH CPU_PE REC_BUS_PE NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST78: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT WHEN A CRAM PARITY ERROR
!EXISTS BUT 'CRM DETECT' IS NEGATED.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	CLEAR_CRAM();			!DO AN 'LC0,DC0'
	MOD_FLD(0,1);			!SET JUST ONE BIT TO CAUSE ODD PARITY
	WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!IS 'PE (1)' NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
!*			  ERR'.
!*	WRT 100/100	- ASSERT 'PE DETECT'. SINCE 'CRM DETECT' IS NOT
!*			  ASSERTED, 'PE (1)' SHOULD NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 1
!]CRM_DET PE PE_LTCH CPU_PE REC_BUS_PE NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST79: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' ASSERTS WHEN 'CRA6 CRAM PARITY ERR' IS
!ASSERTED AND 'CRM DETECT' IS ASSERTED. IT ALSO CHECKS THAT 'CRA PE'
!ASSERTS.
!AFTER 'PE (1)' IS ASSERTED, A CHECK IS MADE TO SEE THAT 'WRT 100 L'
!NEGATES IT.

	BEGIN
	LABEL BLOCK1;
	LOCAL
		ERFLG;

	ERFLG = -1;	!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	CLEAR_CRAM();			!DO AN 'LC0,DC0'
	MOD_FLD(0,1);			!SET JUST ONE BIT TO CAUSE ODD PARITY
	WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	IF ( RD_100 AND CRA_PE ) NEQ 0	!DID 'CRA PE' ASSERT?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
!*			  ERR'. THIS SHOULD ASSERT 'CRA PE'.
!*RESPONSE:
!*	'CRA PE' DID NOT ASSERT.
!]ERROR 1
!]CRA_PE CRA_PE_LTCH PE_LTCH NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) EQL 0	!DID 'PE (1)' ASSERT?
	THEN
		BEGIN
		ERR(2);		!NO,REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
!*			  ERR'.
!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
!*RESPONSE:
!*	'PE (1)' DID NOT ASSERT.
!]ERROR 2
!]PE PE_LTCH CPU_PE CRM_DET PE_DET NTWK
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT100(PE_DET_ENB);	!NEGATE 'CRM DETECT' AND GENERATE 'WRT 100 L'
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' NEGATE?
	THEN
		BEGIN
		ERR(3);		!NO,REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 3
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
!*			  ERR'.
!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
!*	WRT 100/100	- NEGATE 'CRM DETECT'. THE 'WRT 100 L' SIGNAL
!*			  SHOULD NEGATE 'PE (1)'.
!*RESPONSE:
!*	'PE (1)' DID NOT NEGATE.
!]ERROR 3
!]PE_LTCH CPU_PE CRM_DET PE REC_BUS_PE NTWK
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

!IF WE HAD NO ERRORS FOR 2 AND 3, DO SOME FAULT ISOLATION

	IF .ERFLG EQL 0 
	THEN
		NOERR(1);
!]NO ERROR 1
!]PE NTWK

	END;

GLOBAL ROUTINE TST80: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' ASSERTS WHEN 'CRM3 PARITY ERROR' IS
!ASSERTED AND 'CRM DETECT' IS ASSERTED. IT ALSO CHECKS THAT 'CRAM PE'
!ASSERTS.
!AFTER 'PE (1)' IS ASSERTED, A CHECK IS MADE TO SEE THAT 'CRA/M RESET'
!NEGATES IT.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	CLEAR_CRAM();			!DO AN 'LC0,DC0'
	MOD_FLD(7,2);			!SET JUST ONE BIT TO CAUSE ODD PARITY
	WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	IF ( RD_100 AND CRAM_PE ) NEQ 0	!DID 'CRAM PE' ASSERT?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY
!*			  ERROR'. THIS SHOULD ASSERT 'CRAM PE'.
!*RESPONSE:
!*	'CRAM PE' DID NOT ASSERT.
!]ERROR 1
!]CRM_PE_LTCH CRM_PE PE_LTCH NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) EQL 0	!DID 'PE (1)' ASSERT?
	THEN
		ERR(2);		!NO,REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY ERROR'.
!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
!*RESPONSE:
!*	'PE (1)' DID NOT ASSERT.
!]ERROR 2
!]PE_LTCH CPU_PE CRM_DET PE_DET NTWK
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	RESET_CRAM();			!ASSERT AND NEGATE 'CRA/M RESET'
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' NEGATE?
	THEN
		ERR(3);		!NO,REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY ERROR'.
!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
!*	WRT 204/1	- ASSERT 'CRA/M RESET'. THIS SHOULD CAUSE
!*			  'PE (1)' TO NEGATE.
!*	WRT 204/0	- THEN NEGATE IT.
!*RESPONSE:
!*	'PE (1)' DID NOT NEGATE.
!]ERROR 3
!]PE_LTCH CPU_PE CRM_DET REC_BUS_PE NTWK
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST81: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT IF 'PE DETECT' IS
!NEGATED.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	CLEAR_CRAM();			!DO AN 'LC0,DC0'
	MOD_FLD(7,2);			!SET JUST ONE BIT TO CAUSE ODD PARITY
	WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
	WRT100(CRM_PE_DET);		!ASSERT 'CRM DETECT' WITHOUT 'PE DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY ERROR'.
!*	WRT 100/40	- ASSERT 'CRM DETECT'. WITH 'PE DETECT' NEGATED,
!*			  'PE (1)' SHOULD NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 1
!]PE_LTCH PE_DET NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	INIT();					!DO A RESET

	END;

GLOBAL ROUTINE TST82: NOVALUE =

!THIS TEST CHECKS THAT 'PE (1)' STAYS ASSERTED AFTER THE SOURCE OF
!THE PARITY ERROR GOES AWAY, IN THIS CASE, 'CRA6 CRAM PARITY ERR'.  IT
!ALSO CHECKS THAT 'CRA PE' STAYS ASSERTED.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	CLEAR_CRAM();			!DO AN 'LC0,DC0'
	MOD_FLD(2,%O'4000');			!SET JUST ONE BIT TO CAUSE ODD PARITY
	WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
	WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	WRT103(0);			!CLEAR BUFFERS TO WRITE ZEROS TO CRA BOARD
	WRT105(0);
	WRT205(2);			!SET DIAG FN = 2
	WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK ZEROS TO CRA BOARD
	WRT204(CRAM_WRT);		!WRITE ZEROS INTO CRAM
	WRT204(0);			!CLEAR CRAM WRITE BIT
	WRT206(SINGLE_CLK);		!CLOCK CRAM INTO LATCHES
	IF ( RD_301 AND PE_1 ) EQL 0	!DID 'PE (1)' STAY ASSERTED?
	THEN
		ERR(1);		!NO,REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF2,DF4000	- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
!*			  ERR'.
!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
!*	WRT 103/0	- WRITE 8080 I/O BUFFERS WITH ZEROS
!*	WRT 105/0
!*	WRT 205/2	- SET DIAG FN BITS = 2
!*	WRT 210/144	- CLOCK ZEROS TO CRA BOARD.
!*	WRT 204/40	- CLOCK DATA INTO CRAM
!*	WRT 204/0
!*	WRT 206/2	- ASSERT 'SINGLE CLK'. THIS CLOCK CRAM DATA INTO
!*			  LATCHES AND SHOULD CLEAR 'CRA6 CRAM PARITY
!*			  ERR'.  'PE (1)' SHOULD STAY ASSERTED.
!*RESPONSE:
!*	'PE (1)' NEGATED.
!]ERROR 1
!]PE_LTCH CPU_PE CRM_DET PE_DET NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF ( RD_100 AND CRA_PE) NEQ 0	!DID 'CRA PE' STAY ASSERTED?
	THEN
		ERR(2);		!NO,REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF2,DF4000	- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
!*			  ERR'.
!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
!*	WRT 103/0	- WRITE 8080 I/O BUFFERS WITH ZEROS
!*	WRT 105/0
!*	WRT 205/2	- SET DIAG FN BITS = 2
!*	WRT 210/144	- CLOCK ZEROS TO CRA BOARD.
!*	WRT 204/40	- CLOCK DATA INTO CRAM
!*	WRT 204/0
!*	WRT 206/2	- ASSERT 'SINGLE CLK'. THIS CLOCK CRAM DATA INTO
!*			  LATCHES AND SHOULD CLEAR 'CRA6 CRAM PARITY
!*			  ERR'.  'CRA PE' SHOULD STAY ASSERTED.
!*RESPONSE:
!*	'CRA PE' DIDN'T STAY ASSERTED.
!]ERROR 2
!]PE_LTCH CRA_PE_LTCH CRA_PE PE_DET NTWK
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST83: NOVALUE =

!THIS TEST CHECKS THAT 'ENABLE (1)' DOESN'T ASSERT WHEN 'CLK RUN' IS
!ASSERTED BUT 'PE (1)' IS ALSO ASSERTED (I.E., 'PE (0) H' IS NEGATED).

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	CLEAR_CRAM();			!DO AN 'LC0,DC0'
	MOD_FLD(2,%O'4000');		!SET JUST ONE BIT TO CAUSE ODD PARITY
	WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
	WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
	SEND_NUL();				!FORCE SENDING OF WRITE CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	SYNC_CLK();			!STOP CLOCK AND SYNC IT
	WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
	CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
	WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
	CYCLE(2);				!GENERATE 2 T-CLKS
	IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
	THEN
		ERR(1);		!NO, REPORT
!*MESSAGE 1
!*STIMULUS:
!*	MR		- DO A MASTER RESET
!*	LC0,DC0		- CLEAR ALL CRAM BITS
!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
!*			  PARITY.
!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
!*			  ERR'.
!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
!*				'ENABLE (1)' WHICH RESETS ALL THE
!*				CPU CLOCK CONTROL FLOPS.
!*	WRT 206/1		- ASSERT 'CLK RUN'
!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
!*				ASSERT 'ENABLE (1)' BECAUSE 'PE (0) H'
!*				IS NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED.  THIS MEANS THAT 'PE (1)' BEING
!*	ASSERTED DID NOT INHIBIT ASSERTION OF 'ENABLE (1)'.
!]ERROR 1
!]ENABLE_PE NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST84: NOVALUE =

!THIS TEST CHECKS THAT 'RECEIVE PE' LOGIC DOES NOT GENERATE A PARITY
!ERROR WHEN GOOD PARITY IS RECEIVED ON THE KS10 BUS. SINCE IT IS NOT
!POSSIBLE TO GENERATE BAD PARITY ON THE BUS, I CANNOT CHECK THAT THE
!CSL BOARD DETECTS BAD PARITY WHEN IT EXISTS.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	WRT114(IO_DATA);		!SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
	WRT102(0);			!SETUP DATA IN BUFFERS
	WRT104(0);
	WRT106(0);
	WRT110(0);
	WRT112(0);
	SEND_NUL();
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/0	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/0
!*	WRT 106/0
!*	WRT 110/0
!*	WRT 112/0
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 1
!]REC_PE NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT110(1);			!CHANGE BUFFER DATA
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/0	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/0
!*	WRT 106/0
!*	WRT 110/1
!*	WRT 112/0
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 2
!]REC_PE NTWK
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT102(1);			!CHANGE BUFFER DATA
	WRT104(1);
	WRT106(%O'24');
	WRT110(%O'21');
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(3);		!NO, REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/1	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/1
!*	WRT 106/24
!*	WRT 110/21
!*	WRT 112/0
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 3
!]REC_PE NTWK
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT110(%O'20');			!CHANGE BUFFER DATA
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(4);		!NO, REPORT ERROR
!*MESSAGE 4
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/1	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/1
!*	WRT 106/24
!*	WRT 110/20
!*	WRT 112/0
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 4
!]REC_PE NTWK
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT102(%O'20');			!CHANGE BUFFER DATA
	WRT104(%O'21');
	WRT106(%O'25');
	WRT110(0);
	WRT112(1);
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(5);		!NO, REPORT ERROR
!*MESSAGE 5
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/20	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/21
!*	WRT 106/25
!*	WRT 110/0
!*	WRT 112/1
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 5
!]REC_PE NTWK
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT110(1);			!CHANGE BUFFER DATA
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(6);		!NO, REPORT ERROR
!*MESSAGE 6
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/20	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/21
!*	WRT 106/25
!*	WRT 110/1
!*	WRT 112/1
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 6
!]REC_PE NTWK
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT102(%O'21');			!CHANGE BUFFER DATA
	WRT104(%O'20');
	WRT106(1);
	WRT110(%O'21');
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(7);		!NO, REPORT ERROR
!*MESSAGE 7
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/21	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/20
!*	WRT 106/1
!*	WRT 110/21
!*	WRT 112/1
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 7
!]REC_PE NTWK
	IF LOOP_CHK(7)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT110(%O'20');			!CHANGE BUFFER DATA
	WRT100(RESET);			!ASSERT RESET
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
	SEND_NUL();			!SEND CMDS
	CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
	IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
	THEN
		ERR(8);		!NO, REPORT ERROR
!*MESSAGE 8
!*STIMULUS:
!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
!*	WRT 102/21	- SETUP BUFFERS WITH TEST DATA
!*	WRT 104/20
!*	WRT 106/1
!*	WRT 110/20
!*	WRT 112/1
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
!*			  NOT ASSERT.
!*RESPONSE:
!*	'PE (1)' ASSERTED.
!]ERROR 8
!]REC_PE NTWK
	IF LOOP_CHK(8)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST85: NOVALUE =

!THIS TEST CHECKS THAT 'RECEIVE PE', 'RAM ERROR' AND 'DP PE' ARE NOT
!ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR204,DR1,DR0,LR100,DR200,DR0,RP');

	LOCAL
		TEMP;
	DO (0) WHILE
BLOCK1:
	BEGIN
	RESET_CRAM();			!CLEAR CRAM BITS
	INIT();				!DO A RESET
	TEMP = RD_100;			!READ STATUS
	IF (.TEMP AND REC_PE) EQL 0	!IS 'REC PE' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	ASSERT AND NEGATE 'RESET'
!*RESPONSE:
!*	'REC PE' IS ASSERTED.
!]ERROR 1
!]REC_PE REC_PE_LTCH RECEIVE_PE NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND DP_PE) EQL 0	!IS 'DP PE' ASSERTED?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	ASSERT AND NEGATE 'RESET'
!*RESPONSE:
!*	'DP PE' IS ASSERTED.
!]ERROR 2
!]DP_PE_LTCH DP_PAR_ERR DP_PE NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (RD_303 AND RAM_ERR) EQL 0	!IS 'RAM ERROR' NEGATED?
	THEN
		ERR(3);		!NO, REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	ASSERT AND NEGATE 'CRA/M RESET'
!*	ASSERT AND NEGATE 'RESET'
!*RESPONSE:
!*	'RAM ERROR' IS ASSERTED.
!]ERROR 3
!]RAM_ER_DLY RAM_ER_LTCH RAM_ERROR NTWK
	IF FLP_CHK(3,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST86: NOVALUE =

!THIS TEST CHECKS THAT A MEMORY PARITY ERROR CAUSE 'PE (1)' TO ASSERT.

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT100(RESET);			!ASSERT 'RESET'
	WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
	IO_DEPOSIT(%O'100000',%O'40000000000'); !SET MEM PARITY ERROR
	SEND_NUL();			!FORCE SENDING OF CMD LINE
	CHK_ERR_MSG(PAR_ERR);		!CHECK FOR PAR ERR MSG
	IF (RD_100 AND MEM_PE) NEQ 0	!DID 'MEM PARITY ERR' ASSERT?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	LI 100000		- LOAD I/O ADDRESS 100000
!*	DI 40000000000		- SET 'PAR ERR' BIT IN MEMORY STATUS REG
!*				  THIS SHOULD ASSERT 'MEM PARITY ERR'
!*RESPONSE:
!*	'MEM PARITY ERR' DID NOT ASSERT.
!]ERROR 1
!]MEM_PAR_ERR NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (RD_301 AND PE_1) EQL 0	!DID 'PE (1)' ASSERT?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	WRT 100/200	- ASSERT 'RESET'
!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
!*	ASSERT AND NEGATE 'RESET'
!*	LI 100000		- LOAD I/O ADDRESS 100000
!*	DI 40000000000		- SET 'PAR ERR' BIT IN MEMORY STATUS REG
!*	WRT 100/100		- ASSERT 'PE DETECT'.  SINCE 'MEM PARITY
!*				  ERR' IS ASSERTED, 'PE (1)' SHOULD
!*				  ASSERT.
!*RESPONSE:
!*	'PE (1)' DID NOT ASSERT.
!]ERROR 2
!]PE_LTCH NTWK
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	INIT();				!CLEAR PARITY ERROR

	END;

GLOBAL ROUTINE TST87: NOVALUE =

!THIS TEST CHECKS THAT THE '10 INT' FLOP CAN BE ASSERTED AND NEGATED.

	BEGIN
	LABEL BLOCK1;
	LOCAL
		ERFLG;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR205,DR0,DR40,RP');

	ERFLG = 0;		!INIT ERROR FLAG
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT205(0);			!NEGATE '10 INT'
	WRT205(CLR_INT);		!ASSERT '10 INT'
	IF (RD_301 AND TEN_INT) EQL 0	!DID '10 INT' ASSERT?
	THEN
		BEGIN
		ERR(1);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 1
!*STIMULUS:
!*	WRT 205/0		- NEGATE '10 INT'
!*	WRT 205/1		- ASSERT '10 INT'
!*RESPONSE:
!*	'10 INT' DID NOT ASSERT.
!]ERROR 1
!]TEN_INT_LTCH TEN_INT NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT205(0);			!NEGATE '10 INT'
	IF (RD_301 AND TEN_INT) NEQ 0	!DID '10 INT' NEGATE?
	THEN
		BEGIN
		ERR(2);		!NO, REPORT ERROR
		ERFLG = -1;	!SET ERROR FLAG
		END;
!*MESSAGE 2
!*STIMULUS:
!*	WRT 205/0		- NEGATE '10 INT'
!*	WRT 205/1		- ASSERT '10 INT'
!*	WRT 205/0		- NEGATE '10 INT'
!*RESPONSE:
!*	'10 INT' DID NOT NEGATE.
!]ERROR 2
!]TEN_INT_LTCH TEN_INT NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

!IF WE HAD NO ERRORS, THEN THE READ MUX IS OKAY.

	IF .ERFLG EQL 0
	THEN
		NOERR(1);
!]NO ERROR 1
!]TEN_INT NTWK

	END;

GLOBAL ROUTINE TST88: NOVALUE =

!THIS TEST CHECKS THAT THE '10 INT' FLOP ASSERTS WHEN 'DPMB CSL
!INTERRUPT' ASSERTS.
!IT THEN CHECKS THAT 'DP RESET' NEGATES 'DPMB CSL INTERRUPT'.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR1 = UPLIT(%ASCIZ'MR,X10,LR205,DR0,CP,RP'),
		FLP_PTR2 = UPLIT(%ASCIZ'LR204,DR4,DR0,RP');
	BIND
		UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(2000) U_SPEC_APRFLAGS U);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	SET_C(0);			!SET NEXT ADDR TO 0
	WRT205(0);			!MAKE SURE '10 INT' IS NEGATED
	CP(1);				!EXECUTE THE MICRO-INSTR
	IF (RD_301 AND TEN_INT) EQL 0	!DID '10 INT' ASSERT?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICROINSTRUCTION AT LOC 0
!*	MR		- DO A MASTER RESET
!*	WRT 205/0	- MAKE SURE '10 INT' IS NEGATED.
!*	CP 1		- EXECUTE THE MICRO-INSTRUCTION. THIS SHOULD
!*			  CAUSE 'DPMB CSL INTERRUPT' TO ASSERT, WHICH
!*			  IN TURN SHOULD CAUSE '10 INT' TO ASSERT.
!*RESPONSE:
!*	'10 INT' DID NOT ASSERT.
!]ERROR 1
!]TEN_INT_LTCH NTWK
	IF FLP_CHK(1,FLP_PTR1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	WRT204(DP_RESET);		!ASSERT 'DP RESET'
	WRT204(0);			!NEGATE IT
	WRT205(0);			!TRY TO NEGATE '10 INT'
	IF (RD_301 AND TEN_INT) NEQ 0	!DID '10 INT' NEGATE?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICROINSTRUCTION AT LOC 0
!*	MR		- DO A MASTER RESET
!*	WRT 205/0	- MAKE SURE '10 INT' IS NEGATED.
!*	CP 1		- EXECUTE THE MICRO-INSTRUCTION. THIS SHOULD
!*			  CAUSE 'DPMB CSL INTERRUPT' TO ASSERT, WHICH
!*			  IN TURN SHOULD CAUSE '10 INT' TO ASSERT.
!*	WRT 204/4	- ASSERT 'DP RESET'.  THIS SHOULD NEGATE 'DPMB
!*			  CSL INTERRUPT', THUS ALLOWING '10 INT' TO BE
!*			  NEGATED.
!*	WRT 204/0	- NEGATE 'DP RESET'
!*	WRT 205/0	- NEGATE '10 INT'.
!*RESPONSE:
!*	'10 INT' DID NOT NEGATE.  THIS IMPLIES THAT 'DP RESET' DID NOT
!*	NEGATE 'DPMB CSL INTERRUPT'.
!]ERROR 2
!]TEN_INT_LTCH DP_RESET NTWK
	IF FLP_CHK(2,FLP_PTR2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST89: NOVALUE =

!THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
!CORRECTLY.  SPECIFICALLY, THAT 'CRA/M CLK ENABLE' NEGATES AND 'DPE/M
!CLK ENABLE' ASSERTS WHEN 'CRM2 MULTI SHIFT' AND 'FE SIGN' ARE ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR206,DR2,DR2,RP');

	LOCAL
		TEMP;
	BIND
		UC_PTR = PLIT( U_J(1) U_T(0) U_LOADFE U_N(711000) U,
			   U_J(2) U_T(0) U_MULTI_SHIFT U);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);		!LOAD 2 MICRO-INSTR
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);			!SET NEXT ADDR TO 0
	INIT();					!DO A RESET
	SYNC_CLK();			!STOP CLK AND SYNC IT
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
	CYCLE(4);			!EXECUTE 1ST MICRO-INSTR
	WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
	CYCLE(4);			!EXECUTE 2ND MICRO-INSTR
	TEMP = RD_303;			!READ STATES OF CLK ENABLES
	IF (.TEMP AND CR_CLK_ENB) NEQ 0	!IS 'CRA/M CLK ENABLE' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
!*	ASSERT AND NEGATE 'RESET'
!*	SET NEXT ADDRESS TO 0
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 1.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.'MULTI SHIFT' AND
!*			  'FE SIGN' SHOULD ASSERT 'FS (1)'.  THIS WILL
!*			  HOLD 'ENABLE (1)' ASSERTED AND CAUSE 'CRA/M
!*			  CLK ENABLE' TO NEGATE WHILE 'DPE/M CLK ENABLE'
!*			  IS ASSERTED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T NEGATE.
!]ERROR 1
!]SHFT_LOGIC NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND DP_CLK_ENBL) NEQ 0	!DID 'DPE/M CLK ENABLE' ASSERT?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
!*	ASSERT AND NEGATE 'RESET'
!*	SET NEXT ADDRESS TO 0
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 1.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.'MULTI SHIFT' AND
!*			  'FE SIGN' SHOULD ASSERT 'FS (1)'.  THIS WILL
!*			  HOLD 'ENABLE (1)' ASSERTED AND CAUSE 'CRA/M
!*			  CLK ENABLE' TO NEGATE WHILE 'DPE/M CLK ENABLE'
!*			  IS ASSERTED.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T STAY ASSERTED.
!]ERROR 2
!]SHFT_LOGIC NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST90: NOVALUE =

!THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
!CORRECTLY.  SPECIFICALLY, THAT 'DPE/M CLK ENABLE' NEGATES AND 'CRA/M
!CLK ENABLE' ASSERTS WHEN 'CRM2 MULTI SHIFT' IS ASSERTED AND 'FE SIGN'
!IS NEGATED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR206,DR2,DR2,RP');

	LOCAL
		TEMP;
	BIND
		UC_PTR = PLIT( U_J(1) U_T(0) U_LOADFE U_N(710000) U,
			   U_J(2) U_T(0) U_MULTI_SHIFT U);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);		!LOAD 2 MICRO-INSTR
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	SYNC_CLK();			!STOP CLK AND SYNC IT
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
	CYCLE(4);			!EXECUTE 1ST MICRO-INSTR
	WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
	TICK(9);			!GENERATE 9 T-CLK/R-CLKS
	TEMP = RD_303;			!READ STATES OF CLK ENABLES
	IF (.TEMP AND CR_CLK_ENB) EQL 0	!IS 'CRA/M CLK ENABLE' ASSERTED?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
!*	ASSERT AND NEGATE 'RESET'
!*	SET NEXT ADDRESS TO 0
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 0.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 1
!]SHFT_LOGIC NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND DP_CLK_ENBL) EQL 0	!DID 'DPE/M CLK ENABLE' NEGATE?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
!*	ASSERT AND NEGATE 'RESET'
!*	SET NEXT ADDRESS TO 0
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 0.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T NEGATE.
!]ERROR 2
!]SHFT_LOGIC NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST91: NOVALUE =

!THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
!CORRECTLY.  SPECIFICALLY, THAT 'DPE/M CLK ENABLE' AND 'CRA/M CLK
!ENABLE' ASSERT WHEN 'CRM2 MULTI SHIFT' IS NEGATED AND 'FE SIGN' IS
!ASSERTED.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR206,DR2,DR2,RP');

	LOCAL
		TEMP;
	BIND
		UC_PTR = PLIT( U_J(1) U_T(0) U_LOADFE U_N(7110000) U,
			   U_J(2) U_T(0) U);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);		!LOAD 2 MICRO-INSTR
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	SYNC_CLK();			!STOP CLK AND SYNC IT
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
	CYCLE(4);			!EXECUTE 1ST MICRO-INSTR
	WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
	TICK(9);			!GENERATE 9 T-CLK/R-CLKS
	TEMP = RD_303;			!READ STATES OF CLK ENABLES
	IF (.TEMP AND CR_CLK_ENB) EQL 0	!IS 'CRA/M CLK ENABLE' ASSERTED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
!*	ASSERT AND NEGATE 'RESET'
!*	SET NEXT ADDRESS TO 0
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 1.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  WITH 'MULTI SHIFT' NEGATED, 'CRA/M CLK ENABLE'
!*			  AND 'DPE/M CLK ENABLE' SHOULD BOTH ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 1
!]SHFT_LOGIC NTWK
	IF FLP_CHK(1,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF (.TEMP AND DP_CLK_ENBL) NEQ 0	!DID 'DPE/M CLK ENABLE' ASSERT?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
!*	ASSERT AND NEGATE 'RESET'
!*	SET NEXT ADDRESS TO 0
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
!*			  THIS LOADS 'FE SIGN' WITH A 1.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'
!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 2
!]SHFT_LOGIC NTWK
	IF FLP_CHK(2,FLP_PTR)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET

	END;

GLOBAL ROUTINE TST92: NOVALUE =

!THIS TEST CHECKS THAT DOING AN 'EM' COMMAND DOES NOT GIVE A 'NXM'
!ERROR.

	BEGIN
	LABEL BLOCK1;

	MR();				!DO A MASTER RESET
	DO (0) WHILE
BLOCK1:
	BEGIN
	EM_CHK(0);			!EXAMINE MEM LOC 0
	IF (RD_301 AND NEXM) NEQ 0	!IS 'NEXM' NEGATED?
	THEN
		ERR(1);		!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	EM 0		- EXAMINE MEMORY LOCATION 0. SHOULD NOT GET
!*			  A 'NEXM' ERROR.
!*RESPONSE:
!*	'NEXM' ASSERTED.
!]ERROR 1
!]MEM_BUSY NTWK
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	WRT114(0);			!MAKE SURE 'NEXM' CLEARS.
	WRT115(0);			!MAKE SURE 'COM/ADR' IS CLEARED

	END;

GLOBAL ROUTINE TST93: NOVALUE =

!THIS TEST CHECKS THAT THE 'CSL4 INT 10' SIGNAL ASSERTS AND NEGATES
!CORRECTLY AND THAT THE 'PI REQ 1-7' SIGNALS CAN BE READ CORRECTLY.
!THE ASSERTION OF 'INT 10' IS INFERRED BY THE ASSERTION OF A 'PI REQ'
!SIGNAL.  FOUR MICROINSTRUCTIONS ARE EXECUTED TO ACCOMPLISH THIS.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR1 = UPLIT(%ASCIZ'MR,X10,LR116,DR1,CP2,RP'),
		FLP_PTR2 = UPLIT(%ASCIZ'MR,X10,LR116,DR1,CP4,RP');
	BIND
		UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0  U_DBUS_DBM U_N(21) U_SPEC_APR_EN U,
				U_J(2) U,
				U_J(3) U,
				U_J(0) U_SPEC_APRFLAGS U);
	OWN
		PI_MASK: VECTOR[7] INITIAL (200,100,40,20,10,4,2);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);
	INCR PI_REQ FROM 1 TO 7 BY 1
	DO
		DO (0) WHILE
BLOCK1:
		BEGIN
		MR();			!DO A MASTER RESET
		LC(0);			!SET CRAM ADDRESS = 0
		MOD_FLD(3,%O'20' + .PI_REQ); !SETUP MAGIC # FIELD
		WRT116(CSL_INT);	!ASSERT 'INT 10' PRE-FLOP
		CP(2);			!EXECUTE THE 2 MICRO-INSTRS
		IF (RD_101 AND .PI_MASK[.PI_REQ-1]) EQL 0 !DID CORRECT PI REQ BIT ASSERT?
		THEN
			ERRS(.PI_REQ,1,PI_REQ);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD 4 MICRO-INSTRUCTIONS STARTING AT LOC 0
!*	MR		- DO A MASTER RESET
!*	LC 0		- SET CRAM ADDRESS = 0
!*	LF3		- SET DIAG FN TO MODIFY MAGIC # FIELD
!*	DF 2\O0		- SET MAGIC # TO ENABLE APR FLAG 31 AND TO
!*			  SELECT PI REQ \O0.
!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
!*	CP 2		- EXECUTE THE 2 MICRO-INSTRUCTIONS. THIS SHOULD
!*			  CAUSE 'INT 10' TO ASSERT WHICH WILL CAUSE
!*			  'DPMB APR FLAG 31' TO ASSERT.  THIS IN TURN
!*			  ASSERTS 'DPMB APR INT REQ' WHICH CAUSES 'BUS
!*			  PI REQ \O0' TO ASSERT.
!*RESPONSE:
!*	'BUS PI REQ \O0' DID NOT ASSERT.
!]ERROR 1
!]PI_REQ1 INT_10 WRT116 NTWK
!]ERROR 2
!]PI_REQ2 INT_10 WRT116 NTWK
!]ERROR 3
!]PI_REQ3 INT_10 WRT116 NTWK
!]ERROR 4
!]PI_REQ4 INT_10 WRT116 NTWK
!]ERROR 5
!]PI_REQ5 INT_10 WRT116 NTWK
!]ERROR 6
!]PI_REQ6 INT_10 WRT116 NTWK
!]ERROR 7
!]PI_REQ7 INT_10 WRT116 NTWK
		IF FLP_CHK(1,FLP_PTR1)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

		CP(2);			!EXECUTE THE NEXT 2 MICRO-INSTRS
		IF (RD_101 AND .PI_MASK[.PI_REQ-1]) NEQ 0 !DID CORRECT PI REQ BIT NEGATE?
		THEN
			ERRS(.PI_REQ+7,2,PI_REQ);		!NO
!*MESSAGE 2
!*STIMULUS:
!*	LOAD 4 MICRO-INSTRUCTIONS STARTING AT LOC 0
!*	MR		- DO A MASTER RESET
!*	LC 0		- SET CRAM ADDRESS = 0
!*	LF3		- SET DIAG FN TO MODIFY MAGIC # FIELD
!*	DF 2\O0		- SET MAGIC # TO ENABLE APR FLAG 31 AND TO
!*			  SELECT PI REQ \O0.
!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
!*	CP 4		- EXECUTE THE 4 MICRO-INSTRUCTIONS. THIS SHOULD
!*			  CAUSE 'INT 10' TO ASSERT WHICH WILL CAUSE
!*			  'DPMB APR FLAG 31' TO ASSERT.  THIS IN TURN
!*			  ASSERTS 'DPMB APR INT REQ' WHICH CAUSES 'BUS
!*			  PI REQ \O0' TO ASSERT. THE 4TH CLOCK PULSE
!*			  SHOULD NEGATE 'INT 10' WHICH WILL ALLOW THE
!*			  4TH MICRO-INSTR TO NEGATE 'DPMB APR FLAG 31'.
!*			  THIS WILL NEGATE 'PI REQ \O0'.
!*RESPONSE:
!*	'PI REQ \O0' DID NOT NEGATE.
!]ERROR 8
!]PI_REQ1 INT_10 WRT116 NTWK
!]ERROR 9
!]PI_REQ2 INT_10 WRT116 NTWK
!]ERROR 10
!]PI_REQ3 INT_10 WRT116 NTWK
!]ERROR 11
!]PI_REQ4 INT_10 WRT116 NTWK
!]ERROR 12
!]PI_REQ5 INT_10 WRT116 NTWK
!]ERROR 13
!]PI_REQ6 INT_10 WRT116 NTWK
!]ERROR 14
!]PI_REQ7 INT_10 WRT116 NTWK
		IF FLP_CHK(2,FLP_PTR2)
		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
		END;
	MR();

	END;

GLOBAL ROUTINE TST94: NOVALUE =

!THIS TEST CHECKS THAT 'RESET L' SIGNAL NEGATES THE 2ND-STAGE CONTROL
!FLOP FOR THE 'INT 10' SIGNAL. THIS IS DONE BY ASSERTING THE 1ST STAGE
!FLOP AND GENERATING ONE CLOCK PULSE TO ASSERT THE 2ND-STAGE FLOP.
!THEN A RESET IS DONE.  ANOTHER CLOCK PULSE IS GENERATED.  IF THE 2ND
!STAGE FLOP NEGATED, 'PI REQ 1' WILL NOT ASSERT.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'MR,X10,LR116,DR1,CP1,LR100,DR200,DR0,CP1,RP');
	BIND
		UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0  U_DBUS_DBM U_N(21) U_SPEC_APR_EN U,
				U_J(2) U);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();			!DO A MASTER RESET
	LC(0);			!SET CRAM ADDRESS = 0
	WRT116(CSL_INT);	!ASSERT 'INT 10' PRE-FLOP
	CP(1);			!EXECUTE 1 MICRO-INSTR
	INIT();			!ASSERT AND NEGATE 'RESET'
	CP(1);			!EXECUTE THE 2ND MICRO-INSTR
	IF (RD_101 AND PI_REQ_1) NEQ 0 !DID PI REQ BIT STAY NEGATED?
		THEN
			ERR(1);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS STARTING AT LOC 0
!*	MR		- DO A MASTER RESET
!*	LC 0		- SET CRAM ADDRESS = 0
!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
!*	CP 1		- EXECUTE 1 MICRO-INSTRUCTION. THIS SHOULD
!*			  CAUSE THE 2ND-STAGE FLOP TO ASSERT AND SETUP
!*			  THE CPU SO THAT 'INT 10' WILL CAUSE A PI REQ.
!*	WRT 100/200	- ASSERT 'RESET'. THIS SHOULD NEGATE 2ND-STAGE
!*			  FLOP.
!*	WRT 100/0	- NEGATE 'RESET'
!*	CP 1		- EXECUTE THE 2ND MICRO-INSTRUCTION.  SINCE THE
!*			  2ND-STAGE FLOP IS NEGATED, 'INT 10' SHOULD NOT
!*			  ASSERT AND 'PI REQ 1' SHOULD NOT ASSERT.
!*RESPONSE:
!*	'PI REQ 1' ASSERTED.
!]ERROR 1
!]INT_10 PI_REQ1 NTWK
	IF FLP_CHK(1,FLP_PTR)
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	MR();

	END;

GLOBAL ROUTINE TST95: NOVALUE =

!THIS TEST CHECKS THAT THE 1ST-STAGE CONTROL FLOP FOR THE 'INT 10'
! SIGNAL CAN BE NEGATED BY WRITING A ZERO INTO BIT 0 OF 8080 REGISTER
! 116.
!THE FLOP IS FIRST ASSERTED THEN NEGATED. THEN 2 MICRO-INSTRUCTIONS
!ARE EXECUTED.  IF THE FLOP NEGATED CORRECTLY, 'PI REQ 1' WILL NOT
!ASSERT. IF THE FLOP DID NOT NEGATE, 'PI REQ 1' WILL ASSERT.

	BEGIN
	LABEL BLOCK1;
	BIND
		FLP_PTR = UPLIT(%ASCIZ'MR,X10,LR116,DR1,DR0,CP2,RP');
	BIND
		UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0  U_DBUS_DBM U_N(21) U_SPEC_APR_EN U,
				U_J(2) U);

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();			!DO A MASTER RESET
	LC(0);			!SET CRAM ADDRESS = 0
	WRT116(CSL_INT);	!ASSERT 'INT 10' PRE-FLOP
	WRT116(0);		!NEGATE 'INT 10' PRE-FLOP
	CP(2);			!EXECUTE 2 MICRO-INSTR
	IF (RD_101 AND PI_REQ_1) NEQ 0 !DID PI REQ BIT STAY NEGATED?
		THEN
			ERR(1);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD 2 MICRO-INSTRUCTIONS STARTING AT LOC 0
!*	MR		- DO A MASTER RESET
!*	LC 0		- SET CRAM ADDRESS = 0
!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
!*	WRT 116/0	- NEGATE 'INT 10' PRE-FLOP
!*	CP 2		- EXECUTE THE 2 MICRO-INSTRUCTIONS.  SINCE FLOP
!*			  IS NEGATED, 'INT 10' SHOULD NOT ASSERT
!*			  AND 'PI REQ 1' SHOULD NOT ASSERT.
!*RESPONSE:
!*	'PI REQ 1' ASSERTED.
!]ERROR 1
!]PI_REQ1 INT_10 NTWK
	IF FLP_CHK(1,FLP_PTR)
	THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	MR();

	END;

GLOBAL ROUTINE TST96: NOVALUE =

!THIS TESTS VERIFIES THAT A 'PAGE FAIL' WILL CAUSE 'ENABLE (1)' TO
!ASSERT PRE-EMPTIVELY.  IT SHOULD ALSO CAUSE 'CRA/M CLK ENABLE' TO
!ASSERT WHILE 'DPE/M CLK ENABLE' STAYS NEGATED.

	BEGIN
	LABEL BLOCK1,ERBLK1;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
				U_J(2) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
				U_J(3) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
				U_J(4) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(403010) U_SPEC_LDPAGE U,
				U_J(5) U,
				U_J(6) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(432012) U,
				U_J(0) U_MEM U_N(2) U),
		UC_PTR1 = PLIT(U_J(0) U_SPEC_MEMCLR U);
	LOCAL
		ACTUAL;

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);	!LOAD MICROCODE FOR PAGE FAIL
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	SET_C(0);				!SET CRAM START ADDR TO ZERO
	INIT();					!DO A RESET
	SYNC_CLK();		!GO STOP CLOCK AND SYNC IT
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);	!ASSERT 'SINGLE CLK'
	CYCLE(3);		!CLOCK CRAM BITS INTO LATCHES
	WRT206(CLK_RUN);	!ASSERT 'CLK RUN'
	CYCLE(33);		!GENERATE ENOUGH T-CLK CYCLES TO CAUSE PAGE FAILURE
	ACTUAL = RD_303 AND 6;		!READ ENABLE STATUS
	IF .ACTUAL EQL 0		!ARE ENABLES COMPLEMENTED?
	THEN
		ERR(1);		!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP
!*	X1 0		- SET CRAM ADDR = 0.
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS TOGGLES 'ENABLE (1)' WHICH
!*		RESETS ALL THE CPU CONTROL FLOPS AND LATCHES THE CRAM
!*		BITS FOR THE 1ST MICRO-INSTR.
!*	WRT 206/1	- ASSERT  'CLK RUN'.
!*	GENERATE 33 T-CLK/R-CLK CYCLES -
!*		  THE FIRST 5 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD
!*		  CAUSE 'CRA/M CLK ENABLE' TO ASSERT WHILE 'DPE/M CLK
!*		  ENABLE' IS NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DID NOT ASSERT AND 'DPE/M CLK ENABLE' DID NOT
!*	NEGATE.
!]ERROR 1
!]PF_1 PF_ST_1 ENB NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP

	IF .ACTUAL EQL 4		!DID 'DPE/M CLK ENABLE' NEGATE?
	THEN
		ERR(2);		!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP
!*	X1 0		- SET CRAM ADDR = 0.
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS TOGGLES 'ENABLE (1)' WHICH
!*		RESETS ALL THE CPU CONTROL FLOPS AND LATCHES THE CRAM
!*		BITS FOR THE 1ST MICRO-INSTR.
!*	WRT 206/1	- ASSERT  'CLK RUN'.
!*	GENERATE 33 T-CLK/R-CLK CYCLES -
!*		  THE FIRST 3 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD
!*		  CAUSE 'CRA/M CLK ENABLE' TO ASSERT WHILE 'DPE/M CLK
!*		  ENABLE' IS NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED BUT 'DPE/M CLK ENABLE' DIDN'T
!*	NEGATE.
!]ERROR 2
!]PF_1 PF_ST_1 ENB NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	IF .ACTUAL EQL 2		!DID 'CRA/M CLK ENABLE' ASSERT?
	THEN
		ERR(3);		!NO, REPORT ERROR
!*MESSAGE 3
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP
!*	X1 0		- SET CRAM ADDR = 0.
!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS TOGGLES 'ENABLE (1)' WHICH
!*		RESETS ALL THE CPU CONTROL FLOPS AND LATCHES THE CRAM
!*		BITS FOR THE 1ST MICRO-INSTR.
!*	WRT 206/1	- ASSERT  'CLK RUN'.
!*	GENERATE 33 T-CLK/R-CLK CYCLES -
!*		  THE FIRST 3 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD
!*		  CAUSE 'CRA/M CLK ENABLE' TO ASSERT WHILE 'DPE/M CLK
!*		  ENABLE' IS NEGATED.
!*RESPONSE:
!*	'DPE/M CLK ENABLE' NEGATED BUT 'CRA/M CLK ENABLE' DIDN'T ASSERT.
!]ERROR 3
!]PF_1 PF_ST_1 ENB NTWK
	IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING

	END;
	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR1);	!LOAD MEM CLR INSTR
	CP_NOSS(3);		!EXECUTE INSTR TO CLEAR PAGE FAULT
	SEND_NUL();

	END;

GLOBAL ROUTINE TST97: NOVALUE =

!THIS TEST CHECKS THAT THE 'TRAP EN' SIGNAL CAN BE ASSERTED AND NEGATED
!CORRECTLY.
!THIS IS DONE BY DOING A 'TRAP CYCLE' SKIP MICROSEQUENCE.  WITH 'TRAP
!EN' ASSERTED, THE SKIP SHOULD OCCUR.  WITH IT NEGATED, THE SKIP SHOULD
!NOT OCCUR.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(1) U_N(20000) U_SPEC_APR_EN U_DBUS_DBM U_ALU_OR U_RSRC_D0 U,
				U_J(2) U_N(1000) U_SPEC_FLAGS U,
				U_J(3) U_SPEC_NICOND U,
				U_J(3776) U_SKIP_TRAP_CYC U);
	LOCAL
		ACTUAL;

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);	!LOAD MICRO-INSTR
	DO (0) WHILE
BLOCK1:
	BEGIN
	TP(1);			!ASSERT 'CSL4 TRAP EN'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(4);	!EXECUTE NICOND SKIP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3777'		!DID WE SKIP CORRECTLY?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1' AND DO A TRAP CYCLE SKIP
!*		TO 3776.
!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
!*	X1 0		- SET NEXT CRAM ADDR TO 0.
!*	CP 4		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
!*			  'DPE9 TRAP 1'.  THE 3RD INSTR ASSERTS 'SPEC/
!*			  NICOND' WHICH SHOULD ASSERT 'TRAP CYCLE'.
!*			  THE 4TH INSTR DOES A TRAP CYCLE SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID NOT SKIP TO 3777. THIS IMPLIES THAT
!*	'TRAP EN' DID NOT ASSERT.
!]ERROR 1
!]TRAP_EN NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:
	BEGIN
	TP(0);			!TURN OFF TRAP ENABLES
	SET_C(2);		!SET CRAM ADDR TO 2
	ACTUAL = STEP_U_NEXT(2);	!EXECUTE TRAP CYCLE SKIP AND READ NEXT ADDR
	IF .ACTUAL NEQ %O'3776'		!DID WE DISPATCH CORRECTLY?
	THEN
		ERRCA(2,%O'3776',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO ASSERT 'SPEC/NICOND' AND DO A TRAP CYCLE
!*		SKIP TO 3776.
!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
!*			  'DPE9 TRAP 1,2 AND 3'.
!*	X1 3		- SET NEXT CRAM ADDR TO 3.
!*	CP 2		- THE 1ST INSTR WILL ASSERT 'SPEC/NICOND'. WITH
!*			  ALL TRAPS NEGATED, 'NICOND 9' IS ASSERTED. SO
!*			  'TRAP CYCLE' WILL BE NEGATED. WITH 'TRAP
!*			  CYCLE' NEGATED, THE 2ND INSTR WHICH DOES A
!*			  TRAP CYCLE SKIP, SHOULD NOT SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDR DID SKIP TO 3777. THIS IMPLIES THAT THE
!*	'TRAP EN' SIGNAL DID NOT NEGATE.
!]ERROR 2
!]TRAP_EN NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST98: NOVALUE =

!THIS TEST CHECKS THAT THE 'EXECUTE' SIGNAL IS BUFFERED CORRECTLY ONTO
!THE CRA BOARD.
!TO DO THIS, A CONSOLE EXECUTE MODE SKIP IS EXECUTED. WITH THE 'EXECUTE'
!SIGNAL ASSERTED, THE MICRO-CODE SHOULD SKIP.  WITH IT NEGATED, THE
!MICRO-CODE SHOULD NOT SKIP.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_EXECUTE U);
	LOCAL
		ACTUAL;

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT212(EXECUTE);	!ASSERT 'EXECUTE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'EXECUTE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
!*	WRT 212/2	- ASSERT 'EXECUTE' PRE-FLOP
!*	CP 1		- ASSERT 'EXECUTE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777. THIS IMPLIES THAT
!*	THE 'EXECUTE' SIGNAL DID NOT ASSERT ON THE CRA BOARD.
!]ERROR 1
!]EXEC_DRVR NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:
	BEGIN
	WRT212(0);		!NEGATE 'EXECUTE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'EXECUTE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
!*	WRT 212/0	- NEGATE 'EXECUTE' PRE-FLOP
!*	CP 1		- NEGATE 'EXECUTE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777. THIS IMPLIES THAT
!*	THE 'EXECUTE' SIGNAL DID NOT NEGATE ON THE CRA BOARD.
!]ERROR 3
!]EXEC_DRVR NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST99: NOVALUE =

!THIS TEST CHECKS THAT THE 'CONTINUE' SIGNAL ASSERTS AND NEGATES
!CORRECTLY ON THE CRA BOARD.
!TO DO THIS, THE 'CONTINUE' SIGNAL IS ASSERTED ON THE CSL BOARD AND
!A 'NOT CONTINUE' SKIP MICRO-INSTRUCTION IS EXECUTED.  NO SKIP SHOULD
!OCCUR.  THEN THE 'CONTINUE' SIGNAL IS NEGATED.  THIS TIME A SKIP SHOULD
!OCCUR.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_CONTINUE U);
	LOCAL
		ACTUAL;

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT212(CONTINUE);	!ASSERT 'CONTINUE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'CONTINUE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
!*	WRT 212/2	- ASSERT 'CONTINUE' PRE-FLOP
!*	CP 1		- ASSERT 'CONTINUE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP. SINCE
!*			  'CONTINUE' IS ASSERTED, NO SKIP SHOULD OCCUR.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777. THIS IMPLIES THAT THE
!*	'CONTINUE' SIGNAL DID NOT ASSERT ON THE CRA BOARD.
!]ERROR 1
!]CONT_DRVR NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:
	BEGIN
	WRT212(0);		!NEGATE 'CONTINUE' PRE-FLOP
	CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'CONTINUE'
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
!*	WRT 212/0	- NEGATE 'CONTINUE' PRE-FLOP
!*	CP 1		- NEGATE 'CONTINUE'
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP.  SINCE
!*			  'CONTINUE' IS NEGATED, WE SHOULD SKIP TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777. THIS IMPLIES THAT
!*	THE 'CONTINUE' SIGNAL DID NOT NEGATE ON THE CRA BOARD.
!]ERROR 2
!]CONT_DRVR NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST100: NOVALUE =

!THIS TEST CHECKS THAT THE '1 MSEC EN' FLOP GETS ASSERTED AND NEGATED
!CORRECTLY.
!THIS IS DONE BY ASSERTING '1 MSEC EN', ALLOWING THE TIMER TO TIME OUT,
!THEN EXECUTING A 'NOT 1 MSEC TIMER' SKIP MICROINSTRUCTION. NO SKIP
!SHOULD OCCUR.  THEN '1 MSEC EN' IS NEGATED AND THE SAME SEQUENCE IS
!PERFORMED. THIS TIME A SKIP SHOULD OCCUR.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
		UC_PTR = PLIT(U_J(3776) U_SKIP_1_MS U);
	LOCAL
		ACTUAL;

	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);	!LOAD MICROCODE
	DO (0) WHILE
BLOCK1:
	BEGIN
	WRT100(EN_1MS);		!ENABLE 1 MSEC TIME-OUT
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
	THEN
		ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
!*	WRT 100/4	- ENABLE 1 MSEC TIMER. THIS SHOULD CAUSE 'DPMC
!*			  1 MSEC' TO ASSERT.
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP. SINCE
!*			  '1 MSEC' IS ASSERTED, NO SKIP SHOULD OCCUR.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777. THIS IMPLIES THAT THE
!*	'1 MSEC EN' SIGNAL DID NOT ASSERT.
!]ERROR 1
!]MSEC_EN NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	DO (0) WHILE
BLOCK2:
	BEGIN
	WRT100(0);		!NEGATE '1 MSEC TIMER' ENABLE
	SET_C(0);		!SET CRAM ADDR TO 0
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
	IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
	THEN
		ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
!*	WRT 100/0	- NEGATE '1 MSEC TIMER' ENABLE. THIS SHOULD
!*			  CAUSE 'DPMC 1 MSEC' TO NEGATE.
!*	X1 0		- SET CRAM ADDR TO 0
!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP.  SINCE
!*			  '1 MSEC' IS NEGATED, WE SHOULD SKIP TO 3777.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777. THIS IMPLIES THAT
!*	THE '1 MSEC EN' SIGNAL DID NOT NEGATE.
!]ERROR 2
!]MSEC_EN NTWK
	IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;

	END;

GLOBAL ROUTINE TST101: NOVALUE =

!THIS TEST CHECKS THAT THE SUBROUTINE STACK POINTER GETS RESET WHEN
!'STACK RESET' IS ASSERTED.
! A MICROINSTRUCTION AT LOCATION ZERO JUMPS TO LOCATION 2.  FROM
! LOCATION 2, A CALL IS EXECUTED TO LOCATION 4.  THERE A CALL IS
! EXECUTED TO LOCATION 6.  THEN A 'STACK RESET' IS DONE AND A RETURN
! INSTRUCTION IS EXECUTED.  THIS RETURN SHOULD GO TO LOCATION 2 INSTEAD
! OF 4.
	BEGIN
	LABEL BLOCK1;
	BIND
		UC_PTR = PLIT(U_J(2) U,
				U,
				U_J(4) U_CALL U,
				U,
				U_J(6) U_CALL U,
				U,
				 U_DISP_RETURN U);
	LOCAL
		ACTUAL;

	MR();				!DO A MASTER RESET
	WRT204(STK_RESET);		!DO A STACK RESET
	WRT204(0);
	LOAD_U(0,UC_PTR);	!LOAD MICRO-INSTRS
	DO (0) WHILE
BLOCK1:
	BEGIN
	SET_C(0);
	CP(3);			!EXECUTE ALL THE CALL INSTRS
	WRT204(STK_RESET);		!DO A STACK RESET
	WRT204(0);
	ACTUAL = STEP_U_NEXT(1);	!EXECUTE RETURN AND READ NEXT ADDR
	IF .ACTUAL NEQ 2		!ARE WE AT CORRECT RETURN ADDR?
	THEN
		ERRCA(1,2,.ACTUAL,4);	!NO, REPORT ERROR
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRUCTIONS TO JUMP FROM 0 TO 2, DO A CALL FROM 2 TO
!*		4, DO A CALL FROM 4 TO 6, AND DO A RETURN FROM 6.
!*	X1 0	- SET THE CRAM ADDRESS TO ZERO.
!*	CP 3	- THREE CLOCK PULSES EXECUTE THE CALL INSTRS AT LOCS 2
!*		  AND 4.
!*	WRT 204/2	- DO A STACK RESET.
!*	WRT 204/0
!*	CP 1	- EXECUTE THE RETURN INSTR AT LOC 6.  AFTER THE STACK
!*		  RESET, THIS SHOULD CAUSE THE NEXT CRAM ADDR TO BE 2
!*		  INSTEAD OF 4.
!*RESPONSE:
!*	THE NEXT CRAM ADDRESS AFTER EXECUTING THE RETURN IS NOT 2.
!*	THIS IMPLIES THAT 'STACK RESET' DID NOT ASSERT.
!]ERROR 1
!]STK_RESET NTWK
	IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
	THEN
		LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	END;

GLOBAL ROUTINE TST102: NOVALUE =

!THIS TEST CHECKS THAT THE CPU CLOCK CONTROL CIRCUITRY WORKS CORRECTLY
!WHEN THE CPU EXECUTES A MEMORY READ SEQUENCE.  WHAT SHOULD HAPPEN IS
!THAT THE CLOCK ENABLES GET DISABLED UNTIL THE MEMORY RESPONDS WITH THE
!DATA.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	LOCAL
		ERFLG;
	BIND
		UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
			      U_J(2) U_MEM U_N(43012) U,
			      U_J(3) U_MEM U_N(2) U,
			      U_J(3) U);

	ERFLG = 0;		!INIT ERROR FLAG
	MR();				!DO A MASTER RESET
	LOAD_U(0,UC_PTR);	!LOAD MICROCODE FOR MEM READ
	DO (0) WHILE
BLOCK1:
	BEGIN
	MR();				!DO A MASTER RESET
	SET_C(0);	!SET CRAM ADDR = 0
	INIT();		!DO A RESET
	SYNC_CLK();	!GO STOP CLOCK AND SYNC IT
	RESET_CRAM();				!CLEAR CRAM BITS
	WRT206(SINGLE_CLK);	!ASSERT 'SINGLE CLK'
	CYCLE(3);		!INIT CLOCK CONTROL FLOPS
	WRT206(CLK_RUN);	!ASSERT 'CLK RUN'
	CYCLE(9);		!EXECUTE FIRST 3 MICRO-INSTRS

!CPU CLOCKING SHOULD NOW BE DISABLED UNTIL MEMORY RESPONDS WITH THE
!READ DATA.  IT SHOULD TAKE AT LEAST 8 T-CLK CYCLES BEFORE THE CLOCKS
!ARE ENABLED AGAIN.

	INCR I FROM 1 TO 8 BY 1 DO
		BEGIN
		CYCLE(1);	!GENERATE A T-CLK CYCLE
		IF (RD_303 AND CR_CLK_ENB) NEQ 0  !DID 'CRA/M CLK ENABLE ASSERT TOO EARLY?
		THEN
			BEGIN
			ERFLG = -1;	!SET ERROR FLAG
			ERRS(1,1,I);	!YES, REPORT ERROR
			EXITLOOP;
			END;
		END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO DO A MEMORY READ.
!*	X1 0	- SET THE CRAM ADDRESS TO 0.
!*	STOP CLOCK AND SYNC IT WITH T-CLK AND R-CLK NEGATED.
!*	WRT 206/2   - ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS INITS ALL THE CLOCK CONTROL
!*		FLOPS AND LATCHES THE CRAM BITS FOR THE FIRST MICRO-
!*		INSTRUCTION.
!*	WRT 206/1   - ASSERT 'CLK RUN'.
!*	GENERATE 9 T-CLK/R-CLK CYCLES - THIS EXECUTES THE FIRST 3 MICRO-
!*		INSTRUCTIONS. AFTER THE LAST ONE, THE CPU SHOULD BE
!*		WAITING FOR THE MEMORY TO RESPOND WITH THE READ DATA.
!*		THE CPU CLOCK ENABLES SHOULD NOW BE DISABLED FOR AT
!*		LEAST 8 T-CLK/R-CLK CYCLES.
!*	GENERATE \O0 T-CLK/R-CLK CYCLES - 'CRA/M CLK ENABLE' SHOULD
!*		STAY NEGATED.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' ASSERTED BEFORE IT SHOULD HAVE.
!]ERROR 1
!]CLK_ENBS ENB RD_DATA READ_DLY RD_DLY NTWK
	IF LOOP_CHK(1)		!CHECK FOR LOOPING ON ERROR
	THEN
		LEAVE BLOCK1 WITH 1;

!NOW CHECK THAT 'CRA/M CLK ENABLE' ASSERTS WITHIN 8 CYCLES.

	IF .ERFLG EQL 0		!IF WE DIDN'T ALREADY HAVE AN ERROR
	THEN
BLOCK2:	BEGIN
		BEGIN
		INCR I FROM 1 TO 8 BY 1 DO
			BEGIN
			CYCLE(1);	!GENERATE A T-CLK CYCLE
			IF (RD_303 AND CR_CLK_ENB) EQL 0   !DID IT ASSERT?
			THEN
				LEAVE BLOCK2;
			END;

!IF WE GET THIS FAR, 'CRA/M CLK ENABLE' NEVER ASSERTED.
		ERR(2);
		END;
!*MESSAGE 2
!*STIMULUS:
!*	LOAD MICRO-INSTRS TO DO A MEMORY READ.
!*	X1 0	- SET THE CRAM ADDRESS TO 0.
!*	STOP CLOCK AND SYNC IT WITH T-CLK AND R-CLK NEGATED.
!*	WRT 206/2   - ASSERT 'SINGLE CLK'.
!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS INITS ALL THE CLOCK CONTROL
!*		FLOPS AND LATCHES THE CRAM BITS FOR THE FIRST MICRO-
!*		INSTRUCTION.
!*	WRT 206/1   - ASSERT 'CLK RUN'.
!*	GENERATE 9 T-CLK/R-CLK CYCLES - THIS EXECUTES THE FIRST 3 MICRO-
!*		INSTRUCTIONS. AFTER THE LAST ONE, THE CPU SHOULD BE
!*		WAITING FOR THE MEMORY TO RESPOND WITH THE READ DATA.
!*		THE CPU CLOCK ENABLES SHOULD NOW BE DISABLED FOR AT
!*		LEAST 8 T-CLK/R-CLK CYCLES.
!*	GENERATE 8 T-CLK/R-CLK CYCLES - 'CRA/M CLK ENABLE' SHOULD
!*		STAY NEGATED WAITING FOR MEMORY TO RESPOND.
!*	GENERATE 8 T-CLK/R-CLK CYCLE - 'CRA/M CLK ENABLE' SHOULD ASSERT.
!*RESPONSE:
!*	'CRA/M CLK ENABLE' DID NOT ASSERT.
!]ERROR 2
!]CLK_ENBS ENB RD_DATA READ_DLY RD_DLY NTWK
		IF LOOP_CHK(2)		!CHECK FOR LOOPING ON ERROR
		THEN
			LEAVE BLOCK1 WITH 1;
		END;
	0				!TO PREVENT INFO MSG WHEN COMPILING
	END;
	MR();				!DO A MASTER RESET
	END;
END
ELUDOM
 