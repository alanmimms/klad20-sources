SUBTTL MAIN LOOP
									SALL
PGMNAM:	ASCIZ	/DECSYSTEM KS10 KL-PAGING TEST [DSKEC]
/

T=	SIXBTZ	<KS10 KL-PAGING TEST>

; **********************************************************************
;*NOTE:
;*
;*THERE ARE CERTAIN TESTS THAT THE KS10 DOES NOT DO PROPERLY SINCE IT
;*IS A SINGLE SECTION MACHINE.
;*
;*THE FLAG CALLED 'XCHECK' IS USED TO MARK THOSE TESTS.
;*
;*IF IT IS DESIRED TO RUN THOSE TESTS THEN SET THE "XCHECK" PROGRAM
;*CONTROL SWITCH.
; **********************************************************************

; **********************************************************************
;*RIGHT HALF SWITCH PROMPT TABLE
; **********************************************************************

RSWPMT:	BLOCK	^D17		;ONLY SWITCH 35 IS USED
	SIXBIT/XCHECK/

; **********************************************************************
;*START - PROGRAM INITIALIZATION
; **********************************************************************

START:	MOVEI	RSWPMT		;SET UP RIGHT HALF SWITCH PROMPT TABLE
	MOVEM	SWPTAB

	PGMINT			;INITIALIZE SUBROUTINE PACKAGE

	APRID			;GET PROCESSOR ID INFO
	LDB	[POINT 12,0,17]	;GET VERSION TO AC
	SETZM	UCV117#		;ASSUME NOT V117
	CAIL	117		;VERSION 117 OR GREATER?
	SETOM	UCV117		;YES, REMEMBER

	SETZM	XCHECK#
	SWITCH			;IS SWITCH SET FOR EXTENDED CHECKING ?
	TRNE	XCHSW
	SETOM	XCHECK		;YES, THEN DO THOSE TESTS

	SKIPE	UCV117
	JRST	STARTA

	PMSG	<^?IMPROPER MICROCODE, VERSION 117 OR LATER REQUIRED^>

; **********************************************************************
;*STARTA - TEST CONTROL
; **********************************************************************

STARTA:	WREBR	PAGOFF		;TURN OFF PAGING
	WRPI	PIOFF		;TURN OFF PI
	WRPI	PICLR		;CLEAR PI

	GO	KLPAGE		;TURN ON KL PAGING

	GO	TESTS		;RUN THE TESTS.

	JRST	BEGEND		;END OF PROGRAM

SUBTTL ACTUAL TESTS
								XALL
; **********************************************************************
;*TST01 - VERIFY THAT USER AND EXEC MAPPINGS GO THROUGH DIFFERENT
;*	SECTION TABLES.
; **********************************************************************

TESTS:
TST01:	SUBTST

	PAGMAP	(P1,777)	;P1 IS EXEC PAGE 777

	UPAGMP	(P2,777)	;P2 IS USER PAGE 777

	DMOVE	A,[EXP 3.14,2.7] ;EXEC DATA IS PI, USER DATA IS E.
	MOVEM	A,P1
	MOVEM	B,P2		;STORE THE DATA.

	GO	PREVU		;MAKE SURE PREVIOUS CONTEXT IS USER.

	WREBR	PAGON		;TELL HDW OF PAGE MAP

TST01A:	MOVEI	A,0		;START WITH 0.
	MOVE	A,777000	;FETCH EXEC DATA.

	CAME	A,[3.14]
	ERROR	(TST01A,13,[3.14],A,VERIFY THAT USER AND EXEC MAPPINGS
^GO THRU DIFFERENT SECTION TABLES,WRONG EXEC DATA FETCHED)

TST01B:	UMOVE	A,777000	;FETCH USER DATA.

	CAME	A,[2.7]
	ERROR	(TST01B,13,[2.7],A,VERIFY THAT USER AND EXEC MAPPINGS
^GO THRU DIFFERENT SECTION TABLES,WRONG USER DATA FETCHED)

; **********************************************************************
;*TST02 - TRY A SHARE POINTER AS A SECTION POINTER.
;*	(LAST TEST USED A PRIVATE SECTION POINTER)
; **********************************************************************

TST02:	SUBTST

	MOVE	A,USECT+0	;GET SECTION POINTER.
	MOVEM	A,SPT+21	;PUT IT IN THE SPT.

	MOVE	A,[SHARE,,21]	;CREATE SHARED POINTER.
	MOVEM	A,USECT+0	;CHANGE SECTION TABLE TO POINT AT SPT.

TST02A:	WREBR	PAGON		;TELL HARDWARE ABOUT THE CHANGE.

	UMOVE	A,777000	;TRY A DATA FETCH AGAIN.

	CAME	A,[2.7]
	ERROR	(TST02A,13,[2.7],A,SHARE POINTER AS SECTION POINTER FAILED,
WRONG DATA FETCHED)

; **********************************************************************
;*TST03 - THIS TIME WE'LL USE AN INDIRECT POINTER AS THE SECTION POINTER.
;*	WITH SECTION OFFSET (POFFST) = 0
; **********************************************************************

POFFST==0

TST03:	SUBTST

	MOVE	A,SPT+21	;FETCH THE SECTION POINTER.
	MOVEM	A,P1+POFFST	;STICK IT SOMEWHERE.
	MOVEM	A,USECT+0	;PUT IT IN SECTION TABLE TOO UNTIL DONE
	MOVEM	A,SAVSPT#	;SAVE FOR RESTORE

	MOVEI	A,P1PN		;GET POINTER TO PAGE CONTAINING POINTER
	MOVEM	A,SPT+21	;INITIALIZE SPT.

	MOVE	A,[NDIREC+POFFST,,21]	;POINTER TO SECTION POINTER.
	MOVEM	A,USECT+0	;STORE INDIRECT POINTER.

TST03A:	WREBR	PAGON		;TELL HARDWARE OF NEW ARRANGEMENT.

	UMOVE	A,777000	;TRY A DATA FETCH.

	CAME	A,[2.7]
	ERROR	(TST03A,13,[2.7],A,
INDIRECT POINTER AS SECTION POINTER FAILED,
WRONG DATA FETCHED)

; **********************************************************************
;*TST04 - THIS TIME WE'LL USE AN INDIRECT POINTER AS THE SECTION POINTER.
;*	WITH SECTION OFFSET (POFFST) = 3
;*	THE KS10 PRESENTLY PAGE FAILS
; **********************************************************************

TST04:	SUBTST

POFFST==3

	SETOM	PFHSPC		;CAUSE PAGE FAIL HANDLER TO JUST FALL THROUGH

	MOVE	A,SPT+21	;FETCH THE SECTION POINTER.
	MOVEM	A,P1+POFFST	;STICK IT SOMEWHERE.
	MOVEM	A,USECT+0	;PUT IT IN SECTION TABLE TOO UNTIL DONE

	MOVEI	A,P1PN		;GET POINTER TO PAGE CONTAINING POINTER
	MOVEM	A,SPT+21	;INITIALIZE SPT.

	MOVE	A,[NDIREC+POFFST,,21]	;POINTER TO SECTION POINTER.
	MOVEM	A,USECT+0	;STORE INDIRECT POINTER.

TST04A:	SETOM	PFF

	WREBR	PAGON		;TELL HARDWARE OF NEW ARRANGEMENT.

	UMOVE	A,777000	;TRY A DATA FETCH.

	SKIPN	XCHECK		;UCODE CURRENTLY PAGE FAILS
	JRST	TST04B

	CAME	A,[2.7]
	ERROR	(TST04A,13,[2.7],A,
^INDIRECT POINTER AS SECTION POINTER WITH SECTION OFFSET FAILED,
WRONG DATA FETCHED)
	JRST	TST05

TST04B:	SKIPN	PFF		;DID PAGE FAIL HAPPEN?
	JRST	TST04C		;YES

	ERROR	(TST04A,13,0,0,
^INDIRECT POINTER AS SECTION POINTER WITH SECTION OFFSET FAILED,
DIDN'T CAUSE PAGE FAILURE)
	JRST	TST05

TST04C:	MOVE	AC,[371003,,055021]
	CAME	AC,PFW
	ERROR	(TST04A,13,[371003055021],PFW,
^INDIRECT POINTER AS SECTION POINTER WITH SECTION OFFSET FAILED,
PAGE FAIL WORD WRONG)

; **********************************************************************
;*TST05 - TRY EACH OF BITS 12-17 OF THE SPT ENTRY,
;*	TO MAKE SURE ANY ONE OF THEM ON CAUSES A PAGE FAIL.
;*	THE SPT ENTRY WE'RE TALKING ABOUT IS THE ONE REFERENCED
;*	BY THE INDIRECT TYPE SECTION POINTER.
; **********************************************************************

TST05:	SUBTST

	MOVSI	T1,-<17-12+1>	;NUMBER OF TIMES TO LOOP THROUGH
	MOVEI	T2,1		;HERE'S THE BIT TO BE SHIFTED THROUGH.

	SETOM	PFHSPC		;CAUSE PAGE FAIL HANDLER TO JUST FALL THROUGH.

TST05A:	DPB	T2,[220600,,SPT+21]	;TURN ON ONE OF THE BITS IN THE ENTRY

	DPB	T2,[220600,,XTEMP]	;TURN ON SAME BIT IN TEMP WORD

TST05B:	SETOM	PFF		;ALLOW A PAGE FAIL.

	WREBR	PAGON		;TELL HARDWARE ABOUT THE NEW ENTRY.

	UMOVE	A,777000	;TRY A REFERENCE.

	SKIPN	PFF		;MAKE SURE THE PAGE FAILURE HAPPENED.
	JRST	TST05C

	ERROR	(TST05B,13,,XTEMP,NON-ZERO IN 12-17 OF SPT,
DIDN'T CAUSE PAGE FAILURE)
	JRST	TST05D

TST05C:	MOVE	AC,[371003,,SPT+21]
	CAME	AC,PFW
	ERROR	(TST05B,13,[371003000000+SPT+21],PFW,NON-ZERO IN 12-17 OF SPT,
PAGE FAIL WORD WRONG)

TST05D:	LSH	T2,1		;TRY NEXT BIT POSITION.
	AOBJN	T1,TST05A

; **********************************************************************
;*TST06 - TRY WITH BITS 12-17 OF THE SPT ENTRY = 0,
;*	TO MAKE SURE NO PAGE FAILURE HAPPENS.
;*	THE SPT ENTRY WE'RE TALKING ABOUT IS THE ONE REFERENCED
;*	BY THE INDIRECT TYPE SECTION POINTER.
; **********************************************************************

TST06:	SUBTST

	MOVEI	T2,0		;TRY 0 AGAIN TO MAKE SURE NO FAILURE HAPPENS.
	DPB	T2,[220600,,SPT+21]

	MOVE	A,[NDIREC,,21]	;POINTER TO SECTION POINTER
	MOVEM	A,USECT+0	;STORE INDIRECT POINTER

TST06A:	SETOM	PFF

	WREBR	PAGON		;TELL HARDWARE ABOUT THE NEW ENTRY

	UMOVE	T2,777000

	SKIPGE	PFF		;MAKE SURE NO PAGE FAIL HAPPENED.
	JRST	TST06B

	ERROR	(TST06A,13,PFW,PFPC,ZERO IN BITS 12-17 OF SPT,
PAGE FAILURE OCCURRED ANYWAY - C=PFW A=PFPC)
	JRST	TST06C

TST06B:	CAME	T2,[2.7]
	ERROR	(TST06A,13,[2.7],T2,ZERO IN BITS 12-17 OF SPT,
WRONG DATA FETCHED)

TST06C:	MOVE	A,SAVSPT	;GET THE SECTION POINTER.
	MOVEM	A,USECT+0	;RESTORE IT.

	WREBR	PAGON

; **********************************************************************
;*TST07 - MAKE SURE THAT SECTION POINTER TYPE 0 CAUSES A PAGE FAIL.
; **********************************************************************

TST07:	SUBTST

TST07A:	SETOM	PFHSPC		;CAUSE HANDLER TO JUST "FALL THROUGH".

	MOVE	A,USECT+0	;GET USER'S SECTION 0 POINTER.

	SETOM	PFF		;ALLOW A PAGE FAILURE.

	MOVEI	B,0		;START WITH 0 IN B.
	UMOVE	B,777000	;FIRST TRY A NORMAL REFERENCE

	SKIPGE	PFF		;MAKE SURE NO FAILURE HAPPENED
	JRST	TST07B

	ERROR	(TST07A,13,PFW,PFPC,SECTION PTR FAILED,
PAGE FAIL HAPPENED - C=PFW A=PFPC)
	JRST	TST07C

TST07B:	CAME	B,[2.7]		;MAKE SURE CORRECT DATA GOT LOADED.
	ERROR	(TST07A,13,[2.7],B,SECTION PTR FAILED,WRONG DATA)

TST07C:	TLZ	A,(7B2)		;SET POINTER TYPE TO 0.
	MOVEM	A,USECT+0	;PUT IN IN SECTION TABLE.

TST07D:	SETOM	PFF		;ALLOW A PAGE FAILURE

	WREBR	PAGON		;TELL HARDWARE ABOUT CHANGE.

	UMOVE	B,777000	;THIS SHOULD CAUSE PAGE FAILURE

	SKIPN	PFF		;MAKE SURE IT DID.
	JRST	TST07E

	ERROR	(TST07D,13,0,0,SECTION POINTER BITS 0-2 WERE ZERO,
NO PAGE FAILURE HAPPENED)
	JRST	TST08

TST07E:	MOVE	AC,[401000,,777000]
	CAME	AC,PFW
	ERROR	(TST07D,13,[401000777000],PFW,
SECTION POINTER BITS 0-2 WERE ZERO,
PAGE FAIL WORD WRONG)

; **********************************************************************
;*TST08 - AFTER THE PRIVATE POINTER THAT ACTUALLY POINTS TO THE PAGE
;*	TABLE IS FOUND, IT'S BITS 12-17 MUST BE 0.
;*	THE FOLLOWING LOOP TRIES EACH OF THESE BITS BEING ON
;*	TO MAKE SURE A PAGE FAIL OCCURS.
;*	IT THEN TURNS THEM ALL OFF AND MAKES SURE NO PAGE FAIL HAPPENS.
; **********************************************************************

TST08:	SUBTST

	MOVEI	A,ACCESS	;GET PRIVATE POINTER ACCESS BITS.

	MOVE	0,CONSW		;GET CONSOLE SWITCHES
	TLNE	0,INHCSH	;INHIBIT CACHE?
	TRZ	A,(CACHEB)	;YES, CLEAR CACHE BIT

	HRLM	A,USECT+0	;USER'S SECTION 0 POINTER IS PRIVATE.

	MOVSI	T1,-<17-12+1>	;NUMBER OF TIMES TO LOOP THROUGH
	MOVEI	T2,1		;HERE'S THE BIT TO BE SHIFTED THROUGH.

	SETOM	PFHSPC		;CAUSE PAGE FAIL HANDLER TO JUST FALL THROUGH.

TST08A:	SETOM	PFF		;ALLOW A PAGE FAIL.

	DPB	T2,[220600,,USECT+0]	;TURN ON BIT IN THE SECTION POINTER
	DPB	T2,[220600,,XTEMP]	;TURN ON SAME BIT IN TEMP WORD

	WREBR	PAGON		;TELL HARDWARE ABOUT THE NEW ENTRY.

	UMOVE	A,777000	;TRY A REFERENCE.

	SKIPN	PFF		;MAKE SURE THE PAGE FAILURE HAPPENED.
	JRST	TST08B

	ERROR	(TST08A,13,0,XTEMP,
NON-0 IN BITS 12-17 OF PRIVATE SECTION POINTER,DIDN'T CAUSE A PAGE FAILURE)
	JRST	TST08C

TST08B:	MOVE	AC,[401000,,777000]
	CAME	AC,PFW
	ERROR	(TST08A,13,[401000777000],PFW,
NON-0 IN BITS 12-17 OF PRIVATE SECTION POINTER,
PAGE FAIL WORD WRONG)

TST08C:	LSH	T2,1		;TRY NEXT BIT POSITION.
	AOBJN	T1,TST08A

; **********************************************************************
;*TST09 - AFTER THE PRIVATE POINTER THAT ACTUALLY POINTS TO THE PAGE
;*	TABLE IS FOUND, IT'S BITS 12-17 MUST BE 0.
;*	THE FOLLOWING TEST TRIES WITH ALL OF THESE BITS BEING ZERO
;*	TO MAKE SURE NO PAGE FAIL OCCURS.
; **********************************************************************

TST09:	SUBTST

TST09A:	SETOM	PFF

	MOVEI	T2,0		;TRY 0 AGAIN TO MAKE SURE NO FAILURE HAPPENS.
	DPB	T2,[220600,,USECT+0]

	UMOVE	T2,777000

	SKIPGE	PFF		;MAKE SURE NO PAGE FAIL HAPPENED.
	JRST	TST09B

	ERROR	(TST09A,13,PFW,PFPC,BITS 12-17=0 IN PRIVATE SECTION POINTER,
PAGE FAILURE - C=PFW A=PFPC)
	JRST	TST10

TST09B:	CAME	T2,[2.7]
	ERROR	(TST09A,13,[2.7],T2,BITS 12-17=0 IN PRIVATE SECTION POINTER,
WRONG DATA FETCHED)

; **********************************************************************
;*TST10 - CHECK THAT A PAGE FAULT HAPPENS WHEN BITS 0-5 OF THE CST ENTRY
;*	FOR THE PAGE TABLE ARE 0.
;*	EVERY POSSIBLE VALUE FOR THESE BITS WILL BE TRIED.
; **********************************************************************

TST10:	SUBTST

	MOVSI	A,-100		;NUMBER OF LOOPS TO DO.

	HRRZ	B,USECT+0	;GET PAGE TABLE LOCATION.

	SETOM	PFHSPC		;ALLOW PAGE FAULT HANDLER TO "FALL THROUGH".

TST10A:	SETOM	PFF		;ALLOW A PAGE FAULT.

	DPB	A,[360600,,CST(B)]	;PUT BIT COMBINATION INTO CST ENTRY.

	SETZM	XTEMP		;INIT TEMP WORD
	DPB	A,[360600,,XTEMP]	;PUT BIT COMBINATION IN TEMP WORD

	WREBR	PAGON		;MAKE SURE HARDWARE USES NEW CST ENTRY.

	UMOVE	C,777000	;TRY A MEMORY REFERENCE.

	TRNE	A,777777	;WERE BITS 0-5 OF CST ENTRY 0 THIS TIME?
	JRST	TST10C		;NO.

	SKIPN	PFF		;YES, MAKE SURE PAGE FAIL HAPPENED.
	JRST	TST10B

	ERROR	(TST10A,13,0,0,CST BITS 0-5 = 0,NO PAGE FAIL HAPPENED)
	JRST	TST10E

TST10B:	MOVE	AC,[401000,,777000]
	CAME	AC,PFW
	ERROR	(TST10A,13,[401000777000],PFW,CST BITS 0-5 = 0,
PAGE FAIL WORD WRONG)
	JRST	TST10E

TST10C:	SKIPGE	PFF		;AND THAT NO PAGE FAIL HAPPENED.
	JRST	TST10D

	ERROR	(TST10A,13,XTEMP,PFW,CST BITS 0-5 NON-0,
PAGE FAILURE - C=CST BITS A=PFW)
	JRST	TST10E

TST10D:	CAME	C,[2.7]		;NO, SO MAKE SURE DATA GOT READ.
	ERROR	(TST10A,13,XTEMP,C,CST BITS 0-5 NON-0,
WRONG DATA FETCHED - C=CST BITS A=DATA)

TST10E:	AOBJN	A,TST10A	;LOOP FOR REST OF BIT COMBINATIONS IN CST.

; **********************************************************************
;*TST11 - THE FOLLOWING TEST CHECKS THAT THE CST ENTRY CORRESPONDING
;*	TO THE PAGE TABLE IS UPDATED CORRECTLY.
;*	VARIOUS VALUES FOR THE CST MASK AND CST DATA WORD WILL BE TRIED.
; **********************************************************************

TST11:	SUBTST

	MOVEI	A,1B31		;MASK TO BE ANDED INTO CST ENTRY.

	MOVSI	T1,-^D31	;NUMBER OF DIFFERENT MASKS TO TRY.

TST11A:	MOVSI	T2,-^D31	;NUMBER OF DIFFERENT DATA WORDS TO TRY.

	IOR	A,[1B0+17B35]	;B0 PREVENTS PAGE FAIL & 17B35 PRESERVES CST

	MOVEI	C,1B31		;DATA TO BE ORED INTO CST ENTRY.

TST11B:	SETOB	T3,CST(B)	;ALWAYS START WITH -1 IN THE CST ENTRY.
	AND	T3,A
	IOR	T3,C		;DO WHAT THE HARDWARE DOES TO THE CST ENTRY.

	WRCSTM	A		;SETUP CST MASK

	WRPUR	C		;SETUP PROCESS USE REGISTER

TST11C:	WREBR	PAGON		;TELL HARDWARE OF NEW ARRANGEMENT.

	UMOVE	T4,777000	;CAUSE THE CST ENTRY TO BE UPDATED.

	MOVE	AC,CST(B)
	CAME	T3,AC		;MAKE SURE THE UPDATE HAPPENED CORRECTLY.
	ERROR	(TST11C,13,T3,AC,CST UPDATE FOR PAGE TABLE,
HAPPENED INCORRECTLY)

	LSH	C,1		;CHANGE THE CST DATA WORD.

	AOBJN	T2,TST11B	;TRY THE DIFFERENT DATA WORD.

	LSH	A,1		;TRIED ALL THE DATA WORDS, CHANGE THE MASK.
	AOBJN	T1,TST11A

; **********************************************************************
;*TST12 - TRY USING A SHARE POINTER IN THE PAGE TABLE.
; **********************************************************************

TST12:	SUBTST

	LSH	B,9		;CHANGE PAGE TABLE TO WORD ADDRESS.

	MOVE	A,777(B)	;PICK UP THE PAGE TABLE ENTRY.
	TLZ	A,700000	;SET ITS TYPE FIELD TO 0.
	MOVEM	A,777(B)	;REPLACE IT.

TST12A:	SETOM	PFHSPC		;TELL PAGE FAULT HANDLER TO DROP THROUGH.
	SETOM	PFF		;ALLOW A PAGE FAULT.

	WREBR	PAGON		;TELL HARDWARE WE'VE CHANGED THE PAGE TABLE.

	UMOVE	A,777000	;REFERENCE THE PAGE TO CAUSE FAULT.

	SKIPN	PFF		;MAKE SURE THE FAULT HAPPENED.
	JRST	TST12B

	ERROR	(TST12A,13,0,0,PAGE POINTER TYPE 0,NO PAGE FAULT)
	JRST	TST12C

TST12B:	MOVE	AC,[401000,,777000]
	CAME	AC,PFW
	ERROR	(TST12A,13,[401000777000],PFW,PAGE POINTER TYPE 0,
PAGE FAIL WORD WRONG)

TST12C:	MOVE	A,777(B)	;PICK UP THE PAGE POINTER AGAIN.
	MOVEM	A,SPT+22	;PUT IT IN THE SPT.

	MOVE	A,[SHARE,,22]	;GET A SHARE POINTER.
	MOVEM	A,777(B)	;PUT SHARE POINTER IN PAGE TABLE.

TST12D:	WREBR	PAGON		;TELL HARDWARE ABOUT NEW ARRANGEMENT.

	UMOVE	A,777000	;MAKE THE REFERENCE.

	CAME	A,[2.7]		;MAKE SURE DATA GOT RETRIEVED.
	ERROR	(TST12D,13,[2.7],A,SHARE POINTER IN PAGE TABLE FAILED
WRONG DATA FETCHED)

; **********************************************************************
;*TST13 - NOW WE'LL TRY AN INDIRECT POINTER IN THE PAGE TABLE.
; **********************************************************************

TST13:	SUBTST

	MOVE	A,SPT+22
	HRLI	A,ACCESS	;GET THE PRIVATE POINTER BACK AGAIN.
	MOVEM	A,777(B)	;PUT IT BACK IN PAGE TABLE.

TST13A:	UPAGMP	(P3,776)	;GET ACCESS TO USER PAGE 776.

	SETZM	P3		;CLEAR A WORD IN THAT PAGE.
	SKIPE	P3
	ERROR	(TST13A,13,[0],P3,WRITE TO USER PAGE,SETZM FAILED)

	MOVE	A,[17.76]	;SOME DATA FOR THAT PAGE.
	UMOVEM	A,776000	;STORE DATA IN USER PAGE.

	MOVEI	A,0
	UMOVE	A,776000

	CAME	A,[17.76]
	ERROR	(TST13A,13,[17.76],A,UMOVEM/UMOVE TO USER PAGE FAILED,
WRONG DATA FETCHED)

	MOVE	A,USECT+0	;FIND OUT WHERE PAGE TABLE IS.
	MOVEM	A,SPT+23	;STORE IT IN THE SPT.

	MOVE	B,[NDIREC+777,,23]	;GET INDIRECT POINTER.
	LSH	A,9		;CHANGE TO WORD ADDRESS.
	MOVEM	B,776(A)	;NOW REFS TO PAGE 776 SHOULD GO TO PAGE 777.

TST13B:	WREBR	PAGON		;TELL HARDWARE ABOUT NEW SETUP.

	UMOVE	A,776000	;TRY A REFERENCE.

	CAME	A,[2.7]		;MAKE SURE WE GOT DATA FROM PAGE 777000
	ERROR	(TST13B,13,[2.7],A,INDIRECT PTR IN PAGE TABLE FAILED,
WRONG DATA FETCHED)

; **********************************************************************
;*TST14 - MAKE SURE THAT ANY NON-0 VALUE FOR BITS 12-17 OF FINAL POINTER
;*	CAUSES A PAGE FAILURE.
; **********************************************************************

TST14:	SUBTST

	MOVE	A,[-<1_<17-12+1>>,,1]	;NOTE THAT 12-17 = 0 WILL BE DONE LAST.

	MOVE	B,USECT+0	;GET ADDRESS OF PAGE TABLE.
	LSH	B,9		;CHANGE TO WORD ADDRESS.

	SETOM	PFHSPC		;TELL HANDLER TO FALL THROUGH.

TST14A:	DPB	A,[220600,,777(B)] ;STORE A VALUE IN BITS 12-17 OF PAGE 777 ENTRY.
	SETZM	XTEMP		;INIT TEMP WORD
	DPB	A,[220600,,XTEMP]	;SAME BITS TO TEMP WORD

	SETOM	PFF		;ALLOW A PAGE FAILURE.

	WREBR	PAGON		;TELL HARDWARE WE'VE CHANGED THE BITS.

	MOVEI	C,0		;START WITH 0.
	UMOVE	C,777000	;REFERENCE THE PAGE.

	TRNE	A,77		;WERE BITS 12-17 ALL 0 THIS TIME ?
	JRST	TST14B		;NO.

	CAME	C,[2.7]		;MAKE SURE RIGHT DATA GOT READ.
	ERROR	(TST14A,13,[2.7],C,BITS 12-17 OF FINAL PTR WERE 0,
WRONG DATA FETCHED)

	SKIPL	PFF		;MAKE SURE NO PAGE FAIL HAPPENED.
	ERROR	(TST14A,13,PFW,PFPC,BITS 12-17 OF FINAL PTR WERE 0,
PAGE FAIL - C=PFW A=PFPC)

	JRST	TST14C		;SKIP "NON-0" TEST.

TST14B:	SKIPE	PFF		;MAKE SURE PAGE FAIL HAPPENED.
	ERROR	(TST14A,13,0,XTEMP,BITS 12-17 OF PAGE PTR NON-0,NO PAGE FAIL)

	MOVE	AC,[401000,,777000]
	CAME	AC,PFW
	ERROR	(TST14A,13,[401000777000],PFW,
BITS 12-17 OF PAGE PTR NON-0,
PAGE FAIL WORD WRONG)

TST14C:	AOBJN	A,TST14A	;LOOP FOR REST OF BITS 12-17 VALUES.

; **********************************************************************
;*TST15 - NOW WE'LL CHECK A PAGE FAIL OCCURS IF AND ONLY IF BITS 0-5
;*	OF CST ENTRY FOR PAGE IS 0.
; **********************************************************************

TST15:	SUBTST

	HRR	B,777(B)	;FIND OUT PHYSICAL PAGE NUMBER.

	MOVSI	A,-100		;NUMBER OF LOOPS TO DO.

	SETOM	PFHSPC		;ALLOW PAGE FAULT HANDLER TO "FALL THROUGH".

TST15A:	SETOM	PFF		;ALLOW A PAGE FAULT.

	DPB	A,[360600,,CST(B)]	;PUT BIT COMBINATION INTO CST ENTRY.

	SETZM	XTEMP		;INIT TEMP WORD
	DPB	A,[360600,,XTEMP]	;SAME BITS TO TEMP WORD

	WREBR	PAGON		;MAKE SURE HARDWARE USES NEW CST ENTRY.

	UMOVE	C,777000	;TRY A MEMORY REFERENCE.

	TRNE	A,777777	;WERE BITS 0-5 OF CST ENTRY 0 THIS TIME?
	JRST	TST15B		;NO.

	SKIPE	PFF		;YES, MAKE SURE PAGE FAIL HAPPENED.
	ERROR	(TST15A,13,0,0,CST BITS 0-5 = 0,NO PAGE FAIL)
	JRST	TST15C

TST15B:	CAME	C,[2.7]		;NO, SO MAKE SURE DATA GOT READ.
	ERROR	(TST15A,13,[2.7],C,CST BITS 0-5 NON-0,WRONG DATA FETCHED)

	SKIPL	PFF		;AND THAT NO PAGE FAIL HAPPENED.
	ERROR	(TST15A,13,0,XTEMP,CST BITS 0-5 NON-0,PAGE FAIL)

TST15C:	AOBJN	A,TST15A	;LOOP FOR REST OF BIT COMBINATIONS IN CST.

; **********************************************************************
;*TST16 - TRY TURNING OFF THE WRITE BIT IN THE SECTION POINTER,
;*	AND MAKE SURE THAT WE CAN STILL READ THE DATA,
;*	BUT NOT WRITE THE DATA.
; **********************************************************************

TST16:	SUBTST

	MOVE	A,USECT+0	;GET THE SECTION POINTER.
	TLZ	A,(WRITEB)	;TURN OFF THE WRITE BIT.
	MOVEM	A,USECT+0	;UPDATE SECTION POINTER.

	SETOM	PFHSPC		;LET PAGE FAIL HANDLER FALL THROUGH.

TST16A:	SETOM	PFF		;ALLOW A PAGE FAILURE.

	WREBR	PAGON		;TELL HARDWARE ABOUT THE CHANGE.

	UMOVE	A,777000	;TRY A READ.

	CAME	A,[2.7]		;MAKE SURE DATA GOT FETCHED.
	ERROR	(TST16A,13,[2.7],A,
READ REFERENCE WITH W BIT OFF IN SECTION POINTER,WRONG DATA FETCHED)

	SKIPL	PFF		;MAKE SURE NO PAGE FAIL HAPPENED.
	ERROR	(TST16A,13,PFW,PFPC,
READ REFERENCE WITH W BIT OFF IN SECTION POINTER,
PAGE FAIL OCCURRED - C=PFW A=PFPC)

TST16B:	SETOM	PFF		;ALLOW ANOTHER PAGE FAIL.

	PXCT	4,[SETMM 777000]	;TRY A WRITE REFERENCE.

	SKIPE	PFF		;MAKE SURE PAGE FAIL HAPPENED.
	ERROR	(TST16B,13,0,0,
WRITE WITH W BIT OFF IN SECTION POINTER,NO PAGE FAIL OCCURRED)

	MOVE	AC,[511000,,777000]
	CAME	AC,PFW
	ERROR	(TST16B,13,[511000777000],PFW,
WRITE WITH W BIT OFF IN SECTION POINTER,PAGE FAIL WORD WRONG)

; **********************************************************************
;*TST17 - NOW TURN THE WRITE BIT BACK ON,
;*	AND TURN IT OFF IN THE PAGE TABLE,
;*	AND TRY THE SAME TEST.
; **********************************************************************

TST17:	SUBTST

	MOVE	A,USECT+0	;GET SECTION POINTER AGAIN.
	TLC	A,(WRITEB)	;TURN WRITE BIT BACK ON (TLC USED ON PURPOSE)
	MOVEM	A,USECT+0	;REPLACE SECTION POINTER.

	LSH	A,9		;GET WORD ADDRESS OF PAGE TABLE.
	MOVE	B,777(A)	;GET PAGE TABLE ENTRY.
	TLC	B,(WRITEB)	;TURN WRITE BIT OFF IN PAGE TABLE.

	SETOM	PFHSPC		;LET PAGE FAIL HANDLER FALL THROUGH.

	MOVEM	B,777(A)	;UPDATE PAGE POINTER.

TST17A:	SETOM	PFF		;ALLOW A PAGE FAILURE.

	WREBR	PAGON		;TELL HARDWARE ABOUT THE CHANGE.

	UMOVE	C,777000	;TRY A READ.

	CAME	C,[2.7]		;MAKE SURE DATA GOT FETCHED.
	ERROR	(TST17A,13,[2.7],C,READ REF WITH W BIT OFF IN SEC PTR,
WRONG DATA FETCHED)

	SKIPL	PFF		;MAKE SURE NO PAGE FAIL HAPPENED.
	ERROR	(TST17A,13,PFW,PFPC,READ REF WITH W BIT OFF IN SEC PTR,
PAGE FAIL - C=PFW A=PFPC)

TST17B:	SETOM	PFF		;ALLOW ANOTHER PAGE FAIL.

	PXCT	4,[SETMM 777000]	;TRY A WRITE REFERENCE.

	SKIPE	PFF		;MAKE SURE PAGE FAIL HAPPENED.
	ERROR	(TST17B,13,0,0,WRITE WITH W BIT OFF IN PAGE PTR,NO PAGE FAIL)

; **********************************************************************
;*TST18 - MAKE SURE THAT B35 OF THE CST ENTRY FOR THE PAGE
;*	BEING REFERENCED DOESN'T GET TURNED ON BY A READ REFERENCE.
; **********************************************************************

TST18:	SUBTST

	MOVE	B,777(A)	;GET PAGE TABLE ENTRY AGAIN.
	TLC	B,(WRITEB)	;TURN WRITE BIT BACK ON AGAIN.
	MOVEM	B,777(A)

	HRRZ	A,B		;GET PHYS PAGE NUMBER

TST18A:	MOVE	B,CST(A)	;GET CST ENTRY FOR PAGE.
	TRZ	B,1		;MAKE SURE "WRITTEN" BIT IS OFF.
	MOVEM	B,CST(A)

	WREBR	PAGON		;TELL HARDWARE OF CHANGES.

	UMOVE	C,777000	;MAKE A READ REFERENCE.

	MOVE	B,CST(A)	;GET CST ENTRY AGAIN.

	TRZE	B,1		;INSURE WRITTEN BIT STILL OFF.
	ERROR	(TST18A,13,0,0,READ REFERENCE,WRITTEN BIT GOT SET)

; **********************************************************************
;*TST19 - NOW WE'LL MAKE A WRITE REFERENCE AND MAKE SURE IT DOES COME ON.
; **********************************************************************

TST19:	SUBTST

TST19A:	MOVEM	B,CST(A)	;REPLACE CST ENTRY WITH WRITTEN BIT OFF

	PXCT	4,[SETMM 777000]	;MAKE A WRITE REFERENCE.

	MOVE	B,CST(A)	;PICK UP CST ENTRY ONCE MORE.

	TRZN	B,1		;MAKE SURE WRITTEN BIT CAME ON.
	ERROR	(TST19A,13,0,0,WRITE REFERENCE,B35 OF CST ENTRY DIDN'T SET)

; **********************************************************************
;*TST20 - THE FOLLOWING TEST MAKES SURE THE CST ENTRY FOR THE ACTUAL
;*	PAGE BEING REFERENCED IS UPDATED CORRECTLY.
;*	VARIOUS VALUES FOR THE MASK AND DATA WILL BE TRIED.
; **********************************************************************

TST20:	SUBTST

	MOVE	A,USECT+0	;GET SECTION POINTER.
	LSH	A,9		;GET ADDRESS OF PAGE TABLE.
	MOVE	B,777(A)	;GET PHYSICAL PAGE NUMBER OF PAGE.

	MOVEI	A,1B31		;MASK TO BE ANDED INTO CST ENTRY.
	MOVSI	T1,-^D31	;NUMBER OF DIFFERENT MASKS TO TRY.

TST20A:	MOVSI	T2,-^D31	;NUMBER OF DIFFERENT DATA WORDS TO TRY.

	IOR	A,[1B0+17B35]	;B0 PREVENTS PAGE FAIL & 17B35 PRESERVES CST

	MOVEI	C,1B31		;DATA TO BE ORED INTO CST ENTRY.

TST20B:	SETOB	T3,CST(B)	;ALWAYS START WITH -1 IN THE CST ENTRY.
	AND	T3,A
	IOR	T3,C		;DO WHAT THE HARDWARE DOES TO THE CST ENTRY.

	WRCSTM	A		;SETUP CST MASK

	WRPUR	C		;SETUP PROCESS USE REGISTER

	WREBR	PAGON		;TELL HARDWARE OF NEW ARRANGEMENT.

	UMOVE	T4,777000	;CAUSE THE CST ENTRY TO BE UPDATED.

	MOVE	AC,CST(B)
	CAME	T3,AC		;MAKE SURE THE UPDATE HAPPENED CORRECTLY.
	ERROR	(TST20B,13,T3,AC,CST UPDATE FOR PAGE TABLE,FAILED)

	LSH	C,1		;CHANGE THE CST DATA WORD.
	AOBJN	T2,TST20B	;TRY THE DIFFERENT DATA WORD.

	LSH	A,1		;TRIED ALL THE DATA WORDS, CHANGE THE MASK.
	AOBJN	T1,TST20A

; **********************************************************************
;*TST21 - THE FOLLOWING TEST MAKES SURE THAT TIMER INTERRUPTS
;*	ARE ALLOWED OUT OF INDIRECT POINTER CHAINS DUE TO
;*	AN INDIRECT SECTION POINTER.
;*	THE KS10 DOESN'T DO THIS TEST SINCE IT IS A SINGLE SECTION MACHINE.
; **********************************************************************

TST21:	SUBTST

	MOVEI	A,IPAGPN	;INITIALIZE SPT ENTRY.
	MOVEM	A,SPT+3		;TO POINT TO INDIRECT PAGE

	MOVE	A,[NDIREC+1,,3]	;GET INITIAL INDIRECT POINTER.

	MOVSI	B,-777		;NUMBER OF INDIRECT POINTERS TO SET UP.

TST21A:	MOVEM	A,IPAG(B)	;STORE AN INDIRECT POINTER.

	ADD	A,[1,,0]	;CREATE NEXT INDIRECT POINTER FOR CHAIN
	AOBJN	B,TST21A	;SET UP REST OF INDIRECT CHAIN.

				; ******************************
	SKIPN	XCHECK		;CAN'T TEST IF UCODE DOESN'T
	JRST	TST22		; ******************************

	MOVE	A,USECT+0	;GET PRIVATE SECTION POINTER FOR END OF CHAIN.
	MOVEM	A,IPAG+777	;FINISH THE INDIRECT CHAIN.

	MOVE	B,[NDIREC,,3]	;INITIALIZE THE FIRST POINTER.
	MOVEM	B,USECT+0	;SET UP FIRST POINTER.

	MOVE	C,IPAG+402	;TEST CHAIN BY BREAKING IT SOMEWHERE.

TST21B:	SETZM	IPAG+402

	WREBR	PAGON		;TELL HARDWARE ABOUT THIS WILD ARRANGEMENT.

	SETOM	PFF		;PREPARE FOR A PAGE FAILURE.

	UMOVE	A,777000	;TRY A REFERENCE.

	SKIPE	PFF		;MAKE SURE A PAGE FAILURE HAPPENED.
	ERROR	(TST21B,13,0,0,INCOMPLETE INDIRECT CHAIN,NO PAGE FAIL)

	MOVE	AC,[371010,,031000]
	CAME	AC,PFW
	ERROR	(TST21B,13,[371010031000],PFW,
INCOMPLETE INDIRECT CHAIN,PAGE FAIL WORD WRONG)

	MOVEM	C,IPAG+402	;REPAIR THE CHAIN.

TST21C:	WREBR	PAGON		;TELL THE HARDWARE.

	SETOM	PFF		;GUARD AGAINST PAGE FAILURE.

	MOVEI	A,0		;START WITH 0 AS DATA.
	UMOVE	A,777000	;TEST THE CHAIN.

	SKIPL	PFF		;MAKE SURE NO PAGE FAILURE HAPPENED.
	ERROR	(TST21C,13,PFW,PFPC,LONG INDIRECT SECTION PTR,
PAGE FAILED - C=PFW A=PFPC)

	CAME	A,[2.7]		;MAKE SURE CORRECT DATA GOT READ.
	ERROR	(TST21C,13,[2.7],A,LONG INDIRECT SECTION PTR,
WRONG DATA FETCHED)

TST21D:	WREBR	PAGON		;CLEAR HPT

	WRTIM	TWOZER		;DOUBLE WORD OF ZEROS

	UMOVE	A,777000	;SCAN THE WHOLE INDIRECT CHAIN.

	RDTIME	TWOTMP		;READ DOUBLE WORD (4.096 MHZ CLOCK)

	DMOVE	A,TWOTMP	;GET DBLWD RESULT
	DIVI	A,4*<5+5>*2	;A NOW HOLDS TIME IN 10 USEC CHUNKS/2

	TDNE	A,[-1-7777]	;MAKE SURE NUMBER IS IN APPLICABLE RANGE.
	ERROR	(TST21D,13,[-1-7777],A,INDIRECT SECTION POINTER CHAIN,
UNEXPECTED TIME TO SCAN CHAIN)

	MOVEM	A,INTRVL	;STORE TIMER PERIOD TO USE.

	WRPI	PIOFF		;TURN OFF THE PI SYSTEM.

	WRAPR	1B20!1B22!1B30!LAPRP1	;PUT INTERVAL TIMER ON CHN

	MOVE	A,[JSR TST21F]	;TIMER INTERRUPT INSTRUCTION.
	MOVEM	A,EPT+42	;SETUP INTERRUPT INSTRUCTION.

	WREBR	PAGON		;MAKE HARDWARE FORGET AGAIN.

	WRPI	1B23!1B25!1B28!PICHN1	;ACTIVATE CHN

	WRINT	INTRVL		;LOAD INTERVAL TIMER

TST21E:	UMOVE	C,777000	;REFERENCE THE LONG CHAIN.

	ERROR	(TST21D,13,0,0,INDIRECT POINTER CHAIN,NO TIMER INTERRUPT)
	JRST	TST21G		;SKIP OVER THE INTERRUPT ROUTINE.

TST21F:	0			;HOLDS PC FROM WHERE TIMER INTERRUPT OCCURED.

	HRRZ	A,TST21F	;FIND OUT WHERE WE INTERRUPTED FROM.

	CAIE	A,TST21E	;MAKE SURE IT'S THE "MOVE" INSTRUCTION.
	ERROR	(TST21D,13,TST21E,A,INDIRECT POINTER CHAIN,
UNEXPECTED INTERVAL TIMER INTERRUPT)

	CAIE	A,TST21E
	JRST	2,@TST21F	;JUST RETURN TO PROGRAM IF STRANGE INTERRUPT

	MOVE	A,TST21F	;SET UP FOR RETURN WITH RESTORE OF FLGS
	HRRI	A,TST21G	;RESTORE FLAGS AND GO ON
	JRST	2,@A

TST21G:	WRPI	30400		;TURN OFF THE PI SYSTEM.
	MOVE	A,IPAG+777	;GET THE ORIGINAL PRIVATE SECTION PTR
	MOVEM	A,USECT+0	;PUT IT BACK

; **********************************************************************
;*TST22 - THE FOLLOWING TEST MAKES SURE A TIMER INTERRUPT
;*	MAY BE TAKEN OUT OFA LONG CHAIN OF INDIRECT PAGE POINTERS.
;*	(THE LAST TEST WAS WITH SECTION POINTERS)
; **********************************************************************

TST22:	SUBTST

	MOVE	A,USECT		;POINT TO USER SECTION
	LSH	A,9		;GET ADDRESS OF PAGE TABLE.

	MOVE	B,777(A)	;GET PAGE POINTER.
	MOVEM	B,IPAG+777	;STORE IT AS LAST POINTER IN CHAIN.

	MOVE	C,[NDIREC,,3]	;INITIALIZE THE FIRST POINTER.
	MOVEM	C,777(A)	;SET UP FIRST POINTER.

	MOVE	C,IPAG+402	;TEST CHAIN BY BREAKING IT SOMEWHERE.
	SETZM	IPAG+402

TST22A:	WREBR	PAGON		;TELL HARDWARE ABOUT THIS WILD ARRANGEMENT.

	SETOM	PFF		;PREPARE FOR A PAGE FAILURE.

	UMOVE	A,777000	;TRY A REFERENCE.

	SKIPE	PFF		;MAKE SURE A PAGE FAILURE HAPPENED.
	ERROR	(TST22A,13,0,0,INCOMPLETE INDIRECT CHAIN,NO PAGE FAIL)

	MOVE	AC,[401000,,777000]
	CAME	AC,PFW
	ERROR	(TST22A,13,[401000777000],PFW,INCOMPLETE INDIRECT CHAIN,
PAGE FAIL WORD WRONG)

	MOVEM	C,IPAG+402	;REPAIR THE CHAIN.

	WREBR	PAGON		;TELL THE HARDWARE.

TST22B:	SETOM	PFF		;GUARD AGAINST PAGE FAILURE.

	MOVEI	A,0		;START WITH 0 AS DATA.
	UMOVE	A,777000	;TEST THE CHAIN.

	SKIPL	PFF		;MAKE SURE NO PAGE FAILURE HAPPENED.
	ERROR	(TST22B,13,PFW,PFPC,LONG INDIRECT PAGE POINTER CHAIN,
PAGE FAIL - C=PFW A=PFPC)

	CAME	A,[2.7]		;MAKE SURE CORRECT DATA GOT READ.
	ERROR	(TST22B,13,[2.7],A,LONG INDIRECT PAGE POINTER CHAIN,
WRONG DATA FETCHED)

TST22C:	WRPI	PICLR!PIOFF	;CLEAR AND TURN OFF THE PI SYSTEM.

	WREBR	PAGON		;CLEAR HPT

	WRTIM	TWOZER		;DOUBLE WORD OF ZEROS

	UMOVE	A,777000	;SCAN THE WHOLE INDIRECT CHAIN.

	RDTIME	TWOTMP		;READ DOUBLE WORD TIME BASE

	DMOVE	A,TWOTMP	;GET DBLWD RESULT
	DIVI	A,4*<5+5>*2	;A NOW HOLDS TIME IN 10 USEC CHUNKS/2

	TDNE	A,[-1-7777]	;MAKE SURE NUMBER IS IN APPLICABLE RANGE.
	ERROR	(TST22C,13,[-1-7777],A,INDIRECT PAGE POINTER CHAIN,
UNEXPECTED TIME TO SCAN CHAIN)

	MOVEM	A,INTRVL	;STORE THE INTERVAL TO USE.

	WRPI	PICLR!PIOFF	;CLEAR AND TURN OFF THE PI SYSTEM.

	MOVE	A,[JSR TST22E]	;TIMER INTERRUPT INSTRUCTION.
	MOVEM	A,EPT+42	;SET IT UP

	WREBR	PAGON		;MAKE HARDWARE FORGET AGAIN.

	WRINT	INTRVL		;LOAD INTERVAL TIMER

	WRAPR	LFLGEN!LFLGCL!LACLK!LAPRP1	;PUT CLK TIMER ON CHN

	WRPI	PICLR!CHNON!PION!PICHN1	;ACTIVATE CHN

TST22D:	UMOVE	C,777000	;REFERENCE THE LONG CHAIN.

	ERROR	(TST22C,13,0,0,INDIRECT PAGE POINTER CHAIN,
NO TIMER INTERRUPT)
	JRST	TST22F		;SKIP OVER THE INTERRUPT ROUTINE.

TST22E:	0			;HOLDS PC FROM TIMER INTERRUPT 

	HRRZ	A,TST22E	;FIND OUT WHERE WE INTERRUPTED FROM.

	CAIE	A,TST22D	;MAKE SURE IT'S THE "MOVE" INSTRUCTION.
	ERROR	(TST22C,13,0,0,INDIRECT PAGE POINTER CHAIN,
UNEXPECTED TIMER INTERUPT)

	CAIE	A,TST22D
	JRST	2,@TST22E	;JUST RETURN IF FROM STRANGE PLACE

	MOVE	A,TST22E	;RESTORE FLAGS AND CONTINUE
	HRRI	A,TST22F	;AFTER RESTORE GO TO TST22F
	JRST	2,@A

TST22F:	WRPI	30400		;TURN OFF THE PI SYSTEM.

	MOVE	A,USECT+0	;GET THE SECTION POINTER AGAIN.
	LSH	A,9		;CHANGE TO ADDRESS OF PAGE TABLE

	MOVE	B,IPAG+777	;GET PAGE POINTER
	MOVEM	B,777(A)	;NOW SECTION 0 USER PAGING IS OK AGAIN.

; **********************************************************************
;*TST23 - VERIFY THAT WITH EVERYTHING RESTORED TO NORMAL
;*	THAT A PAGING REFERENCE WORKS
; **********************************************************************

TST23:	SUBTST

TST23A:	SETOM	PFF

	WREBR	PAGON		;RESET HPT

	SETOM	PFHSPC		;CLEAR PAGE FAIL FLAG

	PXCT	4,[SETZM 777000]	;DO REFERENCE

	SKIPL	PFF		;TEST THE PAGING NOW 
	ERROR	(TST23A,13,PFW,PFPC,MEMORY REFERENCE,
UNEXPECTED PAGE FAIL - C=PFW A=PFPC)

; **********************************************************************

	RTN			;DONE

SUBTTL MEMORY MANAGEMENT

; **********************************************************************
;*KLPAGE
;*	THIS ROUTINE INITIALIZES PAGING.  ALL EXEC SECTION 0 PAGES ARE
;*	MAPPED TO THEMSELVES.  ALL OTHER EXEC PAGES, AND ALL USER PAGES
;*	ARE RENDERED INNACCESSIBLE.  SEE THE PAGMAP AND UPAGMP MACROS
;*	FOR MAKING PAGES ACCESSIBLE.
; **********************************************************************

KLPAGE:	WREBR	PAGOFF		;TURN OFF PAGING

	SETZM	ESECT		;CLOSE SECTION 0.
	SETZM	USECT		;CLOSE USER SECTION 0.

	MOVE	A,[ACCESS,,MAP0PN]

	MOVE	0,CONSW		;GET CONSOLE SWITCHES
	TLNE	0,INHCSH	;INHIBIT CACHE?
	TLZ	A,(CACHEB)	;YES, CLEAR CACHE BIT
	MOVEM	A,ESECT+0	;SET UP EXEC SECTION 0 POINTER.

;ZERO OUT THE SPECIAL PAGE TABLE.

	MOVE	A,[SPT,,SPT+1]
	SETZM	SPT		;CLEAR THE FIRST WORD
	BLT	A,SPT+777	;AND THE REST

;CLEAR OUT ALL THE PAGE TABLES.

	SETZM	PUSE
	MOVE	A,[PUSE,,PUSE+1]
	BLT	A,PUSE+NPAGES-1	;CLEAR OUT PAGE USE TABLE.

	SETZM	MAP0
	MOVE	A,[MAP0,,MAP0+1]
	BLT	A,MAP0+777	;CLEAR SECTION 0 EXEC TABLE.

	SETZM	MAP1
	MOVE	A,[MAP1,,MAP1+1]
	BLT	A,MAP1+NPAGES_9-1	;CLEAR THE TEST PAGE TABLES.

;MAP ALL SECTION 0 PAGES TO THEMSELVES

	MOVSI	C,ACCESS	;LEFT HALF FOR PAGE TABLE ENTRIES
	MOVE	B,CONSW		;GET THE SWITCHES
	TLNE	B,INHCSH	;INHIBIT CACHE?
	TLZ	C,(CACHEB)	;YES, CLEAR THE CACHE BIT

	MOVSI	B,-1000		;POINTER TO  MAP0
PTLUP:	HRRM	B,MAP0(B)	;INITIALIZE EXEC SEC 0 PAGE TABLE ENTRY
	HLLM	C,MAP0(B)	;AND ITS LEFT HALF
	AOBJN	B,PTLUP		;LOOP UNTIL ALL ENTRIES MADE.

	TLZE	C,(CACHEB)	;NOW CLEAR THE CACHEB (SKIP IF CLEAR)
	HLLM	C,MAP0		;AND SET PAGE ZERO'S ENTRY W/OUT CACHE

;INITIALIZE THE CST

	MOVSI	A,-CSTLEN	;POINTER TO CST
	MOVSI	B,770000	;DATA FOR EVERY CST WORD
CSTINI:	MOVEM	B,CST(A)	;INITIALIZE A CST ENTRY
	AOBJN	A,.-1		;LOOP BACK FOR REST OF CST.

;SET UP CST MASK, DATA, AND BASE REGISTERS

	WRCSTM	[-1]		;PUT ALL 1'S IN CST MASK WORD
	WRSPB	[SPT]		;PUT SPT ADDR IN SPT BASE REGISTER
	WRCSB	[CST]		;PUT CST ADDR IN CST BASE REGISTER

;INITIALIZE MUUO HANDLER

	MOVEI	A,MUUOH		;GET ADDRESS OF MUUO HANDLER
	MOVEM	A,UUONPC	;STORE IT WHERE COMPUTER WANTS IT.
	MOVE	A,[UUONPC,,UUONPC+1]
	BLT	A,UUONPC+5	;ONE OF THESE LOCATIONS IS FETCHED

;SET UP PAGE FAULT HANDLER ADDRESS

	XMOVEI	A,PFH		;GET ADDRESS OF PAGE FAULT HANDLER
	MOVEM	A,PFHA		;STORE PAGE FAULT HANDLER

	WRUBR	UPWD		;SETUP UPT
	WREBR	PAGON		;SETUP EPT, TURN ON PAGING
	RTN

; **********************************************************************
;*MUUOH - THIS ROUTINE GETS TRANSFERRED TO ON ANY MUUO.
; **********************************************************************
								SALL
MUUOH:	PUT	A		;DON'T CLOBBER ANY AC'S
	JSP	A,.+1
	MOVEM	A,UUOSPF	;STORE PC FLAGS FOR NON-X MACHINE.

	ERROR1	13,0,0,BAD MUUO,,BADUUO
	FATAL

BADUUO:	PMSGF	< TEST PC = >
	MOVE	TESTPC
	PNTOCF

	PMSGF	<^ MUUO = >
	MOVE	MCODE
	PNTHWF

	PMSGF	<, MUUO PC = >
	MOVE	MOLDPC		;GET PC OF ERROR
	PNTHWF			;SHOW IT

	PCRLF
	RTN

; **********************************************************************
;*PFH - PAGE FAULT HANDLER
; **********************************************************************

PFH:	AOSE	PFF		;MAKE SURE A PAGE FAULT IS ALLOWED.
	JRST	BADPF		;BAD PAGE FAULT, GO TELL.

	SKIPL	PFHSPC		;-1 IN PFHSPC MEANS "FALL THROUGH"
	JRST	@PFHSPC		;GO HANDLE SPECIAL PAGE FAULT.

	AOS	PFPC		;DON'T RETURN TO OFFENDING INSTRUCTION!
	XJRSTF	PFFLGS		;FALL THRU PAGE FAIL INSTRUCTION

BADPF:	ERROR1	13,0,0,BAD PAGE FAIL,,BADPFX
	FATAL

BADPFX:	PMSGF	< TESTPC = >
	MOVE	TESTPC
	PNTOCF

	PMSGF	<^ PFW = >
	MOVE	PFW		;GET PAGE FAIL WORD
	PNTHWF			;SHOW IT

	PMSGF	<, PFPC = >
	MOVE	PFPC		;GET PAGE FAIL PC
	PNTHWF			;SHOW IT

	PCRLF
	RTN

; **********************************************************************
;*PMAPRT - PAGE MAPPING ROUTINE
; **********************************************************************

PMAPRT:	SETZM	B		;SECTION NUMBER ALWAYS ZERO

	MOVE	T2,A
	LSH	T2,-9		;GET PAGE NUMBER BEING UNMAPPED.
	SUBI	T2,P1PN		;NOW WE HAVE INDEX INTO PUSE TABLE.

	SKIPN	AC4,PUSE(T2)	;PICK UP LAST MAPPING
	JRST	NREMOB		;IT WAS NEVER MAPPED

	MOVEI	AC7,ESECT	;FIRST ASSUME IT WAS AN EXEC MAPPING.
	TLZE	AC4,1
	MOVEI	AC7,USECT	;NO, IT WAS A USER MAPPING.

	LSHC	AC4,-9		;GET PAGE NUMBER OF OLD MAPPING
	LSH	AC5,-^D27	;NOW OLD SECTION # IN AC4, OLD PAGE # IN AC5.

	ADD	AC7,AC4		;CREATE ADDRESS OF PAGE TABLE POINTER.

	MOVE	AC4,(AC7)	;PICK UP THE STARTING ADDRESS OF THE PAGE TABLE.
	LSH	AC4,9		;CHANGE TO CORE ADDRESS.

	ADD	AC4,AC5		;CREATE ADDRESS OF PAGE TABLE ENTRY.

	SETZM	(AC4)		;CLEAR OUT THE OLD ENTRY.

	MOVE	T4,PUSE(T2)	;PICK UP THE OLD MAPPING INFO.
	TRZ	T4,777		;KEEP ONLY THE USER BIT AND SECTION NUMBER.

	MOVSI	AC10,-NPAGES	;LOOK FOR OTHER MAPPINGS IN SAME SECTION.

LK1:	MOVE	AC11,PUSE(AC10)	;PICK UP A MAPPING.
	TRZ	AC11,777	;CLEAR PAGE NUMBER.

	CAME	AC11,T4		;IS THIS A MAPPING IN THE SAME SECTION ?
	JRST	NOQ		;THIS ONE ISN'T THE SAME SECTION.

	CAIE	T2,(AC10)	;COMPARING THE CURRENT ENTRY WITH ITSELF ?
	JRST	NREMOB		;NO, THE SECTION IS STILL IN USE.

NOQ:	AOBJN	AC10,LK1	;KEEP LOOKING.

	SETZM	(AC7)		;NO OTHER PAGE USING SECTION, FREE PAGE TABLE.

NREMOB:	MOVE	T1,ESECT(B)	;FIRST ASSUME THIS IS AN EXEC MAPPING.
	CAIE	T3,0
	MOVE	T1,USECT(B)	;NO, IT'S A USER MAPPING.

	JUMPN	T1,GOTONE	;SECTION ALREADY HAS A PAGE TABLE IF NON-ZERO.

	MOVSI	T2,-NPAGES	;IT DOESN'T, SO LET'S LOOK FOR A FREE PAGE MAP.
	MOVEI	T4,MAP1PN	;SETUP PAGE MAP PAGE NUMBER WE'RE OPTING FOR.

CHKM1:	MOVSI	AC4,-40		;NUMBER OF SECTIONS TO CHECK.

CHKM3:	HRRZ	AC5,ESECT(AC4)	;PICK UP A PAGE TABLE PAGE #.
	HRRZ	AC6,USECT(AC4)	;DO TWO AT ONCE.
	CAME	AC5,T4
	CAMN	AC6,T4
	JRST	CHKM2		;MATCH, THEN THIS PAGE TABLE IS BUSY.

	AOBJN	AC4,CHKM3	;CHECK REST OF POINTERS TO INSURE TABLE IS FREE.

	MOVE	T1,T4		;THIS TABLE IS A GOOD ONE.  WE'LL USE IT.
	JRST	GOTONE

CHKM2:	ADDI	T4,1		;TRY THE NEXT PAGE TABLE.
	AOBJN	T2,CHKM1	;LOOP TILL ALL POSSIBLE PAGE TABLES TRIED.
	FATAL			;TOO MANY TABLES IN USE !!

GOTONE:	HRLI	T1,ACCESS	;GET PRIVATE POINTER ACCESS BITS.

	MOVE	0,CONSW		;GET THE CONSOLE SWITCHES
	TLNE	0,INHCSH	;INHIBIT CACHE?
	TLZ	T1,(CACHEB)	;YES, CLEAR CACHE BIT

	CAIE	T3,0		;USER MAPPING ?
	MOVEM	T1,USECT(B)	;YES, SO SET UP POINTER TO PAGE TABLE.

	CAIN	T3,0
	MOVEM	T1,ESECT(B)	;NO, SET UP POINTER TO EXEC PAGE TABLE.

	LSH	T1,9		;MAKE PAGE TABLE CORE ADDRESS.
	ADD	T1,C		;NOW T1 POINTS TO SPECIFIC PAGE TABLE WORD.

	LSH	A,-9		;CHANGE CORE ADDRESS TO PAGE NUMBER.

	HRLI	A,ACCESS	;SET UP PRIVATE POINTER ACCESS BITS.

	MOVE	0,CONSW		;GET CONSOLE SWITCHES
	TLNN	0,INHCSH	;INHIBIT CACHE?
	CAIN	C,0		;OR PAGE ZERO?
	TLZ	A,(CACHEB)	;YES, CLEAR CACHE BIT

	MOVEM	A,(T1)		;UPDATE THE APPROPRIATE PAGE TABLE.

	ANDI	A,777		;KEEP ONLY THE PHYSICAL PAGE NUMBER.
	SUBI	A,P1PN		;CREATE INDEX INTO PUSE TABLE.

	LSH	B,9		;WE WANT SECTION NUMBER TO LEFT OF PAGE NUMBER.

	MOVEM	T3,PUSE(A)	;STORE USER OR EXEC BIT IN PUSE TABLE.

	IORM	B,PUSE(A)	;STORE VIRTUAL SECTION NUMBER.
	IORM	C,PUSE(A)	;AND VIRTUAL PAGE NUMBER.

	WRUBR	UPWD		;TELL HARDWARE ABOUT THE NEW MAPPING.
	RTN

; **********************************************************************
;*PREVX - SET PREVIOUS CONTEXT TO EXEC
; **********************************************************************

PREVX:	PUT	A

	JSP	A,.+1		;GET PRESENT PC FLAGS
	TLZ	A,(PCUBIT)	;CLEAR PREVIOUS CONTEXT USER BIT
	HRRI	A,.+2		;SETUP NEW PC

	JRSTF	@A		;SET APPROPRIATE FLAGS

	WRUBR	UPWD		;SET USER BASE REGISTER

	GET	A
	RTN

; **********************************************************************
;*PREVU - SET PREVIOUS CONTEXT TO USER
; **********************************************************************

PREVU:	PUT	A

	JSP	A,.+1		;GET PRESENT PC FLAGS
	TLO	A,(PCUBIT)	;SET PREVIOUS CONTEXT USER BIT
	HRRI	A,.+2		;SETUP NEW PC

	JRSTF	@A		;SET APPROPRIATE FLAGS

	WRUBR	UPWD		;SET USER BASE REGISTER

	GET	A
	RTN

SUBTTL	MEMORY MANAGEMENT STORAGE
								SALL
; **********************************************************************
;*PUSE - THE SPECIAL PAGES USED FOR TESTING EACH HAVE
;*	AN ENTRY HERE.  THEY ARE CALLED (P1,P2,P3...
;*	PN) WHERE N IS THE VALUE OF "NPAGES".  THE
;*	ENTRY IN PUSE FOR PN TELLS WHAT VIRTUAL PAGE
;*	OF CORE IS MAPPED TO PHYSICAL PAGE PN.  BIT 17
;*	ON MEANS USER MAPPING, OFF MEANS EXEC MAPPING.
; **********************************************************************

PUSE:	BLOCK	NPAGES

; **********************************************************************
;*FOUR WORD LUUO BLOCK.
; **********************************************************************

UUOCOD:	0			;HOLDS OPCODE, AC FIELD, PC FLAGS
UUOPC:	0			;HOLDS PC ADDRESS
UUOE:	0			;EFFECTIVE ADDRESS OF LUUO
ALOHA:	0			;ADDRESS OF LUUO HANDLER

; **********************************************************************
;*TWO WORD MUUO RETURN BLOCK.
; **********************************************************************

UUOSPF:	0			;HOLDS PC FLAGS.
UUOSPC:	0			;HOLDS SPECIAL MUUO RETURN ADDRESS.

; **********************************************************************
;*PAGE FAULT CONTROL
; **********************************************************************

PFF:	0			;-1 TO ALLOW ONE PAGE FAULT.
PFHSPC:	0			;HOLDS ADDRESS OF SPECIAL PAGE FAULT HANDLER.

; **********************************************************************
;*MISCELLANEOUS STORAGE
; **********************************************************************

INTRVL:	0			;HOLDS INTERVAL TIMER PERIOD.

	LOC	<.!1>+1		;GO TO EVEN WORD
TWOZER:	0			;TWO WORDS ON EVEN BOUNDARY
	0

TWOTMP:	0			;TWO WORDS TO MUNCH
	0

RESDAT:	0
XTEMP:	0			;TEMP WORD FOR RESULTS

UPWD:	1B0!1B2!0B8!UPTPN	;WORD FOR WRUBR	

; **********************************************************************
;*HARDWARE PAGES
; **********************************************************************
								LALL
.PGE	EPT			;EXECUTIVE PROCESS TABLE
.PGE	UPT			;USER PROCESS TABLE

.PGE	P1			;PAGES USED BY TESTS.
.PGE	P3			;THESE ARE PURPOSELY OUT OF ORDER.
.PGE	P2
.PGE	P7
.PGE	P5
.PGE	P6
.PGE	P4

.PGE	MAP0			;EXEC SECTION 0 PAGE MAP.
.PGE	MAP1
.PGE	MAP2
.PGE	MAP3
.PGE	MAP4
.PGE	MAP5
.PGE	MAP6
.PGE	MAP7			;THERE MUST BE EXACTLY "NPAGES" OF THESE MAPS.

.PGE	IPAG			;USED FOR INDIRECT CHAINS.

.PGE	SPT			;SPECIAL PAGES TABLE.

	LOC	<.!777>+1
CST:	BLOCK	CSTLEN		;CORE STATUS TABLE.
   