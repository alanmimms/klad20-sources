   1	%TITLE 'MAIN CONTROL AND COMMON ROUTINES FOR STIRS DIAGNOSTICS'
   2	
   3	MODULE MSSTRC (
   4			LANGUAGE(BLISS36)
   5			) =
   6	
   7	BEGIN
   8	
   9	!
  10	!                     COPYRIGHT (C) 1979
  11	! DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS 01754
  12	!
  13	! THIS SOFTWARE IS FURNISHED  UNDER A LICENSE FOR USE ONLY ON A SINGLE
  14	! COMPUTER  SYSTEM AND  MAY BE  COPIED ONLY WITH  THE INCLUSION OF THE
  15	! ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,
  16	! MAY NOT BE PROVIDED OR  OTHERWISE MADE AVAILABLE TO ANY OTHER PERSON
  17	! EXCEPT FOR USE ON SUCH SYSTEM AND TO ONE WHO AGREES TO THESE LICENSE
  18	! TERMS.  TITLE TO AND  OWNERSHIP OF THE  SOFTWARE  SHALL AT ALL TIMES
  19	! REMAIN IN DEC.
  20	!
  21	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT NOTICE
  22	! AND SHOULD  NOT BE CONSTRUED  AS A COMMITMENT  BY DIGITAL  EQUIPMENT
  23	! CORPORATION.
  24	!
  25	! DEC ASSUMES  NO  RESPONSIBILITY  FOR  THE USE OR  RELIABILITY OF ITS
  26	!SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.
  27	!
  28	
  29	!++
  30	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
  31	!
  32	!
  33	! ABSTRACT:
  34	!
  35	!	THIS MODULE CONTAINS THE MAIN CONTROL AND COMMON SUBROUTINES
  36	!	FOR THE KS10 (2020) STIMULUS-RESPONSE (STIRS) DIAGNOSTICS.  IT
  37	!	IS LINKED WITH A TEST MODULE AND A DATA MODULE TO PRODUCE A
  38	!	FAULT ISOLATION DIAGNOSTIC FOR A KS10 MODULE.
  39	!
  40	! ENVIRONMENT:  RUND UNDER 'CSL' ON A TOPS-20 SYSTEM.
  41	!
  42	! AUTHOR: RICHARD MURATORI	, CREATION DATE: 13-APR-1979
  43	!
  44	! MODIFIED BY:
  45	!
  46	!	RICH MURATORI, 23-MAY-79; VERSION 0.1
  47	!--
  48	
  49	!
  50	! TABLE OF CONTENTS:
  51	!
  52	
  53	FORWARD ROUTINE
  54	    CONTROL : NOVALUE,			!MAIN CONTROL ROUTINE
  55	    PRINT_HEADER : NOVALUE,		!PRINTS PROGRAM HEADER
  56	    PRT_FEATURES : NOVALUE,		!PRINTS LIST OF ACTIVATED FEATURES
  57	    ASK_FEATURES : NOVALUE,		!ASKS USER ABOUT ACTIVATING FEATURES
  58	    MEMSIZE,				!ASKS USER WHAT KS10 MEMORY SIZE IS
  59	    GET_NUM,				!GET USER INPUTTED NUMBER FROM TTY
  60	    INIT_DATA : NOVALUE,		!INITIALIZES DATA BASE BEFORE TESTING
  61	    DISPATCH : NOVALUE,			!TEST DISPATCH ROUTINE
  62	    RUN_CHK,				!CHECKS WHETHER NEXT TEST SHOULD BE RUN
  63	    NET_RPT : NOVALUE,			!PRINTS LIST OF POSSIBLY-FAULTY NETWORKS
  64	
  65	!THE FOLLOWING FOUR ERROR HANDLER ROUTINES ALSO DO FAULT ISOLATION
  66	
  67	    ERR : NOVALUE,			!SIMPLE ERROR HANDLER
  68	    ERRCA : NOVALUE,			!ERROR HANDLER WITH CORRECT AND ACTUAL
  69	    ERRCAS : NOVALUE,			!ERROR HANDLER WITH CORRECT AND ACTUAL
  70						! AND SPECIAL PRINTING
  71	    ERRS : NOVALUE,			!ERROR HANDLER WITH SPECIAL PRINTING
  72	
  73	!THE FOLLOWING FOUR ERROR HANDLER ROUTINES DO NOT DO FAULT ISOLATION
  74	
  75	    ERRM : NOVALUE,			!SIMPLE ERROR HANDLER
  76	    ERMCA : NOVALUE,			!ERROR HANDLER WITH CORRECT AND ACTUAL
  77	    ERMCAS : NOVALUE,			!ERROR HANDLER WITH CORRECT AND ACTUAL
  78						! AND SPECIAL PRINTING
  79	    ERMS : NOVALUE,			!ERROR HANDLER WITH SPECIAL PRINTING
  80	    ERR_RPT : NOVALUE,			!ERROR MESSAGE PRINTING
  81	    PRT_SPEC : NOVALUE,			!SPECIAL PRINTER
  82	    GET_CHAR,				!GETS NEXT CHARACTER FROM MESSAGE FILE
  83	    FIND_NUM,				!LOOKS FOR TEST OR MESSAGE # IN MSG FILE
  84	    PRINT_CA : NOVALUE,			!PRINTS CORRECT AND ACTUAL DATA
  85	    PRT_GTR_12 : NOVALUE,		!PRINTS CORRECT AND ACTUAL DATA GREATER
  86						! THAN 12 OCTAL DIGITS
  87	    PNUM : NOVALUE,			!PRINTS AN OCTAL NUMBER ON TTY
  88	    NOERR : NOVALUE,			!DOES 'NO ERROR' FAULT ISOLATION
  89	    FAILURE : NOVALUE,			!DOES 'ERROR' FAULT ISOLATION
  90	    LOOP_CHK,				!CHECKS FOR ERROR LOOPING CONDITION
  91	    FLP_CHK,				!CHECKS FOR FAST ERROR LOOPING CONDITION
  92	    CHK_ERR_MSG : NOVALUE,		!CHECKS FOR PENDING 8080 ERROR MESSAGE
  93	    WAIT : NOVALUE,			!WAIT LOOP
  94	    PRT_ERR : NOVALUE,			!PRINTS UNEXPECTED ERROR MESSAGE
  95	    SEND_LINE,				!CONCCATENATES AND SENDS 8080 COMMANDS
  96	    TIMED_OUT : NOVALUE,		!REPORTS 8080 RESPONSE TIME OUT
  97	    REPEAT : NOVALUE,			!GENERATES 8080 REPEAT CMD
  98	    PTSTNUM : NOVALUE,			!PRINTS CURRENT TEST NUMBER
  99	    CP : NOVALUE,			!DOES CPU PULSING WITH SINGLE STEP CHECKING
 100	    CP_NOSS : NOVALUE,			!DOES CPU PULSING WITH NO SINGLE STEP CHECKING
 101	    SEND_CP : NOVALUE,			!CREATES 8080 'CP' CMD
 102	    SS_UC : NOVALUE,			!DOES SINGLE STEPPING WITH 'CP' CMDS
 103	    SEND_NUL,				!FORCES SENDING OF COMMAND LINE
 104	    SETNXT : NOVALUE,			!SETS NEXT CRAM ADDRESS
 105	    EXNEXT,				!EXAMINES NEXT CRAM ADDRESS
 106	    WR_CRAM,				!TESTS CRAM ON CRA BOARD
 107	    X1,					!LOADS AND EXECUTES 8080 X1 SUBROUTINE
 108	    LOADUC : NOVALUE,			!LOADS KS10 MICROCODE
 109	    MR : NOVALUE,			!DOES A KS10 MASTER RESET
 110	    PE : NOVALUE,			!ENABLE/DISABLE 8080 PARITY DETECTION
 111	    CE : NOVALUE,			!ENABLE/DISABLE KS10 CACHING
 112	    CS : NOVALUE,			!START KS10 CPU CLOCK
 113	    CH : NOVALUE,			!HALT KS10 CPU CLOCK
 114	    TP : NOVALUE,			!ENABLE/DISABLE KS10 TRAPPING
 115	    TE : NOVALUE,			!ENABLE/DISABLE KS10 1 MSEC TIMER
 116	    EJ,					!DO AN 'EJ' CMD
 117	    SC_0 : NOVALUE,			!TURN OFF SOFT CRAM ERROR RECOVERY
 118	    EC,					!EXAMINE CRAM CONTENTS
 119	    LCA : NOVALUE,			!LOAD CRAM ADDRESS
 120	    DC_035 : NOVALUE,			!DEPOSIT CRAM CONTENTS
 121	    MOD_FLD : NOVALUE,			!MODIFY A 12-BIT CRAM DATA FIELD
 122	    DM_CHK,				!DEPOSIT INTO MEMORY AND CHECK FOR ERROR RESPONSE
 123	    MEM_DEPOSIT : NOVALUE,		!DEPOSIT DATA INTO MEMORY LOCATION
 124	    MEM_EXAMINE,			!EXAMINE MEMORY LOCATION
 125	    EM_CHK,				!EXAMINE MEMORY AND CHECK FOR ERROR RESPONSE
 126	    EM,					!EXAMINE MEMORY
 127	    MSG_CHK : NOVALUE,			!CHECK FOR EXPECTED ERROR RESPONSE
 128	    DN : NOVALUE,			!DO A DEPOSIT NEXT
 129	    IO_DEPOSIT : NOVALUE,		!DEPOSIT INTO KS10 BUS I/O REGISTER
 130	    IO_EXAMINE,				!EXAMINE A KS10 BUS I/O REGISTER
 131	    EI,					!EXAMINE A KS10 BUS I/O REGISTER
 132	    EI_CHK,				!EXAMINE I/O REGISTER AND CHECK FOR ERROR RESPONSE
 133	    INSERT_NUM,				!INSERT A NUMBER FIELD IN AN 8080 CMD
 134	    REG_EXAMINE,			!EXAMINE AN 8080 REGISTER
 135	    WRT100 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 100
 136	    WRT102 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 102
 137	    WRT103 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 103
 138	    WRT104 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 104
 139	    WRT105 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 105
 140	    WRT106 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 106
 141	    WRT107 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 107
 142	    WRT110 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 110
 143	    WRT111 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 111
 144	    WRT112 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 112
 145	    WRT113 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 113
 146	    WRT114 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 114
 147	    WRT115 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 115
 148	    WRT116 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 116
 149	    WRT204 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 204
 150	    WRT205 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 205
 151	    WRT206 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 206
 152	    WRT210 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 210
 153	    WRT212 : NOVALUE,			!DEPOSIT INTO 8080 REGISTER 212
 154	    REG_DEPOSIT : NOVALUE,		!DEPOSIT INTO 8080 REGISTER
 155	    TICK : NOVALUE,			!GENERATE CLOCK TICKS
 156	    TICK_NOSS : NOVALUE,		!GENERATE CLOCK TICKS WITH NO SINGLE STEP
 157	    SEND_TICK : NOVALUE,		!SEND COMMANDS TO DO CLOCK TICKS
 158	    SS_TICK : NOVALUE,			!SINGLE TICK SYSTEM CLOCK
 159	    SYNC_CLK : NOVALUE;			!SYNC SYSTEM CLOCK
 160	
 161	!
 162	! INCLUDE FILES:
 163	!
 164	
 165	REQUIRE 'CSLMAC.R36';			!MACROS TO CUMMUNICATE WITH 'CSL'
 166	
 167	!
 168	!			  COPYRIGHT (c) 1977, 1978 BY
 169	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 170	!
 171	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 172	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 173	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 174	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 175	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 176	! TRANSFERRED.
 177	!
 178	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 179	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 180	! CORPORATION.
 181	!
 182	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 183	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 184	!
 185	
 186	!++
 187	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 188	!
 189	! ABSTRACT:
 190	!
 191	!	THIS FILE CONTAINS MACROS WHICH ARE USED TO COMMUNICATE WITH THE
 192	!	'CSL' PROGRAM.  THE MACROS EXPAND TO LUUO CALLS WHICH PERFORM TTY
 193	!	INPUT AND OUTPUT AND SEND ASCIZ COMMAND LINES TO THE 8080.
 194	!
 195	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 196	!
 197	! AUTHOR:  RICH MURATORI	, CREATION DATE:  12-DEC-78
 198	!
 199	! MODIFIED BY:
 200	!
 201	!  RICH MURATORI, 12-DEC-78 : VERSION 0.1
 202	!--
 203	
 204	BUILTIN UUO;
 205	
 206	LITERAL
 207		ER_AC = 1,
 208		EI_AC = 2,
 209		EJ_AC = 3,
 210		EK_AC = 4,
 211		EB_AC = 5,
 212		EC_AC = 6,
 213		EM_AC = 7,
 214		PM_AC = 8,
 215		X1A_AC = 9,
 216		X1B_AC = 10;
 217	
 218	
 219	!MACROS TO DEFINE PRINTING CALLS MADE TO 'CSL' PROGRAM VIA UUO
 220	
 221	BIND CR_LF = UPLIT(%CHAR(13,10,0));
 222	
 223	MACRO
 224		PRINT_CRLF	= BEGIN
 225				  AC0 = CR_LF;
 226				  UUO(0,31,15,0);
 227				  END%,
 228		PNTSIX(MSGWORD)	= BEGIN
 229				  AC0 = MSGWORD;
 230				  UUO(0,31,0,2);
 231				  END%,
 232		PRINT_MSG(MSGADR)= BEGIN
 233				  AC0 = MSGADR;
 234				  UUO(0,31,15,0);
 235				  END%,
 236		PRINT_WORD(ADDR) = BEGIN
 237				   AC0 = ADDR;
 238				   UUO(0,31,0,0);
 239				   END%,
 240		PRINT_TXT(TEXT) = BEGIN
 241				  AC0 = UPLIT(%ASCIZ TEXT);
 242				  UUO(0,31,15,0);
 243				  END%,
 244		PTXT_CRLF(TEXT)	= BEGIN
 245				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
 246				  UUO(0,31,15,0);
 247				  END%,
 248		PRINT_DEC(NUM)	= BEGIN
 249				  AC0 = NUM;
 250				  UUO(0,31,13,0);
 251				  END%,
 252		PRT_CRLF_F	= BEGIN
 253				  AC0 = CR_LF;
 254				  UUO(0,31,15,1);
 255				  END%,
 256		PRT_MSG_F(MSGADR)= BEGIN
 257				  AC0 = MSGADR;
 258				  UUO(0,31,15,1);
 259				  END%,
 260		PRT_TXT_F(TEXT) = BEGIN
 261				  AC0 = UPLIT(%ASCIZ TEXT);
 262				  UUO(0,31,15,1);
 263				  END%,
 264		PTXT_CRLF_F(TEXT) = BEGIN
 265				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
 266				  UUO(0,31,15,1);
 267				  END%,
 268		PRT_DEC_F(NUM)	= BEGIN
 269				  AC0 = NUM;
 270				  UUO(0,31,13,1);
 271				  END%,
 272		PRINT_OCT_1(NUM)= BEGIN
 273				  AC0 = NUM;
 274				  UUO(0,31,1,0);
 275				  END%,
 276		PRINT_OCT_2(NUM)= BEGIN
 277				  AC0 = NUM;
 278				  UUO(0,31,2,0);
 279				  END%,
 280		PRINT_OCT_3(NUM)= BEGIN
 281				  AC0 = NUM;
 282				  UUO(0,31,3,0);
 283				  END%,
 284		PRINT_OCT_4(NUM)= BEGIN
 285				  AC0 = NUM;
 286				  UUO(0,31,4,0);
 287				  END%,
 288		PRINT_OCT_5(NUM)= BEGIN
 289				  AC0 = NUM;
 290				  UUO(0,31,5,0);
 291				  END%,
 292		PRINT_OCT_6(NUM)= BEGIN
 293				  AC0 = NUM;
 294				  UUO(0,31,6,0);
 295				  END%,
 296		PRINT_OCT_7(NUM)= BEGIN
 297				  AC0 = NUM;
 298				  UUO(0,31,7,0);
 299				  END%,
 300		PRINT_OCT_8(NUM)= BEGIN
 301				  AC0 = NUM;
 302				  UUO(0,31,8,0);
 303				  END%,
 304		PRINT_OCT_11(NUM)= BEGIN
 305				  AC0 = NUM;
 306				  UUO(0,31,11,0);
 307				  END%,
 308		PRINT_OCT_12(NUM)= BEGIN
 309				  AC0 = NUM;
 310				  UUO(0,31,12,0);
 311				  END%,
 312		POCT_SUP(NUM)	= BEGIN
 313				  AC0 = NUM;
 314				  UUO(0,31,14,3);
 315				  END%,
 316		PBELL		= UUO(0,31,1,7)%,
 317	
 318	!MACROS TO DEFINE UUO CALLS TO 'CSL' PROGRAM FOR TTY INPUT
 319	
 320		TT_ALTM = UUO(1,31,7,3)%,
 321		TTI_YES = UUO(1,31,1,3)%,
 322		TTI_CLR = UUO(0,31,10,3)%,
 323		TTI_DEC = UUO(1,31,4,3)%,
 324	
 325	!MACRO TO DEFINE END OF PROGRAM UUO
 326	
 327		EOP_UUO = UUO(0,31,14,4)%,
 328	
 329	!MACROS TO DEFINE UUO CALLS TO 'CSL' TO SEND CMD STRINGS WITH RESPONSE
 330	
 331		SEND_ER_LINE = UUO(0,1,ER_AC,0)%,
 332		SEND_EI_LINE = UUO(0,1,EI_AC,0)%,
 333		SEND_EJ_LINE = UUO(0,1,EJ_AC,0)%,
 334		SEND_EK_LINE = UUO(0,1,EK_AC,0)%,
 335		SEND_EB_LINE = UUO(0,1,EB_AC,0)%,
 336		SEND_EC_LINE = UUO(0,1,EC_AC,0)%,
 337		SEND_EM_LINE = UUO(0,1,EM_AC,0)%,
 338		SEND_PM_LINE = UUO(0,1,PM_AC,0)%,
 339		SEND_X1A_LINE = UUO(0,1,X1A_AC,0)%,
 340		SEND_X1B_LINE = UUO(0,1,X1B_AC,0)%,
 341	
 342	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD STRING
 343	
 344		SEND_CMD_LINE = UUO(0,1,0,0)%,
 345	
 346	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD LINE
 347	
 348		SEND_UUO_1 = UUO(0,1,1,0)%,
 349	
 350	!MACRO TO DEFINE ERROR MESSAGE CHECK CALL TO 'CSL'
 351	
 352		MSG_CHK_UUO = UUO(0,3,0,0)%,
 353	
 354	!MACRO TO DEFINE 'CSL' UUO TO PASS CONTROL-T INFO
 355	
 356		SEND_INFO = UUO(0,3,1,0)%,
 357	
 358	!MACROS TO DEFINE FILE HANDLING UUOS TO 'CSL' PROGRAM
 359	
 360		FSELECT(FILNAM_ADR)	= (AC0 = FILNAM_ADR;
 361					  UUO(1,31,5,4))%,
 362		FRDPAG	= UUO(1,31,8,4)%;
 363	
 364	!8080 ERROR MESSAGE FORMATS WHICH ARE CHECKED FOR.
 365	
 366	BIND
 367		HALTED = UPLIT(%ASCIZ '%HLTD'),
 368		MEM_REF_ERR = UPLIT(%ASCIZ '?MRE'),
 369		PAR_ERR = UPLIT(%ASCIZ '?PAR_ERR');
 370	
 371	! END OF 'CSL.MAC'
 372	
 373	REQUIRE 'REGBIT.R36';			!8080 REGISTER BIT DEFINITIONS
 374	
 375	!
 376	!			  COPYRIGHT (c) 1977, 1978 BY
 377	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 378	!
 379	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 380	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 381	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 382	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 383	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 384	! TRANSFERRED.
 385	!
 386	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 387	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 388	! CORPORATION.
 389	!
 390	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 391	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 392	!
 393	
 394	!++
 395	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 396	!
 397	! ABSTRACT:
 398	!
 399	!	THIS FILE CONTAINS SYMBOLIC BIT DEFINITIONS FOR THE KS10 8080 I/O
 400	!	REGISTERS.  IT IS USED AS A 'REQUIRE' FILE FOR THE STIRS DIAGNOSTICS.
 401	!
 402	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 403	!
 404	! AUTHOR:  RICH MURATORI	, CREATION DATE:  3-JAN-79
 405	!
 406	! MODIFIED BY:
 407	!
 408	!  RICH MURATORI, 3-JAN-79 : VERSION 0.1
 409	!--
 410	
 411	LITERAL
 412	
 413	!WRITE REGISTER 100
 414	
 415		FORCE_PAR	= 1^1,		!FORCE PARITY RIGHT
 416		EN_1MS		= 1^2,		!1 MSEC ENABLE
 417		CACHE_ENB	= 1^3,		!CACHE ENABLE
 418		DP_PE_DET	= 1^4,		!DP PE DETECT
 419		CRM_PE_DET	= 1^5,		!CRM PE DETECT
 420		PE_DET_ENB	= 1^6,		!PE DETECT ENABLE
 421		RESET		= 1^7,		!RESET
 422	
 423	!WRITE REGISTER 102/103
 424	
 425		DATA35		= 1^0,		!KS10 BUS DATA BIT 35
 426		DATA34		= 1^1,		!KS10 BUS DATA BIT 34
 427		DATA33		= 1^2,		!KS10 BUS DATA BIT 33
 428		DATA32		= 1^3,		!KS10 BUS DATA BIT 32
 429		DATA31		= 1^4,		!KS10 BUS DATA BIT 31
 430		DATA30		= 1^5,		!KS10 BUS DATA BIT 30
 431		DATA29		= 1^6,		!KS10 BUS DATA BIT 29
 432		DATA28		= 1^7,		!KS10 BUS DATA BIT 28
 433	
 434	!WRITE REGISTER 104/105
 435	
 436		DATA27		= 1^0,		!KS10 BUS DATA BIT 27
 437		DATA26		= 1^1,		!KS10 BUS DATA BIT 26
 438		DATA25		= 1^2,		!KS10 BUS DATA BIT 25
 439		DATA24		= 1^3,		!KS10 BUS DATA BIT 24
 440		DATA23		= 1^4,		!KS10 BUS DATA BIT 23
 441		DATA22		= 1^5,		!KS10 BUS DATA BIT 22
 442		DATA21		= 1^6,		!KS10 BUS DATA BIT 21
 443		DATA20		= 1^7,		!KS10 BUS DATA BIT 20
 444	
 445	!WRITE REGISTER 106/107
 446	
 447		DATA19		= 1^0,		!KS10 BUS DATA BIT 19
 448		DATA18		= 1^1,		!KS10 BUS DATA BIT 18
 449		DATA17		= 1^2,		!KS10 BUS DATA BIT 17
 450		DATA16		= 1^3,		!KS10 BUS DATA BIT 16
 451		DATA15		= 1^4,		!KS10 BUS DATA BIT 15
 452		DATA14		= 1^5,		!KS10 BUS DATA BIT 14
 453		DATA13		= 1^6,		!KS10 BUS DATA BIT 13
 454		DATA12		= 1^7,		!KS10 BUS DATA BIT 12
 455	
 456	!WRITE REGISTER 110/111
 457	
 458		DATA11		= 1^0,		!KS10 BUS DATA BIT 11
 459		DATA10		= 1^1,		!KS10 BUS DATA BIT 10
 460		DATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 461		DATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 462		DATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 463		DATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 464		DATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 465		DATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 466	
 467	!WRITE REGISTER 112/113
 468	
 469		DATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 470		DATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 471		DATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 472		DATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 473	
 474	!WRITE REGISTER 114/115
 475	
 476		DATA_CYCLE	= 1^0,		!DATA CYCLE
 477		IO_DATA		= 1^1,		!I/O DATA CYCLE
 478		COM_ADR		= 1^2,		!COM/ADR CYCLE
 479		BAD_DATA	= 1^3,		!BAD DATA CYCLE
 480	
 481	!WRITE REGISTER 116
 482	
 483		CSL_INT		= 1^0,		!CSL INTERRUPT THE 10
 484	
 485	!WRITE REGISTER 204
 486	
 487		CRAM_RESET	= 1^0,		!CRAM RESET
 488		STK_RESET	= 1^1,		!STACK RESET
 489		DP_RESET	= 1^2,		!DP RESET
 490		SS_MODE		= 1^3,		!SINGLE STEP MODE
 491		CRAM_ADR_LD	= 1^4,		!CRAM ADR LOAD
 492		CRAM_WRT	= 1^5,		!CRAM WRITE
 493	
 494	!WRITE REGISTER 205
 495	
 496		DIAG1		= 1^0,		!DIAG FN BIT 1
 497		DIAG2		= 1^1,		!DIAG FN BIT 2
 498		DIAG4		= 1^2,		!DIAG FN BIT 4
 499		DIAG10		= 1^3,		!DIAG FN BIT 10
 500		TRAP_ENB	= 1^4,		!TRAP ENABLE
 501		CLR_INT		= 1^5,		!CLEAR 10 INTERRUPT
 502		MNT_CLK_ENB	= 1^6,		!MAINT CLK ENABLE
 503		MAINT_CLK	= 1^7,		!MAINT CLK PULSE
 504	
 505	!WRITE REGISTER 206
 506	
 507		CLK_RUN		= 1^0,		!CLOCK RUN
 508		SINGLE_CLK	= 1^1,		!SINGLE CLOCK
 509	
 510	!WRITE REGISTER 210
 511	
 512		CLOSE_LATCH	= 1^0,		!CLOSE LATCHS
 513		LATCH_DATA	= 1^1,		!LATCH DATA (1)
 514		CRA_R_CLK	= 1^2,		!CRA R CLK ENB (1)
 515		CRA_T_CLK	= 1^3,		!CRA T CLK ENB (1)
 516		XMIT_DATA	= 1^4,		!XMIT DATA (1)
 517		XMIT_ADR	= 1^5,		!XMIT ADR (1)
 518		BUS_REQ		= 1^6,		!BUS REQ
 519		MEM		= 1^7,		!MEM
 520	
 521	!WRITE REGISTER 212
 522	
 523		CONTINUE	= 1^0,		!CONTINUE
 524		EXECUTE		= 1^1,		!EXECUTE
 525		RUN		= 1^2,		!RUN
 526	
 527	
 528	
 529	!READ REGISTER 0
 530	
 531		RDATA35		= 1^0,		!KS10 BUS DATA BIT 35
 532		RDATA34		= 1^1,		!KS10 BUS DATA BIT 34
 533		RDATA33		= 1^2,		!KS10 BUS DATA BIT 33
 534		RDATA32		= 1^3,		!KS10 BUS DATA BIT 32
 535		RDATA31		= 1^4,		!KS10 BUS DATA BIT 31
 536		RDATA30		= 1^5,		!KS10 BUS DATA BIT 30
 537		RDATA29		= 1^6,		!KS10 BUS DATA BIT 29
 538		RDATA28		= 1^7,		!KS10 BUS DATA BIT 28
 539	
 540	!READ REGISTER 1
 541	
 542		RDATA27		= 1^0,		!KS10 BUS DATA BIT 27
 543		RDATA26		= 1^1,		!KS10 BUS DATA BIT 26
 544		RDATA25		= 1^2,		!KS10 BUS DATA BIT 25
 545		RDATA24		= 1^3,		!KS10 BUS DATA BIT 24
 546		RDATA23		= 1^4,		!KS10 BUS DATA BIT 23
 547		RDATA22		= 1^5,		!KS10 BUS DATA BIT 22
 548		RDATA21		= 1^6,		!KS10 BUS DATA BIT 21
 549		RDATA20		= 1^7,		!KS10 BUS DATA BIT 20
 550	
 551	!READ REGISTER 2
 552	
 553		RDATA19		= 1^0,		!KS10 BUS DATA BIT 19
 554		RDATA18		= 1^1,		!KS10 BUS DATA BIT 18
 555		RDATA17		= 1^2,		!KS10 BUS DATA BIT 17
 556		RDATA16		= 1^3,		!KS10 BUS DATA BIT 16
 557		RDATA15		= 1^4,		!KS10 BUS DATA BIT 15
 558		RDATA14		= 1^5,		!KS10 BUS DATA BIT 14
 559		RDATA13		= 1^6,		!KS10 BUS DATA BIT 13
 560		RDATA12		= 1^7,		!KS10 BUS DATA BIT 12
 561	
 562	!READ REGISTER 3
 563	
 564		RDATA11		= 1^0,		!KS10 BUS DATA BIT 11
 565		RDATA10		= 1^1,		!KS10 BUS DATA BIT 10
 566		RDATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 567		RDATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 568		RDATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 569		RDATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 570		RDATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 571		RDATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 572	
 573	!READ REGISTER 100
 574	
 575		ADPT2_PE	= 1^0,		!UNIBUS ADAPTER 2 PARITY ERR
 576		CRA_PE		= 1^1,		!CRA PARITY ERR
 577		DP_PE		= 1^2,		!DP PARITY ERR
 578		MEM_PE		= 1^3,		!MEM PARITY ERR
 579		CRAM_PE		= 1^4,		!CRAM PARITY ERR
 580		ADPT3_PE	= 1^6,		!UNIBUS ADAPTER 3 PARITY ERR
 581		REC_PE		= 1^7,		!RECEIVED PARITY ERR
 582	
 583	!READ REGISTER 101
 584	
 585		MMC_REF_ERR	= 1^0,		!MEM REFRESH ERR
 586		PI_REQ_7	= 1^1,		!PI REQ 7
 587		PI_REQ_6	= 1^2,		!PI REQ 6
 588		PI_REQ_5	= 1^3,		!PI REQ 5
 589		PI_REQ_4	= 1^4,		!PI REQ 4
 590		PI_REQ_3	= 1^5,		!PI REQ 3
 591		PI_REQ_2	= 1^6,		!PI REQ 2
 592		PI_REQ_1	= 1^7,		!PI REQ 1
 593	
 594	!READ REGISTER 102
 595	
 596		RDATA		= 1^0,		!DATA CYCLE
 597		RIO_DATA	= 1^1,		!I/O DATA CYCLE
 598		RCOM_ADR	= 1^2,		!COM/ADR CYCLE
 599		RBAD_DATA	= 1^3,		!BAD DATA CYCLE
 600		RIO_BUSY	= 1^4,		!I/O BUSY
 601		RMEM_BUSY	= 1^5,		!MEM BUSY
 602		RRESET		= 1^6,		!RESET
 603		RAC_LO		= 1^7,		!AC LO
 604	
 605	!READ REGISTER 103
 606	
 607		RDATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 608		RDATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 609		RDATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 610		RDATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 611		PAR_LEFT	= 1^4,		!PARITY LEFT
 612		PAR_RIGHT	= 1^5,		!PARITY RIGHT
 613		ADPT4_PE	= 1^6,		!UNIBUS ADAPTER 4 PARITY ERR
 614		ADPT1_PE	= 1^7,		!UNIBUS ADAPTER 1 PARITY ERR
 615	
 616	!READ REGISTER 300
 617	
 618		CONTINUE_H	= 1^0,		!CONTINUE
 619		EXECUTE_B	= 1^1,		!EXECUTE
 620		RUN_1		= 1^2,		!RUN
 621		HALT_LOOP	= 1^3,		!DPM HALT LOOP
 622		KLINIK_LEN	= 1^4,		!KLINIK LENGTH (SW)
 623		KLINIK_BIT	= 1^5,		!KLINIK BIT # (SW)
 624		CTY_CHAR_LEN	= 1^6,		!CTY CHARACTER LENGTH (SW)
 625		CTY_BIT		= 1^7,		!CTY BIT # (SW)
 626	
 627	!READ REGISTER 301
 628	
 629		DATA_ACK	= 1^0,		!DATA ACK
 630		BOOT		= 1^1,		!BOOT (SW)
 631		CONS_ENB	= 1^2,		!CONSOLE ENABLE (SW)
 632		PE_1		= 1^3,		!PE(1)
 633		BUSREQ		= 1^4,		!BUS REQUEST
 634		NEXM		= 1^6,		!NEXM
 635		TEN_INT		= 1^7,		!10 INTERRUPT
 636	
 637	!READ REGISTER 302
 638	
 639		KLINIK_CARR	= 1^0,		!KLINIK CARRIER
 640		TERM_CARR	= 1^1,		!TERMINAL CARRIER
 641		REM_DIAG_ENB	= 1^2,		!REMOTE DIAG ENB
 642		REM_DIAG_PRO	= 1^3,		!REMOTE DIAG PROT
 643	
 644	!READ REGISTER 303
 645	
 646		RAM_ERR		= 1^0,		!RAM ERROR
 647		DP_CLK_ENBL	= 1^1,		!DPE/M CLK ENABLE
 648		CR_CLK_ENB	= 1^2,		!CRA/M CLK ENABLE
 649		R_CLK_ENB0	= 1^3;		!R CLK ENB (0) H
 650	
 651	! END OF 'REGBIT.R36'
 652	
 653	!
 654	! MACROS:
 655	!
 656	!	NONE
 657	!
 658	! EQUATED SYMBOLS:
 659	!
 660	
 661	LITERAL
 662	    CONTROL_EDIT = 1,			!EDIT NUMBER OF THIS MODULE
 663	    CONTROL_VERSION = 1;		!VERSION NUMBER OF THIS MODULE
 664	
 665	BIND
 666	
 667	!THE FOLLOWING IS AN 8080 SUBROUTINE WHICH IS LOADED AND USED BY THE
 668	!'SETNXT' AND 'EXNEXT' ROUTINES.
 669	!
 670	! 332 327 042 X1CMD:	JC	RHSAVE		;JUMP IF NO ARG TYPED
 671	! 315 254 013		CALL	LCCMD		;ELSE, GO READ IN CRAM ADDRESS
 672	! 052 004 040		LHLD	CRMAD		;GET ADDR IN H,L
 673	! 303 267 014		JMP	CADWR		;GO WRITE ADDR & RETURN
 674	!
 675	! 076 001     RHSAVE:	MVI	A,01		;GET CODE FOR 'NXT'
 676	! 315 331 014		CALL	READC		;READ 'NXT'
 677	! 315 300 030		CALL	P16.		;PRINT RESULTS
 678	! 347 002		PCRLF			;WITH <CR-LF>
 679	! 311			RET			;AND OUT
 680		    CADSUB = PLIT(UPLIT(%ASCIZ 'LK20054,DK332,DN327,DN42,DN315,DN254,DN13,DN52,DN4,DN40,DN303,DN267,DN14'),
 681				UPLIT (%ASCIZ'LK21327,DK76,DN1,DN315,DN331,DN14,DN315,DN300,DN30,DN347,DN2,DN311'));
 682	
 683	BUILTIN
 684	    COPYII,
 685	    POINT,
 686	    SCANI,
 687	    REPLACEI;
 688	
 689	!
 690	! OWN STORAGE
 691	!
 692	
 693	STRUCTURE
 694	    CHAR_BUF [I; N] =				!STRUCTURE FOR PACKING ASCII CHARS
 695		[(N + 5)/5]
 696		(CHAR_BUF + I/5)<29 - (I MOD 5)*7, 7, 0>;
 697	
 698	GLOBAL
 699	    NO_SUBSET : INITIAL (0),			!FLAG FOR SUBSET CHECKING IN 'RUN_CHK'
 700	    TIMOUT,					!FLAG FOR 8080 RESPONSE TIMEOUT
 701	    ERRFLG,					!ERROR FLAG. SET BY 'ERR_RPT' AND CLEARED BY 'LOOP_CHK'
 702	    RPT_ERR_FLAG;				!FLAG TO TURN ON/OFF 8080 ERROR RESPONSE REPORTING
 703	
 704	OWN
 705	    LINE_BUF : CHAR_BUF [80],		!BUFFER TO HOLD 8080 CMD LINE CHARS
 706	    NETWRDS,				!NUMBER OF 36-BIT WORDS IN FAULTY NETWORK BITVECTOR
 707	    SCRIPT_RUN,				!FLAG INDICATING WHETHER SCRIPT IS RUNNING
 708	    HAD_FAILURE,			!FLAG INDICATING THAT FAILURE OCCURRED
 709	    TEST_NUM,				!NUMBER OF TEST BEING EXECUTED
 710	    MSG_FILE_OPEN,			!FLAG INDICATING MESSAGE FILE IS OPENED
 711	    PAGE_IN,				!FLAG INDICATING THAT A PAGE OF MESSAGE FILE IS IN MEMORY
 712	    LOOP_ERR_NUM,			!NUMBER OF ERROR BEING LOOPED ON
 713	    LAST_MEM_ADDR,			!LAST KS10 MEMORY ADDRESS REFERENCED
 714	    LAST_IO_ADDR,			!LAST KS10 I/O ADDR REFERENCED
 715	    LAST_REG_ADDR,			!LAST 8080 REGISTER REFERENCED
 716	    SUB_LOADED,				!FLAG INDICATING WHICH 8080 SUBROUTINE IS LOADED
 717	    LINE_CHARS,				!NUMBERS OF CHARS LOADED IN 8080 CMD LINE
 718	    BELL_ON_ERR : INITIAL (0),		!BELL-ON-ERROR FEATURE FLAG
 719	    LOOP_ON_ERR : INITIAL (0),		!LOOP-ON-ERROR FEATURE FLAG
 720	    FAST_LOOP : INITIAL (0),		!FAST ERROR LOOPING FEATURE FLAG
 721	    LOOP_ON_TEST : INITIAL (0),		!LOOP-ON-TEST FEATURE FLAG
 722	    LOOP_TEST,				!TEST NUMBER TO LOOP ON
 723	    TEXT_INH : INITIAL (0),		!TEXT-INHIBIT FEATURE FLAG
 724	    SINGLE_STEP : INITIAL (0),		!SINGLE-STEPPING FEATURE FLAG
 725	    LOOP_ON_PRG : INITIAL (0),		!LOOP-ON-PROGRAM FEATURE FLAG
 726	    LOOPING,				!FLAG INDICTING THAT PROGRAM IS LOOPING ON ERROR
 727	    NO_ISOLATION : INITIAL (0),		!NO-FAULT-ISOLATION FEATURE FLAG
 728	    PRT_TST_NUM : INITIAL (0),		!PRINT-TEST-NUMBERS FEATURE FLAG
 729	    PATCH : VECTOR [20] INITIAL ( REP 20 OF (0)); !PROGRAM PATCH AREA
 730	
 731	GLOBAL BIND
 732	    LPONTST = LOOP_ON_TEST;
 733	
 734	!
 735	! EXTERNAL REFERENCES:
 736	!
 737	
 738	EXTERNAL
 739	    MSGFIL,				!NAME OF ERROR MESSAGE FILE (FROM TEST MODULE)
 740	    NET_FAULTS,				!CUMULATIVE POSSIBLY-FAULTY BITVECTOR (IN DATA MODULE)
 741	    ES_TBL,				!TABLE OF FAULTY-NETWORK BITVECTORS (IN DATA MODULE)
 742	    NES_TBL;				!TABLE OF NOT-FAULTY-NETWORK BITVECTORS (IN DATA MODULE)
 743	
 744	EXTERNAL LITERAL
 745	    MAXNETS,				!NUMBER OF NETWORKS ON BOARD UNDER TEST
 746	    MAXTEST;				!NUMBER OF TESTS IN TEST MODULE
 747	
 748	MAP
 749	    NET_FAULTS : BITVECTOR,
 750	    ES_TBL : VECTOR,
 751	    NES_TBL : VECTOR;
 752	GLOBAL ROUTINE CONTROL : NOVALUE =
 753	
 754	!++
 755	! FUNCTIONAL DESCRIPTION:
 756	!
 757	!	THIS ROUTINE IS THE MAIN CONTROL FOR THE RUNNING OF STIRS AND IS
 758	!	THE ENTRY POINT TO WHICH THE 'CSL' PROGRAM TRANSFERS TO START
 759	!	STIRS EXECUTION.  THE FIRST TIME THE PROGRAM IS STARTED, THE
 760	!	PROGRAM NAME AND THE EDIT AND VERSION NUMBERS FOR THE MODULES
 761	!	ARE REPORTED.  THEN A LIST OF THE ACTIVATED FEATURES IS PRINTED.
 762	!	THE USER IS ASKED IF HE WANTS TO CHANGE THAT LIST.  IF HE DOES,
 763	!	THEN HE IS ASKED FEATURE-BY-FEATURE WHETHER OR NOT HE WANTS TO
 764	!	ACTIVATE IT.  WHEN THE FEATURE ACTIVATION IS COMPLETED, AN
 765	!	INITALIZATION ROUTINE IS CALLED TO INITALIZE THE DATA BASE. THEN
 766	!	THE DISPATCH ROUTINE IS CALLED TO INVOKE THE RUNNING OF THE
 767	!	TESTS.  WHEN ALL TESTS HAVE BEEN RUN, THE FAULTY NETWORK
 768	!	REPORTING ROUTINE IS CALLED TO PRINT THE LIST OF POSSIBLY FAULTY
 769	!	NETWORKS AS CONTAINED IS THE DATA BASE DERIVED BY RUNNING THE
 770	!	TESTS.
 771	!	IF THE 'LOOP ON PROGRAM' FEATURE IS ACTIVATED, THE ENTIRE TEST
 772	!	SEQUENCE IS REPEATED INDEFINITELY.  OTHERWISE, CONTROL IS
 773	!	RETURNED TO THE 'CSL' PROGRAM VIA AN END-OF-PROGRAM UUO.
 774	!
 775	! FORMAL PARAMETERS:
 776	!
 777	!	NONE
 778	!
 779	! IMPLICIT INPUTS:
 780	!
 781	!	LOOP_ON_PRG	= 1 IF INDEFINITE PROGRAM PASSES ARE TO BE RUN
 782	!			  0 IF ONLY ONE PROGRAM PASSES IS TO BE RUN
 783	!	AC0		= THE 'CSL' PROGRAM PASSES A FLAG IN AC0.
 784	!			  1 MEANS THE PROGRAM IS BEING RUN AS PART OF A
 785	!				FAULT INSERTION OR QV SCRIPT. HENCE,
 786	!				DON'T ASK QUESTIONS.
 787	!			  0 MEANS NORMAL OPERATION.
 788	!
 789	! IMPLICIT OUTPUTS:
 790	!
 791	!	AC0 IS LOADED WITH A FLAG.  0 MEANS NO FAILURES WERE DETECTED.
 792	!				    1 MEANS FAILURE(S) OCCURRED.
 793	!
 794	! ROUTINE VALUE:
 795	!
 796	!	NONE
 797	!
 798	! SIDE EFFECTS:
 799	!
 800	!	NONE
 801	!--
 802	
 803	    BEGIN
 804	
 805	    EXTERNAL ROUTINE
 806		SPEC_DIALOGUE : NOVALUE;		!ALLOWS SPECIAL START-UP DIALOGUE BASED ON TEST MODULE
 807	
 808	    REGISTER
 809		AC0 = 0;
 810	
 811	    OWN
 812		PASS_CNT,				!COUNTER FOR PROGRAM PASS COUNT
 813		FIRST_PASS : INITIAL (0);		!FLAG USED TO DETERMINE PRINTING OF PROGRAM NAME
 814	
 815	    SCRIPT_RUN = .AC0;				!GET SCRIPTING FLAG
 816	!IF IT IS THE FIRST PASS OF THE PROGRAM, THEN TYPE THE PROGRAM NAME
 817	!AND VERSION NUMBERS AND ANY SPECIAL STARTUP DIALOGUE.
 818	
 819	    IF .FIRST_PASS EQL 0
 820	    THEN
 821		BEGIN
 822		PRINT_HEADER ();
 823		FIRST_PASS = 1;				!SET FLAG SO WE ONLY DO THIS BLOCK ONCE
 824		SPEC_DIALOGUE ();			!GO DO SPECIAL DIALOGUE IN TEST MODULE
 825		END;
 826	
 827	!IF THIS IS A SCRIPTING RUN, DON'T PRINT FEATURES OR ASK QUESTIONS.
 828	
 829	    IF .SCRIPT_RUN EQL 0
 830	    THEN
 831		BEGIN
 832		PRT_FEATURES ();			!GO PRINT LIST OF FEATURES
 833		ASK_FEATURES ();			!GO ASK FOR FEATURE CHANGES
 834		END;
 835	
 836	    PASS_CNT = 0;				!INITIALIZE PASS COUNT
 837	!REPEAT THE TESTING INDEFINITELY IF THE 'LOOP-ON-PROGRAM' FEATURE IS
 838	!ACTIVATED.
 839	
 840	    DO
 841		BEGIN
 842		INIT_DATA ();				!INITIALIZE THE DATA BASE AND FLAGS
 843		DISPATCH ();				!GO DISPATCH TO THE TEST ROUTINES
 844		NET_RPT ();				!REPORT RESULTS OF FAULT ISOLATION
 845		PASS_CNT = .PASS_CNT + 1;		!INCREMENT PASS COUNT
 846		PRT_TXT_F ('END OF PASS #');
 847		PRT_DEC_F (.PASS_CNT);
 848		PRT_CRLF_F;
 849		END
 850	    WHILE .LOOP_ON_PRG NEQ 0;
 851	
 852	    AC0 = .HAD_FAILURE;				!SET AC0 WITH FAILURE FLAG FOR 'CSL'
 853	    EOP_UUO;					!RETURN TO 'CSL'
 854	    END;
 855	
 856	ROUTINE PRINT_HEADER : NOVALUE =
 857	
 858	!++
 859	! FUNCTIONAL DESCRIPTION:
 860	!
 861	!	THIS ROUTINE PRINTS THE PROGRAM NAME AND THE EDIT AND VERSION
 862	!	NUMBERS OF THE THREE MODULES WHICH MAKE UP A STIRS PROGRAM -
 863	!	THE CONTROL MODULE (THIS ONE), THE TEST MODULE, AND THE DATA
 864	!	BASE MODULE.
 865	!
 866	! FORMAL PARAMETERS:
 867	!
 868	!	NONE
 869	!
 870	! IMPLICIT INPUTS:
 871	!
 872	!	PRGNAM		= THIS IS THE ADDRESS OF THE PLIT CONTAINING
 873	!			  THE PROGRAM NAME.  IT IS A GLOBAL VARIABLE
 874	!			  WHICH IS DEFINED IN THE TEST MODULE.
 875	!	CONTROL_VERSION	= THIS IS A LITERAL VALUE DEFINING THE VERSION
 876	!			  NUMBER OF THIS MODULE (CONTROL).
 877	!	CONTROL_EDIT	= THIS IS A LITERAL VALUE DEFINING THE EDIT
 878	!			  LEVEL OF THIS MODULE (CONTROL).
 879	!	TEST_VERSION	= THIS IS A GLOBAL LITERAL VALUE DEFINING THE
 880	!			  VERSION NUMBER OF THE TEST MODULE.  IT IS
 881	!			  DEFINED IN THE TEST MODULE.
 882	!	TEST_EDIT	= THIS IS A GLOBAL LITERAL VALUE DEFINING THE
 883	!			  EDIT LEVEL OF THE TEST MODULE.  IT IS
 884	!			  DEFINED IN THE TEST MODULE.
 885	!	DATA_VERSION	= THIS IS A GLOBAL LITERAL VALUE DEFINING THE
 886	!			  VERSION NUMBER OF THE DATA BASE MODULE.  IT IS
 887	!			  DEFINED IN THE DATA BASE MODULE.
 888	!	DATA_EDIT	= THIS IS A GLOBAL LITERAL VALUE DEFINING THE
 889	!			  EDIT LEVEL OF THE DATA BASE MODULE.  IT IS
 890	!			  DEFINED IN THE DATA BASE MODULE.
 891	!
 892	! IMPLICIT OUTPUTS:
 893	!
 894	!	NONE
 895	!
 896	! ROUTINE VALUE:
 897	!
 898	!	NONE
 899	!
 900	! SIDE EFFECTS:
 901	!
 902	!	THE PROGRAM NAME AND THE VERSION AND EDIT NUMBERS OF THE
 903	!	THREE MODULES ARE PRINTED ON THE TTY.
 904	!--
 905	
 906	    BEGIN
 907	
 908	    EXTERNAL
 909		PRGNAM;					!PLIT WITH PROGRAM NAME
 910	
 911	    EXTERNAL LITERAL
 912		TEST_VERSION,				!VERSION NUMBER OF TEST MODULE
 913		TEST_EDIT,				!EDIT NUMBER OF TEST MODULE
 914		DATA_VERSION,				!VERSION NUMBER OF DATA MODULE
 915		DATA_EDIT;				!EDIT NUMBER OF DATA MODULE
 916	
 917	    REGISTER
 918		AC0 = 0;
 919	
 920	    PRT_MSG_F (PRGNAM);				!PRINT THE PROGRAM NAME
 921	    PRT_CRLF_F;
 922	    PRT_TXT_F ('CONTROL MODULE ');
 923	    PRT_DEC_F (CONTROL_EDIT);			!PRINT THE EDIT # OF THIS MODULE
 924	    PRT_TXT_F ('.');
 925	    PRT_DEC_F (CONTROL_VERSION);		!PRINT THE VERSION # OF THIS MODULE
 926	    PRT_TXT_F ('    TEST MODULE ');
 927	    PRT_DEC_F (TEST_EDIT);			!PRINT THE EDIT # OF THE TEST MODULE
 928	    PRT_TXT_F ('.');
 929	    PRT_DEC_F (TEST_VERSION);			!PRINT VERSION # OF TEST MODULE
 930	    PRT_TXT_F ('    DATA MODULE ');
 931	    PRT_DEC_F (DATA_EDIT);			!PRINT EDIT # OF DATA MODULE
 932	    PRT_TXT_F ('.');
 933	    PRT_DEC_F (DATA_VERSION);			!PRINT VERSION # OF DATA MODULE
 934	    PRT_CRLF_F;
 935	    PRT_CRLF_F;
 936	    END;
 937	ROUTINE PRT_FEATURES : NOVALUE =
 938	
 939	!++
 940	! FUNCTIONAL DESCRIPTION:
 941	!
 942	!	THIS ROUTINE PRINTS A LIST OF ACTIVATED FEATURES.  IF NO
 943	!	FEATURES ARE ACTIVATED, IT PRINTS 'NONE'.
 944	!	THE FEATURES WHICH ARE COMMON TO ALL THE DIFFERENT TEST MODULES
 945	!	ARE MAINTAINED IN THIS MODULE.  HOWEVER, SOME TEST MODULES HAVE
 946	!	SPECIAL FEATURES WHICH ARE MAINTAINED BY THE TEST MODULE.
 947	!	WHETHER OR NOT SUCH FEATURES ARE ACTIVATED IS PRINTED BY THE
 948	!	'SPEC_PRT' ROUTINE, WHICH RESIDES IN THE TEST MODULE.
 949	!
 950	! FORMAL PARAMETERS:
 951	!
 952	!	NONE
 953	!
 954	! IMPLICIT INPUTS:
 955	!
 956	!	FEATURES SWITCHES -
 957	!	BELL_ON_ERR	= 1 IF BELL IS TO BE RUNG ON DETECTION OF ERROR
 958	!			  0 IF BELL IS NOT TO BE RUNG
 959	!	LOOP_ON_ERR	= 1 IF PROGRAM IS TO LOOP ON FAILING ERROR
 960	!			  0 IF NO LOOPING IS DESIRED
 961	!	LOOP_ON_TEST	= 1 IF PROGRAM IS TO LOOP ON SPECIFIED TEST
 962	!			  0 IF NO TEST LOOPING IS DESIRED
 963	!	LOOP_TEST	= NUMBER OF TEST ON WHICH PROGRAM IS TO LOOP.
 964	!			  THIS DATA IS MEANINGFUL ONLY IF 'LOOP_ON_TEST'
 965	!			  SWITCH IS ACTIVATED.
 966	!	NO_ISOLATION	= 1 IF FAULT ISOLATION IS TO BE TURNED OFF.
 967	!			  0 IF FAULT ISOLATION IS TO BE PERFORMED.
 968	!	SINGLE_STEP	= 1 IF USER WISHES TO MANUALLY SINGLE STEP THE
 969	!			    DIAGNOSTIC MICROCODE OR THE SYSTEM CLOCK.
 970	!			  0 IF NO MANUAL SINGLE STEPPING IS DESIRED
 971	!	TEXT_INH	= 1 IF FUNCTIONAL ERROR DESCRIPTIONS ARE NOT TO
 972	!			    BE PRINTED. (ONLY TEST AND ERROR NUMBERS AND
 973	!			    CORRECT AND ACTUAL DATA).
 974	!			  0 IF FULL ERROR PRINTOUTS ARE DESIRED.
 975	!	LOOP_ON_PRG	= 1 IF INDEFINITE PROGRAM PASSES ARE TO BE RUN
 976	!			  0 IF ONLY ONE PROGRAM PASSES IS TO BE RUN
 977	!	PRT_TST_NUM	= 1 IF USER WANTS TEST NUMBERS PRINTED AS TESTS ARE RUN
 978	!			  0 IF NO TEST NUMBERS ARE TO BE PRINTED
 979	!
 980	! IMPLICIT OUTPUTS:
 981	!
 982	!	NONE
 983	!
 984	! ROUTINE VALUE:
 985	!
 986	!	NONE
 987	!
 988	! SIDE EFFECTS:
 989	!
 990	!	PRINTS A LIST OF ACTIVATED FEATURES ON THE TTY.
 991	!
 992	!--
 993	    BEGIN
 994	
 995	    EXTERNAL ROUTINE
 996		SPEC_PRT;		!ROUTINE IN TEST MODULE TO PRINT SPECIAL FEATURES
 997	
 998	    REGISTER
 999		AC0 = 0;
1000	
1001	
1002	    PTXT_CRLF_F ('FEATURES ACTIVATED:');
1003	
1004	!IF ANY FEATURE IS ACTIVATED, THEN PRINT THOSE THAT ARE.
1005	
1006	    IF ( SPEC_PRT()	OR		!SPEC_PRT RETURNS 1 IF IT PRINTED ANY FEATURES
1007		.BELL_ON_ERR	OR
1008		.LOOP_ON_ERR	OR
1009		.LOOP_ON_TEST	OR
1010		.TEXT_INH	OR
1011		.SINGLE_STEP	OR
1012		.LOOP_ON_PRG	OR
1013		.PRT_TST_NUM	OR
1014		.NO_ISOLATION)	EQL 0
1015	
1016	    THEN
1017		PTXT_CRLF_F ('NONE')			!NO FEATURES ACTIVATED
1018	    ELSE
1019	
1020	!PRINT LIST OF THOSE FEATURES WHICH ARE ACTIVATED
1021	
1022		BEGIN
1023	
1024		IF .BELL_ON_ERR THEN PTXT_CRLF_F ('RING BELL ON ERROR');
1025	
1026		IF .LOOP_ON_ERR NEQ 0
1027		THEN
1028		    BEGIN
1029		    PRT_TXT_F ('LOOP ON ERROR');
1030	
1031		    IF .FAST_LOOP NEQ 0 THEN PRT_TXT_F (' (FAST LOOPING WHERE POSSIBLE)');
1032	
1033		    PRT_CRLF_F;
1034		    END;
1035	
1036		IF .LOOP_ON_TEST NEQ 0
1037		THEN
1038		    BEGIN
1039		    PRT_TXT_F ('LOOP ON TEST NUMBER ');
1040		    PRT_DEC_F (.LOOP_TEST);
1041		    PRT_CRLF_F;
1042		    END;
1043	
1044		IF .NO_ISOLATION NEQ 0 THEN PTXT_CRLF_F ('NO FAULT ISOLATION');
1045	
1046		IF .SINGLE_STEP NEQ 0 THEN PTXT_CRLF_F ('SINGLE STEP DIAGNOSTIC MICROCODE AND SYSTEM CLOCK');
1047	
1048		IF .TEXT_INH NEQ 0 THEN PTXT_CRLF_F ('SHORT ERROR PRINTOUTS');
1049	
1050		IF .LOOP_ON_PRG THEN PTXT_CRLF_F ('LOOP ON PROGRAM');
1051	
1052		IF .PRT_TST_NUM THEN PTXT_CRLF_F ('PRINTING TEST NUMBERS');
1053	
1054		END;
1055	
1056	    PRT_CRLF_F;
1057	    END;
1058	ROUTINE ASK_FEATURES : NOVALUE =
1059	
1060	!++
1061	! FUNCTIONAL DESCRIPTION:
1062	!
1063	!	THIS ROUTINE CONTROLS THE ACTIVATION OF PROGRAM RUNTIME FEATURES.
1064	!	IT FIRST ASKS THE USER IF HE/SHE WISHES TO CHANGE ACTIVATED
1065	!	FEATURES.  IF NOT, NOTHING IS DONE.  IF YES, THEN THE USER IS
1066	!	ASKED IF HE/SHE WISHES TO ACTIVATE EACH FEATURE, ONE AT A TIME.
1067	!	THE FLAG ASSOCIATED WITH EACH FEATURE IS SET OR CLEARED BASED
1068	!	ON THE RESPONSE.  THE ASKING OF SOME OF THE QUESTIONS IS 
1069	!	CONDITIONAL ON PREVIOUS RESPONSES.  SPECIFICALLY, IF 'LOOPING
1070	!	ON ERROR' IS NOT ACTIVATED, THEN IT IS NOT NECESSARY TO ASK IF
1071	!	'FAST LOOPING' IS DESIRED.  ALSO, IF 'LOOP ON TEST' IS ACTIVATED,
1072	!	THEN IT IS NOT NECESSARY TO ASK IF 'LOOP ON PROGRAM' OR 'PRINTING
1073	!	OF TEST NUMBERS' ARE DESIRED.
1074	!	THE ACTIVATION OF SPECIAL FEATURES PECULIAR TO A GIVEN TEST
1075	!	MODULE IS CONTROLLED BY THE 'SPEC_ASK' ROUTINE WHICH RESIDES IN
1076	!	THE TEST MODULE.
1077	!
1078	! FORMAL PARAMETERS:
1079	!
1080	!	NONE
1081	!
1082	! IMPLICIT INPUTS:
1083	!
1084	!	NONE
1085	!
1086	! IMPLICIT OUTPUTS:
1087	!
1088	!	FEATURES SWITCHES -
1089	!	BELL_ON_ERR	= 1 IF BELL IS TO BE RUNG ON DETECTION OF ERROR
1090	!			  0 IF BELL IS NOT TO BE RUNG
1091	!	LOOP_ON_ERR	= 1 IF PROGRAM IS TO LOOP ON FAILING ERROR
1092	!			  0 IF NO LOOPING IS DESIRED
1093	!	LOOP_ON_TEST	= 1 IF PROGRAM IS TO LOOP ON SPECIFIED TEST
1094	!			  0 IF NO TEST LOOPING IS DESIRED
1095	!	LOOP_TEST	= NUMBER OF TEST ON WHICH PROGRAM IS TO LOOP.
1096	!			  THIS DATA IS MEANINGFUL ONLY IF 'LOOP_ON_TEST'
1097	!			  SWITCH IS ACTIVATED.
1098	!	NO_ISOLATION	= 1 IF FAULT ISOLATION IS TO BE TURNED OFF.
1099	!			  0 IF FAULT ISOLATION IS TO BE PERFORMED.
1100	!	SINGLE_STEP	= 1 IF USER WISHES TO MANUALLY SINGLE STEP THE
1101	!			    DIAGNOSTIC MICROCODE AND THE SYSTEM CLOCK.
1102	!			  0 IF NO MANUAL SINGLE STEPPING IS DESIRED
1103	!	TEXT_INH	= 1 IF FUNCTIONAL ERROR DESCRIPTIONS ARE NOT TO
1104	!			    BE PRINTED. (ONLY TEST AND ERROR NUMBERS AND
1105	!			    CORRECT AND ACTUAL DATA).
1106	!			  0 IF FULL ERROR PRINTOUTS ARE DESIRED.
1107	!	LOOP_ON_PRG	= 1 IF INDEFINITE PROGRAM PASSES ARE TO BE RUN
1108	!			  0 IF ONLY ONE PROGRAM PASSES IS TO BE RUN
1109	!	PRT_TST_NUM	= 1 IF USER WANTS TEST NUMBERS PRINTED AS TESTS ARE RUN
1110	!			  0 IF NO TEST NUMBERS ARE TO BE PRINTED
1111	!
1112	! ROUTINE VALUE:
1113	!
1114	!	NONE
1115	!
1116	! SIDE EFFECTS:
1117	!
1118	!	NONE
1119	!
1120	!--
1121	    BEGIN
1122	
1123	    EXTERNAL ROUTINE
1124		SPEC_ASK : NOVALUE;
1125	
1126	    REGISTER
1127		AC0 = 0;
1128	
1129	    PRT_TXT_F ('DO YOU WISH TO CHANGE ACTIVATED FEATURES?');
1130	
1131	    IF TTI_YES
1132	    THEN
1133		BEGIN
1134		SPEC_ASK ();				!GO ASK ABOUT SPECIAL FEATURES
1135		PRT_TXT_F ('RING BELL ON ERROR?');
1136		BELL_ON_ERR = TTI_YES;
1137		PRT_TXT_F ('INHIBIT FAULT ISOLATION?');
1138		NO_ISOLATION = TTI_YES;
1139		PRT_TXT_F ('SHORT ERROR PRINTOUTS?');
1140		TEXT_INH = TTI_YES;
1141		PRT_TXT_F ('SINGLE STEPPING OF DIAG MICROCODE AND SYSTEM CLOCK?');
1142		SINGLE_STEP = TTI_YES;
1143		PRT_TXT_F ('LOOP ON ERROR?');
1144	
1145	!IF 'LOOP ON ERROR' IS NOT ACTIVATED, IT IS NOT NECESSARY TO ASK ABOUT
1146	!'FAST LOOPING'.
1147	
1148		IF (LOOP_ON_ERR = TTI_YES) NEQ 0
1149		THEN
1150		    BEGIN
1151		    PRT_TXT_F ('FAST LOOPING WHERE POSSIBLE?');
1152		    FAST_LOOP = TTI_YES;
1153		    END
1154		ELSE
1155		    FAST_LOOP = 0;
1156	
1157		PRT_TXT_F ('LOOP ON SPECIFIC TEST?');
1158	
1159	!IF 'LOOP ON TEST' IS ACTIVATED, THEN ASK WHICH TEST NUMBER TO LOOP ON.
1160	!AND DON'T BOTHER TO ASK ABOUT 'LOOP ON PROGRAM' OR 'PRINT TEST NUMBERS'.
1161	
1162		IF (LOOP_ON_TEST = TTI_YES) NEQ 0
1163		THEN
1164		    BEGIN
1165		    LOOP_ON_PRG = PRT_TST_NUM = 0;
1166		    LOOP_TEST = GET_NUM (UPLIT (%ASCIZ'TEST NUMBER'), MAXTEST);
1167		    END
1168		ELSE
1169		    BEGIN
1170		    PRT_TXT_F ('LOOP ON PROGRAM?');
1171		    LOOP_ON_PRG = TTI_YES;
1172		    PRT_TXT_F ('PRINT TEST NUMBERS AS THEY ARE RUN?');
1173		    PRT_TST_NUM = TTI_YES;
1174		    END;
1175	
1176		END;
1177	
1178	    PRT_CRLF_F;
1179	    END;
1180	
1181	GLOBAL ROUTINE MEMSIZE =
1182	
1183	!++
1184	! FUNCTIONAL DESCRIPTION:
1185	!
1186	!	THIS ROUTINE ASKS THE USER HOW MUCH MEMORY EXISTS ON THE KS10
1187	!	UNDER TEST.  IT IS CALLED FROM A TEST MODULE DURING THE START-
1188	!	UP DIALOGUE.  IF THE PROGRAM IS BEING RUN IN THE SCRIPTED MODE,
1189	!	NO QUESTIONS CAN BE ASKED.  SO A DEFAULT SIZE OF 128K IS ASSUMED.
1190	!	THIS ASSUMPTION IS PRINTED ON THE TTY.  IF THE USER TYPES AN
1191	!	INVALID NUMBER OR FORMAT, HE/SHE IS REPROMPTED UNTIL A VALID
1192	!	RESPONSE IS GIVEN.
1193	!
1194	! FORMAL PARAMETERS:
1195	!
1196	!	NONE
1197	!
1198	! IMPLICIT INPUTS:
1199	!
1200	!	NONE
1201	!
1202	! IMPLICIT OUTPUTS:
1203	!
1204	!	NONE
1205	!
1206	! ROUTINE VALUE:
1207	!
1208	!	THE AMOUNT OF MEMORY ON THE KS10 UNDER TEST, IN 'K'.
1209	!
1210	! SIDE EFFECTS:
1211	!
1212	!	NONE
1213	!
1214	!--
1215	    BEGIN
1216	
1217	    REGISTER
1218		AC0 = 0;
1219	
1220	
1221	!IF WE'RE NOT SCRIPTING, ASK HOW MUCH MEMORY KS10 HAS?
1222	
1223	    IF .SCRIPT_RUN EQL 0
1224	    THEN
1225		BEGIN
1226		PRT_TXT_F ('HOW MANY K OF MEMORY DOES THE KS10 HAVE (IN DECIMAL)?:');
1227	
1228	!STAY IN THE LOOP UNTIL A VALID ANSWER IS RECEIVED
1229	
1230		WHILE 1 DO
1231		    BEGIN
1232	
1233	!THE TTI_DEC UUO RETURNS A 0 IF AN INVALID NUMBER FORMAT WAS RECEIVED.  IT
1234	!RETURNS A 1 IF A VALID FORMAT WAS RECEIVED WITH THE NUMBER IN AC0.
1235	
1236		    IF TTI_DEC
1237		    THEN
1238			SELECTONEU .AC0 OF		!CHECK FOR VALID NUMBER
1239			    SET
1240			    [64,128,192,256,320,384,448,512]:	RETURN .AC0;
1241			    [OTHERWISE]:	PTXT_CRLF_F ('INVALID NUMBER');
1242			    TES
1243		    ELSE
1244			BEGIN
1245			PTXT_CRLF_F ('INVALID NUMBER FORMAT');
1246			TTI_CLR;			!CLEAR BAD INPUT FROM BUFFER
1247			END;
1248	
1249	!REPROMPT USER, TELL HIM VALID RESPONSES.
1250	
1251		    PRT_TXT_F ('TRY AGAIN, NUMBER MUST BE 64,128,192,256,320,384,448,512: ');
1252		    END
1253		END
1254	    ELSE
1255		BEGIN
1256		PTXT_CRLF_F ('ASSUMING 128K OF MEMORY ON KS10 UNDER TEST');
1257		RETURN 128;
1258		END;
1259	    0					!TO AVOID INFO MESSAGE WHEN COMPILING
1260	    END;
1261	
1262	ROUTINE GET_NUM (PROMPT, MAXVAL) =
1263	
1264	!++
1265	! FUNCTIONAL DESCRIPTION:
1266	!
1267	!	THIS ROUTINE IS CALLED TO INPUT A NUMBER FROM THE TTY.
1268	!	IT TYPES THE PROMPT POINTED TO BY THE PASSED PARAMETER 'PROMPT'
1269	!	AND INDICATES THE MAXIMUM ALLOWED VALUE ( AS DICTATED BY THE
1270	!	PASSED PARAMETER MAXVAL).  IT THEN WAITS FOR INPUT USING
1271	!	A 'CSL' PROGRAM ROUTINE INVOKED BY A LUUO.  THE INPUT IS
1272	!	INTERPRETED AS DECIMAL.  IF THE NUMBER RECEIVED IS NOT A VALID
1273	!	TEST NUMBER (OUT OF RANGE) OR IF THE TTY INPUT WAS IN A NON-
1274	!	DECIMAL FORMAT, THEN AN ERROR MESSAGE IS TYPED AND THE PROMPT
1275	!	IS REPEATED.
1276	!
1277	! FORMAL PARAMETERS:
1278	!
1279	!	PROMPT		= POINTER TO AN ASCIZ PROMPT MESSAGE
1280	!	MAXVAL		= MAXIMUM VALUE ALLOWED AS INPUT
1281	!
1282	! IMPLICIT INPUTS:
1283	!
1284	!	NONE
1285	!
1286	! IMPLICIT OUTPUTS:
1287	!
1288	!	NONE
1289	!
1290	! ROUTINE VALUE:
1291	!
1292	!	DECIMAL NUMBER RECEIVED AS TTY INPUT
1293	!
1294	! SIDE EFFECTS:
1295	!
1296	!	PRINTS PROMPT MESSAGE ON TTY AND RECEIVES USER RESPONSE.
1297	!	IF TTY INPUT IS INVALID, PROMPT IS REPEATED.
1298	!--
1299	
1300	    BEGIN
1301	
1302	    REGISTER
1303		AC0 = 0;
1304	
1305	!STAY IN LOOP UNTIL USER GIVES VALID RESPONSE
1306	
1307	    WHILE 1 DO
1308		BEGIN
1309		PRT_MSG_F (.PROMPT);			!TYPE PROMPT
1310		PRT_TXT_F (' (MAXIMUM ');
1311		PRT_DEC_F (.MAXVAL);
1312		PRT_TXT_F ('):');
1313	
1314	!THE TTI_DEC UUO RETURNS A 0 IF AN INVALID NUMBER FORMAT WAS RECEIVED.  IT
1315	!RETURNS A 1 IF A VALID FORMAT WAS RECEIVED WITH THE NUMBER IN AC0.
1316	
1317		IF TTI_DEC
1318		THEN
1319	
1320		    IF (.AC0 GTR 0) AND (.AC0 LEQ .MAXVAL)	!IS NUMBER OUT OF RANGE
1321		    THEN
1322			RETURN .AC0			!NO, RETURN WITH NUMBER
1323		    ELSE
1324			PTXT_CRLF_F ('NUMBER OUT OF RANGE') !YES, PRINT ERROR MESSAGE
1325	
1326		ELSE
1327		    BEGIN
1328		    PTXT_CRLF_F ('INVALID NUMBER FORMAT'); !PRINT ERROR MESSAGE
1329		    TTI_CLR;				!CLEAR TTY INPUT BUFFER
1330		    END;
1331	
1332		END;
1333	
1334	    0					!TO AVOID INFO MESSAGE WHEN COMPILING
1335	    END;
1336	ROUTINE INIT_DATA : NOVALUE =
1337	
1338	!++
1339	! FUNCTIONAL DESCRIPTION:
1340	!
1341	!	THIS ROUTINE INITIALIZES THOSE ITEMS OF THE DATA BASE WHICH
1342	!	NEED INITIALIZATION, INCLUDING THE POSSIBLE-FAULTY-NETWORK
1343	!	VECTOR AND ASSORTED PROGRAM FLAGS.  IT ALSO PASSES 'CONTROL-T'
1344	!	INFORMATION TO 'CSL'.  NAMELY, THE NUMBER OF TESTS AND THE
1345	!	ADDRESS WHERE THE NUMBER OF THE TEST BEING RUN IS STORED.
1346	!	LASTLY, IT CALLS A 'TEST_INIT' ROUTINE LOCATED IN THE TEST
1347	!	MODULE TO DO ANY SPECIAL INITIALIZATION.
1348	!
1349	! FORMAL PARAMETERS:
1350	!
1351	!	NONE
1352	!
1353	! IMPLICIT INPUTS:
1354	!
1355	!	MAXNETS		= A GLOBAL LITERAL DEFINING THE NUMBER OF NETWORKS
1356	!			  IN THE BOARD BEING TESTED.
1357	!	MAXTEST		= A GLOBAL LITERAL DEFINING THE NUMBER OF TESTS
1358	!	TEST_NUM	= THE ADDRESS OF THE TEST BEING EXECUTED
1359	!
1360	! IMPLICIT OUTPUTS:
1361	!
1362	!	HAD_FAILURE	= FLAG INDICATING IF ERROR WAS DETECTED
1363	!	MSG_FILE_OPEN	= FLAG INDICATING WHETHER ERROR MESSAGE FILE IS OPEN
1364	!	LAST_MEM_ADDR	= LAST MEMORY ADDRESSED REFERENCED BYF 'LA' OR 'EM' COMMAND
1365	!	LAST_IO_ADDR	= LAST I/O ADDRESSED REFERENCED BY 'LI' OR 'EI' COMMAND
1366	!	LAST_REG_ADDR	= LAST REGISTER ADDRESSED REFERENCED BY 'LR' OR 'ER' COMMAND
1367	!	SUB_LOADED	= FLAG INDICATING WHETHER 'X1' SUBROUTINE IS LOADED
1368	!	LOOPING		= FLAG INDICATING THAT PROGRAM IS LOOPING ON ERROR
1369	!	LINE_CHARS	= COUNTER USED BY 'SEND_LINE' ROUTINE TO COUNT THE # OF CHARS IN CMD LINE
1370	!
1371	! ROUTINE VALUE:
1372	!
1373	!	NONE
1374	!
1375	! SIDE EFFECTS:
1376	!
1377	!	NONE
1378	!--
1379	
1380	    BEGIN
1381	
1382	    EXTERNAL ROUTINE
1383		TEST_INIT;
1384	
1385	    REGISTER
1386		AC0 = 0;
1387	
1388	    MAP
1389		NET_FAULTS : VECTOR;
1390	
1391	    NETWRDS = (MAXNETS + 35)/36;
1392	
1393	    INCR I FROM 0 TO .NETWRDS - 1 BY 1 DO
1394		NET_FAULTS [.I] = -1;
1395	
1396	    HAD_FAILURE = 0;				!INIT TO NO FAILURE STATE
1397	    MSG_FILE_OPEN = 0;				!INIT TO FILE NOT OPEN STATE
1398	
1399	!INIT ADDRESS FLAGS TO NON-EXISTENT ADDRESSES
1400	    LAST_MEM_ADDR = -1;
1401	    LAST_IO_ADDR = -1;
1402	    LAST_REG_ADDR = -1;
1403	
1404	    SUB_LOADED = 0;				!INIT TO SUB NOT LOADED STATE
1405	    LOOPING = 0;				!INIT TO NOT LOOPING STATE
1406	    LINE_CHARS = 0;				!INIT TO ZERO CHAR COUNT
1407	    AC0<18, 18> = MAXTEST;			!PUT MAX # OF TESTS IN LH OF AC0
1408	    AC0<0, 18> = TEST_NUM;			!PUT ADDR OF TEST NUMBER LOC IN RH OF AC0
1409	    SEND_INFO;					!PASS CONTROL-T INFO TO 'CSL'
1410	    TEST_INIT ();				!CALL TEST MODULE INIT ROUTINE
1411	    END;
1412	ROUTINE DISPATCH : NOVALUE =
1413	
1414	!++
1415	! FUNCTIONAL DESCRIPTION:
1416	!
1417	!	THIS ROUTINE CONTROLS THE TEST DISPATCHING.  IF THE USER HAS
1418	!	SELECTED TO LOOP ON A SPECIFIED TEST, THEN THE TEST HE HAS
1419	!	SPECIFIED IS IMMEDIATELY EXECUTED AND INDEFINITELY REPEATED.
1420	!	AFTER THE FIRST EXECUTION OF THAT TEST A MESSAGE IS TYPED
1421	!	INFORMING THE USER THAT HE IS LOOPING ON THAT TEST.
1422	!	IF LOOP-ON-TEST IS NOT ACTIVATED THEN NORMAL TEST DISPATCHING
1423	!	IS DONE.  THE TESTS ARE CONSIDERED IN SEQUENTIAL ORDER.  FIRST,
1424	!	THE 'RUN_CHK' ROUTINE IS CALLED TO DETERMINE WHETHER OR NOT THE
1425	!	TEST SHOULD BE EXECUTED (SEE DESCRIPTION OF 'RUN_CHK' FOR
1426	!	DETAILS).  IF NOT, THEN THE TEST IS SKIPPED.  IF YES, THEN THE
1427	!	TEST IS DISPATCHED TO VIA THE TEST DISPATCH TABLE.
1428	!	RETURN TO THE CALLING PROGRAM IS MADE AFTER ALL TESTS HAVE
1429	!	BEEN EITHER SKIPPED OR EXECUTED.
1430	!
1431	! FORMAL PARAMETERS:
1432	!
1433	!	NONE
1434	!
1435	! IMPLICIT INPUTS:
1436	!
1437	!	FEATURES SWITCHES:
1438	!	LOOP_ON_TEST	= 1 IF PROGRAM IS TO LOOP ON SPECIFIED TEST
1439	!			  0 IF NO TEST LOOPING IS DESIRED
1440	!	LOOP_TEST	= NUMBER OF TEST ON WHICH PROGRAM IS TO LOOP.
1441	!			  THIS DATA IS MEANINGFUL ONLY IF 'LOOP_ON_TEST'
1442	!			  SWITCH IS ACTIVATED.
1443	!	PRT_TST_NUM	= 1 IF USER WANTS TEST NUMBERS PRINTED AS TESTS ARE RUN
1444	!			  0 IF NO TEST NUMBERS ARE TO BE PRINTED
1445	!	MAXTEST		= NUMBER OF TESTS TO BE RUN
1446	!	TEST_DISP	= TEST DISPATCH TABLE. THIS CONTAIN STARTING
1447	!			  ADDRESSES OF THE TESTS AND IS LOCATED IN THE
1448	!			  DATA MODULE.
1449	!
1450	! IMPLICIT OUTPUTS:
1451	!
1452	!	NONE
1453	!
1454	! ROUTINE VALUE:
1455	!
1456	!	NONE
1457	!
1458	! SIDE EFFECTS:
1459	!
1460	!	TEST_NUM	= THE NUMBER OF THE TEST BEING EXECUTED
1461	!	IF 'PRT_TST_NUM' FEATURE IS ACTIVATED, A 'STARTING TEST NUMBER X'
1462	!		MESSAGE WILL GET PRINTED BEFORE EACH TEST IS RUN.
1463	!	IF 'LOOP_ON_TEST' FEATURE IS ACTIVATED, A MESSAGE TO THAT EFFECT
1464	!		WILL BE PRINTED AFTER THE FIRST EXECUTION OF THAT TEST.
1465	!--
1466	
1467	    BEGIN
1468	
1469	    EXTERNAL
1470		TEST_DISP;				!TEST DISPATCH TABLE
1471	
1472	    MAP
1473		TEST_DISP : VECTOR;
1474	
1475	    REGISTER
1476		AC0 = 0;
1477	
1478	    LOCAL
1479		FIRST;					!FLAG FOR LOOPING MESSAGE PRINTING
1480	
1481	!IF 'LOOP ON TEST' FEATURE IS ACTIVATED, THEN INDEFINITELY LOOP ON TEST SPECIFIED
1482	!IN 'LOOP_TEST'.
1483	
1484	    IF .LOOP_ON_TEST NEQ 0
1485	    THEN
1486		BEGIN
1487		TEST_NUM = .LOOP_TEST;			!GET NUMBER OF TEST TO LOOP ON
1488		FIRST = 1;				!SET FIRST TIME THRU FLAG
1489	
1490		WHILE 1 DO
1491		    BEGIN
1492		    (.TEST_DISP [.LOOP_TEST - 1]) ();	!GO EXECUTE TEST
1493	
1494		    IF .FIRST EQL 1			!IF FIRST TIME THRU THEN PRINT MESSAGE
1495		    THEN
1496			BEGIN
1497			PRINT_TXT ('YOU ARE LOOPING ON TEST NUMBER ');
1498			PRINT_DEC (.LOOP_TEST);
1499			PRINT_CRLF;
1500			FIRST = 0;			!CLEAR FIRST TIME THRU FLAG
1501			END;
1502	
1503		    END;
1504	
1505		END;
1506	
1507	!SEQUENTIALLY EXECUTE THE TESTS.  BEFORE RUNNING EACH ONE CHECK IF IT SHOULD BE
1508	!RUN.
1509	
1510	    INCR I FROM 1 TO MAXTEST BY 1 DO
1511		BEGIN
1512		TEST_NUM = .I;				!GET NEXT TEST NUMBER
1513	
1514		IF RUN_CHK ()				!SHOULD THIS TEST BE RUN?
1515		THEN
1516		    BEGIN				!YES
1517	
1518		    IF .PRT_TST_NUM NEQ 0		!IF PRINT TEST #S SWITCH IS SET
1519		    THEN
1520			BEGIN
1521			PRINT_TXT ('STARTING ');	!THEN PRINT MESSAGE
1522			PTSTNUM ();
1523			END;
1524	
1525		    (.TEST_DISP [.TEST_NUM - 1]) ();	!EXECUTE TEST
1526		    END;
1527	
1528		END;
1529	
1530	    END;
1531	ROUTINE RUN_CHK =
1532	
1533	!++
1534	! FUNCTIONAL DESCRIPTION:
1535	!
1536	!	THIS ROUTINE PERFORMS A CHECK TO DETERMINE WHETHER OR NOT THE
1537	!	NEXT TEST SHOULD BE EXECUTED.
1538	!	IF THE 'NO_ISOLATION' SWITCH IS ACTIVATED THEN ALL TESTS ARE TO
1539	!	BE EXECUTED. THEREFORE, AN IMMEDIATE RUN-THE-TEST RETURN (1) IS
1540	!	MADE.
1541	!	THE DECISION TO RUN IS MADE BY COMPARING THE CUMULATIVE FAULTY
1542	!	NETWORKS VECTOR WITH THE VECTORS FOR THE TEST BEING EVALUATED.
1543	!	IF THERE IS NO OVERLAP BETWEEN THEM, THE TEST IS NOT RUN.  THIS
1544	!	INDICATES A CONDITION WHERE THE TEST WILL NOT DETECT ANY OF THE
1545	!	FAULTS WHICH HAVE ALREADY BEEN ESTABLISHED AS POSSIBLE. IF THERE
1546	!	IS OVERLAP, THEN A FURTHER CHECK IS MADE TO INSURE THAT THE
1547	!	CUMULATIVE VECTOR  IS NOT JUST A SUBSET OF THE TEST VECTORS. IF
1548	!	IT IS, THEN THE TEST IS NOT RUN.  THIS INDICATES A CONDITION
1549	!	WHERE THE TEST WILL NOT YIELD ANY FURTHER FAULT RESOLUTION. IF
1550	!	THERE IS OVERLAP AND IT IS NOT A SUBSET, THEN THE TEST IS RUN.
1551	!	A GLOBAL FLAG IS PROVIDED WHICH CAN BE SET BY THE TEST MODULE TO
1552	!	INHIBIT THE SUBSET CHECKING.
1553	!
1554	! FORMAL PARAMETERS:
1555	!
1556	!	NONE
1557	!
1558	! IMPLICIT INPUTS:
1559	!
1560	!	ES_TBL		= TABLE OF POINTERS TO TEST ERROR SIGNATURES (VECTORS)
1561	!	NES_TBL		= TABLE OF POINTERS TO 'NO ERROR' SIGNATURES (VECTORS)
1562	!	NET_FAULTS	= CUMULATIVE FAULTY NETWORK VECTOR
1563	!	NETWRDS		= NUMBER OF 36-BIT WORDS IN NET_FAULTS
1564	!	TEST_NUM	= NUMBER OF TEST TO BE EVALUATED
1565	!	NO_ISOLATION	= 1 IF NOT DOING FAULT ISOLATION - RUN ALL TESTS
1566	!			  0 IF DOING FAULT ISOLATION
1567	!	NO_SUBSET	= GLOBAL FLAG FOR SUBSET CHECKING
1568	!			  1 - DON'T CHECK FOR SUBSET
1569	!			  0 - CHECK FOR SUBSET
1570	!
1571	! IMPLICIT OUTPUTS:
1572	!
1573	!	NONE
1574	!
1575	! ROUTINE VALUE:
1576	!
1577	!	1 IF TEST IS TO BE RUN
1578	!	0 IF TEST IS NOT TO BE RUN
1579	!
1580	! SIDE EFFECTS:
1581	!
1582	!	NONE
1583	!--
1584	
1585	    BEGIN
1586	
1587	    OWN
1588		TEMP : VECTOR [10];			!TEMP STORAGE
1589	
1590	    LOCAL
1591		OVERLAP,				!BITVECTOR OVERLAP FLAG
1592		CNT,					!COUNTER FOR # OF BITVECTORS
1593		PTR,					!TEMP POINTER
1594		SIG_PTR;				!POINTER TO BITVECTOR
1595	
1596	    MAP
1597		NET_FAULTS : VECTOR,
1598		PTR : REF VECTOR,
1599		SIG_PTR : REF VECTOR;
1600	
1601	!IF NOT DOING FAULT ISOLATION, RUN ALL TESTS.
1602	
1603	    IF .NO_ISOLATION NEQ 0 THEN RETURN 1;
1604	
1605	    OVERLAP = 0;				!INIT FAULT OVERLAP FLAG
1606	    PTR = .ES_TBL [.TEST_NUM - 1];		!GET POINTER TO TABLE OF ERROR PTRS
1607	    CNT = .PTR [-1];				!GET NUMBER OF ERROR IN THIS TEST
1608	
1609	!COMPARE EACH ERROR BITVECTOR WITH THE CUMULATIVE BITVECTOR
1610	
1611	    INCR I FROM 0 TO .CNT - 1 BY 1 DO
1612		BEGIN
1613		SIG_PTR = .PTR [.I];			!GET POINTER TO ERROR BITVECTOR
1614	
1615	!COMPARE BITVECTORS A WORD AT A TIME, ITS FASTER.
1616	
1617		INCR J FROM 0 TO .NETWRDS - 1 BY 1 DO
1618		    BEGIN
1619		    TEMP [.J] = .SIG_PTR [.J] AND .NET_FAULTS [.J]; !CHECK FOR OVERLAP
1620	
1621		    IF .TEMP [.J] NEQ 0			!IF THERE WAS OVERLAP THEN
1622		    THEN
1623	
1624			IF .NO_SUBSET EQL 0		!DOES TEST MODULE WANT SUBSET CHECKING?
1625			THEN
1626			    OVERLAP = -1		!YES, SET FLAG THAT THERE IS  FAULT OVERLAP
1627			ELSE
1628			    RETURN 1;			!NO, GIVE RUN-THE-TEST RETURN
1629	
1630		    END;
1631	
1632	!IF THERE WAS OVERLAP AND SUBSET CHECKING IS NOT INHIBITED, THEN CHECK IF THE
1633	!CUMULATIVE BITVECTOR IS A SUBSET OF THE ERROR BITVECTOR.  IF NOT, GIVE A
1634	!RUN-THE-TEST RETURN.  IF YES, CONTINUE CHECKING NEXT BITVECTOR.
1635	
1636		IF .OVERLAP NEQ 0
1637		THEN
1638	
1639		    INCR J FROM 0 TO .NETWRDS - 1 BY 1 DO
1640	
1641			IF .TEMP [.J] NEQ .NET_FAULTS [.J] THEN RETURN 1;
1642	
1643		END;
1644	
1645	!NOW CHECK IF THERE IS ANY OVERLAP BETWEEN THE 'NO ERROR' BITVECTORS AND THE
1646	!CUMULATIVE BITVECTOR.
1647	
1648	    PTR = .NES_TBL [.TEST_NUM - 1];		!GET POINTER TO TABLE OF NO ERROR PTRS
1649	
1650	    IF .PTR NEQ 0				!ONLY CHECK IF THERE ARE NO ERROR BITVECTORS
1651	    THEN
1652		BEGIN
1653		CNT = .PTR [-1];			!GET NUMBER OF NO ERROR IN THIS TEST
1654	
1655	!COMPARE BITVECTORS FOR EACH OF THE 'NO ERROR' BITVECTORS, ONE AT A TIME.
1656	
1657		INCR I FROM 0 TO .CNT - 1 BY 1 DO
1658		    BEGIN
1659		    SIG_PTR = .PTR [.I];		!GET POINTER TO NO ERROR BITVECTOR
1660	
1661	!COMPARE THE BITVECTORS A WORD AT A TIME FOR SPEED.
1662	
1663		    INCR J FROM 0 TO .NETWRDS - 1 BY 1 DO
1664	
1665			IF (.SIG_PTR [.J] AND .NET_FAULTS [.J]) NEQ 0 THEN RETURN 1;
1666	
1667		    END;
1668	
1669		END;
1670	
1671	    RETURN 0;
1672	    END;
1673	ROUTINE NET_RPT : NOVALUE =
1674	
1675	!++
1676	! FUNCTIONAL DESCRIPTION:
1677	!
1678	!	THIS ROUTINE IS CALLED TO PRINT A LIST OF THE POSSIBLY FAULTY
1679	!	NETWORKS AFTER ALL TESTING HAS BEEN DONE.  IT COMPILES THE LIST
1680	!	USING THE INFORMATION IN THE FINAL CUMULATIVE FAULT VECTOR.
1681	!	OFTEN, SEVERAL CONSECUTIVE BITS IN THE CUMULATIVE VECTOR ARE
1682	!	ASSOCIATED WITH THE SAME NETWORK.  TO AVOID PRINTING THE SAME
1683	!	NETWORK NAME MORE THAN ONCE, THE POINTER TO THE LAST NAME
1684	!	PRINTED IS KEPT.  THEN BEFORE THE NEXT NETWORK NAME IS PRINTED,
1685	!	THE POINTERS ARE COMPARED.  IF THEY ARE THE SAME THE NAME IS
1686	!	NOT PRINTED.
1687	!	IF THE 'NO ISOLATION' FEATURE WAS SELECTED, THEN THERE IS NO
1688	!	LIST TO BE PRINTED.
1689	!
1690	! FORMAL PARAMETERS:
1691	!
1692	!	NONE
1693	!
1694	! IMPLICIT INPUTS:
1695	!
1696	!	NO_ISOLATION	= 1 IF NO FAULT ISOLATION WAS DONE - HENCE, NO LIST
1697	!			  0 IF FAULT ISOLATION WAS DONE
1698	!	HAD_FAILURE	= 1 IF AT LEAST ONE FAILURE WAS DETECTED
1699	!			  0 IF NO FAILURES WERE DETECTED - HENCE, NO LIST
1700	!	NET_FAULTS	= CUMULATIVE FAULTY NETWORK VECTOR
1701	!	MAXNETS		= A GLOBAL LITERAL DEFINING THE NUMBER OF NETWORKS
1702	!			  IN THE BOARD BEING TESTED.
1703	!	NET_NAMES	= EXTERNAL TABLE OF NETWORK NAMES
1704	!
1705	! IMPLICIT OUTPUTS:
1706	!
1707	!	NONE
1708	!
1709	! ROUTINE VALUE:
1710	!
1711	!	NONE
1712	!
1713	! SIDE EFFECTS:
1714	!
1715	!	A LIST OF POSSIBLE FAULTY NETWORKS IS PRINTED.
1716	!--
1717	
1718	    BEGIN
1719	
1720	    EXTERNAL
1721		NET_NAMES;				!TABLE OF NETWORK NAMES
1722	
1723	    MAP
1724		NET_NAMES : VECTOR;
1725	
1726	    REGISTER
1727		AC0 = 0;
1728	
1729	    LOCAL
1730		LAST_PTR,				!PTR TO LAST ASCIZ NAME STRING
1731		NAME_PTR;				!PTR TO CURRENT ASCII NAME STRING
1732	
1733	!IF NO FAULT ISOLATION WAS DONE THEN THERE ARE NO FAULTY NETWORKS TO REPORT.
1734	
1735	    IF .NO_ISOLATION NEQ 0			!IF NO FAULT ISOLATION WAS DONE
1736	    THEN
1737		RETURN;					!DON'T REPORT ANYTHING
1738	
1739	!THE CUMULATIVE FAULTY NETWORK BITVECTOR IS MEANINGFUL ONLY IF THERE WAS AT
1740	!LEAST ONE ERROR.  ELSE REPORT NO FAULTS DETECTED.
1741	
1742	    IF .HAD_FAILURE NEQ 0
1743	    THEN
1744		BEGIN
1745		PRINT_CRLF;
1746		PTXT_CRLF ('POSSIBLE FAULTY NETWORKS');	!PRINT HEADING
1747		PTXT_CRLF ('-------- ------ --------');
1748		LAST_PTR = 0;				!INIT LAST PTR
1749	
1750	!GO THRU CUMULATIVE BITVECTOR ONE BIT AT A TIME.
1751	
1752		INCR I FROM 0 TO MAXNETS - 1 BY 1 DO
1753	
1754		    IF .NET_FAULTS [.I] NEQ 0		!IF NETWORK BIT IS SET THEN
1755		    THEN
1756			BEGIN
1757			NAME_PTR = .NET_NAMES [.I];	!GET PTR TO NETWORK NAME
1758	
1759			IF .NAME_PTR NEQ .LAST_PTR	!AND PRINT IT IF IT IS DIFFERENT
1760							! FROM LAST NAME PRINTED.
1761			THEN
1762			    BEGIN
1763			    PRT_MSG_F (.NAME_PTR);	!PRINT NETWORK NAME
1764			    PRT_CRLF_F;
1765			    LAST_PTR = .NAME_PTR;	!UPDATE PTR TO LAST NAME PRINTED
1766			    END;
1767	
1768			END;
1769	
1770		END
1771	    ELSE
1772		PTXT_CRLF_F ('NO FAULTS DETECTED');
1773	
1774	    END;
1775	
1776	GLOBAL ROUTINE ERR (NUM) : NOVALUE =
1777	
1778	!++
1779	! FUNCTIONAL DESCRIPTION:
1780	!
1781	!	THIS ROUTINE IS CALLED WHEN AN ERROR IN DETECTED.  IT IN
1782	!	TURN CALLS A ROUTINE TO PERFORM FAULT ISOLATION BASED ON
1783	!	THE ERROR AND A ROUTINE TO PRINT AN ERROR MESSAGE.  NO
1784	!	CORRECT AND ACTUAL DATA OR SPECIAL PRINTING IS INVOLVED.
1785	!
1786	! FORMAL PARAMETERS:
1787	!
1788	!	NUM		= ERROR NUMBER
1789	!
1790	! IMPLICIT INPUTS:
1791	!
1792	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
1793	!			  0 IF BELL IS NOT TO BE RUNG
1794	!
1795	! IMPLICIT OUTPUTS:
1796	!
1797	!	NONE
1798	!
1799	! ROUTINE VALUE:
1800	!
1801	!	NONE
1802	!
1803	! SIDE EFFECTS:
1804	!
1805	!	ERROR MESSAGE IS PRINTED ON THE TTY.
1806	!	THE CUMULATIVE FAULTY NETWORK VECTOR IS UPDATED BY 'FAILURE'.
1807	!--
1808	
1809	    BEGIN
1810	
1811	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
1812	    THEN
1813		PBELL;					!THEN RING TTY BELL
1814	
1815	    ERR_RPT (.NUM, .NUM, 0, 0, 0, 0);
1816	    FAILURE (.NUM);
1817	    END;
1818	
1819	GLOBAL ROUTINE ERRCA (NUM, CORRECT, ACTUAL, DIGITS) : NOVALUE =
1820	
1821	!++
1822	! FUNCTIONAL DESCRIPTION:
1823	!
1824	!	THIS ROUTINE IS CALLED WHEN AN ERROR IN DETECTED WHICH INVOLVES
1825	!	CORRECT AND ACTUAL DATA.  IT IN TURN CALLS A ROUTINE TO PERFORM
1826	!	FAULT ISOLATION BASED ON THE ERROR AND A ROUTINE TO PRINT AN
1827	!	ERROR MESSAGE.
1828	!
1829	! FORMAL PARAMETERS:
1830	!
1831	!	NUM		= ERROR NUMBER
1832	!	CORRECT		= CORRECT DATA
1833	!	ACTUAL		= ACTUAL DATA
1834	!	DIGITS		= NUMBER OF OCTAL DIGITS IN CORRECT/ACTUAL DATA
1835	!
1836	! IMPLICIT INPUTS:
1837	!
1838	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
1839	!			  0 IF BELL IS NOT TO BE RUNG
1840	!
1841	! IMPLICIT OUTPUTS:
1842	!
1843	!	NONE
1844	!
1845	! ROUTINE VALUE:
1846	!
1847	!	NONE
1848	!
1849	! SIDE EFFECTS:
1850	!
1851	!	ERROR MESSAGE IS PRINTED ON THE TTY.
1852	!	THE CUMULATIVE FAULTY NETWORK VECTOR IS UPDATED BY 'FAILURE'.
1853	!--
1854	
1855	    BEGIN
1856	
1857	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
1858	    THEN
1859		PBELL;					!THEN RING TTY BELL
1860	
1861	    ERR_RPT (.NUM, .NUM, .CORRECT, .ACTUAL, .DIGITS, 0);
1862	    FAILURE (.NUM);
1863	    END;
1864	
1865	GLOBAL ROUTINE ERRCAS (ERR_NUM, MSG_NUM, CORRECT, ACTUAL, DIGITS, SPEC_PTR) : NOVALUE =
1866	
1867	!++
1868	! FUNCTIONAL DESCRIPTION:
1869	!
1870	!	THIS ROUTINE IS CALLED WHEN AN ERROR IS DETECTED WHICH INVOLVES
1871	!	CORRECT AND ACTUAL DATA AND SPECIAL PRINTING.  IT IN TURNS CALLS
1872	!	THE 'ERR_RPT' ROUTINE TO PRINT AN ERROR MESSAGE AND THE 'FAILURE'
1873	!	ROUTINE TO UPDATE THE FAULTY NETWORK VECTOR.
1874	!
1875	! FORMAL PARAMETERS:
1876	!
1877	!	ERR_NUM		= ERROR NUMBER
1878	!	MSG_NUM		= ERROR MESSAGE NUMBER
1879	!	CORRECT		= CORRECT DATA
1880	!	ACTUAL		= ACTUAL DATA
1881	!	DIGITS		= NUMBER OF OCTAL DIGITS IN CORRECT/ACTUAL DATA
1882	!	SPEC_PTR	= POINTER TO TABLE OF SPECIAL PRINT INFO
1883	!
1884	! IMPLICIT INPUTS:
1885	!
1886	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
1887	!			  0 IF BELL IS NOT TO BE RUNG
1888	!
1889	! IMPLICIT OUTPUTS:
1890	!
1891	!	NONE
1892	!
1893	! ROUTINE VALUE:
1894	!
1895	!	NONE
1896	!
1897	! SIDE EFFECTS:
1898	!
1899	!	ERROR MESSAGE IS PRINTED ON THE TTY.
1900	!	THE CUMULATIVE FAULTY NETWORK VECTOR IS UPDATED BY 'FAILURE'.
1901	!
1902	!--
1903	    BEGIN
1904	
1905	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
1906	    THEN
1907		PBELL;					!THEN RING TTY BELL
1908	
1909	    ERR_RPT (.ERR_NUM, .MSG_NUM, .CORRECT, .ACTUAL, .DIGITS, .SPEC_PTR);
1910	    FAILURE (.ERR_NUM);
1911	    END;
1912	
1913	GLOBAL ROUTINE ERRS (ERR_NUM, MSG_NUM, SPEC_PTR) : NOVALUE =
1914	
1915	!++
1916	! FUNCTIONAL DESCRIPTION:
1917	!
1918	!	THIS ROUTINE IS CALLED WHEN AN ERROR IS DETECTED WHICH INVOLVES
1919	!	SPECIAL PRINTING.  IT IN TURNS CALLS THE 'ERR_RPT' ROUTINE TO
1920	!	PRINT AN ERROR MESSAGE AND THE 'FAILURE' ROUTINE TO UPDATE THE
1921	!	CUMULATIVE FAULTY NETWORK VECTOR.
1922	!
1923	! FORMAL PARAMETERS:
1924	!
1925	!	ERR_NUM		= ERROR NUMBER
1926	!	MSG_NUM		= ERROR MESSAGE NUMBER
1927	!	SPEC_PTR	= POINTER TO TABLE OF SPECIAL PRINT INFO
1928	!
1929	! IMPLICIT INPUTS:
1930	!
1931	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
1932	!			  0 IF BELL IS NOT TO BE RUNG
1933	!
1934	! IMPLICIT OUTPUTS:
1935	!
1936	!	NONE
1937	!
1938	! ROUTINE VALUE:
1939	!
1940	!	NONE
1941	!
1942	! SIDE EFFECTS:
1943	!
1944	!	ERROR MESSAGE IS PRINTED ON THE TTY.
1945	!	THE CUMULATIVE FAULTY NETWORK VECTOR IS UPDATED BY 'FAILURE'.
1946	!
1947	!--
1948	    BEGIN
1949	
1950	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
1951	    THEN
1952		PBELL;					!THEN RING TTY BELL
1953	
1954	    ERR_RPT (.ERR_NUM, .MSG_NUM, 0, 0, 0, .SPEC_PTR);
1955	    FAILURE (.ERR_NUM);
1956	    END;
1957	
1958	GLOBAL ROUTINE ERRM (NUM) : NOVALUE =
1959	
1960	!++
1961	! FUNCTIONAL DESCRIPTION:
1962	!
1963	!	THIS ROUTINE IS CALLED WHEN AN ERROR IN DETECTED.  IT IN
1964	!	TURN CALLS THE 'ERR_RPT' ROUTINE TO PRINT AN ERROR MESSAGE.
1965	!
1966	! FORMAL PARAMETERS:
1967	!
1968	!	NUM		= ERROR NUMBER
1969	!
1970	! IMPLICIT INPUTS:
1971	!
1972	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
1973	!			  0 IF BELL IS NOT TO BE RUNG
1974	!
1975	! IMPLICIT OUTPUTS:
1976	!
1977	!	NONE
1978	!
1979	! ROUTINE VALUE:
1980	!
1981	!	NONE
1982	!
1983	! SIDE EFFECTS:
1984	!
1985	!	ERROR MESSAGE IS PRINTED ON THE TTY.
1986	!--
1987	
1988	    BEGIN
1989	
1990	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
1991	    THEN
1992		PBELL;					!THEN RING TTY BELL
1993	
1994	    ERR_RPT (.NUM, .NUM, 0, 0, 0, 0);
1995	    END;
1996	
1997	GLOBAL ROUTINE ERMCA (NUM, CORRECT, ACTUAL, DIGITS) : NOVALUE =
1998	
1999	!++
2000	! FUNCTIONAL DESCRIPTION:
2001	!
2002	!	THIS ROUTINE IS CALLED WHEN AN ERROR IN DETECTED WHICH INVOLVES
2003	!	CORRECT AND ACTUAL DATA.  IT IN TURN CALLS THE 'ERR_RPT' ROUTINE
2004	!	TO PRINT AN ERROR MESSAGE.
2005	!
2006	! FORMAL PARAMETERS:
2007	!
2008	!	NUM		= ERROR NUMBER
2009	!	CORRECT		= CORRECT DATA
2010	!	ACTUAL		= ACTUAL DATA
2011	!	DIGITS		= NUMBER OF OCTAL DIGITS IN CORRECT/ACTUAL DATA
2012	!
2013	! IMPLICIT INPUTS:
2014	!
2015	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
2016	!			  0 IF BELL IS NOT TO BE RUNG
2017	!
2018	! IMPLICIT OUTPUTS:
2019	!
2020	!	NONE
2021	!
2022	! ROUTINE VALUE:
2023	!
2024	!	NONE
2025	!
2026	! SIDE EFFECTS:
2027	!
2028	!	ERROR MESSAGE IS PRINTED ON THE TTY.
2029	!
2030	!--
2031	
2032	    BEGIN
2033	
2034	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
2035	    THEN
2036		PBELL;					!THEN RING TTY BELL
2037	
2038	    ERR_RPT (.NUM, .NUM, .CORRECT, .ACTUAL, .DIGITS, 0);
2039	    END;
2040	
2041	GLOBAL ROUTINE ERMCAS (MSG_NUM, CORRECT, ACTUAL, DIGITS, SPEC_PTR) : NOVALUE =
2042	
2043	!++
2044	! FUNCTIONAL DESCRIPTION:
2045	!
2046	!	THIS ROUTINE IS CALLED WHEN AN ERROR IS DETECTED WHICH INVOLVES
2047	!	CORRECT AND ACTUAL DATA AND SPECIAL PRINTING.  IT IN TURNS CALLS
2048	!	THE 'ERR_RPT' ROUTINE TO PRINT AN ERROR MESSAGE.
2049	!
2050	! FORMAL PARAMETERS:
2051	!
2052	!	MSG_NUM		= ERROR MESSAGE NUMBER
2053	!	CORRECT		= CORRECT DATA
2054	!	ACTUAL		= ACTUAL DATA
2055	!	DIGITS		= NUMBER OF OCTAL DIGITS IN CORRECT/ACTUAL DATA
2056	!	SPEC_PTR	= POINTER TO TABLE OF SPECIAL PRINT INFO
2057	!
2058	! IMPLICIT INPUTS:
2059	!
2060	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
2061	!			  0 IF BELL IS NOT TO BE RUNG
2062	!
2063	! IMPLICIT OUTPUTS:
2064	!
2065	!	NONE
2066	!
2067	! ROUTINE VALUE:
2068	!
2069	!	NONE
2070	!
2071	! SIDE EFFECTS:
2072	!
2073	!	ERROR MESSAGE IS PRINTED ON THE TTY.
2074	!
2075	!--
2076	    BEGIN
2077	
2078	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
2079	    THEN
2080		PBELL;					!THEN RING TTY BELL
2081	
2082	    ERR_RPT (.MSG_NUM, .MSG_NUM, .CORRECT, .ACTUAL, .DIGITS, .SPEC_PTR);
2083	    END;
2084	
2085	GLOBAL ROUTINE ERMS (MSG_NUM, SPEC_PTR) : NOVALUE =
2086	
2087	!++
2088	! FUNCTIONAL DESCRIPTION:
2089	!
2090	!	THIS ROUTINE IS CALLED WHEN AN ERROR IS DETECTED WHICH INVOLVES
2091	!	SPECIAL PRINTING.  IT IN TURNS CALLS THE 'ERR_RPT' ROUTINE TO
2092	!	PRINT AN ERROR MESSAGE.
2093	!
2094	! FORMAL PARAMETERS:
2095	!
2096	!	MSG_NUM		= ERROR MESSAGE NUMBER
2097	!	SPEC_PTR	= POINTER TO TABLE OF SPECIAL PRINT INFO
2098	!
2099	! IMPLICIT INPUTS:
2100	!
2101	!	BELL_ON_ERROR	= 1 IF BELL IS TO BE RUNG
2102	!			  0 IF BELL IS NOT TO BE RUNG
2103	!
2104	! IMPLICIT OUTPUTS:
2105	!
2106	!	NONE
2107	!
2108	! ROUTINE VALUE:
2109	!
2110	!	NONE
2111	!
2112	! SIDE EFFECTS:
2113	!
2114	!	ERROR MESSAGE IS PRINTED ON THE TTY.
2115	!
2116	!--
2117	    BEGIN
2118	
2119	    IF .BELL_ON_ERR NEQ 0			!IF BELL ON ERROR SWITCH IS SET
2120	    THEN
2121		PBELL;					!THEN RING TTY BELL
2122	
2123	    ERR_RPT (.MSG_NUM, .MSG_NUM, 0, 0, 0, .SPEC_PTR);
2124	    END;
2125	
2126	ROUTINE ERR_RPT (ERR_NUM, MSG_NUM, CORRECT, ACTUAL, DIGITS, SPEC_PTR) : NOVALUE =
2127	
2128	!++
2129	! FUNCTIONAL DESCRIPTION:
2130	!
2131	!	THIS ROUTINE IS CALLED TO PRINT AN ERROR MESSAGE ON THE TTY
2132	!	WHEN A ERROR IS DETECTED.
2133	!	BEFORE THE FIRST ERROR MESSAGE IS PRINTED, A HEADING OF
2134	!	'FAILING TESTS' IS PRINTED.  THEN FOR EACH ERROR THE TEST
2135	!	NUMBER AND ERROR NUMBER ARE REPORTED.  IF THE TEXT INHIBIT
2136	!	SWITCH IS ACTIVATED, NO FUNCTIONAL ERROR DESCRIPTION IS
2137	!	PRINTED.  IF IT IS NOT ACTIVATED, THE ERROR MESSAGE FOR THE
2138	!	FAILING TEST AND ERROR IS RETRIEVED FROM THE ERROR MESSAGE
2139	!	FILE.  THIS IS AN ASCII FILE WITH TEST NUMBER AND ERROR NUMBER
2140	!	FLAGS FOR EACH MESSAGE.  USING LUUO CALLS TO 'CSL' PROGRAM
2141	!	FILE HANDLING ROUTINES, THE MESSAGE FILE IS READ UNTIL THE
2142	!	SPECIFIED TEST AND ERROR NUMBER FLAGS ARE LOCATED.  THEN THE
2143	!	MESSAGE IS TRANSFERRED A LINE AT A TIME INTO A BUFFER AND
2144	!	PRINTED ON THE TTY UNTIL THE END-OF-MESSAGE TERMINATOR IS
2145	!	REACHED.
2146	!	SOME ERROR MESSAGES REQUIRE SPECIAL PRINTING.  THIS IS INDICATED
2147	!	BY THE PRESENCE OF A '\' CHARACTER IN THE MESSAGE TEXT. WHEN
2148	!	THIS CHARACTER IS DETECTED, THE 'PRT_SPEC' ROUTINE IS CALLED.
2149	!	IF THE ERROR INVOLVES CORRECT AND ACTUAL DATA, A ROUTINE IS
2150	!	CALLED TO PRINT THAT DATA.  THIS IS DONE REGARDLESS OF WHETHER
2151	!	OR NOT THE TEXT INHIBIT SWITCH IS ACTIVATED.
2152	!
2153	! FORMAL PARAMETERS:
2154	!
2155	!	ERR_NUM		= ERROR NUMBER
2156	!	MSG_NUM		= ERROR MESSAGE NUMBER
2157	!	CORRECT		= CORRECT DATA
2158	!	ACTUAL		= ACTUAL DATA
2159	!	DIGITS		= NUMBER OF OCTAL DIGITS IN CORRECT/ACTUAL DATA
2160	!	SPEC_PTR	= POINTER TO TABLE OF SPECIAL PRINT INFO
2161	!
2162	! IMPLICIT INPUTS:
2163	!
2164	!	LOOPING		= 1 IF LOOPING ON ERROR
2165	!			  0 IF NOT LOOPING
2166	!	LOOP_ERR_NUM	= ERROR NUMBER ON WHICH PROGRAM IS LOOPING
2167	!			  (THIS IS MEANINGFUL ONLY IF 'LOOPING' IS A 1)
2168	!	MSG_FILE_OPEN	= 1 IF MESSAGE FILE IS OPEN
2169	!			  0 IF NOT OPENED
2170	!	TEST_NUM	= NUMBER OF TEST BEING EXECUTED
2171	!	HAD_FAILURE	= 0 IF NO PREVIOUS ERRORS
2172	!			  1 IF ALREADY HAD ERRORS
2173	!	TEXT_INH	= 1 IF ERROR DESCRIPTION IS NOT TO BE PRINTED
2174	!			  0 IF DESCRIPTION IS TO BE PRINTED
2175	!	MSGFIL		= PLIT POINTER TO SIXBIT ERROR MESSAGE FILE NAME
2176	!	PAGE_IN		= FLAG INDICATING WHETHER A MESSAGE PAGE IS IN CORE
2177	!
2178	! IMPLICIT OUTPUTS:
2179	!
2180	!	NONE
2181	!
2182	! ROUTINE VALUE:
2183	!
2184	!	NONE
2185	!
2186	! SIDE EFFECTS:
2187	!
2188	!	AN ERROR MESSAGE IS PRINTED ON THE TTY.
2189	!--
2190	
2191	    BEGIN
2192	
2193	    REGISTER
2194		AC0 = 0;
2195	
2196	    LOCAL
2197		TXT_BUF_PTR,				!BYTE POINTER INTO ERROR TEXT
2198		CH;					!CHARACTER FROM ERROR MSG FILE
2199	
2200	    OWN
2201		LAST_ACTUAL,				!ACTUAL DATA FROM LAST ERROR MESSAGE
2202		TXT_BUF : CHAR_BUF [83],		!ERROR MESSAGE BUFFER
2203		LAST_TEST_MSG,				!# OF LAST TEST WHICH HAD ERROR
2204		LAST_MSG_NUM;				!# OF LAST ERROR MESSAGE PRINTED
2205	
2206	    ERRFLG = 1;					!SET ERROR FLAG FOR 'LOOP_CHK" ROUTINE
2207	
2208	!IF PROGRAM IS ALREADY LOOPING ON ERROR, THEN CHECK IF THIS ERROR PRECEDES THE
2209	!ONE BEING LOOPED ON.  IF SO, THEN THIS ERROR MESSAGE MUST BE PRINTED AND THE
2210	!LOOPING WILL BE TIGHTED TO THIS ERROR.  IF NOT, DON'T REPRINT THE ERROR MESSAGE
2211	!JUST PRINT THE CORRECT AND ACTUAL ONLY IF THE ACTUAL CHANGED.
2212	
2213	    IF .LOOPING NEQ 0				!ARE WE LOOPING ON ERROR?
2214	    THEN
2215	
2216		IF .ERR_NUM LSS .LOOP_ERR_NUM		!YES, IS THIS A PRECEDING ERROR?
2217		THEN
2218		    MSG_FILE_OPEN = 0			!YES, SETUP TO REOPEN MSG FILE
2219							! AND PRINT ERROR MESSAGE
2220		ELSE
2221		    BEGIN
2222	
2223		    IF (.DIGITS NEQ 0) AND (.LAST_ACTUAL NEQ .ACTUAL) !NO, HAS ACTUAL CHANGED?
2224		    THEN
2225			PRINT_CA (.CORRECT, .ACTUAL, .DIGITS); !YES, PRINT NEW COR/ACT
2226	
2227		    RETURN;
2228		    END;
2229	
2230	!IF THIS MESSAGE IS THE SAME AS THE PREVIOUS MESSAGE, THEN WE HAVE TO REOPEN
2231	!THE MESSAGE FILE AND REREAD IT BECAUSE WE'VE ALREADY GONE PAST THE MESSAGE.
2232	
2233	    IF (.TEST_NUM EQL .LAST_TEST_MSG) AND (.MSG_NUM LEQ .LAST_MSG_NUM)
2234	    THEN
2235		MSG_FILE_OPEN = 0;			!SET FLAG TO REOPEN MESSAGE FILE
2236	
2237	!IF THIS IS THE FIRST FAILURE, THEN PRINT THE ERROR MESSAGE HEADER.
2238	
2239	    IF .HAD_FAILURE EQL 0
2240	    THEN
2241		BEGIN
2242		PTXT_CRLF ('FAILING TESTS');
2243		PTXT_CRLF ('------- -----');
2244		HAD_FAILURE = -1;			!SET FLAG THAT WE HAD ERROR
2245		END;
2246	
2247	    PRINT_CRLF;
2248	    PRINT_TXT ('TEST #');
2249	    PRINT_DEC (.TEST_NUM);			!PRINT TEST #
2250	    PRINT_TXT ('  ERROR #');
2251	    PRINT_DEC (.ERR_NUM);			!PRINT ERROR #
2252	    PRINT_CRLF;
2253	
2254	    IF .TEXT_INH EQL 0				!ONLY PRINT TEXT IF TEXT INHIBIT FEATURE IS OFF
2255	    THEN
2256		BEGIN
2257	
2258		IF .MSG_FILE_OPEN EQL 0			!IF MESSAGE FILE ISN'T OPEN, DO IT
2259		THEN
2260		    BEGIN
2261	
2262		    IF FSELECT (MSGFIL)			!GO OPEN FILE
2263		    THEN
2264			BEGIN				!SUCCEEDED!
2265			MSG_FILE_OPEN = 1;		!SET FLAG THAT FILE IS OPEN
2266			PAGE_IN = 0;			!SET FLAG THAT NO PAGE IS IN CORE
2267			LAST_TEST_MSG = 0;		!INIT FLAG
2268			LAST_MSG_NUM = 0;		!INIT FLAG
2269			END
2270		    ELSE
2271			BEGIN				!FAILED, PRINT ERROR MESSAGE
2272			PRINT_TXT ('?ERROR - CANNOT OPEN MESSAGE FILE ');
2273			PNTSIX (.MSGFIL);		!PRINT FILNAME
2274			PRINT_TXT ('.');
2275			PNTSIX (.(MSGFIL + 1));		!PRINT EXTENSION
2276			PRINT_CRLF;
2277			RETURN;
2278			END;
2279	
2280		    END;
2281	
2282	!IF THE CURRENT TEST NUMBER IS GREATER THAN THE ONE FOR THE ERROR LAST PRINTED,
2283	!THEN SEARCH THRU THE MESSAGE FILE FOR THE TEST NUMBER AND KEY-CHAR.
2284	
2285		IF .TEST_NUM GTR .LAST_TEST_MSG
2286		THEN
2287		    BEGIN
2288		    LAST_TEST_MSG = FIND_NUM (.TEST_NUM, %C']');
2289	
2290		    IF .LAST_TEST_MSG EQL -1 THEN RETURN;
2291	
2292		    END;
2293	
2294	!NOW SEARCH THRU THE FILE FOR THE MESSAGE NUMBER AND KEY-CHAR.
2295	
2296		LAST_MSG_NUM = FIND_NUM (.MSG_NUM, %C'[');
2297	
2298		IF .LAST_MSG_NUM EQL -1 THEN RETURN;
2299	
2300	!READ ONE CHAR AT A TIME UNTIL THE START OF THE MESSAGE IS REACHED.
2301	
2302		DO
2303		    BEGIN
2304		    CH = GET_CHAR ();			!READ NEXT CHAR
2305	
2306		    IF .CH EQL -1			!DID WE REACH EOF?
2307		    THEN
2308			RETURN;				!YES, ABORT PRINTING
2309	
2310		    END
2311		UNTIL .CH EQL %C'!';			!UNTIL WE REACH START OF MESSAGE?
2312	
2313		TXT_BUF_PTR = POINT (TXT_BUF, 36, 7, 0, 0); !SETUP BYTE POINTER INTO BUFFER
2314	
2315	!NOW WE SHOULD BE AT THE BEGINNING OF THE ERROR MESSAGE.  READ ONE CHAR AT A
2316	!TIME AT PROCESS IT.
2317	
2318		DO
2319		    BEGIN
2320		    CH = GET_CHAR ();
2321	
2322		    SELECTONEU .CH OF
2323			SET
2324	
2325			[-1] :				!EOF WAS REACHED
2326			    RETURN;
2327	
2328			[%C'!'] :			!END OF MESSAGE MARKER
2329			    0;
2330	
2331			[%O'12'] :			!CAR-RET, GO PRINT MESSAGE LINE
2332			    BEGIN
2333			    REPLACEI (TXT_BUF_PTR, .CH); !PUT CR IN BUFFER
2334			    REPLACEI (TXT_BUF_PTR, 0);	!TERMINATE MSG LINE
2335			    PRINT_MSG (TXT_BUF);	!PRINT LINE
2336			    TXT_BUF_PTR = POINT (TXT_BUF, 36, 7, 0, 0); !REINIT BYTE PTR
2337			    END;
2338	
2339			[%C'\'] :			!SPECIAL PRINT KEY CHAR
2340			    BEGIN
2341			    REPLACEI (TXT_BUF_PTR, 0);	!TERMINATE CURRENT MSG LINE
2342			    PRINT_MSG (TXT_BUF);	!GO PRINT IT
2343			    TXT_BUF_PTR = POINT (TXT_BUF, 36, 7, 0, 0); !REINIT BYTE PTR
2344			    PRT_SPEC (.SPEC_PTR);	!GO DO SPECIAL PRINTING
2345			    END;
2346	
2347			[OTHERWISE] :			!PUT ALL OTHER CHARS INTO MSG LINE BUFFER
2348			    REPLACEI (TXT_BUF_PTR, .CH);
2349			TES;
2350	
2351		    END
2352		UNTIL .CH EQL %C'!';			!UNTIL WE REACH END OF MESSAGE
2353	
2354		END;
2355	
2356	    IF .DIGITS NEQ 0				!IF DIGITS IS NON-ZERO, THEN
2357	    THEN
2358		BEGIN
2359		PRINT_CA (.CORRECT, .ACTUAL, .DIGITS);	!PRINT CORRECT/ACTUAL
2360		LAST_ACTUAL = .ACTUAL;			!UPDATE LAST ACTUAL DATA
2361		END;
2362	
2363	    END;
2364	ROUTINE PRT_SPEC (PTR) : NOVALUE =
2365	
2366	!++
2367	! FUNCTIONAL DESCRIPTION:
2368	!
2369	!	THIS ROUTINE DOES THE SPECIAL PRINTING FOR ERROR MESSAGES.
2370	!	SPECIAL PRINTING IS WHEN THE PROGRAMMER WISHES TO INSERT A
2371	!	VARIABLE NUMBER OR TEXT STRING INTO THE ERROR MESSAGE.  THE
2372	!	FORMAT FOR DOING THIS IS THE RESERVED CHARACTER '\' FOLLOWED BY
2373	!	A PRINT MODE CHARACTER (O,D,S,U) FOLLOWED BY AN INDEX (0-9).
2374	!	UPON ENTERING THIS ROUTINE, THE '\' HAS ALREADY BEEN DETECTED
2375	!	BY THE 'ERR_RPT' ROUTINE.  THIS ROUTINE READS IN THE PRINT MODE
2376	!	CHARACTER AND INDEX.  IT THEN USES THE INDEX TO ACCESS A TABLE
2377	!	ENTRY IN THE TABLE POINTED TO BY THE PASSED PARAMETER.  THE
2378	!	ENTRY IS PROCESSED BASED ON THE PRINT MODE.
2379	!
2380	!	PRINT MODE	ACTION
2381	!	----------	------
2382	!	     O		PRINT TABLE ENTRY AS OCTAL NUMBER
2383	!	     D		PRINT TABLE ENTRY AS DECIMAL NUMBER
2384	!	     S		PRINT ASCIZ STRING POINTED TO BY TABLE ENTRY
2385	!	     U		PRINT TABLE ENTRY AS 12 UNSIGNED OCTAL DIGITS
2386	!
2387	! FORMAL PARAMETERS:
2388	!
2389	!	PTR		= POINTER TO A SPECIAL PRINT TABLE
2390	!
2391	! IMPLICIT INPUTS:
2392	!
2393	!	NONE
2394	!
2395	! IMPLICIT OUTPUTS:
2396	!
2397	!	NONE
2398	!
2399	! ROUTINE VALUE:
2400	!
2401	!	NONE
2402	!
2403	! SIDE EFFECTS:
2404	!
2405	!	PRINTS A SPECIAL NUMBER OR TEXT STRING AS PART OF AN ERROR
2406	!	MESSAGE OR PRINTS AN ERROR MESSAGE IF INVALID CHARACTERS ARE
2407	!	ENCOUNTERED.
2408	!
2409	!--
2410	    BEGIN
2411	
2412	    REGISTER
2413		AC0 = 0;
2414	
2415	    LOCAL
2416		PRINT_MODE,
2417		INDEX;
2418	
2419	    MAP
2420		PTR : REF VECTOR;
2421	
2422	    PRINT_MODE = GET_CHAR ();			!NEXT CHAR IN MESSAGE IS PRINT MODE
2423	    INDEX = GET_CHAR () - %O'60';		!GET NEXT MSG CHAR AND MAKE BINARY
2424	
2425	    IF (.INDEX LSS 0) OR (.INDEX GTR 9)		!INDEX MUST BE NUMERIC
2426	    THEN
2427		BEGIN
2428		PTSTNUM ();				!PRINT TEST NUMBER
2429		PTXT_CRLF ('SPECIAL PRINT NUMBER OUT OF RANGE');
2430		RETURN;
2431		END;
2432	
2433	    AC0 = .PTR [.INDEX];			!GET ENTRY FROM SPECIAL PRINT TABLE
2434	
2435	    SELECTONEU .PRINT_MODE OF			!PROCESS ENTRY BASED ON PRINT MODE
2436		SET
2437	
2438		[%C'O'] :
2439		    POCT_SUP (.AC0);			!PRINT OCTAL NUMBER
2440	
2441		[%C'D'] :
2442		    PRINT_DEC (.AC0);			!PRINT DECIMAL NUMBER
2443	
2444		[%C'S'] :
2445		    PRINT_MSG (.AC0);			!PRINT ASCIZ TEXT STRING
2446	
2447		[%C'U'] :
2448		    PRINT_OCT_12 (.AC0);		!PRINT 12 UNSIGNED OCTAL DIGITS
2449		[OTHERWISE]:
2450		    PTXT_CRLF ('INVALID SPECIAL PRINT MODE CHARACTER'); !PRINT ERROR MESSAGE
2451		TES;
2452	
2453	    END;
2454	ROUTINE GET_CHAR =
2455	
2456	!++
2457	! FUNCTIONAL DESCRIPTION:
2458	!
2459	!	THIS ROUTINE READS THE NEXT CHARACTER FROM THE ERROR MESSAGE
2460	!	FILE.  IT DOES SO BY MAKING AN LUUO CALL TO THE 'CSL' PROGRAM'S
2461	!	FILE READ ROUTINE.  IF THE END-OF-FILE IS REACHED, AN ERROR
2462	!	MESSAGE IS TYPED AND AN ERROR CODE IS RETURNED TO THE CALLING
2463	!	ROUTINE.
2464	!
2465	! FORMAL PARAMETERS:
2466	!
2467	!	NONE
2468	!
2469	! IMPLICIT INPUTS:
2470	!
2471	!	PAGE_IN		= FLAG INDICATING IF PAGE OF MESSAGE TEXT IS IN BUFFER
2472	!
2473	! IMPLICIT OUTPUTS:
2474	!
2475	!	NONE
2476	!
2477	! ROUTINE VALUE:
2478	!
2479	!	ASCII CHAR READ FROM MESSAGE FILE, OR
2480	!	-1 IF END-OF-FILE IS REACHED
2481	!
2482	! SIDE EFFECTS:
2483	!
2484	!	IF END-OF-FILE IS REACHED, A MESSAGE TO THAT EFFECT WILL BE PRINTED
2485	!--
2486	
2487	    BEGIN
2488	
2489	    REGISTER
2490		AC0 = 0;
2491	
2492	    BIND
2493		EOF_MSG = UPLIT(%ASCIZ '?EOF REACHED WHILE READING MSG FILE');
2494	
2495	    OWN
2496		CHAR_CNT,				!NUMBERS OF CHARS LEFT TO BE READ IN BUFFER
2497		CHAR_PTR;				!BYTE POINTER TO NEXT CHAR IN BUFFER
2498	
2499	    LOCAL
2500		CHAR;
2501	
2502	    IF .PAGE_IN EQL 0				!IF FLAG IS ZERO, WE NEED NEXT PAGE
2503	    THEN
2504	
2505		IF FRDPAG				!TRY TO READ NEXT PAGE
2506		THEN
2507	
2508	!IF THE PAGE WAS READ IN, FRDPAG RETURNS A 1 AND AC0 CONTAINS 'WORD CNT,,ADDRESS' OF BUFFER
2509	
2510		    BEGIN
2511		    CHAR_CNT = .AC0<18, 18>*5;		!COMPUTE CHAR COUNT
2512		    CHAR_PTR = POINT (.AC0<0, 18>, 36, 7, 0, 0);	!SETUP POINTER
2513		    PAGE_IN = 1;			!SET FLAG THAT PAGE IS IN BUFFER
2514		    END
2515		ELSE
2516	
2517	!IF END-OF-FILE WAS REACHED, FRDPAG RETURNS 0
2518	
2519		    BEGIN
2520		    PRINT_MSG(EOF_MSG);			!PRINT EOF MESSAGE
2521		    MSG_FILE_OPEN = 0;			!RESET FLAG SO NEXT ERROR WILL REOPEN MSG FILE
2522		    RETURN -1;				!GIVE ERROR RETURN
2523		    END;
2524	
2525	    CHAR = SCANI (CHAR_PTR);			!GET NEXT CHAR FROM BUFFER
2526	    CHAR_CNT = .CHAR_CNT - 1;			!DECREMENT # OF CHARS LEFT IN BUFFER
2527	
2528	    IF .CHAR_CNT EQL 0 THEN PAGE_IN = 0;	!RESET FLAG TO READ IN NEXT PAGE
2529	
2530	    IF .CHAR EQL 0				!IF CHAR IS NULL, IT'S EOF
2531	    THEN
2532		BEGIN
2533		PRINT_MSG(EOF_MSG);			!PRINT EOF MESSAGE
2534		MSG_FILE_OPEN = 0;			!RESET FLAG SO NEXT ERROR WILL REOPEN MSG FILE
2535		RETURN -1;				!GIVE ERROR RETURN
2536		END;
2537	
2538	    RETURN .CHAR;
2539	
2540	    END;
2541	ROUTINE FIND_NUM (SRCH_NUM, KEY_CHAR) =
2542	
2543	!++
2544	! FUNCTIONAL DESCRIPTION:
2545	!
2546	!	THIS ROUTINE SEARCHES THE ERROR MESSAGE FILE FOR THE FLAG
2547	!	ASSOCIATED WITH THE CURRENT TEST NUMBER.
2548	!	THIS FLAG IS OF THE FORM ']XXX' WHERE XXX IS A TEST NUMBER.
2549	!	THE FILE IS READ A CHARACTER AT A TIME UNTIL A ']' IS REACHED.
2550	!	THE SUCCEEDING CHARACTERS UP TO A 'CR' SHOULD ALL BE ASCII DIGITS.
2551	!	IF NOT, AN ERROR MESSAGE IS PRINTED.  THE ASCII DIGITS ARE
2552	!	INTERPRETED AS A DECIMAL NUMBER AND ARE CONVERTED TO A BINARY
2553	!	NUMBER. THIS COMPARED TO THE TEST NUMBER BEING EXECUTED.
2554	!	IF THERE IS A MATCH, THE NUMBER IS RETURNED.  OTHERWISE, THE
2555	!	SEARCH CONTINUES.
2556	!
2557	! FORMAL PARAMETERS:
2558	!
2559	!	NONE
2560	!
2561	! IMPLICIT INPUTS:
2562	!
2563	!	TEST_NUM	= NUMBER OF TEST BEING EXECUTED
2564	!
2565	! IMPLICIT OUTPUTS:
2566	!
2567	!	NONE
2568	!
2569	! ROUTINE VALUE:
2570	!
2571	!	IF TEST NUMBER FLAG IS FOUND, THE TEST NUMBER IS RETURNED.
2572	!	IF THE END-OF-FILE IS REACHED OR AN INVALID FLAG IS FOUND, THEN
2573	!		A -1 IS RETURNED.
2574	!	IF AN NON-DIGIT ASCII CHAR IS FOUND IN THE NUMBER FIELD, AN
2575	!		ERROR MESSAGE IS PRINTED AND A -1 IS RETURNED.
2576	!
2577	! SIDE EFFECTS:
2578	!
2579	!	NONE
2580	!--
2581	
2582	    BEGIN
2583	
2584	    REGISTER
2585		AC0 = 0;
2586	
2587	    LOCAL
2588		CH,					!CHAR FROM BUFFER
2589		NUM;					!NUMBER FROM TEST NUMBER FLAG
2590	
2591	    DO
2592		BEGIN
2593	
2594		DO
2595		    BEGIN
2596		    CH = GET_CHAR ();			!GET NEXT CHAR IN MSG FILE
2597		    IF .CH EQL -1			!CHECK IF EOF REACHED
2598		    THEN
2599			RETURN -1;
2600		    END
2601		WHILE .CH NEQ .KEY_CHAR;		!KEEP LOOKING TIL KEY IS FOUND
2602	
2603	!GET THE NUMBER FOLLOWING THE KEY CHAR
2604	
2605		NUM = 0;				!INIT NUMBER VALUE
2606	
2607		WHILE 1 DO
2608		    BEGIN
2609		    CH = GET_CHAR ();			!GET NEXT DIGIT
2610	
2611		    SELECTONEU .CH OF			!SEE WHAT IT IS
2612			SET
2613	
2614			[%O'60' TO %O'71'] :		!ASCII NUMBER
2615			    BEGIN
2616			    NUM = .NUM*10 + (.CH - %O'60'); !SHIFT CUM VALUE AND ADD NEW VALUE
2617			    END;
2618	
2619			[%O'15'] :
2620			    EXITLOOP;			!CR MARKS END OF NUMBER
2621	
2622			[-1] :				!-1 MEANS EOF
2623			    RETURN -1;
2624	
2625			[OTHERWISE] :			!ANYTHING ELSE IS INVALID
2626			    BEGIN
2627			    PTXT_CRLF ('?NON-DIGIT CHAR IN A # FIELD OF MSG FILE');
2628			    RETURN -1;
2629			    END;
2630			TES;
2631	
2632		    END
2633	
2634		END
2635	    WHILE .SRCH_NUM NEQ .NUM;			!KEEP LOOKING TIL DESIRED NUMBER IS FOUND
2636	
2637	    RETURN .NUM;
2638	    END;
2639	ROUTINE PRINT_CA (CORRECT, ACTUAL, DIGITS) : NOVALUE =
2640	
2641	!++
2642	! FUNCTIONAL DESCRIPTION:
2643	!
2644	!	THIS ROUTINE PRINTS THE CORRECT AND ACTUAL DATA ASSOCIATED
2645	!	WITH A FAILING TEST.  IT ALSO COMPUTES AND PRINTS THE
2646	!	DISCREPANCIES, CORRECT 'XOR' ACTUAL.
2647	!	THE DATA IS PRINTED IN OCTAL WITH THE NUMBER OF DIGITS
2648	!	DETERMINED BY THE PASSED PARAMETER 'DIGITS'. FOR THE CASE
2649	!	WHERE THE # OF DIGITS IS GREATER THAN 12 (THEREFORE, >36 BITS),
2650	!	THE CORRECT AND ACTUAL PARAMETERS ARE INTERPRETED AS MULTIWORD
2651	!	VECTORS.
2652	!
2653	! FORMAL PARAMETERS:
2654	!
2655	!	CORRECT		= CORRECT DATA
2656	!	ACTUAL		= ACTUAL DATA
2657	!	DIGITS		= # OF OCTAL DIGITS IN CORRECT AND ACTUAL
2658	!
2659	! IMPLICIT INPUTS:
2660	!
2661	!	NONE
2662	!
2663	! IMPLICIT OUTPUTS:
2664	!
2665	!	NONE
2666	!
2667	! ROUTINE VALUE:
2668	!
2669	!	NONE
2670	!
2671	! SIDE EFFECTS:
2672	!
2673	!	THE CORRECT, ACTUAL AND DISCREPANCY DATA ARE PRINTED ON THE TTY.
2674	!--
2675	
2676	    BEGIN
2677	
2678	    REGISTER
2679		AC0 = 0;
2680	
2681	    LOCAL
2682		DISCREP : VECTOR [4];			!BUFFER FOR DISCREPANCY DATA
2683	
2684	    PRINT_TXT ('CORRECT: ');
2685	
2686	    IF .DIGITS GTR 12				! >12 DIGITS NEEDS SPECIAL PRINTING
2687	    THEN
2688		PRT_GTR_12 (.CORRECT, .DIGITS)
2689	    ELSE
2690		PNUM (.CORRECT, .DIGITS);
2691	
2692	    PRINT_CRLF;
2693	    PRINT_TXT ('ACTUAL:  ');
2694	
2695	    IF .DIGITS GTR 12				! >12 DIGITS NEEDS SPECIAL PRINTING
2696	    THEN
2697		PRT_GTR_12 (.ACTUAL, .DIGITS)
2698	    ELSE
2699		PNUM (.ACTUAL, .DIGITS);
2700	
2701	    PRINT_CRLF;
2702	    PRINT_TXT ('DISCREP: ');
2703	
2704	    IF .DIGITS GTR 12				! >12 DIGITS REQUIRES SPECIAL TREATMENT
2705	    THEN
2706		BEGIN
2707	
2708		MAP
2709		    ACTUAL : REF VECTOR,
2710		    CORRECT : REF VECTOR;
2711	
2712	!COMPUTE DISCREPANCY DATA WORD BY WORD
2713		INCR I FROM 0 TO (.DIGITS + 11)/12 BY 1 DO
2714		    DISCREP [.I] = .ACTUAL [.I] XOR .CORRECT [.I];
2715	
2716		PRT_GTR_12 (DISCREP, .DIGITS);
2717		END
2718	    ELSE
2719		BEGIN
2720		DISCREP = .CORRECT XOR .ACTUAL;		!COMPUTE DISCREPANCIES
2721		PNUM (.DISCREP, .DIGITS);		!GO PRINT DISCREP VALUE
2722		END;
2723	
2724	    PRINT_CRLF;
2725	    END;
2726	ROUTINE PRT_GTR_12 (PTR, DIGITS) : NOVALUE =
2727	
2728	!++
2729	! FUNCTIONAL DESCRIPTION:
2730	!
2731	!	THIS ROUTINE PRINTS AN OCTAL NUMBER POINTED TO BY 'PTR' WITH
2732	!	'DIGITS' NUMBER OF DIGITS ( >12).
2733	!
2734	! FORMAL PARAMETERS:
2735	!
2736	!	PTR		= POINTER TO A VECTOR CONTAING THE NUMBER TO BE PRINTED
2737	!	DIGITS		= # OF OCTAL DIGITS TO BE PRINTED ( >12)
2738	!
2739	! IMPLICIT INPUTS:
2740	!
2741	!	NONE
2742	!
2743	! IMPLICIT OUTPUTS:
2744	!
2745	!	NONE
2746	!
2747	! ROUTINE VALUE:
2748	!
2749	!	NONE
2750	!
2751	! SIDE EFFECTS:
2752	!
2753	!	PRINTS AN OCTAL NUMBER ( > 12 DIGITS) ON THE TTY.
2754	!
2755	!--
2756	    BEGIN
2757	
2758	    MAP
2759		PTR : REF VECTOR;
2760	
2761	    LOCAL
2762		TEMP;
2763	
2764	    REGISTER
2765		AC0 = 0;
2766	
2767	!PRINT 12 DIGITS AT A TIME UNTIL NUMBER OF DIGITS REMAINING IS <12.
2768	
2769	    INCR I FROM 0 TO 3 BY 1 DO
2770		BEGIN
2771		PRINT_OCT_12 (.PTR [.I]);		!PRINT 12 DIGITS
2772		DIGITS = .DIGITS - 12;			!DECREMENT DIGIT COUNT
2773	
2774		IF .DIGITS LSS 12 THEN EXITLOOP (TEMP = .I + 1);
2775	
2776		END;
2777	
2778	    IF .DIGITS GTR 0				!IF THERE ARE ANY DIGITS LEFT
2779	    THEN
2780		PNUM (.PTR [.TEMP], .DIGITS);		!THEN PRINT THEM
2781	    END;
2782	ROUTINE PNUM (NUM, DIGITS) : NOVALUE =
2783	
2784	!++
2785	! FUNCTIONAL DESCRIPTION:
2786	!
2787	!	THIS ROUTINE PRINTS THE OCTAL NUMBER PASSED IN 'NUM'.
2788	!	'DIGITS' NUMBER OF OCTAL DIGITS ( <12) ARE PRINTED.
2789	!
2790	! FORMAL PARAMETERS:
2791	!
2792	!	NUM		= OCTAL NUMBER TO BE PRINTED
2793	!	DIGITS		= # OF OCTAL DIGITS ( <12) TO BE PRINTED
2794	!
2795	! IMPLICIT INPUTS:
2796	!
2797	!	NONE
2798	!
2799	! IMPLICIT OUTPUTS:
2800	!
2801	!	NONE
2802	!
2803	! ROUTINE VALUE:
2804	!
2805	!	NONE
2806	!
2807	! SIDE EFFECTS:
2808	!
2809	!	AN OCTAL NUMBER ( <12 DIGITS) IS PRINTED ON THE TTY.
2810	!
2811	!--
2812	    BEGIN
2813	
2814	    REGISTER
2815		AC0 = 0;
2816	
2817	!CALL THE APPROPRIATE 'CSL' UUO BASED ON THE # OF DIGITS TO PRINT
2818	
2819	    CASE .DIGITS FROM 1 TO 12 OF
2820		SET
2821	
2822		[1] :
2823		    PRINT_OCT_1 (.NUM);
2824	
2825		[2] :
2826		    PRINT_OCT_2 (.NUM);
2827	
2828		[3] :
2829		    PRINT_OCT_3 (.NUM);
2830	
2831		[4] :
2832		    PRINT_OCT_4 (.NUM);
2833	
2834		[5] :
2835		    PRINT_OCT_5 (.NUM);
2836	
2837		[6] :
2838		    PRINT_OCT_6 (.NUM);
2839	
2840		[7] :
2841		    PRINT_OCT_7 (.NUM);
2842	
2843		[8] :
2844		    PRINT_OCT_8 (.NUM);
2845	
2846		[11] :
2847		    PRINT_OCT_11 (.NUM);
2848	
2849		[12] :
2850		    PRINT_OCT_12 (.NUM);
2851	
2852		[INRANGE] :
2853		    PTXT_CRLF('INVALID NUMBER OF CORRECT/ACTUAL DIGITS');
2854		TES;
2855	
2856	    END;
2857	
2858	GLOBAL ROUTINE NOERR (INDEX) : NOVALUE =
2859	
2860	!++
2861	! FUNCTIONAL DESCRIPTION:
2862	!
2863	!	THIS ROUTINE IS CALLED WHEN A NO-ERROR CONDITION IS DETECTED
2864	!	IN A TEST.  IT PERFORMS FAULT ISOLATION BY UPDATING THE
2865	!	CUMULATIVE FAULTY NETWORK VECTOR.  SINCE NO ERROR WAS DETECTED,
2866	!	THE SET OF FAULTY NETWORKS WHICH WOULD HAVE CAUSED AN ERROR CAN
2867	!	BE ELIMINATED FROM CONSIDERATION AS POSSIBLE FAULTY NETWORKS.
2868	!	THIS IS DONE BY COMPLEMENTING THE FAULTY NETWORK VECTOR
2869	!	ASSOCIATED WITH THE CURRENT TEST AND ERROR NUMBER AND 'ANDING'
2870	!	THE RESULT WITH THE CUMULATIVE FAULTY NETWORK VECTOR.
2871	!	IF THE RESULTANT CUMULATIVE VECTOR WOULD BE ALL ZEROS, THEN
2872	!	A DISCREPANCY EXISTS.  A LIST OF POSSIBLE FAULTY NETWORKS IS
2873	!	PRINTED USING THE CUMULATIVE VECTOR BEFORE THE 'ANDING' AND THE
2874	!	TESTING IS ABORTED.
2875	!	IF WE ARE LOOPING ON AN ERROR OR ON A TEST OR IF THE 'NO ISOLA-
2876	!	TION FEATURE IS ACTIVATED, THERE IS NO NEED TO PERFORM THE
2877	!	ISOLATION.
2878	!
2879	! FORMAL PARAMETERS:
2880	!
2881	!	INDEX		= A NUMBER TO BE USED AS AN INDEX INTO THE
2882	!			  'NO ERROR' TABLE OF NETWORK VECTORS FOR THE
2883	!			  CURRENT TEST.
2884	!
2885	! IMPLICIT INPUTS:
2886	!
2887	!	TEST_NUM	= NUMBER OF TEST BEING EXECUTED
2888	!	LOOP_ON_TEST	= FLAG INDICATING LOOPING ON SPECIFIC TEST
2889	!	LOOPING		= FLAG INDICATING LOOPING ON ERROR
2890	!	NO_ISOLATION	= FLAG INDICATING THAT NO FAULT ISOLATION IS
2891	!			  TO BE PERFORMED.
2892	!	NES_TBL		= TABLE OF POINTERS TO 'NO ERROR' FAULT VECTORS
2893	!	NET_FAULTS	= CUMULATIVE FAULTY NETWORKS VECTOR
2894	!
2895	! IMPLICIT OUTPUTS:
2896	!
2897	!	NONE
2898	!
2899	! ROUTINE VALUE:
2900	!
2901	!	NONE
2902	!
2903	! SIDE EFFECTS:
2904	!
2905	!	THE CUMULATIVE FAULTY NETWORK VECTOR IS UPDATED OR IF A
2906	!	DISCREPANCY IS FOUND, AN ERROR MESSAGE IS PRINTED AND TESTING
2907	!	IS ABORTED.
2908	!--
2909	
2910	    BEGIN
2911	
2912	    LOCAL
2913		NZ_FLAG,				!FLAG TO INDICATING IF 'ANDING' RESULT IS NON-ZERO
2914		NES_PTR;				!POINTER TO FAULT VECTOR
2915	
2916	    OWN
2917		TEMP : VECTOR [10];			!TEMPORARY BUFFER
2918	
2919	    MAP
2920		NET_FAULTS : VECTOR,
2921		NES_PTR : REF VECTOR;
2922	
2923	!IF IT DOESN'T MAKE SENSE TO DO ISOLATION, JUST RETURN
2924	
2925	    IF (.LOOP_ON_TEST OR .LOOPING OR .NO_ISOLATION) NEQ 0 THEN RETURN;
2926	
2927	    NZ_FLAG = 0;				!INITIALIZE NON-ZERO FLAG
2928	    NES_PTR = .NES_TBL [.TEST_NUM - 1];		!GET POINTER TO TABLE OF POINTERS FOR THIS TEST
2929	    NES_PTR = .NES_PTR [.INDEX - 1];		!GET POINTER TO FAULTY NETWORKS VECTOR
2930	
2931	!'AND' CUMULATIVE VECTOR WITH 'NO ERROR' VECTOR.  KEEP TRACK OF WHETHER
2932	!RESULT IS ZERO OR NOT.
2933	
2934	    INCR I FROM 0 TO .NETWRDS - 1 BY 1 DO
2935		BEGIN
2936		TEMP [.I] = .NET_FAULTS [.I] AND ( NOT .NES_PTR [.I]);
2937		NZ_FLAG = .TEMP [.I] OR .NZ_FLAG;	!IF RESULT OF FAULT ISOLATION IS NON-ZERO, SET NZ_FLAG
2938		END;
2939	
2940	    IF .NZ_FLAG EQL 0				!IF RESULT WAS ZERO
2941	    THEN
2942		BEGIN
2943	
2944		REGISTER
2945		    AC0 = 0;
2946	
2947		PRINT_CRLF;
2948		PTXT_CRLF ('FAULT ISOLATION DISCREPANCY, TESTING BEING ABORTED');
2949		PRINT_CRLF;
2950		NET_RPT ();				!LIST FAULTY NETWORKS
2951		AC0 = -1;				!TELL 'CSL' WE HAD ERROR
2952		EOP_UUO;				!RETURN TO 'CSL'
2953		END
2954	    ELSE
2955	
2956	!IF RESULT WAS NOT ZERO, UPDATE CUMULATIVE VECTOR
2957	
2958		INCR I FROM 0 TO .NETWRDS - 1 BY 1 DO
2959		    NET_FAULTS [.I] = .TEMP [.I];
2960	
2961	    END;
2962	
2963	GLOBAL ROUTINE FAILURE (ERR_NUM) : NOVALUE =
2964	
2965	!++
2966	! FUNCTIONAL DESCRIPTION:
2967	!
2968	!	THIS ROUTINE IS CALLED BY THE ERROR HANDLING ROUTINES TO
2969	!	PERFORM FAULT ISOLATION.
2970	!	SINCE AN ERROR WAS DETECTED, THE FAULT WHICH CAUSED THE ERROR
2971	!	MUST BE CONTAINED IN THE FAULTY NETWORKS VECTOR FOR THE CURRENT
2972	!	TEST AND ERROR NUMBERS.  FROM PREVIOUS TESTS, WE ALSO KNOW THAT
2973	!	THE FAULT MUST BE CONTAINED IN THE CUMULATIVE FAULTY NETWORK
2974	!	VECTOR.  THEREFORE, THE FAULT MUST BE CONTAINED IN THAT SUBSET
2975	!	OF NETWORKS WHICH IS COMMON TO BOTH THE CUMULATIVE VECTOR AND
2976	!	THE TEST VECTOR.THIS SUBSET IS THE NEW CUMULATIVE FAULT VECTOR.
2977	!	THIS IS OBTAINED BY 'ANDING' THE CUMULATIVE VECTOR WITH THE
2978	!	VECTOR ASSOCIATED WITH THE CURRENT TEST AND ERROR NUMBERS.
2979	!	IF THE RESULTANT CUMULATIVE VECTOR WOULD BE ALL ZEROS, THEN
2980	!	A DISCREPANCY EXISTS.  A LIST OF POSSIBLE FAULTY NETWORKS IS
2981	!	PRINTED USING THE CUMULATIVE VECTOR BEFORE THE 'ANDING' AND THE
2982	!	TESTING IS ABORTED.
2983	!	IF WE ARE LOOPING ON AN ERROR OR ON A TEST OR IF THE 'NO ISOLA-
2984	!	TION FEATURE IS ACTIVATED, THERE IS NO NEED TO PERFORM THE
2985	!	ISOLATION.
2986	!
2987	! FORMAL PARAMETERS:
2988	!
2989	!	ERR_NUM		= A NUMBER TO BE USED AS AN INDEX INTO THE
2990	!			  'NO ERROR' TABLE OF NETWORK VECTORS FOR THE
2991	!			  CURRENT TEST.
2992	!
2993	! IMPLICIT INPUTS:
2994	!
2995	!	TEST_NUM	= NUMBER OF TEST BEING EXECUTED
2996	!	LOOP_ON_TEST	= FLAG INDICATING LOOPING ON SPECIFIC TEST
2997	!	LOOPING		= FLAG INDICATING LOOPING ON ERROR
2998	!	NO_ISOLATION	= FLAG INDICATING THAT NO FAULT ISOLATION IS
2999	!			  TO BE PERFORMED.
3000	!	ES_TBL		= TABLE OF POINTERS TO 'ERROR' FAULT VECTORS
3001	!	NET_FAULTS	= CUMULATIVE FAULTY NETWORKS VECTOR
3002	!
3003	! IMPLICIT OUTPUTS:
3004	!
3005	!	NONE
3006	!
3007	! ROUTINE VALUE:
3008	!
3009	!	NONE
3010	!
3011	! SIDE EFFECTS:
3012	!
3013	!	THE CUMULATIVE FAULTY NETWORK VECTOR IS UPDATED OR IF A
3014	!	DISCREPANCY IS FOUND, AN ERROR MESSAGE IS PRINTED AND TESTING
3015	!	IS ABORTED.
3016	!--
3017	
3018	    BEGIN
3019	
3020	    LOCAL
3021		NZ_FLAG,				!FLAG TO INDICATING IF 'ANDING' RESULT IS NON-ZERO
3022		TEMP : VECTOR [10],			!TEMPORARY BUFFER
3023		ES_PTR;				!POINTER TO FAULT VECTOR
3024	
3025	    MAP
3026		NET_FAULTS : VECTOR,
3027		ES_PTR : REF VECTOR;
3028	
3029	!IF IT DOESN'T MAKE SENSE TO DO ISOLATION, JUST RETURN
3030	
3031	    IF (.LOOP_ON_TEST OR .LOOPING OR .NO_ISOLATION) NEQ 0 THEN RETURN;
3032	
3033	    NZ_FLAG = 0;				!INITIALIZE NON-ZERO FLAG
3034	    ES_PTR = .ES_TBL [.TEST_NUM - 1];		!GET POINTER TO TABLE OF POINTERS FOR THIS TEST
3035	    ES_PTR = .ES_PTR [.ERR_NUM - 1];		!GET POINTER TO FAULT VECTOR
3036	
3037	!'AND' CUMULATIVE VECTOR WITH 'NO ERROR' VECTOR.  KEEP TRACK OF WHETHER
3038	!RESULT IS ZERO OR NOT.
3039	
3040	    INCR I FROM 0 TO .NETWRDS - 1 BY 1 DO
3041		BEGIN
3042		TEMP [.I] = .NET_FAULTS [.I] AND .ES_PTR [.I];
3043		NZ_FLAG = .TEMP [.I] OR .NZ_FLAG;	!IF RESULT OF FAULT ISOLATION IS NON-ZERO, SET NZ_FLAG
3044		END;
3045	
3046	    IF .NZ_FLAG EQL 0				!IF RESULT WAS ZERO
3047	    THEN
3048		BEGIN
3049	
3050		REGISTER
3051		    AC0 = 0;
3052	
3053		PRINT_CRLF;
3054		PTXT_CRLF ('FAULT ISOLATION DISCREPANCY, TESTING BEING ABORTED');
3055		PRINT_CRLF;
3056		NET_RPT ();				!LIST FAULTY NETWORKS
3057		AC0 = -1;				!TELL 'CSL' WE HAD ERROR
3058		EOP_UUO;				!RETURN TO 'CSL'
3059		END;
3060	
3061	!IF RESULT WAS NOT ZERO, UPDATE CUMULATIVE FAULTY VECTOR
3062	
3063	    INCR I FROM 0 TO .NETWRDS - 1 BY 1 DO
3064		    NET_FAULTS [.I] = .TEMP [.I];
3065	
3066	    END;
3067	
3068	GLOBAL ROUTINE LOOP_CHK (ERR_NUM) =
3069	
3070	!++
3071	! FUNCTIONAL DESCRIPTION:
3072	!
3073	!	THIS ROUTINE IS CALLED AFTER EVERY ERROR CHECK IN A TEST TO
3074	!	DETERMINE IF LOOPING SHOULD BE DONE.
3075	!	A 'LOOP' RETURN (1) WILL BE MADE FOR THE FOLLOWING CASES:
3076	!		1. THE FIRST ERROR IS DETECTED AND LOOP-ON-ERROR
3077	!		   IS ACTIVATED.
3078	!		2. WE ARE ALREADY LOOPING ON ERROR X AND WE REACH THE
3079	!		   THE POINT IN THE PROGRAM WHERE ERROR X IS CHECKED
3080	!		   FOR.  IN THIS CASE WE LOOP REGARDLESS OF WHETHER
3081	!		   ERROR X RECURS OR NOT.
3082	!		3. WE ARE ALREADY LOOPING ON AN ERROR WHEN AN ERROR IS
3083	!		   DETECTED AT AN EARLIER POINT IN THE TEST.  IN THIS
3084	!		   CASE, WE TIGHTEN THE ERROR LOOP AND BECOME LOOPING ON
3085	!		   THIS NEW ERROR.
3086	!
3087	! FORMAL PARAMETERS:
3088	!
3089	!	ERR_NUM		= NUMBER OF ERROR CHECK WITHIN CURRENT TEST
3090	!
3091	! IMPLICIT INPUTS:
3092	!
3093	!	ERRFLG		= FLAG INDICATING IF ERROR WAS DETECTED BY
3094	!			  LAST ERROR CHECK
3095	!	LOOP_ON_ERROR	= FEATURE FLAG FOR ENABLING LOOP ON ERROR
3096	!	LOOPING		= FLAG INDICATING PROGRAM IS PRESENTLY LOOPING
3097	!			  ON ERROR
3098	!	LOOP_ERR_NUM	= NUMBER OF ERROR BEING LOOPED UPON
3099	!
3100	! IMPLICIT OUTPUTS:
3101	!
3102	!	LOOPING		= SAME AS ABOVE
3103	!	LOOP_ERR_NUM	= SAME AS ABOVE
3104	!	ERRFLG		= SAME AS ABOVE
3105	!
3106	! ROUTINE VALUE:
3107	!
3108	!	0 IF CURRENT ERROR IS NOT TO BE LOOPED UPON
3109	!	1 IF CURRENT ERROR IS TO BE LOOPED UPON
3110	!
3111	! SIDE EFFECTS:
3112	!
3113	!	IF IT IS THE FIRST ERROR DETECTED AND LOOP-ON-ERROR IS SET,
3114	!	THEN A 'YOU ARE LOOPING ON THIS ERROR' MESSAGE IS PRINTED.
3115	!--
3116	
3117	    BEGIN
3118	
3119	    REGISTER
3120		AC0 = 0;
3121	
3122	    LOCAL
3123		ERR_FLAG;				!TEMP STORAGE FOR ERRFLG
3124	
3125	    ERR_FLAG = .ERRFLG;				!SAVE ERRFLG FOR LATER USE
3126	    ERRFLG = 0;					!RESET GLOBAL FLAG
3127	
3128	!IF LOOP-ON-ERROR IS NOT ACTIVATED, GIVE DON'T LOOP RETURN
3129	
3130	    IF .LOOP_ON_ERR EQL 0 THEN RETURN 0;
3131	
3132	    IF .LOOPING NEQ 0				!IF WE'RE ALREADY LOOPING THEN
3133	    THEN
3134	
3135		IF .LOOP_ERR_NUM EQL .ERR_NUM		!CHECK IF THIS IS THE ORIGINAL ERROR
3136		THEN
3137		    RETURN 1				!IF YES, GIVE 'DO LOOP' RETURN
3138		ELSE
3139	
3140		    IF .ERR_FLAG NEQ 0			!IF NOT, CHECK IF THIS IS A NEW ERROR
3141		    THEN
3142			BEGIN
3143			LOOP_ERR_NUM = .ERR_NUM;	!IF YES, SET NEW LOOP ERROR NUMBER
3144			PTXT_CRLF ('YOU ARE LOOPING ON THIS ERROR');
3145			RETURN 1;			!GIVE 'DO LOOP' RETURN
3146			END
3147		    ELSE
3148			RETURN 0;			!IF NOT, GIVE 'DON'T LOOP' RETURN
3149	
3150	!WE GET HERE IF WE'RE NOT ALREADY LOOPING
3151	
3152	    IF .ERR_FLAG NEQ 0				!DID WE JUST HAVE ERROR?
3153	    THEN
3154		BEGIN
3155		LOOPING = 1;				!IF YES, SET FLAG FOR LOOPING
3156		LOOP_ERR_NUM = .ERR_NUM;		!SAVE CURRENT ERROR NUMBER
3157		PTXT_CRLF ('YOU ARE LOOPING ON THIS ERROR');
3158		RETURN 1;				!GIVE 'DO LOOP' RETURN
3159		END;
3160	
3161	!IF WE GET THIS FAR, NO ERROR LOOPING IS REQUIRED
3162	    RETURN 0;
3163	
3164	    END;
3165	
3166	GLOBAL ROUTINE FLP_CHK (ERR_NUM, PTR) =
3167	
3168	!++
3169	! FUNCTIONAL DESCRIPTION:
3170	!
3171	!	THIS ROUTINE IS CALLED AFTER AN ERROR CHECK IN A TEST TO
3172	!	DETERMINE IF ERROR LOOPING SHOULD BE DONE - EITHER FAST OR
3173	!	NORMAL.
3174	!	IF THE 'FAST LOOPING' FEATURE IS NOT ACTIVATED, CONTROL IS
3175	!	TRANSFERRED TO THE 'LOOP_CHK' ROUTINE.  IF THE FEATURE IS
3176	!	ACTIVATED AND AN ERROR WAS DETECTED, THEN THE COMMAND LINE
3177	!	POINTED TO BY THE PASSED PARAMETER IS SENT TO THE 8080 FRONT
3178	!	END.  THIS COMMAND LINE WILL END WITH AN 'RP' COMMAND AND WILL
3179	!	IMPLEMENT A ERROR LOOP UNDER CONTROL OF 8080.  THIS MAKES FOR
3180	!	A MUCH TIGHTER SCOPE LOOP THAN IS POSSIBLE WITH NORMAL ERROR
3181	!	LOOPING UNDER CONTROL OF THE REMOTE HOST.  HOWEVER, SINCE
3182	!	SENDING A COMMAND LINE WHICH ENDS IN 'RP' CAUSES THE 8080 TO
3183	!	BE HUNG AS FAR AS THE HOST IS CONCERNED, A DETAILED EXPLANATION
3184	!	OF THE PROCEDURE REQUIRED TO RESUME TESTING IS PRINTED ON THE
3185	!	TTY.
3186	!
3187	! FORMAL PARAMETERS:
3188	!
3189	!	ERR_NUM		= NUMBER OF ERROR CHECK WITHIN TEST
3190	!	PTR		= POINTER TO ASCIZ COMMAND LINE
3191	!
3192	! IMPLICIT INPUTS:
3193	!
3194	!	FAST_LOOP	= FEATURE FLAG INDICATING FAST ERROR LOOPING ACTIVATED
3195	!	ERRFLG		= FLAG INDICATING THAT AN ERROR WAS DETECTED
3196	!
3197	! IMPLICIT OUTPUTS:
3198	!
3199	!	NONE
3200	!
3201	! ROUTINE VALUE:
3202	!
3203	!	IF 'FAST_LOOP' IS NOT ACTIVATED, THE VALUE RETURNED IS THAT
3204	!	RETURNED BY 'LOOP_CHK' ROUTINE.  IF IT IS ACTIVATED, BUT NO
3205	!	ERROR WAS DETECTED, A ZERO IS RETURNED.
3206	!
3207	! SIDE EFFECTS:
3208	!
3209	!	IF FAST LOOPING IS REQUIRED, A COMMAND LINE IS SENT TO THE 8080
3210	!	AND A STEP-BY-STEP RESTART PROCEDURE IS PRINTED ON THE TTY.
3211	!
3212	!--
3213	    BEGIN
3214	
3215	    REGISTER
3216		AC0 = 0;
3217	
3218	    IF .FAST_LOOP EQL 0 THEN RETURN LOOP_CHK (.ERR_NUM);
3219	
3220	    IF .ERRFLG NEQ 0
3221	    THEN
3222		BEGIN
3223		ERRFLG = 0;
3224		PRINT_CRLF;
3225		PRINT_TXT ('YOU ARE FAST LOOPING ON TEST #');
3226		PRINT_DEC (.TEST_NUM);
3227		PRINT_TXT (' ERROR #');
3228		PRINT_DEC (.ERR_NUM);
3229		PRINT_CRLF;
3230		PTXT_CRLF ('THE 8080 COMMAND LINE BEING EXECUTED IS:');
3231		PRINT_MSG (.PTR);
3232		PRINT_CRLF;
3233		PRINT_CRLF;
3234		PTXT_CRLF ('TO ABORT DO THE FOLLOWING:');
3235		PTXT_CRLF ('   PRESS RESET SWITCH, TYPE "MM", TYPE A CONTROL-C,');
3236		PTXT_CRLF ('   TYPE "QUIT", THEN TYPE "ST"');
3237		SEND_LINE (.PTR, -1);
3238		END;
3239	
3240	    0					!TO AVOID INFO MESSAGE WHEN COMPILING
3241	    END;
3242	
3243	GLOBAL ROUTINE CHK_ERR_MSG (MSG_PTR) : NOVALUE =
3244	
3245	!++
3246	! FUNCTIONAL DESCRIPTION:
3247	!
3248	!	THIS ROUTINE CHECKS FOR A SPECIFIED 8080 ERROR MESSAGE WHICH
3249	!	MAY BE PENDING IN 'CSL' INPUT BUFFER.
3250	!	IF THE 8080 DETECTS AN ERROR WHILE IT IS IN ITS IDLE LOOP
3251	!	(I. E., NOT EXECUTING ANY COMMAND), IT WILL SEND THE APPROP-
3252	!	RIATE ERROR MESSAGE TO THE HOST.  SINCE THE 'CSL' IS NOT
3253	!	EXPECTING A RESPONSE AT THAT TIME, THE MESSAGE WILL REMAIN IN
3254	!	THE INPUT BUFFER.  IT SOME CASES, A TEST WILL STIMULATE THE
3255	!	HARDWARE SUCH THAT ONE OF THESE ASYNCHRONOUS ERROR MESSAGES
3256	!	WILL OCCUR.  THIS ROUTINE PROVIDES THE ABILITY TO CHECK FOR
3257	!	THE MESSAGE AND FLUSH IT.  IF A MESSAGE IS FOUND BUT IT IS NOT
3258	!	THE EXPECTED ONE, AN ERROR MESSAGE WILL BE PRINTED ON THE TTY
3259	!	IF THE FLAG IS SET TO DO SO.
3260	!
3261	! FORMAL PARAMETERS:
3262	!
3263	!	MSG_PTR		= A POINTER TO THE ASCIZ STRING OF THE
3264	!			  EXPECTED ERROR MESSAGE
3265	!
3266	! IMPLICIT INPUTS:
3267	!
3268	!	RPT_ERR_FLAG	= FLAG INDICATING WHETHER OR NOT ERRORS SHOULD
3269	!			  BE PRINTED ON THE TTY.
3270	!
3271	! IMPLICIT OUTPUTS:
3272	!
3273	!	NONE
3274	!
3275	! ROUTINE VALUE:
3276	!
3277	!	NONE
3278	!
3279	! SIDE EFFECTS:
3280	!
3281	!	ANY ERROR MESSAGE PENDING IN 'CSL' INPUT BUFFER WILL BE FLUSHED.
3282	!	ALSO, IF A UNEXPECTED ERROR MESSAGE IS FOUND AND THE FLAG IS
3283	!	SET TO REPORT ERRORS, A MESSAGE IS PRINTED ON THE TTY.
3284	!
3285	!--
3286	    BEGIN
3287	
3288	    REGISTER
3289		AC0 = 0;
3290	
3291	    LOCAL
3292		CHR,					!STORAGE FOR MESSAGE CHAR
3293		MSG_BUF_PTR,				!BYTE POINTER TO EXPECTED MESSAGE
3294		BUF_PTR,				!BYTE POINTER TO ACTUAL ERROR MESSAGE
3295		SAV_PTR;				!PLACE TO SAVE ACTUAL POINTER
3296	
3297	    WAIT (%O'400000');				!GIVE ERROR MESSAGE TIME TO GET HERE
3298	    MSG_CHK_UUO;				!CHECK WITH 'CSL' FOR ERROR MSG
3299	    BUF_PTR = .AC0;				!GET RESULTS
3300	
3301	    IF .BUF_PTR NEQ 0				!IF AC0 ISN'T 0 THEN IT'S A PTR
3302	    THEN
3303		BEGIN
3304		SAV_PTR = .BUF_PTR;			!SAVE POINTER TO START OF MESSAGE
3305		MSG_BUF_PTR = POINT (MSG_PTR, 36, 7, 0, 0);
3306	
3307	!COMPARE MESSAGE WHICH 'CSL' FOUND WITH THAT WHICH IS EXPECTED (PASSED
3308	!THROUGH POINTER 'MSG_PTR').
3309	
3310		WHILE (CHR = SCANI (MSG_BUF_PTR)) NEQ 0 DO
3311	
3312		    IF .CHR NEQ SCANI (BUF_PTR)		!CHECK IF MSG CHAR IS CORRECT
3313		    THEN
3314	
3315			IF .RPT_ERR_FLAG NEQ 0
3316			THEN
3317			    PRT_ERR (.SAV_PTR)		!GO REPORT UNEXPECTED ERROR
3318			ELSE
3319			    RETURN;
3320	
3321		END;
3322	
3323	    END;
3324	
3325	GLOBAL ROUTINE WAIT (LOOP_CNT) : NOVALUE =
3326	
3327	!++
3328	! FUNCTIONAL DESCRIPTION:
3329	!
3330	!	THIS ROUTINE WAITS FOR A SPECIFIED NUMBER OF LOOP COUNTS.
3331	!	IT IS NOT INTENDED TO GIVE ANY PRECISE TIMING, JUST A GROSS
3332	!	WAIT INTERVAL.
3333	!
3334	! FORMAL PARAMETERS:
3335	!
3336	!	LOOP_CNT	= NUMBER OF TIMES TO EXECUTE WAIT LOOP
3337	!
3338	! IMPLICIT INPUTS:
3339	!
3340	!	NONE
3341	!
3342	! IMPLICIT OUTPUTS:
3343	!
3344	!	NONE
3345	!
3346	! ROUTINE VALUE:
3347	!
3348	!	NONE
3349	!
3350	! SIDE EFFECTS:
3351	!
3352	!	NONE
3353	!
3354	!--
3355	    BEGIN
3356	
3357	    INCR I FROM 0 TO .LOOP_CNT BY 1 DO
3358		BEGIN
3359		0					!TO AVOID INFO MESSAGE WHEN COMPILING
3360		END;
3361	
3362	    END;
3363	
3364	ROUTINE PRT_ERR (MSG_PTR) : NOVALUE =
3365	
3366	!++
3367	! FUNCTIONAL DESCRIPTION:
3368	!
3369	!	THIS ROUTINE IS CALLED TO PRINT AN ERROR MESSAGE WHEN AN
3370	!	UNEXPECTED ERROR RESPONSE IS RECEIVED FROM THE 8080.  AFTER
3371	!	THE ERROR MESSAGE IS PRINTED, TESTING IS ABORTED WITH A RETURN
3372	!	TO THE 'CSL' PROGRAM.
3373	!	SINCE THE ERROR MESSAGE WHICH IS PASSED AS A PARAMETER MAY NOT
3374	!	BEGIN ON AN WORD BOUNDARY, IT MUST BE TRANSFERRED INTO A PRINT
3375	!	BUFFER BEFORE IT CAN BE PRINTED.
3376	!
3377	! FORMAL PARAMETERS:
3378	!
3379	!	MSG_PTR		= BYTE POINTER TO ERROR MESSAGE
3380	!
3381	! IMPLICIT INPUTS:
3382	!
3383	!	NONE
3384	!
3385	! IMPLICIT OUTPUTS:
3386	!
3387	!	NONE
3388	!
3389	! COMPLETION CODES:
3390	!
3391	!	-1 IS RETURNED IN AC0.  THIS TELLS 'CSL' WE HAD AN ERROR.
3392	!
3393	! SIDE EFFECTS:
3394	!
3395	!	AN ERROR MESSAGE IS PRINTED ON THE TTY AND TESTING IS ABORTED.
3396	!
3397	!--
3398	    BEGIN
3399	
3400	    LOCAL
3401		BUF_PTR,				!BYTE POINTER FOR PRINT BUFFER
3402		CHR;					!CHARACTER STORAGE
3403	
3404	    OWN
3405		MSG_BUF : VECTOR [5];			!PRINT BUFFER
3406	
3407	    REGISTER
3408		AC0 = 0;
3409	
3410	    BUF_PTR = POINT (MSG_BUF, 36, 7, 0, 0);	!INIT BUFFER POINTER
3411	
3412	    DO
3413		BEGIN
3414		CHR = SCANI (MSG_PTR);			!GET NEXT CHAR OF MESSAGE
3415		REPLACEI (BUF_PTR, .CHR);		!MOVE IT INTO PRINT BUFFER
3416		END
3417	    WHILE .CHR NEQ 0;				!CONTINUE UNTIL END OF MESSAGE
3418	
3419	    PRT_CRLF_F;
3420	    PRT_TXT_F ('UNEXPECTED ERROR RESPONSE RECEIVED FROM 8080 DURING ');
3421	    PTSTNUM ();					!PRINT TEST NUMBER
3422	    PRINT_MSG (MSG_BUF);			!GO PRINT MESSAGE
3423	    PTXT_CRLF_F ('THE LAST COMMAND LINE SENT TO THE 8080 WAS:');
3424	    PRT_MSG_F (LINE_BUF);
3425	    PRT_CRLF_F;
3426	    PTXT_CRLF_F ('TESTING BEING ABORTED');
3427	    AC0 = -1;					!TELL 'CSL' WE HAD ERROR
3428	    EOP_UUO;					!RETURN TO 'CSL'
3429	    END;
3430	
3431	GLOBAL ROUTINE SEND_LINE (CMD_BUF, FORCE_SEND) =
3432	
3433	!++
3434	! FUNCTIONAL DESCRIPTION:
3435	!
3436	!	THIS ROUTINE CONCATENATES 8080 COMMANDS TOGETHER ON A SINGLE
3437	!	LINE AND SENDS THAT LINE TO THE 8080 BY PASSING IT TO THE 'CSL'
3438	!	PROGRAM VIA A LUUO.
3439	!	THE INPUT TO THIS ROUTINE IS AN ASCII COMMAND STRING AND A
3440	!	'FORCE-SEND' FLAG.  IF CONCATENATING THE COMMAND STRING ONTO
3441	!	THE CUMULATIVE COMMAND LINE WILL CAUSE IT TO EXCEED 79 CHARS
3442	!	(THE 8080 LIMITATION), THEN THE CUMULATIVE COMMAND LINE IS
3443	!	SENT AND THE COMMAND STRING IS USED TO START A NEW COMMAND LINE.
3444	!	IF THE 'FORCE_SEND' FLAG IS NON-ZERO, THEN AFTER THE COMMAND
3445	!	STRING IS CONCATENATED THE CUMULATIVE COMMAND LINE IS SENT.
3446	!	THE 'FORCE_SEND' FLAG ALSO INDICATES THE TYPE OF COMMAND STRING
3447	!	AND THEREFORE THE TYPE OF LUUO TO BE USED WHEN SENDING THE
3448	!	COMMAND LINE.  IT IS NECESSARY THAT 'CSL' KNOWS WHICH FORM OF
3449	!	RESPONSE WILL BE COMING FROM THE 8080 AS A RESULT OF SENDING IT
3450	!	THE COMMAND LINE.
3451	!	IF 'CSL' RETURNS AC0 = -1, THEN THE 8080 TIMED OUT IN RESPONSE
3452	!	TO THE COMMAND LINE.  IF IT RETURNS AC0 = BYTE POINTER, THEN
3453	!	THE 8080 RESPONDED WITH AN ERROR MESSAGE WHICH IS POINTED TO BY
3454	!	THE BYTE POINTER.
3455	!
3456	! FORMAL PARAMETERS:
3457	!
3458	!	CMD_BUF		= ADDRESS OF COMMAND STRING
3459	!	FORCE_SEND	= FLAG INDICATING THAT THE COMMAND STRING MUST
3460	!			  BE SENT.  IT ALSO DICTATES THE AC FIELD OF
3461	!			  LUUO TO BE USED.
3462	! IMPLICIT INPUTS:
3463	!
3464	!	RPT_ERR_FLAG	= FLAG INDICATING WHETHER OR NOT 8080 ERRORS
3465	!			  SHOULD BE REPORTED.
3466	!
3467	! IMPLICIT OUTPUTS:
3468	!
3469	!	NONE
3470	!
3471	! ROUTINE VALUE:
3472	!
3473	!	0 IF NO COMMAND LINE IS SENT.
3474	!	POINTER TO RESPONSE IF COMMAND LINE WAS SENT.
3475	!
3476	! SIDE EFFECTS:
3477	!
3478	!	A ASCII COMMAND LINE MAY BE SENT TO THE 8080 THROUGH THE
3479	!	'CSL' PROGRAM.
3480	!--
3481	
3482	    BEGIN
3483	
3484	    REGISTER
3485		AC0 = 0;
3486	
3487	    LOCAL
3488		CMD_BUF_PTR,				!BYTE POINTER TO COMMAND STRING
3489		CMD_CHARS;				!# OF CHARS IN COMMAND STRING
3490	
3491	    OWN
3492		LINE_BUF_PTR;				!BYTE POINTER TO COMMAND LINE
3493	
3494	!COMPUTE THE NUMBER OF CHARACTERS IN THE COMMAND
3495	    TIMOUT = 0;					!RESET TIME OUT FLAG
3496	    CMD_CHARS = 0;
3497	    CMD_BUF_PTR = POINT (.CMD_BUF, 36, 7, 0, 0);	!INITIALIZE BYTE POINTER
3498	
3499	    WHILE SCANI (CMD_BUF_PTR) NEQ 0		!AS LONG AS NEXT COMMAND CHAR IS NONZERO
3500	    DO
3501		CMD_CHARS = .CMD_CHARS + 1;		!INCREMENT THE CHARACTER COUNT
3502	
3503	!IF THIS COMMAND WILL NOT FIT ON THE CURRENT COMMAND LINE (WILL CAUSE
3504	!LINE TO EXCEED 79 CHARS), THEN SEND THE CURRENT COMMAND LINE AND RESET
3505	!PARAMETERS TO START A NEW LINE WITH THE NEW COMMAND
3506	
3507	    IF (.CMD_CHARS + .LINE_CHARS) GTR 78
3508	    THEN
3509		BEGIN
3510		REPLACEI (LINE_BUF_PTR, 0);		!TERMINATE COMMAND LINE
3511		AC0 = LINE_BUF;
3512		SEND_CMD_LINE;
3513	!IF 'CSL' RETURNS AC0 = -1 THEN THE 8080 TIMED OUT. GO PRINT THE TEST
3514	!NUMBER AND THE LAST CMD LINE SENT.
3515	
3516		IF .AC0 EQL -1 THEN TIMED_OUT ();
3517	
3518	!IF 'CSL' RETURNS LH OF AC0 NON-ZERO, THEN IT CONTAINS A POINTER TO AN
3519	!ERROR MESSAGE WHICH WAS RECEIVED FROM THE 8080.  IF REPORTING ERRORS
3520	!IS TURNED ON, THEN GO REPORT IT AND ABORT.
3521	
3522		IF (.AC0<18, 18> NEQ 0) AND (.RPT_ERR_FLAG NEQ 0) THEN PRT_ERR (.AC0);
3523	
3524		LINE_CHARS = 0;
3525		END;
3526	
3527	!IF THIS IS THE FIRST COMMAND ON THE LINE INIT THE LINE BUFFER POINTER
3528	
3529	    IF .LINE_CHARS EQL 0
3530	    THEN
3531		BEGIN
3532	
3533		IF .CMD_CHARS EQL 0			!IF THIS COMMAND IS A NULL CMD
3534		THEN
3535		    RETURN 0;				!THEN THERE'S NOTHING TO DO
3536	
3537	
3538		LINE_BUF_PTR = POINT (LINE_BUF, 36, 7, 0, 0);	!RESET BYTE POINTER
3539		END;
3540	
3541	!IF THI SCOMMAND STRING ISN'T A NULL, CONCATENATE IT TO THE CUMULATIVE
3542	!COMMAND LINE.
3543	
3544	    IF .CMD_CHARS GTR 0
3545	    THEN
3546		BEGIN
3547	
3548		IF .LINE_CHARS NEQ 0			!IF THIS IS NOT THE FIRST COMMAND
3549		THEN 					!THEN
3550		    BEGIN
3551		    REPLACEI (LINE_BUF_PTR, %C',');	!INSERT A COMMA
3552		    LINE_CHARS = .LINE_CHARS + 1;	!INCREMENT LINE CHAR CNT
3553		    END;
3554	
3555		CMD_BUF_PTR = POINT (.CMD_BUF, 36, 7, 0, 0);	!INITIALIZE BYTE POINTER
3556	
3557		INCR I FROM 1 TO .CMD_CHARS		!MOVE CMD CHARS INTO BUFFER
3558		    DO
3559		    BEGIN
3560		    COPYII (CMD_BUF_PTR, LINE_BUF_PTR);	!COPY CMD CHAR INTO LINE BUFFER
3561		    LINE_CHARS = .LINE_CHARS + 1;	!INCREMENT COMMAND CHAR COUNT
3562		    END;
3563	
3564		END;
3565	
3566	!IF 'FORCE_SEND' FLAG IS ZERO, DON'T SEND THE COMMAND LINE.  OTHERWISE,
3567	!SEND IT BASED ON THE VALUE OF THE FLAG.
3568	
3569	    IF .FORCE_SEND EQL 0
3570	    THEN
3571		RETURN 0
3572	    ELSE
3573		BEGIN
3574		REPLACEI (LINE_BUF_PTR, 0);		!TERMINATE COMMAND
3575		AC0 = LINE_BUF;
3576	
3577		IF .FORCE_SEND EQL -1
3578		THEN
3579		    SEND_CMD_LINE
3580		ELSE
3581	
3582		    CASE .FORCE_SEND FROM 1 TO 10 OF
3583			SET
3584	
3585			[1] :
3586			    SEND_ER_LINE;		!LAST COMMAND IS 'ER'
3587	
3588			[2] :
3589			    SEND_EI_LINE;		!LAST COMMAND IS 'EI'
3590	
3591			[3] :
3592			    SEND_EJ_LINE;		!LAST COMMAND IS 'EJ'
3593	
3594			[4] :
3595			    SEND_EK_LINE;		!LAST COMMAND IS 'EK'
3596	
3597			[5] :
3598			    SEND_EB_LINE;		!LAST COMMAND IS 'EB'
3599	
3600			[6] :
3601			    SEND_EC_LINE;		!LAST COMMAND IS 'EC'
3602	
3603			[7] :
3604			    SEND_EM_LINE;		!LAST COMMAND IS 'EM'
3605	
3606			[8] :
3607			    SEND_PM_LINE;		!LAST COMMAND IS 'PM'
3608	
3609			[9] :
3610			    SEND_X1A_LINE;		!LAST COMMAND IS 'X1'
3611	
3612			[10] :
3613			    SEND_X1B_LINE;		!LAST COMMAND IS 'X1'
3614			TES;
3615	
3616		LINE_CHARS = 0;				!REINIT CHAR COUNT
3617	!IF 'CSL' RETURNS AC0 = -1 THEN THE 8080 TIMED OUT. GO PRINT THE TEST
3618	!NUMBER AND THE LAST CMD LINE SENT.
3619	
3620		IF .AC0 EQL -1 THEN TIMED_OUT ();
3621	
3622	!IF 'CSL' RETURNS LH OF AC0 NON-ZERO, THEN IT CONTAINS A POINTER TO AN
3623	!ERROR MESSAGE WHICH WAS RECEIVED FROM THE 8080.  IF REPORTING ERRORS
3624	!IS TURNED ON, THEN GO REPORT IT AND ABORT.
3625	
3626		IF (.AC0<18, 18> NEQ 0) AND (.RPT_ERR_FLAG NEQ 0) THEN PRT_ERR (.AC0);
3627	
3628		RETURN .AC0;				!RETURN THE 8080 RESPONSE
3629		END;
3630	
3631	    0					!TO AVOID INFO MESSAGE WHEN COMPILING
3632	    END;
3633	
3634	ROUTINE TIMED_OUT : NOVALUE =
3635	
3636	!++
3637	! FUNCTIONAL DESCRIPTION:
3638	!
3639	!	THIS ROUTINE IS CALLED WHEN THE 8080 TIMES OUT IN RESPONSE TO
3640	!	A COMMAND LINE.  IT PRINTS A MESSAGE TO THAT EFFECT AND PRINTS
3641	!	THE COMMAND LINE WHICH WAS SENT.  IT ALSO SETS THE GLOBAL FLAG
3642	!	'TIMOUT' TO NOTIFY ANY CONCERNED TEST ROUTINES THAT THIS OCCURRED.
3643	!
3644	! FORMAL PARAMETERS:
3645	!
3646	!	NONE
3647	!
3648	! IMPLICIT INPUTS:
3649	!
3650	!	LINE_BUF	= ADDRESS OF LAST COMMAND LINE SENT
3651	!
3652	! IMPLICIT OUTPUTS:
3653	!
3654	!	TIMOUT		= FLAG INDICATING THAT A TIME OUT OCCURRED
3655	!
3656	! ROUTINE VALUE:
3657	!
3658	!	NONE
3659	!
3660	! SIDE EFFECTS:
3661	!
3662	!	AN ERROR MESSAGE IS PRINTED ON THE TTY.
3663	!
3664	!--
3665	    BEGIN
3666	
3667	    REGISTER
3668		AC0 = 0;
3669	
3670	    PRT_CRLF_F;
3671	    PRT_TXT_F ('8080 TIMED OUT DURING ');
3672	    PTSTNUM ();					!PRINT THE CURRENT TEST NUMBER
3673	    PTXT_CRLF_F ('THE LAST COMMAND LINE SENT TO THE 8080 WAS:');
3674	    PRT_MSG_F (LINE_BUF);			!PRINT THE LAST CMD LINE SENT
3675	    PRT_CRLF_F;
3676	    TIMOUT = -1;				!SET TIMED OUT FLAG
3677	    END;
3678	
3679	GLOBAL ROUTINE REPEAT (RPT_CNT) : NOVALUE =
3680	
3681	!++
3682	! FUNCTIONAL DESCRIPTION:
3683	!
3684	!	THIS ROUTINE CREATES AND SENDS A 'RP XXX' (REPEAT) COMMAND.
3685	!	THE REPEAT COUNT IS PASSED AS A PARAMETER AND IS CONVERTED
3686	!	INTO AN ASCII NUMBER WHICH BECOMES THE REPEAT FIELD OF THE
3687	!	'RP' COMMAND.
3688	!
3689	! FORMAL PARAMETERS:
3690	!
3691	!	RPT_CNT		= REPEAT COUNT
3692	!
3693	! IMPLICIT INPUTS:
3694	!
3695	!	NONE
3696	!	
3697	! IMPLICIT OUTPUTS:
3698	!
3699	!	NONE
3700	!
3701	! ROUTINE VALUE:
3702	!
3703	!	NONE
3704	!
3705	! SIDE EFFECTS:
3706	!
3707	!	PASSES 'RP' COMMAND TO THE 'SEND_LINE' ROUTINE, WHERE IT GETS
3708	!	CONCATENATED ONTO A COMMAND LINE AND SENT TO THE 8080.
3709	!	IF THE RPT_CNT PARAMETER IS OUT OF RANGE, AN ERROR MESSAGE IS
3710	!	PRINTED.
3711	!--
3712	
3713	    BEGIN
3714	
3715	    BIND
3716		RPT_CMD = UPLIT (%ASCIZ'RP   ');	!RP CMD SKELETON
3717	
3718	    LOCAL
3719		BUF_PTR;				!BYTE POINTER TO RP CMD STRING
3720	
3721	    REGISTER
3722		AC0 = 0;
3723	
3724	    IF (.RPT_CNT LEQ 0) OR (.RPT_CNT GTR %O'376')	!IF REPEAT COUNT IS OUT OF RANGE
3725	    THEN 					!REPORT AS ERROR
3726		BEGIN
3727		PTSTNUM ();				!PRINT TEST NUMBER
3728		PTXT_CRLF ('CALL TO REPEAT ROUTINE HAS OUT OF RANGE COUNT');
3729		END;
3730	
3731	    BUF_PTR = POINT (RPT_CMD, 22, 7, 0, 0);	!SET BYTE POINTER TO FIRST CHAR AFTER 'RP '
3732	    BUF_PTR = INSERT_NUM (.BUF_PTR, .RPT_CNT, 3);	!INSERT COUNT FIELD IN CMD
3733	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
3734	    SEND_LINE (RPT_CMD, -1);
3735	    END;
3736	
3737	GLOBAL ROUTINE PTSTNUM : NOVALUE =
3738	
3739	!++
3740	! FUNCTIONAL DESCRIPTION:
3741	!
3742	!	THIS ROUTINE PRINTS THE NUMBER OF THE TEST BEING EXECUTED.
3743	!
3744	! FORMAL PARAMETERS:
3745	!
3746	!	NONE
3747	!
3748	! IMPLICIT INPUTS:
3749	!
3750	!	TEST_NUM	= NUMBER OF TEST BEING EXECUTED
3751	!
3752	! IMPLICIT OUTPUTS:
3753	!
3754	!	NONE
3755	!
3756	! ROUTINE VALUE:
3757	!
3758	!	NONE
3759	!
3760	! SIDE EFFECTS:
3761	!
3762	!	PRINTS TEST NUMBER ON THE TTY.
3763	!
3764	!--
3765	    BEGIN
3766	
3767	    REGISTER
3768		AC0 = 0;
3769	
3770	    PRINT_TXT ('TEST #');
3771	    PRINT_DEC (.TEST_NUM);
3772	    PRINT_CRLF;
3773	    END;
3774	
3775	GLOBAL ROUTINE CP (N) : NOVALUE =
3776	
3777	!++
3778	! FUNCTIONAL DESCRIPTION:
3779	!
3780	!	THIS ROUTINE IS CALLED TO GENERATE A 'CP' COMMAND STRING.
3781	!	IF THE 'SINGLE STEP' FEATURE IS ACTIVATED AND THE PROGRAM IS
3782	!	LOOPING ON A TEST OR AN ERROR, THEN THE CP'S MUST BE DONE IN
3783	!	A CONTROLLED MANNER.  THIS IS DONE BY CALLING THE 'SS_UC'
3784	!	ROUTINE.
3785	!
3786	! FORMAL PARAMETERS:
3787	!
3788	!	N		= NUMBER OF CLOCK PULSES REQUIRED
3789	!
3790	! IMPLICIT INPUTS:
3791	!
3792	!	SINGLE_STEP	= FEATURE FLAG INDICATING THAT MICROCODE IS TO
3793	!			  BE SINGLE STEPPED.
3794	!	LOOPING		= FLAG INDICATING THAT PROGRAM IS LOOPING ON ERROR
3795	!	LOOP_ON_TEST	= FEATURE FLAG INDICATING THAT PROGRAM IS LOOPING
3796	!			  ON TEST.
3797	!
3798	! IMPLICIT OUTPUTS:
3799	!
3800	!	NONE
3801	!
3802	! ROUTINE VALUE:
3803	!
3804	!	NONE
3805	!
3806	! SIDE EFFECTS:
3807	!
3808	!	IF NOT SINGLE-STEPPING, A 'CP' COMMAND IS PASSED TO THE
3809	!	'SEND_LINE' ROUTINE FOR CONCATENATION ONTO THE COMMAND LINE.
3810	!	IF SINGLE-STEPPING, 'CP' COMMANDS ARE SENT UNDER USER CONTROL.
3811	!	IF THE STEP COUNT IS OUT OF RANGE, AN ERROR MESSAGE IS PRINTED
3812	!	ON THE TTY.
3813	!
3814	!--
3815	    BEGIN
3816	
3817	    REGISTER
3818		AC0 = 0;
3819	
3820	    IF (.N LSS 1) OR (.N GTR %O'177777')	!IS STEP COUNT OUT OF RANGE
3821	    THEN
3822		BEGIN
3823		PTSTNUM ();				!PRINT THE TEST NUMBER
3824		PTXT_CRLF ('MICROCODE STEP COUNT OUT OF RANGE');
3825		END;
3826	
3827	!CHECK WHETHER WE SHOULD DO SINGLE STEPPING OR NOT
3828	
3829	    IF .SINGLE_STEP AND (.LOOPING OR .LOOP_ON_TEST)
3830	    THEN
3831		SS_UC (.N)				!GO DO SINGLE STEPPING
3832	    ELSE
3833		SEND_CP (.N);				!GO SEND 'CP' CMD
3834	    END;
3835	
3836	GLOBAL ROUTINE CP_NOSS (N) : NOVALUE =
3837	
3838	!++
3839	! FUNCTIONAL DESCRIPTION:
3840	!
3841	!	THIS ROUTINE IS CALLED TO GENERATE A 'CP' COMMAND STRING.
3842	!
3843	! FORMAL PARAMETERS:
3844	!
3845	!	N		= NUMBER OF CLOCK PULSES REQUIRED
3846	!
3847	! IMPLICIT INPUTS:
3848	!
3849	!	NONE
3850	!
3851	! IMPLICIT OUTPUTS:
3852	!
3853	!	NONE
3854	!
3855	! ROUTINE VALUE:
3856	!
3857	!	NONE
3858	!
3859	! SIDE EFFECTS:
3860	!
3861	!	A 'CP' COMMAND IS PASSED TO THE 'SEND_LINE' ROUTINE FOR
3862	!	CONCATENATION ONTO THE COMMAND LINE.
3863	!	IF THE STEP COUNT IS OUT OF RANGE, AN ERROR MESSAGE IS PRINTED
3864	!	ON THE TTY.
3865	!
3866	!--
3867	    BEGIN
3868	
3869	    REGISTER
3870		AC0 = 0;
3871	
3872	    IF (.N LSS 1) OR (.N GTR %O'177777')	!IS STEP COUNT OUT OF RANGE
3873	    THEN
3874		BEGIN
3875		PTSTNUM ();				!PRINT THE TEST NUMBER
3876		PTXT_CRLF ('MICROCODE STEP COUNT OUT OF RANGE');
3877		END;
3878	
3879	    SEND_CP (.N);				!GO SEND 'CP' CMD
3880	    END;
3881	
3882	ROUTINE SEND_CP (N) : NOVALUE =
3883	
3884	!++
3885	! FUNCTIONAL DESCRIPTION:
3886	!
3887	!	THIS ROUTINE GENERATES A 'CP' COMMAND STRING AND PASSES IT TO
3888	!	THE 'SEND_LINE' ROUTINE FOR CONCATENATION ONTO THE COMMAND
3889	!	LINE.  IT TAKES THE PASSED PARAMETER 'N' AND CONVERTS IT TO BE
3890	!	THE ASCII NUMBER FIELD OF THE 'CP' COMMAND.
3891	!
3892	! FORMAL PARAMETERS:
3893	!
3894	!	N		= NUMBER OF CLOCK PULSES REQUIRED
3895	!
3896	! IMPLICIT INPUTS:
3897	!
3898	!	NONE
3899	!
3900	! IMPLICIT OUTPUTS:
3901	!
3902	!	NONE
3903	!
3904	! ROUTINE VALUE:
3905	!
3906	!	NONE
3907	!
3908	! SIDE EFFECTS:
3909	!
3910	!	PASSES 'CP' COMMAND TO 'SEND_LINE' ROUTINE FOR CONCATENATION
3911	!	ONTO COMMAND LINE.
3912	!
3913	!--
3914	    BEGIN
3915	
3916	    LOCAL
3917		BUF_PTR;
3918	
3919	    BIND
3920		CP_CMD = UPLIT (%ASCIZ'CP      ');
3921	
3922	    BUF_PTR = POINT (CP_CMD, 22, 7, 0, 0);	!SETUP BUFFER BYTE POINTER
3923	
3924	    IF .N GEQ 2					! CP DEFAULTS TO DOING IT ONCE
3925	    THEN
3926		BUF_PTR = INSERT_NUM (.BUF_PTR, .N, 6);
3927	
3928	    REPLACEI (BUF_PTR, 0);
3929	    SEND_LINE (CP_CMD, 0);			!PASS 'CP' CMD
3930	    END;
3931	ROUTINE SS_UC (N) : NOVALUE =
3932	
3933	!++
3934	! FUNCTIONAL DESCRIPTION:
3935	!
3936	!	THIS ROUTINE ALLOWS THE USER TO CONTROL SINGLE STEPPING OF
3937	!	DIAGNOSTIC MICROCODE.  IT PRINTS A MESSAGE INFORMING THE USER
3938	!	OF THE NUMBER OF MICROCODE STEPS REQUIRED IN THE FUNCTION
3939	!	BEING EXECUTED.  IT THEN PROMPTS HIM/HER FOR THE NUMBER OF
3940	!	STEPS DESIRED.  THE SPECIFIED NUMBER OF STEPS ARE EXECUTED
3941	!	USING A 'CP' CMD.  THE RESULTS OF AN 'EJ' COMMAND ARE PRINTED
3942	!	FOLLOWING THAT EXECUTION.  THIS PROCESS IS REPEATED UNTIL THE
3943	!	REQUIRED NUMBER OF STEPS HAVE BEEN EXECUTED.  AT THAT POINT,
3944	!	THE USER IS ASKED IF HE/SHE WISHES TO CONTINUE.  IF NOT,
3945	!	PROGRAM CONTROL IS RETURNED TO 'CSL'.
3946	!
3947	! FORMAL PARAMETERS:
3948	!
3949	!	N		= NUMBER OF CLOCK PULSES REQUIRED
3950	!
3951	! IMPLICIT INPUTS:
3952	!
3953	!	NONE
3954	!
3955	! IMPLICIT OUTPUTS:
3956	!
3957	!	NONE
3958	!
3959	! ROUTINE VALUE:
3960	!
3961	!	NONE
3962	!
3963	! SIDE EFFECTS:
3964	!
3965	!	PRINTS PROMPT MESSAGES ON THE TTY AND RECEIVES INPUT.
3966	!	EXECUTES SPECIFIED NUMBER OF 'CP' AND 'EJ' COMMANDS.
3967	!
3968	!--
3969	    BEGIN
3970	
3971	    REGISTER
3972		AC0 = 0;
3973	
3974	    LOCAL
3975		EJ_PTR,					!POINTER TO 'EJ' RESULTS
3976		STEPS;					!COUNTER FOR # OF MICROCODE STEPS
3977	
3978	!PRINT REQUIRED # OF MICROCODE STEPS
3979	
3980	    PRINT_TXT ('THIS MICROCODE SEQUENCE REQUIRES ');
3981	    PRINT_DEC (.N);
3982	    PTXT_CRLF (' MICROCODE STEPS');
3983	
3984	!EXECUTE USER SPECIFIED NUMBER OF MICROCODE STEPS UNTIL REQUIRED #
3985	!ARE EXECUTED.
3986	
3987	    DO
3988		BEGIN
3989		STEPS = GET_NUM (UPLIT (%ASCIZ'ENTER DESIRED NUMBER OF MICRO-STEPS'), .N);
3990		SEND_CP (.STEPS);			!PASS 'CP' CMDS
3991		EJ_PTR = EJ ();
3992		PRINT_CRLF;
3993		PRINT_TXT ('CUR/');
3994		PRINT_OCT_4 (.(.EJ_PTR));		!PRINT 'CUR' CRAM ADDR
3995		PRINT_TXT ('   NXT/');
3996		PRINT_OCT_4 (.(.EJ_PTR + 1));		!PRINT 'NXT' CRAM ADDR
3997		PRINT_TXT ('   J/');
3998		PRINT_OCT_4 (.(.EJ_PTR + 2));		!PRINT 'J' FIELD
3999		PRINT_TXT ('   SUB/');
4000		PRINT_OCT_4 (.(.EJ_PTR + 3));		!PRINT 'SUB' RETURN ADDR
4001		PRINT_CRLF;
4002		PRINT_CRLF;
4003		END
4004	    WHILE (N = .N - .STEPS) GTR 0;
4005	
4006	!FIND OUT IF USER WANTS TO CONTINUE OR RETURN TO 'CSL'
4007	
4008	    PTXT_CRLF ('REQUIRED # OF MICRO-STEPS HAVE BEEN EXECUTED');
4009	    PRINT_TXT ('DO YOU WANT TO CONTINUE THIS TEST?');
4010	
4011	    IF NOT TTI_YES THEN EOP_UUO;
4012	
4013	    END;
4014	
4015	GLOBAL ROUTINE SEND_NUL =
4016	
4017	!++
4018	! FUNCTIONAL DESCRIPTION:
4019	!
4020	!	THIS ROUTINE CAUSES THE CUMULATIVE COMMAND LINE BEING BUILT
4021	!	BY THE 'SEND_LINE' ROUTINE TO BE SENT TO THE 8080.  IT DOES
4022	!	THIS BY PASSING 'SEND_LINE' A NULL COMMAND STRING WITH THE
4023	!	'FORCE_SEND' FLAG SET TO -1.
4024	!
4025	! FORMAL PARAMETERS:
4026	!
4027	!	NONE
4028	!
4029	! IMPLICIT INPUTS:
4030	!
4031	!	NONE
4032	!
4033	! IMPLICIT OUTPUTS:
4034	!
4035	!	NONE
4036	!
4037	! ROUTINE VALUE:
4038	!
4039	!	NONE
4040	!
4041	! SIDE EFFECTS:
4042	!
4043	!	CAUSES THE CUMULATIVE COMMAND LINE TO BE SENT TO THE 8080.
4044	!
4045	!--
4046	    BEGIN
4047	
4048	    OWN
4049		NUL_CMD : INITIAL (0);
4050	
4051	    RETURN SEND_LINE (NUL_CMD, -1);		!SEND CMD LINE
4052	    END;
4053	
4054	GLOBAL ROUTINE SETNXT (ADDR) : NOVALUE =
4055	
4056	!++
4057	! FUNCTIONAL DESCRIPTION:
4058	!
4059	!	THIS ROUTINE CAUSES THE NEXT CRAM ADDR IN THE KS10 TO BE
4060	!	SET TO THE VALUE OF THE PASSED PARAMETER 'ADDR'.
4061	!
4062	! FORMAL PARAMETERS:
4063	!
4064	!	ADDR		= VALUE OF DESIRED NEXT CRAM ADDRESS
4065	!
4066	! IMPLICIT INPUTS:
4067	!
4068	!	NONE
4069	!
4070	! IMPLICIT OUTPUTS:
4071	!
4072	!	NONE
4073	!
4074	! ROUTINE VALUE:
4075	!
4076	!	
4077	!
4078	! SIDE EFFECTS:
4079	!
4080	!	CAUSES THE KS10 NEXT CRAM ADDRESS TO BE SET TO 'ADDR'.
4081	!
4082	!--
4083	    BEGIN
4084	
4085	    LITERAL
4086		X1_AC = 0;
4087	
4088	    RETURN X1 (CADSUB, .ADDR, X1_AC);		!USE 'X1' TO SET ADDR
4089	    END;
4090	
4091	GLOBAL ROUTINE EXNEXT =
4092	
4093	!++
4094	! FUNCTIONAL DESCRIPTION:
4095	!
4096	!	THIS ROUTINE IS CALLED TO EXAMINE THE NEXT CRAM ADDR IN THE
4097	!	KS10.
4098	!
4099	! FORMAL PARAMETERS:
4100	!
4101	!	NONE
4102	!
4103	! IMPLICIT INPUTS:
4104	!
4105	!	NONE
4106	!
4107	! IMPLICIT OUTPUTS:
4108	!
4109	!	NONE
4110	!
4111	! ROUTINE VALUE:
4112	!
4113	!	KS10 NEXT CRAM ADDRESS
4114	!
4115	! SIDE EFFECTS:
4116	!
4117	!	CAUSES AN 'X1' COMMAND TO BE SENT TO THE 8080.  ALSO, IF
4118	!	THE X1 SUBROUTINE IS NOT ALREADY LOADED, A SEQUENCE OF COMMAND
4119	!	LINES WILL BE SENT TO LOAD IT.
4120	!
4121	!--
4122	    BEGIN
4123	
4124	    LITERAL
4125		X1_AC = 9;
4126	
4127	    RETURN .X1 (CADSUB, 0, X1_AC);
4128	    END;
4129	
4130	GLOBAL ROUTINE WR_CRAM (DATA) =
4131	
4132	!++
4133	! FUNCTIONAL DESCRIPTION:
4134	!
4135	!	THIS ROUTINE IS CALLED TO LOAD AND EXECUTE AN 8080 SUBROUTINE
4136	!	WHICH WRITES AND READS BITS 0-35 OF THE KS10 CRAM.
4137	!	THE ACTUAL LOADING AND EXECUTING IS DONE BY THE 'X1' ROUTINE.
4138	!
4139	! FORMAL PARAMETERS:
4140	!
4141	!	DATA		= DATA TO BE WRITTEN INTO BITS 0-35 OF CRAM
4142	!
4143	! IMPLICIT INPUTS:
4144	!
4145	!	NONE
4146	!
4147	! IMPLICIT OUTPUTS:
4148	!
4149	!	NONE
4150	!
4151	! ROUTINE VALUE:
4152	!
4153	!	POINTER TO THE ADDRESS AND ACTUAL DATA FOR LAST ADDRESS
4154	!	TESTED.
4155	!
4156	! SIDE EFFECTS:
4157	!
4158	!	CAUSES 'X1' COMMAND TO BE SENT TO THE 8080.  IF THE REQUIRED
4159	!	8080 SUBROUTINE IS NOT LOADED, IT WILL SEND A SEQUENCE OF COMMAND
4160	!	LINES TO LOAD IT.
4161	!
4162	!--
4163	    BEGIN
4164	
4165	!THE FOLLOWING IS A LISTING OF THE 8080 SUBROUTINE WHICH GETS LOADED
4166	!AND EXECUTED.  IT WRITES THE RECEIVED DATA PATTERN INTO THE KS10 CRAM
4167	!BITS 0-35, READS THEM BACK AND VERIFIES THEM.  IF IT FINDS AN ERROR OR
4168	!WHEN THE LAST ADDRESS IS TESTED, THE ADDRESS AND ACTUAL DATA ARE
4169	!RETURNED.
4170	
4171	!RAM ADDRESS 'RAMX1' = 20054
4172	! 303 327 042	RAMX1:	JMP	RHSAVE
4173	! RAM ADDRESS 'RHSAVE' = 21327
4174	! 347		RHSAVE:	ARG36		;ASSEMBLE 36 BIT ARG
4175	! 010			.BYTE 8
4176	! 322 040		.ADDR	CRMTM	;PLACE TO PUT IT
4177	! 257			XRA	A	;ZERO ACCUM
4178	! 062 145 043		STA	ERRFLG	;CLEAR ERROR FLAG
4179	! 072 322 040		LDA	CRMTM	;GET DATA BEING WRITTEN
4180	! 062 146 043		STA	DATA	;STORE IT
4181	! 315 335 014	NXTAD:	CALL	CRM.AD	;WRITE CRAM ADDRESS
4182	! 076 002		MVI	A,2	;SET STARTING DIAG FN
4183	! 001 010 040		LXI	B,CRMFN	;SETUP STORAGE ADDRESS
4184	! 002		DCLP:	STAX	B	;SAVE CURRENT DIAG FN VALUE
4185	! 072 146 043		LDA	DATA	;GET DATA TO WRITE
4186	! 147			MOV	H,A	;PUT IT INTO H,L
4187	! 157			MOV	L,A
4188	! 315 303 014		CALL	WFUNC	;DO DIAG FN WRITE
4189	! 012			LDAX	B	;GET DIAG FN
4190	! 075			DCR	A	;DECR IT
4191	! 362 355 042		JP	DCLP	;CONTINUE UNTIL DIAG FN = -1
4192	! 315 205 013		CALL	CP1	;CLOCK CRAM BITS INTO REG
4193	! 041 141 043		LXI	H,RDLST	;GET PTR TO LIST OF FNS TO READ
4194	! 176		ECLP:	MOV	A,M	;GET DIAG FN TO ACCUM
4195	! 043			INX	H	;UPDATE PTR
4196	! 247			ANA	A	;CHECK FOR END OF LIST (MINUS ENTRY)
4197	! 372 060 043		JM	SETCH	;GO INC CRAM ADDR
4198	! 315 002 015		CALL	READC	;GO READ DIAG FN
4199	! 042 170 040		SHLD	ECSAV	;SAVE H,L
4200	! 041 100 040		LXI	H,TMPB2	;SETUP PTR TO DATA
4201	! 072 146 043		LDA	DATA	;GET DATA WRITTEN
4202	! 256			XRA	M	;COMPARE TO DATA READ
4203	! 302 042 043		JNZ	ERR	;JUMP IF DIFFERENT
4204	! 072 146 043		LDA	DATA	;GET DATA WRITTEN
4205	! 346 017		ANI	17	;MASK OFF DON'T CARE BITS
4206	! 043			INX	H	;INCR PTR TO READ DATA
4207	! 256			XRA	M	;COMPARE
4208	! 053			DCX	H	;RESTORE DATA PTR
4209	! 312 045 043		JZ	NOERR2	;JUMP IF NO ERROR
4210	! 062 145 043	ERR:	STA	ERRFLG	;SET ERROR FLAG
4211	! 315 045 031	NOERR2:	CALL	OCTAL	;TURN DATA INTO ASCII CHAR
4212	! 002			.BYTE	2
4213	! 004			.BYTE	4
4214	! 052 170 040		LHLD	ECSAV	;RESTORE H,L
4215	! 303 001 043		JMP	ECLP	;CONTINUE READING DIAG FNS
4216	! 072 145 043	SETCH:	LDA	ERRFLG	;GET ERROR FLAG
4217	! 356 000		XRI	0	;CHECK FOR ZERO
4218	! 302 102 043		JNZ	RPTIT	;JUMP IF HAD ERROR
4219	! 052 004 040		LHLD	CRMAD	;GET CRAM ADDR
4220	! 043			INX	H	;INCR IT
4221	! 174			MOV	A,H	;GET HIGH ORDER ADDR BITS
4222	! 356 010		XRI	10	;CHECK IF REACHED MAX ADDR
4223	! 302 117 043		JNZ	POPSTK	;JUMP IF NOT
4224	! 041 004 040	RPTIT:	LXI	H,CRMAD	;GET ADDR OF CRAM ADDR
4225	! 315 332 030		CALL	P16	;GO PRINT ADDR
4226	! 317 057		PSLASH		;PRINT SLASH
4227	! 006 014		MVI	B,12.	;NUM OF CHAR TO TYPE
4228	! 303 046 016		JMP	PCRLP	;GO TYPE CHARS AND END CMD
4229	! 042 004 040	POPSTK:	SHLD	CRMAD	;STORE IT BACK
4230	! 361			POP	PSW	;POP CHAR OFF STACK
4231	! 361			POP	PSW	;POP CHAR OFF STACK
4232	! 361			POP	PSW	;POP CHAR OFF STACK
4233	! 361			POP	PSW	;POP CHAR OFF STACK
4234	! 361			POP	PSW	;POP CHAR OFF STACK
4235	! 361			POP	PSW	;POP CHAR OFF STACK
4236	! 361			POP	PSW	;POP CHAR OFF STACK
4237	! 361			POP	PSW	;POP CHAR OFF STACK
4238	! 361			POP	PSW	;POP CHAR OFF STACK
4239	! 361			POP	PSW	;POP CHAR OFF STACK
4240	! 361			POP	PSW	;POP CHAR OFF STACK
4241	! 361			POP	PSW	;POP CHAR OFF STACK
4242	! 303 345 042		JMP	NXTAD	;GO TEST NEXT ADDR
4243	! 005		RDLST:	.BYTE	5	;READ 24-35
4244	! 004			.BYTE	4	;READ 12-23
4245	! 000			.BYTE	0	;READ 0-11
4246	! 377			.BYTE	377	;MARKS END OF LIST
4247	! 000		ERRFLG:	.BYTE	0
4248	! 000		DATA:	.BYTE	0
4249	
4250	    BIND
4251		SUB = PLIT (UPLIT (%ASCIZ 'LK20054,DK303,DN327,DN42,LK21327,DK347,DN10,DN322,DN40,DN257,DN62,DN145,DN43'),
4252			    UPLIT(%ASCIZ 'DN72,DN322,DN40,DN62,DN146,DN43,DN315,DN264,DN14,DN76,DN2,DN1,DN10,DN40,DN2'),
4253			    UPLIT(%ASCIZ 'DN72,DN146,DN43,DN147,DN157,DN315,DN232,DN14,DN12,DN75,DN362,DN355,DN42,DN315'),
4254			    UPLIT(%ASCIZ 'DN127,DN13,DN41,DN141,DN43,DN176,DN43,DN247,DN372,DN60,DN43,DN315,DN331,DN14'),
4255			    UPLIT(%ASCIZ 'DN42,DN170,DN40,DN41,DN100,DN40,DN72,DN146,DN43,DN256,DN302,DN42,DN43,DN72'),
4256			    UPLIT(%ASCIZ 'DN146,DN43,DN346,DN17,DN43,DN256,DN53,DN312,DN45,DN43,DN62,DN145,DN43,DN315'),
4257			    UPLIT(%ASCIZ 'DN16,DN31,DN2,DN4,DN52,DN170,DN40,DN303,DN1,DN43,DN72,DN145,DN43,DN356,DN0'),
4258			    UPLIT(%ASCIZ 'DN302,DN102,DN43,DN52,DN4,DN40,DN43,DN174,DN356,DN10,DN302,DN117,DN43,DN41'),
4259			    UPLIT(%ASCIZ 'DN4,DN40,DN315,DN303,DN30,DN317,DN57,DN6,DN14,DN303,DN375,DN15,DN42,DN4,DN40'),
4260			    UPLIT(%ASCIZ 'DN361,DN361,DN361,DN361,DN361,DN361,DN361,DN361,DN361,DN361,DN361,DN361,DN303'),
4261			    UPLIT(%ASCIZ 'DN345,DN42,DN5,DN4,DN0,DN377,DN0,DN0'));
4262	
4263	    LITERAL
4264		X1_AC = 10;
4265	
4266	    RETURN X1 (SUB, .DATA, X1_AC);
4267	    END;
4268	
4269	GLOBAL ROUTINE X1 (SUB_PTR, ARG, X1_AC) =
4270	
4271	!++
4272	! FUNCTIONAL DESCRIPTION:
4273	!
4274	!	THIS ROUTINE LOADS AN 8080 SUBROUTINE, IF NECESSARY, AND
4275	!	CREATES AND SENDS AN 'X1' COMMAND TO EXECUTE THAT ROUTINE.
4276	!	FOR THOSE X1 COMMANDS WHICH REQUIRE AN ARGUMENT, THE 'ARG'
4277	!	PARAMETER IS CONVERTED TO AN ASCII OCTAL NUMBER FIELD ON
4278	!	THE 'X1' COMMAND.
4279	!
4280	! FORMAL PARAMETERS:
4281	!
4282	!	SUB_PTR		= POINTER TO THE SEQUENCE OF ASCII COMMAND LINES
4283	!			  REQUIRED TO LOAD THE 8080 SUBROUTINE
4284	!	ARG		= VALUE TO BE USED AS THE NUMBER FIELD IN THE
4285	!			  'X1' COMMAND
4286	!	X1_AC		= VALUE TO BE PASSED TO 'SEND_LINE' AS THE 'FORCE
4287	!			  SEND' FLAG.  3 VALUES ARE POSSIBLE:
4288	!			  0 = 'X1' WITH ARGUMENT TO SET NEXT CRAM ADDRESS
4289	!			  9 = 'X1' WITHOUT ARGUMENT TO READ NEXT CRAM ADDR
4290	!			  10 = 'X1' WITH ARGUMENT TO WRITE AND READ CRAM
4291	!			  	BITS 0-35
4292	!
4293	! IMPLICIT INPUTS:
4294	!
4295	!	SUB_LOADED	= FLAG CONTAINING POINTER TO SUBROUTINE SEQUENCE
4296	!			  CURRENTLY LOADED INTO 8080.
4297	!
4298	! IMPLICIT OUTPUTS:
4299	!
4300	!	NONE
4301	!
4302	! ROUTINE VALUE:
4303	!
4304	!	POINTER TO 8080 RESPONSE DATA, IF THERE IS ANY.
4305	!
4306	! SIDE EFFECTS:
4307	!
4308	!	CAUSES SUBROUTINE TO BE LOADED INTO 8080 RAM, IF NEEDED.
4309	!	CAUSES 'X1' COMMAND TO BE SENT TO 8080.
4310	!
4311	!--
4312	    BEGIN
4313	
4314	    BIND
4315		X1_CMD = UPLIT (%ASCIZ'X1            ');
4316	
4317	    LOCAL
4318		BUF_PTR;
4319	
4320	!CHECK IF REQUIRED SUBROUTINE IS ALREADY LOADED.
4321	
4322	    IF .SUB_LOADED NEQ .SUB_PTR			!IF CORRECT SUBROUTINE ISN'T LOADED
4323	    THEN 					!THEN LOAD IT
4324		BEGIN
4325	
4326		INCR I FROM 0 TO .(.SUB_PTR - 1) - 1 BY 1 DO
4327		    SEND_LINE (.(.SUB_PTR + .I), -1);
4328	
4329		SUB_LOADED = .SUB_PTR;			!SET FLAG THAT IT'S LOADED
4330		END;
4331	
4332	    BUF_PTR = POINT (X1_CMD, 22, 7, 0, 0);	!INIT BYTE POINTER
4333	
4334	    IF .X1_AC EQL 0				!IF THIS IS 'X1' TO SET NEXT CRAM ADDR
4335	    THEN
4336		BUF_PTR = INSERT_NUM (.BUF_PTR, .ARG, 4);	!INSERT ARG FIELD INTO CMD
4337	
4338	    IF .X1_AC EQL 10				!IF THIS IS 'X1' TO TEST CRAM 0-35
4339	    THEN
4340		BUF_PTR = INSERT_NUM (.BUF_PTR, .ARG, 12);	!INSERT ARG FIELD INTO CMD
4341	
4342	    REPLACEI (BUF_PTR, 0);			!TERMINATE COMMAND STRING
4343	    RETURN SEND_LINE (X1_CMD, .X1_AC);
4344	    END;
4345	
4346	GLOBAL ROUTINE LOADUC (CRAM_ADDR, DATA_ADDR) : NOVALUE =
4347	
4348	!++
4349	! FUNCTIONAL DESCRIPTION:
4350	!
4351	!	THIS ROUTINE LOADS THE KS10 CRAM WITH MICROCODE.
4352	!	FIRST, IT FORCES SENDING THE CUMULATIVE COMMAND LINE BY
4353	!	CALLING THE 'SEND_NUL' ROUTINE.  THEN IT EXECUTES AN LUUO
4354	!	TO 'CSL' TO CAUSE THE LOADING OF A SPECIFIED BLOCK OF MICROCODE.
4355	!
4356	! FORMAL PARAMETERS:
4357	!
4358	!	CRAM_ADDR	= CRAM ADDRESS AT WHICH TO START LOADING UCODE
4359	!	DATA_ADDR	= POINTER TO THE BLOCK OF MICROCODE TO BE LOADED.
4360	!			  (POINTER-1) CONTAINS THE # OF 36-BIT WORDS IN
4361	!			  THE BLOCK.  THE BLOCK CONTAINS 3-WORD ENTRY,
4362	!			  WITH EACH ENTRY SPECIFYING THE 96 BITS OF UCODE
4363	!			  TO BE LOADED.
4364	!
4365	! IMPLICIT INPUTS:
4366	!
4367	!	NONE
4368	!
4369	! IMPLICIT OUTPUTS:
4370	!
4371	!	NONE
4372	!
4373	! ROUTINE VALUE:
4374	!
4375	!	NONE
4376	!
4377	! SIDE EFFECTS:
4378	!
4379	!	CAUSES THE CUMULATIVE COMMAND LINE TO BE SENT THEN LOADS THE
4380	!	SPECIFIED BLOCK OF UCODE INTO THE KS10 CRAM.
4381	!
4382	!--
4383	    BEGIN
4384	
4385	    REGISTER
4386		AC0 = 0;
4387	
4388	    SEND_NUL ();				!SEND ANY EXISTING CMD LINE
4389	
4390	!SETUP AC0 WITH DATA AS REQUIRED BY LUUO.
4391	
4392	    AC0<0, 18> = .DATA_ADDR;			!POINTER TO UCODE DATA
4393	    AC0<18, 12> = .CRAM_ADDR;			!START LOAD ADDR
4394	    AC0<30, 6> = (.(.DATA_ADDR - 1))/3;		!# OF UCODE WORDS TO LOAD
4395	    UUO (0, 2, 0, 0);				!GO TO 'CSL' TO LOAD UCODE
4396	    END;
4397	
4398	GLOBAL ROUTINE MR : NOVALUE =
4399	
4400	!++
4401	! FUNCTIONAL DESCRIPTION:
4402	!
4403	!	THIS ROUTINE PASSES A 'MR' (MASTER RESET) COMMAND TO THE
4404	!	'SEND_LINE' ROUTINE FOR CONCATENATION ONTO THE COMMAND LINE.
4405	!
4406	! FORMAL PARAMETERS:
4407	!
4408	!	NONE
4409	!
4410	! IMPLICIT INPUTS:
4411	!
4412	!	NONE
4413	!
4414	! IMPLICIT OUTPUTS:
4415	!
4416	!	NONE
4417	!
4418	! ROUTINE VALUE:
4419	!
4420	!	NONE
4421	!
4422	! SIDE EFFECTS:
4423	!
4424	!	PASSES 'MR' COMMAND STRING TO 'SEND_LINE' FOR CONCATENATION
4425	!	ONTO THE COMMAND LINE.  WHEN IT GETS EXECUTED, THE KS10 WILL
4426	!	BE RESET.
4427	!
4428	!--
4429	    BEGIN
4430	
4431	    BIND
4432		MR_CMD = UPLIT (%ASCIZ'MR');		!'MR' COMMAND STRING
4433	
4434	    SEND_LINE (MR_CMD, 0);
4435	    END;
4436	
4437	GLOBAL ROUTINE PE (ARG) : NOVALUE =
4438	
4439	!++
4440	! FUNCTIONAL DESCRIPTION:
4441	!
4442	!	THIS ROUTINE IS CALLED TO TURN ON OR OFF PARITY DETECTION BY
4443	!	THE 8080.  IT PASSES THE APPROPRIATE 'PE' COMMAND TO 'SEND_LINE'
4444	!	FOR CONCATENATION ONTO THE COMMAND LINE.
4445	!
4446	! FORMAL PARAMETERS:
4447	!
4448	!	ARG		= ARGUMENT FIELD FOR PE COMMAND
4449	!			  0 - DISBALE ALL PARITY DETECTION
4450	!			  1 - ENABLE DATA PATH PARITY DETECTION
4451	!			  2 - ENABLE CRAM PARITY DETECTION
4452	!			  3 - (1 AND 2)
4453	!			  4 - ENABLE CLOCK STOP ON PARITY ERROR
4454	!			  5 - (1 AND 4)
4455	!			  6 - (2 AND 4)
4456	!			  7 - ENABLE ALL
4457	!
4458	! IMPLICIT INPUTS:
4459	!
4460	!	NONE
4461	!
4462	! IMPLICIT OUTPUTS:
4463	!
4464	!	NONE
4465	!
4466	! ROUTINE VALUE:
4467	!
4468	!	NONE
4469	!
4470	! SIDE EFFECTS:
4471	!
4472	!	PASSES 'PE' COMMAND STRING TO 'SEND_LINE' FOR CONCATENATION
4473	!	ONTO THE COMMAND LINE.  WHEN EXECUTED, IT WILL TURN ON OR OFF
4474	!	8080 PARITY DETECTION. IF THE ARGUMENT PARAMETER IS OUT OF RANGE,
4475	!	AN ERROR MESSAGE IS PRINTED.
4476	!
4477	!--
4478	    BEGIN
4479	
4480	    BIND
4481		PE_CMD = UPLIT (%ASCIZ'PE ');		!'PE' COMMAND STRING SKELETON
4482	
4483	    LOCAL
4484		BUF_PTR;				!BYTE POINTER
4485	
4486	    REGISTER
4487		AC0 = 0;
4488	
4489	    IF (.ARG LSS 0) OR (.ARG GTR 7)		!CHECK IF ARG IS IN RANGE
4490	
4491	    THEN
4492		BEGIN
4493		PTSTNUM ();				!PRINT TEST NUMBER
4494		PTXT_CRLF ('ARGUMENT TO PE ROUTINE NOT 0 TO 7');
4495		END;
4496	
4497	    BUF_PTR = POINT (PE_CMD, 22, 7, 0, 0);
4498	    REPLACEI (BUF_PTR, .ARG + %O'60');		!INSERT ARGUMENT FIELD
4499	    SEND_LINE (PE_CMD, 0);
4500	    END;
4501	
4502	GLOBAL ROUTINE CE (ARG) : NOVALUE =
4503	
4504	!++
4505	! FUNCTIONAL DESCRIPTION:
4506	!
4507	!	THIS ROUTINE IS CALLED TO ENABLE OR DISABLE CACHING BY THE KS10.
4508	!	IT PASSES A 'CE' COMMAND TO THE 'SEND_LINE' ROUTINE FOR CONCAT-
4509	!	ENATION ONTO THE COMMAND LINE.
4510	!
4511	! FORMAL PARAMETERS:
4512	!
4513	!	ARG		= ARGUMENT FIELD FOR 'CE' COMMAND STRING
4514	!			  0 - DISABLE CACHING
4515	!			  1 - ENABLE CACHING
4516	!
4517	! IMPLICIT INPUTS:
4518	!
4519	!	NONE
4520	!
4521	! IMPLICIT OUTPUTS:
4522	!
4523	!	NONE
4524	!
4525	! ROUTINE VALUE:
4526	!
4527	!	NONE
4528	!
4529	! SIDE EFFECTS:
4530	!
4531	!	PASSES A 'CE' COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR
4532	!	CONCATENATION ONTO THE COMMAND LINE.  WHEN EXECUTED, IT WILL
4533	!	ENABLE OR DISABLE CACHING ON THE KS10.  IF THE 'ARG' PARAMETER IS
4534	!	OUT OF RANGE, AN ERROR MESSAGE IS PRINTED.
4535	!
4536	!--
4537	    BEGIN
4538	
4539	    BIND
4540		CE_CMD = UPLIT (%ASCIZ'CE ');		!'CE' COMMAND STRING SKELETON
4541	
4542	    LOCAL
4543		BUF_PTR;				!BYTE POINTER
4544	
4545	    REGISTER
4546		AC0 = 0;
4547	
4548	    IF (.ARG LSS 0) OR (.ARG GTR 1)		!CHECK IF ARG FIELD IS IN RANGE
4549	    THEN
4550		BEGIN
4551		PTSTNUM ();				!PRINT TEST NUMBER
4552		PTXT_CRLF ('ARGUMENT TO CE ROUTINE NOT 0 OR 1');
4553		END;
4554	
4555	    BUF_PTR = POINT (CE_CMD, 22, 7, 0, 0);
4556	    REPLACEI (BUF_PTR, .ARG + %O'60');		!INSERT ARGUMENT FIELD
4557	    SEND_LINE (CE_CMD, 0);
4558	    END;
4559	
4560	GLOBAL ROUTINE CS : NOVALUE =
4561	
4562	!++
4563	! FUNCTIONAL DESCRIPTION:
4564	!
4565	!	THIS ROUTINE IS CALLED TO START THE KS10 CPU CLOCK. IT PASSES
4566	!	A 'CS' COMMAND TO 'SEND_LINE' FOR CONCATENATION ONTO THE COMMAND
4567	!	LINE.
4568	!
4569	! FORMAL PARAMETERS:
4570	!
4571	!	NONE
4572	!
4573	! IMPLICIT INPUTS:
4574	!
4575	!	NONE
4576	!
4577	! IMPLICIT OUTPUTS:
4578	!
4579	!	NONE
4580	!
4581	! ROUTINE VALUE:
4582	!
4583	!	NONE
4584	!
4585	! SIDE EFFECTS:
4586	!
4587	!	CONCATENATES 'CS' COMMAND ONTO THE CUMULATIVE COMMAND LINE.
4588	!	WHEN EXECUTED, IT WILL START THE KS10 CPU CLOCK.
4589	!
4590	!--
4591	    BEGIN
4592	
4593	    BIND
4594		CS_CMD = UPLIT (%ASCIZ'CS');		!'CS' COMMAND STRING
4595	
4596	    SEND_LINE (CS_CMD, 0);
4597	    END;
4598	
4599	GLOBAL ROUTINE CH : NOVALUE =
4600	
4601	!++
4602	! FUNCTIONAL DESCRIPTION:
4603	!
4604	!	THIS ROUTINE IS CALLED TO HALT THE KS10 CPU CLOCK. IT PASSES
4605	!	A 'CH' COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR CONCAT-
4606	!	ENATION ONTO THE COMMAND LINE.
4607	!
4608	! FORMAL PARAMETERS:
4609	!
4610	!	NONE
4611	!
4612	! IMPLICIT INPUTS:
4613	!
4614	!	NONE
4615	!
4616	! IMPLICIT OUTPUTS:
4617	!
4618	!	NONE
4619	!
4620	! ROUTINE VALUE:
4621	!
4622	!	NONE
4623	!
4624	! SIDE EFFECTS:
4625	!
4626	!	CONCATENATES A 'CH' COMMAND STRING ONTO THE CUMULATIVE COMMAND
4627	!	LINE. WHEN EXECUTED, IT WILL HALT THE KS10 CPU CLOCK.
4628	!
4629	!--
4630	    BEGIN
4631	
4632	    BIND
4633		CH_CMD = UPLIT (%ASCIZ'CH');		!'CH' COMMAND STRING
4634	
4635	    SEND_LINE (CH_CMD, 0);
4636	    END;
4637	
4638	GLOBAL ROUTINE TP (ARG) : NOVALUE =
4639	
4640	!++
4641	! FUNCTIONAL DESCRIPTION:
4642	!
4643	!	THIS ROUTINE IS CALLED TO ENABLE OR DISABLE KS10 TRAPPING. IT
4644	!	PASSES A 'TP' COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR
4645	!	CONCATENATION ONTO THE COMMAND LINE.
4646	!
4647	! FORMAL PARAMETERS:
4648	!
4649	!	ARG		= ARGUMENT FIELD FOR THE 'TP' COMMAND
4650	!			  0 = DISBALE TRAPPING
4651	!			  1 = ENABLE TRAPPING
4652	!
4653	! IMPLICIT INPUTS:
4654	!
4655	!	NONE
4656	!
4657	! IMPLICIT OUTPUTS:
4658	!
4659	!	NONE
4660	!
4661	! ROUTINE VALUE:
4662	!
4663	!	NONE
4664	!
4665	! SIDE EFFECTS:
4666	!
4667	!	CONCATENATES A 'TP' COMMAND ONTO THE CUMULATIVE COMMAND LINE.
4668	!	WHEN EXECUTED, IT WILL ENABLE OR DISABLE KS10 TRAPPING.  IF THE
4669	!	'ARG' PARAMETER IS OUT OF RANGE, AN ERROR MESSAGE IS PRINTED.
4670	!
4671	!--
4672	    BEGIN
4673	
4674	    BIND
4675		TP_CMD = UPLIT (%ASCIZ'TP ');		!'TP' CMD STRING SKELETON
4676	
4677	    LOCAL
4678		BUF_PTR;				!BYTE POINTER
4679	
4680	    REGISTER
4681		AC0 = 0;
4682	
4683	    IF (.ARG LSS 0) OR (.ARG GTR 1)		!CHECK IF ARG FIELD IS IN RANGE
4684	    THEN
4685		BEGIN
4686		PTSTNUM ();				!PRINT TEST NUMBER
4687		PTXT_CRLF ('ARGUMENT TO TP ROUTINE NOT 0 OR 1');
4688		END;
4689	
4690	    BUF_PTR = POINT (TP_CMD, 22, 7, 0, 0);
4691	    REPLACEI (BUF_PTR, .ARG + %O'60');		!INSERT ARGUMENT FIELD
4692	    SEND_LINE (TP_CMD, 0);
4693	    END;
4694	
4695	GLOBAL ROUTINE TE (ARG) : NOVALUE =
4696	
4697	!++
4698	! FUNCTIONAL DESCRIPTION:
4699	!
4700	!	THIS ROUTINE IS CALLED TO ENABLE OR DISABLE THE KS10 1 MSEC
4701	!	TIMER.  IT PASSES A 'TE' COMMAND STRING TO THE 'SEND_LINE'
4702	!	ROUTINE FOR CONCATENATION ONTO THE COMMAND LINE.
4703	!
4704	! FORMAL PARAMETERS:
4705	!
4706	!	ARG		= ARGUMENT FIELD FOR 'TE' COMMAND STRING
4707	!			  0 - DISABLE 1 MSEC TIMER
4708	!			  1 - ENABLE 1 MSEC TIMER
4709	!
4710	! IMPLICIT INPUTS:
4711	!
4712	!	NONE
4713	!
4714	! IMPLICIT OUTPUTS:
4715	!
4716	!	NONE
4717	!
4718	! ROUTINE VALUE:
4719	!
4720	!	NONE
4721	!
4722	! SIDE EFFECTS:
4723	!
4724	!	CONCATENATES A 'TE' COMMAND ONTO THE CUMULATIVE COMMAND STRING.
4725	!	WHEN EXECUTED, IT WILL ENABLE OR DISABLE THE KS10 1 MSEC TIMER.
4726	!	IF THE 'ARG' PARAMETER IS OUT OF RANGE, AN ERROR MESSAGE IS
4727	!	PRINTED.
4728	!--
4729	    BEGIN
4730	
4731	    BIND
4732		TE_CMD = UPLIT (%ASCIZ'TE ');		!'TE' CMD STRING SKELETON
4733	
4734	    LOCAL
4735		BUF_PTR;				!BYTE POINTER
4736	
4737	    REGISTER
4738		AC0 = 0;
4739	
4740	    IF (.ARG LSS 0) OR (.ARG GTR 1)		!CHECK IF ARG IS OUT OF RANGE
4741	    THEN
4742		BEGIN
4743		PTSTNUM ();				!PRINT TEST NUMBER
4744		PTXT_CRLF ('ARGUMENT TO TE ROUTINE NOT 0 OR 1');
4745		END;
4746	
4747	    BUF_PTR = POINT (TE_CMD, 22, 7, 0, 0);
4748	    REPLACEI (BUF_PTR, .ARG + %O'60');		!INSERT ARGUMENT FIELD
4749	    SEND_LINE (TE_CMD, 0);
4750	    END;
4751	
4752	GLOBAL ROUTINE EJ =
4753	
4754	!++
4755	! FUNCTIONAL DESCRIPTION:
4756	!
4757	!	THIS ROUTINE EXECUTES AN 'EJ' COMMAND TO READ THE KS10 ADDRESS
4758	!	PARAMTERS - NEXT CRAM ADDR, CURRENT LOCATION, MICROCODE J FIELD,
4759	!	AND SUBROUTINE RETURN ADDRESS.  IT DOES THIS BY PASSING AN 'EJ'
4760	!	COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR CONCATENATION ONTO
4761	!	THE COMAND LINE.
4762	!
4763	! FORMAL PARAMETERS:
4764	!
4765	!	NONE
4766	!
4767	! IMPLICIT INPUTS:
4768	!
4769	!	NONE
4770	!
4771	! IMPLICIT OUTPUTS:
4772	!
4773	!	NONE
4774	!
4775	! ROUTINE VALUE:
4776	!
4777	!	POINTER TO BLOCK OF KS10 ADDRESS PARAMETERS.
4778	!
4779	!	POINTER -> CURRENT LOC
4780	!		   NXT CRAM ADDR
4781	!		   J FIELD
4782	!		   SUB RTN ADDR
4783	!
4784	! SIDE EFFECTS:
4785	!
4786	!	CONCATENATES 'EJ' COMMAND TO CUMULATIVE COMMAND LINE AND
4787	!	CAUSES COMMAND LINE TO BE SENT TO 8080.
4788	!
4789	!--
4790	    BEGIN
4791	
4792	    BIND
4793		EJ_CMD = UPLIT (%ASCIZ'EJ');		!'EJ' CMD STRING
4794	
4795	    RETURN SEND_LINE (EJ_CMD, EJ_AC);
4796	    END;
4797	
4798	GLOBAL ROUTINE SC_0 : NOVALUE =
4799	
4800	!++
4801	! FUNCTIONAL DESCRIPTION:
4802	!
4803	!	THIS ROUTINE IS CALLED TO DISABLE 8080 SOFT CRAM ERROR RECOVERY.
4804	!	IT PASSES A 'SC 0' COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR
4805	!	CONCATENATION ONTO THE COMMAND LINE.
4806	!
4807	! FORMAL PARAMETERS:
4808	!
4809	!	NONE
4810	!
4811	! IMPLICIT INPUTS:
4812	!
4813	!	NONE
4814	!
4815	! IMPLICIT OUTPUTS:
4816	!
4817	!	NONE
4818	!
4819	! ROUTINE VALUE:
4820	!
4821	!	NONE
4822	!
4823	! SIDE EFFECTS:
4824	!
4825	!	CONCATENATES A 'SC 0' COMMAND ONTO THE CUMULATIVE COMMAND LINE.
4826	!	WHEN EXECUTED, IT WILL DISABLE 8080 SOFT CRAM ERROR RECOVERY.
4827	!
4828	!--
4829	    BEGIN
4830	
4831	    BIND
4832		SC0_CMD = UPLIT (%ASCIZ'SC0');		!'SC 0' COMMAND STRING
4833	
4834	    SEND_LINE (SC0_CMD, 0);
4835	    END;
4836	
4837	GLOBAL ROUTINE EC (ADDR) =
4838	
4839	!++
4840	! FUNCTIONAL DESCRIPTION:
4841	!
4842	!	THIS ROUTINE EXECUTES AN 'EC' COMMAND TO EXAMINE THE CONTENTS
4843	!	OF A SPECIFIED KS10 CRAM LOCATION.IT DOES THIS BY PASSING THE 'EC'
4844	!	COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR CONCATENATION ONTO THE
4845	!	COMMAND LINE.
4846	!
4847	! FORMAL PARAMETERS:
4848	!
4849	!	ADDR		= CRAM ADDR TO BE READ
4850	!			  IF -1, THEN DON'T PUT ADDR FIELD ON COMMAND STRING
4851	!
4852	! IMPLICIT INPUTS:
4853	!
4854	!	NONE
4855	!
4856	! IMPLICIT OUTPUTS:
4857	!
4858	!	NONE
4859	!
4860	! ROUTINE VALUE:
4861	!
4862	!	POINTER TO THE CRAM DATA READ BY 8080
4863	!
4864	!	POINTER -> CRAM ADDR
4865	!		   CRAM BITS 60-95
4866	!		   CRAM BITS 24-59
4867	!		   CRAM BITS 0-23
4868	!
4869	! SIDE EFFECTS:
4870	!
4871	!	CONCATENATES AN 'EC' COMMAND ONTO THE CUMULATIVE COMMAND LINE AND
4872	!	CAUSES THAT COMMAND LINE TO BE SENT TO THE 8080.
4873	!
4874	!--
4875	    BEGIN
4876	
4877	    LOCAL
4878		BUF_PTR;				!BYTE POINTER
4879	
4880	    BIND
4881		EC_CMD = UPLIT (%ASCIZ'EC    ');	!'EC' CMD STRING SKELETON
4882	
4883	    BUF_PTR = POINT (EC_CMD, 22, 7, 0, 0);	!INIT BYTE POINTER
4884	
4885	    IF .ADDR NEQ -1				!IF ADDR IS -1, DON'T ADD ADDR FIELD TO CMD
4886	    THEN
4887		BUF_PTR = INSERT_NUM (.BUF_PTR, .ADDR, 4);	!INSERT ADDR FIELD INTO CMD
4888	
4889	    REPLACEI (BUF_PTR, 0);			!TERMINATE THE COMMAND
4890	    RETURN SEND_LINE (EC_CMD, EC_AC);		!SEND CMD AND RETURN POINTER
4891	    END;
4892	
4893	GLOBAL ROUTINE LCA (ADDR) : NOVALUE =
4894	
4895	!++
4896	! FUNCTIONAL DESCRIPTION:
4897	!
4898	!	THIS ROUTINE IS CALLED TO LOAD A SPECIFIED CRAM ADDRESS.  IT
4899	!	PASSES A 'LC' COMMAND STRING TO THE 'SEND_LINE' FOR CONCATENATION
4900	!	ONTO THE COMMAND LINE.
4901	!
4902	! FORMAL PARAMETERS:
4903	!
4904	!	ADDR		= VALUE TO BE USED AS ADDR FIELD IN 'LC' COMMAND
4905	!
4906	! IMPLICIT INPUTS:
4907	!
4908	!	NONE
4909	!
4910	! IMPLICIT OUTPUTS:
4911	!
4912	!	NONE
4913	!
4914	! ROUTINE VALUE:
4915	!
4916	!	NONE
4917	!
4918	! SIDE EFFECTS:
4919	!
4920	!	CONCATENATES AN 'LC' COMMAND ONTO THE CUMUULATIVE COMMAND LINE.
4921	!	WHEN EXECUTED, IT WILL LOAD THE SPECIFIED CRAM ADDRESS.
4922	!
4923	!--
4924	    BEGIN
4925	
4926	    LOCAL
4927		BUF_PTR;				!BYTE POINTER
4928	
4929	    BIND
4930		LC_CMD = UPLIT (%ASCIZ'LC    ');	!'LC' CMD STRING SKELETON
4931	
4932	    BUF_PTR = POINT (LC_CMD, 22, 7, 0, 0);	!INIT BYTE POINTER
4933	    BUF_PTR = INSERT_NUM (.BUF_PTR, .ADDR, 4);	!INSERT ADDR FIELD INTO CMD
4934	    REPLACEI (BUF_PTR, 0);			!TERMINATE COMMAND
4935	    SEND_LINE (LC_CMD, 0);
4936	    END;
4937	
4938	GLOBAL ROUTINE DC_035 (DATA) : NOVALUE =
4939	
4940	!++
4941	! FUNCTIONAL DESCRIPTION:
4942	!
4943	!	THIS ROUTINE IS CALLED TO DEPOSIT SPECIFIED DATA INTO BITS 0-35
4944	!	OF THE KS10 CRAM (BITS 36-96 ARE ZEROED).  IT CREATES AND PASSES
4945	!	A 'DC' COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR CONCATENATION
4946	!	ONTO THE COMMAND LINE.
4947	!
4948	! FORMAL PARAMETERS:
4949	!
4950	!	DATA		= DATA TO BE WRITTEN INTO CRAM BITS 0-35
4951	!
4952	! IMPLICIT INPUTS:
4953	!
4954	!	NONE
4955	!
4956	! IMPLICIT OUTPUTS:
4957	!
4958	!	NONE
4959	!
4960	! ROUTINE VALUE:
4961	!
4962	!	NONE
4963	!
4964	! SIDE EFFECTS:
4965	!
4966	!	CONCATENATES A 'DC' COMMAND ONTO THE CUMULATIVE COMMAND LINE.
4967	!	WHEN EXECUTED, IT WILL WRITE THE SPECIFIED DATA INTO CRAM BITS 0-35
4968	!	AND ZEROES BITS 36-96.
4969	!
4970	!--
4971	    BEGIN
4972	
4973	    LOCAL
4974		BUF_PTR;				!BYTE POINTER
4975	
4976	    BIND
4977		DC_CMD = UPLIT (%ASCIZ'DC                                '); !'DC" CMD SKELETON
4978	
4979	    BUF_PTR = POINT (DC_CMD, 22, 7, 0, 0);	!INIT BYTE POINTER
4980	    BUF_PTR = INSERT_NUM (.BUF_PTR, .DATA, 12);	!INSERT DATA FIELD INTO CMD
4981	
4982	    INCR I FROM 0 TO 19 BY 1 DO
4983		REPLACEI (BUF_PTR, %C'0');		!FILL IN ZEROS FOR CRAM BITS 36-96
4984	
4985	    REPLACEI (BUF_PTR, 0);			!TERMINATE COMMAND STRING
4986	    SEND_LINE (DC_CMD, 0);			!SEND CMD LINE
4987	    END;
4988	
4989	GLOBAL ROUTINE MOD_FLD (DIAG_FN, DATA) : NOVALUE =
4990	
4991	!++
4992	! FUNCTIONAL DESCRIPTION:
4993	!
4994	!	THIS ROUTINE IS CALLED TO MODIFY A 12-BIT DATA FIELD IN THE KS10
4995	!	CRAM.  THE LOCATION MODIFIED IS THAT WHICH WAS PREVIOUSLY SELECTED
4996	!	BY A 'DC' OR 'LC' COMMAND.  'LF' AND 'DF' COMMAND STRINGS ARE
4997	!	PASSED TO THE 'SEND_LINE' ROUTINE FOR CONCATENATION ONTO THE
4998	!	COMMAND LINE.
4999	!
5000	! FORMAL PARAMETERS:
5001	!
5002	!	DIAG_FN		= DIAG FUNCTION TO BE USED AS ARGUMENT FIELD IN THE
5003	!			  'LF' COMMAND.  IT SPECIFIES WHICH MICROCODE FIELD
5004	!			  IS TO BE MODIFIED.
5005	!	DATA		= 12-BIT DATA TO BE DEPOSITED INTO SPECIFIED MICRO-
5006	!			  CODE FIELD.  IT IS USED AS ARGUMENT FIELD IN THE
5007	!			  'DF; COMMAND.
5008	!
5009	! IMPLICIT INPUTS:
5010	!
5011	!	NONE
5012	!
5013	! IMPLICIT OUTPUTS:
5014	!
5015	!	NONE
5016	!
5017	! ROUTINE VALUE:
5018	!
5019	!	NONE
5020	!
5021	! SIDE EFFECTS:
5022	!
5023	!	CONCATENATES 'LF' AND 'DF' COMMANDS ONTO THE CUMULATIVE COMMAND
5024	!	LINE. WHEN EXECUTED, THEY WILL WRITE THE SPECIFIED DATA INTO
5025	!	THE SPECIFIED 12-BIT FIELD OF THE MICROCODE.  IF THE 'DIAG_FN'
5026	!	PARAMETER IS OUT OF RANGE, AN ERROR MESSAGE IS PRINTED.
5027	!
5028	!--
5029	    BEGIN
5030	
5031	    OWN
5032		CMD_BUF : CHAR_BUF [13];		!BUFFER FOR COMMAND STRING
5033	
5034	    LOCAL
5035		BUF_PTR;				!BYTE POINTER
5036	
5037	    REGISTER
5038		AC0 = 0;
5039	
5040	    IF (.DIAG_FN LSS 0) OR (.DIAG_FN GTR 7)	!DO A RANGE CHECK ON DIAG FN
5041	    THEN
5042		BEGIN
5043		PRINT_TXT ('TEST #');
5044		PRINT_DEC (.TEST_NUM);
5045		PRINT_CRLF;
5046		PTXT_CRLF ('DIAG FN VALUE OUT OF RANGE IN MOD_FLD CALL');
5047		RETURN;
5048		END;
5049	
5050	    BUF_PTR = POINT (CMD_BUF, 36, 7, 0, 0);	!INIT BYTE POINTER
5051	
5052	!CREATE THE 'LF' AND 'DF' COMMANDS IN THE BUFFER
5053	
5054	    REPLACEI (BUF_PTR, %C'L');
5055	    REPLACEI (BUF_PTR, %C'F');
5056	    REPLACEI (BUF_PTR, .DIAG_FN + %O'60');	!INSERT DIAG FN INTO CMD
5057	    REPLACEI (BUF_PTR, %C',');
5058	    REPLACEI (BUF_PTR, %C'D');
5059	    REPLACEI (BUF_PTR, %C'F');
5060	    BUF_PTR = INSERT_NUM (.BUF_PTR, .DATA, 4);	!INSERT DATA FIELD INTO CMD
5061	    REPLACEI (BUF_PTR, 0);			!TERMINATE THE COMMAND
5062	    SEND_LINE (CMD_BUF, 0);
5063	    END;
5064	
5065	GLOBAL ROUTINE DM_CHK (ADDR, DATA) =
5066	
5067	!++
5068	! FUNCTIONAL DESCRIPTION:
5069	!
5070	!	THIS ROUTINE EXECUTES A DEPOSIT MEMORY, 'DM', COMMAND AND CHECKS
5071	!	THAT NO ERROR RESPONSE IS RECEIVED.
5072	!
5073	! FORMAL PARAMETERS:
5074	!
5075	!	ADDR		= MEMORY ADDRESS TO BE WRITTEN
5076	!	DATA		= 36-BIT DATA TO BE WRITTEN INTO MEMORY
5077	!
5078	! IMPLICIT INPUTS:
5079	!
5080	!	NONE
5081	!
5082	! IMPLICIT OUTPUTS:
5083	!
5084	!	NONE
5085	!
5086	! ROUTINE VALUE:
5087	!
5088	!	0 IF NO ERROR RESPONSE IS RECEIVED.
5089	!	1 IF AN ERROR RESPONSE IS RECEIVED.
5090	!
5091	! SIDE EFFECTS:
5092	!
5093	!	CONCATENATES A 'DM' COMMAND ONTO THE CUMULATIVE COMMAND LINE AND
5094	!	CAUSES THAT LINE TO BE SENT TO THE 8080.
5095	!
5096	!--
5097	    BEGIN
5098	
5099	    LOCAL
5100		RESPONSE;
5101	
5102	    MEM_DEPOSIT (.ADDR, .DATA);			!CONCATENATE 'DM' COMMAND
5103	    RESPONSE = SEND_NUL ();			!FORCE SENDING OF COMMAND LINE
5104	
5105	!IF LEFT HALF OF RESPONSE IS NON-ZERO, IT IS A POINTER TO AN ERROR RESPONSE
5106	!MESSAGE.
5107	
5108	    IF .RESPONSE<18, 18> NEQ 0 THEN RETURN 1;
5109	
5110	    RETURN 0;
5111	
5112	    END;
5113	
5114	GLOBAL ROUTINE MEM_DEPOSIT (ADDR, DATA) : NOVALUE =
5115	
5116	!++
5117	! FUNCTIONAL DESCRIPTION:
5118	!
5119	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED 36-BIT WORD INTO A
5120	!	SPECIFIED MEMORY LOCATION.  IT DOES THIS BY PASSING A LOAD ADDRESS,
5121	!	'LA', COMMAND AND A DEPOSIT MEMORY, 'DM', COMMAND TO THE 'SEND_LINE'
5122	!	ROUTINE FOR CONCATENATION ONTO THE COMMAND LINE.  IF THE LAST MEMORY
5123	!	ADDRESS WHICH WAS REFERENCED IS THE SAME AS THE PRESENT ADDRESS, THEN
5124	!	THE 'LA' COMMAND IS NOT NEEDED.  THE 8080 PROGRAM REMEMBERS THE LAST
5125	!	ADDRESS REFERENCED.
5126	!
5127	! FORMAL PARAMETERS:
5128	!
5129	!	ADDR		= MEMORY ADDRESS TO BE WRITTEN
5130	!	DATA		= 36-BIT DATA TO BE WRITTEN INTO MEMORY
5131	!
5132	! IMPLICIT INPUTS:
5133	!
5134	!	LAST_MEM_ADDR	= MEMORY ADDRESS WHICH WAS REFERENCED LAST BY AN
5135	!			  'EM' OR 'DM' COMMAND.
5136	!
5137	! IMPLICIT OUTPUTS:
5138	!
5139	!	LAST_MEM_ADDR	= MEMORY ADDRESS SPECIFIED IN 'ADDR' PARAMETER
5140	!
5141	! ROUTINE VALUE:
5142	!
5143	!	NONE
5144	!
5145	! SIDE EFFECTS:
5146	!
5147	!	CONCATENATES 'LA' AND 'DM' COMMANDS ONTO THE CUMULATIVE COMMAND
5148	!	LINE.  WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED 36-BIT WORD
5149	!	INTO THE SPECIFIED MEMORY LOCATION.
5150	!
5151	!--
5152	    BEGIN
5153	
5154	    LOCAL
5155		BUF_PTR;				!BYTE POINTER
5156	
5157	    BIND
5158		LA_CMD = UPLIT (%ASCIZ'LA       '),	!'LA' COMMAND STRING SKELETON
5159		DM_CMD = UPLIT (%ASCIZ'DM            '); !'DM' COMMAND STRING SKELETON
5160	
5161	!IF THE PRESENT ADDRESS IS THE SAME AS THE LAST ADDRESS REFERENCED, THE 'LA'
5162	!COMMAND IS NOT NEEDED.
5163	
5164	    IF .ADDR NEQ .LAST_MEM_ADDR
5165	    THEN
5166		BEGIN
5167		BUF_PTR = POINT (LA_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5168		BUF_PTR = INSERT_NUM (.BUF_PTR, .ADDR, 7); !INSERT ADDR FIELD INTO CMD STRING
5169		REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
5170		SEND_LINE (LA_CMD, 0);			!PASS CMD
5171		LAST_MEM_ADDR = .ADDR;			!UPDATE LAST MEM ADDR ACCESSED
5172		END;
5173	
5174	    BUF_PTR = POINT (DM_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5175	    BUF_PTR = INSERT_NUM (.BUF_PTR, .DATA, 12);	!PUT DATA FIELD IN CMD STRING
5176	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
5177	    SEND_LINE (DM_CMD, 0);			!PASS CMD
5178	    END;
5179	
5180	GLOBAL ROUTINE MEM_EXAMINE (ADDR) =
5181	
5182	!++
5183	! FUNCTIONAL DESCRIPTION:
5184	!
5185	!	THIS ROUTINE EXECUTES AN EXAMINE MEMORY, 'EM', COMMAND.  IT CALLS THE
5186	!	'EM' ROUTINE TO CREATE THE 'EM' COMMAND AND CONCATENATE IT ONTO THE
5187	!	COMMAND LINE.
5188	!
5189	! FORMAL PARAMETERS:
5190	!
5191	!	ADDR		= MEMORY ADDRESS TO BE EXAMINED
5192	!
5193	! IMPLICIT INPUTS:
5194	!
5195	!	NONE
5196	!
5197	! IMPLICIT OUTPUTS:
5198	!
5199	!	NONE
5200	!
5201	! ROUTINE VALUE:
5202	!
5203	!	NONE
5204	!
5205	! SIDE EFFECTS:
5206	!
5207	!	CAUSES CONCATENATION OF 'EM' COMMAND ONTO CUMULATIVE COMMAND LINE AND
5208	!	SENDING OF THAT COMMAND LINE.
5209	!
5210	!--
5211	    BEGIN
5212	    RETURN .(EM (.ADDR) + 1);
5213	    END;
5214	
5215	GLOBAL ROUTINE EM_CHK (ADDR) =
5216	
5217	!++
5218	! FUNCTIONAL DESCRIPTION:
5219	!
5220	!	THIS ROUTINE IS CALLED TO EXECUTE AN 'EM' COMMAND AND CHECK FOR
5221	!	A 'NXM' RESPONSE.
5222	!
5223	! FORMAL PARAMETERS:
5224	!
5225	!	ADDR		= MEMORY ADDRESS TO BE EXAMINED
5226	!
5227	! IMPLICIT INPUTS:
5228	!
5229	!	NONE
5230	!
5231	! IMPLICIT OUTPUTS:
5232	!
5233	!	NONE
5234	!
5235	! ROUTINE VALUE:
5236	!
5237	!	0 IF NO ERROR RESPONSE IS RECEIVED.
5238	!	1 IF A 'NXM' ERROR RESPONSE IS RECEIVED.
5239	!
5240	! SIDE EFFECTS:
5241	!
5242	!	CAUSES CONCATENATION OF AN 'EM' COMMAND ONTO THE CUMULATIVE COMMAND
5243	!	LINE AND SENDING OF THAT LINE. IF A NON-NXM ERROR RESPONSE IS RECEIVED,
5244	!	AN ERROR MESSAGE IS PRINTED AND TESTING IS ABORTED.
5245	!
5246	!--
5247	    BEGIN
5248	
5249	    BIND
5250		NXM_MSG = UPLIT (%ASCIZ'?NXM');	!FORMAT FOR 8080 NXM ERROR MESSAGE
5251	
5252	    LOCAL
5253		RESPONSE;
5254	
5255	    RESPONSE = EM (.ADDR);			!GO SEND 'EM' COMMAND
5256	
5257	!IF LEFT HALF OF RESPONSE IS NON-ZERO, ITS A POINTER TO AN ERROR RESPONSE.
5258	!GO CHECK IF ITS A 'NXM' MESSAGE.
5259	
5260	    IF .RESPONSE<18, 18> NEQ 0
5261	    THEN
5262		BEGIN
5263		MSG_CHK (.RESPONSE, NXM_MSG);
5264		RETURN 1
5265		END;
5266	
5267	    RETURN 0;
5268	
5269	    END;
5270	
5271	ROUTINE EM (ADDR) =
5272	
5273	!++
5274	! FUNCTIONAL DESCRIPTION:
5275	!
5276	!	THIS ROUTINE CAUSES EXECUTION OF AN 'EM' COMMAND.  IT PASSES AN
5277	!	'EM' COMMAND STRING TO THE 'SEND_LINE' ROUTINE FOR CONCATENATION ONTO
5278	!	THE COMMAND LINE AND FORCES THE SENDING OF THAT COMMAND LINE.  IF THE
5279	!	LAST MEMORY ADDRESS REFERENCED IS THE SAME AS THE PRESENT ADDRESS,
5280	!	THEN THE ADDRESS FIELD OF THE 'EM' COMMAND IS NOT NEEDED. 
5281	!
5282	!FORMAL PARAMETERS:
5283	!
5284	!	ADDR		= MEMORY ADDRESS TO BE EXAMINED
5285	!
5286	! IMPLICIT INPUTS:
5287	!
5288	!	LAST_MEM_ADDR	= MEMORY ADDRESS WHICH WAS REFERENCED LAST BY AN
5289	!			  'EM' OR 'DM' COMMAND.
5290	!
5291	! IMPLICIT OUTPUTS:
5292	!
5293	!	LAST_MEM_ADDR	= MEMORY ADDRESS SPECIFIED IN 'ADDR' PARAMETER
5294	!
5295	! ROUTINE VALUE:
5296	!
5297	!	POINTER TO THE BLOCK OF DATA RETURNED BY THE 'EM' COMMAND.
5298	!
5299	!	POINTER -> ADDR
5300	!		   DATA
5301	!
5302	! SIDE EFFECTS:
5303	!
5304	!	CONCATENATES 'EM' COMMAND ONTO CUMULATIVE COMMAND LINE AND FORCES
5305	!	SENDING OF THAT LINE.
5306	!
5307	!--
5308	    BEGIN
5309	
5310	    LOCAL
5311		BUF_PTR;				!BYTE POINTER
5312	
5313	    BIND
5314		EM_CMD = UPLIT (%ASCIZ'EM       ');	!'EM' CMD STRING SKELETON
5315	
5316	    BUF_PTR = POINT (EM_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5317	
5318	!IF LAST ADDRESS REFERENCED IS SAME AS PRESENT ADDRESS, THE ADDR FIELD IS
5319	!NOT NEEDED.
5320	
5321	    IF .ADDR NEQ .LAST_MEM_ADDR
5322	    THEN
5323		BEGIN
5324		BUF_PTR = INSERT_NUM (.BUF_PTR, .ADDR, 7); !INSERT ADDR FIELD ON CMD STRING
5325		LAST_MEM_ADDR = .ADDR;			!UPDATE LAST MEM ADDR ACCESSED
5326		END;
5327	
5328	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
5329	    RETURN SEND_LINE (EM_CMD, EM_AC);		!PASS CMD
5330	    END;
5331	ROUTINE MSG_CHK (RESPONSE, MSG) : NOVALUE =
5332	
5333	!++
5334	! FUNCTIONAL DESCRIPTION:
5335	!
5336	!	THIS ROUTINE COMPARES A RECEIVED ERROR RESPONSE WITH AN EXPECTED
5337	!	ERROR RESPONSE.
5338	!
5339	! FORMAL PARAMETERS:
5340	!
5341	!	RESPONSE	= BYTE POINTER TO RECEIVED RESPONSE
5342	!	MSG		= POINTER TO EXPECTED RESPONSE
5343	!
5344	! IMPLICIT INPUTS:
5345	!
5346	!	NONE
5347	!
5348	! IMPLICIT OUTPUTS:
5349	!
5350	!	NONE
5351	!
5352	! ROUTINE VALUE:
5353	!
5354	!	NONE
5355	!
5356	! SIDE EFFECTS:
5357	!
5358	!	IF THE RECEIVED RESPONSE IS NOT THE SAME AS THE EXPECTED RESPONSE,
5359	!	THEN THE 'PRT_ERR' ROUTINE IS CALLED TO PRINT AN ERROR MESSAGE AND
5360	!	ABORT TESTING.
5361	!
5362	!--
5363	    BEGIN
5364	
5365	    LOCAL
5366		MSG_PTR,				!BYTE POINTER TO EXPECTED RESPONSE
5367		SAV_PTR;				!SAVED BYTE POINTER
5368	
5369	    MSG_PTR = POINT (.MSG, 36, 7, 0, 0);	!SETUP POINTER TO EXPECTED RESPONSE
5370	    SAV_PTR = .RESPONSE;			!SAVE POINTER TO RECEIVED RESPONSE
5371	
5372	!COMPARE RECEIVED WITH EXPECTED RESPONSE ONE CHAR AT A TIME.  IF MISMATCH IS
5373	!FOUND, REPORT ERROR AND ABORT.
5374	    INCR I FROM 0 TO 3 BY 1 DO
5375	
5376		IF SCANI (MSG_PTR) NEQ SCANI (RESPONSE) THEN PRT_ERR (.SAV_PTR);
5377	
5378	    END;
5379	
5380	GLOBAL ROUTINE DN (DATA) : NOVALUE =
5381	
5382	!++
5383	! FUNCTIONAL DESCRIPTION:
5384	!
5385	!	THIS ROUTINE CONCATENATES A DEPOSIT NEXT, 'DN', COMMAND STRING ONTO
5386	!	THE COMMAND LINE.
5387	!
5388	! FORMAL PARAMETERS:
5389	!
5390	!	DATA		= 36-BIT DATA TO BE DEPOSITED
5391	!
5392	! IMPLICIT INPUTS:
5393	!
5394	!	NONE
5395	!
5396	! IMPLICIT OUTPUTS:
5397	!
5398	!	LAST_MEM_ADDR	= -1, TO INVALIDATE LAST MEM ADDRESS REFERENCED
5399	!	LAST_IO_ADDR	= -1, TO INVALIDATE LAST I/O ADDRESS REFERENCED
5400	!
5401	! ROUTINE VALUE:
5402	!
5403	!	NONE
5404	!
5405	! SIDE EFFECTS:
5406	!
5407	!	CONCATENATES A 'DN' COMMAND ONTO CUMULATIVE COMMAND LINE.  WHEN
5408	!	EXECUTED, IT WILL DEPOSIT THE SPECIFIED DATA INTO THE NEXT MEMORY
5409	!	LOCATION OR I/O REGISTER, DEPENDING ON THE ORIGINAL DEPOSIT COMMAND.
5410	!
5411	!--
5412	    BEGIN
5413	
5414	    LOCAL
5415		BUF_PTR;				!BYTE POINTER
5416	
5417	    BIND
5418		DN_CMD = UPLIT (%ASCIZ'DN            '); !'DN' COMMAND SKELETON
5419	
5420	    LAST_MEM_ADDR = -1;				!WIPE OUT LAST ADDRESSES
5421	    LAST_IO_ADDR = -1;
5422	    BUF_PTR = POINT (DN_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5423	    BUF_PTR = INSERT_NUM (.BUF_PTR, .DATA, 12);	!PUT DATA FIELD IN CMD
5424	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
5425	    SEND_LINE (DN_CMD, 0);			!PASS CMD
5426	    END;
5427	
5428	GLOBAL ROUTINE IO_DEPOSIT (ADDR, DATA) : NOVALUE =
5429	
5430	!++
5431	! FUNCTIONAL DESCRIPTION:
5432	!
5433	!	THIS ROUTINE IS CALLED TO PERFORM AN I/O DEPOSIT COMMAND.  IT
5434	!	PASSES 'LI' AND 'DI' COMMAND STRINGS TO THE 'SEND_LINE' ROUTINE FOR
5435	!	CONCATENATION ONTO THE COMMAND LINE.  IF THE LAST I/O REGISTER ADDR
5436	!	REFERENCED IS THE SAME AS THE PRESENT ADDR, THEN THE 'LI' COMMAND IS
5437	!	NOT NEEDED.
5438	!
5439	! FORMAL PARAMETERS:
5440	!
5441	!	ADDR		= I/O REGISTER ADDR TO BE WRITTEN
5442	!	DATA		= 36-BIT DATA TO BE WRITTEN
5443	!
5444	! IMPLICIT INPUTS:
5445	!
5446	!	LAST_IO_ADDR	= LAST I/O REGISTER ADDR REFERENCED BY AN 'EI' OR
5447	!			  'DI' COMMAND.
5448	!
5449	! IMPLICIT OUTPUTS:
5450	!
5451	!	LAST_IO_ADDR	= I/O REGISTER ADDRESS SPECIFIED IN 'ADDR' PARAMETER
5452	!
5453	! ROUTINE VALUE:
5454	!
5455	!	NONE
5456	!
5457	! SIDE EFFECTS:
5458	!
5459	!	CONCATENATES 'LI' AND 'DI' COMMANDS ONTO THE CUMULATIVE COMMAND
5460	!	LINE.  WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO THE
5461	!	SPECIFIED I/O REGISTER ADDRESS.
5462	!
5463	!--
5464	    BEGIN
5465	
5466	    LOCAL
5467		BUF_PTR;				!BYTE POINTER
5468	
5469	    BIND
5470		LI_CMD = UPLIT (%ASCIZ'LI        '),	!'LI' CMD STRING SKELETON
5471		DI_CMD = UPLIT (%ASCIZ'DI            '); !'DI' CMD STRING SKELETON
5472	
5473	!IF PRESENT I/O ADDR IS SAME AS LAST REFERENCED I/O ADDR, THEN 'LI' COMMAND
5474	!IS NOT NEEDED.
5475	
5476	    IF .ADDR NEQ .LAST_IO_ADDR
5477	    THEN
5478		BEGIN
5479		BUF_PTR = POINT (LI_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5480		BUF_PTR = INSERT_NUM (.BUF_PTR, .ADDR, 8); !INSERT ADDR FIELD INTO CMD
5481		REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
5482		SEND_LINE (LI_CMD, 0);			!PASS CMD
5483		LAST_IO_ADDR = .ADDR;			!UPDATE LAST IO ADDR ACCESSED
5484		END;
5485	
5486	    BUF_PTR = POINT (DI_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5487	    BUF_PTR = INSERT_NUM (.BUF_PTR, .DATA, 12);	!PUT DATA FIELD IN CMD
5488	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
5489	    SEND_LINE (DI_CMD, 0);			!PASS CMD
5490	    END;
5491	
5492	GLOBAL ROUTINE IO_EXAMINE (ADDR) =
5493	
5494	!++
5495	! FUNCTIONAL DESCRIPTION:
5496	!
5497	!	THIS ROUTINE IS CALLED TO EXAMINE A SPECIFIED I/O REGISTER.  IT CALLS
5498	!	THE 'EI' ROUTINE TO GENERATE AN 'EI' COMMAND AND CONCATENATE IT ONTO
5499	!	THE COMMAND LINE.
5500	!
5501	! FORMAL PARAMETERS:
5502	!
5503	!	ADDR		= I/O REGISTER ADDRESS TO BE EXAMINED
5504	!
5505	! IMPLICIT INPUTS:
5506	!
5507	!	NONE
5508	!
5509	! IMPLICIT OUTPUTS:
5510	!
5511	!	NONE
5512	!
5513	! ROUTINE VALUE:
5514	!
5515	!	CONTENTS OF EXAMINED I/O REGISTER
5516	!
5517	! SIDE EFFECTS:
5518	!
5519	!	CONCATENATES AN 'EI' COMMAND ONTO THE CUMULATIVE COMMAND LINE AND
5520	!	FORCES THAT LINE TO BE SENT.
5521	!
5522	!--
5523	    BEGIN
5524	    RETURN .(EI (.ADDR) + 1);			!SEND 'EI' CMD AND RETURN RESULTS
5525	    END;
5526	
5527	ROUTINE EI (ADDR) =
5528	
5529	!++
5530	! FUNCTIONAL DESCRIPTION:
5531	!
5532	!	THIS ROUTINE CREATES AN 'EI' COMMAND AND CALLS THE 'SEND_LINE'
5533	!	ROUTINE TO CONCATENATE IT TO THE COMMAND LINE AND SEND THAT LINE.
5534	!	IF THE REGISTER ADDR IS THE SAME AS THE LAST REGISTER ADDR, THEN
5535	!	THE ADDR FIELD OF THE COMMAND STRING IS NOT NEEDED.
5536	!
5537	! FORMAL PARAMETERS:
5538	!
5539	!	ADDR		= I/O REGISTER ADDRESS TO BE EXAMINED.
5540	!
5541	! IMPLICIT INPUTS:
5542	!
5543	!	LAST_IO_ADDR	= LAST I/O REGISTER ADDR REFERENCED BY AN 'EI' OR
5544	!			  'DI' COMMAND.
5545	!
5546	! IMPLICIT OUTPUTS:
5547	!
5548	!	LAST_IO_ADDR	= I/O REGISTER ADDRESS SPECIFIED IN 'ADDR' PARAMETER
5549	!
5550	! ROUTINE VALUE:
5551	!
5552	!	POINTER TO BLOCK OF DATA RETURNED BY 'EI' COMMAND
5553	!
5554	!	POINTER -> I/O ADDR
5555	!		   DATA
5556	!
5557	! SIDE EFFECTS:
5558	!
5559	!	CONCATENATES AN 'EI' COMMAND ONTO THE CUMULATIVE COMMAND LINE
5560	!	AND FORCES SENDING OF THAT LINE.
5561	!
5562	!--
5563	    BEGIN
5564	
5565	    LOCAL
5566		BUF_PTR;				!BYTE POINTER
5567	
5568	    BIND
5569		EI_CMD = UPLIT (%ASCIZ'EI        ');	!'EI' CMD STRING SKELETON
5570	
5571	    BUF_PTR = POINT (EI_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5572	
5573	!IF PRESENT I/O ADDR IS SAME AS LAST REFERENCED I/O ADDR, THEN THE ADDR FIELD
5574	!IS NOT NEEDED.
5575	
5576	    IF .ADDR NEQ .LAST_IO_ADDR
5577	    THEN
5578		BEGIN
5579		BUF_PTR = INSERT_NUM (.BUF_PTR, .ADDR, 8); !INSERT ADDR FIELD IN CMD STRING
5580		LAST_IO_ADDR = .ADDR;			!UPDATE LAST IO ADDR ACCESSED
5581		END;
5582	
5583	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
5584	    RETURN SEND_LINE (EI_CMD, EI_AC);		!PASS CMD
5585	    END;
5586	
5587	GLOBAL ROUTINE EI_CHK (ADDR) =
5588	
5589	!++
5590	! FUNCTIONAL DESCRIPTION:
5591	!
5592	!	THIS ROUTINE IS CALLED TO EXECUTE AN 'EI' COMMAND AND CHECK FOR
5593	!	AN '?NDA' ERROR RESPONSE.
5594	!
5595	! FORMAL PARAMETERS:
5596	!
5597	!	ADDR		= I/O REGISTER ADDRESS TO BE EXAMINED.
5598	!
5599	! IMPLICIT INPUTS:
5600	!
5601	!	NONE
5602	!
5603	! IMPLICIT OUTPUTS:
5604	!
5605	!	NONE
5606	!
5607	! ROUTINE VALUE:
5608	!
5609	!	0 IF NO ERROR RESPONSE IS RECEIVED
5610	!	1 IF AN '?NDA' ERROR RESPONSE IS RECEIVED
5611	!
5612	! SIDE EFFECTS:
5613	!
5614	!	CONCATENATES AN 'EI' COMMAND ONTO THE CUMULATIVE COMMAND LINE AND
5615	!	FORCES THE SENDING OF THAT LINE.  IF AN ERROR RESPONSE OTHER THAN
5616	!	'?NDA' IS RECEIVED, AN ERROR MESSAGE IS PRINTED ON THE TTY AND 
5617	!	TESTING IS ABORTED.
5618	!
5619	!--
5620	    BEGIN
5621	
5622	    BIND
5623		NDA_MSG = UPLIT (%ASCIZ'?NDA');	!FORMAT FOR 8080 NO DATA ACK MESSAGE
5624	
5625	    LOCAL
5626		RESPONSE;
5627	
5628	    RESPONSE = EI (.ADDR);			!EXECUTE 'EI' COMMAND
5629	
5630	!IF LEFT HALF OF RESPONSE IS NON-ZERO, THEN IT IS A BYTE POINTER TO AN
5631	!ERROR RESPONSE.  GO CHECK IF THAT RESPONSE IS '?NDA'.
5632	
5633	    IF .RESPONSE<18, 18> NEQ 0
5634	    THEN
5635		BEGIN
5636		MSG_CHK (.RESPONSE, NDA_MSG);		!GO CHECK FOR ?NDA
5637		RETURN 1				!GIVE '?NDA RECEIVED' RETURN
5638		END;
5639	
5640	    RETURN 0;					!GIVE 'NO ERROR RESPONSE' RETURN
5641	
5642	    END;
5643	
5644	ROUTINE INSERT_NUM (BUF_PTR, NUM, DIGITS) =
5645	
5646	!++
5647	! FUNCTIONAL DESCRIPTION:
5648	!
5649	!	THIS ROUTINE INSERTS AN ARGUMENT FIELD INTO A COMMAND STRING.  IT
5650	!	CONVERTS A PASSED BINARY VALUE INTO AN ASCII DIGITS.
5651	!
5652	! FORMAL PARAMETERS:
5653	!
5654	!	BUF_PTR		= BYTE POINTER TO POSITION IN CMD STRING WHERE
5655	!			  ARGUMENT FIELD IS TO BE INSERTED
5656	!	NUM		= BINARY VALUE OF ARGUMENT FIELD
5657	!	DIGITS		= NUMBER OF ASCII DIGITS TO BE INSERTED
5658	!
5659	! IMPLICIT INPUTS:
5660	!
5661	!	NONE
5662	!
5663	! IMPLICIT OUTPUTS:
5664	!
5665	!	NONE
5666	!
5667	! ROUTINE VALUE:
5668	!
5669	!	BYTE POINTED UPDATED TO NEXT POSITION AFTER LAST DIGIT IN THE
5670	!	INSERTED ARGUMENT FIELD.
5671	!
5672	! SIDE EFFECTS:
5673	!
5674	!	INSERT ASCII ARGUMENT FIELD INTO SPECIFIED COMMAND STRING.
5675	!
5676	!--
5677	    BEGIN
5678	
5679	    LOCAL
5680		SWITCH,					!FLAG INDICATING WHETHER OR NOT INSERTION HAS STARTED
5681		TEMP;					!TEMP STORAGE FOR ASCII DIGIT
5682	
5683	    SWITCH = 0;					!INIT FLAG TO SHOW INSERTION HASN'T STARTED
5684	
5685	!THE DIGITS ARE INSERTED FROM LEFT TO RIGHT - HIGH ORDER TO LOW ORDER.  SO THE
5686	!PASSED NUMBER TO BE INSERTED IS PROCESSED FROM LEFT TO RIGHT IN 3-BIT
5687	!QUANTITIES.  LEADING ZEROS ARE NOT INSERTED.  WHEN THE FIRST NON-ZERO DIGIT
5688	!IS INSERTED, THE 'SWITCH' FLAG IS SET SO ALL SUBSEQUENT DIGITS ARE INSERTED,
5689	!ZERO OR NOT.
5690	
5691	    DECR I FROM .DIGITS TO 1 DO
5692		BEGIN
5693		TEMP = .NUM<(.I - 1)*3, 3>;		!GET NEXT OCTAL DIGIT
5694	
5695		IF (.TEMP NEQ 0) OR (.SWITCH EQL 1) OR (.I EQL 1)
5696		THEN
5697		    BEGIN
5698		    REPLACEI (BUF_PTR, .TEMP + %O'60');
5699		    SWITCH = 1;
5700		    END;
5701	
5702		END;
5703	
5704	    RETURN .BUF_PTR;				!RETURN UPDATED BUFFER POINTER
5705	    END;
5706	
5707	GLOBAL ROUTINE REG_EXAMINE (REG_ADDR) =
5708	
5709	!++
5710	! FUNCTIONAL DESCRIPTION:
5711	!
5712	!	THIS ROUTINE CREATES AN EXAMINE REGISTER, 'ER', COMMAND AND CALLS
5713	!	THE 'SEND_LINE' ROUTINE TO CONCATENATE IT ONTO THE COMMAND LINE AND
5714	!	SEND IT TO THE 8080.  IF THE 8080 REGISTER ADDRESS IS THE SAME AS
5715	!	THE LAST REGISTER REFERENCED, THEN THE ADDRESS FIELD IS NOT NEEDED.
5716	!
5717	! FORMAL PARAMETERS:
5718	!
5719	!	ADDR		= 8080 REGISTER ADDRESS TO BE EXAMINED
5720	!
5721	! IMPLICIT INPUTS:
5722	!
5723	!	LAST_REG_ADDR	= 8080 REGISTER ADDRESS WHICH WAS LAST REFERENCED BY
5724	!			  AN 'ER' OR 'LR' COMMAND.
5725	!
5726	! IMPLICIT OUTPUTS:
5727	!
5728	!	LAST_REG_ADDR	= 8080 REGISTER ADDRESS SPECIFIED IN 'ADDR' PARAMETER
5729	!
5730	! ROUTINE VALUE:
5731	!
5732	!	CONTENTS OF 8080 REGISTER WHICH WAS EXAMINED
5733	!
5734	! SIDE EFFECTS:
5735	!
5736	!	CONCATENATES AN 'ER' COMMAND ONTO THE CUMULATIVE COMMAND LINE AND
5737	!	FORCES SENDING OF THAT LINE.
5738	!
5739	!--
5740	    BEGIN
5741	
5742	    LOCAL
5743		BUF_PTR,				!BYTE POINTER
5744		RESPONSE;				!TEMP STORAGE FOR RESPONSE
5745	
5746	    BIND
5747		ER_CMD = UPLIT (%ASCIZ'ER   ');		!'ER' CMD STRING SKELETON
5748	
5749	    BUF_PTR = POINT (ER_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
5750	
5751	!IF REGISTER ADDRESS IS THE SAME AS THE LAST REFERENCED REGISTER ADDRES, THEN
5752	!THE ADDRESS FIELD IS NOT NEEDED.
5753	
5754	    IF .LAST_REG_ADDR NEQ .REG_ADDR
5755	    THEN
5756		BEGIN
5757		BUF_PTR = INSERT_NUM (.BUF_PTR, .REG_ADDR, 3); !INSERT ADDR FIELD
5758		LAST_REG_ADDR = .REG_ADDR;		!UPDATE LAST REG ADDR
5759		END;
5760	
5761	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD STRING
5762	    RESPONSE = SEND_LINE (ER_CMD, ER_AC);	!SEND CMD AND GET RESPONSE
5763	    RETURN .(.RESPONSE + 1);			!RETURN JUST REG CONTENTS
5764	    END;
5765	
5766	GLOBAL ROUTINE WRT100 (DATA) : NOVALUE =
5767	
5768	!++
5769	! FUNCTIONAL DESCRIPTION:
5770	!
5771	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
5772	!	100.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
5773	!	COMMANDS.
5774	!
5775	! FORMAL PARAMETERS:
5776	!
5777	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 100
5778	!
5779	! IMPLICIT INPUTS:
5780	!
5781	!	NONE
5782	!
5783	! IMPLICIT OUTPUTS:
5784	!
5785	!	NONE
5786	!
5787	! ROUTINE VALUE:
5788	!
5789	!	NONE
5790	!
5791	! SIDE EFFECTS:
5792	!
5793	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
5794	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 100.
5795	!
5796	!--
5797	    BEGIN
5798	    REG_DEPOSIT (%O'100',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
5799	    END;
5800	
5801	GLOBAL ROUTINE WRT102 (DATA) : NOVALUE =
5802	
5803	!++
5804	! FUNCTIONAL DESCRIPTION:
5805	!
5806	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
5807	!	102.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
5808	!	COMMANDS.
5809	!
5810	! FORMAL PARAMETERS:
5811	!
5812	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 102
5813	!
5814	! IMPLICIT INPUTS:
5815	!
5816	!	NONE
5817	!
5818	! IMPLICIT OUTPUTS:
5819	!
5820	!	NONE
5821	!
5822	! ROUTINE VALUE:
5823	!
5824	!	NONE
5825	!
5826	! SIDE EFFECTS:
5827	!
5828	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
5829	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 102.
5830	!
5831	!--
5832	    BEGIN
5833	    REG_DEPOSIT (%O'102',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
5834	    END;
5835	
5836	GLOBAL ROUTINE WRT103 (DATA) : NOVALUE =
5837	
5838	!++
5839	! FUNCTIONAL DESCRIPTION:
5840	!
5841	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
5842	!	103.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
5843	!	COMMANDS.
5844	!
5845	! FORMAL PARAMETERS:
5846	!
5847	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 103
5848	!
5849	! IMPLICIT INPUTS:
5850	!
5851	!	NONE
5852	!
5853	! IMPLICIT OUTPUTS:
5854	!
5855	!	NONE
5856	!
5857	! ROUTINE VALUE:
5858	!
5859	!	NONE
5860	!
5861	! SIDE EFFECTS:
5862	!
5863	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
5864	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 103.
5865	!
5866	!--
5867	    BEGIN
5868	    REG_DEPOSIT (%O'103',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
5869	    END;
5870	
5871	GLOBAL ROUTINE WRT104 (DATA) : NOVALUE =
5872	
5873	!++
5874	! FUNCTIONAL DESCRIPTION:
5875	!
5876	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
5877	!	104.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
5878	!	COMMANDS.
5879	!
5880	! FORMAL PARAMETERS:
5881	!
5882	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 104
5883	!
5884	! IMPLICIT INPUTS:
5885	!
5886	!	NONE
5887	!
5888	! IMPLICIT OUTPUTS:
5889	!
5890	!	NONE
5891	!
5892	! ROUTINE VALUE:
5893	!
5894	!	NONE
5895	!
5896	! SIDE EFFECTS:
5897	!
5898	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
5899	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 104.
5900	!
5901	!--
5902	    BEGIN
5903	    REG_DEPOSIT (%O'104',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
5904	    END;
5905	
5906	GLOBAL ROUTINE WRT105 (DATA) : NOVALUE =
5907	
5908	!++
5909	! FUNCTIONAL DESCRIPTION:
5910	!
5911	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
5912	!	105.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
5913	!	COMMANDS.
5914	!
5915	! FORMAL PARAMETERS:
5916	!
5917	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 105
5918	!
5919	! IMPLICIT INPUTS:
5920	!
5921	!	NONE
5922	!
5923	! IMPLICIT OUTPUTS:
5924	!
5925	!	NONE
5926	!
5927	! ROUTINE VALUE:
5928	!
5929	!	NONE
5930	!
5931	! SIDE EFFECTS:
5932	!
5933	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
5934	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 105.
5935	!
5936	!--
5937	    BEGIN
5938	    REG_DEPOSIT (%O'105',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
5939	    END;
5940	
5941	GLOBAL ROUTINE WRT106 (DATA) : NOVALUE =
5942	
5943	!++
5944	! FUNCTIONAL DESCRIPTION:
5945	!
5946	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
5947	!	106.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
5948	!	COMMANDS.
5949	!
5950	! FORMAL PARAMETERS:
5951	!
5952	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 106
5953	!
5954	! IMPLICIT INPUTS:
5955	!
5956	!	NONE
5957	!
5958	! IMPLICIT OUTPUTS:
5959	!
5960	!	NONE
5961	!
5962	! ROUTINE VALUE:
5963	!
5964	!	NONE
5965	!
5966	! SIDE EFFECTS:
5967	!
5968	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
5969	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 106.
5970	!
5971	!--
5972	    BEGIN
5973	    REG_DEPOSIT (%O'106',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
5974	    END;
5975	
5976	GLOBAL ROUTINE WRT107 (DATA) : NOVALUE =
5977	
5978	!++
5979	! FUNCTIONAL DESCRIPTION:
5980	!
5981	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
5982	!	107.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
5983	!	COMMANDS.
5984	!
5985	! FORMAL PARAMETERS:
5986	!
5987	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 107
5988	!
5989	! IMPLICIT INPUTS:
5990	!
5991	!	NONE
5992	!
5993	! IMPLICIT OUTPUTS:
5994	!
5995	!	NONE
5996	!
5997	! ROUTINE VALUE:
5998	!
5999	!	NONE
6000	!
6001	! SIDE EFFECTS:
6002	!
6003	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6004	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 107.
6005	!
6006	!--
6007	    BEGIN
6008	    REG_DEPOSIT (%O'107',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6009	    END;
6010	
6011	GLOBAL ROUTINE WRT110 (DATA) : NOVALUE =
6012	
6013	!++
6014	! FUNCTIONAL DESCRIPTION:
6015	!
6016	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6017	!	110.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6018	!	COMMANDS.
6019	!
6020	! FORMAL PARAMETERS:
6021	!
6022	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 110
6023	!
6024	! IMPLICIT INPUTS:
6025	!
6026	!	NONE
6027	!
6028	! IMPLICIT OUTPUTS:
6029	!
6030	!	NONE
6031	!
6032	! ROUTINE VALUE:
6033	!
6034	!	NONE
6035	!
6036	! SIDE EFFECTS:
6037	!
6038	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6039	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 110.
6040	!
6041	!--
6042	    BEGIN
6043	    REG_DEPOSIT (%O'110',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6044	    END;
6045	
6046	GLOBAL ROUTINE WRT111 (DATA) : NOVALUE =
6047	
6048	!++
6049	! FUNCTIONAL DESCRIPTION:
6050	!
6051	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6052	!	111.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6053	!	COMMANDS.
6054	!
6055	! FORMAL PARAMETERS:
6056	!
6057	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 111
6058	!
6059	! IMPLICIT INPUTS:
6060	!
6061	!	NONE
6062	!
6063	! IMPLICIT OUTPUTS:
6064	!
6065	!	NONE
6066	!
6067	! ROUTINE VALUE:
6068	!
6069	!	NONE
6070	!
6071	! SIDE EFFECTS:
6072	!
6073	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6074	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 111.
6075	!
6076	!--
6077	    BEGIN
6078	    REG_DEPOSIT (%O'111',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6079	    END;
6080	
6081	GLOBAL ROUTINE WRT112 (DATA) : NOVALUE =
6082	
6083	!++
6084	! FUNCTIONAL DESCRIPTION:
6085	!
6086	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6087	!	112.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6088	!	COMMANDS.
6089	!
6090	! FORMAL PARAMETERS:
6091	!
6092	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 112
6093	!
6094	! IMPLICIT INPUTS:
6095	!
6096	!	NONE
6097	!
6098	! IMPLICIT OUTPUTS:
6099	!
6100	!	NONE
6101	!
6102	! ROUTINE VALUE:
6103	!
6104	!	NONE
6105	!
6106	! SIDE EFFECTS:
6107	!
6108	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6109	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 112.
6110	!
6111	!--
6112	    BEGIN
6113	    REG_DEPOSIT (%O'112',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6114	    END;
6115	
6116	GLOBAL ROUTINE WRT113 (DATA) : NOVALUE =
6117	
6118	!++
6119	! FUNCTIONAL DESCRIPTION:
6120	!
6121	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6122	!	113.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6123	!	COMMANDS.
6124	!
6125	! FORMAL PARAMETERS:
6126	!
6127	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 113
6128	!
6129	! IMPLICIT INPUTS:
6130	!
6131	!	NONE
6132	!
6133	! IMPLICIT OUTPUTS:
6134	!
6135	!	NONE
6136	!
6137	! ROUTINE VALUE:
6138	!
6139	!	NONE
6140	!
6141	! SIDE EFFECTS:
6142	!
6143	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6144	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 113.
6145	!
6146	!--
6147	    BEGIN
6148	    REG_DEPOSIT (%O'113',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6149	    END;
6150	
6151	GLOBAL ROUTINE WRT114 (DATA) : NOVALUE =
6152	
6153	!++
6154	! FUNCTIONAL DESCRIPTION:
6155	!
6156	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6157	!	114.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6158	!	COMMANDS.
6159	!
6160	! FORMAL PARAMETERS:
6161	!
6162	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 114
6163	!
6164	! IMPLICIT INPUTS:
6165	!
6166	!	NONE
6167	!
6168	! IMPLICIT OUTPUTS:
6169	!
6170	!	NONE
6171	!
6172	! ROUTINE VALUE:
6173	!
6174	!	NONE
6175	!
6176	! SIDE EFFECTS:
6177	!
6178	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6179	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 114.
6180	!
6181	!--
6182	    BEGIN
6183	    REG_DEPOSIT (%O'114',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6184	    END;
6185	
6186	GLOBAL ROUTINE WRT115 (DATA) : NOVALUE =
6187	
6188	!++
6189	! FUNCTIONAL DESCRIPTION:
6190	!
6191	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6192	!	115.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6193	!	COMMANDS.
6194	!
6195	! FORMAL PARAMETERS:
6196	!
6197	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 115
6198	!
6199	! IMPLICIT INPUTS:
6200	!
6201	!	NONE
6202	!
6203	! IMPLICIT OUTPUTS:
6204	!
6205	!	NONE
6206	!
6207	! ROUTINE VALUE:
6208	!
6209	!	NONE
6210	!
6211	! SIDE EFFECTS:
6212	!
6213	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6214	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 115.
6215	!
6216	!--
6217	    BEGIN
6218	    REG_DEPOSIT (%O'115',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6219	    END;
6220	
6221	GLOBAL ROUTINE WRT116 (DATA) : NOVALUE =
6222	
6223	!++
6224	! FUNCTIONAL DESCRIPTION:
6225	!
6226	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6227	!	116.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6228	!	COMMANDS.
6229	!
6230	! FORMAL PARAMETERS:
6231	!
6232	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 116
6233	!
6234	! IMPLICIT INPUTS:
6235	!
6236	!	NONE
6237	!
6238	! IMPLICIT OUTPUTS:
6239	!
6240	!	NONE
6241	!
6242	! ROUTINE VALUE:
6243	!
6244	!	NONE
6245	!
6246	! SIDE EFFECTS:
6247	!
6248	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6249	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 116.
6250	!
6251	!--
6252	    BEGIN
6253	    REG_DEPOSIT (%O'116',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6254	    END;
6255	
6256	GLOBAL ROUTINE WRT204 (DATA) : NOVALUE =
6257	
6258	!++
6259	! FUNCTIONAL DESCRIPTION:
6260	!
6261	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6262	!	204.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6263	!	COMMANDS.
6264	!
6265	! FORMAL PARAMETERS:
6266	!
6267	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 204
6268	!
6269	! IMPLICIT INPUTS:
6270	!
6271	!	NONE
6272	!
6273	! IMPLICIT OUTPUTS:
6274	!
6275	!	NONE
6276	!
6277	! ROUTINE VALUE:
6278	!
6279	!	NONE
6280	!
6281	! SIDE EFFECTS:
6282	!
6283	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6284	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 204.
6285	!
6286	!--
6287	    BEGIN
6288	    REG_DEPOSIT (%O'204',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6289	    END;
6290	
6291	GLOBAL ROUTINE WRT205 (DATA) : NOVALUE =
6292	
6293	!++
6294	! FUNCTIONAL DESCRIPTION:
6295	!
6296	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6297	!	205.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6298	!	COMMANDS.
6299	!
6300	! FORMAL PARAMETERS:
6301	!
6302	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 205
6303	!
6304	! IMPLICIT INPUTS:
6305	!
6306	!	NONE
6307	!
6308	! IMPLICIT OUTPUTS:
6309	!
6310	!	NONE
6311	!
6312	! ROUTINE VALUE:
6313	!
6314	!	NONE
6315	!
6316	! SIDE EFFECTS:
6317	!
6318	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6319	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 205.
6320	!
6321	!--
6322	    BEGIN
6323	    REG_DEPOSIT (%O'205',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6324	    END;
6325	
6326	GLOBAL ROUTINE WRT206 (DATA) : NOVALUE =
6327	
6328	!++
6329	! FUNCTIONAL DESCRIPTION:
6330	!
6331	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6332	!	206.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6333	!	COMMANDS.
6334	!
6335	! FORMAL PARAMETERS:
6336	!
6337	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 206
6338	!
6339	! IMPLICIT INPUTS:
6340	!
6341	!	NONE
6342	!
6343	! IMPLICIT OUTPUTS:
6344	!
6345	!	NONE
6346	!
6347	! ROUTINE VALUE:
6348	!
6349	!	NONE
6350	!
6351	! SIDE EFFECTS:
6352	!
6353	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6354	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 206.
6355	!
6356	!--
6357	    BEGIN
6358	    REG_DEPOSIT (%O'206',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6359	    END;
6360	
6361	GLOBAL ROUTINE WRT210 (DATA) : NOVALUE =
6362	
6363	!++
6364	! FUNCTIONAL DESCRIPTION:
6365	!
6366	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6367	!	210.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6368	!	COMMANDS.
6369	!
6370	! FORMAL PARAMETERS:
6371	!
6372	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 210
6373	!
6374	! IMPLICIT INPUTS:
6375	!
6376	!	NONE
6377	!
6378	! IMPLICIT OUTPUTS:
6379	!
6380	!	NONE
6381	!
6382	! ROUTINE VALUE:
6383	!
6384	!	NONE
6385	!
6386	! SIDE EFFECTS:
6387	!
6388	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6389	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 210.
6390	!
6391	!--
6392	    BEGIN
6393	    REG_DEPOSIT (%O'210',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6394	    END;
6395	
6396	GLOBAL ROUTINE WRT212 (DATA) : NOVALUE =
6397	
6398	!++
6399	! FUNCTIONAL DESCRIPTION:
6400	!
6401	!	THIS ROUTINE IS CALLED TO DEPOSIT A SPECIFIED VALUE INTO 8080 REGISTER
6402	!	212.  IT CALLS THE 'REG_DEPOSIT' ROUTINE TO CREATE 'LR' AND 'DR'
6403	!	COMMANDS.
6404	!
6405	! FORMAL PARAMETERS:
6406	!
6407	!	DATA		= DATA TO BE DEPOSITED INTO 8080 REGISTER 212
6408	!
6409	! IMPLICIT INPUTS:
6410	!
6411	!	NONE
6412	!
6413	! IMPLICIT OUTPUTS:
6414	!
6415	!	NONE
6416	!
6417	! ROUTINE VALUE:
6418	!
6419	!	NONE
6420	!
6421	! SIDE EFFECTS:
6422	!
6423	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6424	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO REGISTER 212.
6425	!
6426	!--
6427	    BEGIN
6428	    REG_DEPOSIT (%O'212',.DATA);		!GO MAKE 'LR' AND 'DR' CMDS
6429	    END;
6430	ROUTINE REG_DEPOSIT (REG_ADDR,DATA) : NOVALUE =
6431	
6432	!++
6433	! FUNCTIONAL DESCRIPTION:
6434	!
6435	!	THIS ROUTINE CREATES 'LR' AND 'DR' COMMAND STRINGS AND PASSES THEM
6436	!	TO THE 'SEND_LINE' ROUTINE FOR CONCATENATION ONTO THE COMMAND LINE.
6437	!	IF THE 8080 REGISTER ADDRESS IS THE SAME AS THE LAST REFERENCED 
6438	!	ADDRESS, THEN THE 'LR' COMMAND IS NOT NEEDED.
6439	!
6440	! FORMAL PARAMETERS:
6441	!
6442	!	REG_ADDR	= ADDRESS OF 8080 REGISTER TO BE WRITTEN
6443	!	DATA		= 8-BIT DATA TO BE WRITTEN
6444	!
6445	! IMPLICIT INPUTS:
6446	!
6447	!	LAST_REG_ADDR	= ADDRESS OF 8080 REGISTER WHICH WAS LAST
6448	!			  REFERENCED BY AN 'ER' OR 'LR' COMMAND.
6449	!
6450	! IMPLICIT OUTPUTS:
6451	!
6452	!	LAST_REG_ADDR	= 800 REGISTER ADDRESS SPECIFIED BY 'REG_ADDR'
6453	!			  PARAMETER.
6454	!
6455	! ROUTINE VALUE:
6456	!
6457	!	NONE
6458	!
6459	! SIDE EFFECTS:
6460	!
6461	!	CONCATENATES 'LR' AND 'DR' COMMANDS TO THE CUMULATIVE COMMAND LINE.
6462	!	WHEN EXECUTED, THEY WILL DEPOSIT THE SPECIFIED DATA INTO THE SPECIFIED
6463	!	8080 REGISTER.
6464	!--
6465	
6466	    BEGIN
6467	
6468	    LOCAL
6469		BUF_PTR;				!BYTE POINTER
6470	
6471	    BIND
6472		DR_CMD = UPLIT (%ASCIZ'DR   '),		!'DR' CMD STRING SKELETON
6473		LR_CMD = UPLIT (%ASCIZ'LR   ');		!'LR' CMD STRING SKELETON
6474	
6475	!IF THE 8080 REG ADDR IS THE SAME AS THE LAST REFERENCED REG ADDR, THEN THE
6476	!'LR' COMMAND IS NOT NEEDED.
6477	
6478	    IF .LAST_REG_ADDR NEQ .REG_ADDR
6479	    THEN
6480		BEGIN
6481		BUF_PTR = POINT (LR_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
6482		BUF_PTR = INSERT_NUM (.BUF_PTR, .REG_ADDR, 3); !INSERT REG ADDR FIELD
6483		REPLACEI (BUF_PTR, 0);			!TERMINATE COMMAND
6484		SEND_LINE (LR_CMD, 0);			!GO CONCATENATE 'LR' CMD
6485		LAST_REG_ADDR = .REG_ADDR;		!UPDATE LAST REG ADDR
6486		END;
6487	
6488	    BUF_PTR = POINT (DR_CMD, 22, 7, 0, 0);	!SETUP BYTE POINTER
6489	    BUF_PTR = INSERT_NUM (.BUF_PTR, .DATA, 3);	!INSERT DATA FIELD IN CMD
6490	    REPLACEI (BUF_PTR, 0);			!TERMINATE CMD
6491	    SEND_LINE (DR_CMD, 0);			!GO CONCATENATE 'DR' CMD
6492	    END;
6493	
6494	GLOBAL ROUTINE TICK (N) : NOVALUE =
6495	
6496	!++
6497	! FUNCTIONAL DESCRIPTION:
6498	!
6499	!	THIS ROUTINE IS CALLED TO GENERATE A SPECIFIED NUMBER OF SYSTEM CLOCK
6500	!	TICKS.
6501	!	IF THE 'SINGLE STEP' FEATURE IS ACTIVATED AND THE PROGRAM IS
6502	!	LOOPING ON A TEST OR AN ERROR, THEN THE TICKS MUST BE DONE IN
6503	!	A CONTROLLED MANNER.  THIS IS DONE BY CALLING THE 'SS_TICK'
6504	!	ROUTINE.
6505	!
6506	! FORMAL PARAMETERS:
6507	!
6508	!	N		= NUMBER OF CLOCK TICKS REQUIRED
6509	!
6510	! IMPLICIT INPUTS:
6511	!
6512	!	SINGLE_STEP	= FEATURE FLAG INDICATING THAT CLOCK TICKS ARE TO
6513	!			  BE SINGLE STEPPED.
6514	!	LOOPING		= FLAG INDICATING THAT PROGRAM IS LOOPING ON ERROR
6515	!	LOOP_ON_TEST	= FEATURE FLAG INDICATING THAT PROGRAM IS LOOPING
6516	!			  ON TEST.
6517	!
6518	! IMPLICIT OUTPUTS:
6519	!
6520	!	NONE
6521	!
6522	! ROUTINE VALUE:
6523	!
6524	!	NONE
6525	!
6526	! SIDE EFFECTS:
6527	!
6528	!	IF SINGLE-STEPPING, THE CLOCK TICKS ARE DOEN UNDER USER CONTROL.
6529	!	IF THE TICK COUNT IS OUT OF RANGE, AN ERROR MESSAGE IS PRINTED
6530	!	ON THE TTY.
6531	!
6532	!--
6533	    BEGIN
6534	
6535	    REGISTER
6536		AC0 = 0;
6537	
6538	    IF (.N LSS 1) OR (.N GTR %O'376')	!IS TICK COUNT OUT OF RANGE (FOR 'RP' CMD)
6539	    THEN
6540		BEGIN
6541		PTSTNUM ();				!PRINT THE TEST NUMBER
6542		PTXT_CRLF ('TICK COUNT OUT OF RANGE');
6543		END;
6544	
6545	!CHECK WHETHER WE SHOULD DO SINGLE STEPPING OR NOT
6546	
6547	    IF .SINGLE_STEP AND (.LOOPING OR .LOOP_ON_TEST)
6548	    THEN
6549		SS_TICK (.N)				!GO DO SINGLE STEPPING
6550	    ELSE
6551		SEND_TICK (.N);				!GO SEND TICKS
6552	    END;
6553	
6554	GLOBAL ROUTINE TICK_NOSS (N) : NOVALUE =
6555	
6556	!++
6557	! FUNCTIONAL DESCRIPTION:
6558	!
6559	!	THIS ROUTINE IS CALLED TO GENERATE A SPECIFIED NUMBER OF SYSTEM
6560	!	CLOCK TICKS.  IT DOES SO BY CALLING THE 'SS_TICK' ROUTINE.
6561	
6562	!
6563	! FORMAL PARAMETERS:
6564	!
6565	!	N		= NUMBER OF CLOCK TICKS REQUIRED
6566	!
6567	! IMPLICIT INPUTS:
6568	!
6569	!	NONE
6570	!
6571	! IMPLICIT OUTPUTS:
6572	!
6573	!	NONE
6574	!
6575	! ROUTINE VALUE:
6576	!
6577	!	NONE
6578	!
6579	! SIDE EFFECTS:
6580	!
6581	!	A 'RP' COMMAND STRING IS CONCATENATED ONTO THE CUMULATIVE COMMAND LINE.
6582	!	IF THE TICK COUNT IS OUT OF RANGE, AN ERROR MESSAGE IS PRINTED
6583	!	ON THE TTY.
6584	!
6585	!--
6586	    BEGIN
6587	
6588	    REGISTER
6589		AC0 = 0;
6590	
6591	    IF (.N LSS 1) OR (.N GTR %O'376')	!IS TICK COUNT OUT OF RANGE
6592	    THEN
6593		BEGIN
6594		PTSTNUM ();				!PRINT THE TEST NUMBER
6595		PTXT_CRLF ('TICK COUNT OUT OF RANGE');
6596		END;
6597	
6598	    SEND_TICK (.N);				!EXECUTES SPECIFIED NUMBER OF TICKS
6599	    END;
6600	
6601	GLOBAL ROUTINE SEND_TICK (TICKS) : NOVALUE =
6602	
6603	!++
6604	! FUNCTIONAL DESCRIPTION:
6605	!
6606	!	THIS ROUTINE EXECUTES A SPECIFIED NUMBER OF KS10 MAINTENANCE CLOCK
6607	!	TICKS.  IT IS ASSUMED THAT THE MAIN SYSTEM CLOCK HAS ALREADY BEEN
6608	!	DISABLED.  MAINTENANCE CLOCK TICKS ARE GENERATED BY TOGGLING THE
6609	!	MAINT CLOCK BIT IN 8080 REGISTER 205.  THIS ROUTINE CREATES A COMMAND
6610	!	STRING TO DO THIS TOGGLING, THEN IT ADDS A REPEAT COMMAND ON THE END.
6611	!	THE REPEAT COUNT IS SET TO PRODUCE THE SPECIFIED NUMBER OF CLOCK
6612	!	TICKS.
6613	!
6614	! FORMAL PARAMETERS:
6615	!
6616	!	TICKS		= NUMBER OF MAINTENANCE CLOCK TICKS REQUIRED
6617	!
6618	! IMPLICIT INPUTS:
6619	!
6620	!	NONE
6621	!
6622	! IMPLICIT OUTPUTS:
6623	!
6624	!	NONE
6625	!
6626	! ROUTINE VALUE:
6627	!
6628	!	NONE
6629	!
6630	! SIDE EFFECTS:
6631	!
6632	!	FORCES SENDING OF CUMULATIVE COMMAND LINE.  THEN SENDS REPEAT COMMAND
6633	!	STRING TO TOGGLE MAINT CLOCK BIT IN 8080 REGISTER 205.
6634	!
6635	!--
6636	    BEGIN
6637	
6638	    REGISTER
6639		AC0 = 0;
6640	
6641	!IF MORE THAN 1 TICK IS REQUIRED, THEN A REPEAT COMMAND WILL BE USED.  THIS
6642	!MEANS THAT THE CURRENT CUMULATIVE COMMAND LINE MUST BE SENT SO IT WON'T GET
6643	!REPEATED TOO.
6644	
6645	    IF .TICKS GTR 1 THEN SEND_NUL ();		!FORCE SENDING OF CURRENT CMD LINE
6646	
6647	    WRT205 (MNT_CLK_ENB + MAINT_CLK);		!ASSERT MAINT CLK BIT
6648	    WRT205 (MNT_CLK_ENB);			!NEGATE IT
6649	
6650	!IF MORE THAN 1 TICK IS REQUIRED, ADD A REPEAT COMMAND WITH REPEAT COUNT TO
6651	!PROVIDE REQUIRED # OF TICKS.
6652	
6653	    IF .TICKS GTR 1 THEN REPEAT (.TICKS - 1);
6654	
6655	    END;
6656	
6657	ROUTINE SS_TICK (N) : NOVALUE =
6658	
6659	!++
6660	! FUNCTIONAL DESCRIPTION:
6661	!
6662	!	THIS ROUTINE ALLOWS THE USER TO CONTROL SINGLE TICKING OF
6663	!	SYSTEM CLOCK.  IT PRINTS A MESSAGE INFORMING THE USER
6664	!	OF THE NUMBER OF CLOCK TICKS REQUIRED IN THE FUNCTION
6665	!	BEING EXECUTED.  IT THEN PROMPTS HIM/HER FOR THE NUMBER OF
6666	!	TICKS DESIRED.  THE SPECIFIED NUMBER OF TICKS ARE EXECUTED
6667	!	USING A 'SEND_TICK' ROUTINE.  THE RESULTS OF AN 'ER' COMMAND
6668	!	ARE PRINTED FOLLOWING THAT EXECUTION.  THIS PROCESS IS REPEATED
6669	!	UNTIL THE REQUIRED NUMBER OF TICKS HAVE BEEN EXECUTED.  AT
6670	!	THAT POINT, THE USER IS ASKED IF HE/SHE WISHES TO CONTINUE.  IF NOT,
6671	!	PROGRAM CONTROL IS RETURNED TO 'CSL'.
6672	!
6673	! FORMAL PARAMETERS:
6674	!
6675	!	N		= NUMBER OF CLOCK TICKS REQUIRED
6676	!
6677	! IMPLICIT INPUTS:
6678	!
6679	!	NONE
6680	!
6681	! IMPLICIT OUTPUTS:
6682	!
6683	!	NONE
6684	!
6685	! ROUTINE VALUE:
6686	!
6687	!	NONE
6688	!
6689	! SIDE EFFECTS:
6690	!
6691	!	PRINTS PROMPT MESSAGES ON THE TTY AND RECEIVES INPUT.
6692	!	EXECUTES SPECIFIED NUMBER OF 'RP' AND 'ER' COMMANDS.
6693	!
6694	!--
6695	    BEGIN
6696	
6697	    REGISTER
6698		AC0 = 0;
6699	
6700	    OWN
6701		FIRST_TIME: INITIAL (0);		!FLAG FOR "NOTE" PRINTING
6702	
6703	    LOCAL
6704		TICKS;					!COUNTER FOR # OF CLOCK TICKS
6705	
6706	!PRINT REQUIRED # OF CLOCK TICKS
6707	
6708	    PRINT_TXT ('THIS TEST SEQUENCE REQUIRES ');
6709	    PRINT_DEC (.N);
6710	    PTXT_CRLF (' CLOCK TICKS');
6711	    IF .FIRST_TIME EQL 0			!ONLY PRINT "NOTE" ONCE
6712	    THEN
6713		BEGIN
6714		FIRST_TIME = -1;			!SET FLAG
6715		PTXT_CRLF ('NOTE: 1 T-CLK/R-CLK CYCLE = 4 CLOCK TICKS');
6716		END;
6717	
6718	!EXECUTE USER SPECIFIED NUMBER OF CLOCK TICKS UNTIL REQUIRED #
6719	!ARE EXECUTED.
6720	
6721	    DO
6722		BEGIN
6723		TICKS = GET_NUM (UPLIT (%ASCIZ'ENTER DESIRED NUMBER OF CLOCK TICKS'), .N);
6724		SEND_TICK (.TICKS);			!PASS 'RP' CMDS
6725		PRINT_CRLF;
6726		PRINT_TXT ('8080 REGISTER 303: ');
6727		PRINT_OCT_3 ( REG_EXAMINE (%O'303'));	!READ AND PRINT REG CONTENTS
6728		PRINT_CRLF;
6729		END
6730	    WHILE (N = .N - .TICKS) GTR 0;
6731	
6732	!FIND OUT IF USER WANTS TO CONTINUE OR RETURN TO 'CSL'
6733	
6734	    PTXT_CRLF ('REQUIRED # OF CLOCK TICKS HAVE BEEN EXECUTED');
6735	    PRINT_TXT ('DO YOU WANT TO CONTINUE THIS TEST?');
6736	
6737	    IF NOT TTI_YES THEN EOP_UUO;
6738	
6739	    END;
6740	
6741	GLOBAL ROUTINE SYNC_CLK : NOVALUE =
6742	
6743	!++
6744	! FUNCTIONAL DESCRIPTION:
6745	!
6746	!	THIS ROUTINE STOPS THE MAIN KS10 SYSTEM CLOCK AND SYNCHS IT TO A
6747	!	STATE WHERE BOTH THE T-CLK AND R-CLK SIGNALS ARE NEGATED.  IT DOES
6748	!	THIS BY TICKING THE CLOCK UNTIL THE 'R CLK ENB' SIGNAL ASSERTS.
6749	!	THIS OCCURS WHEN THE T-CLK SIGNAL ASSERTS.  THREE MORE CLOCK TICKS
6750	!	FROM THAT POINT WILL NEGATE BOTH T-CLK AND R-CLK.
6751	!
6752	! FORMAL PARAMETERS:
6753	!
6754	!	NONE
6755	!
6756	! IMPLICIT INPUTS:
6757	!
6758	!	NONE
6759	!
6760	! IMPLICIT OUTPUTS:
6761	!
6762	!	NONE
6763	!
6764	! ROUTINE VALUE:
6765	!
6766	!	NONE
6767	!
6768	! SIDE EFFECTS:
6769	!
6770	!	STOPS MAIN KS10 CLOCK AND SYNCHS IT.  IN THE PROCESS OF DOING THIS,
6771	!	THE 'R CLK ENB' SIGNAL GETS NEGATED AND ASSERTED.
6772	!	IF THE ROUTINE FAILS TO SYNCH THE CLOCKS, AN ERROR MESSAGE IS PRINTED
6773	!	ON THE TTY AND TESTING IS ABORTED.
6774	!
6775	!--
6776	    BEGIN
6777	
6778	    REGISTER
6779		AC0 = 0;
6780	
6781	    WRT210 (CLOSE_LATCH);			!CAUSE 'R CLK ENB' TO NEGATE
6782	    WRT205 (MNT_CLK_ENB);			!STOP THE CLOCK
6783	    WRT210 (0);					!NEGATE 'CLOSE LATCHS'
6784	    TICK_NOSS (4);					!WILL TAKE AT LEAST 4 TICKS FOR
6785							! 'R CLK ENB' TO ASSERT.
6786	
6787	!'R CLK ENB' SHOULD ASSERT WITHIN 4 MORE TICKS.  CHECK FOR ASSERTION AFTER
6788	!EACH TICK.
6789	
6790	    INCR I FROM 1 TO 4 BY 1 DO
6791		BEGIN
6792		TICK_NOSS(1);
6793	
6794		IF (REG_EXAMINE (%O'303') AND R_CLK_ENB0) EQL 0 !IF 'R CLK ENB' ASSERTED
6795		THEN
6796		    BEGIN
6797		    TICK_NOSS (3);				!GIVE 3 MORE TICKS TO MAKE
6798		    					!T CLK AND R CLK NEGATED
6799		    RETURN;
6800		    END;
6801	
6802		END;
6803	
6804	!IF WE DROP THRU, IT MEANS WE FAILED TO SYNCH
6805	
6806	    PTSTNUM ();					!PRINT TEST NUMBER
6807	    PTXT_CRLF ('FAILED TO SYNC CLOCK IN MAINT MODE, TESTING BEING ABORTED');
6808	    AC0 = .HAD_FAILURE;				!SET FLAG FOR 'CSL'
6809	    EOP_UUO;					!RETURN COONTROL TO 'CSL'
6810	    END;
6811	
6812	END
6813	
6814	ELUDOM

AC0				 225+#	 229+#	 233+#	 237+#	 241+#	 245+#	 249+#	 253+#	 257+#	 261+#	 265+#	 269+#
				 273+#	 277+#	 281+#	 285+#	 289+#	 293+#	 297+#	 301+#	 305+#	 309+#	 313+#	 360+#
				 809#	 815	 852#	 918#	 999#	1127#	1218#	1238	1240	1303#	1320	1322
				1386#	1407#	1408#	1476#	1727#	2194#	2413#	2433#	2439	2442	2445	2448
				2490#	2511	2512	2585#	2679#	2765#	2815#	2945#	2951#	3051#	3057#	3120#
				3216#	3289#	3299	3408#	3427#	3485#	3511#	3516	3522	3575#	3620	3626
				3628	3668#	3722#	3768#	3818#	3870#	3972#	4386#	4392#	4393#	4394#	4487#
				4546#	4681#	4738#	5038#	6536#	6589#	6639#	6698#	6779#	6808#
ACTUAL				1819	1861	1865	1909	1997	2038	2041	2082	2126	2223	2225	2359
				2360	2639	2697	2699	2709	2714	2720
ADDR				 236+	 237+	4054	4088	4837	4885	4887	4893	4933	5065	5102	5114
				5164	5168	5171	5180	5212	5215	5255	5271	5321	5324	5325	5428
				5476	5480	5483	5492	5524	5527	5576	5579	5580	5587	5628
ADPT1_PE			 614+#
ADPT2_PE			 575+#
ADPT3_PE			 580+#
ADPT4_PE			 613+#
ARG				4269	4336	4340	4437	4489	4498	4502	4548	4556	4638	4683	4691
				4695	4740	4748
ASK_FEATURES			  57	 833	1058*
BAD_DATA			 479+#
BELL_ON_ERR			 718	1007	1024	1136#	1811	1857	1905	1950	1990	2034	2078	2119
BLISS36				   4
BOOT				 630+#
BUF_PTR				3294	3299#	3301	3304	3312	3401	3410#	3415	3719	3731#	3732#	3733
				3917	3922#	3926#	3928	4318	4332#	4336#	4340#	4342	4484	4497#	4498
				4543	4555#	4556	4678	4690#	4691	4735	4747#	4748	4878	4883#	4887#
				4889	4927	4932#	4933#	4934	4974	4979#	4980#	4983	4985	5035	5050#
				5054	5055	5056	5057	5058	5059	5060#	5061	5155	5167#	5168#	5169
				5174#	5175#	5176	5311	5316#	5324#	5328	5415	5422#	5423#	5424	5467
				5479#	5480#	5481	5486#	5487#	5488	5566	5571#	5579#	5583	5644	5698
				5704	5743	5749#	5757#	5761	6469	6481#	6482#	6483	6488#	6489#	6490
BUSREQ				 633+#
BUS_REQ				 518+#
CACHE_ENB			 417+#
CADSUB				 680#	4088	4127
CE				 111	4502*
CE_CMD				4540#	4555	4557
CH				 113	2198	2304#	2306	2311	2320#	2322	2333	2348	2352	2588	2596#
				2597	2601	2609#	2611	2616	4599*
CHAR				2500	2525#	2530	2538
CHAR_BUF			 694#	 696	 705	2202	5032
CHAR_CNT			2496	2511#	2526#	2528
CHAR_PTR			2497	2512#	2525
CHK_ERR_MSG			  92	3243*
CHR				3292	3310#	3312	3402	3414#	3415	3417
CH_CMD				4633#	4635
CLK_RUN				 507+#
CLOSE_LATCH			 512+#	6781
CLR_INT				 501+#
CMD_BUF				3431	3497	3555	5032	5050	5062
CMD_BUF_PTR			3488	3497#	3499	3555#	3560
CMD_CHARS			3489	3496#	3501#	3507	3533	3544	3557
CNT				1592	1607#	1611	1653#	1657
COM_ADR				 478+#
CONS_ENB			 631+#
CONTINUE			 523+#
CONTINUE_H			 618+#
CONTROL				  54	 752*
CONTROL_EDIT			 662#	 923
CONTROL_VERSION			 663#	 925
COPYII				 684	3560
CORRECT				1819	1861	1865	1909	1997	2038	2041	2082	2126	2225	2359	2639
				2688	2690	2710	2714	2720
CP				  99	3775*
CP_CMD				3920#	3922	3929
CP_NOSS				 100	3836*
CRAM_ADDR			4346	4393
CRAM_ADR_LD			 491+#
CRAM_PE				 579+#
CRAM_RESET			 487+#
CRAM_WRT			 492+#
CRA_PE				 576+#
CRA_R_CLK			 514+#
CRA_T_CLK			 515+#
CRM_PE_DET			 419+#
CR_CLK_ENB			 648+#
CR_LF				 221+#	 225+	 253+
CS				 112	4560*
CSL_INT				 483+#
CS_CMD				4594#	4596
CTY_BIT				 625+#
CTY_CHAR_LEN			 624+#
DATA				4130	4266	4938	4980	4989	5060	5065	5102	5114	5175	5380	5423
				5428	5487	5766	5798	5801	5833	5836	5868	5871	5903	5906	5938
				5941	5973	5976	6008	6011	6043	6046	6078	6081	6113	6116	6148
				6151	6183	6186	6218	6221	6253	6256	6288	6291	6323	6326	6358
				6361	6393	6396	6428	6430	6489
DATA0				 472+#
DATA1				 471+#
DATA10				 459+#
DATA11				 458+#
DATA12				 454+#
DATA13				 453+#
DATA14				 452+#
DATA15				 451+#
DATA16				 450+#
DATA17				 449+#
DATA18				 448+#
DATA19				 447+#
DATA2				 470+#
DATA20				 443+#
DATA21				 442+#
DATA22				 441+#
DATA23				 440+#
DATA24				 439+#
DATA25				 438+#
DATA26				 437+#
DATA27				 436+#
DATA28				 432+#
DATA29				 431+#
DATA3				 469+#
DATA30				 430+#
DATA31				 429+#
DATA32				 428+#
DATA33				 427+#
DATA34				 426+#
DATA35				 425+#
DATA4				 465+#
DATA5				 464+#
DATA6				 463+#
DATA7				 462+#
DATA8				 461+#
DATA9				 460+#
DATA_ACK			 629+#
DATA_ADDR			4346	4392	4394
DATA_CYCLE			 476+#
DATA_EDIT			 915	 931
DATA_VERSION			 914	 933
DC_035				 120	4938*
DC_CMD				4977#	4979	4986
DIAG1				 496+#
DIAG10				 499+#
DIAG2				 497+#
DIAG4				 498+#
DIAG_FN				4989	5040	5056
DIGITS				1819	1861	1865	1909	1997	2038	2041	2082	2126	2223	2225	2356
				2359	2639	2686	2688	2690	2695	2697	2699	2704	2713	2716	2721
				2726	2772#	2774	2778	2780	2782	2819	5644	5691
DISCREP				2682	2714#	2716	2720#	2721
DISPATCH			  61	 843	1412*
DI_CMD				5471#	5486	5489
DM_CHK				 122	5065*
DM_CMD				5159#	5174	5177
DN				 128	5380*
DN_CMD				5418#	5422	5425
DP_CLK_ENBL			 647+#
DP_PE_DET			 418+#
DP_PE				 577+#
DP_RESET			 489+#
DR_CMD				6472#	6488	6491
EB_AC				 211+#	 335+
EC				 118	4837*
EC_AC				 212+#	 336+	4890
EC_CMD				4881#	4883	4890
EI				 131	5524	5527*	5628
EI_AC				 208+#	 332+	5584
EI_CHK				 132	5587*
EI_CMD				5569#	5571	5584
EJ				 116	3991	4752*
EJ_AC				 209+#	 333+	4795
EJ_CMD				4793#	4795
EJ_PTR				3975	3991#	3994	3996	3998	4000
EK_AC				 210+#	 334+
EM				 126	5212	5255	5271*
EM_AC				 213+#	 337+	5329
EM_CHK				 125	5215*
EM_CMD				5314#	5316	5329
EN_1MS				 416+#
EOF_MSG				2493#	2520	2533
EOP_UUO				 327+#	 853	2952	3058	3428	4011	6737	6809
ERMCAS				  77	2041*
ERMCA				  76	1997*
ERMS				  79	2085*
ERR				  67	1776*
ERRCAS				  69	1865*
ERRCA				  68	1819*
ERRFLG				 701	2206#	3125	3126#	3220	3223#
ERRM				  75	1958*
ERR_FLAG			3123	3125#	3140	3152
ERR_NUM				1865	1909	1910	1913	1954	1955	2126	2216	2251	2963	3035	3068
				3135	3143	3156	3166	3218	3228
ERR_RPT				  80	1815	1861	1909	1954	1994	2038	2082	2123	2126*
ER_AC				 207+#	 331+	5762
ER_CMD				5747#	5749	5762
ES_PTR				3023	3027	3034#	3035#	3042
ES_TBL				 741	 750	1606	3034
EXECUTE_B			 619+#
EXNEXT				 105	4091*
FAILURE				  89	1816	1862	1910#	1955	2963*
FAST_LOOP			 720	1031	1152#	1155#	3218
FILNAM_ADR			 360+
FIND_NUM			  83	2288	2296	2541*
FIRST_PASS			 813	 819	 823#
FIRST_TIME			6701	6711	6714#
FIRST				1479	1488#	1494	1500#
FLP_CHK				  91	3166*
FORCE_PAR			 415+#
FORCE_SEND			3431	3569	3577	3582
FRDPAG				 362+#	2505
FSELECT				 360+#	2262
GET_CHAR			  82	2304	2320	2422	2423	2454*	2596	2609
GET_NUM				  59	1166	1262*	3989	6723
HAD_FAILURE			 708	 852	1396#	1742	2239	2244#	6808
HALTED				 367+#
HALT_LOOP			 621+#
I				 694	 696	1393	1394	1510	1512	1611	1613	1657	1659	1752	1754
				1757	2713	2714	2769	2771	2774	2934	2936	2937	2958	2959	3040
				3042	3043	3063	3064	3357	3557	4326	4327	4982	5374	5691	5693
				5695	6790
INDEX				2417	2423#	2425	2433	2858	2929
INIT_DATA			  60	 842	1336*
INSERT_NUM			 133	3732	3926	4336	4340	4887	4933	4980	5060	5168	5175	5324
				5423	5480	5487	5579	5644*	5757	6482	6489
IO_DATA				 477+#
IO_DEPOSIT			 129	5428*
IO_EXAMINE			 130	5492*
J				1617	1619	1621	1639	1641	1663	1665
KEY_CHAR			2541	2601
KLINIK_BIT			 623+#
KLINIK_CARR			 639+#
KLINIK_LEN			 622+#
LANGUAGE			   4
LAST_ACTUAL			2201	2223	2360#
LAST_IO_ADDR			 714	1401#	5421#	5476	5483#	5576	5580#
LAST_MEM_ADDR			 713	1400#	5164	5171#	5321	5325#	5420#
LAST_MSG_NUM			2204	2233	2268#	2296#	2298
LAST_PTR			1730	1748#	1759	1765#
LAST_REG_ADDR			 715	1402#	5754	5758#	6478	6485#
LAST_TEST_MSG			2203	2233	2267#	2285	2288#	2290
LATCH_DATA			 513+#
LA_CMD				5158#	5167	5170
LCA				 119	4893*
LC_CMD				4930#	4932	4935
LINE_BUF			 705	3424	3511	3538	3575	3674
LINE_BUF_PTR			3492	3510	3538#	3551	3560	3574
LINE_CHARS			 717	1406#	3507	3524#	3529	3548	3552#	3561#	3616#
LI_CMD				5470#	5479	5482
LOADUC				 108	4346*
LOOPING				 726	1405#	2213	2925	3031	3132	3155#	3829	6547
LOOP_CHK			  90	3068*	3218
LOOP_CNT			3325	3357
LOOP_ERR_NUM			 712	2216	3135	3143#	3156#
LOOP_ON_ERR			 719	1008	1026	1148#	3130
LOOP_ON_PRG			 725	 850	1012	1050	1165#	1171#
LOOP_ON_TEST			 721	 732	1009	1036	1162#	1484	2925	3031	3829	6547
LOOP_TEST			 722	1040	1166#	1487	1492	1498
LPONTST				 732#
LR_CMD				6473#	6481	6484
MAINT_CLK			 503+#	6647
MAXNETS				 745	1391	1752
MAXTEST				 746	1166	1407	1510
MAXVAL				1262	1311	1320
MEM				 519+#
MEMSIZE				  58	1181*
MEM_DEPOSIT			 123	5102	5114*
MEM_EXAMINE			 124	5180*
MEM_PE				 578+#
MEM_REF_ERR			 368+#
MMC_REF_ERR			 585+#
MNT_CLK_ENB			 502+#	6647	6648	6782
MOD_FLD				 121	4989*
MR				 109	4398*
MR_CMD				4432#	4434
MSG				5331	5369
MSGADR				 232+	 233+	 256+	 257+
MSGFIL				 739	2262	2273	2275
MSGWORD				 228+	 229+
MSG_BUF				3405	3410	3422
MSG_BUF_PTR			3293	3305#	3310
MSG_CHK				 127	5263	5331*	5636
MSG_CHK_UUO			 352+#	3298
MSG_FILE_OPEN			 710	1397#	2218#	2235#	2258	2265#	2521#	2534#
MSG_NUM				1865	1909	1913	1954	2041	2082	2085	2123	2126	2233	2296
MSG_PTR				3243	3305	3364	3414	5366	5369#	5376
MSSTRC				   3#
N				 694	 695	3775	3820	3831	3833	3836	3872	3879	3882	3924	3926
				3931	3981	3989	4004#	6494	6538	6549	6551	6554	6591	6598	6657
				6709	6723	6730#
NAME_PTR			1731	1757#	1759	1763	1765
NDA_MSG				5623#	5636
NES_PTR				2914	2921	2928#	2929#	2936
NES_TBL				 742	 751	1648	2928
NETWRDS				 706	1391#	1393	1617	1639	1663	2934	2958	3040	3063
NET_FAULTS			 740	 749	1389	1394#	1597	1619	1641	1665	1754	2920	2936	2959#
				3026	3042	3064#
NET_NAMES			1721	1724	1757
NET_RPT				  63	 844	1673*	2950	3056
NEXM				 634+#
NOERR				  88	2858*
NO_ISOLATION			 727	1014	1044	1138#	1603	1735	2925	3031
NO_SUBSET			 699	1624
NUL_CMD				4049	4051
NUM				 248+	 249+	 268+	 269+	 272+	 273+	 276+	 277+	 280+	 281+	 284+	 285+
				 288+	 289+	 292+	 293+	 296+	 297+	 300+	 301+	 304+	 305+	 308+	 309+
				 312+	 313+	1776	1815	1816	1819	1861	1862	1958	1994	1997	2038
				2589	2605#	2616#	2635	2637	2782	2823	2826	2829	2832	2835	2838
				2841	2844	2847	2850	5644	5693
NXM_MSG				5250#	5263
NZ_FLAG				2913	2927#	2937#	2940	3021	3033#	3043#	3046
OVERLAP				1591	1605#	1626#	1636
PAGE_IN				 711	2266#	2502	2513#	2528#
PAR_ERR				 369+#
PAR_LEFT			 611+#
PAR_RIGHT			 612+#
PASS_CNT			 812	 836#	 845#	 847
PATCH				 729
PBELL				 316+#	1813	1859	1907	1952	1992	2036	2080	2121
PE				 110	4437*
PE_1				 632+#
PE_CMD				4481#	4497	4499
PE_DET_ENB			 420+#
PI_REQ_1			 592+#
PI_REQ_2			 591+#
PI_REQ_3			 590+#
PI_REQ_4			 589+#
PI_REQ_5			 588+#
PI_REQ_6			 587+#
PI_REQ_7			 586+#
PM_AC				 214+#	 338+
PNTSIX				 228+#	2273	2275
PNUM				  87	2690	2699	2721	2780	2782*
POCT_SUP			 312+#	2439
POINT				 685	2313	2336	2343	2512	3305	3410	3497	3538	3555	3731	3922
				4332	4497	4555	4690	4747	4883	4932	4979	5050	5167	5174	5316
				5369	5422	5479	5486	5571	5749	6481	6488
PRGNAM				 909	 920
PRINT_CA			  84	2225	2359	2639*
PRINT_CRLF			 224+#	1499	1745	2247	2252	2276	2692	2701	2724	2947	2949	3053
				3055	3224	3229	3232	3233	3772	3992	4001	4002	5045	6725	6728
PRINT_DEC			 248+#	1498	2249	2251	2442	3226	3228	3771	3981	5044	6709
PRINT_HEADER			  55	 822	 856*
PRINT_MODE			2416	2422#	2435
PRINT_MSG			 232+#	2335	2342	2445	2520	2533	3231	3422
PRINT_OCT_1			 272+#	2823
PRINT_OCT_11			 304+#	2847
PRINT_OCT_12			 308+#	2448	2771	2850
PRINT_OCT_2			 276+#	2826
PRINT_OCT_3			 280+#	2829	6727
PRINT_OCT_4			 284+#	2832	3994	3996	3998	4000
PRINT_OCT_5			 288+#	2835
PRINT_OCT_6			 292+#	2838
PRINT_OCT_7			 296+#	2841
PRINT_OCT_8			 300+#	2844
PRINT_TXT			 240+#	1497	1521	2248	2250	2272	2274	2684	2693	2702	3225	3227
				3770	3980	3993	3995	3997	3999	4009	5043	6708	6726	6735
PRINT_WORD			 236+#
PROMPT				1262	1309
PRT_CRLF_F			 252+#	 848	 921	 934	 935	1033	1041	1056	1178	1764	3419	3425
				3670	3675
PRT_DEC_F			 268+#	 847	 923	 925	 927	 929	 931	 933	1040	1311
PRT_ERR				  94	3317	3364*	3522	3626	5376
PRT_FEATURES			  56	 832	 937*
PRT_GTR_12			  85	2688	2697	2716	2726*
PRT_MSG_F			 256+#	 920	1309	1763	3424	3674
PRT_SPEC			  81	2344	2364*
PRT_TST_NUM			 728	1013	1052	1165#	1173#	1518
PRT_TXT_F			 260+#	 846	 922	 924	 926	 928	 930	 932	1029	1031	1039	1129
				1135	1137	1139	1141	1143	1151	1157	1170	1172	1226	1251	1310
				1312	3420	3671
PTR				1593	1598	1606#	1607	1613	1648#	1650	1653	1659	2364	2420	2433
				2726	2759	2771	2780	3166	3231	3237
PTSTNUM				  98	1522	2428	3421	3672	3727	3737*	3823	3875	4493	4551	4686
				4743	6541	6594	6806
PTXT_CRLF			 244+#	1746	1747	2242	2243	2429	2450	2627	2853	2948	3054	3144
				3157	3230	3234	3235	3236	3728	3824	3876	3982	4008	4494	4552
				4687	4744	5046	6542	6595	6710	6715	6734	6807
PTXT_CRLF_F			 264+#	1002	1017	1024	1044	1046	1048	1050	1052	1241	1245	1256
				1324	1328	1772	3423	3426	3673
RAC_LO				 603+#
RAM_ERR				 646+#
RBAD_DATA			 599+#
RCOM_ADR			 598+#
RDATA				 596+#
RDATA0				 610+#
RDATA1				 609+#
RDATA10				 565+#
RDATA11				 564+#
RDATA12				 560+#
RDATA13				 559+#
RDATA14				 558+#
RDATA15				 557+#
RDATA16				 556+#
RDATA17				 555+#
RDATA18				 554+#
RDATA19				 553+#
RDATA2				 608+#
RDATA20				 549+#
RDATA21				 548+#
RDATA22				 547+#
RDATA23				 546+#
RDATA24				 545+#
RDATA25				 544+#
RDATA26				 543+#
RDATA27				 542+#
RDATA28				 538+#
RDATA29				 537+#
RDATA3				 607+#
RDATA30				 536+#
RDATA31				 535+#
RDATA32				 534+#
RDATA33				 533+#
RDATA34				 532+#
RDATA35				 531+#
RDATA4				 571+#
RDATA5				 570+#
RDATA6				 569+#
RDATA7				 568+#
RDATA8				 567+#
RDATA9				 566+#
REC_PE				 581+#
REG_ADDR			5707	5754	5757	5758	6430	6478	6482	6485
REG_DEPOSIT			 154	5798	5833	5868	5903	5938	5973	6008	6043	6078	6113	6148
				6183	6218	6253	6288	6323	6358	6393	6428	6430*
REG_EXAMINE			 134	5707*	6727	6794
REM_DIAG_ENB			 641+#
REM_DIAG_PRO			 642+#
REPEAT				  97	3679*	6653
REPLACEI			 687	2333	2334	2341	2348	3415	3510	3551	3574	3733	3928	4342
				4498	4556	4691	4748	4889	4934	4983	4985	5054	5055	5056	5057
				5058	5059	5061	5169	5176	5328	5424	5481	5488	5583	5698	5761
				6483	6490
RESET				 421+#
RESPONSE			5100	5103#	5108	5253	5255#	5260	5263	5331	5370	5376	5626	5628#
				5633	5636	5744	5762#	5763
RIO_BUSY			 600+#
RIO_DATA			 597+#
RMEM_BUSY			 601+#
RPT_CMD				3716#	3731	3734
RPT_CNT				3679	3724	3732
RPT_ERR_FLAG			 702	3315	3522	3626
RRESET				 602+#
RUN				 525+#
RUN_1				 620+#
RUN_CHK				  62	1514	1531*
R_CLK_ENB0			 649+#	6794
SAV_PTR				3295	3304#	3317	5367	5370#	5376
SC0_CMD				4832#	4834
SCANI				 686	2525	3310	3312	3414	3499	5376
SCRIPT_RUN			 707	 815#	 829	1223
SC_0				 117	4798*
SEND_CMD_LINE			 344+#	3512	3579
SEND_CP				 101	3833	3879	3882*	3990
SEND_EB_LINE			 335+#	3598
SEND_EC_LINE			 336+#	3601
SEND_EI_LINE			 332+#	3589
SEND_EJ_LINE			 333+#	3592
SEND_EK_LINE			 334+#	3595
SEND_EM_LINE			 337+#	3604
SEND_ER_LINE			 331+#	3586
SEND_INFO			 356+#	1409
SEND_LINE			  95	3237	3431*	3734	3929	4051	4327	4343	4434	4499	4557	4596
				4635	4692	4749	4795	4834	4890	4935	4986	5062	5170	5177	5329
				5425	5482	5489	5584	5762	6484	6491
SEND_NUL			 103	4015*	4388	5103	6645
SEND_PM_LINE			 338+#	3607
SEND_TICK			 157	6551	6598	6601*	6724
SEND_UUO_1			 348+#
SEND_X1A_LINE			 339+#	3610
SEND_X1B_LINE			 340+#	3613
SETNXT				 104	4054*
SIG_PTR				1594	1599	1613#	1619	1659#	1665
SINGLE_CLK			 508+#
SINGLE_STEP			 724	1011	1046	1142#	3829	6547
SPEC_ASK			1124*	1134
SPEC_DIALOGUE			 806*	 824
SPEC_PRT			 996*	1006
SPEC_PTR			1865	1909	1913	1954	2041	2082	2085	2123	2126	2344
SRCH_NUM			2541	2635
SS_MODE				 490+#
SS_TICK				 158	6549	6657*
SS_UC				 102	3831	3931*
STEPS				3976	3989#	3990	4004
STK_RESET			 488+#
SUB				4251#	4266
SUB_LOADED			 716	1404#	4322	4329#
SUB_PTR				4269	4322	4326	4327	4329
SWITCH				5680	5683#	5695	5699#
SYNC_CLK			 159	6741*
TE				 115	4695*
TEMP				1588	1619#	1621	1641	2762	2774#	2780	2917	2936#	2937	2959	3022
				3042#	3043	3064	5681	5693#	5695	5698
TEN_INT				 635+#
TERM_CARR			 640+#
TEST_DISP			1470	1473	1492	1525
TEST_EDIT			 913	 927
TEST_INIT			1383*	1410
TEST_NUM			 709	1408	1487#	1512#	1525	1606	1648	2233	2249	2285	2288	2928
				3034	3226	3771	5044
TEST_VERSION			 912	 929
TEXT				 240+	 241+	 244+	 245+	 260+	 261+	 264+	 265+
TEXT_INH			 723	1010	1048	1140#	2254
TE_CMD				4732#	4747	4749
TICK				 155	6494*
TICKS				6601	6645	6653	6704	6723#	6724	6730
TICK_NOSS			 156	6554*	6784	6792	6797
TIMED_OUT			  96	3516	3620	3634*
TIMOUT				 700	3495#	3676#
TP				 114	4638*
TP_CMD				4675#	4690	4692
TRAP_ENB			 500+#
TTI_CLR				 322+#	1246	1329
TTI_DEC				 323+#	1236	1317
TTI_YES				 321+#	1131	1136	1138	1140	1142	1148	1152	1162	1171	1173	4011
				6737
TT_ALTM				 320+#
TXT_BUF				2202	2313	2335	2336	2342	2343
TXT_BUF_PTR			2197	2313#	2333	2334	2336#	2341	2343#	2348
UUO				 204+	 226+	 230+	 234+	 238+	 242+	 246+	 250+	 254+	 258+	 262+	 266+
				 270+	 274+	 278+	 282+	 286+	 290+	 294+	 298+	 302+	 306+	 310+	 314+
				 316+	 320+	 321+	 322+	 323+	 327+	 331+	 332+	 333+	 334+	 335+	 336+
				 337+	 338+	 339+	 340+	 344+	 348+	 352+	 356+	 361+	 362+	4395
WAIT				  93	3297	3325*
WRT100				 135	5766*
WRT102				 136	5801*
WRT103				 137	5836*
WRT104				 138	5871*
WRT105				 139	5906*
WRT106				 140	5941*
WRT107				 141	5976*
WRT110				 142	6011*
WRT111				 143	6046*
WRT112				 144	6081*
WRT113				 145	6116*
WRT114				 146	6151*
WRT115				 147	6186*
WRT116				 148	6221*
WRT204				 149	6256*
WRT205				 150	6291*	6647	6648	6782
WRT206				 151	6326*
WRT210				 152	6361*	6781	6783
WRT212				 153	6396*
WR_CRAM				 106	4130*
X1				 107	4088	4127	4266	4269*
X1A_AC				 215+#	 339+
X1B_AC				 216+#	 340+
X1_AC				4086#	4088	4125#	4127	4264#	4266	4269	4334	4338	4343
X1_CMD				4315#	4332	4343
XMIT_ADR			 517+#
XMIT_DATA			 516+#


TIME: 15 SEC.
CORE: 12K
 