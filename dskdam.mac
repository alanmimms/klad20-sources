SUBTTL	ARITHMETIC/RANDOM/INTERRUPT/MEMORY RELIABILITY TEST

; **********************************************************************
;*SIMDDT - SIMULATOR -DDT- INITIALIZATION SEQUENCE
; **********************************************************************

SIMDDT:	PGMINT			;INITIALIZE PROGRAM
	SETZM	SNGLIN
	SETZM	SEQ
	JRST	SENTRY		;GO TO SIMULATOR

; **********************************************************************
;*SFSRT1 - SPECIAL FEATURE START
; **********************************************************************

SFSRT1:	SETZM	$ONETM		;CLEAR ONE TIME FLAG
	JRST	BEGIN		;NOW START

; **********************************************************************
;*START - INITIALIZING AND CONTROL SEQUENCE
; **********************************************************************

START:	SKIPN	$ONETM		;REGULAR START
	SETZM	ONETIM#

	SETZM	TICKS
	SETZM	TSTIMR#
	SETZM	TIMCNT#
	SETOM	PVPAGI		;PREVENT PAGE INHIBIT
	SETOM	MAPNEW
	MOVEI	RSWPMT		;SETUP RIGHT HALF SWITCH PROMPT TABLE
	MOVEM	SWPTAB

	PGMINT			;INITIALIZE SUBROUTINES

	SKIPE	ONETIM		;FIRST TIME OR SF RESTART ?
	JRST	.+^D10		;NO
	SETZM	ERRTLS		;YES, CLEAR ALL TOTALS
	SETZM	AICTLS#		;CLEAR ARITH INST COMPARE TOTALS
	SETZM	SIMTLS#		;CLEAR ARITHMETIC SIMULATION TOTALS
	SETZM	RSIMTLS#	;CLEAR RANDOM SIMULATION TOTALS
	SETZM	RANTLS#		;CLEAR RANDOM LOOP TOTALS
	GO	CLRERR		;CLEAR MEMORY TOTALS
	SKIPL	MONCTL		;DIAGNOSTIC MONITOR SCRIPT CONTROL ?
	GO	HLPPNT		;NO, PRINT HELP MESSAGE
	SETOM	ONETIM

	MOVE	42
	MOVEM	$SAVITR#	;SAVE INTERRUPT INSTRUCTION

	MOVEI	<^D32*^D1024>-1
	MOVEM	VMEM#		;SETUP HIGHEST SIM VIRTUAL MEMORY

	MOVE	[JRST FTLRST]
	MOVEM	$ITRX1		;RESTART ON FATAL ERRORS

	SETOM	CLKON#
	SKIPE	USER
	JRST	STARTB

	MOVEI	1,^D1000
	MOVEM	1,HERTZ#	;SETUP HERTZ PER SECOND

	MOVE	1,[^D<1000*60*15>]
	MOVEM	1,HERTZQ#	;SETUP HERTZ PER QUARTER HOUR

	SETZM	CLKON
	SWITCH
	TRNE	INHCLK		;INHIBIT CLOCK ?
	JRST	STARTB		;YES

	MOVE	[JSR ITRCLK]
	MOVEM	$ITRHL		;SET INTERRUPT ROUTINE

	CONO	APR,LFLGDS!LFLGCL!LACLK
	WRINT	[<^D1>B23]	;SET TIMER TO 1 MILLISECOND
	CONO	APR,LAPRAL+LACLK+LAPRP1
	CONO	PI,CHNON!PION!PICHNA

	SETZB	0,1
	WRTIM			;CLEAR TIME BASE

	SETZM	TLAST#
	SETOM	CLKON

; **********************************************************************
;*STARTB - SETUP BASE RANDOM NUMBER
; **********************************************************************

STARTB:	SETZM	ONCFLG#
	SETOM	DISPAT#
	SETZM	REPT#

	SKIPN	USER
	JRST	STARTC

	GO	TSTIMU		;GET USER RUN TIME IN SECONDS
	MOVEM	TSTIMR		;SAVE AS INITIAL TIME ZERO TIME

	SKIPE	MONTYP
	JRST	[SETO	2,
		 SETZ	4,
		 104000,,222	;ODCNV - GET DATE & TIME
		 MOVE	0,4
		 JRST	.+2]
	CALL	0,[SIXBIT/TIMER/]	;USER RANDOM BASE
	MOVEM	0,RANDBS	;SETUP RANDOM BASE

STARTC:	SWITCH
	TRNN	RANBAS		;SPECIFY RANDOM NUMBER BASE ?
	JRST	STARTA

	PNTMSF	[ASCIZ/
SPECIFY RANDOM NUMBER BASE - /]
	TTIOCT			;INPUT OCTAL NUMBER
	JRST	.-2		;ERROR
	MOVEM	0,RANDBS

; **********************************************************************
;*STARTA - START OF PASS CONTROL
; **********************************************************************

STARTA:	SETOM	SIMFLG#		;SETUP CONTROL FLAGS
	SETOM	NEWFLG#

	CLRAPR
	SKIPN	USER
	CLRPI+CHNON

	SWITCH
	TRNE	INHNEW		;INHIBIT NEW INST'S ?
	SETZM	NEWFLG		;YES

	TRNE	FAST		;INHIBIT SIMULATION ?
	SETZM	SIMFLG		;YES

	MOVEI	1,^D10
	TRNE	SNGFL		;SINGLE FAST LOOP ?
	MOVEI	1,1		;YES
	MOVEM	1,FLCNT#

	MOVE	RA,RANDBS
	SETOM	.FIXF#		;SET TEST CONTROL FLAGS TO RUN ALL
	SETOM	.FLTF#
	SETOM	.BYTF#
	SETOM	.FASTF#
	SETOM	.SLOWF#
	SETOM	.DFLTF#
	SETOM	.RANF#
	SETZM	CKOUTF#

	MOVEI	1,6
	MOVEM	1,RTIME#

	SWITCH			;SETUP TEST CONTROL FLAGS
	TRNE	INHFXD
	SETZM	.FIXF		;FIXED POINT INHIBITED

	TRNE	INHFP
	SETZM	.FLTF		;FLOATING POINT INHIBITED

	TRNE	INHBYT
	SETZM	.BYTF		;BYTE'S INHIBITED

	TRNE	INHDFP
	SETZM	.DFLTF		;DOUBLE FLOATING INHIBITED

	TRNE	SLOW
	SETZM	.FASTF		;SIMULATION COMPARISON ONLY

	TRNE	INHRAN
	SETZM	.RANF		;RANDOM INSTRUCTION INHIBITED

	TRNE	FAST
	SETZM	.SLOWF		;INSTRUCTION RESULT COMPARE ONLY

	TLNN	RELIAB		;RELIABILITY MODE ?
	SETZM	RTIME		;NO, FAST CYCLE OPERATION

	JRST	BEGFX

; **********************************************************************
;*TSTEND - END OF TEST, GENERATE NEW RANDOM BASE NUMBER
; **********************************************************************

TSTEND:	MOVS	10,RANDBS
	MULI	10,6065
	DIV	10,[377777,,777741]
	SKIPN	11		;IF ZERO, MAKE RANDOM BASE = 1
	MOVEI	11,1
	MOVEM	11,RANDBS
	JRST	BEGEND		;NOW DO SUBROUTINE END OF PASS

; **********************************************************************
;*MISCELLANEOUS ROUTINES
; **********************************************************************

OPDEF	PTAB	[PNTCI	"	"]
OPDEF	PTABF	[PNTCIF	"	"]

PCRF:	PCRLF
	RTN

PCR:	PCRL
	RTN

PCR1:	PNTCI	14
	RTN

PCRX:	PCRL
	RTN

$CLRAPR:SKIPE	USER
	RTN

	PUT	0
	MOVE	$SAVITR
	MOVEM	42
	MOVEM	44
	MOVEM	46
	MOVEM	50
	MOVEM	52
	MOVEM	54
	MOVEM	56
	GET	0

	SKIPE	CLKON
	CONO	APR,LAPRAL!LACLK!LAPRP1

	SKIPN	CLKON
	CONO	APR,LAPRAL!LAPRP1
	RTN

; **********************************************************************
;*RENTR1 - REENTER SEQUENCE
; **********************************************************************

RENTR1:	MOVE	P,PLIST

	JSR	PNTTOT		;PRINT TOTALS
	GO	SYSTAT		;PRINT INTERRUPT TOTALS
	GO	TOTAL		;PRINT MEMORY TOTALS

	DROPDV			;CLOSE OUT LOGICAL FILE, IF IN USE

	EOPUUO			;RETURN TO DIAGNOSTIC MONITOR

; **********************************************************************
;*DDTEX - TRANSFER TO DDT
; **********************************************************************

DDTEX:	MOVEM	0,SAC0#
	PMSGF	<^**********^>
	MOVE	0,SAC0
	JRST	SRTDDT

; **********************************************************************
;*FTLRST - FATAL ERROR RESTART
; **********************************************************************

FTLRST:	SETOM	$$TOGGLE	;DON'T ASK FOR SWITCHES
	PGMINT			;INITIALIZE
	SETZM	$$TOGGLE
	JRST	STARTA		;CONTINUE

; **********************************************************************
;*HLPPNT - PRINT HELP MESSAGE
; **********************************************************************

HLPPNT:	PNTMSG	HLPMSG
	RTN

HLPMSG:	ASCIZ/
----------
WHILE RUNNING THE FOLLOWING TYPED CHARACTERS CAUSE THE GIVEN ACTION:
	T	PRINT PROGRAM TOTALS
	R	PRINT RUN TIME,  PRESENT TEST PC AND DESCRIPTION
	^T	EXEC - PRINT TEST PC
	^T	USER - PRINT NORMAL MONITOR INFORMATION
	^E	PRINT ERROR PC AND TOTAL ERRORS
	^G	ALLOWS CHANGE OF TYPED-IN CONSOLE SWITCHES
	H	PRINTS THIS HELP MESSAGE
----------
/

; **********************************************************************
;*PGMNAM - PROGRAM NAME
; **********************************************************************

PGMNAM:	ASCIZ %
DECSYSTEM 2020 CPU & MEMORY RELIABILITY TEST (DSKDA)
%

; **********************************************************************
;*RSWPMT - RIGHT HALF SWITCH PROMPT TABLE
; **********************************************************************

RSWPMT:	SIXBIT/RANBAS/		;SPECIFY RANDOM NUMBER BASE
	SIXBIT/INHCLK/		;INHIBIT CLOCK INTERRUPTS
	SIXBIT/INHMEM/		;INHIBIT MEMORY TESTING

	SIXBIT/INHII/		;INHIBIT INSTRUCTION INTERRUPT TESTING
	SIXBIT/INHCI/		;INHIBIT CLOCK INTERRUPT TESTING
	SIXBIT/INHBLT/		;INHIBIT BLT INTERRUPT TESTING

	SIXBIT/INHNXM/		;INHIBIT NON-EX-MEMORY INTERRUPT TESTING
	0
	0

	SIXBIT/INHNEW/		;INHIBIT DOUBLE PRECISION INSTRUCTIONS
	SIXBIT/INHDFP/		;INHIBIT DOUBLE FLOATING POINT TEST
	SIXBIT/INHFP/		;INHIBIT FLOATING POINT TEST

	SIXBIT/INHBYT/		;INHIBIT BYTE TEST
	SIXBIT/INHFXD/		;INHIBIT FIXED POINT TEST
	SIXBIT/INHRAN/		;INHIBIT RANDOM INSTRUCTION

	SIXBIT/SNGFL/		;RUN SINGLE FAST LOOP
	SIXBIT/SLOW/		;RUN JUST SIMULATION COMPARISION
	SIXBIT/FAST/		;RUN JUST INSTRUCTION COMPARISION
SUBTTL	FIXED POINT ARITHMETIC OPERATIONS
; **********************************************************************

BEGFX:	MOVEI	ACSP,ACS	;SETUP SIMULATED AC POINTER
	SETZM	CNTL

	SKIPN	.FIXF
	JRST	BEGFP		;DON'T TEST FIXED

	SKIPN	.FASTF
	JRST	FXS		;FIXED POINT, SLOW ONLY

; **********************************************************************
;*FIXED POINT FAST
;*COMPARE RESULTS OF MUL,DIV,ADD REMAINDER WITH ORIGINAL
; **********************************************************************

FXF:	SUBTST

	MOVEI	LOP,^D20
	ASH	LOP,@RTIME	;SETUP RUNNING TIME

FXF1:	JSR	FSTMDI
	CAI	FIXEDI+4(CNTR)	;FIXED POINT INTERGERS

	JSR	FSTMD
	CAI	FIXED+2(CNTR)	;FIXED POINT

	SOJG	LOP,FXF1

; **********************************************************************
;*FIXED POINT SLOW
;*COMPARE MACHINE RESULTS AGAINST SIMULATION
; **********************************************************************

FXS:	SUBTST

	SKIPN	.SLOWF
	JRST	BEGFP		;DON'T RUN

	MOVEI	LOP,^D10
	ASH	LOP,@RTIME	;SETUP RUNNING TIME

FXS1:	JSR	MD
	CAI	FIXEDI+10(CNTR)	;FIXED POINT INTERGERS

	JSR	MD
	CAI	FIXED+10(CNTR)	;FIXED POINT

	SOJG	LOP,FXS1
SUBTTL	FLOATING POINT ARITHMETIC OPERATIONS
; **********************************************************************

BEGFP:	SKIPN	.FLTF
	JRST	BEGBYT		;DON'T TEST FLOATING

	SKIPN	.FASTF
	JRST	FPS		;FLOATING POINT, SLOW ONLY

; **********************************************************************
;*FLOATING POINT FAST
;*COMPARE RESULTS OF DIV THEN MUL
; **********************************************************************

FPF:	SUBTST

	MOVEI	LOP,^D20
	ASH	LOP,@RTIME	;SETUP RUNNING TIME

	JSR	FSTFP		;FLOATING POINT
	CAI	FPMD+4(CNTR)

	SOJG	LOP,.-2

; **********************************************************************
;*FLOATING POINT SLOW
;*COMPARE MACHINE RESULTS AGAINST SIMULATION
; **********************************************************************

FPS:	SUBTST

	SKIPN	.SLOWF
	JRST	BEGBYT		;DON'T RUN

	MOVEI	LOP,^D10
	ASH	LOP,@RTIME	;SETUP RUNNING TIME

FPS1:	MOVSI	CNTL,FP
	JSR	MD		;FLOATING POINT ADD/SUB
	CAI	FPAS+10(CNTR)

	JSR	MD		;FLOATING POINT SUB/MUL
	CAI	FPSM+10(CNTR)

	JSR	MD		;FLOATING POINT MUL/DIV
	CAI	FPMD+10(CNTR)

	MOVSI	CNTL,FP!FPI
	JSR	MD		;FLOATING POINT IMMEDIATE
	CAI	FPIMMD+10(CNTR)

	SOJG	LOP,FPS1
SUBTTL	BYTE INSTRUCTION OPERATIONS
; **********************************************************************

BEGBYT:	SKIPN	.BYTF
	JRST	BEGDFP		;DON'T TEST BYTE

; **********************************************************************
;*BYTES SLOW
;*COMPARE MACHINE RESULTS AGAINST SIMULATION
; **********************************************************************

BYTS:	SUBTST

	MOVSI	CNTL,BYT
	MOVEI	LOP,^D5
	ASH	LOP,@RTIME	;SETUP RUNNING TIME

	JSR	BYTE		;SIM AND CHECK BYTES
	CAI	BYTES+5(CNTR)

	SOJG	LOP,.-2
SUBTTL	DOUBLE FLOATING POINT OPERATIONS
; **********************************************************************

BEGDFP:	SKIPN	.DFLTF
	JRST	BEGRAND		;DON'T TEST DOUBLE FLOATING

	SKIPN	.FASTF
	JRST	DFPS		;DOUBLE FLOATING, SLOW ONLY

; **********************************************************************
;*DOUBLE FLOATING POINT FAST
;*COMPARE RESULTS OF ADD/SUB AND MUL/DIV
; **********************************************************************

DFPF:	SUBTST

	MOVEI	LOP,^D10
	ASH	LOP,@RTIME	;SETUP RUNNING TIME

	MOVSI	CNTL,DFP
	JSR	FSTFP
	CAI	DFPAS+4(CNTR)	;DOUBLE FLOATING POINT

	SOJG	LOP,.-2

; **********************************************************************
;*DOUBLE FLOATING POINT SLOW
;*COMPARE MACHINE RESULTS AGAINST SIMULATION
; **********************************************************************

DFPS:	SUBTST

	SKIPN	.SLOWF
	JRST	BEGRAND		;DON'T RUN

	MOVEI	LOP,^D10
	ASH	LOP,@RTIME	;SETUP RUNNING TIME

DFPS1:	MOVSI	CNTL,DFP
	JSR	MD
	CAI	DFPAS+10(CNTR)	;DOUBLE FLOATING POINT

	SOJG	LOP,DFPS1
	JRST	BEGRAND
SUBTTL	ARITHMETIC TEST SUBROUTINES

; **********************************************************************
;*FSTMDI - TEST OF IMUL AND IDIV
;*	DIVIDE THEN MULTIPLY AND ADD REMAINDER
; **********************************************************************

FSTMDI:	0
	MOVE	IT,@.-1		;POINT TO INST
	HRROI	CNTR,-4

FSMDI1:	JSR	RANNOV		;RANDOM, OV NOT POSSIBLE

	SETZM	CNTL
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3

	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JFCL	10,FSMDI2	;OV SET, DIVIDE ERROR

	XCT	@IT		;MULTIPLY
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3

	JFCL	10,FSMDI2	;MUL OR DIV ERROR
	ADD	AC,DIVAC+1
	CAME	AC,RA		;LOOK FOR ORIG
FSMDI2:	JSR	FSTER		;ERROR

	AOJL	CNTR,FSMDI1	;NEXT PAIR
	JRST	@FSTMDI		;EXIT

; **********************************************************************
;*FSTMD - TEST OF MUL AND DIV
;*	DIVIDE THEN MULTIPLY AND ADD REMAINDER
; **********************************************************************

FSTMD:	0
	MOVE	IT,@.-1		;POINT TO INST
	HRROI	CNTR,-2

FSTMD1:	JSR	RANNOV		;RANDOM, OV NOT POSSIBLE

	SETZM	CNTL
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3

	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JFCL	10,FSTMD2	;OV SET, DIVIDE ERROR

	JRST	2,@[XWD 0,.+1]	;CLEAR FLAGS
	XCT	@IT		;MULTIPLY
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	JSP	.+1
	MOVEM	SECFLG#

	JFCL	10,FSTMD2	;MUL OR DIV ERROR
	JFCL	17,.+1
	ADD	AC+1,DIVAC+1
	JFCL	2,CRYFIX	;THE CRY 1 FLAG
	JFCL	4,CRY0FX
	CAMN	AC,RA
	CAME	AC+1,RA+1
FSTMD2:	JSR	FSTER		;MUL OR DIV ERROR

	AOJL	CNTR,FSTMD1	;NEXT PAIR
	JRST	@FSTMD		;EXIT

CRYFIX:	TLC	AC+1,400000
	AOJA	AC,FSTMD2-3

CRY0FX:	TLC	AC+1,400000
	SOJA	AC,FSTMD2-2

; **********************************************************************
;*FSTFP - TEST OF FLOATING POINT
;*	FLOATING POINT DIV THEN FLOATING POINT MUL
; **********************************************************************

FSTFP:	0
	MOVE	IT,@.-1		;POINT TO A FP INSTRUCTION
	HRROI	CNTR,-4		;4 ITEMS

FSTFP1:	JSR	RANORM		;NORMALIZED RANDOM NUMBERS

	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	FLAGS,FSTFLG#
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3

	AOJGE	CNTR,GG		;IF JUMP PROG LOST

	JSR	DOINS		;DO A FLOATING POINT MULTIPLY
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3

	CAME	AC,RA
	JRST	FSTFP3		;POSSIBLE ERROR

FSTFP2:	AOJL	CNTR,FSTFP1	;NEXT PAIR
	JRST	@FSTFP		;EXIT

FSTFP3:	MOVEM	FLAGS,SECFLG	;SAVE SECOND FLAGS
	MOVE	FLAGS,FSTFLG
	MOVE	AC		;RESULT NOT EQUAL TO ORIGINAL
	SUBI	1		;IF LARGER OR SMALLER
	CAMN	RA		;COMPARE IT
	JRST	FSTFP2		;OK
	SUBI	1
	CAMN	RA
	JRST	FSTFP2		;OK
	ADDI	3
	CAMN	RA
	JRST	FSTFP2		;OK
	ADDI	1
	CAME	RA
FSTFP4:	JSR	FSTER		;ERROR, FIND WHAT FAILED
	JRST	FSTFP2		;OK

; **********************************************************************
;*BYTE - TEST OF BYTE INSTRUCTIONS
;*	COMPARE MACHINE RESULTS WITH SIMULATION
; **********************************************************************

BYTE:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-5		;5 ITEMS

BYTE1:	JSR	RANDOM		;GENERATE RANDOM NUMBERS

	LSH	RA+2,-^D30	;MAKE A BYTE
	LSH	AC+2,-^D24	;POINTER

	ANDI	AC+2,77		;IF THE POINTER (RIGHT HALF)
	TRNN	CNTR,2
	CAMG	AC+2,RA+2	;WILL BE INCREMENTED
	TRO	AC+2,10000	;POINT TO AC

	TRO	RA+2,100	;IF NO INCREMENT
	ROT	RA+2,^D30	;POINT TO AC+1
	ROT	AC+2,^D24
	ADDB	AC+2,RA+2	;THE POINTER IN RA+2, AC+2

	JSR	SIMIT		;SIMULATE

	JSR	DOIT		;XCT

	AOJL	CNTR,BYTE1	;ITERATE
	JRST	@BYTE		;EXIT

; **********************************************************************
;*DOINS - PERFORM THE MACHINE INSTRUCTION
; **********************************************************************

DOINS:	0
	AOS	AICTLS		;COUNT IT
	JSR	TSTIME

	JRST	2,@[XWD 0,.+1]	;CLEAR FLAGS
DOINS1:	XCT	@IT		;DO THE INSTRUCTION
	JSP	.+1		;SAVE FLAGS

	SKIPE	CKOUTF		;CHECKOUT ?
	TLZ	0,400!200	;YES, CLEAR TN0,TN1
	HLLM	FLAGS		;IN FLAG REGISTR
	JRST	@DOINS

; **********************************************************************
;*MD - TEST INSTRUCTION BY COMPARING MACHINE RESULTS
;*	WITH SIMULATION RESULTS
; **********************************************************************

MD:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-10	;GROUPS OF 8

MD1:	TLNN	CNTL,DFP!FP	;DOUBLE FLOAT OR FLOAT FLAG SET ?
	JRST	MD2		;NO

	SKIPE	KLFLG		;KL10 ?
	JRST	.+3		;YES, NORMALIZED RANDOM

	SKIPN	CKOUTF		;CHECKOUT ?
	JRST	MD2		;NO

	JSR	RANORM		;YES, GENERATE NORMALIZED RANDOM
	JRST	MD2+1

MD2:	JSR	RANDOM		;GENERATE RANDOM NUMBERS

	HLLZS	CNTL		;CLEAR CONTROL SWITCHES
	JSR	SIMIT		;SIMULATE INSTRUCTION

	JSR	DOIT		;XCT INSTRUCTION

	AOJL	CNTR,MD1	;ITERATE
	JRST	@MD		;EXIT

; **********************************************************************
;*SIMIT - SIMULATE THE INSTRUCTION
; **********************************************************************

SIMIT:	0
	JSR	TSTIME

	SAVEM	RA,1

	SINST	@IT		;SIMULATE, RESULTS IN ACS

	JRST	@SIMIT

; **********************************************************************
;*CHECK - COMPARE MACHINE RESULTS AGAINST SIMULATOR
; **********************************************************************

CHECK:	0
	HLR	FLAGS,PCSAV#
	TLZ	FLAGS,USERF!LIP	;CLEAR MISC

	MOVS	FLAGS
	CAME	FLAGS		;COMPARE FLAGS
	HRRI	CNTL,FLAGS	;FLAG ERROR

	SKIPE	KLFLG
	JRST	KLCHK

CHECK3:	CAME	AC+3,4(ACSP)	;COMPARE AC+3
	HRRI	CNTL,AC+3	;AC+3 ERROR

	CAME	AC+2,3(ACSP)	;COMPARE AC+2
	HRRI	CNTL,AC+2	;AC+2 ERROR

	TLNE	CNTL,DFP	;DOUBLE FLOATING POINT
	JRST	CHECK2		;YES, CHECK RESULT LS +-1

	CAME	AC+1,2(ACSP)	;COMPARE AC+1
	HRRI	CNTL,AC+1	;AC+1 ERROR

CHECK1:	CAME	AC,1(ACSP)	;COMPARE AC
	HRRI	CNTL,AC		;AC ERROR

	JRST	@CHECK

CHECK2:	SKIPE	KLFLG		;KL10 ?
	JRST	.+3		;YES

	SKIPN	CKOUTF		;CHECKOUT ?
	JRST	CHECK1-2	;NO

	MOVE	0,AC+1
	CAMN	0,2(ACSP)	;CHECK DBL FP LS +-1
	JRST	CHECK1
	SUBI	0,1
	CAMN	0,2(ACSP)
	JRST	CHECK1
	ADDI	0,2
	CAMN	0,2(ACSP)
	JRST	CHECK1
	JRST	CHECK1-1

KLCHK:	TLNN	CNTL,FP!FPL	;FLOATING POINT ?
	JRST	CHECK3		;NO

	CAME	AC+3,4(ACSP)	;COMPARE AC+3
	JRST	KLCHK1

KLCHKA:	CAME	AC+2,3(ACSP)	;COMPARE AC+2
	JRST	KLCHK2

KLCHKB:	CAME	AC+1,2(ACSP)	;COMPARE AC+1
	JRST	KLCHK3

KLCHKC:	CAME	AC,1(ACSP)	;COMPARE AC
	JRST	KLCHK4

KLCHKD:	JRST	@CHECK

KLCHK1:	MOVE	0,AC+3		;COMPARE AC+3 PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,4(ACSP)
	JRST	KLCHKA
	ADDI	0,2
	CAMN	0,4(ACSP)
	JRST	KLCHKA
	HRRI	CNTL,AC+3
	JRST	@CHECK

KLCHK2:	MOVE	0,AC+2		;COMPARE AC+2 PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,3(ACSP)
	JRST	KLCHKB
	ADDI	0,2
	CAMN	0,3(ACSP)
	JRST	KLCHKB
	HRRI	CNTL,AC+2
	JRST	@CHECK

KLCHK3:	MOVE	0,AC+1		;COMPARE AC+1 PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,2(ACSP)
	JRST	KLCHKC
	ADDI	0,2
	CAMN	0,2(ACSP)
	JRST	KLCHKC
	TLNN	CNTL,FPL
	HRRI	CNTL,AC+1
	JRST	@CHECK

KLCHK4:	MOVE	0,AC		;COMPARE AC PLUS/MINUS 1
	SUBI	0,1
	CAMN	0,1(ACSP)
	JRST	KLCHKD
	ADDI	0,2
	CAMN	0,1(ACSP)
	JRST	KLCHKD
	HRRI	CNTL,AC
	JRST	@CHECK

; **********************************************************************
;*DOIT - PERFORM THE INSTRUCTION
; **********************************************************************

DOIT:	0

	JSR	DOINS		;XCT THE INSTRUCTION

	TLNN	CNTL,ER		;BYPASS IF ERROR
	JSR	CHECK		;CHECK FOR VALID DATA

	TRNN	CNTL,-1
	JRST	@DOIT		;EXIT, NO ERRORS

DOIT1:	TLOE	CNTL,ER		;SET ERROR FLAG
	JRST	DOIT4		;SEE IF PRINT ALL ERRORS

	PNTMSG	[ASCIZ/
**********
SIMULATION COMPARISION FAILURE
/]
	JSR	TTLPNT		;PRINT TITLE
	JSR	RESULT		;PRINT MACHINE RESULTS
	JSR	PNTSIM		;PRINT SIMULATION

DOIT2:	JSR	TSTIME

	MOVEM	CNTL,SAVCNT#	;SAVE CNTL
	TRZ	CNTL,-1		;CLEAR RIGHT HALF

	JSR	CHECK		;CHECK FOR ERROR
	MOVE	AC,RA
	MOVE	AC+1,RA+1
	MOVE	AC+2,RA+2
	MOVE	AC+3,RA+3

	SWITCH			;READ SWITCHES
	TLNE	ERSTOP		;HALT ON ERROR ?
	JSR	GOING		;YES

	TLNE	LOOPER		;PROCEED SWITCH SET?
	JRST	.+4		;NO
	JSR	DOIT3		;YES, GO RING BELL

	TLZ	CNTL,ER		;CLEAR ER FLAG
	JRST	@DOIT		;AND CONT WITH PROG

	TRNE	CNTL,-1		;HAD AN ERROR?
	JSR	DOIT3		;YES, GO RING BELL

	MOVE	CNTL,SAVCNT	;RESTORE CNTL
	JRST	DOIT+1		;CYCLE ERROR

; **********************************************************************
;*FSTER - DETERMINE IF FIRST OR SECOND OPERATION CAUSED FAILURE
; **********************************************************************

FSTER:	0
	SETZM	FAIL1#

	SUBI	CNTR,1		;POINT TO FIRST INSTRUCTION
	JSR	SIMIT		;SIMULATE
	MOVE	AC,DIVAC	;RESTORE FIRST RESULTS.
	MOVE	AC+1,DIVAC+1
	MOVE	AC+2,DIVAC+2
	MOVE	AC+3,DIVAC+3

	TRZ	CNTL,-1
	JSR	CHECK		;CHECK SIM VS ACTUAL
	TRNN	CNTL,-1
	AOJA	CNTR,FSTER2	;LOOKS LIKE SECOND OP FAILED

FSTER1:	PNTMSG	[ASCIZ/
**********
INSTRUCTION COMPARISION FAILURE
/]
	JSR	TTLPNT		;PRINT TITLE
	JSR	RESULTS		;FIRST OP FAILED, PRINT RESULTS

	SAVEM	RA,1

	JSR	PNTSIM		;PRINT SIMULATION

	TLO	CNTL,ER		;SET ER FLAG
	JSR	DOIT		;SCOPE LOOP

	SKIPN	FAIL1		;FIRST OP FAILURE ?
	AOJGE	CNTR,GG		;YES, INC CNTR; IF JUMP PROG LOST
	JRST	@FSTER		;EXIT

FSTER2:	SETOM	FAIL1
	MOVE	RA,DIVAC
	MOVE	RA+1,DIVAC+1
	MOVE	RA+2,DIVAC+2
	MOVE	AC+3,DIVAC+3
	MOVE	AC,MULAC
	MOVE	AC+1,MULAC+1
	MOVE	AC+2,MULAC+2
	MOVE	AC+3,MULAC+3

	JSR	SIMIT		;SIMULATE SECOND OP

	HLL	FLAGS,SECFLG	;GET FLAGS FROM SECOND OP
	JSR	CHECK		;CHECK SIM VS ACTUAL
	TRNE	CNTL,-1		;DID SECOND FAIL ?
	JRST	FSTER1		;YES, PRINT RESULTS

	JRST	@FSTER		;NO, SIM SAYS BOTH OK...CONTINUE

GG:	PNTMSF	[ASCIZ/
INTERNAL PROGRAM PROBLEM, SUGGEST RELOAD, RESTART !
/]
	ERRHLT
	JRST	BEGIN

; **********************************************************************
;*SIMNST - SIMULATE SINGLE INSTRUCTION, NO PRINTOUT
; **********************************************************************

SIMNST:	SETOM	MASK		;INHIBIT PRINTOUT
	MOVE	[XWD 1,SAVAC+1]
	BLT	SAVAC+17
	HRRZ	$SVUUO

	AOS	SIMTLS		;COUNT SIMULATIONS DONE

	MOVEM	INPC		;SETUP PC
	SETZM	INSTR
	SETZM	CNTLPC
	SETOM	SNGLIN		;SET SINGLE INSTRUCTION CONTROL
	SETZM	SNGL2		;SET FOR FIRST INSTR

	GO	SENTRY		;GO TO SIMULATOR
	MOVE	PC
	TLZ	400!200		;CLEAR TN0,TN1
	JSP	1,.+1		;GET ACTUAL FLAGS
	MOVEM	PCSAV#		;SAVE PC FLAGS

	MOVS	[XWD 1,SAVAC+1]
	BLT	17
	JRST	UUOEXT		;EXIT UUO

; **********************************************************************
;*SIMMT - SIMULATE SINGLE INSTRUCTION, PRINT STATES
; **********************************************************************

SIMMT:	SETZM	MASK		;ALLOW PRINTOUT
	JRST	SIMNST+1	;REST SAME AS ABOVE

; **********************************************************************
;*TTLPNT - PRINT PROGRAM TITLE AND PASS COUNT
; **********************************************************************

TTLPNT:	0
	SKIPN	TTLFST#		;FIRST TITLE PRINT ?
	PNTNM			;YES, PRINT PROGRAM NAME
	SETOM	TTLFST

	AOS	ERRTLS		;INCREMENT ERROR TOTALS

	JSR	RUNTIM		;PRINT PROGRAM RUN TIME

TLPNT1:	PNTMSG	[ASCIZ/
BASE RANDOM NUMBER = /]
	MOVE	0,RANDBS
	PNTHW			;PRINT RANDOM NUMBER BASE

	MOVE	PASCNT		;PRINT PASS COUNT
	CAMN	PSCTR1#
	JRST	TLPNT2
	PNTMSG	[ASCIZ/
TEST PASS COUNT = /]
	MOVE	PASCNT
	MOVEM	PSCTR1
	PNTDEC

TLPNT2:	PCRL
	JRST	@TTLPNT

DOIT3:	0
	TLNE	DING		;RING BELL ON ERROR ?
	PBELL
	JRST	@DOIT3

; **********************************************************************
;*DOIT4 - CHECK PRINT ALL ERRORS SWITCH
; **********************************************************************

DOIT4:	SWITCH
	TLNN	PALERS		;PRINT ALL ERRORS ?
	JRST	DOIT2		;NO, DON'T PRINT...NOT FIRST
	JRST	DOIT1+2

; **********************************************************************
;*RANDOM - RANDOM NUMBER GENERATION
;*	FOUR RANDOM IN AC,AC+1,AC+2,AC+3
;*	A COPY ALSO IN RA,RA+1,RA+2,RA+3
; **********************************************************************

RANDOM:	0

	MOVE	AC,RA
	ADD	AC,[543217335216]
	ROT	AC,-1
	EQVB	AC,RA		;RANDOM 1

	MOVS	AC+1,RA
	ADD	AC+1,[165742176525]
	ROT	AC+1,-1
	EQVB	AC+1,RA+1	;RANDOM 2

	MOVS	AC+2,RA+1
	ADD	AC+2,[147532173543]
	ROT	AC+2,-1
	EQVB	AC+2,RA+2	;RANDOM 3

	MOVS	AC+3,RA+2
	ADD	AC+3,[731341527517]
	ROT	AC+3,-1
	EQVB	AC+3,RA+3	;RANDOM 4

	JRST	@RANDOM

; **********************************************************************
;*RANNOV - RANDOM NUMBER GENERATION
;*	OVERFLOW NOT POSSIBLE FOR DIVIDE
; **********************************************************************

RANNOV:	0
	JSR	RANDOM		;GENERATE RANDOM

	MOVM	AC+2
	MOVMM	RA,TEMP#
	CAMN	TEMP
	JRST	RANNOV+1	;DIVISOR=HI DIVIDEND

	CAML	TEMP
	JRST	.+3

	EXCH	AC,AC+2		;DIVISOR SMALLER, EXCHANGE
	EXCH	RA,RA+2		;TO MAKE LARGER

	JUMPE	RA+2,RANNOV+1
	TRNN	AC+2,-1
	JRST	RANNOV+1	;REJECT IF 0 FOR IDIV1

	TLZ	AC+1,400000	;NORMALIZE
	TLNE	AC,400000
	TLO	AC+1,400000
	MOVEM	AC+1,RA+1

	JRST	@RANNOV

; **********************************************************************
;*RANORM - RANDOM NUMBER GENERATION
;*	NORMALIZED RANDOM FOR FLOATING POINT
; **********************************************************************

RANORM:	0
	JSR	RANDOM
	NORM	RA+3,AC+3
	NORM	RA+2,AC+2

	TLNN	CNTL,FPI	;FLOATING POINT IMMEDIATE ?
	JRST	.+4		;NO

	TLNN	AC+2,000777	;ANY FRACTIONAL PART ?
	TLO	AC+2,400	;NO, MAKE ONE
	MOVSS	RA+2,AC+2	;PUT SIGNIFICANT PART IN LOWER 18

	NORM	RA+1,AC+1
	NORM	RA,AC
	JRST	@RANORM

; **********************************************************************
;*PNTSIM - SIMULATE AND PRINT THE INSTRUCTION
; **********************************************************************

PNTSIM:	0
	SAVEM	RA,1

	SMT	@IT		;SIMULATE AND PRINT

	JRST	@PNTSIM

; **********************************************************************
;*RESULT - PRINT FAST TEST FAILURE RESULTS
; **********************************************************************

RESULT:	0
	SETOM	PNTSPC		;SET TO SPACE AFTER OCTALS

	PNTMSG	[ASCIZ/
FLAGS FROM MACHINE & SIMULATE - /]
	MOVE	FLAGS
	PNTHW

	MOVEI	[ASCIZ/
MACHINE  RESULTS IN AC,AC+1,E  /]
	TLNE	CNTL,BYT	;BYTE ERROR
	MOVEI	[ASCIZ/
MACHINE  RESULTS IN AC,POINTER,E  /]
	PNTAL

	GO	RSLTS1		;PRINT MACHINE RESULTS

	MOVE	AC,1(ACSP)	;PUT SIMULATED RESULTS IN AC'S
	MOVE	AC+1,2(ACSP)
	MOVE	AC+2,3(ACSP)
	MOVE	AC+3,4(ACSP)
	MOVEI	[ASCIZ/
SIMULATE RESULTS IN AC,AC+1,E  /]
	TLNE	CNTL,BYT	;BYTE ERROR
	MOVEI	[ASCIZ/
SIMULATE RESULTS IN AC,POINTER,E  /]
	PNTAL

	GO	RSLTS1		;PRINT SIMULATED RESULTS

	SETOM	PNTSPC
	PCRL
	JRST	@RESULT

RSLTS1:	SETOM	PNTSPC		;SET TO SPACE AFTER OCTALS

	HLRZ	AC		;PRINT AC
	PNT6
	SETZM	PNTSPC
	HRRZ	AC
	PNT6
	PNTCI	","

	SETOM	PNTSPC
	TLNE	CNTL,BYT
	EXCH	AC+1,AC+2
	HLRZ	AC+1		;PRINT AC+1
	PNT6
	SETZM	PNTSPC
	HRRZ	AC+1
	PNT6
	PNTCI	","

	SETOM	PNTSPC
	HLRZ	AC+2		;PRINT AC+2, (E)
	PNT6
	SETZM	PNTSPC
	HRRZ	AC+2
	PNT6

	RTN
SUBTTL	ARITHMETIC INSTRUCTIONS TESTED

; **********************************************************************
;*FIXEDI - INTERGER FIXED POINT
; **********************************************************************

FIXEDI:	IDIV	AC,AC+2
	IMUL	AC,AC+2
	IDIVI	AC,(AC+2)
	IMULI	AC,(AC+2)
	IDIVM	AC,AC+2
	IMULM	AC,AC+2
	IDIVB	AC,AC+2
	IMULB	AC,AC+2

; **********************************************************************
;*FIXED - MULTIPLY AND DIVIDE
; **********************************************************************

FIXED:	DIV	AC,AC+2
	MUL	AC,AC+2
	DIVI	AC,(AC+2)
	MULI	AC,(AC+2)
	MULM	AC,AC+2
	DIVM	AC,AC+2
	MULB	AC,AC+2
	DIVB	AC,AC+2

; **********************************************************************
;*FPAS - FLOATING POINT: ADD, SUBTRACT
; **********************************************************************

FPAS:	FAD	AC,AC+2
	FSB	AC,AC+2
	FADR	AC,AC+2
	FSBR	AC,AC+2
	FADM	AC,AC+2
	FADB	AC,AC+2
	FADRM	AC,AC+2
	FADRB	AC,AC+2

; **********************************************************************
;*FPSM - FLOATING POINT: SUBTRACT, MULTIPLY
; **********************************************************************

FPSM:	FSBM	AC,AC+2
	FSBB	AC,AC+2
	FSBRM	AC,AC+2
	FSBRB	AC,AC+2
	FMPM	AC,AC+2
	FMPB	AC,AC+2
	FMPRM	AC,AC+2
	FMPRB	AC,AC+2

; **********************************************************************
;*FPMD - FLOATING POINT: MULTIPLY, DIVIDE
; **********************************************************************

FPMD:	FMP	AC,AC+2
	FDV	AC,AC+2
	FMPR	AC,AC+2
	FDVR	AC,AC+2
	FDVM	AC,AC+2
	FDVB	AC,AC+2
	FDVRM	AC,AC+2
	FDVRB	AC,AC+2

; **********************************************************************
;*FPIMMD - FLOATING POINT: IMMEDIATE
; **********************************************************************

FPIMMD:	FADRI	AC,(AC+2)
	FSBRI	AC,(AC+2)
	FMPRI	AC,(AC+2)
	FDVRI	AC,(AC+2)
	FADRI	AC,(AC+2)
	FSBRI	AC,(AC+2)
	FMPRI	AC,(AC+2)
	FDVRI	AC,(AC+2)

; **********************************************************************
;*BYTES - BYTE INSTRUCTIONS
; **********************************************************************

BYTES:	IBP	AC+2
	ILDB	AC,AC+2
	IDPB	AC,AC+2
	LDB	AC,AC+2
	DPB	AC,AC+2

; **********************************************************************
;*DFPAS - DOUBLE FLOATING POINT: ADD, SUBTRACT
; **********************************************************************

DFPAS:	DFSB	AC,AC+2
	DFAD	AC,AC+2

; **********************************************************************
;*DFPMD - DOUBLE FLOATING POINT: MULTIPLY, DIVIDE
; **********************************************************************

DFPMD:	DFMP	AC,AC+2
	DFDV	AC,AC+2

; **********************************************************************
;*FPMISC - FLOATING POINT: MISCELLANEOUS
; **********************************************************************

FPMISC:	FLTR	AC,AC+2
	FIX	AC,AC+2
	FIXR	AC,AC+2
	FLTR	AC,AC+2
SUBTTL	RANDOM DIAGNOSTIC SECTION

; **********************************************************************
;*PROGRAM DESIGNED TO EXECUTE RANDOM INSTRUCTIONS (NON-PC CHANGE)
;* IN MEMORY, IN THE FAST AC'S, AND THRU SOFTWARE SIMULATION.
;*THE RESULTS OF THE THREE GROUPS OF INST ARE COMPARED FOR EQUALITY.
;*UPON A DISCREPENCY THE PROGRAM PRINTS ALL PERTINENT INFORMATION
;* AND GOES INTO A REPETITIVE FAILURE LOOP.
;*
;*THE PROGRAM OPERATES AS FOLLOWS:
;*	1. GENERATES EIGHT RANDOM NUMBERS AND STORES
;*	   THEM IN AC 0-7.
;*	2. RESTORES THEM IN RAND-RAND+7
;*	3. TEST AC'S FOR VALID INST.
;*		A. OP CODES 0-17 CHANGED TO DFAD
;*		B. OP CODES 20-37 CHANGED TO DFSB
;*		C. OP CODES 40-57 CHANGED TO DFMP
;*		D. OP CODES 60-77 CHANGED TO DFDV
;*		E. OP CODES 100-107 CHANGED TO ROTC
;*		F. OP CODES 114-117,123 CHANGED TO DFDV
;*		G. OP CODES 133-137 CHANGED TO ASHC
;*		H. OP CODES 243+247 CHANGED TO IMUL
;*		I. OP CODES 260-267 CHANGED TO IMUL
;*		J. OP CODES 251-257 CHANGED TO IMUL
;*		K. OP CODES 300-377 CHANGED TO FSBR
;*		L. OP CODES 600-677 CHANGED TO FDVR IF
;*		   IT IS THE LAST INST IN THE INST GROUP
;*		M. OP CODES OF 700-777 CHANGED TO FMPR
;*		N. THEN ALL VALID INST. ARE MASKED FOR
;*		   INDEX REG, INDIRECT, AC'S ABOVE 7, AND
;*		   ONLY AN "E" FIELD OF 0-7.
;*	4. STORES VALID INST IN INSBLK
;*	5. SETS UP SLOW MEMORY LOOP WITH SIMULATION TRANSFER
;*	   BETWEEN EACH VALID INST.
;*	6. EXECUTES & SIMULATES SLOW LOOP.
;*	7. COMPARES RESULTS AFTER EACH INST/SIMULATION.
;*	8. STORES ANS. (AC'S 0-7) IN ANSBLK.
;*	9. LOADS FAST LOOP AND AC'S
;*	10. EXECUTES FAST LOOP.
;*	11. COMPARES FAST LOOP AND SLOW LOOP ANS.
;*	12. RE-EXECUTES FAST LOOP 7 TIMES WITH ANS CHECKING.
;*	13. UPON AN ERROR THE PROGRAM WILL OUTPUT ON LPT OR TTY,
;*	    THE OPERANDS, INSTRUCTIONS, SLOW/FAST LOOP
;*	    ANSWERS, AND THE SIM/SLOW LOOP ANSWERS.
;*	14. THE PROGRAM WILL THEN SIMULATE AND PRINT THE
;*	 APPROPRIATE FAILING INSTRUCTION(S).
;*	15. IT THEN WILL GO INTO AN ERROR LOOP.
; **********************************************************************

; **********************************************************************
;*BEGRAND - RANDOM TEST CONTROL
; **********************************************************************

BEGRAND:SUBTST

	SKIPN	.RANF
	JRST	BEGINT		;RANDOM INSTRUCTION INHIBITED

	SETZM	ERRCNT#		;ERROR COUNT

	SETZM	RLOOPC#		;CLEAR RANDOM LOOP COUNTER

	MOVE	RANDBS		;SETUP RANDOM BASE
	MOVEM	K1#

CONTNU:	MOVE	10,FLCNT
	MOVEM	10,K2#		;SETUP FAST LOOP ITERATE COUNTER

	SETZM	PRNT#		;PRINT FLAG
	SETZ	12,0

CONTN1:	MOVS	10,K1		;RESTART TO CONTINUE RANDOM NUMBERS
	MULI	10,6065		
	DIV	10,[XWD 377777,777741]
	MOVEM	11,K1
	MOVEM	11,0(12)
	AOS	12,12
	CAIE	12,10
	JRST	CONTN1

	HRRI	12,RAND		;STOR NUM IN RAND TO RAND+7 AND AC 0-7
	HRLI	12,0
	BLT	12,RAND+7

; **********************************************************************
;*VIT - CREATE A VALID INSTRUCTION
; **********************************************************************

VIT:	SETZ	12,0		;TEST FOR VALID INST
	MOVE	11,@12
	AND	11,[XWD 770000,0]
	ROT	11,6

	CAIGE	11,20		;LESS THAN OP CODE 200 ?
	JRST	XKL10		;YES, SPECIAL INSTRUCTIONS

	CAIGE	11,11		;LESS THAN 110
	JRST	XCONVT		;YES, MAKE NEW INST

	CAIGE	11,13		;LESS THAN 130
	JRST	NWINST		;YES, MAKE NEW KI INSTRUCTIONS

	CAIGE	11,14		;LESS THAN 140
	JRST	BYTTST		;YES GO CHECK FOR POSSIBLE BYTE OR FSC

	CAIN	11,26		;CHECK FOR PUSH,POP
	JRST	XIMUL		;GO MAKE NEW INST (IMUL)

	CAIN	11,25		;CHECK FOR JMP INST
	JRST	ECHTST		;GO CHECK FOR POSSIBLE EXCH

	LSH	11,-3
	CAIN	11,3		;CHECK FOR SKIPS & JMPS
	JRST	XFSBR		;GO MAKE NEW INST(FSBR)

	CAIN	11,6		;CHECK FOR TST INST
	JRST	TSTTST		;GO CHECK FOR LAST INST IN GROUP

	CAIN	11,7		;CHECK FOR IOT
	JRST	XFMPR		;GO MAKE NEW INST(FMPR)

	CAIE	11,2		;CHECK FOR JFFO
	JRST	MASKX		;NO

	JSR	ARANGE		;YES, POSSIBLE

	CAIN	13,243
	JRST	XIMUL		;GO MAKE NEW INST (IMUL)

	CAIN	13,247		;MAP INSTRUCTION
	JRST	XIMUL		;MAKE IMUL

	JRST	MASKX		;GO MASKX OUT UNWANTED BITS

ARANGE: 0			;GET OPERATION CODE OF OPERAND
	MOVE	13,@12
	AND	13,[XWD 777000,0]
	ROT	13,9
	JRST	@ARANGE

BYTTST:	JSR	ARANGE
	CAILE	13,132		;CHECK FOR FSC OR BYTE
	JRST	XASHC		;NO,MAKE NEW INST (ASHC)
	JRST	MASKX		;YES,GO MASKX OUT UNWANTED BITS

ECHTST:	JSR	ARANGE		;GO GET OP CODE
	CAIE	13,250		;POSSIBLE EXCHANGE INST
	JRST	XIMUL		;NO,MAKE NEW INST (IMUL)
	JRST	MASKX		;YES,GO MASKX OUT UNWANTED BITS

TSTTST:	CAILE	12,4		;POSSIBLE TST INST IF NOT LAST IN GROUP
	JRST	XFDVR		;NO,GO MAKE NEW INST (FDVR)
	JRST	MASKX		;YES,GO MASKX OUT UNWANTED BITS

VITEXT:	AOS	12
	MOVEM	11,INSBLK-1(12)	;STOR VALID INST IN INSBLK TO INS BLK+7
	CAIN	12,7
	JRST	SLO		;GO SET UP SLOW LOOP
	JRST	VIT+1		;GO TEST MORE

XKL10:	CAIGE	13,120		;0 TO 117 - MAKE DIV
	JRST	XDVR
	CAIG	13,122		;DMOVE, DMOVN, FIX - OK
	JRST	MASKX
	CAIN	13,123		;123 - MAKE MUL
	JRST	XMPR
	CAIGE	13,130		;DMOVEM, DMOVNM, FIXR, FLTR - OK
	JRST	MASKX
	CAIGE	13,140		;130-137, MAKE DIV
	JRST	XDVR
	CAIGE	13,150		;140-147, MAKE MUL
	JRST	XMPR
	CAIGE	13,160		;150-157, MAKE SUB
	JRST	XSBR
	CAIGE	13,170		;160-167, MAKE ADD
	JRST	XADD
	JRST	XASHC		;170-177, MAKE ASHC

MMASKX:	0			;MAKE NEW INST
	MOVE	11,@12
	TLZ	11,777000
	XCT	@MMASKX
	JRST	MASKX+1

XROTC:	JSR	MMASKX
	ADD	11,[XWD 245000,0]	;MAKE IT A ROTC

XIMUL:	JSR	MMASKX
	ADD	11,[XWD 220000,0]	;MAKE IT A IMUL

XFDVR:	SKIPE	KLFLG
	JRST	XDVR
	JSR	MMASKX		;MAKE IT A FDVR
	ADD	11,[XWD 174000,0]

XDVR:	JSR	MMASKX
	ADD	11,[234000,,0]	;MAKE IT A DIV

XMPR:	JSR	MMASKX
	ADD	11,[224000,,0]	;MAKE IT A MUL

XSBR:	JSR	MMASKX
	ADD	11,[274000,,0]	;MAKE IT A SUB

XADD:	JSR	MMASKX
	ADD	11,[244000,,0]	;MAKE IT A ADD

XFMPR:	SKIPE	KLFLG
	JRST	XMPR
	JSR	MMASKX
	ADD	11,[XWD 164000,0]	;MAKE IT A FMPR

XFSBR:	SKIPE	KLFLG
	JRST	XSBR
	JSR	MMASKX
	ADD	11,[XWD 154000,0]	;MAKE IT A FSBR

XASHC:	JSR	MMASKX
	ADD	11,[XWD 244000,0]	;MAKE IT A ASHC

XDFAD:	JSR	MMASKX
	ADD	11,[XWD	110000,0]	;MAKE DFAD

XDFSB:	JSR	MMASKX
	ADD	11,[XWD 111000,0]	;MAKE DFSB

XDFMP:	JSR	MMASKX
	ADD	11,[XWD 112000,0]	;MAKE DFMP

XDFDV:	JSR	MMASKX
	ADD	11,[XWD 113000,0]	;MAKE DFDV

MASKX:	MOVE	11,@12		;MASK OUT INDEX REG & HIGH ORDER E FIELD
	AND	11,[XWD 777340,7]
	JRST	VITEXT

XCONVT:	SKIPN	KLFLG
	SKIPN	NEWFLG		;MAKE NEW INST'S
	JRST	XROTC		;NO
	CAIGE	11,02
	JRST	XDFAD		;0-17 MAKE DFAD
	CAIGE	11,04
	JRST	XDFSB		;20-37 MAKE DFSB
	CAIGE	11,06
	JRST	XDFMP		;40-57 MAKE DFMP
	CAIGE	11,10
	JRST	XDFDV		;60-77 MAKE DFDV
	JRST	XROTC		;100-107 MAKE ROTC

NWINST:	SKIPN	NEWFLG		;MAKE NEW INST'S
	JRST	XROTC		;NO
	JSR	ARANGE
	CAIG	13,113
	JRST	MASKX		;DOUBLE FP
	CAIGE	13,120
	JRST	XDFDV		;MAKE NEW INST (DFDV)
	CAIG	13,122
	JRST	MASKX		;DOUBLE MOVES
	CAIN	13,123
	JRST	XDFDV		;MAKE NEW INST (DFDV)
	JRST	MASKX		;DBL MOVES MEM, FIX, FLT

; **********************************************************************
;*SLO - PERFORM RANDOM INSTRUCTIONS FROM MEMORY
; **********************************************************************

SLO:	SUBTST

	AOS	RANTLS		;COUNT RANDOM LOOPS DONE

	MOVE	10,INSBLK	;GO STORE INSTRUCTIONS
	MOVEM	10,MEMIN1	;IN MEMORY LOOP
	MOVE	10,INSBLK+1
	MOVEM	10,MEMIN2
	MOVE	10,INSBLK+2
	MOVEM	10,MEMIN3
	MOVE	10,INSBLK+3
	MOVEM	10,MEMIN4
	MOVE	10,INSBLK+4
	MOVEM	10,MEMIN5
	MOVE	10,INSBLK+5
	MOVEM	10,MEMIN6
	SETZM	SVINPC#		;CLEAR SVINPC FOR ERROR

SLO1:	JSR	TSTIME

	SETZM	MEMXF		;CLEAR FLAG FOR SIMULATION
	MOVSI	10,RAND
	BLT	10,7		;SETUP AC OPERANDS
	MOVE	10,[RAND,,ACS]
	BLT	10,ACS+7	;SETUP SIMULATOR OPERANDS
	SETZB	10,ACS+10	;AC10 IS 0 IN BOTH
	JRSTF	@.+1		;CLEAR FLAGS
		.+1

MEMLOP:	SETZM	NOSKPF		;CLEAR NO SKIP FLAG
MEMIN1:	0			;1ST INSTRUCTION
	SETOM	NOSKPF		;NO SKIP
	JSR	MEMEX		;GO TO SIMULATION
MEMIN2:	0			;2ND INST
	SETOM	NOSKPF
	JSR	MEMEX
MEMIN3:	0			;3RD INST
	SETOM	NOSKPF
	JSR	MEMEX
MEMIN4:	0			;4TH INST
	SETOM	NOSKPF
	JSR	MEMEX
MEMIN5:	0			;5TH INST
	SETOM	NOSKPF
	JSR	MEMEX
MEMIN6:	0			;6TH INST
	SETOM	NOSKPF
	JSR	MEMEX
	JRST	.+3
MEMXF:	0			;SIMULATION FLAG
NOSKPF:	0			;NO SKIP FLAG
	SKIPGE	K2		;PREVIOUS FAILURE, BUT NONE THIS TIME ?
	JRST	MEMR1		;YES

	MOVEI	10,ANSBLK
	BLT	10,ANSBLK+7	;SAVE ANSWERS

	MOVE	10,FLCNT
	MOVEM	10,K2		;SETUP FAST LOOP COUNT
	SETZM	MEMXF		;CLEAR SIMULATION FLAG

; **********************************************************************
;*FASTLP - PERFORM RANDOM INSTRUCTIONS FROM THE AC'S
; **********************************************************************

FASTLP:	SUBTST
	JSR	TSTIME

	MOVE	10,[INSBLK,,11]
	BLT	10,16		;LOAD FAST LOOP INSTRUCTIONS
	MOVSI	10,RAND
	BLT	10,7		;LOAD OPERANDS
	SETZM	10

EXFAST:	SKIPN	USER
	CONO	PI,PIOFF

	MOVE	17,[JRST CHEC]	;SETUP EXIT INST
	JRSTF	@.+1		;CLEAR FLAGS
		.+1
	JRST	11		;GO TO FAST LOOP

CHEC:	MOVEM	0,ANSSV0#
	MOVE	P,PLIST
	MOVEI	$PSHER
	PUT	0
	SKIPN	USER
	CONO	PI,PION

	MOVE	0,ANSSV0
	CAME	0,ANSBLK	;CHECK FAST LOOP AND SLOW LOOP ANS
	JSR	ERRX

	CAME	1,ANSBLK+1
	JSR	ERRX

	CAME	2,ANSBLK+2
	JSR	ERRX

	CAME	3,ANSBLK+3
	JSR	ERRX

	CAME	4,ANSBLK+4
	JSR	ERRX

	CAME	5,ANSBLK+5
	JSR	ERRX

	CAME	6,ANSBLK+6
	JSR	ERRX

	CAME	7,ANSBLK+7
	JSR	ERRX

CHEC1:	SKIPGE	K2		;FAILURE ?
	JRST	FSTLP1		;YES

	SOSE	K2		;REPEAT FAST LOOP ?
	JRST	FASTLP		;YES

CHEC2:	SWITCH

	AOS	16,RLOOPC
	TLNE	RELIAB		;RELIABILITY MODE ?
	JRST	.+4

	TRNE	16,7		;NO, ITERATE RANDOM 8 TIMES
	JRST	CONTNU

	JRST	BEGINT

	TRNE	16,37		;YES, ITERATE RANDOM 32 TIMES
	JRST	CONTNU

	JRST	BEGINT		;DONE, GO DO INTERRUPT TEST

FSTLP1:	SWITCH
	TLNN	LOOPER		;STAY IN ERROR LOOP
	JRST	CHEC2		;NO

	JRST	FASTLP		;YES, REPEAT FAILING LOOP

MEMEX:	0
	MOVEM	10,SAC10#

	MOVE	10,MEMEX	;GET CALL PC
	SUBI	10,3		;-3, POINTS TO INST
	MOVEM	10,INPC		;SAVE AS SIM PC

	ADDI	10,3
	SKIPN	NOSKPF		;DID INST SKIP ?
	ADDI	10,3		;YES, SET RETURN TO SKIP NEXT INST

	MOVEM	10,MEMEX
	SETZM	NOSKPF
	MOVE	10,SAC10

	SKIPN	SIMFLG		;SIMULATE INSTRUCTION ?
	JRST	@MEMEX		;NO

MEMEX1:	SETOM	MEMXF
	MOVE	10,[ACS,,SIMBLK]
	BLT	10,SIMBLK+10	;SAVE ORIG SIM AC'S FOR ERROR

	SETOM	MASK
	JSR	SIMI		;SIMULATE INSTRUCTION

	CAME	0,ACS+0		;COMPARE AC RESULTS & SIM RESULTS
	JSR	ERRX		;ERROR

	CAME	1,ACS+1
	JSR	ERRX

	CAME	2,ACS+2
	JSR	ERRX

	CAME	3,ACS+3
	JSR	ERRX

	CAME	4,ACS+4
	JSR	ERRX

	CAME	5,ACS+5
	JSR	ERRX

	CAME	6,ACS+6
	JSR	ERRX

	CAME	7,ACS+7
	JSR	ERRX

	MOVE	10,SAC10
	JRST	@MEMEX		;EXIT

MEMR1:	SWITCH
	TLNN	LOOPER		;LOOP ON ERROR ?
	JRST	CHEC2		;NO

	JRST	SLO1		;YES, STAY IN SLOW LOOP

; **********************************************************************
;*ERRX - ERROR ROUTINES
; **********************************************************************

ERRX:	0
	MOVEM	0,SAV0#
	SWITCH
	MOVEM	0,10
	MOVE	0,SAV0

	SKIPE	PRNT		;FIRST OUTPUT
	TLNE	10,PALERS	;PRINT ALL ERRORS ?
	JSR	OUT		;GO OUTPUT

ERRX1:	AOS	ERRCNT
	AOS	ERRTLS
	SWITCH
	TLNE	ERSTOP		;HALT ON ERROR ?
	JSR	GOING		;YES

	TLNE	0,LOOPER	;LOOP ON ERROR ?
	SETOM	K2		;YES, MAKES LOOP EFF FOREVER

	TLNE	DING		;RING TTY BELL ?
	PBELL

ERRX2:	SKIPE	MEMXF		;IN SIMULATION ?
	JRST	MEMR1		;YES

	JRST	FSTER1		;NO

; **********************************************************************
;*GOING - HALT ON ERROR
; **********************************************************************

GOING:	0
	SKIPN	USER
	CONO	PI,PIOFF	;TURN OFF INTERRUPTS
	MOVEM	0,$ACC0		;SAVE AC0

	ERRHLT			;HALT - WAIT FOR CONTINUE

	MOVE	0,$ACC0		;RESTORE AC0
	SKIPN	USER
	CONO	PI,PION		;TURN ON INTERRUPTS
	JRSTF	@GOING		;CONTINUE

; **********************************************************************
;*OUT - PRINT RANDOM INSTRUCTION FAILURE
; **********************************************************************

OUT:	0
	SETZM	EXIT1#		;CLEAR EXIT FLAG
	MOVEI	10,FSTANS	;SAVE FAST LOOP ANSWERS
	BLT	10,FSTANS+7
	MOVEI	0,7		;INIT INST CNT,
	MOVEM	0,INTCNT#
	MOVEM	0,ACCNT#	;AND AC CNT

	PNTNM
	PNTMSG	[ASCIZ/
**********/]
	JSR	RUNTIM		;PRINT RUN TIME

OUTX:	PNTMSG	0,[ASCIZ/
RANDOM INSTRUCTION FAILURE
    INST GROUP        OPERANDS           /]

	MOVEI	[ASCIZ/SLOW ANS          SIM ANS/]
	SKIPN	MEMXF
	MOVEI	[ASCIZ/FAST ANS          SLOW ANS/]
	PNTAL
	SETZM	PNTSPC

OUT1:	MOVE	10,INTCNT
	SOJE	10,LOOP		;MONITOR CNT
	MOVEM	10,INTCNT
	SETCA	10,0
	ANDI	10,7
	PCRL
	SETZM	PNTSPC
	MOVEI	0,1		;PRINT FIRST DIGIT
	PNT1			;OF INST GROUP AND,
	MOVE	0,10
	PNT1			;2ND DIGIT
	PMSG	</ >		;PRINT / SPACE 
	MOVE	0,INSBLK-1(10)
	PNTHW			;PRINT INST

OUT2:	JSR	ACPNT1		;PRINT AC
	MOVE	0,RAND(10)
	PNTHW			;PRINT OPERANDS
	JSR	ACPNT1		;PRINT AC
	MOVE	0,FSTANS(10)	;PRINT FAST ANS/SIM - SLOW ANS
	PNTHW			;PRINT AC
	JSR	ACPNT1		;PRINT AC NUMBER
	MOVE	0,ACS(10)
	SKIPN	MEMXF
	MOVE	0,ANSBLK(10)
	PNTHW			;PRINT SLOW ANS/SIM - SIM ANS
	SOSLE	ACCNT
	JRST	OUT1

OUT3:	SKIPE	EXIT1
	JRST	OUT4
	PNTMSG	[ASCIZ /
                  / ]		;PRINT MARGIN
	SETOM	EXIT1
	JRST	OUT2

OUT4:	SETOM	PRNT
	PCRL
	PNTMSG	[ASCIZ/
BASE RANDOM NUMBER = /]
	MOVE	RANDBS
	PNTHW			;PRINT RANDOM BASE
	PCRL

OUT5:	SKIPN	SIMFLG		;SIMULATION INHIBITED ?
	JRST	@OUT		;YES
	SKIPN	MEMXF		;SLOW LOOP FAILURE ?
	JRST	SIMFST		;NO

	PNTMSG	[ASCIZ/
INSTRUCTION SIMULATION - MEMORY LOOP INST # /]
	HRRZ	INPC		;COMPUTE INST NUMBER
	SUBI	MEMIN1
	IDIVI	3
	ADDI	1
	PNT1			;PRINT
	PNTMSG	[ASCIZ/
----------
/]
	MOVS	10,[ACS,,SIMBLK]
	BLT	10,ACS+10	;RESTORE SIM OPERANDS
	JRST	SIMIP		;SIM & PRINT INSTRUCTION

ACPNT1:	0
	PNTCI	" "
	MOVE	10,ACCNT	;GET AC NUMBER
	SETCA	10,0
	ANDI	10,7
	MOVE	0,10
	SETZM	PNTSPC
	PNT1			;PRINT IT
	PMSG	</ >
	JRST	@ACPNT1

LOOP:	PCRL
	MOVEI	0,17		;PRINT 17
	SETZM	PNTSPC
	PNT2
	PMSG	</ >
	PNTMSG	[ASCIZ/   EXIT       /]	;PRINT EXIT
	JRST	OUT2

; **********************************************************************
;*PNTTOT - PRINT ERROR TOTALS
; **********************************************************************

PNTTOT:	0
	JSR	RUNTIM		;PRINT RUN TIME

	PNTMSG	[ASCIZ/
TEST PASS COUNT = /]
	MOVE	PASCNT
	PNTDEC			;PRINT PASS COUNT

	PNTMSG	[ASCIZ/
TOTAL ERRORS = /]
	MOVE	ERRTLS
	PNTDEC			;PRINT TOTAL ERRORS

	PNTMSG	[ASCIZ/
BASE RANDOM NUMBER = /]
	MOVE	0,RANDBS
	PNTHW			;PRINT RANDOM BASE

	PCRL
	JRST	@PNTTOT		;CONTINUE

ARANTLS:PNTMSG	[ASCIZ/
ARITHMETIC INSTRUCTIONS = /]
	MOVE	AICTLS
	PNTDEC

	PNTMSG	[ASCIZ/
ARITHMETIC SIMULATIONS = /]
	MOVE	SIMTLS
	PNTDEC

	PNTMSG	[ASCIZ/
RANDOM INST LOOPS = /]
	MOVE	RANTLS
	PNTDEC

	PNTMSG	[ASCIZ/
RANDOM SIMULATIONS = /]
	MOVE	RSIMTLS
	PNTDEC
	PCRL
	RTN

; **********************************************************************
;*TSTIME - TEST RUN TIME SUBROUTINE
;*	DOES 'TTALTM' TYPEIN CHECKING
;*	PRINTS APPROPRIATE HELPFUL INFORMATION
;*	PRINTS TIME AT 15 MINUTE INTERVALS OR WHEN REQUESTED
; **********************************************************************

TSTIME:	0

	MOVEM	0,SAC0
	TTALTM
	SKIPA
	JRST	DDTEX+1		;ALTMODE, GO TO DDT

	CAIN	0,"E"-100	;CONTROL-E TYPED ?
	JRST	TSTIMJ		;YES, IF USER GIVE ERROR PC & TOTALS

	CAIN	0,"R"		;R TYPED
	JRST	TSTIMG		;YES, PRINT RUN TIME, TEST PC, TEST DESCRIPTION

	CAIN	0,"T"		;T TYPED ?
	JRST	TSTIMH		;YES, GIVE TOTALS

	CAIN	0,"H"		;H TYPED ?
	JRST	TSTIMI		;YES, GIVE HELP MESSAGE

	MOVE	0,SAC0
	SKIPN	USER		;USER MODE ?
	SKIPN	CLKON		;OR CLOCK INHIBITED ?
	JRST	@TSTIME		;YES, EXIT

	PUT	0
	PUT	1
	MOVE	TICKS		;UPDATE TIME
	SUB	TSTIMR
	CAMGE	HERTZQ
	JRST	TSTIMF		;NOT QUARTER HOUR YET

TSTIMC:	SETOM	TIMFRC		;SET QUARTER HOUR FORCE PRINT TIME FLAG
	JSR	TSTIMA		;GO PRINT TIME

TSTIMF:	GET	1
	GET	0
	JRST	@TSTIME

TSTIMH:	MOVE	0,SAC0		;T TYPED
	PUT	0
	PUT	1
	PNTMSG	[ASCIZ/
----------
/]
	JSR	PNTTOT		;PRINT ERROR TOTALS & BASE RANDOM NUMBER

	GO	ARANTLS		;PRINT ARITH & RANDOM TOTALS

	GO	SYSTAT		;PRINT INTERRUPT TOTALS

	GO	TOTAL		;PRINT MEMORY TOTALS

	PNTMSG	[ASCIZ/
----------
/]
	JRST	TSTIMF

TSTIMI:	MOVE	0,SAC0		;H TYPED
	PUT	0
	PUT	1
	PNTMSG	HLPMSG		;PRINT HELP MESSAGE
	JRST	TSTIMF

TSTIMJ:	MOVE	0,SAC0		;CONTROL-E TYPED
	SKIPN	USER		;'SUBSM' HANDLES THIS IN EXEC MODE
	JRST	@TSTIME

	PNTMSF	[ASCIZ/
ERROR PC = /]
	HRRZ	ERRPC
	PNT6F
	PNTMSF	[ASCIZ/ ERROR TOTALS = /]
	MOVE	ERRTLS
	PNTDCF
	PCRLF
	MOVE	0,SAC0
	JRST	@TSTIME

TSTIMG:	MOVE	0,SAC0		;R TYPED
	PUT	0
	PUT	1

	PNTMSG	[ASCIZ/
----------
TEST PC = /]
	HRRZ	TESTPC
	PNT6
	PCRL

	MOVEI	1,TSTTAB	;PRINT TEST PC IN ENGLISH
	HLRZ	(1)		;GET TABLE ENTRY
	JUMPE	.+5		;NOT THERE
	CAME	TESTPC		;A MATCH ?
	AOJA	1,.-3		;NO, TRY NEXT

	HRRZ	(1)		;GET MESSAGE ADDRESS
	PNTAL			;PRINT IT

	JSR	TSTIMA		;PRINT RUN TIME

	PNTMSG	[ASCIZ/----------
/]
	JRST	TSTIMF

TSTTAB:	FXF,,[ASCIZ/FIXED POINT FAST/]
	FXS,,[ASCIZ/FIXED POINT SLOW/]
	FPF,,[ASCIZ/FLOATING POINT FAST/]
	FPS,,[ASCIZ/FLOATING POINT SLOW/]
	BYTS,,[ASCIZ/BYTES/]
	DFPF,,[ASCIZ/DOUBLE FLOATING POINT FAST/]
	DFPS,,[ASCIZ/DOUBLE FLOATING POINT SLOW/]
	BEGRAND,,[ASCIZ/BEGINNING RANDOM/]
	SLO,,[ASCIZ/RANDOM FROM MEMORY/]
	FASTLP,,[ASCIZ/RANDOM FROM AC'S/]
	BEGINT,,[ASCIZ/BEGINNING INTERRUPT/]
	CLKTST,,[ASCIZ/BASIC CLOCK INTERRUPT/]
	INTINS,,[ASCIZ/INSTRUCTION INTERRUPT/]
	NXMTST,,[ASCIZ/NXM INTERRUPT/]
	BLTTST,,[ASCIZ/BLT INTERRUPT/]
	BEGMEM,,[ASCIZ/BEGINNING MEMORY/]
	PHYTST,,[ASCIZ/MEMORY PHYSICAL ADDRESS UP/]
	PHYDWN,,[ASCIZ/MEMORY PHYSICAL ADDRESS DOWN/]
	PATTST,,[ASCIZ/MEMORY DATA PATTERN RR/]
	PATBLT,,[ASCIZ/MEMORY DATA PATTERN BLT/]
	PATFR,,[ASCIZ/MEMORY DATA PATTERN FR/]
	0

; **********************************************************************
;*RUNTIM - REPORT PROGRAM RUN TIME
; **********************************************************************

RUNTIM:	0
	SKIPN	CLKON		;IS CLOCK ON ?
	JRST	@RUNTIM		;NO

	SKIPN	USER
	CONO	PI,PIOFF

	JSR	TSTIMA		;PRINT RUN TIME

	SKIPN	USER
	CONO	PI,PION
	JRST	@RUNTIM

; **********************************************************************
;*ITRCLK - CLOCK INTERRUPT ROUTINE
; **********************************************************************

ITRCLK:	0
	CONSO	APR,LACLK
	JRSTF	@ITRCLK		;NOT CLOCK

	AOS	TICKS		;INCREMENT CLOCK COUNTER
	MOVEM	0,CLKAC0#
	MOVEM	1,CLKAC1#

	MOVE	1,RA		;GET RANDOM NUMBER
	ANDI	1,7
	SKIPN	1		;IF 0, MAKE 1
	AOS	1		;SETUP CLOCK ON RANDOM CHANNEL
	CONO	APR,LAPRAL!LACLK(1)
	MOVE	0,CLKAC0
	MOVE	1,CLKAC1
	JEN	@ITRCH1		;DISMISS CLOCK INTERRUPT

; **********************************************************************
;*TSTIMA - PRINT PROGRAM RUN TIME
; **********************************************************************

TSTIMA:	0
	SKIPN	CLKON
	JRST	@TSTIMA

	PUT	0
	PUT	1
	PNTMSF	[ASCIZ/
RUN TIME = /]
	SKIPE	USER
	JRST	TSTIMV		;USER RUN TIME

	MOVE	TICKS		;UPDATE TIME
	SKIPE	TIMFRC#		;REQUESTED TIME, IF SO DON'T
	GO	TIMQHR		;UPDATE QUARTER HOUR COMPARE

	IDIV	HERTZ		;CONVERT TO SECONDS
TSTIMD:	IDIVI	^D<60*60>	;CONVERT TO HOURS
	MOVEM	1,TIMAC1#	;SAVE MIN:SEC
	PNTDCF			;PRINT HOURS
	PNTCIF	":"

	MOVE	0,TIMAC1	;RETURN MIN:SEC
	IDIVI	^D60		;CONVERT TO MINUTES
	MOVEM	1,TIMAC1	;SAVE :SEC
	PNTDCF			;PRINT MINUTES
	PNTCIF	":"

	MOVE	0,TIMAC1	;RETURN :SEC
	PNTDCF			;PRINT SECONDS

	PCRLF
	SETZM	TIMFRC
	GET	1
	GET	0
	JRST	@TSTIMA

TIMQHR:	PUT	0
	MOVE	0,HERTZQ
	ADDM	0,TSTIMR	;UPDATE QUARTER HOUR COMPARE
	GET	0
	RTN

TSTIMV:	GO	TSTIMU		;GET USER RUN TIME IN SECONDS

	SUB	TSTIMR		;GET DIFFERENCE FROM TIME ZERO
	MOVEM	TICKS
	JRST	TSTIMD

; **********************************************************************
;*TSTIMU - GET USER MODE RUN TIME IN SECONDS
; **********************************************************************

TSTIMU:	SETZM	0
	SKIPE	MONTYP
	JRST	[PUT	1
		 PUT	2
		 PUT	3
		 MOVNI	1,5
		 104000,,15	;RUNTM - GET JOB RUN TIME
		 MOVE	0,1
		 GET	3
		 GET	2
		 GET	1
		 JRST	.+2]
	CALLI	27		;GET USER RUN TIME
	IDIVI	^D1000		;CHANGE TO SECONDS
	RTN

; **********************************************************************
;*SIMI - SIMULATE INSTRUCTION
; **********************************************************************

SIMI:	0
	AOS	RSIMTLS		;COUNT IT
	MOVEM	0,SAVAC
	MOVE	[1,,SAVAC+1]
	BLT	SAVAC+17	;SAVE AC'S
	SETZM	INSTR
	SETZM	CNTLPC
	SETOM	SNGLIN		;SET SINGLE INSTRUCTION CONTROL
	SETZM	SNGL2		;SET FOR FIRST INST
	MOVE	P,PLIST
	MOVEI	$PSHER
	PUSH	P,0
	GO	SENTRY		;GO TO SIMULATOR

	MOVS	[1,,SAVAC+1]
	BLT	17		;RESTORE AC'S
	MOVE	0,SAVAC
	JRST	@SIMI

; **********************************************************************
;*SIMIP - SIMULATE INSTRUCTION, PRINT
; **********************************************************************

SIMIP:	SETZM	MASK		;ALLOW PRINTOUT
	JSR	SIMI		;GO SIMULATE
	PCRL
	JRST	@OUT

MULAC:	BLOCK	4
DIVAC:	BLOCK	4
RAND:	BLOCK	10
INSBLK:	BLOCK	10
ANSBLK:	BLOCK	10
FSTANS:	BLOCK	10
SAVAC:	BLOCK	20
SIMBLK:	BLOCK	^D10

; **********************************************************************
;*SIMFST - SIMULATE AND PRINT ALL INSTRUCTIONS
;*	FAST LOOP RELIABILITY/SPEED FAILURE
; **********************************************************************

SIMFST:	PNTMSG	[ASCIZ/
INSTRUCTION SIMULATION - FAST LOOP FAILURE
----------
/]
	SETZM	MASK
	MOVE	[1,,SAVAC+1]
	BLT	SAVAC+17	;SAVE AC'S
	MOVE	[INSBLK,,ACS+11]
	BLT	ACS+17		;SETUP INSTRUCTIONS
	MOVE	[RAND,,ACS]
	BLT	ACS+7
	SETZM	ACS+10		;SETUP OPEARANDS
	MOVEI	11
SIMFS1:	MOVEM	INPC		;SET INPC TO FIRST INSTRUCTION
	SETZM	INSTR
	SETZM	CNTLPC
	SETOM	SNGLIN		;SET SINGLE INSTRUCTION CONTROL
	SETZM	SNGL2		;SET FOR FIRST INST
	MOVE	P,PLIST
	MOVEI	$PSHER
	PUSH	P,0
	GO	SENTRY		;GO TO SIMULATOR

	HRRZ	PC
	CAIE	17		;COMPLETED SIM ?
	JRST	SIMFS1		;NO
	MOVS	[1,,SAVAC+1]
	BLT	17		;RESTORE AC'S
	PCRL
	JRST	@OUT
SUBTTL	INTERRUPT RELIABILITY MAIN DISPATCHING

; **********************************************************************
;*BEGINT - INTERRUPT TEST CONTROL
; **********************************************************************

BEGINT:	SUBTST

	SKIPE	USER
	JRST	BEGMEM		;CAN'T RUN INTERRUPT IN USER MODE

	JSR	TSTIME
	SETZM	MAPNEW
	MAPMEM			;REMAP MEMORY  - 0 TO 256K

	GO	CSYNC		;SYNC CLOCK

	SWITCH
	TRNN	INHCI		;WANT BASIC CLOCK TEST
	GO	CLKTST		;YES

	SWITCH
	TRNN	INHII		;WANT INSTRUCTION INT. TEST
	GO	INTXCT		;YES

	SWITCH
	TRNN	INHNXM		;WANT NON-EX-MEM TEST
	GO	NXMTST		;YES

	SWITCH
	TRNN	INHBLT		;WANT BLT TEST
	GO	BLTTST		;YES

	JRST	BEGMEM		;TO NEXT TEST
SUBTTL	INTERRUPT - BASIC CLOCK TEST
								SALL
; **********************************************************************
;*CLKTST - VERIFY THAT THE INTERVAL TIMER DOES INDEED CAUSE INTERRUPTS
; **********************************************************************

	T=SIXBTZ BASIC CLOCK TEST

CLKTST:	SUBTST

CLKLOP:	CLRAPR
	CLRPI

	MOVE	4,[JSR ATRP]	;GOOD CLOCK TRAP
	MOVE	5,[JSR BTRP]	;INCORRECT CLOCK TRAP
	GO	RANCHN		;INIT RANDOM CHANNEL
	MOVEM	4,CLKCHN	;SAVE CLOCK ASSIGNMENT

	MOVNI	15,^D200000
	SETZM	CLKFOO
	CONO	PI,12377	;CLEAR AND ENABLE PI SYSTEM
	CONO	APR,LAPRAL+LACLK(4)
	MOVNI	15,^D200000
	AOJGE	15,.+2
	JRST	.-1		;WAIT FOR INTERRUPT A LONG TIME

CLKP1:	CONI	PI,PISTAT#	;SAVE PI STATUS
	CONI	APR,APRSTS#	;AND APR STATUS
	CLRAPR
	CLRPI+CHNON

	SKIPE	CLKFOO#		;DID WE GET INTERRUPT FROM CLOCK
	RTN			;YES

	ERROR1	(13,0,0,^WAITED FOR COUNT OF 20K AOJGE'S^YET GOT NO CLOCK INTERRUPT,,STATUS)
	ERLP2	CLKLOP
	RTN

ATRP:	0			;HERE IF CLOCK INTERRUPT
	AOS	TICKS
	AOS	INTCNT-1(4)	;SAVE THIS CHANNELS INTERRUPT COUNT
	SETOM	CLKFOO		;TELL MAIN LOOP IT WAS THE CLOCK
	JRST	CLKP1		;AND RETURN TO MAIN LOOP

BTRP:	0			;HERE IF ON WRONG CHANNEL
	CONI	PI,PISTAT#	;SAVE PI STATUS
	CONI	APR,APRSTS	;SAVE APR STATUS
	CLRAPR
	CLRPI
	SETZM	CLKFOO		;INFORM MAIN LOOP THIS WASN'T THE CLOCK
	ERROR1	(13,0,0,^GOT INTERRUPT ON WRONG CHANNEL,,STATUS)
	ERLP2	CLKLOP
	CLRPI+CHNON
	RTN
SUBTTL	INTERRUPT - INSTRUCTION INTERRUPTION TEST

; **********************************************************************
;*INTINS - THIS TEST TESTS THE INTERRUPTABILITY
;*	OF ALL CLASSES OF INSTRUCTIONS WITH THE EXCEPTION
;*	OF THE TWO PART INSTRUCTIONS (I.E. BLT BYTE ETC.)
;*	IT IS ENTERED WITH AC1 CONTAINING THE INSTRUCTION TO BE
;*	EXECUTED AND THE NUMBER OF TIMES TO TEST THE LOOP IN AC2.
;*	THE CLOCK IS USED FOR CAUSING THE INTERRUPTS. AND IT RUNS 
;*	ON RANDOM CHANNELS
; **********************************************************************

INTINS:	SUBTST

	MOVEM	1,INTSAV#
	SETZM	AOJFLG#

INTXX:	CLRAPR
	CLRPI

	MOVE	1,INTSAV
	MOVEM	1,INTBLK	;SET UP FOR BLT
	MOVE	1,[XWD INTBLK,INTBLK+1]	;BLT POINTER
	BLT	1,INTBLK+2000-1	;FILL LOOP ADDRESSES

	MOVE	4,[JSR INTTRP]	;GOOD TRAP
	MOVE	5,[JSR ERRTRP]	;BAD TRAP
	GO	RANCHN		;TURN ON A RANDOM CHANNEL(APR CLK)
	MOVEM	4,CLKCHN	;SAVE CURRENT ASSIGNMENT

	CONO	APR,LAPRAL+LACLK
	CONSO	APR,LACLK
	JRST	.-1
	AOS	TICKS

	CONO	APR,LAPRAL+LACLK(4)
	CONO	PI,PION+CHNON+177	;TURN ON FULL PI SYSTEM

	JRST	INTBKA		;START INSTRUCTION LOOP

INTTRP:	0			;HERE IF PI REQUEST FROM ABOVE
	AOS	TICKS

	HRRZ	3,.-2		;GET PC OF REQUEST
	CAILE	3,INTBLK+2000	;IS IT OUT OF ERROR HANDLER INSTRUCTION?
	JRST	NOGOOD		;YES IT WAS SO INS CAN NOT INT.

	ERLP2	INTXX

	CAIN	3,INTBLK+2000	;WAS IT THE AOJGE
	JRST	INTTRX		;YES

	AOS	INTCNT-1(4)	;KEEP TRACK OF THIS CHANNELS INTERRUPTS
	AOS	INSCNT#		;KEEP TRACK OF TIMES HERE
	CLRAPR
	CLRPI+CHNON
	RTN

INTTRX:	AOS	AOJGX#		;TELL HOW MANY TIMES WE GOT IT THERE.
	SETOM	AOJFLG#		;TELL MAIN CODE
	JRST	INTXX		;AND LOOP TEST

ERRTRP:	0			;HERE IF ON WRONG CHANNEL
	CONI	PI,PISTAT	;SAVE PI STATUS
	CONI	APR,APRSTS	;AND APR STATUS

	PNTMSG	[ASCIZ/
ERROR DURING INSTRUCTION INTERRUPTION TEST
RECIEVED INCORRECT INTERRUPT ON CHANNEL /]
	MOVE	CLKCHN		;GET AND TYPE CLOCK CHANNEL
	PNT1

	GO	STATUS		;TYPE OUT PERTINANT DATA
	AOS	SPRCNT#		;BUMP SPURIOUS INTERRUPT COUNTER
	PNTMSG	[ASCIZ/
ERROR COUNTED AS SPURIOUS AND WILL BE IGNORED
/]
	SETZM	AOJFLG#
	JEN	@ERRTRP

INTBKA:	SKIPE	AOJFLG		;SKIP IF HERE BECAUSE OF SOJGE
	MOVEI	1,^D100		;LOOP 100 TIMES MAX.
	MOVE	[SOJGE	1,INTBLK]
	MOVEM	BUFEND-1
	MOVE	[JRST NOGOOD]
	MOVEM	BUFEND
	JRST	INTBLK
								SALL
	T=SIXBTZ INSTRUCTION INTERRUPTION TEST

NOGOOD=.
ERRLOC:	ERROR1	(13,0,0,^INTERRUPT DID NOT OCCUR AFTER 200000 INSTRUCTIONS,,TYPINS)
	ERLP2	INTXX
	CLRAPR
	CLRPI+CHNON
	RTN

TYPINS:	PNTMSG	[ASCIZ/SEQUENCE STARTS AT:/]
	MOVEI	INTBLK		;GET SEQUENCE START ADDRESS
	PNT6			;PRINT IT

	PNTMSG	[ASCIZ/
ERROR INSTRUCTION:	/]
	MOVE	0,INTBLK
	PNTHW			;GET AND TYPE ERROR DATA (INST)

	PNTMSG	[ASCIZ/
INTERRUPT SHOULD HAVE OCCURED ON CHANNEL: /]
	MOVE	CLKCHN
	PNT1			;GET AND PRINT CLOCK CHANNEL

	PCRL
	RTN			;RETURN TO SENDER

; **********************************************************************
;*INTXCT - THIS SUBROUTINE RANDOMLY RETRIEVES AN INSTRUCTION FROM A TABLE
;*	AND STORES IT IN AN AC FOR THE "INTINS" TEST TO USE
; **********************************************************************

INTXCT:	GO	GETNUM		;GET TABLE POINTER
	ANDI	1,177774	;INSURE IT'S DIVISIBLE BY 4
	CAIL	1,INSTAB
	JRST	.+3		;IS IT IN THE TABLE AREA?
	ADDI	1,100		;NO ADD 100
	JRST	.-3		;CHECK IT AGAIN
	CAIG	1,INSEND	;IS IT BEYOND THE TABLE'S END?
	JRST	.+3		;NO
	SUBI	1,100		;SUBTRACT 100 TILL IT IS
	JRST	.-3		;CHECK AGAIN
	MOVEM	1,INDEX#	;SAVE INDEX POINTER
	MOVE	1,(1)		;GET INSTRUCTION TO TEST
	MOVE	2,INDEX
	MOVE	2,1(2)		;AND NUMBER OF TIMES TO DO IT
	MOVE	16,INDEX	;GET INDEX POINTER
	AOS	2(16)		;COUNT TIMES TESTED THIS INSTRUCTION
	GO	INTINS		;AND GO DO TEST
	RTN			;RETURN TO MAIN DISPATCHING

GETNUM:	SETZB	0,1		;CLEAR WORK AREA
	SKIPE	ONCEH#		;BEEN HERE BEFORE
	MOVE	1,LSTNUM#	;GET LAST NUMBER
	ADDI	1,4		;BUMP POINTER
	MOVEM	1,LSTNUM#	;SAVE NEW POINTER
	CAIGE	1,INSEND-INSTAB+1	;OUT OF BOUNDS
	JRST	.+3		;OK
	SETZM	ONCEH#		;CLEAR FLAG
	JRST	GETNUM		;LOOP FOR NEW NUMBER
	SETOM	ONCEH#		;SET FLAG TO SKIP SETUP
	ADDI	1,INSTAB
	RTN			;RETURN
SUBTTL	INTERRUPT - NON-EXISTENT-MEMORY TEST
								SALL
; **********************************************************************
;*NXMTST - TEST NON-EXISTANT MEMORY INTERRUPT
; **********************************************************************

	T=SIXBTZ NON-EX-MEM TEST

NXMTST:	SUBTST
	MOVEI	14,LOPCNT	;LOOP COUNT

NOMEM1:	CLRAPR
	CLRPI

	MOVE	4,[JSR NXMTRP]	;CORRECT TRAP INSTRUCTION
	MOVE	5,[JSR NONXM]	;INCORRECT TRAP
	GO	RANCHN		;GO GET RANDOM CHANNEL
	MOVEM	4,ERRCHN#	;SAVE ERROR ASSIGNMENT

	GO	RANDM1		;GET RANDOM NON ZERO DATA
	ANDI	1,-1		;MAKE LEGAL MA
	MOVE	MEMSIZ+1	;GET MEMORY SIZE
	CAIL	0,777777	;256K MACHINE
	JRST	NXM256		;YES SO DONT DO NXMTST

	CAMLE	1,0		;BEYOND LAST MEMORY LOCATION
	JRST	.+3		;YES
	ADDI	1,1000		;MAKE NEW MA
	JRST	.-3		;TEST IT AGAIN

	CONO	APR,LAPRAL+LACLK
	CONSO	APR,LACLK	;WAIT FOR CLOCK
	JRST	.-1
	AOS	TICKS

	CONO	APR,LCNXER(4)	;CLEAR NON-EX-MEM AND SET ERROR CHANNEL
	CONO	PI,2377		;PUT ON THE CHANNELS

	MOVE	16,[1,,-1]	;TIME OUT COUNT
	CAM	(1)		;CAUSE NON-EX-MEM
	SOJGE	16,.		;LOOP TILL IT COMES

	ERROR1	(13,1,0,^EXPECTED NON-EX-MEM INTERRUPT DID NOT OCCUR,C=REF ADR)
	ERLP2	NOMEM1
	CLRAPR
	CLRPI+CHNON
	RTN			;EXIT TEST

; **********************************************************************
;*NXMTRP - COME HERE ON NON-EX-MEM INTERRUPT
; **********************************************************************

NXMTRP:	0
	CONSO	APR,LNXMER	;IS NXM FLOP SET?
	ERROR1	(13,1,0,^GOT NON-EX-MEM INTERRUPT WITHOUT NXM FLOP SET,C=REF ADR)
	ERLP2	NOMEM1

	AOS	TOTNXM		;BUMP NON-EX-EM COUNT
	AOS	ERRCNT		;AND ERROR INTERRUPT COUNTER
	CLRAPR
	CLRPI+CHNON
	SWITCH			;GET CONSOLE SWITCHES
	TLNE	RELIAB		;FAST CYCLE WANTED?
	SOJGE	14,NXMTST+3	;LOOP TEST TILL 14 = 0
	RTN			;EXIT TEST

; **********************************************************************
;*NONXM - GRIEF IF HERE - WE GOT AN INTERRUPT ON THE WRONG CHANNEL
; **********************************************************************

NONXM:	0
	CONI	APR,APRSTS	;GET AND SAVE
	CONI	PI,PISTAT	;APR AND PI STATUS
	CLRAPR
	CLRPI
	ERROR1	(13,0,0,^GOT NON-EX-MEM INTERRUPT ON THE WRONG CHANNEL,,STATUS)
	ERLP2	NOMEM1
	CLRAPR
	CLRPI+CHNON
	RTN

; **********************************************************************
;*HERE IF WE HAVE A 256K MACHINE
; **********************************************************************

NXM256:	SETOM	NXMFLG		;INFORM PROGRAM THIS TEST IS NOT BEING DONE
	CLRAPR
	CLRPI+CHNON
	RTN			;EXIT NXMTST
SUBTTL	INTERRUPT - BLOCK TRANSFER TEST
								SALL
; **********************************************************************
;*BLTTST - TEST BLOCK TRANSFER INTERRUPTABILITY
; **********************************************************************

	T=SIXBTZ BLOCK TRANSFER TEST

BLTTST:	SUBTST

	CLRAPR
	CLRPI

	MOVE	4,[JSR BLTTRP]
	MOVE	5,[JSR BLTBAD]
	GO	RANCHN		;INIT RANDOM CHANNEL

	MOVE	RANDBS
	MOVEM	BUFF
	MOVE	16,[BUFF,,BUFF+1]
	BLT	16,BUFF+2000	;FILL TRANSFER BUFFER

	SETZM	BUFF1
	MOVE	16,[BUFF1,,BUFF1+1]
	BLT	16,BUFF1+2000	;CLEAR RECIEVING BUFFER

	CONO	APR,LAPRAL+LACLK
	CONSO	APR,LACLK
	JRST	.-1
	AOS	TICKS

	CONO	APR,LAPRAL+LACLK(4)
	MOVE	16,[BUFF,,BUFF1]	;BLT FROM - TO
	SETZM	BLTAC
	CONO	PI,2377		;ENABLE INTERRUPT SYSTEM

	BLT	16,BUFF1+2000	;DO BLT

; **********************************************************************
;*DATTST - CHECK BLT RESULTS
; **********************************************************************

DATTST:	SKIPN	BLTAC		;DID BLT GET INTERRUPTED ?
	JRST	BLTNOI		;NO

	MOVEI	2,BUFF1
DATLOP:	MOVE	1,@2		;GET DATA
	CAME	1,BUFF		;COMPARE
	JRST	DATERR		;GOT AN ERROR

	ADDI	2,1
	CAIG	2,BUFF1+2000	;FINISHED TESTING
	JRST	DATLOP		;NO

	AOS	BLTCNT		;YES
	CLRAPR
	CLRPI+CHNON
	RTN			;EXIT TEST

; **********************************************************************
;*DATERR - COME HERE ON DATA ERROR IN BLOCK TRANSFER TEST
; **********************************************************************

DATERR:	ERROR1	(13,BUFF,1,^DATA COMPARE ERROR IN BLT TEST,,DATMOR)
	ERLP2	BLTTST

	CLRAPR
	CLRPI+CHNON
	RTN			;CHECK SOME MORE

DATMOR:	HRRZ	12,BLTAC	;GET E OF BLT WHEN INTERRUPTED
	CAME	1,12		;DID FAILING DATA = BLTAC AT INTERRUPT
	JRST	DAT001		;NO
	JRST	BLTFAL		;YES

DAT001:	SUBI	12,1
	CAME	1,12		;CHECK NEAR IT
	JRST	DAT002
	JRST	BLTFAL

DAT002:	RTN			;COULD BE REAL DATA ERROR

BLTFAL:	PNTMSG	[ASCIZ/
ADDRESS OF FAILING DATA IS EQUAL TO BLT TO ADDRESS OR BLT TO ADDRESS-1
AT INTERRUPT TIME. BLT IS NOT STORING THE CORRECT POINTER WHEN
INTERRUPTED.
FAILING ADDRESS: /]

	MOVE	12
	PNTOCT
	PCRL
	RTN			;RETURN TO ERROR HANDLER

BLTNOI:	CONI	APR,APRSTS
	CONI	PI,PISTAT
	CLRAPR
	CLRPI+CHNON
	ERROR1	(13,0,0,^INTERRUPT DID NOT OCCUR DURING BLT)
	ERLP2	BLTTST
	RTN

; **********************************************************************
;*BLTTRP - COME HERE ON INTERRUPT FROM CLOCK DURING BLT TEST
; **********************************************************************

BLTTRP:	0			;FOR JSR
	AOS	TICKS
	AOS	INTCNT-1(4)	;COUNT THIS INTERRUPT
	MOVEM	16,BLTAC#	;SAVE CONTENTS OF BLTAC
	CLRAPR
	CLRPI+CHNON
	JRST	@BLTTRP		;FINISH BLOCK TRANSFER

; **********************************************************************
;*BLTBAD - COME HERE ON INCORRECT CLOCK INTERRUPT
; **********************************************************************

BLTBAD:	0			;FOR JSR
	AOS	SPRCNT		;COUNT AS SPURIOUS INTERRUPT
	ERROR1	(13,0,0,^SPURIOUS CLOCK INTERRUPT OCCURED,RESTARTING TEST)
	CLRAPR
	CLRPI+CHNON
	JRST	BLTTST		;RESTART BLOCK TRANSFER TEST
SUBTTL	INTERRUPT TEST SUBROUTINES

; **********************************************************************
;*RANCHN - THIS SUBROUTINE TO INIT THE CLOCK ON SOME RANDOM CHANNEL AND TO
;*	RETURN TO ALL OTHER CHANNELS AS ERRORS.
;*	ROUTINE IS ENTERED WITH AC4 CONTAINING THE CORRECT TRAP ADDRESS
;*	AND AC5 CONTAINS THE ERROR TRAP ADDRESS.
; **********************************************************************

RANCHN:	MOVEM	4,CORTRP#	;SAVE CORRECT TRAP ADDRESS
	MOVEM	5,BADTRP#	;AND BAD CHANNEL TRAP
	MOVE	4,RA2#		;GENERATE RANDOM NUMBER
	ADD	4,RANDBS	;ADD IN BASE
	ROT	4,-1
	EQVB	4,RA2
	ANDI	4,7		;MASK OUT ALL BUT ASSIGNMENT
	CAIGE	4,1		;MUST BE CHANNEL 1 OR BETTER
	MOVEI	4,1
	MOVEM	4,CLKCHN#	;SAVE CLOCK CHANNEL
	MOVEI	4,44
	MOVE	5,BADTRP	;GET TRAPS FOR WRONG CHANNEL
	MOVEM	5,(4)		;SET ALL CHANNELS TO BAD
	ADDI	4,2
	CAIGE	4,60
	JRST	.-3
	MOVE	5,CORTRP	;GET CORRECT TRAP
	MOVE	4,CLKCHN	;GET CHANNEL NUMBER
	ROT	4,1
	MOVEM	5,40(4)		;STORE INSTRUCTION
	ROT	4,-1
	RTN

; **********************************************************************
;*STATUS - REPORT THE STATUS OF THE APR AND PI
; **********************************************************************

STATUS:	PNTMSG	[ASCIZ/
APR STATUS	PI STATUS
/]
	MOVE	APRSTS		;GET AND TYPE APR STATUS
	PNTHW
	MOVE	PISTAT		;GET AND PRINT PI STATUS
	PNTHW
	PCRL
	RTN			;RETURN TO SENDER

; **********************************************************************
;*RANDM0 - THIS ROUTINE GENERATES SOME RANDOM NUMBER WHICH MAY BE ZERO
; **********************************************************************

RANDM0:	MOVE	0,RA2#		;GENERATE RANDOM NUMBER
	ADD	0,RANDBS	;ADD IN BASE
	ROT	0,-1
	EQVB	0,RA2
	MOVEM	1		;STORE IN AC1
	RTN			;RETURN

; **********************************************************************
;*RANDM1 - THIS SUBROUTINE GENERATES A RANDOM NUMBER WHICH MAY NOT BE ZERO
; **********************************************************************

RANDM1:	MOVE	0,RA2		;GENERATE RANDOM NUMBER THAT IS NOT =0
	ADD	0,RANDBS	;ADD IN BASE
	ROT	0,-1
	EQVB	0,RA2
	JUMPE	0,RANDM1	;LOOP IF NUMBER =0
	MOVEM	1
	RTN			;RETURN

; **********************************************************************
;*CSYNC - THIS ROUTINE IS USED TO DETERMINE HOW MANY AOJNS AND CONSOS
;*	ARE EXECUTED IN 1 MSEC.
; **********************************************************************

CSYNC:	SKIPE	TIMCNT#		;DONE THIS BEFORE?
	RTN			;YES DONT DO IT AGAIN

CSYNC2:	MOVEI	15,3		;LOOP COUNT
	SETZB	16,TIMCNT#
	HRLZI	1,400000
	MOVE	2,[CONSO APR,LACLK]
	MOVE	3,[AOJN 1,2]
	MOVE	4,[AOS TICKS]
	MOVE	5,[SOJLE 15,CSYNC1]
	MOVE	6,[CONO APR,LAPRAL+LACLK]
	MOVE	7,[CONSO APR,LACLK]
	MOVE	10,[SOJA 16,7]
	MOVE	11,[AOS TICKS]
	MOVE	12,[CONO APR,LAPRAL+LACLK]
	MOVE	13,[SOJA 16,2]
	CLRAPR
	CLRPI

	CONO	APR,LAPRAL+LACLK
	CONSO	APR,LACLK
	JRST	.-1
	AOS	TICKS

	CONO	APR,LAPRAL+LACLK
	JRST	2		;START TIMING LOOP

CSYNC1:	TLC	1,400000	;DELETE BIT 0
	IMULI	1,^D6
	IDIVI	1,3		;TO GET NUMBER IN 1 ITERATION
	IDIVI	1,^D100		;TO GET NUMBER IN MSECS.
	MOVEM	1,TIMCNT
	CLRAPR
	CLRPI+CHNON
	RTN			;EXIT SYNC ROUTINE

; **********************************************************************
;*WAIT - ROUTINE IS ENTERED WITH AC0 CONTAINING THE NUMBER OF MSECS. TO STALL
;*	THIS ROUTINE IS DONE IN FAST MEMORY.
; **********************************************************************

WAIT:	SKIPN			;ANY ARGUMENT?
	RTN			;NO 0. MSEC. WAIT

	CONO	PI,PIOFF
	IMUL	0,TIMCNT	;COUNTS IN 1 MS X NO. OF MSECS.
	EXCH	1,[CONSO APR,]	;WAIT IT OUT
	EXCH	2,[SOJGE 1]	;LOOP TILL -1
	EXCH	3,[JRST WATRET]	;AND ESCAPE
	JRST	1

WATRET:	EXCH	1,@.-4
	EXCH	2,@.-4
	EXCH	3,@.-4		;RESTORE AC'S AND RETURN
	CONO	PI,PION
	RTN			;EXIT WAIT

; **********************************************************************
;*TIMER - THIS ROUTINE IS ENTERED WITH AC0 CONTAINING THE INSTRUCTION
;*	WHICH CHECKS THE EVENT TO BE TIMED (MUST BE A CONSO)
;*	AC1 CONTAINS A NUMBER (0-3) TO DETERMINE THE TIME TO BE RETURNED
;*	I.E. 0 FOR MSECS., 1 FOR 10THS OF MSECS., 2 FOR 100THS OF MSECS.
;*	AND 3 FOR 1000THS OF MSECS.
; **********************************************************************

TIMER:	CAILE	1,3		;FACTOR UP TO 1000THS
	SETZ	1,		;IF GREATER THAN 3 ASSUME MSECS.
	MOVEM	1,10		;AND SAVE IT
	CAIN	1,1		;TENTHS
	MOVEI	10,^D10
	CAIN	1,2		;HUNDREDTHS
	MOVEI	10,^D100
	CAIN	1,3		;THOUSANDTHS
	MOVEI	10,^D1000
	SKIPGE	1,		;IS IT NEGATIVE
	SETZM	10		;YES
	MOVEM	0,11		;PUT CONSO INTO 11
	SETZ	0		;START WITH AC = 0
	MOVE	12,[AOJN 11]	;COUNT INSTR. IN 12
	MOVE	13,[JRST TEXIT]	;EXIT INSTRUCTION
	CLRAPR
	CLRPI

	CONO	APR,LAPRAL+LACLK
	CONSO	APR,LACLK
	JRST	.-1
	AOS	TICKS

	CONO	APR,LAPRAL+LACLK
	JRST	11		;ENTER LOOP

; **********************************************************************
;*TEXIT - COME HERE TO FIGURE THE TIME AND EXIT WITH AC0 AND AC1 CONTAINING THE
;*	ANSWER. WHICH IS READY TO BE PRINTED OR TESTED AND ALSO STORE THE ANSWER
;*	IN CLKTIC AND CLKTIC+1
; **********************************************************************

TEXIT:	SKIPE	10		;DON'T MULTIPLY IF 10 = 0
	IMUL	0,10		;MULTIPLICATION FACTOR
	IDIV	0,TIMCNT
	MOVEM	0,CLKTIC
	MOVEM	1,CLKTIC+1	;SAVE TICK TIME
	CLRAPR
	CLRPI+CHNON
	RTN			;AC0 HAS THE TIME!

; **********************************************************************
;*SYSTAT - PRINT INTERRUPT RELIABILTY TOTALS
; **********************************************************************

SYSTAT:	SKIPE	USER		;TEST NOT DONE IN USER MODE
	RTN

	PNTMSG	[ASCIZ/
* INTERRUPT TOTALS *
CHANNEL 1 INTERRUPTS = /]
	MOVE	INTCNT
	PNTDEC

	PNTMSG	[ASCIZ/
CHANNEL 2 INTERRUPTS = /]
	MOVE	INTCNT+1
	PNTDEC

	PNTMSG	[ASCIZ/
CHANNEL 3 INTERRUPTS = /]
	MOVE	INTCNT+2
	PNTDEC

	PNTMSG	[ASCIZ/
CHANNEL 4 INTERRUPTS = /]
	MOVE	INTCNT+3
	PNTDEC

	PNTMSG	[ASCIZ/
CHANNEL 5 INTERRUPTS = /]
	MOVE	INTCNT+4
	PNTDEC

	PNTMSG	[ASCIZ/
CHANNEL 6 INTERRUPTS = /]
	MOVE	INTCNT+5
	PNTDEC

	PNTMSG	[ASCIZ/
CHANNEL 7 INTERRUPTS = /]
	MOVE	INTCNT+6
	PNTDEC

	PNTMSG	[ASCIZ/
ERROR PIA INTERRUPTS = /]
	MOVE	ERRCNT
	PNTDEC

	PNTMSG	[ASCIZ/
PROGRAM GENERATED NXM'S = /]
	MOVE	TOTNXM
	PNTDEC

	PNTMSG	[ASCIZ/
TOTAL SPURIOUS INTERRUPTS = /]
	MOVE	SPRCNT
	PNTDEC

	PNTMSG	[ASCIZ/
TOTAL BLT'S DONE IN BLTSTS = /]
	MOVE	BLTCNT
	PNTDEC
	PCRL

	RTN			;EXIT SYSTAT

; **********************************************************************
;*SYSTAT TABLE
; **********************************************************************

CLKTIC:	0			;TIME BETWEEN CLOCK TICKS
	0
TOTNXM:	0			;TOTAL NON-EX-MEMS
NXMFLG:	0			;-1 IF 256K MACHINE
ERRCNT:	0			;TOTAL ERROR INTERRUPTS
ERRCHN:	0			;LAST ERROR PIA ASSIGNMENT
CLKCHN:	0			;LAST CLOCK PIA ASSIGNMENT
INSCNT:	0			;TOTAL INTERRUPTED INSTRUCTIONS
	0
INTCNT:	0			;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 1
	0			;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 2
	0			;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 3
	0			;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 4
	0			;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 5
	0			;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 6
	0			;TOTAL NUMBER OF INTERRUPTS ON CHANNEL 7
	0
SPRCNT:	0			;TOTAL NUMBER OF SPURIOUS INTERRUPTS
CURENT:	0			;LAST INSTRUCTION TESTED
BLTCNT:	0			;TOTAL NUMBER OF BLT'S DONE
SYNC:	0			;AOJGE'S IN 1 CLOCK TICK.

; **********************************************************************
;*INSTAB - HERE BEITH THE INSTRUCTION TABLE
;*	ALL NON SKIP INSTRUCTIONS AND 1 PART INSTRUCTIONS ARE STORED HERE
;*	EACH ENTRY INTO THE TABLE INCLUDES:
;*		1.AN INSTRUCTION TO TEST
;*		2.THE NUMBER OF TIMES TO TRY IT
;*		3.A STORAGE WORD TO TELL HOW MANY TIMES THIS PARTICULAR
;*		  INSTRUCTION WAS TESTED
;*		4.A RESERVED STORAGE WORD
; **********************************************************************

	LOC	<<.+4>&777774>
INSTAB:	FAD	10,MEMLOC#
	5
	0
	0
	FADM	10,MEMLOC
	5
	0
	0
	FADB	10,MEMLOC
	5
	0
	0
	FADRI	10,MEMLOC
	5
	0
	0
	FADRM	10,MEMLOC
	5
	0
	0
	FADRB	10,MEMLOC
	5
	0
	0
	FSB	10,MEMLOC
	5
	0
	0
	FSBM	10,MEMLOC
	5
	0
	0
	FSBB	10,MEMLOC
	5
	0
	0
	FSBR	10,MEMLOC
	5
	0
	0
	FSBRI	10,MEMLOC
	5
	0
	0
	FSBRM	10,MEMLOC
	5
	0
	0
	FSBRB	10,MEMLOC
	5
	0
	0
	FMP	10,MEMLOC
	5
	0
	0
	FMPM	10,MEMLOC
	5
	0
	0
	FMPB	10,MEMLOC
	5
	0
	0
	FMPR	10,MEMLOC
	5
	0
	0
	FMPRI	10,MEMLOC
	5
	0
	0
	FMPRM	10,MEMLOC
	5
	0
	0
	FMPRB	10,MEMLOC
	5
	0
	0
	MOVE	10,MEMLOC
	5
	0
	0
	MOVEI	10,MEMLOC
	5
	0
	0
	MOVEM	10,MEMLOC
	5
	0
	0
	MOVES	10,MEMLOC
	5
	0
	0
	MOVS	10,MEMLOC
	5
	0
	0
	MOVSI	10,MEMLOC
	5
	0
	0
	MOVSM	10,MEMLOC
	5
	0
	0
	MOVSS	10,MEMLOC
	5
	0
	0
	MOVN	10,MEMLOC
	5
	0
	0
	MOVNI	10,MEMLOC
	5
	0
	0
	MOVNM	10,MEMLOC
	5
	0
	0
	MOVNS	10,MEMLOC
	5
	0
	0
	MOVM	10,MEMLOC
	5
	0
	0
	MOVMI	10,MEMLOC
	5
	0
	0
	MOVMM	10,MEMLOC
	5
	0
	0
	MOVMS	10,MEMLOC
	5
	0
	0
	IMUL	10,MEMLOC
	5
	0
	0
	IMULI	10,MEMLOC
	5
	0
	0
	IMULM	10,MEMLOC
	5
	0
	0
	IMULB	10,MEMLOC
	5
	0
	0
	MUL	10,MEMLOC
	5
	0
	0
	MULI	10,MEMLOC
	5
	0
	0
	MULM	10,MEMLOC
	5
	0
	0
	MULB	10,MEMLOC
	5
	0
	0
	IDIV	10,MEMLOC
	5
	0
	0
	IDIVI	10,MEMLOC
	5
	0
	0
	IDIVM	10,MEMLOC
	5
	0
	0
	IDIVB	10,MEMLOC
	5
	0
	0
	DIV	10,MEMLOC
	5
	0
	0
	DIVI	10,MEMLOC
	5
	0
	0
	DIVM	10,MEMLOC
	5
	0
	0
	DIVB	10,MEMLOC
	5
	0
	0
	ASH	10,MEMLOC
	5
	0
	0
	ROT	10,MEMLOC
	5
	0
	0
	LSH	10,MEMLOC
	5
	0
	0
	ASHC	10,MEMLOC
	5
	0
	0
	ROTC	10,MEMLOC
	5
	0
	0
	LSHC	10,MEMLOC
	5
	0
	0
	EXCH	10,MEMLOC
	5
	0
	0
	ADD	10,MEMLOC
	5
	0
	0
	ADDI	10,MEMLOC
	5
	0
	0
	ADDM	10,MEMLOC
	5
	0
	0
	ADDB	10,MEMLOC
	5
	0
	0
	SUB	10,MEMLOC
	5
	0
	0
	SUBI	10,MEMLOC
	5
	0
	0
	SUBM	10,MEMLOC
	5
	0
	0
	SUBB	10,MEMLOC
	5
	0
	0
	SETZ	10,MEMLOC
	5
	0
	0
	SETZI	10,MEMLOC
	5
	0
	0
	SETZM	10,MEMLOC
	5
	0
	0
	SETZB	10,MEMLOC
	5
	0
	0
	AND	10,MEMLOC
	5
	0
	0
	ANDI	10,MEMLOC
	5
	0
	0
	ANDM	10,MEMLOC
	5
	0
	0
	ANDB	10,MEMLOC
	5
	0
	0
	ANDCA	10,MEMLOC
	5
	0
	0
	ANDCAI	10,MEMLOC
	5
	0
	0
	ANDCAM	10,MEMLOC
	5
	0
	0
	ANDCAB	10,MEMLOC
	5
	0
	0
	SETM	10,MEMLOC
	5
	0
	0
	SETMI	10,MEMLOC
	5
	0
	0
	SETMM	10,MEMLOC
	5
	0
	0
	SETMB	10,MEMLOC
	5
	0
	0
	ANDCM	10,MEMLOC
	5
	0
	0
	ANDCMI	10,MEMLOC
	5
	0
	0
	ANDCMM	10,MEMLOC
	5
	0
	0
	ANDCMB	10,MEMLOC
	5
	0
	0
	SETA	10,MEMLOC
	5
	0
	0
	SETAI	10,MEMLOC
	5
	0
	0
	SETAM	10,MEMLOC
	5
	0
	0
	SETAB	10,MEMLOC
	5
	0
	0
	XOR	10,MEMLOC
	5
	0
	0
	XORI	10,MEMLOC
	5
	0
	0
	XORM	10,MEMLOC
	5
	0
	0
	XORB	10,MEMLOC
	5
	0
	0
	IOR	10,MEMLOC
	5
	0
	0
	IORI	10,MEMLOC
	5
	0
	0
	IORM	10,MEMLOC
	5
	0
	0
	IORB	10,MEMLOC
	5
	0
	0
	ANDCB	10,MEMLOC
	5
	0
	0
	ANDCBI	10,MEMLOC
	5
	0
	0
	ANDCBM	10,MEMLOC
	5
	0
	0
	ANDCBB	10,MEMLOC
	5
	0
	0
	EQV	10,MEMLOC
	5
	0
	0
	EQVI	10,MEMLOC
	5
	0
	0
	EQVM	10,MEMLOC
	5
	0
	0
	EQVB	10,MEMLOC
	5
	0
	0
	SETCA	10,MEMLOC
	5
	0
	0
	SETCAI	10,MEMLOC
	5
	0
	0
	SETCAM	10,MEMLOC
	5
	0
	0
	SETCAB	10,MEMLOC
	5
	0
	0
	ORCA	10,MEMLOC
	5
	0
	0
	ORCAI	10,MEMLOC
	5
	0
	0
	ORCAM	10,MEMLOC
	5
	0
	0
	ORCAB	10,MEMLOC
	5
	0
	0
	SETCM	10,MEMLOC
	5
	0
	0
	SETCMI	10,MEMLOC
	5
	0
	0
	SETCMM	10,MEMLOC
	5
	0
	0
	SETCMB	10,MEMLOC
	5
	0
	0
	ORCM	10,MEMLOC
	5
	0
	0
	ORCMI	10,MEMLOC
	5
	0
	0
	ORCMM	10,MEMLOC
	5
	0
	0
	ORCMB	10,MEMLOC
	5
	0
	0
	SETO	10,MEMLOC
	5
	0
	0
	SETOI	10,MEMLOC
	5
	0
	0
	SETOM	10,MEMLOC
	5
	0
	0
	SETOB	10,MEMLOC
	5
	0
	0
	HLL	10,MEMLOC
	5
	0
	0
	HLLI	10,MEMLOC
	5
	0
	0
	HLLM	10,MEMLOC
	5
	0
	0
	HLLS	10,MEMLOC
	5
	0
	0
	HRL	10,MEMLOC
	5
	0
	0
	HRLI	10,MEMLOC
	5
	0
	0
	HRLM	10,MEMLOC
	5
	0
	0
	HRLS	10,MEMLOC
	5
	0
	0
	HLLZ	10,MEMLOC
	5
	0
	0
	HLLZI	10,MEMLOC
	5
	0
	0
	HLLZM	10,MEMLOC
	5
	0
	0
	HLLZS	10,MEMLOC
	5
	0
	0
	HLLO	10,MEMLOC
	5
	0
	0
	HLLOI	10,MEMLOC
	5
	0
	0
	HLLOM	10,MEMLOC
	5
	0
	0
	HLLOS	10,MEMLOC
	5
	0
	0
	HRLO	10,MEMLOC
	5
	0
	0
	HRLOI	10,MEMLOC
	5
	0
	0
	HRLOM	10,MEMLOC
	5
	0
	0
	HRLOS	10,MEMLOC
	5
	0
	0
	HLLE	10,MEMLOC
	5
	0
	0
	HLLEI	10,MEMLOC
	5
	0
	0
	HLLEM	10,MEMLOC
	5
	0
	0
	HLLES	10,MEMLOC
	5
	0
	0
	HRLE	10,MEMLOC
	5
	0
	0
	HRLEI	10,MEMLOC
	5
	0
	0
	HRLEM	10,MEMLOC
	5
	0
	0
	HRLES	10,MEMLOC
	5
	0
	0
	HRR	10,MEMLOC
	5
	0
	0
	HRRI	10,MEMLOC
	5
	0
	0
	HRRM	10,MEMLOC
	5
	0
	0
	HRRS	10,MEMLOC
	5
	0
	0
	HLR	10,MEMLOC
	5
	0
	0
	HLRI	10,MEMLOC
	5
	0
	0
	HLRM	10,MEMLOC
	5
	0
	0
	HLRS	10,MEMLOC
	5
	0
	0
	HRRZ	10,MEMLOC
	5
	0
	0
	HRRZI	10,MEMLOC
	5
	0
	0
	HRRZM	10,MEMLOC
	5
	0
	0
	HRRZS	10,MEMLOC
	5
	0
	0
	HLRZ	10,MEMLOC
	5
	0
	0
	HLRZI	10,MEMLOC
	5
	0
	0
	HLRZM	10,MEMLOC
	5
	0
	0
	HLRZS	10,MEMLOC
	5
	0
	0
	HRRO	10,MEMLOC
	5
	0
	0
	HRROI	10,MEMLOC
	5
	0
	0
	HRROM	10,MEMLOC
	5
	0
	0
	HRROS	10,MEMLOC
	5
	0
	0
	HLRO	10,MEMLOC
	5
	0
	0
	HLROI	10,MEMLOC
	5
	0
	0
	HLROM	10,MEMLOC
	5
	0
	0
	HLROS	10,MEMLOC
	5
	0
	0
	HRRE	10,MEMLOC
	5
	0
	0
	HRREI	10,MEMLOC
	5
	0
	0
	HRREM	10,MEMLOC
	5
	0
	0
	HRRES	10,MEMLOC
	5
	0
	0
	HLRE	10,MEMLOC
	5
	0
	0
	HLREI	10,MEMLOC
	5
	0
	0
	HLREM	10,MEMLOC
	5
	0
	0
INSEND:	HLRES	10,MEMLOC
	5
	0
	0
  