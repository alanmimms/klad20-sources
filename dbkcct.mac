;MAINDEC-10-DBKCC

DECVER=003
MCNVER=000

	XLIST
DEFINE	NAME	(MCNVER,DECVER),<
TITLE	DBKCC PDP-10 KI10 ADVANCED INSTRUCTION DIAGNOSTIC #3, VERSION MCNVER,DECVER >
	LIST
	LALL

NAME	\MCNVER,\DECVER

	XALL
;(FIX,FIXR,FLTR AND DOUBLE MOVE)

;COPYRIGHT 1972, 1973, 1974,1975
;DIGITAL EQUIPMENT CORPORATION
;MAYNARD, MASS., 01754

;JOHN R. KIRCHOFF
;LINDA GARLAND

LOC	137
MCNVER,,DECVER
	NOSYM
SUBTTL	DIAGNOSTIC PARAMETERS

;OPERATOR DEFINITIONS

OPDEF	ER1	[1B8]
OPDEF	ER2	[2B8]
OPDEF	ER3	[3B8]
OPDEF	ER4	[4B8]
OPDEF	ER5	[5B8]
OPDEF	ER6	[6B8]
OPDEF	ER7	[7B8]
OPDEF	ER10	[10B8]
OPDEF	ER11	[11B8]
OPDEF	ER12	[12B8]
OPDEF	ER13	[13B8]

LUUO1==ERRMES
LUUO2==ERRMES
LUUO3==ERRMES
LUUO4==ERRMES
LUUO5==ERRMES
LUUO6==ERRMES
LUUO7==ERRMES
LUUO10==ERRMES
LUUO11==ERRMES
LUUO12==ERRMES
LUUO13==ERRMES

;SUBROUTINE ASSEMBLY DEFINITIONS

DEBUG=100
EXCASB=1
USRASB=1
KI10=1
PGMEND=1
ERDIAG=1
KLOLD=1
MODDVU=BEGIN
MODDVL=BEGIN

;MACROS

DEFINE	SAVEAC	(A,B)<
	MOVEI	SAC,.
	MOVEM	SAC,TESTPC	;SETUP SUBTEST PC
	MOVEI	SAC,SAC		;INFORM ERROR ROUTINE WHICH
	MOVEM	SAC,ERRLOP#	;AC IS USED FOR ITERATION>

;BEGIN ASSEMBLY PARAMETERS

SADR1=BEGIN
SADR2=RESRT1
SADR3=RENTR1
SADR4=BEGIN
SADR5=BEGIN
SADR6=BEGIN
SADR7=0
SADR8=0
SADR9=0
SADR10=0
SADR11=0

PAREA1=0
PAREA2=0
PAREA3=SIXBIT/DBKCC/
PAREA4=SIXBIT/PNT/
PAREA5=0
PAREA6=0

ITERAT=1000
DEFINE	DMVE	(L,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVE INSTRUCTION
;FIRST, AC, AC+1 ARE PRELOADED WITH DATA OTHER THAN THE TEST WORDS.
;THEN, THE DATA SPECIFIED BY [XWD A,B] AND [XWD C,D] IS MOVED
;FROM MEMORY TO AC, AC+1 VIA THE DMOVE INSTRUCTION.
;C(AC) AND C(AC+1) ARE THEN COMPARED WITH THE TEST WORDS
;[XWD A,B] AND [XWD C,D], RESPECTIVELY.  THE TEST PASSES IF THESE
;COMPARISONS AGREE.

Q'L'0:	MOVE	AC+5,[XWD A,B]	;INITIALIZE TEST WORDS
	MOVE	AC+6,[XWD C,D]	;FOR COMPARISON
	MOVE	AC,[XWD 707070,707070]
	MOVE	AC+1,[XWD 070707,070707]  ;INITIALIZE AC,AC+1
	DMOVE	AC,[XWD A,B	;*MOVE DOUBLE WORD A,B ; C,D
		    XWD C,D]	;FROM MEMORY TO AC, AC+1
	CAME	AC,<AC+5>&17	;WAS AC LOADED CORRECTLY?
	ER3	AC,L'1	;FAIL IF CONTENTS(AC) NOT = A,B
	CAME	AC+1,<AC+6>&17	;WAS AC+1 LOADED CORRECTLY?
	ER4	AC+1,L'2	;FAIL IF CONTENTS(AC+1) NOT = C,D
	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH>


DEFINE 	DMVE17	(L,T,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVE INSTRUCTION
;FIRST, AC, AC+1 ARE PRELOADED WITH DATA OTHER THAN THE TEST WORDS.
;THEN, THE DATA SPECIFIED BY [XWD A,B] AND [XWD C,D] IS MOVED
;FROM MEMORY TO AC, AC+1 VIA THE DMOVE INSTRUCTION.
;C(AC) AND C(AC+1) ARE THEN COMPARED WITH THE TEST
;WORDS [XWD A,B] AND [XWD C,D], RESPECTIVELY.
;THE TEST PASSES IF THESE COMPARISONS AGREE.

Q'T'0:	MOVEM	AC,%SV17#	;SAVE AC17
Q'L'0:	MOVE	AC+5,[XWD A,B]	;INITIALIZE TEST WORDS
	MOVE	AC+6,[XWD C,D]	;FOR COMPARISON
	MOVE	AC,[XWD 707070,707070]
	MOVE	AC+1,[XWD 070707,070707]  ;INITIALIZE AC,AC+1
	DMOVE	AC,[XWD A,B	;*MOVE DOUBLE WORD A,B ; C,D
		    XWD C,D]	;FROM MEMORY TO AC, AC+1
Q'T'3:	CAMN	AC,<AC+5>&17	;WAS AC LOADED CORRECTLY?
	JRST	.+4		;HERE IF NO ERROR
	MOVEM	AC,AC-1		;STORE INCORRECT RESLUTS
	MOVE	AC,%SV17	;RESTORE P
	ER3	AC-1,L'1	;FAIL IF CONTENTS(AC) NOT = A,B
	CAMN	AC+1,<AC+6>&17	;WAS AC+1 LOADED CORRECTLY?
	JRST	.+4		;HERE IF NO ERROR
	MOVEM	AC+1,AC-1	;STORE INCORRECT WORD
	MOVE	AC,%SV17	;RESTORE P
	ER4	AC-1,L'2
	MOVE	AC,%SV17	;RESTORE AC UNCONDITIONALLY
	JUMPL	SAC,Q'T'0	;LOOP ON ERROR SWITCH>
DEFINE	DMVN	(L,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVN INSTRUCTION
;FIRST, AC, AC+1 ARE PRELOADED WITH DATA OTHER THAN THE TEST WORDS.
;THEN, THE NEGATIVE (TWOS COMPLEMENT) OF THE DATA SPECIFIED BY
;[XWD A,B] AND [XWD C,D] IS MOVED FROM MEMORY TO AC, AC+1 VIA
;THE DMOVN INSTRUCTION.  C(AC) AND C(AC+1) ARE THEN COMPARED
;WITH THE NEGATIVE (TWOS COMPLEMENT) OF THE TEST
;WORDS [XWD A,B] AND [XWD C,D], RESPECTIVELY.
;THE TEST PASSES IF THESE COMPARISONS AGREE.

Q'L'0:	DMOVE	AC,[XWD 707070,707070
		    XWD 070707,070707]  ;INITIALIZE AC,AC+1
	SETCM	AC+5,[XWD A,B]	;INITIALIZE TEST WORDS FOR COMPARISON
	IFIDN	<C,D><0,0>,<
	SETZ	AC+6,
	ADDI	AC+5,1	>
	IFIDN	<C,D><400000,0>,<
	SETZ	AC+6,
	ADDI	AC+5,1	>
	IFDIF	<C,D><0,0>,<
	IFDIF	<C,D><400000,0>,<
	MOVN	AC+6,[XWD C,D]
	TLZ	AC+6,1B18	;CLEAR SIGN BIT OF LOW ORDER WORD >>
	DMOVN	AC,[XWD A,B	;*MOVE NEGATIVE OF DOUBLE WORD A,B ;
		    XWD C,D]	;C,D FROM MEMORY TO AC, AC+1
	CAME	AC,<AC+5>&17	;WAS AC LOADED CORRECTLY?
	ER3	AC,L'1	;FAIL IF CONTENTS(AC) NOT = COMPLEMENT OF A,B
	CAME	AC+1,<AC+6>&17	;WAS AC+1 LOADED CORRECTLY?
	ER4	AC+1,L'2	;FAIL IF CONTENTS(AC+1) NOT = MINUS C,D
	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH>
DEFINE	DMVN17	(L,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVN INSTRUCTION
;FIRST, AC, AC+1 ARE PRELOADED WITH DATA OTHER THAN THE TEST WORDS.
;THEN, THE NEGATIVE (TWOS COMPLEMENT) OF THE DATA SPECIFIED BY
;[XWD A,B] AND [XWD C,D] IS MOVED FROM MEMORY TO AC, AC+1 VIA
;THE DMOVN INSTRUCTION.  C(AC) AND C(AC+1) ARE THEN COMPARED
;WITH THE NEGATIVE (TWOS COMPLEMENT) OF THE TEST
;WORDS [XWD A,B] AND [XWD C,D], RESPECTIVELY.
;THE TEST PASSES IF THESE COMPARISONS AGREE.

Q'L'0:	MOVEM	AC,%SV17	;SAVE P
	DMOVE	AC,[XWD 707070,707070
		    XWD 070707,070707]  ;INITIALIZE AC,AC+1
	SETCM	AC+5,[XWD A,B]	;INITIALIZE TEST WORDS FOR COMPARISON
	IFIDN	<C,D><0,0>,<
	SETZ	AC+6,
	ADDI	AC+5,1	>
	IFIDN	<C,D><400000,0>,<
	SETZ	AC+6,
	ADDI	AC+5,1	>
	IFDIF	<C,D><0,0>,<
	IFDIF	<C,D><400000,0>,<
	MOVN	AC+6,[XWD C,D]
	TLZ	AC+6,1B18	;CLEAR SIGN BIT OF LOW ORDER WORD >>
	DMOVN	AC,[XWD A,B	;*MOVE NEGATIVE OF DOUBLE WORD A,B ;
		    XWD C,D]	;C,D FROM MEMORY TO AC, AC+1
	CAMN	AC,<AC+5>&17	;WAS AC LOADED CORRECTLY?
	JRST	.+4		;HERE IF TESTS OK
	MOVEM	AC,AC-1		;SAVE BAD WORD
	MOVE	AC,%SV17	;RESTORE P
	ER3	AC-1,L'1	;FAIL IF CONTENTS(AC) NOT = COMPLEMENT OF A,B
	CAMN	AC+1,<AC+6>&17	;WAS AC+1 LOADED CORRECTLY?
	JRST	.+4		;HERE IF TESTS OK
	MOVEM	AC,AC-1
	MOVE	AC,%SV17	;RESTORE P
	ER4	AC+1,L'2	;FAIL IF CONTENTS(AC+1) NOT = MINUS C,D
	MOVE	AC,%SV17	;RESTORE P UNCODITIONALLY
	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH>
DEFINE	DMVNF	(L,A,B,C,D,KIEF,KIUF,KLEF,KLUF)	<
;**KI10**
;THIS MACRO VERIFIES THAT THE DMOVN INSTRUCTION DOES NOT SET OVERFLOW
;OR CARRY FLAGS ON THE KI10.  FIRST, OVFL AND CRY0,1 FLAGS ARE CLEARED;
;THEN,DMOVN IS EXECUTED.  NEXT, OVFL AND CRY0,1 FLAGS ARE EXAMINED.
;IF ANY OF THESE FLAGS ARE SET, THE TEST FAILS.

;**KL10**
;THIS MACRO VERIFIES THAT THE DMOVN INSTRUCTION DOES SET OVERFLOW
;OR CARRY FLAGS ON THE KL10.  FIRST, OVFL AND CRY0,1 FLAGS ARE CLEARED;
;THEN,DMOVN IS EXECUTED.  NEXT, OVFL AND CRY0,1 FLAGS ARE EXAMINED.
;IF THE PROPER FLAGS ARE NOT SET, THE TEST FAILS.

Q'L'0:	JFCL	17,.+1		;CLEAR OVFL AND CRY0,1 FLAGS
	DMOVN	AC+1,[XWD A,B	;*DMOVN TEST
		      XWD C,D]
	JSP	AC,.+1		;READ FLAGS
Q'L'1:	TLZ	AC,027777	;CLEAR EXTRA JUNK
	TLNE	AC,USERF	;IN USER MODE ?
	JRST	Q'L'4		;YES
	SKIPE	KLFLG		;KL10 ?
	JRST	Q'L'3		;YES
;KI10 EXEC MODE
	CAME	AC,[KIEF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF OVFL OR CRY0,1 FLG SET
Q'L'2:	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH
	JRST	Q'L'6
;KL10 EXEC MODE
Q'L'3:	CAME	AC,[KLEF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF FLAGS NOT SET
	JRST	Q'L'2
;KL10/KI10 USER MODE
Q'L'4:	SKIPE	KLFLG		;KL10 ?
	JRST	Q'L'5		;YES
;KI10 USER MODE
	CAME	AC,[KIUF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF ANY FLAGS SET
	JRST	Q'L'2
;KL10 USER MODE
Q'L'5:	CAME	AC,[KLUF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF FLAGS NOT SET
	JRST	Q'L'2

Q'L'6:	JRST	.+1>
DEFINE	DMVM	(L,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVEM INSTRUCTION
;FIRST, TSTWD, TSTWD+1 ARE PRELOADED WITH DATA OTHER THAN THE
;TEST WORDS AND AC,AC+1 ARE LOADED WITH THE TEST WORDS.
;THEN, THE DATA SPECIFIED BY [XWD A,B] AND [XWD C,D] IS MOVED
;FROM AC, AC+1 TO MEMORY (TSTWD, TSTWD+1) VIA
;THE DMOVEM INSTRUCTION.  C(TSTWD) AND C(TSTWD+1) ARE THEN
;COMPARED WITH THE TEST WORDS [XWD A,B] AND [XWD C,D], RESPECTIVELY.
;THE TEST PASSES IF THESE COMPARISONS AGREE.

Q'L'0:	DMOVE	AC,[XWD 707070,707070
		    XWD 070707,070707]	;INITIALIZE TEST WORDS
	MOVEM	AC,TSTWD	;TSTWD, TSTWD+1 ARE IN MEMORY JUST
	MOVEM	AC+1,TSTWD+1	;AFTER THE FINAL TEST OF THIS PROGRAM
	DMOVE	AC,[XWD A,B
		    XWD C,D]	;INITIALIZE AC,AC+1
	DMOVEM	AC,TSTWD	;*MOVE DOUBLE WORD FROM AC, AC+1
				;TO MEMORY (TSTWD, TSTWD+1)
	DMOVE	AC,TSTWD	;PUT RESULTS OF TEST IN AC,AC+1 FOR COMPARISON
	CAME	AC,[XWD A,B]	;WAS TSTWD LOADED CORRECTLY?
	ER5	AC,L'1	;FAIL IF CONTENTS(TSTWD) NOT = A,B
	CAME	AC+1,[XWD C,D]	;WAS TSTWD+1 LOADED CORRECTLY?
	ER6	AC+1,L'2	;FAIL IF CONTENTS(TSTWD+1) NOT = C,D
	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH>

DEFINE	DMVNM	(L,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVNM INSTRUCTION
;FIRST, TSTWD, TSTWD+1 ARE PRELOADED WITH DATA OTHER THAN THE
;TEST WORDS AND AC, AC+1 ARE LOADED WITH THE TEST WORDS.
;THEN, THE NEGATIVE (TWOS COMPLEMENT) OF THE DATA SPECIFIED BY
;[XWD A,B] AND [XWD C,D] IS MOVED FROM AC, AC+1 TO MEMORY
;(TSTWD, TSTWD+1) VIA THE DMOVNM INSTRUCTION.
;C(TSTWD) AND C(TSTWD+1) ARE THEN COMPARED WITH THE
;NEGATIVE (TWOS COMPLEMENT) OF THE TEST
;WORDS [XWD A,B] AND [XWD C,D], RESPECTIVELY.
;THE TEST PASSES IF THESE COMPARISONS AGREE.

Q'L'0:	DMOVE	AC,[XWD 707070,707070
		    XWD 070707,070707]
	DMOVEM	AC,TSTWD	;INITIALIZE TEST WORDS
	DMOVE	AC,[XWD A,B
		    XWD C,D]	;INITIALIZE AC,AC+1
	DMOVN	AC+5,[XWD A,B
		      XWD C,D]	;SET-UP TO CHECK RESULTS
	DMOVNM	AC,TSTWD	;*MOVE NEGATIVE OF DOUBLE WORD FROM AC, AC+1
				;TO MEMORY (TSTWD, TSTWD+1)
	DMOVE	AC,TSTWD	;PUT TEST RESULTS IN AC,AC+1
	CAME	AC,<AC+5>&17	;WAS TSTWD LOADED CORRECTLY?
	ER5	AC,L'1	;FAIL IF CONTENTS(TSTWD) NOT = COMPLEMENT OF A,B
	CAME	AC+1,<AC+6>&17	;WAS TSTWD+1 LOADED CORRECTLY?
	ER6	AC+1,L'2	;FAIL IF CONTENTS(TSTWD) NOT = MINUS C,D
	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH>
DEFINE	DMVM17	(L,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVEM INSTRUCTION
;FIRST, TSTWD, TSTWD+1 ARE PRELOADED WITH DATA OTHER THAN THE
;TEST WORDS AND AC,AC+1 ARE LOADED WITH THE TEST WORDS.
;THEN, THE DATA SPECIFIED BY [XWD A,B] AND [XWD C,D] IS MOVED
;FROM AC, AC+1 TO MEMORY (TSTWD, TSTWD+1) VIA THE DMOVEM INSTRUCTION.
;C(TSTWD) AND C(TSTWD+1) ARE THEN COMPARED WITH THE TEST
;WORDS [XWD A,B] AND [XWD C,D], RESPECTIVELY.
;THE TEST PASSES IF THESE COMPARISONS AGREE.

Q'L'0:	MOVEM	AC,%SV17	;SAVE AC17 CAUSE IT HAS PDP
	DMOVE	AC,[XWD 707070,707070
		    XWD 070707,070707]	;INITIALIZE TEST WORDS
	MOVEM	AC,TSTWD	;TSTWD, TSTWD+1 ARE IN MEMORY JUST
	MOVEM	AC+1,TSTWD+1	;AFTER THE FINAL TEST OF THIS PROGRAM
	DMOVE	AC,[XWD A,B
		    XWD C,D]	;INITIALIZE AC,AC+1
	DMOVEM	AC,TSTWD	;*MOVE DOUBLE WORD FROM AC, AC+1
				;TO MEMORY (TSTWD, TSTWD+1)
	DMOVE	AC,TSTWD	;PUT RESULTS OF TEST IN AC,AC+1 FOR COMPARISON
	CAMN	AC,[XWD A,B]	;WAS TSTWD LOADED CORRECTLY?
	JRST	.+4		;HERE IF TESTS OK
	MOVEM	AC,AC-1		;SAVE BAD WORD
	MOVE	AC,%SV17	;RESTORE P
	ER5	AC-1,L'1	;FAIL IF CONTENTS(TSTWD) NOT = A,B
	CAMN	AC+1,[XWD C,D]	;WAS TSTWD+1 LOADED CORRECTLY?
	JRST	.+4		;HERE IF TESTS OK
	MOVEM	AC,AC-1		;SAVE BAD WORD
	MOVE	AC,%SV17	;RESTORE P
	ER6	AC+1,L'2	;FAIL IF CONTENTS(TSTWD+1) NOT = C,D
	MOVE	AC,%SV17	;RESTORE AC UNCONDITIONALLY
	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH>
DEFINE	DMVNM17	(L,A,B,C,D)	<
;THIS MACRO TESTS THE DMOVNM INSTRUCTION
;FIRST, TSTWD, TSTWD+1 ARE PRELOADED WITH DATA OTHER THAN THE
;TEST WORDS AND AC, AC+1 ARE LOADED WITH THE TEST WORDS.
;THEN, THE NEGATIVE (TWOS COMPLEMENT) OF THE DATA SPECIFIED BY
;[XWD A,B] AND [XWD C,D] IS MOVED FROM AC, AC+1 TO MEMORY
;(TSTWD, TSTWD+1) VIA THE DMOVNM INSTRUCTION.
;C(TSTWD) AND C(TSTWD+1) ARE THEN COMPARED WITH THE
;NEGATIVE (TWOS COMPLEMENT) OF THE TEST
;WORDS [XWD A,B] AND [XWD C,D], RESPECTIVELY.
;THE TEST PASSES IF THESE COMPARISONS AGREE.

Q'L'0:	DMOVE	AC,[XWD 707070,707070
		    XWD 070707,070707]
	DMOVEM	AC,TSTWD	;INITIALIZE TEST WORDS
	DMOVE	AC,[XWD A,B
		    XWD C,D]	;INITIALIZE AC,AC+1
	DMOVN	AC+5,[XWD A,B
		      XWD C,D]	;SET-UP TO CHECK RESULTS
	DMOVNM	AC,TSTWD	;*MOVE NEGATIVE OF DOUBLE WORD FROM AC, AC+1
				;TO MEMORY (TSTWD, TSTWD+1)

	DMOVE	AC,TSTWD	;PUT TEST RESULTS IN AC,AC+1
	CAMN	AC,<AC+5>&17	;WAS TSTWD LOADED CORRECTLY?
	JRST	.+4
	MOVEM	AC,AC-1		;SAVE BAD WORD
	MOVE	AC,%SV17	;RESTORE P
	ER5	AC-1,L'1	;FAIL IF CONTENTS(TSTWD) NOT = COMPLEMENT OF A,B
	CAMN	AC+1,<AC+6>&17	;WAS TSTWD+1 LOADED CORRECTLY?
	JRST	.+4		;HERE IF TESTS OK
	MOVEM	AC,AC-1		;SAVE BAD WORD
	MOVE	AC,%SV17
	ER6	AC+1,L'2	;FAIL IF CONTENTS(TSTWD) NOT = MINUS C,D
	MOVE	AC,%SV17
	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH>
DEFINE	DMVNMF	(L,A,B,C,D,KIEF,KIUF,KLEF,KLUF)	<
;**KI10**
;THIS MACRO VERIFIES THAT THE DMOVN INSTRUCTION DOES NOT SET OVERFLOW
;OR CARRY FLAGS ON THE KI10.  FIRST, OVFL AND CRY0,1 FLAGS ARE CLEARED;
;THEN,DMOVN IS EXECUTED.  NEXT, OVFL AND CRY0,1 FLAGS ARE EXAMINED.
;IF ANY OF THESE FLAGS ARE SET, THE TEST FAILS.

;**KL10**
;THIS MACRO VERIFIES THAT THE DMOVN INSTRUCTION DOES SET OVERFLOW
;OR CARRY FLAGS ON THE KL10.  FIRST, OVFL AND CRY0,1 FLAGS ARE CLEARED;
;THEN,DMOVN IS EXECUTED.  NEXT, OVFL AND CRY0,1 FLAGS ARE EXAMINED.
;IF THE PROPER FLAGS ARE NOT SET, THE TEST FAILS.

Q'L'0:	JFCL	17,.+1		;CLEAR OVFL AND CRY0,1 FLAGS
	DMOVE	AC,[XWD A,B
		    XWD C,D]	;SETUP INITIAL
	DMOVNM	AC,TSTWD	;*DMOVNM TEST
	JSP	AC,.+1		;READ FLAGS
Q'L'1:	TLZ	AC,027777	;CLEAR EXTRA JUNK
	TLNE	AC,USERF	;IN USER MODE ?
	JRST	Q'L'4		;YES
	SKIPE	KLFLG		;KL10 ?
	JRST	Q'L'3		;YES
;KI10 EXEC MODE
	CAME	AC,[KIEF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF OVFL OR CRY0,1 FLG SET
Q'L'2:	JUMPL	SAC,Q'L'0	;LOOP ON ERROR SWITCH
	JRST	Q'L'6
;KL10 EXEC MODE
Q'L'3:	CAME	AC,[KLEF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF FLAGS NOT SET
	JRST	Q'L'2
;KL10/KI10 USER MODE
Q'L'4:	SKIPE	KLFLG		;KL10 ?
	JRST	Q'L'5		;YES
;KI10 USER MODE
	CAME	AC,[KIUF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF ANY FLAGS SET
	JRST	Q'L'2
;KL10 USER MODE
Q'L'5:	CAME	AC,[KLUF,,Q'L'1]
	ER13	AC,L'1		;FAIL IF FLAGS NOT SET
	JRST	Q'L'2

Q'L'6:	JRST	.+1>
   