;*MAINDEC-10-MAGTAP

	MCNVER==0
	DECVER==5

XLIST
	.DIRECTIVE	.XTABM

	DEFINE	PTITL	(MCNVER,DECVER)<

TITLE	MAGTAP - DIAGNOSTIC DISTRIBUTION MAGTAPE CREATOR, VERSION MCNVER,DECVER>
LIST
LALL
	PTITL	\MCNVER,\DECVER

	SALL
;*			IDENTIFICATION
;*			--------------
;*
;*	PRODUCT CODE:	MAINDEC - 10 - DDQDF
;*
;*	PRODUCT NAME:	DIAGNOSTIC DISTRIBUTION MAGTAPE CREATOR
;*
;*	VERSION:	0.5
;*
;*	DATE RELEASED:	MAY 1978
;*
;*	AUTHOR:		JOHN R. KIRCHOFF
;*			DALE R. KECK
;*
;*	MAINTAINED BY:	DIAGNOSTIC ENGINEERING GROUP
;*
;*COPYRIGHT(C) 1976,1977,1978
;*DIGITAL EQUIPMENT CORPORATION
;*MARLBORO, MASS. 01752
;*
;*THIS SOFTWARE IS FURNISHED UNDER A LICENSE FOR USE ONLY
;*ON A SINGLE COMPUTER SYSTEM AND MAY BE COPIED ONLY WITH
;*THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE,
;*OR ANY OTHER COPIES THEREOF, MAY NOT BE PROVIDED OR OTHERWISE
;*MADE AVAILABLE TO ANY OTHER PERSON EXECPT FOR USE ON SUCH SYSTEM
;*AND TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE TO AND
;*OWNERSHIP OF THE SOFTWARE SHALL AT ALL TIMES REMAIN IN DEC.
;*
;*THE INFORMATION IN THIS DOCUMENT IS SUBJECT TO CHANGE WITHOUT
;*NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY DIGITAL
;*EQUIPMENT CORPORATION.
;*
;*DEC ASSUMES NO RESPONSIBILITY FOR THE USE OR RELIABILITY OF ITS
;*SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DEC.

	LOC	137
MCNVER,,DECVER
SUBTTL	PROGRAM PARAMETERS

;*ACCUMULATOR ASSIGNMENTS

	A=1				;GENERAL PURPOSE ACS
	B=2
	C=3
	D=4
	STAT=5				;OPEN BLOCK, STATUS
	DEV=6				;DEVICE NAME
	BUFFS=7				;BUFFER ADDRESS
	CNT=10				;EXTENDED LOOKUP BLOCK, COUNT
	PPN=11				;PROJECT, PROGRAMMER NUMBER
	FN=12				;FILENAME
	EXT=13				;EXTENSION
	DAT=14				;DATE
	SIZ=15				;SIZE
	VER=16				;VERSION
	P=17				;PUSH DOWN LIST POINTER

;*ASCII CHARACTER VALUES

	SPACE==" "
	TAB==11
	COMMA==","
	LF==12
	CR==15
	VT==13
	COLON==":"
	SCOLON==";"
	SLASH=="/"
	QMARK=="?"
	LB=="["
	RB=="]"
	PERIOD=="."
	DASH=="-"
	CRLF==	BYTE(7)CR,LF
;*JOB DATA AREA DEFINITIONS

	.JBREL= 44
	.JBSA= 120
	.JBFF= 121

;*MAGTAP DEFINITIONS

	RCDSIZ==^D512			;SIZE OF RECORDS ON TAPE
	NUMBUF==^D12			;NUMBER OF MAGTAPE BUFFERS
	RDIADR==1000			;ADDRESS OF READ-IN PROGRAM

	OPDEF	GO	[PUSHJ P,]
	OPDEF	RTN	[POPJ  P,]
	OPDEF	PUT	[PUSH  P,]
	OPDEF	GET	[POP   P,]
	OPDEF	TAPOP.	[CALLI 154]

	DEFINE	PRINT	(MES) <
	OUTSTR	[ASCIZ \MES\]
	>

;*I/O CHANNELS

	CH0==0				;INPUT FILE CHANNEL
	CH1==1				;INPUT CHANNEL
	CH2==2				;WRITE CHANNEL
	CH3==3				;WRITE CHANNEL
	CH4==4				;MAGTAPE CHANNEL
SUBTTL	PROGRAM INITIALIZATION

;*START, INITIAL START OF PROGRAM

START:	RESET				;RESET ALL IO CHANNELS
	MOVE	P,[-40,,PLIST-1]	;SET UP PUSH LIST
	MOVEI	PSHERR			;UNDERFLOW ERROR CALL
	PUT
	PUT
	SETZM	ALOWLD#			;DON'T ALLOW WILD CHARACTERS
	SKIPE	ONETIM#			;CHECK ONE TIME FLAG
	JRST	DEFSWT			;BYPASS PRINTING TITLE
	MOVE	.JBREL			;GET CORE ALLOCATED
	MOVEM	SAVREL#			;SAVE IT
	PRINT	<
DIAGNOSTIC DISTRIBUTION MAGTAPE CREATOR   VERSION >
	MOVEI	MCNVER			;GET EDIT NUMBER
	GO	PNTOCT			;PRINT IN OCTAL
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	MOVEI	DECVER			;GET VERSION NUMBER
	GO	PNTOCT			;PRINT IN OCTAL
	OUTSTR	[CRLF]			;END THE LINE
	SETOM	ONETIM			;SET ONE TIME FLAG

;*DEFSWT, READ SWITCH.INI FOR DEFAULT SEARCH LIST

DEFSWT:	MOVSI	'DSK'			;SET UP DEFAULT SEARCH LIST
	MOVEM	SCHLST			;OF DSK
	SETZM	SCHLST+1		;TO USER'S PPN
	SETZB	C,SCHLST+2		;END OF TABLE, CLEAR OPTION NAME
	GO	RDSWIT			;READ THE SWITCH.INI FILE
	CAI				;DON'T CARE IF CAN'T FIND IT
SUBTTL	DEVICE SELECTION

;*STARTA, ASK WHICH MAGTAPE DEVICE TO USE

STARTA:	PRINT	<
MAGTAPE	DEVICE - >

	MOVE	[INCHWL A]		;GET TERMINAL INPUT INSTRUCTION
	MOVEM	INWXCT			;PUT IN WORD EXECUTED BY INWORD
TAPEI:	SETZM	DIRFLG#			;CLEAR DIRECTORY IN CORE FLAG
	GO	INWORD			;INPUT FROM TERMINAL
	CAIN	A,33			;CHECK IF AN ALTMODE TYPED
	JRST	NULMAG			;YES, DON'T OPEN  MAGTAPE
	SKIPE				;SKIP IF NO NAME TYPED
	MOVEM	MAGDEV			;STORE AWAY NAME
MAGFLS:	CAIN	A,LF			;CHECK IF END OF LINE INPUT
	JRST	MAGINT			;YES, GO OPEN MAGTAPE
	GO	INWORD			;INPUT REST OF LINE
	JRST	MAGFLS			;NO CHECK IF END

	MOVEI	10			;SET INITIAL STATUS BITS
	HRRM	MAGINT			;TO SPECIFY IMAGE MODE
MAGINT:	INIT	CH4,10			;INIT TO IMAGE MODE
MAGDEV:	0				;MAGTAPE DEVICE NAME
	XWD	BUF4,BUF4		;BUFFER ADDRESS, INPUT AND OUTPUT
	JRST	NOMAG			;ERROR RETURN
;*CHECK DRIVE TYPE TO DETERMINE DENSITY

	MTDEC.	CH4,			;SET TO DIGITAL COMPATIBLE MODE
	MOVEI	3			;SET DENSITY CODE TO 800 BPI
	MOVEM	TAPEDC			;STORE IN MEMORY
	MOVEI	CH4			;SET UP FOR CHANNEL 4
	MTCHR.				;READ CHARACTERISTICS OF DEVICE
	JRST	NOTMAG			;NOT A MAGNETIC TAPE
	TRNE	1B31			;CHECK IF 7-TRACK
	JRST	DEN800			;7-TRACK, MUST BE 800 BPI
	MOVE	[XWD 2,[1002		;READ CONTROLLER TYPE CODE
			CH4   ]]	;FOR CHANNEL 4
	TAPOP.				;OBTAIN THE CODE
	JRST	DEN800			;NO TAPOP.S, CAN'T BE 1600 BPI
	JUMPL	ASKDEN			;IF TYPE NUMBER
	CAIG	2			;  IS 0, 1 OR 2, CONTROLLER IS TM10 OR TC10
	JRST	TMDEN			;  SO USE ONLY 800 BPI

ASKDEN:	PRINT	<WHAT DENSITY? (800 OR 1600) - >
	GO	INWORD			;INPUT FROM TERMINAL
	CAIN	A,LF			;TERMINATE WITH LF?
	JRST	DECODE			;YES, DECODE ANSWER
	PUT	0			;SAVE ANSWER
	GO	INWORD			;INPUT SOME MORE
	CAIE	A,LF			;LINE FEED NOW?
	JRST	.-2			;NO, KEEP READING
	GET	0			;GET ANSWER BACK
DECODE:	MOVE	B,DENSITY		;GET POINTER TO TABLE
	GO	COMPARE			;COMPARE ANSWER WITH TABLE
	JRST	NOTDEN			;DIDN'T COMPARE
	SKIPE	B			;SKIP IF 800 SELECTED
	AOS	TAPEDC			;CHANGE DENSITY CODE TO 1600 BPI
TMDEN:	MOVE	[XWD 3,TAPEDN]		;GET DENSITY CODE POINTER
	TAPOP.				;SET DENSITY
	JRST	NO1600			;ERROR
	JRST	COMM			;NOW ASK FOR COMMAND

NULMAG:	GO	INWORD			;INPUT TO END OF LINE
	CAIE	A,LF			;CHECK IF LINE FEED
	JRST	NULMAG			;NOT YET
	SETZM	MAGDEV			;CLEAR MAGTAPE DEVICE NAME
	JRST	COMM			;GO GET NEXT COMMAND

TAPEDN:	2001				;TAPOP. CODE TO SET DENSITY
	CH4				;MAGTAPE CHANNEL
TAPEDC:	3				;3 = 800 BPI, 4 = 1600 BPI

DEN800:	MOVEI	600			;GET 800 BPI IN STATUS BITS
	ORM	MAGINT			;SET INTO STATUS WORD
	SETSTS	CH4,@MAGINT		;SET NEW STATUS
	JRST	COMM			;GO GET NEXT COMMAND
;*MAGTAPE DEVICE SELECTION ERROR MESSAGES

NOMAG:	GO	COCLR			;CLEAR CONTROL O
	OUTCHR	["?"]			;TYPE A QUESTION MARK
	MOVE	MAGDEV			;GET MAGTAPE NAME
	GO	PNTSIX			;PRINT IT
	PRINT	< NOT AVAILABLE>
	JRST	STARTA			;GO ASK AGAIN

NOTMAG:	GO	COCLR			;CLEAR CONTROL O
	OUTCHR	["?"]			;TYPE A QUESTION MARK
	MOVE	MAGDEV			;GET DEVICE NAME
	GO	PNTSIX			;PRINT IT
	PRINT	< NOT A MAGNETIC TAPE DEVICE>
	JRST	STARTA			;ASK AGAIN

NOTDEN:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<?
>
	JRST	ASKDEN			;ASK AGAIN

NO1600:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? CAN'T SET DENSITY WITH TAPOP. UUO
>
	JRST	ASKDEN			;ASK AGAIN

;*CONTROL O CLEAR

COCLR:	TTCALL	13,0			;CLEAR CONTROL O
	JFCL
	RTN
SUBTTL	COMMAND DECODER

;*COMM, ASK FOR A COMMAND

COMM:	MOVE	P,[-40,,PLIST-1]	;SET UP PUSH LIST
	MOVEI	PSHERR			;UNDERFLOW ERROR CALL
	PUT
	PUT
	RELEASE				;RELEASE ALL DEVICES BUT MAGTAPE
	RELEASE	CH1,
	RELEASE	CH2,
	RELEASE	CH3,
	SETZM	ALOWLD#			;DON'T ALLOW WILD CHARACTERS
	SETZM	LSTSW#			;CLEAR LIST SWITCH FLAG
	SETZM	WRDIR#			;CLEAR DIRECTORY IN CORE FLAG
	GO	COCLR			;CLEAR CONTROL O
	PRINT	<
COMMAND - >				;ASK FOR COMMAND
	HLRZ	.JBSA			;GET LOWEST FIRST FREE
	SKIPE	DIRFLG			;SKIP IF DIRECTORY NOT IN CORE
	MOVE	MAGDRE#			;GET END OF DIRECTORY ADDRESS
	MOVEM	.JBFF			;SET IN JOB DATA AREA
	CAMGE	SAVREL			;DON'T REDUCE CORE BELOW ORIGINAL
	MOVE	SAVREL			;GET ORIGINAL CORE SIZE
	CORE				;REDUCE TO ORIGINAL VALUE
	CAI				;IGNORE ERROR
	MOVEI	CNT,6			;SET COUNT TO 6 FOR EXTENDED LOOKUPS
	MOVEI	STAT,10			;SET DATA MODE TO IMAGE
	MOVE	[INCHWL A]		;GET TERMINAL INPUT INSTRUCTION
	MOVEM	INWXCT#			;PUT IN LOCATION EXECUTED BY INWORD
	GO	INWORD			;GET COMMAND
	MOVE	B,COMAND		;GET COMMAND LIST ADDRESS
	GO	COMPARE			;COMPARE COMMAND TO LIST
	JRST	BADCMD			;DOES NOT MATCH
	JRST	@CMDGO(B)		;GO TO COMMAND CALLED

;*BADCMD, BAD COMMAND WAS INPUT

BADCMD:	JUMPN	BADCMI			;WAS ANY COMMAND TYPED?
	CAIN	A,LF			;NO, JUST A LINE FEED?
	JRST	COMM			;YES, ASK AGAIN
	GO	COCLR			;CLEAR CONTROL O
	OUTCHR	["?"]			;PRINT A QUESTION MARK
	OUTCHR	A			;PRINT BAD COMMAND
	JRST	BADCMX
BADCMI:	OUTCHR	["?"]			;PRINT A QUESTION MARK
	GO	PNTSIX			;PRINT WORD INPUT
BADCMX:	OUTCHR	["?"]			;PRINT ANOTHER QUESTION MARK
BADCMF:	CAIN	A,12			;LINE FEED INPUT?
	JRST	COMM			;YES, ASK FOR ANOTHER COMMAND
	GO	INWORD			;INPUT REST OF LINE
	JRST	BADCMF			;CHECK IF THIS IS ALL
;*COMAND, COMMAND COMPARE TABLE

COMAND:	XWD .-COMNDE,.+1
	SIXBIT	"HELP"
	SIXBIT	"MAKE"
	SIXBIT	"GET"
	SIXBIT	"CHECK"
	SIXBIT	"VERIFY"
	SIXBIT	"DIRECT"
	SIXBIT	"REWIND"
	SIXBIT	"UNLOAD"
	SIXBIT	"EXIT"
	SIXBIT	"SEARCH"
	SIXBIT	"OPTION"
	SIXBIT	"FDIREC"
	SIXBIT	"NUMBER"
	SIXBIT	"TAPE"
COMNDE=.-1

;*CMDGO, COMMAND DISPATCH TABLE

CMDGO:	HELP				;ADDRESSES OF COMMAND ROUTINES
	MAKE
	GETCOM
	CHEK
	VERIFY
	DIRECT
	REWIND
	UNLOAD
	LEAVE
	SRCH
	OPTION
	FDIR
	NUMBER
	TAPEIN

CMDERR:	CAIN	A,LF			;END OF LINE INPUT?
	JRST	CMDERP			;YES, GO PRINT
	GO	INWORD			;NO, INPUT MORE CHARACTERS
	JRST	CMDERR
CMDERP:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? COMMAND ERROR>	;PRINT ERROR MESSAGE
	JRST	COMM			;ASK AGAIN
;*SWPROC, COMMAND SWITCH PROCESS

SWPROC:	PUT	B
	GO	INWORD			;GET SWITCH COMMAND
	MOVE	B,SWCMD			;GET SWITCH LIST ADDRESS
	GO	COMPARE			;COMPARE COMMAND TO LIST
	JRST	BADCMD			;DOES NOT MATCH
	JRST	@SWGO(B)		;GO TO SWITCH COMMAND CALLED

SWCMD:	XWD	.-SWCMDE,.+1
	SIXBIT	"LIST"
	SIXBIT	"GROUP"
	SIXBIT	"TYPE"
SWCMDE=.-1

SWGO:	SWLIST				;ADDRESS OF SWITCH COMMAND ROUTINES
	SWGRP
	SWTYPE

SWLIST:	SETOM	LSTSW			;SET LISTING SWITCH
	JRST	SWEXIT

;*DENSITY, DENSITY COMPARE TABLE

DENSITY:XWD -2,.+1			;POINTER TO TABLE
	SIXBIT	"800"
	SIXBIT	"1600"
;*SWGRP, GET-CHECK-VERIFY ETC. COMMAND /GROUP PROCESS

SWGRP:	CAIE	A,":"			;/GROUP SW END WITH COLON
	JRST	BADCMD			;NO, ERROR
	GO	INWORD			;GET ARGUMENT
	MOVE	B,GPCMD			;GET SWITCH LIST ADDRESS
	GO	COMPARE			;COMPARE COMMAND TO LIST
	JRST	BADCMD			;DOES NOT MATCH
	MOVEM	B,GPNBR			;SAVE GROUP NUMBER
	JRST	SWEXIT			;TO SWPROC EXIT

;*SWTYPE, GET-CHECK-VERIFY ETC. COMMAND /TYPE PROCESS

SWTYPE:	CAIE	A,":"			;/TYPE SW END WITH COLON
	JRST	BADCMD			;NO, ERROR
	GO	INWORD			;GET ARGUMENT
	MOVE	B,TYPCMD		;GET SWITCH LIST ADDRESS
	GO	COMPARE			;COMPARE COMMAND TO LIST
	JRST	BADCMD			;DOES NOT MATCH
	CAIN	B,0			;/TYPE:ALL ?
	JRST	.+5			;YES
	MOVEI	0,1			;CHANGE TYPE INTO BIT POSITION
	SOS	B
	LSH	0,(B)
	ORM	0,TYPNBR		;OR TYPE BIT INTO TYPE NUMBER
	JRST	SWEXIT			;TO SWPROC EXIT

;*SWEXIT, SWITCH PROCESS EXIT

SWEXIT:	CAIN	A,"/"			;DID THIS SW END WITH SLASH ?
	JRST	SWPROC+1		;YES, PROCESS ANOTHER SWITCH
	CAIE	A,LF			;MUST BE LF THEN
	JRST	BADCMD			;NO, ERROR

	GET	B			;OK, RETURN
	RTN

TYPCMD:	XWD	.-TYPCME,.+1
	SIXBIT	"ALL"
	SIXBIT	"EXEC"
	SIXBIT	"USER"
	SIXBIT	"SPECIA"
	SIXBIT	"MONITO"
	SIXBIT	"UNDEF"
TYPCME=.-1
;*SWINP, MAKE COMMAND /GROUP SWITCH PROCESS

SWINP:	PUT	A
	PUT	B
	PUT	INWXCT			;SAVE PRESENT INPUT INST
	MOVE	B,[GO INWINP]
	MOVEM	B,INWXCT		;SETUP TO READ FROM INP FILE
	GO	INWORD			;GET SWITCH COMMAND
	CAME	[SIXBIT/GROUP/]
	JRST	SWIERR			;ONLY SW IS /GROUP:
	CAIE	A,":"
	JRST	SWIERR

	GO	INWORD			;GET ARGUMENT
	MOVEM	A,SAVA#			;SAVE CMD TERMINATOR
	MOVE	B,GPCMD			;GET SWITCH LIST ADDRESS
	GO	COMPARE			;COMPARE COMMAND TO LIST
	JRST	SWIERR			;DOES NOT MATCH
	MOVEM	B,GPNBR			;SAVE GROUP NUMBER

	SKIPN	WRDIR			;WRITING .DIR FILE ?
	JRST	SWINP1			;NO

	PUT	0
	MOVE	A,[POINT 7,[ASCIZ "/GROUP:"]]
	ILDB	A			;PUT COMMAND IN .DIR FILE
	JUMPE	.+3
	GO	WRCHAR
	JRST	.-3

	GET	0
	MOVEI	A,6
	GO	OUTWRD			;PUT ARGUMENT IN .DIR FILE

SWINP1:	GET	INWXCT			;RESTORE INPUT INST
	GET	B
	GET	A
	MOVE	SAVA			;PUT COMMAND TERMINATOR IN 0
	JRST	RDONW			;PUT REST OF LINE IN .DIR FILE
;*GPCMD, MAKE /GROUP COMMAND TABLE

GPCMD:	XWD	.-GPCMDE,.+1
	SIXBIT	"ALL"		;0
	SIXBIT	"DIASUP"	;1
	SIXBIT	"KACPU"		;2
	SIXBIT	"KICPU"		;3
	SIXBIT	"KLCPU"		;4
	SIXBIT	"KLDIAG"	;5
	SIXBIT	"KLTIC"		;6
	SIXBIT	"KLISO"		;7
	SIXBIT	"KLADIA"	;8
	SIXBIT	"KLATIC"	;9
	SIXBIT	"KLAISO"	;10
	SIXBIT	"KLBDIA"	;11
	SIXBIT	"KLBTIC"	;12
	SIXBIT	"KLBISO"	;13
	SIXBIT	"MEMORY"	;14
	SIXBIT	"TAPE"		;15
	SIXBIT	"DISK"		;16
	SIXBIT	"UNIREC"	;17
	SIXBIT	"COMMUN"	;18
	SIXBIT	"SYSEXR"	;19
	SIXBIT	"FEDIAG"	;20
	SIXBIT	"FESUPP"	;21
	SIXBIT	"FLDSRV"	;22
	SIXBIT	"SPECIA"	;23
	SIXBIT	"TOPS10"	;24
	SIXBIT	"TOPS20"	;25
	SIXBIT	"UNDEF1"	;26
	SIXBIT	"UNDEF2"	;27
	SIXBIT	"UNDEF3"	;28
	SIXBIT	"UNDEF4"	;29
	SIXBIT	"UNDEF5"	;30
	SIXBIT	"UNDEF6"	;31
GPCMDE=.-1
SUBTTL	MAKE COMMAND

;*MAKE, MAKE COMMAND WAS TYPED
;*	INPUT ARGUMENTS WITH COMMAND

MAKE:	SETZM	DIRFLG			;CLEAR DIRECTORY IN CORE FLAG
	SETZM	GPNBR#			;SET GROUP NUMBER TO ZERO
	SETZM	TYPNBR#			;SET TYPE NUMBER TO ZERO
	HLRZ	B,.JBSA			;RECLAIM CORE FROM DIRECTORY AREA
	MOVEM	B,.JBFF
	MOVSI	'DSK'			;SET UP DEFAULT INPUT FILE SPECS
	MOVEM	INDEVN			;DEVICE
	MOVE	['MAGTAP']
	MOVEM	INFILN			;FILE NAME
	MOVSI	'INP'
	MOVEM	INFILE			;EXTENSION
	SETZM	INFILP			;PPN
	CAIN	A,LF			;CHECK IF TERMINATOR IS LINE FEED
	JRST	MKINDD			;YES, GO READ INDIRECT FILE
	CAIN	A,"@"			;IS INDIRECT SPECIFIED ?
	JRST	MKIND			;YES
	GO	INWORD			;INPUT ANOTHER WORD
	CAIN	A,LF			;LINE FEED
	JUMPE	MKINDD			;AND NO FILE NAMED
	CAIE	A,"@"			;SKIP IF INDIRECT SPECIFIED
	JRST	MAKNOI			;GO INPUT FILE NAMES

;*MKIND, MAKE COMMAND INDIRECT TO EXISTING FILE

MKIND:	GO	INWORD			;INPUT NEXT WORD
	CAIE	A,COLON			;TERMINATE A COLON?
	JRST	MKFILN			;NO, LOAD FILE NAME
	JUMPE	CMDERR			;ERROR IF NO DEVICE NAMED
	MOVEM	INDEVN			;LOAD INTO DEVICE NAME
	JRST	MKIND			;INPUT NEXT WORD
MKFILN:	SKIPE				;SKIP IF NO FILE NAMED
	MOVEM	INFILN			;LOAD FILE NAME
	CAIE	A,PERIOD		;PERIOD TYPED?
	JRST	MKPPN			;NO
	GO	INWORD			;GET EXTENSION
	MOVEM	INFILE			;LOAD EXTENSION
MKPPN:	CAIE	A,LB			;LEFT BRACKET TYPED?
	JRST	MKTERM			;NO
	GO	INNUM			;INPUT OCTAL NUMBER
	CAIE	A,COMMA			;TERM A COMMA?
	JRST	CMDERR			;NO, ERROR
	HRLM	INFILP			;LOAD PROJECT NUMBER
	GO	INNUM			;INPUT ANOTHER NUMBER
	HRRM	INFILP			;LOAD PROGRAMMER NUMBER
	CAIN	A,RB			;RIGHT BRACKET INPUT?
	JRST	MKIND			;YES, INPUT MORE
	CAIE	A,LF			;END OF LINE?
	JRST	CMDERR			;NO, ERROR
	JRST	MKINDD			;YES, INPUT DONE
;*MKTERM, COMPARE EXISTING INPUT FILE WITH REQUIRED FORMAT

MKTERM:	CAIN	A,"/"			;INPUT A SLASH ?
	GO	SWPROC			;YES, PROCESS SWITCH
	CAIE	A,SPACE			;INPUT A SPACE
	CAIN	A,TAB			;OR TAB?
	JRST	MKIND			;YES, GO CONTINUE INPUT
	CAIE	A,LF			;END OF LINE?
	JRST	CMDERR			;NO, UNEXPECTED CHARACTER
MKINDD:	MOVEI	BUF0			;SET UP BUFFER ADDRESS
	MOVEM	INDEVB			;FOR INPUT FILE
	OPEN	INDEV			;OPEN DISK ON CHANNEL 0
	JRST	OPENFI			;AND READ INPUT FILE
	MOVE	INFILP			;GET P,PN
	MOVEM	INPPN			;PUT IN LOOKUP BLOCK
	LOOKUP	INFILN			;LOOK UP INPUT FILE
	JRST	LOOKFI			;ERROR RETURN, CAN'T FIND IT
	IN				;SET UP BUFFERS
	MOVEI	A,0			;FILE NUMBER
	MOVEI	B,NAMTAB		;ADR OF NAME TABLE
CHKINF:	GO	RDNAME			;READ A FILE NAME FROM INPUT FILE
	JRST	INFILR			;FILE ERROR
	CAMN	FN,(B)			;COMPARE FILE NAMES
	CAME	EXT,1(B)		;AND EXTENSIONS
	JRST	INFILM			;THEY DON'T MATCH
	ADDI	B,2			;INCREMENT TO NEXT NAME
	CAIE	A,4			;FIVE FILES CHECKED?
	AOJA	A,CHKINF		;NO, CHECK MORE
	ADDI	A,1			;CHECK THE "INP" FILE
	GO	RDNAME			;READ NEXT FILE NAME
	JRST	INFILR			;ERROR ON EOF
	CAME	FN,INFILN		;CHECK FILE NAME WITH THIS FILE
	JRST	INFILM			;DON'T COMPARE
	HLLZ	INFILE			;GET EXTENSION ONLY
	CAME	EXT			;COMPARE
	JRST	INFILM			;DON'T COMPARE

	JRST	MKRDI			;INPUT FILE OK, GO MAKE RDI FILE
;*MAKNOI, INPUT LIST OF FILE NAMES FROM COMMAND
;*	MAKE A FILE OF INFORMATION CALLED MAGTAP.TMP

MAKNOI:	CAIN	A,"/"			;CHECK IF TERM A SLASH
	JRST	CMDERR			;YES, ERROR
	CAIN	A,LF			;CHECK IF TERM A LF
	JRST	CMDERR			;YES, ERROR
	MOVSI	B,'TMP'			;GET TMP EXTENSION
	MOVEM 	B,INFILE		;STORE IN EXTENSION WORD
	GO	INLIST			;INPUT LIST OF FILE NAMES
	CAIN	A,"/"			;WAS TERM A SLASH ?
	GO	SWPROC			;YES, PROCESS SWITCH COMMAND
	PRINT	<WRITING FILE MAGTAP.TMP
>
	MOVEI	BUF3			;GET BUFFER ADR
	MOVSM	INDEVB			;SET UP FOR OUTPUT
	OPEN	CH3,INDEV		;OPEN DISK FOR OUTPUT
	JRST	OPENFI			;ERROR
	MOVE	INFILP			;GET P,PN
	MOVEM	INPPN			;PUT IN LOOKUP BLOCK
	ENTER	CH3,INFILN		;ENTER FILE
	JRST	ENTRFI			;ERROR RETURN
	OUTBUF	CH3,			;SET UP BUFFERS

	MOVE	D,[XWD -5,NAMTAB]	;SET UP FOR 5 FILE NAMES
	GO	WRITF			;WRITE THEM
	MOVE	D,[XWD -1,INFILN]	;SET UP FOR INPUT FILE
	HLLZS	INFILE			;CLEAR DATE FROM ENTENSION WORD
	GO	WRITF			;WRITE IT
	MOVE	D,B			;GET INPUT LIST POINTER
	GO	WRITF			;WRITE THEM
;*MKRDI, CHECK IF MAGTAP.RDI AND DXMPA.A8 EXIST
;*	IF DXMPA.A8 EXISTS, MAKE NEW RDI FILE UNLESS NEWER THAN DXMPA.A8

MKRDI:	RELEASE	CH3,			;CLOSE AND RELEASE FILE ON CHN 0
	HLRZ	.JBSA			;RESTORE .JBFF TO RESET VALUE
	MOVEM	.JBFF			;TO REUSE CORE AREA
	MOVEI	CNT,4			;SET ARG COUNT TO 4
	SETZ	STAT,			;SET ASCII MODE
	MOVE	FN,[SIXBIT "DXMPA"]	;LOOKUP DX10 MICRO CODE FILE
	MOVSI	EXT,'A8 '	
	SETZB	DEV,DATEX#		;NO DEVICE OPEN NOW, ZERO DATE
	MOVEI	CH1			;SET CHANNEL NO.
	MOVEM	CHAN#			;TO 1
	MOVEI	BUFFS,BUF1		;INPUT BUFFER IS BUF1
	GO	FIND			;FIND FILE
	JRST	LOKRDI			;NON-EXISTANT
	MOVE	DAT			;GET DATE
	ANDI	7777			;CLEAR OTHER BITS
	LSH	EXT,-3			;POSITION HIGH ORDER 3 BITS OF DATE
	ANDI	EXT,70000		;CLEAR OTHER BITS
	OR	EXT			;MERGE
	LSH	DAT,-^D12		;POSITION TIME
	ANDI	DAT,3777		;CLEAR OTHER BITS
	HRL	DAT			;PUT IN LEFT OF 0
	MOVEM	DATEX			;SAVE DATE AND TIME OF DXMPA
LOKRDI:	MOVE	FN,[SIXBIT "MAGTAP"]	;LOOKUP MAGTAP.RDI
	MOVSI	EXT,'RDI'	
	SETZB	DEV,BUFFS		;NO DEVICE CURRENTLY OPEN, NO BUFFERS
	MOVEI	CH2			;SET UP CHANNEL NO.
	MOVEM	CHAN			;TO 2
	GO	FIND			;FIND FILE
	JRST	NEWRDI			;NOT FOUND, MAKE A NEW RDI FILE
	SKIPN	DATEX			;MICRO-CODE EXIST?
	JRST	MKDIR			;NO, USE RDI FILE
	LDB	[POINT 12,DAT,35]	;GET LOW ORDER BITS OF DATE
	LDB	A,[POINT 3,EXT,20]	;GET HIGH ORDER BITS
	DPB	A,[POINT 3,0,23]	;PUT TOGETHER IN 0
	HRRZ	A,DATEX			;GET DATE OF DXMPA
	CAMLE	A			;RDI DATE NEWER THAN DXMPA?
	JRST	MKDIR			;YES, USE RDI FILE
	CAME	A			;DATES SAME?
	JRST	UPDRDI			;NO, GO UPDATE RDI FILE
	LDB	[POINT 11,DAT,23]	;GET CREATION TIME OF RDI FILE
	HLRZ	A,DATEX			;AND DXMPA
	CAML	A			;RDI FILE OLDER?
	JRST	MKDIR			;NO, USE RDI FILE
	JRST	UPDRDI			;GO UPDATE RDI FILE
;*NEWRDI, MAKE FILE CALLED MAGTAP.RDI
;*	THE READ-IN BOOTSTRAP FILE TO GO ON THE FRONT OF THE TAPE

NEWRDI:	SKIPN	DATEX			;SKIP IF MICRO-CODE IS EXISTANT
	JRST	NOMCOD			;NO, CAN'T MAKE RDI FILE
UPDRDI:	HLLZS	EXT			;CLEAR CREATION AND
	SETZ	DAT,			;ACCESS DATES
	PRINT	<WRITING FILE MAGTAP.RDI
>
	MOVSI	BUFFS,BUF2		;GET OUTPUT BUFFER ADR
	MOVEI	STAT,13			;BINARY MODE
	OPEN	CH2,STAT		;OPEN CHANNEL
	JRST	OPENFG			;ERROR
	ENTER	CH2,CNT			;ENTER FILE NAME
	JRST	ENTRFG			;ERROR
	OUTPUT	CH2,			;SET UP OUTPUT BUFFERS
	IN	CH1,			;SET UP INPUT BUFFERS
	MOVE	A,[-<RDIEND-RDI0>,,RDI0] ;SIZE OF RDI PROGRAM, ADR
	MOVEI	B,RCDSIZ-<RDIEND-RDI0>	;ZERO FILL COUNTER
RDIWRT:	MOVE	(A)			;GET A DATA WORD
	GO	WRT2			;WRITE IT
	AOBJN	A,RDIWRT		;COUNT THE WORDS
	JUMPE	B,RDIDXM		;JUMP IF NO ZERO WORDS
	SETZ				;CLEAR 0
	GO	WRT2			;WRITE ZEROS
	SOJG	B,.-1			;FOR ZERO FILL COUNT
RDIDXM:	GO	RDDXMC			;GO READ MICRO-CODE FILE
	MOVSI	A,-<10K/3+1>		;GET COUNT IF WORDS IN STORAGE AREA
	HRR	A,.JBFF			;GET START ADR
RDIMC:	MOVE	(A)			;GET A WORD
	GO	WRT2			;WRITE THIS WORD
	AOBJN	A,RDIMC			;COUNT ALL THE WORDS
MKDIR:	RELEASE	CH2,			;CLOSE AND RELEASE THE FILE
	RELEASE	CH1,			;RELEASE DXMPA.A8
	HLRZ	.JBSA			;GET ORIGINAL FIRST FREE
	MOVEM	.JBFF			;STORE IN .JBFF
	SETZM	GPNBR			;CLEAR GROUP NUMBER
	PRINT	<WRITING FILES MAGTAP.MTA AND MAGTAP.DIR
>
;*	OPEN INPUT FILE

	MOVEI	BUF0			;SET UP READ BUFFER ADDRESS
	MOVEM	INDEVB			;IN DEVICE BLOCK
	OPEN	INDEV			;OPEN CHANNEL 0 FOR INPUT DEVICE
	JRST	OPENFI			;ERROR
	MOVE	INFILP			;GET P,PN
	MOVEM	INPPN			;PUT IN LOOKUP BLOCK
	LOOKUP	INFILN			;LOOKUP INPUT FILE
	JRST	LOOKFI			;ERROR
	IN				;SET UP BUFFERS
	MOVE	[GO INWDEV]		;GET DEVICE READ DISPATCH INSTRUCTION
	MOVEM	INWXCT			;PUT IN LOCATION EXECUTED BY INWORD
	SETZM	CHAR#
	SETZM	LINE#
	SETZM	PAGE#

;*	OPEN CHANNEL 2 FOR MAGTAP.MTA

	MOVEI	CNT,6			;LOOKUP ARGUMENT COUNT
	MOVE	FN,['MAGTAP']		;GET  FILE NAME
	MOVSI	EXT,'MTA'		;EXTENSION
	SETZ	DEV,			;CLEAR DEV
	MOVEI	CH2			;SET UP FOR
	MOVEM	CHAN			;CHANNEL 2
	MOVEI	STAT,13			;SET UP FOR BINARY MODE
	MOVSI	BUFFS,BUF2		;SPECIFY OUTPUT BUFFER
	GO	FIND			;FIND THE FILE
	JFCL				;NOT, FOUND
DIRMTA:	HLLZS	EXT			;CLEAR RIGHT HALF OF EXTENSION
	SETZB	DAT,VER			;CLEAR DATE AND VERSION
	CLOSE	CH2,			;CLOSE THE INPUT FILE
	ENTER	CH2,CNT			;ENTER THE FILE
	JRST	ENTRFG			;ERROR
	OUTBUF	CH2,			;SET UP OUTPUT BUFFERS
;*	OPEN CHANNEL 3 FOR MAGTAP.DIR

	MOVSI	EXT,'DIR'		;SET UP EXTENSION
	SETZB	DEV,STAT		;CLEAR DEV, SET ASCII MODE
	AOS	CHAN			;CHANGE CHANNEL TO 3
	MOVSI	BUFFS,BUF3		;SPECIFY OUTPUT BUFFER
	GO	FIND			;FIND THE FILE
	JFCL				;NOT FOUND
DIRDIR:	HLLZS	EXT			;CLEAR DATE FROM EXTENSION
	SETZB	DAT,VER			;CLEAR DATE AND VERSION
	CLOSE	CH3,			;CLOSE INPUT FILE
	ENTER	CH3,CNT			;ENTER DIR FILE
	JRST	ENTRFG			;ERROR
	OUTBUF	CH3,			;SET UP BUFFERS
	SETOM	WRDIR			;SET WRITING DIRECTORY FLAG
	GO	RDNAME			;READ A NAME FROM THE FILE
	JRST	RDNMER			;ERROR READING INPUT FILE
	MOVE	.JBFF			;GET JOB FIRST FREE
	MOVEM	SAVFF#			;SAVE IT
	SETZB	B			;WRITE A ZERO FILE NUMBER
	GO	WRT2
	MOVEI	CH1			;SET UP FOR CHANNEL 1
	MOVEM	CHAN			;PUT IN CHAN
	MOVEI	BUFFS,BUF1		;SET UP INPUT BUFFER ADDRESS
;*	CREATE THE MAGTAPE DIRECTORY FILES

	MOVE	A,[POINT 7,[ASCIZ "DIAGNOSTIC MAGTAPE CREATED BY MAGTAP VER "]]
DIRHED:	ILDB	A			;GET A CHARACTER
	JUMPE	DIRVER			;JUMP AROUND IF NULL
	GO	WRCHAR			;WRITE CHARACTER
	JRST	DIRHED			;GET NEXT CHARACTER
DIRVER:	SETZM	LDCHAR			;CLEAR LEADING CHARACTER FOR OUTNUM
	LDB	[POINT 9,137,17]	;GET EDIT NUMBER
	GO	OUTNUM			;WRITE NUMBER
	MOVEI	PERIOD			;WRITE A PERIOD
	GO	WRCHAR
	LDB	[POINT 9,137,35]	;GET VERSION NUMBER
	GO	OUTNUM			;WRITE NUMBER
	MOVSI	' ON'			;PRINT ON
	MOVEI	A,4			;SET CHARACTER COUNT TO 4
	GO	OUTWRD			;WRITE WORD
	DATE				;GET TODAY'S DATE
	GO	WRDATE			;WRITE THE DATE
	MOVSI	'AT '			;PRINT AT
	MOVEI	A,3			;SET CHARACTER COUNT TO 3
	GO	OUTWRD			;WRITE WORD
	MSTIME				;GET TIME
	IDIVI	^D60K			;DIVIDE INTO MINUTES
	IDIVI	^D60			;DIVIDE OUT HOURS
	PUT	A			;SAVE MINUTES
	IDIVI	^D10			;DIVIDE BY 10
	GO	OUTDIG			;PRINT THE NUMBER
	MOVE	A			;GET NEXT DIGIT
	AOS	DIGCNT			;CAUSE REST OF DIGITS TO BE PRINTED
	GO	OUTDIG			;PRINT DIGIT
	MOVEI	COLON			;PRINT A COLON
	GO	WRCHAR	
	GET	0			;GET MINUTES AGAIN
	IDIVI	^D10			;DIVIDE BY 10	
	GO	OUTDIG			;PRINT FIRST DIGIT
	MOVE	A			;GET SECOND DIGIT
	GO	OUTDIG			;PRINT IT
	MOVE	A,[POINT 7,HEDMSG]
	ILDB	A
	JUMPE	.+3
	GO	WRCHAR			;WRITE HEADER
	JRST	.-3
;*DIRFIL, SET UP EACH RECORD OF MTA FILE WITH FILE COUNT AND CHECKSUM

DIRRCD:	HRRZM	B,CHECK			;CLEAR CHECKSUM
	HRLI	B,-<RCDSIZ-2>/3		;SET IN COUNT OF FILE NAMES PER RECORD

DIRFIL:	SETZM	DIGCNT#			;CLEAR DIGIT COUNTER
	MOVEI	A,SPACE			;SET LEADING CHARACTER TO A SPACE
	MOVEM	A,LDCHAR		;FOR OUTDIG ROUTINE
	HRRZ	B			;GET FILE NUMBER
	IDIVI	^D1000			;DIVIDE BY 1000
	GO	OUTDIG			;WRITE THE DIGIT
	MOVE	A			;GET REMAINDER
	IDIVI	^D100			;DIVIDE BY 100
	GO	OUTDIG			;WRITE THE DIGIT
	MOVE	A			;GET REMAINDER
	IDIVI	^D10			;DIVIDE BY 10
	GO	OUTDIG			;WRITE THE DIGIT
	MOVEI	"0"(A)			;GET REMAINING DIGIT
	GO	WRCHAR			;WRITE IT
	MOVEI	PERIOD			;WRITE A PERIOD
	GO	WRCHAR
	MOVEI	SPACE			;WRITE 2 SPACES
	GO	WRCHAR
	GO	WRCHAR

	LDB	A,[POINT 3,TYPNBR,32]
	MOVEI	"0"(A)
	GO	WRCHAR			;WRITE HI-DIGIT TYPE NUMBER
	LDB	A,[POINT 3,TYPNBR,35]
	MOVEI	"0"(A)
	GO	WRCHAR			;WRITE LO-DIGIT TYPE NUMBER
	MOVEI	SPACE
	GO	WRCHAR			;WRITE 2 SPACES
	GO	WRCHAR

	MOVE	FN			;GET FILE NAME
	ADDM	CHECK			;ADD TO CHECKSUM
	GO	WRT2			;WRITE NAME IN MTA FILE
	MOVEI	A,7			;SET CHAR COUNT TO 7
	GO	OUTWRD			;WRITE WORD INTO .DIR FILE
	CAME	FN,['MAGTAP']		;IS FILE NAME MAGTAP?
	JRST	DIRFND			;NO, GO FIND THE FILE
	HLRZ	EXT			;GET EXTENSION
	CAIE	'MTA'			;CHECK IF ONE OF THE FILES
	CAIN	'DIR'			;BEING WRITTEN
	SKIPA				;YES, PUT IN CURRENT DATE
	JRST	DIRFND			;NO, GO FIND FILE
	DATE	DAT,			;GET TODAY'S DATE
	MSTIME				;GET TIME
	IDIVI	^D60K			;CONVERT TO MINUTES
	HRRM	EXT			;STORE TO RIGHT OF EXTENSION
	SETZ	VER,			;CLEAR VERSION
	SETZM	INCNT			;NO SIZE ON "MAGTAP'S" FILES
	JRST	DIREXT			;GO WRITE EXTENSION

;*DIRFND, READ EACH FILE TO GET DIRECTORY INFORMATION

DIRFND:	GO	FIND			;FIND THE FILE
	JRST	NOTFND			;NOT FOUND

	GO	INCOMP			;FIND INPUT FILE SIZE
	LDB	[POINT 11,DAT,23]	;GET TIME FROM FILE
	LDB	A,[POINT 3,EXT,20]	;GET 3 BITS OF DATE FROM EXT WORD
	HRRM	EXT			;PUT TIME TO RIGHT OF EXTENSION
	ANDI	DAT,7777		;CLEAR ALL BUT DATE BITS
	DPB	A,[POINT 3,DAT,23]	;SET IN HIGH ORDER BITS

DIREXT:	MOVE	GPNBR			;INSERT GROUP NUMBER IN .MTA FILE
	DPB	[POINT 5,EXT,24]

	LDB	[POINT 2,TYPNBR,32]
	DPB	[POINT 2,EXT,19]	;INSERT HI 2 BITS OF TYPE NUMBER
	MOVE	EXT			;GET EXTENSION
	ADDM	CHECK			;ADD TO CHECKSUM
	GO	WRT2			;WRITE IN .MTA FILE
	HLLZ	EXT			;GET EXTENSION
	MOVEI	A,4			;SET CHARACTER COUNT TO 4
	GO	OUTWRD			;WRITE EXTENSION INTO .DIR FILE
	GO	GETVER			;GET VERSION NUMBER FROM FILE
					;AND WRITE IT IN .DIR FILE
	MOVE	TYPNBR
	DPB	[POINT 3,DAT,20]	;INSERT LOW 3 BITS OF TYPE NUMBER
	MOVE	DAT			;GET VERSION AND DATE WORD
	ADDM	CHECK			;ADD TO CHECKSUM
	GO	WRT2			;WRITE INTO .MTA FILE
	MOVEI	SPACE			;SET LEADING CHARACTER TO SPACE
	MOVEM	LDCHAR			;FOR OUTDIG ROUTINE
	LDB	[POINT 15,DAT,35]	;GET DATE
	GO	WRDATE			;WRITE THE DATE
	GO	WRSIZE			;WRITE FILE SIZE
	MOVE	SAVFF			;RESTORE FIRST FREE
	MOVEM	.JBFF			;WITH START VALUE
;*	FINISH LINE OF DIRECTORY FILE MAGTAP.DIR WITH INPUT DATA

SKIPIN:	SKIPN	A,CHAR			;CHECK IF INPUT TO END OF LINE
	JRST	SKIPCR			;YES, GO PRINT CR
	CAIL	A,^D34			;CHECK IF 34 CHARACTERS INPUT
	JRST	SKIPON			;YES, GO AROUND
	GO	RDCHAR			;READ ANOTHER CHARACTER
	JRST	SKIPCR			;EOF, CALL IT END OF LINE
	JRST	SKIPIN			;KEEP SKIPPING INPUT CHARACTERS
SKIPCR:	MOVEI	CR			;OUTPUT A CR
	JRST	SKIPX
SKIPON:	MOVEI	TAB			;PREPARE TO PRINT A TAB
	CAIE	A,^D34			;SKIP IF EXACTLY ON 34 CHARACTERS
SKIPX:	GO	WRCHAR			;NO, WRITE A TAB

	GO	RDNAME			;READ NEXT FILE NAME
	JRST	DIREND			;END OF INPUT FILE
	AOBJN	B,DIRFIL		;RECORD NEXT FILE UNLESS FULL
	HRRZ	CHECK			;GET RIGHT HALF OF CHECKSUM
	HLRZ	A,CHECK			;GET LEFT HALF OF CHECKSUM
	ADD	A			;ADD TOGETHER
	HRLI	0			;MARK MORE RECORDS TO COME WITH 0 IN LEFT HALF
	GO	WRT2			;WRITE CHECKSUM INTO RECORD
	HRRZ	B			;GET NEXT FILE NUMBER
	GO	WRTBF2			;WRITE CURRENT RECORD AND FILE NUMBER INTO NEXT
	JRST	DIRRCD			;GO WRITE NEXT RECORD
;*DIREND, INSERT CHECKSUM TO END OF DIRECTORY RECORD IN MTA FILE

DIREND:	HRRZ	CHECK			;GET RIGHT HALF OF CHECKSUM
	HLRZ	A,CHECK			;GET LEFT HALF OF CHECKSUM
	ADD	A			;ADD TOGETHER
	HRLI	1			;MARK LAST RECORD WITH 1 IN LEFT HALF
	GO	WRT2			;WRITE INTO RECORD
	RELEASE	CH2,			;CLOSE THE .MTA FILE
	RELEASE	CH3,			;CLOSE THE .DIR FILE
	RELEASE	CH0			;RELEASE INPUT FILES
	RELEASE	CH1		
	HLRZ	.JBSA			;RESTORE .JBFF TO ORIGINAL
	MOVEM	.JBFF			;VALUE FOR NEXT STEP
	SETZM	WRDIR			;CLEAR WRITING DIRECTORY FLAG
	SKIPN	MAGDEV			;SKIP IF MAGTAPE DEVICE OPEN
	JRST	COMM		
	PRINT	<MAKING MAGTAPE
>
	OPEN	INDEV			;OPEN INPUT DEVICE
	JRST	OPENFI			;ERROR
	MOVE	INFILP			;GET P,PN
	MOVEM	INPPN			;PUT IN LOOKUP BLOCK
	LOOKUP	INFILN			;LOOKUP INPUT FILE
	JRST	LOOKFI			;ERROR
	IN				;SET UP BUFFERS
	MTREW.	CH4,			;REWIND THE MAGTAPE
	GO	MAGBUF			;SET UP MAGTAPE BUFFERS
	MOVEI	STAT,10			;SET MODE TO IMAGE
	MOVE	.JBFF			;SAVE FIRST FREE
	MOVEM	SAVFF			;ADDRESS
;*MKTAPE, WRITE THE MAGTAPE

MKTAPE:	GO	RDNAME			;READ A FILE NAME FROM INPUT FILE
	JRST	MKEND			;END OF TAPE
	GO	FIND			;LOOKUP FILE
	JRST	NOTFND			;ERROR
	IN	CH1,			;SET UP BUFFERS
	SKIPN	LSTSW			;LIST FILES AS PROCESSED ?
	JRST	.+10			;NO
	OUTCHR	[TAB]
	MOVE	FN			;PRINT FILE NAME
	GO	PNTSIX
	OUTCHR	[PERIOD]		;A PERIOD
	HLLZ	EXT			;THEN EXTENSION
	GO	PNTSIX
	OUTSTR	[CRLF]			;END THE LINE
	ENTER	CH4,FN			;ENTER FILE ONTO MAGTAPE
	CAI				;CAN'T FAIL
	GO	RD1			;READ FIRST WORD
	JRST	NULFIL			;EOF ON FIRST INPUT
	JRST	MKWRIT			;GO WRITE THIS WORD
MKTAPW:	GO	RD1			;READ A WORD
	JRST	MKCLOS			;ENTIRE FILE READ
MKWRIT:	GO	WRT4			;WRITE ONTO MAGTAPE
	JRST	MKTAPW			;GET NEXT CHARACTER
MKCLOS:	CLOSE	CH4,			;CLOSE OUTPUT FILE ON MAGTAP
	MOVE	SAVFF			;RESTORE START FIRST FREE
	MOVEM	.JBFF			;ADDRESS
	JRST	MKTAPE			;START NEXT FILE

MKEND:	MTREW.	CH4,			;REWIND THE MAGTAP
	GO	COCLR			;CLEAR CONTROL O
	PRINT	<MAGTAPE COMPLETED
	>
	JRST	COMM			;END OF MAKE COMMAND
NULFIL:	GO	ERRNAM			;PRINT ERROR FILE NAME
	PRINT	<FILE CONTAINS NO DATA, CAN'T WRITE ON MAGTAPE
>
	JRST	COMM

NOMCOD:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? NEITHER MAGTAP.RDI OR DXMPA.A8 WERE FOUND.
AT LEAST ONE MUST BE ON DISK.
>
	JRST COMM

ERRNAM:	PUT	0			;PRINT ERROR FILE NAME
	GO	COCLR			;CLEAR CONTROL O
	OUTCHR	[QMARK]
	OUTCHR	[SPACE]
	MOVE	FN			;PRINT FILE NAME
	GO	PNTSIX
	OUTCHR	[PERIOD]		;A PERIOD
	HLLZ	EXT			;THEN EXTENSION
	GO	PNTSIX
	PRINT	< - >
	GET	0
	RTN

INCOMP:	MOVE	SIZ			;GET WORD COUNT FROM EXTENDED LOOKUP
	IDIVI	^D128			;DIVIDE BY BLOCK SIZE
	JUMPE	1,.+2			;ANY REMAINDER ?
	ADDI	0,1			;YES, ROUND UP
	MOVEM	INCNT#
	RTN

HEDMSG:	ASCIZ	"

  #  TYPE  FILE   EXT   VER     DATE     SIZE

"
;*WRSIZE, WRITE FILES SIZE INTO .DIR FILE

WRSIZE:	MOVEI	SPACE
	GO	WRCHAR

	SKIPN	INCNT			;ANY FILE SIZE ?
	JRST	WRSIZ2			;NO

	SETZM	DIGCNT
	MOVEI	A,SPACE
	MOVEM	A,LDCHAR

	HRRZ	INCNT
	IDIVI	^D1000
	GO	OUTDIG			;PRINT 1000 DIGIT

	MOVE	A
	IDIVI	^D100
	GO	OUTDIG			;PRINT 100 DIGIT

	MOVE	A
	IDIVI	^D10
	GO	OUTDIG			;PRINT 10 DIGIT

	MOVEI	"0"(A)
	GO	WRCHAR			;PRINT 1 DIGIT

	MOVEI	SPACE
WRSIZ1:	GO	WRCHAR
	GO	WRCHAR
	RTN

WRSIZ2:	GO	WRCHAR
	GO	WRCHAR
	GO	WRCHAR
	GO	WRCHAR
	JRST	WRSIZ1
SUBTTL	UTILITY COMMANDS

;*REWIND, REWIND COMMAND

REWIND:	SKIPN	MAGDEV			;SKIP IF A MAGTAPE ASSIGNED
	JRST	BADCMF			;NO, GET OUT
	MTREW.	CH4,			;REWIND THE TAPE
	SETZM	DIRFLG#			;CLEAR DIRECTORY FLAG
	JRST	BADCMF			;GO FOR NEXT COMMAND


;*UNLOAD, UNLOAD COMMAND

UNLOAD:	SKIPE	MAGDEV			;CHECK IF A MAGTAPE ASSIGNED
	MTUNL.	CH4,			;REWIND AND UNLOAD THE TAPE

;*EXIT, EXIT COMMAND

LEAVE:	RESET				;RESET ALL DEVICES
	CAIN	A,LF			;CHECK IF END OF LINE INPUT
	JRST	LEAVN			;YES, GO ON
	GO	INWORD			;INPUT REST OF LINE
	JRST	.-3
LEAVN:	EXIT	1,			;EXIT PROGRAM
	JRST	START			;START OVER IF CONTINUED

;*OPTION, OPTION COMMAND

OPTION:	SETZ	C,			;CLEAR OPTION NAME
	CAIN	A,LF			;LINE FEED INPUT?
	JRST	OPTRD			;YES, GO READ SWITCH.INI FILE
	GO	INWORD			;READ NEXT WORD OF INPUT
	MOVEM	C			;SAVE OPTION NAME
OPTFSH:	CAIN	A,LF			;LINE FEED INPUT?
	JRST	OPTRD			;YES, GO READ FILE
	GO	INWORD			;NO, KEEP READING UNTIL FIND ONE
	JRST	OPTFSH
OPTRD:	GO	RDSWIT			;READ THE SWITCH.INI FILE
	PRINT	<? OPTION LINE NOT FOUND
>
	JRST	COMM			;GO GET COMMAND

SRCH:	GO	SETSRC			;READ SEARCH LIST FROM TTY
	JRST	COMM			;GO GET NEXT COMMAND

TAPEIN:	CAIN	A,LF			;CHECK IF END OF LINE
	JRST	CMDERR			;YES, ERROR
	JRST	TAPEI			;GO BACK TO MAGTAPE NAME INPUT ROUTINE
SUBTTL	DIRECTORY COMMANDS

;*DIRECT, DIRECTORY AND FDIRECTORY COMMANDS

DIRECT:	SETZM	FASTDR#			;CLEAR FAST DIRECTORY FLAG
	JRST	DIR

FDIR:	SETOM	FASTDR			;SET FAST DIRECTORY FLAG

DIR:	MOVSI	DEV,'TTY'		;SET UP DEFAULT DEVICE AS TTY
	CAIN	A,LF			;CHECK IF END OF COMMAND LINE
	JRST	DIRPOS			;YES, GO POSITION TAPE
	GO	INWORD			;NO, READ DEVICE NAME
	SKIPE				;SKIP IF NO DEVICE NAMED
	MOVEM	DEV			;SAVE DEVICE NAMED
DIRFCM:	CAIN	A,LF			;END OF LINE?
	JRST	DIRPOS			;YES
	GO	INWORD			;GET REST OF LINE
	JRST	DIRFCM
;*DIRPOS, SET UP TO READ DIRECTORY FILE

DIRPOS:	GO	GETDIR			;GET MAGTAPE DIRECTORY
	GO	MAGBUF			;SET UP MAGTAPE BUFFERS
	SETZB	PPN,STAT		;SET OUTPUT STATUS TO ASCII
	MOVSI	BUFFS,BUF3		;SET UP OUTPUT BUFFER ADR
	OPEN	CH3,STAT		;OPEN OUTPUT DEV
	JRST	OPENFG			;ERROR
	MOVE	FN,['MAGTAP']		;SET UP DIRECTORY NAME
	MOVSI	EXT,'DIR'		;  MAGTAP.DIR
	SETZB	DAT,SIZ			;CLEAR PPN AND DATE
	ENTER	CH3,FN			;ENTER FILE
	JRST	ENTRFG			;ERROR
	OUTBUF	CH3,			;SET UP BUFFERS
	LOOKUP	CH4,FN			;READ FILE FROM MAGTAPE
	JFCL				;CAN'T FAIL
	SKIPE	FASTDR			;CHECK IF FAST DIRECTORY REQUESTED
	JRST	FDIRWT			;YES, GO TO FAST PRINTER
	GO	FNDFIL			;FIND FILE ON MAGTAPE
	JRST	NODIR			;NO DIRECTORY FILE FOUND
	MOVEI	700			;CHANGE BYTE SIZE TO 7 BITS
	HRLM	BUF4+1			;FOR MAGTAPE READ BUFFER
DIRWRT:	GO	RD4			;READ A CHARACTER
	JRST	DIRDON			;EOF, ALL DONE
	GO	WRCHAR			;WRITE IT TO DEVICE
	JRST	DIRWRT			;KEEP WRITING
DIRDON:	CLOSE	CH4,			;CLOSE INPUT FILE
	AOS	POSIT			;INCREMENT POSITION OF TAPE
	JRST	COMM			;GET NEXT COMMAND

NODIR:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? CAN'T FIND MAGTAP.>
	HLLZ	EXT			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	PRINT	< ON MAGTAPE>
	JRST	COMM
;*FDIRWT, WRITE FILE NAME AND EXTENSION, 4 FILES PER LINE

FDIRWT:	MOVSI	EXT,'MTA'		;SET UP MTA EXTENSION
	GO	FNDFIL			;FIND FILE ON MAGTAPE
	JRST	NODIR			;CAN'T FIND IT
	SETZ	D,			;MAKE D POINT TO 0 FOR WRTFNX ROUTINE
DIRPNT:	GO	RD4			;READ FIRST WORD OF FILE
	JRST	DIRDON			;NO WORDS IN FILE
DIRLIN:	MOVEI	CR			;PRINT A CARRIAGE RETURN
	GO	WRCHAR
	MOVEI	LF			;PRINT A LINE FEED
	GO	WRCHAR
	MOVEI	C,4			;SET UP ENTRIES PER LINE COUNTER
DIRFLE:	GO	RD4			;READ FILE NAME
	JRST	DIRLST			;END OF FILE
	TLNN	770000			;CHECK IF A FILE NAME
	JRST	DIRREC			;NO, MUST BE END OF RECORD
	GO	WRTFNX			;PRINT THE NAME
	MOVEI	TAB			;PRINT A TAB
	GO	WRCHAR
	GO	RD4			;READ EXTENSION
	JRST	DIRLST			;END OF FILE
	HLLZ				;CLEAR RIGHT HALF
	GO	WRTFNX			;WRITE EXTENSION
	GO	RD4			;READ NEXT WORD
	JRST	DIRLST			;END OF FILE
	SOJLE	C,DIRLIN		;END OF LINE?
	MOVEI	TAB			;NO, PRINT A TAB
	GO	WRCHAR
	JRST	DIRFLE			;PRINT NEXT FILE NAME
DIRFLS:	GO	RD4			;READ TILL INPUT END OF FILE
	SKIPA				;GOT IT
	JRST	DIRFLS			;KEEP READING
DIRLST:	MOVEI	CR			;PRINT A CARRIAGE RETURN
	GO	WRCHAR
	MOVEI	LF			;PRINT A LINE FEED
	GO	WRCHAR
	JRST	DIRDON
DIRREC:	TLNE	-1			;ABSOLUTE END OF DIRECTORY FILE?
	JRST	DIRFLS			;YES
	GO	RD4			;NO, READ HEADER WORD FROM NEXT RECORD
	JRST	DIRLST			;END OF FILE
	JRST	DIRFLE			;PRINT THIS FILE NAME
SUBTTL	READ COMMANDS

;*CHEK, CHECK-VERIFY-GET COMMANDS

CHEK:	SETZ	B,			;CLEAR CHECK FLAG
	JRST	CHKCOM
VERIFY:	SKIPA	B,[-1]			;MAKE CHECK FLAG NEGATIVE
GETCOM:	MOVEI	B,-1			;MAKE CHECK FLAG POSITIVE

CHKCOM:	MOVEM	B,CHKFLG#		;SAVE CHECK CONTROL FLAG
	SETZM	GPNBR
	SETZM	TYPNBR
	SETOM	ALOWLD			;ALLOW WILD CHARACTERS

;*	INPUT REST OF COMMAND

	CAIN	A,"/"			;CHECH IF TERM A SLASH
	JRST	CHKLST			;YES, GET NULL LIST
	CAIN	A,LF			;CHECK IF TERM A LF
	JRST	CHKLST			;YES, GET NULL LIST
	GO	INWORD			;YES, GET NEXT WORD OF INPUT
	CAIN	A,"/"			;IF TERM NOW A SLASH
	JUMPN	CMDERR			;AND ONE WORD TYPED, ERROR
	CAIN	A,LF			;IF TERM NOW A LF
	JUMPN	CMDERR			;AND ONE WORD TYPED, ERROR
CHKLST:	GO	INLIST			;INPUT FILE LIST
	CAIN	A,"/"			;IS SLASH TERMINATOR ?
	GO	SWPROC			;YES, PROCESS SWITCH COMMAND
	HRRZM	B,LSTADR#		;SAVE ADDRESS OF LIST
	HLREM	B,LSTCNT#		;SAVE COUNT OF FILES
	MOVEI	CH1			;SET UP TO USE CHANNEL 1
	MOVEM	CHAN			;PUT IN CHAN FOR FIND ROUTINE
	MOVE	BUFFS,[BUF2,,BUF1]	;SET UP BUFFER ADDRESSES
	MOVEI	CNT,6			;SET UP CNT
	MOVEI	STAT,10			;SET DATA MODE TO IMAGE
;*	READ THE MAGTAPE DIRECTORY FILE

	GO	GETDIR			;GET THE DIRECTORY FILE INTO CORE
	GO	MAGBUF			;SET UP MAGTAPE BUFFERS
	MOVE	.JBFF			;SAVE FIRST FREE
	MOVEM	SAVFF

;*	SET UP FOR EXAMINING LIST OF FILES

	SKIPGE	LSTCNT			;SKIP IF CHECKING ALL FILES
	JRST	CHKWLD			;NO, GO GET FIRST ONE FROM LIST

	HRRZ	MAGDIR			;GET DIRECTORY ADDRESS
	AOJ				;INCREMENT BY 1
	MOVEM	LSTADR			;SAVE AS LIST ADDRESS
	SKIPN	GPNBR			;BOTH GROUP & TYPE 0 ?
	SKIPE	TYPNBR
	JRST	CHKNXT			;NO
	SKIPE	POSIT			;YES, REWIND TAPE
	MTREW.	CH4,
	SETZM	POSIT			;CLEAR POSITION

;*CHKNXT, CHECK EACH FILE NAME IN THE LIST

CHKNXT:	MOVE	FN,@LSTADR		;GET FILE NAME
	AOS	LSTADR			;INCREMENT ADDRESS
	HLLZ	EXT,@LSTADR		;GET EXTENSION

	SKIPN	GPNBR			;GROUP # 0 ?
	JRST	.+4			;YES, GET ALL
	LDB	[POINT 5,@LSTADR,24]	;GET .MTA FILE GROUP #
	CAME	GPNBR			;THIS FILE MATCH SELECTION ?
	JRST	CHKBYP			;NO, BYPASS

	SKIPN	TYPNBR			;GET /TYPE:ALL ?
	JRST	CHKOK			;YES

	PUT	A
	LDB	A,[POINT 2,@LSTADR,19]
	AOS	LSTADR			;GET .MTA FILE TYPE NUMBER
	LDB	[POINT 3,@LSTADR,20]
	MOVEM	TYPGET#
	DPB	A,[POINT 2,TYPGET,32]
	GET	A
	MOVE	TYPNBR			;GET /TYPE: NUMBER
	TDNN	TYPGET			;ANY CORR BITS SET IN .MTA FILE ?
	JRST	CHKBYP+1		;NO, BYPASS
	JRST	CHKOK+1
CHKOK:	AOS	LSTADR			;INCREMENT ADDRESS
	SKIPE	LSTCNT			;CHECKING ALL FILES ?
	JRST	.+5			;NO
	SKIPN	GPNBR			;BOTH GPNBR & TYPNBR ZERO ?
	SKIPE	TYPNBR
	JRST	CHKGPT			;NO
	JRST	CHKALL			;YES, GO AROUND
	GO	FNDFIL			;FIND THE FILE
	JRST	FNFNDM			;  NOT FOUND
	JRST	CHKLOK			;GO TO LOOKUP FILE
CHKGPT:	GO	FNDFIL			;FIND THE FILE
	JRST	FNFNDM			;   NOT FOUND
	AOS	LSTADR			;INCREMENT ADR TO NEXT ENTRY
	JRST	CHKLOK			;GO TO LOOKUP FILE
CHKALL:	SKIPN	LSTSW			;LIST FILES AS PROCESSED ?
	JRST	.+10			;NO
	OUTCHR	[TAB]
	MOVE	FN			;PRINT FILE NAME
	GO	PNTSIX
	OUTCHR	[PERIOD]
	HLLZ	EXT			;PRINT EXT
	GO	PNTSIX
	OUTSTR	[CRLF]
	AOS	A,LSTADR		;INCREMENT ADDRESS TO NEXT ENTRY
	SUBI	A,3			;MAKE A CONTAIN START OF DIRECTORY ENTRY

CHKLOK:	SETZM	CHKERR#			;CLEAR CHECK ERROR FLAG
	SETZM	VERERR#			;CLEAR VERIFY ERROR FLAG
	LOOKUP	CH4,FN			;LOOKUP FILE ON MAGTAPE
	JFCL				;CAN'T FAIL
	GO	CHKSET			;SET UP CHECK PARAMETERS
	SKIPL	CHKFLG			;SKIP IF VERIFYING
	JRST	CHKGET			;NO
	GO	FIND			;FIND FILE ON DISK
	JRST	FNFNDD			;ERROR, FILE NOT FOUND
	IN	CH1,			;SET UP BUFFERS
CHKGET:	SKIPG	CHKFLG			;SKIP IF GET COMMAND
	JRST	CHKDAT			;NO, GO CHECK DATA
;*	WRITE FILE TO DISK

	MOVSI	DEV,'DSK'		;SET DEVICE NAME TO DSK
	OPEN	CH2,STAT		;OPEN ON CHANNEL 2
	JRST	OPENFG			;ERROR
	SETZ	PPN,			;ZERO PPN
	LDB	[POINT 3,2(A),23]	;GET HIGH ORDER BITS OF DATE
	ROT	-3			;POSITION
	HLRM	EXT			;PUT TO RIGHT OF EXTENSION
	LDB	[POINT 12,2(A),35]	;GET REST OF DATE
	MOVEM	DAT			;PUT IN DATE WORD
	LDB	[POINT 11,1(A),35]	;GET CREATION TIME
	LSH	^D12			;POSITION
	ORM	DAT			;SET IN WITH DATE
	LDB	[POINT 9,2(A),8]	;GET EDIT NUMBER
	HRLZM	VER			;PUT IN LEFT OF VERSION WORD
	LDB	[POINT 9,2(A),17]	;GET VERSION NUMBER
	HRRM	VER			;PUT IN VERSION WORD
	ENTER	CH2,CNT			;ENTER FILE
	JRST	ENTRFG			;ERROR
CHKDAT:	GO	RD4X			;READ A WORD FROM MAGTAPE
	JRST	CHKEOF			;EOF
	GO	CHKWRD			;CHECK WORD
	SKIPL	CHKFLG			;SKIP IF VERIFYING
	JRST	CHKWGT			;NO
	MOVEM	A			;SAVE WORD
	GO	RD1			;READ A WORD FROM DISK
	JRST	CHDEOF			;EOF
	CAME	A			;COMPARE WORDS
	SETOM	VERERR			;SET VERIFY ERROR FLAG
CHKWGT:	SKIPLE	CHKFLG			;SKIP IF NOT GET COMMAND
	GO	WRT2			;WRITE WORD ONTO DISK
	JRST	CHKDAT			;GO BACK FOR NEXT WORD

CHDEOF:	GO	RD4X			;DISK EOF, READ TILL TAPE EOF
	JRST	CHKEOF+4		;EOF
	SKIPE				;IF TAPE ZERO FILLED, OK
	SETOM	VERERR			;OTHERWISE ERROR
	JRST	.-4
;*CHKEOF, CHECK THAT BOTH FILES TERMINATE TOGETHER

CHKEOF:	SKIPGE	CHKFLG			;SKIP IF NOT VERIFYING
	GO	RD1			;READ FROM DISK
	SKIPA				;EOF IS EXPECTED NOW
	GO	ERREOF			;NO EOF, VERIFY ERROR
	SKIPE	VERERR			;CHECK VERIFY ERROR FLAG
	GO	ERRCHK			;FILES ARE DIFFERENT

NEXTA:	AOS	POSIT			;INCREMENT POSITION OF TAPE
NEXTB:	CLOSE	CH4,			;CLOSE MAGTAPE FILE
	RELEASE	CH1,			;CLOSE INPUT FILE IF VERIFY
	RELEASE CH2,			;CLOSE OUTPUT FILE IN GET
	MOVE	SAVFF			;RESTORE FIRST FREE
	MOVEM	.JBFF			;ADDRESS
NEXT:	SKIPL	LSTCNT			;SKIP IF CHECKING FILES FROM LIST
	JRST	CHKNXA			;NO
	SKIPE	WILD			;WILD FILE PROCESS ?
	JRST	CHKWNX			;YES, DO ENTIRE .MTA FILE
	AOSL	LSTCNT			;INCREMENT FILE COUNT
	JRST	COMM			;EXIT, ALL FILES CHECKED
	JRST	CHKWLD			;GO CHECK NEXT FILE IN LIST

CHKNXA:	HLRZ	@LSTADR			;GET LEFT HALF OF NEXT WORD
	TRNE	770000			;CHECK IF A FILE NAME
	JRST	CHKNXT			;YES, GO CHECK IT
	JUMPN	COMM			;IF NOT ZERO, END OF TAPE
	MOVEI	2			;ANOTHER RECORD TO COME
	ADDM	LSTADR			;INCREMENT ADDRESS TO NEXT FILE NAME
	JRST	CHKNXT			;GO CHECK NEXT FILE

CHKBYP:	AOS	LSTADR			;POINT TO NEXT ENTRY
	AOS	LSTADR
	JRST	NEXT			;TRY NEXT FILE
CHKWLD:	MOVE	FN,@LSTADR		;GET REQUESTED FILE NAME
	AOS	LSTADR
	HLLZ	EXT,@LSTADR		;GET EXTENSION

	MOVE	A,[POINT 6,FN]
	MOVEI	B,^D9

	SETZM	WILD#
	ILDB	0,A			;CHECK NAME & EXT FOR WILD
	CAIN	0,'?'			;WILD CHAR ?
	SETOM	WILD			;YES, SET INDICATOR
	SOJG	B,.-3

	SKIPN	WILD			;WILD INDICATOR SET ?
	JRST	CHKNXT+3		;NO, SINGLE FILE PROCESS

	MOVE	A,MAGDIR		;START LOOKING AT FILE 0
	SUBI	A,2			;COMPENSATE FOR "FNDWLD"
	SETOM	WILDC
	MOVEM	A,WILDA

	MOVEM	FN,SAVFN#
	MOVEM	EXT,SAVEXT#

CHKWNX:	MOVE	FN,SAVFN		;GET BACK FILE NAME
	MOVE	EXT,SAVEXT

	GO	FNDWLD			;FIND THE FILE
	JRST	NEXT+4			;SCANNED ENTIRE LIST

	JRST	CHKLOK			;GO LOOKUP & PROCESS FILE
;*FNDWLD, FIND THE FILE SPECIFIED IN THE .MTA DIRECTORY
;*	DOES PROCESSING FOR WILD FILE NAMES
;*	RETURNS +1 WHEN COMPLETE
;*	RETURNS +2 AFTER TAPE IN POSITION

FNDWLD:	PUT	0
	PUT	B
	PUT	C

	MOVE	C,WILDC#		;GET SAVED POINTERS
	MOVE	A,WILDA#
	JRST	FNDWL2

FNDWL1:	GO	FILWLD			;COMPARE FILE NAMES
	JRST	FNDWL2			;NO MATCH

	MOVE	FN,(A)			;SETUP PROPER FILE NAME
	HLLZ	EXT,1(A)

	MOVEM	C,WILDC			;SAVE POINTERS
	MOVEM	A,WILDA

	JRST	FOUND			;GO POSITION TO FILE

FNDWL2:	ADDI	A,3			;INCREASE ADDRESS OVER ENTRY
	HLRZ	(A)			;GET LEFT HALF OF NEXT WORD
	TRNE	770000			;CHECK IF A FILE NAME
	AOJA	C,FNDWL1		;YES, INCREMENT COUNT & GO TO IT
	JUMPN	FNDWL3			;IF END OF DIRECTORY, RETURN
	ADDI	A,2
	AOJA	C,FNDWL1

FNDWL3:	GET	C
	GET	B
	GET	0
	RTN				;SCANNED ENTIRE DIR, DONE
;*FILWLD, FILE NAME WILD CHARACTER COMPARE
;*	CHECKS REQUESTED AND .MTA FILE NAMES CHAR BY CHAR
;*	WILD CHAR "?" ALWAYS MATCHES
;*	RETURN +1 FOR NO MATCH
;*	RETURN +2 IF FILE NAMES MATCH

FILWLD:	PUT	A
	PUT	B
	PUT	C
	PUT	D
	PUT	DAT
	PUT	SIZ

	SKIPN	GPNBR			;GROUP # 0 ?
	JRST	.+4			;YES, ALL
	LDB	[POINT 5,1(A),24]	;GET .MTA FILE GROUP #
	CAME	GPNBR			;THIS MATCH SELECTION ?
	JRST	FILWL3			;NO, BYPASS

	SKIPN	TYPNBR			;GET /TYPE:ALL ?
	JRST	FILWL1			;YES

	LDB	B,[POINT 2,1(A),19]
	LDB	0,[POINT 3,2(A),20]
	MOVEM	TYPGET			;GET .MTA FILE TYPE NUMBER
	DPB	B,[POINT 2,TYPGET,32]
	MOVE	TYPNBR			;GET /TYPE:NUMBER
	TDNN	TYPGET			;ANY CORR BITS SET IN .MTA FILE ?
	JRST	FILWL3			;NO, BYPASS

FILWL1:	MOVE	DAT,(A)			;SETUP .MTA FILE NAME
	HLLZ	SIZ,1(A)

	MOVE	C,[POINT 6,FN]
	MOVE	D,[POINT 6,DAT]
	MOVEI	B,^D9			;COMPARE 9 CHARS

FILWL2:	ILDB	0,C			;GET CHAR FROM NAME REQUESTED
	ILDB	A,D			;GET CHAR FROM .MTA FILE NAME
	CAIN	0,'?'			;REQ CHAR A WILD CHAR ?
	JRST	.+3			;YES, MAKE A MATCH
	CAME	0,A			;ARE BOTH CHARS THE SAME ?
	JRST	FILWL3			;NO, DOES NOT MATCH
	SOJG	B,FILWL2		;SO FAR OK, DO ALL 9 CHARS

	AOS	-6(P)			;MATCH, SKIP RETURN

FILWL3:	GET	SIZ
	GET	DAT
	GET	D
	GET	C
	GET	B
	GET	A
	RTN
FNFNDM:	GO	ERRNAM
	PRINT	<FILE NOT FOUND ON MAGTAPE
>
	JRST	NEXT			;GO TO NEXT FILE

FNFNDD:	GO	ERRNAM
	PRINT	<FILE NOT FOUND ON DISK, CAN'T VERIFY
>
	SKIPGE	LSTCNT			;SKIP IF VERIFYING ENTIRE TAPE
	JRST	NEXTB			;NO, GO TO NEXT FILE
	MTSKF.	CH4,			;SKIP OVER FILE
	JRST	NEXTA			;GO TO NEXT FILE

ERREOF:	GO	ERRNAM
	PRINT	<FILES ARE DIFFERENT LENGTH
>
	RTN

ERRCHK:	GO	ERRNAM
	PRINT	<FILES ARE DIFFERENT
>
	RTN
;*CHKSET, SET UP TO CHECK INTERNAL CHECKSUM OF FILE

CHKSET:	MOVEI	B,177777		;SET UP MASK BITS FOR
	HLRZ	EXT			;  ASSEMBLED WORD
	CAIE	'A10'			;CHECK IF AN A10
	CAIN	'A11'			;  OR A11 FILE
	JRST	CHKA			;YES
	CAIE	'RAM'			;CHECK IF A RAM
	CAIN	'TIC'			;OR TIC FILE
	JRST	CHKA			;YES
	CAIE	'A8 '			;18 BIT WORDS EXCEPT
	JRST	CHKN			;NO, NOT AN ASCII FILE, DON'T CHECK
	LSH	B,-4			;IF A8 FILE, THEN 12 BIT WORDS
CHKA:	MOVEM	B,CHKMSK#		;SAVE MASK
	MOVEI	B,CHR1			;SET UP TO EXPECT
	RTN				;  CHARACTER #1

;*CHKWRD, COME HERE TO CHECK EACH WORD OF FILE

CHKWRD:	SKIPE	CHKERR			;CHECK IF ANY ERROR SO FAR
	RTN				;YES, DON'T DO ANY MORE CHECKING
	MOVSI	A,(POINT 7)		;GET BYTE POINTER TO WORD
CHKNX:	ILDB	C,A			;GET A CHARACTER
	JUMPE	C,CHKNC			;IF ZERO, GO TO NEXT CHARACTER
	CAIE	C,LF			;IF LINE FEED, GO TO NEXT CHARACTER
	JRST	@B			;GO TO EXPECTING ROUTINE
CHKNC:	TLNN	A,700000		;LOOK IF 5 CHARACTERS ALREADY CHECKED
	RTN				;YES, RETURN FOR NEXT WORD
	JRST	CHKNX			;NO, GO CHECK NEXT CHARACTER

CHR1:	SETZM	CHKSM#			;CLEAR CHECKSUM WORD
	CAIL	C,"0"			;CHECK IF CHARACTER BETWEEN
	CAILE	C,"Z"			;  0 AND Z
	JRST	CHKE2			;NO, ERROR
	MOVEI	B,CHR2			;SET UP TO EXPECT SECOND CHARACTER
	CAIN	C,SCOLON		;UNLESS CHARACTER IS A SEMI-COLON
	MOVEI	B,CHROD			;THEN IGNORE THE ENTIRE LINE
	JRST	CHKNC			;  OF LINE
CHKE1:	GO	ERRNAM
	PRINT	<ILLEGAL CHARACTER CODE IN FILE ">
CHKEC:	PUT	0			;SAVE 0
	MOVE	C			;GET CHARACTER
	GO	PNTOCT			;PRINT CHARACTER CODE
	PRINT	<">			;END THE QUOTATION
	GET	0			;RESTORE 0
CHKE:	OUTSTR	[CRLF]			;END THE LINE
CHKN:	SETOM	CHKERR			;SET ERROR FLAG
	RTN				;IGNORE REST OF FILE

CHKE2:	GO	ERRNAM
	PRINT	<ILLEGAL FIRST CHARACTER IN LINE OF FILE ">
	JRST	CHKEC			;PRINT CHARACTER CODE
;*CHR2, CHECK FOR SPACE OR "O" IN SECOND CHARACTER POSITION

CHR2:	SETZ	D,			;CLEAR CHARACTER ASSEMBLY WORD
	MOVEI	B,CHRAD			;SET UP FOR ASCII DATA
	CAIN	C,SPACE			;CHECK IF A SPACE
	JRST	CHKNC			;YES, GO GET NEXT CHARACTER
	MOVEI	B,CHROD			;SET UP FOR OCTAL DATA
	CAIN	C,"O"			;CHECK IF O
	JRST	CHKNC			;YES, GO GET NEXT CHARACTER
	GO	ERRNAM
	PRINT	<ILLEGAL SECOND CHARACTER IN LINE OF FILE ">
	JRST	CHKEC			;PRINT CHARACTER CODE

CHRAD:	CAIE	C,COMMA			;CHECK IF A COMMA
	JRST	CHRA1			;NO
	AND	D,CHKMSK		;FULL WORD IN D, STRIP
	ADDM	D,CHKSM			;ADD TO CHECKSUM
	SETZ	D,			;CLEAR ASSEMBLED WORD
	JRST	CHKNC			;GO GET NEXT CHARACTER

CHRA1:	CAIE	C,CR			;CHECK IF A CARRIAGE RETURN
	JRST	CHRA2			;NO
	MOVEI	B,CHR1			;SET UP TO EXPECT NEW LINE
	AND	D,CHKMSK		;STRIP CHECKSUM WORD
	ADD	D,CHKSM			;ADD TO CHECKSUM COMPUTED
	TDNN	D,CHKMSK		;CHECK IF SUM IS ZERO
	JRST	CHKNC			;GO TO NEXT CHARACTER IF ZERO SUM
	GO	ERRNAM
	PRINT	<CHECKSUM ERROR IN FILE>
	JRST	CHKE			;SET ERROR FLAG
CHRA2:	CAIL	C,"5"			;5 TO : ?
	CAILE	C,":"
	JRST	.+6

	SUBI	C,"5"			;YES, INSERT SUPPRESSED ONES
	LSH	D,6
	TRO	D,77
	SOJG	C,.-2
	JRST	CHKNC

	CAIL	C,"0"			;0 TO 4 ?
	CAILE	C,"4"
	JRST	CHRA3			;NO

	ANDI	C,7			;YES, INSERT SUPPRESSED ZEROS
	LSH	D,6
	SOJGE	C,.-1
	JRST	CHKNC

CHRA3:	CAIL	C,75			;CHECK IF CHARACTER BETWEEN
	CAILE	C,174			;  75 AND 174
	JRST	CHKE1			;NO, ERROR

	ANDI	C,77			;STRIP TO 6 BITS
	LSH	D,6			;MAKE ROOM FOR BITS
	ORM	C,D			;MERGE IN THE NEW BITS
	JRST	CHKNC			;GET NEXT CHARACTER

CHROD:	CAIN	C,CR			;WAIT FOR CARRAIGE RETURN
	MOVEI	B,CHR1			;YES, SET UP FOR NEW LINE
	JRST	CHKNC			;GET NEXT CHARACTER
SUBTTL	NUMBER COMMAND

;*NUMBER, NUMBER COMMAND

NUMBER:	SETOM	NEWVER			;SET NEW VERSION AND DATE
	SETOM	NEWDAT			;  STORAGE TO INVALID DATA
	CAIN	A,LF			;END OF LINE?
	JRST	CMDERR			;YES, ERROR
	GO	INWORD			;READ FILE NAME
	CAIE	A,PERIOD		;TERM WITH PERIOD
	JRST	CMDERR			;  ERROR
	JUMPE	CMDERR			;ERROR IF NO FILE NAMED
	MOVEM	FN			;SAVE FILE NAME
	GO	INWORD			;GET EXT
	CAIN	A,LF			;END OF LINE?
	JRST	CMDERR			;YES, ERROR
	HLLZM	EXT			;SAVE EXT
	CAIN	A,PERIOD		;CAN'T TERM WITH PERIOD
	JRST	CMDERR			;ERROR
	GO	INWORD			;GET EDIT NUMBER OR DATE
NUMARG:	CAIE	A,PERIOD		;TERM WITH PERIOD?
	JRST	NUMDAT			;NO, CHECK IF DASH
	SKIPN	NOTNUM			;CHECK IF NUMBER WAS TYPED
	TRNE	-1			;CHECK IF NO MORE THAN 3 DIGITS
	JRST	CMDERR			;TOO LARGE
	GO	CNVNUM			;CONVERT TO NUMBER
	HRLZM	NEWVER#			;SAVE EDIT NUMBER
	GO	INNUM			;INPUT VERSION NUMBER
	CAILE	777			;CHECK RANGE
	JRST	CMDERR			;TOO LARGE
	HRRM	NEWVER			;STORE VERSION NUMBER
NUMFLS:	CAIN	A,LF			;END OF LINE YET?
	JRST	NUMFND			;YES, GO AROUND
	GO	INWORD			;INPUT NEXT WORD
	JUMPN	NUMARG			;JUMP IF ANYTHING TYPED
	CAIE	A,LF			;CHECK IF END OF LINE
	JRST	CMDERR			;NO, ERROR
NUMFND:	MOVEI	CH1			;SET UP CHAN
	MOVEM	CHAN			;  FOR CHANNEL 1
	GO	FIND			;FIND FILE
	JRST	NOTFND			;NOT FOUND
	SKIPL	NEWVER			;SKIP IF NO VERSION TYPED
	MOVE	VER,NEWVER		;GET NEW VERSION
	SKIPGE	A,NEWDAT		;SKIP IF A DATE WAS TYPED
	JRST	NUMREN			;NO, GO AROUND
	DPB	A,[POINT 12,DAT,35]	;DEPOSIT LOW BITS OF NEW DATE
	LSH	A,-^D12			;SHIFT OUT LOW ORDER BITS
	DPB	A,[POINT 3,EXT,20]	;DEPOSIT HIGH ORDER BITS
NUMREN:	RENAME	CH1,CNT			;RENAME THE FILE
	PRINT	<? RENAME ERROR>
	JRST	COMM
;*	A DATE IS SPECIFIED IN COMMAND

NUMDAT:	CAIE	A,DASH			;TERM A DASH?
	JRST	CMDERR			;NO, ERROR
	SKIPN	NOTNUM			;CHECK IF NUMBER
	TLNE	77			;  OF NO MORE THAN 2 DIGITS
	JRST	CMDERR			;NO
	GO	CNVDEC			;CONVERT TO NUMBER
	CAIG	^D31			;CHECK RANGE
	SOSGE	C,0			;SAVE DATE, LESS 1
	JRST	CMDERR			;DATE NOT LEGAL
	GO	INWORD			;INPUT ANOTHER WORD
	CAIE	A,DASH			;TERMINATOR BETTER BE A DASH
	JRST	CMDERR			;NO, ERROR
	MOVE	B,DATTBP		;GET ADR OF MONTH TABLE
	GO	COMPARE			;COMPARE INPUT WITH TABLE
	JRST	CMDERR			;ERROR
	GO	INWORD			;READ NEXT WORD
	TLNE	77			;MAKE SURE NUMBER IS ONLY 2 DIGITS
	JRST	CMDERR			;ERROR
	PUT	A			;SAVE A
	GO	CNVDEC			;CONVERT TO NUMBER
	SUBI	^D64			;SUBTRACT START DATE OF 64
	SKIPGE				;NEGATIVE RESULT?
	ADDI	^D100			;YES, MAKE POSITIVE
	IMULI	^D12			;MULTIPLY BY 12
	ADDM	B			;ADD TO MONTH
	IMULI	B,^D31			;MULITPLY BY 31
	ADD	B,C			;ADD DAYS
	MOVEM	B,NEWDAT#		;SAVE NEW DATE
	GET	A			;RESTORE A
	JRST	NUMFLS			;CONTINUE TO READ ARGUMENTS
SUBTTL	DIRECTORY READ

;*GETDIR, READ DIRECTORY FILE FROM MAGTAPE

GETDIR:	SKIPN	MAGDEV			;SKIP IF A MAGTAGE DEVICE AVAILABLE
	JRST	IMPOSB			;IMPOSSIBLE WITH NO MAGTAPE
	SKIPE	DIRFLG			;SKIP IF DIRECTORY NOT IN CORE
	RTN				;ALREADY IN CORE, RETURN NOW
	MOVE	A,MAGINT		;GET INITIAL STATUS BITS
	SETSTS	CH4,7(A)		;SET MODE TO DUMP
	MTREW.	CH4,			;REWIND THE MAGTAPE
	MOVEI	3			;SPACE FORWARD
	MTSKF.	CH4,			;  TO MAGTAP.MTA
	SOJG	.-1			;  THREE FILES FORWARD
	SETZ	C,			;CLEAR FILE COUNT
	MOVE	A,.JBFF			;GET FIRST FREE ADDRESS
	MOVEM	A,MAGDIR#		;SAVE AS START OF DIRECTORY
	SOJ	A,			;GET ADDRESS -1 FOR IO WORD
GETDRR:	MOVEI	D,1(A)			;GET START OF DATA BUFFER
	ADDI	D,RCDSIZ		;ADD SIZE OF RECORD
	GO	INCORE			;CHECK IF CORE AVAILABLE
	MOVEM	D,.JBFF			;INCREASE FIRST FREE
	HRLI	A,-RCDSIZ		;BUILD IO WORD
	SETZ	B,			;CLEAR LOCATION AFTER IO WORD
	IN	CH4,A			;READ A RECORD
	SKIPA
	JRST	DIRRDE			;DIRECTORY READ ERROR
	MOVE	D,1(A)			;GET HEADER WORD
	CAIE	C,(D)			;CHECK IF EXPECTED FILE NUMBER
	JRST	DIRHDE			;NO, HEADER ERROR
;*	CHECK INTERNAL CHECKSUM OF EACH DIRECTORY RECORD

	ADDI	A,2			;INCREASE BUFFER ADDRESS TO FIRST ENTRY
GETDRA:	ADD	D,(A)			;ADD THE THREE WORDS FROM
	ADD	D,1(A)			;  THE CURRENT FILE ENTRY
	ADD	D,2(A)			;  TO CHECKSUM
	ADDI	A,3			;INCREASE ADDRESS TO NEXT ENTRY
	HLRZ	(A)			;GET LEFT HALF OF NEXT WORD
	TRNE	770000			;CHECK IF A FILE NAME
	AOJA	C,GETDRA		;YES, INCREMENT FILE COUNT AND ADD IT IN
	HLRZ	B,D			;NO, GET LEFT OF COMPUTED CHECKSUM
	ADDI	B,(D)			;ADD RIGHT HALF TO IT
	HRRZ	D,(A)			;GET RIGHT HALF OF CHECKSUM WORD FROM RECORD
	CAIE	D,(B)			;SKIP IF THEY MATCH
	JRST	DIRHDC			;NO, CHECKSUM ERROR
	SKIPN				;SKIP IF LAST RECORD OF DIRECTORY FILE
	AOJA	C,GETDRR		;NO, INCREMENT FILE COUNT AND READ AGAIN
	CLOSE	CH4,			;CLOSE THE MAGTAPE FILE
	AOJ	A,			;INCREMENT ADDRESS TO AFTER CHECKSUM WORD
	HRRZM	A,.JBFF			;PUT THIS ADDRESS IN JOB FIRST FREE
	HRRZM	A,MAGDRE		;SAVE END OF DIRECTORY
	SETSTS	CH4,@MAGINT		;SET STATUS BACK TO IMAGE MODE
	MTSKF.	CH4,			;MOVE TAPE OVER FILE MARK
	MOVEI	4			;SET CURRENT TAPE POSITION
	MOVEM	POSIT#			;TO FILE NUMBER 4
	SETOM	DIRFLG			;SET DIRECTORY IN CORE FLAG
	RTN				;RETURN
;*	DIRECTORY READ ERROR MESSAGES

DIRRDE:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? READ ERROR >
	GETSTS	CH4,			;READ FILE STATUS
	GO	PNTOCT			;PRINT STATUS
	PRINT	< FROM MAGTAPE FILE MAGTAP.MTA>
	JRST	COMM

DIRHDE:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? HEADER WORD INCORRECT IN MAGTAPE FILE MAGTAP.MTA>
	JRST	COMM

DIRHDC:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? CHECKSUM ERROR IN MAGTAPE FILE MAGTAP.MTA>
	JRST	COMM

IMPOSB:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? IMPOSSIBLE WITH NO MAGTAPE DEVICE SELECTED
>
	JRST	STARTA			;GO ASK FOR MAGTAPE DEVICE AGAIN
;*FNDFIL, FIND THE FILE SPECIFIED IN FN AND EXT IN THE MAGTAPE DIRECTORY
;*	THEN POSITION THE TAPE TO THE FILE
;*	RETURN +1 IF NO FILE FOUND OF SPECIFIED NAME
;*	RETURN +2 AFTER TAPE IS IN POSITION AND ADDRESS OF
;*		DIRECTORY ENTRY IN A

FNDFIL:	PUT	0			;SAVE ACS
	PUT	B
	PUT	C
	SETZ	C,			;START LOOKING AT FILE 0
	MOVE	A,MAGDIR		;GET ADDRESS OF DIRECTORY INFO
	AOJ	A,			;INCREMENT ADDRESS OVER HEADER
FNDFLE:	CAME	FN,(A)			;COMPARE FILE NAMES
	JRST	FNDFLN			;NO MATCH
	HLLZ	1(A)			;GET EXTENSION
	XOR	EXT			;EXCLUSIVE OR WITH EXT
	TLNN	-1			;SKIP IF NO MATCH
	JRST	FOUND			;FOUND IT, GO POSITION TO FILE
FNDFLN:	ADDI	A,3			;INCREASE ADDRESS OVER ENTRY
	HLRZ	(A)			;GET LEFT HALF OF NEXT WORD
	TRNE	770000			;CHECK IF A FILE NAME
	AOJA	C,FNDFLE		;YES, INCREMENT FILE COUNT AND GO TO IT
	JUMPN	FNDNFF			;IF END OF DIRECTORY, RETURN NOW
	ADDI	A,2			;INCREMENT ADDRESS TO NEXT FILE NAME
	AOJA	C,FNDFLE
FNDNFF:	GET	C			;RESTORE ACS
	GET	B
	GET	0
	RTN
;*FOUND, FILE FOUND IN MAGTAPE DIRECTORY
;*	MOVE TAPE TO BEGINNING OF THE FILE

FOUND:	SKIPN	LSTSW			;LIST FILE AS PROCESSED ?
	JRST	.+10			;NO
	OUTCHR	[TAB]			;PRINT A TAB
	MOVE	FN			;GET FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	MOVE	EXT			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	OUTSTR	[CRLF]			;END THE LINE

POS:	EXCH	C,POSIT			;PUT FILE NUMBER IN POSITION
	SKIPE	POSIT			;POSIT = WHERE TO BE, C = PRESENT POSITION
	JRST	POSTAP			;NO, POSITION TAPE AWAY FROM BOT
	MTREW.	CH4,			;GOING TO POSITION 0, REWIND
	JRST	FNDFLX			;  AND EXIT

;*	COMPUTE DIRECTION AND NUMBER OF FILES TO MOVE TAPE

POSTAP:	MOVE	B,C			;SAVE PRESENT POSITION
	SUB	C,POSIT			;COMPUTE NUMBER OF FILES TO MOVE
	JUMPE	C,FNDFLX		;EXIT NOW IF IN POSITION
	JUMPG	C,POSBAK		;JUMP IF MOVING BACKWARD
	MTSKF.	CH4,			;SKIP FORWARD TO FILE
	AOJL	C,.-1			;COUNT THE FILES
	JRST	FNDFLX			;IN POSITION, EXIT NOW

;*	MOVE TAPE BACKWARDS

POSBAK:	LSH	B,-1			;HALVE PRESENT POSITION
	CAMLE	B,POSIT			;IS WHERE TO BE LT 1/2 PRESENT POS ?
	JRST	POSRWD			;YES, REWIND THEN SPACE FORWARD
	MTBSF.	CH4,			;SKIP BACKWARD TO FILE
	SOJGE	C,.-1			;COUNT THE FILES
	MTSKF.	CH4,			;MOVE FORWARD OVER THE FILE MARK

FNDFLX:	GET	C			;RESTORE ACS
	GET	B
	GET	0
	AOS	(P)			;CAUSE SUCCESSFUL RETURN
	RTN				;EXIT

;*	BACKWARDS POSITION L.T. 1/2 PRESENT POSITION
;*	REWIND THEN SPACE FORWARD TO FILE

POSRWD:	MTREW.	CH4,			;REWIND
	SETZM	C			;PRESENT POSITION NOW 0
	JRST	POS+1			;NOW SKIP FORWARD TO FILE
SUBTTL	SUBROUTINES

;*FIND, FIND SUBROUTINE
;*	LOOKUP FILENAME AND EXTENSION IN ALL DISK AREAS SPECIFIED BY
;*	SEARCH SWITCH.  RETURN +2 WHEN FOUND.  RETURN +1
;*	IF NOT FOUND

FIND:	MOVE	C,[OPEN STAT]		;GET OPEN UUO
	MOVE	D,[LOOKUP CNT]		;GET LOOKUP UUO
	MOVE	A,CHAN			;GET CHANNEL NUMBER
	DPB	A,[POINT 4,C,12]	;PUT CHANNEL NUMBER IN OPEN UUO
	DPB	A,[POINT 4,D,12]	;PUT CHANNEL NUMBER IN LOOKUP UUO
	MOVEI	A,SCHLST		;SET UP POINTER TO DISK AREAS
FINDD:	SKIPN	(A)			;SKIP IF A DEVICE TO INIT
	JRST	FINDNO			;FILE NOT FOUND
	MOVE	DEV,(A)			;GET DEVICE NAME
	XCT	C			;OPEN THE DEVICE
	JRST	NODEV			;DEVICE NOT AVAILABLE

FINDF:	MOVE	PPN,1(A)		;GET PPN
	XCT	D			;LOOKUP THE FILE
	SKIPA				;ERROR RETURN
	JRST	CPOPJ1			;FILE FOUND, RETURN +2
FINDN:	ADDI	A,2			;UPDATE POINTER TO SCHLST
	JRST	FINDD			;FOR LOOKUP ON NEXT AREA

NODEV:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? OPEN FAILURE ON DEVICE >
	MOVE	DEV			;GET DEVICE NAME
	GO	PNTSIX			;PRINT IT
	OUTSTR	[CRLF]			;END THE LINE
	SETZ	DEV,			;CLEAR DEV
	JRST	FINDN			;KEEP LOOKING

FINDNO:	CAME	FN,INFILN		;CHECK IF INPUT FILE NAME
	RTN				;NO, GIVE ERROR RETURN
	HLLZ	A,EXT			;GET EXTENSION
	XOR	A,INFILE		;COMPARE WITH INPUT EXTENSION
	TLNE	A,-1			;SKIP IF A MATCH
	RTN				;NO, GIVE ERROR RETURN
	MOVE	DEV,INDEVN		;GET DEVICE OF INPUT FILE
	XCT	C			;OPEN THE DEVICE
	RTN				;ERROR
	MOVE	PPN,INFILP		;GET P,PN OF INPUT FILE
	XCT	D			;LOOKUP THE FILE
	RTN				;ERROR
	JRST	CPOPJ1			;SUCCESSFUL RETURN
;*COMPARE, COMPARE WORD IN 0 WITH ENTRIES IN TABLE SPECIFIED BY B
;*	NORMAL RETURN +2 WITH INDEX OF MATCH IN B
;*	ERROR	RETURN +1

COMPARE:JUMPE	CPOPJ			;ERROR IF NO WORD IN 0
	HRRZM	B,TABADR#		;SAVE TABLE ADDRESS
	MOVEM	A,SVTRM#		;SAVE INPUT TERMINATOR
	MOVEM	D,SAVD#
	MOVEI	A,77			;SET UP MASK
COMPM:	TDNE	A			;SKIP IF ALL MASKED BITS ARE ZERO
	JRST	COMPMK			;GO, COMPLETE MASK
	LSH	A,6			;SHIFT MASK BITS LEFT
	TRO	A,77			;SET FIRST 6 AGAIN
	JRST	COMPM			;GO CHECK MASK AGAIN
COMPMK:	LSH	A,-6			;SHIFT OUT LAST 6 BITS
	SETCAM	A,COMPMS#		;COMPLIMENT MASK BITS, SAVE IT
	SETZ	D,			;CLEAR MATCH COUNTER
COMPST:	MOVE	A,(B)			;GET A WORD FROM TABLE
	AND	A,COMPMS		;STRIP UNTYPED POSITIONS
	CAMN	A,0			;COMPARE
	GO	COMSET			;MATCH!
	AOBJN	B,COMPST		;SET UP FOR COMPARE OF NEXT WORD
	CAIE	D,1			;MORE THAN 1 MATCH OR
	JRST	COMPX			;NOT FOUND ?
COMPMT:	MOVE	B,SAVB			;GET MATCH POINTER
	HRRZS	B			;CLEAR COUNT OF TABLE ENTRIES
	SUB	B,TABADR		;SUBTRACT ADR TO GET INDEX
	AOS	(P)			;RETURN +2
COMPX:	MOVE	A,SVTRM			;RESTORE TERMINATOR
	MOVE	D,SAVD
	RTN

COMSET:	MOVEM	B,SAVB#			;SAVE MATCH POINTER
	AOS	D			;COUNT MATCH
	RTN
;*RDNAME, READ A FILE NAME FROM THE INPUT FILE

RDNAME:	SKIPE	CHAR			;SKIP IF AT START OF LINE
	JRST	RDON			;READ NEXT CHARACTER
	GO	RDCHAR			;READ A CHARACTER
	RTN				;EOF
	CAILE	SPACE			;PRINTABLE CHARACTER?
	CAIN	SCOLON			;AND NOT A SEMI-COLON
	JRST	RDONW			;READ NEXT CHAR AFTER WRITING THIS ONE
	CAIN	"/"			;SLASH SWITCH COMMAND ?
	JRST	SWINP			;YES, PROCESS

	SETZB	FN,TYPNBR
	CAIL	"0"			;IS TYPE GIVEN ?
	CAILE	"7"
	JRST	.+2			;NO

	GO	RDTYPE			;YES, PROCESS TYPE NUMBER

	SETZB	FN,EXT			;CLEAR FILE NAME AND EXT
	MOVE	D,[POINT 6,FN]		;GET BYTE POINTER TO FN
	MOVEI	C,6			;SET COUNT TO 6

RDFILN:	CAIN	PERIOD			;CHARACTER A PERIOD?
	JRST	RDDOT			;YES
	SOJL	C,FILERR		;DECREMENT COUNT
	CAIG	"_"			;CHECK IF LOWER CASE
	TRC	40			;CONVERT TO SIXBIT
	IDPB	D			;DEPOSIT CHARACTER
	GO	RDCHAR			;READ NEXT CHARACTER
	JRST	FILERR			;EOF IN FILE NAME
	CAIG	SPACE			;PRINTABLE CHARACTER?
	JRST	FILERR			;NO, ERROR IN FILE NAME
	JRST	RDFILN			;YES, CONTINUE WITH FILE NAME

RDDOT:	JUMPE	FN,FILERR		;ERROR IF ZERO FILE NAME
	MOVE	D,[POINT 6,EXT]		;GET BYTE POINTER TO EXT
	MOVEI	C,3			;SET COUNT TO 3
;*RDEXT, READ THE EXTENSION

RDEXT:	GO	RDCHAR			;READ NEXT CHARACTER
	JRST	RDCHRX			;EOF, RETURN +2
	CAIG	SPACE			;PRINTABLE CHARACTER?
	JRST	RDCHRX			;NO RETURN +2
	SOJL	C,RDCHRX		;DECREMENT COUNT.
	CAIG	"_"			;CHECK IF LOWER CASE
	TRC	40			;CONVERT TO SIXBIT
	IDPB	D			;DEPOSIT CHARACTER
	JRST	RDEXT			;GET NEXT CHARACTER
RDCHRX:
CPOPJ1:	AOS	(P)			;RETURN +2 WITH FILE NAME IN FN
CPOPJ:	RTN				;AND EXTENSION IN EXT

RDON:	GO	RDCHAR			;READ NEXT CHARACTER
	RTN				;EOF
RDONW:	SKIPE	WRDIR			;SKIP IF NOT WRITING DIRECTORY
	GO	WRCHAR			;WRITE CHARACTER IN DIRECTORY FILE
	JRST	RDNAME			;RETURN TO START OF ROUTINE
;*RDTYPE, READ TYPE FROM INPUT FILE

RDTYPE:	CAIE	TAB
	CAIN	SPACE
	JRST	RDTYP1			;TYPE TERMINATOR

	CAIL	"0"
	CAILE	"7"
	JRST	FILERR			;TYPE ERROR

	LSH	FN,3
	ANDI	7
	ORM	FN			;INSERT THIS DIGIT IN TYPE NUMBER

	GO	RDCHAR			;GET NEXT CHAR
	JRST	FILERR			;EOF, ERROR
	JRST	RDTYPE

RDTYP1:	CAIL	FN,37			;TYPE IS 0 TO 37
	JRST	FILERR			;NO, ERROR
	MOVEM	FN,TYPNBR		;SAVE TYPE NUMBER
	GO	RDCHAR			;READ CHAR PAST TERM
	JRST	FILERR			;EOF, ERROR
	RTN
;*	INPUT FILE ERRORS

SWIERR:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? SWITCH ERROR IN >
	MOVEM	0,FN
	JRST	.+3

FILERR:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? IMPROPER FORMAT OF FILE NAME IN >
	MOVE	INFILN			;PRINT FILE NAME
	GO	PNTSIX
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	INFILE			;PRINT EXTENSION
	GO	PNTSIX
	OUTCHR	[TAB]			;PRINT TAB

	SKIPN	PAGE			;SKIP IF NOT PAGE 1
	JRST	FILERL			;GO PRINT LINE NUMBER
	PRINT	<PAGE >			;PRINT PAGE NUMBER
	AOS	PAGE
	MOVE	PAGE
	GO	PNTDEC

FILERL:	PRINT	< LINE >		;PRINT LINE NUMBER
	AOS	LINE
	MOVE	LINE
	GO	PNTDEC
	OUTSTR	[CRLF]			;END LINE
	MOVE	FN
	GO	PNTSIX			;PRINT LINE ALREADY INPUT
FILERP:	OUTCHR				;PRINT LAST CHARACTER
	CAIN	LF			;LINE FEED PRINTED?
	JRST	COMM			;YES, GET OUT NOW
	GO	RDCHAR			;READ NEXT CHARACTER
	JRST	COMM			;EOF
	JRST	FILERP			;PRINT REST OF LINE
;*	INPUT FILE READ ERROR MESSAGES

INFILR:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? END OF FILE WHILE READING >
	MOVE	INFILN			;GET FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	EXT			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	PRINT	< AFTER >
	MOVEI	1(A)			;GET NUMBER
	GO	PNTDEC			;PRINT IT
	PRINT	< FILE NAMES WERE READ.
A MINIMUM OF SEVEN FILE NAMES ARE REQUIRED>
	JRST	COMM

INFILM:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? ERROR IN INPUT FILE >
	MOVE	INFILN			;GET FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	INFILE			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	PRINT	<
FILE NUMBER >
	MOVE	A			;GET NUMBER
	GO	PNTDEC			;PRINT IT
	PRINT	< MUST BE >
	CAIN	A,4			;CHECK IF FILE 4
	MOVEI	B,INFILN		;YES, POINT TO INFILN
	MOVE	(B)			;GET FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	1(B)			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	PRINT	< BUT IS >
	MOVE	FN			;GET ACTUAL FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	EXT			;GET ACTUAL EXTENSION
	GO	PNTSIX			;PRINT IT
	OUTSTR	[CRLF]			;END LINE
	JRST 	COMM
;*INLIST, INPUT A LIST OF FILE.EXT AND PLACE IN MEMORY
;*	STARTING AT C(.JBFF)
;*	RETURN -FILE COUNT,, ADR IN B

INLIST:	MOVE	B,.JBFF			;GET FIRST FREE LOCATION
INLSTS:	CAIN	A,"/"			;SLASH ?
	JRST	.+3			;YES, END OF LIST
	CAIE	A,LF			;LINE FEED?
	JRST	INLSTD			;NO, MAYBE A DOT
	PUT	A
	MOVE	A,B			;GET START ADR
	SUB	A,.JBFF			;SUBTRACT ENDING ADR
	ASH	A,-1			;DIVIDE BY 2 FOR COUNT OF FILES
	HRL	B,A			;BUILD POINTER IN B
	GET	A
	RTN				;EXIT

INLSTD:	CAIE	A,PERIOD		;PERIOD?
	JRST	CMDERR			;ERROR
	JUMPE	CMDERR			;ERROR IF NO NAME TYPED
	MOVEI	D,2			;INCREMENT .JBFF BY 2
	ADDB	D,.JBFF			;GET VALUE IN D
	GO	INCORE			;INCREASE CORE
	MOVEM	-2(D)			;STORE FILE NAME
	GO	INWORD			;INPUT ANOTHER WORD
	HLLZM	-1(D)			;STORE EXTENSION
INLSTC:	CAIN	A,PERIOD		;MAKE SURE NOT ANOTHER PERIOD
	JRST	CMDERR			;ERROR
	CAIE	A,COMMA			;IF COMMA,
	CAIN	A,SPACE			;SPACE
	SKIPA				;
	CAIN	A,TAB			;OR TAB
	GO	INWORD			;INPUT NEXT WORD
	JRST	INLSTS			;NOW LOOK AT TERM

;*INCORE, INCREASE CORE ASSIGNED TO JOB TO ENABLE REFERENCE
;*	TO ADDRESS IN D

INCORE:	CAMG	D,.JBREL
	RTN
	PUT	D			;SAVE D
	CORE	D,			;CALL CORE UUO
	JRST	INCORX			;ERROR RETURN
	GET	D			;RESTORE D
	RTN
INCORX:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? NOT ENOUGH CORE AVAILABLE>
	JRST	COMM
;*RDDXMC, READ THE DX10 MICRO-CODE FILE

RDDXMC:	MOVE	D,.JBFF			;GET FIRST FREE ADR
	ADDI	D,10K/3+1		;COMPUTE SIZE OF BLOCK
	GO	INCORE			;INCREASE CORE TO INCLUDE BLOCK
	HRLZ	C,.JBFF			;BUILD BLT POINTER
	HRR	C,.JBFF			;TO STORAGE BLOCK
	MOVE	[BYTE(12)7402,7402,7402]	;LOAD STORAGE AREA
	MOVEM	(C)			;WITH HLT INSTRUCTIONS
	AOJ	C,			;COMPLETE POINTER
	BLT	C,(D)			;FILL THE AREA
MCADR:	GO	WCTIN			;GO READ THE WORD COUNT
	JUMPE	A,ENDLOD		;END OF FILE
	MOVEM	A,D			;SAVE COUNT
	GO	WRDIN			;READ THE ADDRESS
	IDIVI	A,3			;GET ADDRESS OF STORAGE WORD
	ADD	A,.JBFF			;ADD TABLE OF ADDRESS
	MOVEM	A,PNTR#			;SAVE AS POINTER ADR
	IMULI	B,^D12			;COMPUTE BYTE POSITION
	MOVEI	A,^D36			;FROM REMAINDER
	SUB	A,B			;IN FIRST
	LSH	A,^D12			;POSITION NUMBER
	ORI	A,^D12_6		;BYTE SIZE
	HRLM	A,PNTR			;COMPLETE POINTER
MCDATA:	GO	WRDIN			;GET DATA WORD
	IDPB	A,PNTR			;DEPOSIT BYTE INTO TABLE
	SOJG	D,MCDATA		;GET ALL THE WORDS
	GO	CHKIN			;READ AND CHECK THE CHECKSUM
	JRST	MCADR			;GO READ ANOTHER ADDRESS
ENDLOD:	RTN				;ALL DONE

;*WCTIN, READ THE BEGINNING OF THE LINE FROM THE FILE

WCTIN:	GO	RD1			;READ A CHARACTER
	JRST	MCERR			;FILE ERROR
	CAIE	"8"			;FIRST CHARACTER SHOULD BE AN 8
	JRST	MCERR1			;NO, MAYBE A COMMENT
	GO	RD1			;READ ANOTHER CHARACTER
	JRST	MCERR			;ERROR
	MOVEI	A,77			;SET UP CHARACTER MASK
	MOVEI	B,6			;SET UP CHARACTER SHIFT COUNT
	CAIN	SPACE			;CHECK FOR SPACE
	JRST	WCTWC			;GO ON TO READ WC
	CAIE	"O"			;CHECK IF AN O
	JRST	MCERR			;UNKNOWN CHARACTER
	MOVEI	A,7			;MAKE CHARACTER MASK A 7
	MOVEI	B,3			;SHIFT ONLY 3 CHARACTERS
WCTWC:	MOVEM	A,CMASK#		;STORE AWAY CHARACTER MASK
	MOVEM	B,CSIZE#		;STORE AWAY SHIFT COUNT
	SETZM	CHECK#			;CLEAR CHECKSUM

;*WRDIN, READ AN ENTRY FROM THE FILE, TERMINATE ON A COMMA

WRDIN:	SETZ	A,			;CLEAR NUM
	GO	RD1			;READ A CHARACTER
	JRST	MCERR			;ERROR
	CAIN	COMMA			;CHECK IF COMA
	JRST	WRDCK			;YES CHECK NUMBER
	LSH	A,@CSIZE		;SHIFT NUMBER
	AND	CMASK			;CLEAR UNWANTED BITS
	OR	A,			;MERGE TOGETHER
	JRST	WRDIN+1			;READ NEXT
WRDCK:	CAILE	A,7777			;CHECK IF A LEGAL ENTRY
	JRST	MCERR			;ERROR
	ADDM	A,CHECK			;UPDATE CHECKSUM
	RTN

;*CHKIN, READ THE CHECKSUM FROM THE FILE AND THE CR-LF
;*	CHECK THAT CHECKSUM IS CORRECT

CHKIN:	SETZ	A,			;CLEAR A
	GO	RD1			;READ A CHARACTER
	JRST	MCERR			;ERROR
	CAIN	CR			;CHECK IF CR
	JRST	CHKSUM			;CHECKSUM IS IN A
	CAIN	COMMA			;CHECK IF NOT A COMMA
	JRST	MCERR			;NO END OF LINE HERE
	LSH	A,@CSIZE		;SHIFT NUMBER
	AND	CMASK			;CLEAR UNWANTED BITS
	OR	A,			;MERGE TOGETHER
	JRST	CHKIN+1			;READ NEXT CHARACTER
CHKSUM:	ADD	A,CHECK			;ADD COMPUTED CHECKSUM
	ANDI	A,7777			;STRIP TO 12 BITS
	MOVE	CSIZE			;GET CHARACTER SIZE
	CAIE	3			;SKIP IF OCTAL CHARACTERS
	JUMPN	A,MCERR			;ERROR IN CHECKSUM
	GO	RD1			;READ LF
	JRST	MCERR			;ERROR
	RTN				;RETURN
MCERR:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? FORMAT OR CHECKSUM ERROR READING DXMPA.A8>
	JRST	COMM

MCERR1:	CAIE	SCOLON			;CHECK IF A COMMENT LINE
	JRST	MCERR			;NO, ERROR
MCERRC:	GO	RD1			;YES, INPUT ENTIRE LINE
	JRST	MCERR			;  AND IGNORE ALL CHARACTERS IN IT
	CAIE	LF			;WAIT FOR A LINE FEED
	JRST	MCERRC			;NOT YET, GET NEXT CHARACTER
	JRST	WCTIN			;GO INPUT NEXT LINE
;*MAGBUF, SET UP MAGTAPE BUFFERS FOR CHANNEL 4

MAGBUF:	MOVE	A,.JBFF			;GET FIRST FREE ADDRESS
	ADD	A,[1B0+1]		;SET USE BIT
	MOVEM	A,BUF4			;PUT IN HEADER
	ADDI	A,1			;INCREASE ADR AGAIN
	HRLI	A,4400			;SET IN BYTE COUNT
	MOVEM	A,BUF4+1		;STORE BYTE POINTER
	SETZM	BUF4+2			;CLEAR BYTE COUNT
	MOVE	D,.JBFF			;GET FIRST FREE AGAIN
	ADDI	D,NUMBUF*<RCDSIZ+3>	;ADD BUFFER AREA SPACE
	GO	INCORE			;NO, INCREASE CORE
	EXCH	D,.JBFF			;UPDATE FIRST FREE AND GET OLD VALUE
	AOS	A,D			;INCREASE BY ONE
	HRLI	A,RCDSIZ+1		;PUT SIZE IN LEFT HALF
	MOVEI	B,NUMBUF-1		;GET NUMBER OF BUFFERS
MAGBFL:	ADDI	A,RCDSIZ+3		;POINT TO NEXT BUFFER
	MOVEM	A,-<RCDSIZ+3>(A)	;STORE IN THIS BUFFER
	SOJG	B,MAGBFL		;LOOP ON ALL BUFFERS
	HRLI	D,RCDSIZ+1		;PUT SIZE TO LEFT OF FIRST BUFFER ADR
	MOVEM	D,(A)			;STORE IN LAST BUFFER
	RTN				;RETURN
;*INWORD, INPUT A WORD FROM DEVICE USING INPUT INSTRUCTION IN INWXCT
;*	PLACE WORD IN SIXBIT IN 0
;*	PLACE TERMNATER CHARACTER IN A
;*	TERMINATOR CHARACTERS ARE SPACE, TAB, COMMA, PERIOD, LF, ALTMODE,
;*				  LB, RB, COLON, ATSIGN, DASH, SLASH
;*	CARRIAGE RETURNS AND SUCCESSIVE SPACES, COMMAS AND TABS ARE IGNORED
;*	NOTNUM IS SET TO -1 IF ANYTHING OTHER THAN A NUMBER WAS INPUT

INWORD:	SETZB	NOTNUM#			;CLEAR 0 AND NOT NUMBER FLAG
	MOVE	A,[POINT 6,0]		;GET BYTE POINTER TO 0
	MOVEM	A,INWDP#		;SAVE IT
INWDNX:	XCT	INWXCT			;INPUT A CHARACTER
	CAILE	A,"_"			;CHECK IF LOWER CASE
	SUBI	A,40			;YES, CONVERT TO UPPER CASE
	CAIN	A,CR			;CHECK IF CARRIAGE RETURN
	JRST	INWDNX			;IGNORE IT
	CAIE	A,LF			;CHECK IF LINE FEED
	CAIN	A,COMMA			;OR COMMA
	RTN				;YES, RETURN
	CAIN	A,"/"			;CHECK IF SLASH
	RTN				;YES, RETURN
	CAIE	A,33			;CHECK IF ALT-MODE
	CAIN	A,COLON			;CHECK IF COLON
	RTN				;YES, RETURN NOW
	CAIE	A,LB			;CHECK IF A SQUARE BRACKET
	CAIN	A,RB			;LEFT OR RIGHT
	RTN				;RETURN
	CAIE	A,PERIOD		;CHECK IF PERIOD
	CAIN	A,"@"			;CHECK IF @
	RTN				;RETURN
	CAIE	A,DASH			;CHECK IF A DASH
	CAIN	A,0			;  OR EOF
	RTN				;  RETURN
	CAIE	A,SPACE			;CHECK IF SPACE
	CAIN	A,TAB			;OR TAB
	JRST	INWDSP			;YES, IT IS A SEPARATOR
	CAIN	A,"*"			;IS IT ASTERISK ?
	JRST	INAST			;YES, WILD FIELD
	CAIGE	A,40			;CHECK IF A SIXBIT CHARACTER
	JRST	INWDNX			;NO, IGNORE IT
	TRC	A,40			;MAKE IT SIXBIT
	CAIN	A,'?'			;IS IT QUESTION MARK ?
	GO	INQMRK			;YES, WILD CHARACTER
	TRNN	77			;SKIP IF INPUT WORD IS FULL
	IDPB	A,INWDP			;STORE CHARACTER
	CAIL	A,'0'			;CHECK IF A DIGIT
	CAILE	A,'9'			;  OR NOT
	SETOM	NOTNUM			;NO, SET NOT NUMBER FLAG
	JRST	INWDNX			;GO GET NEXT CHARACTER
INWDSP:	JUMPE	INWDNX			;IGNORE SEPARATOR IF NO WORD ASSEMBLED
	RTN				;RETURN IF WORD IS ASSEMBLED
INAST:	SKIPN	ALOWLD			;ALLOW WILD ?
	JRST	CMDERR			;NO, COMMAND ERROR

	MOVEI	A,'?'			;WILD FIELD, FILL REST WITH ?'S
	TRNE	77
	JRST	INWDSP-2		;FILLED, SET NOT NUMBER & SCAN FOR TERM
	IDPB	A,INWDP
	JRST	.-3

INQMRK:	SKIPN	ALOWLD			;ALLOW WILD ?
	JRST	CMDERR			;NO, COMMAND ERROR
	RTN

INWDEV:	MOVEM	A			;SAVE 0
	GO	RD1			;GET A CHARACTER FROM FILE
	SETZ				;EOF, SET CHARACTER TO ZERO
	EXCH	A			;PUT CHARACTER IN A
	RTN				;EXIT

;*	INPUT FROM .INP FILE

INWINP:	MOVEM	A			;SAVE 0
	GO	RDCHAR			;GET A CHAR FROM FILE
	SETZ				;EOF, SET CHAR TO ZERO
	EXCH	A			;PUT CHAR IN A
	RTN
;*INNUM, INPUT AN OCTAL NUMBER
;*	PLACE NUMBER IN 0, MAXIMUM OF SIX DIGITS
;*	PLACE FIRST NON-DIGIT CHARACTER OR SEVENTH DIGIT IN A

INNUM:	SETZ				;CLEAR 0
INNUMS:	XCT	INWXCT			;INPUT A CHARACTER
	CAIL	A,"0"			;CHECK IF AN OCTAL DIGIT
	CAILE	A,"7"			;
	RTN				;NO, RETURN WITH CHARACTER IN A
	TRNE	700000			;ANY ROOM FOR DIGIT?
	RTN				;NO, ONLY 6 ALLOWED
	ROT	A,-3			;ROTATE DIGIT TO LEFT
	LSHC	3			;SHIFT INTO 0
	JRST	INNUMS			;GO GET NEXT CHARACTER

;*PNTOCT, PRINT THE OCTAL NUMBER IN AC0

PNTOCT:	JUMPE	PNTZRO			;JUMP IF ZERO
	PUT	0			;SAVE TWO ACS
	PUT	A
	LSHC	-^D33			;SHIFT NUMBER INTO A
	TRO	A,7			;SET LOWER ORDER DIGIT TO ONES
	JUMPN	PNTOTC			;IF ZERO, FORCE A PRINT
	LSHC	3			;GET A DIGIT
	JUMPE	.-1			;IGNORE LEADING ZEROS
PNTOTC:	ADDI	"0"			;CONVERT TO ASC11 CODE
	OUTCHR				;PRINT THIE DIGIT
	SETZ				;CLEAR ZERO
	LSHC	3			;GET NEXT DIGIT
	JUMPN	A,PNTOTC		;PRINT THIS ONE
	GET	A			;RESTORE ACS
	GET	0
	RTN				;EXIT

PNTZRO:	OUTCHR	["0"]			;PRINT A ZERO
	RTN
;*PNTDEC, PRINT THE DECIMAL NUMBER IN AC0

PNTDEC:	PUT	0			;SAVE ACS
	PUT	B
	PUT	A
	SETZ	B,			;CLEAR DIGIT COUNTER
PNTDCD:	IDIVI	^D10			;DIVIDE BY 10
	JUMPE	PNTDCO			;GO OUTPUT IF ZERO QUOTIENT
	PUT	A			;SAVE DIGIT ON PUSH LIST
	AOJA	B,PNTDCD		;GO DIVIDE AGAIN
PNTDCO:	ADDI	A,"0"			;CONVERT TO ASCII
	OUTCHR	A			;PRINT DIGIT IN A
	GET	A			;GET NEXT DIGIT
	SOJGE	B,PNTDCO		;COUNT THE DIGITS TO PRINT
	GET	B			;RESTORE ACS
	GET	0
	RTN				;RETURN

;*PNTSIX, PRINT SIXBIT WORD IN 0

PNTSIX:	PUT 0				;SAVE ACS
	PUT A
	LSHC	-^D36			;SHIFT WORD INTO A
PNTSXC:	LSHC	6			;SHIF IN ONE CHARACTER
	ADDI	SPACE			;CONVERT TO ASCII
	OUTCHR				;PRINT IT
	SETZ				;CLEAR AC
	TLNE	A,770000		;SKIP IF NEXT CHARACTER IS BLANK
	JRST	PNTSXC			;NO, PRINT IT
PNTSXX:	GET	A			;RESTORE ACS
	GET 	0
	RTN				;EXIT
;*RDCHAR, INPUT A CHARACTER FROM FILE ON CHANNEL 0.
;*	UPDATE LOCATION PAGE, LINE AND CHAR TO SHOW POSITION OF NEXT CHARACTER
;*	TO BE INPUT.  RETURN +2 WITH CHARACTER IN 0.
;*	RETURN +1 IF EOF INPUT
;*	IF ERROR, REPORT IT AND EXIT TO COMM

RDCHAR:	SOSGE	BUF0+2			;DECREMENT THE BYTE COUNT
	JRST	GETBF0			;BUFFER EMPTY - GET ANOTHER ONE
	ILDB	BUF0+1			;GET A CHARACTER
	CAIN	CR			;CARRIAGE RETURN
	SETZM	CHAR			;CLEAR CHAR
	CAIE	LF			;LINE FEED  OR
	CAIN	VT			;VERTICAL TAB
	SKIPA
	JRST	RDCHRT			;NO
	SETZM	LINE			;CLEAR LINE
	SETZM	CHAR			;CLEAR CHAR
	AOS	PAGE			;INCREMENT PAGE
RDCHRT:	CAIE	TAB			;TAB
	JRST	RDCHRP			;NO
	EXCH	CHAR			;GET CHAR
	TRZ	7			;CLEAR LOW ORDER OCTAL DIGIT
	ADDI	10			;INCREMENT TO TAB STOP
	EXCH	CHAR			;RESTORE CHAR
RDCHRP:	CAIL	SPACE			;PRINTABLE CHARACTER
	AOS	CHAR			;INCREMENT CHAR
	AOS	(P)			;RETURN +2
	RTN

GETBF0:	IN				;GET NEW BUFFER
	JRST	RDCHAR			;NO ERRORS
	GETSTS				;GET ERROR STATUS
	TRNN	1B22			;SKIP IF EOF
	JRST	ERRBF0			;NO, ERROR
	SETZ	0			;CLEAR CHARACTER
	RTN				;RETURN +1

ERRBF0:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? READ ERROR >		;READ ERROR, REPORT IT
	GO	PNTOCT			;PRINT STATUS
	PRINT	< FILE - >		;PRINT FILE NAME
	MOVE	INFILN
	GO	PNTSIX
	OUTCHR	[PERIOD]
	HLLZ	INFILE			;AND EXTENSION
	GO	PNTSIX
	JRST	COMM
;*RD1, READ A CHARACTER INTO 0 FROM CHANNEL 1

RD1:	SOSGE	BUF1+2			;DECREMENT BYTE COUNT
	JRST	RDBUF1			;BUFFER EMPTY
	ILDB	BUF1+1			;GET A BYTE
	AOS	(P)
	RTN
RDBUF1:	IN	CH1,			;GET ANOTHER BUFFER
	JRST	RD1			;NOW GET CHARACTER
	GETSTS	CH1,			;GET ERROR STATUS
	TRNE	1B22			;CHECK IF EOF
	JRST	RDEOF			;YES
	GO	ERRNAM
	PRINT	<READ ERROR > 		;NO, PRINT ERROR
	GO	PNTOCT			;PRINT STATUS WORD
	JRST	COMM

RDEOF:	SETZ				;CLEAR 0
	RTN

;*RD4, READ A CHARACTER FROM MAGTAPE ON CHANNEL 4

RD4:	SOSGE	BUF4+2			;DECREMENT BYTE COUNT
	JRST	RDBUF4			;BUFFER EMPTY
	ILDB	BUF4+1			;GET A BYTE
	AOS	(P)			;CAUSE SKIP RETURN
	RTN				;RETURN

RDBUF4:	IN	CH4,			;GET ANOTHER BUFFER
	JRST	RD4			;NOW GET CHARACTER
	GETSTS	CH4,			;GET ERROR STATUS
	TRNE	1B22			;CHECK IF EOF
	JRST	RDEOF			;YES
	GO	ERRNAM
	PRINT	<MAGTAPE READ ERROR > 
	GO	PNTOCT			;PRINT STATUS WORD
	JRST	COMM
;*RD4X, READ A CHARACTER FROM MAGTAPE ON CHANNEL 4
;*	IF A READ ERROR OCCURS, REPORT & READ TAPE TILL EOF

RD4X:	SOSGE	BUF4+2			;DECREMENT BYTE COUNT
	JRST	RDBF4X			;BUFFER EMPTY
	ILDB	BUF4+1			;GET A BYTE
	AOS	(P)			;CAUSE SKIP RETURN
	RTN				;RETURN

RDBF4X:	IN	CH4,			;GET ANOTHER BUFFER
	JRST	RD4X			;NOW GET CHARACTER
	GETSTS	CH4,			;GET ERROR STATUS
	TRNE	1B22			;CHECK IF EOF
	JRST	RDEOF			;YES

	GO	ERRNAM
	PRINT	<MAGTAPE READ ERROR > 
	GO	PNTOCT			;PRINT STATUS WORD
	OUTSTR	[CRLF]

	IN	CH4,			;GET BUFFERS TILL EOF
	JRST	.-1
	GETSTS	CH4,
	TRNN	1B22
	JRST	.-4

	CLOSE	CH2,40			;EOF, CLOSE & THRO AWAY NEW FILE
	GET	0			;THRO AWAY SUBROUTINE RETURN
	JRST	NEXTA			;GO COMPLETE
;*WRT2, WRITE THE DATA FROM 0 ONTO FILE ON CHANNEL 2

WRT2:	SOSGE	BUF2+2			;DECREMENT BYTE COUNT
	JRST	WRTBF2			;BUFFER FULL, GET ANOTHER
	IDPB	BUF2+1			;DEPOSIT A CHARACTER
	RTN
WRTBF2:	OUT	CH2,			;WRITE THE BUFFER
	JRST	WRT2			;WRITE DATA NOW
	GETSTS	CH2,			;GET STATUS
	JRST	WRTERR

;*WRCHAR, WRITE A CHARACTER INTO DIRECTORY FILE ON CHANNEL 3

WRCHAR:	SOSGE	BUF3+2			;DECREMENT THE BYTE COUNT
	JRST	GETBF3			;BUFFER FULL - GET ANOTHER
	IDPB	BUF3+1			;DEPOSIT A CHARACTER
	RTN
GETBF3:	OUT	CH3,			;WRITE THIS BUFFER
	JRST	WRCHAR			;TRY AGAIN
	GETSTS	CH3,			;GET STATUS
WRTERR:	GO	ERRNAM
	PRINT	<WRITE ERROR > 		;REPORT ERROR
	GO	PNTOCT			;PRINT STATUS
	JRST	COMM			;GET OUT NOW

;*WRT4, WRITE THE DATA FROM 0 ONTO MAGTAPE ON CHANNEL 4

WRT4:	SOSGE	BUF4+2			;DECREMENT THE BYTE COUNT
	JRST	WRTBF4			;BUFFER FULL - GET ANOTHER
	IDPB	BUF4+1			;DEPOSIT A CHARACTER
	RTN				;RETURN
WRTBF4:	OUT	CH4,			;WRITE THIS BUFFER
	JRST	WRT4			;TRY AGAIN
	GETSTS	CH4,			;GET ERROR STATUS
	CLOSE	CH4,			;CLOSE MAGTAPE CHANNEL
	JRST	WRTERR
;*OUTDIG, OUTPUT THE DIGIT IN AC0. CONVERT TO SPACE IF LEADING ZERO

OUTDIG:	SKIPN	DIGCNT			;SKIP IF NUMBER ALREADY PRINTED
	JUMPE	OUTLDC			;OUTPUT LDCHAR IF DIGIT IS ZERO
	ADDI	"0"			;CONVERT TO ASCII CODE
	AOS	DIGCNT			;COUNT THE DIGIT
OUTLCH:	GO	WRCHAR			;WRITE IT
	RTN

OUTLDC:	MOVE	LDCHAR#			;GET LEADING CHARACTER
	JUMPN	OUTLCH			;OUTPUT IT IF NOT ZERO
	RTN				;ZERO CHARACTER, RETURN NOW

;*OUTWRD, OUTPUT SIXBIT WORD IN 0. CHARACTER COUNT IS IN A.

OUTWRD:	MOVEM	A,DIGCNT		;SAVE COUNT
	LSHC	-^D30			;GET FIRST CHARACTER
OUTWDC:	ADDI	SPACE			;CONVERT TO ASCII
	GO	WRCHAR			;WRITE CHARACTER
	SOSG	DIGCNT			;COUNT THE CHARACTER
	RTN				;ALL WERE PRINTED
	SETZ				;CLEAR ZERO
	LSHC	6			;GET NEXT CHARACTER
	JRST	OUTWDC			;WRITE THIS ONE
;*RDSWIT, READ SWITCH.INI FILE TO INPUT SEARCH LIST

RDSWIT:	SETZB	STAT,PPN		;CLEAR STATUS AND PPN, SELECTING ASCII MODE
	MOVSI	DEV,'DSK'		;GET DEVICE NAME
	MOVEI	BUFFS,BUF1		;INPUT BUFFER IS BUF1
	MOVEI	CNT,6			;SET COUNT TO 6
	MOVE	FN,['SWITCH']		;PREPARE TO READ FILE
	MOVSI	EXT,'INI'		;  SWITCH.INI
	OPEN	CH1,STAT		;OPEN CHANNEL 1 ON DSK
	RTN				;ERROR
	LOOKUP	CH1,CNT			;LOOPUP FILE SWITCH.INI
NOSWIT:	RTN				;NOT FOUND
	IN	CH1,			;SET UP BUFFERS
	MOVE	[GO INWDEV]		;SET UP INPUT COMMAND
	MOVEM	INWXCT			;PUT IN WORD EXECUTED BY INWORD
	MOVE	B,['MAGTAP']		;GET NAME OF THIS PROGRAM
RDLINE:	GO	INWORD			;INPUT A WORD
	JUMPE	A,NOSWIT		;EXIT IF END OF FILE
	CAIN	A,LF			;LINE FEED?
	JRST	RDLINE			;YES, READ NEXT LINE
	CAMN	B			;CHECK IF WORD IS MAGTAP
	JRST	RDOPT			;YES, LOOK AT OPTION
RDEND:	GO	INWORD			;READ NEXT WORD
RDENDA:CAIN	A,LF			;INPUT REST OF LINE
	JRST	RDLINE			;LINE FEED FOUND, READ NEXT LINE
	JUMPN	A,RDEND			;IF NOT END OF FILE, KEEP READING
	RTN				;EOF, RETURN

RDOPT:	JUMPE	C,NOOPT			;JUMP IF NO OPTION SPECIFIED
	CAIE	A,COLON			;CHECK IF COLON INPUT
	JRST	RDENDA			;NO, THIS LINE HAS NO OPTION NAME
	GO	INWORD			;READ OPTION NAME
	CAME	C			;MATCH WITH NAME SPECIFIED
	JRST	RDENDA			;NO, THIS IS NOT OPTION LINE WANTED
	JRST	LINFND			;YES, GO SET UP SEARCH LIST

NOOPT:	CAIE	A,SPACE			;TERMINATOR A SPACE
	CAIN	A,TAB			;  OR TAB?
	SKIPA				;YES
	JRST	RDENDA			;NO, NOT THIS LINE
LINFND:	AOS	(P)			;FROM HERE, CAUSE RETURN +2
;*SETSRC, SET UP SEARCH LIST

SETSRC:	MOVEI	B,SCHLST		;GET SEARCH LIST ADR
	MOVEI	C,^D20			;GET LIMIT AT 20 ENTRIES

SETSCH:	MOVSI	'DSK'			;SET UP DEFAULT DSK
	MOVEM	(B)			;  AND USERS PPN IN
	SETZM	1(B)			;  SEARCH LIST
	SETZM	2(B)			;  THEN END OF LIST
SETSNX:	JUMPE	A,SETEND		;EOF, RETURN
	CAIN	A,LF			;END OF LINE?
	JRST	SETEND			;YES, RETURN
	GO	INWORD			;READ A WORD
	SKIPE				;ANY STRUCTURE INPUT?
	MOVEM	(B)			;YES, SAVE IN LIST
	CAIE	A,COLON			;IF A COLON
	JRST	SETPPN			;NO, GO LOOK FOR PPN
	JUMPE	NULDEV			;ERROR IF NULL DEVICE
	JRST	SETSNX			;GO FOR NEXT WORD
SETPPN:	CAIE	A,LB			;CHECK IF A LEFT BRACKET
	JRST	SETCOM			;NO
	GO	INNUM			;INPUT PROJECT NUMBER
	CAIE	A,COMMA			;TERMINATOR A COMMA?
	JRST	SETERP			;ERROR, IMPROPER PPN
	HRLM	1(B)			;STORE IT
	GO	INNUM			;INPUT PROGRAMMER NUMBER
	HRRM	1(B)			;STORE IT
	CAIN	A,RB			;TERMINATOR A RIGHT BRACKET?
	JRST	SETSNX			;YES, KEEP READING
	JRST	SETERP			;NO, ERROR, IMPROPER PPN

SETCOM:	CAIE	A,COMMA			;CHECK IF COMMA INPUT
	JRST	SETSNX			;NO, KEEP READING
	ADDI	B,2			;INCREMENT ADDRESS BY 2
	SOJG	C,SETSCH		;KEEP READING
	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? TOO MANY DISK AREAS SPECIFIED, MAXIMUM OF 20 ALLOWED
>
SETTMY:	CAIN	A,LF			;CHECK IF LINE FEED INPUT
	JRST	SETERR			;YES, REPLACE ENTRY WITH DSK AND USERS PPN
	GO	INWORD			;INPUT ANOTHER WORD
	JRST	SETTMY			;LOOK FOR LF AGAIN
;*	SEARCH LIST ARGUMENT ERROR MESSAGES

SETERP:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? IMPROPER [P,PN] SPECIFICATION
>
	JRST	SETERR

SETEND:	ADDI	B,2			;INCREMENT ADDRESS BY 2
SETERR:	MOVSI	'DSK'			;SET UP DSK
	MOVEM	(B)			;  AND USER'S PPN
	SETZM	1(B)			;  AT END OF LIST
	SETZM	2(B)			;END THE LIST
	RTN

NULDEV:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? NULL DEVICE NAME IN SEARCH LIST
>
	JRST	SETERR
;*GETVER, OBTAIN AND WRITE VERSION NUMBER OF FILE.
;*	ALSO PLACE IN LH OF DATE WORD
;*	IF IN NORMAL FORMAT.

GETVER:	HLRZ	EXT			;GET EXTENSION
	CAIN	'SAV'			;IS IT SAV?
	GO	SAVVER			;YES
	CAIE	'A10'			;CHECK IF AN ASCIIZED FILE
	CAIN	'A11'			;A10, A11, OR A8
	JRST	ASCVER			;YES, A10 OR A11
	CAIN	'A8 '
	JRST	ASCVER			;YES, A8
	CAIE	'RAM'			;CHECK IF RAM OR TIC
	CAIN	'TIC'
	JRST	ASCVER			;YES, RAM OR TIC
GETVRA:	JUMPE	VER,ZROVER		;IS VERSION ZERO?
	LDB	[POINT 9,VER,17]	;GET EDIT NUMBER
	DPB	[POINT 9,DAT,8]		;PUT IN DATE WORD
	GO	OUTNUM			;WRITE NUMBER
	MOVEI	PERIOD			;WRITE A PERIOD
	GO	WRCHAR
	LDB	[POINT 9,VER,35]	;GET VERSION NUMBER
	DPB	[POINT 9,DAT,17]	;PUT IN DATE WORD
	SETZM	LDCHAR			;CLEAR LEADING CHARACTER FOR OUTDIG
	SETZM	DIGCNT			;CLEAR DIGIT COUNTER
	GO	OUTNUM			;WRITE THE NUMBER
	MOVEI	A,4			;GET CHARACTER COUNT OF 4
	SUB	A,DIGCNT		;SUBTRACT DIGITS PRINTED
	JRST	VERE			;GO TO WRITE SPACE AFTER VERSION
ZROVER:	HRLI	DAT,0			;CLEAR VERSION IN DATE WORD
	MOVEI	A,8			;SET SPACE COUNT TO 8
VERE:	SETZ				;CLEAR ZERO TO TYPE SPACES ONLY
	GO	OUTWRD			;WRITE THE SPACES
	RTN			
;*ASCVER, READ FIRST LINE OF ASCII FILE AND EXTRACT VERSION AND DATE

ASCVER:	PUT	.JBFF			;SAVE JOB FIRST FREE
	SETZM	VERPNT#			;CLEAR VERSION PRINTED FLAG
	INBUF	CH1,1			;SET UP BUFFERS
	GO	RD1			;READ FIRST CHARACTER
	JRST	ASCEND			;ERROR
	CAIE	SCOLON			;CHECK IF A SEMI-COLON
	JRST	ASCEND			;NO
	GO	INWORD			;READ A WORD FROM FILE
	CAIE	A,PERIOD		;CHECK IF A PERIOD TERMINATOR
	JRST	ASCEND			;ERROR
	GO	INWORD			;READ NEXT WORD
	CAIE	A,TAB			;CHECK IF A TAB TERMINATOR
	CAIN	A,SPACE			;CHECK IF A SPACE TERMINATOR
	JRST	.+2			;YES, SPACE OR TAB
	JRST	ASCEND			;ERROR
	GO 	INWORD			;READ NEXT WORD
	CAME	[SIXBIT 'VER']		;CHECK IF THE WORD 'VER'
	JRST	ASCEND			;ERROR
	GO	INWORD			;READ NEXT WORD
	SKIPN	NOTNUM			;NUMBER INPUT AND
	CAIE	A,PERIOD		;  TERMINATOR A PERIOD?
	JRST	VERUNK			;NO, UNKNOWN VERSION TYPE
	MOVEM	VER			;PUT EDIT NUMBER IN VER
	GO	INWORD			;READ NEXT WORD
	SKIPN	NOTNUM			;SKIP IF A NUMBER WAS NOT INPUT
	JRST	ASCVRA			;YES
	MOVE	VER			;GET FIRST WORD BACK
	JRST	VERUNK			;VERSION IN UNKNOWN FORMAT
ASCVRA:	TDNN	[101010101010]		;CHECK IF EITHER NUMBER
	TDNE	VER,[101010101010]	;IS DECIMAL
	JRST	VERDEC			;YES, TREAT IT SPECIAL
	GO	CNVNUM			;CONVERT VERSION TO NUMBER
	EXCH	VER			;PUT IN VER, GET EDIT
	GO	CNVNUM			;CONVERT EDIT TO NUMBER
	HRLM	VER			;PUT IN VER
	JRST	ASCDAT			;GO ON TO READ DATE
;*VERDEC, SET UP VERSION AND DATE FROM FILE

VERDEC:	EXCH	VER			;GET BACK EDIT NUMBER
	SKIPA
	LSH	6			;GET THE THREE
	TRNE	-1			;LEAST SIGNIFICANT BITS
	JRST	.-2			;IN LEFT HALF OF AC
	SKIPA				;RIGHT JUSITFY
	LSH	-6			;NUMBER
	TLNN	77			;IN LEFT HALF
	JRST	.-2			;OF AC
	MOVEI	A,3			;SET CHARACTER COUNT TO 3
	GO	OUTWRD			;WRITE THE EDIT NUMBER
	MOVEI	PERIOD			;WRITE A PERIOD
	GO	WRCHAR			;TO SEPARATE THE EDIT AND VERSION NUMBERS
	MOVE	VER			;GET VERSION NUMBER
	SKIPA
	LSH	6			;MOVE THREE LEAST SIGNIFICANT BITS
	TRNE	-1			;INTO LEFT HALF OF AC
	JRST	.-2			;THEN SHIFT
	MOVEI	A,4			;SET CHARACTER COUNTER TO 4
	GO	OUTWRD			;WRITE THE VERSION NUMBER
	JRST	VEROUT			;MARK VERSION AS PRINTED

VERUNK:	TRNE	77			;SKIP IF LAST CHARACTER IS BLANK
	JRST	UNKPNT			;NO
	LSH	-6			;SHIFT WORD TO RIGHT
	TRNE	77			;SKIP IF LAST CHARACTER STILL BLANK
	JRST	UNKPNT			;NO
	LSH	-6			;SHIFT WORD TO RIGHT
	TRNN	77			;LAST CHARACTER STILL ZERO?
	LSH	-6			;YES, SHIFT AGAIN
UNKPNT:	MOVEI	A,8			;SET CHARACTER COUNT TO 8
	GO	OUTWRD			;WRITE VERSION WORD FROM FILE
VEROUT:	HRLI	DAT,0			;CLEAR VERSION IN DATE WORD
	SETOM	VERPNT			;SET PRINTED VERSION FLAG
;*ASCDAT, READ DATE FROM FILE LINE

ASCDAT:	GO	INWORD			;READ NEXT WORD
	CAIE	A,LF			;IF LINE FEED OR
	CAIN	A,0			;  EOF
	JRST	ASCEND			;  ERROR
	CAIN	A,DASH			;IF A DASH AND
	SKIPE	NOTNUM			;  A NUMBER
	JRST	ASCEND			;  MUST BE DATE. IF NOT, ERROR
	TDNE	[77777777]		;MAKE SURE NUMBER IS ONLY 2 DIGITS
	JRST	ASCEND			;ERROR
	MOVEM	C			;SAVE DATE
	GO	INWORD			;INPUT ANOTHER WORD
	CAIE	A,DASH			;TERMINATOR BETTER BE A DASH
	JRST	ASCEND			;ERROR
	PUT	B			;SAVE B
	MOVE	B,DATTBP		;GET ADR OF MONTH TABLE
	GO	COMPARE			;COMPARE INPUT WITH TABLE
	JRST	[GET	B		;ERROR, ALSO RESTORE B
		 JRST	ASCEND ]
	MOVEM	B,D			;SAVE MONTH NUMBER
	GET	B			;RESTORE B	
	GO	INWORD			;READ NEXT WORD
	TDNE	[77777777]		;MAKE SURE NUMBER IS ONLY 2 DIGITS
	JRST	ASCEND			;ERROR
	GO	CNVDEC			;CONVERT YEAR TO NUMBER
	SUBI	^D64			;SUBTRACT START DATE OF 64
	SKIPGE				;NEGATIVE RESULT?
	ADDI	^D100			;YES, MAKE POSITIVE
	IMULI	^D12			;MULTIPLY BY 12
	ADDM	D			;ADD TO MONTH
	IMULI	D,^D31			;MULTIPLY BY 31
	MOVE	C			;GET DAYS
	GO	CNVDEC			;CONVERT TO NUMBER
	SOSGE				;REDUCE DAY BY 1
	JRST	ASCEND			;ERROR, DAY WAS ZERO
	ADDM	D			;ADD TO REST OF DATE
	HRRM	D,DAT			;STORE THE DATE
ASCEND:	GET	.JBFF			;RESTORE JOB FIRST FREE
	SKIPN	VERPNT			;VERSION ALREADY PRINTED?
	JRST	GETVRA			;NO, GO PRINT NOW
	RTN				;RETURN
;*CNVNUM, CONVERT SIXBIT NUMBER IN 0 TO OCTAL NUMBER

CNVNUM:	JUMPE	CNVNMX			;RETURN IMMEDIATELY IF NO INPUT
CNVNMA:	TRNE	77			;CHECK IF NUMBER RIGHT JUSTIFIED
	JRST	CNVNMB			;YES, GO START CONVERSION
	LSH	-6			;NO, SHIFT TO RIGHT
	JRST	CNVNMA			;TRY AGAIN
CNVNMB:	ROTC	-3			;GET FIRST DIGIT
	LSH	-3			;MOVE TO NEXT
	ROTC	-3			;GET SECOND DIGIT
	LSH	-3			;MOVE TO NEXT
	ROTC	6			;MERGE ALL DIGITS
	ANDI	777			;CLEAR OTHER BITS
CNVNMX:	RTN				;RETURN

;*CNVDEC, CONVERT SIXBIT NUMBER IN 0 TO DECIMAL NUMBER

CNVDEC:	TLNN	7700			;CHECK IF ONLY ONE DIGIT
	LSH	-6			;YES, MAKE FIRST DIGIT ZERO
	LDB	A,[POINT 4,0,5]		;GET FIRST DIGIT
	IMULI	A,^D10			;MULTIPLY BY 10
	LDB	[POINT 4,0,11]		;GET SECOND DIGIT
	ADD	A			;ADD TOGETHER
	RTN
;*SAVVER, GET VERSION NUMBER OUT OF SAV FILE

SAVVER:	PUT	.JBFF			;SAVE JOB FIRST FREE
	SETSTS	CH1,10			;SET IMAGE MODE
	MOVEI	4400			;CHANGE BYTE POINTER FOR
	HRLM 	BUF1+1			;BUFFER HEADER
	IN	CH1,			;CLEAR VERSION FOR NOW
SAVPNT:	GO	RD1			;READ A POINTER WORD
	JRST	SAVVEX			;EOF, EXIT NOW
	SKIPL	A,0			;MOVE TO A
	JRST	SAVVEX			;NOT A POINTER, EXIT NOW
SAVDWD:	GO	RD1			;READ DATA WORD
	JRST	SAVVEX			;EOF, ERROR IN SAV FILE
	HRRZ	C,A			;GET ADDRESS OF POINTER
	CAIL	C,136			;CHECK IF 136 OR GREATER
	JRST	SAVVRF			;YES, VERSION FOUND?
	AOBJN	A,SAVDWD		;READ NEXT DATA WORD
	JRST	SAVPNT			;READ NEXT POINTER
SAVVRF:	CAIN	C,136			;IS ADR 136?
	MOVEM	VER			;YES, SAVE VERSION
SAVVEX:	GET	.JBFF			;RESTORE JOB FIRST FREE
	RTN				;RETURN
;*	OPEN AND LOOKUP FAILURE MESSAGES FOR INPUT FILE

OPENFI:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? OPEN FAILURE ON DEVICE >
	MOVE	INDEVN			;GET DEVICE NAME
	GO	PNTSIX			;PRINT IT
	JRST	COMM

ENTRFI:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? ENTER FAILURE ON >
	JRST	.+3
LOOKFI:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? LOOKUP FAILURE ON >
	MOVE	INDEVN			;GET DEVICE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[COLON]			;PRINT A COLON
	MOVE	INFILN			;GET FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	INFILE			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	SKIPN	INFILP			;CHECK IF PPN SPECIFIED
	JRST	COMM
	OUTCHR	[LB]			;PRINT OPENING BRACKET
	HLRZ	INFILP			;GET PROJECT NUMBER
	GO	PNTOCT			;PRINT IT
	OUTCHR	[COMMA]			;PRINT A COMMA
	HRRZ	INFILP			;GET PROGRAMMER NUMBER
	GO	PNTOCT			;PRINT IT
	OUTCHR	[RB]			;CLOSE THE BRACKET
	JRST	COMM
;*	OPEN AND LOOKUP FAILURE MESSAGES FOR DATA FILES

OPENFG:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? OPEN FAILURE ON DEVICE >
	MOVE	DEV			;GET DEVICE NAME
	GO	PNTSIX			;PRINT IT
	JRST	COMM

ENTRFG:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? ENTER FAILURE ON >
	JRST	.+3
LOOKFG:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? LOOKUP FAILURE ON >
	MOVE	DEV			;GET DEVICE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[COLON]			;PRINT A COLON
	MOVE	FN			;GET FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	EXT			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	JUMPE	PPN,COMM		;EXIT IF NO PPN SPECIFIED
	OUTCHR	[LB]			;PRINT OPENING BRACKET
	HLRZ	PPN			;GET PROJECT NUMBER
	GO	PNTOCT			;PRINT IT
	OUTCHR	[COMMA]			;PRINT A COMMA
	HRRZ	PPN			;GET PROGRAMMER NUMBER
	GO	PNTOCT			;PRINT IT
	OUTCHR	[RB]			;CLOSE THE BRACKET
	JRST	COMM
;*	ADDITIONAL ERROR MESSAGES

RDNMER:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? ERROR READING INPUT FILE,  EOF WHEN NOT EXPECTED.>
	JRST	COMM

NOTFND:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? CAN'T FIND FILE >
	MOVE	FN			;GET FILE NAME
	GO	PNTSIX			;PRINT IT
	OUTCHR	[PERIOD]		;PRINT A PERIOD
	HLLZ	EXT			;GET EXTENSION
	GO	PNTSIX			;PRINT IT
	JRST	COMM

PSHERR:	GO	COCLR			;CLEAR CONTROL O
	PRINT	<? PUSHDOWN LIST UNDERFLOW ERROR>
	JRST 	COMM
;*WRITF, WRITE FILE NAMES POINTED TO BY C(D) INTO FILE ON CHANNEL 3

WRITF:	GO	WRTFNX			;WRITE FILE NAME
	MOVEI	PERIOD			;WRITE A PERIOD
	GO	WRCHAR
	AOJ	D,			;INCREMENT ADDRESS
	GO	WRTFNX			;WRITE EXTENSION
WRITCR:	MOVEI	CR			;WRITE A CARRIAGE RETURN
	GO	WRCHAR
	MOVEI	LF			;WRITE A LINE FEED
	GO	WRCHAR
	AOBJN	D,WRITF			;WRITE NEXT LINE
	RTN

WRTFNX:	MOVE	A,(D)			;GET WORD TO WRITE
WRITFN:	SETZ	0			;CLEAR 0
	LSHC	6			;GET A CHARACTER
	ADDI	SPACE			;CONVERT TO ASCII
	GO	WRCHAR			;WRITE IT
	JUMPN	A,WRITFN		;WRITE NEXT CHARACTER
	RTN				;EXIT


OUTNUM:	SETZM	DIGCNT			;CLEAR DIGIT PRINTED FLAG
	LSHC	-6			;SHIFT OUT 2 DIGITS
	GO	OUTDIG			;PRINT DIGIT OR SPACE
	SETZ				;CLEAR 0
	LSHC	3			;GET NEXT DIGIT
	GO	OUTDIG			;PRINT DIGIT OR SPACE
	SETZ				;CLEAR 0
	LSHC	3			;GET LAST DIGIT
	ADDI	"0"			;CONVERT TO ASCII
	GO	WRCHAR			;WRITE IT
	AOS	DIGCNT			;COUNT THE DIGIT PRINTED
	RTN
;*WRDATE, WRITE CREATION DATE OF FILE INTO .DIR FILE

WRDATE:	IDIVI	^D31			;EXTRACT THE DAY
	PUT	0			;SAVE THE REST
	ADDI	A,1			;INCREASE BY ONE
	MOVE	A			;MOVE NUMBER TO 0
	IDIVI	^D10			;DIVIDE BY 10
	SETZM	DIGCNT			;CLEAR DIGIT COUNTER
	GO	OUTDIG			;PRINT FIRST DIGIT OR SPACE
	MOVE	A			;GET SECOND DIGIT
	GO	OUTDIG			;PRINT SECOND DIGIT
	GET	0			;GET REST OF DATE
	IDIVI	^D12			;EXTRACT THE MONTH
	PUT	0			;SAVE THE YEAR
	MOVEI	"-"			;PRINT A DASH
	GO	WRCHAR
	MOVE	DATTAB(A)		;GET NAME OF MONTH
	MOVEI	A,3			;GET CHARACTER COUNT TO 3
	GO	OUTWRD			;PRINT THE MONTH
	MOVEI	"-"			;PRINT ANOTHER DASH
	GO	WRCHAR
	GET	0			;GET YEAR AGAIN
	ADDI	^D64			;ADD START YEAR OF 64
	CAIL	^D100			;CHECK FOR OVERFLOW
	SUBI	^D100			;REDUCE TO TWO DIGITS
	AOS	DIGCNT			;MOKE DIGIT COUNT POSITIVE
	IDIVI	^D10			;DIVIDE BY 10
	GO	OUTDIG			;PRINT FIRST DIGIT
	MOVE	A			;GET SECOND DIGIT
	GO	OUTDIG			;PRINT IT
	MOVEI	SPACE			;PRINT A SPACE
	GO	WRCHAR
	RTN				;EXIT
;*DATTBP, COMPARE TABLE FOR MONTHS OF THE YEAR

DATTBP:	.-DATTBE,,.+1
DATTAB:	SIXBIT	'JAN'
	SIXBIT	'FEB'
	SIXBIT	'MAR'
	SIXBIT	'APR'
	SIXBIT	'MAY'
	SIXBIT	'JUN'
	SIXBIT	'JUL'
	SIXBIT	'AUG'
	SIXBIT	'SEP'
	SIXBIT	'OCT'
	SIXBIT	'NOV'
	SIXBIT	'DEC'
DATTBE==.-1

;*NAMTAB, COMPARE TABLE FOR REQUIRED FILES ON EACH MAGTAPE

NAMTAB:	SIXBIT	"MAGTAP"		;THESE FILES MUST BE THE
	SIXBIT	"RDI"			;FIRST TO BE WRITTEN ON
	SIXBIT	"MAGTAP"		;THE MAGTAP
	SIXBIT	"SAV"
	SIXBIT	"MAGMON"
	SIXBIT	"SAV"
	SIXBIT	"MAGTAP"
	SIXBIT	"MTA"
	SIXBIT	"MAGTAP"
	SIXBIT	"DIR"
;HELP COMMAND

HELP:	OUTSTR	HLPMSG			;PRINT THE HELP MESSAGE
	JRST	BADCMF			;GO FOR NEXT COMMAND

HLPMSG:	ASCIZ	\
			MAGTAP COMMAND SUMMARY

HELP				TYPE THIS MESSAGE

GET				GET ALL FILES ON THE MAGTAPE AND PLACE
				ON DISK
GET FILE1.EXT,FILE2.EXT		GET SPECIFIED FILES FROM MAGTAPE AND
				PLACE ON DISK

DIRECTORY DEV			WRITE DIRECTORY OF MAGTAPE ON DEV AS
				MAGTAP.DIR (DEFAULT DEV IS TTY)

FDIRECTORY DEV			WRITE A FAST DIRECTORY ON DEV AS
				MAGTAP.DIR (FILE NAMES ONLY)

CHECK				CHECK THAT ENTIRE MAGTAPE CAN BE READ
				WITHOUT ERRORS
CHECK FILE1.EXT,FILE2.EXT	CHECK THAT THE SPECIFIED FILES CAN BE
				READ WITHOUT ERRORS

EXIT				EXIT TO MONITOR

UNLOAD				UNLOAD MAGTAPE AND EXIT TO MONITOR

REWIND				REWIND MAGTAPE AND CLEAR IN-CORE
				DIRECTORY

TAPE DEV			SELECT NEW MAGTAPE DEVICE DEV

MAKE				MAKE A MAGTAPE USING INPUT FILE
				DSK:MAGTAP.INP
MAKE @DEV:FILE.EXT[P,PN]	MAKE MAGTAPE USING INPUT FILE SPECIFIED
MAKE FILE1.EXT,FILE2.EXT	MAKE MAGTAPE CONTANING SPECIFIED FILES

VERIFY				VERIFY THAT EVERY FILE ON MAGTAPE IS
				IDENTICAL TO SAME FILE ON DISK
VERIFY FILE1.EXT,FILE2.EXT	VERIFY THAT SPECIFIED FILES ARE
				IDENTICAL ON MAGTAPE AND DISK

SEARCH DEV:[P,PN1],DEV2:[P,PN2]	SET UP SEARCH LIST OF DISK AREAS TO BE
				SEARCHED BY MAKE, VERIFY AND NUMBER
				COMMANDS

OPTION NAME			SET UP SEARCH LIST FROM DSK:SWITCH.INI
				LINE 'MAGTAP:NAME'

NUMBER FILE.EXT 0.1		SET VERSION NUMBER OF SPECIFIED FILE
				IN DISK DIRECTORY TO 0.1

/LIST				LIST FILES AS PROCESSED
				FOR MAKE, GET, CHECK, VERIFY COMMAND

/GROUP:ARG			FOR GET, CHECK, VERIFY COMMAND
  GROUP ARGUMENTS ARE:		ALL, DIASUP, KACPU, KICPU, KLCPU
				KLDIAG, KLTIC, KLISO
				KLADIAG, KLATIC, KLAISO
				KLBDIAG, KLBTIC, KLBISO
				MEMORY, TAPE, DISK, UNIREC, COMM
				SYSEXR, FEDIAG, FESUPP, FLDSRV
				SPECIAL, TOPS10, TOPS20
				UNDEF1-6

/TYPE:ARG			FOR GET, CHECK, VERIFY COMMAND
  TYPE ARGUMENTS ARE:		ALL, EXEC, USER, SPECIAL, MONITOR, UNDEF

				    TYPE .INP FILE CODES:
					20 = UNDEF
					10 = MONITOR
					04 = SPECIAL
					02 = USER
					01 = EXEC
					00 = ALL
\
SUBTTL	MAGTAPE READ-IN BOOTSTRAP FILE

;*MAGTAPE CONTROL BITS

TMS=344					;MAG TAPE STATUS (TMS)
TMC=340					;MAG TAPE CONTROL (TMC)
TMC2=350				;MAGTAPE CONTROL #2
TMS2=354				;MAGTAPE STATUS #2
PARITY=1B21				;ODD PARITY
BPI800=1B28				;800 BPI DENSITY
DUMP=1B22				;CORE DUMP MODE
NOOP=0					;NO-OP
NOOP1=10B26				;UNIT READY CHECK
READX=2B26				;READ
SPACE=6B26				;SPACE FORWARD RECORD
SPACE1=16B26				;SPACE FORWARD FILE
SPACE2=7B26				;SPACE REVERSE RECORD
SPACE3=17B26				;SPACE REVERSE FILE

;*MAGTAPE STATUS BITS

DF22=1B9				;DF10 IN 22 BIT MODE
DF10=17B14				;DF10 CHECK BITS
HUNG=1B18				;TRANSPORT HUNG
WIND=1B19				;TRANSPORT REWINDING
BOT=1B20				;BEGINNING OF TAPE
ILLOP=1B21				;ILLEGAL OPERATION
PERR=1B22				;PARITY ERROR
EOF=1B23				;END OF FILE
EOT=1B24				;END OF TAPE (REAL)
RCERR=1B25				;READ/COMP ERROR
RLINC=1B26				;RECORD LENGTH INCORRECT
DATLAT=1B27				;DATA LATE
BADTAP=1B28				;BAD TAPE
JOBDON=1B29				;JOB DONE
IDLE=1B30				;XPORT IDLE
WRTLCK=1B32				;WRITE LOCK
CHAN7=1B33				;SEVEN CHANNEL XPORT
DATA=1B35				;DATA READY

BADBIT=HUNG!ILLOP!EOT!RCERR!DATLAT!BADTAP!PERR	;ERROR BITS
;*RDIO, READ-IN PROGRAM FOR MAGTAP.RDI

RDI0:	IOWD	<RDIEND-RDI0-3>,STTM	;POINTER TO DATA IN RECORD

	PHASE	RDIADR

STTM:	CONI	TMS,STAT		;READ STATUS OF TMS
	TRNE	STAT,JOBDON		;CHECK IF JOB DONE SET
	JRST	GOTM			;YES, GO USE IT
	MOVSI	D,(1B8)			;GET BIT 8 TO CHANGE DEVICE CODE
	ORM	D,STTM			;CHANGE CODE OF CONI
	XCT	STTM			;READ STATUS OF TMS2
	TRNN	STAT,JOBDON		;CHECK IF JOB DONE SET
	HALT	.			;NO
	ORM	D,TMDTO			;CHANGE ALL I/O INSTRUCTIONS
	ORM	D,RDTM			;TO THE TM10
	ORM	D,TMBLK			;TO SECOND DEVICE CODE
	ORM	D,TMSP

GOTM:	JSP	P,CLRCOR		;CLEAR CORE
	MOVEI	TMCHN			;SET UP DF10 ICCW
	MOVEM	LOWCMD			;IN MEMORY
	TLNN	STAT,(DF10)		;CHECK IF TM10B
	TLNN	STAT,(DF22)		;WITH 22-BIT DF10
	JRST	LDTM			;NO
	HLRZ	TMCHN			;GET WORD COUNT
	LSH	4			;POSITION FOR 22-BIT ADDRESS
	HRLM	TMCHN			;PUT IT BACK IN CHAN LIST
LDTM:	MOVEI	LOWCMD			;GET ICCW ADDRESS
TMDTO:	DATAO	TMS,			;LOAD INTO TM10
	XCT	STTM			;READ STATUS OF XPORT
	TRNN	STAT,IDLE		;WAIT FOR XPORT TO BECOME IDLE
	JRST	.-2			;KEEP WAITING
TMSP:	CONO	TMC,DUMP!PARITY!SPACE1!BPI800	;SPACE FORWARD ONE
	JSP	P,WAITTM		;  FILE MARK
	XCT	TMSP			;SPACE FORWARD ANOTHER FILE MARK
	JSP	P,WAITTM		;TO POSITION AT MAGMON.SAV
RDTM:	CONO	TMC,DUMP!PARITY!READX!BPI800	;START READ
	TLNN	STAT,(DF10)		;CHECK IF TM10B
	JRST	WTTM			;YES, WAIT FOR DONE
	MOVE	TMCHN			;GET BLKI POINTER
TMRDS:	XCT	STTM			;GET STATUS
	TRNE	STAT,JOBDON		;LOOK FOR JOB DONE
	JRST	TMDON			;YES
	TRNN	STAT,DATA		;LOOK FOR DATA REQUEST
	JRST	TMRDS			;WAIT AGAIN
TMBLK:	BLKI	TMC,0			;READ A DATA WORD
	JRST	WTTM			;BLKI SATISFIED
	JRST	TMRDS			;WAIT AGAIN
;*	WAIT FOR TM10 OPERATION TO COMPLETE

WTTM:	JSP	P,WAITTM		;WAIT FOR XPORT TO STOP
TMDON:	TRNE	STAT,BADBIT!EOF		;CHECK FOR ERRORS
	HALT	.			;READ ERROR
	JSP	P,LOADPG		;LOAD DATA FROM THIS RECORD
	JRST	RDTM			;READ NEXT RECORD

TMCHN:	IOWD	RCDSIZ,RDIBUF		;DF10 TRANSFER WORD
	0				;END OF LIST

WAITTM:	XCT	STTM			;GET STATUS
	TRNN	STAT,JOBDON		;SKIP IF XPORT IDLE
	JRST	WAITTM			;NO, KEEP WAITING
	JRST	@P			;RETURN
;*DX10 CONTROL BITS

PDC=220					;DX10 DEVICE CODE
PDC2=224				;DX10 #2
PDC3=34					;DX10 #3
RUNIND=1				;RUN INDICATOR OF 8A PROCESSOR
INHLD=1B25				;INHIBIT LOAD OF ICPC (CONO)
CSRFLG=1B25				;CHANNEL STATUS REGISTER ERROR (CONI)
MPERR=1B26				;8A TIME OUT ERROR
MEMPAR=1B27				;MEMORY PARITY ERROR
NXM=1B28				;NON-EXISTANT MEMORY ERROR
STAVL=1B29				;STATUS AVAILABLE FLAG
CLEAR=1B31				;CLEAR DEVICES
CONT=1B32				;CONTINUE DX10
INTFLG=MPERR+MEMPAR+NXM+STAVL


;*DX10 COMMANDS

BSB=	1B1!47B23			;BACKSPACE BLOCK
BSF=1B1!57B23				;BACKSPACE SPACE FILE
FSF=1B1!77B23				;FORWARD SPACE FILE
RDF=1B1!1B2!2B23			;READ FORWARD
CHJMPG=1B2!1B3				;CHANNEL JUMP AND GO
STORE=1B4				;STORE STATUS
REWD=1B1!7B23				;REWIND COMMAND
CHJMPS=1B3!1B4				;STORE AND JUMP COMMAND
;*DX10 STATUS BITS

BUSY=1B3				;CONTROL UNIT OR DEVICE BUSY
UNITCK=1B6				;UNIT CHECK
UNITEX=1B7				;UNIT EXCEPTION
TYPE0=2B10				;STATUS TYPE CODE 2
SELERR=1B11				;DEVICE SELECTION ERROR
SEQERR=1B12				;SEQUENCE ERROR
DEVPAR=1B13				;DEVICE PARITY ERROR
LENERR=1B14				;LENGTH ERROR
ILLCMD=1B16				;ILLEGAL COMMAND
DSRFLG=1B17				;DEVICE STATUS REGISTER ERROR
SNSERR=1B18				;SENSE BYTE RETRIEVAL ERROR
OPI=1B19				;OPERATION INCOMPLETE

RETRY=^D10				;RETRY COUNT
LOWCMD=20				;LOW COMMAND AREA

DXCLR=2					;RESET DX10 BIT
RSEL=1					;SELECT RSEL REGISTER
MPADR=5					;8A ADDRESS REGISTER CODE
MPCTL=4					;8A CONTROL REGISTER CODE
DAC=12					;DATA ADDRESS COUNTER CODE
UNITNM=	7713				;ADDRESS OF UNIT FROM 8-MEMORY
ENEXM=1B22				;ENABLE EXAMINE
ENDEP=1B23				;ENABLE DEPOSIT
MPHALT=1B19				;8A HALT SWITCH
MPCONT=1B20				;8A CONTINUE SWITCH
MCSTRT=200				;MICRO-CODE START ADDRESS
MCCODE=16				;MICRO-CODE ADDRESS CONTAINING '70'
DXCODE='70'				;CODE IN MCCODE
;*SRTDX, DX10 READ-IN PROGRAM

	DXFIX==RDIADR+77-.
	IF1,	<
	IFL	<DXFIX>, <
PRINTX	DX10 READ-IN START ADDRESS CANNOT BE PLACED IN 100 >>
	IFG	<DXFIX>, < BLOCK DXFIX >

SRTDX:	HRLZI	100			;SET UP BLT POINTER
	HRRI	SRTDX			;  TO TRANSFER PROGRAM TO
	BLT	RDIBUF			;  CORRECT PLACE IN MEMORY
	JRST	STDX			;GO TO PROGRAM THERE

STDX:	CONI	PDC,STAT		;READ DX10 STATUS
	TLNE	STAT,RUNIND		;CHECK IF DX10 IS RUNNING
	JRST	SPDX			;YES
	MOVEI	D,PDC2_-2		;GET PDC2 CODE
	CONI	PDC2,STAT		;READ STATUS
	TLNE	STAT,RUNIND		;CHECK IF RUNNING
	JRST	FNDDX			;YES
	MOVEI	D,PDC3_-2		;GET PDC3 CODE
	CONI	PDC3,STAT		;READ STATUS
	TLNN	STAT,RUNIND		;CHECK IF RUNNING
	HALT	.			;NO

FNDDX:	MOVSI	B,-6			;GET COUNT OF I/O INSTRUCTIONS
	DPB	D,DXPNT(B)		;CHANGE ALL I/O INSTRUCTIONS
	AOBJN	B,.-1			;  TO DEVICE CODE OF DX10 RUNNING
;*	DX10 FOUND, STOP IT AND MODIFY PDP-8A MEMORY

SPDX:	MOVSI	DXBK1-DXBK2		;GET COUNT OF DATAO DATA WORDS
	HRRI	DXBK1-1			;BUILD BLKO POINTER
	JSP	P,DXBKO			;STOP THE DX10 AND READ UNIT NO.
DXDTI:	DATAI	PDC,A			;READ ADDRESS OF DRIVE
	ANDI	A,17			;CLEAR ALL OTHER BITS
	ORM	A,DXFSF1		;LOAD ADDRESS INTO ALL
	ORM	A,DXFSF2		;  DX10 DEVICE INSTRUCTIONS
	ORM	A,DXRD
	HRLI	DXBK2-DXBK3		;GET COUNT OF NEXT I/O LIST
	JSP	P,DXBKO			;CAUSE DX10 TO READ THE MICRO-CODE
					;  FROM THE TAPE INTO CORE
	XCT	STDX			;READ STATUS
	TLNE	STAT,RUNIND		;WAIT FOR DX10 TO STOP
	JRST	.-2
	TRNN	STAT,STAVL		;CHECK IF STATUS AVAILABLE SET
	HALT	.			;NO, ERROR READING MICR0-CODE TO CORE
	HRLI	DXBK3-DXBK4		;GET COUNT OF NEXT I/O LIST
	JSP	P,DXBKO			;SELECT 8A ADDRESS 0
	MOVSI	B,(POINT 12)		;BUILD BYTE POINTER
	HRRI	B,31000			;  TO 8A MEMORY IMAGE
	MOVEI	C,10000			;GET COUNT OF PDP-8A WORDS
LOAD8A:	ILDB	A,B			;GET A PDP-8A WORD
	TRO	A,ENDEP			;SET THE ENDEP BIT
DXDTO:	DATAO	PDC,A			;WRITE INTO 8A MEMORY
	SOJG	C,LOAD8A		;LOAD ALL WORDS

	HRLI	DXBK4-DXBK5		;START THE DX10
	JSP	P,DXBKO			;  MICRO-CODE

	JSP	P,CLRCOR		;CLEAR CORE
	MOVEI	DXFSF1			;SET UP ICPC
	HRLI	(CHJMPG)		;  IN MEMORY WITH A JUMP
	MOVEM	LOWCMD			;  COMMAND TO PROGRAM
DXCNO:	CONO	PDC,<LOWCMD>_9!STAVL!CLEAR!CONT	;START THE DX10
DXWAT:	XCT	STDX			;READ DX10 STATUS
	TRNN	STAT,INTFLG		;WAIT FOR AN INTERRUPT FLAG
	JRST	DXWAT
	TRNE	STAT,MPERR!MEMPAR!NXM!CSRFLG	;CHECK FOR ERRORS
	HALT	.			;ERROR FLAG SET, STOP HERE
	JSP	P,LOADPG		;LOAD PROGRAM
DXCNT:	CONO	PDC,INHLD!STAVL!CONT	;CONTINUE READING
	JRST	DXWAT			;WAIT FOR DONE FLAG
;*	DX10 BLOCKO ROUTINE

DXBKO:	BLKO	PDC,0			;WRITE TO DX10
	JRST	@P			;BLKO SATISFIED
	JRST	DXBKO			;KEEP WRITING

DXPNT:	POINT	7,STDX,9		;POINTER TO ALL
	POINT	7,DXDTI,9		;  I/O INSTRUCTIONS
	POINT	7,DXDTO,9
	POINT	7,DXBKO,9
	POINT	7,DXCNO,9	
	POINT	7,DXCNT,9

DXFSF1:	FSF				;SKIP OVER TWO FILE MARKS
DXFSF2:	FSF				;TO POSITION AT MAGMON.SAV
DXRD:	RDF				;READ FROM TAPE
	-<RCDSIZ*5>_4,,RDIBUF		;TRANSFER WORD FOR READ
	CHJMPS!DXRD			;STORE STATUS, SET CPC TO READ AGAIN
;*	DATAO WORDS SENT TO DX10

DXBK1:	DXCLR,,0			;STOP THE DX10
	RSEL,,MPCTL			;SELECT MPCTL
	0				;CLEAR THE SWITCHES
	RSEL,,MPADR			;SELECT MPADR
	7605				;SET ADDRESS
	RSEL,,MPCTL			;SELECT CONTROL
	ENDEP!5211			;DEPOSIT JMP 7611
	RSEL,,MPADR			;SELECT ADDRESS
	7616				;SET ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	ENDEP!6505			;INSERT G8C INSTRUCTION
	ENDEP!1315			;TAD (1000)
	RSEL,,MPADR			;SELECT MPADR
	7644				;SET ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	ENDEP!2312			;DEPOSIT ISZ LMT
	ENDEP!5215			;DEPOSIT JMP RDNXT
	ENDEP!6567			;DEPOSIT SSA
	ENDEP!7402			;DEPOSIT HLT
	RSEL,,MPADR			;SELECT MPADR
	7712				;SET ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	ENDEP!<-4&7777>			;DEPOSIT A -4
	ENEXM				;READ THE NEXT WORD
DXBK2:	ENDEP!7				;REWIND COMMAND
	ENDEP!RCDSIZ			;RECORD SIZE
	RSEL,,7				;SELECT 8R REGISTER
	0,,-<RCDSIZ*5>_4		;LOAD BYTE COUNT
	RSEL,,6				;SELECT OTHER HALF
	37000				;LOAD ADDRESS
	RSEL,,MPADR			;SELECT MPADR
	7601				;LOAD ADDRESS OF BOOTSTRAP PROGRAM
	RSEL,,MPCTL			;SELECT MPCTL
	MPCONT				;START THE DX10
DXBK3:	RSEL,,MPCTL			;SELECT MPCTL
	0				;CLEAR SWITCHES
	RSEL,,MPADR			;SELECT MPADR
	0				;LOAD ADDRESS 0
	RSEL,,MPCTL			;SELECT MPCTL
DXBK4:	DXCLR,,0			;CLEAR THE DX10
	RSEL,,MPADR			;SELECT MPADR
	MCSTRT				;LOAD MICRO-CODE START ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	MPCONT				;START THE DX10 MICRO-CODE
DXBK5:
;*RH10 CONTROL BITS

DH==270					;RH10 DEVICE CODES
DH2==274
DH3==360
DH4==364
DH5==370
DH6==374

CMDDN==1B32				;CONI DONE BIT
DF22F==1B6				;DF22 FLAG BIT
RHCLR==1B25				;RESET RH10
DEN1==1B26				;800 BPI DENSITY BIT
DRTC==11B5				;TAPE CONTROL REGISTER
LR==1B6					;LOAD REGISTER BIT
DRFC==5B5				;FRAME COUNT REGISTER
DRCR==0B25				;DRIVE COMMAND REGISTER
DRSR==1B5				;STATUS REGISTER
SPFWDR==31				;SKIP FORWARD COMMAND
PIP==1B22				;POSITIONING IN PROGRESS
DRY==1B28				;DRIVE READY
CERR==1B21				;CUMULATIVE ERROR BIT
DHSTRC==40B5				;RH10 CONTROL REGISTER
RDF==71					;READ COMMAND
DRER1==2B5				;ERROR REGISTER
TM==1B33				;TAPE MARK READ
;*STRH, RH10 READ-IN PROGRAM

STRH:	CONSZ	DH,CMDDN		;LOOK FOR A RH10
	JRST	FNDTU			;  WITH THE DONE BIT SET
	MOVEI	D,DH2_-2		;  TO FIND OUT WHICH
	CONSZ	DH2,CMDDN		;  RH10 PERFORMED THE READ-IN
	JRST	FNDRH
	MOVEI	D,DH3_-2
	CONSZ	DH3,CMDDN
	JRST	FNDRH
	MOVEI	D,DH4_-2
	CONSZ	DH4,CMDDN
	JRST	FNDRH
	MOVEI	D,DH5_-2
	CONSZ	DH5,CMDDN
	JRST	FNDRH
	MOVEI	D,DH6_-2
	CONSO	DH6,CMDDN
	HALT	.			;NO RH10 HAS THE DONE BIT SET

FNDRH:	MOVSI	B,-9			;GET COUNT OF I/O INSTRUCTIONS
	DPB	D,RHPNT(B)		;CHANGE ALL I/O INSTRUCTIONS
	AOBJN	B,.-1			;  TO DEVICE CODE OF RH10 TO USE

FNDTU:	DATAI	DH,0			;GET DRIVE NUMBER
	HLRZ				;  TO RIGHT OF AC
	MOVSI	B,-6			;GET COUNT OF DATAO WORDS
	DPB	DVPNT(B)		;CHANGE ALL WORDS TO
	AOBJN	B,.-1			;  DRIVE NUMBER READ

	JSP	P,CLRCOR		;CLEAR CORE
	MOVEI	TMCHN			;SET UP DF10 ICCW
	MOVEM	LOWCMD			;  IN MEMORY

GORH:	SETO	A,			;SET TWICE FLAG
RHCNO:	CONO	DH,RHCLR		;CLEAR THE RH10
	CAM	RHERR			;STALL
RHDT1:	DATAO	DH,RHCTL		;LOAD TAPE CONTROL REGISTER
	CAM	RHERR			;STALL
RHDT2:	DATAO	DH,RHFC			;CLEAR FRAME COUNTER
	CAM	RHERR			;STALL
RHDT3:	DATAO	DH,RHFORW		;SPACE FORWARD ONE FILE
	JSP	P,RHRDY			;WAIT FOR TAPE TO STOP
	TRNN	TM			;CHECK FOR TAPE MARK DETECTED
	HALT	.			;SPACE FORWARD ERROR
	AOJE	A,GORH+1		;SPACE OVER TWO FILE MARKS

	XCT	RHCNO			;CLEAR THE RH10
	CAM	RHERR			;STALL
RDRH:	XCT	RHDT1			;LOAD CONTROL REGISTER
	CAM	RHERR			;STALL
	XCT	RHDT2			;CLEAR FRAME COUNT REGISTER
	CAM	RHERR			;STALL
RHDT4:	DATAO	DH,RHREAD		;START A READ OPERATION
;*	CHECK IF RH10 READ CORRECTLY

RHST:	CONI	DH,STAT			;READ CHANNEL STATUS
	TRNN	STAT,CMDDN		;WAIT FOR DONE FLAG
	JRST	.-2
	TRNE	STAT,577700		;CHECK FOR CHANNEL ERROR
	HALT	.			;RH10 ERROR WHILE READING
	JSP	P,RHRDY			;WAIT FOR TAPE TO STOP
	TRNE	TM			;CHECK IF READ A TAPE MARK
	HALT	.			;READ ERROR - EOF DETECTED
RHDT5:	DATAO	DH,RHERR		;SELECT ERROR REGISTER
	CAM	RHERR			;STALL
	XCT	FNDTU			;READ ERROR BITS
	TRNE	176777			;CHECK IF ERROR OTHER THAN LENGTH ERROR
	HALT	.			;DEVICE READ ERROR
	JSP	P,LOADPG		;LOAD DATA FROM THIS RECORD
	JRST	RDRH			;READ NEXT RECORD

RHPNT:	POINT	7,FNDTU,9		;POINTERS TO ALL I/O
	POINT	7,RHST,9		;  INSTRUCTIONS
	POINT	7,RHCNO,9
	POINT	7,RHDT1,9
	POINT	7,RHDT2,9
	POINT	7,RHDT3,9
	POINT	7,RHDT4,9
	POINT	7,RHDT5,9
	POINT	7,RHRDY,9

DVPNT:	POINT	3,RHCTL,17		;POINTERS TO ALL DATAO WORDS
	POINT	3,RHFC,17		;  TO TAPE UNIT OR RH10
	POINT	3,RHFORW,17
	POINT	3,RHSTAT,17
	POINT	3,RHREAD,17
	POINT	3,RHERR,17

RHRDY:	DATAO	DH,RHSTAT		;SELECT STATUS REGISTER
	CAM	RHERR			;STALL
	XCT	FNDTU			;READ STATUS
	TRNN	PIP			;CHECK IF DRIVE IS STOPPED
	TRNN	DRY
	JRST	RHRDY			;NO, KEEP WAITING
	JRST	@P			;RETURN

RHCTL:	DRTC!LR!DEN1			;LOAD TAPE CONTROL REGISTER
RHFC:	DRFC!LR!0			;CLEAR FRAME COUNTER
RHFORW:	DRCR!LR!SPFWDR			;LOAD SPACE FORWARD COMMAND
RHSTAT:	DRSR				;SELECT STATUS REGISTER
RHREAD:	DHSTRC!LR!RDF!<LOWCMD>B29	;READ DATA
RHERR:	DRER1				;SELECT ERROR REGISTER
;*CLRCOR, CLEAR CORE IN PDP-10 FOR MAGMON.SAV

CLRCOR:	MOVNI	B,STTM-20		;GET COUNT OF WORD TO CLEAR
	SETZM	STTM(B)			;BETWEEN 20 AND STTM
	AOJL	B,.-1			;CLEAR ALL THE WORDS
	MOVNI	B,30600-RDIBUF		;GET COUNT OF WORDS TO CLEAR
	SETZM	30600(B)		;BETWEEN RDIBUF AND 30600
	AOJL	B,.-1			;CLEAR ALL THE WORDS
	JRST	@P			;RETURN

;*LOADPG, LOAD THE DATA BUFFER INTO CORE AND START MAGMON AT END

LOADPG:	MOVSI	A,-RCDSIZ		;GET COUNT OF WORDS IN BUFFER
	HRRI	A,RDIBUF		;AND ADDRESS OF BUFFER
LOADWD:	MOVE	(A)			;GET A WORD FROM BUFFER
	JUMPGE	B,LOADPT		;JUMP IF LOOKING FOR POINTER
	AOBJP	B,.+1			;INCREMENT POINTER
	MOVEM	(B)			;PUT WORD IN MEMORY
LOADNX:	AOBJN	A,LOADWD		;COUNT AND GET NEXT WORD IN BUFFER
	JRST	@P			;RETURN TO READ NEXT BUFFER
LOADPT:	JUMPGE	PGMST			;START PROGRAM IF START WORD
	MOVEM	B			;STORE POINTER IN B
	JRST	LOADNX			;GET NEXT WORD FROM BUFFER
PGMST:	JRST	@0			;START THE PROGRAM

RDIBUF:					;ADDRESS OF READ BUFFER

	JRST	STTM			;START WORD FOR TM10

	IOWD	1,.+1			;POINTER WORD FOR RH10
	JRST	STRH			;START WORD FOR RH10

	DEPHASE

RDIEND:	

	IF1,<
	IFG <RDIEND-RDI0-RCDSIZ>,<
	PRINTX	READ-IN CODE IS LARGER THAN ONE MAGTAPE RECORD  >>
SUBTTL	PROGRAM STORAGE AREA

;*INPUT FILE NAME FOR MAKE COMMAND

INDEV:	EXP	0			;ASCII MODE
INDEVN:	SIXBIT	'DSK'			;DEVICE NAME
INDEVB:	EXP	BUF0			;BUFFER ADDRESS FOR CHANNEL 0
INFILN:	SIXBIT	'MAGTAP'		;FILE NAME
INFILE:	SIXBIT	'INP'			;EXTENSION
INFILD:	0				;CREATION DATE
INPPN:	0				;P,PN
INFILP:	0				;SAVED P,PN



;*SEARCH LIST SET UP BY SEARCH SWITCH

SCHLST:	SIXBIT	'DSK'			;DEFAULT TO DSK
	0				;OF USER P,PN
	0				;ZERO DENOTES END OF TABLE
	BLOCK	^D20*2			;ROOM FOR 20 ENTRIES
BUF0:	BLOCK 3				;RING BUFFER HEADER FOR CHN 0
BUF1:	BLOCK 3
BUF2:	BLOCK 3
BUF3:	BLOCK 3
BUF4:	BLOCK 3

PLIST:	BLOCK 40

END:	0
	RELOC	END

	NOSYM
	END	START
    