	SUBTTL	DATA PATH TEST - PART 2

DEFTST	MCODE5
	TEST	225,TEST MASSBUS COUNTER (MC)
;*TEST THAT THE MC INCREMENTS CORRECTLY WHEN A "SET MSTR ACK" PULSE IS
;*GENERATED.

;*LOAD TEST DATA INTO THE MC.
;*SET "MSTR RDY DLY 2".
;*SET "DIAG MSTR REQ".
;*CHECK THE MC FOR CORRECT INCREMENTED DATA.

	LDMAR	0			;CLEAR MAR
	LDMEM	1			;SETUP ADD PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDBR	CNTDAT			;SETUP POINTER TO DATA TO LOAD
	MOVB	AC2
	LDBR	CNTCOR			;SETUP POINTER TO CORRECT DATA AFTER
	MOVB	AC3			;INCREMENTING
	LDBR	^D18			;SET LOOP COUNT MINUS 1
	MOVB	AC1
MCLP:	MOV	AC2,MAR			;SET MAR TO POINT TO LOAD DATA
	MOVMEM	MCHI,I			;LOAD HI ORDER BITS AND INC POINTER
	MOVMEM	MCLO			;LOAD LOW ORDER BITS
	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	GOSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	MCHI,AC0		;READ HI ORDER BITS
	DATI	MCLO,AC4		;READ LOW ORDER BITS
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC2,MAR			;STORE LOADED DATA FOR
	MOVMEM	MPGP13,I		;ERROR
	MOVMEM	MPGP12			;PRINTOUT
	MOV	AC4,BR			;STORE ACTUAL DATA FOR
	MOVB	MPGP16			;ERROR
	MOV	AC0,BR			;PRINTOUT
	MOVB	MPGP17
	MOV	AC3,MAR			;STORE CORRECT DATA FOR
	MOVMEM	MPGP15,I		;ERROR
	MOVMEM	MPGP14			;PRINTOUT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	MOV	AC3,MAR			;SET MAR TO CORRECT DATA
	OSM	AC0,I			;CHECK IF HI ORDER BITS CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	MCERR			;ELSE, REPORT ERROR
	OSM	AC4			;CHECK IF LOW ORDER BITS CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
MCERR:	ERROR	MCLP,MC DID NOT INCREMENT CORRECTLY,,PNT
	INCR	AC3			;INC CORRECT DATA POINTER TO
	INCR	AC3			;NEXT VALUE
	INCR	AC2			;INC LOAD DATA POINTER TO
	INCR	AC2			;NEXT VALUE
	DECR	AC1			;DEC LOOP COUNT
	JMPZ	.+2			;JUMP IF DONE
	JMP	MCLP			;ELSE, CONTINUE

	REPEAT	TST
	TEST	226,TEST "MC OF FLAG"
;*CLEAR ALL REG 0 FLAGS.
;*LOAD MC WITH ALL ONES AND CLOCK IT.
;*CHECK THAT "MC OF FLAG" IS SET.

	MOVB	REG0			;CLEAR FLAGS
	LDBR	377			;LOAD ALL ONES INTO MC
	MOVB	MCLO
	MOVB	MCHI
	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	GOSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,AC0		;READ REG 0
	SHL	AC0,BR			;MOVE "MC OF FLAG" TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"MC OF FLAG" DID NOT SET,
DIAG LOADED MC WITH ALL ONES THEN SET "DIAG MSTR REQ"
;*LOAD ALL ZEROS INTO THE MC AND CLOCK IT.
;*CHECK THAT "MC OF FLAG" STAYS SET.

	LDBR	0			;CLEAR THE MC
	MOVB	MCHI
	MOVB	MCLO
	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	GOSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,AC0		;READ REG 0
	SHL	AC0,BR			;MOVE "MC OF FLAG" TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"MC OF FLAG" DID NOT STAY SET,
<DIAG SET "MC OF FLAG" THEN LOADED MC WITH ZEROS AND
SET "DIAG MSTR REQ">
;*WRITE REG 0.
;*CHECK THAT "MC OF FLAG" IS CLEARED.

	MOVB	REG0			;WRITE REG 0 TO CLEAR FLAGS
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,AC0		;READ REG 0
	SHL	AC0,BR			;MOVE "MC OF FLAG" TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	TST,"MC OF FLAG" DID NOT CLEAR,
DIAG SET "MC OF FLAG" THEN WROTE REG 0
;*LOAD MC WITH SELECTED DATA PATTERNS THEN CLOCK IT.
;*CHECK THAT "MC OF FLAG" IS NOT SET.

MCOF1:	LDMAR	CTR1			;SET MAR TO LOAD DATA
	GOSUB	MCFTST			;GO LOAD MC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	MCOF1,"MC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED MC WITH 177760 THEN SET "DIAG MSTR REQ"
MCOF2:	LDMAR	CTR2			;SET MAR TO LOAD DATA
	GOSUB	MCFTST			;GO LOAD MC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	MCOF1,"MC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED MC WITH 177417 THEN SET "DIAG MSTR REQ"
MCOF3:	LDMAR	CTR3			;SET MAR TO LOAD DATA
	GOSUB	MCFTST			;GO LOAD MC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	MCOF1,"MC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED MC WITH 170377 THEN SET "DIAG MSTR REQ"
MCOF4:	LDMAR	CTR4			;SET MAR TO LOAD DATA
	GOSUB	MCFTST			;GO LOAD MC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	MCOF1,"MC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED MC WITH 7777 THEN SET "DIAG MSTR REQ"
	REPEAT	TST
	TEST	227,TEST GENERATION OF "MSTR END XFER"
;*TEST THAT "MSTR END XFER" IS SET WHEN (1) "MC OF FLAG" SETS WITH
;*"MSTR END XFER ON MC OVFL" (MEX ON MC) SET, OR (2) "FMTR END XFER" SETS
;*WITH "MSTR END XFER ON FMTR END XFER" (MEX ON FEX) SET.

;*CLEAR "MEX ON MC OVERFLOW" BIT.
;*GENERATE "MC OF FLAG".
;*CHECK THAT "MSTR END XFER" IS NOT SET.

	MOVB	REG0			;CLEAR FLAGS
	LDBR	377			;LOAD ALL ONES INTO MC
	MOVB	MCLO
	MOVB	MCHI
	LDBR	0
	MOVB	REG2			;CLEAR MEX ON MC BIT
	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	GOSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,BR			;READ REG 3
	SHR				;RIGHT ADJUST "NOT MSTR END XFER" BIT
	SHR
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"MSTR END XFER" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "MEX ON MC" THEN SET "MC OF FLAG"
;*SET "MEX ON MC OVERFLOW" BIT.
;*CHECK THAT "MSTR END XFER" IS SET.

	LDBR	MEMCOV			;SET "MEX ON MC"
	MOVB	REG2
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,BR			;READ REG 3
	SHR				;RIGHT ADJUST "NOT MSTR END XFER" BIT
	SHR
	JMPB0	.+2			;JUMP IF IT SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	TST,"MSTR END XFER" DID NOT SET,
DIAG SET "MC OF FLAG" THEN SET "MEX ON MC"
;*WRITE REG 0 TO CLEAR "MC OF FLAG".
;*CHECK THAT "MSTR END XFER" IS CLEARED.

	MOVB	REG0			;CLEAR "MC OF FLAG"
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,BR			;READ REG 3
	SHR				;RIGHT ADJUST "NOT MSTR END XFER" BIT
	SHR
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"MSTR END XFER" DIDN'T CLEAR,
DIAG SET "MSTR END XFER" THEN CLEARED "MC OF FLAG"
;*SET "MEX ON FEX" BIT.
;*SET "FMTR END XFER".
;*CHECK THAT "MSTR END XFER" IS SET.

	GOSUB	DEVRD			;SETUP DEVICE READ
MEX1:	LDBR	RMADR8+MEONFE		;SET "MEX ON FEX" AND ROM ADDR BIT 8
	MOVB	REG2
	MOVB	HSDPIN			;CLEAR "RUN"
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	ZEROS			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 00"=0
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	GOSUB	SWEX			;GO SET "SLVE WOR END XFER"
	DATI	REG3,BR			;READ REG 3
	SHR				;RIGHT ADJUST "NOT MSTR END XFER" BIT
	SHR
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	MEX1,"MSTR END XFER" DID NOT SET,
DIAG SET "MEX ON FEX" AND "FMTR END XFER"
;*CLEAR "MEX ON FEX" BIT.
;*CHECK THAT "MSTR END XFER" IS CLEARED.

	LDBR	RMADR8			;CLEAR "MEX ON FEX"
	MOVB	REG2
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,BR			;READ REG 3
	SHR				;RIGHT ADJUST "NOT MSTR END XFER" BIT
	SHR
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	MEX1,"MSTR END XFER" DID NOT CLEAR,
DIAG SET "MSTR END XFER" THEN CLEARED "MEX ON FEX"
;*SET "MEX ON FEX" BIT.
;*CLEAR "FMTR END XFER" BY CLEARING "SLVE END XFER".
;*CHECK THAT "MSTR END XFER" IS CLEARED.

	LDBR	RMADR8+MEONFE		;SET "MEX ON FEX"
	MOVB	REG2
	GOSUB	CLRSEX			;GO CLEAR "SLVE WOR END XFER"
	DATI	REG3,BR			;READ REG 3
	SHR				;RIGHT ADJUST "NOT MSTR END XFER" BIT
	SHR
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	MEX1,"MSTR END XFER" DID NOT CLEAR,
DIAG SET "MSTR END XFER" THEN CLEARED "FMTR END XFER"
	REPEAT	TST
	TEST	228,TEST BYTE COUNTER (BC)
;*TEST THAT THE BC INCREMENTS CORRECTLY WHEN A "SET SLVE ACK" PULSE IS
;*GENERATED.

;*LOAD TEST DATA INTO THE BC.
;*SET "SLVE RDY DLY 2".
;*SET "DIAG SLVE REQ".
;*CHECK THE BC FOR THE CORRECT INCREMENTED DATA.

	LDMAR	0			;CLEAR MAR
	LDMEM	2			;SETUP ADD PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDBR	CNTDAT			;SETUP POINTER TO DATA TO LOAD
	MOVB	AC2
	LDBR	CNTCOR			;SETUP POINTER TO CORRECT DATA AFTER
	MOVB	AC3			;INCREMENTING
	LDBR	^D18			;SET LOOP COUNT MINUS 1
	MOVB	AC1
BCLP:	MOV	AC2,MAR			;SET MAR TO POINT TO LOAD DATA
	MOVMEM	BCHI,I			;LOAD HI ORDER BITS AND INC POINTER
	MOVMEM	BCLO			;LOAD LOW ORDER BITS
	LDBR	0			;CLEAR "SLVE REQ"
	MOVB	REG1
	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	DSLVRQ			;SET "SLVE REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	BCHI,AC0		;READ HI ORDER BITS
	DATI	BCLO,AC4		;READ LOW ORDER BITS
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC2,MAR			;STORE LOADED DATA FOR
	MOVMEM	MPGP13,I		;ERROR
	MOVMEM	MPGP12			;PRINTOUT
	MOV	AC4,BR			;STORE ACTUAL DATA FOR
	MOVB	MPGP16			;ERROR
	MOV	AC0,BR			;PRINTOUT
	MOVB	MPGP17
	MOV	AC3,MAR			;STORE CORRECT DATA FOR
	MOVMEM	MPGP15,I		;ERROR
	MOVMEM	MPGP14			;PRINTOUT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	MOV	AC3,MAR			;SET MAR TO CORRECT DATA
	OSM	AC0,I			;CHECK IF HI ORDER BITS CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	BCERR			;ELSE, REPORT ERROR
	OSM	AC4			;CHECK IF LOW ORDER BITS CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
BCERR:	ERROR	BCLP,BC DID NOT INCREMENT CORRECTLY,,PNT
	INCR	AC3			;INC CORRECT DATA POINTER TO
	INCR	AC3			;NEXT VALUE
	INCR	AC2			;INC LOAD DATA POINTER TO
	INCR	AC2			;NEXT VALUE
	DECR	AC1			;DEC LOOP COUNT
	JMPZ	.+2			;JUMP IF DONE
	JMP	BCLP			;ELSE, CONTINUE

	REPEAT	TST
	TEST	229,TEST "BC OF FLAG"
;*CLEAR ALL REG 0 FLAGS.
;*LOAD BC WITH ALL ONES AND CLOCK IT.
;*CHECK THAT "BC OF FLAG" IS SET.

	MOVB	REG0			;WRITE REG 0 TO CLEAR FLAGS
	LDBR	377			;FILL THE BC
	MOVB	BCHI
	MOVB	BCLO
	LDBR	0
	MOVB	REG1			;CLEAR "DIAG SLVE REQ"
	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	DSLVRQ			;SET "DIAG SLVE REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,AC0		;READ REG 0
	LDBR	373			;SET MASK OF ALL BUT "BC OF FLAG" BIT
	LORB	AC0			;IF BIT IS SET, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"BC OF FLAG" DID NOT SET,
DIAG LOADED BC WITH ALL ONES THEN SET "DIAG SLVE REQ"
;*LOAD ALL ZEROS INTO THE BC THEN CLOCK IT.
;*CHECK THAT THE "BC OF FLAG" STAYS SET.

	LDBR	0			;CLEAR THE BC
	MOVB	BCHI
	MOVB	BCLO
	MOVB	REG1			;CLEAR "DIAG SLVE REQ"
	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	DSLVRQ			;SET "DIAG SLVE REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,AC0		;READ REG 0
	LDBR	373			;SET MASK OF ALL BUT "BC OF FLAG" BIT
	LORB	AC0			;IF BIT IS SET, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF STILL SET, SHOULD BE
	ERROR	TST,"BC OF FLAG" DID NOT STAY SET,
<DIAG SET "BC OF FLAG" THEN LOADED BC WITH ZEROS AND
SET "DIAG SLVE REQ">
;*WRITE REG 0.
;*CHECK THAT "BC OF FLAG" IS CLEARED.

	MOVB	REG0			;WRITE REG 0 TO CLEAR FLAGS
	LDBR	373			;SET MASK OF ALL BUT "BC OF FLAG"
	MOVB	AC0			;MOVE MASK TO AC0
	DATI	REG0,BR			;READ REG 0
	LORCB	AC0			;IF BIT CLEARED, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF CLEARED
	ERROR	TST,"BC OF FLAG" DID NOT CLEAR,
DIAG SET "BC OF FLAG" THEN WROTE REG 0
;*LOAD BC WITH SELECTED DATA PATTERNS THEN CLOCK IT.
;*CHECK THAT "BC OF FLAG" IS NOT SET.

BCOF1:	LDMAR	CTR1			;SET MAR TO LOAD DATA
	GOSUB	BCFTST			;GO LOAD BC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	BCOF1,"BC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED BC WITH 177760 THEN SET "DIAG SLVE REQ"
BCOF2:	LDMAR	CTR2			;SET MAR TO LOAD DATA
	GOSUB	BCFTST			;GO LOAD BC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	BCOF1,"BC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED BC WITH 177417 THEN SET "DIAG SLVE REQ"
BCOF3:	LDMAR	CTR3			;SET MAR TO LOAD DATA
	GOSUB	BCFTST			;GO LOAD BC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	BCOF1,"BC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED BC WITH 170377 THEN SET "DIAG SLVE REQ"
BCOF4:	LDMAR	CTR4			;SET MAR TO LOAD DATA
	GOSUB	BCFTST			;GO LOAD BC AND CLOCK IT
	JMPZ	.+2			;JUMP IF CLEAR
	ERROR	BCOF1,"BC OF FLAG" SET WHEN IT SHOULDN'T HAVE,
DIAG LOADED BC WITH 7777 THEN SET "DIAG SLVE REQ"
	REPEAT	TST
	TEST	230,TEST GENERATION OF "SLVE END XFER"
;*TEST THAT "SLVE END XFER" IS GENERATED WHEN "SLVE END XFER ON BC OVERFLOW" IS
;*SET AND "BC OF FLAG" SETS.

;*CLEAR "SEX ON BC OVERFLOW" BIT.
;*GENERATE "BC OF FLAG".
;*CHECK THAT "SLVE END XFER" IS NOT SET.

	LDBR	377			;FILL BYTE COUNTER
	MOVB	BCLO
	MOVB	BCHI
	LDBR	0
	MOVB	REG1			;CLEAR "SLVE REQ"
	MOVB	REG2			;CLEAR "SEX ON BC"
	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	DSLVRQ			;SET "SLVE REQ" TO SET "BC OF FLAG"
	MOVB	REG1			;AND CLEAR "SEX ON BC" BIT
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,BR			;READ REG3
	SHR				;MOVE "NOT SLVE END XFER" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET (SLVE END XFER=0)
	ERROR	TST,"SLVE END XFER" SET WHEN IT SHOULDN'T HAVE,
DIAG CLEARED "SEX ON BC" AND SET "BC OF FLAG"
;*SET "SEX ON BC OVERFLOW" BIT.
;*CHECK THAT "SLVE END XFER" IS SET.

	LDBR	SEBCOV			;SET "SEX ON BC" BIT
	MOVB	REG2
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,BR			;READ REG3
	SHR				;MOVE "NOT SLVE END XFER" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET (SLVE END XFER=0)
	JMP	.+2			;ELSE, OKAY - SHOULD BE = 1
	ERROR	TST,"SLVE END XFER" DID NOT SET,
DIAG SET "BC OF FLAG" THEN SET "SEX ON BC"
;*WRITE REG 0 TO CLEAR "BC OF FLAG".
;*CHECK THAT "SLVE END XFER" IS CLEARED.

	MOVB	REG0			;CLEAR "BC OF FLAG"
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG3,BR			;READ REG3
	SHR				;MOVE "NOT SLVE END XFER" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET (SLVE END XFER=0)
	ERROR	TST,"SLVE END XFER" DID NOT CLEAR,
DIAG SET "SLVE END XFER" THEN CLEARED "BC OF FLAG"
	REPEAT	TST
	TEST	231,TEST SRR AND CB AND SLVE BUS DRIVERS
;*LOOP DATA PATTERNS FROM THE CB BOARD TO THE SRR TO THE CB REG THEN
;*TO THE SLVE BUS DRIVERS ONTO THE SLVE DATA LINES.

;*SETUP CB BOARD LOOPING.
;*CLEAR CLOCK PHASES AND LOAD ROM ADDR WHERE "ROM 02"=1.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2".
;*CLOCK DATA PATTERN FROM CB BOARD ONTO SLVE DATA LINES.
;*GENERATE 3 SINGLE STEP PULSES TO SET "RUN" AND CLOCK SRR.
;*GENERATE 4 SINGLE STEP PULSES TO CLOCK CB.
;*CLEAR "DIR TO MSTR".
;*CLOCK THE SLAVE DATA LINES INTO THE DR REG ON THE CB BOARD.
;*READ THE DR REG FOR THE CORRECT PATTERN.

	LDMARX	1			;SET MAR EXT BITS
	GOSUB	CBLOOP			;GO SETUP CB BOARD LOOPING
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	^D17			;SET LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	SDPAT&377		;SET MAR TO DATA PATTERN ADDR
	LDBR	BCLKEN			;CLEAR "DX HIGH SPEED" AND ENABLE BASE CLK
	MOVB	REG1
	LDBR	CC4			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02" =1
	GOSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
SDLOOP:	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;TO SET "SLVE RDY DLY 2"
	GOSUB	CLKDT			;GO CLOCK DATA ONTO SLAVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	PULSE4			;CLOCK DATA INTO CB AND CLEAR PHASES
	GOSUB	DEVWR			;GO SETUP DEVICE WRITE
	GOSUB	RDDATA			;GO READ DATA OFF SLVE DATA LINES
	OSM	AC0			;COMPARE IT TO DATA WRIITEN
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	SDLOOP,LOOPED DATA IS INCORRECT,
<DIAG CLOCKED DATA INTO CB REG WITH "DIR TO MSTR" SET THEN
CLEARED "DIR TO MSTR" AND READ SLAVE DATA LINES>
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	SDLOOP			;ELSE, CONTINUE

	REPEAT	TST
	TEST	232,TEST CLEARING OF SRR AND CB
;*SET "DIR TO MSTR".
;*USING CB BOARD LOOPING AND SINGLE STEPPING, CLOCK ALL ONES INTO
;*THE SRR AND CB.
;*DO A HS DP INIT.
;*CLEAR "DIR TO MSTR".
;*CLOCK THE SLAVE DATA LINES INTO THE DR REG ON THE CB BOARD.
;*CHECK THE DR REG FOR ALL ZEROS.

	GOSUB	CBLOOP			;SETUP CB BOARD LOOPING
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	CC4			;SET ROM ADDR TO LOC WITH
	MOVB	DFRMAD			;"ROM 02"=1
	GOSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	GOSUB	DEVRD			;SET DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDMEM	-1			;CLOCK ALL ONES DATA ONTO
	GOSUB	CLKDAT			;SLAVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	PULSE4			;CLOCK DATA INTO CB AND CLEAR PHASES
	MOVB	HSDPIN			;CLEAR SRR AND CLOCK ZEROS INTO CB
	GOSUB	DEVWR			;SETUP DEVICE WRITE
	GOSUB	RDDATA			;READ SLAVE DATA LINES
	OSM	AC0			;CHECK FOR IT
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	TST,"HS DP INIT" DID NOT CLOCK ALL ZEROS INTO CB,
<DIAG LOADED ALL ONES INTO SRR AND CB THEN
DID A HS DP INIT>
;*SET "DIR TO MSTR".
;*USING CB BOARD LOOPING AND SINGLE STEPPING, CLOCK ALL ONES INTO THE SRR.
;*SET "SLVE END XFER" ON THE CB BOARD.
;*CLOCK THE CB.
;*CLEAR "DIR TO MSTR"
;*CLOCK THE SLAVE DATA LINES INTO THE DR REG ON THE CB BOARD.
;*CHECK THE DR REG FOR ALL ZEROS.

SRR1:	GOSUB	DEVRD			;SET DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDMEM	-1			;CLOCK ALL ONES DATA ONTO
	GOSUB	CLKDAT			;SLAVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	SWEX			;GO SET "SLVE END XFER" (CLEARS SRR)
	GOSUB	PULSE4			;CLOCK DATA INTO CB AND CLEAR PHASES
	GOSUB	DEVWR			;SETUP DEVICE WRITE
	GOSUB	RDDATA			;READ SLAVE DATA LINES
	OSM	AC0			;CHECK FOR IT
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	SRR1,"SLVE END XFER" DID NOT CLEAR SRR,
<DIAG LOADED ALL ONES INTO SRR THEN SET "SLVE END XFER"
AND CLOCKED CB>
	GOSUB	CLRSEX			;CLEAR "SLVE END XFER"
	REPEAT	TST
	TEST	233,TEST "SLVE PE"
;*TEST THAT "SLVE PE" SETS WHEN EVEN PARITY DATA IS CLOCKED INTO THE CB
;*AND DOES NOT SET FOR ODD PARITY.

;*SET "DIR TO MSTR".
;*CLOCK ODD PARITY DATA PATTERNS FROM CB BOARD INTO CB.
;*CHECK THAT "SLVE PE" IS NOT SET.

	LDMEM	3			;SETUP ADDITIONAL PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDMARX	1			;SET MAR EXT BITS
	GOSUB	CBLOOP			;GO SETUP CB BOARD LOOPING
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	^D17			;SET LOOP COUNT MINUS 1
	MOVB	AC1
	LDMAR	SDPAT&377		;SET MAR TO DATA PATTERN ADDR
	LDBR	BCLKEN			;CLEAR "DX HIGH SPEED" AND ENABLE BASE CLK
	MOVB	REG1
	LDBR	CC4			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02" =1
	GOSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
SPARLP:	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;TO SET "SLVE RDY DLY 2"
	GOSUB	SETDAT			;GO SETUP DATA FOR ERROR PRINTOUT
	GOSUB	CLKDAT			;GO CLOCK DATA ONTO SLAVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	PULSE4			;CLOCK DATA INTO CB AND CLEAR PHASES
	DATI	REG16,BR		;READ REG 16 FOR "SLVE PE" BIT
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	SPARLP,"SLVE PE" SET WHEN IT SHOULDN'T HAVE,
DIAG CLOCKED GOOD PARITY DATA INTO CB WITH "DIR TO MSTR" SET,PNT
;*CLEAR "DIR TO MSTR" TO ENABLE SLVE BUS DRIVERS.
;*SET AND CLEAR "SLVE ACK" ON CB BOARD TO GATE "DP PE FLAG".
;*CHECK THAT "DP PE FLAG" IS NOT SET.

	GOSUB	DEVWR			;SETUP DEVICE WRITE
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	CLRFLG			;CLEAR "DP PE FLAG"
	MOVB	CSR0
	MOVB	SLAK25			;CLOCK "DP PE FLAG"
	NOP				;DELAY BEFORE DOING DATI
	DATI	CSR0,AC0		;READ "DP PE FLAG"
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	MOV	AC0,BR			;MOVE BIT TO BR FOR TESTING
	SHR				;MOVE BIT TO BIT 4
	JMPB4	.+2			;JUMP IF "DP PE FLAG" SET, SHOULDN'T HAVE
	JMP	.+2			;ELSE, OKAY
	ERROR	SPARLP,"DP PE FLAG" ON CB BOARD SET WHEN IT SHOULDN'T HAVE,
<DIAG CLOCKED DATA INTO CB REG THEN CLEARED "DIR TO MSTR"
AND SET "SLVE ACK" ON CB BOARD>,PNT
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	SPARLP			;ELSE, CONTINUE

;*SET "DIR TO MSTR".
;*CLOCK ALL ZEROS EVEN PARITY DATA INTO CB FROM CB BOARD.
;*CHECK THAT "SLVE PE" IS SET.
;*SET "DIR TO MSTR".

SPAR1:	GOSUB	DEVRD			;SET DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE AND CLEAR EV PAR BIT
	MOVB	CSR1			;AND CHANNEL MODE
	LDBR	-1			;CLOCK ALL ZEROS (INCLUDING PARITY BIT)
	GOSUB	CLKIT			;ONTO SLAVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	PULSE4			;CLOCK DATA INTO CB AND CLEAR PHASES
	DATI	REG16,BR		;READ REG 16 FOR "SLVE PE"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	SPAR1,"SLVE PE" DID NOT SET,
<DIAG CLOCKED EVEN PARITY DATA (ALL ZER0S)
INTO CB REG WITH "DIR TO MSTR" SET>
	LDMAR	0			;CLEAR MAR
SPAR2:	GOSUB	DEVRD			;SET DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDMEM	-1			;CLOCK ALL ONES DATA ONTO
	GOSUB	CLKDAT			;SLAVE DATA LINES
	GOSUB	SWEX			;GO SET "SLVE END XFER" (CLEARS SRR)
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	PULSE4			;CLOCK DATA INTO CB AND CLEAR PHASES
	DATI	REG16,BR		;READ REG 16 FOR "SLVE PE" BIT
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERROR	SPAR2,"SLVE PE" SET WHEN IT SHOULDN'T HAVE,
DIAG SET "SLVE END XFER" THEN CLOCKED CB WITH "DIR TO MSTR" SET
	GOSUB	CLRSEX			;CLEAR "SLVE END XFER"
	REPEAT	TST
	TEST	234,TEST "DP PE FLAG" USING "SLVE PE"
;*SETUP CB BOARD LOOPING AND CLEAR CLOCK PHASES.
;*LOAD ROM ADDR WHERE "ROM 02"=1.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEP.
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2".
;*CLOCK ALL ZEROS, EVEN PARITY DATA ONTO THE SLVE DATA LINES.
;*GENERATE 3 SINGLE STEP PULSES TO CLOCK THE SRR AND SET "RUN".
;*GENERATE 3 MORE SINGLE STEP PULSES TO CLOCK THE CB AND SET "SLVE PE".
;*CHECK THAT "DP PE FLAG" IS NOT SET YET.

	MOVB	REG0			;CLEAR FLAGS
	GOSUB	CBLOOP			;SETUP CB BOARD LOOPING
	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	CC4			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02"=1
	GOSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	LOOPEN+CHANL		;SET LOOP ENABLE, CLEAR EV PAR
	MOVB	CSR1			;AND SET CHANNEL MODE
	LDBR	-1			;CLOCK ALL ZEROS, EVEN PARITY DATA ONTO
	GOSUB	CLKIT			;THE SLVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	PULSE3			;CLOCK DATA INTO CB
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	TST,"DP PE FLAG" SET BEFORE IT SHOULD HAVE,
<DIAG SET "CC 2" AND "DIR TO MSTR" AND "SLVE PE" THEN
GENERATED 3 SINGLE STEP PULSES>
;*GENERATE A SINGLE STEP PULSE TO CLOCK "DP PE FLAG".
;*CHECK THAT IT IS SET.

	MOVB	CLKPLS			;GEN ANOTHER SINGLE STEP PULSE
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"DP PE FLAG" DID NOT SET,
<DIAG SET "CC 2" AND "DIR TO MSTR" AND "SLVE PE" THEN
GENERATED 4 SINGLE STEP PULSES>
;*CHECK THAT "DP PE FLAG" GENERATES AN INTERRUPT.

	JMPI	ZRTN			;JUMP IF INTERRUPT OCCURRED
	JMPZ	.+2			;JUMP IF INTERRUPT OCCURRED
	ERROR	TST,"DP PE FLAG" DID NOT CAUSE INTERRUPT
;*CLEAR "ROM 02" AND SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES TO CLOCK "DP PE FLAG".
;*CHECK THAT "DP PE FLAG" STAYS SET.

	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	ZEROS			;CLEAR "CC 2"
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;CLOCK "DP PE FLAG" FLOP AGAIN
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"DP PE FLAG" DID NOT STAY SET,
<DIAG SET "DP PE FLAG" THEN CLEARED "CC 2" AND
GENERATED 4 SINGLE STEP PULSES>
;*WRITE REG 0.
;*CHECK THAT "DP PE FLAG" IS CLEARED.

	MOVB	REG0			;CLEAR FLAGS
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	TST,"DP PE FLAG" DID NOT CLEAR,
DIAG SET "DP PE FLAG" THEN WROTE REG 0
;*SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES.
;*CHECK THAT "DP PE FLAG" IS NOT SET. ("CC 2"=0)

SDDPE1:	MOVB	REG0			;CLEAR FLAG
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE4			;CLOCK "DP PE FLAG" FLOP
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	SDDPE1,"DP PE FLAG" SET WHEN IT SHOULDN'T HAVE,
<DIAG SET "SLVE PE" AND "DIR TO MSTR" AND CLEARED "CC 2"
THEN GENERATED 4 SINGLE STEP PULSES>
;*SET "DIR TO MSTR" AND "ROM 02".
;*SET "RUN" AND GENERATE 2 SINGLE STEP PULSES.
;*CLEAR "DIR TO MSTR".
;*GENERATE 2 MORE SINGLE STEP PULSES.
;*CHECK THAT "DP PE FLAG" IS NOT SET.

SDDPE2:	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	REG0			;CLEAR FLAG
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	CC4			;SET "CC 2"
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	GOSUB	PULSE2			;CLOCK DATA INTO CB
	GOSUB	DEVWR			;SETUP DEVICE WRITE
	GOSUB	PULSE2			;CLOCK "DP PE FLAG" FLOP
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	SDDPE2,"DP PE FLAG" SET WHEN IT SHOULDN'T HAVE,
<DIAG SET "SLVE PE" AND "CC 2" AND CLEARED "DIR TO MSTR" THEN
CLOCKED THE "DP PE FLAG" FLOP>
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2".
;*CLOCK ALL ZEROS ODD PARITY DATA ONTO THE SLVE DATA LINES.
;*GENERATE 3 SINGLE STEP PULSES TO CLOCK THE SRR AND SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES TO CLOCK CB AND CLEAR "SLVE PE" AND
;*CLOCK "DP PE FLAG" FLOP.
;*CHECK THAT "DP PE FLAG" IS NOT SET.

SDDPE3:	MOVB	REG0			;CLEAR FLAG
	GOSUB	DEVRD			;SET DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	GOSUB	CBLOOP			;SETUP FOR GOOD PARITY
	LDMEM	0			;CLOCK ALL ZEROS, ODD PARITY DATA ONTO
	GOSUB	CLKDAT			;THE SLVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET "RUN"
	GOSUB	PULSE4			;CLOCK "DP PE FLAG" FLOP
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	SDDPE3,"DP PE FLAG" SET WHEN IT SHOULDN'T HAVE,
<DIAG SET "CC 2" AND "DIR TO MSTR" AND CLEARED "SLVE PE"
THEN GENERATED 4 SINGLE STEP PULSES>
	REPEAT	TST
	TEST	235,TEST CLEARING OF AR BY HS DP INIT
;*CHECK THAT DOING A HS DP INIT CLEARS THE AR.  SINCE DEMUX HAS NOT BEEN
;*TESTED YET, LOAD AR USING ALL SHIFT VALUES WITH MASK OF ALL ONES.

;*SETUP CB BOARD LOOPING.
;*CLEAR THE CLOCK PHASES.
;*LOAD ROM ADDR FOR SHIFT=0 AND MASK=ALL 1'S.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2" WITH A HS DP INIT.
;*CLOCK ALL ONES DATA ONTO SLVE DATA LINES.
;*GENERATE 3 SINGLE STEP PULSES TO CLOCK SRR AND SET "RUN".
;*GENERATE 4 SINGLE STEP PULSES TO CLOCK CB AND ENABLE THEN DISABLE DEMUX.
;*DO A HS DP INIT.
;*CHECK THAT THE AR IS ALL ZEROS.
;*REPEAT PROCEDURE FOR ALL SHIFT VALUES (0-15).

	LDMAR	0			;RESET MAR TO ZERO
	LDMEM	4			;SET ADDITIONAL PNT ROUTINE NUMBER
	GOSUB	SETPNT
	LDMARX	1			;SET MAR EXT BITS
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	GOSUB	CBLOOP			;SETUP CB BOARD LOOPING
	LDBR	0			;INIT SHIFT COUNT VALUE
	MOVB	AC1
ARLP:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	DSHF0			;START ADDR OF DEMUX SHIFT PROGS
	ADB	AC1,BR			;INDEX BY SHIFT COUNT VALUE
	MOVB	DFRMAD
	GOSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	GOSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDMAR	0			;CLEAR MAR
	LDMEM	-1			;CLOCK ALL ONES DATA ONTO
	GOSUB	CLKDAT			;THE SLVE DATA LINES
	GOSUB	PULSE3			;CLOCK DATA INTO SRR AND SET RUN
	GOSUB	PULSE4			;CLOCK CB THEN ENABLE AND DISABLE DEMUX
	MOVB	HSDPIN			;CLEAR AR
	LDBR	AR0S&377,MAR		;SET ZEROS DATA ADDR
	MOVB	AC2			;PUT IT IN AC2 ALSO
	GOSUB	ARCHK			;GO CHECK AR FOR ALL ZEROS
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERROR	ARLP,AR NOT CLEARED BY HS DP INIT,
DIAG LOADED DATA INTO AR THEN DID A HS DP INIT,PNT
	INCR	AC1			;INC SHIFT COUNT VALUE
	MOV	AC1,BR			;MOVE TO BR FOR TESTING
	JMPB4	.+2			;JUMP IF ALL 16 SHIFTS TESTED.
	JMP	ARLP			;ELSE, CONTINUE

	REPEAT	TST
	JUMP	NXTBNK			;JUMP TO NEXT BANK OF CRAM
	.LOC	2000
NXTBNK:
	TEST	236,TEST DEMUX MASKING
;*TEST DEMUX MASKING BY PUTTING ALL ONES DATA INTO THE CB THEN SETTING
;*MASKS OF ALL ONES, ALL ZEROS, AND FLOATING ONES.  CHECK THE AR FOR
;*CORRECTLY MASKED DATA.

;*CLEAR CLOCK PHASES.
;*SETUP CB BOARD LOOPING.
;*LOAD ROM ADDR FOR PROG WITH ALL ONES MASK AND SHIFT=0.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2" WITH HS DP INIT.
;*CLOCK ALL ONES DATA ONTO SLAVE DATA LINES.
;*GENERATE 3 SINGLE STEP PULSES TO CLOCK SRR AND SET "RUN".
;*GENERATE 3 MORE SINGLE STEP PULSES TO CLOCK CB AND ENABLE DEMUX.
;*CHECK THAT AR BITS 7-0 ARE ONES.

	LDMAR	0			;CLEAR MAR
	LDMEM	5			;SETUP ADDITIONAL PNT ROUTINE NUMBER
	JMPSUB	SETPNT
	LDMARX	1			;SET MAR EXT BITS FOR 2ND 256 WORD BLOCK
	LDBR	BCLKEN			;ENABLE BASE CLK
	MOVB	REG1
	JMPSUB	CBLOOP			;SETUP LOOPING ON CB BOARD
	LDBR	RMADR8			;SET ROM ADR BIT 8
	MOVB	REG2
	LDBR	DSHF0			;LOAD ROM ADR FOR ALL ONES MASK
	MOVB	DFRMAD
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDMEM	-1			;SETUP ALL ONES DATA
	JMPSUB	CLKDAT			;CLOCK IT ONTO THE SLVE DATA LINES
	JMPSUB	PULSE3			;CLOCK DATA INTO THE SRR AND SET "RUN"
	JMPSUB	PULSE3			;SET "EN MUX/DEMUX"
	LDBR	AR1S&377,MAR		;SET MAR TO CORRECT DATA
	MOVB	AC2			;PUT IT IN AC2 ALSO
	LDBR	-1			;SETUP MASK
	MOVB	AC3
	JMPSUB	ARCHK			;CHECK AR FOR CORRECT DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERROR	TST,AR DATA FROM DEMUX IS INCORRECT,,PNT
;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR TO CLOCK CB.
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2" WITH HS DP INIT.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*CLOCK ALL ONES DATA ONTO SLAVE DATA LINES.
;*SET "RUN" AND CLEAR "DX HIGH SPEED".
;*LOAD ROM ADDR FOR ZERO MASK, THIS CLEARS "ROM 02" WHICH CLOCKS CB.
;*GENERATE 3 SINGLE STEP PULSES TO ENABLE DEMUX.
;*CHECK THAT AR BITS 7-0 ARE ALL ZEROS.

DMSK:	LDMAR	0			;REINIT MAR
	LDBR	BCLKEN			;ENABLE BASE CLK
	MOVB	REG1
	LDBR	CC4			;SET ROM TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02"=1
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	LDMEM	-1			;SETUP ALL ONES DATA
	JMPSUB	CLKDAT			;CLOCK IT ONTO THE SLVE DATA LINES
	MOVB	SETRUN			;CLEAR "CLR RUN"
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	MSK0			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;ALL ZEROS MASK
	JMPSUB	PULSE3			;SET "EN MUX/DEMUX"
	LDBR	AR0S&377,MAR		;SET MAR TO ALL ZEROS CORRECT DATA
	MOVB	AC2			;PUT IT IN AC2 ALSO
	LDBR	0			;SETUP MASK FOR PRINTOUT
	MOVB	AC3
	JMPSUB	ARCHK			;GO CHECK AR DATA
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERROR	DMSK,AR DATA FROM DEMUX IS INCORRECT,,PNT
;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR TO CLOCK CB.
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2" WITH HS DP INIT.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*CLOCK ALL ONES DATA ONTO SLAVE DATA LINES.
;*SET "RUN" AND CLEAR "DX HIGH SPEED".
;*LOAD ROM ADDR FOR TEST MASK, THIS CLEARS "ROM 02" WHICH CLOCKS CB.
;*GENERATE 3 SINGLE STEP PULSES TO ENABLE DEMUX.
;*CHECK AR BITS 7-0 FOR CORRECT MASKED DATA.
;*REPEAT FOR EIGHT 1-BIT MASKS.

	LDBR	ARDA0&377		;START ADDR OF CORRECT DATA
	MOVB	AC2
	LDBR	0			;INIT MASK INDEX
	MOVB	AC1
	LDBR	1			;INIT MASK
	MOVB	AC3
DMSKLP:	LDMAR	0			;REINIT MAR
	LDBR	BCLKEN			;ENABLE BASE CLK
	MOVB	REG1
	LDBR	CC4			;SET ROM TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 02"=1
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	LDMEM	-1			;SETUP ALL ONES DATA
	JMPSUB	CLKDAT			;CLOCK IT ONTO THE SLVE DATA LINES
	MOVB	SETRUN			;CLEAR "CLR RUN"
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	MSK1			;START OF ROM MASK LOC
	ADB	AC1,BR			;INDEX BY MASK INDEX
	MOVB	DFRMAD
	JMPSUB	PULSE3			;SET "EN MUX/DEMUX"
	MOV	AC2,MAR			;SET MAR TO CORRECT DATA ADDR
	JMPSUB	ARCHK			;GO CHECK AR DATA
	JMPZ	.+2			;JUMP IF ALL ZEROS
	ERROR	DMSKLP,AR DATA FROM DEMUX IS INCORRECT,,PNT
	SHLR	AC3			;SHIFT MASK
	LDBR	3			;ADVANCE CORRECT DATA POINTER
	ADBR	AC2
	INCR	AC1			;INC MASK INDEX
	SHL	AC1,BR			;SHIFT IT AND PUT IN BR
	JMPB4	.+2			;JUMP IF ALL 8 MASKS TESTED
	JMP	DMSKLP			;ELSE, CONTINUE

	REPEAT	TST
	TEST	237,TEST DEMUX SHIFTING
;*FOR EACH SHIFT COUNT VALUE (0-15), CLOCK FLOATING ONES PATTERNS
;*FROM THE CB BOARD THRU THE DEMUX AND INTO THE AR.

;*SETUP CB BOARD LOOPING.
;*CLEAR CLOCK PHASES AND LOAD ROM ADDR FOR DESIRED SHIFT COUNT.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2".
;*CLOCK DATA FROM CB BOARD ONTO SLVE DATA LINES.
;*GENERATE 3 SINGLE STEP PULSES TO CLOCK SRR AND SET "RUN".
;*GENERATE 3 MORE SINGLE STEP PULSES TO CLOCK CB AND ENABLE DEMUX.
;*CHECK AR FOR CORRECTED SHIFTED DATA.

	LDBR	0			;SETUP SHIFT COUNT VALUE
	MOVB	AC3,MAR			;AND CLEAR MAR
	LDMEM	6			;SETUP ADDITIONAL PNT ROUTINE #
	JMPSUB	SETPNT
	LDMARX	1			;SETUP MAR EXT BITS
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	JMPSUB	CBLOOP			;SETUP LOOPING ON CB BOARD
DMXLPO:	LDBR	DPDAT&377		;SETUP LOAD DATA POINTER
	MOVB	AC1
	LDBR	ARDATS&377		;GET ADDR OF "CORRECT DATA START ADDR" TABLE
	ADB	AC3,MAR			;INDEX BY SHIFT COUNT AND SET MAR WITH ADDR
	MOVMEM	AC2			;SET AC2 TO BE CORRECT DATA POINTER
DMXLPI:	LDBR	BCLKEN			;ENABLE BASE CLK ANDCLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	DSHF0			;START ADDR OF DEMUX SHIFT PROGS
	ADB	AC3,BR			;INDEX BY SHIFT COUNT
	MOVB	DFRMAD			;LOAD THAT ADDR
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDMAR	0			;SET MAR TO LOC 0
	MOV	AC2,MEM			;SAVE CORRECT DATA PTR THERE
	MOV	AC1,MAR			;SET MAR TO LOAD DATA ADDR
	JMPSUB	SETDAT			;SETUP DEMUX SHIFT CNT FOR PRINTOUT
	JMPSUB	CLKDAT			;GO CLOCK DATA INTO SRR FROM CB BOARD
	JMPSUB	PULSE3			;CLOCK DATA INTO SRR AND SET "RUN"
	JMPSUB	PULSE3			;SET "EN MUX/DEMUX"
	LDMAR	0			;SET MAR TO LOC 0
	MOVMEM	AC2,MAR			;RESTORE CORRECT DATA ADDR
	JMPSUB	ARCHK			;GO CHECK CONTENTS OF AR
	JMPZ	.+2			;JUMP IF CORRECT
	ERROR	DMXLPI,AR DATA FROM DEMUX INCORRECT,,PNT
	LDBR	3			;SETUP CONSTANT
	ADBR	AC2			;ADVANCE CORRECT DATA POINTER
	INCR	AC1			;INCREMENT LOAD DATA POINTER
	MOV	AC1,MAR			;SET MAR TO POINT TO LOAD DATA
	MOVMEM	BR			;MOVE LOAD DATA TO CHECK FOR ONES
	JMPZ	.+2			;JUMP IF DONE, ALL ONES MARKS END
	JMP	DMXLPI			;ELSE CONTINUE
	INCR	AC3			;INCREMENT ROM ADDR
	MOV	AC3,BR			;MOVE INDEX TO BR
	JMPB4	.+2			;JUMP IF TESTED ALL SHIFTS (16)
	JMP	DMXLPO			;ELSE CONTINUE

	REPEAT	TST
	TEST	238,TEST AR TO CB GATING
;*CLOCK DATA FROM THE CB BOARD INTO BITS 8-1 OF THE AR WITH "DIR TO MSTR" SET.
;*THEN CLEAR "DIR TO MSTR" AND CLOCK THE AR DATA INTO THE CB.

;*SETUP CB BOARD LOOPING AND CLEAR THE CLOCK PHASES.
;*LOAD ROM ADDR FOR PROGRAM WHICH LOADS AR.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEP.
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2".
;*CLOCK DATA FROM CB BOARD ONTO SLVE DATA LINES.
;*GENERATE 7 SINGLE STEP PULSES TO LOAD BITS 7-0 OF AR.
;*CLOCK NEXT DATA FROM CB BOARD ONTO SLVE DATA LINES.
;*GENERATE 7 SINGLE STEP PULSES TO LOAD BITS 15-8 OF AR.
;*CLEAR "DIR TO MSTR" AND SET "RUN".
;*GENERATE 2 SINGLE STEP PULSES TO CLOCK AR BITS 8-1 INTO CB.
;*READ SLVE DATA LINES FROM CB BOARD AND CHECK DATA.

	LDMARX	1			;SET MAR EXT BITS
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	JMPSUB	CBLOOP			;GO SETUP CB BOARD LOOPING
	LDBR	^D9			;SET LOOP COUNT MINUS 1
	MOVB	AC1
	LDBR	SDPAT&377		;SETUP CORRECT DATA ADDR IN AC3
	MOVB	AC3
	LDBR	CBPAT&377		;SETUP LOAD DATA IN AC2
	MOVB	AC2
ARCB:	LDBR	BCLKEN			;CLEAR "DX HIGH SPEED" AND ENABLE BASE CLK
	MOVB	REG1
	LDBR	DMXSHF			;SETUP FOR ROM PROGRAM TO LOAD AR
	MOVB	DFRMAD
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;TO SET "SLVE RDY DLY 2"
	MOV	AC2,MAR			;SET MAR TO LOAD DATA ADDR
	JMPSUB	CLKDAT			;GO CLOCK DATA ONTO SLAVE DATA LINES
	JMPSUB	PULSE7			;CLOCK DATA INTO AR 7-0
	IMAR				;INC LOAD DATA ADDR
	JMPSUB	CLKDAT			;CLOCK NEXT 8 DATA BITS INTO
	JMPSUB	PULSE7			;AR BITS 15-8
	JMPSUB	DEVWR			;GO SETUP DEVICE WRITE
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE2			;CLOCK AR DATA INTO CB
	JMPSUB	RDDATA			;GO READ DATA OFF SLVE DATA LINES
	MOV	AC3,MAR			;SET MAR TO CORRECT DATA
	OSM	AC0			;COMPARE IT TO DATA WRIITEN
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	ARCB,CB DATA FROM AR IS INCORRECT,
<DIAG LOADED AR (8-1) WITH DATA PATTERN THEN CLEARED
"DIR TO MSTR" AND CLOCKED AR DATA INTO CB>
	INCR	AC3			;INC CORRECT DATA POINTER
	INCR	AC2			;INC LOAD DATA POINTER
	INCR	AC2
	DECR	AC1,I			;DEC LOOP COUNT AND INC PATTERN ADDR
	JMPZ	.+2			;JUMP IF DONE
	JMP	ARCB			;ELSE, CONTINUE

	REPEAT	TST
	TEST	239,TEST MUX MASKING
;*TEST MUX MASKING BY PUTTING ALL ONES DATA INTO THE SB THEN SETTING
;*MASKS OF ALL ONES, ALL ZEROS, AND FLOATING ONES.  CHECK THE AR FOR
;*CORRECTLY MASKED DATA.

;*SETUP CB BOARD LOOPING.
;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR FOR MASK OF ALL ONES.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SET "DIR TO MSTR".
;*DO A HS DP INIT TO CLOCK ALL 1'S INTO SB FROM "NOT" AR.
;*SET "RUN" AND GENERATE A SINGLE STEP PULSE TO CLOCK SB AGAIN.
;*CLEAR "DIR TO MSTR".
;*GENERATE 3 MORE SINGLE STEP PULSES TO ENABLE THEN DISABLE MUX.
;*CHECK AR BITS 8-1 FOR ALL ONES.

	LDMAR	0			;CLEAR MAR
	LDMEM	7			;SETUP ADDITIONAL PNTROUTINE NUMBER
	JMPSUB	SETPNT
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	JMPSUB	CBLOOP			;SETUP CB BOARD LOOPING
	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	MSK1S			;SET ROM ADDR FOR ALL ONES MASK
	MOVB	DFRMAD
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;CLOCK 1'S INTO SB FROM AR
	MOVB	SETRUN			;SET "RUN"
	MOVB	CLKPLS			;CLOCK SB
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	JMPSUB	PULSE2			;ENABLE MUX
	LDMEM	-1			;SET MEM TO CORRECT DATA
	JMPSUB	ARCHK7			;GO CHECK FOR CORRECT AR DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	TST,AR DATA FROM MUX IS INCORRECT,
<DIAG CLOCKED ONES INTO SB BITS 7-0 THEN CLEARED AR
AND ENABLED MUX WITH SHIFT COUNT=0 AND MASK=377>
;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR FOR MASK OF ALL ZEROS.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SET "DIR TO MSTR".
;*DO A HS DP INIT TO CLOCK ALL 1'S INTO SB FROM "NOT" AR.
;*CLEAR "DIR TO MSTR".
;*SET "RUN" AND GENERATE 4 SINGLE STEP PULSES TO ENABLE THEN DISABLE MUX.
;*CHECK AR BITS 8-1 FOR ALL ZEROS.

MMSK:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	MSK0			;SET ROM ADDR FOR ZERO MASK
	MOVB	DFRMAD			;THIS CLOCK SB.
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;CLOCK 1'S INTO SB FROM AR
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE4			;ENABLE MUX
	LDMEM	0			;SETUP CORRECT DATA
	JMPSUB	ARCHK7			;CHECK FOR CORRECT AR DATA
	JMPZ	.+2			;JUMP IF CORRECT, ALL ZEROS
	ERRORM	TST,AR DATA FROM MUX IS INCORRECT,
<DIAG CLOCKED ONES INTO SB BITS 7-0 THEN CLEARED AR
AND ENABLED MUX WITH SHIFT COUNT=0 AND MASK=0>
;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR FOR DESIRED MASK.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SET "DIR TO MSTR".
;*DO A HS DP INIT TO CLOCK ALL 1'S INTO SB FROM "NOT" AR.
;*CLEAR "DIR TO MSTR".
;*SET "RUN" AND GENERATE 4 SINGLE STEP PULSES TO ENABLE THEN DISABLE MUX.
;*CHECK AR BITS 8-1 FOR CORRECTLY MASKED DATA.

	LDMARX	2			;SET MAR EXT BITS
	LDMAR	ARDM0&377		;SETUP CORRECT DATA START ADDR
	LDBR	0			;INIT MASK INDEX
	MOVB	AC1
MMSKLP:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	MSK1			;START ADDR OF ROM MASK LOCS
	ADB	AC1,BR			;INDEX BY MASK INDEX
	MOVB	DFRMAD			;LOAD ADDR, CLOCKS SB
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;CLOCK 1'S INTO SB FROM AR
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE4			;ENABLE MUX
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP10			;STORE MASK FOR PRINTOUT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	JMPSUB	ARCHK7			;CHECK FOR CORRECT AR DATA
	JMPZ	.+2			;JUMP IF CORRECT, ALL ZEROS
	ERRORM	MMSKLP,AR DATA FROM MUX IS INCORRECT,,PNT
	INCR	AC1,I			;INC MASK INDEX AND CORRECT DATA ADDR
	SHL	AC1,BR			;SHIFT IT AND PUT IN BR
	JMPB4	.+2			;JUMP IF TESTED ALL 8 MASKS
	JMP	MMSKLP			;ELSE, CONTINUE

	REPEAT	TST
	TEST	240,TEST MUX SHIFTING
;*FOR EACH SHIFT COUNT VALUE (0-15), CLOCK FLOATING ONES PATTERNS INTO THE
;*SB FROM THE CB BOARD.  THEN CLEAR "DIR TO MSTR" AND CLOCK THE PATTERN
;*THRU THE MUX AND INTO THE AR.

;*SETUP CB BOARD LOOPING.
;*CLEAR THE CLOCK PHASES.
;*LOAD ROM ADDR FOR PROG TO LOAD AR FROM THE CB BOARD.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SET "DIR TO MSTR" AND "SLVE RDY DLY 2" WITH A HS DP INIT.
;*USING SINGLE STEPPING, CLOCK FLOATING PATTERN INTO AR.
;*LOAD ROM ADDR FOR MUX SHIFTING.
;*SET "RUN" AND GENERATE A SINGLE STEP PULSE TO CLOCK SB.
;*CLEAR "DIR TO MSTR".
;*GENERATE 3 MORE SINGLE STEP PULSES TO ENABLE THEN DISABLE MUX.
;*CHECK AR FOR CORRECT SHIFTED DATA.

	LDBR	0			;INITIALIZE MUX SHIFT COUNT
	MOVB	AC1,MAR			;AND CLEAR MAR
	LDMEM	8			;SET ADDITIONAL PNT ROUTINE NUMBER
	JMPSUB	SETPNT
	JMPSUB	CBLOOP			;SETUP CB BOARD LOOPING
	LDMARX	2			;SET MAR EXT BITS FOR 3RD 256 WORD BLOCK
MUXLPO:	LDBR	ARDATM&377		;START OF "CORRECT MUX DATA ADDR" TABLE
	ADB	AC1,MAR			;INDEX INTO TABLE AND SET MAR
	MOVMEM	AC2			;SETUP CORRECT DATA ADDR
	LDBR	MUXDAT&377,MAR		;INITIALIZE LOAD DATA ADDR
	MOVB	AC3
MUXLPI:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	DMXSHF			;SET ROM ADDR TO LOAD AR
	MOVB	DFRMAD
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP12,I		;STORE LOAD DATA FOR PRINTOUT
	MOVMEM	MPGP13,I
	MOVMEM	MPGP16
	MOV	AC3,MAR			;RESTORE MAR
	MOV	AC1,BR			;GET SHIFT CNT
	MOVB	MPGP17			;STORE IT FOR PRINTOUT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	JMPSUB	CLKDT			;CLOCK TABLE DATA INTO SRR
	JMPSUB	PULSE7			;CLOCK DATA INTO AR BITS 7-0
	IMAR				;INC LOAD DATA ADDR
	JMPSUB	CLKDT			;CLOCK NEXT DATA INTO SRR
	JMPSUB	PULSE7			;CLOCK DATA INTO AR BITS 15-8
	IMAR				;INC LOAD DATA ADDR
	JMPSUB	CLKDT			;CLOCK NEXT DATA INTO SRR
	JMPSUB	PULSE7			;CLOCK DATA INTO AR BITS 17-16
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	MSHF0			;START ADDR OF MUX SHIFT PROGS
	ADB	AC1,BR			;INDEX BY SHIFT CNT
	MOVB	DFRMAD			;LOAD ROM ADDR WITH DESIRED MUX SHIFT LOC
	MOVB	SETRUN			;SET "RUN"
	MOVB	CLKPLS			;CLOCK SB
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	JMPSUB	PULSE2			;ENABLE MUX
	MOV	AC2,MAR			;SET MAR TO CORRECT DATA ADDR
	JMPSUB	ARCHK7			;GO CHECK FOR CORRECT AR DATA
	JMPZ	.+2			;JUMP IF CORRECT
	ERRORM	MUXLPI,AR DATA FROM MUX INCORRECT,,PNT
	INCR	AC2			;INC CORRECT DATA ADDR
	LDBR	3			;ADVANCE LOAD DATA ADDR
	ADBR	AC3
	MOV	AC3,MAR			;SET MAR TO LOAD DATA
	MOVMEM				;CHECK FOR ALL ONES END OF DATA MARKER
	JMPZ	.+2			;JUMP IF AT END OF TABLE
	JMP	MUXLPI			;ELSE, CONTINUE
	INCR	AC1			;INC MUX SHIFT COUNT
	MOV	AC1,BR			;MOVE IT TO BR
	JMPB4	.+2			;JUMP IF DONE ALL SHIFTS
	JMP	MUXLPO			;ELSE, CONTINUE

	REPEAT	TST
	TEST	241,TEST GENERATING "MSTR REQ" ON MB BOARD
;*TEST THAT "MSTR REQ" SETS AND CLEARS CORRECTLY ON THE MASSBUS
;*DATA BOARD.

;*ENABLE SINGLE STEPPING AND SET "DX HIGH SPEED".
;*CLEAR "MSTR RDY DLY 2".
;*SETUP THE RH20 FOR A WRITE XFER.
;*SET THE "START" BIT.
;*CHECK THAT "MSTR REQ" IS SET.

	JMPSUB	ABTXFR			;ABORT THE XFER
	LDBR	5			;SETUP DATA PATTERN NUMBER
	MOVB	AC0
	JMPSUB	SETCNT			;GO SETUP HOST DATA FOR XFER
	LDBR	0			;ENABLE SINGLE STEP
	MOVB	REG1
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	DEVRD			;SETUP FOR DEVICE READ
	MOVB	HSDPIN			;CLEAR "MSTR RDY DLY 2"
	JMPSUB	STXFRW			;SETUP FOR A DEVICE WRITE XFER
	JMPSUB	STRMB			;START THE XFER, SET "MSTR REQ"
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET
	ERROR	TST,"MSTR REQ" DIDN'T SET,
DIAG STARTED A DEVICE WRITE XFER
;*SEND "EBL" TO ABORT PREVIOUS XFER.
;*SETUP FOR A WRITE XFER AND SET "MSTR REQ".
;*DO A MICROBUS INIT.
;*CHECK THAT "MSTR REQ" IS CLEARED.

MRQ1:	JMPSUB	ABTXFR			;END THE XFER
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	DEVRD			;SET "DIR TO MSTR"
	MOVB	HSDPIN			;CLEAR "MSTR RDY DLY 2"
	JMPSUB	STXFRW			;SETUP FOR A DEVICE WRITE XFER
	JMPSUB	STRMB			;START THE XFER, SET "MSTR REQ"
	JMPSUB	INITL			;DO A DEVICE RESET
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	MRQ1,"MSTR REQ" DIDN'T CLEAR,
DIAG SET "MSTR REQ" THEN DID A DEVICE RESET
;*SEND "EBL" TO ABORT PREVIOUS XFER.
;*SETUP FOR A WRITE XFER AND SET "MSTR REQ".
;*CLEAR "DX HIGH SPEED".
;*CHECK THAT "MSTR REQ" IS CLEARED.

MRQ2:	JMPSUB	ABTXFR			;END THE XFER
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	DEVRD			;SET "DIR TO MSTR"
	MOVB	HSDPIN			;CLEAR "MSTR RDY DLY 2"
	JMPSUB	STXFRW			;SETUP FOR A DEVICE WRITE XFER
	JMPSUB	STRMB			;START THE XFER, SET "MSTR REQ"
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEARED
	ERROR	MRQ2,"MSTR REQ" DIDN'T CLEAR,
DIAG SET "MSTR REQ" THEN CLEARED "DX HIGH SPEED"
;*SEND "EBL" TO ABORT THE PREVIOUS XFER.
;*DO A MICROBUS INIT TO CLEAR "MSTR REQ".
;*SET "MSTR RDY DLY 2".
;*SET "MSTR REQ", THIS SHOULD GENERATE "MSTR ACK" WHICH SHOULD CLEAR
;*"MSTR REQ".
;*WAIT FOR "MSTR REQ" TO SET AGAIN.

MRQ3:	JMPSUB	ABTXFR			;ABORT THE XFER
	JMPSUB	INITL			;CLEAR "MSTR REQ" ON MB BOARD
	LDBR	BCLKEN			;ENABLE BASE CLK
	MOVB	REG1
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	CC0			;CLEAR CC BITS
	MOVB	DFRMAD
	LDBR	BCLKEN+DXHISP		;SET "DX HIGH SPEED" AND ENABLE BASE CLK
	MOVB	REG1
	JMPSUB	STXFRW			;SETUP FOR A DEVICE WRITE XFER
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	JMPSUB	STRMB			;START THE XFER, SET "MSTR REQ"
	DATI	REG1			;DELAY UNTIL "MSTR REQ" HAS TIME TO SET AGAIN
	DATI	REG1			;DELAY UNTIL "MSTR REQ" HAS TIME TO SET AGAIN
	DATI	REG1			;DELAY UNTIL "MSTR REQ" HAS TIME TO SET AGAIN
	DATI	REG1
	DATI	REG1
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET, SHOULD BE
	ERROR	MRQ3,"MSTR REQ" DIDN'T SET,
DIAG SET "MSTR REQ" ON MB BOARD THEN SET AND CLEARED "MSTR ACK"
;*SEND "EBL" TO ABORT PREVIOUS XFER.
;*DO A MICROBUS INIT TO CLEAR "MSTR REQ".
;*SETUP FOR A READ XFER AND SET "START".
;*CHECK THAT "MSTR REQ" IS SET.

MRQ4:	JMPSUB	ABTXFR			;END THE XFER
	JMPSUB	INITL			;CLEAR "MSTR REQ" ON MB BOARD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	STXFRR			;SETUP FOR A DEVICE READ XFER
	MOVB	HSDPIN			;CLEAR "MSTR RDY DLY 2"
	JMPSUB	STRMB			;START THE XFER, SET "MSTR REQ"
	DATI	REG1,BR			;READ REG 1
	JMPB7	.+2			;JUMP IF "MSTR REQ" SET
	ERROR	MRQ4,"MSTR REQ" DIDN'T SET,
DIAG STARTED A DEVICE READ XFER
	JMPSUB	ABTXFR			;END THE XFER
	JMPSUB	INITL			;CLEAR "MSTR REQ" ON MB BOARD

	REPEAT	TST
	TEST	242,TEST MSTR BUS DRIVERS
;*CLOCK DATA PATTERNS FROM THE CB BOARD THRU THE FORMATTER AND INTO
;*THE MASSBUS DATA BOARD BUFFER.

;*SETUP CB BOARD LOOPING.
;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR FOR PROGRAM TO SEND DATA FROM CB TO MASSBUS.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEP.
;*SETUP THE RH20 FOR A READ XFER.
;*DO A HS DP INIT.
;*SET THE "START" BIT.
;*USING SINGLE STEPPING,  CLOCK DATA FROM CB INTO AR BITS 17-0.
;*CLOCK THE AR INTO THE SB AND THRU THE MSTR BUS DRIVERS INTO THE
;*MASSBUS DATA BOARD BUFFER.
;*CHECK THAT THE DATA IN THE BUFFER IS CORRECT.

	LDMAR	0			;CLEAR MAR
	LDMEM	4			;SETUP ADDITIONAL PNT ROUTINE NUMBER
	JMPSUB	SETPNT
	LDBR	5			;SETUP DATA PATTERN NUMBER
	MOVB	AC0
	JMPSUB	SETCNT			;SETUP DATA FOR HOST
	JMPSUB	CBLOOP			;SETUP CB BOARD LOOPING
	LDMARX	2			;SET MAR EXT BITS FOR 3RD 256 WORD BLOCK
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	MUXDT1&377,MAR		;INITIALIZE LOAD DATA ADDR
	MOVB	AC2
MBDLP:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	DMXSHF			;SET ROM ADDR TO LOAD AR
	MOVB	DFRMAD
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	STXFRR			;SETUP FOR DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	JMPSUB	STRMB			;START THE XFER
	JMPSUB	CLKDAT			;CLOCK TABLE DATA INTO SRR
	JMPSUB	PULSE7			;CLOCK DATA INTO AR BITS 7-0
	IMAR				;INC LOAD DATA ADDR
	JMPSUB	CLKDAT			;CLOCK NEXT DATA INTO SRR
	JMPSUB	PULSE7			;CLOCK DATA INTO AR BITS 15-8
	IMAR				;INC LOAD DATA ADDR
	JMPSUB	CLKDAT			;CLOCK NEXT DATA INTO SRR
	JMPSUB	PULSE7			;CLOCK DATA INTO AR BITS 17-16
	JMPSUB	PULSE7			;SEND DATA TO MSTR
	JMPSUB	ABTXFR			;END THE XFER
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	DATI	MPDB0,AC0		;READ DATA BUFFER BITS 7-0
	DATI	MPDB1,AC4		;READ DATA BUFFER BITS 15-8
	DATI	MPDB2,AC5		;READ DATA BUFFER BITS 17-16
	LDBR	3			;SET MASK
	LANDBR	AC5			;ISOLATE BITS 17-16
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	JMPSUB	SETUP			;GO SETUP CORRECT AND ACTUAL FOR PRINTOUT
	MOV	AC2,MAR			;SET MEM TO CORRECT DATA ADDR
	OSM	AC0,I			;CHECK BITS 7-0
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	MBERR			;ELSE, REPORT ERROR
	OSM	AC4,I			;CHECK BITS 15-8
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	MBERR			;ELSE, REPORT ERROR
	OSM	AC5			;CHECK BITS 17-16
	JMPZ	.+2			;JUMP IF CORRECT
MBERR:	ERROR	MBDLP,DATA ERROR,
DIAG CLOCKED DATA FROM FORMATTER TO MB DATA BUFFER,PNT
	LDBR	3			;ADVANCE LOAD DATA ADDR
	ADBR	AC2,MAR			;SET MAR TO LOAD DATA ADDR
	MOVMEM				;CHECK FOR ALL ONES END OF DATA MARKER
	JMPZ	.+2			;JUMP IF AT END OF TABLE
	JMP	MBDLP			;ELSE, CONTINUE

	REPEAT	TST
	TEST	243,TEST MRR
;*SEND DATA FROM THE HOST THRU THE MASSBUS INTERFACE AND INTO THE AR
;*OF THE FORMATTER.

;*SETUP FOR CB BOARD LOOPING.
;*CLEAR CLOCK PHASES.
;*LOAD ROM ADDR FOR PROGRAM TO RECEIVE DATA FROM MASSBUS INTERFACE.
;*SET "DX HIGH SPEED" AND ENABLE SINGLE STEPPING.
;*SETUP RH20 FOR WRITE XFER.
;*DO A HS DP INIT.
;*SET THE "START" BIT.
;*USING SINGLE STEPPING, CLOCK THE DATA INTO THE MRR AND SB.
;*THEN FORMAT IT AND SEND IT TO THE CB BOARD.
;*CHECK THE DATA AS IT PASSES THRU THE AR.

	LDMAR	0			;CLEAR MAR
	LDMEM	4			;SET ADDITIONAL PNT ROUTINE NUMBER
	JMPSUB	SETPNT
	LDBR	5			;SETUP DATA PATTERN NUMBER
	MOVB	AC0
	JMPSUB	SETCNT			;SETUP DATA FOR HOST
	JMPSUB	CBLOOP			;SETUP CB BOARD LOOPING
	LDMARX	2			;SET MAR EXT BITS FOR 3RD 256 WORD BLOCK
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	MUXDT1&377		;INITIALIZE CORRECT DATA ADDR
	MOVB	AC2
MSTRI:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	MUXSHF			;SET ROM TO LOAD SB
	MOVB	DFRMAD
	JMPSUB	ENSS			;ENABLE SINGLE STEP AND SET "DX HIGH SPEED"
	JMPSUB	STXFRW			;SETUP FOR DEVICE WRITE XFER
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	JMPSUB	STRMB			;START THE XFER
	JMPSUB	PULSE3			;CLOCK DATA TO MRR AND SET RUN
	JMPSUB	GETAR			;CLOCK DATA INTO AR AND PUT INTO BR
	MOVB	AC5			;SAVE IN AC5
	JMPSUB	SETSLV			;SET "SLVE REQ" ON CB BOARD
	JMPSUB	GETAR			;CLOCK DATA INTO AR AND PUT INTO BR
	MOVB	AC4			;SAVE IN AC4
	JMPSUB	SETSLV			;SET "SLVE REQ" ON CB BOARD
	JMPSUB	PULSE3			;SEND BYTE AND SET RUN AGAIN
	JMPSUB	GETAR			;CLOCK DATA INTO AR AND PUT INTO BR
	MOVB	AC0			;SAVE IN AC0
	JMPSUB	ABTXFR			;END THE XFER
	JMPSUB	SETUP			;SETUP CORRECT AND ACTUAL FOR PRINTOUT
	MOV	AC4,BR			;SAVE DATA
	MOVB	AC1
	MOV	AC5,BR			;SAVE DATA
	MOVB	AC3
	JMPSUB	MBPAR			;GO CHECK MASSBUS PARITY
	JMPZ	.+2			;JUMP IF OKAY
	ERROR	MSTRI,DATA PARITY ERROR ON MASSBUS INTERFACE,
DIAG CLOCKED DATA FROM HOST TO DATA PATH INTERFACE,PNT
	MOV	AC2,MAR			;SET MAR TO CORRECT DATA
	OSM	AC0,I			;CHECK IF BITS 7-0 ARE OKAY
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	MSTRER			;ELSE, REPORT ERROR
	OSM	AC1,I			;CHECK IF BITS 15-8 ARE OKAY
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	MSTRER			;ELSE, REPORT ERROR
	LDBR	3			;SET MASK OF BITS 17-16
	LANDBR	AC3			;ISOLATE THEM IN AC5
	OSM	AC3			;CHECK IF THEY'RE OKAY
	JMPZ	.+2			;JUMP IF CORRECT
MSTRER:	ERROR	MSTRI,DATA ERROR,
DIAG CLOCKED DATA FROM HOST THRU MRR INTO AR,PNT
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	DATI	MPGP10,AC0		;READ DATA PATTERN NUMBER
	INC	AC0,BR			;INCREMENT IT
	MOVB	MPGP10			;AND STORE IT
	LDBR	22			;SELECT DATA PATH
	MOVB 	IOSEL
	LDBR	3			;ADVANCE CORRECT DATA POINTER
	ADBR	AC2,MAR
	MOVMEM				;TEST NEXT ENTRY
	JMPZ	.+2			;ALL ONES MEANS END OF TABLE
	JMP	MSTRI			;ELSE, CONTINUE

	REPEAT	TST
	TEST	244,TEST CLEARING OF MRR AND SB
;*TEST THAT A HS DP INIT CLEARS THE MRR AND CLOCKS IT INTO THE SB.

;*CLEAR THE CLOCK PHASES AND ENABLE SINGLE STEP.
;*SET "DIR TO MSTR".
;*DO A HS DP INIT, SHOULD CLOCK "NOT AR" INTO SB.
;*CLEAR "DIR TO MSTR".
;*DO A HS DP INIT, SHOULD CLOCK MRR INTO SB.
;*LOAD ROM ADDR FOR PROGRAM TO CLOCK SB INTO AR.
;*SET "DX HIGH SPEED" AND "RUN".
;*SINGLE STEP SB BITS 7-0 INTO AR.
;*SET "RUN" AGAIN AND SINGLE STEP SB BITS 15-8 INTO AR.
;*SET "RUN" AGAIN AND SINGLE STEP SB BITS 17-16 INTO AR.
;*CHECK THAT ALL SB BITS ARE ZEROS.

	LDMAR	0			;CLEAR MAR
	LDMEM	4			;SETUP ADDITIONAL PNT ROUTINE NUMBER
	JMPSUB	SETPNT
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	0			;ENABLE SINGLE STEP
	MOVB	REG1
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;CLEAR AR, CLOCK "NOT AR" INTO SB
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;CLEAR MRR, CLOCK MRR INTO SB
	LDBR	MUXSHF			;SET ROM TO CLOCK SB DATA INTO AR
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	GETAR			;CLOCK DATA INTO AR AND PUT INTO BR
	MOVB	AC5			;MOVE THEM TO AC5
	LDBR	3			;SET MASK OF BITS 17-16
	LANDBR	AC5			;ISOLATE THEM IN AC5
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	GETAR			;CLOCK DATA INTO AR AND PUT INTO BR
	MOVB	AC4			;SAVE THEM IN AC4
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	GETAR			;CLOCK DATA INTO AR AND PUT INTO BR
	MOVB	AC0			;SAVE THEM IN AC0
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;SETUP CORRECT DATA
	MOVB	MPGP12
	MOVB	MPGP13
	MOVB	MPGP16
	LDBR	22			;SELECT DATA PATH
	MOVB 	IOSEL
	JMPSUB	SETACT			;SETUP ACTUAL DATA
	LDMEM	0			;SETUP CORRECT DATA
	OSM	AC0			;CHECK BITS 7-0
	JMPZ	.+2			;JUMP IF THEY'RE ALL ZEROS
	JMP	CLRER			;ELSE, REPORT ERROR
	OSM	AC4			;CHECK BITS 15-8
	JMPZ	.+2			;JUMP IF THEY'RE ALL ZEROS
	JMP	CLRER			;ELSE, REPORT ERROR
	OSM	AC5			;CHECK BITS 17-16
	JMPZ	.+2			;JUMP IF THEY'RE ALL ZEROS
CLRER:	ERROR	TST,MRR DID NOT CLEAR AFTER HS DP INIT,
<DIAG CLEARED "DIR TO MSTR" AND DID A HS DP INIT THEN
READ THE SB CONTENTS FROM THE AR>,PNT
	REPEAT	TST
	TEST	245,TEST "MSTR PE"
;*TEST THAT "MSTR PE" SETS WHEN EVEN PARITY DATA IS CLOCKED INTO THE SB
;*AND DOES NOT SET FOR ODD PARITY DATA.

;*ENABLE SINGLE STEP AND CLEAR "DX HIGH SPEED".
;*CLEAR "DIR TO MSTR".
;*DO A HS DP INIT TO CLOCK ALL ZEROS INTO THE SB.
;*CHECK THAT "MSTR PE" IS SET.

	LDBR	0			;ENABLE SINGLE STEP
	MOVB	REG1
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;CLOCKED ALL ZEROS INTO SRR, SET "MSTR PE"
	DATI	REG16,BR		;READ REG 16
	SHR				;RIGHT ADJUST "MSTR PE"
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"MSTR PE" DIDN'T SET,
DIAG DID A HS DP INIT WITH "DIR TO MSTR" CLEARED
;*CLEAR CLOCK PHASES.
;*CLEAR "DIR TO MSTR" AND SET "MSTR RDY DLY 2".
;*LOAD ROM ADDR FOR PROG TO CLOCK SB.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SETUP RH20 FOR WRITE XFER AND SET "START".
;*GENERATE 7 SINGLE STEP PULSES TO CLOCK MASSBUS DATA PATTERN INTO SB.
;*ABORT THE XFER.
;*CHECK THAT "MSTR PE" IS NOT SET.
;*REPEAT FOR ONES, ZEROS, FLOATING ONES AND ZEROS PATTERNS.

	LDMAR	0			;CLEAR MAR
	LDMEM	9			;SET ADDITIONAL PNT ROUTINE NUMBER
	JMPSUB	SETPNT
	LDBR	5			;SETUP DATA PATTERN NUMBER
	MOVB	AC0
	JMPSUB	SETCNT			;SETUP DATA FOR HOST
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDMARX	2			;SET MAR EXT BITS FOR 3RD 256 WORD BLOCK
	LDBR	MUXDT1&377		;INITIALIZE RECEIVED DATA ADDR
	MOVB	AC2
MPARLP:	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	MUXSHF			;SET ROM TO LOAD SB
	MOVB	DFRMAD
	JMPSUB	ENSS			;ENABLE SINGLE STEP AND SET "DX HIGH SPEED"
	JMPSUB	STXFRW			;SETUP FOR DEVICE WRITE XFER
	JMPSUB	STRMB			;START THE XFER
	JMPSUB	PULSE7			;CLOCK DATA TO MRR AND SB
	JMPSUB	ABTXFR			;END THE XFER
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	JMPSUB	SETCOR			;SETUP CORRECT DATA FOR PRINTOUT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	JMPSUB	MBPAR			;GO CHECK MASSBUS PARITY
	JMPZ	.+2			;JUMP IF OKAY
	ERROR	MPARLP,DATA PARITY ERROR ON MASSBUS INTERFACE,
DIAG CLOCKED DATA FROM HOST TO DATA PATH INTERFACE,PNT
	DATI	REG16,BR		;READ REG 16
	SHR				;RIGHT ADJUST "MSTR PE"
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	MPARLP,<"MSTR PE" SET WHEN GOOD DATA WAS CLOCKED
 INTO THE SB>,,PNT
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	DATI	MPGP10,AC0		;READ DATA PATTERN NUMBER
	INC	AC0,BR			;INCREMENT IT
	MOVB	MPGP10			;AND STORE IT
	LDBR	22			;SELECT DATA PATH
	MOVB 	IOSEL
	LDBR	3			;ADVANCE CORRECT DATA POINTER
	ADBR	AC2,MAR
	MOVMEM				;TEST NEXT ENTRY
	JMPZ	.+2			;ALL ONES MEANS END OF TABLE
	JMP	MPARLP			;ELSE, CONTINUE

	REPEAT	TST
	TEST	246,TEST "DP PE FLAG" USING "MSTR PE"
;*CLEAR CLOCK PHASES.
;*SET "ROM 01".
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*CLEAR "DIR TO MSTR".
;*DO A HS DP INIT TO SET "MSTR PE".
;*SET "RUN" AND GENERATE 4 SINGLE STEP PULSES.
;*CHECK THAT "DP PE FLAG" IS SET.

	LDBR	BCLKEN			;CLEAR CLOCK PHASES
	MOVB	REG1
	LDBR	RMADR8			;SET ROM ADDR BIT 8
	MOVB	REG2
	LDBR	CC2			;SET ROM ADDR TO POINT TO LOC WITH
	MOVB	DFRMAD			;"ROM 01"=1
	JMPSUB	ENSS			;SET "DX HIGH SPEED" AND ENABLE SINGLE STEP
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;CLOCK ZEROS INTO SB, SET "MSTR PE"
	MOVB	SETRUN			;CLEAR "CLR RUN"
	JMPSUB	PULSE4			;GEN 4 SINGLE STEP PULSES
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULD BE
	ERROR	TST,"DP PE FLAG" DID NOT SET,
<DIAG SET "CC 1" AND "MSTR PE" AND CLEARED "DIR TO MSTR" THEN
GENERATED 4 SINGLE STEP PULSES>
;*WRITE REG 0 TO CLEAR "DP PE FLAG".
;*CLEAR "ROM 01".
;*SET "RUN" AND GENERATE 4 SINGLE STEP PULSES.
;*CHECK THAT "DP PE FLAG" IS NOT SET.

MDPPE1:	MOVB	REG0			;CLEAR FLAG
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	ZEROS			;CLEAR "ROM 01"
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE4			;CLOCK "DP PE FLAG" FLOP
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	MDPPE1,"DP PE FLAG" SET WHEN IT SHOULDN'T HAVE,
<DIAG SET "MSTR PE" AND CLEARED "CC 1" AND "DIR TO MSTR"
THEN GENERATED 4 SINGLE STEP PULSES>
;*CLEAR "DIR TO MSTR" AND SET "ROM 01".
;*SET "RUN" AND GENERATE 2 SINGLE STEP PULSES.
;*SET "DIR TO MSTR" AND GENERATE 2 MORE SINGLE STEP PULSES.
;*CHECK THAT "DP PE FLAG" IS NOT SET.

MDPPE2:	MOVB	REG0			;CLEAR FLAG
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	LDBR	CC2			;SET "CC 1"
	MOVB	DFRMAD
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	MOVB	SETRUN			;SET "RUN"
	JMPSUB	PULSE2			;CLOCK ZEROS TO SB
	JMPSUB	DEVRD			;SETUP DEVICE READ
	JMPSUB	PULSE2			;CLOCK "DP PE FLAG" FLOP
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	MDPPE2,"DP PE FLAG" SET WHEN IT SHOULDN'T HAVE,
<DIAG SET "MSTR PE" AND "CC 1" AND "DIR TO MSTR" THEN
GENERATED 4 SINGLE STEP PULSES>
	LDBR	5			;SETUP DATA PATTERN NUMBER
	MOVB	AC0
	JMPSUB	SETCNT			;SETUP DATA FOR HOST
;*CLEAR "DIR TO MSTR" AND SET "MSTR RDY DLY 2" WITH HS DP INIT.
;*LOAD ROM ADDR FOR PROG TO LOAD SB.
;*ENABLE SINGLE STEP AND SET "DX HIGH SPEED".
;*SETUP RH20 FOR A WRITE XFER AND SET "START".
;*GENERATE 7 SINGLE STEP PULSES TO CLOCK GOOD DATA INTO SB.
;*ABORT THE XFER.
;*CHECK THAT "DP PE FLAG" IS NOT SET.

MDPPE3:	MOVB	REG0			;CLEAR FLAG
	LDBR	0			;CLEAR "DX HIGH SPEED"
	MOVB	REG1
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	MUXSHF			;SET ROM TO LOAD SB
	MOVB	DFRMAD
	JMPSUB	ENSS			;ENABLE SINGLE STEP AND SET "DX HIGH SPEED"
	JMPSUB	STXFRW			;SETUP FOR DEVICE WRITE XFER
	JMPSUB	STRMB			;START THE XFER
	JMPSUB	PULSE7			;CLOCK DATA TO MRR AND SB
	JMPSUB	ABTXFR			;END THE XFER
	JMPSUB	MBPAR			;GO CHECK MASSBUS PARITY
	JMPZ	.+2			;JUMP IF OKAY
	ERROR	MDPPE3,DATA PARITY ERROR ON MASSBUS INTERFACE,
DIAG CLOCKED DATA FROM HOST TO DATA PATH INTERFACE
	DATI	REG0,BR			;READ REG0
	SHR				;MOVE "DP PE FLAG" INTO BIT 0
	JMPB0	.+2			;JUMP IF SET, SHOULDN'T BE
	JMP	.+2			;JUMP IF CLEAR
	ERROR	MDPPE3,"DP PE FLAG" SET WHEN IT SHOULDN'T HAVE,
<DIAG SET "CC 1" AND CLEARED "MSTR PE" AND "DIR TO MSTR"
THEN GENERATED 4 SINGLE STEP PULSES>
	JMPSUB	INITL			;DO A DEVICE RESET

	REPEAT	TST
	JMP	END			;JUMP AROUND SUBROUTINES

;DO A MICROBUS INIT AND ZERO MEMORY POINTER.
INITL:	LDBR	INIT+22			;SET INIT
	MOVB	IOSEL
	LDBR	22			;CLR INIT & SELECT DP
	MOVB	IOSEL
	LDMAR	0			;PUT MEMORY ADDRESS TO 0
	LDMEM	0			;CLR MEMORY LOC. 0
	RETURN

;LOAD THE MC WITH A DATA PATTERN FROM MEMORY AND CLOCK THE MC.
;THEN READ THE "MC OF FLAG" BIT.  RETURN WITH Z CLEARED IF IT IS SET
;AND Z SET IF IT IS CLEARED.
MCFTST:	MOVB	REG0			;CLEAR "MC OF FLAG"
	LDBR	0			;CLEAR "DIAG MSTR REQ"
	MOVB	REG1
	MOVMEM	MCHI,I			;SET HI ORDER MC BITS
	MOVMEM	MCLO			;SET LOW ORDER MC BITS
	JMPSUB	DEVWR			;SETUP DEVICE WRITE
	MOVB	HSDPIN			;SET "MSTR RDY DLY 2"
	LDBR	DMSTRQ			;SET "DIAG MSTR REQ"
	MOVB	REG1
	NOP				;DELAY BEFORE DOING DATI
	DATI	REG0,AC4		;READ REG 0
SHFTIT:	SHL	AC4,BR			;MOVE "MC OF FLAG" TO BIT 4
	JMPB4	.+2			;JUMP IF SET, SHOULDN'T BE
	RETURN	-1			;GIVE NO ERROR RETURN
	RETURN				;GIVE ERROR RETURN

;THIS SUBROUTINE IS USED IN THE "BC OF FLAG" TEST.
;LOAD THE BC WITH DATA FROM MEMORY THEN GENERATE "SET SLVE ACK".
;CHECK "BC OF FLAG", RETURN WITH "Z" SET IF FLAG IS NOT SET.
;RETURN WITH "Z" CLEARED IF IT IS SET.
BCFTST:	MOVB	REG0			;WRITE REG 0 TO CLEAR FLAGS
	LDBR	0			;CLEAR "SLVE REQ"
	MOVB	REG1
	MOVMEM	BCHI,I			;SET HI ORDER BC BITS
	MOVMEM	BCLO			;SET LOW ORDER BC BITS
	JMPSUB	DEVRD			;SETUP DEVICE READ
	MOVB	HSDPIN			;SET "SLVE RDY DLY 2"
	LDBR	DSLVRQ			;SET "SLVE REQ"
	MOVB	REG1
	LDBR	373			;SET MASK OF ALL BUT "BC OF FLAG" BIT
	MOVB	AC0			;MOVE MASK TO AC0
	DATI	REG0,BR			;READ REG 0
	LORCB	AC0			;IF BIT IS CLEAR, RESULT IS ALL ONES
	JMPZ	.+2			;JUMP IF CLEAR
	RETURN				;GIVE ERROR RETURN
	RETURN	-1			;GIVE NO ERROR RETURN

;SET "SLVE WOR END XFER" ON THE CB BOARD BY SETTING "STA IN".
;IT IS ASSUMED THAT "DX HIGH SPEED" AND "DIR TO MSTR" ARE SET.
SWEX:	LDBR	33			;SELECT	CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	LOOPEN			;SET LOOP ENABLE
	MOVB	CSR1
	LDBR	STAINL			;SET "STA IN"
	MOVB	TOR0
RTRN:	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	RETURN

;CLEAR "SLVE WOR END XFER" ON THE CB BOARD BY CLEARING "STA IN".
CLRSEX:	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;CLEAR "STA IN"
	MOVB	TOR0
	LDBR	0			;CLEAR LOOP ENABLE
	MOVB	CSR1
	JMP	RTRN

;STORE DATA FROM MEMORY INTO GP REG 2 FOR ERROR PRINTOUTS.
SETDAT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP4			;STORE DATA
	JMP	RTRN

;SET "DIR TO MSTR" IN THE MASSBUS INTERFACE.
DEVRD:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;SETUP FOR DEVICE READ
	MOVB	MPSCR1
	JMP	RTRN

;CLEAR "DIR TO MSTR" IN THE MASSBUS INTERFACE.
DEVWR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	DTD			;SETUP FOR DEVICE WRITE
	MOVB	MPSCR1
	JMP	RTRN

;SETUP THE 18 BIT CORRECT AND ACTUAL DATA FOR ERROR PRINTOUTS.
;IT IS ASSUMED THAT THE CORRECT DATA IS IN MEMORY POINTED TO BY AC2.
;AND ACTUAL DATA IS IN AC0, AC4 AND AC5.
SETUP:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	JMPSUB	SETCOR			;SETUP CORRECT DATA
SETACT:	MOV	AC0,BR			;GET SB BITS 7-0
	MOVB	MPGP14			;STORE FOR PRINTOUT
	MOV	AC4,BR			;GET SB BITS 15-8
	MOVB	MPGP15			;STORE FOR PRINTOUT
	MOV	AC5,BR			;GET SB BITS 17-16
	MOVB	MPGP17			;STORE FOR PRINTOUT
	JMP	RTRN

;STORE 18 BIT CORRECT DATA FOR ERROR PRINTOUTS.  IT IS ASSUMED THAT THE
;DATA IS IN MEMORY POINTED TO BY AC2.
SETCOR:	MOV	AC2,MAR			;SET MAR TO POINT TO CORRECT DATA
	MOVMEM	MPGP12,I		;STORE IT FOR PRINTOUT
	MOVMEM	MPGP13,I		;STORE IT FOR PRINTOUT
	MOVMEM	MPGP16			;STORE IT FOR PRINTOUT
	RETURN

;GENERATED FROM 2 TO 7 SINGLE STEPS PULSES.
PULSE7:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE6:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE5:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE4:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE3:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
PULSE2:	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	MOVB	CLKPLS			;GENERATE A SINGLE STEP PULSE
	RETURN

;SETUP THE RH20 FOR A DEVICE WRITE.  THEN SET "OCCUPIED"
;IN THE MASSBUS INTERFACE.  WAIT FOR "RUN" TO SET.  IF IT DOESN'T CONTINUE
;ANYWAY AND ALLOW THE TEST TO FAIL.
STXFRW:	WRITE				;SETUP FOR A DEVICE WRITE
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	DTD+OCC			;SET MASK OF BITS TO BE SET
	MOVB	MPSCR1			;AND WRITE IT TO STATUS REG
	JMPSUB	RUNWAT			;GO WAIT FOR "RUN" TO SET
	JMP	RTRN

;SETUP THE RH20 FOR A DEVICE READ.  THEN SET "DIR TO MSTR" AND "OCC"
;IN THE MASSBUS INTERFACE.  WAIT FOR "RUN" TO SET.  IF IT DOESN'T CONTINUE
;ANYWAY AND ALLOW THE TEST TO FAIL.
STXFRR:	READ				;SETUP FOR A DEVICE READ
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	OCC			;SET MASK OF BITS TO BE SET
	MOVB	MPSCR1			;AND WRITE IT TO STATUS REG
	JMPSUB	RUNWAT			;GO WAIT FOR "RUN" TO SET
	JMP	RTRN

;WAIT FOR "RUN" TO SET IN THE MASSBUS INTERFACE.
RUNWAT:	LDBR	0			;CLEAR WAIT CNT
	MOVB	AC0
RUNLP:	INCR	AC0			;INC WAIT CNT
	JMPC	RUNBCK			;JUMP IF TIMED OUT, TEST WILL FAIL
	DATI	MPSCR0,BR		;CHECK "RUN" BIT
	JMPB0	.+2			;JUMP IF SET
	JMP	RUNLP			;ELSE, KEEP WAITING
RUNBCK:	RETURN

;START THE PREVIOUSLY SETUP DATA XFER BY SETTING "START" IN THE MASSBUS
;INTERFACE.
STRMB:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	DATI	MPSCR1,AC0		;READ PRESENT STATE OF STATUS
	LDBR	OCC+DTD			;SET MASK OF BITS TO KEEP
	LANDBR	AC0
	LDBR	START			;SET MASK OF START BIT
	LORB	AC0,BR			;SET IT INTO PRESENT STATUS
	MOVB	MPSCR1
	JMP	RTRN

;ABORT THE XFER BY CLEARING "OCC" AND SETTING "EBL".
ABTXFR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	EBL			;SET MASK OF BIT TO BE SET
	MOVB	MPSCR1			;AND WRITE IT TO STATUS REG
	JMP	RTRN

;SETUP XFER INFORMATION IN GP REGS FOR THE HOST.  IT IS ASSUMED THAT
;THE DATA PATTERN NUMBER IS IN AC0 AND THAT THE XFER IS FOR 1 WORD AND
;1 BLOCK.
SETCNT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC0,BR			;PUT DATA PATTERN NUMBER INTO BR
	MOVB	MPGP10			;AND STORE IT FOR HOST
	LDBR	1			;SET XFER WORD CNT=1
	MOVB	MPGP2
	MOVB	MPGP11			;SET BLOCK CNT=1
	LDBR	0			;CLEAR HIGH ORDER WRD CNT BITS
	MOVB	MPGP3
	JMP	RTRN

;ENABLE SINGLE STEPPING AND SET "DX HIGH SPEED".
ENSS:	LDBR	0			;ENABLE SINGLE STEP
	MOVB	REG1
	LDBR	DXHISP			;SET "DX HIGH SPEED"
	MOVB	REG1
	RETURN

;STORE THE ADDITIONAL PNT ROUTINE NUMBER FOR THE HOST TO USE IN
;ERROR PRINTOUTS.  IT IS ASSUMED TO BE IN MEMORY.
SETPNT:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP6			;STORE ADDITIONAL PNT ROUTINE NUMBER
	JMP	RTRN

;SETUP CB BOARD LOOPING.  SINCE DATA WILL BE INVERTED, SET "EV PAR" SO
;ACTUAL DATA WILL HAVE ODD PARITY.
CBLOOP:	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	LOOPEN+EVPAR+CHANL	;SET LOOP ENABLE AND EVEN PARITY
	MOVB	CSR1			;AND CHANNEL MODE
	JMP	RTRN

;SET "SLVE REQ" ON CB BOARD BY TOGGLING "SRV IN". IT IS ASSUMED THAT
;LOOP ENABLE IS SET.
SETSLV:	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	JMP	CLKIT1
;CLOCK THE DATA PROVIDED IN MEMORY ONTO THE SLAVE DATA LINES IN AN
;INVERTED FORM.
CLKDT:	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	MOVMEM	BR			;MOVE LOAD DATA TO BR
	JMP	CLKIT
;CLOCK THE DATA PROVIDED IN MEMORY ONTO THE SLAVE DATA LINES.
CLKDAT:	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDBR	0			;COMPUTE THE COMPLEMENT OF MEM CONTENTS
	MOVB	AC0
	LORCM	AC0,BR			;PUT IT IN BR
CLKIT:	MOVB	BORLO			;LOAD DATA INTO BOR
CLKIT1:	LDBR	SRVINL			;SET "SRV IN"
	MOVB	TOR1
	LDBR	0			;CLEAR "SRV IN"
	MOVB	TOR1
	JMP	RTRN

;READ DATA OFF THE SLAVE DATA LINES INTO AC0.
RDDATA:	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	MOVB	CLKDRL			;CLK DRLO REG ON CB BOARD
	NOP				;DELAY BEFORE DOING DATI
	DATI	DRLO,AC0		;READ DATA
	JMP	RTRN

;READ THE CONTENTS OF THE AR AND COMPARE IT TO CORRECT DATA IN MEMORY.
;IF AR IS CORRECT, RETURN WITH "Z" SET. IF NOT, SETUP CORRECT AND ACTUAL
;IN GP REGS AND RETURN WITH "Z" CLEARED.
ARCHK:	DATI	ARLO,AC0		;READ AR BITS 7-0
	DATI	ARHI,AC4		;READ AR BITS 15-8
	DATI	REG15,AC5		;READ REG 15
	OSM	AC0,I			;CHECK IF CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	ARERR			;ELSE, SETUP PRINTOUT DATA
	OSM	AC4,I			;CHECK IF CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	ARERR			;ELSE, SETUP PRINTOUT DATA
	LDBR	AR1716			;SET MASK OF AR BITS 17-16
	LANDBR	AC5			;ISOLATE THOSE BITS
	OSM	AC5			;CHECK IF CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	JMP	ARERR			;ELSE, SETUP PRINTOUT DATA
	RETURN	-1			;GIVE NO ERROR RETURN

ARERR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOV	AC0,BR			;MOVE AR BITS 7-0 INTO BR
	MOVB	MPGP14			;AND STORE THEM FOR PRINTOUT
	MOV	AC4,BR			;MOVE AR BITS 15-8 IN BR
	MOVB	MPGP15			;AND STORE THEM FOR PRINTOUT
	MOV	AC5,BR			;MOVE AR BITS 17-16 INTO BR
	MOVB	MPGP17			;AND STORE THEM FOR PRINTOUT
	JMPSUB	SETCOR			;GO SETUP CORRECT DATA
	MOV	AC3,BR			;STORE SHIFT CNT/MSK FOR PRINTOUT
	MOVB	MPGP5
	JMP	RTRN

;READ AR BITS 8-1 (OUTPUT FROM MUX) AND COMPARE IT TO CORRECT DATA IN MEMORY.
;IF IT IS CORRECT, RETURN WITH "Z" SET. IF NOT, RETURN WITH "Z" CLEARED.
ARCHK7:	DATI	ARLO,BR			;READ AR BITS 7-0
	DATI	ARHI,BRSR		;PUT AR BITS 8-1 INTO BR
	MOVB	AC0			;MOVE INTO AC0 FOR COMPARE
	OSM	AC0			;CHECK IF DATA CORRECT
	JMPZ	.+2			;JUMP IF CORRECT
	RETURN				;GIVE ERROR RETURN
	RETURN	-1			;GO NO ERROR RETURN

;GENERATE 4 SINGLE STEP PULSES TO CLOCK DATA FROM THE SB INTO THE AR.
;THEN READ THE AR BITS (8-1) INTO THE BR.
GETAR:	JMPSUB	PULSE4			;CLOCK SB DATA INTO AR
	DATI	ARLO,BR			;READ BITS 7-0 0F AR
	DATI	ARHI,BRSR		;CREATE AR BITS 8-1 IN BR
	RETURN

;CHECK IF "DP PARITY ERROR" SET IN THE MASSBUS INTERFACE.
MBPAR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	DATI	MPDB2,AC4		;READ BUFFER WITH PE BIT
	LDBR	22			;SELECT DATA PATH
	MOVB	IOSEL
	JMP	SHFTIT			;GO SHIFT AND TEST PARITY BIT
END:	.ECRAM
	.MEM
	0				;FIRST MEM LOC IS FOR SCRATCH
CTR1:	377
	360
CTR2:	377
	17
CTR3:	360
	377
CTR4:	17
	377
CNTCOR:	0
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	0
	0
	361
	17
	20
	17
	361
CNTDAT:	0
	0
	0
	1
	0
	3
	0
	7
	0
	17
	0
	37
	0
	77
	0
	177
	0
	377
	1
	377
	3
	377
	7
	377
	17
	377
	37
	377
	77
	377
	177
	377
	0
	360
	17
	17
	17
	360
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
;START OF 2ND 256 WORD BLOCK OF WORKING MEMORY
	0
DPDAT:	1
	2
	4
	10
	20
	40
	100
	200
	-1
ARDATS:	ARDA0&377
	ARDA1&377
	ARDA2&377
	ARDA3&377
	ARDA4&377
	ARDA5&377
	ARDA6&377
	ARDA7&377
	ARDA10&377
	ARDA11&377
	ARDA12&377
	ARDA13&377
	ARDA14&377
	ARDA15&377
	ARDA16&377
	ARDA17&377
AR0S:	0
	0
	0
AR1S:	377
	0
	0
ARDA0:	1
	0
	0
	2
	0
	0
ARDA2:	4
	0
	0
	10
	0
	0
ARDA4:	20
	0
	0
ARDA5:	40
	0
	0
ARDA6:	100
	0
	0
	200
	0
	0
ARDA10:	0
	1
	0
ARDA11:	0
	2
	0
ARDA12:	0
	4
	0
ARDA13:	0
	10
	0
ARDA14:	0
	20
	0
	0
	40
	0
ARDA16:	0
	100
	0
ARDA17:	0
	200
	0
ARDA15:	0
	0
	1
	0
	0
	2
	1
	0
	0
	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
ARDA1:	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
	100
	0
	0
	200
	0
	0
	1
	0
	0
ARDA3:
ARDA7:	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
SDPAT:	-1
	0
	376
	375
	373
	367
	357
	337
	277
	177
	1
	2
	4
	10
	20
	40
	100
	200
CBPAT:	-1
	-1
	0
	0
	374
	1
	372
	1
	366
	1
	356
	1
	336
	1
	276
	1
	176
	1
	376
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	0
	0
	1
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
;START OF 3RD 256 WORD BLOCK OF WORKING MEMORY
	0
MUXDT1:	377
	377
	3
	0
	0
	0
MUXDAT:	1
	0
	0
	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
	100
	0
	0
	200
	0
	0
	0
	1
	0
	0
	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
	100
	0
	0
	200
	0
	0
	0
	1
	0
	0
	2
	-1
ARDATM:	ARDM0&377
	ARDM1&377
	ARDM2&377
	ARDM3&377
	ARDM4&377
	ARDM5&377
	ARDM6&377
	ARDM7&377
	ARDM10&377
	ARDM11&377
	ARDM12&377
	ARDM13&377
	ARDM14&377
	ARDM15&377
	ARDM16&377
	ARDM17&377
ARDM12:	0
ARDM11:	0
ARDM10:	0
	0
ARDM6:	0
ARDM5:	0
ARDM4:	0
	0
ARDM2:	0
	0
ARDM0:	1
	2
ARDM15:	4
ARDM17:	10
ARDM16:	20
	40
ARDM14:	100
ARDM13:	200
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	1
	2
	4
	10
	20
	40
	100
ARDM1:	200
	1
	2
	4
	10
	20
	40
	100
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
ARDM3:	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
	0
ARDM7:	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
	377
.END
END:	.ECRAM
	.MEM
	0				;FIRST MEM LOC IS FOR SCRATCH
UBPAR:	0
	56
	127
	144
	272
	311
	375
SCDATD:	1
	2
	4
	10
	20
	40
	100
SCDATU:	1
	3
	7
	17
	37
	77
DNDATA:	17
	160
UPDATA:	77
	137
	157
	160
CLKPHS:	100
	300
	200
	0
FLTZ1:	2
	1
FLTZ2:	176
	175
	173
	167
	157
	137
	77
	1
	2
	4
	10
	20
	40
	100
FLTZ3:	376
	375
	373
	367
	357
	341
	342
	344
	350
	360
FLTZ:	376
	375
	373
	367
	357
	337
	277
	177
	1
	2
	4
	10
	20
	40
	100
	200

CNTDAT:	0
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	0
	1
	17
	1
	360
	37
	17
	37
	360
	20
	377
CNTCOR:	0
	0
	0
	1
	0
	3
	0
	7
	0
	17
	0
	37
	0
	77
	0
	177
	0
	377
	1
	377
	3
	377
	7
	377
	17
	377
	37
	377
	77
	377
	177
	377
	1
	16
	1
	357
	37
	16
	37
	357
	20
	377
	0				;FIRST MEM LOC IS FOR SCRATCH
CLKPHF:	60
	40
	0
CNTDAT:	0
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	0
	1
	17
	1
	360
	37
	17
	37
	360
	20
	377
CNTCOR:	0
	0
	0
	1
	0
	3
	0
	7
	0
	17
	0
	37
	0
	77
	0
	177
	0
	377
	1
	377
	3
	377
	7
	377
	17
	377
	37
	377
	77
	377
	177
	377
	1
	16
	1
	357
	37
	16
	37
	357
	20
	377
RAMPAT:	1
	0
	0
	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
	100
	0
	0
	200
	0
	0
	0
	1
	0
	0
	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
	100
	0
	0
	200
	0
	0
	0
	1
	0
	0
	2
	0
	0
	376
	377
	3
	375
	377
	3
	373
	377
	3
	367
	377
	3
	357
	377
	3
	337
	377
	3
	277
	377
	3
	177
	377
	3
	377
	376
	3
	377
	375
	3
	377
	373
	3
	377
	367
	3
	377
	357
	3
	377
	337
	3
	377
	277
	3
	377
	177
	3
	377
	377
	2
	377
	377
	1
RAMADR:	0
	1
	2
	4
	10
	20
	40
	100
ROMDAT:	0
.END
END:	.ECRAM
.MEM
	0				;FIRST MEM LOC IS FOR SCRATCH
CLKPHF:	60
	40
	0
CNTDAT:	0
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	1
	0
	2
	0
	4
	0
	10
	0
	20
	0
	40
	0
	100
	0
	200
	0
	1
	17
	1
	360
	37
	17
	37
	360
	20
	377
CNTCOR:	0
	0
	0
	1
	0
	3
	0
	7
	0
	17
	0
	37
	0
	77
	0
	177
	0
	377
	1
	377
	3
	377
	7
	377
	17
	377
	37
	377
	77
	377
	177
	377
	1
	16
	1
	357
	37
	16
	37
	357
	20
	377
RAMPAT:	1
	0
	0
	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
	100
	0
	0
	200
	0
	0
	0
	1
	0
	0
	2
	0
	0
	4
	0
	0
	10
	0
	0
	20
	0
	0
	40
	0
	0
	100
	0
	0
	200
	0
	0
	0
	1
	0
	0
	2
	0
	0
	376
	377
	3
	375
	377
	3
	373
	377
	3
	367
	377
	3
	357
	377
	3
	337
	377
	3
	277
	377
	3
	177
	377
	3
	377
	376
	3
	377
	375
	3
	377
	373
	3
	377
	367
	3
	377
	357
	3
	377
	337
	3
	377
	277
	3
	377
	177
	3
	377
	377
	2
	377
	377
	1
RAMADR:	0
	1
	2
	4
	10
	20
	40
	100
ROMDAT:	0
.END
    