%TITLE 'STIRS TESTS FOR M8618 (MMC) BOARD'

MODULE MSMMCT	(
		LANGUAGE(BLISS36)
		) =

BEGIN

!
!			  COPYRIGHT (C) 1979 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.  
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
!
! ABSTRACT:
!
!	THIS MODULE CONTAIN THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
!	(STIRS) DIAGNOSTIC FOR THE M8618 (MMC) BOARD.  IT ALSO CONTAINS SEVERAL
!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
!	'MSMMCD' MODULES TO PRODUCE THE 'MSMMC.EXE' FILE.
!
! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
!
! AUTHOR: Richard Stockdale	, CREATION DATE: 23-MAY-79
!
! MODIFIED BY:
!
!	Richard Stockdale, 23-MAY-79; VERSION 0.1
!--


!  PROGRAM DESCRIPTION:
!
!
!    This program is one of a series  of STIRS  diagnostics.  The STIRS
! package  consists  of three modules - the  Control Module MSSTRC, the
! Test Module (MSMMC in this case), and the Data Module (MSMMC in  this
! case.
!
!    The Control Module  handles  the  running  of  the diagnostic  for
! handling all of the  communication  with the CSL program  to the KS10
! and for determining which test to run based on which program switches
! are set (loop on test ...).  Also the Control Module  does  the fault
! isolation calculations based on the data passed by the Test Module in
! ERROR and NOERR routine calls.
!
!    The Test Module does all of the  testing  of  the  MMC board.  The
! Control Module just decides which test to run and then  goes  to  the
! Test Module  and  runs  it.  The Test Module may find errors in which
! case it calls routine ERROR.  In some cases it may call routine NOERR
! it no errors  have  occurred in a particular test or tests.  The Test
! Module also contains  any additional routines required by the various
! tests  and a few routines SPEC_PRT, SPEC_ASK, and TEST_INIT which are
! required  by the Control Module.
!
!    The Test Module (for the MMC board, at least) does fault isolation
! in addition to that done by the Control Module.  This is done only to
! limit amount of testing done to tests which are appropriate  based on
! what errors have already occurred.  The fault  isolation  done by the
! Control Module causes tests not to be run if  there  are  no networks
! specified in the error network description for each error in the test.
! This method will cause a subset of tests to be run.  However, for the
! MMC board, the number of possible faulty networks for each test is so
! broad and covers so much of the board that this method of restricting
! which tests are to be run is insufficient.  So the method selected to
! help  determine  which  tests to run is implemented using the routine 
! RUN_TEST  which  is  called  at the beginning of each test.  RUN_TEST 
! examines a set of  error  flags  set  by individual tests in the Test
! Module.  If any  of  the error flags are set which match a predefined
! set of flags  for the particular test (ie. if flag 1 is set don't run
! Test 14) then the test is not run.  The flags are as follows:
! 
!   MRE_MEM   -   A ?MRE occurred when it shouldnt have on a memory access
!   MRE_IO    -   A ?MRE occurred when it shouldnt have on an I/O access
!   MRE_MEM_NOT - A ?MRE did not occur when it should have on a mem access
!   MRE_IO_NOT -  A ?MRE did not occur when it should have on an I/O access
!   MSR_READ   -  Could not read MSR
!   MSR_WRITE  -  Could not write MSR
!   MEM_READ   -  Could not read memory
!   MEM_WRITE  -  Could not write memory
!   TEST_ABORT -  A conclusive error occurred so abort future testing
!   ECC_SINGLE -  Could not get a single bit ECC error
!   ECC_DOUBLE -  Could not get a double bit ECC error
!   BUS_XCVR   -  Bus transceiver would not work
! 
! The use of these flags can be seen easily by example. For example, if
! the first test to attempt to read  the  MSR fails when it tries to do
! so, then no other tests would be attempted which required the ability
! to read  MSR.   Or  if  an early test fails to set ?MRE then some the 
! timing tests (which require ?MRE  to  be  set in order to run at all)
! would  not  be  run  at all.  The TEST_ABORT flag is set whenever the
! error found in a particular test is such that  the number of possible
! faulty networks is very low.  There is no point in  running  any more
! tests because the fault is well isolated already.
! 
!    Last of all is the Data Module. This really exists only at compile
! time.  It actually gets merged with the Test Module  and  the Control
! Module when MSMMC.EXE is  created.  It is created by a SNOBOL program
! taking  ERROR  and  NOERR network data out the the Test Module source
! code and creating a set of  PLIT's  and so forth for use by the fault
! isolation and error handling of the Control Module.
!			STIRS TESTS FOR MMC - M8618 BOARD
!
!
! SEQUENCE OF TESTS:
!
!	[1] Verify bus transceivers - connection to the bus	TST1
!								TST2
!
!	[2] Verify ability to read/write status			TST3
!
!	[3] Verify ability to read/write memory			TST4
!
!	[4] Verify read/write control bits			TST5
!
!	[5] Examine/deposit memory - Functional test		TST6
!
!	[6] Misc tests:  Verify 8080 reg bits when quiescent	TST7
!			 Verify 8646 parity generation		TST8
!
!	[7] Address logic tests - Board select logic		TST9
!				  Word enable logic		TST10
!				  Row/col logic			TST11
!				  Row/col logic			TST12
!				  Row/col logic			TST13
!
!	[8] Verify MSR - Read address logic			TST14
!			 Write address logic			TST15
!			 Write address logic			TST16
!			 MSR bits				TST17
!			 Parity error checking			TST18
!			 Error address register			TST19
!			 Force bits				TST20
!			 Parity generators			TST21
!			 Force check bits (loading of)		TST22
!			 Err.addr.register (loading of)		TST23
!			 Bus reset				TST24
!			 Mixers & select logic			TST25
!
!	[9] ECC Tests - 'MMC5 READ ERROR'			TST26
!			Detect single bit error			TST27
!			Detect double bit error			TST28
!			'MMC5 ERR HOLD'				TST29
!			Single bit error - no correction	TST30
!			Single bit error - correction		TST31
!			Single bit error - no correction	TST32
!			Single bit error - correction		TST33
!			Double bit error			TST34
!			Double bit error			TST35
!			Double bit error			TST36
!			Double bit error			TST37
!	[10] Examine/deposit memory - Functional test		TST38
!
!	[11] Misc - ?MRE causes 'ERR HOLD','ERR ADD LOAD'	TST39
!		    ?MRE - NXM afterwards			TST40
!
!	[12] Read/write timing - I/O write			TST41
!				 I/O read			TST42
!				 Memory write			TST43
!				 ?NXM				TST44
!				 Good vs. bad data cycle	TST45
!
!	[13] Refresh - 'REF ERR' set by ?MRE			TST46
!		       Refresh timing				TST47
!		       Refresh cycle				TST48
!		       Sync refresh debug routine		TST49
!		       Does mem actually get refreshed?		TST50
!
!	[14] MISC -    ECC - Verification of Check Bits		TST51
!		       not written				TST52
!		       not written				TST53
!		       not written				TST54
!		       not written				TST55
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	TST1:		NOVALUE,	! 8646 Bus Transceivers
	TST2:		NOVALUE,	! Verify Control Signals on the Bus
	TST3:		NOVALUE,	! Simple Write/Read Status
	TST4:		NOVALUE,	! Simple Write/Read Memory
	TST5:		NOVALUE,	! 'MMC3 READ','MMC3 WRITE' control bits
	TST6:		NOVALUE,	! 8646's, MOS Drivers, Data Path
	TST7:		NOVALUE,	! Verify 8080 Reg Bits When Mem Quiet
	TST8:		NOVALUE,	! 8646 Parity Gen/Chk
	TST9:		NOVALUE,	! Word Group Address Logic
	TST10:		NOVALUE,	! Word Group Address Logic

	TST11:		NOVALUE,	! Row/Col Address Logic
	TST12:		NOVALUE,	! Row/Col Address Logic
	TST13:		NOVALUE,	! Row/Col Address Logic
	TST14:		NOVALUE,	! MSR Read Address Logic
	TST15:		NOVALUE,	! MSR Write Address Logic
	TST16:		NOVALUE,	! MSR Write Address Logic
	TST17:		NOVALUE,	! Memory Status Register
	TST18:		NOVALUE,	! Parity Error
	TST19:		NOVALUE,	! Error Address Register
	TST20:		NOVALUE,	! Force Bits

	TST21:		NOVALUE,	! ECC:  Parity Gen's For Check Bits
	TST22:		NOVALUE,	! Force Check Bits Loading Of
	TST23:		NOVALUE,	! Error Address Register Loading Of
	TST24:		NOVALUE,	! Bus Reset
	TST25:		NOVALUE,	! Mixers & Select Logic
	TST26:		NOVALUE,	! ECC: Determining 'MMC5 READ ERROR'
	TST27:		NOVALUE,	! ECC:  Detection of Single Bit Errors
	TST28:		NOVALUE,	! ECC:  Detection of Double Bit Errors
	TST29:		NOVALUE,	! ECC:  Setting of 'ERR HOLD' Bit
	TST30:		NOVALUE,	! ECC:  1-Bit Error No Correction

	TST31:		NOVALUE,	! ECC:  1-Bit Error Correction
	TST32:		NOVALUE,	! ECC:  1-Bit Error No Correction
	TST33:		NOVALUE,	! ECC:  1-Bit Error Correction
	TST34:		NOVALUE,	! ECC:  2-Bit Error No Correction
	TST35:		NOVALUE,	! ECC:  2-Bit Error No Correction
	TST36:		NOVALUE,	! ECC:  2-Bit Error No Correction
	TST37:		NOVALUE,	! ECC:  2-Bit Error No Correction
	TST38:		NOVALUE,	! 8646's, MOS Drivers, Data Path
	TST39:		NOVALUE,	! ?MRE ==> MMC5 ERR HOLD / ERR ADD LOAD
	TST40:		NOVALUE,	! ?MRE / ?NXM
	TST41:		NOVALUE,	! Timing Of An I/O Write Instruction
	TST42:		NOVALUE,	! Timing Of An I/O Read Instruction
	TST43:		NOVALUE,	! Lengh of a Memory Write Access
	TST44:		NOVALUE,	! How Long Does ?NXM Tie Up MMC
	TST45:		NOVALUE,	! MMC Timing:  Good vs. Bad Data Cycle
	TST46:		NOVALUE,	! 'MMC9 REFRESH ERR' Set By ?MRE Error
	TST47:		NOVALUE,	! Refresh Timing
	TST48:		NOVALUE,	! Timing Test of Refresh Cycle (Length)
	TST49:		NOVALUE,	! Sync Refresh Debug Routine
	TST50:		NOVALUE,	! Refresh Test - Mem Getting Refreshed?

	TST51:		NOVALUE,	! ECC - Verification of Check Bits

	INIT:		NOVALUE,	! Reset Routine
	TEST_INIT:	NOVALUE,	! Initial Testing Initialization
	RUN_TEST,			! Determine if this test should be run
	SPEC_DIALOGUE:	NOVALUE,	! Special user I/O (not used)
	SPEC_PRT:	NOVALUE,	! Print the special specs (switches)
	SPEC_ASK:	NOVALUE,	! Ask for special questions
	WRITE_STATUS:	NOVALUE,	! Write MSR via 8080 regs
	READ_BUS,			! Read current contents of the bus
	HANG_MEM:	NOVALUE,	! Hang memory (causes refresh error)
	WRITE_COMADR:	NOVALUE,	! Write com/adr data to 8080 regs
	WRITE_DATA:	NOVALUE,	! Write data data to 8080 regs
	WRITE_CONTROL:	NOVALUE,	! Write control data to 8080 regs
	WRITE_CONTROL1:	NOVALUE,	! Write most of the control data
	SYNC_REFRESH;			! Synchronize refresh error occurrence

!
! EQUATED SYMBOLS:
!

GLOBAL LITERAL
	TEST_VERSION = 1,		! Current version and edit
	TEST_EDIT = 0;			!   numbers

LITERAL
	ECC_OFF = 1,			! MSR code for turning ECC off
	ECC_ON = 0,			! MSR code for turning ECC on
	PE_SET = %O'040000000000',	! MSR code for setting PE
	PE_CLR = 0,			! MSR code for clearing PE
	MSR = %O'100000';		! MSR I/O address

GLOBAL BIND
	MSGFIL = UPLIT (%SIXBIT'MSMMC', %SIXBIT'MSG'),
	PRGNAM = UPLIT (%ASCIZ'KS10 STIMULUS-RESPONSE DIAGNOSTIC FOR THE M8618/MMC BOARD');

!
! OWN STORAGE:
!

OWN
	RUN_ERR_VECT: VECTOR[15],	! Used to determine if test to be run
					!   by keeping track of prior errors
	DEBUG: INITIAL(0),		! Special debugging switches mostly for
	DEBUG1: INITIAL(0),		!   debugging the sync refresh routine
	MMA_MAP: VECTOR[8]		! Memory map (1 if that block of 64k
	    INITIAL (0,0,0,0,0,0,0,0),	!   exists
	MAX_MEM,			! Max amount of memory available
	NOERR_MAP: VECTOR[55]		! Vector to keep track of whether or
	    INITIAL (-1,-1,-1,-1,-1,-1	!   not an error has occurred in a test
	       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
	       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1),
	MRE_TICKS: INITIAL (804);	! # of ticks from one ?MRE to the next
BIND
	MRE_MEM = RUN_ERR_VECT[0],	! A ?MRE occurred when it shouldnt have
	MRE_IO = RUN_ERR_VECT[1],	!   on a memory / I/O access
	MRE_MEM_NOT = RUN_ERR_VECT[2],	! A ?MRE did not occur when it should
	MRE_IO_NOT = RUN_ERR_VECT[3],	!   have on a memory / I/O access
	MSR_READ = RUN_ERR_VECT[4],	! Could not read MSR
	MSR_WRITE = RUN_ERR_VECT[5],	! Could not write MSR
	MEM_READ = RUN_ERR_VECT[6],	! Could not read memory
	MEM_WRITE = RUN_ERR_VECT[7],	! Could not write memory
	TEST_ABORT = RUN_ERR_VECT[8],	! A fatal or conclusive error occurred
					!   so abort future testing
	ECC_SINGLE = RUN_ERR_VECT[9],	! Could not get a single bit ECC error
	ECC_DOUBLE = RUN_ERR_VECT[10],	! Could not get a double bit ECC error
	BUS_XCVR = RUN_ERR_VECT[11],	! Bus transceiver would not work

	NOERR_1 = NOERR_MAP[1],		! Did an error occur in test N
	NOERR_2 = NOERR_MAP[2],		!   if not NOERR_N = 0
	NOERR_3 = NOERR_MAP[3],		!   if so  NOERR_N # 0
	NOERR_4 = NOERR_MAP[4],		!	  ....
	NOERR_5 = NOERR_MAP[5],		!	  ....
	NOERR_6 = NOERR_MAP[6],
	NOERR_7 = NOERR_MAP[7],
	NOERR_8 = NOERR_MAP[8],
	NOERR_9 = NOERR_MAP[9],
	NOERR_10 = NOERR_MAP[10],

	NOERR_11 = NOERR_MAP[11],
	NOERR_12 = NOERR_MAP[12],
	NOERR_13 = NOERR_MAP[13],
	NOERR_14 = NOERR_MAP[14],
	NOERR_15 = NOERR_MAP[15],
	NOERR_16 = NOERR_MAP[16],
	NOERR_17 = NOERR_MAP[17],
	NOERR_18 = NOERR_MAP[18],
	NOERR_19 = NOERR_MAP[19],
	NOERR_20 = NOERR_MAP[20],

	NOERR_21 = NOERR_MAP[21],
	NOERR_22 = NOERR_MAP[22],
	NOERR_23 = NOERR_MAP[23],
	NOERR_24 = NOERR_MAP[24],
	NOERR_25 = NOERR_MAP[25],
	NOERR_26 = NOERR_MAP[26],
	NOERR_27 = NOERR_MAP[27],
	NOERR_28 = NOERR_MAP[28],
	NOERR_29 = NOERR_MAP[29],
	NOERR_30 = NOERR_MAP[30],

	NOERR_31 = NOERR_MAP[31],
	NOERR_32 = NOERR_MAP[32],
	NOERR_33 = NOERR_MAP[33],
	NOERR_34 = NOERR_MAP[34],
	NOERR_35 = NOERR_MAP[35],
	NOERR_36 = NOERR_MAP[36],
	NOERR_37 = NOERR_MAP[37],
	NOERR_38 = NOERR_MAP[38],
	NOERR_39 = NOERR_MAP[39],
	NOERR_40 = NOERR_MAP[40],

	NOERR_41 = NOERR_MAP[41],
	NOERR_42 = NOERR_MAP[42],
	NOERR_43 = NOERR_MAP[43],
	NOERR_44 = NOERR_MAP[44],
	NOERR_45 = NOERR_MAP[45],
	NOERR_46 = NOERR_MAP[46],
	NOERR_47 = NOERR_MAP[47],
	NOERR_48 = NOERR_MAP[48],
	NOERR_49 = NOERR_MAP[49],
	NOERR_50 = NOERR_MAP[50],

	NOERR_51 = NOERR_MAP[51],
	NOERR_52 = NOERR_MAP[52],
	NOERR_53 = NOERR_MAP[53],
	NOERR_54 = NOERR_MAP[54],
	NOERR_55 = NOERR_MAP[55];

!
! MACROS:
!

MACRO
	PAR_DISABLE = PE(0)%,		! Disable parity error detection
	PAR_ENABLE = PE(7)%,		! Enable parity error detection
	START_CLK = WRT205(0)%,		! Start the clock (was in ss mode)
	STOP_CLK = WRT205(MNT_CLK_ENB)%;! Stop  the clock (put in ss mode)

!
! STRUCTURES:
!

STRUCTURE
	BTTVECTOR[I;N]=[1]		! A real PDP-10 bit vector
		(BTTVECTOR)		!   (36 bits long)
		<35-I,1>,
	BIT8646[I;N]=[N]		! Special 8646 data path vector
		(BIT8646)
		<32-I*4+((I+1)/5)*2,4-(I EQL 4 OR I EQL 9)*2>;
!
! INCLUDE FILES:
!

SWITCHES LIST(NOSOURCE);
REQUIRE 'STIRSD.R36';			! Stirs common declarations
REQUIRE 'CSLMAC.R36';			! CSL macros (UUO's etc..)
REQUIRE 'KSU.R36';			! Microcode macros
SWITCHES LIST(SOURCE);
REQUIRE 'REGBIT.R36';			! 8080 register bit definitions

GLOBAL ROUTINE TST1: NOVALUE =
!++   ------------------ 8646 BUS TRANCEIVERS ------------------
! TEST DESCRIPTION:  This test checks out the 8646  transceivers
!	on the MMC board which are connected directly to the bus.
!	It verifies that the interface with the bus on the 8646's
!	is not stuck at 0/1.  This test tries not to do anything
!	to the MMC board - just verify its connection to the bus.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write 8080 registers for a write to memory
!			Com/Adr Cycle Bits 00-35:
!			  Bits 00-03 8080 Reg 113
!			       04-11      Reg 111
!			       12-19      Reg 107
!			       20-27      Reg 105
!			       28-35      Reg 103
!			Data all 0's
!		   Set XMIT_ADR Bit - Put address data on the bus
!		   Read the data off the bus and check it
!		   Repeat the test with 1's on the bus
!
! POSSIBLE ERRORS:  8646 Bus Tranceivers on MMC1 are faulty.
!
!--

BEGIN

LOCAL
	ERR,				! Temporary variable
	TEMP,				! Temporary variable
	ERR_FLAG;			! Error flag - set to 1 if an error
					!   has occurred so far
OWN
	MESSV: VECTOR[2],		! Error output vector
	BUS_DATA,			! Bus data read from the bus
	TEST_DATA,			! Test data send to the bus
	TEST_TEMP_VECT: BIT8646[1],	! Temporary storage area for comparison
	MESS_STR: VECTOR[10]		! Message Strings
	    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
		    UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
		    UPLIT(%ASCIZ '16-17'),UPLIT(%ASCIZ '18-21'),
		    UPLIT(%ASCIZ '22-25'),UPLIT(%ASCIZ '26-29'),
		    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'));

BIND
	TEST_TEMP = TEST_TEMP_VECT;

LABEL
	BLOCK1;

RPT_ERR_FLAG = 0;			! Don't report unexpected error
NOERR_1 = 0;				! No errors have occurred yet

DECR TEST_DATA FROM 0 TO -1 BY 1 DO
	BEGIN
	MESSV[1] = (.TEST_DATA EQL -1);
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR(0);			! Master Reset

	    WRT115(0);			! Dont want to start com/adr or a
	    WRT114(0);			!   data cycle - just put data on bus
	    WRITE_COMADR(.TEST_DATA);		
	    WRT210(MEM+BUS_REQ+XMIT_ADR+CLOSE_LATCH);
	    BUS_DATA = READ_BUS();	! Find out what is now on the bus
	    ERR_FLAG = 0;		! No error has occurred yet

! Look for and report any single bit errors.

	    INCR BTT FROM 0 TO 35 DO
		BEGIN			
		TEMP = .BUS_DATA XOR (1 ^ (35-.BTT));
		IF .TEMP EQL .TEST_DATA
		    THEN BEGIN
			 MESSV[0] = .BTT;
			 ERR_FLAG = 1;
			 ERRCAS(.BTT+1,1,.TEST_DATA,.BUS_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If no errors have occurred yet check for multiple bit errors matching
!   a single transceiver.

	    ERR = (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .BUS_DATA);
	    INCR BTT FROM 0 TO 9 DO
		BEGIN
		TEST_TEMP = 0;
		TEST_TEMP_VECT[.BTT] = %O'777777';
		TEMP = .BUS_DATA OR .TEST_TEMP;
		IF .TEMP EQL (.TEST_DATA OR .TEST_TEMP) AND (.ERR EQL 1)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 MESSV[0] = .MESS_STR[.BTT];
			 ERRCAS(.BTT+37,2,.TEST_DATA,.BUS_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 37) THEN LEAVE BLOCK1 WITH 1;
		END;

! Well, if no specific error has been found yet and the correct/actual
!   is different then the whole data path is bad or random sections of
!   it are bad so report the fact.

	    IF (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .BUS_DATA)
		THEN BEGIN
		     ERR_FLAG = 1;
		     ERRCAS(47,3,.TEST_DATA,.BUS_DATA,12,MESSV);
		     END;
	    IF LOOP_CHK(47) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG NEQ 0 THEN TEST_ABORT = 1;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS
!*	WRT 113,105,107,111,103 - Write 0's to the 8080 bus
!*				  data registers
!*	WRT 210/143 - Set:  CONSOLE REQ, T ENB FOR COM/ADR,
!*			    LATCH DATA SENT, R CLK ENB L
!*	RD 103,3,2,1,0 - 8080 Regs should contain the data
!*			 put on the bus
!*RESPONSE
!*	Bus data bit \D0 is stuck at \D1

!]ERROR 1
!] A1  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] A1  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] A1  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] A1  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] B1  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] B1  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] B1  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] B1  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] C1  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] C1  NTWK
!]NO ERROR 10
!]  NTWK

!]ERROR 11
!] C1  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] C1  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] D1  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] D1  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] D1  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] D1  NTWK
!]NO ERROR 16
!]  NTWK

!]ERROR 17
!] E1  NTWK
!]NO ERROR 17
!]  NTWK

!]ERROR 18
!] E1  NTWK
!]NO ERROR 18
!]  NTWK

!]ERROR 19
!] F1  NTWK
!]NO ERROR 19
!]  NTWK

!]ERROR 20
!] F1  NTWK
!]NO ERROR 20
!]  NTWK

!]ERROR 21
!] F1  NTWK
!]NO ERROR 21
!]  NTWK

!]ERROR 22
!] F1  NTWK
!]NO ERROR 22
!]  NTWK

!]ERROR 23
!] G1  NTWK
!]NO ERROR 23
!]  NTWK

!]ERROR 24
!] G1  NTWK
!]NO ERROR 24
!]  NTWK

!]ERROR 25
!] G1  NTWK
!]NO ERROR 25
!]  NTWK

!]ERROR 26
!] G1  NTWK
!]NO ERROR 26
!]  NTWK

!]ERROR 27
!] H1  NTWK
!]NO ERROR 27
!]  NTWK

!]ERROR 28
!] H1  NTWK
!]NO ERROR 28
!]  NTWK

!]ERROR 29
!] H1  NTWK
!]NO ERROR 29
!]  NTWK

!]ERROR 30
!] H1  NTWK
!]NO ERROR 30
!]  NTWK

!]ERROR 31
!] I1  NTWK
!]NO ERROR 31
!]  NTWK

!]ERROR 32
!] I1  NTWK
!]NO ERROR 32
!]  NTWK

!]ERROR 33
!] I1  NTWK
!]NO ERROR 33
!]  NTWK

!]ERROR 34
!] I1  NTWK
!]NO ERROR 34
!]  NTWK

!]ERROR 35
!] J1  NTWK
!]NO ERROR 35
!]  NTWK

!]ERROR 36
!] J1  NTWK
!]NO ERROR 36
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	WRT 113,105,107,111,103 - Write 0's to the 8080 bus
!*				  data registers
!*	WRT 210/143 - Set:  CONSOLE REQ, T ENB FOR COM/ADR,
!*			    LATCH DATA SENT, R CLK ENB L
!*	RD 103,3,2,1,0 - 8080 Regs should contain the data
!*			 put on the bus
!*RESPONSE
!*	Bus data bits \S0 are stuck at \D1

!]ERROR 37
!] A1  NTWK
!]NO ERROR 37
!]  NTWK

!]ERROR 38
!] B1  NTWK
!]NO ERROR 38
!]  NTWK

!]ERROR 39
!] C1  NTWK
!]NO ERROR 39
!]  NTWK

!]ERROR 40
!] D1  NTWK
!]NO ERROR 40
!]  NTWK

!]ERROR 41
!] E1  NTWK
!]NO ERROR 41
!]  NTWK

!]ERROR 42
!] F1  NTWK
!]NO ERROR 42
!]  NTWK

!]ERROR 43
!] G1  NTWK
!]NO ERROR 43
!]  NTWK

!]ERROR 44
!] H1  NTWK
!]NO ERROR 44
!]  NTWK

!]ERROR 45
!] I1  NTWK
!]NO ERROR 45
!]  NTWK

!]ERROR 46
!] J1  NTWK
!]NO ERROR 46
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	WRT 113,105,107,111,103 - Write 0's to the 8080 bus
!*				  data registers
!*	WRT 210/143 - Set:  CONSOLE REQ, T ENB FOR COM/ADR,
!*			    LATCH DATA SENT, R CLK ENB L
!*	RD 103,3,2,1,0 - 8080 Regs should contain the data
!*			 put on the bus
!*RESPONSE
!*	Bus data bits 00-35 has some bits stuck at \D1

!]ERROR 47
!] A1 B1 C1 D1 E1 F1 G1 H1 I1 J1 L7 AA  NTWK
!]NO ERROR 47
!]  NTWK

END;
GLOBAL ROUTINE TST2: NOVALUE =

!++   ------------ VERIFY CONTROL SIGNALS ON THE BUS ---------------
! TEST DESCRIPTION:  This routine verifies that  the control signals
!	on the bus ('AC LO','RESET','MEM BUSY','I/O BUSY','BAD DATA',
!	'COM ADR','I/O DATA', and 'DATA') are  not  stuck low on the
!	MMC board.  A Master Reset is done - then  these signals are
!	inspected.  None of them should be asserted.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Read 8080 I/O Reg 102
!		   Verify that each bit is 0
!			'RESET'
!			'MEM BUSY'
!			'I/O BUSY'
!			'BAD DATA'
!			'COM ADR'
!			'I/O DATA'
!			'DATA'
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

OWN
	REG;

LABEL
	BLOCK1;

IF RUN_TEST(2) THEN RETURN;		! Run this test? Return if no

RPT_ERR_FLAG = 1;			! Report any unexpected errors
NOERR_2 = 0;				! No errors have occurred yet

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	REG = RD_102;			! Read 8080 Reg 102
	IF (.REG AND RRESET) NEQ 0
	    THEN BEGIN			! Not 0?  Error - print error message
		 TEST_ABORT = 1;	!   and abort further testing.
		 ERRS(1,1,REG);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF (.REG AND RMEM_BUSY) NEQ 0
	    THEN BEGIN			! Not 0?  Error - print error message
		 TEST_ABORT = 1;	!   and abort further testing.
		 ERRS(2,2,REG);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
	IF (.REG AND RIO_BUSY) NEQ 0
	    THEN BEGIN			! Not 0?  Error - print error message
		 TEST_ABORT = 1;	!   and abort further testing.
		 ERRS(3,3,REG);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	IF (.REG AND RBAD_DATA) NEQ 0
	    THEN BEGIN			! Not 0?  Error - print error message
		 TEST_ABORT = 1;	!   and abort further testing.
		 ERRS(4,4,REG);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	IF (.REG AND RCOM_ADR) NEQ 0
	    THEN BEGIN			! Not 0?  Error - print error message
		 TEST_ABORT = 1;	!   and abort further testing.
		 ERRS(5,5,REG);
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
	IF (.REG AND RIO_DATA) NEQ 0
	    THEN BEGIN			! Not 0?  Error - print error message
		 TEST_ABORT = 1;	!   and abort further testing.
		 ERRS(6,6,REG);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
	IF (.REG AND RDATA) NEQ 0
	    THEN BEGIN			! Not 0?  Error - print error message
		 TEST_ABORT = 1;	!   and abort further testing.
		 ERRS(7,7,REG);
		 END;
	IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
!*RESPONSE
!*	'RESET' signal is asserted     102:  \O0

!]ERROR 1
!] DB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
!*RESPONSE
!*	'MEM BUSY' signal is asserted     102:  \O0

!]ERROR 2
!] N3 I5 AB DB  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
!*RESPONSE
!*	'I/O BUSY' signal is asserted     102:  \O0

!]ERROR 3
!] F3 DB  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
!*RESPONSE
!*	'BAD DATA' signal is asserted     102:  \O0

!]ERROR 4
!] AA BA  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
!*RESPONSE
!*	'COM ADR' signal is asserted     102:  \O0

!]ERROR 5
!] BA  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
!*RESPONSE
!*	'I/O DATA' signal is asserted     102:  \O0

!]ERROR 6
!] L7 DB  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
!*RESPONSE
!*	'DATA' signal is asserted     102:  \O0

!]ERROR 7
!] AA BA  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST3: NOVALUE =

!++   ------------------- SIMPLE WRITE/READ STATUS ------------------
! TEST DESCRIPTION:  This routine verifies that something can be done
!	with the MMC board.  This test merely attempts a write status
!	and a read status. If MMC hangs after either (causing ?MRE or
!	?NXM)  or  MMC just doesnt do anything then something is very
!	wrong with the board.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Sync T & R Clocks (in maintenance mode)
!		   Set up 8080 registers for a Com/Adr cycle
!			indicating an I/O read & 0's data
!		   Write control bits needed to do the operation
!		   Tick the clock until 'I/O BUSY' has asserted
!			and cleared or 25 T Clocks (100 ticks)
!			whichever comes first
!		   Verify response:  There should be no errors
!			(particularly no ?MRE)
!
!		   Repeat with an I/O write
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	READ_IO = %O'600000100000',	! Read MSR
	WRITE_IO = %O'500000100000';	! Write MSR

OWN
	MESSV: VECTOR[5];		! Error message output vector

BIND
	TICK1 = MESSV,
	TICK2 = MESSV[1],
	REG102 = MESSV[2],
	REG102A = MESSV[3],
	REG101 = MESSV[4],
	REF_ERR = UPLIT(%ASCIZ '?MRE');	! For CHK_ERR_MSG routine

LABEL
	BLOCK1,
	BLOCK2;

IF RUN_TEST(3) THEN RETURN;		! Run this test? Return if no

RPT_ERR_FLAG = 0;			! Don't report unexpected error
NOERR_3 = 0;				! No errors have occurred yet

DO (0) WHILE
BLOCK1:	BEGIN
!
!----  READ  ----
!
	MR();				! Master Reset
	SYNC_CLK();			! Put clock in maintenance mode
	WRITE_COMADR(READ_IO);		! Start an I/O read
	WRITE_CONTROL();
	TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;

	DO  BEGIN
	    TICK(4);			! Tick along until 'I/O BUSY' appears
	    REG102 = RD_102;		!   in Reg 102 (but not past a timeout
	    CHK_ERR_MSG(REF_ERR);	!   error or 100 ticks).  Check for
	    TICK1 = .TICK1 + 4;		!   unexpected error messages and
	    END				!   discard them.
	WHILE (.TICK1 LSS 100 AND (.REG102 AND RIO_BUSY) EQL 0 AND .TIMOUT EQL 0);

	IF .TIMOUT EQL 0		! If it didnt timeout then tick along
	    THEN BEGIN			!   until 'I/O BUSY' clears from 102
		 DO  BEGIN		!   (but not past a timeout error or
		     TICK(4);		!   100 ticks).  Also discard any
		     REG102A = RD_102;	!   unexpected error messages gotten.
		     CHK_ERR_MSG(REF_ERR);
		     TICK2 = .TICK2 + 4;
		     END
		 WHILE (.TICK2 LSS 100 AND (.REG102A AND RIO_BUSY) NEQ 0 AND .TIMOUT EQL 0);
		 END;

! Now do error handling.

	IF .TIMOUT EQL 1		! Was there a timout error - if yes
	    THEN BEGIN			!   set error flags and print error
		 NOERR_3 = 1;		!   messages.
		 ERRS(1,1,MESSV);
		 IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	START_CLK;			! All done fiddling so start up clock
	SEND_NUL();			!   and discard any more unexpected
	CHK_ERR_MSG(REF_ERR);		!   error message that appear.

	REG101 = RD_101;		! Read I/O Reg 101 to see if ?MRE
	IF (.REG101 AND 1) EQL 1	!   occurred at any point back there.
	    THEN BEGIN			! If so set error flags and print
		 MRE_IO = 1;		!   error messages.
		 NOERR_3 = 1;
		 ERRS(2,2,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK1 NEQ 100		! Did the MSR read fail (1st half)?
	    THEN BEGIN			! If so set error flags and
		 MSR_READ = 1;		!   print error message.
		 NOERR_3 = 1;
		 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK2 EQL 100		! Did the MSR read fail (2nd half)?
	    THEN BEGIN			! If so set error flags and print
		 MSR_READ = 1;		!   error message.
		 NOERR_3 = 1;
		 ERRS(4,4,MESSV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

DO (0) WHILE
BLOCK2:	BEGIN
!
!----  WRITE  ----
!
	MR();				! Master Reset
	SYNC_CLK();			! Put clock in maintenance mode
	WRITE_COMADR(WRITE_IO);		! Start and I/O write
	WRITE_DATA(0);
	WRITE_CONTROL();
	TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;

	DO  BEGIN			! Tick along until 'I/O BUSY' appears
	    TICK(4);			!   in Reg 102 (but not past a timout
	    REG102 = RD_102;		!   error or 100 ticks).  Check for
	    CHK_ERR_MSG(REF_ERR);	!   unexpected error messages and
	    TICK1 = .TICK1 + 4;		!   discard them.
	    END
	WHILE (.TICK1 LSS 100 AND (.REG102 AND RIO_BUSY) EQL 0 AND .TIMOUT EQL 0);
	IF .TIMOUT EQL 0		! If it didnt timeout then tick along
	    THEN BEGIN			!   until 'I/O BUSY' clears from 102
		 DO  BEGIN		!   (but not past a timeout error or
		     TICK(4);		!   100 ticks).  Also discard any
		     REG102A = RD_102;	!   unexpected error messages gotten.
		     CHK_ERR_MSG(REF_ERR);
		     TICK2 = .TICK2 + 4;
		     END
		 WHILE (.TICK2 LSS 100 AND (.REG102A AND RIO_BUSY) NEQ 0 AND .TIMOUT EQL 0);
		 END;

! Now do error handling.

	IF .TIMOUT EQL 1		! Was there a timout error - if yes
	    THEN BEGIN			!   set error flags and print error
		 NOERR_3 = 1;		!   messages.
		 ERRS(5,5,MESSV);
		 IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;

	START_CLK;			! All done fiddling so start up clock
	SEND_NUL();			!   and discard any more unexpected
	CHK_ERR_MSG(REF_ERR);		!   error message that appear.
	
	REG101 = RD_101;		! Read I/O Reg 101 to see if ?MRE
	IF (.REG101 AND 1) EQL 1	!   occurred at any point back there.
	    THEN BEGIN			! If so set error flags and print
		 MRE_IO = 1;		!   error messages.
		 NOERR_3 = 1;
	    	 ERRS(6,6,MESSV);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;

	IF .TICK1 EQL 100		! Did the MSR write fail (1st half)?
	    THEN BEGIN			! If so set error flags and
		 MSR_WRITE = 1;		!   print error message.
		 NOERR_3 = 1;
		 ERRS(7,7,MESSV);
		 END;
	IF LOOP_CHK(7) THEN LEAVE BLOCK2 WITH 1;

	IF .TICK2 EQL 100		! Did the MSR write fail (2nd half)?
	    THEN BEGIN			! If so set error flags and print
		 MSR_WRITE = 1;		!   error message.
		 NOERR_3 = 1;
		 ERRS(8,8,MESSV);
		 END;
	IF LOOP_CHK(8) THEN LEAVE BLOCK2 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
!*	  (It should assert only on a 'STATUS I/O WRITE') then watch
!*	  for it to clear
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3

!]ERROR 1
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
!*	  (It should assert only on a 'STATUS I/O WRITE')
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	?MRE occurred - MMC hung?
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
!*	8080 REG 101: \O4

!]ERROR 2
!] A1 K1 E3 F3 L7 A9 B9 C9 AA AB BB CB BC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
!*	  (It should assert only on a 'STATUS I/O WRITE')
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'I/O BUSY' appeared in Reg 102 
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3

!]ERROR 3
!] A1 E3 F3 L7 DB BC  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
!*	  (It should assert only on a 'STATUS I/O WRITE')
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'I/O BUSY' still asserted in Reg 102
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3

!]ERROR 4
!] A1 E3 F3 L7 DB BC  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Write 0's to Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3

!]ERROR 5
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Write 0's to Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	?MRE occurred - MMC hung?
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
!*	8080 Reg 101: \O4

!]ERROR 6
!] A1 K1 E3 F3 L7 A9 B9 C9 AA AB BB CB BC  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Write 0's to Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'I/O BUSY' never appeared in Reg 102
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3

!]ERROR 7
!] A1 D1 E1 F1 H1 J1 K1 E3 F3 I3 J3 K3 L3 M3 N3 L7 DB BC  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Write 0's to Mem Stat Reg
!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA,
!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'I/O BUSY' never cleared from Reg 102
!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3

!]ERROR 8
!] A1 E3 F3 I3 J3 K3 L3 M3 N3 L7 DB BC  NTWK
!]NO ERROR 8
!]  NTWK

END;
GLOBAL ROUTINE TST4: NOVALUE =

!++   ------------------- SIMPLE WRITE/READ MEMORY ------------------
! TEST DESCRIPTION:  This routine verifies that something can be done
!	with the MMC board.  This test merely attempts a write memory
!	and a read memory. If MMC hangs after either (causing ?MRE or
!	?NXM)  or  MMC just doesnt do anything then something is very
!	wrong with the board.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Sync T & R Clocks (In maintenance mode)
!		   Set up 8080 registers for a Com/Adr cycle
!			indicating an mem read & 0's data
!		   Write control bits needed to do the operation
!		   Tick the clock until 'MEM BUSY' has asserted
!			and cleared or 25 T Clocks (100 ticks)
!			whichever comes first
!		   Verify response:  There should be no errors
!			(particularly no ?MRE)
!
!		   Repeat with an mem write
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	READ_MEM = %O'200000000000',	! Read mem loc 0
	WRITE_MEM = %O'100000000000';	! Write mem loc 0

OWN
	MESSV: VECTOR[6];		! Error message output vector

BIND
	TICK1 = MESSV,
	TICK2 = MESSV[1],
	REG102 = MESSV[2],
	REG102A = MESSV[3],
	REG101 = MESSV[4],
	REG301 = MESSV[5],
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LABEL
	BLOCK1,
	BLOCK2;

IF RUN_TEST(4) THEN RETURN;		! Run this test? Return if no

RPT_ERR_FLAG = 0;			! Don't report unexpected error
NOERR_4 = 0;				! No errors have occurred yet

DO (0) WHILE
BLOCK1:	BEGIN
!
!----  READ  ----
!
	MR();				! Master Reset
	SYNC_CLK();			! Put clocks in maintenance mode
	WRITE_COMADR(READ_MEM);		! Start a memory read
	WRITE_CONTROL();
	TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;

	DO  BEGIN
	    TICK(4);			! Tick along until 'MEM BUSY' appears
	    REG102 = RD_102;		!   in Reg 102 (but not past a timeout
	    CHK_ERR_MSG(REF_ERR);	!   error or 100 ticks).  Check for 
	    TICK1 = .TICK1 + 4;		!   unexpected error messages and
	    END				!   discard them.
	WHILE (.TICK1 LSS 100 AND (.REG102 AND RMEM_BUSY) EQL 0 AND .TIMOUT EQL 0);

	IF .TIMOUT EQL 0		! If it didnt timeout then tick along
	    THEN BEGIN			!   until 'MEM BUSY' clears from 102
		 DO  BEGIN		!   (but not past a timeout error or
		     TICK(4);		!   100 ticks).  Also discard any
		     REG102A = RD_102;	!   unexpected error messages gotten.
		     CHK_ERR_MSG(REF_ERR);
		     TICK2 = .TICK2 + 4;
		     END
		 WHILE (.TICK2 LSS 100 AND (.REG102A AND RMEM_BUSY) NEQ 0 AND .TIMOUT EQL 0);
		 END;

! Now do error handling.

	IF .TIMOUT EQL 1		! Was there a timeout error - if yes
	    THEN BEGIN			!   set error flags and print error
		 NOERR_4 = 1;		!   messages.
		 ERRS(1,1,MESSV);
		 IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	START_CLK;			! All done fiddling so start up clock
	SEND_NUL();			!   and discard any more unexpected
	CHK_ERR_MSG(REF_ERR);		!   error message that appear.

	REG301 = RD_301;		! Read I/O Regs 301 and 101 to see if
	REG101 = RD_101;		!   ?NXM or ?MRE occurred at any point
	IF (.REG101 AND 1) EQL 1	!   back there.
	    THEN BEGIN			! If so set error flags and print
		 MRE_MEM = 1;		!   error messages.
		 NOERR_4 = 1;
	    	 ERRS(2,2,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF (.REG301 AND NEXM) NEQ 0	! Did we get a ?NXM - If so set
	    THEN BEGIN			!   error flags and print error
		 NOERR_4 = 1;		!   message.
		 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK1 EQL 100		! Did the mem read fail (1st half)?
	    THEN BEGIN			! If so set error flags and
		 NOERR_4 = 1;		!   print error message.
		 ERRS(4,4,MESSV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK2 EQL 100		! Did the mem read fail (2nd half)?
	    THEN BEGIN			! If so set error flags and print
		 NOERR_4 = 1;		!   error message.
		 ERRS(5,5,MESSV);
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

DO (0) WHILE
BLOCK2:	BEGIN
!
!----  WRITE  ----
!
	MR();				! Master Reset
	SYNC_CLK();			! Put clock in maintenance mode
	WRITE_COMADR(WRITE_MEM);	! Start and mem write
	WRITE_DATA(0);			! Tick along until 'MEM BUSY' appears
	WRITE_CONTROL();
	TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;

	DO  BEGIN			! Tick along until 'MEM BUSY' appears
	    TICK(4);			!   in Reg 102 (but not past a timout
	    REG102 = RD_102;		!   error or 100 ticks).  Check for
	    CHK_ERR_MSG(REF_ERR);	!   unexpected error messages and
	    TICK1 = .TICK1 + 4;		!   discard them.
	    END
	WHILE (.TICK1 LSS 100 AND (.REG102 AND RMEM_BUSY) EQL 0 AND .TIMOUT EQL 0);

	DO  BEGIN			! Now tick along until 'MEM BUSY'
	    TICK(4);			!   clears from Reg 102 (but not past
	    REG102A = RD_102;		!   a timeout error or 100 ticks).
	    CHK_ERR_MSG(REF_ERR);	!   Also discard any unexpected error
	    TICK2 = .TICK2 + 4;		!   messages gotten.
	    END
	WHILE (.TICK2 LSS 100 AND (.REG102A AND RMEM_BUSY) NEQ 0 AND .TIMOUT EQL 0);


! Now do error handling.

	IF .TIMOUT EQL 1		! Was there a timout error - if yes
	    THEN BEGIN			!   set error flags and print error
		 NOERR_4 = 1;		!   messages.
		 ERRS(6,6,MESSV);
		 IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;

	START_CLK;			! All done fiddling so start up clock
	SEND_NUL();			!   and discard any more unexpected
	CHK_ERR_MSG(REF_ERR);		!   error message that appear.

	REG301 = RD_301;		! Read I/O Regs 301,101 to see if ?NXM
	REG101 = RD_101;		!   or ?MRE occurred at any point back
	IF (.REG101 AND 1) EQL 1	!   there.
	    THEN BEGIN			! If so set error flags and print
		 MRE_MEM = 1;		!   error messages.
		 NOERR_4 = 1;
	    	 ERRS(7,7,MESSV);
		 END;
	IF LOOP_CHK(7) THEN LEAVE BLOCK2 WITH 1;

	IF (.REG301 AND NEXM) NEQ 0	! If ?NXM occurred set error flags
	    THEN BEGIN			!   and print error messages.
		 NOERR_4 = 1;
		 ERRS(8,8,MESSV);
		 END;
	IF LOOP_CHK(8) THEN LEAVE BLOCK2 WITH 1;

	IF .TICK1 EQL 100		! Did the mem write fail (1st half)?
	    THEN BEGIN			! If so set error flags and
		 NOERR_4 = 1;		!   print error message.
		 ERRS(9,9,MESSV);
		 END;
	IF LOOP_CHK(9) THEN LEAVE BLOCK2 WITH 1;

	IF .TICK2 EQL 100		! Did the mem write fail (2nd half)?
	    THEN BEGIN			! If so set error flags and print
		 NOERR_4 = 1;		!   error message.
		 ERRS(10,10,MESSV);
		 END;
	IF LOOP_CHK(10) THEN LEAVE BLOCK2 WITH 1;

	0				! To eliminate INFO compiler message
	END;

! If no errors occurred in tests 3 and 4 (MSR read/write and mem read/write)
!   then  the  flops 'MMC3 READ' and 'MMC3 WRITE' have to be ok so eliminate
!   from the STIRS fault isolation vector.  By calling NOERR  specifying the
!   two networks I3 - 'MMC3 READ' and O3 - 'MMC3 WRITE'.

	IF (.NOERR_3 OR .NOERR_4) EQL 0
	    THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read mem loc 0
!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
!*	  then watch for it to disappear
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3

!]ERROR 1
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 1
!] I3 O3  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read mem loc 0
!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	?MRE occurred - MMC hung?
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 2
!] A1 K1 EFION3 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read mem loc 0
!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	?NXM occurred
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 3
!] A1 K1 E3 F3 J3 K3 L3 N3 C5 A7 B7 L7 A9 A8 AA AB BB CB DB  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read mem loc 0
!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'MEM BUSY' never appeared in Reg 102
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 4
!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read mem loc 0
!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'MEM BUSY' never cleared from Reg 102
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 5
!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Read mem loc 0
!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
!*	  then watch for it to disappear
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3

!]ERROR 6
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Write 0's to mem loc 0
!*	LR 210,DR 360	    Write 'MEM WRITE' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	?MRE occurred - MMC hung?
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 7
!] A1 K1 EFION3 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - WRITE 0'S TO MEM LOC 0
!*	LR 210,DR 360	    Write 'MEM WRITE' control bits - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	?NXM occurred
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 8
!] A1 K1 E3 F3 J3 K3 L3 N3 C5 A7 B7 L7 A9 A8 AA AB BB CB DB  NTWK
!]NO ERROR 8
!]  NTWK

!*MESSAGE 9
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - WRITE 0'S TO MEM LOC 0
!*	LR 210,DR 360	    WRITE 'MEM WRITE' CONTROL BITS - CHECK NXM,CONSOLE
!*				REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'MEM BUSY' never appeared in Reg 102
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 9
!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
!]NO ERROR 9
!]  NTWK

!*MESSAGE 10
!*STIMULUS
!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
!*				Regs 102...115 - Write 0's to mem loc 0
!*	LR 210,DR 360	    Write 'MEM WRITE' write control bits - CHECK NXM,
!*				CONSOLE REQ,T ENB FOR COM/ADR & DATA
!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
!*	Turn clocks back on then check to see if a ?MRE results
!*RESPONSE
!*	'MEM BUSY' never cleared from Reg 102
!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
!*	8080 Regs 101: \O4    301: \O5

!]ERROR 10
!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
!]NO ERROR 10
!]  NTWK

END;
GLOBAL ROUTINE TST5: NOVALUE =

!++   ------------ 'MMC3 READ','MMC3 WRITE' CONTROL BITS -----------
! TEST DESCRIPTION:  This routine  verifies that the read/write bits
!	that are loaded  from  the Com/Adr cycle data are valid.  If
!	either of them or both are stuck high/low then the operation
!	will either cause a memory  refresh  error by hanging up the
!	memory or it will succeed. The address attempted to  read or
!	write will be a memory location  of  existent memory so if a
!	read is actually successful no errors will be returned.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Set up 8080 registers for a Com/Adr cycle
!			indicating a read,write,both, or neither
!		   Write control bits needed to do the operation
!		   Verify response:  ?MRE  ?NXM  NO RESPONSE
!			and print out error messages (if error)
!
!		   Correct response:
!			READ	-	NO RESPONSE
!			WRITE	-	NO RESPONSE
!			READ&WRITE  -	?MRE
!			NEITHER    -	?MRE
!
! POSSIBLE ERRORS:  'MMC3 READ' or 'MMC3 WRITE' flip flops are faulty
!
!--

BEGIN

LITERAL
	READ = 1^34,			! Bit for a read
	WRITE = 1^33;			! Bit for a write

LOCAL
	M_REF,
	NXM;

OWN
	MESSV: VECTOR[2];		! Error message output vector

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LABEL
	BLOCK1,
	BLOCK2,
	BLOCK3,
	BLOCK4;

IF RUN_TEST(5) THEN RETURN;		! Run this test? Return if no

NOERR_5 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

!
!----  READ  ----
!
DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	WRITE_COMADR(READ);		! Do a read cycle
	WRT115(COM_ADR);
	WRT114(DATA_CYCLE);
	WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA+CLOSE_LATCH);
	SEND_NUL();			! Get this sent off to 8080

	IF .TIMOUT EQL 1		! Did a timeout error occur?
	    THEN BEGIN			! If so set error flag, print
		 NOERR_5 = 1;		!   error message and exit
		 ERR(1);
		 IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
	MESSV = RD_101;			! Read 8080 Reg 101 and see if 
	M_REF = .MESSV AND 1;		!   we got a ?MRE
	MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
	NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM

	IF .NXM EQL 1 AND .M_REF EQL 0	! If only a ?NXM occurred set
	    THEN BEGIN			!   error flag and print error
		 NOERR_5 = 1;		!   message
		 ERRS(2,2,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF .NXM EQL 0 AND .M_REF EQL 1	! If only a ?MRE occurred set
	    THEN BEGIN			!   error flag and print error
		 MRE_MEM = 1;		!   message
		 NOERR_5 = 1;
	    	 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	IF .NXM EQL 1 AND .M_REF EQL 1	! If both a ?MRE and a ?NXM occurred
	    THEN BEGIN			!   set error flag and print error
		 MRE_MEM = 1;		!   message
		 NOERR_5 = 1;
	    	 ERRS(4,4,MESSV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!
!----  WRITE  ----
!
DO (0) WHILE
BLOCK2:	BEGIN
	MR();				! Master Reset
	WRITE_COMADR(WRITE);		! Do a write cycle
	WRT115(COM_ADR);
	WRT114(DATA_CYCLE);
	WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA+CLOSE_LATCH);
	SEND_NUL();			! Get this sent off to 8080

	IF .TIMOUT EQL 1		! Did a timeout error occur?
	    THEN BEGIN			! If so set error flag, print
		 NOERR_5 = 1;		!   error message and exit
		 ERR(5);
		 IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;

	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
	MESSV = RD_101;			! Read 8080 Reg 101 and see if 
	M_REF = .MESSV AND 1;		!   we got a ?MRE
	MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
	NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM

	IF .NXM EQL 1 AND .M_REF EQL 0	! If only a ?NXM occurred set
	    THEN BEGIN			!   error flag and print error
		 NOERR_5 = 1;		!   message
		 ERRS(6,6,MESSV);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;

	IF .NXM EQL 0 AND .M_REF EQL 1	! If only a ?MRE occurred set
	    THEN BEGIN			!   error flag and print error
		 MRE_MEM = 1;		!   message
		 NOERR_5 = 1;
		 ERRS(7,7,MESSV);
		 END;
	IF LOOP_CHK(7) THEN LEAVE BLOCK2 WITH 1;

	IF .NXM EQL 1 AND .M_REF EQL 1	! If both a ?MRE and a ?NXM occurred
	    THEN BEGIN			!   set error flag and print error
		 MRE_MEM = 1;		!   message
		 NOERR_5 = 1;
	    	 ERRS(8,8,MESSV);
		 END;
	IF LOOP_CHK(8) THEN LEAVE BLOCK2 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!
!----  READ & WRITE  ----
!
DO (0) WHILE
BLOCK3:	BEGIN
	MR();				! Master Reset
	WRITE_COMADR(READ+WRITE);	! Do a read and a write cycle
	WRT115(COM_ADR);
	WRT114(DATA_CYCLE);
	WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);
	SEND_NUL();			! Get this sent off to 8080

	IF .TIMOUT EQL 1		! Did a timeout error occur?
	    THEN BEGIN			! If so set error flag, print
		 NOERR_5 = 1;		!   error message and exit
		 ERR(9);
		 IF LOOP_CHK(9) THEN LEAVE BLOCK3 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(9) THEN LEAVE BLOCK3 WITH 1;

	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
	MESSV = RD_101;			! Read 8080 Reg 101 and see if 
	M_REF = .MESSV AND 1;		!   we got a ?MRE
	MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
	NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM

	IF .NXM EQL 1 AND .M_REF EQL 1	! If both ?NXM and ?MRE occurred set
	    THEN BEGIN			!   error flag and print error
		 NOERR_5 = 1;		!   message
		 ERRS(10,10,MESSV);
		 END;
	IF LOOP_CHK(10) THEN LEAVE BLOCK3 WITH 1;

	IF .NXM EQL 0 AND .M_REF EQL 0	! If neither ?NXM nor ?MRE
	    THEN BEGIN			!   occurred set error flag
		 MRE_MEM_NOT = 1;	!   and print error message
		 NOERR_5 = 1;
	    	 ERRS(11,11,MESSV);
		 END;
	IF LOOP_CHK(11) THEN LEAVE BLOCK3 WITH 1;

	IF .NXM EQL 1 AND .M_REF EQL 0	! If ?NXM occurred but ?MRE did not
	    THEN BEGIN			!   set error flag and print error
		 MRE_MEM_NOT = 1;	!   message
		 NOERR_5 = 1;
	    	 ERRS(12,12,MESSV);
		 END;
	IF LOOP_CHK(12) THEN LEAVE BLOCK3 WITH 1;
	0				! To eliminate INFO compiler message
	END;

DO (0) WHILE
BLOCK4:	BEGIN
!
!----  NEITHER READ NOR WRITE  ----
!
	MR();				! Master Reset - do this twice to
	SEND_NUL();			!   make sure we have recovered
	WAIT(1000);			!   from the last thing we did
	MR();				!   which generated errors
	SEND_NUL();
	WAIT(1000);
	MR();
	SEND_NUL();

	WRITE_COMADR(0);		! Do neither a read nor a write
	WRT115(COM_ADR);
	WRT114(DATA_CYCLE);
	WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);
	SEND_NUL();			! Get this sent off to 8080

	IF .TIMOUT EQL 1		! Did a timeout error occur?
	    THEN BEGIN			! If so set error flag, print
		 NOERR_5 = 1;		!   error message and exit
		 ERR(13);
		 IF LOOP_CHK(13) THEN LEAVE BLOCK4 WITH 1;
		 RETURN;
		 END;
	IF LOOP_CHK(13) THEN LEAVE BLOCK4 WITH 1;

	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
	MESSV = RD_101;			! Read 8080 Reg 101 and see if 
	M_REF = .MESSV AND 1;		!   we got a ?MRE
	MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
	NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM

	IF .NXM EQL 1 AND .M_REF EQL 1	! If both ?NXM and ?MRE occurred set
	    THEN BEGIN			!   error flag and print error
		 NOERR_5 = 1;		!   message
		 ERRS(14,14,MESSV);
		 END;
	IF LOOP_CHK(14) THEN LEAVE BLOCK4 WITH 1;

	IF .NXM EQL 0 AND .M_REF EQL 0	! If neither ?NXM nor ?MRE
	    THEN BEGIN			!   occurred set error flag
		 MRE_MEM_NOT = 1;	!   and print error message
		 NOERR_5 = 1;
	    	 ERRS(15,15,MESSV);
		 END;
	IF LOOP_CHK(15) THEN LEAVE BLOCK4 WITH 1;

	IF .NXM EQL 1 AND .M_REF EQL 0	! If ?NXM occurred but ?MRE did not
	    THEN BEGIN			!   set error flag and print error
		 MRE_MEM_NOT = 1;	!   message
		 NOERR_5 = 1;
	    	 ERRS(16,16,MESSV);
		 END;
	IF LOOP_CHK(16) THEN LEAVE BLOCK4 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds

!]ERROR 1
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	No ref err occurred but NXM set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 2
!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB AC BC CC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	Refresh error occurred & NXM not set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 3
!] A1 K1 EFION3 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB AC BC CC  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	NXM set and refresh error occurred
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 4
!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 A9 B9 C9 AA AB BB CB DB AC BC CC  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds

!]ERROR 5
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Write mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	NO ref err occurred but NXM set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 6
!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB AC BC CC  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Write mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	Refresh error occurred & NXM not set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 7
!] A1 K1 EFION3 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB AC BC CC  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Write mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	NXM set and refresh error occurred
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 8
!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 A9 B9 C9 AA AB BB CB DB AC BC CC  NTWK
!]NO ERROR 8
!]  NTWK

!*MESSAGE 9
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds

!]ERROR 9
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 9
!]  NTWK

!*MESSAGE 10
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read & write mem loc 0
!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA
!*	NXM should not set - Refresh error should occur
!*RESPONSE
!*	Refresh error occurred but NXM was set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 10
!] A1 I3 J3 K3 N3 L3 O3 A8 A9 B9 C9 AA AC BC CC  NTWK
!]NO ERROR 10
!]  NTWK

!*MESSAGE 11
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read & write mem loc 0
!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA
!*	NXM should not set - Refresh error should occur
!*RESPONSE
!*	NXM did not set but refresh error did not occur
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 11
!] A1 I3 N3 O3 A9 B9 C9 AA BB AC BC CC  NTWK
!]NO ERROR 11
!]  NTWK

!*MESSAGE 12
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read & write mem loc 0
!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA
!*	NXM should not set - Refresh error should occur
!*RESPONSE
!*	Refresh error did not occur & NXM set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 12
!] A1 I3 J3 K3 N3 O3 A8 AA AB BB AC BC CC  NTWK
!]NO ERROR 12
!]  NTWK

!*MESSAGE 13
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
!*			     107,109,111,113 - Read mem loc 0
!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
!*	NXM should not set - No refresh error should occur
!*RESPONSE
!*	KS10 timed out - MMC failed to respond for 60 seconds

!]ERROR 13
!] AA BA AB BB CB DB  NTWK
!]NO ERROR 13
!]  NTWK

!*MESSAGE 14
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,107,
!*		   109,111,113 - Neither read nor write mem loc 0
!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA
!*	NXM should not set - Refresh error should occur
!*RESPONSE
!*	Refresh error occurred but NXM was set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 14
!] A1 I3 J3 K3 N3 L3 O3 A8 A9 B9 C9 AA AC BC CC  NTWK
!]NO ERROR 14
!]  NTWK

!*MESSAGE 15
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,107,
!*		   109,111,113 - Neither read nor write mem loc 0
!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA
!*	NXM should not set - Refresh error should occur
!*RESPONSE
!*	NXM not set but refresh error did not occur
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 15
!] A1 I3 N3 O3 A9 B9 C9 AA BB AC BC CC  NTWK
!]NO ERROR 15
!]  NTWK

!*MESSAGE 16
!*STIMULUS
!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,107,
!*		   109,111,113 - Neither read nor write mem loc 0
!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
!*			  T ENB FOR COM/ADR & DATA
!*	NXM should not set - Refresh error should occur
!*RESPONSE
!*	Refresh error did not occur & NXM set
!*	8080 Regs 101: \O0	301: \O1

!]ERROR 16
!] A1 I3 J3 K3 N3 O3 A8 AA AB BB AC BC CC  NTWK
!]NO ERROR 16
!]  NTWK

END;
GLOBAL ROUTINE TST6: NOVALUE =

!++   ------------------ 8646'S, MOS DRIVERS, DATA PATH ---------------
! TEST DESCRIPTION:  This test  performs a basic functional test of the
!	MMC board. Data is written to memory and read back and verified.
!	This  test  is  intended  to  check out the 8646's, the hex MOS
!	drivers, and the data path within the MMC board.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write a test pattern to mem loc 0
!		   Read it back and verify it
!		   Repeat with several test patterns
!
! POSSIBLE ERRORS:
!
!--

BEGIN

OWN

! All the message strings

	MESS_STR: VECTOR[28]
	    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-05'),
		    UPLIT(%ASCIZ '06-07'),UPLIT(%ASCIZ '08-11'),
		    UPLIT(%ASCIZ '12-15'),UPLIT(%ASCIZ '16-17'),
		    UPLIT(%ASCIZ '18-21'),UPLIT(%ASCIZ '22-23'),
		    UPLIT(%ASCIZ '24-25'),UPLIT(%ASCIZ '26-29'),
		    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
		    UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
		    UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
		    UPLIT(%ASCIZ '16-17'),UPLIT(%ASCIZ '18-21'),
		    UPLIT(%ASCIZ '22-25'),UPLIT(%ASCIZ '26-29'),
		    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
		    UPLIT(%ASCIZ '00-05'),UPLIT(%ASCIZ '06-11'),
		    UPLIT(%ASCIZ '12-17'),UPLIT(%ASCIZ '18-23'),
		    UPLIT(%ASCIZ '24-29'),UPLIT(%ASCIZ '30-35')),

! Data patterns

	PATTERN: VECTOR[4]
	    INITIAL (%O'111111111111',%O'666666666666',
		     %O'0',%O'777777777777'),

! Misc

	MEM_STAT_VECT: BTTVECTOR[36],

! For the special data structure definition

	STRUCT: VECTOR[24]
	    INITIAL (32,4,30,2,28,2,24,4,20,4,18,2,14,4,
		     12,2,10,2,6,4,2,4,0,2);

LITERAL
	NUM_PATTERN = 4;

STRUCTURE
	BIT_VECT[I;N] = [N]		! This structure duplicates the bit
	    (BIT_VECT)			!   partitions on the data path
	    <.STRUCT[I*2],.STRUCT[I*2+1]>,
	BIT_MOS[I;N] = [N]		! This structure maps the MOS drivers
	    (BIT_MOS)			!   into the data path
	    <30-I*6,6>;

OWN
	CUM_ERR,			! Errors cumulated so far
	CUM_NXMM,			! ?NXM errors cumulated so far
	NONXM1,				! ?NXM error
	NONXM2,				! ?NXM error
	SPEC_VECT: VECTOR[4],
	MESSV: VECTOR[2],		! Error message output vector
	TEST_8646_VECT: BIT8646[1],	! Data path mapped onto transceivers
	TEST_MOS_VECT: BIT_MOS[1],	! Miscellaneous structures
	TEST_TEMP_VECT: BIT_VECT[1],	!    ...
	TEST_DATA_VECT: BIT_VECT[1],
	TEST_PATT_VECT: BIT_VECT[1];

BIND
	S0 = SPEC_VECT[0],
	S1 = SPEC_VECT[1],
	S2 = SPEC_VECT[2],
	S3 = SPEC_VECT[3],
	TEST_DATA = TEST_DATA_VECT,
	TEST_PATT = TEST_PATT_VECT,
	MEM_STAT_REG = MEM_STAT_VECT,
	TEST_MOS = TEST_MOS_VECT,
	TEST_8646 = TEST_8646_VECT,
	TEST_TEMP = TEST_TEMP_VECT;

LOCAL
	SPEC_ERR,
	NXMM,
	ERR,
	ERR_FLAG,
	TEMP;

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LABEL
	BLOCK1;

IF RUN_TEST(6) THEN RETURN;		! Run this test? Return if no

NOERR_6 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

CUM_ERR = CUM_NXMM = 0;			! Init misc flags
S0 = S1 = S2 = S3 = 0;

INCR DATA_LOOP FROM 0 TO NUM_PATTERN-1 DO
	BEGIN				! Now start the test:
	TEST_PATT=.PATTERN[.DATA_LOOP];	!   Get the data pattern to use
	MESSV = .TEST_PATT;		!   Save it for error ouput
	MR();				!   Do a Master Reset
	IO_DEPOSIT(MSR,ECC_OFF);	!   Make sure ECC is off
	CHK_ERR_MSG(REF_ERR);		!   Discard any unexpected errors

	DO (0) WHILE
BLOCK1:	    BEGIN
	    TEST_DATA = ERR_FLAG = NONXM2 = 0;
	    NONXM1 = DM_CHK(0,.TEST_PATT);	! Write data and see if a ?NXM
	    NONXM1 = .NONXM1 OR .TIMOUT;	!   or timeout occurred 
	    CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors

	    IF .NONXM1 NEQ 1			! If a ?NXM did not occur read
		THEN BEGIN			!   back the data. See if ?NXM
		     NONXM2 = EM_CHK(0);	!   or timeout occurred this
		     NONXM2 = .NONXM2 OR .TIMOUT;!  time.
		     CHK_ERR_MSG(REF_ERR);	! Discard any unexpected errors
		     IF .NONXM2 NEQ 1 THEN TEST_DATA = EM(0);
		     END;

	    NXMM = NOT (.NONXM1 OR .NONXM2);	! 0 if ?NXM did not occur on
						!    either write or read
	    SPEC_VECT[.DATA_LOOP] = .TEST_DATA XOR .TEST_PATT;
	    CUM_NXMM = .NONXM1 + .NONXM2;

! Now check to see if there are any single bit errors.

	    INCR BTT FROM 0 TO 35 DO
		BEGIN
		MESSV[1] = .BTT;
		TEMP = .TEST_DATA XOR (1 ^ (35-.BTT));
		IF .TEMP EQL .TEST_PATT AND .NXMM
		    THEN BEGIN
			 ERRCAS(.BTT+1,1,.TEST_PATT,.TEST_DATA,12,MESSV);
			 ERR_FLAG = 1;
			 END;
		IF LOOP_CHK(.BTT + 1) THEN LEAVE BLOCK1 WITH 1;
		END;

! Now check to see if there are any multiple bit errors which occurred in
!   only one logical group of bits (such as in the first transceiver...).
!   These particular groups are the subsections of the  transceivers, MOS
!   drivers and mixers on MMC7 which are common to all three. Hence these
!   are the next stage up from a single bit error.

	    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM;
	    INCR BTT FROM 0 TO 11 DO
		BEGIN
		TEST_TEMP = 0;
		TEST_TEMP_VECT[.BTT] = %O'777777';
		TEMP = .TEST_DATA OR .TEST_TEMP;
		IF .TEMP EQL (.TEST_PATT OR .TEST_TEMP) AND .ERR
		    THEN BEGIN
			 ERR_FLAG = 1;
			 MESSV[1] = .MESS_STR[.BTT];
			 ERRCAS(.BTT+37,2,.TEST_PATT,.TEST_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 37) THEN LEAVE BLOCK1 WITH 1;
		END;

! Now check to see if there are any errors which occurred exclusively in
!   the 8646 transceivers.

	    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM;
	    INCR BTT FROM 0 TO 9 DO
		BEGIN
		TEST_8646 = 0;
		TEST_8646_VECT[.BTT] = %O'777777';
		TEMP = .TEST_DATA OR .TEST_8646;
		IF .TEMP EQL (.TEST_PATT OR .TEST_8646) AND .ERR
		    THEN BEGIN
			 ERR_FLAG = 1;
			 MESSV[1] = .MESS_STR[.BTT+12];
			 ERRCAS(.BTT+49,2,.TEST_PATT,.TEST_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 49) THEN LEAVE BLOCK1 WITH 1;
		END;

! Now check to see if there are any errors which occurred exclusively in
!   the MOS drivers on MMC6.

	    ERR =(.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		TEST_MOS = 0;
		TEST_MOS_VECT[.BTT] = %O'777777';
		TEMP = .TEST_DATA OR .TEST_MOS;
		IF .TEMP EQL (.TEST_PATT OR .TEST_MOS) AND .ERR
		    THEN BEGIN
			 ERR_FLAG = 1;
			 MESSV[1] = .MESS_STR[.BTT+22];
			 ERRCAS(.BTT+59,2,.TEST_PATT,.TEST_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 59) THEN LEAVE BLOCK1 WITH 1;
		END;
	    CUM_ERR = .CUM_ERR + .ERR_FLAG;

! So if no error messages have been printed out yet and the data came
!   back incorrectly, then the error must be a strange  multiple  bit
!   error.  So we will report the whole thing.

	    IF (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM
		THEN BEGIN
		     ERR_FLAG = CUM_ERR = 1;
		     ERRCAS(65,3,.TEST_PATT,.TEST_DATA,12,MESSV);
		     END
		ELSE BEGIN
		     IF (.CUM_ERR EQL 0) AND (.DATA_LOOP EQL .NUM_PATTERN - 1)
			THEN NOERR(1);
		     END;
	    IF LOOP_CHK(65) THEN LEAVE BLOCK1 WITH 1;

! Do the rest of the error reporting for ?NXM errors.
! Also set error flags for prior errors which occurred.

	    IF .CUM_ERR NEQ 0
		THEN BEGIN
		     NOERR_6 = 1;		! Test 6 has error
		     BUS_XCVR = 1;		! Bus xcvr has a fault
		     END;

	    IF .NONXM1 EQL 1			! Report ?NXM on the write
		THEN BEGIN
		     NOERR_6 = 1;
		     ERRS(66,4,MESSV);
		     END;
	    IF LOOP_CHK(66) THEN LEAVE BLOCK1 WITH 1;

	    IF .NONXM2 EQL 1			! Report ?NXM on the read
		THEN BEGIN
		     NOERR_6 = 1;
		     ERRS(67,5,MESSV);
		     END;
	    IF LOOP_CHK(67) THEN LEAVE BLOCK1 WITH 1;

	    IF (.S0 EQL .S1) AND (.S0 EQL .S2) AND (.S0 EQL .S3) AND (.S0 NEQ 0)
		THEN BEGIN			! Now if the fault has been 
		     TEST_ABORT = 1;		!   sufficiently isolated, set
		     NOERR_6 = 1;		!   Test Abort switch to abort
		     ERRS(72,10,TEMP);		!   all future testing.
		     END
		ELSE NOERR(3);
	    IF .NOERR_6 EQL 0
		THEN NOERR(2);

!*MESSAGE 1
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	Bit \D1 of data returned is incorrect

!]ERROR 1
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 1
!] A_J1 A6 B6 C6 D6 E6 F6  NTWK

!]ERROR 2
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 2
!] A6 B6 C6 D6 E6 F6  NTWK

!]ERROR 3
!] A1 A2 H2  A6 C7 B9  NTWK
!]NO ERROR 3
!] A2 B2 C2 D2 E2 F2 G2  NTWK

!]ERROR 4
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] B1 A2 H2 A6 D7  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] B1 A2 H2 A6 D7  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] B1 B2 I2 B6 D7  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] B1 B2 I2 B6 D7  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 10
!]  NTWK

!]ERROR 11
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 16
!]  NTWK

!]ERROR 17
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 17
!]  NTWK

!]ERROR 18
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 18
!]  NTWK

!]ERROR 19
!] F1 D2 K2 D6 G7  NTWK
!]NO ERROR 19
!]  NTWK

!]ERROR 20
!] F1 D2 K2 D6 G7  NTWK
!]NO ERROR 20
!]  NTWK

!]ERROR 21
!] F1 D2 K2 D6 H7  NTWK
!]NO ERROR 21
!]  NTWK

!]ERROR 22
!] F1 D2 K2 D6 H7  NTWK
!]NO ERROR 22
!]  NTWK

!]ERROR 23
!] G1 D2 K2 D6 H7  NTWK
!]NO ERROR 23
!]  NTWK

!]ERROR 24
!] G1 D2 K2 D6 H7  NTWK
!]NO ERROR 24
!]  NTWK

!]ERROR 25
!] G1 E2 L2 E6 I7  NTWK
!]NO ERROR 25
!]  NTWK

!]ERROR 26
!] G1 E2 L2 E6 I7  NTWK
!]NO ERROR 26
!]  NTWK

!]ERROR 27
!] H1 E2 L2 E6 I7  NTWK
!]NO ERROR 27
!]  NTWK

!]ERROR 28
!] H1 E2 L2 E6 I7  NTWK
!]NO ERROR 28
!]  NTWK

!]ERROR 29
!] H1 E2 L2 E6 J7  NTWK
!]NO ERROR 29
!]  NTWK

!]ERROR 30
!] H1 E2 L2 E6 J7  NTWK
!]NO ERROR 30
!]  NTWK

!]ERROR 31
!] I1 F2 M2 F6 J7  NTWK
!]NO ERROR 31
!]  NTWK

!]ERROR 32
!] I1 F2 M2 F6 J7  NTWK
!]NO ERROR 32
!]  NTWK

!]ERROR 33
!] I1 F2 M2 F6 K7  NTWK
!]NO ERROR 33
!]  NTWK

!]ERROR 34
!] I1 F2 M2 F6 K7  NTWK
!]NO ERROR 34
!]  NTWK

!]ERROR 35
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 35
!]  NTWK

!]ERROR 36
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 36
!]  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	Bits \S1 of data returned is incorrect

!]ERROR 37
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 37
!]  NTWK

!]ERROR 38
!] B1 A2 H2 A6 D7  NTWK
!]NO ERROR 38
!]  NTWK

!]ERROR 39
!] B1 B2 I2 B6 D7  NTWK
!]NO ERROR 39
!]  NTWK

!]ERROR 40
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 40
!]  NTWK

!]ERROR 41
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 41
!]  NTWK

!]ERROR 42
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 42
!]  NTWK

!]ERROR 43
!] F1 D2 K2 D6 G7 H7  NTWK
!]NO ERROR 43
!]  NTWK

!]ERROR 44
!] G1 D2 K2 D6 H7  NTWK
!]NO ERROR 44
!]  NTWK

!]ERROR 45
!] G1 E2 L2 E6 I7  NTWK
!]NO ERROR 45
!]  NTWK

!]ERROR 46
!] H1 E2 L2 E6 I7 J7  NTWK
!]NO ERROR 46
!]  NTWK

!]ERROR 47
!] I1 F2 M2 F6 J7 K7  NTWK
!]NO ERROR 47
!]  NTWK

!]ERROR 48
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 48
!]  NTWK

!]ERROR 49
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 49
!]  NTWK

!]ERROR 50
!] B1 A2 B2 H2 I2 A6 B6 D7  NTWK
!]NO ERROR 50
!]  NTWK

!]ERROR 51
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 51
!]  NTWK

!]ERROR 52
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 52
!]  NTWK

!]ERROR 53
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 53
!]  NTWK

!]ERROR 54
!] F1 D2 K2 D6 G7 H7  NTWK
!]NO ERROR 54
!]  NTWK

!]ERROR 55
!] G1 D2 E2 K2 L2 D6 E6 H7 I7  NTWK
!]NO ERROR 55
!]  NTWK

!]ERROR 56
!] H1 E2 L2 E6 I7 J7  NTWK
!]NO ERROR 56
!]  NTWK

!]ERROR 57
!] I1 F2 M2 F6 J7 K7  NTWK
!]NO ERROR 57
!]  NTWK

!]ERROR 58
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 58
!]  NTWK

!]ERROR 59
!] A1 B1 A2 H2 A6 C7 D7  NTWK
!]NO ERROR 59
!]  NTWK

!]ERROR 60
!] B1 C1 B2 I2 B6 D7 E7  NTWK
!]NO ERROR 60
!]  NTWK

!]ERROR 61
!] D1 E1 C2 J2 C6 F7 G7  NTWK
!]NO ERROR 61
!]  NTWK

!]ERROR 62
!] F1 G1 D2 K2 D6 G7 H7  NTWK
!]NO ERROR 62
!]  NTWK

!]ERROR 63
!] G1 H1 E2 L2 E6 I7 J7  NTWK
!]NO ERROR 63
!]  NTWK

!]ERROR 64
!] I1 J1 F2 M2 F6 J7 K7  NTWK
!]NO ERROR 64
!]  NTWK

!*MESSAGE 3
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	Bits 00-35 of data returned is incorrect

!]ERROR 65
!] A_J1 A_D3 I_O3 C_K7 B_K8 AA BA AB BB DB AC BC  NTWK
!]NO ERROR 65
!]  NTWK

!*MESSAGE 4
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*RESPONSE:
!*	NXM SET

!]ERROR 66
!] A1 D1 E1 F1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB DB AC BC CC  NTWK
!]NO ERROR 66
!]  NTWK

!*MESSAGE 5
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	NXM set

!]ERROR 67
!] A1 D1 E1 F1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB DB AC BC CC  NTWK
!]NO ERROR 67
!]  NTWK

	    SPEC_ERR = 0;
	    MESSV[1] = MEM_STAT_REG = EI(100000);
	    CHK_ERR_MSG(REF_ERR);
	    IF .MEM_STAT_VECT[2] EQL 1
		THEN SPEC_ERR = 68 * (.SPEC_ERR EQL 0);
	    IF .MEM_STAT_VECT[3] EQL 1
		THEN SPEC_ERR = 69 * (.SPEC_ERR EQL 0);
	    IF .MEM_STAT_VECT[4] EQL 1
		THEN SPEC_ERR = 70 * (.SPEC_ERR EQL 0);
	    IF .MEM_STAT_VECT[12] EQL 1
		THEN SPEC_ERR = 71 * (.SPEC_ERR EQL 0);
	    INCR ERR FROM 68 TO 71 DO
		BEGIN
		IF .SPEC_ERR EQL .ERR
		    THEN BEGIN
			 NOERR_6 = 1;
			 ERRCAS(.ERR,.ERR-62,.TEST_PATT,.TEST_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
		END;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 6
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*	Examine Mem Status Register
!*RESPONSE:
!*	Data returned ok but refresh error set
!*	Mem Stat Reg:  \U1

!]ERROR 68
!] A1 K1 C7 AA AB BB DB  NTWK
!]NO ERROR 68
!]  NTWK

!*MESSAGE 7
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*	Examine Mem Status Register
!*RESPONSE:
!*	Data returned ok but memory parity error set
!*	Mem Stat Reg:  \U1

!]ERROR 69
!] A_N1 C7 AA AB CB DB  NTWK
!]NO ERROR 69
!]  NTWK

!*MESSAGE 8
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*	Examine Mem Status Register
!*RESPONSE:
!*	Data returned ok but ECC shut off
!*	Mem Stat Reg:  \U1

!]ERROR 70
!] A1 B1 J1 K1 H3 D7 AA AB CB DB  NTWK
!]NO ERROR 70
!]  NTWK

!*MESSAGE 9
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*	Examine Mem Status Register
!*RESPONSE:
!*	Data returned ok but power fail set
!*	Mem Stat Reg:  \U1

!]ERROR 71
!] A1 D1 K1 A5 F7 AA AB CB DB  NTWK
!]NO ERROR 71
!]  NTWK

!*MESSAGE 10
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	'MMC2 ECC CODE XX' stuck hi/lo - data bit is complemented

!]ERROR 72
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2  NTWK
!]NO ERROR 72
!]  NTWK

END;
GLOBAL ROUTINE TST7: NOVALUE =

!++   --------- VERIFY 8080 I/O REG BITS WHEN MEM IS QUIESCENT -------
! TEST DESCRIPTION: This routine verifies that there are no stuck bits
!	in the memory controller.  When the memory is not busy and has
!	just gotten reset  by  a Master Reset, the 8080 Registers that
!	hold PARITY ERROR, REFRESH ERROR,  MEM BUSY, I/O BUSY, and NXM
!	bits should not be set.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Examine mem location 0 (To turn off ?NXM if it
!			is already set)
!		   Master Reset
!		   ER 102 - Should be all 0's
!		   ER 100 - 'MEM PE' should not be set
!		   ER 301 - 'NXM' should not be set
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

OWN
	REGV: BTTVECTOR[35];

BIND
	REG = REGV;

LABEL
	BLOCK1;

IF RUN_TEST(7) THEN RETURN;		! Run this test? Return if no

NOERR_7 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	RPT_ERR_FLAG = 0;		! Don't report unexpected error
	EM(0);				! Examine mem loc 0 (to turn off
					!   ?NXM if there is one in Reg 301)
	MR();				! Master Reset
	REG = RD_102;			! Read 8080 Reg 102

	INCR BTT FROM 30 TO 35 DO	! Check to see if any bits set
	    BEGIN			!   which shouldnt be
	    IF .REGV[.BTT] NEQ 0
		THEN BEGIN		! If so set error flags, print
		     TEST_ABORT = 1;	!   error message, and abort
		     NOERR_7 = 1;	!   future testing
		     ERRS(.BTT-29,.BTT-29,REG);
		     END;
	    IF LOOP_CHK(.BTT-29) THEN LEAVE BLOCK1 WITH 1;
	    END;

	REG = RD_100;			! Now take a look at 8080 Reg 100
	IF (.REG AND MEM_PE) EQL 0	! Parity error set?
	    THEN BEGIN			! If so set error flags, print
		 NOERR_7 = 1;		!   error message, and abort
		 TEST_ABORT = 1;	!   future testing
		 ERRS(7,7,REG);
		 END;
	IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;

	REG = RD_301;			! Read 8080 Reg 301
	IF (.REG AND NEXM) NEQ 0	! ?NXM set?
	    THEN BEGIN			! If so set error flags, print
		 NOERR_7 = 1;		!   error message, and abort
		 ERRS(8,8,REG);		!   future testing
		 END;
	IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
!*		  'I/O DATA','DATA' - None should be asserted)
!*RESPONSE
!*	'MEM BUSY' asserted       102:  \O0

!]ERROR 1
!] DB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
!*		  'I/O DATA','DATA' - None should be asserted)
!*RESPONSE
!*	'I/O BUSY' asserted       102:  \O0

!]ERROR 2
!] DB  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
!*		  'I/O DATA','DATA' - None should be asserted)
!*RESPONSE
!*	'BAD DATA' asserted       102:  \O0

!]ERROR 3
!] BA  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
!*		  'I/O DATA','DATA' - None should be asserted)
!*RESPONSE
!*	'COM ADR' asserted       102:  \O0

!]ERROR 4
!] BA  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
!*		  'I/O DATA','DATA' - None should be asserted)
!*RESPONSE
!*	'I/O DATA' asserted       102:  \O0

!]ERROR 5
!] L7 DB NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
!*		  'I/O DATA','DATA' - None should be asserted)
!*RESPONSE
!*	'DATA' asserted       102:  \O0

!]ERROR 6
!] AA BA  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 100	Examine 8080 Reg 100 - Should show 'MEM PE' not asserted
!*RESPONSE
!*	'MEM PE' asserted       100:  \O0

!]ERROR 7
!] B7 CB DB  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS
!*	MR	Master Reset
!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
!*	MR	Master Reset
!*	ER 301	Examine 8080 Reg 301 - Should show 'NXM' not asserted
!*RESPONSE
!*	'NXM' asserted       301:  \O0

!]ERROR 8
!] A1 D1 E1 F1 K1 N3 J3 K3 A7 B7 L7 A8 AA AB BB CB DB AC BC CC  NTWK
!]NO ERROR 8
!]  NTWK

END;
GLOBAL ROUTINE TST8: NOVALUE =

!++   ------------------- 8646 PARITY GEN/CHK --------------------
! TEST DESCRIPTION:  This routine checks out the parity generation
!	and verification logic attached to the KS10 Bus on the MMC
!	board.   The 8646 tranceivers generate the parity in 4 bit
!	chunks and separate parity generators calculate parity for
!	the whole word.   The result of this determines whether or
!	not valid parity was received from the bus. In the case of
!	a read the parity is put on the bus for the device reading
!	the data to verify.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Shut off parity checking by the 8080
!		   Write 0's to mem location 0
!		   Read 8080 I/O Reg 100 to see if CSL board thinks that
!			a parity error occurred
!		   Read Mem Stat Reg to see if MMC board thinks that
!			a parity error occurred
!		   Read mem location 0
!		   Read 8080 I/O Reg 100 and check if a parity
!			error occurred
!
! POSSIBLE ERRORS:  8646 tranceivers are not generating parity correctly
!			or the parity generators on MMC1 are bad
!		    Logic which sets 'MMC7 PARITY ERR' is bad or the
!			inverter which sends the signal to CSL is
!			broken.
!
!--

BEGIN

LOCAL
	REG_100,			! 8080 Reg 100
	CSL_PAR,			! CSL board shows PE
	MMC_PAR,			! MMC board shows PE
	MEM_STAT,			! Mem Status Register
	TEMP;				! Temporary storage

OWN
	MESSV: VECTOR[3];		! Error message output vector

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE');

MACRO
	PAR_BIT = 32,1%;

LABEL
	BLOCK1,
	BLOCK2;

IF RUN_TEST(8) THEN RETURN;		! Run this test? Return if no

NOERR_8 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

PAR_DISABLE;				! Shut off parity checking by 8080

!
!	1ST HALF - VERIFY PARITY GEN/CHK ON WRITE
!

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	DM(0,0);			! Write 0's to mem loc 0
	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
	MESSV = REG_100 = RD_100;	! Read 8080 Reg 100
	CSL_PAR = (.REG_100 AND MEM_PE) XOR %O'10';
	MESSV[1] = MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
	MMC_PAR = .MEM_STAT<PAR_BIT>;

	IF .CSL_PAR NEQ 0 AND .MMC_PAR NEQ 0
	    THEN BEGIN			! If both MMC and CSL see PE then
		 NOERR_8 = 1;		!   set error flag and print error
		 ERRS(1,1,MESSV);	!   message.
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	IF .CSL_PAR NEQ 0 AND .MMC_PAR EQL 0
	    THEN BEGIN			! If only CSL sees PE then set error
		 TEST_ABORT = 1;	!   flags, print error message and
		 NOERR_8 = 1;		!   abort future testing
		 ERRS(2,2,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF .CSL_PAR EQL 0 AND .MMC_PAR NEQ 0
	    THEN BEGIN			! If only MMC sees PE then set error
		 TEST_ABORT = 1;	!   flags, print error message and
		 NOERR_8 = 1;		!   abort future testing
		 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!
!	2ND HALF - VERIFY PARITY GEN/CHK ON READ
!

DO (0) WHILE
BLOCK2:	BEGIN
	MR();				! Master Reset
	MESSV[2] = EM(0);		! Examine mem loc 0
	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
	MESSV = REG_100 = RD_100;	! Read 8080 Reg 100
	CSL_PAR = ((.REG_100 AND (MEM_PE OR REC_PE)) NEQ (MEM_PE OR REC_PE));
	MESSV[1] = MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
	MMC_PAR = .MEM_STAT<PAR_BIT>;

	IF .CSL_PAR NEQ 0 AND .MMC_PAR NEQ 0
	    THEN BEGIN			! If both MMC and CSL see PE then
		 NOERR_8 = 1;		!   set error flag and print error
		 ERRS(4,4,MESSV);	!   message.
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK2 WITH 1;

	IF .CSL_PAR NEQ 0 AND .MMC_PAR EQL 0
	    THEN BEGIN			! If only CSL sees PE then set error
		 TEST_ABORT = 1;	!   flags, print error message and
		 NOERR_8 = 1;		!   abort future testing
		 ERRS(5,5,MESSV);
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;

	IF .CSL_PAR EQL 0 AND .MMC_PAR NEQ 0
	    THEN BEGIN			! If only MMC sees PE then set error
		 TEST_ABORT = 1;	!   flags, print error message and
		 NOERR_8 = 1;		!   abort future testing
		 ERRS(6,6,MESSV);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR,PE 0		Shut off parity error checking by 8080
!*	LA 0,DM 0	Write 0's to memory loc 0 (Parity err should not occur)
!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
!*	EI 100000	Look to see if MSR shows 'PE' also
!*RESPONSE
!*	8080 & M8618 both see 'PARITY ERR' occurred on write
!*	I/O Reg 100: \O0    MSR: \U1

!]ERROR 1
!] A_N1 E3 F3 B7  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR,PE 0		Shut off parity error checking by 8080
!*	LA 0,DM 0	Write 0's to memory loc 0 (Parity err should not occur)
!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
!*	EI 100000	Look to see if MSR shows 'PE' also
!*RESPONSE
!*	8080 thinks 'PARITY ERR' occurred on write but M8618 doesnt
!*	I/O Reg 100: \O0    MSR: \U1

!]ERROR 2
!] B7 C7  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR,PE 0		Shut off parity error checking by 8080
!*	LA 0,DM 0	Write 0's to memory loc 0 (Parity err should not occur)
!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
!*	EI 100000	Look to see if MSR shows 'PE' also
!*RESPONSE
!*	M8618 thinks 'PARITY ERR' occurred on write but 8080 doesnt
!*	I/O Reg 100: \O0    MSR: \U1

!]ERROR 3
!] B7 C7  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR,PE 0		Shut off parity error checking by 8080
!*	LA 0,DM 0	Write 0's to memory loc 0
!*	EM 0		Examine mem loc 0 (Parity err should not occur)
!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
!*	EI 100000	Look to see if MSR shows 'PE' also
!*RESPONSE
!*	8080 & M8618 both see 'PARITY ERR' occurred on read
!*	I/O Reg 100: \O0    MSR: \U1   Mem loc 0: \U2

!]ERROR 4
!] A_N1 E3 F3 B7  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	MR,PE 0		Shut off parity error checking by 8080
!*	LA 0,DM 0	Write 0's to memory loc 0
!*	EM 0		Examine mem loc 0 (Parity err should not occur)
!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
!*	EI 100000	Look to see if MSR shows 'PE' also
!*RESPONSE
!*	8080 thinks 'PARITY ERR' occurred on read but M8618 doesnt
!*	I/O Reg 100: \O0    MSR: \U1   Mem loc 0: \U2

!]ERROR 5
!] B7 C7  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	MR,PE 0		Shut off parity error checking by 8080
!*	LA 0,DM 0	Write 0's to memory loc 0
!*	EM 0		Examine mem loc 0 (Parity err should not occur)
!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
!*	EI 100000	Look to see if MSR shows 'PE' also
!*RESPONSE
!*	M8618 thinks 'PARITY ERR' occurred on read but 8080 doesnt
!*	I/O Reg 100: \O0    MSR: \U1   Mem loc 0: \U2

!]ERROR 6
!] B7 C7  NTWK
!]NO ERROR 6
!]  NTWK

END;
GLOBAL ROUTINE TST9: NOVALUE =

!++   -------------- BOARD SELECT ADDRESS LOGIC -----------------
! TEST DESCRIPTION:  This routine checks the board select address
!	logic on the  MMC  board.   It  verifies that none of the
!	address lines are stuck at 0/1.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write RANDOM PATTERN1 to MMA Board 0 Address 0
!				       2 to MMA Board 1 Address 0
!				       3 to MMA Board 2 Address 0
!				       4 to MMA Board 3 Address 0
!				       5 to MMA Board 4 Address 0
!				       6 to MMA Board 5 Address 0
!				       7 to MMA Board 6 Address 0
!				       8 to MMA Board 7 Address 0
!		   In each case check NXM
!		   Read data back from each board and verify it is
!			correct depending on whether or not it is 
!			nonexistent memory.
!
! POSSIBLE ERRORS:  OR gates on MMC8 are faulty
!      (Indirectly) Other address decode logic is faulty
!
!--

BEGIN

OWN
	MESSV: VECTOR[3],		! Error message output vector
	MESS_STR1: VECTOR[8]		! Error message strings
	    INITIAL(UPLIT(%ASCIZ '000'),UPLIT(%ASCIZ '001'),
		    UPLIT(%ASCIZ '010'),UPLIT(%ASCIZ '011'),
		    UPLIT(%ASCIZ '100'),UPLIT(%ASCIZ '101'),
		    UPLIT(%ASCIZ '110'),UPLIT(%ASCIZ '111')),
	MESS_STR2: VECTOR[2]		! Error message strings
	    INITIAL(UPLIT(%ASCIZ ' not '),UPLIT(%ASCIZ ' ')),
	PATTERN: VECTOR[8]		! Test data patterns
	    INITIAL (%O'765432101234',%O'654321012345',
		     %O'543210123456',%O'432101234567',
		     %O'321012345676',%O'210123456765',
		     %O'101234567654',%O'012345676543');

LOCAL
	CUM_ERR,
	ERR_FLAG,
	PATT,
	DATA_OK,
	ERR_NUM,
	TEMP,
	TEST_DATA,
	NONXM;

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LABEL
	BLOCK1;

IF RUN_TEST(9) THEN RETURN;		! Run this test? Return if no

NOERR_9 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
CUM_ERR = 0;

IO_DEPOSIT(MSR,ECC_OFF);		! Make sure ECC is off on MMC board
CHK_ERR_MSG(REF_ERR);			!   and discard any unexpected errors
					!   that may have occurred doing this
DO (0) WHILE
BLOCK1: BEGIN
	INCR BOARD FROM 0 TO 7 DO	! Write data to each MMA board
	    BEGIN
	    MR();			! Master Reset
	    NONXM = DM_CHK(.BOARD^16,.PATTERN[.BOARD]);	! See if we would get a
	    ERR_NUM = .BOARD*2+1+.MMA_MAP[.BOARD];	!   ?NXM if we wrote
	    MESSV[0] = .PATTERN[.BOARD];		! Set up data for error
	    MESSV[1] = .MESS_STR1[.BOARD];		!   message in case we
	    MESSV[2] = .MESS_STR2[.MMA_MAP[.BOARD]];	!   have an error

	    IF .NONXM EQL .MMA_MAP[.BOARD]	! Did we get ?NXM on existent
		THEN BEGIN			!   memory or no ?NXM on non-
		     CUM_ERR = 1;		!   existent memory
		     ERRS(.ERR_NUM,1,MESSV);
		     END;
	    IF LOOP_CHK(.ERR_NUM) THEN LEAVE BLOCK1 WITH 1;
	    END;

	INCR BOARD FROM 0 TO 7 DO
	    BEGIN
	    MR();				! Master Reset
	    NONXM = EM_CHK(.BOARD ^ 16);	! See if can examine MMA board
	    PATT = .PATTERN[.BOARD];
	    TEST_DATA = 0;
	    IF .NONXM EQL 0
		THEN TEST_DATA = MEM_EXAMINE(.BOARD ^ 16);
	    DATA_OK = (.TEST_DATA EQL .PATT) AND 1;
	    ERR_NUM = 16 + .BOARD * 4;
	    ERR_FLAG = 0;
	    MESSV[0] = .PATTERN[.BOARD];	! Set up error message
	    MESSV[1] = .MESS_STR1[.BOARD];	!   printout

	    IF .MMA_MAP[.BOARD] EQL 0		! Now determine if we have any
		THEN BEGIN			!   errors depending on whether
		     IF .NONXM NEQ 1		!   or not the memory is out
			THEN BEGIN		!   there.
			     IF .DATA_OK
				THEN ERR_FLAG = 1
				ELSE ERR_FLAG = 2;
			     END;
		     END
		ELSE BEGIN
		     IF .NONXM NEQ 1
			THEN BEGIN
			     IF .DATA_OK NEQ 1
				THEN ERR_FLAG = 3;
			     END
			ELSE ERR_FLAG = 4;
		     END;

! Now print out the errors whatever they are.

	    INCR ERR FROM 1 TO 4 DO
		BEGIN
		IF (.ERR EQL .ERR_FLAG) AND (.ERR_FLAG NEQ 3)
		   THEN ERRCAS(.ERR_NUM+.ERR,1+.ERR,.PATT,.TEST_DATA,12,MESSV);
		IF LOOP_CHK(.ERR_NUM+.ERR) THEN LEAVE BLOCK1 WITH 1;
		END;
	    CUM_ERR = .CUM_ERR + .ERR_FLAG;
	    IF (.ERR_FLAG NEQ 0) AND (.ERR_FLAG NEQ 3) THEN RETURN;
	    END;

	IF .CUM_ERR EQL 0		! No errors?  If not then we can
	    THEN NOERR(1);		!   get rid of some networks as
	NOERR_9 = .CUM_ERR;		!   not being faulty.
	0				! To eliminate INFO compiler message
	END;

!  ERROR 1 - Board 000 - Memory nonexistent - But ?NXM did not occur
!  ERROR 2 - Board 000 - Memory exists - But ?NXM occurred
!  ERROR 3 - Board 001 - Memory nonexistent - But ?NXM did not occur
!  ERROR 4 - Board 001 - Memory exists - But ?NXM occurred
!   ...		...		...

!*MESSAGE 1
!*STIMULUS:
!*	LA (\S1 Board select + 0 Address) (\S2existent memory)
!*	DM \U0
!*RESPONSE:
!*	NXM\S2set

!]ERROR 1
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 1
!] A8  NTWK

!]ERROR 2
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 10
!]  NTWK

!]ERROR 11
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 16
!]  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	LA (\S1 Board select + 0 Address) (Nonexistent memory)
!*	DM \U0
!*	EM
!*RESPONSE:
!*	NXM not set & data ok

!*MESSAGE 3
!*STIMULUS:
!*	LA (\S1 Board select + 0 Address) (Nonexistent memory)
!*	DM \U0
!*	EM
!*RESPONSE:
!*	NXM not set & data not ok

!*MESSAGE 4
!*STIMULUS:
!*	LA (\S1 Board select + 0 Address) (Memory exists)
!*	DM \U0
!*	EM
!*RESPONSE:
!*	NXM not set & data not ok

!*MESSAGE 5
!*STIMULUS:
!*	LA (\S1 Board select + 0 Address) (Memory exists)
!*	DM \U0
!*	EM
!*RESPONSE:
!*	NXM set

!  ERROR 17 - Board 000 - Mem non-existent - But ?NXM did not occur - data ok
!  ERROR 18 - Board 000 - Mem non-existent - But ?NXM did not occur - data bad
!  ERROR 19 - Board 000 - Mem exists - But ?NXM did not occur - data bad
!  ERROR 20 - Board 000 - Mem exists - But ?NXM occurred
!   ...		...		...

!]ERROR 17
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 17
!]  NTWK

!]ERROR 18
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 18
!]  NTWK

!]ERROR 19
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 19
!]  NTWK

!]ERROR 20
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 20
!]  NTWK

!]ERROR 21
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 21
!]  NTWK

!]ERROR 22
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 22
!]  NTWK

!]ERROR 23
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 23
!]  NTWK

!]ERROR 24
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 24
!]  NTWK

!]ERROR 25
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 25
!]  NTWK

!]ERROR 26
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 26
!]  NTWK

!]ERROR 27
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 27
!]  NTWK

!]ERROR 28
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 28
!]  NTWK

!]ERROR 29
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 29
!]  NTWK

!]ERROR 30
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 30
!]  NTWK

!]ERROR 31
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 31
!]  NTWK

!]ERROR 32
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 32
!]  NTWK

!]ERROR 33
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 33
!]  NTWK

!]ERROR 34
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 34
!]  NTWK

!]ERROR 35
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 35
!]  NTWK

!]ERROR 36
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 36
!]  NTWK

!]ERROR 37
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 37
!]  NTWK

!]ERROR 38
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 38
!]  NTWK

!]ERROR 39
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 39
!]  NTWK

!]ERROR 40
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 40
!]  NTWK

!]ERROR 41
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 41
!]  NTWK

!]ERROR 42
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 42
!]  NTWK

!]ERROR 43
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 43
!]  NTWK

!]ERROR 44
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 44
!]  NTWK

!]ERROR 45
!] E1 F1 J3 N3 A8  NTWK
!]NO ERROR 45
!]  NTWK

!]ERROR 46
!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 46
!]  NTWK

!]ERROR 47
!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
!]NO ERROR 47
!]  NTWK

!]ERROR 48
!] E1 F1 J3 N3 A8 AA AB  NTWK
!]NO ERROR 48
!]  NTWK

END;
GLOBAL ROUTINE TST10: NOVALUE =

!++   --------------- WORD GROUP ADDRESS LOGIC ----------------
! TEST DESCRIPTION:  This routine checks the word group address
!	logic on the  MMC  board.  It verifies that none of the
!	address lines 20-21 are stuck at 0/1.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write PATTERN1 to Word group 00 Address 0
!				2 to Word group 01 Address 0
!		   Read data back from word group 00 and verify it
!
!		   Repeat for word groups 00/10 and 00/11
!
! POSSIBLE ERRORS:  OR, AND Gates on MMC8 faulty
!      (Indirectly) Other address decode logic is faulty
!
!--

BEGIN

LITERAL
	BIT_20 = %O'100000',		! Address for word group 2
	BIT_21 = %O'40000',		! Address for word group 1
	FORCE_CLR = %O'700000000000',	! MSR clear 'ERR HOLD'...
	DATA1 = %O'111111111111',	! Data pattern to loc 0
	DATA2 = %O'222222222222';	! Data pattern to loc word group n

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LOCAL
	TEMP;

OWN
	MESSV,				! Error message output data
	MESS_STR: VECTOR[3]		! Strings for error message
	    INITIAL(UPLIT(%ASCIZ '01'),UPLIT(%ASCIZ '10'),UPLIT(%ASCIZ '11'));

LABEL
	BLOCK1;

IF RUN_TEST(10) THEN RETURN;		! Run this test? Return if no

NOERR_10 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	IO_DEPOSIT(MSR,ECC_OFF);	! Shut off ECC
	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
	MEM_DEPOSIT(0,DATA1);		! Write to loc 0
	MEM_DEPOSIT(BIT_21,DATA2);	! Write to loc word group 1
	TEMP = EM(0);			! Read loc 0

	IF .TEMP EQL DATA2		! Did 'Write loc word group' overwrite
	    THEN BEGIN			!   contents of location 0?
		 TEST_ABORT = 1;	! If so set error flags, print error
		 MESSV = .MESS_STR[0];	!   message and abort future testing
		 NOERR_10 = 1;
		 ERRCAS(1,1,DATA1,.TEMP,12,MESSV);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	MR();				! Master Reset
	MEM_DEPOSIT(0,DATA1);		! Write to loc 0
	MEM_DEPOSIT(BIT_20,DATA2);	! Write to loc word group 2
	TEMP = EM(0);			! Read loc 0

	IF .TEMP EQL DATA2		! Did 'Write loc word group' overwrite
	    THEN BEGIN			!   contents of location 0?
		 TEST_ABORT = 1;	! If so set error flags, print error
		 MESSV = .MESS_STR[1];	!   message and abort future testing
		 NOERR_10 = 1;
		 ERRCAS(2,1,DATA1,.TEMP,12,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	MR();				! Master Reset
	MEM_DEPOSIT(0,DATA1);		! Write to loc 0
	MEM_DEPOSIT(BIT_20+BIT_21,DATA2);! Write to loc word group 3
	TEMP = EM(0);			! Read loc 0

	IF .TEMP EQL DATA2		! Did 'Write loc word group' overwrite
	    THEN BEGIN			!   contents of location 0?
		 TEST_ABORT = 1;	! If so set error flags, print error
		 MESSV = .MESS_STR[2];	!   message and abort future testing
		 NOERR_10 = 1;
		 ERRCAS(3,1,DATA1,.TEMP,12,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	IO_DEPOSIT(MSR,FORCE_CLR);	! Clear any errors caused by this test
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS:
!*	LA (00 Word group + 0 Address)
!*	DM 111111111111
!*	LA (\S0 Word group + 0 Address)
!*	DM 222222222222
!*	EM 00 (Bits 20,21) 00000 (Bits 22..35)
!*RESPONSE:
!*	DM 22.. Overwrote 11.. (Addr bit 20/21 stuck at 0/1)

!]ERROR 1
!] J3  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] J3  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] J3  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST11: NOVALUE =

!++   ------------------- ROW/COL ADDRESS LOGIC ---------------------
! TEST DESCRIPTION:  This routine checks the row/column address logic
!	on the MMC board.  It verifies that none of the address lines
!	22-35 are stuck at 0/1.  This tests the outputs of the mixers
!	on MMC3 so the row address is equal to the column address for
!	each test.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write PATTERN1 to Row 00000000 Col 00000000
!				2 to Row 00000001 Col 00000001
!		   Read data back and verify it
!
!		   Repeat for row/cols 00000010 00000010
!				       00000100 00000100
!				       00001000 00001000
!				       00010000 00010000
!				       00100000 00100000
!				       01000000 01000000
!				       10000000 10000000
!
! POSSIBLE ERRORS:  Faulty 2x4 mixers on MMC3
!
!--

BEGIN

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LOCAL
	NUM_ERR,
	TEMP;

LITERAL
	ONES = %O'77777777777777',	! Ones
	ADDR = %B'0000000100000001';	! Row 1 Column 1

OWN
	DATA: BTTVECTOR[36];		! Bitvector of data read from mem loc 0

LABEL
	BLOCK1;

IF RUN_TEST(11) THEN RETURN;		! Run this test? Return if no

NOERR_11 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
MR();					! Master Reset

IO_DEPOSIT(MSR,ECC_OFF);		! Shut off ECC
CHK_ERR_MSG(REF_ERR);			! Discard any unexpected errors

INCR ROWCOL FROM 1 TO 7 DO		! For each row/col address:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    DM(0,0);			! Write 0's to mem loc 0
	    TEMP = ADDR^(.ROWCOL-1);	! Calculate row/col address
	    MEM_DEPOSIT(.TEMP,ONES);	! Write 1's to mem loc row/col
	    TEMP = EM(0);		! Read mem loc 0

	    NUM_ERR = 0;		! Count up the total number of bits
	    INCR BTT FROM 0 TO 35 DO	!   in error (if any). (There must be
		BEGIN			!   many incorrect bits to be certain
		IF .DATA[.BTT] EQL 1	!   of an addressing error.)
		    THEN NUM_ERR = .NUM_ERR + 1;
		END;

	    IF .NUM_ERR GEQ 29		! Over 29 bits in error?
		THEN BEGIN		! If so set error flags, print error
		     TEST_ABORT = 1;	!   message and abort future testing
		     NOERR_11 = 1;
		     ERRCA(.ROWCOL,0,.TEMP,12);
		     END;
	    IF LOOP_CHK(.ROWCOL) THEN LEAVE BLOCK1 WITH 1;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000001 0000001
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 28 COL 35' stuck at 0/1

!]ERROR 1
!] D3 NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000010 0000010
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 27 COL 34' Stuck at 0/1

!]ERROR 2
!] D3 NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000100 0000100
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 26 COL 33' Stuck at 0/1

!]ERROR 3
!] C3 NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0001000 0001000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 25 COL 32' Stuck at 0/1

!]ERROR 4
!] C3 NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0010000 0010000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 24 COL 31' Stuck at 0/1

!]ERROR 5
!] B3 NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0100000 0100000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 23 COL 30' Stuck at 0/1

!]ERROR 6
!] B3 NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 1000000 1000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 22 COL 29' Stuck at 0/1

!]ERROR 7
!] A3 NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST12: NOVALUE =

!++   ------------------ ROW/COL ADDRESS LOGIC ----------------------
! TEST DESCRIPTION:  This routine checks the row/column address logic
!	on the MMC board.  It verifies that none of the address lines
!	22-35 are stuck at 0/1.  This tests the  select  lines on the
!	mixers on MMC3 so the row address  will  be  zero  while  the
!	column address varies and vice versa.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write 0's to row 0 col 0
!		   write 1's to row N1 col N2
!		   Read data back and verify it
!
!		   Do for row/cols 0000000 0000001
!				   0000000 0000010
!				   0000000 0000100
!				   0000000 0001000
!				   0000000 0010000
!				   0000000 0100000
!				   0000000 1000000
!
!				   0000001 0000000
!				   0000010 0000000
!				   0000100 0000000
!				   0001000 0000000
!				   0010000 0000000
!				   0100000 0000000
!				   1000000 0000000
!
! POSSIBLE ERRORS:  Faulty 2x4 mixers on MMC3
!
!--

BEGIN

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LOCAL
	NUM_ERR,
	TEMP;

LITERAL
	ONES = %O'777777777777',	! Ones
	ADDR = 1;			! Address to write to (gets shifted
					!   over for each new row/col address)
OWN
	DATA: BTTVECTOR[36];		! Bitvector of data read from mem loc 0

LABEL
	BLOCK1;

IF RUN_TEST(12) THEN RETURN;		! Run this test? Return if no

NOERR_12 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
MR();					! Master Reset

IO_DEPOSIT(MSR,ECC_OFF);		! Shut off ECC
CHK_ERR_MSG(REF_ERR);			! Discard any unexpected errors

INCR ROWCOL FROM 1 TO 14 DO		! For each address:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    DM(0,0);			! Write 0's to mem loc 0
	    TEMP = ADDR^(.ROWCOL-1);	! Calculate row/col address
	    MEM_DEPOSIT(.TEMP,ONES);	! Write 1's to mem loc row/col
	    TEMP = EM(0);		! Read mem loc 0 (see if got overwrote)

	    NUM_ERR = 0;		! Count up the total number of bits
	    INCR BTT FROM 0 TO 35 DO	!   in error (if any). (There must be
		BEGIN			!   many incorrect bits to be certain
		IF .DATA[.BTT] EQL 1	!   of an addressing error.)
		    THEN NUM_ERR = .NUM_ERR + 1;
		END;

	    IF .NUM_ERR GEQ 29		! Over 29 bits in error?
		THEN BEGIN		! If so set error flags, print error
		     TEST_ABORT = 1;	!   message and abort future testing
		     NOERR_12 = 1;
		     ERRCA(.ROWCOL,0,.TEMP,12);
		     END;
	    IF LOOP_CHK(.ROWCOL) THEN LEAVE BLOCK1 WITH 1;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000000 0000001
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 28 COL 35' Stuck at 0/1

!]ERROR 1
!] H1 J1 D3 L3 M3 NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000000 0000010
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 27 COL 34' Stuck at 0/1

!]ERROR 2
!] H1 J1 D3 L3 M3 NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000000 0000100
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 26 COL 33' Stuck at 0/1

!]ERROR 3
!] H1 I1 C3 L3 M3 NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000000 0001000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 25 COL 32' Stuck at 0/1

!]ERROR 4
!] G1 I1 C3 L3 M3 NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000000 0010000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 24 COL 31' Stuck at 0/1

!]ERROR 5
!] G1 I1 B3 L3 M3 NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000000 0100000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 23 COL 30' Stuck at 0/1

!]ERROR 6
!] G1 I1 B3 L3 M3 NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000000 1000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 22 COL 29' Stuck at 0/1

!]ERROR 7
!] G1 H1 A3 L3 M3 NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000001 0000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 28 COL 35' Stuck at 0/1

!]ERROR 8
!] H1 J1 D3 L3 M3 NTWK
!]NO ERROR 8
!]  NTWK

!*MESSAGE 9
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000010 0000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 27 COL 34' Stuck at 0/1

!]ERROR 9
!] H1 J1 D3 L3 M3 NTWK
!]NO ERROR 9
!]  NTWK

!*MESSAGE 10
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0000100 0000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 26 COL 33' Stuck at 0/1

!]ERROR 10
!] H1 I1 C3 L3 M3 NTWK
!]NO ERROR 10
!]  NTWK

!*MESSAGE 11
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0001000 0000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 25 COL 32' Stuck at 0/1

!]ERROR 11
!] G1 I1 C3 L3 M3 NTWK
!]NO ERROR 11
!]  NTWK

!*MESSAGE 12
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0010000 0000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 24 COL 31' Stuck at 0/1

!]ERROR 12
!] G1 I1 B3 L3 M3 NTWK
!]NO ERROR 12
!]  NTWK

!*MESSAGE 13
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 0100000 0000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 23 COL 30' Stuck at 0/1

!]ERROR 13
!] G1 I1 B3 L3 M3 NTWK
!]NO ERROR 13
!]  NTWK

!*MESSAGE 14
!*STIMULUS:
!*	LA (Row col bits) 0000000 0000000
!*	DM 000000000000
!*	LA (Row col bits) 1000000 0000000
!*	DM 777777777777
!*	EM 0
!*RESPONSE:
!*	DM 777.. Overwrote DM 000..
!*	'MMC3 ROW 22 COL 29' Stuck at 0/1

!]ERROR 14
!] G1 H1 A3 L3 M3 NTWK
!]NO ERROR 14
!]  NTWK

END;
GLOBAL ROUTINE TST13: NOVALUE =

!++   ----------------- ROW/COL ADDRESS LOGIC -------------------
! TEST DESCRIPTION:  This  routine  tests  the row/column address
!	select  logic on the MMC board.  It verifies that none of
!	the select inputs to the row/col/refresh select chips are
!	stuck 0/1 thereby causing a memory access to always go to
!	the row address, column address, or refresh address.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write PATTERN1 to Row N1 Col N2
!				2 to Row N2 Col N1
!				3 to Row N1 Col N1
!				4 to Row N2 Col N2
!		   Read data back and verify it for each address
!
!		   Do for row/cols 0000000 0000001
!				   0000000 0000010
!				   0000000 0000100
!				   0000000 0001000
!				   0000000 0010000
!				   0000000 0100000
!				   0000000 1000000
!
! POSSIBLE ERRORS:  Faulty chips in address logic on MMC3.  This test
!	verifies the 2x4 mixers that decode the row/col addresses.
!
!--

BEGIN

LITERAL
	MIX_1 = %O'004020100400',
	MIX_2 = %O'030140603000',
	MIX_3 = %O'140603014000',
	MIX_4 = %O'603014060300';

LOCAL
	NUM_ERR,		! Number of bits in error in a word
				!   (must be >= 5 to be significant)
	ERR_OCC,		! Flag to indicate an error occurred
	ADDR1,			! Address 1
	ADDR2,			! Address 2
	ADDR3,			! Address 3
	ADDR4,			! Address 4
	TEMP1,			! Temporary variable
	ERR_FLAG;		! Error flag

STRUCTURE
	BITBLOCK[I,J;M,N]=[1]		! Structure for keeping track of what
	    (BITBLOCK)<35-I-J*7,1>;	!   errors have / have not occurred

OWN
	DATA_BIT: BTTVECTOR[36],	! Data read from memory
	PATT_BIT: BTTVECTOR[36],	! Data written to memory
	ROW_VECT: BITBLOCK[7,4],	! Fault is always writing to row addr
	COL_VECT: BITBLOCK[7,4],	! Fault is always writing to col addr
	STR_VECT: BITBLOCK[7,4],	! Garbage writes
	SSTR_VECT: BITBLOCK[7,4],	! Garbage writes
	PATT: VECTOR[4]			! Data patterns to use
	      INITIAL (0,-1,%O'252525252525',%O'525252525252'),
	TEMP: VECTOR[4];		! Will contain the data read back

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE'),
	VROW = ROW_VECT,		! 1 word == ROW_VECT bit structure
	VCOL = COL_VECT,		! 1 word == COL_VECT bit structure
	VSTR = STR_VECT,		! 1 word == STR_VECT bit structure
	VSSTR = SSTR_VECT;		! 1 word == SSTR_VECT bit structure
LABEL
	BLOCK1;

IF RUN_TEST(13) THEN RETURN;		! Run this test? Return if no

NOERR_13 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	IO_DEPOSIT(MSR,ECC_OFF);	! Shut off ECC
	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
	VROW = VCOL = VSTR = VSSTR = 0;

	INCR ROWCOL FROM 0 TO 6 DO	! For each row/col:
	    BEGIN
	    ADDR1 = 1^.ROWCOL;		! Calculate address 1: row 00 col N2
	    ADDR2 = .ADDR1^7;		! Calculate address 2: row N2 col 00
	    ADDR3 = 0;			! Calculate address 3: row 00 col 00
	    ADDR4 = .ADDR1 + .ADDR2;	! Calculate address 4: row N2 col N2

	    MEM_DEPOSIT(.ADDR1,.PATT[0]); ! Write data pattern 1 to mem loc 1
	    MEM_DEPOSIT(.ADDR2,.PATT[1]); ! Write data pattern 2 to mem loc 2
	    MEM_DEPOSIT(.ADDR3,.PATT[2]); ! Write data pattern 3 to mem loc 3
	    MEM_DEPOSIT(.ADDR4,.PATT[3]); ! Write data pattern 4 to mem loc 4

	    TEMP[0]=MEM_EXAMINE(.ADDR1);  ! Read back mem loc 1
	    TEMP[1]=MEM_EXAMINE(.ADDR2);  ! Read back mem loc 2
	    TEMP[2]=MEM_EXAMINE(.ADDR3);  ! Read back mem loc 3
	    TEMP[3]=MEM_EXAMINE(.ADDR4);  ! Read back mem loc 4

! If there is a fault in the address logic we might see one address get
!    clobbered by a write to another address.  So the first thing to do
!    after writing and reading the data is to check for matches.

	    INCR TEST FROM 0 TO 3 DO	! Test each location for a match with
		BEGIN			!   another.
		TEMP1 = -1;		! TEMP1 remains -1 if no matches at all
		INCR MATCH TO 3 DO	! Check for match with each address
		    BEGIN		!   written to.  It is a match if there
		    NUM_ERR = 0;	!   are more than 29 bits correct.
		    DATA_BIT = .TEMP[.TEST];
		    PATT_BIT = .PATT[.MATCH];
		    INCR BTT FROM 0 TO 35 DO
			IF .PATT_BIT[.BTT] NEQ .DATA_BIT[.BTT]
			    THEN NUM_ERR = .NUM_ERR + 1;
		    IF .NUM_ERR LSS 5		! Since < 5 errors TEMP1 gets
			THEN TEMP1 = .MATCH;	!  this address matched
		    END;

! If no matches then SSTR_VECT gets the flag.

		IF .TEMP1 EQL -1
		    THEN SSTR_VECT[.ROWCOL,.TEST] = 1;

! If there was a match and it wasn't the correct match (data got overwritten)
!   then  flag  either  STR_VECT, ROW_VECT, or COL_VECT depending on what the
!   match was.

		IF .TEMP1 NEQ .TEST AND .TEMP1 NEQ -1
		    THEN BEGIN
			 IF .TEMP1 LSS .TEST OR .TEST GEQ 2
			    THEN STR_VECT[.ROWCOL,.TEST] = 1
			    ELSE IF .TEMP1-.TEST EQL 2
				 THEN COL_VECT[.ROWCOL,.TEST] = 1
				 ELSE ROW_VECT[.ROWCOL,.TEST] = 1;
			 END;
		END;
	    END;

! By now we have found out what all of the errors were.  Now to decide
!   what error messages to print out and what networks to call faulty.
! In this section ERR_OCC is true if the error is the one we are looking
!   for.  Then VROW or VCOL or VSTR or VSSTR or combinations of them are
!   used in conjunction  with the masks MIX_1, MIX_2, MIX_3 and MIX_4 to
!   determine  if the error coincides with the particular error call  in
!   the section being handled.

	ERR_FLAG = 0;
	ERR_OCC = (.VCOL + .VSTR + .VSSTR EQL 0) AND (.VROW NEQ 0);
	IF ((.VROW OR MIX_1) EQL MIX_1) AND .ERR_OCC
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(1);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	IF ((.VROW OR MIX_2) EQL MIX_2) AND .ERR_OCC
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(2);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF ((.VROW OR MIX_3) EQL MIX_3) AND .ERR_OCC
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(3);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	IF ((.VROW OR MIX_4) EQL MIX_4) AND .ERR_OCC
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(4);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;

	ERR_OCC = (.ERR_FLAG + .VROW + .VSTR + .VSSTR EQL 0) AND (.VCOL NEQ 0);
	IF ((.VCOL OR MIX_1) EQL MIX_1) AND .ERR_OCC
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(5);
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;

	IF ((.VCOL OR MIX_2) EQL MIX_2) AND .ERR_OCC 
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(6);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;

	IF ((.VCOL OR MIX_3) EQL MIX_3) AND .ERR_OCC 
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(7);
		 END;
	IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;

	IF ((.VCOL OR MIX_4) EQL MIX_4) AND .ERR_OCC 
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(8);
		 END;
	IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;

	IF (.ERR_FLAG+.VCOL+.VSTR+.VSSTR EQL 0) AND .VROW EQL %O'777760000000'
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(9);
		 END;
	IF LOOP_CHK(9) THEN LEAVE BLOCK1 WITH 1;

	IF (.ERR_FLAG+.VROW+.VSTR+.VSSTR EQL 0) AND .VCOL EQL %O'777760000000'
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(10);
		 END;
	IF LOOP_CHK(10) THEN LEAVE BLOCK1 WITH 1;

	IF (.ERR_FLAG+.VCOL+.VSTR+.VSSTR EQL 0) AND .VROW NEQ 0
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(11);
		 END;
	IF LOOP_CHK(11) THEN LEAVE BLOCK1 WITH 1;

	IF (.ERR_FLAG+.VROW+.VSTR+.VSSTR EQL 0) AND .VCOL NEQ 0
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(12);
		 END;
	IF LOOP_CHK(12) THEN LEAVE BLOCK1 WITH 1;

	IF (.ERR_FLAG+.VSTR+.VSSTR EQL 0) AND (.VROW NEQ 0) AND (.VCOL NEQ 0)
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(13);
		 END;
	IF LOOP_CHK(13) THEN LEAVE BLOCK1 WITH 1;

	IF (.ERR_FLAG + .VSSTR) EQL 0 AND (.VCOL + .VROW + .VSTR) NEQ 0
	    THEN BEGIN
		 ERR_FLAG = 1;
		 ERR(14);
		 END;
	IF LOOP_CHK(14) THEN LEAVE BLOCK1 WITH 1;

	IF .ERR_FLAG NEQ 0
	    THEN BEGIN
		 NOERR_13 = 1;
		 TEST_ABORT = 1;
		 END;

!	IF .ERR_FLAG EQL 0  AND .VSSTR NEQ 0    (no longer used for this
!	    THEN BEGIN				 test but this remains
!		 ERR_FLAG = 1;			 here for reference.)
!		 ERR(15);
!		 END;
!	IF LOOP_CHK(15) THEN LEAVE BLOCK1 WITH 1;

	0				! To eliminate INFO compiler message
	END;

! If Tests 9,10,11,12,13 all passed then the Bus Address Register on MMC3 is ok. 

	ERR_FLAG = .NOERR_9 OR .NOERR_10 OR .NOERR_11 OR .NOERR_12;
	IF (.ERR_FLAG OR .NOERR_13) EQL 0 THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 1000000 (binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
!*		by 0,0 for address bit 22/29

!]ERROR 1
!] A3  NTWK
!]NO ERROR 1
!] J3 K3 L3 M3 N3  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0100000 and 0010000 (Binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
!*		by 0,0 for address bits 23,24/30,31

!]ERROR 2
!] B3  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0001000 and 0000100 (Binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
!*		by 0,0 for address bits 25,26/32,33

!]ERROR 3
!] C3  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0000010 and 0000001 (Binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
!*		by 0,0 for address bits 27,28/34,35

!]ERROR 4
!] D3  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 1000000 (Binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
!*		by N,N for address bits 22/29

!]ERROR 5
!] A3  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0100000 and 0010000 (Binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
!*		by N,N for address bits 23,24/30,31

!]ERROR 6
!] B3  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0001000 and 0000100 (Binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
!*		by N,N for address bits 25,26/32,33

!]ERROR 7
!] C3  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0000010 and 0000001 (Binary)
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
!*		by N,N for address bits 27,28/34,35

!]ERROR 8
!] D3  NTWK
!]NO ERROR 8
!]  NTWK

!*MESSAGE 9
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0000001, 0000010 ... 1000000
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
!*		by 0,0 for address bits 22-28/29-35

!]ERROR 9
!] ABCD3 BB  NTWK
!]NO ERROR 9
!]  NTWK

!*MESSAGE 10
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0000001, 0000010 ... 1000000
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
!*		by N,N for address bits 22-28/29-35

!]ERROR 10
!] ABCD3 NTWK
!]NO ERROR 10
!]  NTWK

!*MESSAGE 11
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0000001, 0000010 ... 1000000
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
!*	  by 0,0 (for multiple chips)

!]ERROR 11
!] ABCD3 NTWK
!]NO ERROR 11
!]  NTWK

!*MESSAGE 12
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0000001, 0000010 ... 1000000
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
!*	  by N,N (for multiple chips)

!]ERROR 12
!] ABCD3 NTWK
!]NO ERROR 12
!]  NTWK

!*MESSAGE 13
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  For N = 0000001, 0000010 ... 1000000
!*RESPONSE:
!*	'MMCA COL ADD EN H' stuck low and high - Data in 0,N is overwritten
!*	  by 0,0/N,N (For multiple chips)

!]ERROR 13
!] ABCD3 NTWK
!]NO ERROR 13
!]  NTWK

!*MESSAGE 14
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  FOR N = 0000001, 0000010 ... 1000000
!*RESPONSE:
!*	Data in various locations is overwritten by later writes
!*	  (This test cannot single out any particular error here)

!]ERROR 14
!] ABCD3 BB  NTWK
!]NO ERROR 14
!]  NTWK

!*MESSAGE 15
!*STIMULUS:
!*	Write 0000.. to address  0,N
!*	Write 7777.. to address  N,0
!*	Write 2525.. to address  0,0
!*	Write 5252.. to address  N,N
!*	  FOR N = 0000001, 0000010 ... 1000000
!*RESPONSE:
!*	Data in various locations is overwritten or disappears
!*	  (Possibly -  'MMCB REF ADD EN H' stuck high so writes
!*	  alway go to the address being refreshed at the time)

!]ERROR 15
!] A_D3 G3 H3 J3 K3 L3 M3 N3 I8 J8 K8 AA BA AB BB  NTWK
!]NO ERROR 15
!]  NTWK

END;
GLOBAL ROUTINE TST14: NOVALUE =

!++   ------------------ MSR READ ADDRESS LOGIC ---------------------
! TEST DESCRIPTION:  This routine checks the address decode logic for
!	reading the Memory Status Register.  This logic is handled by
!	one nand gate on the board (MMC7 Print).
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write status - Force bits all 1's
!		   Write data to mem location 00017043
!		   Examine mem loc 00017043 (ECC error results)
!		   Mem Stat Reg now contains addr 00017043
!		   Read IO Reg 00100001	should get ?NDA or
!			       00100002	  if such an IO Reg
!			       00100000	  should exists then
!			       00300000	  not get 00017043
!			       00500000	  back.  (Except for
!			       01100000   IO Reg 00100000)
!			       02100000
!			       04100000
!			       10100000
!			       00000000
!
!	Note:  Address bits 21..33 are ignored by the MMC
!		board in determining an address match.
!
! POSSIBLE ERRORS:  NAND Gate on MMC7 is broken or the inputs to
!			it are bad.
!
!--

BEGIN

LITERAL
	FORCE_ONES = %O'700040000376',	! Clear errors, write force bits 1's
	FORCE_ZEROS = %O'700040000000',	! Clear errors, write force bits 0's
	TESTADR = %O'17043';		! Test address for this test (selected
					!   so that it doesnt match any IO Reg)
LOCAL
	NDA,				! ?NDA occurred
	ADDR;				! IO Reg address

OWN
	MESSV: VECTOR[2],		! Error message output string
	TEST_ADR_VECT: VECTOR[10]	! IO Register address to write to
	    INITIAL(0,MSR+1,MSR+2,MSR,MSR+MSR^1,MSR+MSR^2,
		MSR+MSR^3,MSR+MSR^4,MSR+MSR^5,MSR+MSR^6);

BIND
	TEST_ADR = MESSV;

LABEL
	BLOCK1;

MR();					! Master Reset
IF RUN_TEST(14) THEN RETURN;		! Run this test? Return if no

NOERR_14 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

IO_DEPOSIT(MSR,FORCE_ONES);		! Cause an ECC error and have 'Err
MEM_DEPOSIT(TESTADR);			!   Addr Reg' contain the address
MEM_EXAMINE(TESTADR);			!   17043 so that we will know when
					!   MSR actually does get read

INCR ADR FROM 0 TO 9 DO			! For each IO address:
	BEGIN
	TEST_ADR = .TEST_ADR_VECT[.ADR];
	DO (0) WHILE
BLOCK1:	    BEGIN
	    NDA = EI_CHK(.TEST_ADR);	! Try to do EI and see if we get ?NDA

	    IF .NDA EQL 1 THEN		! ?NDA occurred.
		BEGIN
		IF .ADR EQL 3		! If MSR was read and got ?NDA then set
		    THEN BEGIN		!   error flags, print error message
			 TEST_ABORT = 1;!   and abort future testing
			 NOERR_14 = 1;
			 ERRS(4,2,MESSV);
			 END;
		END;

	    IF .NDA NEQ 1 THEN		! ?NDA did not occur.
		IF .ADR NEQ 3		! If IO address was not MSR then read
		  THEN BEGIN		!   the IO address again, set error
		       MESSV[1] = IO_EXAMINE(.TEST_ADR);
		       TEST_ABORT = 1;	!   flags, print error message and
		       NOERR_14 = 1;	!   abort future testing.
		       ERRS(.ADR+1,1,MESSV);
		       END;
	    IF LOOP_CHK(.ADR+1) THEN LEAVE BLOCK1 WITH 1;
	    IF .TEST_ABORT EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear ERR HOLD bit,
!*	DI 700000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA 17043,DM0	Write 0's into mem loc 17043
!*	EM 17043	Examine mem loc 17043 (Causes ECC error)
!*	EI (IO REG)	Examine IO Reg \O0
!*	Should return ?NDA (Or data other than mem addr 17043 if this
!*	   matched a different I/O Register)
!*RESPONSE
!*	Mem Stat Reg was read (Data is: \U1 )

!*MESSAGE 2
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear ERR HOLD bit,
!*	DI 700000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA 17043,DM0	Write 0's into mem loc 17043
!*	EM 17043	Examine mem loc 17043 (Causes ECC error)
!*	EI (IO REG)	Examine IO Reg \O0
!*	Should Read Mem Stat Reg - Returned address should be 17043
!*RESPONSE
!*	Mem Stat Reg was not read (?NDA returned instead)

!]ERROR 1
!] K1 L7  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] K1 L7  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] K1 L7  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] K1 L7  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] K1 L7  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] K1 L7  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] K1 L7  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] K1 L7  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] K1 L7  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] K1 L7  NTWK
!]NO ERROR 10
!]  NTWK

END;
GLOBAL ROUTINE TST15: NOVALUE =

!++   ----------------- MSR WRITE ADDRESS LOGIC -----------------
! TEST DESCRIPTION:  This routine checks the address decode logic
!	for writing to the Memory Status Register.  This logic is
!	handled by one nand gate on the board (MMC3 Print).
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Do a Master Reset
!		   Sync T & R Clocks
!		   Write IO Reg 00000000
!			        00100001
!			        00100002
!			        00100000
!			        00300000
!			        00500000
!			        01100000 (00500000 actually)
!			        02100000
!			        04100000
!			        10100000
!
!		   After each write:  Tick 16 T Clocks and verify that
!					either 'IO BUSY' is or is not set
!				      Turn clocks on and verify ?NDA did or
!					or did not appear as expected
!
!		   Note:  Address bits 21..33 are ignored by the MMC
!			board in determining an address match.
!
! POSSIBLE ERRORS:  Nand gate on MMC3 is broken or the inputs to
!			it are bad.
!
!--

BEGIN

LITERAL
	WRITE_IO = %O'500000000000';	! Write to IO Register

OWN
	MESSV: VECTOR[2],		! Error message output vector
	TEST_ADR_VECT: VECTOR[10]	! IO Register addresses
	    INITIAL(0,MSR+1,MSR+2,MSR,MSR+MSR^1,MSR+MSR^2,
		MSR+MSR^2,MSR+MSR^4,MSR+MSR^5,MSR+MSR^6);

BIND
	NDA_ERR = UPLIT(%ASCIZ '?NDA'),
	TEST_ADR = MESSV[0],
	REG102 = MESSV[1];

LABEL
	BLOCK1;

IF RUN_TEST(15) THEN RETURN;		! Run this test? Return if no

NOERR_15 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR ADR FROM 0 TO 9 DO			! For each IO Register address:
	BEGIN
	TEST_ADR = .TEST_ADR_VECT[.ADR];
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    SYNC_CLK();			! Sync T & R Clocks in maintenance mode

! Write to IO address and give 20 ticks.  The 20 ticks should do enough of
!   the IO write that if this is a valid MSR address 'IO BUSY' will appear
!   in 8080 Reg 102.

	    WRITE_COMADR(WRITE_IO OR .TEST_ADR);
	    WRITE_DATA(0);
	    WRITE_CONTROL();
	    TICK(20);			! Give 20 ticks
	    REG102 = RD_102;		! Read Reg 102

	    START_CLK;			! Start up the clock
	    CHK_ERR_MSG(NDA_ERR);	! Check to see if ?NDA occurred

	    IF .ADR NEQ 3 THEN		! Did not try to write to MSR
		BEGIN			! Did 'IO BUSY' assert?
		IF (.REG102 AND RIO_BUSY) NEQ 0
		    THEN BEGIN		! If yes - set error flags, print error
			 TEST_ABORT = 1;!   message, abort future testing
			 NOERR_15 = 1;
			 ERRS(.ADR+1,1,MESSV);
			 END;
		IF LOOP_CHK(.ADR+1) THEN LEAVE BLOCK1 WITH 1;
		IF .TEST_ABORT EQL 1 THEN RETURN;
		END;

	    IF .ADR EQL 3 THEN		! Tried to write to MSR
		BEGIN			! Did 'IO BUSY' assert?
		IF (.REG102 AND RIO_BUSY) EQL 0
		    THEN BEGIN		! If no - set error flags, print error
			 TEST_ABORT = 1;!   message, abort future testing
			 NOERR_15 = 1;
			 ERRS(.ADR+1,2,MESSV);
			 END;
		IF LOOP_CHK(.ADR+1) THEN LEAVE BLOCK1 WITH 1;
		IF .TEST_ABORT EQL 1 THEN RETURN;
		END;
	    0				! To eliminate INFO compiler message
	    END;
	END;
	NOERR(1);			! If we made it this far with no errors
					!   then the NAND gate cannot be faulty

!*MESSAGE 1
!*STIMULUS
!*	MR,SYNC CLKS
!*	LI (IO REG)	Write status to IO Reg \O0
!*	DI 0		   (Data is 0's)
!*	Tick clock 20 ticks (5 T Clocks) - 'I/O BUSY' should not
!*	   appear in 8080 Reg 102
!*RESPONSE
!*	'I/O BUSY' appeared in 8080 Reg 102
!*	8080 Reg 102: \U1

!*MESSAGE 2
!*STIMULUS
!*	MR,SYNC CLKS
!*	LI (IO REG)	Write status to IO Reg \O0
!*	DI 0		   (Data is 0's)
!*	Tick clock 20 ticks (5 T Clocks) - 'I/O BUSY' should have
!*	   appeared in 8080 Reg 102
!*RESPONSE
!*	'I/O BUSY' did not appear in 8080 Reg 102
!*	8080 Reg 102: \U1

!]ERROR 1
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 1
!] F3  NTWK

!]ERROR 2
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
!]NO ERROR 10
!]  NTWK

END;
GLOBAL ROUTINE TST16: NOVALUE =

!++   --------------- MSR WRITE ADDRESS LOGIC -------------------
! TEST DESCRIPTION:  This routine checks the address decode logic
!	for writing to the Memory Status Register.  This logic is
!	handled by one nand gate on the board (MMC3 Print).
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Do a Master Reset
!		   Write IO Reg 00100001 Shut off ECC / Shut off PE
!			        00100002 Shut off ECC / Shut off PE
!			        00100000 Shut off ECC / Shut off PE
!			        00300000 Shut off ECC / Shut off PE
!			        00500000 Shut off ECC / Shut off PE
!			        01100000 Shut off ECC / Shut off PE
!			        02100000 Shut off ECC / Shut off PE
!			        04100000 Shut off ECC / Shut off PE
!			        10100000 Shut off ECC / Shut off PE
!			        00000000 Shut off ECC / Shut off PE
!
!		   After each write, read IO Reg and check ?NDA
!		     or check to see if ECC / PE was affected.
!
!		   Note:  Address bits 21..33 are ignored by the MMC
!			board in determining an address match.
!
! POSSIBLE ERRORS:  Nand gate on MMC3 is broken or the inputs to
!			it are bad.
!
!--

BEGIN

LITERAL
	PE_ECC = %O'060000000000',	! Parity Error set and ECC on
	PE_ERR = %O'020000000000';	! Parity Error set and ECC off

LOCAL
	ERRR,
	IO_NDA;

OWN
	MESSV: VECTOR[2],		! Error message output vector
	TEST_ADR_VECT: VECTOR[10]	! IO Registers to write to
	    INITIAL(0,MSR+1,MSR+2,MSR,MSR+MSR^1,MSR+MSR^2,
		MSR+MSR^3,MSR+MSR^4,MSR+MSR^5,MSR+MSR^6);

BIND
	TEST_ADR = MESSV[0],
	MEM_STAT = MESSV[1];

LABEL
	BLOCK1;

IF RUN_TEST(16) THEN RETURN;		! Run this test? Return if no

NOERR_16 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR ADR FROM 0 TO 9 DO			! For each IO Register:
	BEGIN
	TEST_ADR = .TEST_ADR_VECT[.ADR];
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset

! Write IO address - set Parity Error and turn off ECC

	    IO_DEPOSIT(.TEST_ADR,PE_SET + ECC_OFF);

! Now see if can read IO address.  Then read MSR to see if it got written to.

	    IO_NDA = EI_CHK(.TEST_ADR);
	    MEM_STAT = IO_EXAMINE(MSR);

	    ERRR = .ADR * 2 + 1 + (.ADR GEQ 4);	! Error number

	    IF .ADR NEQ 3 THEN		! Wrote to IO Reg which was not MSR
		BEGIN
		IF (.MEM_STAT AND PE_ECC) EQL PE_SET AND .IO_NDA EQL 0
		    THEN BEGIN		! If the IO Register write succeeded
			 TEST_ABORT = 1;!   (PE got set, ?NDA did not occur)
			 NOERR_16 = 1;	!   set error flags, print err message
			 ERRS(.ERRR,1,MESSV);
			 END;
		IF LOOP_CHK(.ERRR) THEN LEAVE BLOCK1 WITH 1;
		IF .TEST_ABORT EQL 1 THEN RETURN;

		IF (.MEM_STAT AND PE_ECC) EQL PE_SET AND .IO_NDA EQL 1
		    THEN BEGIN		! If the IO Register write succeeded
			 TEST_ABORT = 1;!   (PE got set, ?NDA occurred) then
			 NOERR_16 = 1;	!   set error flags, print err message
			 ERRS(.ERRR+1,2,MESSV);
			 END;
		IF LOOP_CHK(.ERRR+1) THEN LEAVE BLOCK1 WITH 1;
		IF .TEST_ABORT EQL 1 THEN RETURN;
		END;

	    IF .ADR EQL 3 THEN		! Wrote to IO Reg which was MSR
		BEGIN
		IF (.MEM_STAT AND PE_ECC) EQL PE_ERR AND .IO_NDA EQL 0
		    THEN BEGIN		! If the IO Register write failed
			 TEST_ABORT = 1;!  (PE not set, ?NDA did not occur)
			 NOERR_16 = 1;	!   set error flags, print err message
			 ERRS(7,3,MESSV);
			 END;
		IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
		IF .TEST_ABORT EQL 1 THEN RETURN;

		IF (.MEM_STAT AND PE_ECC) EQL PE_SET AND .IO_NDA EQL 1
		    THEN BEGIN		! If the IO Register write failed
			 TEST_ABORT = 1;!  (PE got set, ?NDA occurred) then
			 NOERR_16 = 1;	!   set error flags, print err message
			 ERRS(8,4,MESSV);
			 END;
		IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
		IF .TEST_ABORT EQL 1 THEN RETURN;

		IF (.MEM_STAT AND PE_ECC) EQL PE_ERR AND .IO_NDA EQL 1
		    THEN BEGIN		! If the IO Register write failed
			 TEST_ABORT = 1;!   (PE not set, ?NDA occurred) then
			 NOERR_16 = 1;	!   set error flags, print err message
			 ERRS(9,5,MESSV);
			 END;
		IF LOOP_CHK(9) THEN LEAVE BLOCK1 WITH 1;
		IF .TEST_ABORT EQL 1 THEN RETURN;

		END;
	    0				! To eliminate INFO compiler message
	    END;
	END;

! Call NOERR if the last 3 tests succeeded - we can definitely read/write
!   the Memory Status Register.

	IF (.NOERR_14 OR .NOERR_15 OR .NOERR_16) EQL 0
	    THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS
!*	MR		Ensure ECC on and PE not set
!*	LI (IO Reg)	Write status to IO Reg \O0
!*	DI 040000000001 Shut off ECC / Set PE - (Should return ?NDA)
!*	EI 100000	Examine Mem Stat Reg (Should show ECC on / PE on)
!*RESPONSE
!*	ECC shut off / PE set and no ?NDA occurred on DI \O0
!*	Mem Stat Reg: \U1

!*MESSAGE 2
!*STIMULUS
!*	MR		Ensure ECC on and PE not set
!*	LI (IO Reg)	Write status to IO Reg \O0
!*	DI 040000000001 Shut off ECC / Set PE - (Should return ?NDA)
!*	EI 100000	Examine Mem Stat Reg (Should show ECC on / PE on)
!*RESPONSE
!*	ECC shut off / PE set (Also, ?NDA occurred on DI \O0)
!*	Mem Stat Reg: \U1

!*MESSAGE 3
!*STIMULUS
!*	MR		Ensure ECC on and PE not set
!*	LI 100000	Write status to IO Reg 100000
!*	DI 040000000001 Shut off ECC / Set PE
!*	EI 100000	Examine Mem Stat Reg (Should show ECC now off)
!*RESPONSE
!*	ECC still on / PE not set and no ?NDA occurred on EI 100000)
!*	Mem Stat Reg: \U1

!*MESSAGE 4
!*STIMULUS
!*	MR		Ensure ECC on and PE not set
!*	LI 100000	Write status to IO Reg 100000
!*	DI 040000000001 Shut off ECC / Set PE
!*	EI 100000	Examine Mem Stat Reg (Should show ECC now off)
!*RESPONSE
!*	ECC shut off / PE set but ?NDA occurred on EI 100000)
!*	Mem Stat Reg: \U1

!*MESSAGE 5
!*STIMULUS
!*	MR		Ensure ECC on and PE not set
!*	LI 100000	Write status to IO Reg 100000
!*	DI 040000000001 Shut off ECC / Set PE
!*	EI 100000	Examine Mem Stat Reg (Should show ECC now off)
!*RESPONSE
!*	ECC still on / PE not set and ?NDA occurred on EI 100000)
!*	Mem Stat Reg: \U1

!]ERROR 1
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 1
!] E3 F3 K1  NTWK

!]ERROR 2
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 10
!]  NTWK

!]ERROR 11
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 16
!]  NTWK

!]ERROR 17
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 17
!]  NTWK

!]ERROR 18
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 18
!]  NTWK

!]ERROR 19
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 19
!]  NTWK

!]ERROR 20
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 20
!]  NTWK

!]ERROR 21
!] A1 D1 E1 F1 J1 K1 E3  NTWK
!]NO ERROR 21
!]  NTWK

END;
GLOBAL ROUTINE TST17: NOVALUE =

!++   ------------------- MEMORY STATUS REGISTER -----------------
! TEST DESCRIPTION:  This  routine  verifies  various  bits in the
!	Mem Status Register. Some of these bits such as 'ERR HOLD',
!	'UNCOR ERR HOLD', 'POWER FAILED', 'REFRESH ERR' are tested
!	only in that they are ok if they do not assert as a result
!	of this test.  These bits except 'POWER FAILED' are tested
!	more completely in later tests.  The remainder are toggled
!	and the state of each verified after each mem status write.
!
!	These bits are:	00-ERR HOLD (RD/WR)	04-ECC ON (READ)
!			01-UNCOR ERR HOLD (R/W)	12-POWER FAILED (READ)
!			02-REFRESH ERR (RD/WR)	35-ECC ON (WRITE)
!			03-PARITY ERR (RD/WR)
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Do a Master Reset
!		   Shut off parity checking by 8080
!		   Write status (0000...)
!		   Read status & verify bits 00-04,12
!		   Write status (Bits 00-04,12 set to 1's, remaining
!			bits all 0's)
!		   Read status & verify bits
!
! POSSIBLE ERRORS:  Status bits may be stuck at 0/1
!
!--

BEGIN

LITERAL
	MASK_AND = %O'017720000000',
	MASK_XOR1 = %O'020000100000',
	MASK_XOR2 = %O'040000000000';

OWN
	MEM_STAT_VECT: BTTVECTOR[36],
	DATA_CORR_VECT: BTTVECTOR[36];

BIND
	MEM_STAT = MEM_STAT_VECT,
	DATA_CORR = DATA_CORR_VECT;

LABEL
	BLOCK1,
	BLOCK2;

IF RUN_TEST(17) THEN RETURN;		! Run this test? Return if no

NOERR_17 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
PAR_DISABLE;				! Disable parity error checking by 8080

! First write 0's to MSR and see if any faults appear.

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	DM(0,0);			! Write 0's to mem loc 0
	EM(0);				! Examine mem loc 0 (ensures ?NXM off)

	IO_DEPOSIT(MSR,0);		! Write 0's to MSR
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
	DATA_CORR = (.MEM_STAT AND MASK_AND) XOR MASK_XOR1;

! Check for faulty bits 00..04 'ERR HOLD','UNCORR ERR HOLD','REFRESH ERROR',
!  'PARITY ERROR','ECC ON'.

	INCR ERRR FROM 0 TO 4 DO
	    BEGIN
	    IF .MEM_STAT_VECT[.ERRR] NEQ .DATA_CORR_VECT[.ERRR]
		THEN BEGIN
		     NOERR_17 = 1;
		     ERRCA(.ERRR+1,.DATA_CORR,.MEM_STAT,12);
		     END;
	    IF LOOP_CHK(.ERRR+1) THEN LEAVE BLOCK1 WITH 1;
	    END;

! Also check 'Power Fail' bit in MSR.

	IF .MEM_STAT_VECT[12] NEQ .DATA_CORR_VECT[12]
	    THEN BEGIN
		 NOERR_17 = 1;
		 ERRCA(6,.DATA_CORR,.MEM_STAT,12);
		 END
	    ELSE NOERR(2);
	IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

! Now write 1's to MSR and see if any faults appear.

DO (0) WHILE
BLOCK2:	BEGIN
	IO_DEPOSIT(MSR,%O'777777777777'); ! Write 1's to MSR
	MEM_STAT = IO_EXAMINE(MSR);	  ! Read MSR
	DATA_CORR = (.MEM_STAT AND MASK_AND) XOR MASK_XOR2;

! Check for faulty bits 00..04 'ERR HOLD','UNCORR ERR HOLD','REFRESH ERROR',
!  'PARITY ERROR','ECC ON'.

	INCR ERRR FROM 0 TO 4 DO
	    BEGIN
	    IF .MEM_STAT_VECT[.ERRR] NEQ .DATA_CORR_VECT[.ERRR]
		THEN BEGIN
		     NOERR_17 = 1;
		     ERRCA(.ERRR+7,.DATA_CORR,.MEM_STAT,12);
		     END;
	    IF LOOP_CHK(.ERRR+7) THEN LEAVE BLOCK2 WITH 1;
	    END;

! Also check 'Power Fail' bit in MSR.

	IF .MEM_STAT_VECT[12] NEQ .DATA_CORR_VECT[12]
	    THEN BEGIN
		 NOERR_17 = 1;
		 ERRCA(12,.DATA_CORR,.MEM_STAT,12);
		 END
	    ELSE NOERR(2);
	IF LOOP_CHK(12) THEN LEAVE BLOCK2 WITH 1;
	0				! To eliminate INFO compiler message
	END;
	IF .NOERR_17 EQL 0
	    THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	'ERR HOLD' should be 0 - ('MR' would turn it off if on)
!*RESPONSE:
!*	'MMC5 ERR HOLD' bit 00 asserted

!]ERROR 1
!] C5 E5 F5 G5 C7 L7 AA  NTWK
!]NO ERROR 1
!] H3  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	'UNCOR ERR HOLD' should be 0
!*RESPONSE:
!*	'MMC4 UNCOR ERR HOLD' bit 01 asserted

!]ERROR 2
!] J4 B5 G5 C7 L7 AA  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	'REFRESH ERR' should be 0 - ('MR' would turn it off if on)
!*RESPONSE:
!*	'MMC9 REF ERR' bit 02 asserted

!]ERROR 3
!] A1 C7 L7 B9 AA  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	'PARITY ERR' should be 0 - ('DI 0' would turn it off if on)
!*RESPONSE:
!*	'MMC7 PARITY ERR' bit 03 asserted

!]ERROR 4
!] A_J1 N1 E3 F3 B7 C7 L7 AA  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	'ECC ON' should be 1 - ('DI 0' turns it on)
!*RESPONSE:
!*	'MMC3 ECC ON' bit 04 not asserted

!]ERROR 5
!] B1 E3 F3 H3 D7 L7 AA  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	'POWER FAILED' should be 0
!*RESPONSE:
!*	'MMC5 POWER FAILED' bit 12 asserted

!]ERROR 6
!] A5 C7 L7 AA  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
!*			  clear 'REF ERR', set 'PE', turn off ECC)
!*	EI 100000	Read Mem Status Reg
!*RESPONSE:
!*	'MMC5 ERR HOLD' bit 00 asserted

!]ERROR 7
!] C5 E5 F5 G5 C7 L7 AA  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
!*			  clear 'REF ERR', set 'PE', turn off ECC)
!*	EI 100000	Read Mem Status Reg
!*RESPONSE:
!*	'MMC4 UNCOR ERR HOLD' bit 01 asserted

!]ERROR 8
!] J4 B5 G5 C7 L7 AA  NTWK
!]NO ERROR 8
!]  NTWK

!*MESSAGE 9
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
!*			  clear 'REF ERR', set 'PE', turn off ECC)
!*	EI 100000	Read Mem Status Reg
!*RESPONSE:
!*	'MMC9 REF ERR' bit 02 asserted

!]ERROR 9
!] C7 L7 B9 AA  NTWK
!]NO ERROR 9
!]  NTWK

!*MESSAGE 10
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
!*			  clear 'REF ERR', set 'PE', turn off ECC)
!*	EI 100000	Read Mem Status Reg
!*RESPONSE:
!*	'MMC7 PARITY ERR' bit 03 not asserted

!]ERROR 10
!] A_J1 N1 E3 F3 B7 C7 L7 AA  NTWK
!]NO ERROR 10
!]  NTWK

!*MESSAGE 11
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
!*			  clear 'REF ERR', set 'PE', turn off ECC)
!*	EI 100000	Read Mem Status Reg
!*RESPONSE:
!*	'MMC3 ECC ON' bit 04 asserted

!]ERROR 11
!] B1 E3 F3 H3 D7 L7 AA  NTWK
!]NO ERROR 11
!]  NTWK

!*MESSAGE 12
!*STIMULUS:
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
!*	EI 100000	Read Mem Status Reg
!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
!*			  clear 'REF ERR', set 'PE', turn off ECC)
!*	EI 100000	Read Mem Status Reg
!*RESPONSE:
!*	'MMC5 POWER FAILED' bit 12 asserted

!]ERROR 12
!] A5 C7 L7 AA  NTWK
!]NO ERROR 12
!]  NTWK

END;
GLOBAL ROUTINE TST18: NOVALUE =

!++   -------------------- PARITY ERROR --------------------------
! TEST DESCRIPTION:  This routine tests parity checking on the MMC
!	board.   Since  bad parity cannot be generated explicitly,
!	the test uses the Mem Status Register to set parity error.
!	then it verifies that parity error actually occurred. Then
!	'PE' is cleared and the fact is verified.  This test is an
!	expansion  of an earlier test which tested various bits of
!	the Memory Status Register.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Do a Master Reset
!		   Shut off 8080 parity checking
!		   Write status (parity error)
!		   Check to see if PE occurred
!		   Write status (no parity error)
!		   Check to see if PE still set
!
! POSSIBLE ERRORS:  Faulty parity error register logic.  Or the
!			route to the PE flop or from it to the
!			8080 is faulty.
!
!--

BEGIN

LOCAL
	TEMP;

LABEL
	BLOCK1;

IF RUN_TEST(18) THEN RETURN;		! Run this test? Return if no

NOERR_18 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
PAR_DISABLE;				! Disable parity error checking by 8080

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	IO_DEPOSIT(MSR,PE_SET);		! Set PE
	SEND_NUL();			! Send it off to 8080

	TEMP = RD_100;			! Read Reg 100 - should show PE exists
	IF (.TEMP AND %O'010') NEQ 0	! If it doesnt - set error flag and 
	    THEN BEGIN			!   print error message.
		 NOERR_18 = 1;
		 ERR(1);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	IO_DEPOSIT(MSR,PE_CLR);		! Clear out the PE
	TEMP = RD_100;			! Read Reg 100 - should show no PE
	IF (.TEMP AND %O'010') EQL 0	! If it does - set error flag and
	    THEN BEGIN			!   print error message.
		 NOERR_18 = 1;
		 ERR(2);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

! If no errors in Tests 17 or 18 then parity error logic on MMC7 is ok.

	IF (.NOERR_17 OR .NOERR_18) NEQ 0
	    THEN NOERR(1);

! If no errors in Tests 8 or 18 then parity generators on MMC1 are ok.

	IF (.NOERR_8 OR .NOERR_18) NEQ 0
	    THEN NOERR(2);

!*MESSAGE 1
!*STIMULUS
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000	Set 'MMC7 PARITY ERR' by writing
!*	DI 40000000000	  to Mem Status Register
!*	ER 100		Look at 8080 Reg 100 to see if PE detected
!*RESPONSE
!*	8080 Reg 100 is: \O0 - No mem par err detected

!]ERROR 1
!] E3 F3 H3 B7 C7  NTWK
!]NO ERROR 1
!] B7  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR,PE 3		Shut off 8080 parity checking
!*	LI 100000	Set 'MMC7 PARITY ERR' by writing
!*	DI 40000000000	  to Mem Status Register
!*	ER 100		Look at 8080 Reg 100 to see if PE detected
!*	DI 0		Write status to clear 'MMC7 PARITY ERR'
!*RESPONSE
!*	8080 Reg 100 is: \O0 - Mem par err did not go away

!]ERROR 2
!] A_J1 N1 E3 F3 H3 B7 C7  NTWK
!]NO ERROR 2
!] L1 M1 N1  NTWK

END;
GLOBAL ROUTINE TST19: NOVALUE =

!++   ------------------- ERROR ADDRESS REGISTER ------------------
! TEST DESCRIPTION:  This routine checks the error address register
!	on MMC8.  The address is normally loaded into this register
!	directly from the 8646 transceiver upon receipt of a Com/Adr
!	cycle if the Err Hold flag is not set.  This address will be
!	held in the register until a bus reset or a mem status write
!	clears the Err Hold bit.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write status (Force bits all 1's)
!		   Write a 0 to address 00000000
!		   Read mem loc 00000000 (will cause a single bit ECC
!			error and address will be latched in the Err
!			Adr Reg)
!		   Examine Mem Status Reg and verify address
!		   Write status (Force bits 1's and clear Err Hold)
!		   Repeat with address 17777777
!
!		   When all done reset MMC - Clear Err Hold
!
! POSSIBLE ERRORS:  Faulty chips in the err addr holding register
!			on MMC8
!
!--

BEGIN

LITERAL
	FORCE_SET = %O'400000000376',	! Set force bits 177
	FORCE_CLR = %O'400000000000',	! Clear 'ERR HOLD'
	ADR14_21 = %O'17740000',	! Address for flop 1 of err addr reg
	ADR22_29 = %O'00037700',	! Address for flop 2 of err addr reg
	ADR30_35 = %O'00000077';	! Address for flop 3 of err addr reg

LOCAL
	TEST_ADR,			! Test address we are writing to
	TEMP,
	TEMP1,
	TEMP2,
	ERRNO,
	ERR_SWITCH,
	ERR_TEMP,
	ERR_FLAG;

OWN
	MESSV: VECTOR[2],		! Error message output vector
	MEM_STAT_REG,
	MEM_STAT_ADR,
	MSR_CORR,
	ADR: VECTOR[2]			! Memory addresses to use
	     INITIAL (%O'177777',0);

LABEL
	BLOCK1;

IF RUN_TEST(19) THEN RETURN;		! Run this test? Return if no

NOERR_19 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 1 DO
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    TEST_ADR = MESSV = .ADR[.TEST];
	    MSR_CORR = .MESSV OR %O'437700000000';
	    IO_DEPOSIT(MSR,FORCE_SET);	! Set force bits
	    MEM_DEPOSIT(.TEST_ADR,0);	! Write 0's to test address
	    MEM_EXAMINE(.TEST_ADR);	! Read test address - load err adr reg
	    MEM_STAT_REG = IO_EXAMINE(MSR);! Read MSR - see what we got
	    MEM_STAT_ADR = .MEM_STAT_REG AND %O'17777777';

	    ERR_FLAG = 0;
	    IF .MEM_STAT_ADR EQL MSR OR .MEM_STAT_REG GEQ 0
		THEN BEGIN		! If either the address was MSR or
		     ERR_FLAG = 1;	!   'ERR HOLD' was not set then set
		     ECC_SINGLE = 1;	!   error flags and print error message
		     NOERR_19 = 1;
		     ERRCAS(1,1,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
		     END;
	    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	    INCR BTT FROM 14 TO 35 DO	! Now check for single bit errors in 
		BEGIN			!   the address and report any found
		ERRNO = .BTT - 12;
		ERR_TEMP = (.ERR_FLAG EQL 0 AND .TEST_ADR NEQ .MEM_STAT_ADR);
		MESSV[1] = .BTT;
		TEMP = .MEM_STAT_ADR XOR 1^(35-.BTT);
		IF .ERR_TEMP AND (.TEMP EQL .TEST_ADR)
		    THEN BEGIN
			 TEST_ABORT = 1;
			 NOERR_19 = 1;
			 ERRCAS(.ERRNO,2,.MSR_CORR,.MEM_STAT_REG,12,MESSV);
			 ERR_FLAG = 1;
			 END;
		IF LOOP_CHK(.ERRNO) THEN LEAVE BLOCK1 WITH 1;
		END;

	    TEMP1 = .TEST_ADR OR ADR14_21;	! Now handle multiple errors
	    TEMP2 = .MEM_STAT_ADR OR ADR14_21;	!   in flop 1 - report
	    ERR_SWITCH = (.ERR_FLAG EQL 0) AND (.TEST_ADR NEQ .MEM_STAT_ADR);
	    IF (.TEMP1 EQL .TEMP2) AND (.ERR_SWITCH EQL 1)
		THEN BEGIN
		     TEST_ABORT = 1;
		     NOERR_19 = 1;
		     ERRCAS(24,3,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
		     ERR_FLAG = 1;
		     END;
	    IF LOOP_CHK(24) THEN LEAVE BLOCK1 WITH 1;

	    TEMP1 = .TEST_ADR OR ADR22_29;	! Now handle multiple errors
	    TEMP2 = .MEM_STAT_ADR OR ADR22_29;	!   in flop 2 - report
	    ERR_SWITCH = (.ERR_FLAG EQL 0) AND (.TEST_ADR NEQ .MEM_STAT_ADR);
	    IF (.TEMP1 EQL .TEMP2) AND (.ERR_SWITCH EQL 1)
		THEN BEGIN
		     TEST_ABORT = 1;
		     NOERR_19 = 1;
		     ERRCAS(25,4,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
		     ERR_FLAG = 1;
		     END;
	    IF LOOP_CHK(25) THEN LEAVE BLOCK1 WITH 1;

	    TEMP1 = .TEST_ADR OR ADR30_35;	! Now handle multiple errors
	    TEMP2 = .MEM_STAT_ADR OR ADR30_35;	!   in flop 3 - report
	    ERR_SWITCH = (.ERR_FLAG EQL 0) AND (.TEST_ADR NEQ .MEM_STAT_ADR);
	    IF (.TEMP1 EQL .TEMP2) AND (.ERR_SWITCH EQL 1)
		THEN BEGIN
		     TEST_ABORT = 1;
		     NOERR_19 = 1;
		     ERRCAS(26,5,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
		     ERR_FLAG = 1;
		     END;
	    IF LOOP_CHK(26) THEN LEAVE BLOCK1 WITH 1;

! If no single or isolated error the whole address must be messed up
!   so report that. 

	    IF .ERR_FLAG EQL 0 AND .TEST_ADR NEQ .MEM_STAT_ADR
		THEN BEGIN
		     NOERR_19 = 1;
		     ERRCAS(27,6,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
		     END;
		IF LOOP_CHK(27) THEN LEAVE BLOCK1 WITH 1;
	    0				! To eliminate INFO compiler message
	    END;

! Clear MMC prior to doing the next part of the loop.

	IO_DEPOSIT(MSR,FORCE_CLR);
	END;

! If Tests 17 and 19 passed then the 'ERR HOLD' logic on MMC5 must be ok
!  so call NOERR and clear that network from the 'possible faulty networks'
!  maintained by STIRS via a call to NOERR.

	IF (.NOERR_17 OR .NOERR_19) EQL 0
	    THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA (ADDR),DM0	Write 0's to mem loc \O0
!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
!*	EI 100000	Examine Mem Status Reg - Should contain memory
!*			  address \O0 (Loaded when ECC error occurred)
!*RESPONSE
!*	'MMC5 ERR HOLD' not set by 'EM' so the address returned in
!*	   Mem Stat Reg is 100000 (MSR)

!]ERROR 1
!] E3 H4 C5 E5 I5 G6 H6 I8 J8 K8 AA AB  NTWK
!]NO ERROR 1
!] C5  NTWK

!*MESSAGE 2
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA (ADDR),DM0	Write 0's to mem loc \O0
!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
!*	EI 100000	Examine Mem Status Reg - Should contain memory
!*			  address \O0 (Loaded when ECC error occurred)
!*RESPONSE
!*	Bit \D1 of returned address incorrect

!]ERROR 2
!] D1 K3 I5 F7 I8  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] D1 L3 I5 F7 I8  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] E1 L3 I5 G7 I8  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] E1 J3 I5 G7 I8  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] F1 J3 I5 G7 I8  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] F1 J3 I5 G7 I8  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] F1 J3 I5 H7 I8  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] F1 K3 I5 H7 I8  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] G1 L3 I5 H7 J8  NTWK
!]NO ERROR 10
!]  NTWK

!]ERROR 11
!] G1 L3 I5 H7 J8  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] G1 L3 I5 I7 J8  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] G1 L3 I5 I7 J8  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] H1 L3 I5 I7 J8  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] H1 L3 I5 I7 J8  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] H1 M3 I5 J7 J8  NTWK
!]NO ERROR 16
!]  NTWK

!]ERROR 17
!] H1 M3 I5 J7 J8  NTWK
!]NO ERROR 17
!]  NTWK

!]ERROR 18
!] I1 M3 I5 J7 K8  NTWK
!]NO ERROR 18
!]  NTWK

!]ERROR 19
!] I1 M3 I5 J7 K8  NTWK
!]NO ERROR 19
!]  NTWK

!]ERROR 20
!] I1 M3 I5 K7 K8  NTWK
!]NO ERROR 20
!]  NTWK

!]ERROR 21
!] I1 M3 I5 K7 K8  NTWK
!]NO ERROR 21
!]  NTWK

!]ERROR 22
!] J1 M3 I5 K7 K8  NTWK
!]NO ERROR 22
!]  NTWK

!]ERROR 23
!] J1 M3 I5 K7 K8  NTWK
!]NO ERROR 23
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA (ADDR),DM0	Write 0's to mem loc \O0
!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
!*	EI 100000	Examine Mem Status Reg - Should contain memory
!*			  address \O0 (Loaded when ECC error occurred)
!*RESPONSE
!*	Bits 14..21 of returned address incorrect

!]ERROR 24
!] J3 K3 L3 N3 I5 I8  NTWK
!]NO ERROR 24
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA (ADDR),DM0	Write 0's to mem loc \O0
!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
!*	EI 100000	Examine Mem Status Reg - Should contain memory
!*			  address \O0 (Loaded when ECC error occurred)
!*RESPONSE
!*	Bits 22..29 of returned address incorrect

!]ERROR 25
!] L3 M3 N3 I5 J8  NTWK
!]NO ERROR 25
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA (ADDR),DM0	Write 0's to mem loc \O0
!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
!*	EI 100000	Examine Mem Status Reg - Should contain memory
!*			  address \O0 (Loaded when ECC error occurred)
!*RESPONSE
!*	Bits 30..35 of returned address incorrect

!]ERROR 26
!] M3 N3 I5 K8  NTWK
!]NO ERROR 26
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
!*	LA (ADDR),DM0	Write 0's to mem loc \O0
!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
!*	EI 100000	Examine Mem Status Reg - Should contain memory
!*			  address \O0 (Loaded when ECC error occurred)
!*RESPONSE
!*	Bits 14-35 of returned address incorrect (multiple bit errors
!*	  not matching any particular chip)

!]ERROR 27
!] J3 K3 L3 M3 N3 I5 F7 G7 H7 I7 J7 K7 L7 I8 J8 K8  NTWK
!]NO ERROR 27
!]  NTWK

END;
GLOBAL ROUTINE TST20: NOVALUE =

!++   ----------------------- 'FORCE BITS' --------------------------
! TEST DESCRIPTION:   This  routine  tests  the 'FORCE BITS' that are
!	written to the MMC board by a write status.  They are used to
!	calculate the 7 bit ECC code along with bits 00-35. In normal
!	operation the force bits are all 0.  When an ECC error occurs
!	(only during a read) the  memory  address being accessed gets
!	loaded into an error register on MMC8.  Also  the  check bits
!	are loaded into an error register on MMC4. Then a read status
!	can be done to access the check bits which should be the same
!	as the force bits.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status (Force bits 1111110)
!		   Write 0's to mem loc 33
!		   Read mem loc 33 (Causes ECC error)
!		   Read status and verify force bits and address
!
! POSSIBLE ERRORS:  Incorrect force bits returned - 'MMC3 FORCE' register,
!			'MMC4 ERR' check bits register, 'MMC4 FORCE' 2x4
!			mixers, or MMC7 4x2 mixers faulty
!		    Incorrect Err Address - MMC7 4x2 mixers, 'MMC8 ERR
!			ADDR' register faulty
!
!--

BEGIN

LITERAL
	RESET = %O'700000000000',	! Clear 'ERR HOLD','REF ERR','PE'
	FORCE_ONES = %O'700040000374',	! Write force bits all ones to MSR
	LFOR = %O'761777777777',	! Masks for isolating force bit errors
	RFOR = %O'777077777777',	!   to flops on MMC4 or mixers on MMC7.
	LFORA = %O'760777777777',	!   LFOR,RFORA - mixers on MMC7.
	RFORA = %O'776077777777',	!   LFORA,RFOR - flops on MMC4.  
	BITS14_21 = %O'000017740000',	! Error address bit masks corresponding
	BITS22_29 = %O'000000037700',	!   to three flops on MMC8
	BITS30_35 = %O'000000000077';	!	...

LOCAL
	ERR_OCC,			! Flag to say 'an error occurred'
	ERR_FLAG,			! Error flag
	TEMP;

OWN
	MESSV,				! Error message output data
	STRUCT: VECTOR[5]		! For use in structure declarations
	    INITIAL (14,20,22,28,30),	!   STR1,STR2 for mapping error address
	MEM_TEMP_VECT: BTTVECTOR[36],
	MSR_CORR_VECT: BTTVECTOR[36],
	MEM_STAT_VECT: BTTVECTOR[36],

! Error message strings - MESS_STR and MESS_WSTR

	MESS_STR: VECTOR[12]
	    INITIAL(UPLIT(%ASCIZ ' CP'),UPLIT(%ASCIZ ' C40'),
		    UPLIT(%ASCIZ ' C20'),UPLIT(%ASCIZ ' C10'),
		    UPLIT(%ASCIZ ' C4'),UPLIT(%ASCIZ ' C2'),
		    UPLIT(%ASCIZ ' C1'),UPLIT(%ASCIZ 's CP,C40,C20'),
		    UPLIT(%ASCIZ 's C4,C2,C1'),UPLIT(%ASCIZ 's CP,C40,C20,C10'),
		    UPLIT(%ASCIZ 's C10,C4,C2,C1'),
		    UPLIT(%ASCIZ 's CP,C40,C20,C10,C4,C2,C1')),
	MESS_WSTR: VECTOR[14]
	    INITIAL(UPLIT(%ASCIZ '14,15'),UPLIT(%ASCIZ '20,21'),
		    UPLIT(%ASCIZ '22,23'),UPLIT(%ASCIZ '28,29'),
		    UPLIT(%ASCIZ '30,31'),UPLIT(%ASCIZ '16..19'),
		    UPLIT(%ASCIZ '20..23'),UPLIT(%ASCIZ '24..27'),
		    UPLIT(%ASCIZ '28..31'),UPLIT(%ASCIZ '32..35'),
		    UPLIT(%ASCIZ '14..21'),UPLIT(%ASCIZ '22..29'),
		    UPLIT(%ASCIZ '30..35'),UPLIT(%ASCIZ '14..35'));

STRUCTURE
	STR1[I;N] = [N]
	    (STR1)<34-.STRUCT[I],2>,
	STR2[I;N] = [N]
	    (STR2)<32-I*4-16,4>;

OWN
	MEM_TEMP1_VECT: STR1[1],
	MEM_TEMP2_VECT: STR2[1],
	TEST1_VECT: STR1[1],
	TEST2_VECT: STR2[1];

BIND
	MSR_CORR = MSR_CORR_VECT,
	MEM_STAT = MEM_STAT_VECT,
	MEM_TEMP = MEM_TEMP_VECT,
	MEM_TEMP1 = MEM_TEMP1_VECT,
	MEM_TEMP2 = MEM_TEMP2_VECT,
	T1_VECT = TEST1_VECT,
	T2_VECT = TEST2_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(20) THEN RETURN;		! Run this test? Return if no

NOERR_20 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	IO_DEPOSIT(MSR,FORCE_ONES);	! Write force bits to MMC board
	DM(33,0);			! Write 0's to mem loc 33 then read it
	TEMP = EM(33);			!   back (causes double bit ECC error)
	MSR_CORR = %O'637600000033';	! Correct contents of MSR
	MEM_STAT = IO_EXAMINE(MSR);	! Actual contents of MSR

! First check out the first 5 bits of the result - 'ERR HOLD','UNCOR ERR HOLD',
!   'REFRESH ERR','PARITY ERR','ECC'.

	IF .MEM_STAT_VECT[0] NEQ 1	! 'ERR HOLD' should be asserted - if
	    THEN BEGIN			!   not - set error flags and print
		 ECC_DOUBLE = 1;	!   error message.
		 NOERR_20 = 1;
		 ERRCA(1,.MSR_CORR,.MEM_STAT,12);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	IF .MEM_STAT_VECT[1] NEQ 1	! 'UNCOR ERR HOLD' should be asserted
	    THEN BEGIN			! If not - set error flag and print
		 NOERR_20 = 1;		!   error message.
		 ERRCA(2,.MSR_CORR,.MEM_STAT,12);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF .MEM_STAT_VECT[2] NEQ 0	! 'REF ERR' should not be asserted.
	    THEN BEGIN			! If it is - set error flag and print
		 NOERR_20 = 1;		!   error message.
		 ERRCA(3,.MSR_CORR,.MEM_STAT,12);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	IF .MEM_STAT_VECT[3] NEQ 0	! 'PARITY ERR' should not be asserted.
	    THEN BEGIN			! If it is - set error flag and print
		 NOERR_20 = 1;		!   error message.
		 ERRCA(4,.MSR_CORR,.MEM_STAT,12);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;

	IF .MEM_STAT_VECT[4] NEQ 1	! 'ECC' should still be on - If it
	    THEN BEGIN			!   isn't - set error flags and print
		 TEST_ABORT = 1;	!   error message.
		 NOERR_20 = 1;
		 ERRCA(5,.MSR_CORR,.MEM_STAT,12);
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;

! Secondly, check out the next 7 bits - force bits.

! Now mask out everything except for the force bits and verify that they are
!   correct.  If not correct report the error and set error flag.  This only
!   checks a single bit error (only one bit is in error).

	MEM_TEMP = .MEM_STAT OR %O'017600000000';
	ERR_FLAG = 0;
	INCR ERRR FROM 5 TO 11 DO
	    BEGIN
	    IF .MEM_TEMP EQL (.MEM_STAT XOR 1^(35-.ERRR))
		THEN BEGIN
		     MESSV = .MESS_STR[.ERRR-5];
		     NOERR_20 = 1;
		     ERRCAS(.ERRR+1,6,.MSR_CORR,.MEM_STAT,12,MESSV);
		     ERR_FLAG = 1;
		     END;
	    IF LOOP_CHK(.ERRR+1) THEN LEAVE BLOCK1 WITH 1;
	    END;

! If an error did occur but we have not yet reported it then the fault
!   could be a multiple bit error in one of the chips that holds the
!   force bits. So first check LFOR - left 3 bits which are a complete
!   mixer on MMC7 and part of a flop on MMC7.

	ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
	IF ((.MEM_TEMP AND LFOR) EQL (.MEM_STAT AND LFOR)) AND .ERR_OCC
	    THEN BEGIN
		 MESSV = .MESS_STR[7];
		 NOERR_20 = 1;
		 ERRCAS(13,6,.MSR_CORR,.MEM_STAT,12,MESSV);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(13) THEN LEAVE BLOCK1 WITH 1;

! Now check RFOR - right 3 bits which are a complete flop on MMC4 and
!   and part of a mixer on MMC7.

	ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
	IF ((.MEM_TEMP AND RFOR) EQL (.MEM_STAT AND RFOR)) AND .ERR_OCC
	    THEN BEGIN
		 MESSV = .MESS_STR[8];
		 NOERR_20 = 1;
		 ERRCAS(14,6,.MSR_CORR,.MEM_STAT,12,MESSV);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(14) THEN LEAVE BLOCK1 WITH 1;

! Now check LFORA - left 4 bits which are a complete mixer on MMC7 and
!   and more than a flop on MMC4.

	ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
	IF ((.MEM_TEMP AND LFORA) EQL (.MEM_STAT AND LFORA)) AND .ERR_OCC
	    THEN BEGIN
		 MESSV = .MESS_STR[9];
		 NOERR_20 = 1;
		 ERRCAS(15,6,.MSR_CORR,.MEM_STAT,12,MESSV);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(15) THEN LEAVE BLOCK1 WITH 1;

! Now check RFORA - left 4 bits which are a complete flop on MMC4 and
!   and more than a mixer on MMC7.

	ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
	IF ((.MEM_TEMP AND RFORA) EQL (.MEM_STAT AND RFORA)) AND .ERR_OCC
	    THEN BEGIN
		 MESSV = .MESS_STR[10];
		 NOERR_20 = 1;
		 ERRCAS(16,6,.MSR_CORR,.MEM_STAT,12,MESSV);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(16) THEN LEAVE BLOCK1 WITH 1;

! Now if no particular errors have been determined so far yet a fault
!   fault really does exist then just report the error.  The fault
!   isolation really can't narrow down on very much however.

	IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
	    THEN BEGIN
		 MESSV = .MESS_STR[11];
		 NOERR_20 = 1;
		 ERRCAS(17,6,.MSR_CORR,.MEM_STAT,12,MESSV);
		 END;
	IF LOOP_CHK(17) THEN LEAVE BLOCK1 WITH 1;

! Thirdly, check out bit 12 - 'POWER FAIL'.

	IF .MEM_STAT_VECT[12] NEQ 0	! 'POWER FAIL' should not be asserted.
	    THEN BEGIN			! If it is - set error flags and print
		 NOERR_20 = 1;		!    error message.
		 ERRCAS(18,7,.MSR_CORR,.MEM_STAT,12,MESSV);
		 END;
	IF LOOP_CHK(18) THEN LEAVE BLOCK1 WITH 1;

! Fourthly check out the remainder of the MSR contents - bits 14 .. 35
!   the error address.

! If error address register is loaded indiscriminately it may contain the
!   last address sent off to MMC board which is 100000 (address of MSR) so
!   check it out.

	ERR_FLAG = 0;
	MEM_TEMP = .MEM_STAT AND %O'777740000033';
	IF .MEM_TEMP<0,22> EQL MSR	! If error address is 100000 - set
	    THEN BEGIN			!   error flags and print error
		 ERR_FLAG = 1;		!   message.
		 NOERR_20 = 1;
		 ERRCAS(19,8,.MSR_CORR,.MEM_STAT,12,MESSV);
		 END;

! Now check for a single bit error in the address.  If there is a single
!   bit in error (none others incorrect) then set error flags and print
!   error message.

	INCR ERRR FROM 14 TO 35 DO
	    BEGIN
	    IF .MEM_TEMP EQL (.MEM_STAT XOR 1^(35-.ERRR))
		THEN BEGIN
		     TEST_ABORT = 1;
		     NOERR_20 = 1;
		     ERRCAS(.ERRR+6,9,.MSR_CORR,.MEM_STAT,12,ERRR);
		     ERR_FLAG = 1;
		     END;
	    IF LOOP_CHK(.ERRR+5) THEN LEAVE BLOCK1 WITH 1;
	    END;

! There is a multiple bit error in the error address (if there is one at all)
!   so check various bit combinations which are the bits which are common to
!   both the mixers on MMC7 and the error address register on MMC8.  This is
!   the 5 bit combinations which happen to be 2 bits wide - and hence can be
!   represented by a data structure T1_VECT and TEST1_VECT.
! If any errors are found - set error flags and print error message.

	INCR ERRR FROM 0 TO 4 DO
	    BEGIN
	    IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
		THEN BEGIN
		     T1_VECT = .MEM_STAT;
		     TEST1_VECT[.ERRR] = 0;
		     MEM_TEMP1 = .MEM_TEMP;
		     MEM_TEMP1_VECT[.ERRR] = 0;
		     IF .MEM_TEMP1 EQL .T1_VECT
			THEN BEGIN
			     MESSV = .MESS_WSTR[.ERRR];
			     TEST_ABORT = 1;
			     NOERR_20 = 1;
			     ERRCAS(.ERRR+42,10,.MSR_CORR,.MEM_STAT,12,MESSV);
			     ERR_FLAG = 1;
			     END;
		     END;
	    IF LOOP_CHK(.ERRR+42) THEN LEAVE BLOCK1 WITH 1;
	    END;

! As above but we now are done with the 2 bit combinations so go to the 4 bit
!   combinations which match the mixers on MMC7 and are subsets of the error
!   address register on MMC8.
! If any errors are found - set error flags and print error message.

	INCR ERRR FROM 0 TO 4 DO
	    BEGIN
	    IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
		THEN BEGIN
		     T2_VECT = .MEM_STAT;
		     TEST2_VECT[.ERRR] = 0;
		     MEM_TEMP2 = .MEM_TEMP;
		     MEM_TEMP2_VECT[.ERRR] = 0;
		     IF .MEM_TEMP2 EQL .T2_VECT
			THEN BEGIN
			     MESSV = .MESS_WSTR[.ERRR+5];
			     TEST_ABORT = 1;
			     NOERR_20 = 1;
			     ERRCAS(.ERRR+47,10,.MSR_CORR,.MEM_STAT,12,MESSV);
			     ERR_FLAG = 1;
			     END;
		     END;
	    IF LOOP_CHK(.ERRR+47) THEN LEAVE BLOCK1 WITH 1;
	    END;

! So far (if no errors have occurred yet) the fault (if there is one) is a
!   multiple bit error which covers a larger area than we have already looked
!   at.  So now we check to see if the error is a multiple bit error probably
!   involving the control logic on one of the three error address register 
!   chips on MMC8.  First check bits 14..21.
! If any errors are found - set error flags and print error message.

	ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
	IF ((.MEM_TEMP OR BITS14_21) EQL (.MEM_STAT OR BITS14_21)) AND .ERR_OCC
	    THEN BEGIN
		 MESSV = .MESS_WSTR[10];
		 TEST_ABORT = 1;
		 NOERR_20 = 1;
		 ERRCA(52,11,.MSR_CORR,.MEM_STAT,12,MESSV);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(52) THEN LEAVE BLOCK1 WITH 1;

! Now check bits 22..29 of error address register as described above.
! If any errors are found - set error flags and print error message.

	ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
	IF ((.MEM_TEMP OR BITS22_29) EQL (.MEM_STAT OR BITS22_29)) AND .ERR_OCC
	    THEN BEGIN
		 MESSV = .MESS_WSTR[11];
		 TEST_ABORT = 1;
		 NOERR_20 = 1;
		 ERRCA(53,11,.MSR_CORR,.MEM_STAT,12,MESSV);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(53) THEN LEAVE BLOCK1 WITH 1;

! Now check bits 30..35 of error address register as described above.
! If any errors are found - set error flags and print error message.

	ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
	IF ((.MEM_TEMP OR BITS30_35) EQL (.MEM_STAT OR BITS30_35)) AND .ERR_OCC
	    THEN BEGIN
		 MESSV = .MESS_WSTR[12];
		 NOERR_20 = 1;
		 ERRCA(54,11,.MSR_CORR,.MEM_STAT,12,MESSV);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(54) THEN LEAVE BLOCK1 WITH 1;

! If still no errors have been isolated and there is a fault somewhere
!   there is not much to do except report the results in a generalized
!   error message - there are multiple bit errors in strange places
!   which probably means this board has multiple faults on it.
! If any errors are found - set error flags and print error message.

	IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
	    THEN BEGIN
		 MESSV = .MESS_WSTR[13];
		 NOERR_20 = 1;
		 ERRCAS(55,11,.MSR_CORR,.MEM_STAT,12,MESSV);
		 END;
	IF LOOP_CHK(55) THEN LEAVE BLOCK1 WITH 1;

! All done testing.  Now just reset the board particularly in regard to
!   'UNCOR ERR HOLD' in the MSR which can be cleared only by doing a
!   deposit followed by an examine after a reset has been done.

	IO_DEPOSIT(MSR,RESET);		! Clear the error bits in MSR on MMC
	DM(0,0);			! Write 0's to mem loc 0
	EM(0);				! Read mem loc 0 (should shut off
	0				! To eliminate INFO compiler message
	END;				!   'UNCOR ERR HOLD'

! If Tests 17 and 20 both passed then 'MMC5 ERR HOLD' logic is ok.

	IF (.NOERR_17 OR .NOERR_20) EQL 0 THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC5 ERR HOLD' should be asserted
!*RESPONSE
!*	'MMC5 ERR HOLD' bit 00 not asserted

!]ERROR 1
!] E3 H4 C5 E5 F5 G5 G6 H6 C7  NTWK
!]NO ERROR 1
!] C5  NTWK

!*MESSAGE 2
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC4 UNCOR ERR HOLD' should be set
!*RESPONSE
!*	'MMC4 UNCOR ERR HOLD' bit 01 not asserted

!]ERROR 2
!] E3 H3 H4 J4 C5 E5 F5 G5 H5 G6 H6 C7  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC9 REF ERR' should not be asserted
!*RESPONSE
!*	'MMC9 REF ERR' bit 02 asserted

!]ERROR 3
!] E3 H3 C7 A9 B9 C9  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC7 PARITY ERR' should not be asserted
!*RESPONSE
!*	'MMC7 PARITY ERR' bit 03 asserted

!]ERROR 4
!] A_J1 N1 B7 C7  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC3 ECC ON' should be asserted
!*RESPONSE
!*	'MMC3 ECC ON' bit 04 not asserted

!]ERROR 5
!] B1 E3 H3 D7  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC4 ERR' check bits should be 1111110
!*RESPONSE
!*	'MMC4 ERR' check bit\S0 incorrect

!]ERROR 6
!] B1 E3 H3 A4 H4 I4 C5 E5 F5 G5 G6 H6 D7  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] B1 E3 H3 B4 H4 I4 K4 C5 E5 F5 G5 G6 H6 D7  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] B1 E3 H3 C4 H4 I4 L4 C5 E5 F5 G5 G6 H6 D7  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] C1 E3 H3 D4 H4 I4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] C1 E3 H3 E4 H4 I4 K4 C5 E5 F5 G5 G6 H6 E7  NTWK
!]NO ERROR 10
!]  NTWK

!]ERROR 11
!] C1 E3 H3 F4 H4 I4 L4 C5 E5 F5 G5 G6 H6 E7  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] C1 E3 H3 G4 H4 I4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] E3 H3 A4 B4 C4 H4 I4 K4 L4 C5 E5 F5 G5 G6 H6 D7  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] E3 H3 E4 F4 G4 H4 I4 K4 L4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] E3 H3 A4 B4 C4 D4 H4 I4 K4 L4 M4 C5 E5 F5 G5 G6 H6 D7 E7  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] E3 H3 D4 E4 F4 G4 H4 I4 K4 L4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
!]NO ERROR 16
!]  NTWK

!]ERROR 17
!] E3 H3 A_H4 K4 L4 M4 I4 C5 E5 F5 G5 G6 H6 D7 E7  NTWK
!]NO ERROR 17
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC5 POWER FAILED' should not be asserted
!*RESPONSE
!*	'MMC5 POWER FAILED' bit 12 asserted

!]ERROR 18
!] A5 F7  NTWK
!]NO ERROR 18
!]  NTWK

!*MESSAGE 8
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC8 ERR ADDR' should be 0
!*RESPONSE
!*	'MMC8 ERR ADDR' is 100000 (Mem Stat Reg)

!]ERROR 19
!] E3 H3 H4 C5 E5 F5 G5 I5 G6 H6 I8 J8 K8  NTWK
!]NO ERROR 19
!]  NTWK

!*MESSAGE 9
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC8 ERR ADDR' should be 0
!*RESPONSE
!*	'MMC8 ERR ADDR' bit \D0 incorrect

!]ERROR 20
!] D1 F7 I8  NTWK
!]NO ERROR 20
!]  NTWK

!]ERROR 21
!] D1 F7 I8  NTWK
!]NO ERROR 21
!]  NTWK

!]ERROR 22
!] E1 G7 I8  NTWK
!]NO ERROR 22
!]  NTWK

!]ERROR 23
!] E1 G7 I8  NTWK
!]NO ERROR 23
!]  NTWK

!]ERROR 24
!] F1 G7 I8  NTWK
!]NO ERROR 24
!]  NTWK

!]ERROR 25
!] F1 G7 I8  NTWK
!]NO ERROR 25
!]  NTWK

!]ERROR 26
!] F1 H7 I8  NTWK
!]NO ERROR 26
!]  NTWK

!]ERROR 27
!] F1 H7 I8  NTWK
!]NO ERROR 27
!]  NTWK

!]ERROR 28
!] G1 H7 J8  NTWK
!]NO ERROR 28
!]  NTWK

!]ERROR 29
!] G1 H7 J8  NTWK
!]NO ERROR 29
!]  NTWK

!]ERROR 30
!] G1 I7 J8  NTWK
!]NO ERROR 30
!]  NTWK

!]ERROR 31
!] G1 I7 J8  NTWK
!]NO ERROR 31
!]  NTWK

!]ERROR 32
!] H1 I7 J8  NTWK
!]NO ERROR 32
!]  NTWK

!]ERROR 33
!] H1 I7 J8  NTWK
!]NO ERROR 33
!]  NTWK

!]ERROR 34
!] H1 J7 J8  NTWK
!]NO ERROR 34
!]  NTWK

!]ERROR 35
!] H1 J7 J8  NTWK
!]NO ERROR 35
!]  NTWK

!]ERROR 36
!] I1 J7 K8  NTWK
!]NO ERROR 36
!]  NTWK

!]ERROR 37
!] I1 J7 K8  NTWK
!]NO ERROR 37
!]  NTWK

!]ERROR 38
!] I1 K7 K8  NTWK
!]NO ERROR 38
!]  NTWK

!]ERROR 39
!] I1 K7 K8  NTWK
!]NO ERROR 39
!]  NTWK

!]ERROR 40
!] J1 K7 K8  NTWK
!]NO ERROR 40
!]  NTWK

!]ERROR 41
!] J1 K7 K8  NTWK
!]NO ERROR 41
!]  NTWK

!*MESSAGE 10
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
!*	LA 33,DM 33	Write 0's to mem loc 33
!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
!*	EI 100000	Read MSR - 'MMC8 ERR ADDR' should be 0
!*RESPONSE
!*	'MMC8 ERR ADDR' bits \S0 incorrect

!]ERROR 42
!] F7 I8  NTWK
!]NO ERROR 42
!]  NTWK

!]ERROR 43
!] H7 I8  NTWK
!]NO ERROR 43
!]  NTWK

!]ERROR 44
!] H7 J8  NTWK
!]NO ERROR 44
!]  NTWK

!]ERROR 45
!] J7 J8  NTWK
!]NO ERROR 45
!]  NTWK

!]ERROR 46
!] J7 K8  NTWK
!]NO ERROR 46
!]  NTWK

!]ERROR 47
!] G7 I8  NTWK
!]NO ERROR 47
!]  NTWK

!]ERROR 48
!] H7 I8 J8  NTWK
!]NO ERROR 48
!]  NTWK

!]ERROR 49
!] I7 J8  NTWK
!]NO ERROR 49
!]  NTWK

!]ERROR 50
!] J7 J8 K8  NTWK
!]NO ERROR 50
!]  NTWK

!]ERROR 51
!] K7 K8  NTWK
!]NO ERROR 51
!]  NTWK

!]ERROR 52
!] F7 G7 H7 I8  NTWK
!]NO ERROR 52
!]  NTWK

!]ERROR 53
!] H7 I7 J7 J8  NTWK
!]NO ERROR 53
!]  NTWK

!]ERROR 54
!] E3 G3 H3 I5 J7 K7 K8  NTWK
!]NO ERROR 54
!]  NTWK

!]ERROR 55
!] E3 G3 H3 I5 F7 G7 H7 I7 J7 K7 I8 J8 K8  NTWK
!]NO ERROR 55
!]  NTWK

END;
GLOBAL ROUTINE TST21: NOVALUE =

!++   ------------ ECC:  PARITY GENERATORS FOR CHECK BITS ---------
! TEST DESCRIPTION:  This routine verifies the parity generators on
!	MMC4 which generate the check bits on a read or on a write.
!	In addition  the 'MMC4 ERR'  check bits holding register is
!	implicitly  checked since no difference between the two can
!	be detected.  Since ECC errors could exist on the MMA board
!	this test is attempted on 3 different memory  locations and
!	the condition which is most prevalent is used as the memory
!	location on which to base the results and is  assumed to be
!	unaffected by ECC errors.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (1111111)
!		   Write 1's to mem location 040000,100000,140000
!		   For each memory location do:
!			Examine mem loc (Causes ECC error)
!			Read Mem Status Reg and see if force bits are
!				equal to 1's
!		   If number of matches (check bits are 1's) is
!			greater than 1 then no error exists. Otherwise
!			determine which error exists in one of the
!			error cases.
!
! POSSIBLE ERRORS:  8-D-FLOP chip on MMC4 which holds the check bits
!			is bad
!		    1 or more of the sets of chips which generate the
!			check bits (each set consists of 2 parity
!			generators and 2 xor gates)
!
!--

BEGIN

LITERAL
	ECC_ON_FORCE = %O'700000000376'; ! Set force bits 1's, turn on ECC

MACRO
	FORCE = 24,7,0%;		! Force bits byte pointer in MSR word

LOCAL
	ERR_FLAG,			! Error flag
	MEM_CORR,			! Correct data back from memory
	NUM_ERR,			! Number of errors which have occurred
	MEM_STAT,			! Mem Status Register
	MEM_DATA,			! Data written to memory
	TEMP;

OWN
	MESSV: VECTOR[2],		! Error message output string
	LAST_STAT,			! MSR from the last try
	LAST_ERR,			! Error address from the last try
	LAST_FORCE,			! Force bits from the last try
	TEST_ADR: VECTOR[3]		! Test addresses to use
	    INITIAL (%O'040000',%O'100000',%O'140000'),
	MESS_STR: VECTOR[8]		! Error message strings
	    INITIAL(UPLIT(%ASCIZ ' CP'),UPLIT(%ASCIZ ' C40'),
		    UPLIT(%ASCIZ ' C20'),UPLIT(%ASCIZ ' C10'),
		    UPLIT(%ASCIZ ' C4'),UPLIT(%ASCIZ ' C2'),
		    UPLIT(%ASCIZ ' C1'),UPLIT(%ASCIZ ' s are'));

LABEL
	BLOCK1;

IF RUN_TEST(21) THEN RETURN;		! Run this test? Return if no

NOERR_21 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	IO_DEPOSIT(MSR,ECC_ON_FORCE);	! Write force bits to MSR & turn on ECC

	INCR TEST FROM 0 TO 2 DO	! Write 1's three times to memory
	    MEM_DEPOSIT(.TEST_ADR[.TEST],-1);

	NUM_ERR = 0;			! Init number of errors to zero
	INCR TEST FROM 0 TO 2 DO	! For each try:
	    BEGIN
	    MEM_EXAMINE(.TEST_ADR[.TEST]);	! Read mem loc
	    MEM_STAT = IO_EXAMINE(MSR);		! Read MSR
	    IF .MEM_STAT<FORCE> NEQ %O'177'	! Force bits correct?
		THEN BEGIN		
		     NUM_ERR = .NUM_ERR + 1;	! If not incr # errors and keep
		     LAST_ERR = .TEST;		!    track of force bits, test
		     LAST_FORCE = .MEM_STAT<FORCE>;! number, and MSR
		     LAST_STAT = .MEM_STAT;
		     END;
	    MR();				! Master Reset
	    END;

! Now see if a error occurred.  If there were 1 or less errors (a minority)
!  then no error occurred so handle looping in case we were.

	ERR_FLAG = 0;
	IF .NUM_ERR LSS 2
	    THEN BEGIN
		 INCR ERR FROM 1 TO 8 DO
		    BEGIN
		    IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
		    END;
		 END;

! An error occurred for sure - so report it (if it is a particular
!  error ie. unique to a particular flop).

	IF .NUM_ERR GTR 1
	    THEN BEGIN
		 MESSV[0] = .TEST_ADR[.LAST_FORCE];
		 INCR ERR FROM 0 TO 6 DO
		    BEGIN
		    IF (.LAST_FORCE XOR (1^.ERR)) EQL %O'177'
			THEN BEGIN
			     ERR_FLAG = 1;
			     NOERR_21 = 1;
			     ERRCAS(.ERR+1,1,.MEM_CORR,.LAST_STAT,12,MESSV);
			     END;
		    IF LOOP_CHK(.ERR+1) THEN LEAVE BLOCK1 WITH 1;
		    END;

! If we have an error but can't narrow it down to anything then report
!  it anyway.

		 IF .ERR_FLAG EQL 0 AND .LAST_FORCE NEQ %O'177'
		    THEN BEGIN
			 NOERR_21 = 1;
			 ERRCAS(8,1,.MEM_CORR,.LAST_STAT,12,MESSV);
			 END;
		 IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
		 END;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits 1111111, turn on ECC
!*	LA (ADDR),DM -1 Write 1's to mem loc \U0
!*	EM (ADDR)	Examine mem loc (Should cause single bit error)
!*	EI 100000	Read Mem Stat Reg (Check bits should be all 1's)
!*RESPONSE
!*	Check bit\S1 incorrect (MSR data follows)

!]ERROR 1
!] B1 E3 G3 A4 H4 I4 J4 B5 C5 E5 F5 G5 H5 D7  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] B1 E3 G3 B4 H4 I4 J4 K4 B5 C5 E5 F5 G5 H5 D7  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] B1 E3 G3 C4 H4 I4 J4 L4 B5 C5 E5 F5 G5 H5 D7  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] C1 E3 G3 D4 H4 I4 J4 M4 B5 C5 E5 F5 G5 H5 E7  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] C1 E3 G3 E4 H4 I4 J4 K4 B5 C5 E5 F5 G5 H5 E7  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] C1 E3 G3 F4 H4 I4 J4 L4 B5 C5 E5 F5 G5 H5 E7  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] C1 E3 G3 G4 H4 I4 J4 M4 B5 C5 E5 F5 G5 H5 E7  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] C1 E3 G3 A_H4 I4 K4 L4 M4 B5 C5 E5 F5 G5 H5 D7 E7  NTWK
!]NO ERROR 8
!]  NTWK

END;
GLOBAL ROUTINE TST22: NOVALUE =

!++   ----------------- FORCE CHECK BITS LOADING OF ----------------
! TEST DESCRIPTION:  This routine verifies that the force check bits
!	(held in a holding register on MMC3) are loaded properly and
!	at the right time.  If the logic controlling the register is
!	faulty then the register may be loaded whenever data is sent
!	to memory.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status force bits 007
!		   Write 052 to mem loc 125
!		   Read mem loc 125
!		   Read MSR - Check the force bits - Should be
!			equal to 007.  If they are equal to 025
!			or 052 then the force bits register is
!			being written to indiscriminately.
!
!		   Repeat for force bits 170
!
! POSSIBLE ERRORS:  'MMC3 STATUS LOAD EN' stuck high
!		    Force check bits register faulty
!
!--

BEGIN

LOCAL
	TEMP,
	ERR_NUM,
	MEM_STAT;

OWN
	MSR_CORR: VECTOR[2]		! Correct data
	    INITIAL (%O'420700000125',%O'437000000125'),
	FORCE_BITS: VECTOR[2]		! Force bits to be used
	    INITIAL (%O'700000000016',%O'700000000360');

LABEL
	BLOCK1;

IF RUN_TEST(22) THEN RETURN;		! Run this test? Return if no

NOERR_22 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 1 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();				! Master Reset
	    IO_DEPOSIT(MSR,.FORCE_BITS[.TEST]);	! Write force bits
	    DM(125,052);		! Write 052 to mem loc 125
	    EM(125);			! Read mem loc 125 - causes ECC err
	    MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
	    IF .MEM_STAT GEQ 0		! 'ERR HOLD' not set?  If not then
		THEN NOERR_22 = 1;	!   set error flag.

! Now see if the force bits gotten are the same as expected.  If not then
!   set error flag and print error message.

	    TEMP = .MSR_CORR[.TEST];
	    IF (.MEM_STAT<24,7> NEQ .TEMP<24,7>) AND (.NOERR_22 NEQ 1)
		THEN BEGIN
		     NOERR_22 = 1;
		     ERRCA(.TEST+1,.TEMP,.MEM_STAT,12);
		     END;
	    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	    0				! To eliminate INFO compiler message
	    END;
	END;

! If Tests 20 and 22 passed then force bits register on MMC3 is ok.

	IF (.NOERR_22 OR .NOERR_20) EQL 0
	    THEN NOERR(1);

! If Tests 20,21,22 passed then the ECC GEN/CHK logic on MMC4 is ok.

	IF (.NOERR_22 OR .NOERR_21 OR .NOERR_20) EQL 0
	    THEN NOERR(2);

! If Tests (20 and 21) or (21 and 22) passed then 'MMC5 ERR LOAD' And
!   gate is ok.

	IF (.NOERR_20 OR .NOERR_22) EQL 0 OR (.NOERR_21 OR .NOERR_22) EQL 0
	    THEN NOERR(3);

!*MESSAGE 1
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set Clear Err Hold ...
!*	DI 700000000034	  Set force bits '007'
!*	LA 125,DM 052	Write '052' to mem loc '125'
!*	EM 125		Examine memory loc '125' (Causes ECC error and loads
!*			  force bits into mem stat reg)
!*RESPONSE
!*	Force bits returned incorrect
!*	Memory Status Register correct/actual:

!]ERROR 1
!] B1 C1 E3 G3 H4 I4 E5 H5 B7 AB  NTWK
!]NO ERROR 1
!] G3  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set Clear Err Hold ...
!*	DI 700000000360	  Set force bits '170'
!*	LA 125,DM 052	Write '052' to mem loc '125'
!*	EM 125		Examine memory loc '125' (Causes ECC error and loads
!*			  force bits into mem stat reg)
!*RESPONSE
!*	Force bits returned incorrect
!*	Memory Status Register correct/actual:

!]ERROR 2
!] B1 C1 E3 G3 H4 I4 E5 H5 B7 AB  NTWK
!]NO ERROR 2
!] A4 B4 C4 D4 E4 F4 G4 H4 I4 K4 L4 M4  NTWK

!*MESSAGE 3
!*STIMULUS
!*RESPONSE
!]ERROR 3
!]  NTWK
!]NO ERROR 3
!] B5  NTWK

END;
GLOBAL ROUTINE TST23: NOVALUE =

!++   -------------- ERROR ADDRESS REGISTER LOADING OF -------------
! TEST DESCRIPTION:  This routine verifies that 'ERR HOLD' being set
!	does in fact prevent 'MMC5 ERR ADD LOAD' from being asserted
!	when data is read to or written from memory thereafter.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write 0's to mem loc 222
!		   Write status force bits 177
!		   Write 0's to mem loc 111
!		   Read mem loc 111 (Causes err and 'ERR HOLD' sets)
!		   Read mem loc 222
!		   Read MSR - Check the error  address - should be
!			equal to 111. If it is equal to 222 or MSR
!			then the Error Address Register  is  being
!			written to indiscriminately.
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	FORCE_BITS = %O'700000000376';	! Set force bits 177, clear 'ERR HOLD',
					!   'REF ERR','PARITY ERR'
LOCAL
	ERR_FLAG,			! Error flag
	MEM_STAT;			! Memory Status Register

LABEL
	BLOCK1;

IF RUN_TEST(23) THEN RETURN;		! Run this test? Return if no

NOERR_23 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	DM(222,0);			! Write 0's to mem loc 222
	IO_DEPOSIT(MSR,FORCE_BITS);	! Now change force bits
	DM(111,0);			! Write 0's to mem loc 111

! Now an EM 111 should cause 'ERR HOLD' to be set and error address to 
!   be set to 111.  The EM 222 afterwards should not affect any of the
!   data already in the MSR.

	EM(111);			! Read mem loc 111
	EM(222);			! Read mem loc 222
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR

	SELECTONE .MEM_STAT<0,22> OF
	    SET
	    [%O'111']:	BEGIN		! No error if address is 111
			ERR_FLAG = 0;
			END;
	    [%O'222']:	BEGIN		! EM 222 causes a new error address to
			TEST_ABORT = 1;	!   be loaded in spite of 'ERR HOLD'
			ERR_FLAG = 1;	!   being asserted.
			END;
	    [MSR]:	BEGIN		! EM 222 might have failed.  But read
			TEST_ABORT = 1;	!   MSR causes error address to be that
			ERR_FLAG = 2;	!   of MSR.  So either 'ERR HOLD' not
			END;		!   set or 'ERR ADDR LOAD' stuck high.
	    [OTHERWISE]:BEGIN		! Its garbage - some other error.
			ERR_FLAG = 3;
			END;
	    TES;

	INCR ERR FROM 1 TO 3 DO		! Now print out an error message for
	    BEGIN			!   the error if one was found.
	    IF .ERR EQL .ERR_FLAG
		THEN BEGIN
		     NOERR_23 = 1;
		     ERRCA(.ERR,%O'437700000111',.MEM_STAT,12);
		     END;
	    IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
	    END;
	0				! To eliminate INFO compiler message
	END;

	IF .NOERR_23 EQL 0		! If no errors in this test then
	    THEN NOERR(1);		!   'MMC5 ERR ADDR LOAD' is ok

!*MESSAGE 1
!*STIMULUS
!*	MR (Clear everything)
!*	Write 0's to mem loc '222'
!*	Write status to mem (Set force bits '177')
!*	Write 0's to mem loc '111'
!*	Examine mem loc '111' (Causes ECC error and adr latched in Err Adr Reg)
!*	Examine mem loc '222' - Should have no effect on error data
!*	Examine Mem Status Register
!*RESPONSE
!*	EM 222 wiped out Err Adr 111 but EI 100000 did not wipe out 222
!*Mem Status Register C/A:

!]ERROR 1
!] I5 I8 J8 K8  NTWK
!]NO ERROR 1
!] I5  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR (Clear everything)
!*	Write 0's to mem loc '222'
!*	Write status to mem (Set force bits '177')
!*	Write 0's to mem loc '111'
!*	Examine mem loc '111' (Causes ECC error and adr latched in Err Adr Reg)
!*	Examine mem loc '222' - Should have no effect on error data
!*	Examine Mem Status Register
!*RESPONSE
!*	EI 100000 wiped out Err Adr 111
!*Mem Status Register C/A:

!]ERROR 2
!] I5 I8 J8 K8  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR (Clear everything)
!*	Write 0's to mem loc '222'
!*	Write status to mem (Set force bits '177')
!*	Write 0's to mem loc '111'
!*	Examine mem loc '111' (Causes ECC error and adr latched in Err Adr Reg)
!*	Examine mem loc '222' - Should have no effect on error data
!*	Examine Mem Status Register
!*RESPONSE
!*	Err Adr 111 destroyed somehow
!*Mem Status Register C/A:

!]ERROR 3
!] D1 E1 F1 G1 H1 I1 J1 F3 N3 I5 F7 G7 H7 I7 J7 K7 L7 I8 J8 K8 AA  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST24: NOVALUE =

!++   ---------------------- BUS RESET -----------------------
! TEST DESCRIPTION:  This routine verifies that a Master Reset
!	causes bus reset to be seen on the MMC board resulting
!	in a reset of the MMC board.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Turn off parity error checking by 8080
!		   Write status to MMC board - Set force bits (0111111)
!		   Write 0's to mem location 17043
!		   Examine mem loc 17043 - Causes Err Hold
!					 	  Uncorr Err Hold
!		   Write status to MMC board - Set PE
!					       Turn off ECC
!		   Read/write to mem simultaneously - Hangs memory
!			and causes a mem refresh err within 26 usec.
!		   Do a Master Reset
!		   Read Mem Status Reg - Should show:
!				PE off
!				Ref Err off
!				ECC on
!				Err Hold off
!				Uncor Err Hold on
!				Err Addr not 17043 - Should be 100000
!
! POSSIBLE ERRORS:  'MMC5 ERR HOLD','MMC7 PARITY ERR','MMC9 REF ERR',
!			'MMC4 UNCOR ERR HOLD','MMC5 POWER FAILED',
!			'MMC3 ECC ON' flops are faulty
!		    Err Addr Register on MMC8 does not get loaded if
!			'MMC5 ERR HOLD' is not set
!
!--

BEGIN

LITERAL
	RESET = %O'700000000000',	! Clear 'ERR HOLD','REF ERR','PAR ERR'
	FORCE_SET = %O'700000000176',	! Set force bits 077, do reset (above)
	PAR_SET = %O'040000000000',	! Set parity error
	UNCOR = %O'000000000000';	! Mask for 'UNCOR ERR HOLD' bit of MSR

OWN
	MEM_STAT_V: BTTVECTOR[36],	! MSR bitvector
	TEMP_V: BTTVECTOR[36];		! MSR bitvector (with 'UNCOR ERR HOLD'
					!   bit reversed.
BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE'),
	MEM_STAT = MEM_STAT_V,
	TEMP = TEMP_V;

LABEL
	BLOCK1;

IF RUN_TEST(24) THEN RETURN;		! Run this test? Return if no

NOERR_24 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset

! Set up MSR with force bits, ECC off, parity error all set.
! Then write to mem and read back so that check bits, Error Address,
!   Err Hold and Uncorr Err Hold are set. Then hang MMC so that ?MRE
!   get asserted also.

	IO_DEPOSIT(MSR,FORCE_SET+ECC_OFF+PAR_SET);
	DM(17043,0);			! Write 0's to mem loc 17043
	EM(17043);			! Examine mem loc 17043 
	HANG_MEM();			! Set ?MRE
	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors

	TEMP = RD_101;			! Make sure that a ?MRE occurred
	IF (.TEMP AND 1) NEQ 1		! If not set error flag and print
	    THEN BEGIN			!   error message.
		 NOERR_24 = 1;
		 ERRS(1,1,TEMP);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

! Now do MR - this should reset most bits in the MSR (except 'UNCORR ERR HOLD')

	MR();				! Master Reset
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
	TEMP = .MEM_STAT XOR UNCOR;	! Reverse 'UNCORR ERR HOLD' bit

	INCR ERRR FROM 0 TO 3 DO	! Now make sure 'ERR HOLD','UNCORR ERR
	    BEGIN			!   HOLD','REF ERR','PAR ERR' are all
	    IF .TEMP_V[.ERRR] NEQ 0	!   zeros - if not set error flag and
		THEN BEGIN		!   print error message.
		     NOERR_24 = 1;
		     ERRS(.ERRR+2,.ERRR+2,MEM_STAT);
		     END;
	    IF LOOP_CHK(.ERRR+2) THEN LEAVE BLOCK1 WITH 1;
	    END;

	IF .MEM_STAT_V[4] NEQ 1		! Now make sure that ECC got turned
	    THEN BEGIN			!   back on - If not set error flag
		 NOERR_24 = 1;		!   and print error message.
		 ERRS(6,6,MEM_STAT);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;

	IF .MEM_STAT_V[12] NEQ 0	! Now make sure 'POWER FAIL' is still
	    THEN BEGIN			!   off - If not set error flag and
		 NOERR_24 = 1;		!   print error message.
		 ERRS(7,7,MEM_STAT);
		 END;
	IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;

	IF (.MEM_STAT AND %O'17777777') NEQ MSR	! Now make sure Error Address
	    THEN BEGIN				!   shows MSR (since 'ERR HOLD'
		 NOERR_24 = 1;			!   was reset) - if not set
		 ERRCA(8,MSR,.MEM_STAT,12);	!   error flag and print error
		 END;				!   message.
	IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;

	IO_DEPOSIT(MSR,RESET);		! We are all done so just reset MMC
	DM(0,0);			!   to clean things up.  Also do a 
	EM(0);				!   DM,EM to clear 'UNCORR ERR HOLD'
	0				! To eliminate INFO compiler message
	END;				!   if it was set.

!*MESSAGE 1
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		8080 Reg 101 should show 'REF ERR'
!*RESPONSE
!*	Mem ref err not set (8080 IO Reg 101: \U0 )

!]ERROR 1
!] C7 A9 B9 C9 AA BB BC  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
!*	MR		Should reset 'MMC5 ERR HOLD'
!*	EI 100000	MSR should show 'MMC5 ERR HOLD' not asserted
!*RESPONSE
!*	'MMC5 ERR HOLD' bit 00 set (Mem Stat Reg: \U0 )

!]ERROR 2
!] C5 C7 L7 AA CB AC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
!*	MR		Should not reset 'MMC4 UNCOR ERR HOLD'
!*	EI 100000	MSR should show 'MMC4 UNCOR ERR HOLD' still set
!*RESPONSE
!*	'MMC4 UNCOR ERR HOLD' bit 01 not set (Mem Stat Reg: \U0 )

!]ERROR 3
!] J4 E5 G5 H5 C7 CC  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
!*	MR		Should reset 'MMC9 REF ERR'
!*	EI 100000	MSR should show 'MMC9 REF ERR' not asserted
!*RESPONSE
!*	'MMC9 REF ERR' bit 02 set (Mem Stat Reg: \U0 )

!]ERROR 4
!] B9 C7 A9 AA CB BC  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
!*	MR		Should reset 'MMC7 PARITY ERR'
!*	EI 100000	MSR should show 'MMC7 PARITY ERR' not asserted
!*RESPONSE
!*	'MMC7 PARITY ERR' bit 03 set (Mem Stat Reg: \U0 )

!]ERROR 5
!] B7 C7 CB BC  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
!*	MR		Should assert 'MMC3 ECC ON'
!*	EI 100000	MSR should show 'MMC3 ECC ON' asserted
!*RESPONSE
!*	ECC still turned off (bit 04) (Mem Stat Reg: \U0 )

!]ERROR 6
!] E3 H3 D7 CB  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
!*	MR		Should not affect 'MMC5 POWER FAILED'
!*	EI 100000	MSR should show 'MMC5 POWER FAILED' not asserted
!*RESPONSE
!*	'MMC5 POWER FAILED' bit 12 set (Mem Stat Reg: \U0 )

!]ERROR 7
!] D1 A5 F7 AC  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*STIMULUS
!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
!*	DI 700000000176	  Set force bits to 077, clear Err Hold
!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
!*	EM 0		  it - Causes single bit ECC error
!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
!*	MR		Should reset 'MMC5 ERR HOLD'
!*	EI 100000	Err Addr should be 100000 since 'ERR HOLD' reset
!*RESPONSE
!*	Err Address bits 14..35 incorrect

!]ERROR 8
!] D1 E1 F1 G1 H1 I1 J1 F3 N3 C5 I5 F7 G7 H7 I7 J7 K7 L7 I8 J8 K8 AA  NTWK
!]NO ERROR 8
!]  NTWK

END;
GLOBAL ROUTINE TST25: NOVALUE =

!++   ------------------- MIXERS & SELECT LOGIC ------------------------
! TEST DESCRIPTION:  This  routine  verifies that the 4x2 mixers on MMC7
!	are working properly. Normally either the Memory Status Register
!	data (gathered together from  various parts of the board) or the
!	corrected/uncorrected data  from memory (resulting from a read).
!	the select input on each mixer consists of 'MMC7 READ STATUS'.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Do a Master Reset
!		   Write status - Set force bits '376'
!				  Turn off ECC
!		   Write '360077700000' to mem loc '77777'
!			(Complement of MSR when read)
!		   Examine mem loc '77777'
!		   Read Mem Status Reg
!		   Examine mem loc '77777'
!		   Verify that MSR = '417700077777'
!			  Mem data = '360077700000'
!
! POSSIBLE ERRORS:  Select inputs of 4 x 2 mixers on MMC7 are faulty.
!
!--

BEGIN

LOCAL
	MESSV,				! Error message output data
	ERR_FLAG,			! Error flag
	MEM_CONT,			! Memory contents
	MSR_CONT;			! MSR contents

LITERAL
	FORCE_SET = %O'700000000377',	! Set force bits to 177
	MSR_DATA = %O'417700077777',	! Correct data we should read from MSR
	MEM_DATA = %O'360077700000',	! Correct data we should read from mem
	MEM_LOC = %O'77777';		! Memory location to use for this test

STRUCTURE
	BIT4[I;N]=[N]			! Structure to look at data in 4 bit
	    (BIT4)			!   chunks (matching the mixers on
	    <32-I*4,4>;			!   MMC7).

OWN
	T_CONT_VECT: BIT4[9],
	T_DATA_VECT: BIT4[9],
	MIX_VECT: BIT4[9],
	MESS_STR: VECTOR[9]		! Error message output strings
	    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
		UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
		UPLIT(%ASCIZ '16-19'),UPLIT(%ASCIZ '20-23'),
		UPLIT(%ASCIZ '24-27'),UPLIT(%ASCIZ '28-31'),
		UPLIT(%ASCIZ '32-35'));

BIND
	T_CONT = T_CONT_VECT,
	T_DATA = T_DATA_VECT,
	MEM_STAT_REG = MIX_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(25) THEN RETURN;		! Run this test? Return if no

NOERR_25 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	IO_DEPOSIT(MSR,FORCE_SET);	! Write force bits to MSR
	MEM_DEPOSIT(MEM_LOC,MEM_DATA);	! Write data to mem
	MEM_EXAMINE(MEM_LOC);		! Read mem
	MSR_CONT = IO_EXAMINE(MSR);	! Read MSR
	MEM_CONT = MEM_EXAMINE(MEM_LOC);! Read mem

! Look for errors unique to a single MMC7 mixer. (4 bit chunks)
! Here look at the contents of MSR expected vs. actual.

	ERR_FLAG = 0;
	INCR BTT FROM 0 TO 8 DO
	    BEGIN
	    T_CONT = .MSR_CONT;		! Copy data expected and actual
	    T_DATA = MSR_DATA;		!   and mask out the particular
	    T_CONT_VECT[.BTT] = %O'777';!   4 bit section we want.
	    T_DATA_VECT[.BTT] = %O'777';
	    IF (.T_CONT EQL .T_DATA) AND (.MSR_CONT NEQ MSR_DATA)
		THEN BEGIN			! If error - set error flags,
		     MESSV = .MESS_STR[.BTT];	!   print error message, and
		     ERR_FLAG = 1;		!   abort future testing.
		     TEST_ABORT = 1;
		     NOERR_25 = 1;
		     ERRCAS(1+.BTT,1,MSR_DATA,.MSR_CONT,12,MESSV);
		     END;
	    IF LOOP_CHK(1+.BTT) THEN LEAVE BLOCK1 WITH 1;
	    END;

! If there is an error but not in only one 4-bit segment then report
!   it anyway.  Still work on MSR contents.

 	IF (.ERR_FLAG EQL 0) AND (.MSR_CONT NEQ MSR_DATA)
	    THEN BEGIN
		 NOERR_25 = 1;
		 ERRCAS(10,2,MSR_DATA,.MSR_CONT,12,MESSV);
		 END;
	IF LOOP_CHK(10) THEN LEAVE BLOCK1 WITH 1;

! Look for errors unique to a single MMC7 mixer. (4 bit chunks)
! Here look at the contents of memory expected vs. actual.

	ERR_FLAG = 0;
	INCR BTT FROM 0 TO 8 DO
	    BEGIN
	    T_CONT = .MEM_CONT;		! Copy data expected and actual
	    T_DATA = MEM_DATA;		!   and mask out the particular
	    T_CONT_VECT[.BTT] = %O'777';!   4 bit section we want.
	    T_DATA_VECT[.BTT] = %O'777';
	    IF (.T_CONT EQL .T_DATA) AND (.MEM_CONT NEQ MEM_DATA)
		THEN BEGIN			! If error - set error flags,
		     MESSV = .MESS_STR[.BTT];	!   print error message, and
		     ERR_FLAG = 1;		!   abort future testing.
		     TEST_ABORT = 1;
		     NOERR_25 = 1;
		     ERRCAS(11+.BTT,3,MEM_DATA,.MEM_CONT,12,MESSV);
		     END;
	    IF LOOP_CHK(11+.BTT) THEN LEAVE BLOCK1 WITH 1;
	    END;

! If there is an error but not in only one 4-bit segment then report
!   it anyway.  Still work on memory contents.

	IF (.ERR_FLAG EQL 0) AND (.MEM_CONT NEQ MEM_DATA)
	    THEN BEGIN
		 NOERR_25 = 1;
		 ERRCAS(20,4,MEM_DATA,.MEM_CONT,12,MESSV);
		 END;
	IF LOOP_CHK(20) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

! If Test 25 passed then all of the bus transceivers on MMC1 and all of the
!  mixers on MMC7 are ok.

IF .NOERR_25 EQL 0 THEN NOERR(1);

! If both Test 14 and Test 25 passed then 'MMC7 READ STATUS' logic is ok.

IF (.NOERR_25 OR .NOERR_14) EQL 0 THEN NOERR(2);

! If Tests 6,17,19,22,25 all passed then all of the mixers on MMC7 are ok.

IF (.NOERR_6 OR .NOERR_17 OR .NOERR_19 OR .NOERR_22 OR .NOERR_25) EQL 0 THEN NOERR(3);

!*MESSAGE 1
!*STIMULUS
!*	MR		Master Reset
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
!*	LA 77777	Write to mem loc 77777 - data is complement of what
!*	DM 360077700000	  Should be in the MSR when this location is read
!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
!*	EI 100000	Read MSR - should contain '417700077777'
!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
!*RESPONSE
!*	Bits \S0 of Memory Status Register was read improperly

!]ERROR 1
!] A1 C7 AC  NTWK
!]NO ERROR 1
!] A_J1 A7 C7 D7 E7 F7 G7 H7 I7 J7 K7  NTWK

!]ERROR 2
!] A_G4 H4 I4 B1 G6 H6 D7 AC  NTWK
!]NO ERROR 2
!] L7  NTWK

!]ERROR 3
!] A_G4 H4 I4 C1 G6 H6 E7 AC  NTWK
!]NO ERROR 3
!] C7 D7 E7 F7 G7 H7 I7 J7 K7  NTWK

!]ERROR 4
!] D1 F7 AC  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] E1 F1 G7 AC  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] F1 G1 H7 AC  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] G1 H1 I7 AC  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] H1 I1 J7 AC  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] I1 J1 K7 AC  NTWK
!]NO ERROR 9
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR		Master Reset
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
!*	LA 77777	Write to mem loc 77777 - data is complement of what
!*	DM 360077700000	  Should be in the MSR when this location is read
!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
!*	EI 100000	Read MSR - should contain '417700077777'
!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
!*RESPONSE
!*	Memory Status Register was read improperly

!]ERROR 10
!] A7 C7 D7 E7 F7 G7 H7 I7 J7 K7 L7 AA DB AC  NTWK
!]NO ERROR 10
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR		Master Reset
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
!*	LA 77777	Write to mem loc 77777 - data is complement of what
!*	DM 360077700000	  Should be in the MSR when this location is read
!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
!*	EI 100000	Read MSR - should contain '417700077777'
!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
!*RESPONSE
!*	Bits \S0 of mem loc 77777 was read improperly

!]ERROR 11
!] A1 A6 G6 H6 C7 H2 AC  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] B1 A6 B6 G6 H6 D7 H2 I2 AC  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] C1 B6 G6 H6 E7 I2 AC  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] D1 C6 G6 H6 F7 J2 AC  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] E1 F1 C6 D6 G6 H6 G7 J2 K2 AC  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] F1 G1 D6 G6 H6 H7 K2 AC  NTWK
!]NO ERROR 16
!]  NTWK

!]ERROR 17
!] G1 H1 D6 G6 H6 I7 L2 AC  NTWK
!]NO ERROR 17
!]  NTWK

!]ERROR 18
!] H1 I1 E6 F6 G6 H6 J7 L2 M2 AC  NTWK
!]NO ERROR 18
!]  NTWK

!]ERROR 19
!] I1 J1 F6 G6 H6 K7 M2 AC  NTWK
!]NO ERROR 19
!]   NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR		Master Reset
!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
!*	LA 77777	Write to mem loc 77777 - data is complement of what
!*	DM 360077700000	  Should be in the MSR when this location is read
!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
!*	EI 100000	Read MSR - should contain '417700077777'
!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
!*RESPONSE
!*	Mem loc 77777 was read improperly

!]ERROR 20
!] A_M2 A_H6 A7 C7 D7 E7 F7 G7 H7 I7 J7 K7 L7 AA DB AC  NTWK
!]NO ERROR 20
!]  NTWK

END;
GLOBAL ROUTINE TST26: NOVALUE =

!++   ------------ ECC: DETERMINATION OF 'MMC5 READ ERROR' -------
! TEST DESCRIPTION:  This routine verifies  some of the ECC logic.
!	In particular it verifies  that there are no stuck pins on
!	the OR  gate  that  determines 'MMC5 READ ERROR'.  It also
!	verfies the double bit  error detection (determined by the
!	parity generator on MMC5). All of the ECC errors generated
!	in this test should be single bit errors.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write status - Shut off ECC
!				- Set force bits (0000001)
!		   Write 0's to mem location 11111
!		   Examine mem loc 11111 - Sets 'ERR HOLD'
!					 - Does not set 'UNCORR ERR HOLD'
!		   Read Mem Status Reg - should show:
!				'ERR HOLD' on
!				'UNCOR ERR HOLD' off
!				'ERR ADDR' is 11111
!		   Repeat with force bits shifted left a bit at a time
!
! POSSIBLE ERRORS:  OR gate determining 'MMC5 READ ERROR' faulty
!		    Parity generator & AND gate determining
!			'MMC5 UNCORRECTABLE ERROR' is broken.
!
!--

BEGIN

MACRO
	ERR_HOLD = .MEM_STAT_VECT[0]%;	! Error hold bit

LITERAL
	ECC_OFF = %O'700000000001';	! Shut off ECC

LOCAL
	MEM_CORR;

OWN
	MEM_DATA: VECTOR[2],
	MEM_STAT_VECT: BTTVECTOR[36];

BIND
	MEM_DAT = MEM_DATA,
	MEM_STAT = MEM_STAT_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(26) THEN RETURN;		! Run this test? Return if no

NOERR_26 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 1 TO 7 DO		! For a force bit in each bit pos:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();				! Master Reset
	    IO_DEPOSIT(MSR,ECC_OFF+1^.TEST);	! Write force bit to MSR
	    DM(11111,0);			! Write 0's to mem loc 11111
	    EM(11111);				! Read it back (cause ECC error)

! Now check the results.

	    MEM_DATA[0] = MEM_STAT = IO_EXAMINE(MSR);
	    MEM_CORR = %O'400000011111' OR 1^(.TEST+24);
	    MEM_DATA[1] = 1^(.TEST-1);
	    IF ERR_HOLD NEQ 1		! If 'ERR HOLD' not asserted (didnt
		THEN BEGIN		!   cause ECC error??) - set error
		     ECC_SINGLE = 1;	!   flags and print error message.
		     NOERR_26 = 1;
		     ERRS(1,1,MEM_DAT);
		     END;
	    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	    IF (.MEM_STAT_VECT[1] NEQ 0) AND (ERR_HOLD EQL 1)
		THEN BEGIN		! 'UNCORR ERR HOLD' should not be
		     NOERR_26 = 1;	!   asserted (along with 'ERR HOLD'
		     ERRS(2,2,MEM_DAT);	! If it is - set flag, print message.
		     END;
	    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	    IF ((.MEM_STAT AND %O'17777777') NEQ %O'11111') AND (ERR_HOLD EQL 1)
		THEN BEGIN		! Err Addr should be 11111 - if not
		     NOERR_26 = 1;	!   set flag and print error message.
		     ERRCAS(3,3,.MEM_CORR,.MEM_STAT,12,MEM_DATA[1]);
		     END;
	    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	    0				! To eliminate INFO compiler message
	    END;
	    IF .NOERR_26 EQL 1 THEN RETURN;
	0				! To eliminate INFO compiler message
	END;

! If Test 26 passed then 'MMC5 READ ERROR' logic is ok.

	IF .NOERR_26 EQL 0 THEN NOERR(1);

! If Tests 17 and 26 passed then 'MMC5 ERR HOLD' logic is ok.

	IF (.NOERR_17 OR .NOERR_26) EQL 0 THEN NOERR(2);

!*MESSAGE 1
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause single bit ECC err & set 'MMC5 ERR HOLD'
!*RESPONSE
!*	'MMC5 ERR HOLD' bit 00 not set (Mem Stat Reg: \U0 )

!]ERROR 1
!] H4 C5 E5 H6 C7 AC  NTWK
!]NO ERROR 1
!] E5  NTWK

!*MESSAGE 2
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause single bit ECC err
!*RESPONSE
!*	Double bit error was detected - 'MMC4 UNCORR ERR HOLD'
!*	   bit 01 set (Mem Stat Reg: \U0 )

!]ERROR 2
!] A_G4 H4 J4 K4 L4 M4 G5 H5 G6 H6 C7 AC  NTWK
!]NO ERROR 2
!] C5  NTWK

!*MESSAGE 3
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause single bit err & load MMC8 Err Addr Reg
!*RESPONSE
!*	'MMC8 ERR ADDR' incorrect

!]ERROR 3
!] D1 E1 F1 G1 H1 I1 J1 I5 F7 G7 H7 I7 J7 K7 AC  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST27: NOVALUE =

!++   ------------ ECC:  DETECTION OF SINGLE BIT ERRORS ---------
! TEST DESCRIPTION:  This routine verifies some of the ECC logic.
!	In particular it tests the parity generator on MMC5 which
!	determines whether there is a single or double bit error.
!	All of the ECC errors  generated  in  this test should be
!	single bit errors.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write status - Shut off ECC
!				- Set force bits (0000111)
!		   Write 0's to mem location 11111
!		   Examine mem loc 11111 - Sets 'ERR HOLD'
!					 - Does not set 'UNCORR ERR HOLD'
!		   Read Mem Status Reg - should show:
!				ERR HOLD on
!				UNCOR ERR HOLD off
!				Err Addr is 11111
!		   Repeat with force bits shifted left a bit at a time
!		   Repeat with 0011111 .. and 1111111
!
! POSSIBLE ERRORS:  Parity generator, AND gates, & OR gate determining
!			'MMC5 READ ERROR' and 'MMC5 UNCORRECTIBLE ERR'
!
!--

BEGIN

MACRO
	ERR_HOLD = .MEM_STAT_VECT[0]%;	! Error hold bit

LITERAL
	ECC_OFF = %O'700000000001';	! Turn off ECC

LOCAL
	TEMP,
	ERR_FLAG,			! Error flag
	MEM_CORR;			! Correct memory data

OWN
	FORCE_BITS: VECTOR[9]		! Force bits to use for this test
	    INITIAL (%B'0000111',%B'0001110',%B'0011100',
		%B'0111000',%B'1110000',%B'0011111',%B'0111110',
		%B'1111100',%B'1111111'),
	MEM_DATA: VECTOR[2],
	MEM_STAT_VECT: BTTVECTOR[36];

BIND
	MEM_DAT = MEM_DATA,
	MEM_STAT = MEM_STAT_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(27) THEN RETURN;		! Run this test? Return if no

NOERR_27 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
ERR_FLAG = 0;

INCR FORCE FROM 0 TO 8 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    TEMP = ECC_OFF+.FORCE_BITS[.FORCE]^1;
	    IO_DEPOSIT(MSR,.TEMP);	! Write force bits
	    DM(11111,0);		! Write to mem loc 11111
	    EM(11111);			! Read it back - causes ECC error

! Now check the results.

	    MEM_DATA[0] = MEM_STAT = IO_EXAMINE(MSR);
	    MEM_CORR = %O'400000011111' OR .FORCE_BITS[.FORCE]^23;
	    MEM_DATA[1] = .FORCE_BITS[.FORCE];
	    IF ERR_HOLD NEQ 1		! If 'ERR HOLD' not asserted (didnt
		THEN BEGIN		!   cause ECC error??) - set error
		     ECC_SINGLE = 1;	!   flags and print error message.
		     NOERR_27 = 1;
		     ERRS(1,1,MEM_DAT);
		     END;
	    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	    IF ((.MEM_STAT_VECT[1] EQL 0) AND (ERR_HOLD EQL 1)) EQL 0
		THEN BEGIN		! 'UNCORR ERR HOLD' should not be
		     ERR_FLAG = 1;	!   asserted (along with 'ERR HOLD'
		     NOERR_27 = 1;	! If it is - set flag, print message.
		     ERRS(2,2,MEM_DAT);
		     END;
	    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	    IF ((.MEM_STAT AND %O'17777777') NEQ %O'11111') AND (ERR_HOLD EQL 1)
		THEN BEGIN		! Err Addr should be 11111 - if not
		     NOERR_27 = 1;	!   set flag and print error message.
		     ERRCAS(3,3,.MEM_CORR,.MEM_STAT,12,MEM_DATA[1]);
		     END;
	    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;
	    IF .NOERR_27 EQL 1 THEN RETURN;
	END;

! If Tests 17 and 27 both passed then 'MMC5 ERR HOLD' logic is ok.

	IF (.NOERR_17 OR .NOERR_27) EQL 0 THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause single bit ECC err & set 'MMC5 ERR HOLD'
!*RESPONSE
!*	'MMC5 ERR HOLD' bit 00 not set (Mem Stat Reg: \U0 )

!]ERROR 1
!] C5 E5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
!]NO ERROR 1
!] C5  NTWK

!*MESSAGE 2
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause single bit ECC err
!*RESPONSE
!*	Double bit error was detected - 'MMC4 UNCORR ERR HOLD'
!*	   Bit 01 set (Mem Stat Reg: \U0 )

!]ERROR 2
!] J4 G5 H5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause single bit err & load MMC8 Err Addr Reg
!*RESPONSE
!*	'MMC8 ERR ADDR' incorrect

!]ERROR 3
!] D1 E1 F1 G1 H1 I1 J1 I5 F7 G7 H7 I7 J7 K7 AC  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST28: NOVALUE =

!++   ------------ ECC:  DETECTION OF DOUBLE BIT ERRORS ---------
! TEST DESCRIPTION:  This routine verifies some of the ECC logic.
!	In particular it tests the parity generator on MMC5 which
!	determines whether there is a single or double bit error.
!	All of the ECC errors  generated  in  this test should be
!	double bit errors.
!
! TEST ASSUMPTIONS: None.
!
! TEST PROCEDURE:  Write status - Shut off ECC
!				- Set force bits (0000011)
!		   Write 0's to mem location 11111
!		   Examine mem loc 11111 - Sets 'ERR HOLD'
!					 - Sets 'UNCORR ERR HOLD'
!		   Read Mem Status Reg - should show:
!				Err Hold on
!				Uncor Err Hold on
!				Err Addr is 11111
!		   Repeat with force bits shifted left a bit at a time
!		   Repeat with 0001111 .. and 0111111 ..
!
! POSSIBLE ERRORS:  Parity generator, AND gates, & OR gate determining
!			'MMC5 READ ERROR' and 'MMC5 UNCORRECTIBLE ERR'
!
!--

BEGIN

MACRO
	ERR_HOLD = .MEM_STAT_VECT[0]%;	! Error hold bit

LITERAL
	RESET = %O'700000000000',	! Clear MSR error bits & turn on ECC
	ECC_ON = %O'700000000000';	! Clear MSR error bits & turn on ECC

LOCAL
	TEMP,
	ERR_FLAG,			! Error flag
	MEM_CORR;			! Correct data expected from memory

OWN
	FORCE_BITS: VECTOR[12]		! Force bits to use for this test
	    INITIAL (%B'0000011',%B'0000110',%B'0001100',
		%B'0011000',%B'0110000',%B'1100000',%B'0001111',
		%B'0011110',%B'0111100',%B'1111000',%B'0111111',
		%B'1111110'),
	MEM_DATA: VECTOR[2],
	MEM_STAT_VECT: BTTVECTOR[36];

BIND
	MEM_DAT = MEM_DATA,
	MEM_STAT = MEM_STAT_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(28) THEN RETURN;		! Run this test? Return if no

NOERR_28 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
ERR_FLAG = 0;

INCR FORCE FROM 0 TO 11 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    TEMP = ECC_ON+.FORCE_BITS[.FORCE]^1;
	    IO_DEPOSIT(MSR,.TEMP);	! Write force bits
	    DM(11111,0);		! Write to mem loc 11111
	    EM(11111);			! Read it back - causes ECC error

! Now check the results.

	    MEM_DATA[0] = MEM_STAT = IO_EXAMINE(MSR);
	    MEM_CORR = %O'400000011111' OR .FORCE_BITS[.FORCE]^23;
	    MEM_DATA[1] = .FORCE_BITS[.FORCE];
	    IF ERR_HOLD NEQ 1		! If 'ERR HOLD' not asserted (didnt
		THEN BEGIN		!   cause ECC error??) - set error
		     ECC_DOUBLE = 1;	!   flags and print error message.
		     NOERR_28 = 1;
		     ERRS(1,1,MEM_DAT);
		     END;
	    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	    IF ((.MEM_STAT_VECT[1] EQL 1) AND (ERR_HOLD EQL 1)) NEQ 1
		THEN BEGIN		! 'UNCORR ERR HOLD' should be
		     ERR_FLAG = 1;	!   asserted (along with 'ERR HOLD'
		     NOERR_28 = 1;	! If not - set flag, print message.
		     ERRS(2,2,MEM_DAT);
		     END;
	    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	    IF ((.MEM_STAT AND %O'17777777') NEQ %O'11111') AND (ERR_HOLD EQL 1)
		THEN BEGIN		! Err Addr should be 11111 - if not
		     NOERR_28 = 1;	!   set flag and print error message.
		     ERRCAS(3,3,.MEM_CORR,.MEM_STAT,12,MEM_DATA[1]);
		     END;
	    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;

	IO_DEPOSIT(MSR,RESET);		! Reset MMC particularly the
	DM(0,0);			!   'UNCORR ERR HOLD' which was
	EM(0);				!   set by the double bit error.
	END;

! If Tests 26 and 28 passed then 'MMC4 UNCOR ERR HOLD' logic is ok.

	IF (.NOERR_26 OR .NOERR_28) EQL 0 THEN NOERR(1);

! If Tests 27 and 28 passed then 'MMC4 UNCOR ERR HOLD' logic is ok.

	IF (.NOERR_27 OR .NOERR_28) EQL 0 THEN NOERR(1);

! If Tests 17 and 28 passed then 'MMC5 ERR HOLD' logic is ok.

	IF (.NOERR_17 OR .NOERR_28) EQL 0 THEN NOERR(2);

!*MESSAGE 1
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause double bit ECC err & set 'MMC5 ERR HOLD'
!*RESPONSE
!*	'MMC5 ERR HOLD' bit 00 not set (Mem Stat Reg: \U0 )

!]ERROR 1
!] C5 E5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
!]NO ERROR 1
!] J4  NTWK

!*MESSAGE 2
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause double bit ERR & set 'MMC4 UNCOR ERR HOLD'
!*RESPONSE
!*	'MMC4 UNCOR ERR HOLD' bit 01 not set (Mem Stat Reg: \U0 )

!]ERROR 2
!] J4 G5 H5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
!]NO ERROR 2
!] C5  NTWK

!*MESSAGE 3
!*STIMULUS
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 11111,DM 0	Write 0's to mem loc 11111
!*	EM 11111	Should cause double bit ERR & load MMC8 Err Addr Reg
!*RESPONSE
!*	'MMC8 ERR ADDR' incorrect

!]ERROR 3
!] D1 E1 F1 G1 H1 I1 J1 I5 F7 G7 H7 I7 J7 K7 AC  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST29: NOVALUE =

!++   ------------ ECC:  SETTING OF 'ERR HOLD' BIT -------------
! TEST DESCRIPTION:  This routine verifies the 'ERR HOLD' bit in
!	the Memory Status Register. It appears as a flop on MMC5
!	and signals  whether or not there is data latched in the
!	error holding register.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Do a Master Reset
!		   Read MSR - Verify 'ERR HOLD' off
!		   Write MSR force bits 0000111
!		   Write 0's to mem loc 22222
!		   Read MSR - Verify 'ERR HOLD' still off
!		   Examine mem loc 22222 (Should set 'ERR HOLD')
!		   Read MSR - Verify 'ERR HOLD' now on
!		   Read MSR - Verify 'ERR HOLD' now off
!
!		   Repeat with 1's to mem loc 22222
!
! POSSIBLE ERRORS:  'MMC5 ERR HOLD' flop faulty or logic just before
!			is faulty
!
!--

BEGIN

LITERAL
	FORCE_SET = %O'700000000016';	! Set force bits 007, clear errors

OWN
	MESS_STR: VECTOR[2]		! Error message strings
	    INITIAL(UPLIT(%ASCIZ '0'),UPLIT(%ASCIZ '-1')),
	MESSV: VECTOR[2];		! Error message output vector

BIND
	MEM_STAT = MESSV[0];

LABEL
	BLOCK1,
	BLOCK2;

IF RUN_TEST(29) THEN RETURN;		! Run this test? Return if no

NOERR_29 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

! First half of test - writing 0's to memory.

MESSV[2] = .MESS_STR[0];
DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure 'ERR HOLD'
	IF .MEM_STAT LSS 0		!   is not set - if it is set error
	    THEN BEGIN			!   flag and print error message.
		 NOERR_29 = 1;
		 ERRS(1,1,MESSV);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;

	IO_DEPOSIT(MSR,FORCE_SET);	! Now write force bits
	DM(22222,0);			! Write 0's to mem loc 22222
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure that
	IF .MEM_STAT LSS 0		!   'ERR HOLD' is still not set
	    THEN BEGIN			! If it is - set error flag and
		 NOERR_29 = 1;		!   print error message.
		 ERRS(2,2,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	EM(22222);			! Now read data back (cause ECC error)
	MEM_STAT = IO_EXAMINE(MSR);	! Check MSR (should show 'ERR HOLD' set)
	IF .MEM_STAT GEQ 0		! If 'ERR HOLD' not set - set error
	    THEN BEGIN			!   flag and print error message
		 NOERR_29 = 1;
		 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	MR();				! Master Reset
	MEM_STAT = IO_EXAMINE(MSR);	! Now see if 'ERR HOLD' clears after
	IF .MEM_STAT LSS 0		!   a MR - If it doesnt - set error
	    THEN BEGIN			!   flag and print error message.
		 NOERR_29 = 1;
		 ERRS(4,4,MESSV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

! If Tests 17 and 29 (so far) passed then 'MMC5 ERR HOLD' logic is ok.

	IF (.NOERR_17 OR .NOERR_29) EQL 0 THEN NOERR(1);

! If this test already failed there is no need to run the second half.

	IF .NOERR_29 EQL 1 THEN RETURN;

! Second half of test - writing 0's to memory.

MESSV[2] = .MESS_STR[1];
DO (0) WHILE
BLOCK2:	BEGIN
	MR();				! Master Reset
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure 'ERR HOLD'
	IF .MEM_STAT LSS 0		!   is not set - if it is set error
	    THEN BEGIN			!   flag and print error message.
		 NOERR_29 = 1;
		 ERRS(1,1,MESSV);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK2 WITH 1;

	IO_DEPOSIT(MSR,FORCE_SET);	! Now write force bits
	MEM_DEPOSIT(%O'22222',-1);	! Write 1's to mem loc 22222
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure that
	IF .MEM_STAT LSS 0		!   'ERR HOLD' is still not set
	    THEN BEGIN			! If it is - set error flag and
		 NOERR_29 = 1;		!   print error message.
		 ERRS(2,2,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK2 WITH 1;

	EM(22222);			! Now read data back (cause ECC error)
	MEM_STAT = IO_EXAMINE(MSR);	! Check MSR (should show 'ERR HOLD' set)
	IF .MEM_STAT GEQ 0		! If 'ERR HOLD' not set - set error
	    THEN BEGIN			!   flag and print error message
		 NOERR_29 = 1;
		 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK2 WITH 1;

	MR();				! Master Reset
	MEM_STAT = IO_EXAMINE(MSR);	! Now see if 'ERR HOLD' clears after
	IF .MEM_STAT LSS 0		!   a MR - If it doesnt - set error
	    THEN BEGIN			!   flag and print error message.
		 NOERR_29 = 1;
		 ERRS(4,4,MESSV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK2 WITH 1;
	0				! To eliminate INFO compiler message
	END;

! If Tests 17 and 29 passed then 'MMC5 ERR HOLD' logic is ok.

	IF (.NOERR_17 OR .NOERR_29) EQL 0 THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS:
!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should not be set)
!*RESPONSE:
!*	'MMC5 ERR HOLD' bit 00 set

!]ERROR 1
!] C5 E5 AC  NTWK
!]NO ERROR 1
!] C5  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
!*	EI 100000	Read Mem Status Register
!*	DI 700000000016	Write Mem Stat Reg:  Set force bits 0000111
!*	LA 22222,DM \S1	Write \S1 to mem loc 22222
!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should not be set)
!*RESPONSE:
!*	'MMC5 ERR HOLD' bit 00 set

!]ERROR 2
!] C5 E5 AC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS:
!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
!*	EI 100000	Read Mem Status Register
!*	DI 700000000016	Write Mem Stat Reg:  Set force bits 0000111
!*	LA 22222,DM \S1	Write \S1 to mem loc 22222
!*	EI 100000	Read Mem Status Register
!*	EM 22222	Examine mem loc 22222 (Should cause ECC error)
!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should be set)
!*RESPONSE:
!*	'MMC5 ERR HOLD' bit 00 not set

!]ERROR 3
!] C5 E5 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS:
!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
!*	EI 100000	Read Mem Status Register
!*	DI 700000000016	Write Mem Stat Reg:  Set force bits 0000111
!*	LA 22222,DM \S1	Write \S1 to mem loc 22222
!*	EI 100000	Read Mem Status Register
!*	EM 22222	Examine mem loc 22222 (Should cause ECC error)
!*	EI 100000	Read Mem Status Register
!*	MR		Clear 'MMC5 ERR HOLD'
!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should not be set)
!*RESPONSE:
!*	'MMC5 ERR HOLD' bit 00 set

!]ERROR 4
!] C5 E5 AC  NTWK
!]NO ERROR 4
!]  NTWK

END;
GLOBAL ROUTINE TST30: NOVALUE =

!++   ------------ ECC:  1 BIT ERROR NO CORRECTION (DATA 0'S) -------
! TEST DESCRIPTION:  This routine verifies some of the ECC logic.  In
!	particular it verifies that the decoders on MMC2 which decode
!	which bit to correct are ok.  This is accomplished by writing
!	patterns of force bits to cause a read error.   The  patterns
!	used do not match any of the patterns  which  would correct a
!	particular bit. Hence no actual error correction will be made.
!	All of the patterns indicate a single bit error.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (0000001)
!		   Write 0's to mem location 0
!		   Examine mem loc 0 - should show data is all 0's (no
!			correction).  If the data is not 0 then read
!			Mem Status Reg and print out relevant data.
!		   Repeat above steps for the remaining patterns which
!			indicate an 'Uncorrectable' single bit error
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
!
!--

BEGIN

LITERAL
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_STAT,			! Data read from MSR
	MEM_DATA;			! Data read from mem

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should not cause any error correction to be
!   done but still indicate a single bit error (an odd number of 1's).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
		     %O'777777007777',%O'777777770077',%O'777777777700'),
	FORCE_BITS: VECTOR[15]
	    INITIAL (%B'0000001',%B'0000010',%B'1000011',
		%B'0000100',%B'1000101',%B'1000110',%B'0000111',
		%B'0111000',%B'1111001',%B'1111010',%B'0111011',
		%B'1111100',%B'0111101',%B'0111110',%B'1111111'),
	DATA_VECT: VECTOR[2];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(30) THEN RETURN;		! Run this test? Return if no

NOERR_30 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset

	    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
	    TEST_DATA = EM(0);		!   data comes back after writing 0's

! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,0);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    MEM_DATA = MEM_EXAMINE(0);

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_30 = 1;
			 ERRCAS(.BTT+1,1,0,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_30 = 1;
		     ERRCAS(7,1,0,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM 0	Write 0's to mem loc 0
!*	EM 0		Examine mem loc (Should cause single bit error
!*			  - Data should not be corrected)
!*RESPONSE
!*	Data returned was corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST31: NOVALUE =

!++   ------------ ECC:  1 BIT ERROR CORRECTION (DATA 0'S) -----------
! TEST DESCRIPTION:  This routine verifies  some of the ECC logic.  In
!	particular it verifies that  the decoders on MMC2 which decode
!	which bit to correct are ok.  This is  accomplished by writing
!	patterns of force bits to cause a single bit correctable error.
!	The logic corrects  the  data  when it is read and the program
!	verifies that the correct bit was complemented.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (1001001)
!		   Write 0's to mem location 0
!		   Examine mem loc 0 - should show data is all 0's with a
!			single bit corrected to a 1. If the data is 0 then
!			read Mem Status Reg and print out relevant data.
!		   Repeat above steps for all other patterns which
!			correct bits 00-35
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty
!
!--

BEGIN

LITERAL
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_CORR,			! Corrected data as it should appear
	MEM_STAT,			! Data read from MSR
	MEM_DATA;			! Data read from mem

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should cause error correction to be done
!   (ie. a single bit error with a valid ECC code).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
		     %O'777777007777',%O'777777770077',%O'777777777700'),
	FORCE_BITS: VECTOR[36]
	    INITIAL (%B'1001001',%B'1001010',%B'0001011',
		%B'1001100',%B'0001101',%B'0001110',%B'1010001',
		%B'1010010',%B'0010011',%B'1010100',%B'0010101',
		%B'0010110',%B'0011001',%B'0011010',%B'1011011',
		%B'0011100',%B'1011101',%B'1011110',%B'1100001',
		%B'1100010',%B'0100011',%B'1100100',%B'0100101',
		%B'0100110',%B'0101001',%B'0101010',%B'1101011',
		%B'0101100',%B'1101101',%B'1101110',%B'0110001',
		%B'0110010',%B'1110011',%B'0110100',%B'1110101',
		%B'1110110'),
	DATA_VECT: VECTOR[3];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(31) THEN RETURN;		! Run this test? Return if no

NOERR_31 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
	    TEST_DATA = EM(0);		!   data comes back after writing 0's

! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,0);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    DATA_VECT[2] = .TEST;
	    MEM_DATA = MEM_EXAMINE(0);
	    MEM_CORR = 1^(35-.TEST) OR .TEST_DATA;

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .MEM_CORR)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_31 = 1;
			 ERRCAS(.BTT+1,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .MEM_CORR)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_31 = 1;
		     ERRCAS(7,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM 0	Write 0's to mem loc 0
!*	EM 0		Examine mem loc (Should cause single bit error
!*			  (Bit \D2) - and complement it
!*RESPONSE
!*	Data returned was not corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST32: NOVALUE =

!++   ------------ ECC:  1 BIT ERROR NO CORRECTION (DATA 1'S) -------
! TEST DESCRIPTION:  This routine verifies some of the ECC logic.  In
!	particular it verifies that the decoders on MMC2 which decode
!	which bit to correct are ok.  This is accomplished by writing
!	patterns of force bits to cause a  read error.   The patterns
!	used do not match any of  the  patterns which would correct a
!	particular bit. Hence no actual error correction will be made.
!	All of the patterns indicate a single bit error.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (0000001)
!		   Write 1's to mem location 0
!		   Examine mem loc 0 - should show data is
!			all 1's (no correction).  If the data is not 0
!			then read Mem Status Reg and print out relevant
!			data.
!		   Repeat above steps for the remaining patterns which
!			indicate an 'uncorrectable' single bit error.
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
!
!--

BEGIN

LITERAL
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_STAT,			! Data read from MSR
	MEM_DATA;			! Data read from mem

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should not cause any error correction to be
!   done but still indicate a single bit error (an odd number of 1's).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
		     %O'000000770000',%O'000000007700',%O'000000000077'),
	FORCE_BITS: VECTOR[15]
	    INITIAL (%B'0000001',%B'0000010',%B'1000011',
		%B'0000100',%B'1000101',%B'1000110',%B'0000111',
		%B'0111000',%B'1111001',%B'1111010',%B'0111011',
		%B'1111100',%B'0111101',%B'0111110',%B'1111111'),
	DATA_VECT: VECTOR[2];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(32) THEN RETURN;		! Run this test? Return if no

NOERR_32 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset

	    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
	    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's

! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,-1);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    MEM_DATA = MEM_EXAMINE(0);

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA OR .MASK[.BTT]) EQL -1) AND (.MEM_DATA NEQ .TEST_DATA)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_32 = 1;
			 ERRCAS(.BTT+1,1,-1,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_32 = 1;
		     ERRCAS(7,1,-1,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM 0	Write 1's to mem loc 0
!*	EM 0		Examine mem loc (Should cause single bit error
!*			  - But data should not be corrected)
!*RESPONSE
!*	Data returned was corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST33: NOVALUE =

!++   ------------ ECC:  1 BIT ERROR CORRECTION (DATA 1'S) -----------
! TEST DESCRIPTION:  This routine verifies  some of the ECC logic.  In
!	particular it verifies  that the decoders on MMC2 which decode
!	which bit to correct are ok.  This is  accomplished by writing
!	patterns of force bits to cause a single bit correctable error.
!	The logic corrects the data when it  is  read  and the program
!	verifies that the correct bit was complemented.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (1001001)
!		   Write 1's to mem location 0
!		   Examine mem loc 0 - should show data is all 1's with a
!			single bit corrected to a 0. If the data is 1 then
!			read Mem Status Reg and print out relevant data.
!		   Repeat above steps for all other patterns which
!			correct bits 00-35
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
!
!--

BEGIN

LITERAL
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_CORR,			! Corrected data as it should appear
	MEM_STAT,			! Data read from MSR
	MEM_DATA;			! Data read from mem

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should cause error correction to be done
!   (ie. a single bit error with a valid ECC code).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
		     %O'000000770000',%O'000000007700',%O'000000000077'),
	FORCE_BITS: VECTOR[36]
	    INITIAL (%B'1001001',%B'1001010',%B'0001011',
		%B'1001100',%B'0001101',%B'0001110',%B'1010001',
		%B'1010010',%B'0010011',%B'1010100',%B'0010101',
		%B'0010110',%B'0011001',%B'0011010',%B'1011011',
		%B'0011100',%B'1011101',%B'1011110',%B'1100001',
		%B'1100010',%B'0100011',%B'1100100',%B'0100101',
		%B'0100110',%B'0101001',%B'0101010',%B'1101011',
		%B'0101100',%B'1101101',%B'1101110',%B'0110001',
		%B'0110010',%B'1110011',%B'0110100',%B'1110101',
		%B'1110110'),
	DATA_VECT: VECTOR[3];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(33) THEN RETURN;		! Run this test? Return if no

NOERR_33 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
	    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's

! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,-1);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    DATA_VECT[2] = .TEST;
	    MEM_DATA = MEM_EXAMINE(0);
	    MEM_CORR = (.TEST_DATA XOR (1^(35-.TEST)));

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA OR .MASK[.BTT]) EQL 0) AND (.MEM_DATA EQL .MEM_CORR)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_33 = 1;
			 ERRCAS(.BTT+1,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .MEM_CORR)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_33 = 1;
		     ERRCAS(7,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM -1	Write 1's to mem loc 0
!*	EM 0		Examine mem loc (Should cause single bit error
!*			  (Bit \D2) - and complement it
!*RESPONSE
!*	Data returned was not corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST34: NOVALUE =

!++   -------- ECC:  2-BIT ERR NO CORR. (UNUSED CODES/DATA 0'S) ----
! TEST DESCRIPTION:  This routine verifies that no correction occurs
!	when a double bit error occurs.  The  test  writes  a set of
!	double bit error patterns to memory and the reads  them back
!	generating double bit ECC errors.   The  data read should be
!	unchanged.  The force bit patterns  used in this test do not
!	resemble any codes used by the ECC logic.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (1000001)
!		   Write 0's to mem location 0
!		   Examine mem loc 0 - Should show data is all 0's
!			(no correction).  If the data is not 0 then
!			read Mem Status Reg and print out relevant data.
!		   Repeat above steps for the remaining patterns
!			which do not resemble any actual ECC codes
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
!
!--

BEGIN

LITERAL
	RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_STAT,			! Data read from MSR
	MEM_DATA;			! Data read from mem

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should not cause any error correction to be
!   done but still indicate a double bit error (an even number of 1's).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
		     %O'777777007777',%O'777777770077',%O'777777777700'),
	FORCE_BITS: VECTOR[15]
	    INITIAL (%B'1000001',%B'1000010',%B'0000011',
		%B'1000100',%B'0000101',%B'0000110',%B'1000111',
		%B'1111000',%B'0111001',%B'0111010',%B'1111011',
		%B'0111100',%B'1111101',%B'1111110',%B'0111111'),
	DATA_VECT: VECTOR[2];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(34) THEN RETURN;		! Run this test? Return if no

NOERR_34 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
	    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 0's

! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,0);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    MEM_DATA = MEM_EXAMINE(0);

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_34 = 1;
			 ERRCAS(.BTT+1,1,0,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_34 = 1;
		     ERRCAS(7,1,0,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;

	IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
	DM(0,0);			!   everything before leaving 
	EM(0);				!   this test
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM 0	Write 0's to mem loc 0
!*	EM 0		Examine mem loc (Should cause double bit error
!*			  - Data should not be corrected)
!*RESPONSE
!*	Data returned was corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST35: NOVALUE =

!++   ------- ECC:  2-BIT ERR NO CORR. (SIMILAR CODES/DATA 0'S) ----
! TEST DESCRIPTION:  This routine verifies that no correction occurs
!	when a double  bit error occurs.   The test  writes a set of
!	double bit error  patterns to memory and the reads them back
!	generating double bit ECC errors.   The data  read should be
!	unchanged.  The force bit patterns used in this test are the
!	same  as the codes used by the ECC  logic  except  the force
!	parity bit (CP) is set to cause a double bit error.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (0001001)
!		   Write 0's to mem location 0
!		   Examine mem loc 0 - should show data is all 0's with
!			no bits corrected.  If the data is not 0 then
!			read Mem Status Reg and print out relevant data.
!		   Repeat above steps for the remaining patterns
!			which do resemble an actual ECC code.
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty
!
!--

BEGIN

LITERAL
	RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_CORR,			! Data which would come back if
					!   correction did occur (in error)
	MEM_STAT,			! Data read from MSR
	MEM_DATA;			! Data read from mem

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should not cause any error correction to be
!   done but still indicate a double bit error (an even number of 1's).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
		     %O'777777007777',%O'777777770077',%O'777777777700'),
	FORCE_BITS: VECTOR[36]
	    INITIAL (%B'0001001',%B'0001010',%B'1001011',
		%B'0001100',%B'1001101',%B'1001110',%B'0010001',
		%B'0010010',%B'1010011',%B'0010100',%B'1010101',
		%B'1010110',%B'1011001',%B'1011010',%B'0011011',
		%B'1011100',%B'0011101',%B'0011110',%B'0100001',
		%B'0100010',%B'1100011',%B'0100100',%B'1100101',
		%B'1100110',%B'1101001',%B'1101010',%B'0101011',
		%B'1101100',%B'0101101',%B'0101110',%B'1110001',
		%B'1110010',%B'0110011',%B'1110100',%B'0110101',
		%B'0110110'),
	DATA_VECT: VECTOR[2];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(35) THEN RETURN;		! Run this test? Return if no

NOERR_35 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
	    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 0's

! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,0);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    MEM_DATA = MEM_EXAMINE(0);

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_35 = 1;
			 ERRCAS(.BTT+1,1,0,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_35 = 1;
		     ERRCAS(7,1,0,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;

	IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
	DM(0,0);			!   everything before leaving 
	EM(0);				!   this test
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM 0	Write 0's to mem loc 0
!*	EM 0		Examine mem loc (Should cause double bit error
!*			  - Data should not be corrected)
!*RESPONSE
!*	Data returned was corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST36: NOVALUE =

!++   ------- ECC:  2-BIT ERR NO CORR. (UNUSED CODES/DATA 1'S) -----
! TEST DESCRIPTION:  This routine verifies that no correction occurs
!	when a double  bit error occurs.   The test  writes a set of
!	double bit error  patterns to memory and the reads them back
!	generating double bit ECC errors.   The data  read should be
!	unchanged.  The force bit patterns  used in this test do not
!	resemble any codes used by the ECC logic.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (1000001)
!		   Write 0's to mem location 0
!		   Examine mem loc 0 - should show data is all 0's (no
!			correction).  If the data is not 0 then read Mem
!			Status Reg and print out relevant data.
!		   Repeat above steps for the remaining patterns
!			which do not resemble any actual ECC codes.
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
!
!--

BEGIN

LITERAL
	RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_STAT,			! Data read from MSR
	MEM_DATA,			! Data read from mem
	TEMP;

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should not cause any error correction to be
!   done but still indicate a double bit error (an even number of 1's).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
		     %O'000000770000',%O'000000007700',%O'000000000077'),
	FORCE_BITS: VECTOR[15]
	    INITIAL (%B'1000001',%B'1000010',%B'0000011',
		%B'1000100',%B'0000101',%B'0000110',%B'1000111',
		%B'1111000',%B'0111001',%B'0111010',%B'1111011',
		%B'0111100',%B'1111101',%B'1111110',%B'0111111'),
	DATA_VECT: VECTOR[2];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(36) THEN RETURN;		! Run this test? Return if no

NOERR_36 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
	    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's

! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,-1);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    MEM_DATA = MEM_EXAMINE(0);

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA OR .MASK[.BTT]) EQL -1) AND (.MEM_DATA NEQ .TEST_DATA)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_36 = 1;
			 ERRCAS(.BTT+1,1,-1,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_36 = 1;
		     ERRCAS(7,1,-1,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;
	IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
	DM(0,0);			!   everything before leaving 
	EM(0);				!   this test
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM -1	Write 1's to mem loc 0
!*	EM 0		Examine mem loc (Should cause double bit error
!*			  - Data should not be corrected)
!*RESPONSE
!*	Data returned was corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!]  NTWK

!]ERROR 2
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST37: NOVALUE =

!++   ----- ECC:  2-BIT ERR NO CORR. (SIMILAR CODES/DATA 1'S) ------
! TEST DESCRIPTION:  This routine verifies that no correction occurs
!	when a double  bit error occurs.   The test  writes a set of
!	double bit error  patterns to memory and the reads them back
!	generating double bit ECC errors.   The data  read should be
!	unchanged.  The force bit patterns used in this test are the
!	same  as the codes used by the ECC  logic  except  the force
!	parity bit (CP) is set to cause a double bit error.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   Write status to MMC board - Set force bits (1001001)
!		   Write 1's to mem location 0
!		   Examine mem loc 0 - should show data
!			is all 1's with no bits corrected.  If the
!			data is not 1 then read Mem Status Reg and
!			print out relevant data.
!		   Repeat above steps for the remaining patterns
!			which do resemble an actual ECC code.
!
! POSSIBLE ERRORS:  Logic on MMC2 is faulty
!
!--

BEGIN

LITERAL
	RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
	ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...

LOCAL
	TEST_DATA,			! Data writen to mem
	ERR_FLAG,			! Error flag
	MEM_STAT,			! Data read from MSR
	MEM_DATA;			! Data read from mem

! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
!   sections match the bits as they are segregated in the ECC section of
!   the MMC board.
! FORCE_BITS - patterns which should not cause any error correction to be
!   done but still indicate a double bit error (an even number of 1's).

OWN
	MASK: VECTOR[6]
	    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
		     %O'000000770000',%O'000000007700',%O'000000000077'),
	FORCE_BITS: VECTOR[36]
	    INITIAL (%B'0001001',%B'0001010',%B'1001011',
		%B'0001100',%B'1001101',%B'1001110',%B'0010001',
		%B'0010010',%B'1010011',%B'0010100',%B'1010101',
		%B'1010110',%B'1011001',%B'1011010',%B'0011011',
		%B'1011100',%B'0011101',%B'0011110',%B'0100001',
		%B'0100010',%B'1100011',%B'0100100',%B'1100101',
		%B'1100110',%B'1101001',%B'1101010',%B'0101011',
		%B'1101100',%B'0101101',%B'0101110',%B'1110001',
		%B'1110010',%B'0110011',%B'1110100',%B'0110101',
		%B'0110110'),
	DATA_VECT: VECTOR[3];

BIND
	IO_DATA = DATA_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(37) THEN RETURN;		! Run this test? Return if no

NOERR_37 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
	BEGIN
	DO (0) WHILE
BLOCK1:	    BEGIN
	    MR();			! Master Reset
	    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
	    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's

! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.

	    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
	    MEM_DEPOSIT(0,-1);
	    DATA_VECT[1] = .FORCE_BITS[.TEST];
	    DATA_VECT[2] = .TEST;
	    MEM_DATA = MEM_EXAMINE(0);

! Now check to see if there is any error and which section of bits it is in.
! For any errors set error flags and print error message.

	    ERR_FLAG = 0;
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		IF ((.MEM_DATA OR .MASK[.BTT]) EQL -1) AND (.MEM_DATA NEQ .TEST_DATA)
		    THEN BEGIN
			 ERR_FLAG = 1;
			 IO_DATA = IO_EXAMINE(MSR);
			 NOERR_37 = 1;
			 ERRCAS(.BTT+1,1,-1,.MEM_DATA,12,DATA_VECT);
			 END;
		IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
		END;

! If the error is not in a single section of bits - write out error message.

	    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
		THEN BEGIN
		     ERR_FLAG = 1;
		     IO_DATA = IO_EXAMINE(MSR);
		     NOERR_37 = 1;
		     ERRCAS(7,1,-1,.MEM_DATA,12,DATA_VECT);
		     END;
	    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;
	    0				! To eliminate INFO compiler message
	    END;

	IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
	DM(0,0);			!   everything before leaving 
	EM(0);				!   this test
	END;

! Now if there have not been any errors in the ECC tests then there
!   are a lot of networks to eliminate via a call to NOERR.

	ERR_FLAG = .NOERR_31 OR .NOERR_32 OR .NOERR_33 OR .NOERR_34;
	IF (.ERR_FLAG OR .NOERR_35 OR .NOERR_36 OR .NOERR_37) EQL 0
	    THEN NOERR(1);

!*MESSAGE 1
!*STIMULUS
!*	MR		Clear everything
!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
!*	DI (STATUS)	  Set force bits \O1, turn on ECC
!*	LA 0,DM -1	Write 1's to mem loc 0
!*	EM 0		Examine mem loc (Should cause double bit error
!*			  - Data should not be corrected)
!*RESPONSE
!*	Data returned was corrected (Mem Stat Reg: \U0 )

!]ERROR 1
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 1
!] F5 G5 H5 G6 H6 A7 L7  NTWK

!]ERROR 2
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 2
!]  NTWK

!]ERROR 3
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 3
!]  NTWK

!]ERROR 4
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 4
!]  NTWK

!]ERROR 5
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST38: NOVALUE =

!++   -------------- 8646'S, MOS DRIVERS, DATA PATH -----------
! TEST DESCRIPTION:  This test performs a basic functional test
!	of the MMC board.  Data is written to  memory  and read
!	back and verified.  This test is  intended to check out
!	the 8646's, the hex MOS  drivers,  and  the  data  path 
!	within the MMC board.  This  test  is  identical to the
!	first part of Test 6 except this time ECC is enabled.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write a test pattern to mem loc 0
!		   Read it back and verify it
!		   Repeat with several test patterns
!
! POSSIBLE ERRORS:
!
!--

BEGIN

OWN

! All the message strings

	MESS_STR: VECTOR[28]
	    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-05'),
		    UPLIT(%ASCIZ '06-07'),UPLIT(%ASCIZ '08-11'),
		    UPLIT(%ASCIZ '12-15'),UPLIT(%ASCIZ '16-17'),
		    UPLIT(%ASCIZ '18-21'),UPLIT(%ASCIZ '22-23'),
		    UPLIT(%ASCIZ '24-25'),UPLIT(%ASCIZ '26-29'),
		    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
		    UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
		    UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
		    UPLIT(%ASCIZ '16-17'),UPLIT(%ASCIZ '18-21'),
		    UPLIT(%ASCIZ '22-25'),UPLIT(%ASCIZ '26-29'),
		    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
		    UPLIT(%ASCIZ '00-05'),UPLIT(%ASCIZ '06-11'),
		    UPLIT(%ASCIZ '12-17'),UPLIT(%ASCIZ '18-23'),
		    UPLIT(%ASCIZ '24-29'),UPLIT(%ASCIZ '30-35')),

! Data patterns

	PATTERN: VECTOR[4]
	    INITIAL (%O'111111111111',%O'666666666666',
		     %O'0',%O'777777777777'),

! For the special data structure definition

	STRUCT: VECTOR[24]
	    INITIAL (32,4,30,2,28,2,24,4,20,4,18,2,14,4,
		     12,2,10,2,6,4,2,4,0,2);

LITERAL
	NUM_PATTERN = 4;

STRUCTURE
	BIT_VECT[I;N] = [N]		! This structure duplicates the bit
	    (BIT_VECT)			!   partitions on the data path
	    <.STRUCT[I*2],.STRUCT[I*2+1]>,
	BIT_MOS[I;N] = [N]		! This structure maps the MOS drivers
	    (BIT_MOS)			!   into the data path
	    <30-I*6,6>;

OWN
	MESSV: VECTOR[2],		! Error message output vector
	TEST_8646_VECT: BIT8646[1],	! Data path mapped onto transceivers
	TEST_MOS_VECT: BIT_MOS[1],	! Miscellaneous structures
	TEST_TEMP_VECT: BIT_VECT[1],	!    ...
	TEST_DATA_VECT: BIT_VECT[1],
	TEST_PATT_VECT: BIT_VECT[1];

BIND
	TEST_DATA = TEST_DATA_VECT,
	TEST_PATT = TEST_PATT_VECT,
	TEST_MOS = TEST_MOS_VECT,
	TEST_8646 = TEST_8646_VECT,
	TEST_TEMP = TEST_TEMP_VECT;

LOCAL
	ERR,
	ERR_FLAG,
	TEMP;

LABEL
	BLOCK1;

IF RUN_TEST(38) THEN RETURN;		! Run this test? Return if no

NOERR_38 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

INCR DATA_LOOP FROM 0 TO NUM_PATTERN-1 DO
	BEGIN				! Now start the test:
	TEST_PATT=.PATTERN[.DATA_LOOP];	!   Get the data pattern to use
	MESSV = .TEST_PATT;		!   Save it for error output
	MR();				!   Do a Master Reset

	DO (0) WHILE
BLOCK1:	    BEGIN
	    TEST_DATA = ERR_FLAG = 0;
	    MEM_DEPOSIT(0,.TEST_PATT);
	    TEST_DATA = EM(0);

! Now check to see if there are any single bit errors.

	    INCR BTT FROM 0 TO 35 DO
		BEGIN
		MESSV[1] = .BTT;
		TEMP = .TEST_DATA XOR (1 ^ (35-.BTT));
		IF .TEMP EQL .TEST_PATT
		    THEN BEGIN
			 ERRCAS(.BTT+1,1,.TEST_PATT,.TEST_DATA,12,MESSV);
			 ERR_FLAG = 1;
			 END;
		IF LOOP_CHK(.BTT + 1) THEN LEAVE BLOCK1 WITH 1;
		END;

! Now check to see if there are any multiple bit errors which occurred in
!   only one logical group of bits (such as in the first transceiver...).
!   These particular groups are the subsections of the  transceivers, MOS
!   drivers and mixers on MMC7 which are common to all three. Hence these
!   are the next stage up from a single bit error.

	    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT);
	    INCR BTT FROM 0 TO 11 DO
		BEGIN
		TEST_TEMP = 0;
		TEST_TEMP_VECT[.BTT] = %O'777777';
		TEMP = .TEST_DATA OR .TEST_TEMP;
		IF .TEMP EQL (.TEST_PATT OR .TEST_TEMP) AND .ERR
		    THEN BEGIN
			 ERR_FLAG = 1;
			 MESSV[1] = .MESS_STR[.BTT];
			 ERRCAS(.BTT+37,2,.TEST_PATT,.TEST_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 37) THEN LEAVE BLOCK1 WITH 1;
		END;

! Now check to see if there are any errors which occurred exclusively in
!   the 8646 transceivers.

	    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT);
	    INCR BTT FROM 0 TO 9 DO
		BEGIN
		TEST_8646 = 0;
		TEST_8646_VECT[.BTT] = %O'777777';
		TEMP = .TEST_DATA OR .TEST_8646;
		IF .TEMP EQL (.TEST_PATT OR .TEST_8646) AND .ERR
		    THEN BEGIN
			 ERR_FLAG = 1;
			 MESSV[1] = .MESS_STR[.BTT+12];
			 ERRCAS(.BTT+49,2,.TEST_PATT,.TEST_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 49) THEN LEAVE BLOCK1 WITH 1;
		END;

! Now check to see if there are any errors which occurred exclusively in
!   the MOS drivers on MMC6.

	    ERR =(.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT);
	    INCR BTT FROM 0 TO 5 DO
		BEGIN
		TEST_MOS = 0;
		TEST_MOS_VECT[.BTT] = %O'777777';
		TEMP = .TEST_DATA OR .TEST_MOS;
		IF .TEMP EQL (.TEST_PATT OR .TEST_MOS) AND .ERR
		    THEN BEGIN
			 ERR_FLAG = 1;
			 MESSV[1] = .MESS_STR[.BTT+22];
			 ERRCAS(.BTT+59,2,.TEST_PATT,.TEST_DATA,12,MESSV);
			 END;
		IF LOOP_CHK(.BTT + 59) THEN LEAVE BLOCK1 WITH 1;
		END;

! So if no error messages have been printed out yet and the data came
!   back incorrectly, then the error must be a strange  multiple  bit
!   error.  So we will report the whole thing.

	    IF (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .TEST_PATT)
		THEN BEGIN
		     ERR_FLAG = 1;
		     ERRCAS(65,3,.TEST_PATT,.TEST_DATA,12,MESSV);
		     END;
	    IF LOOP_CHK(65) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG NEQ 0 THEN NOERR_38 = 1;
	    0				! To eliminate INFO compiler message
	    END;
	END;

ERR = .NOERR_30 OR .NOERR_31 OR .NOERR_32 OR .NOERR_33 OR .NOERR_34;
ERR = .ERR OR .NOERR_35 OR .NOERR_36 OR .NOERR_37 OR .NOERR_38;

! If Tests 30,31,32,33,34,35,36,37,38 all passed then the ECC code decoders
!   'MMC2 ECC CODE 10'..'MMC2 ECC CODE 7X' are ok.

IF .ERR EQL 0 THEN NOERR(1);

! If Tests 30,31,32,33,34,35,36,37,38 all passed then the XOR gates on
!   MMC2 which determine 'MMC2 CORRECT DATA xx' are ok.

IF (.ERR OR .NOERR_6) EQL 0 THEN NOERR(2);

! If Test 38 passed then the hex MOS drivers on MMC6 are ok.

IF .NOERR_38 EQL 0 THEN NOERR(3);

! If Tests 17,19,22,25,38 all passed then the mixers on MMC7 which
!   determine 'MMC7 XMITINF xx' are ok.

IF (.NOERR_38 OR .NOERR_17 OR .NOERR_19 OR .NOERR_22 OR .NOERR_25) EQL 0
	THEN NOERR(4);

!*MESSAGE 1
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	Bit \D1 of data returned is incorrect

!]ERROR 1
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 1
!] A2 B2 C2 D2 E2 F2 G2  NTWK

!]ERROR 2
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 2
!] H2 I2 J2 K2 L2 M2  NTWK

!]ERROR 3
!] A1 A2 H2  A6 C7 B9  NTWK
!]NO ERROR 3
!] A6 B6 C6 D6 E6 F6  NTWK

!]ERROR 4
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 4
!] C7 D7 E7 F7 G7 H7 I7 J7 K7  NTWK

!]ERROR 5
!] B1 A2 H2 A6 D7  NTWK
!]NO ERROR 5
!]  NTWK

!]ERROR 6
!] B1 A2 H2 A6 D7  NTWK
!]NO ERROR 6
!]  NTWK

!]ERROR 7
!] B1 B2 I2 B6 D7  NTWK
!]NO ERROR 7
!]  NTWK

!]ERROR 8
!] B1 B2 I2 B6 D7  NTWK
!]NO ERROR 8
!]  NTWK

!]ERROR 9
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 9
!]  NTWK

!]ERROR 10
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 10
!]  NTWK

!]ERROR 11
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 11
!]  NTWK

!]ERROR 12
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 12
!]  NTWK

!]ERROR 13
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 13
!]  NTWK

!]ERROR 14
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 14
!]  NTWK

!]ERROR 15
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 15
!]  NTWK

!]ERROR 16
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 16
!]  NTWK

!]ERROR 17
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 17
!]  NTWK

!]ERROR 18
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 18
!]  NTWK

!]ERROR 19
!] F1 D2 K2 D6 G7  NTWK
!]NO ERROR 19
!]  NTWK

!]ERROR 20
!] F1 D2 K2 D6 G7  NTWK
!]NO ERROR 20
!]  NTWK

!]ERROR 21
!] F1 D2 K2 D6 H7  NTWK
!]NO ERROR 21
!]  NTWK

!]ERROR 22
!] F1 D2 K2 D6 H7  NTWK
!]NO ERROR 22
!]  NTWK

!]ERROR 23
!] G1 D2 K2 D6 H7  NTWK
!]NO ERROR 23
!]  NTWK

!]ERROR 24
!] G1 D2 K2 D6 H7  NTWK
!]NO ERROR 24
!]  NTWK

!]ERROR 25
!] G1 E2 L2 E6 I7  NTWK
!]NO ERROR 25
!]  NTWK

!]ERROR 26
!] G1 E2 L2 E6 I7  NTWK
!]NO ERROR 26
!]  NTWK

!]ERROR 27
!] H1 E2 L2 E6 I7  NTWK
!]NO ERROR 27
!]  NTWK

!]ERROR 28
!] H1 E2 L2 E6 I7  NTWK
!]NO ERROR 28
!]  NTWK

!]ERROR 29
!] H1 E2 L2 E6 J7  NTWK
!]NO ERROR 29
!]  NTWK

!]ERROR 30
!] H1 E2 L2 E6 J7  NTWK
!]NO ERROR 30
!]  NTWK

!]ERROR 31
!] I1 F2 M2 F6 J7  NTWK
!]NO ERROR 31
!]  NTWK

!]ERROR 32
!] I1 F2 M2 F6 J7  NTWK
!]NO ERROR 32
!]  NTWK

!]ERROR 33
!] I1 F2 M2 F6 K7  NTWK
!]NO ERROR 33
!]  NTWK

!]ERROR 34
!] I1 F2 M2 F6 K7  NTWK
!]NO ERROR 34
!]  NTWK

!]ERROR 35
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 35
!]  NTWK

!]ERROR 36
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 36
!]  NTWK

!*MESSAGE 2
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	Bits \S1 of data returned is incorrect

!]ERROR 37
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 37
!]  NTWK

!]ERROR 38
!] B1 A2 H2 A6 D7  NTWK
!]NO ERROR 38
!]  NTWK

!]ERROR 39
!] B1 B2 I2 B6 D7  NTWK
!]NO ERROR 39
!]  NTWK

!]ERROR 40
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 40
!]  NTWK

!]ERROR 41
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 41
!]  NTWK

!]ERROR 42
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 42
!]  NTWK

!]ERROR 43
!] F1 D2 K2 D6 G7 H7  NTWK
!]NO ERROR 43
!]  NTWK

!]ERROR 44
!] G1 D2 K2 D6 H7  NTWK
!]NO ERROR 44
!]  NTWK

!]ERROR 45
!] G1 E2 L2 E6 I7  NTWK
!]NO ERROR 45
!]  NTWK

!]ERROR 46
!] H1 E2 L2 E6 I7 J7  NTWK
!]NO ERROR 46
!]  NTWK

!]ERROR 47
!] I1 F2 M2 F6 J7 K7  NTWK
!]NO ERROR 47
!]  NTWK

!]ERROR 48
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 48
!]  NTWK

!]ERROR 49
!] A1 A2 H2 A6 C7  NTWK
!]NO ERROR 49
!]  NTWK

!]ERROR 50
!] B1 A2 B2 H2 I2 A6 B6 D7  NTWK
!]NO ERROR 50
!]  NTWK

!]ERROR 51
!] C1 B2 I2 B6 E7  NTWK
!]NO ERROR 51
!]  NTWK

!]ERROR 52
!] D1 C2 J2 C6 F7  NTWK
!]NO ERROR 52
!]  NTWK

!]ERROR 53
!] E1 C2 J2 C6 G7  NTWK
!]NO ERROR 53
!]  NTWK

!]ERROR 54
!] F1 D2 K2 D6 G7 H7  NTWK
!]NO ERROR 54
!]  NTWK

!]ERROR 55
!] G1 D2 E2 K2 L2 D6 E6 H7 I7  NTWK
!]NO ERROR 55
!]  NTWK

!]ERROR 56
!] H1 E2 L2 E6 I7 J7  NTWK
!]NO ERROR 56
!]  NTWK

!]ERROR 57
!] I1 F2 M2 F6 J7 K7  NTWK
!]NO ERROR 57
!]  NTWK

!]ERROR 58
!] J1 F2 M2 F6 K7  NTWK
!]NO ERROR 58
!]  NTWK

!]ERROR 59
!] A1 B1 A2 H2 A6 C7 D7  NTWK
!]NO ERROR 59
!]  NTWK

!]ERROR 60
!] B1 C1 B2 I2 B6 D7 E7  NTWK
!]NO ERROR 60
!]  NTWK

!]ERROR 61
!] D1 E1 C2 J2 C6 F7 G7  NTWK
!]NO ERROR 61
!]  NTWK

!]ERROR 62
!] F1 G1 D2 K2 D6 G7 H7  NTWK
!]NO ERROR 62
!]  NTWK

!]ERROR 63
!] G1 H1 E2 L2 E6 I7 J7  NTWK
!]NO ERROR 63
!]  NTWK

!]ERROR 64
!] I1 J1 F2 M2 F6 J7 K7  NTWK
!]NO ERROR 64
!]  NTWK

!*MESSAGE 3
!*STIMULUS:
!*	LA 0	Write to mem loc 0
!*	DM \U0
!*	EM 0	Examine mem loc 0
!*RESPONSE:
!*	Bits 00-35 of data returned is incorrect

!]ERROR 65
!] A_J1 A_D3 I_O3 C_K7 B_K8 AA BA AB BB DB AC BC  NTWK
!]NO ERROR 65
!]  NTWK

END;
GLOBAL ROUTINE TST39: NOVALUE =

!++   ------------ ?MRE CAUSES 'MMC5 ERR HOLD / ERR ADD LOAD' ---------
! TEST DESCRIPTION:   This  routine  verifies  that when memory refresh
!	error occurs 'MMC5 ERR HOLD' is asserted thus causing 'MMC5 ERR
!	ADD LOAD' to assert and thereby load the 'ERR ADDR' Register on
!	MMC8 with the address in the MMC board whatever it might be.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Write 0's to mem loc 77777 - Just to quickly load
!			the 8080 address registers
!		   Write control bits to Reg 114,115,210 - To hang
!			memory and cause a ?MRE
!		   Examine Mem Status Register - Verify that 'ERR HOLD'
!			is set and the error address is '77777'
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LOCAL
	NUM_ERR,
	ERR_FLAG;

OWN
	REG101,
	MEM_STAT_VECT: BTTVECTOR[36];

BIND
	MEM_STAT_REG = MEM_STAT_VECT,
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LABEL
	BLOCK1;

IF RUN_TEST(39) THEN RETURN;		! Run this test? Return if no

NOERR_39 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset

	DM(77777,0);			! Write 0's to mem loc 77777 (just to
	WRT114(0);			!   load up the 8080 data/addr regs)
	WRT115(COM_ADR);		! Now do mem access which causes ?MRE
	WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);

	ERR_FLAG = 0;
	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
	MEM_STAT_REG = IO_EXAMINE(MSR);	! Read MSR (for error printouts)

	REG101 = RD_101;		! Read 8080 Reg 101 and see if a ?MRE
	IF (.REG101 AND MMC_REF_ERR) EQL 0!  occurred - If not set error flags,
	    THEN BEGIN			!    print error message, and abort
		 ERR_FLAG = 1;		!    the rest of this test.
		 NOERR_39 = 1;
		 ERRS(1,1,REG101);
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	MEM_STAT_REG = IO_EXAMINE(MSR);	! Now check MSR to see if 'ERR HOLD' is
	IF .MEM_STAT_REG GEQ 0		!   set - If not set error flags, print
	    THEN BEGIN			!   error message and abort the rest of
		 TEST_ABORT = 1;	!   this test.
		 NOERR_39 = 1;
		 ERRCA(2,%O'520000077777',.MEM_STAT_REG,12);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	NUM_ERR = 0;			! Now see how badly in error the error
	INCR BTT FROM 14 TO 35 DO	!   address is - count up the number of
	    BEGIN			!   bit positions in error.
	    IF .MEM_STAT_VECT[.BTT] NEQ 1
		THEN NUM_ERR = .NUM_ERR + 1;
	    END;

	IF .NUM_ERR GTR 17		! If the number errors > 17 we can be
	    THEN BEGIN			!   reasonably certain that 'ERR ADD
		 TEST_ABORT = 1;	!   LOAD' did not assert (in case of
		 NOERR_39 = 1;		!   other errors allow up to 5 errors)
		 ERRCA(3,%O'520000077777',.MEM_STAT_REG,12); 
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Master Reset
!*	LA 77777,DM 0	Put address into 8080 I/O Regs
!*	LR 114,DR 0	Turn off data cycle bit
!*	LR 115,DR 4	Turn on comadr cycle bit
!*	LR 210,DR 360	Do half of a write to mem (causes ?MRE)
!*RESPONSE
!*	?MRE did not occur    8080 Reg 101:  \O0

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR		Master Reset
!*	LA 77777,DM 0	Put address into 8080 I/O Regs
!*	LR 114,DR 0	Turn off data cycle bit
!*	LR 115,DR 4	Turn on comadr cycle bit
!*	LR 210,DR 360	Do half of a write to mem (causes ?MRE)
!*	EI 100000	Read Mem Status Reg - Verify 'ERR HOLD' bit
!*			  and error address
!*RESPONSE
!*	MMC5 'ERR HOLD' bit not asserted
!*	Mem Stat Reg:  \U0

!]ERROR 2
!] C5 AC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR		Master Reset
!*	LA 77777,DM 0	Put address into 8080 I/O Regs
!*	LR 114,DR 0	Turn off data cycle bit
!*	LR 115,DR 4	Turn on comadr cycle bit
!*	LR 210,DR 360	Do half of a write to mem (causes ?MRE)
!*	EI 100000	Read Mem Status Reg - Verify 'ERR HOLD' bit
!*			 and error address
!*RESPONSE
!*	MMC8 'ERR ADDR' not correct

!]ERROR 3
!] C5 AC CC NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST40: NOVALUE =

!++ ------------------------ ?MRE / ?NXM -------------------------------
! TEST DESCRIPTION:   This  routine verifies  that when the MMC board is
!	hung the memory controller will not respond to any commands such
!	as EM or DM but will respond to EI and DI.  MMC is hung and will
!	not perform any memory accesses - But a Read / Write status  can
!	still be done.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Hang mem - Cause a refresh error
!		   Verify that read mem loc 0 results in ?NXM
!		   Verify that write mem loc 0 results in ?NXM
!		   Verify that read status can be done
!		   Verify that write status can be done
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LOCAL
	ERR_FLAG;

OWN
	MESSV: VECTOR[6];		! Error message output vector

BIND
	REF_ERR = UPLIT(%ASCIZ '?MRE'),
	NXM_ERR = UPLIT(%ASCIZ '?NXM'),
	REG101 = MESSV,
	REG301 = MESSV[1],
	MSR_HANG = MESSV[2],
	MSR_EM = MESSV[3],
	MSR_DM = MESSV[4],
	MEM_EM = MESSV[5];

LABEL
	BLOCK1;

IF RUN_TEST(40) THEN RETURN;		! Run this test? Return if no

NOERR_40 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	REG101 = REG301 = 0;
	ERR_FLAG = 0;
	HANG_MEM();			! Cause a ?MRE
	CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
	MSR_HANG = IO_EXAMINE(MSR);	! Read MSR (should show ?MRE)

	REG101 = RD_101;		! Read 8080 Reg 101 - should show
	IF (.REG101 AND MMC_REF_ERR) EQL 0!   that a ?MRE occurred.
	    THEN BEGIN
		 ERR_FLAG = 1;		! If it doesnt set error flags and
		 NOERR_40 = 1;		!   print error message and abort
		 ERRS(1,1,MESSV);	!   the rest of this test
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	MEM_EM = EM(0);			! Try to read mem loc 0
	CHK_ERR_MSG(NXM_ERR);		! Discard any CSL error messages
	REG301 = RD_301;		! Read 8080 Reg 301 to see if a
	IF (.REG301 AND NEXM) EQL 0	!   ?NXM occurred then.
	    THEN BEGIN			! If not read MSR then set error
		 MSR_EM = IO_EXAMINE(MSR);!  flags, print error message and
		 TEST_ABORT = 1;	!    abort future testing.
		 NOERR_40 = 1;
		 ERRS(2,2,MESSV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	DM(0,123);			! Try to write to mem loc 0
	SEND_NUL();			! Send it out to 8080
	CHK_ERR_MSG(NXM_ERR);		! Discard any CSL error messages
	REG301 = RD_301;		! Read 8080 Reg 301 to see if a
	IF (.REG301 AND NEXM) EQL 0	!     ?NXM occurred then.
	    THEN BEGIN			! If not read MSR then set error
		 MSR_DM = IO_EXAMINE(MSR);!  flags, print error message and
		 TEST_ABORT = 1;	!    abort future testing.
		 NOERR_40 = 1;
		 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Master Reset
!*	HANG MMC	Cause a memory refresh error
!*RESPONSE
!*	?MRE did not occur    8080 Reg 101:  \O0

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR		Master Reset
!*	HANG MMC	Cause a memory refresh error
!*	EM 0		Should result in ?NXM
!*RESPONSE
!*	?MRE did occur (8080 Reg 101:  \O0) (Mem Stat Reg:  \U2)
!*	?NXM did not occur   EM 0:  \U5    8080 Reg 301:  \O1
!*	Mem Stat Reg (After EM 0):  \U3

!]ERROR 2
!] AB  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR		Master Reset
!*	HANG MMC	Cause a memory refresh error
!*	EM 0
!*	LA 0,DM 0	Should result in ?NXM
!*RESPONSE
!*	?MRE did occur (8080 Reg 101:  \O0) (Mem Stat Reg:  \U2)
!*	?NXM did not occur      8080 Reg 301:  \O1
!*	Mem Stat Reg (After DM 0):  \U4

!]ERROR 3
!] AB  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST41: NOVALUE =

!++   ------------ TIMING OF AN I/O WRITE INSTRUCTION ------------
! TEST DESCRIPTION:  This routine verifies the amount of time that
!	a write status takes.  The bus  arbitrator  grants the bus
!	for 3 T Clocks for an I/O instruction.  For a write status
!	to memory the MMC board  needs only this amount of time to
!	complete the request.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   SYNC REFRESH - Make sure that the timing of this
!			test is not affected by the occurrence of a
!			mem refresh cycle occurring before it gets
!			started.  Clock is also put into maintenance
!			mode and synced.
!		   Write data into 8080 Regs - For a write status to
!			turn off ?MRE
!		   Tick 3 T Clocks (Actually 13 ticks)
!		   Write data into 8080 Regs - For a write to memory
!			(The previous write status is not yet finished
!			but this write will grab the bus after the 3rd
!			T Clock)
!		   Tick until 'MEM BUSY' appears in 8080 Reg 102
!			(Look for 'MMC REF ERR' shut off in Reg 101)
!		   Verify that the number of ticks it took for a 
!			write status is correct
!		   Verify that 'MMC REF ERR' turned off
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000',	! Write to MSR
	WRITE_MEM = %O'100000000000',	! Write to mem loc 0
	AFTER = 1,			! Sync Refresh after ?MRE
	APPROX = 1;			! Sync Refresh approximately only

OWN
	ERR_FLAG,
	REGV: VECTOR[5];		! Error message output vector

BIND
	REG102 = REGV,
	REG101 = REGV[1],
	REG3 = REGV[2],
	TICK2 = REGV[3],
	TICK1 = REGV[4];

LABEL
	BLOCK1;

IF RUN_TEST(41) THEN RETURN;		! Run this test? Return if no

NOERR_41 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	DEBUG = 0;			! Make sure SYNC does not output
	ERR_FLAG = 0;
	IF SYNC_REFRESH(APPROX,AFTER)	! Sync the refresh at a point some
	    THEN BEGIN			!   time after ?MRE occurred
		 ERR_FLAG = 1;		! If this failed set error flags,
		 NOERR_41 = 1;		!   print error message, and abort
		 ERR(1);		!   this test.
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	WRITE_COMADR(WRITE_MSR);	! Now write to MSR to shut off the ?MRE
	WRITE_DATA(%O'700000000000');	!   left over from the SYNC_REFRESH
	WRITE_CONTROL();
	TICK(13);			! And give a few ticks to get it going

	WRITE_COMADR(WRITE_MEM);	! Now start a write mem - this should
	WRITE_DATA(%O'777777777777');	!   start immmediately after the write
	WRITE_CONTROL();		!   status is complete

	TICK1 = 13;			! Now tick along until 'MEM BUSY'
	TICK2 = 0;			!   clears from 8080 Reg 102. And
	DO  BEGIN			!   keep track of when ?MRE clears
	    TICK(1);			!   from Reg 101 (from the write
	    TICK1 = .TICK1 + 1;		!   status) also.
	    REG102 = RD_102;
	    REG101 = RD_101;
	    IF (.REG101 AND MMC_REF_ERR) EQL 0 AND .TICK2 EQL 0
		THEN TICK2 = .TICK1;
	    END
	WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 56;

	START_CLK;			! Start the clock back up
	IF (.REG102 AND RMEM_BUSY) EQL 0! If 'MEM BUSY' did not appear
	    THEN BEGIN			!   in Reg 102 - set error flag
		 NOERR_41 = 1;		!   and print error message.
		 ERRS(2,2,REGV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK1 NEQ 34 AND (.REG102 AND RMEM_BUSY) NEQ 0
	    THEN BEGIN			! If the number of ticks to see
		 NOERR_41 = 1;		!   'MEM BUSY' clear is incorrect
		 ERRS(3,3,REGV);	!   set error flag and print error
		 END;			!   message
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK2 NEQ 17 AND (.REG102 AND RMEM_BUSY) NEQ 0
	    THEN BEGIN			! If the number of ticks to see ?MRE
		 REGV[1]=IO_EXAMINE(MSR);!  clear is incorrect - set error
		 NOERR_41 = 1;		!   flag and print error message
		 ERRS(4,4,REGV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*RESPONSE
!*	Attempt to sync T & R Clocks failed - could not generate a
!*	  refresh error

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a write status to turn
!*	  off 'MMC REF ERR'
!*	Write '360' TO 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Do 13 ticks (3 T Clocks to do most of the write status)
!*	Write 8080 I/O Regs 102..115 for a write to memory
!*	Write '360' TO 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
!*	  (It should occur after 5 more T Clocks to allow I/O
!*	  write to complete and then start memory write cycle)
!*RESPONSE
!*	'MEM BUSY' never appeared in I/O Reg 102: \O0
!*	  (A total of 56 ticks (14 T Clocks) were given since
!*	   the start of the mem I/O status write cycle)

!]ERROR 2
!] AB BB AC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a write status to turn
!*	  OFF 'MMC REF ERR'
!*	Write '360' TO 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Do 13 ticks (3 T Clocks to do most of the write status)
!*	Write 8080 I/O Regs 102..115 for a write to memory
!*	Write '360' TO 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
!*	  (It should occur after 5 more T Clocks to allow I/O
!*	  write to complete and then start memory write cycle)
!*RESPONSE
!*	'MEM BUSY' appeared in I/O Reg 102 after \D4 ticks
!*	  but it should have occurred after 34 ticks (8 T Clocks)

!]ERROR 3
!] AB BB AC  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a write status to turn
!*	  off 'MMC REF ERR'
!*	Write '360' TO 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Do 13 ticks (3 T Clocks to do most of the write status)
!*	Write 8080 I/O Regs 102..115 for a write to memory
!*	Write '360' TO 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
!*	  (It should occur after 5 more T Clocks to allow I/O
!*	  write to complete and then start memory write cycle)
!*RESPONSE
!*	Mem status write did not occur properly - 'WRITE STATUS' and
!*	  'WRITE MEM' both succeeded but timing is off
!*	Number of ticks from start of 'WRITE STATUS' to see 'MMC REF ERR'
!*	  shut off in 8080 I/O Reg 101 - \D3 ticks  (Reg 101:  \O1)
!*	Number of ticks from start of 'WRITE STATUS' to see 'MEM BUSY'
!*	  in 8080 I/O Reg 102 - \D4 TICKS (102:  \O0)
!*	Mem Status Reg:  \U1  (Seen after clocks restarted)

!]ERROR 4
!] AB BB AC  NTWK
!]NO ERROR 4
!]  NTWK

END;
GLOBAL ROUTINE TST42: NOVALUE =

!++   ------------ TIMING OF AN I/O READ INSTRUCTION -------------
! TEST DESCRIPTION:  This routine verifies the amount of time that
!	a read status  takes.   The  bus arbitrator grants the bus
!	for 3 T Clocks for an I/O  instruction.  For a read status
!	to memory  the MMC board needs only this amount of time to
!	complete the request.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Write 0's to mem loc 0  -  Read mem loc 0
!			(To initialize 8080 I/O Reg 103 to 0's)
!		   SYNC REFRESH - Make sure that the timing of this
!			test is not affected by the occurrence of a
!			mem refresh cycle occurring before it gets
!			started.  Clock is also put into maintenance
!			mode and synced.
!		   Write data into 8080 Regs - For a write status to
!			turn off ?MRE so that the write memory will
!			not result in ?NXM later on.
!		   Tick until write status is complete.
!		   Write data into 8080 regs - For a read status to
!			see 'MMC REF ERR'
!		   Tick 13 ticks (3 T Clocks)
!		   Write data into 8080 Regs - For a write to memory
!			(The previous read status is not yet finished
!			but this write will grab the bus after the 3rd
!			T Clock)
!		   Tick until 'MEM BUSY' appears in 8080 Reg 102
!			(Look for 'RDATA 4' bit set in 8080 I/O Reg 3 -
!			 Indicating 'ECC ON' bit in Mem Stat Reg - This
!			 will detect the completion of the read status)
!		   Verify that the number of ticks it took for a 
!			read status is correct
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000',	! Write to MSR
	READ_MSR = %O'600000100000',	! Read MSR
	APPROX = 1,			! Sync refresh only approximately
	AFTER = 1,			! Sync refresh and leave after ?MRE
	WRITE_MEM = %O'100000000000';	! Write to mem loc 0

OWN
	ERR_FLAG,
	REGV: VECTOR[5];		! Error message output vector

BIND
	REG102 = REGV,
	REG101 = REGV[1],
	REG3 = REGV[2],
	TICK2 = REGV[3],
	TICK1 = REGV[4];

LABEL
	BLOCK1;

IF RUN_TEST(42) THEN RETURN;		! Run this test? Return if no

NOERR_42 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	DEBUG = 0;			! Ensure SYNC does not output
	ERR_FLAG = 0;

	IF SYNC_REFRESH(APPROX,AFTER)	! Sync refresh - if this fails
	    THEN BEGIN			!   set error flags, print error
		 NOERR_42 = 1;		!   message, and abort the test.
		 ERR(1);
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	WRITE_COMADR(WRITE_MSR);	! Clear ?MRE so that ?NXM does not
	WRITE_DATA(%O'700000000000');	!   occur on the write to mem which
	WRITE_CONTROL();		!   is done later
	TICK(40);			! Enough ticks to do write status

	WRITE_COMADR(READ_MSR);		! Now initiate the read status - this
	WRITE_CONTROL1();		!   is the one we will time
	TICK(13);			! Do most of it

	WRITE_COMADR(WRITE_MEM);	! Now start a memory cycle - 'MEM_BUSY'
	WRITE_DATA(%O'777777777777');	!   will appear as soon as the read
	WRITE_CONTROL();		!   status is done

	TICK1 = 13;			! Now count the number of ticks it
	TICK2 = 0;			!   takes to see 'MEM_BUSY' appear
	DO  BEGIN
	    TICK(1);			! Also keep track of when the data
	    TICK1 = .TICK1 + 1;		!   comes back from the read status
	    REG102 = RD_102;		!   into Reg 3 (TICK2 has # of ticks)
	    REG3 = RD_3;
	    IF (.REG3 AND RDATA4) NEQ 0 AND .TICK2 EQL 0
		THEN TICK2 = .TICK1;
	    END
	WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 56;

	START_CLK;			! All done with timing so restart clock
	IF (.REG102 AND RMEM_BUSY) EQL 0
	    THEN BEGIN			! If 'MEM_BUSY' never appeared set
		 NOERR_42 = 1;		!   error flags, and print error
		 ERRS(2,2,REGV);	!   message.
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK1 NEQ 34 AND (.REG102 AND RMEM_BUSY) NEQ 0
	    THEN BEGIN			! Was the timing correct?  If not
		 NOERR_42 = 1;		!   set error flags and print error
		 ERRS(3,3,REGV);	!   message.
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;

	IF .TICK2 NEQ 18 AND (.REG102 AND RMEM_BUSY) NEQ 0
	    THEN BEGIN			! Was timing correct for seeing data
		 REGV[1]=IO_EXAMINE(MSR);!  come back from read status?  If not
		 NOERR_42 = 1;		!   read current contents of MSR, set
		 ERRS(4,4,REGV);	!   error flags and print error message
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*RESPONSE
!*	Attempt to sync T & R Clocks failed - could not generate a
!*	  refresh error

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115,210 for a write status to turn off
!*	  'MMC REF ERR' (So that MMC will not be hung for a mem access)
!*	Write 8080 I/O Regs 102..115 for a read status to read 'ECC ON'
!*	  (Should appear as 'R DATA 4' bit in 8080 I/O Reg 3)
!*	WRITE '361' TO 8080 I/O REG 210 CONTROL BITS FOR READ
!*	  ('MEM','BUS REQ','XMIT ADR','LATCH DATA SENT','R CLK ENABLE L')
!*	Do 13 ticks (3 T Clocks to do most of the read status)
!*	Write 8080 I/O Regs 102..115 for a write to memory
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
!*	  (It should occur after 5 more T Clocks to allow I/O
!*	  read to complete and then start memory write cycle)
!*RESPONSE
!*	'MEM BUSY' never appeared in I/O Reg 102: \O0
!*	  (A total of 56 ticks (14 T Clocks) were given since
!*	   the start of the Mem I/O Status Read cycle)
!*	Either 'READ STATUS' failed or 'WRITE MEM' failed

!]ERROR 2
!] AB BB AC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115,210 for a write status to turn off
!*	  'MMC REF ERR' (So that MMC will not be hung for a mem access)
!*	Write 8080 I/O Regs 102..115 for a read status to read 'ECC ON'
!*	  (Should appear as 'R DATA 4' bit in 8080 I/O Reg 3)
!*	Write '361' to 8080 I/O Reg 210 control bits for read
!*	  ('MEM','BUS REQ','XMIT ADR','LATCH DATA SENT','R CLK ENABLE L')
!*	Do 13 ticks (3 T Clocks to do most of the read status)
!*	Write 8080 I/O Regs 102..115 for a write to memory
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
!*	  (It should occur after 5 more T Clocks to allow I/O
!*	  read to complete and then start memory write cycle)
!*RESPONSE
!*	'MEM BUSY' appeared in I/O Reg 102 after \D4 ticks but it
!*	  should have occurred after 34 ticks (8 T Clocks) (Or
!*	  21 ticks (5 T Clocks) after writing 'WRITE MEM' data to
!*	  8080 Regs.  Therefore the 'READ STATUS' took longer or
!*	  shorter than it should have.

!]ERROR 3
!] AB BB AC  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115,210 for a write status to turn off
!*	  'MMC REF ERR' (So that MMC will not be hung for a mem access)
!*	Write 8080 I/O Regs 102..115 for a read status to read 'ECC ON'
!*	  (Should appear as 'R DATA 4' bit in 8080 I/O Reg 3)
!*	Write '361' to 8080 I/O Reg 210 control bits for read
!*	  ('MEM','BUS REQ','XMIT ADR','LATCH DATA SENT','R CLK ENABLE L')
!*	Do 13 ticks (3 T Clocks to do most of the read status)
!*	Write 8080 I/O Regs 102..115 for a write to memory
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
!*	  (It should occur after 5 more T Clocks to allow I/O
!*	  read to complete and then start memory write cycle)
!*RESPONSE
!*	Mem status read did not occur properly - 'READ STATUS' and
!*	  'WRITE MEM' both succeeded but timing is off
!*	Number of ticks from start of 'READ STATUS' to see 'ECC ON' in
!*	  8080 I/O Reg 3 - \D3 ticks  (Reg 3:  \O2)
!*	Number of ticks from start of 'READ STATUS' to see 'MEM BUSY'
!*	  in 8080 I/O Reg 102 - \D4 ticks (102:  \O0)
!*	Mem Status Reg:  \U1  (Seen after clocks restarted)

!]ERROR 4
!] AB BB AC  NTWK
!]NO ERROR 4
!]  NTWK

END;
GLOBAL ROUTINE TST43: NOVALUE =

!++   ------------ LENGH OF A MEMORY WRITE ACCESS --------------
! TEST DESCRIPTION:  This routine  verifies that a memory  write
!	takes only 7 T Clocks or  1050 NS.  First the clocks are
!	put into maintenance mode  and  synced.  Then a write is
!	done and as soon as 'MEM BUSY' turns  off a second write
!	is done. In this manner the length of a write is verified
!	and the delay between one write and the next is verified
!	(It should be none since the mem cycles  should actually
!	overlap slightly - 1/2 T Clock)
!	If the test fails there is a possiblility that a refresh
!	cycle interfered with the timing so the test is repeated
!	immediately - it it now fails there is definitely an error.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   SYNC REFRESH - Make sure that the timing of this
!		     test is not affected by the occurrence of a
!		     mem refresh cycle occurring before it gets
!		     started.  Clock is also put into maintenance
!		     mode and synced.
!		   Write data into 8080 Regs - For a write to mem
!			(This cycle should start on the next T Clock)
!		   Do a T Clock until 'MEM BUSY' is detected (By a read
!			of 8080 I/O Reg 102)
!		   Do a T Clock until 'MEM BUSY' goes away
!		   Write data into 8080 Regs - For a write to mem
!			(This cycle should start on the next T Clock)
!		   Do a T Clock until 'MEM BUSY' is detected (By a read
!			of 8080 I/O Reg 102)
!		   Do a T Clock until 'MEM BUSY' goes away
!		   Verify that the number of T Clocks it took is ok
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000',	! Write to MSR
	CLEAR_MRE = %O'100000000000',	! Clear ?MRE on a write to MSR
	APPROX = 1,			! Sync refresh only approximately
	AFTER = 1,			! Sync refresh and leave after ?MRE
	WRITE_MEM = %O'100000000000';	! Write to mem loc 0

OWN
	ERR_FLAG,
	TICKV: VECTOR[4],		! Error message output vector
	REG;

BIND
	TICK1 = TICKV,
	TICK2 = TICKV[1],
	TICK3 = TICKV[2],
	TICK4 = TICKV[3];

LABEL
	BLOCK1;

IF RUN_TEST(43) THEN RETURN;		! Run this test? Return if no

NOERR_43 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
DEBUG = 0;				! Make sure SYNC does not output

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	IF SYNC_REFRESH(APPROX,AFTER)	! Sync refresh
	    THEN BEGIN
		 NOERR_43 = 1;		! If it fails - set error flags, print
		 ERR(1);		!   error message, and abort the test.
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE caused by SYNC
	WRITE_DATA(CLEAR_MRE);
	WRITE_CONTROL();
	TICK(40);			! Enough ticks to clear it

	WRITE_COMADR(WRITE_MEM);	! Write to mem loc 0
	WRITE_CONTROL();
	TICK1 = 0;			! Count how many ticks it takes to
	DO  BEGIN			!   see 'MEM_BUSY' in 8080 Reg 102
	    TICK(1);
	    REG = RD_102;
	    TICK1 = .TICK1 + 1;
	    END
	WHILE (.REG AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 60;

	TICK2 = 0;			! Now count how many ticks it takes
	DO  BEGIN			!   to see 'MEM_BUSY' clear.
	    TICK(1);
	    REG = RD_102;
	    TICK2 = .TICK2 + 1;
	    END
	WHILE (.REG AND RMEM_BUSY) NEQ 0 AND .TICK2 LSS 60;

	WRITE_COMADR(WRITE_MEM);	! Now write to memory again and count
	WRITE_CONTROL();		!   how many ticks it takes to see
	TICK3 = 0;			!   'MEM_BUSY' appear in Reg 102
	DO  BEGIN
	    TICK(1);
	    REG = RD_102;
	    TICK3 = .TICK3 + 1;
	    END
	WHILE (.REG AND RMEM_BUSY) EQL 0 AND .TICK3 LSS 60;

	TICK4 = 0;			! Now see how long it takes for
	DO  BEGIN			!   'MEM_BUSY' to clear
	    TICK(1);
	    REG = RD_102;
	    TICK4 = .TICK4 + 1;
	    END
	WHILE (.REG AND RMEM_BUSY) NEQ 0 AND .TICK4 LSS 60;

! Now just compare actual vs. expected and do error handling if needed.

	IF .TICK1 NEQ 18 OR .TICK2 NEQ 8 OR .TICK3 NEQ 20 OR .TICK4 NEQ 8
	    THEN BEGIN
		 NOERR_43 = 1;
		 ERRS(2,2,TICKV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*RESPONSE
!*	Attempt to sync T & R Clocks failed - could not generate a
!*	  refresh error

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	(A)  Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
!*	     (Should take 18 ticks (4.5 T Clocks))
!*	(B)  Tick T Clock until 'MEM BUSY' clears in 8080 I/O Reg 102
!*	     (Should take 8 ticks (2 T Clocks))
!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	(C)  Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
!*	     (Should take 20 ticks (5 T Clocks))
!*	(D)  Tick T Clock until 'MEM BUSY' clears in 8080 I/O Reg 102
!*	     (Should take 8 ticks (2 T Clocks))
!*RESPONSE
!*	(A) - Took \D0 ticks to see 'MEM BUSY' assert
!*	(B) - Took \D1 ticks to see 'MEM BUSY' clear
!*	(C) - Took \D2 ticks to see 'MEM BUSY' assert
!*	(D) - Took \D3 ticks to see 'MEM BUSY' clear

!]ERROR 2
!] AA BA AB BB AC  NTWK
!]NO ERROR 2
!]  NTWK

END;
GLOBAL ROUTINE TST44: NOVALUE =

!++   ------------ HOW LONG DOES ?NXM TIE UP MMC -------------
! TEST DESCRIPTION:  This test  verifies that when ?NXM occurs
!	the MMC controller quickly signals ?NXM and aborts the
!	memory cycle freeing up memory for the next operation.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Sync T & R Clocks
!		   Write data to 8080 I/O Regs - For a write to
!			mem loc 7777777 (nonexistent)
!		   Tick clock until ?NXM is set
!		   Write data to 8080 I/O Regs - For a write to
!			mem loc 0
!		   Tick clock until 'MEM BUSY' appears
!		   Verify the number of ticks taken
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	WRITE_MEM = %O'100000000000',	! Write to mem loc 0
	WRITE_NXM = %O'100007777777';	! Write to mem loc ?NXM

OWN
	ERR_FLAG,
	REGV: VECTOR[4];		! Error message data vector

BIND
	REG301 = REGV,
	REG102 = REGV[1],
	TICK1 = REGV[2],
	TICK2 = REGV[3];

LABEL
	B2,
	BLOCK1;

IF RUN_TEST(44) THEN RETURN;		! Run this test? Return if no

NOERR_44 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();
	SYNC_CLK();			! Sync T & R Clocks

! Try this whole thing twice in case it doesnt work the first time.
!   Occasionally a flaky error may cause it to fail needlessly.

	INCR TRY FROM 0 TO 1 DO
	B2: BEGIN
	    WRITE_COMADR(WRITE_NXM);	! Write to ?NXM
	    WRITE_CONTROL();

	    TICK1 = 0;			! Tick forward until we get
	    DO  BEGIN			!   a ?NXM in 8080 Reg 301
		TICK(1);
		REG301 = RD_301;
		TICK1 = .TICK1 + 1;
		END
	    WHILE (.REG301 AND NEXM) EQL 0 AND .TICK1 LSS 100;

	    ERR_FLAG = 0;
	    IF (.REG301 AND NEXM) EQL 0
		THEN BEGIN		! If a ?NXM did not occur set
		     NOERR_44 = 1;	!   error flags, print error
		     ERR_FLAG = 1;	!   message, and abort the test.
		     ERRS(1,1,REGV);
		     END;
	    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;

	    TICK(1);			! Give a tick just for good luck
	    WRITE_COMADR(WRITE_MEM);	! Now start the memory write cycle
	    WRITE_CONTROL();		!   which should be delayed while MMC
	    TICK2 = 0;			!   finishes clearing the NXM cycle.
	    DO	BEGIN
		TICK(1);		! Tick until 'MEM_BUSY' appears in
		REG102 = RD_102;	!   Reg 102
		TICK2 = .TICK2 + 1;
		END
	    WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK2 LSS 100;

	    IF (.REG102 AND RMEM_BUSY) EQL 0
		THEN BEGIN		! If 'MEM_BUSY' never appeared do
		     IF .TRY EQL 0	!   a retry but if we already did
			THEN LEAVE B2;	!   one then set error flags, print
		     NOERR_44 = 1;	!   error message.
		     ERRS(2,2,REGV);
		     END;
	    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;

	    IF (.REG102 AND RMEM_BUSY) NEQ 0
		THEN BEGIN			! So we did see 'MEM_BUSY' -
		     IF .TICK2 NEQ 19		!   was it at the right time?
			THEN BEGIN
			     IF .TRY EQL 0	! If no - retry - but if retry
				THEN LEAVE B2;	!   already done then set error
			     NOERR_44 = 1;	!   flags, print error message.
			     ERRS(3,3,REGV);
			     END;
		     END;
	    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	    END;
	TICK(40);			! 40 ticks just to give room for the
	0				! To eliminate INFO compiler message
	END;				!   the second try

!*MESSAGE 1
!*STIMULUS
!*	Sync T & R Clocks
!*	Write 8080 I/O Regs 102..115 for a write to mem loc 7777777
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'NXM' gets set in 8080 I/O Reg 301
!*	  (Should take 16 ticks (4 T Clocks))
!*RESPONSE
!*	'NXM' never appeared in I/O Reg 301: \O0   (\D2 ticks given)

!]ERROR 1
!] I8 A8 AA AB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	Sync T & R Clocks
!*	Write 8080 I/O Regs 102..115 for a write to mem loc 7777777
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'NXM' gets set in 8080 I/O Reg 301
!*	  (Should take 16 ticks (4 T Clocks)) (It took \D2 ticks)
!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
!*	  (Should take 16 ticks (4 T Clocks))
!*RESPONSE
!*	'MEM BUSY' never appeared in Reg 102 (\D3 more ticks)
!*	8080 I/O Regs 301:  \O0   102:  \O1

!]ERROR 2
!] AA BA AB BB AC  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	Sync T & R Clocks
!*	Write 8080 I/O Regs 102..115 for a write to mem loc 7777777
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'NXM' gets set in 8080 I/O Reg 301
!*	  (Should take 16 ticks (4 T Clocks)) (It took \D2 ticks)
!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
!*	  (Should take 16 ticks (4 T Clocks))
!*RESPONSE
!*	'MEM BUSY' appeared in I/O Reg 102 but it took \D3 ticks
!*	8080 I/O Regs 301:  \O0   102:  \O1

!]ERROR 3
!] AA BA AB BB AC  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST45: NOVALUE =

!++   ---------- MMC TIMING:  GOOD VS. BAD DATA CYCLE ----------
! TEST DESCRIPTION:  This routine verifies one small part of the
!	timing characteristics  of  the MMC board.  First that a
!	memory read takes 3 clock periods  when there are no ECC
!	errors encountered. And that a read when bad data appears
!	takes an additional clock period.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Master Reset
!		   Write 0's to mem loc 111
!		   Write status force bits 177
!		   Write 0's to mem loc 222 (When read this will
!			cause a single bit error)
!		   Write 0's to mem loc 333 (When read this will
!			cause a double bit error)
!		   SYNC REFRESH - Make sure that the timing of this
!		     test is not affected by the occurrence of a
!		     mem refresh cycle occurring before it gets
!		     started.  Clock is also put into maintenance
!		     mode and synced.
!		   Repeat for each mem location:
!			Write Com/Adr data to 8080 Regs
!			Write control bits to 8080 Regs
!			Tick until 8080 I/O Reg 102 'R COM ADR' turns
!			   on - Error if not correct number of ticks
!			Tick until 8080 I/O Reg 102 'R MEM BUSY' turns
!			   on - Error if not correct number of ticks
!			Tick until 8080 I/O Reg 102 'R MEM BUSY' turns
!			   off - Error if not correct number of ticks
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000',
	CLEAR_MRE = %O'100000000000',
	READ = %O'200000000000',
	APPROX = 1,			! Sync refresh approximately only
	AFTER = 1,			! Sync refresh after ?MRE occurred
	FORCE_SINGLE = %O'700000000376',! Force bits for a single bit error
	FORCE_DOUBLE = %O'700000000374';! Force bits for a double bit error

OWN
	ADR_VECT: VECTOR[3]		! Three addr:  111 - good data
	    INITIAL (%O'111',%O'222',	! 	       222 - single bit error
		     %O'333'),		! 	       333 - double bit error
	T_CORRECT: VECTOR[3]		! Correct number of T-Clocks needed
	    INITIAL (12,16,24),		!   for each read
	T_CORRECT1: VECTOR[3]		! Correct number of T-Clocks needed
	    INITIAL (12,16,24),		!   for each read
	REGV: VECTOR[9];		! Error message output vector

BIND
	TICK1 = REGV,			! Ticks to see Com/Adr in Reg 102
	REG102A = REGV[1],		! Reg 102 at TICK1
	TICK2 = REGV[2],		! Ticks to see Mem Busy in Reg 102
	REG102B = REGV[3],		! Reg 102 at TICK2
	TICK3 = REGV[4],		! Ticks to see Mem Busy in Reg 102
	REG102C = REGV[5],		! Reg 102 at TICK3
	MLOC = REGV[6],			! Memory location
	T_SHOULD = REGV[7],		! # of T Clocks it should have taken
	T_ACTUAL = REGV[8];		! # of T Clocks it actually did take

LOCAL
	T_SHOULD1,
	ERR_FLAG;

LABEL
	BLOCK1;

IF RUN_TEST(45) THEN RETURN;		! Run this test? Return if no

NOERR_45 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();
	DM(111,0);			! Write good data
	IO_DEPOSIT(MSR,FORCE_SINGLE);
	DM(222,0);			! Write data with single bit error
	IO_DEPOSIT(MSR,FORCE_DOUBLE);
	DM(333,0);			! Write data with double bit error

	DEBUG = 0;			! Ensure SYNC doesnt print DEBUG output
	IF SYNC_REFRESH(APPROX,AFTER)
	    THEN BEGIN			! Sync refresh and abort if SYNC
		 ERR(1);		!   failed - set error flags and
		 NOERR_45 = 1;		!   abort this test.
		 ERR_FLAG = 1;
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE that SYNC caused
	WRITE_DATA(CLEAR_MRE);
	WRITE_CONTROL();
	TICK(40);			! Give enough ticks to clear it

! Now we are all set to read the data back and time each read access.

	INCR MEM_LOC FROM 0 TO 2 DO
	    BEGIN			! First write control data to 
	    MLOC = .ADR_VECT[.MEM_LOC];	!   8080 registers to do read
	    T_SHOULD = .T_CORRECT[.MEM_LOC];
	    T_SHOULD1 = .T_CORRECT1[.MEM_LOC];
	    WRITE_COMADR(READ + .ADR_VECT[.MEM_LOC]);
	    WRITE_CONTROL();

	    TICK1 = 0;			! Now tick until we see 'COM/ADR'
	    DO	BEGIN			!   in Reg 102 (should be much
		TICK(1);		!   less than 60 ticks)
		TICK1 = .TICK1 + 1;
		REG102A = RD_102;
		END
	    WHILE (.REG102A AND RCOM_ADR) EQL 0 AND .TICK1 LSS 60;

	    IF (.REG102A AND RCOM_ADR) EQL 0
		THEN BEGIN		! If this read failed set error
		     ERR_FLAG = 1;	!   flags, print error message
		     NOERR_45 = 1;	!   and abort this test.
		     ERRS(2,2,REGV);
		     END;
	    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;

	    TICK2 = 0;			! Now tick until we see 'MEM BUSY'
	    DO	BEGIN			!   in Reg 102 (should be much
		TICK(1);		!   less than 60 ticks)
		TICK2 = .TICK2 + 1;
		REG102B = RD_102;
		END
	    WHILE (.REG102B AND RMEM_BUSY) EQL 0 AND .TICK2 LSS 60;

	    IF (.REG102B AND RMEM_BUSY) EQL 0
		THEN BEGIN		! If 'MEM_BUSY' failed to appear
		     ERR_FLAG = 1;	!   set error flags, print error
		     NOERR_45 = 1;	!   message, and abort the test.
		     ERRS(3,3,REGV);
		     END;
	    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;

	    TICK3 = 0;			! Now tick along until 'MEM_BUSY'
	    DO	BEGIN			!   clears - by now we know how
		TICK(1);		!   long the read took.
		TICK3 = .TICK3 + 1;
		REG102C = RD_102;
		END
	    WHILE (.REG102C AND RMEM_BUSY) NEQ 0 AND .TICK3 LSS 60;

	    IF (.REG102C AND RMEM_BUSY) NEQ 0
		THEN BEGIN		! If 'MEM_BUSY' never cleared then
		     ERR_FLAG = 1;	!   set error flags, print error
		     NOERR_45 = 1;	!   message, and abort the test.
		     ERRS(4,4,REGV);
		     END;
	    IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	    IF .ERR_FLAG EQL 1 THEN RETURN;

	    T_ACTUAL = .TICK3;		! Did the read take exactly as long
	    IF (.TICK3 NEQ .T_SHOULD) AND (.TICK3 NEQ .T_SHOULD1)
		THEN BEGIN		!   as it should have?
		     NOERR_45 = 1;	! If not set error flags and print
		     ERRS(5,5,REGV)	!   error message.
		     END;
	    IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
	    END;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*RESPONSE
!*	Attempt to sync T & R Clocks failed - could not generate a
!*	  refresh error

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	MR,LA 111,DM 0	Write 0's to mem loc 111
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
!*	LA 222,DM 0	Write 0's to mem loc 222
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
!*	LA 333,DM 0	Write 0's to mem loc 333
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
!*	  start of the memory cycle
!*RESPONSE
!*	'COM ADR' not asserted after \D0 ticks
!*	8080 I/O Reg 102:  \O1	

!]ERROR 2
!] BA  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	MR,LA 111,DM 0	Write 0's to mem loc 111
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
!*	LA 222,DM 0	Write 0's to mem loc 222
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
!*	LA 333,DM 0	Write 0's to mem loc 333
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
!*	  start of the memory cycle - It took \D0 Ticks    102:  \O1
!*	Tick clock until 'MEM BUSY' asserts in Reg 102
!*RESPONSE
!*	'MEM BUSY' never appeared in Reg 102
!*	Reg 102:  \O3   After \D2 Ticks

!]ERROR 3
!] AA BA AB BB AC  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	MR,LA 111,DM 0	Write 0's to mem loc 111
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
!*	LA 222,DM 0	Write 0's to mem loc 222
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
!*	LA 333,DM 0	Write 0's to mem loc 333
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
!*	  start of the memory cycle - It took \D0 ticks    102:  \O1
!*	Tick clock until 'MEM BUSY' asserts in Reg 102 (It took \D2 ticks)
!*	Tick clock until 'MEM BUSY' clears (It should take \D7 ticks)
!*RESPONSE
!*	'MEM BUSY' still asserted after \D4 ticks
!*	8080 I/O Reg 102:  \O5	

!]ERROR 4
!] AA BA AB BB AC  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	MR,LA 111,DM 0	Write 0's to mem loc 111
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
!*	LA 222,DM 0	Write 0's to mem loc 222
!*	LI 100000	Write status to mem - Clear ERR HOLD ..
!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
!*	LA 333,DM 0	Write 0's to mem loc 333
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
!*	Write '360' to 8080 I/O Reg 210 control bits for write
!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
!*	  start of the memory cycle - It took \D0 ticks    102:  \O1
!*	Tick clock until 'MEM BUSY' asserts in Reg 102 (It took \D2 ticks)
!*	Tick clock until 'MEM BUSY' clears - 'MEM BUSY' should have been
!*	  asserted for a total of \D7 ticks
!*RESPONSE
!*	Ticks needed to clear 'MEM BUSY' - \D5
!*	MEM BUSY was asserted for \D8 ticks - Timing is off

!]ERROR 5
!] AA BA AB BB AC  NTWK
!]NO ERROR 5
!]  NTWK

END;
GLOBAL ROUTINE TST46: NOVALUE =

!++   -------- 'MMC9 REFRESH ERR' BIT SET BY REFRESH ERROR -------
! TEST DESCRIPTION:   This routine  verifies that the signal 'MMC9
!	REFRESH ERR' can be set by a refresh error and in addition
!	the 8080 can see the complement of this signal in Reg 101.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  MR
!		   LR 115  DR 4 (Set Com/Adr cycle)
!		   LR 113  DR 6 (Set Com/Adr bits to a read & a write)
!		   LR 210  DR 361 (Cause the data to go out on the
!			bus to the MMC board)
!		   Read Mem Stat Reg and 8080 Reg 101 and verify
!			that 'REF ERR' shows up in each
!
! POSSIBLE ERRORS:  'MMC9 REF ERR' flop or 'MMC9 REF ERR B L' inverter
!			are faulty.
!
!--

BEGIN

LOCAL
	ERR_FLAG,
	M_REF;

OWN
	MEM_DATA_VECT: VECTOR[2],
	MEM_STAT_VECT: BTTVECTOR[36];

BIND
	MEM_DAT = MEM_DATA_VECT,
	MEM_STAT = MEM_STAT_VECT,
	REF_ERR = UPLIT(%ASCIZ '?MRE');

LABEL
	BLOCK1;

IF RUN_TEST(46) THEN RETURN;		! Run this test? Return if no

NOERR_46 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	HANG_MEM();			! Cause ?MRE

! Get rid of the unexpected error message that CSL will send to STIRS
	CHK_ERR_MSG(REF_ERR);

	MEM_DAT = MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
	MEM_DATA_VECT[1] = M_REF = RD_101;	! Read Reg 101 (shows ?MRE)
	ERR_FLAG = 0;
	IF .MEM_STAT_VECT[2] EQL 0		! Did we get ?MRE?
	    THEN BEGIN
		 IF (.M_REF AND 1) EQL 0	! No - but check Reg 101 to
		    THEN ERR_FLAG = 1		!   see if that shows up the
		    ELSE BEGIN			!   ?MRE
			 TEST_ABORT = 1;
			 ERR_FLAG = 3;
			 END;
		 END
	    ELSE BEGIN
		 IF (.M_REF AND 1) EQL 0	! Yes - now make sure Reg 101
		    THEN BEGIN			!   shows ?MRE also
			 TEST_ABORT = 1;
			 ERR_FLAG = 2;
			 END;
		 END;

! Now we know what type of error occurred if in fact one did so
!   do the error message handling.

	INCR ERR FROM 1 TO 3 DO
	    BEGIN
	    IF .ERR EQL .ERR_FLAG		! Did this error occur?
		THEN BEGIN
		     NOERR_46 = 1;		! Yes - set error flag
		     ERRS(.ERR,.ERR,MEM_DAT);
		     END;
	    IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
	    END;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	LR 115,DR 4	Write Com/Adr data to 8080 Regs - Set 'COM/ADR CYCLE'
!*	LR 114,DR 0	  Set MEM WRITE, do not set 'DATA CYCLE' -- causes
!*	LR 113,DR 1	  ?MRE
!*	LR 210,DR 361	Set up mem cycle - 'CHECK NXM','CONSOLE REQ','T ENB
!*			  FOR COM/ADR & DATA', and 'R CLK ENB L'
!*	EI 100000	Read Mem Stat Reg - should show 'REF ERR'
!*	ER 101		Read 8080 Reg 101 - should show 'MMC REF ERR B'
!*RESPONSE
!*	Neither IO Reg 101 or MSR shows 'REF ERR'
!*	MSR:  \U0	I/O Reg 101:  \O1

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	LR 115,DR 4	Write Com/Adr data to 8080 regs - set 'COM/ADR CYCLE'
!*	LR 114,DR 0	  Set MEM WRITE, do not set 'DATA CYCLE' -- causes
!*	LR 113,DR 1	  ?MRE
!*	LR 210,DR 361	Set up mem cycle - 'CHECK NXM','CONSOLE REQ','T ENB
!*			  FOR COM/ADR & DATA', and 'R CLK ENB L'
!*	EI 100000	Read Mem Stat Reg - should show 'REF ERR'
!*	ER 101		Read 8080 Reg 101 - should show 'MMC REF ERR B'
!*RESPONSE
!*	MSR shows 'REF ERR' but I/O Reg 101 does not
!*	MSR:  \U0	I/O Reg 101:  \O1

!]ERROR 2
!] B9  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	LR 115,DR 4	Write Com/Adr data to 8080 regs - set 'COM/ADR CYCLE'
!*	LR 114,DR 0	  Set MEM WRITE, do not set 'DATA CYCLE' -- causes
!*	LR 113,DR 1	  ?MRE
!*	LR 210,DR 361	Set up mem cycle - 'CHECK NXM','CONSOLE REQ','T ENB
!*			  FOR COM/ADR & DATA', and 'R CLK ENB L'
!*	EI 100000	Read Mem Stat Reg - should show 'REF ERR'
!*	ER 101		Read 8080 Reg 101 - should show 'MMC REF ERR B'
!*RESPONSE
!*	IO Reg 101 shows 'REF ERR' but MSR does not
!*	MSR:  \U0	I/O Reg 101:  \O1

!]ERROR 3
!] B9  NTWK
!]NO ERROR 3
!]  NTWK

END;
GLOBAL ROUTINE TST47: NOVALUE =

!++   ---------------------- REFRESH TIMING -------------------------
! TEST DESCRIPTION:  This test partially verifies the refresh control
!	logic on MMC7. The logic which this test is trying to test is
!	the binary counters  which determine when a refresh will take
!	place and at what point after that a refresh error will occur
!	if refresh does not happen because memory is hung or busy.
!
! TEST ASSUMPTIONS:  None.
!
! TEST PROCEDURE:  Write Com/Adr data to 8080 I/O Regs to hang MMC
!		   Sync T & R Clocks
!		   Write Com/Adr cycle data to I/O Reg: 210,114,115
!		   Tick until ?MRE occurs
!		   Write status to turn off ?MRE (60 ticks are given after
!		     the ?MRE and 60 more ticks to get the write status
!		     done - 120 ticks so far)
!		   Write Com/Adr data to 8080 I/O Regs to hang MMC
!		   Tick until ?MRE occurs - Should take 684 more ticks
!			or a total of 200 T Clocks since the last
!			?MRE.  If it doesnt there is a fault in 
!			the counters.
!
! POSSIBLE ERRORS:  Binary counters on MMC7 faulty.
!
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000',
	CLEAR_MRE = %O'100000000000',
	HANGMEM = %O'300000000000';

LOCAL
	TEMP;

OWN
	ERR_FLAG,
	REG,
	REGV: VECTOR[9];

BIND
	TICK1 = REGV,
	REG101 = REGV[1],
	TICK2 = REGV[2],
	TICK3 = REGV[3],
	TICK9 = REGV[5],
	TICK10 = REGV[6],
	TICK48 = REGV[7],
	TICK170 = REGV[8];

LABEL
	BLOCK1;

IF RUN_TEST(47) THEN RETURN;		! Run this test? Return if no

NOERR_47 = 0;				! No errors have occurred yet
REGV[4] = .MRE_TICKS;			! Save # ticks needed for ?MRE for
TICK10 = .MRE_TICKS / 4;		!   error message printout
TICK48 = .MRE_TICKS - 132 - 620;
TICK170 = .MRE_TICKS - 620;

! Do this section only if the DEBUG flag is set.

IF .DEBUG NEQ 0 THEN			! This code is intended for debugging
	BEGIN				!   purposes.  It is executed only if
	MR();				!   DEBUG is non-zero.  It puts clocks
	SYNC_CLK();			!   in maintenance mode, does a memory
	HANG_MEM();			!   cycle to hang up memory (cause a
	TICK1 = 0;			!   ?MRE), then times how long it takes
	DO BEGIN			!   to get the ?MRE.  It counts ticks
	   TICK(4);			!   4 at a time and allows up to 4000.
	   REG101 = RD_101;		! 
	   REG = .REG101 AND MMC_REF_ERR;
	   TICK1 = .TICK1 + 4;
	   END
	WHILE (.REG EQL 0) AND (.TICK1 LSS 4000);
	ERRS(7,7,REGV);

	TICK(60);			! Tick forward a bit then clear
	WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
	WRITE_DATA(CLEAR_MRE);		!   more to get it done
	WRITE_CONTROL();
	TICK(60);
	REG = 0;			! Keep on ticking until it is done.
	TICK1 = 120;
	WHILE (.REG EQL 0) AND (.TICK1 LSS 1000) DO
	    BEGIN
	    TICK(4);
	    TICK1 = .TICK1 + 4;
	    REG101 = RD_101;
	    REG = .REG101 AND MMC_REF_ERR;
	    END;

	HANG_MEM();			! Now see how long it takes to get
	REG = 0;			!   the second ?MRE using same
	DO BEGIN			!   procedure as above.
	   TICK(4);
	   REG101 = RD_101;
	   REG = .REG101 AND MMC_REF_ERR;
	   TICK1 = .TICK1 + 4;
	   END
	WHILE (.REG EQL 0) AND (.TICK1 LSS 4000);
	ERRS(7,7,REGV);

	TICK(60);			! Tick forward a bit then clear
	WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
	WRITE_DATA(CLEAR_MRE);		!   more to get it done
	WRITE_CONTROL();
	TICK(60);
	REG = 0;			! Keep on ticking until it is done.
	TICK1 = 120;
	WHILE (.REG EQL 0) AND (.TICK1 LSS 1000) DO
	    BEGIN
	    TICK(4);
	    TICK1 = .TICK1 + 4;
	    REG101 = RD_101;
	    REG = .REG101 AND MMC_REF_ERR;
	    END;

	HANG_MEM();			! Now see how long it takes to
	REG = 0;			!   get the third ?MRE using the
	DO BEGIN			!   same procedure as above.
	   TICK(4);
	   REG101 = RD_101;
	   REG = .REG101 AND MMC_REF_ERR;
	   TICK1 = .TICK1 + 4;
	   END
	WHILE (.REG EQL 0) AND (.TICK1 LSS 4000);
	ERRS(7,7,REGV);

	START_CLK;			! Turn clocks back on and clear
	WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
	WRITE_DATA(CLEAR_MRE);		!   more to get it done
	WRITE_CONTROL();
	END;

! Now get down to the actual test.  The prior section was done only if the
!   DEBUG flag was set.

INCR TRY FROM 0 TO 2 DO			! Try three times to get test to pass
	BEGIN				!   (in case of flaky errors)
	DO (0)	WHILE
BLOCK1:	BEGIN
	RPT_ERR_FLAG = 0;		! Don't report unexpected error
	ERR_FLAG = TICK1 = 0;

! First cause a ?MRE.  If the refresh logic is faulty the ?MRE may occur
!   at the wrong time so we will give it 2 tries and 1056 ticks to get
!   one.  

	DO  BEGIN
	    IF .TICK1 EQL 0 OR .TICK1 EQL 25*132
		THEN BEGIN
		     MR();			! Master Reset
		     SEND_NUL();		! Send it off
		     MR();			! Master Reset
		     SYNC_CLK();		! Clocks in maintenance mode
		     HANG_MEM();		! Cause a ?MRE (after enough
		     END;			!   ticks are given)
	    TICK(132);				! 132 ticks at a time
	    REG101 = RD_101;
	    REG = .REG101 AND MMC_REF_ERR;	! ?MRE yet?
	    TICK1 = .TICK1 + 132;
	    END
	WHILE (.REG EQL 0) AND (.TICK1 LSS 50*132);

	IF (.TICK1 EQL 50*132) AND (.REG EQL 0)
	    THEN BEGIN			! If we haven't failed 3 tries
		 IF .TRY NEQ 2 THEN	!   yet try another one.
		    LEAVE BLOCK1 WITH 0;! Couldnt get a ?MRE at all so
		 NOERR_47 = 1;		!   set error flags, write out an
		 ERR_FLAG = 1;		!   error message and abort the
		 ERRS(1,1,REGV);	!   test.
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	TICK(60);			! Tick forward a bit then clear
	WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
	WRITE_DATA(CLEAR_MRE);		!   more to get it done
	WRITE_CONTROL();
	TICK(60);
	REG101 = RD_101;		! Make sure ?MRE got cleared
	REG = .REG101 AND MMC_REF_ERR;
	IF .REG EQL 1			! ?MRE did not get cleared so
	    THEN BEGIN			!   set error flags, write out an
		 IF .TRY NEQ 2 THEN	!   error message and abort the
		    LEAVE BLOCK1 WITH 0;!   test and future testing.
		 ERR_FLAG = 1;		! Note: if three tries have not
		 NOERR_47 = 1;		!   been done then don't do error
		 TEST_ABORT = 1;	!   handling yet.
		 ERRS(2,2,REGV);
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

! Now try to home in on the error more accurately.  At least we know
!   by now that we can get a ?MRE and that we can predict within 132
!   ticks the occurrence of the next ?MRE (when it should occur).
! Note that the above was not really necessary except that the test
!   would take too long if we went along 4 ticks at a time until we
!   got a ?MRE.

	HANG_MEM();			! Now cause another ?MRE
	REG = 0;
	TICK(200);			! Move a ways down the track - 
	TICK(200);			!   500 ticks
	TICK(100);
	REG = TICK2 = 0;

	WHILE BEGIN				! Now go 4 ticks at a time
	      REG101 = RD_101;			!   until we see ?MRE in
	      REG = .REG101 AND MMC_REF_ERR;	!   Reg 101.
	      IF (.REG EQL 0) AND (.TICK2 LSS 2000)
		THEN 1 ELSE 0
	      END
	DO BEGIN
	    TICK(4);
	    TICK2 = .TICK2 + 4;
	    END;

	IF .REG EQL 0			! Were we able to cause another
	    THEN BEGIN			!   ?MRE within a reasonable 
		 IF .TRY NEQ 2 THEN	!   amount of time?  If no set
		    LEAVE BLOCK1 WITH 0;!   error flags, print error
		 ERR_FLAG = 1;		!   message and abort the test.
		 TEST_ABORT = 1;	! If this isn't third try yet 
		 NOERR_47 = 1;		!   keep trying.
		 ERRS(3,3,REGV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

! Now we are all set to actually time how long it takes for the
!   the binary counters to count down to ?MRE.

	TICK(60);
	WRITE_COMADR(WRITE_MSR);	! Clear that ?MRE
	WRITE_DATA(CLEAR_MRE);
	WRITE_CONTROL();
	TICK(60);

	REG101 = RD_101;		! And make sure its cleared
	REG = .REG101 AND MMC_REF_ERR;
	IF .REG EQL 1			! If not cleared, set error
	    THEN BEGIN			!   flags, print error message
		 IF .TRY NEQ 2 THEN	!   and abort the test.
		    LEAVE BLOCK1 WITH 0;! If not third try yet - keep
		 ERR_FLAG = 1;		!   trying.
		 TEST_ABORT = 1;
		 NOERR_47 = 1;
		 ERRS(4,4,REGV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	HANG_MEM();			! Cause the next ?MRE
	REG = 0;
	TICK(200);			! Tick along a ways
	TICK(200);
	TICK(240);
	TICK3 = 760;			! So far we have done 760 ticks

	REG = 0;			! ?MRE should now occur in 44
	WHILE BEGIN			!   more ticks or so. (Actually 
	      REG101 = RD_101;		!   MRE_TICKS - 760 more ticks)
	      REG = .REG101 AND MMC_REF_ERR;
	      IF .REG EQL 0 AND .TICK3 LSS 4000
		THEN 1 ELSE 0
	      END
	DO BEGIN
	    TICK(4);			! So tick it along
	    TICK3 = .TICK3 + 4;
	    END;

	IF .TICK3 NEQ .MRE_TICKS AND .REG EQL 1
	    THEN BEGIN			! Did ?MRE occur at the right
		 IF .TRY NEQ 2 THEN	!   time? - If no set error flags,
		    LEAVE BLOCK1 WITH 0;!   print message and abort the test.
		 TEST_ABORT = 1;	! If not third try yet - keep trying
		 NOERR_47 = 1;
		 ERRS(5,5,REGV);
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;

	IF .REG EQL 0			! ?MRE did not actually occur again
	    THEN BEGIN			!   at all so set error flags, print
  		 IF .TRY NEQ 2 THEN	!   error message and exit.
		    LEAVE BLOCK1 WITH 0;! If not third try yet - keep trying.
		 TEST_ABORT = 1;
		 NOERR_47 = 1;
		 ERRS(6,6,REGV);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;
	END;

!*MESSAGE 1
!*STIMULUS
!*	Sync T & R Clocks in maintenance mode
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
!*	At this point we should be within 132 ticks of the time the refresh
!*	  error actually occurred
!*RESULTS
!*	After 6600 ticks (1650 T Clocks) a ?MRE still failed to appear

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	Sync T & R Clocks in maintenance mode
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
!*	?MRE did appear after \D0 ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*RESPONSE
!*	?MRE did not clear   8080 Reg 101:  \O1

!]ERROR 2
!] B9  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	Sync T & R Clocks in maintenance mode
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
!*	?MRE did appear after \D0 ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert
!*RESPONSE
!*	No refresh error occurred even after \D2 additional ticks

!]ERROR 3
!] A9 B9 C9  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	Sync T & R Clocks in maintenance mode
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
!*	?MRE did appear after \D0 ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert - it took
!*	  \D2 additional ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*RESPONSE
!*	?MRE did not clear   8080 Reg 101:  \O1

!]ERROR 4
!] B9  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	Sync T & R Clocks in maintenance mode
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
!*	?MRE did appear after \D0 ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert - It took
!*	  \D2 additional ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 640 ticks (160 T Clocks)
!*	Tick T Clock forward 4 ticks (1 T Clock) at a time until a ?MRE
!*	  occurs - It should have taken \D4 ticks since the previous ?MRE
!*RESPONSE
!*	Caused a ?MRE after \D3 ticks - Timing is faulty

!]ERROR 5
!] A9 B9 C9  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	Sync T & R Clocks in maintenance mode
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
!*	?MRE did appear after \D0 ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert - It took
!*	  \D2 additional ticks
!*	Do 60 ticks (15 T Clocks)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
!*	  hang memory controller and cause a memory refresh error
!*	Tick T Clock forward 640 ticks (160 T Clocks)
!*	Tick T Clock forward 4 ticks (1 T Clock) at a time until a ?MRE
!*	  occurs - It should have taken \D4 ticks since the previous ?MRE
!*RESPONSE
!*	No refresh error occurred even after \D3 ticks    REG 101:  \O1

!]ERROR 6
!] A9 B9 C9  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*RESPONSE
!*	TICKS TO SEE ?MRE \D0   REG101 \O1

!]ERROR 7
!]  NTWK
!]NO ERROR 7
!]  NTWK

END;
GLOBAL ROUTINE TST48: NOVALUE =

!++   ------------ TIMING TEST OF REFRESH CYCLE (LENGTH) ------------
! TEST DESCRIPTION:  This routine  verifies that a refresh cycle does
!	not take longer than 750 NS or 5 T Clocks.  This test sets up
!	the  MMC  board  immediately  before the refresh cycle should
!	occur.  Then a Write I/O Status to memory  is  started to set
!	parity error immediately after the refresh cycle is complete.
!	The timing is then verified.
!
! TEST ASSUMPTIONS:  None
!
! TEST PROCEDURE:  Master Reset
!		   SYNC REFRESH - Set up MMC board such that refresh
!			error has just occurred. To do this the clock
!			is also put into Maintenance Mode and synced.
!		   Write data into 8080 Regs - For a write status to
!			turn off ?MRE
!		   Write data to mem location 0 - To keep memory busy
!			past the point where 'REFRESH REQUEST' gets
!			asserted - so that when the write status is
!			begun the memory will not do it for 5 T Clocks
!			while refresh is occurring
!		   Write data into 8080 regs - For a write status to
!			turn on PE
!		   Do a T Clock until 'PE' is detected (by a read of
!			8080 I/O Reg 100)
!		   Verify that the number of T Clocks it took is ok
!
! POSSIBLE ERRORS:  
!
!--

BEGIN

LITERAL
	AFTER = 1,			! Sync after the ?MRE
	EXACT = 0,			! Sync exactly
	CLEAR_MRE = %O'700000000000',
	WRITE_MEM = %O'100000000000',
	WRITE_MSR = %O'500000100000';

OWN
	RETRY,				! Retry flag
	VTICK: INITIAL(86),
	ERR_FLAG,			! Error flag set when error occurs
	REG101,				! 8080 register 101
	MESSV: VECTOR[5];		! Error message data

BIND
	REG102 = MESSV,			! What the error message data
	TICK1 = MESSV[1],		!   consists of
	TICK2 = MESSV[2],
	TICK3 = MESSV[3],
	TICK4 = MESSV[4];

LABEL
	BLOCK1;

IF RUN_TEST(48) THEN RETURN;		! Run this test? Return if no

NOERR_48 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error
RETRY = 0;				! Clear retry count

DO (0) WHILE
BLOCK1:	BEGIN

! Get everything set up - flags and sync the clock and refresh

	MR();				! Master Reset
	WAIT(100);			! Wait 100 msecs
	MR();				! Master Reset
	MR();				! Master Reset
	DEBUG = 0;			! Make sure DEBUG is off
	ERR_FLAG = 0;			! No errors yet
	IF SYNC_REFRESH(EXACT,AFTER)
	    THEN BEGIN
		 IF SYNC_REFRESH(EXACT,AFTER)	! Sync refresh
		    THEN BEGIN
			 ERR_FLAG = 1;	! It failed so set the error flags
			 NOERR_48 = 1;	!   and write out error message
			 ERR(1);
			 END;
		 END;
	IF LOOP_CHK(1)			! Loop on error?
	    THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;	! Did SYNC fail - if so abort test

! Now we are ready to do the test.  First just clear the ?MRE caused by
!   SYNC_REFRESH and give a few ticks to get close to the point where
!   MMC will want to start a refresh cycle.

	WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE
	WRITE_DATA(CLEAR_MRE);
	WRITE_CONTROL();
	TICK(200);			! Tick forward a ways (486 ticks)
	TICK(200);
	TICK(.VTICK);
	TICK1 = 0;

	REG101 = RD_101;		! Make sure we didnt get ?MRE yet
	IF (.REG101 AND MMC_REF_ERR) NEQ 0
	    THEN BEGIN				
		 ERR_FLAG = 1;		! If ?MRE occurred then set
		 TEST_ABORT = 1;	!   error flags, abort all
		 NOERR_48 = 1;		!   future testing and write	
		 ERRS(2,2,REG101);	!   out an error message
		 END;
	IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

! Now write to memory - while this is occurring 'REFRESH REQUEST' will
!   assert but no refresh will occur because the memory is busy.
! Various error conditions may occur along the way at which point the
!   test will be aborted.   These  errors  are mostly that the memory
!   cycle is not progressing as it should.

	WRITE_COMADR(WRITE_MEM);	! Write to memory and just
	WRITE_CONTROL();		!   tick the clock until
	TICK1 = 0;			!   Mem Busy appears in
	DO BEGIN			!   8080 Reg 102
	    TICK(1);
	    REG102 = RD_102;
	    TICK1 = .TICK1 + 1;
	    END
	WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 100;

	IF (.REG102 AND RMEM_BUSY) EQL 0
	    THEN BEGIN			! If Mem Busy never appeared in
		 ERR_FLAG = 1;		!   Reg 102 then abort the test,
		 TEST_ABORT = 1;	!   set error flags, and write
		 NOERR_48 = 1;		!   out an error message
		 ERRS(3,3,MESSV);
		 END;
	IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	TICK2 = 0;			! Now just tick the clock some
	DO BEGIN			!   more until Mem Busy goes
	    TICK(1);			!   away (at that point the
	    REG102 = RD_102;		!   memory cycle would be done).
	    TICK2 = .TICK2 + 1;
	    END
	WHILE (.REG102 AND RMEM_BUSY) NEQ 0 AND .TICK2 LSS 100;

	IF (.REG102 AND RMEM_BUSY) NEQ 0
	    THEN BEGIN			! If Mem Busy never cleared from
		 ERR_FLAG = 1;		!   Reg 102 then set error flags,
		 TEST_ABORT = 1;	!   write out error message and
		 NOERR_48 = 1;		!   abort this test and any others.
		 ERRS(4,4,MESSV);
		 END;
	IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

! Now we are ready to do the test. Just initiate another write to
!   memory and this time it should take longer than  normal since
!   refresh has to complete before the cycle is started.

	TICK(2);			! Give MMC a chance to start the
	WRITE_COMADR(WRITE_MEM);	!   refresh cycle then initiate
	WRITE_CONTROL();		!   another memory write cycle

	TICK3 = 0;			! Tick until Mem Busy appears in
	DO BEGIN			!   Reg 102
	    TICK(1);
	    REG102 = RD_102;
	    TICK3 = .TICK3 + 1;
	    END
	WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK3 LSS 100;

	IF (.REG102 AND RMEM_BUSY) EQL 0
	    THEN BEGIN			! Mem Busy never appeared in Reg 102
		 ERR_FLAG = 1;		!   so set error flags, write out
		 TEST_ABORT = 1;	!   an error message and abort the
		 NOERR_48 = 1;		!   test.
		 ERRS(5,5,MESSV);
		 END;
	IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	TICK4 = 0;			! Now see how long this write
	DO BEGIN			!   takes (until Mem Busy goes
	    TICK(1);			!   away).  It should take
	    REG102 = RD_102;		!   24 ticks.
	    TICK4 = .TICK4 + 1;
	    END
	WHILE (.REG102 AND RMEM_BUSY) NEQ 0 AND .TICK4 LSS 100;

	IF (.REG102 AND RMEM_BUSY) NEQ 0
	    THEN BEGIN			! Mem Busy never cleared - set
		 ERR_FLAG = 1;		!   error flags, write out an
		 TEST_ABORT = 1;	!   error message, and abort
		 NOERR_48 = 1;		!   the test
		 ERRS(6,6,MESSV);
		 END;
	IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
	IF .ERR_FLAG EQL 1 THEN RETURN;

	IF .TICK4 NEQ 24		! If the number of ticks is not 24
	    THEN BEGIN			!   then either refresh never
		 RETRY = .RETRY + 1;
		 IF .RETRY LSS 3 THEN LEAVE BLOCK1 WITH 1;
		 TEST_ABORT = 1;	!   occurred or the timing of it
		 NOERR_48 = 1;		!   or the memory cycle is faulty.
		 ERRS(7,7,MESSV);
		 END;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	Sync T & R Clocks to a point shortly after a ?MRE has
!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller) (To keep refresh from disrupting this test)
!*RESPONSE
!*	Attempt to sync T & R Clocks failed - could not generate a
!*	  refresh error

!]ERROR 1
!] A9 B9 C9 AA AB BB  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*STIMULUS
!*	Sync T & R Clocks to a point immediately after refresh error
!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
!*	  ticks 'MMC9 REFRESH REQ' will assert
!*RESPONSE
!*	'MMC9 REF ERR' did not clear - Write status failed
!*	8080 Reg 101:  \O0

!]ERROR 2
!] B9  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*STIMULUS
!*	Sync T & R Clocks to a point immediately after refresh error
!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
!*	  ticks 'MMC9 REFRESH REQ' will assert
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	  Reg 102 (so that a refresh cycle will occur immediately before
!*	  after 'MEM BUSY' clears and before the next memory write
!*RESPONSE
!*	'MEM BUSY' never appeared in 8080 I/O Reg 102:  \O0
!*	Number of ticks given:  \D1

!]ERROR 3
!]  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*STIMULUS
!*	Sync T & R Clocks to a point immediately after refresh error
!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
!*	  ticks 'MMC9 REFRESH REQ' will assert
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - just to keep
!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	  Reg 102 (so that a refresh cycle will occur immediately before
!*	  after 'MEM BUSY' clears and before the next memory write
!*RESPONSE
!*	'MEM BUSY' appeared in 8080 I/O Reg 102 after \D1 ticks but it was
!*	  never cleared    (8080 I/O Reg 102:  \O0)
!*	Number of ticks given:  \D2  (after 'MEM BUSY' was set)

!]ERROR 4
!]  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*STIMULUS
!*	Sync T & R Clocks to a point immediately after refresh error
!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
!*	  ticks 'MMC9 REFRESH REQ' will assert
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	  Reg 102 (so that a refresh cycle will occur immediately before
!*	  after 'MEM BUSY' clears and before the next memory write
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - It should take
!*	  16 extra ticks (4 T Clocks) since a refresh cycle will be occurring
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	  Reg 102 - Then verify the number of ticks take for the write
!*RESPONSE
!*	'MEM BUSY' never appeared in 8080 I/O Reg 102:  \O0
!*	Number of ticks given:  \D3

!]ERROR 5
!]  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*STIMULUS
!*	Sync T & R Clocks to a point immediately after refresh error
!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 
!*	  ticks 'MMC9 REFRESH REQ' will assert
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	  Reg 102 (so that a refresh cycle will occur immediately before
!*	  after 'MEM BUSY' clears and before the next memory write
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - It should take
!*	  16 extra ticks (4 T Clocks) since a refresh cycle will be occurring
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	  Reg 102 - Then verify the number of ticks take for the write
!*RESPONSE
!*	'MEM BUSY' appeared in 8080 I/O Reg 102 after \D3 ticks but it was
!*	  never cleared    (8080 I/O Reg 102:  \O0)
!*	Number of ticks given:  \D4  (After 'MEM BUSY' was set)

!]ERROR 6
!]  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*STIMULUS
!*	Sync T & R Clocks to a point immediately after refresh error
!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
!*	  memory controller)
!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
!*	  ticks 'MMC9 REFRESH REQ' will assert
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	(A) Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	    Reg 102 (So that a refresh cycle will occur immediately before
!*	    after 'MEM BUSY' clears and before the next memory write
!*	Write 8080 I/O Regs 102..115,210 for a write to mem - It should take
!*	  16 extra ticks (4 T Clocks) since a refresh cycle will be occurring
!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
!*	(B) Tick T Clock until 'MEM BUSY' appears and disappears from 8080
!*	    Reg 102 - Then verify the number of ticks take for the write -
!*	    It should take 24 ticks (6 T Clocks) which is 16 ticks longer
!*	    than normal (600 NS - 4 T Clocks)
!*RESPONSE
!*	'MEM BUSY' was asserted for \D4 ticks instead of 24 ticks
!*	(A) Ticks to appear - \D1    Disappear - \D2
!*	(B) Ticks to appear - \D3    Disappear - \D4

!]ERROR 7
!] A9 B9 C9  NTWK
!]NO ERROR 7
!]  NTWK


END;
GLOBAL ROUTINE TST49: NOVALUE =

!++   -------------- SYNC REFRESH DEBUG ROUTINE -------------------
! TEST DESCRIPTION:  This  routine tests 'SYNC REFRESH' for each of
!	the possible combination of inputs. The test is intended to
!	aid  in  debugging and is left in the module for any future
!	debugging needs.  This test is run by changing the variable
!	'DEBUG1' from a 0 to a 1.  The routine 'SYNC REFRESH'  uses
!	the  variable 'DEBUG'.  If 'DEBUG' is set,  the  particular
!	test calling 'SYNC_REFRESH' will be expected  to supply the
!	text of the error messages used.  If 'DEBUG1' is equal to 0
!	in this test no testing of 'SYNC_REFRESH' will be done.
!
! TEST ASSUMPTIONS:  None
!
! TEST PROCEDURE:  Master Reset
!		   SYNC REFRESH
!		   Write status - turn off ?MRE
!		   Tick 60 times
!		   Write mem - hang mem
!		   Tick clock for the next 1600 ticks (400 T CLOCKS)
!			and watch for 'MEM REF ERR' in Reg 102
!			(stop when ?MRE is seen)
!
!		   Do the above steps for:
!			SYNC_REFRESH(EXACTLY,BEFORE)
!			SYNC_REFRESH(EXACTLY,AFTER)
!			SYNC_REFRESH(APPROX,BEFORE)
!			SYNC_REFRESH(APPROX,AFTER)
!
! POSSIBLE ERRORS:  Sometimes a flaky error may occur and prevent this
!	routine from working successfully.  This  is  sometimes a line
!	problem or maybe a synchronization problem between CSL and the
!	8080.
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000',
	CLEAR_MRE = %O'100000000000',	! Data portion of a write MSR
	HANG_MEM = %O'300000000000';	! Read & Write simultaneously

OWN
	RE_ERR,
	REGV: VECTOR[2];

BIND
	REG = REGV;

LABEL
	BLOCK1;

DO (0)	WHILE
BLOCK1:	BEGIN

	IF .DEBUG1 EQL 0			! Only run this routine if the
	    THEN RETURN 0;			!   DEBUG1 switch is on

	INCR AHOW FROM 0 TO 1 DO		! Do for exact and approximate
	    BEGIN
	    INCR AWHEN FROM 0 TO 1 DO		! Do for ?MRE before and after
		BEGIN
		MR();
		REGV[0] = .AHOW;		! Write out what type of a SYNC
		REGV[1] = .AWHEN;		!   we are going to do
		ERRS(7,7,REGV);
		DEBUG = 1;			! Turn on the DEBUG switch so 
						!   that SYNC will output
		RE_ERR = SYNC_REFRESH(.AHOW,.AWHEN);
		IF .RE_ERR EQL 1		! Did it fail to get ?MRE
		    THEN ERR(10);
		WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE and watch Reg 
		WRITE_DATA(CLEAR_MRE);		!   101 to see when the ?MRE
		WRITE_CONTROL();		!   actually gets cleared.
		INCR TICKN FROM 1 TO 50 DO
		    BEGIN
		    TICK(4);
		    REG = RD_101;
		    REGV[1] = .TICKN * 4;
		    ERRS(8,8,REGV);
		    END;
		WRITE_COMADR(HANG_MEM);		! Now hang mem to cause another
		WRITE_CONTROL();		!   ?MRE and just find out when
		INCR TICKN FROM 1 TO 600 DO	!   the next one occurs so that
		    BEGIN			!   we see where SYNC_REFRESH
		    TICK(4);			!   left us.
		    REG = RD_101;
		    REGV[1] = .TICKN * 4;
		    ERRS(9,9,REGV);
		    IF (.REG AND 1) EQL 1
			THEN EXITLOOP 0;
		    END;
		START_CLK;
		END;
	    END;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*S1:  Number of ticks required to generate ?MRE - \D1   101: \O0

!]ERROR 1
!]  NTWK
!]NO ERROR 1
!]  NTWK

!*MESSAGE 2
!*S2:  After 60 more ticks - 101: \O0

!]ERROR 2
!]  NTWK
!]NO ERROR 2
!]  NTWK

!*MESSAGE 3
!*S3:  Write 'CLEAR ?MRE' data to 8080 regs
!*S3:  Give 60 more ticks - 101: \O0

!]ERROR 3
!]  NTWK
!]NO ERROR 3
!]  NTWK

!*MESSAGE 4
!*S4:  Write 'HANG MEM' data to 8080 regs then tick until ?MRE
!*S4:  Ticks - \D1    101 - \O0

!]ERROR 4
!]  NTWK
!]NO ERROR 4
!]  NTWK

!*MESSAGE 5
!*S5:  Tick 60 then write 'CLEAR ?MRE' data to 8080 regs
!*S5:  Give 60 more ticks - 101: \O0
!*S5:  Give 668 more ticks

!]ERROR 5
!]  NTWK
!]NO ERROR 5
!]  NTWK

!*MESSAGE 6
!*S6:  Write 'HANG MEM' data to 8080 regs then give 280 ticks
!*S6:  101: \O0

!]ERROR 6
!]  NTWK
!]NO ERROR 6
!]  NTWK

!*MESSAGE 7
!*T1:  Call SYNC REFRESH - How \O0   When \O1

!]ERROR 7
!]  NTWK
!]NO ERROR 7
!]  NTWK

!*MESSAGE 8
!*T2:  'CLEAR ?MRE' data written to 8080 regs then clock is ticked
!*T2:  Ticks: \D1    101: \O0

!]ERROR 8
!]  NTWK
!]NO ERROR 8
!]  NTWK

!*MESSAGE 9
!*T3:  'HANG MEM' data written to 8080 regs then clock is ticked
!*T3:  Ticks: \D1    101: \O0

!]ERROR 9
!]  NTWK
!]NO ERROR 9
!]  NTWK

!*MESSAGE 10
!*T4:  SYNC REFRESH returned with failure condition

!]ERROR 10
!]  NTWK
!]NO ERROR 10
!]  NTWK

END;
GLOBAL ROUTINE TST50: NOVALUE =
!++   ------------ REFRESH TEST - IS MEM GETTING REFRESHED ---------
! TEST DESCRIPTION:  This test  verifies that the binary counters on
!	MMC9 are sequencing the refresh address through the range of
!	of addresses properly.
!
! TEST ASSUMPTIONS:  Memory will go away within 45 seconds.
!
! TEST PROCEDURE:  Write '777123456000' to memory locations
!			XXXXX XXXXXXX XXXXXXX
!			17.21 22...28 29...35
!			BOARD --ROW-- --COL--
!			00000 1111111 0000000  (0037600)
!			00000 1111110 0000001  (0077401)
!			00000 1111101 0000010  (0137202)
!			 ...    ...     ...
!			00000 1100000 0011111  (1770037)
!			00000 1011111 0100000  (0027640)
!			00000 1011110 0100001  (0067441)
!			 ...    ...     ...
!			00000 1000000 0111111  (0020077)
!
!		   Also write to mem locations: (if the memory is out there)
!			00000 (BOARD SEL) 00000000000000 (ADDR)
!			00001 (BOARD SEL) 00000000000000 (ADDR)
!			 ...		     ........
!			11111 (BOARD SEL) 00000000000000 (ADDR)
!
!		   Wait 45 seconds - if any of the addresses
!			did not get refreshed they should
!			contain garbage now
!		   Read data back and verify it
!
! POSSIBLE ERRORS:  Binary counters on MMC9 which sequence the refresh
!			address
!		    Address decode logic on MMC8 for board address and
!			word group address
!		    Address decode logic on MMC3 for row/col address
!
!--

BEGIN

LOCAL
	ERR_NUM;

OWN
	ADDR_VECT: VECTOR[96]
	INITIAL(%B'11111110000000',%B'11111100000001',
		%B'11111010000010',%B'11111000000011',
		%B'11110110000100',%B'11110100000101',
		%B'11110010000110',%B'11110000000111',
		%B'11101110001000',%B'11101100001001',
		%B'11101010001010',%B'11101000001011',
		%B'11100110001100',%B'11100100001101',
		%B'11100010001110',%B'11100000001111',
		%B'11011110010000',%B'11011100010001',
		%B'11011010010010',%B'11011000010011',
		%B'11010110010100',%B'11010100010101',
		%B'11010010010110',%B'11010000010111',
		%B'11001110011000',%B'11001100011001',
		%B'11001010011010',%B'11001000011011',
		%B'11000110011100',%B'11000100011101',
		%B'11000010011110',%B'11000000011111',
		%B'10111110100000',%B'10111100100001',
		%B'10111010100010',%B'10111000100011',
		%B'10110110100100',%B'10110100100101',
		%B'10110010100110',%B'10110000100111',
		%B'10101110101000',%B'10101100101001',
		%B'10101010101010',%B'10101000101011',
		%B'10100110101100',%B'10100100101101',
		%B'10100010101110',%B'10100000101111',
		%B'10011110110000',%B'10011100110001',
		%B'10011010110010',%B'10011000110011',
		%B'10010110110100',%B'10010100110101',
		%B'10010010110110',%B'10010000110111',
		%B'10001110111000',%B'10001100111001',
		%B'10001010111010',%B'10001000111011',
		%B'10000110111100',%B'10000100111101',
		%B'10000010111110',%B'10000000111111',

		%B'0000000000000000000',%B'0000100000000000000',
		%B'0001000000000000000',%B'0001100000000000000',
		%B'0010000000000000000',%B'0010100000000000000',
		%B'0011000000000000000',%B'0011100000000000000',
		%B'0100000000000000000',%B'0100100000000000000',
		%B'0101000000000000000',%B'0101100000000000000',
		%B'0110000000000000000',%B'0110100000000000000',
		%B'0111000000000000000',%B'0111100000000000000',
		%B'1000000000000000000',%B'1000100000000000000',
		%B'1001000000000000000',%B'1001100000000000000',
		%B'1010000000000000000',%B'1010100000000000000',
		%B'1011000000000000000',%B'1011100000000000000',
		%B'1100000000000000000',%B'1100100000000000000',
		%B'1101000000000000000',%B'1101100000000000000',
		%B'1110000000000000000',%B'1110100000000000000',
		%B'1111000000000000000',%B'1111100000000000000'),
	MEM_MAP: VECTOR[96],
	MESSV: VECTOR[2],
	READV: VECTOR[96];

LITERAL
	TEST_DATA = %O'777';

LABEL
	BLOCK1;


DO (0) WHILE
	BEGIN
	MR();					! Master Reset
	ERR_NUM = 0;				! Init number of errors gotten
	INCR ADDR FROM 0 TO 95 DO		! Write data to mem but only if
	    BEGIN				!   the memory actually exists
	    IF .ADDR_VECT[.ADDR] LSS .MAX_MEM
		THEN BEGIN
		     MEM_MAP[.ADDR] = 1;	! Set flag for mem exists
		     MEM_DEPOSIT(.ADDR_VECT[.ADDR],TEST_DATA);
		     END
		ELSE MEM_MAP[.ADDR] = 0;	! Set flag indication NONXM
	    READV[.ADDR] = 0;			! Init data read back
	    END;

	SEND_NUL();				! Send out the last deposit
	WAIT(%O'30000000');			! Wait 30..45 seconds

	INCR ADDR FROM 0 TO 95 DO		! Read back each location
	    IF .MEM_MAP[.ADDR] EQL 1		!  - Put data into 'READV'
		THEN READV[.ADDR] = MEM_EXAMINE(.ADDR_VECT[.ADDR]);

	INCR ADDR FROM 0 TO 95 DO		! Verify the data read back
	    BEGIN
	    IF .ERR_NUM GTR 4			! Only print out 5 errors max
		THEN EXITLOOP;
	    MESSV[0] = TEST_DATA;
	    MESSV[1] = .ADDR_VECT[.ADDR];
	    IF (.READV[.ADDR] NEQ TEST_DATA) AND (.MEM_MAP[.ADDR] EQL 1)
		THEN BEGIN
		     ERR_NUM = .ERR_NUM + 1;
		     ERRCAS(1,1,TEST_DATA,.READV[.ADDR],12,MESSV);
		     END
		ELSE NOERR(1);
	    END;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	Write '\U0' to 64 locations
!*	Wait 30-45 seconds
!*	Refresh should be occurring and refreshing each location
!*	    just written to
!*RESPONSE
!*	Data returned incorrect - Location '\U1' not refreshed?

!]ERROR 1
!] A3 B3 C3 D3 B8 C8 D8 E8 F8 G8 H8 C9 BB  NTWK
!]NO ERROR 1
!]  NTWK

END;
GLOBAL ROUTINE TST51: NOVALUE =

!++   ------------ ECC: VERIFICATION OF CHECK BITS --------------
! TEST DESCRIPTION:  This routine verifies some of the ECC logic.
!	In particular it verifies that there are no stuck pins on
!	the parity generators which calculate the check bits sent
!	to memory and recalculate  them  when they come back.  In
!	this test a read error will occur if there are any S1 pins
!	on the inputs to the  parity  generators.  If there is no
!	fault no ECC error will occur.
!
! TEST ASSUMPTIONS:  This test is only done if no errors have
!	occurred so far on Tests 1..50.
!
! TEST PROCEDURE:  Master Reset (Force bits will be set to 0's)
!		   Write 1's to memory
!		   Read data back
!		   Did an ECC error occur?
!
! POSSIBLE ERRORS:  Faulty parity generators on MMC4
!		    
!
!--

BEGIN

LOCAL
	MEM_CORR;

OWN
	MEM_DATA: VECTOR[2],
	MEM_STAT_VECT: BTTVECTOR[36];

BIND
	MEM_DAT = MEM_DATA,
	MEM_STAT = MEM_STAT_VECT;

LABEL
	BLOCK1;

IF RUN_TEST(51) THEN RETURN;		! Run this test? Return if no

NOERR_51 = 0;				! No errors have occurred yet
RPT_ERR_FLAG = 0;			! Don't report unexpected error

DO (0) WHILE
BLOCK1:	BEGIN
	MR();				! Master Reset
	MEM_DEPOSIT(0,-1);		! Write 1's to mem loc 0
	EM(0);				! Read data back
	MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
	IF .MEM_STAT LSS 0		! Did an ECC error occur?
	    THEN BEGIN
		 NOERR_51=1;		! Yes - set error flag and go
		 ERRS(1,1,MEM_STAT);	!   report the error
		 END;
	IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
	0				! To eliminate INFO compiler message
	END;

!*MESSAGE 1
!*STIMULUS
!*	MR		Master Reset
!*	LA 0,DM -1	Write 1's to mem loc 0
!*	EM 0		Read data back (should not cause ECC error)
!*RESPONSE
!*	ECC error occurred / 'MMC5 ERR HOLD' bit 00 set (Mem Stat Reg: \U0 )

!]ERROR 1
!] A4 B4 C4 D4 E4 F4 G4 K4 L4 M4  NTWK
!]NO ERROR 1
!]  NTWK

END;
ROUTINE INIT: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine does a bus RESET.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

WRT100(RESET);				!Assert RESET
WRT100(0);				!Clear RESET
SEND_NUL();

END;
GLOBAL ROUTINE TEST_INIT: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine is executed only once - normally
!	just  before  Test 1 is executed.   However if 'LOOP ON TEST' is
!	specified the routine is done before whatever test is being
!	looped on.
!
! FORMAL PARAMETERS:  none.
!
! IMPLICIT INPUTS:  none.
!
! IMPLICIT OUTPUTS:  none.
!
! ROUTINE VALUE:  novalue.
!
! COMPLETION CODES:  none.
!
! SIDE EFFECTS:  none.
!
!--

BEGIN

MR();					! Do a MASTER RESET
PAR_ENABLE;				! Enable parity checking by 8080

INCR I FROM 0 TO 14 DO			! Initialize run error vector to
	RUN_ERR_VECT[.I] = 0;		!   zeros (run all tests)

END;
GLOBAL ROUTINE RUN_TEST(TEST) =

!++
! FUNCTIONAL DESCRIPTION:   This routine  is  executed at the beginning
!	of every test.  It determines if the  test  should be run based
!	whether prior fatal errors have occurred or not. 'LOOP ON TEST'
!	being set will reset  the error vector ('RUN_ERR_VECT') so that
!	looping  can  occur  regardless  of  what  types of errors have
!	occurred.
!
! FORMAL PARAMETERS:  Test number.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  0 - Run the test
!		  1 - Do not run the test.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  NONE.
!
!--

BEGIN

STRUCTURE
	BLVECTOR[I,J;N,M] = [N*M]	! A real 55 x 15 array like FORTRAN
	(BLVECTOR+I*15+J);

! ERR_MAP contains a mask of RUN_ERR_VECT  for  each test.  When a test
!  is started, the contents of ERR_MAP is compared with the contents of
!  RUN_ERR_VECT.  If any flags  are  set  in  both for the same type of
!  error the test is not run.

OWN
	ERR_MAP: BLVECTOR[55,15]
	    INITIAL(0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST1
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST2
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST3
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST4
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST5
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST6
		    1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,	!TST7
		    1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,	!TST8
		    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST9
		    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST10
		    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST11
		    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST12
		    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST13
		    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST14
		    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST15
		    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST16
		    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST17
		    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST18
		    1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,	!TST19
		    1,1,0,0,1,1,1,1,1,0,1,0,0,0,0,	!TST20
		    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST21
		    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST22
		    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST23
		    0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,	!TST24
		    1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,	!TST25
		    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST26
		    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST27
		    1,1,0,0,1,1,1,1,1,0,1,0,0,0,0,	!TST28
		    1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,	!TST29
		    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST30
		    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST31
		    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST32
		    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST33
		    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST34
		    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST35
		    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST36
		    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST37
		    1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST38
		    0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,	!TST39
		    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST40
		    0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,	!TST41
		    1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,	!TST42
		    1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,	!TST43
		    1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,	!TST44
		    1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,	!TST45
		    0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,	!TST46
		    0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,	!TST47
		    1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,	!TST48
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST49
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST50
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST51
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST52
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST53
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST54
		    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0);	!TST55
!		    ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
!		    ! ! ! ! ! ! ! ! ! ! ! ! Unused
!		    ! ! ! ! ! ! ! ! ! ! ! Bus xcvr
!		    ! ! ! ! ! ! ! ! ! ! ECC single
!		    ! ! ! ! ! ! ! ! ! ECC double
!		    ! ! ! ! ! ! ! ! Test Abort
!		    ! ! ! ! ! ! ! Mem write failed
!		    ! ! ! ! ! ! Mem read failed
!		    ! ! ! ! ! MSR write failed
!		    ! ! ! ! MSR read failed
!		    ! ! ! ?MRE IO would not occur
!		    ! ! ?MRE mem would not occur
!		    ! ?MRE IO occurred when shouldnt have
!		    ?MRE mem occurred when shouldnt have

IF .LPONTST EQL 1			! Are we looping on test?
	THEN BEGIN			!  if yes just zero RUN_ERR_VECT to
	     INCR I FROM 0 TO 14 DO	!    sure that we dont skip the test
		RUN_ERR_VECT[.I] = 0;	!    then return
		RETURN 0;
	     END;
INCR I FROM 0 TO 14 DO			! If not looping on test determine if
	BEGIN				!   this test should be run
	IF .RUN_ERR_VECT[.I] * .ERR_MAP[.TEST,.I] NEQ 0
	    THEN RETURN 1;		! RETURN 1 to abort the test
	END;
RETURN 0;				! RETURN 0 to run the test
END;
GLOBAL ROUTINE SPEC_DIALOGUE: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine inputs special data needed for
!	MMC board testing, namely, the amount of memory which the KS10
!	has.  It takes the  amount  of  memory and calculates a memory
!	mapping (in global vector 'MMA_MAP') which indicates which MMA
!	boards are in the machine.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  This routine will ask for the amount of memory - the
!	program user will be expected to type it in.  This is handled by
!	a call to routine 'MEMSIZE'.
!
! IMPLICIT OUTPUTS:  Global vector 'MMA_MAP' indicates which MMA boards
!	are in the machine.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

LOCAL
	MEM;

MEM = MEMSIZE()/64;			! Find out how much memory is
INCR I FROM 0 TO .MEM-1 DO		!   available
	BEGIN				! Init MMA_MAP to 1 for each
	MMA_MAP[.I] = 1			!   64K chunk of memory
	END;
MAX_MEM = .MEM * 1024 * 64 - 1;		! Calculate maximum amount of memory

END;
GLOBAL ROUTINE SPEC_PRT: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine prints out any special features
!	which may or may not be activated. The MMC testing does not use
!	any additional features so this routine does not do anything at
!	the present time.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN
0
END;


GLOBAL ROUTINE SPEC_ASK: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine asks for any special features
!	which may or may not be desired. The MMC testing does not use
!	any additional  features so this routine does not do anything
!	at the present time.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN
0
END;
ROUTINE WRITE_STATUS (DATA): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine writes status to MEM STAT REG.
!	It is used when the T&R clocks are being single stepped in
!	maintenance mode.
!
! FORMAL PARAMETERS:  .DATA - The 36 bits of data to be written to
!	the MEMORY STATUS REGISTER.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000';

WRITE_COMADR(WRITE_MSR);		! Write com/adr to 8080 regs
WRITE_DATA(.DATA);			! Write data to 8080 regs
WRITE_CONTROL();			! Write control data to 8080 regs

END;
ROUTINE READ_BUS =

!++
! FUNCTIONAL DESCRIPTION:  This routine reads data from the bus.  It looks
!	at the 8080 registers which contain the data that should be on the
!	bus or which has just been latched into the bus tranceivers on the
!	CSL board.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  36 bits of data - What was on the bus as read from
!	8080 I/O Registers 0,1,2,3,103.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

LOCAL
	TEMP,
	BUS_DATA;

TEMP=RD_0;				! Read 8080 register 0
BUS_DATA<0,8> = .TEMP<0,8>;		! Copy 8 bits to result
TEMP=RD_1;				! Read 8080 register 1
BUS_DATA<8,8> = .TEMP<0,8>;		! Copy 8 bits to result
TEMP=RD_2;				! Read 8080 register 2
BUS_DATA<16,8> = .TEMP<0,8>;		! Copy 8 bits to result
TEMP=RD_3;				! Read 8080 register 3
BUS_DATA<24,8> = .TEMP<0,8>;		! Copy 8 bits to result
TEMP=RD_103;				! Read 8080 register 103
BUS_DATA<32,4> = .TEMP<0,4>;		! Copy 4 bits to result

RETURN .BUS_DATA;

END;
ROUTINE HANG_MEM: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine causes a MEM REFRESH ERROR.  It
!	requests memory but for COM/ADR bits it specifies write access.
!	'COM ADR CYCLE' is  set in 8080 REG 115 but 'DATA CYCLE' is not
!	set in 8080 REG 114 so the  memory  controller hangs after half
!	the cycle is complete.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  MMC board is hung.  A refresh error has occurred.
!
!--

BEGIN

WRITE_COMADR(%O'100000000000');		! Specify a write mem of location 0
WRT115(COM_ADR);			! Specify com/adr data out
WRT114(0);				! Do not specify data cycle out
WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);	! Do it - half of it will be done and
					!   MMC will hang because it doesnt
					!   ever get the other half.
SEND_NUL();				! Just make sure that this line gets
					!   sent off to the 8080.
END;
ROUTINE WRITE_COMADR(DATA): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine writes data to 8080 I/O registers
!	103..113 for the COM/ADR portion to a memory access.
!
! FORMAL PARAMETERS:  .DATA - The 36 bits of data to be written to
!	8080 REGISTERS 102,104,106,110,112 for a COM/ADR cycle.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

WRT103(.DATA<0,8>);			! 1st 8 bits
WRT105(.DATA<8,8>);			! 2nd 8 bits
WRT107(.DATA<16,8>);			! 3rd 8 bits
WRT111(.DATA<24,8>);			! 4th 8 bits
WRT113(.DATA<32,4>);			! last 4 bits

END;
ROUTINE WRITE_DATA(DATA): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This  routine  writes  data to 8080 I/O
!	registers 102..112 for the data portion of a memory access.
!
! FORMAL PARAMETERS:  .DATA - The 36 bits of data to be written to
!	8080 registers 103,105,107,111,113 for a data cycle.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

WRT102(.DATA<0,8>);			! 1st 8 bits
WRT104(.DATA<8,8>);			! 2nd 8 bits
WRT106(.DATA<16,8>);			! 3rd 8 bits
WRT110(.DATA<24,8>);			! 4th 8 bits
WRT112(.DATA<32,4>);			! last 4 bits

END;
ROUTINE WRITE_CONTROL: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine writes data to 8080 I/O registers
!	114,115,210 for the cycle control bits portion to a memory access.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

WRT115(COM_ADR);			! Set up COM/ADR part
WRT114(DATA_CYCLE);			! Set up DATA part
WRT210(MEM + BUS_REQ + XMIT_DATA	! Do it (or at least get ready to if
     + XMIT_ADR);			!   the clock is in maintenance mode)

END;
ROUTINE WRITE_CONTROL1: NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:  This routine writes data to 8080 I/O registers
!	115,210 for the cycle control bits portion of a memory read access.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  None.
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  Novalue.
!
! COMPLETION CODES:  None.
!
! SIDE EFFECTS:  None.
!
!--

BEGIN

WRT115(COM_ADR);			! Set up COM/ADR part
WRT210(MEM + BUS_REQ + XMIT_ADR		! Do it (or at least get ready to if
   + LATCH_DATA + CLOSE_LATCH);		!    clock is in maintenance mode)

END;
ROUTINE SYNC_REFRESH(HOW,WHEN) =

!++
! FUNCTIONAL DESCRIPTION:  This routine syncs the  refresh  binary  counter
!	on 'MMC7' to a particular point  depending  on the arguments given.
!	It may be before refresh error is about to occur or it may be after
!	refresh error has just  occurred.  The exactness of the positioning
!	may also be specified.  Some  tests just want to get refresh out of
!	the way so that a memory cycle  will  not  be  delayed by a refresh
!	cycle. Other tests are testing the timing of a refresh cycle so the
!	syncing of the binary counter must be exact.
!
! FORMAL PARAMETERS:  None.
!
! IMPLICIT INPUTS:  How & when the syncing is to occur:
!	How - 0 Exactly
!	      1 Approximate only
!	When - 0 - Before the refresh cycle is to occur
!			(if exact then 3 T clocks before)
!	       1 - After the refresh cycle has just occurred
!			(if exact then exactly after complete)
!
! IMPLICIT OUTPUTS:  None.
!
! ROUTINE VALUE:  0 - Successful syncing of refresh has occurred
!		  1 - Refresh syncing has failed - due to the
!			non-appearance of a MEM REFRESH ERROR
!
! COMPLETION CODES:  Same as routine value.
!
! SIDE EFFECTS:  Causes a refresh error which in effect hangs the
!	the memory controller until the error  is  cleared  via a
!	write  status  or a BUS RESET (or MASTER RESET).  When in
!	this state  and read or write to any memory location will
!	result in a ?NXM since the timer on CSL will time out.
!
!--

BEGIN

LITERAL
	WRITE_MSR = %O'500000100000',	! Write to MSR
	CLEAR_MRE = %O'100000000000',	! Clear ?MRE
	HANG = %O'300000000000';	! Com/adr cycle to hang MMC

OWN
	TICK1,				! Clock tick counter
	TICK2,				! Clock tick counter
	REG,				! Register contents
	REG1,				! Register contents
	REGV: VECTOR[2];		! Error message output vector

LOCAL
	TEMP,
	TRY;				! Number of 132 ticks done to try
					!   to generate a ?MRE
LABEL
	BLOCK1;

DO (0)	WHILE
BLOCK1:	BEGIN
	RPT_ERR_FLAG = 0;		! Don't report unexpected errors

! Tick the clock 132 ticks at a  time  until a ?MRE occurs. This will
!  get us within 132 ticks of a refresh error so we very quickly home
!  in on the section of the refresh cycle we want.
! The ?MRE  should  occur  within 8*132 ticks.  The test tries 20*132
!  ticks at a time up to 4 times. If a ?MRE has still failed to occur
!  then this routine fails and returns with an error condition.

	TICK1 = 0;
	TRY = 0;
	DO  BEGIN
	    IF .TICK1 EQL 0
		THEN BEGIN
		     MR();		! Master RESET
		     DM(0,0);		! Write 0's to mem loc 0 (to init 8080
		     MR();		!   regs to 0's fast) then sync clocks
		     SEND_NUL();
		     SYNC_CLK();	! Put clocks into maintenance mode
		     HANG_MEM();	! Start a mem cycle now that will cause
		     END;		!   MMC to hang and ?MRE to occur.
	    TICK(132);			! Tick 132 times
	    REG1 = RD_101;		! See if a ?MRE has occurred yet
	    REG = .REG1 AND MMC_REF_ERR;
	    TICK1 = .TICK1 + 132;	! Keep track of number of ticks done
	    IF .TICK1 EQL 20*132	! Did we give it 2640 ticks?
		THEN BEGIN		! If so then try again
		     TRY = .TRY + 1;
		     IF .TRY NEQ 4	! But if already 4th try don't reset
			THEN TICK1 = 0;	!   TICK1 - we couldn't get a ?MRE.
		     END;
	    END
	WHILE (.REG EQL 0 AND .TRY LSS 4);

	IF .DEBUG EQL 1			! Are we writing out debug type
	    THEN BEGIN			!   output?  If so write out number
		 REGV[0] = .REG1;	!   of ticks it took to get ?MRE and
		 REGV[1] = .TICK1;	!   the contents of 8080 Reg 101.
		 ERRS(1,1,REGV);
		 END;

	IF (.TICK1 EQL 20*132) OR (.REG EQL 0)! Did we fail to get ?MRE at all?
	    THEN RETURN 1;		! If so - return with 1 (error)

	IF .HOW EQL 1			! Do we want approximate positioning?
	    THEN BEGIN			! If so just give 16 more ticks to
		 TICK(16);		!   make sure we are past the ?MRE
		 RETURN 0;		!   and then return successfully
		 END;

! Now we have to home in on the refresh error more exactly.

	TICK(60);			! Give 60 ticks

	IF .DEBUG EQL 1			! Are we writing out debug type
	    THEN BEGIN			!   output?  If so write out the
		 REG = RD_101;		!   the contents of 8080 Reg 101.
		 ERRS(2,2,REG);
		 END;

	WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE and give another
	WRITE_DATA(CLEAR_MRE);		!   60 ticks
	WRITE_CONTROL();
	TICK(60);

	IF .DEBUG EQL 1			! Are we writing out debug type
	    THEN BEGIN			!   output?  If so write out the
		 REG = RD_101;		!   the contents of 8080 Reg 101.
		 ERRS(3,3,REG);
		 END;

	HANG_MEM();			! Now hang MMC again to cause another
					!   refresh error
	REG = TICK2 = 0;
	DO  BEGIN			! This time give the ticks in blocks
	    TICK(200);			!   of 200 so as to home in on it more
	    REG1 = RD_101;		!   quickly and since we already have
	    REG = .REG1 AND MMC_REF_ERR;!   a good idea of when it will occur
	    TICK2 = .TICK2 + 200;	! We should not quite reach a ?MRE
	    END
	WHILE (.REG EQL 0 AND .TICK2 LSS 600);

	IF .DEBUG EQL 1			! Are we writing out debug type
	    THEN BEGIN			!   output?  If so write out number
		 REGV[0] = .REG1;	!   of ticks it took to get ?MRE and
		 REGV[1] = .TICK2;	!   the contents of 8080 Reg 101.
		 ERRS(4,4,REGV);
		 END;

	IF .REG EQL 1			! Did a ?MRE occur prematurely?
	    THEN RETURN 1;		! If so - return with a 1 (error)

! Now home in on the ?MRE until it occurs by ticking 4 ticks at a time.

	REG = 0;
	DO  BEGIN
	    TICK(4);			! Tick 4 times
	    REG1 = RD_101;		! Find out if ?MRE occurred yet
	    REG = .REG1 AND MMC_REF_ERR;
	    TICK2 = .TICK2 + 4;
	    END
	WHILE (.REG EQL 0 AND .TICK2 LSS 2000);

	IF .DEBUG EQL 1			! Are we writing out debug type
	    THEN BEGIN			!   output?  If so write out number
		 REGV[0] = .REG1;	!   of ticks it took to get ?MRE and
		 REGV[1] = .TICK2;	!   the contents of 8080 Reg 101.
		 ERRS(4,4,REGV);
		 END;

	IF .TICK2 EQL 2000		! Did a ?MRE fail to occur?
	    THEN RETURN 1;		! If so - return with 1 (error)

! At this point we know  exactly where we are on the refresh cycle.  We are
!  at the occurrence of a ?MRE which is 200 T clocks from the next ?MRE and
!  100 T clocks from the next REFRESH REQUEST signal.   Depending  on value
!  of WHEN we may be done.

	IF .WHEN EQL 1			! Did we want to be positioned just
	    THEN RETURN 0;		!   after the ?MRE - if so return

! Now we know exactly when the next ?MRE should occur (in 800 ticks or
!  200 T clocks) so we just  clear  the current ?MRE and write data to
!  8080 regs to cause the  next ?MRE.   Then  just  tick  forward  the
!  remaining number of ticks (less 12 or 3 T clocks).

	TICK(60);			! Get a little room after last ?MRE
	WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE
	WRITE_DATA(CLEAR_MRE);
	WRITE_CONTROL();
	TICK(60);			! Give the clear time to work

	IF .DEBUG EQL 1			! Are we writing out debug type
	    THEN BEGIN			!   output?  If so write out the
		 REG = RD_101;		!   the contents of 8080 Reg 101.
		 ERRS(5,5,REG);
		 END;

	HANG_MEM();			! Now hang the memory controller
	TICK(200);			! And give enough ticks to almost
	TICK(200);			!   get to the next ?MRE
	TICK(200);
	TEMP = .MRE_TICKS - 736;
	TICK(.TEMP);

	IF .DEBUG EQL 1			! Are we writing out debug type
	    THEN BEGIN			!   output?  If so write out the
		 REG = RD_101;		!   the contents of 8080 Reg 101.
		 ERRS(6,6,REG);
		 END;

	RETURN 0;			! All done - return
	END;
0					! To eliminate INFO compiler message
END;
END
ELUDOM
    