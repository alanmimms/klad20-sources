SUBTTL	TEST OF THE ADD INSTRUCTION

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED
;TO ADD A NON-ZERO NUMBER CONTAINED IN E TO AN AC CONTAINING ALL ZEROS,
;THE RESULT IS A NON-ZERO NUMBER IN THE AC.  FIRST, THE AC IS CLEARED;
;THEN, ANON-ZERO POSITIVE NUMBER IS ADDED TO THE AC USING THE ADD 
;INSTRUCTION.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

	A10400:	MOVE	[0]		;PRESET AC TO ALL ZEROS
	ADD	[123456765432]	;*ADD OF A NON-ZERO NUMBER TO AN AC OF ALL
				;ZEROS SHOULD RESULT
				;IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;AD ADD [ADC1], AD ADD EN [ADC1],
;F CYC ACT EN A [F1], AD FM + FETCH EN A [ADFP],
;F CYC ACT EN C[F1], IR ADSUB [IR1], IRXX [IR1]

;**********

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A10500:	MOVE	[123456765432]	;PRESET AC WITH A NON-ZERO NUMBER
	ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC
				;CONTAINING A NON-ZERO NUMBER
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F [E],
;AR AD ET2 EN [ARMA], IR ADSUB [IR1]

;**********
;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A10600:	MOVE	[XWD 123456,0]	;PRESET AC WITH A NON-ZERO NUMBER
	ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
				;A NON-ZERO NUMBER SHOULD RESULT IN AN AC
				;CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;AR AD EN [ARMA], AR AD EN A [ARMA], ET2C F/F[E],
;AR AD ET2 EN [ARMA], IR AD SUB [IR1]

;*********

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD OF ALL ZEROS TO AN AC CONTAINING A NON-ZERO POSITIVE NUMBER, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A NON-ZERO POSITIVE NUMBER; THEN, A WORD OF ALL ZEROS
; IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A10700:	MOVE	[123456]	;PRESET AC WITH A NON-ZERO NUMBER
	ADD	[0]		;*ADD OF A WORD OF ALL ZEROS TO AN AC CONTAINING
				;A NON-ZERO NUMBER
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IS C(AC) IS NON-ZERO
	STOP

;**********
;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A13300:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
	ADD	[123456,,0]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;**********

;THIS TEST VERIFIES THAT WHEN THE ADD INSTRUCTION IS USED TO ADD
;A WORD CONTAINING A NON-ZERO POSITIVE NUMBER TO AN AC OF ALL ZEROS, THE
;RESULT IS A NON-ZERO POSITIVE NUMBER IN THE AC.  FIRST, THE AC IS
;INITIALIZED WITH A WORD OF ALL ZEROS ;THEN, A NON-ZERO POSITIVE NUMBER
;IS ADDED TO THE AC.  THE AC IS THEN CHECKED FOR ITS CONTENTS NON-ZERO

A13400:	MOVE	[0]		;PRESET AC WITH ALL ZEROS
	ADD	[123456]	;*ADD OF A NON-ZERO NUMBER TO AN AC CONTAINING ALL ZEROS
				;SHOULD RESULT IN AN AC CONTAINING A NON-ZERO NUMBER
	SKIPN			;PASS TEST IF C(AC) IS NON-ZERO
	STOP

;**********
;ADD ZERO TO A RIPPLED ONE

SN=11000
	ZZ=0

A11000:	REPEAT	^D36,
<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
;A WORD OF ALL ZEROS IS ADDED TO AN
;AC CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS IN IT ORIGINALLY.
;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
;EVERY BIT OF THE AC.
;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;LOAD AC WITH A FLOATING ONE
	ADD	[0]		;*ADD OF ZERO TO FLOATING ONE
	EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
	EQV	[0]		;RESULTS IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;ADDX; AD AR + EN [ADAP], F CYC ACT EN A[F1],
;IR ADDX [IR1], IR ADSUB [IR1]

;**********
PAGE
>
;THIS TEST VERIFIES THAT THE ADDITION OF A WORD OF 
;ALL ZEROS TO AN AC OF ALL ZEROS RESULTS IN
;C(AC)=0. FIRST THE AC IS CLEARED; THEN, A WORD
;OF ALL ZEROS IS ADDED TO THE AC. THE RESULT IN
;THE AC IS THEN CHECKED TO INSURE THAT C(AC)=0

A11100:	MOVE	[0]		;PRESET AC TO ZERO
	ADD	[0]		;*ADD OF ZERO TO ZERO SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;FCE[F1], IR AD SUB [IR1]
;AD FM + EN [ADFP], AD FM + EN A [ADFP],
;F CYC ACT EN C[F1], IR ADSUB [IR1]

;**********
;ADD ZERO TO A RIPPLED ONE

SN=13200
	ZZ=0

A13200:	REPEAT	^D36,
<;THIS TEST CHECKS THE 'ADD' INSTRUCTION AND THE ADDER ON A 0NE-BIT-AT-A-TIME BASIS.
;TO AN AC  OF ALL ZEROS IS ADDED A
;WORD CONTAINING ALL ZEROS EXCEPT FOR A ONE IN ONE AND ONLY ONE BIT,
;THE RESULT IS THAT THE AC CONTAINS THE SAME NUMBER WHICH WAS ADDED TO IT.
;THE AC IS THEN EQUIVALENCED WITH C(E) WHERE C(E)=C(AC).  THIS RESULT SHOULD
;BE ALL ONES.  NEXT, THE AC IS EQUIVALENCED WITH A WORD OF ALL ZEROS.
;THE FINAL RESULT SHOULD BE C(AC)=0. THIS
;TEST IS REPEATED 36 TIMES SO THAT A ONE MAY BE RIPPLED THOUGH
;EVERY BIT OF THE AC.
;THE AC IS CHECKED TO INSURE THAT IT CONTAINS ALL ZEROS.
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[0]		;LOAD AC WITH ALL ZEROS
	ADD	[ZZ]		;*ADD OF FLOATING ONE TO ZERO
	EQV	[ZZ]		;RESULTS IN C(AC)=ALL ONES
	EQV	[0]		;RESULTS IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
PAGE
;ADD A RIPPLED ONE TO A RIPPLED ONE

SN=11200
	ZZ=0

A11200:	REPEAT	^D35,
<;THIS TEST VERIFIES THAT THE RESULT OF ADDING C(AC)
;TO C(E) WHERE AC IS DIFFERENT FROM E BUT C(AC)=
;C(E)=A ONE IN ONE AND ONLY ONE BIT IS AN
;AC WHOSE CONTENTS IS NON-ZERO. HENCE, IF A
;CARRY IS NOT GENERATED IN THE ADDITION PROCESS THE
;RESULT IN THE AC WILL BE ZERO AND THE TEST
;WILL FAIL. THIS TEST IS REPEATED 35 TIMES
;SO THAT A ONE WILL BE FLOATED THROUGH
;BITS 1 THRU 35 OF BOTH AC AND E
SN=SN+1
	ZZ=ZZ+ZZ
	IFE	ZZ,<ZZ=1>
	MOVE	[ZZ]		;PRESET AC WITH A FLOATING ONE
	ADD	[ZZ]		;*ADD FLOATING ONE TO SAME SHOULD RESULT IN C(AC) NONZERO
	EQV	[ZZ+ZZ]		;RESULTS IN C(AC)=ALL ONES
	EQV	[0]		;RESULTS IN C(AC)=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
SN=11300
	ZZ=0
	YY=0

A11300:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
;36TH POWER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHOUT THE
;ADDER. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MADE EQUAL TO ITS
;FORMER VALUE PLUS THE CURRENT C(AC)
SN=SN+1
	YY=YY/2
	ZZ=ZZ+YY
	IFE	YY,<YY=400000>
	IFE	ZZ,<ZZ=400000>
	MOVE	[XWD ZZ,0]	;PRESET AC TO A RIPPLED ONE STARTING WITH BIT POSITION 0
	ADD	[XWD YY,0]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
				;POWER SHOULD RESULT IN C(AC)=0.
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
>
PAGE
SN=11400
	ZZ=0
	YY=0

A11400:	REPEAT	^D18,
<;THIS TEST VERIFIES THAT THE ADDITION OF TWO NUMBERS WHOSE SUM IS 2 RAISED TO THE
;36TH POSER WILL RESULT IN THE C(AC)=0 SINCE THIS NUMBER IS ONE LARGER
;THAN THE 36 BIT HARDWARE OF THE PROCESSOR IS DESIGNED TO HANDLE. THIS TEST
;ALSO VERIFIES CARRY GENERATION AND PROPAGATION THROUGHT THE
;ADDEC. THIS TEST IS REPEATED 36 TIMES. TESTING BEGINS WITH LOADING THE
;AC WITH 400000000000 AND ADDING THE SAME NUMBER TO IT; THEN,
;CHECKING FOR C(AC)=0. IN THE SUBSEQUENT 35 TESTS, THE NUMBER
;LOADED INTO THE AC IS HALVED EACH TIME AND C(E) IS MODE EQUAL TO ITS
;FORMER VALUE PLUS THE CURRENT C(AC)
SN=SN+1
	YY=YY/2
	ZZ=ZZ+YY
	IFE	YY,<YY=400000>
	IFE	ZZ,<ZZ=400000>	;PRESET AB TO A RIPPLED ONE STARTING WITH BIT POSITION 0
	MOVE	[XWD -1,ZZ]	;*ADD OF TWO NUMBERS TOTALING 2 RAISED TO THE 36TH
				;POWER SHOULD RESULT IN C(AC)=0.
	ADD	[YY]		;PASS TEST IF C(AC)=0
	SKIPE
	STOP

;**********
>
SUBTTL	SPECIAL KI10 FOUR BIT ADDER TEST

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 33 TO BIT 32.

A13500:	MOVE	[-1,,-5]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 33
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 33 TO BIT 32
	EQV	[-1,,-4]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 29 TO BIT 28.

A13600:	MOVE	[-1,,-101]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 29
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 29 TO BIT 28
	EQV	[-1,,-100]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 25 TO BIT 24.

A13700:	MOVE	[-1,,-2001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 25
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 25 TO BIT 24
	EQV	[-1,,-2000]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 21 TO BIT 20.

A14000:	MOVE	[-1,,-40001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 21
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 21 TO BIT 20
	EQV	[-1,,-40000]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 18 TO BIT 17.

A14100:	MOVE	[-1,,-400001]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 18
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 18 TO BIT 17
	EQV	[-1,,400000]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 14 TO BIT 13.

A14200:	MOVE	[-11,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 14
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 14 TO BIT 13
	EQV	[-10,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 10 TO BIT 9.

A14300:	MOVE	[-201,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 10
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 10 TO BIT 9
	EQV	[-200,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 6 TO BIT 5.

A14400:	MOVE	[-4001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 6
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 6 TO BIT 5
	EQV	[-4000,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 2 TO BIT 1.

A14500:	MOVE	[-100001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 2
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 2 TO BIT 1
	EQV	[-100000,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT 1 TO BIT 0.

A14600:	MOVE	[-200001,,-1]	;PRESET AC WITH ALL ONES EXCEPT FOR BIT 1
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT 1 TO BIT 0
	EQV	[600000,,0]	;RESULT IN AC=ALL ONES
	EQV	[0]		;RESULT IN AC=0
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********

;THIS TEST CHECKS THE CARRY FUNCTION FROM THE MOST SIGNIFICANT BIT OF A FOUR
;BIT ADDER TO THE LEAST SIGNIFICANT BIT OF THE NEXT SIGNIFICANT FOUR BIT ADDER.
;SPECIFICALLY, IT IS VERIFIED THAT AN ILLEGAL CARRY DOES NOT OCCUR FROM BIT -1TO BIT 35.

A14700:	MOVE	[-1,,-1]	;PRESET AC WITH ALL ONES
	ADD	[1]		;*ADD SHOULD NOT CAUSE CARRY FROM BIT -1 TO BIT 35
	SKIPE			;PASS TEST IF C(AC)=0
	STOP

;**********
SUBTTL	TEST OF SUB AND COMPARE INSTRUCTIONS

;THIS TEST VERIFIES THAT IF A NON ZERO POSITIVE NUMBER IN E IS
;SUBTRACTED FROM THE AC WHEN C(AC)=0, THE RESULT IN THE AC
;IS NEGATIVE

A11500:	MOVE	[0]		;PRESET AC TO ZERO
	SUB	[XWD 0,-1]	;*SUB OF POSITIVE NONZERO NUMBER FROM AC OF ALL ZEROS
				;SHOULD RESULT IN C(AC) NEGATIVE
	SKIPL			;PASS TEST IF C(AC) IS NEGATIVE
	STOP

;AD AR- EN D [ADAM], F CYC ACT ENB [F1],
;IR SUBX[IR1], IR ADSUB[IR1]

;**********

;THIS TEST VERIFIES THAT IF A WORD OF ALL ZEROS IS
;SUBTRACTED FROM AN AC OF ALL ZEROS, THE RESULT
;IS AN AC OF ZEROS.

A11600:	MOVE	[0]		;PRESET AC TO ZERO
	SUB	[0]		;*SUB OF 0 FROM 0 SHOULD RESULT IN C(AC)=0
	SKIPE			;PASS TEST IF C( THIS TEST PASSES

B12300:	SETZ			;PRELOAD AC WITH 0		
	MOVM	[-1]		;*MOVM SHOULD PLACE 0,,1 INTO THE AC
	CAIE	1		;PASS IF C(AC)=0,,1
	STOP

;*****     FAILURE ANALYSIS     *****
;C(AC0)		C(AC1)		FAILING SIGNAL

;0				FC: AD FM + EN
;0				FC: AD ADD
;0				FC: AD CRY 36
;0				FC: AD AR - EN
;-1,,-1				ET2: AR AD EN

;**********
;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
;IN THIS CASE, C(E)=400000,,0.  HENCE, THE RESULT IN THE AC SHOULD BE
;400000,,0.  THE AC IS CHECKED FOR 400000,,0.
;IF C(AC)=400000,,0, THIS TEST PASSES.

B12400:	SETZ
	MOVM	[XWD 400000,0]	;*MOVM SHOULD PLACE 400000,,0 INTO THE AC
	CAME	[XWD 400000,0]	;PASS IF C(AC)=400000,,0
	STOP

;**********

;THIS TEST VERIFIES THAT MOVM PLACES THE MAGNITUDE OF C(E) INTO THE AC
;IN THIS CASE, C(E)=377777,,-1.  HENCE, THE RESULT IN THE AC SHOULD BE
;377777,,-1.  THE AC IS CHECKED FOR 377777,,-1.
;IF C(AC)=377777,,-1, THIS TEST PASSES.

B12500:	SETZ			;PRELOAD AC WITH 0
	MOVM	[XWD 377777,-1]	;*MOVM SHOULD PLACE 377777,,-1 INTO THE AC
	CAME	[XWD 377777,-1]	;PASS IF C(AC)=377777,,-1
	STOP

;**********
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                