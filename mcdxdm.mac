	SUBTTL	SELECTION SEQUENCE MICRODIAGNOSTIC

DEFTST	MCDXD
TEST	2,TEST TAG OUT STATUS AFTER DX20 RESET
;* TEST THAT DOING A DX20 RESET CLEARS THE TAG OUT LINES.

;* DO A MICROBUS INIT.
;* SET ONLINE AND CHANNEL MODE THEN WAIT 5 MS FOR SEL OUT RELAY TO SETTLE.
;* CHECK THAT ALL TAG OUT LINES ARE RESET.

	JMPSUB	INITL			;DO A MICROBUS INIT
	LDBR	ONLINE+CHANL		;SET ONLINE TO ENABLE DRIVERS/RECEIVERS
	MOVB	CSR1			;AND SET "CHANNEL MODE"
	JMPSUB	WAIT			;WAIT FOR >5 MS AFTER ONLINE
	NOP
	DATI	TOR0,AC0		;READ TAG OUT REG 0
	LDBR	373			;SET MASK OF TAG OUT BITS
	LANDBR	AC0			;CLEAR NON-TAG OUT BITS
	LDMEM	0			;SET EXPECTED DATA
	OSM	AC0			;CHECK FOR CLEARED TAG OUT BITS
	JMPZ	.+2			;JUMP IF ALL CLEARED
	ERRORM	TST,MICROBUS INIT DID NOT CLEAR ALL "TOR0" TAG OUT BITS
	DATI	TOR1,AC0		;READ TAG OUT REG 1
	LDBR	263			;SET MASK OF TAG OUT BITS
	LANDBR	AC0			;CLEAR NON-TAG OUT BIT
	OSM	AC0			;CHECK FOR CLEARED TAG OUT BITS
	JMPZ	.+2			;JUMP IF ALL CLEARED
	ERRORM	TST,MICROBUS INIT DID NOT CLEAR ALL "TOR1" TAG OUT BITS
	REPEAT	TST

TEST	3,TEST TAG IN STATUS AFTER SYSTEM RESET
;*TEST THAT NO DEVICES RESPOND WITH A TAG IN LINE TO "OPL OUT"
;*AFTER A SYSTEM RESET.

;*CLEAR ALL TAG OUT LINES.
;*SET "OPL OUT".
;*CHECK THAT ALL TAG IN LINES ARE CLEARED.

	JMPSUB	CLROUT			;CLEAR ALL TAG OUT LINES
	LDBR	OPLOUT			;SET "OPL OUT"
	MOVB 	TOR1		
	LDBR	200			;SET WAIT COUNT
	MOVB	AC1
TAGWT:	DATI	TAGIN0,AC0		;READ TAG IN REG 0
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF ALL BITS CLEARED
	JMP	TISET			;ELSE, REPORT ERROR
	DATI	TAGIN1,AC0		;READ TAG IN REG 1
	LDBR	360
	LANDBR	AC0			;CLEAR SP ADDR BITS
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF ALL BITS CLEARED
	JMP	TISET			;ELSE, REPORT ERROR
	DECR	AC1			;DEC LOOP CNT
	JMPZ	.+2			;JUMP IF DONE WAITING
	JMP	TAGWT			;ELSE, KEEP WAITING

TISET:	DATI	TAGIN0,AC0		;READ TAG IN REG 0
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF ALL BITS CLEARED
	ERRORM	TST,ALL "TAGIN0" TAG IN BITS DID NOT ALL CLEAR,
DIAG DID A MICROBUS INIT THEN SET "OPL OUT"
	DATI	TAGIN1,AC0		;READ TAG IN REG 1
	LDBR	360
	LANDBR	AC0			;CLEAR SP ADDR BITS
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF ALL BITS CLEARED
	ERRORM	TST,ALL "TAGIN1" TAG IN BITS DID NOT ALL CLEAR,
DIAG DID A MICROBUS INIT THEN SET "OPL OUT"
	REPEAT	TST
TEST	4,TEST "SEL OUT" PROPAGATION
;*CLEAR ALL TAG OUT LINES.
;*SET "OPL OUT", "HLD OUT", THEN "SEL OUT".
;*WAIT FOR "SEL OUT" TO RETURN AS "SEL IN".

	JMPSUB	CLROUT			;CLEAR ALL TAG OUT LINES
	LDBR	OPLOUT			;SET "OPL OUT"
	MOVB	TOR1			
	LDBR	HLDOUT			;SET "HLD OUT"
	MOVB	TOR0		
	LDBR	SELOUT+HLDOUT		;SET "SEL OUT"
	MOVB	TOR0		
	LDBR	200			;SET WAIT COUNT
	MOVB	AC1			
SELWT:	DATI	TAGIN0,BR		;READ TAG IN REG 0
	MOVB	AC0			;SAVE IT IN AC0
	SHR				;RIGHT ADJ "SEL IN"
	JMPB0	SELERR+1		;JUMP IF IT SET
	DECR	AC1			;DEC WAIT COUNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SELWT			;ELSE, KEEP WAITING		
SELERR:	ERROR	TST,"SEL IN" DID NOT RETURN,
<DIAG DID A MICROBUS INIT THEN SET "OPL OUT", "HLD OUT",
AND "SEL OUT" WITH NO ADDRESS REQUESTED.
NO DEVICE SHOULD HAVE STOPPED "SEL OUT" PROPAGATION.>
	LDMEM	SELIN			;SET MASK FOR "SEL IN"
	OSM	AC0			;CHECK THAT ONLY "SEL IN" SET
	JMPZ	.+2			;JUMP IT YES
	ERRORM	TST,MORE THAN JUST "SEL IN" SET,
<DIAG DID A MICROBUS INIT THEN SET "OPL OUT", "HLD OUT",
AND "SEL OUT" WITH NO ADDRESS REQUESTED>
	REPEAT	TST
TEST	5,TEST "OPL IN" RESPONSE TO SELECTION SEQUENCE
;*TEST THAT THE CONTROLLER RESPONDS WITH "OPL IN" TO AN INITIAL SELECTION SEQUENCE.

;*CLEAR ALL TAG OUT LINES.
;*SET "OPL OUT".
;*PUT DEVICE ADDRESS OF 0 ON BUS OUT LINES.
;*SET "ADR OUT", "HLD OUT", THEN "SEL OUT".
;*CHECK FOR SOME RESPONSE ON TAG IN LINES.

	JMPSUB	CLROUT			;CLEAR ALL TAG OUT LINES
	LDBR	OPLOUT			;SET "OPL OUT"
	MOVB	TOR1			
	LDBR	0			;PUT ZERO DEV ADDR ON BUS OUT
	MOVB	BORLO	
	LDBR	ADROUT			;SET "ADDR OUT
	MOVB	TOR0		
	LDBR	HLDOUT+ADROUT		;SET "HLD OUT"
	MOVB	TOR0
	LDBR	SELOUT+HLDOUT+ADROUT	;SET "SEL OUT"
	MOVB	TOR0	
	LDBR	200			;SET WAIT COUNT
	MOVB	AC1			
OPLWT:	DATI	TAGIN0,BR		;READ TAG IN REG 0
	JMPB7	TAGSET			;JUMP IF "OPL IN" SET
	DECR	AC1			;DEC LOOP CNT
	JMPZ	.+2			;JUMP IF TURNED OUT
	JMP	OPLWT			;ELSE, KEEP WAITING
TAGSET:	DATI	TAGIN1,AC0		;READ TAG IN REG 1
	LDBR	360			
	LANDBR	AC0			;CLEAR SP ADDR BITS
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF ALL BITS CLEARED
	ERRORM 	TST,<SOME "TAGIN1" TAG IN LINES SET IN RESPONSE TO INITIAL
SELECTION SEQUENCE>
	DATI	TAGIN0,AC0		;READ TAG IN REG 0
	OSM	AC0			;CHECK FOR ZEROS
	JMPZ	.+2			;JUMP IF ALL BITS CLEARED
	JMP	.+2			;ELSE, CHECK BITS SET
	ERROR	TST,SELECTION SEQUENCE RESULTED IN NO RESPONSE ON TAG IN LINES
;*CHECK THAT NO TAG IN LINES GOT SET OTHER THEN "SEL IN" OR "OPL IN".

	LDBR	MTRIN			;SET "MTR IN" MASK
	LANDB	AC0,MEM			;GET ACTUAL STATE OF "MTR IN" IN MEM
	LDBR	OPLIN			;SET "OPL IN" MASK
	MOVB	AC1
	LORM	AC1,MEM			;SET EXPECTED DATA WITH "OPL IN" SET
	LDBR	0			;SETUP A ZERO REG
	MOVB	AC1
	LDBR	MK0IN!ADRIN!TOHOUT!STAIN ;CHECK FOR WRONG TAG LINES SET
	LANDB	AC0,BR			;CLEAR ALL BUT WRONG BITS
	LORCBR	AC1			;COMPLEMENT BR
	JMPZ	.+2			;JUMP IF ALL WRONG BITS ARE CLEARED
	ERRORM	TST,<SOME "TAGIN0" TAG IN LINES, OTHER THAN "OPL IN" OR "SEL IN",
SET IN RESPONSE TO INITIAL SELECTION SEQUENCE>
	LDBR	OPLIN+SELIN		;SET "OPL IN" AND "SEL IN" MASK
	MOVB	AC1
	LORM	AC1,BR			;SET TEST DATA MASK
	OSB	AC0			;CHECK IF BOTH ARE SET
	JMPZ	.+2			;JUMP IF THEY DID
	JMP	.+2			;ELSE, OKAY
	ERRORM	TST,<BOTH "OPL IN AND "SEL IN" SET SIMULTANEOUSLY IN RESPONSE
TO INITIAL SELECTION SEQUENCE>
	LDBR	MTRIN			;SET "MTR IN" MASK
	MOVB	AC1
	LANDMR	AC1			;GET ACTUAL STATE OF "MTR IN" IN AC1
	LDBR	SELIN			;SET MASK OF "SEL IN"
	LORB	AC1,BR			;SET TEST DATA MASK
	OSB	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF "SEL IN" IS SET, SHOULDN'T BE
	JMP	.+2			;ELSE, OKAY
	ERRORM	TST,<CONTROL UNIT RESPONDED WITH "SEL IN" INSTEAD OF "OPL IN"
DURING INITIAL SELECTION SEQUENCE>
	OSM	AC0			;CHECK FOR "OPL IN" PLUS ACTUAL STATE OF "MTR IN"
	JMPZ	.+2			;JUMP IF OKAY
	ERRORM	TST,<CU RESPONDED WITH "MTR IN" INSTEAD OF "OPL IN"
DURING INITIAL SELECTION SEQUENCE>
	REPEAT	TST

TEST	6,TEST "TEST I/O" COMMAND
;*TEST THAT THE CONTROL UNIT RESPONDS CORRECTLY TO THE "TEST I/O COMMAND" SEQUENCE.

;*CLEAR ALL TAG OUT LINES.
;*SET "OPL OUT".
;*PUT DEVICE ADDRESS 0 ON THE BUS OUT LINES.
;*SET "ADR OUT", "HLD OUT", THEN "SEL OUT".
;*CHECK THAT "OPL IN" SETS.

	JMPSUB	CLROUT			;CLEAR ALL TAG OUT LINES
	LDBR	OPLOUT			;SET "OPL OUT"
	MOVB	TOR1
	LDBR	0			;PUT DEV ADDR 0 ON BUS OUT
	MOVB	BORLO
	LDBR	ADROUT			;SET "ADR OUT"
	MOVB	TOR0		
	LDBR	HLDOUT+ADROUT		;SET "HLD OUT"
	MOVB	TOR0
	LDBR	SELOUT+HLDOUT+ADROUT	;SET "SEL OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1			
	LDMEM	OPLIN			;SET EXPECTED DATA
TIOLP1:	DATI	TAGIN0,AC0		;READ TAG IN BITS
	MOV	AC0,BR
	JMPB7	TIOER1+1		;JUMP IF "OPL IN" SET
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	TIOLP1			;ELSE, KEEP WAITING
TIOER1:	ERRORM	TST,CONTROL UNIT DID NOT RESPOND WITH "OPL IN" DURING 
SELECTION SEQUENCE
;*CLEAR "ADR OUT".
;*CHECK THAT "ADR IN" SETS.

	LDBR	SELOUT+HLDOUT		;CLEAR "ADR OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1			
	LDMEM	ADRIN+OPLIN		;SET EXPECTED DATA
TIOLP2:	DATI	TAGIN0,AC0		;READ TAG IN BITS
	MOV	AC0,BR		
	JMPB4	TIOER2+1		;JUMP IF SET
	DECR	AC1
	JMPZ	.+2
	JMP	TIOLP2
TIOER2:	ERRORM	TST,CONTROL UNIT DID NOT RESPOND WITH "ADR IN" DURING 
SELECTION SEQUENCE
;*CHECK THAT BUS IN LINES CONTAIN ADDRESS REQUESTED(0).

	DATI	CBILO,AC0		;READ BUS IN LINES
	LDMEM	0			;SET EXPECTED DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF BUS IN LINES=0
	ERRORM 	TST,
<CONTROL UNIT RESPONDED WITH "ADR IN" DURING SELECTION SEQUENCE BUT
BUS IN LINES DID NOT EQUAL ADDRESS REQUESTED>
;*CHECK THAT "BUS0 PE FLAG" IS NOT SET.
	DATI	CSR0,AC0		;READ REG0
	MOV	AC0,BR
	SHR				;RIGHT ADJ "BUS0 SE FLAG"
	JMPB0	.+2			;JUMP IF PARITY ERROR
	JMP	.+2			;ELSE, OKAY
	ERRORM	TST,
<CONTROL UNIT CORRECTLY RETURNED ADDRESS ON BUS IN LINES BUT
"BUS0 PARITY ERROR" WAS DETECTED>
;*PUT TEST I-O COMMAND (0) ON BUS OUT LINES.
;*SET "CMD OUT".
;*CHECK THAT "ADR IN" CLEARS.

	LDBR	0			;PUT TEST I/O CMD ON BUS LINES
	MOVB	BORLO
	LDBR	CMDOUT+HLDOUT+SELOUT	;SET "CMD OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1	
	LDMEM	OPLIN			;SET EXPECTED TAG IN
TIOLP3:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB4	.+2			;JUMP IF "ADR IN" STILL SET
	JMP	TIOER3+1		;ELSE, IT DROPPED
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	TIOLP3			;ELSE, KEEP WAITING
TIOER3:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND TO "CMD OUT" BY DROPPING "ADR IN" DURING
SELECTION SEQUENCE. COMMAND WAS "TEST I-O".>
;*CLEAR "CMD OUT".
;*CHECK THAT "STA IN" SETS.

	LDBR	HLDOUT+SELOUT		;CLEAR "CMD OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT.
	MOVB	AC1
	LDMEM	OPLIN+STAIN		;SET EXPECTED DATA
TIOLP4:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB0	TIOER4+1		;JUMP IF "STA IN" SET
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	TIOLP4			;ELSE, KEEP WAITING
TIOER4:	ERRORM	TST,
CONTROL UNIT DID NOT RESPOND WITH "STA IN" TO "TEST I-O" COMMAND
;*SET "SRV OUT".
;*CHECK THAT "STA IN" CLEARS.

	LDBR	SRVOUT+HLDOUT+SELOUT	;SET "SRV OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMEM	OPLIN			;SET EXPECTED DATA
TIOLP5:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB0	.+2			;JUMP IF STILL SET
	JMP	TIOER5+1		;ELSE, CLEARED OKAY
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	TIOLP5			;ELSE, KEEP
TIOER5:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND TO "SRV OUT" BY DROPPING "STA IN"
DURING "TEST I-O" COMMAND>
;*CLEAR "SRV OUT", "HLD OUT", THEN "SEL OUT".
;* CHECK THAT "OPL IN" CLEARS.

	LDBR	HLDOUT+SELOUT		;CLEAR "SRV OUT"
	MOVB	TOR0
	LDBR	SELOUT			;CLEAR "HLD OUT"
	MOVB	TOR0
	LDBR	0			;CLEAR "SEL OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMEM	0			;SET EXPECTED DATA
TIOLP6:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	OSM	AC0			;CHECK FOR ALL ZEROS
	JMPZ	TIOER6+1		;JUMP IF ZEROS
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	TIOLP6			;ELSE, KEEP WAITING
TIOER6:	ERRORM	TST,
CONTROL UNIT DID NOT DROP ALL TAG IN LINES AFTER "TEST I-O" COMMAND
	REPEAT	TST
;*GET DRIVE ADDRESS AND "TESTING-ONE-UNIT" FLAG FROM HOST.

NXTDR:	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	2			;SET CODE FOR HOST
	MOVB	MPECR
	LDBR	ATA			;SET ATTENTION
	JMPSUB	SETATA
	JMPSUB	WAITGO			;WAIT FOR GO TO SET
	JMPSUB	OFFGO			;TURN GO OFF AGAIN
	LDMAR	DRVADR			;SET MEM STORAGE ADDR
	DATI	MPGP10,MEM,I		;STORE DRIVE ADDRESS
	DATI	MPGP11,MEM		;STORE TESTING ONE UNIT FLAG
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
TEST	7,TEST "SENSE" COMMAND
;*TEST THAT THE CONTROL UNIT RESPONDS CORRECTLY TO THE "SENSE COMMAND" SEQUENCE.
;*READ AND CHECK THE 24 SENSE BYTES.

;*CLEAR ALL TAG OUT LINES.
;*SET "OPL OUT".
;*PUT DRIVE ADDRESS ON THE BUS OUT LINES.
;*SET "ADR OUT", "HLD OUT", THEN "SEL OUT".
;* CHECK THAT "OPL IN" SETS.

	LDMAR	SBYTNM			;SET MEM TO SENSE BYTE NUMBER ADDR
	LDMEM	0			;INIT TO ZERO
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	1			;SET ADDITIONAL PNT ROUTINE NUMBER
	MOVB	MPGP6
	MOVMEM	MPGP12			;STORE SENSE BYTE NUMBER FOR PRINTOUT
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	JMPSUB	CLROUT			;CLEAR ALL TAG OUT LINES
	LDBR	OPLOUT			;SET "OPL OUT"
	MOVB	TOR1
	LDMAR	DRVADR			;SET ADDR OF DRIVE ADDR
	MOVMEM	BORLO
	LDMAR	0			;RESET MAR
	LDBR	ADROUT			;SET "ADR OUT"
	MOVB	TOR0		
	LDBR	HLDOUT+ADROUT		;SET "HLD OUT"
	MOVB	TOR0
	LDBR	SELOUT+HLDOUT+ADROUT	;SET "SEL OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1			
	LDMEM	OPLIN			;SET EXPECTED DATA
SNSLP1:	DATI	TAGIN0,AC0		;READ TAG IN BITS
	MOV	AC0,BR
	JMPB7	SNSSET			;JUMP IF "OPL IN" SET
	SHR				;RIGHT ADJUST "SEL IN"
	JMPB0	SNSSET			;JUMP IF SET
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP1			;ELSE, KEEP WAITING
SNSSET:	MOV	AC0,BR			;PUT TAG IN LINES IN BR
	SHR				;RIGHT ADJUST "SEL IN"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	NSELIN			;ELSE, CHECK FOR "OPL IN"
	LDMAR	ONEUNT			;GET FLAG ADDR
	MOVMEM				;CHECK IF ALL ONES
	JMPZ	.+2			;JUMP IF TESTING ONE UNIT
	JMP	NXTDR			;ELSE, GO ASK FOR NEXT DRIVE
NSELIN:	MOV	AC0,BR			;RESTORE TAG IN LINES
	JMPB7	.+2			;JUMP IF "OPL IN" SET
	ERRORM	TST,CONTROL UNIT DID NOT RESPOND WITH "OPL IN" DURING 
SELECTION SEQUENCE
;*CLEAR "ADR OUT".
;*CHECK THAT "ADR IN" SETS.

	LDBR	SELOUT+HLDOUT		;CLEAR "ADR OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1			
	LDMAR	0			;RESET MAR
	LDMEM	ADRIN+OPLIN		;SET EXPECTED DATA
SNSLP2:	DATI	TAGIN0,AC0		;READ TAG IN BITS
	MOV	AC0,BR		
	JMPB4	SNSER2+1		;JUMP IF SET
	DECR	AC1
	JMPZ	.+2
	JMP	SNSLP2
SNSER2:	ERRORM	TST,CONTROL UNIT DID NOT RESPOND WITH "ADR IN" DURING 
SELECTION SEQUENCE
;*CHECK THAT BUS IN LINES CONTAIN ADDRESS REQUESTED(0).

	DATI	CBILO,AC0		;READ BUS IN LINES
	LDMAR	DRVADR			;SET EXPECTED DATA ADDR
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF BUS IN LINES=0
	ERRORM 	TST,
<CONTROL UNIT RESPONDED WITH "ADR IN" DURING SELECTION SEQUENCE BUT
BUS IN LINES DID NOT EQUAL ADDRESS REQUESTED>
;*CHECK THAT "BUS0 PE FLAG" IS NOT SET.
	LDMAR	0			;RESET MAR
	LDMEM	0			;SET EXPECTED DATA
	DATI	CSR0,AC0		;READ REG0
	MOV	AC0,BR
	SHR				;RIGHT ADJ "BUS0 SE FLAG"
	JMPB0	.+2			;JUMP IF PARITY ERROR
	JMP	.+2			;ELSE, OKAY
	ERRORM	TST,
<CONTROL UNIT CORRECTLY RETURNED ADDRESS ON BUS IN LINES BUT
"BUS0 PARITY ERROR" WAS DETECTED>
;*PUT SENSE COMMAND (0) ON BUS OUT LINES.
;*SET "CMD OUT".
;*CHECK THAT "ADR IN" CLEARS.

	LDBR	SENSE			;PUT SENSE CMD ON BUS LINES
	MOVB	BORLO
	LDBR	CMDOUT+HLDOUT+SELOUT	;SET "CMD OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1	
	LDMEM	OPLIN			;SET EXPECTED TAG IN
SNSLP3:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB4	.+2			;JUMP IF "ADR IN" STILL SET
	JMP	SNSER3+1		;ELSE, IT DROPPED
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP3			;ELSE, KEEP WAITING
SNSER3:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND TO "CMD OUT" BY DROPPING "ADR IN"
DURING SELECTION SEQUENCE. COMMAND WAS "SENSE".>
;*CLEAR "CMD OUT".
;*CHECK THAT "STA IN" SETS.

	LDBR	HLDOUT+SELOUT		;CLEAR "CMD OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT.
	MOVB	AC1
	LDMEM	OPLIN+STAIN		;SET EXPECTED DATA
SNSLP4:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB0	SNSER4+1		;JUMP IF "STA IN" SET
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP4			;ELSE, KEEP WAITING
SNSER4:	ERRORM	TST,
CONTROL UNIT DID NOT RESPOND WITH "STA IN" TO "SENSE" COMMAND
;*CHECK THAT INITIAL STATUS IS ZERO.

	LDMEM	0			;SET EXPECTED DATA
	DATI	CBILO,AC0		;READ INITIAL STATUS
	OSM	AC0			;CHECK IT
	JMPZ	.+2			;JUMP IF IT'S ZERO
	ERRORM	TST,
CONTROL UNIT PRESENTED NON-ZERO INITIAL STATUS TO SENSE COMMAND
	DATI	CSR0,AC0		;READ FLAG STATUS
	MOV	AC0,BR
	SHR				;RIGHT ADJUST "BUS0 PE FLAG"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERRORM	TST,
<"BUS0 PE FLAG" SET WITH RECEPTION OF INITIAL STATUS
DURING SENSE COMMAND>
;*SET "SRV OUT".
;*CHECK THAT "STA IN" CLEARS.

	LDBR	SRVOUT+HLDOUT+SELOUT	;SET "SRV OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMEM	OPLIN			;SET EXPECTED DATA
SNSLP5:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB0	.+2			;JUMP IF "STA IN" STILL SET
	JMP	SNSER5+1		;ELSE, CLEARED OKAY
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP5			;ELSE, KEEP
SNSER5:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND TO "SRV OUT" BY DROPPING "STA IN"
DURING "SENSE" COMMAND>
;*CLEAR "SRV OUT".
;*CHECK THAT "SRV IN" SETS.

	LDBR	HLDOUT+SELOUT		;CLEAR "SRV OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMEM	SRVIN			;SET EXPECTED DATA
SNSLP6:	DATI	TAGIN1,AC0		;READ TAG IN LINES
	LDBR	360			;ZERO SP ADR BITS
	LANDBR	AC0
	MOV	AC0,BR
	JMPB7	SNSER6+1		;JUMP IF "SRV IN" SET
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP6			;ELSE, KEEP WAITING
SNSER6:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND WITH "SRV IN" AFTER INITIAL STATUS
DURING SENSE COMMAND>
;*READ AND SAVE THE SENSE BYTE.
;*CHECK THAT "BUS0 PE FLAG" DID NOT SET.

NXTSB:	DATI	CBILO,AC2		;READ SENSE BYTE
	LDMEM	0			;SET EXPECTED
	DATI	CSR0,AC0		;READ FLAG STATUS
	MOV	AC0,BR
	SHR				;RIGHT ADJUST "BUS0 PE FLAG"
	JMPB0	.+2			;JUMP IF IT SET
	JMP	.+2			;ELSE, OKAY
	ERRORM	TST,"BUS0 PE FLAG" SET WITH RECEPTION OF SENSE BYTE,,PNT
;*GO PROCESS THE SENSE BYTE

	MOV	AC2,BR			;SAVE SENSE BYTE IN AC0
	MOVB	AC0
	LDMAR	SBYTNM			;SET ADDR OF SENSE BYTE NUMBER
	MOVMEM	AC4			;GET SENSE BYTE NUMBER
	LDMAR	0			;RESET MAR
	LDBR	SBYTAB&377		;SET BR TO BEGIN OF DISPATCH TABLE
	JMP	@AC4+BR,SBYTAB		;JUMP INTO DISPATCH TABLE

SBYTAB:	JMP	SBYTE0			;BYTE 0
	JMP	SBYTE1			;BYTE 1
	JMP	SBYTEZ			;BYTE 2
	JMP	SBYTE3			;BYTE 3
	JMP	SBYTE4			;BYTE 4
	JMP	SBYTE5			;BYTE 5
	JMP	SBYTE6			;BYTE 6
	JMP	SBYTE7			;BYTE 7
	JMP	SBYTEZ			;BYTE 8
	JMP	SBYTE9			;BYTE 9
	JMP	SBYTEZ			;BYTE 10
	JMP	SBYTEZ			;BYTE 11
	JMP	SBYTEZ			;BYTE 12
	JMP	SBYTER			;BYTE 13
	JMP	SBYTER			;BYTE 14
	JMP	SBYTER			;BYTE 15
	JMP	SBYTER			;BYTE 16
	JMP	SBYTER			;BYTE 17
	JMP	SBYT18			;BYTE 18
	JMP	SBYTEZ			;BYTE 19
	JMP	SBYTER			;BYTE 20
	JMP	SBYTEZ			;BYTE 21
	JMP	SBYTEZ			;BYTE 22
	JMP	SBYT23			;BYTE 23

;*STORE SENSE BYTE AND SET "SRV OUT".
;*CHECK THAT "SRV IN" CLEARS.

SBYTER:	LDMAR	SBYTNM			;SET ADDR OF SENSE BYTE NUMBER
	MOVMEM	AC4
	LDBR	SBYTES			;ADDR OF SENSE BYTE STORAGE
	ADB	AC4,BR			;COMPUTE ADDR TO STORE SENSE BYTE
	MOVB	MAR			;SET THAT ADDR
	MOV	AC0,MEM
	LDBR	SRVOUT+HLDOUT+SELOUT	;SET "SRV OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMAR	0			;RESET MAR
	LDMEM	0			;SET EXPECTED DATA
SNSLP7:	DATI	TAGIN1,AC0		;READ TAG IN LINES
	LDBR	360			;ZERO SP ADR BITS
	LANDBR	AC0
	MOV	AC0,BR
	JMPB7	.+2			;JUMP IF "SRV IN" STILL SET
	JMP	SNSER7+1		;ELSE, CLEARED OKAY
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP7			;ELSE, KEEP
SNSER7:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND TO "SRV OUT" BY DROPPING "SRV IN"
AFTER PRESENTING SENSE BYTE>,,PNT
;*CLEAR "SRV OUT".
;*IF RECEIVED ALL 24 SENSE BYTES, TERMINATE SEQUENCE.
;*ELSE, CHECK THAT "SRV IN" SETS AND CONTINUE RECEIVING BYTES.

	LDBR	HLDOUT+SELOUT		;CLEAR "SRV OUT"
	MOVB	TOR0
	LDMAR	SBYTNM			;SET ADDR OF SENSE BYTE NUMBER
	MOVMEM	AC0			;GET NUM OF BYTES
	INCR	AC0			;INC BYTE CNT
	MOV	AC0,MEM			;STORE NEW BYTE CNT
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	MOVMEM	MPGP12			;STORE BYTE CNT FOR PRINTOUT
	LDBR	33			;SELECT CHANNEL BUS INTERFACE
	MOVB	IOSEL
	LDMAR	0			;CLEAR MAR
	LDBR	^D24			;SET COMPARE CNT
	OSB	AC0			;CHECK IF RECEIVED 24 BYTES
	JMPZ	BYTDON			;JUMP IF YES
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMEM	SRVIN			;SET EXPECTED DATA
SNSLP8:	DATI	TAGIN1,AC0		;READ TAG IN LINES
	LDBR	360			;ZERO SP ADR BITS
	LANDBR	AC0
	MOV	AC0,BR
	JMPB7	SNSER8+1		;JUMP IF "SRV IN" SET
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP8			;ELSE, KEEP WAITING
SNSER8:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND WITH "SRV IN" WITH SENSE BYTE
DURING SENSE COMMAND>,,PNT
	JMP	NXTSB			;GO GET NEXT SENSE BYTE

;*TERMINATE THE SENSE COMMAND SEQUENCE.
;*CHECK THAT "STA IN" SET IN RESPONSE TO LAST "SRV OUT" CLEARING.

BYTDON:	LDBR	200			;SET WAIT CNT.
	MOVB	AC1
	LDMEM	OPLIN+STAIN		;SET EXPECTED DATA
SNSLP9:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB0	SNSER9+1		;JUMP IF "STA IN" SET
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLP9			;ELSE, KEEP WAITING
SNSER9:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND WITH "STA IN" IN PRESENTING ENDING
STATUS AT THE END OF A SENSE COMMAND>
;*SET "SRV OUT".
;*CHECK THAT "STA IN" CLEARS.

	LDBR	SRVOUT+HLDOUT+SELOUT	;SET "SRV OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMEM	OPLIN			;SET EXPECTED DATA
SNSLPX:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	MOV	AC0,BR
	JMPB0	.+2			;JUMP IF "STA IN" STILL SET
	JMP	SNSERX+1		;ELSE, CLEARED OKAY
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLPX			;ELSE, KEEP
SNSERX:	ERRORM	TST,
<CONTROL UNIT DID NOT RESPOND TO "SRV OUT" BY DROPPING "STA IN" AFTER
PRESENTING ENDING STATUS IN SENSE COMMAND>
;*CLEAR "SRV OUT", "HLD OUT", THEN "SEL OUT".
;* CHECK THAT "OPL IN" CLEARS.

	LDBR	HLDOUT+SELOUT		;CLEAR "SRV OUT"
	MOVB	TOR0
	LDBR	SELOUT			;CLEAR "HLD OUT"
	MOVB	TOR0
	LDBR	0			;CLEAR "SEL OUT"
	MOVB	TOR0
	LDBR	200			;SET WAIT CNT
	MOVB	AC1
	LDMEM	0			;SET EXPECTED DATA
SNSLPY:	DATI	TAGIN0,AC0		;READ TAG IN LINES
	OSM	AC0			;CHECK FOR ALL ZEROS
	JMPZ	SNSERY+1		;JUMP IF ZEROS
	DECR	AC1			;DEC WAIT CNT
	JMPZ	.+2			;JUMP IF TIMED OUT
	JMP	SNSLPY			;ELSE, KEEP WAITING
SNSERY:	ERRORM	TST,
CONTROL UNIT DID NOT DROP ALL TAG IN LINES AFTER "SENSE" COMMAND
	REPEAT	TST
;SEND THE SENSE BYTES TO THE HOST.
	LDBR	11			;SELECT MASSBUS INTERFACE
	MOVB	IOSEL
	LDBR	1			;SET CODE FOR HOST
	MOVB	MPECR
	LDBR	0			;CLEAR CONTROL BITS
	MOVB	MPGP2
	LDMAR	SBYTES			;SET ADDR OF SENSE BYTES
	MOVMEM	MPGP5,I			;STORE SENSE BYTES FOR HOST
	MOVMEM	MPGP4,I
	MOVMEM	MPGP7,I
	MOVMEM	MPGP6,I
	MOVMEM	MPGP11,I
	MOVMEM	MPGP10,I
	MOVMEM	MPGP13,I
	MOVMEM	MPGP12,I
	MOVMEM	MPGP15,I
	MOVMEM	MPGP14,I
	MOVMEM	MPGP17,I
	MOVMEM	MPGP16,I
	LDBR	ATA
	JMPSUB	SETATA			;GO SET ATTEN
	LDBR	1			;SET LOOP CNT MINUS 1
	MOVB	AC0
SNSND:	DATI	MPGP2,BR		;READ CONTROL BIT REG
	JMPB0	.+2			;JUMP IF HOST SET DATA ACCEPTED BIT
	JMP	.-2			;ELSE, KEEP WAITING
	DECR	AC0			;DEC BYTE COUNT
	JMPZ	SNDONE			;JUMP IF SENT ALL DATA
	MOVMEM	MPGP5,I			;STORE SENSE BYTES FOR HOST
	MOVMEM	MPGP4,I
	MOVMEM	MPGP7,I
	MOVMEM	MPGP6,I
	MOVMEM	MPGP11,I
	MOVMEM	MPGP10,I
	MOVMEM	MPGP13,I
	MOVMEM	MPGP12,I
	MOVMEM	MPGP15,I
	MOVMEM	MPGP14,I
	MOVMEM	MPGP17,I
	MOVMEM	MPGP16
	LDBR	0			;CLEAR ACCEPT BIT TO SIGNAL HOST
	MOVB	MPGP2			;THAT MORE DATA IS AVAILABLE
	JMP	SNSND			;GO WAIT FOR HOST TO ACCEPT

SNDONE:	LDBR	2			;CLEAR ACCEPT BIT AND SET DONE BIT
	MOVB	MPGP2			;TO SIGNAL HOST
	JMPSUB	WAITGO			;WAIT FOR GO TO SET
	JMPSUB	OFFGO			;TURN GO OFF AGAIN
	JMP	END
SBYTEZ:	LDMEM	0			;SET EXPECTED DATA=0
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF SENSE BYTE=0
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYTE0:	LDMEM	0			;SET EXPECTED DATA
	OSM	AC0			;CHECK FOR ZERO STATUS
	JMPZ	SB0ER+1			;JUMP IF ZERO STATUS
	LDMAR	ONEUNT			;GET TESTING ONE UNIT FLAG
	MOVMEM
	JMPZ	.+2			;JUMP IF TESTING ONE UNIT
	JMP	NXTDR			;ELSE, GO ASK FOR NEXT DRIVE ADDR
	LDMAR	0			;RESET MAR
SB0ER:	ERRORM	TST,ERROR BIT(S) ARE SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYTE1:	LDBR	TUSTA			;SET "TU STATUS A" IN EXPECTED DATA
	LORB	AC0,MEM
	SHL	AC0,BR			;LEFT ADJUST "TU STATUS A" BIT
	JMPB7	SB1ER+1			;JUMP IF IT IS SET
	LDMAR	ONEUNT			;GET TESTING ONE UNIT FLAG
	MOVMEM
	JMPZ	.+2			;JUMP IF TESTING ONE UNIT
	JMP	NXTDR			;ELSE, GO ASK FOR NEXT DRIVE ADDR
	LDMAR	0			;RESET MAR
SB1ER:	ERRORM	TST,"TU STATUS A" BIT IS NOT SET IN SENSE BYTE,,PNT
	LDBR	375			;CLEAR "FILE PROT" BIT IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	SB1ER2+1		;JUMP IF "FILE PROT" IS CLEARED
	LDMAR	ONEUNT			;GET TESTING ONE UNIT FLAG
	MOVMEM
	JMPZ	.+2			;JUMP IF TESTING ONE UNIT
	JMP	NXTDR			;ELSE, GO ASK FOR NEXT DRIVE ADDR
	LDMAR	0			;RESET MAR
SB1ER2:	ERRORM	TST,"FILE PROTECTED" BIT IS SET IN SENSE BYTE,,PNT
	LDBR	134			;CLEAR "TU STATUS B", NOISE, AND NOT CAP
	LANDB	AC0,MEM			;IN EXPECTED DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL BITS CLEARED
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYTE3:	LDBR	6			;CLEAR ERROR BITS IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL ERROR BITS CLEAR
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYTE4:	LDBR	40			;CLEAR ERROR BITS IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL ERROR BITS CLEAR
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYTE5:	LDBR	100			;CLEAR ERROR BITS IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL ERROR BITS CLEAR
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	LDBR	NEWSUB			;SET "NEW SUBSYSTEM" BIT IN EXPECTED DATA
	LORB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF IT IS SET
	ERRORM	TST,"NEW SUBSYSTEM" BIT IS NOT SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYTE6:	LDBR	370			;CLEAR TU MODEL BITS
	LANDB	AC0,BR
	MOVB	AC1			;PUT RESULT IN AC1
	LDBR	4			;SET TU MODEL BITS=4 IN
	LORB	AC1,MEM			;EXPECTED DATA
	OSM	AC0			;COMPARE
	JMPZ	SB6ER+1			;JUMP IF TU MODEL BITS=4
	LDBR	5			;SET TU MODEL BITS=5 IN
	LORB	AC1,MEM			;EXPECTED DATA
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF TU MODEL BITS=5
SB6ER:	ERRORM	TST,TAPE UNIT MODEL IDENTIFICATION IS NOT 4 OR 5,,PNT
	JMP	SBYTER

SBYTE7:	LDBR	20			;CLEAR ERROR BITS IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL ERROR BITS CLEAR
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYTE9:	LDBR	10			;CLEAR ERROR BITS IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL ERROR BITS CLEAR
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYT18:	LDBR	17			;CLEAR ERROR BITS IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL ERROR BITS CLEAR
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

SBYT23:	LDBR	200			;CLEAR ERROR BITS IN EXPECTED DATA
	LANDB	AC0,MEM
	OSM	AC0			;COMPARE
	JMPZ	.+2			;JUMP IF ALL ERROR BITS CLEAR
	ERRORM	TST,ERROR BIT(S) SET IN SENSE BYTE,,PNT
	JMP	SBYTER

INITL:	LDBR	INIT			;DO MICROBUS INIT
	MOVB	IOSEL
	LDBR	33			;SELECT CHAN BUS AND CLEAR INIT
	MOVB	IOSEL
CLRMEM:	LDMAR	0
	LDMARX	0
	LDMEM	0
	RETURN

WAIT:	LDBR	^D30			;SET OUTER LOOP WAIT COUNT
	MOVB	AC0
WAITO:	LDBR	^D207			;SET INNER LOOP WAIT COUNT
	MOVB	AC1
WAITI:	DECR	AC1			;DEC INNER LOOP COUNT
	JMPZ	.+2			;JUMP IF INNER LOOP TIMED OUT
	JMP	WAITI			;ELSE, CONTINUE
	DECR	AC0			;DEC OUTER LOOP COUNT
	JMPZ	.+2			;JUMP IF OUTER LOOP TIMED OUT
	JMP	WAITO			;ELSE CONTINUE
	RETURN

CLROUT:	LDBR	0			;CLEAR TAG OUT LINES
	MOVB	TOR0
	MOVB	TOR1
	LDBR	20			;SET WAIT CNT
	MOVB	AC0
	DECR	AC0			;DEC WAIT CNT
	JMPZ	.-1			;KEEP WAITING
	JMP	CLRMEM
END:	.ECRAM
	.MEM
	0
DRVADR:	0				;DRIVE ADDR STORAGE
ONEUNT:	0				;TESTING ONE UNIT FLAG
SBYTNM:	0				;SENSE BYTE NUMBER
SBYTES:	0				;SENSE BYTE 0
	0				;SENSE BYTE 1
	0				;SENSE BYTE 2
	0				;SENSE BYTE 3
	0				;SENSE BYTE 4
	0				;SENSE BYTE 5
	0				;SENSE BYTE 6
	0				;SENSE BYTE 7
	0				;SENSE BYTE 8
	0				;SENSE BYTE 9
	0				;SENSE BYTE 10
	0				;SENSE BYTE 11
	0				;SENSE BYTE 12
	0				;SENSE BYTE 13
	0				;SENSE BYTE 14
	0				;SENSE BYTE 15
	0				;SENSE BYTE 16
	0				;SENSE BYTE 17
	0				;SENSE BYTE 18
	0				;SENSE BYTE 19
	0				;SENSE BYTE 20
	0				;SENSE BYTE 21
	0				;SENSE BYTE 22
	0				;SENSE BYTE 23
.END
