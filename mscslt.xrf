   1	%TITLE 'STIRS TESTS FOR M8616 (CSL) BOARD'
   2	
   3	MODULE MSCSLT	(
   4			LANGUAGE(BLISS36)
   5			) =
   6	
   7	BEGIN
   8	
   9	!
  10	!			  COPYRIGHT (C) 1979 BY
  11	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
  12	!
  13	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
  14	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
  15	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
  16	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
  17	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
  18	! TRANSFERRED.
  19	!
  20	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
  21	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
  22	! CORPORATION.
  23	!
  24	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
  25	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
  26	!
  27	
  28	!++
  29	! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
  30	!
  31	! ABSTRACT:
  32	!
  33	!	THIS MODULE CONTAINS THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
  34	!	(STIRS) DIAGNOSTIC FOR THE M8616 (CSL) BOARD.  IT ALSO CONTAINS SEVERAL
  35	!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
  36	!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
  37	!	'MSCSLD' MODULES TO PRODUCE THE 'MSCSL.EXE' FILE.
  38	!
  39	! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
  40	!
  41	! AUTHOR: RICH MURATORI	, CREATION DATE: 23-MAY-79
  42	!
  43	! MODIFIED BY:
  44	!
  45	!	RICH MURATORI, 23-MAY-79; VERSION 0.1
  46	!--
  47	!
  48	! TABLE OF CONTENTS:
  49	!
  50	
  51	FORWARD ROUTINE
  52		SPEC_DIALOGUE: NOVALUE,		!SPECIAL USER DIALOGUE
  53		SPEC_PRT,			!SPECIAL FEATURE PRINTING
  54		SPEC_ASK: NOVALUE,		!SPECIAL FEATURE QUESTIONS
  55		TEST_INIT: NOVALUE,		!INITIALIZATION ROUTINE
  56		CLEAR_CRAM: NOVALUE,		!CLEAR CRAM BITS IN CRAM LOC 0
  57		RESET_CRAM: NOVALUE,		!DO A 'CRA/M RESET'
  58		INIT : NOVALUE,			!DO A KS10 'RESET'
  59		ERR_CHK_4 : NOVALUE,		!CHECK 4-BIT DATA
  60		ERR_CHK_8 : NOVALUE,		!CHECK 8-BIT DATA
  61		TST1 : NOVALUE,			!TOGGLE 'RESET'
  62		TST2 : NOVALUE,			!TOGGLE 'BUS REQ' WITH CLOCK STOPPED
  63		TST3 : NOVALUE,			!'GRANT' NEGATING 'BUS REQ'
  64		TST4 : NOVALUE,			!'NEXM' GENERATION
  65		TST5 : NOVALUE,			!'GRANT' STUCK TOGGLING
  66		TST6 : NOVALUE,			!'NEXM' NOT ASSERTING WITH 'MEM' NEGATED
  67		TST7 : NOVALUE,			!TOGGLE 'R CLK ENB'
  68		TST8 : NOVALUE,			!SINGLE PULSING MAINT CLOCK
  69		TST9 : NOVALUE,			!RESETTING 'CLOSE LATCHS'
  70		TST10 : NOVALUE,		!'R CLK ENB' ASSERTION
  71		TST11 : NOVALUE,		!'R CLK ENB' NEGATION
  72		TST12 : NOVALUE,		!'R CLK ENB' NEGATION
  73		TST13 : NOVALUE,		!'LATCH DATA ENB (1)' NEGATION
  74		TST14 : NOVALUE,		!'BUS REQ' ASSERTING 'R CLK ENB'
  75		TST15 : NOVALUE,		!SINGLE PULSING CPU CLOCKS
  76		TST16 : NOVALUE,		!TURNING OFF CPU CLOCKING
  77		TST17 : NOVALUE,		!KS10 BUS CONTROL SIGNALS (COM/ADR LOCS)
  78		TST18 : NOVALUE,		!KS10 BUS CONTROL SIGNALS (DATA LOCS)
  79		TST19 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
  80		TST20 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
  81		TST21 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
  82		TST22 : NOVALUE,		!'DATA ACK' AND 'R CLK ENB'
  83		TST23 : NOVALUE,		!'DATA ACK'
  84		TST24 : NOVALUE,		!BUS DATA 00-03 (COM/ADR LOCS)
  85		TST25 : NOVALUE,		!BUS DATA 00-03 (DATA LOCS)
  86		TST26 : NOVALUE,		!BUS DATA 04-11 (COM/ADR LOCS)
  87		TST27 : NOVALUE,		!BUS DATA 04-11 (DATA LOCS)
  88		TST28 : NOVALUE,		!BUS DATA 12-19 (COM/ADR LOCS)
  89		TST29 : NOVALUE,		!BUS DATA 12-19 (DATA LOCS)
  90		TST30 : NOVALUE,		!BUS DATA 20-27 (COM/ADR LOCS)
  91		TST31 : NOVALUE,		!BUS DATA 20-27 (DATA LOCS)
  92		TST32 : NOVALUE,		!BUS DATA 28-35 (COM/ADR LOCS)
  93		TST33 : NOVALUE,		!BUS DATA 28-35 (DATA LOCS)
  94		TST34 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
  95		TST35 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
  96		TST36 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
  97		TST37 : NOVALUE,		!TRANSCEIVER XMIT CONTROL SIGNALS
  98		TST38 : NOVALUE,		!'STATUS RD (1)'
  99		TST39 : NOVALUE,		!'STATUS RD (1)'
 100		TST40 : NOVALUE,		!'STATUS RD (1)'
 101		TST41 : NOVALUE,		!'STATUS RD (1)'
 102		TST42 : NOVALUE,		!'STATUS RD (1)'
 103		TST43 : NOVALUE,		!'STATUS RD (1)'
 104		TST44 : NOVALUE,		!'STATUS RD (1)'
 105		TST45 : NOVALUE,		!'STATUS RD (1)'
 106		TST46 : NOVALUE,		!'STATUS RD (1)'
 107		TST47 : NOVALUE,		!CLOCKING DATA TO/FROM CRA BOARD
 108		TST48 : NOVALUE,		!'CRA R CLK\#20\' SIGNAL
 109		TST49 : NOVALUE,		!'CRA T CLK ENABLE' SIGNAL
 110		TST50 : NOVALUE,		!WRITING TO CRAM
 111		TST51 : NOVALUE,		!WRITING AND READING CRAM BITS 12-23
 112		TST52 : NOVALUE,		!WRITING AND READING CRAM BITS 24-35
 113		TST53 : NOVALUE,		!'CRA/M RESET' SIGNAL
 114		TST54 : NOVALUE,		!'CRAM WRITE' SIGNAL
 115		TST55 : NOVALUE,		!'CRAM ADR LOAD' SIGNAL
 116		TST56 : NOVALUE,		!RESETTING 'CRAM ADR LOAD'
 117		TST57 : NOVALUE,		!'HALT LOOP (1)' GENERATION
 118		TST58 : NOVALUE,		!'HALT LOOP (1)' GENERATION
 119		TST59 : NOVALUE,		!'HALT LOOP (1)' GENERATION
 120		TST60 : NOVALUE,		!'HALT LOOP (1)' GENERATION
 121		TST61 : NOVALUE,		!'HALT LOOP (1)' GENERATION
 122		TST62 : NOVALUE,		!'HALT LOOP (1)' GENERATION
 123		TST63 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
 124		TST64 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
 125		TST65 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
 126		TST66 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
 127		TST67 : NOVALUE,		!'RUN', 'EXECUTE' AND 'CONTINUE'
 128		TST68 : NOVALUE,		!KS10 BUS PARITY GENERATION
 129		TST69 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
 130		TST70 : NOVALUE,		!RESETTING 'CLK RUN'
 131		TST71 : NOVALUE,		!RESETTING 'CLK RUN'
 132		TST72 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
 133		TST73 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
 134		TST74 : NOVALUE,		!CPU CLOCKING WITH 'CLK RUN'
 135		TST75 : NOVALUE,		!'PE (1)' GENERATION
 136		TST76 : NOVALUE,		!'PE (1)' GENERATION
 137		TST77 : NOVALUE,		!'PE (1)' GENERATION
 138		TST78 : NOVALUE,		!'PE (1)' GENERATION
 139		TST79 : NOVALUE,		!'PE (1)' GENERATION
 140		TST80 : NOVALUE,		!'PE (1)' GENERATION
 141		TST81 : NOVALUE,		!'PE (1)' GENERATION
 142		TST82 : NOVALUE,		!'PE (1)' GENERATION
 143		TST83 : NOVALUE,		!CPU CLOCKING WITH 'PE (1)' ASSERTED
 144		TST84 : NOVALUE,		!KS10 BUS PARITY DETECTION
 145		TST85 : NOVALUE,		!PARITY ERROR LATCHES
 146		TST86 : NOVALUE,		!MEMORY PARITY ERROR
 147		TST87 : NOVALUE,		!TOGGLING '10 INT'
 148		TST88 : NOVALUE,		!ASSERTING '10 INT'
 149		TST89 : NOVALUE,		!FAST SHIFTING CONTROL LOGIC
 150		TST90 : NOVALUE,		!FAST SHIFTING CONTROL LOGIC
 151		TST91 : NOVALUE,		!FAST SHIFTING CONTROL LOGIC
 152		TST92 : NOVALUE,		!NO 'NEXM' ON 'EM' COMMAND
 153		TST93 : NOVALUE,		!TOGGLING 'INT 10'
 154		TST94 : NOVALUE,		!RESETTING 'INT 10' CONTROL LOGIC
 155		TST95 : NOVALUE,		!RESETTING 'INT 10' CONTROL LOGIC
 156		TST96 : NOVALUE,		!CPU CLOCKING WITH 'PAGE FAIL'
 157		TST97 : NOVALUE,		!'TRAP EN' ASSERTION
 158		TST98 : NOVALUE,		!'EXECUTE' SIGNAL ON CRA BOARD
 159		TST99 : NOVALUE,		!'CONTINUE' SIGNAL ON CRA BOARD
 160		TST100 : NOVALUE,		!'1 MSEC EN' TOGGLING
 161		TST101 : NOVALUE,		!'STACK RESET' SIGNAL
 162		TST102 : NOVALUE;		!CPU CLOCKING DURING MEMORY READ
 163	
 164	!
 165	! INCLUDE FILES:
 166	!
 167	
 168	REQUIRE 'REGBIT.R36';				!8080 I/O REGISTER BIT DEFINITIONS
 169	
 170	!
 171	!			  COPYRIGHT (c) 1977, 1978 BY
 172	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 173	!
 174	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 175	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 176	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 177	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 178	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 179	! TRANSFERRED.
 180	!
 181	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 182	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 183	! CORPORATION.
 184	!
 185	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 186	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 187	!
 188	
 189	!++
 190	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 191	!
 192	! ABSTRACT:
 193	!
 194	!	THIS FILE CONTAINS SYMBOLIC BIT DEFINITIONS FOR THE KS10 8080 I/O
 195	!	REGISTERS.  IT IS USED AS A 'REQUIRE' FILE FOR THE STIRS DIAGNOSTICS.
 196	!
 197	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 198	!
 199	! AUTHOR:  RICH MURATORI	, CREATION DATE:  3-JAN-79
 200	!
 201	! MODIFIED BY:
 202	!
 203	!  RICH MURATORI, 3-JAN-79 : VERSION 0.1
 204	!--
 205	
 206	LITERAL
 207	
 208	!WRITE REGISTER 100
 209	
 210		FORCE_PAR	= 1^1,		!FORCE PARITY RIGHT
 211		EN_1MS		= 1^2,		!1 MSEC ENABLE
 212		CACHE_ENB	= 1^3,		!CACHE ENABLE
 213		DP_PE_DET	= 1^4,		!DP PE DETECT
 214		CRM_PE_DET	= 1^5,		!CRM PE DETECT
 215		PE_DET_ENB	= 1^6,		!PE DETECT ENABLE
 216		RESET		= 1^7,		!RESET
 217	
 218	!WRITE REGISTER 102/103
 219	
 220		DATA35		= 1^0,		!KS10 BUS DATA BIT 35
 221		DATA34		= 1^1,		!KS10 BUS DATA BIT 34
 222		DATA33		= 1^2,		!KS10 BUS DATA BIT 33
 223		DATA32		= 1^3,		!KS10 BUS DATA BIT 32
 224		DATA31		= 1^4,		!KS10 BUS DATA BIT 31
 225		DATA30		= 1^5,		!KS10 BUS DATA BIT 30
 226		DATA29		= 1^6,		!KS10 BUS DATA BIT 29
 227		DATA28		= 1^7,		!KS10 BUS DATA BIT 28
 228	
 229	!WRITE REGISTER 104/105
 230	
 231		DATA27		= 1^0,		!KS10 BUS DATA BIT 27
 232		DATA26		= 1^1,		!KS10 BUS DATA BIT 26
 233		DATA25		= 1^2,		!KS10 BUS DATA BIT 25
 234		DATA24		= 1^3,		!KS10 BUS DATA BIT 24
 235		DATA23		= 1^4,		!KS10 BUS DATA BIT 23
 236		DATA22		= 1^5,		!KS10 BUS DATA BIT 22
 237		DATA21		= 1^6,		!KS10 BUS DATA BIT 21
 238		DATA20		= 1^7,		!KS10 BUS DATA BIT 20
 239	
 240	!WRITE REGISTER 106/107
 241	
 242		DATA19		= 1^0,		!KS10 BUS DATA BIT 19
 243		DATA18		= 1^1,		!KS10 BUS DATA BIT 18
 244		DATA17		= 1^2,		!KS10 BUS DATA BIT 17
 245		DATA16		= 1^3,		!KS10 BUS DATA BIT 16
 246		DATA15		= 1^4,		!KS10 BUS DATA BIT 15
 247		DATA14		= 1^5,		!KS10 BUS DATA BIT 14
 248		DATA13		= 1^6,		!KS10 BUS DATA BIT 13
 249		DATA12		= 1^7,		!KS10 BUS DATA BIT 12
 250	
 251	!WRITE REGISTER 110/111
 252	
 253		DATA11		= 1^0,		!KS10 BUS DATA BIT 11
 254		DATA10		= 1^1,		!KS10 BUS DATA BIT 10
 255		DATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 256		DATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 257		DATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 258		DATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 259		DATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 260		DATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 261	
 262	!WRITE REGISTER 112/113
 263	
 264		DATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 265		DATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 266		DATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 267		DATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 268	
 269	!WRITE REGISTER 114/115
 270	
 271		DATA_CYCLE	= 1^0,		!DATA CYCLE
 272		IO_DATA		= 1^1,		!I/O DATA CYCLE
 273		COM_ADR		= 1^2,		!COM/ADR CYCLE
 274		BAD_DATA	= 1^3,		!BAD DATA CYCLE
 275	
 276	!WRITE REGISTER 116
 277	
 278		CSL_INT		= 1^0,		!CSL INTERRUPT THE 10
 279	
 280	!WRITE REGISTER 204
 281	
 282		CRAM_RESET	= 1^0,		!CRAM RESET
 283		STK_RESET	= 1^1,		!STACK RESET
 284		DP_RESET	= 1^2,		!DP RESET
 285		SS_MODE		= 1^3,		!SINGLE STEP MODE
 286		CRAM_ADR_LD	= 1^4,		!CRAM ADR LOAD
 287		CRAM_WRT	= 1^5,		!CRAM WRITE
 288	
 289	!WRITE REGISTER 205
 290	
 291		DIAG1		= 1^0,		!DIAG FN BIT 1
 292		DIAG2		= 1^1,		!DIAG FN BIT 2
 293		DIAG4		= 1^2,		!DIAG FN BIT 4
 294		DIAG10		= 1^3,		!DIAG FN BIT 10
 295		TRAP_ENB	= 1^4,		!TRAP ENABLE
 296		CLR_INT		= 1^5,		!CLEAR 10 INTERRUPT
 297		MNT_CLK_ENB	= 1^6,		!MAINT CLK ENABLE
 298		MAINT_CLK	= 1^7,		!MAINT CLK PULSE
 299	
 300	!WRITE REGISTER 206
 301	
 302		CLK_RUN		= 1^0,		!CLOCK RUN
 303		SINGLE_CLK	= 1^1,		!SINGLE CLOCK
 304	
 305	!WRITE REGISTER 210
 306	
 307		CLOSE_LATCH	= 1^0,		!CLOSE LATCHS
 308		LATCH_DATA	= 1^1,		!LATCH DATA (1)
 309		CRA_R_CLK	= 1^2,		!CRA R CLK ENB (1)
 310		CRA_T_CLK	= 1^3,		!CRA T CLK ENB (1)
 311		XMIT_DATA	= 1^4,		!XMIT DATA (1)
 312		XMIT_ADR	= 1^5,		!XMIT ADR (1)
 313		BUS_REQ		= 1^6,		!BUS REQ
 314		MEM		= 1^7,		!MEM
 315	
 316	!WRITE REGISTER 212
 317	
 318		CONTINUE	= 1^0,		!CONTINUE
 319		EXECUTE		= 1^1,		!EXECUTE
 320		RUN		= 1^2,		!RUN
 321	
 322	
 323	
 324	!READ REGISTER 0
 325	
 326		RDATA35		= 1^0,		!KS10 BUS DATA BIT 35
 327		RDATA34		= 1^1,		!KS10 BUS DATA BIT 34
 328		RDATA33		= 1^2,		!KS10 BUS DATA BIT 33
 329		RDATA32		= 1^3,		!KS10 BUS DATA BIT 32
 330		RDATA31		= 1^4,		!KS10 BUS DATA BIT 31
 331		RDATA30		= 1^5,		!KS10 BUS DATA BIT 30
 332		RDATA29		= 1^6,		!KS10 BUS DATA BIT 29
 333		RDATA28		= 1^7,		!KS10 BUS DATA BIT 28
 334	
 335	!READ REGISTER 1
 336	
 337		RDATA27		= 1^0,		!KS10 BUS DATA BIT 27
 338		RDATA26		= 1^1,		!KS10 BUS DATA BIT 26
 339		RDATA25		= 1^2,		!KS10 BUS DATA BIT 25
 340		RDATA24		= 1^3,		!KS10 BUS DATA BIT 24
 341		RDATA23		= 1^4,		!KS10 BUS DATA BIT 23
 342		RDATA22		= 1^5,		!KS10 BUS DATA BIT 22
 343		RDATA21		= 1^6,		!KS10 BUS DATA BIT 21
 344		RDATA20		= 1^7,		!KS10 BUS DATA BIT 20
 345	
 346	!READ REGISTER 2
 347	
 348		RDATA19		= 1^0,		!KS10 BUS DATA BIT 19
 349		RDATA18		= 1^1,		!KS10 BUS DATA BIT 18
 350		RDATA17		= 1^2,		!KS10 BUS DATA BIT 17
 351		RDATA16		= 1^3,		!KS10 BUS DATA BIT 16
 352		RDATA15		= 1^4,		!KS10 BUS DATA BIT 15
 353		RDATA14		= 1^5,		!KS10 BUS DATA BIT 14
 354		RDATA13		= 1^6,		!KS10 BUS DATA BIT 13
 355		RDATA12		= 1^7,		!KS10 BUS DATA BIT 12
 356	
 357	!READ REGISTER 3
 358	
 359		RDATA11		= 1^0,		!KS10 BUS DATA BIT 11
 360		RDATA10		= 1^1,		!KS10 BUS DATA BIT 10
 361		RDATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 362		RDATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 363		RDATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 364		RDATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 365		RDATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 366		RDATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 367	
 368	!READ REGISTER 100
 369	
 370		ADPT2_PE	= 1^0,		!UNIBUS ADAPTER 2 PARITY ERR
 371		CRA_PE		= 1^1,		!CRA PARITY ERR
 372		DP_PE		= 1^2,		!DP PARITY ERR
 373		MEM_PE		= 1^3,		!MEM PARITY ERR
 374		CRAM_PE		= 1^4,		!CRAM PARITY ERR
 375		ADPT3_PE	= 1^6,		!UNIBUS ADAPTER 3 PARITY ERR
 376		REC_PE		= 1^7,		!RECEIVED PARITY ERR
 377	
 378	!READ REGISTER 101
 379	
 380		MMC_REF_ERR	= 1^0,		!MEM REFRESH ERR
 381		PI_REQ_7	= 1^1,		!PI REQ 7
 382		PI_REQ_6	= 1^2,		!PI REQ 6
 383		PI_REQ_5	= 1^3,		!PI REQ 5
 384		PI_REQ_4	= 1^4,		!PI REQ 4
 385		PI_REQ_3	= 1^5,		!PI REQ 3
 386		PI_REQ_2	= 1^6,		!PI REQ 2
 387		PI_REQ_1	= 1^7,		!PI REQ 1
 388	
 389	!READ REGISTER 102
 390	
 391		RDATA		= 1^0,		!DATA CYCLE
 392		RIO_DATA	= 1^1,		!I/O DATA CYCLE
 393		RCOM_ADR	= 1^2,		!COM/ADR CYCLE
 394		RBAD_DATA	= 1^3,		!BAD DATA CYCLE
 395		RIO_BUSY	= 1^4,		!I/O BUSY
 396		RMEM_BUSY	= 1^5,		!MEM BUSY
 397		RRESET		= 1^6,		!RESET
 398		RAC_LO		= 1^7,		!AC LO
 399	
 400	!READ REGISTER 103
 401	
 402		RDATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 403		RDATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 404		RDATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 405		RDATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 406		PAR_LEFT	= 1^4,		!PARITY LEFT
 407		PAR_RIGHT	= 1^5,		!PARITY RIGHT
 408		ADPT4_PE	= 1^6,		!UNIBUS ADAPTER 4 PARITY ERR
 409		ADPT1_PE	= 1^7,		!UNIBUS ADAPTER 1 PARITY ERR
 410	
 411	!READ REGISTER 300
 412	
 413		CONTINUE_H	= 1^0,		!CONTINUE
 414		EXECUTE_B	= 1^1,		!EXECUTE
 415		RUN_1		= 1^2,		!RUN
 416		HALT_LOOP	= 1^3,		!DPM HALT LOOP
 417		KLINIK_LEN	= 1^4,		!KLINIK LENGTH (SW)
 418		KLINIK_BIT	= 1^5,		!KLINIK BIT # (SW)
 419		CTY_CHAR_LEN	= 1^6,		!CTY CHARACTER LENGTH (SW)
 420		CTY_BIT		= 1^7,		!CTY BIT # (SW)
 421	
 422	!READ REGISTER 301
 423	
 424		DATA_ACK	= 1^0,		!DATA ACK
 425		BOOT		= 1^1,		!BOOT (SW)
 426		CONS_ENB	= 1^2,		!CONSOLE ENABLE (SW)
 427		PE_1		= 1^3,		!PE(1)
 428		BUSREQ		= 1^4,		!BUS REQUEST
 429		NEXM		= 1^6,		!NEXM
 430		TEN_INT		= 1^7,		!10 INTERRUPT
 431	
 432	!READ REGISTER 302
 433	
 434		KLINIK_CARR	= 1^0,		!KLINIK CARRIER
 435		TERM_CARR	= 1^1,		!TERMINAL CARRIER
 436		REM_DIAG_ENB	= 1^2,		!REMOTE DIAG ENB
 437		REM_DIAG_PRO	= 1^3,		!REMOTE DIAG PROT
 438	
 439	!READ REGISTER 303
 440	
 441		RAM_ERR		= 1^0,		!RAM ERROR
 442		DP_CLK_ENBL	= 1^1,		!DPE/M CLK ENABLE
 443		CR_CLK_ENB	= 1^2,		!CRA/M CLK ENABLE
 444		R_CLK_ENB0	= 1^3;		!R CLK ENB (0) H
 445	
 446	! END OF 'REGBIT.R36'
 447	REQUIRE 'KSU.R36';				!KS10 MICROCODE MACROS
 448	
 449	!
 450	!			  COPYRIGHT (c) 1977, 1978 BY
 451	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 452	!
 453	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 454	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 455	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 456	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 457	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 458	! TRANSFERRED.
 459	!
 460	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 461	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 462	! CORPORATION.
 463	!
 464	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 465	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 466	!
 467	
 468	
 469	!++
 470	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 471	!
 472	! ABSTRACT:
 473	!
 474	!	 THESE MACROS ALLOW YOU TO WRITE MICROINSTRUCTIONS IN A SYMBOLIC FORM
 475	!	 (DIFFERENT THAN THE NORMAL MICRO CROSS ASSEMBLER) FOR USE AS LITERAL
 476	!	 VALUES WITHIN A BLISS-36 PROGRAM.   MACROS ARE NECESSARY (AS OPPOSED
 477	!	 TO ARITHMETIC EXPRESSIONS) TO HANDLE SOME FIELDS' DEFAULT VALUES IN
 478	!	 THE "RIGHT WAY"; THEY DEFAULT TO THE VALUE WHICH MAY HAVE BEEN SET IN
 479	!	 OTHER FIELDS.   ALSO, IT ALLEVIATES YOU FROM HAVING TO REMEMBER WHICH
 480	!	 OF THE 3 36-BIT PDP-10 WORDS THE FIELD GOES INTO.
 481	!
 482	! FUNCTIONAL DESCRIPTION:
 483	!
 484	!	 TO CREATE A MICROINSTRUCTION, CALL THE MACROS FOR THE FIELDS WHICH
 485	!	 YOU DESIRE TO SPECIFY EXPLICITLY.   SOME OF THEM REQUIRE ARGUMENTS;
 486	!	 SOME OF THEM CALL OTHERS WITH THE APPROPRIATE ARGUMENT.   THESE WILL
 487	!	 EXPAND TO THE NULL LEXEME (THAT IS, THEY GO AWAY).   FINALLY, THE
 488	!	 U MACRO IS CALLED.   IT HANDLES THE TRICKY DEFAULTS, EXPANDS TO 3
 489	!	 DECIMAL CONSTANTS SEPPARATED BY COMMAS, AND RESETS THE COMPILETIME
 490	!	 VARIABLES BACK TO THEIR INITIAL VALUES (MOSTLY, THE MICROINSTRUCTION
 491	!	 WITH ALL OF THE SIMPLE FIELDS WITH THEIR DEFAULT VALUES).   THE U
 492	!	 MACRO MAY BE CALLED AS THE ARGUMENT OF A PLIT.   IT MAY BE CALLED SEVERAL
 493	!	 TIMES WITH A COMMA BETWEEN EACH ONE (AND THE FIELD-SETTING MACROS
 494	!	 BEFORE EACH ONE) TO MAKE A PLIT WITH A BLOCK OF SEVERAL MICROINSTRUCTIONS
 495	!	 SINCE THE HOOKS INTO CSL WILL PERMIT LOADING SEVERAL MICROINSTRUCTIONS
 496	!	 INTO CONTIGUOUS CRAM LOCATIONS WITH ONE CALL.   MACROS MAY BE DEFINED
 497	!	 WHICH SET MANY OF THE FIELDS (JUST LIKE IN MICRO) BY HAVING IT CALL THE
 498	!	 DESIRED FIELD-SETTING MACROS.
 499	!
 500	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 501	!
 502	! AUTHOR: ARON INSINGA, CREATION DATE: 22-AUG-78
 503	!
 504	! MODIFIED BY:
 505	!
 506	!	ARON INSINGA, 28-AUG-78: VERSION 0.1
 507	!--
 508	
 509	!
 510	! TABLE OF CONTENTS:
 511	!
 512	!	JUMP FIELD
 513	!	2901 ALU FUNCTION
 514	!	LEFT SOURCE
 515	!	RIGHT SOURCE
 516	!	DESTINATION (DP, Q, B)
 517	!	DATA PATH ADDRESS A
 518	!	DATA PATH ADDRESS B
 519	!	RAMFILE ADDRESS
 520	!	D-BUS SELECT
 521	!	DBM SELECT
 522	!	FICTICOUS PARITY-VALIDATE BIT
 523	!	CLOCK LEFT HALF OF THE MACHINE
 524	!	STORE PARITY FOR LEFT 2901'S
 525	!	CHECK LEFT HALF D-BUS PARITY
 526	!	CLOCK RIGHT HALF OF THE MACHINE
 527	!	STORE PARITY FOR RIGHT 2901'S
 528	!	CHECK RIGHT HALF D-BUS PARITY
 529	!	SPEC
 530	!	SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
 531	!	SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
 532	!	DISPATCH
 533	!	SKIP STUFF
 534	!	TIME FIELD
 535	!	RANDOM CONTROL BITS
 536	!	INJECT A CARRY
 537	!	LOAD SC FROM SCAD
 538	!	LOAD FE FROM SCAD
 539	!	WRITE THE RAM FILE
 540	!	START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
 541	!	THIS MICROINSTRUCTION IS DOING A DIVIDE
 542	!	MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
 543	!	FAST SHIFT
 544	!	CALL
 545	!	MAGIC NUMBER FIELD (#)
 546	!	SCAD (SHIFT-COUNT ADDER) FUNCTION
 547	!	SCAD A-INPUT MUX
 548	!	SCAD B-INPUT MUX
 549	!	SCAD NUMBER FIELD
 550	!	MICROINSTRUCTION BUILDER
 551	!
 552	!	MICROINSTRUCTION WITH DEFAULT FIELDS
 553	!	MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
 554	!	MICROINSTRUCTION BEING BUILT
 555	!
 556	
 557	!
 558	! MACROS:
 559	!
 560	
 561	    MACRO
 562	
 563		! JUMP FIELD
 564		U_J(O_CRAM_ADDR) =
 565		    %ASSIGN(U_0,U_0 OR ((%O %STRING(O_CRAM_ADDR))^24)) %,
 566	
 567		! 2901 ALU FUNCTION
 568		U_ALU(FUNC) =
 569		    %ASSIGN(U_0,(U_0 AND %O'777707777777') OR ((FUNC)^21)) %,
 570	
 571		U_ALU_ADD = U_ALU(0) %,
 572		U_ALU_SUB = U_ALU(1) %,
 573		U_ALU_RSUB = U_ALU(2) %,
 574		U_ALU_OR = U_ALU(3) %,
 575		U_ALU_AND = U_ALU(4) %,
 576		U_ALU_MASK = U_ALU(5) %,
 577		U_ALU_XOR = U_ALU(6) %,
 578		U_ALU_XNOR = U_ALU(7) %,
 579	
 580		! LEFT SOURCE
 581		U_LSRC(SRC) =
 582		    %ASSIGN(U_0,(U_0 AND %O'777770777777') OR ((SRC)^18)) %,
 583	
 584		U_LSRC_AQ = U_LSRC(0) %,
 585		U_LSRC_AB = U_LSRC(1) %,
 586		U_LSRC_0Q = U_LSRC(2) %,
 587		U_LSRC_0B = U_LSRC(3) %,
 588		U_LSRC_0A = U_LSRC(4) %,
 589		U_LSRC_DA = U_LSRC(5) %,
 590		U_LSRC_DQ = U_LSRC(6) %,
 591		U_LSRC_D0 = U_LSRC(7) %,
 592	
 593		! RIGHT SOURCE
 594		U_RSRC(SRC) =
 595		    %ASSIGN(U_0,(U_0 AND %O'777777077777') OR ((SRC)^15))
 596		    %ASSIGN(U_SET,U_SET OR U_SET_RSRC) %,
 597	
 598		U_RSRC_AQ = U_RSRC(0) %,
 599		U_RSRC_AB = U_RSRC(1) %,
 600		U_RSRC_0Q = U_RSRC(2) %,
 601		U_RSRC_0B = U_RSRC(3) %,
 602		U_RSRC_0A = U_RSRC(4) %,
 603		U_RSRC_DA = U_RSRC(5) %,
 604		U_RSRC_DQ = U_RSRC(6) %,
 605		U_RSRC_D0 = U_RSRC(7) %,
 606	
 607		! DESTINATION (DP, Q, B)
 608		U_DEST(DEST) =
 609		    %ASSIGN(U_0,(U_0 AND %O'777777707777') OR ((DEST)^12)) %,
 610	
 611		U_DEST_A = U_DEST(0) %,
 612		U_DEST_AD = U_DEST(1) %,
 613		U_DEST_Q_AD = U_DEST(2) %,
 614		U_DEST_PASS = U_DEST(3) %,
 615		U_DEST_Q_MUL2 = U_DEST(4) %,
 616		U_DEST_AD_MUL2 = U_DEST(5) %,
 617		U_DEST_Q_DIV2 = U_DEST(6) %,
 618		U_DEST_AD_DIV2 = U_DEST(7) %,
 619	
 620		! DATA PATH ADDRESS A
 621		U_A(DP) =
 622		    %ASSIGN(U_0,U_0 OR ((DP)^6)) %,
 623	
 624		U_A_MAG = U_A(0) %,
 625		U_A_PC = U_A(1) %,
 626		U_A_HR = U_A(2) %,
 627		U_A_AR = U_A(3) %,
 628		U_A_ARX = U_A(4) %,
 629		U_A_BR = U_A(5) %,
 630		U_A_BRX = U_A(6) %,
 631		U_A_ONE = U_A(7) %,
 632		U_A_EBR = U_A(8) %,
 633		U_A_UBR = U_A(9) %,
 634		U_A_MASK = U_A(10) %,
 635		U_A_FLG = U_A(11) %,
 636		U_A_PI = U_A(12) %,
 637		U_A_XWD1 = U_A(13) %,
 638		U_A_T0 = U_A(14) %,
 639		U_A_T1 = U_A(15) %,
 640	
 641		! DATA PATH ADDRESS B
 642		U_B(DP) =
 643		    %ASSIGN(U_0,U_0 OR (DP)) %,
 644	
 645		U_B_MAG = U_B(0) %,
 646		U_B_PC = U_B(1) %,
 647		U_B_HR = U_B(2) %,
 648		U_B_AR = U_B(3) %,
 649		U_B_ARX = U_B(4) %,
 650		U_B_BR = U_B(5) %,
 651		U_B_BRX = U_B(6) %,
 652		U_B_ONE = U_B(7) %,
 653		U_B_EBR = U_B(8) %,
 654		U_B_UBR = U_B(9) %,
 655		U_B_MASK = U_B(10) %,
 656		U_B_FLG = U_B(11) %,
 657		U_B_PI = U_B(12) %,
 658		U_B_XWD1 = U_B(13) %,
 659		U_B_T0 = U_B(14) %,
 660		U_B_T1 = U_B(15) %,
 661	
 662		! RAMFILE ADDRESS
 663		U_RAM(SEL) =
 664		    %ASSIGN(U_1,(U_1 AND %O'77777777777') OR ((SEL)^33)) %,
 665	
 666		U_RAM_AC = U_RAM(0) %,
 667		U_RAM_AC_FN = U_RAM(1) %,
 668		U_RAM_XR = U_RAM(2) %,
 669		U_RAM_VMA = U_RAM(4) %,
 670		U_RAM_RAM = U_RAM(6) %,
 671		U_RAM_N = U_RAM(7) %,
 672	
 673		! D-BUS SELECT
 674		U_DBUS(SEL) =
 675		    %ASSIGN(U_1,(U_1 AND %O'747777777777') OR ((SEL)^30)) %,
 676	
 677		U_DBUS_PC_FLAGS = U_DBUS(0) %,		! LEFT HALF
 678		U_DBUS_PI_NEW = U_DBUS(0) %,		! BITS 19:21
 679		U_DBUS_VMA = U_DBUS(0) %,		! BITS 27:35
 680		U_DBUS_DP = U_DBUS(1) %,
 681		U_DBUS_RAM = U_DBUS(2) %,
 682		U_DBUS_DBM = U_DBUS(3) %,
 683	
 684		! DBM SELECT
 685		U_DBM(SEL) =
 686		    %ASSIGN(U_1,(U_1 AND %O'770777777777') OR ((SEL)^27)) %,
 687	
 688		U_DBM_SCAD = U_DBM(0) %,		! LEFT HALF
 689		U_DBM_PF_DISP = U_DBM(0) %,		! BITS 18:21
 690		U_DBM_APR_FLAGS = U_DBM(0) %,		! BITS 22:35
 691		U_DBM_BYTES = U_DBM(1) %,
 692		U_DBM_EXP = U_DBM(2) %,			! LEFT HALF
 693		U_DBM_MSEC = U_DBM(2) %,		! RIGHT HALF
 694		U_DBM_DP = U_DBM(3) %,
 695		U_DBM_DP_SWAP = U_DBM(4) %,
 696		U_DBM_VMA = U_DBM(5) %,
 697		U_DBM_MEM = U_DBM(6) %,
 698		U_DBM_N = U_DBM(7) %,
 699	
 700		! FICTICOUS PARITY-VALIDATE BIT
 701		U_ALU_PARITY_OK =
 702		    %ASSIGN(U_3,U_3 OR (1^35)) %,
 703	
 704		! CLOCK LEFT HALF OF THE MACHINE
 705		U_NO_CLKL =
 706		    %ASSIGN(U_1,U_1 AND %O'777377777777') %,
 707	
 708		! STORE PARITY FOR LEFT 2901'S
 709		U_GENL =
 710		    %ASSIGN(U_1,U_1 OR (1^25))
 711		    %ASSIGN(U_SET,U_SET OR U_SET_GENL) %,
 712	
 713		! CHECK LEFT HALF D-BUS PARITY
 714		U_CHKL =
 715		    %ASSIGN(U_1,U_1 OR (1^24)) %,
 716	
 717		! CLOCK RIGHT HALF OF THE MACHINE
 718		U_NO_CLKR =
 719		    %ASSIGN(U_1,U_1 AND %O'777737777777') %,
 720	
 721		! STORE PARITY FOR RIGHT 2901'S
 722		U_GENR =
 723		    %ASSIGN(U_1,U_1 OR (1^22))
 724		    %ASSIGN(U_SET,U_SET OR U_SET_GENR) %,
 725	
 726		! CHECK RIGHT HALF D-BUS PARITY
 727		U_CHKR =
 728		    %ASSIGN(U_1,U_1 OR (1^21)) %,
 729	
 730		! SPEC
 731		U_SPEC(X) =
 732		    %ASSIGN(U_1,U_1 OR ((X)^15)) %,
 733	
 734		U_SPEC_N = U_SPEC(%O'10') %,
 735		U_SPEC_CLRCLK = U_SPEC(%O'11') %,
 736		U_SPEC_CLRIOLAT = U_SPEC(%O'12') %,
 737		U_SPEC_CLRIOBSY = U_SPEC(%O'13') %,
 738		U_SPEC_LDPAGE = U_SPEC(%O'14') %,
 739		U_SPEC_NICOND = U_SPEC(%O'15') %,
 740		U_SPEC_LDPXCT = U_SPEC(%O'16') %,
 741		U_SPEC_WAIT = U_SPEC(%O'17') %,
 742		U_SPEC_PREV = U_SPEC(%O'20') %,
 743		U_SPEC_LOADXR = U_SPEC(%O'21') %,
 744		U_SPEC_APRFLAGS = U_SPEC(%O'23') %,
 745		U_SPEC_CLRCSH = U_SPEC(%O'24') %,
 746		U_SPEC_APR_EN = U_SPEC(%O'25') %,
 747		U_SPEC_MEMCLR = U_SPEC(%O'27') %,
 748		U_SPEC_SWEEP = U_SPEC(%O'34') %,
 749		U_SPEC_PXCT_OFF = U_SPEC(%O'36') %,
 750		U_SPEC_INHCRY18 = U_SPEC(%O'40') %,
 751		U_SPEC_LOADIR = U_SPEC(%O'41') %,
 752		U_SPEC_LDPI = U_SPEC(%O'43') %,
 753		U_SPEC_ASHOV = U_SPEC(%O'44') %,
 754		U_SPEC_EXPTST = U_SPEC(%O'45') %,
 755		U_SPEC_FLAGS = U_SPEC(%O'46') %,
 756		U_SPEC_LDACBLK = U_SPEC(%O'47') %,
 757		U_SPEC_LDINST = U_SPEC(%O'61') %,
 758	
 759		! SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
 760		U_BYTE(X) =
 761		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
 762	
 763		U_BYTE_1 = U_BYTE(1) %,
 764		U_BYTE_2 = U_BYTE(2) %,
 765		U_BYTE_3 = U_BYTE(3) %,
 766		U_BYTE_4 = U_BYTE(4) %,
 767		U_BYTE_5 = U_BYTE(5) %,
 768	
 769		! SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
 770		U_SHSTYLE(X) =
 771		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
 772	
 773		U_SHSTYLE_NORM = U_SHSTYLE(0) %,
 774		U_SHSTYLE_ZERO = U_SHSTYLE(1) %,
 775		U_SHSTYLE_ONES = U_SHSTYLE(2) %,
 776		U_SHSTYLE_ROT = U_SHSTYLE(3) %,
 777		U_SHSTYLE_ASHC = U_SHSTYLE(4) %,
 778		U_SHSTYLE_LSHC = U_SHSTYLE(5) %,
 779		U_SHSTYLE_DIV = U_SHSTYLE(6) %,
 780		U_SHSTYLE_ROTC = U_SHSTYLE(7) %,
 781	
 782		! DISPATCH
 783		U_DISP(X) =
 784		    %ASSIGN(U_1,(U_1 AND %O'777777700777') OR ((X)^9)) %,
 785	
 786		U_DISP_CONSOLE = U_DISP(%O'00') %,
 787		U_DISP_DROM = U_DISP(%O'12') %,
 788		U_DISP_AREAD = U_DISP(%O'13') %,
 789		U_DISP_DP_LEFT = U_DISP(%O'31') %,
 790		U_DISP_NORM = U_DISP(%O'34') %,
 791		U_DISP_DP = U_DISP(%O'35') %,
 792		U_DISP_ADISP = U_DISP(%O'36') %,
 793		U_DISP_BDISP = U_DISP(%O'37') %,
 794		U_DISP_RETURN = U_DISP(%O'41') %,
 795		U_DISP_MUL = U_DISP(%O'62') %,
 796		U_DISP_PAGEFAIL = U_DISP(%O'63') %,
 797		U_DISP_NICOND = U_DISP(%O'64') %,
 798		U_DISP_BYTE = U_DISP(%O'65') %,
 799		U_DISP_EAMODE = U_DISP(%O'66') %,
 800		U_DISP_SCAD0 = U_DISP(%O'67') %,
 801	
 802		! SKIP STUFF
 803		U_SKIP(X) =
 804		    %ASSIGN(U_1,(U_1 AND %O'777777777007') OR ((X)^3)) %,
 805	
 806		U_SKIP_IOLGL = U_SKIP(%O'04') %,
 807		U_SKIP_LLE = U_SKIP(%O'12') %,
 808		U_SKIP_CRY0 = U_SKIP(%O'31') %,
 809		U_SKIP_ADLEQ0 = U_SKIP(%O'32') %,
 810		U_SKIP_ADREQ0 = U_SKIP(%O'33') %,
 811		U_SKIP_KERNEL = U_SKIP(%O'34') %,
 812		U_SKIP_FPD = U_SKIP(%O'35') %,
 813		U_SKIP_AC0 = U_SKIP(%O'36') %,
 814		U_SKIP_INT = U_SKIP(%O'37') %,
 815		U_SKIP_LE = U_SKIP(%O'42') %,
 816		U_SKIP_CRY2 = U_SKIP(%O'51') %,
 817		U_SKIP_DP0 = U_SKIP(%O'52') %,
 818		U_SKIP_DP18 = U_SKIP(%O'53') %,
 819		U_SKIP_IOT = U_SKIP(%O'54') %,
 820		U_SKIP_JFCL = U_SKIP(%O'55') %,
 821		U_SKIP_CRY1 = U_SKIP(%O'56') %,
 822		U_SKIP_TXXX = U_SKIP(%O'57') %,
 823		U_SKIP_TRAP_CYC = U_SKIP(%O'61') %,
 824		U_SKIP_ADEQ0 = U_SKIP(%O'62') %,
 825		U_SKIP_SC = U_SKIP(%O'63') %,
 826		U_SKIP_EXECUTE = U_SKIP(%O'64') %,
 827		U_SKIP_IO_BUSY = U_SKIP(%O'65') %,
 828		U_SKIP_CONTINUE = U_SKIP(%O'66') %,
 829		U_SKIP_1_MS = U_SKIP(%O'67') %,
 830	
 831		! TIME FIELD [O.E. "UT" = MDN.E. "OUT"]
 832		U_T(X) =
 833		    %ASSIGN(U_1,(U_1 AND %O'777777777774') OR (X)) %,
 834	
 835		! RANDOM CONTROL BITS
 836	
 837		! INJECT A CARRY
 838		U_CRY38 =
 839		    %ASSIGN(U_2,U_2 OR (1^35)) %,
 840	
 841		! LOAD SC FROM SCAD
 842		U_LOADSC =
 843		    %ASSIGN(U_2,U_2 OR (1^34)) %,
 844	
 845		! LOAD FE FROM SCAD
 846		U_LOADFE =
 847		    %ASSIGN(U_2,U_2 OR (1^33)) %,
 848	
 849		! WRITE THE RAM FILE
 850		U_FMWRITE =
 851		    %ASSIGN(U_2,U_2 OR (1^32)) %,
 852	
 853		! START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
 854		U_MEM =
 855		    %ASSIGN(U_2,U_2 OR (1^31)) %,
 856	
 857		! THIS MICROINSTRUCTION IS DOING A DIVIDE
 858		U_DIVIDE =
 859		    %ASSIGN(U_2,U_2 OR (1^30)) %,
 860	
 861		! MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
 862		U_MULTI_PREC =
 863		    %ASSIGN(U_2,U_2 OR (1^29)) %,
 864	
 865		! FAST SHIFT
 866		U_MULTI_SHIFT =
 867		    %ASSIGN(U_2,U_2 OR (1^28)) %,
 868	
 869		! CALL
 870		U_CALL =
 871		    %ASSIGN(U_2,U_2 OR (1^27)) %,
 872	
 873		! MAGIC NUMBER FIELD (#)
 874		U_N(O_N) =
 875		    %ASSIGN(U_2,U_2 OR (%O %STRING(O_N))) %,
 876	
 877		! MAGIC NUMBER FIELD REDEFINED FOR SHIFT-COUNT ADDER (SCAD) CONTROL
 878	
 879		! SCAD FUNCTION
 880		U_SCAD(X) =
 881		    %ASSIGN(U_2,(U_2 AND %O'777777077777') OR ((X)^15)) %,
 882	
 883		U_SCAD_A_MUL2 = U_SCAD(0) %,
 884		U_SCAD_OR = U_SCAD(1) %,
 885		U_SCAD_SUBB = U_SCAD(2) %,
 886		U_SCAD_SUB = U_SCAD(3) %,
 887		U_SCAD_ADD = U_SCAD(4) %,
 888		U_SCAD_AND = U_SCAD(5) %,
 889		U_SCAD_A_DEC = U_SCAD(6) %,
 890		U_SCAD_A = U_SCAD(7) %,
 891	
 892		! SCAD A INPUT MUX
 893		U_SCADA(X) =
 894		    %ASSIGN(U_2,(U_2 AND %O'777777707777') OR ((X)^12)) %,
 895	
 896		U_SCADA_SC = U_SCADA(0) %,
 897		U_SCADA_SN = U_SCADA(1) %,
 898		U_SCADA_PTR44 = U_SCADA(2) %,
 899		U_SCADA_BYTE1 = U_SCADA(3) %,
 900		U_SCADA_BYTE2 = U_SCADA(4) %,
 901		U_SCADA_BYTE3 = U_SCADA(5) %,
 902		U_SCADA_BYTE4 = U_SCADA(6) %,
 903		U_SCADA_BYTE5 = U_SCADA(7) %,
 904	
 905		! SCAD B INPUT MUX
 906		U_SCADB(X) =
 907		    %ASSIGN(U_2,(U_2 AND %O'777777771777') OR ((X)^10)) %,
 908	
 909		U_SCADB_FE = U_SCADB(0) %,
 910		U_SCADB_EXP = U_SCADB(1) %,
 911		U_SCADB_SHIFT = U_SCADB(2) %,
 912		U_SCADB_SIZE = U_SCADB(3) %,
 913	
 914		! SCAD/SMALL NUMBER FIELD
 915		U_SN(O_SN) =
 916		    %ASSIGN(U_2,(U_2 AND %O'777777776000') OR (%O %STRING(O_SN))) %,
 917	
 918		! MICROINSTRUCTION BUILDER
 919		!	 HANDLE DEFAULTS FOR FIELDS WHICH DEFAULT TO OTHER FIELDS.
 920		!	 EXPAND OUT TO THE 3 WORDS (108 BIT FORMAT) WITH COMMAS.
 921		!	 RESET ALL THE COMPILETIME VARIABLES TO THEIR ORIGINAL VALUES.
 922		U =
 923		    
 924		! DEFAULT RSRC = LSRC
 925		    %IF (U_SET AND U_SET_RSRC) EQL 0
 926		    %THEN
 927			%ASSIGN(U_0,U_0 OR ((U_0^(-3)) AND %O'700000'))
 928		    %FI
 929	
 930		! DEFAULT GENL = ALU_PARITY_OK
 931		    %IF (U_SET AND U_SET_GENL) EQL 0
 932		    %THEN
 933			%ASSIGN(U_1,U_1 OR ((U_3^(-10)) AND %O'000200000000'))
 934		    %FI
 935	
 936		! DEFAULT GENR = ALU_PARITY_OK
 937		    %IF (U_SET AND U_SET_GENR) EQL 0
 938		    %THEN
 939			%ASSIGN(U_1,U_1 OR ((U_3^(-13)) AND %O'000020000000'))
 940		    %FI
 941	
 942		    U_0,U_1,U_2
 943	
 944		    %ASSIGN(U_0,U_0_DEFAULT)
 945		    %ASSIGN(U_1,U_1_DEFAULT)
 946		    %ASSIGN(U_2,U_2_DEFAULT)
 947		    %ASSIGN(U_3,U_3_DEFAULT)
 948		    %ASSIGN(U_SET,0) %;
 949	
 950	!
 951	! EQUATED SYMBOLS:
 952	!
 953	
 954	    LITERAL
 955	
 956		! MICROINSTRUCTION WITH DEFAULT FIELDS
 957		U_0_DEFAULT = %O'000044030000',
 958		U_1_DEFAULT = %O'417440070703',
 959		U_2_DEFAULT = %O'000000000000',
 960		U_3_DEFAULT = %O'000000000000',
 961	
 962		! MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
 963		U_SET_RSRC = %O'1',
 964		U_SET_GENL = %O'2',
 965		U_SET_GENR = %O'4';
 966	
 967	    COMPILETIME
 968	
 969		! MICROINSTRUCTION BEING BUILT
 970		U_0 = U_0_DEFAULT,
 971		U_1 = U_1_DEFAULT,
 972		U_2 = U_2_DEFAULT,
 973		U_3 = U_3_DEFAULT,
 974		U_SET = 0;
 975	
 976	! END OF "KSU.R36"
 977	
 978	REQUIRE 'CSLMAC.R36';				!'CSL' INTERFACE MACROS
 979	
 980	!
 981	!			  COPYRIGHT (c) 1977, 1978 BY
 982	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 983	!
 984	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 985	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 986	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 987	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 988	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 989	! TRANSFERRED.
 990	!
 991	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 992	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 993	! CORPORATION.
 994	!
 995	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 996	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 997	!
 998	
 999	!++
1000	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
1001	!
1002	! ABSTRACT:
1003	!
1004	!	THIS FILE CONTAINS MACROS WHICH ARE USED TO COMMUNICATE WITH THE
1005	!	'CSL' PROGRAM.  THE MACROS EXPAND TO LUUO CALLS WHICH PERFORM TTY
1006	!	INPUT AND OUTPUT AND SEND ASCIZ COMMAND LINES TO THE 8080.
1007	!
1008	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
1009	!
1010	! AUTHOR:  RICH MURATORI	, CREATION DATE:  12-DEC-78
1011	!
1012	! MODIFIED BY:
1013	!
1014	!  RICH MURATORI, 12-DEC-78 : VERSION 0.1
1015	!--
1016	
1017	BUILTIN UUO;
1018	
1019	LITERAL
1020		ER_AC = 1,
1021		EI_AC = 2,
1022		EJ_AC = 3,
1023		EK_AC = 4,
1024		EB_AC = 5,
1025		EC_AC = 6,
1026		EM_AC = 7,
1027		PM_AC = 8,
1028		X1A_AC = 9,
1029		X1B_AC = 10;
1030	
1031	
1032	!MACROS TO DEFINE PRINTING CALLS MADE TO 'CSL' PROGRAM VIA UUO
1033	
1034	BIND CR_LF = UPLIT(%CHAR(13,10,0));
1035	
1036	MACRO
1037		PRINT_CRLF	= BEGIN
1038				  AC0 = CR_LF;
1039				  UUO(0,31,15,0);
1040				  END%,
1041		PNTSIX(MSGWORD)	= BEGIN
1042				  AC0 = MSGWORD;
1043				  UUO(0,31,0,2);
1044				  END%,
1045		PRINT_MSG(MSGADR)= BEGIN
1046				  AC0 = MSGADR;
1047				  UUO(0,31,15,0);
1048				  END%,
1049		PRINT_WORD(ADDR) = BEGIN
1050				   AC0 = ADDR;
1051				   UUO(0,31,0,0);
1052				   END%,
1053		PRINT_TXT(TEXT) = BEGIN
1054				  AC0 = UPLIT(%ASCIZ TEXT);
1055				  UUO(0,31,15,0);
1056				  END%,
1057		PTXT_CRLF(TEXT)	= BEGIN
1058				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
1059				  UUO(0,31,15,0);
1060				  END%,
1061		PRINT_DEC(NUM)	= BEGIN
1062				  AC0 = NUM;
1063				  UUO(0,31,13,0);
1064				  END%,
1065		PRT_CRLF_F	= BEGIN
1066				  AC0 = CR_LF;
1067				  UUO(0,31,15,1);
1068				  END%,
1069		PRT_MSG_F(MSGADR)= BEGIN
1070				  AC0 = MSGADR;
1071				  UUO(0,31,15,1);
1072				  END%,
1073		PRT_TXT_F(TEXT) = BEGIN
1074				  AC0 = UPLIT(%ASCIZ TEXT);
1075				  UUO(0,31,15,1);
1076				  END%,
1077		PTXT_CRLF_F(TEXT) = BEGIN
1078				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
1079				  UUO(0,31,15,1);
1080				  END%,
1081		PRT_DEC_F(NUM)	= BEGIN
1082				  AC0 = NUM;
1083				  UUO(0,31,13,1);
1084				  END%,
1085		PRINT_OCT_1(NUM)= BEGIN
1086				  AC0 = NUM;
1087				  UUO(0,31,1,0);
1088				  END%,
1089		PRINT_OCT_2(NUM)= BEGIN
1090				  AC0 = NUM;
1091				  UUO(0,31,2,0);
1092				  END%,
1093		PRINT_OCT_3(NUM)= BEGIN
1094				  AC0 = NUM;
1095				  UUO(0,31,3,0);
1096				  END%,
1097		PRINT_OCT_4(NUM)= BEGIN
1098				  AC0 = NUM;
1099				  UUO(0,31,4,0);
1100				  END%,
1101		PRINT_OCT_5(NUM)= BEGIN
1102				  AC0 = NUM;
1103				  UUO(0,31,5,0);
1104				  END%,
1105		PRINT_OCT_6(NUM)= BEGIN
1106				  AC0 = NUM;
1107				  UUO(0,31,6,0);
1108				  END%,
1109		PRINT_OCT_7(NUM)= BEGIN
1110				  AC0 = NUM;
1111				  UUO(0,31,7,0);
1112				  END%,
1113		PRINT_OCT_8(NUM)= BEGIN
1114				  AC0 = NUM;
1115				  UUO(0,31,8,0);
1116				  END%,
1117		PRINT_OCT_11(NUM)= BEGIN
1118				  AC0 = NUM;
1119				  UUO(0,31,11,0);
1120				  END%,
1121		PRINT_OCT_12(NUM)= BEGIN
1122				  AC0 = NUM;
1123				  UUO(0,31,12,0);
1124				  END%,
1125		POCT_SUP(NUM)	= BEGIN
1126				  AC0 = NUM;
1127				  UUO(0,31,14,3);
1128				  END%,
1129		PBELL		= UUO(0,31,1,7)%,
1130	
1131	!MACROS TO DEFINE UUO CALLS TO 'CSL' PROGRAM FOR TTY INPUT
1132	
1133		TT_ALTM = UUO(1,31,7,3)%,
1134		TTI_YES = UUO(1,31,1,3)%,
1135		TTI_CLR = UUO(0,31,10,3)%,
1136		TTI_DEC = UUO(1,31,4,3)%,
1137	
1138	!MACRO TO DEFINE END OF PROGRAM UUO
1139	
1140		EOP_UUO = UUO(0,31,14,4)%,
1141	
1142	!MACROS TO DEFINE UUO CALLS TO 'CSL' TO SEND CMD STRINGS WITH RESPONSE
1143	
1144		SEND_ER_LINE = UUO(0,1,ER_AC,0)%,
1145		SEND_EI_LINE = UUO(0,1,EI_AC,0)%,
1146		SEND_EJ_LINE = UUO(0,1,EJ_AC,0)%,
1147		SEND_EK_LINE = UUO(0,1,EK_AC,0)%,
1148		SEND_EB_LINE = UUO(0,1,EB_AC,0)%,
1149		SEND_EC_LINE = UUO(0,1,EC_AC,0)%,
1150		SEND_EM_LINE = UUO(0,1,EM_AC,0)%,
1151		SEND_PM_LINE = UUO(0,1,PM_AC,0)%,
1152		SEND_X1A_LINE = UUO(0,1,X1A_AC,0)%,
1153		SEND_X1B_LINE = UUO(0,1,X1B_AC,0)%,
1154	
1155	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD STRING
1156	
1157		SEND_CMD_LINE = UUO(0,1,0,0)%,
1158	
1159	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD LINE
1160	
1161		SEND_UUO_1 = UUO(0,1,1,0)%,
1162	
1163	!MACRO TO DEFINE ERROR MESSAGE CHECK CALL TO 'CSL'
1164	
1165		MSG_CHK_UUO = UUO(0,3,0,0)%,
1166	
1167	!MACRO TO DEFINE 'CSL' UUO TO PASS CONTROL-T INFO
1168	
1169		SEND_INFO = UUO(0,3,1,0)%,
1170	
1171	!MACROS TO DEFINE FILE HANDLING UUOS TO 'CSL' PROGRAM
1172	
1173		FSELECT(FILNAM_ADR)	= (AC0 = FILNAM_ADR;
1174					  UUO(1,31,5,4))%,
1175		FRDPAG	= UUO(1,31,8,4)%;
1176	
1177	!8080 ERROR MESSAGE FORMATS WHICH ARE CHECKED FOR.
1178	
1179	BIND
1180		HALTED = UPLIT(%ASCIZ '%HLTD'),
1181		MEM_REF_ERR = UPLIT(%ASCIZ '?MRE'),
1182		PAR_ERR = UPLIT(%ASCIZ '?PAR_ERR');
1183	
1184	! END OF 'CSL.MAC'
1185	REQUIRE 'STIRSD.R36';				!LINKAGE TO 'MSSTRC' DEFINITIONS
1186	
1187	!
1188	!			  COPYRIGHT (c) 1977, 1978 BY
1189	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
1190	!
1191	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
1192	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
1193	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
1194	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
1195	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
1196	! TRANSFERRED.
1197	!
1198	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
1199	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
1200	! CORPORATION.
1201	!
1202	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
1203	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
1204	!
1205	
1206	!++
1207	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
1208	!
1209	! ABSTRACT:
1210	!
1211	!	THESE ARE THE COMMON DECLARATIONS WHICH ARE USED BY THE TEST MODULES
1212	!	FOR THE DIFFERENT STIRS DIAGNOSTICS.
1213	!
1214	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
1215	!
1216	! AUTHOR: ARON INSINGA, CREATION DATE: 01-SEP-78
1217	!
1218	! MODIFIED BY:
1219	!
1220	!	ARON INSINGA, 23-MAY-79: VERSION 0.1
1221	!--
1222	
1223	!
1224	! MACROS:
1225	!
1226	
1227	    MACRO
1228		LOAD_U(CRAM_ADDR,SOURCE_ADDR) = LOADUC(%O %STRING(CRAM_ADDR),SOURCE_ADDR) %,
1229		LC(O_CRAM_ADDR) = LCA(%O %STRING(O_CRAM_ADDR)) %,
1230		SET_C(O_CRAM_ADDR) = SETNXT(%O %STRING(O_CRAM_ADDR)) %,
1231		STEP_U_NEXT(N) = (CP(N);EX_NXT) %,
1232		BEGIN_XLIST = BEGIN SWITCHES LIST(NOSOURCE); %,
1233		END_LIST = SWITCHES LIST(SOURCE); END %,
1234		DM(ADDR,DATA) = MEM_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
1235		EM(ADDR) = MEM_EXAMINE(%O %STRING(ADDR)) %,
1236		DI(ADDR,DATA) = IO_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
1237		EI(ADDR) = IO_EXAMINE(%O %STRING(ADDR)) %,
1238		EX_NXT = EXNEXT() %,
1239		RD_0	= REG_EXAMINE(%O'0')%,
1240		RD_1	= REG_EXAMINE(%O'1')%,
1241		RD_2	= REG_EXAMINE(%O'2')%,
1242		RD_3	= REG_EXAMINE(%O'3')%,
1243		RD_100	= REG_EXAMINE(%O'100')%,
1244		RD_101	= REG_EXAMINE(%O'101')%,
1245		RD_102	= REG_EXAMINE(%O'102')%,
1246		RD_103	= REG_EXAMINE(%O'103')%,
1247		RD_300	= REG_EXAMINE(%O'300')%,
1248		RD_301	= REG_EXAMINE(%O'301')%,
1249		RD_303	= REG_EXAMINE(%O'303')%;
1250	
1251	!
1252	! EQUATED SYMBOLS:
1253	!
1254	
1255	    BUILTIN
1256		POINT,
1257		SCANI,
1258		REPLACEI;
1259	
1260	    EXTERNAL ROUTINE
1261		CONTROL: NOVALUE, 
1262		MEMSIZE,
1263		ERR: NOVALUE,
1264		ERRCA: NOVALUE,
1265		ERRCAS: NOVALUE,
1266		ERRS: NOVALUE,
1267		ERRM: NOVALUE,
1268		ERMCA: NOVALUE,
1269		ERMCAS: NOVALUE,
1270		ERMS: NOVALUE,
1271		NOERR: NOVALUE,
1272		FAILURE: NOVALUE,
1273		LOOP_CHK,
1274		FLP_CHK,
1275		CHK_ERR_MSG: NOVALUE,
1276		WAIT: NOVALUE,
1277		SEND_LINE,
1278		REPEAT: NOVALUE,
1279		PTSTNUM: NOVALUE,
1280		CP: NOVALUE,
1281		CP_NOSS: NOVALUE,
1282		SEND_NUL,
1283		SETNXT: NOVALUE,
1284		EXNEXT,
1285		WR_CRAM,
1286		X1,
1287		LOADUC: NOVALUE,
1288		MR: NOVALUE,
1289		PE: NOVALUE,
1290		CE: NOVALUE,
1291		CS: NOVALUE,
1292		CH: NOVALUE,
1293	        TP: NOVALUE,
1294	        TE: NOVALUE,
1295		EJ,
1296		SC_0: NOVALUE,
1297		EC,
1298		LCA: NOVALUE,
1299		DC_035: NOVALUE,
1300		MOD_FLD: NOVALUE,
1301		DM_CHK,
1302		MEM_DEPOSIT: NOVALUE,
1303		MEM_EXAMINE,
1304		EM_CHK,
1305		DN: NOVALUE,
1306		IO_DEPOSIT: NOVALUE,
1307		IO_EXAMINE,
1308		EI_CHK,
1309		REG_EXAMINE,
1310		WRT100: NOVALUE,
1311		WRT102: NOVALUE,
1312		WRT103: NOVALUE,
1313		WRT104: NOVALUE,
1314		WRT105: NOVALUE,
1315		WRT106: NOVALUE,
1316		WRT107: NOVALUE,
1317		WRT110: NOVALUE,
1318		WRT111: NOVALUE,
1319		WRT112: NOVALUE,
1320		WRT113: NOVALUE,
1321		WRT114: NOVALUE,
1322		WRT115: NOVALUE,
1323		WRT116: NOVALUE,
1324		WRT204: NOVALUE,
1325		WRT205: NOVALUE,
1326		WRT206: NOVALUE,
1327		WRT210: NOVALUE,
1328		WRT212: NOVALUE,
1329		SYNC_CLK: NOVALUE,
1330		TICK: NOVALUE;
1331	
1332	    EXTERNAL
1333		NO_SUBSET,
1334		LPONTST,
1335		TIMOUT,
1336		RPT_ERR_FLAG,
1337		ERRFLG;
1338	
1339	! END OF "STIRSD.R36"
1340	
1341	
1342	!
1343	! MACROS:
1344	!
1345	
1346	MACRO
1347	
1348		V_AC_DP = U_DBUS_DP U_RAM_AC U_FMWRITE %,	! AC0 <-- DP
1349		V_D_AC = U_DBUS_RAM U_RAM_AC %,			! D <-- AC0
1350		V_DP_0 = U_A_T1 U_LSRC_0A U_ALU_AND %,		! DP <-- 0
1351		V_DP__1 = U_A_T1 U_B_T1 U_LSRC_AB U_ALU_XNOR %,	! DP <-- -1
1352		V_DP_D = U_LSRC_D0 U_ALU_OR %,			! DP <-- D
1353		CYCLE(CNT) = TICK(4*CNT)%,		!4 TICKS = 1 T-CLK CYCLE
1354		STOP_CLK  = WRT205(MNT_CLK_ENB)%;	!STOPS SYSTEM CLOCK
1355	
1356	!
1357	! EQUATED SYMBOLS:
1358	!
1359	
1360	GLOBAL BIND
1361		MSGFIL = UPLIT(%SIXBIT 'MSCSL',%SIXBIT 'MSG'),
1362		PRGNAM = UPLIT(%ASCIZ 'KS10 STIMULUS-RESPONSE DIAGNOSTIC FOR THE M8616 BOARD');
1363	
1364	GLOBAL LITERAL
1365		TEST_VERSION = 1,			!VERSION NUMBER FOR THIS MODULE
1366		TEST_EDIT = 4;				!EDIT NUMBER FOR THIS MODULE
1367	
1368	!
1369	! OWN STORAGE:
1370	!
1371	
1372	OWN
1373		ERROR_FLAG;				!FLAG SET BY 'ERR_CHK_4' AND
1374							! 'ERR_CHK_8' WHEN ERROR IS DETECTED
1375	
1376	!
1377	! EXTERNAL REFERENCES:
1378	!
1379	
1380	
1381	GLOBAL ROUTINE SPEC_DIALOGUE: NOVALUE =
1382	!++
1383	! FUNCTIONAL DESCRIPTION
1384	!
1385	!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PERFORM ANY
1386	!	SPECIAL USER DIALOGUE BEFORE THE ACTIVATED FEATURES ARE LISTED.
1387	!	SINCE THIS TEST MODULE HAS NO SPECIAL DIALOGUE, THIS ROUTINE IS NUL.
1388	!
1389	! FORMAL PARAMETERS:
1390	!
1391	!	NONE
1392	!
1393	! IMPLICIT INPUTS:
1394	!
1395	!	NONE
1396	!
1397	! IMPLICIT OUTPUTS:
1398	!
1399	!	NONE
1400	!
1401	! ROUTINE VALUE:
1402	!
1403	!	NONE
1404	!
1405	! SIDE EFFECTS:
1406	!
1407	!	NONE
1408	!
1409	!--
1410		BEGIN
1411		0				!TO PREVENT INFO MSG WHEN COMPILING
1412		END;
1413	
1414	GLOBAL ROUTINE SPEC_PRT =
1415	!++
1416	! FUNCTIONAL DESCRIPTION
1417	!
1418	!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PRINT ANY SPECIAL
1419	!	PROGRAM FEATURES WHICH MAY BE ACTIVATED.  SINCE THIS TEST MODULE HAS NO
1420	!	SPECIAL FEATURES, THE ROUTINE IS NUL.
1421	!
1422	! FORMAL PARAMETERS:
1423	!
1424	!	NONE
1425	!
1426	! IMPLICIT INPUTS:
1427	!
1428	!	NONE
1429	!
1430	! IMPLICIT OUTPUTS:
1431	!
1432	!	NONE
1433	!
1434	! ROUTINE VALUE:
1435	!
1436	!	NONE
1437	!
1438	! SIDE EFFECTS:
1439	!
1440	!	NONE
1441	!
1442	!--
1443		BEGIN
1444		0				!TO PREVENT INFO MSG WHEN COMPILING
1445		END;
1446	
1447	GLOBAL ROUTINE SPEC_ASK: NOVALUE =
1448	!++
1449	! FUNCTIONAL DESCRIPTION
1450	!
1451	!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO ASK THE USER IF
1452	!	HE/SHE WISHES TO ACTIVATE FEATURES WHICH ARE PECULIAR TO THIS TEST
1453	!	MODULE.  SINCE THIS MODULE HAS NO SPECIAL FEATURES, THE ROUTINE IS NUL.
1454	!
1455	! FORMAL PARAMETERS:
1456	!
1457	!	NONE
1458	!
1459	! IMPLICIT INPUTS:
1460	!
1461	!	NONE
1462	!
1463	! IMPLICIT OUTPUTS:
1464	!
1465	!	NONE
1466	!
1467	! ROUTINE VALUE:
1468	!
1469	!	NONE
1470	!
1471	! SIDE EFFECTS:
1472	!
1473	!	NONE
1474	!
1475	!--
1476		BEGIN
1477		0				!TO PREVENT INFO MSG WHEN COMPILING
1478		END;
1479	
1480	GLOBAL ROUTINE TEST_INIT: NOVALUE =
1481	
1482	!++
1483	! FUNCTIONAL DESCRIPTION:
1484	!
1485	!	THIS ROUTINE INITIALIZES THE DATA BASE AND THE KS10 UNDER TEST BEFORE
1486	!	ANY TESTING IS DONE.
1487	!
1488	! FORMAL PARAMETERS:
1489	!
1490	!	NONE
1491	!
1492	! IMPLICIT INPUTS:
1493	!
1494	!	NONE
1495	!
1496	! IMPLICIT OUTPUTS:
1497	!
1498	!	RPT_ERR_FLAG	= SET TO 0 TO INHIBIT REPORTING OF UNEXPECTED 8080
1499	!			  ERROR RESPONSES.
1500	!
1501	! ROUTINE VALUE:
1502	!
1503	!	NONE
1504	!
1505	! SIDE EFFECTS:
1506	!
1507	!	INITIALIZES KS10 BEING TESTED.
1508	!
1509	!--
1510		BEGIN
1511	
1512		BIND
1513			INIT_UCODE = PLIT(
1514	U_J(1) V_DP_0 U_SPEC_LDACBLK U,
1515	U_J(2) V_DP_0 U_DBUS_DP U_SPEC_LOADIR U,
1516	U_J(3) V_DP__1 V_AC_DP U,
1517	U_J(4) V_D_AC V_DP_D U_B_AR U_DEST_AD U,
1518	U_J(5) U_A_AR U_B_ARX U_LSRC_0A U_ALU_OR U_DEST_AD U,
1519	U_J(6) U_A_ARX U_B_ARX U_LSRC_AB U_ALU_ADD U_DEST_AD U,
1520	U_J(7) U_A_ARX U_ALU_XNOR U_LSRC_0A V_AC_DP U,
1521	U_J(10) V_D_AC V_DP_D U_B_BR U_DEST_AD U,
1522	U_J(11) V_DP_0 U_B_BRX U_DEST_AD U_SPEC_APR_EN U,
1523	U_J(12) V_DP_0 U_DBM_N U_N(0) U_SPEC_FLAGS U,
1524	U_J(13) U_SPEC_CLRCLK U,
1525	U_J(14) V_DP__1 U_SPEC_LDPI U,
1526	U_J(14) V_DP_0 U_SPEC_MEMCLR U
1527		    );
1528	
1529	!THE FOLLOWING CODE IS COMMENTED OUT PENDING FURTHER TESTING.  IT
1530	!WAS ADDED IN AN ATTEMPT TO SOLVE THE PROBLEM OF HAVING TO DO A "BT"
1531	!BEFORE RUNNING THIS STIRS AFTER POWERING UP.
1532	
1533	!	BIND
1534	!		BTCODE = PLIT(
1535	!UPLIT(%ASCIZ 'LC0,DC20707400077770037377760724100'),
1536	!UPLIT(%ASCIZ 'LC2,DC130707400000000000344732724502'),
1537	!UPLIT(%ASCIZ 'LC13,DC530707000000010000355772724100'),
1538	!UPLIT(%ASCIZ 'LC53,DC610707400000000000344732604700'),
1539	!UPLIT(%ASCIZ 'LC61,DC710707000000010000377760754102'),
1540	!UPLIT(%ASCIZ 'LC71,DC31707400000010000475772674102'),
1541	!UPLIT(%ASCIZ 'LC3,DC1000707400060000037475772634100'),
1542	!UPLIT(%ASCIZ 'LC100,DC1060707400002274000333720637302'),
1543	!UPLIT(%ASCIZ 'LC106,DC1100727507000100000422660714100'),
1544	!UPLIT(%ASCIZ 'LC110,DC1250747007000000000422720704100'),
1545	!UPLIT(%ASCIZ 'LC125,DC1310727405000000000422720734100'),
1546	!UPLIT(%ASCIZ 'LC131,DC1360707400002304000333720737300'),
1547	!UPLIT(%ASCIZ 'LC136,DC1620707000003004000333720737302'),
1548	!UPLIT(%ASCIZ 'LC162,DC2120707400003014000333720737300'),
1549	!UPLIT(%ASCIZ 'LC212,DC2140707400014434000422720601300'),
1550	!UPLIT(%ASCIZ 'LC214,DC2230707000014444000333720671302'),
1551	!UPLIT(%ASCIZ 'LC223,DC2260707000000230071422720634142'),
1552	!UPLIT(%ASCIZ 'LC226,DC2350707400003444000333720677302'),
1553	!UPLIT(%ASCIZ 'LC235,DC2420707400003734000422720607300'),
1554	!UPLIT(%ASCIZ 'LC242,DC2440707400003440000377760624100'),
1555	!UPLIT(%ASCIZ 'LC244,DC3110707000003730000377760664100'),
1556	!UPLIT(%ASCIZ 'LC311,DC100707100000100000011727664100'),
1557	!UPLIT(%ASCIZ 'LC10,DC5603707000014441400377740641102'),
1558	!UPLIT(%ASCIZ 'LC560,DC6203707400014431400377740651102'),
1559	!UPLIT(%ASCIZ 'LC620,DC6211707400000000000444720604300'),
1560	!UPLIT(%ASCIZ 'LC621,DC6220707000000000000011725654100'),
1561	!UPLIT(%ASCIZ 'LC622,DC21323507000600000000011724644100'),
1562	!UPLIT(%ASCIZ 'LC2132,DC40704010000000000444720604300'),
1563	!UPLIT(%ASCIZ 'LC626,DC10704010000000000444720604300'),
1564	!UPLIT(%ASCIZ 'LC561,DC21325507000614440000055744641100'),
1565	!UPLIT(%ASCIZ 'LC565,DC6002707400014430000055745651102'),
1566	!UPLIT(%ASCIZ 'LC600,DC6211707400000000000444720604300'),
1567	!UPLIT(%ASCIZ 'LC601,DC21323507000600000000011723644102'),
1568	!UPLIT(%ASCIZ 'LC605,DC33200707400014444000344724641000'),
1569	!UPLIT(%ASCIZ 'LC3320,DC20704010014434000344725651002'),
1570	!UPLIT(%ASCIZ 'LC12,DC3230707400000004000333720656302'),
1571	!UPLIT(%ASCIZ 'LC323,DC3240707500000100000011727624102'),
1572	!UPLIT(%ASCIZ 'LC324,DC2240607000300004060333720646342'),
1573	!UPLIT(%ASCIZ 'LC224,DC3110707000000000000444720604300'),
1574	!UPLIT(%ASCIZ 'LC2133,DC33210707000077770037455764444100'),
1575	!UPLIT(%ASCIZ 'LC3321,DC40704010000000000011727654102'),
1576	!UPLIT(%ASCIZ 'LC225,DC1402307400206560033655765604300'),
1577	!UPLIT(%ASCIZ 'LC141,DC35731707000000000000422720744102'),
1578	!UPLIT(%ASCIZ 'LC3573,DC35740707000000000000377474764002'),
1579	!UPLIT(%ASCIZ 'LC3574,DC35750707200000000000244727364100'),
1580	!UPLIT(%ASCIZ 'LC3575,DC35760707400000000000411734764100'),
1581	!UPLIT(%ASCIZ 'LC3576,DC100744413000000000744736604302'),
1582	!UPLIT(%ASCIZ 'LC151,DC3340707400001200000475772774102'),
1583	!UPLIT(%ASCIZ 'LC334,DC3430747006000040000422720614102'),
1584	!UPLIT(%ASCIZ 'LC343,DC1160707000000000000377760774102'),
1585	!UPLIT(%ASCIZ 'LC116,DC36570707100010160021422720644100'),
1586	!UPLIT(%ASCIZ 'LC3657,DC24762707500000020000333720774314'),
1587	!UPLIT(%ASCIZ 'LC2476,DC36531707100010160023011727244100'),
1588	!UPLIT(%ASCIZ 'LC3653,DC12704110000020000333720614316'),
1589	!UPLIT(%ASCIZ 'LC2477,DC50717400000740000444720604300'),
1590	!UPLIT(%ASCIZ 'LC5,DC40607000600000000444720604300'));
1591	!
1592	!	BIND
1593	!		BT_CMD = PLIT(UPLIT(%ASCIZ 'LK20054,DK303,DN327,DN42,LK21327,DK76,DN6,DN62,DN172,DN40,DN315,DN276,DN22'),
1594	!			UPLIT(%ASCIZ 'DN332,DN210,DN32,DN315,DN56,DN23,DN315,DN312,DN21,DN311'));
1595	!
1596	!	MAP BTCODE: VECTOR;
1597	!	MAP BT_CMD: VECTOR;
1598	!
1599		RPT_ERR_FLAG = 0;		!SET FLAG TO NOT REPORT 8080 CMD ERRORS
1600	!	INCR I FROM 0 TO 1 BY 1 DO
1601	!		SEND_LINE(.BT_CMD[.I],-1);
1602	!	SEND_LINE(UPLIT(%ASCIZ 'X1'),-1);
1603		PE(0);				!TURN OFF 8080 PARITY DETECTION
1604		CH();				!MAKE SURE KS10 CPU IS HALTED
1605		SC_0();				!TURN OFF SOFT CRAM ERR RECOVERY
1606		DM(31,0);			!CLEAR KS10 KEEP ALIVE AND STATUS WORD
1607						! SO THAT 8080 DOESN'T TRY TO REBOOT
1608						! WHEN TESTS CAUSE 'HALTED' MESSAGE
1609		SEND_NUL();			!FORCE SENDING OF COMMAND LINE
1610		CHK_ERR_MSG(PAR_ERR);		!CHECK IN CASE 'PE (1)' IS STUCK
1611		LOAD_U(0,INIT_UCODE);		!LOAD INIT MICROCODE
1612	!	INCR I FROM 0 TO (.BTCODE[-1] - 1) BY 1 DO
1613	!		SEND_LINE(.BTCODE[.I],-1);
1614		SET_C(0);			!SET CRAM START ADDR TO ZERO
1615		CP_NOSS(18);			!EXECUTE IT WITH 5 EXTRA CLOCKS TO INSURE PAGE FAIL CLEARS
1616	!	CS();				!START MICROCODE
1617		SEND_NUL();			!SEND CS CMD
1618	!	CHK_ERR_MSG(HALTED);		!CHECK FOR 'HALTED' MESSAGE
1619	!	CH();				!STOP MICROCODE
1620		CLEAR_CRAM();			!CLEAR CRAM BITS IN LOC 0
1621		WRT114(0);			!CLEAR KS10 BUS CONTROL BITS IN THE
1622		WRT115(0);			! CSL BOARD I/O BUFFERS
1623		SEND_NUL();			!FORCE SENDING OF COMMAND LINE
1624		END;
1625	
1626	ROUTINE CLEAR_CRAM: NOVALUE =
1627	
1628	!++
1629	! FUNCTIONAL DESCRIPTION:
1630	!
1631	!	THIS ROUTINE DOES A MASTER RESET OF THE KS10 AND DEPOSITS ALL ZEROS
1632	!	INTO LOCATION 0 OF THE CRAM.
1633	!
1634	! FORMAL PARAMETERS:
1635	!
1636	!	NONE
1637	!
1638	! IMPLICIT INPUTS:
1639	!
1640	!	NONE
1641	!
1642	! IMPLICIT OUTPUTS:
1643	!
1644	!	NONE
1645	!
1646	! ROUTINE VALUE:
1647	!
1648	!	NONE
1649	!
1650	! SIDE EFFECTS:
1651	!
1652	!	DOES A MASTER RESET OF THE KS10 AND DEPOSITS 0 INTO CRAM LOC 0.
1653	!
1654	!--
1655		BEGIN
1656		BIND
1657			DC_0 = UPLIT(%ASCIZ 'LC0,DC0');	!CMD STRING TO DEPOSIT ZEROS
1658	
1659		MR();				!DO A KS10 MASTER RESET
1660		SEND_LINE(DC_0,0);		!INSURE CRAM BITS ARE CLEARED
1661		END;
1662	
1663	ROUTINE RESET_CRAM: NOVALUE =
1664	
1665	!++
1666	! FUNCTIONAL DESCRIPTION:
1667	!
1668	!	THIS ROUTINE IS CALLED TO TOGGLE THE 'CRA/M RESET' SIGNAL IN THE
1669	!	KS10.  THIS CLEARS THE CRAM CONTROL BITS LATCHES.
1670	!
1671	! FORMAL PARAMETERS:
1672	!
1673	!	NONE
1674	!
1675	! IMPLICIT INPUTS:
1676	!
1677	!	NONE
1678	!
1679	! IMPLICIT OUTPUTS:
1680	!
1681	!	NONE
1682	!
1683	! ROUTINE VALUE:
1684	!
1685	!	NONE
1686	!
1687	! SIDE EFFECTS:
1688	!
1689	!	CONCATENATES A COMMAND STRING TO ASSERT AND NEGATE THE 'CRA/M RESET'
1690	!	BIT IN 8080 REGISTER 204 ONTO THE CUMULATIVE COMMAND LINE.
1691	!
1692	!--
1693		BEGIN
1694		WRT204(CRAM_RESET);			!ASSERT CRA/M RESET
1695		WRT204(0);				!THEN NEGATE IT
1696		END;
1697	
1698	ROUTINE INIT: NOVALUE =
1699	
1700	!++
1701	! FUNCTIONAL DESCRIPTION:
1702	!
1703	!	THIS ROUTINE CAUSES THE KS10 'RESET' SIGNAL TO BE TOGGLED.
1704	!
1705	! FORMAL PARAMETERS:
1706	!
1707	!	NONE
1708	!
1709	! IMPLICIT INPUTS:
1710	!
1711	!	NONE
1712	!
1713	! IMPLICIT OUTPUTS:
1714	!
1715	!	NONE
1716	!
1717	! ROUTINE VALUE:
1718	!
1719	!	NONE
1720	!
1721	! SIDE EFFECTS:
1722	!
1723	!	CAUSES A COMMAND STRING TO ASSERT AND NEGATE THE 'RESET' BIT IN 8080
1724	!	REGISTER 100 TO BE CONCATENATED ONTO THE CUMULATIVE COMMAND STRING.
1725	!
1726	!--
1727		BEGIN
1728	
1729		SEND_NUL();			!MAKE SURE 'RESET' ASSERTING ANG CLEARING
1730						!GO ON THE SAME COMMAND LINE
1731		WRT100(RESET);			!ASSERT 'RESET'
1732		WRT100(0);			!NEGATE IT
1733		END;
1734	
1735	ROUTINE ERR_CHK_4(CORRECT,ACTUAL): NOVALUE =
1736	
1737	!++
1738	! FUNCTIONAL DESCRIPTION:
1739	!
1740	!	THIS ROUTINE COMPARES 4 BITS WORTH OF CORRECT AND ACTUAL DATA.  IT
1741	!	CHECKS FOR SINGLE BIT ERRORS, COMPLEMENTED DATA, AND MULTIPLE BIT
1742	!	ERRORS.  IT IS CALLED BY THE TESTS WHICH CHECK THE KS10 BUS XCVRS.
1743	!
1744	! FORMAL PARAMETERS:
1745	!
1746	!	CORRECT		= 4 BITS OF CORRECT DATA
1747	!	ACTUAL		= 4 BITS OF ACTUAL DATA
1748	!
1749	! IMPLICIT INPUTS:
1750	!
1751	!	NONE
1752	!
1753	! IMPLICIT OUTPUTS:
1754	!
1755	!	ERROR_FLAG	= -1 IF CORRECT IS NOT EQUAL TO ACTUAL.
1756	!			  UNCHANGED OTHERWISE
1757	!
1758	! ROUTINE VALUE:
1759	!
1760	!	NONE
1761	!
1762	! SIDE EFFECTS:
1763	!
1764	!	IF ERROR IS DETECTED, FAULT ISOLATION IS PERFORMED.
1765	!
1766	!--
1767		BEGIN
1768		LOCAL
1769			DISCREP;
1770	
1771		IF .ACTUAL EQL .CORRECT		!IS DATA CORRECT?
1772		THEN
1773			RETURN;			!YES, JUST RETURN
1774		ERROR_FLAG = -1;		!SET ERROR FLAG
1775		ERMCA(1,.CORRECT,.ACTUAL,3);	!REPORT ERROR
1776		DISCREP = .ACTUAL XOR .CORRECT;	!COMPUTE DISCREPANCIES
1777	
1778	!CHECK FOR SINGLE BIT ERROR
1779	
1780		INCR J FROM 0 TO 3 BY 1 DO
1781			IF .DISCREP EQL 1^.J
1782			THEN
1783				BEGIN
1784				FAILURE(1+.J);	!DO FAULT ISOLATION
1785				RETURN;
1786				END;
1787	
1788	!CHECK IF ACTUAL DATA IS COMPLEMENTED
1789	
1790		IF .DISCREP EQL %O'17'
1791		THEN
1792			BEGIN
1793			FAILURE(5);	!DO FAULT ISOLATION
1794			RETURN;
1795			END;
1796	
1797	!IF WE GET THIS FAR THEN THE WHOLE WORD MUST BE INCORRECT
1798	
1799		FAILURE(6);	!DO FAULT ISOLATION
1800		END;
1801	
1802	ROUTINE ERR_CHK_8(CORRECT,ACTUAL): NOVALUE =
1803	
1804	!++
1805	! FUNCTIONAL DESCRIPTION:
1806	!
1807	!	THIS ROUTINE COMPARES 8 BITS WORTH OF CORRECT AND ACTUAL DATA.  IT
1808	!	CHECKS FOR SINGLE BIT ERRORS, COMPLEMENTED DATA, AND MULTIPLE BIT
1809	!	ERRORS.  IT IS CALLED BY THE TESTS WHICH CHECK THE KS10 BUS XCVRS.
1810	!
1811	! FORMAL PARAMETERS:
1812	!
1813	!	CORRECT		= 8 BITS OF CORRECT DATA
1814	!	ACTUAL		= 8 BITS OF ACTUAL DATA
1815	!
1816	! IMPLICIT INPUTS:
1817	!
1818	!	NONE
1819	!
1820	! IMPLICIT OUTPUTS:
1821	!
1822	!	ERROR_FLAG	= -1 IF CORRECT IS NOT EQUAL TO ACTUAL.
1823	!			  UNCHANGED OTHERWISE
1824	!
1825	! ROUTINE VALUE:
1826	!
1827	!	NONE
1828	!
1829	! SIDE EFFECTS:
1830	!
1831	!	IF ERROR IS DETECTED, FAULT ISOLATION IS PERFORMED.
1832	!
1833	!--
1834		BEGIN
1835		LOCAL
1836			DISCREP;
1837	
1838		IF .ACTUAL EQL .CORRECT		!IS DATA CORRECT?
1839		THEN
1840			RETURN;			!YES, JUST RETURN
1841		ERROR_FLAG = -1;		!SET ERROR FLAG
1842		ERMCA(1,.CORRECT,.ACTUAL,3);	!REPORT ERROR
1843		DISCREP = .ACTUAL XOR .CORRECT;	!COMPUTE DISCREPANCIES
1844	
1845	!CHECK FOR SINGLE BIT ERROR
1846	
1847		INCR J FROM 0 TO 7 BY 1 DO
1848			IF .DISCREP EQL 1^.J
1849			THEN
1850				BEGIN
1851				FAILURE(1+.J);	!DO FAULT ISOLATION
1852				RETURN;
1853				END;
1854	
1855	!CHECK IF ACTUAL DATA IS COMPLEMENTED
1856	
1857		IF .DISCREP EQL %O'377'
1858		THEN
1859			BEGIN
1860			FAILURE(9);	!DO FAULT ISOLATION
1861			RETURN;
1862			END;
1863	
1864	!CHECK FOR HIGH ORDER FOUR BITS COMPLEMENTED
1865	
1866		IF .DISCREP EQL %O'360'
1867		THEN
1868			BEGIN
1869			FAILURE(10);	!DO FAULT ISOLATION
1870			RETURN;
1871			END;
1872	
1873	!CHECK FOR LOW ORDER FOUR BITS COMPLEMENTED
1874	
1875		IF .DISCREP EQL %O'17'
1876		THEN
1877			BEGIN
1878			FAILURE(11);	!DO FAULT ISOLATION
1879			RETURN;
1880			END;
1881	
1882	!CHECK FOR JUST HIGH ORDER FOUR BITS INCORRECT
1883	
1884		IF (.DISCREP AND %O'360') NEQ 0
1885		THEN
1886			BEGIN
1887			FAILURE(12);		!DO FAULT ISOLATION
1888			RETURN;
1889			END;
1890	
1891	!CHECK FOR JUST LOW ORDER FOUR BITS INCORRECT
1892	
1893		IF (.DISCREP AND %O'17') NEQ 0
1894		THEN
1895			BEGIN
1896			FAILURE(13);		!DO FAULT ISOLATION
1897			RETURN;
1898			END;
1899	
1900	!IF WE GET THIS FAR THEN THE WHOLE WORD MUST BE INCORRECT
1901	
1902		FAILURE(14);	!DO FAULT ISOLATION
1903		END;
1904	
1905	GLOBAL ROUTINE TST1: NOVALUE =
1906	
1907	!THIS TEST CHECKS THAT 'RESET' CAN BE ASSERTED AND NEGATED.
1908	!SINCE THE 'RESET' FLOP CANNOT BE READ DIRECTLY 'R RESET' IS READ.
1909	!'R RESET' IS THE PROPAGATION OF 'RESET' ONTO THE KS10 BUS AND BACK
1910	!INTO THE 8646 RECEIVERS.
1911	!AT THE SAME TIME THAT 'RESET' IS ASSERTED, 'PE DETECT' IS NEGATED.
1912	!SO A CHECK IS MADE TO INSURE THAT 'PE (1)' IS NEGATED.
1913	
1914		BEGIN
1915		LABEL BLOCK1;
1916		LOCAL
1917			ERFLG,
1918			TEMP;
1919		BIND
1920			PTR = UPLIT(%ASCIZ 'LR100,DR0,DR200,ER102,LR100,DR0');
1921		BIND
1922			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,RP');
1923	
1924		ERFLG = 0;		!INIT ERROR FLAG
1925		DO (0) WHILE
1926	BLOCK1:
1927		BEGIN
1928		TEMP = .(SEND_LINE(PTR,1) + 1);		!SEND COMMANDS TO ASSERT AND READ 'R RESET'
1929		CHK_ERR_MSG(PAR_ERR);			!CHECK FOR 'PAR ERR' MESSAGE
1930		IF (.TEMP AND RRESET) EQL 0		!DID IT SET?
1931		THEN
1932			BEGIN
1933			ERR(1);				!NO, REPORT ERROR
1934			ERFLG = 1;			!SET ERROR FLAG
1935			END;
1936	!*MESSAGE 1
1937	!*STIMULUS:
1938	!*	WRT 100/0	- NEGATE 'RESET'
1939	!*	WRT 100/200	- ASSERT 'CSL3 RESET L'.  THIS SHOULD ASSERT
1940	!*			  'CSL5 RESET H' WHICH SHOULD ASSERT 'R RESET'.
1941	!*RESPONSE:
1942	!*	'R RESET' DIDN'T ASSERT
1943	!]ERROR 1
1944	!]WRT100 RST_LTCH RESETH RST_XCVR RCLKD TCLKA R_RESET RD_100 ADR1L_H ADR0L2_L NTWK
1945		IF FLP_CHK(1,FLP_PTR)
1946			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
1947	
1948		IF (RD_102 AND RRESET) NEQ 0		!DID 'R RESET' CLEAR?
1949		THEN
1950			BEGIN
1951			ERR(2);			!NO , REPORT ERROR
1952			ERFLG = 1;		!SET ERROR FLAG
1953			END;
1954	!*MESSAGE 2
1955	!*STIMULUS:
1956	!*	WRT 100/0	- NEGATE 'RESET'
1957	!*	WRT 100/200	- ASSERT 'CSL3 RESET L'.  THIS SHOULD ASSERT
1958	!*			  'CSL5 RESET H' WHICH SHOULD ASSERT 'R RESET'.
1959	!*	WRT 100/0	- NEGATE 'RESET'
1960	!*RESPONSE:
1961	!*	'R RESET' DIDN'T NEGATE
1962	!]ERROR 2
1963	!]RST1 PNL_RST RST_LTCH RESETH RST_XCVR RCLKD TCLKA R_RESET RD_100 ADR1L_H ADR0L2_L NTWK
1964		IF FLP_CHK(2,FLP_PTR)
1965			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
1966	
1967		IF .ERFLG EQL 0		!IF HAD NO ERRORS THEN
1968		THEN
1969			NOERR(1);	!DO FAULT ISOLATION
1970	!]NO ERROR 1
1971	!]RESETH RST_XCVR TCLKA RCLKD R_RESET RD_100 ADR1L_H ADR0L2_L  PNL_RST RST1 RST_LTCH WRT100 NTWK
1972	
1973		IF ( RD_301 AND PE_1 ) NEQ 0		!IS 'PE (1)' CLEAR?
1974		THEN
1975			ERR(3);		!NO, REPORT ERROR
1976	!*MESSAGE 3
1977	!*STIMULUS:
1978	!*	WRT 100/200		- ASSERT 'RESET' AND NEGATE 'PE DETECT'
1979	!*	WRT 100/0		- NEGATE 'RESET'
1980	!*RESPONSE:
1981	!*	'PE (1)' IS ASSERTED ALTHOUGH 'PE DETECT' IS NEGATED.
1982	!]ERROR 3
1983	!]PE_LTCH PE NTWK
1984		IF FLP_CHK(3,FLP_PTR)
1985			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
1986		0				!TO PREVENT INFO MSG WHEN COMPILING
1987		END;
1988	
1989		END;
1990	
1991	GLOBAL ROUTINE TST2: NOVALUE =
1992	
1993	!THIS TEST CHECKS THAT THE 'BUS REQ' FLOP CAN BE ASSERTED AND NEGATED.
1994	!SINCE IN NORMAL OPERATION 'BUS REQ' GETS CLEARED AUTOMATICALLY AFTER
1995	!BEING SET, IT IS NECESSARY TO STOP THE CLOCK IN ORDER TO FREEZE THE
1996	!FLOP IN THE ASSERTED STATE.
1997	
1998		BEGIN
1999		LOCAL
2000			ERFLG;
2001		LABEL BLOCK1;
2002		BIND
2003			FLP_PTR = UPLIT(%ASCIZ'LR210,DR0,DR100,RP');
2004	
2005		INIT();					!ASSERT AND NEGATE 'RESET'
2006		STOP_CLK;				!STOP CLOCK
2007		ERFLG = 0;		!INIT ERROR FLAG
2008		DO (0) WHILE
2009	BLOCK1:
2010		BEGIN
2011		WRT210(0);				!CLEAR BUS REQ
2012		WRT210(BUS_REQ);			!SET BUS REQ
2013		IF ( RD_301 AND BUSREQ ) EQL 0	!DID BUS REQ SET?
2014		THEN
2015			BEGIN
2016			ERR(1);		!NO, REPORT ERROR
2017			ERFLG = 1;	!SET ERROR FLAG
2018			END;
2019	!*MESSAGE 1
2020	!*STIMULUS:
2021	!*	WRT 205/100	- STOP CLOCK
2022	!*	WRT 210/0	- NEGATE 'BUS REQ'
2023	!*	WRT 210/100	- ASSERT 'BUS REQ'
2024	!*RESPONSE:
2025	!*	'BUS REQ' DIDN'T ASSERT
2026	!]ERROR 1
2027	!]WRT210 RESETB_L BUSREQ GRANT GRANT_1 BUS_ARB BUS_REQ RD_300 ADR0L2_H NTWK
2028	
2029		IF FLP_CHK(1,FLP_PTR)
2030		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2031	
2032		WRT210(0);				!CLEAR BUS REQ
2033		IF ( RD_301 AND BUSREQ ) NEQ 0	!DID BUS REQ CLEAR?
2034		THEN
2035			BEGIN
2036			ERR(2);		!NO, REPORT ERROR
2037			ERFLG = 1;	!SET ERROR FLAG
2038			END;
2039	!*MESSAGE 2
2040	!*STIMULUS:
2041	!*	WRT 205/100	- STOP CLOCK
2042	!*	WRT 210/0	- NEGATE 'BUS REQ'
2043	!*	WRT 210/100	- ASSERT 'BUS REQ'
2044	!*	WRT 210/0	- NEGATE 'BUS REQ'
2045	!*RESPONSE:
2046	!*	'BUS REQ' DIDN'T NEGATE
2047	!]ERROR 2
2048	!]BUSREQ WRT210 BUS_REQ RD_300 ADR0L2_H NTWK
2049	
2050		IF FLP_CHK(2,FLP_PTR)
2051			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2052		0				!TO PREVENT INFO MSG WHEN COMPILING
2053	
2054		END;
2055	
2056	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
2057	
2058		IF .ERFLG EQL 0
2059		THEN
2060			NOERR(1);
2061	!]NO ERROR 1
2062	!]RESETB_L BUSREQ BUS_REQ RD_300 ADR0L2_H WRT210 NTWK
2063	
2064		INIT();				!START CLOCK
2065		END;
2066	
2067	GLOBAL ROUTINE TST3: NOVALUE =
2068	
2069	!THIS TEST CHECKS THAT 'BUS REQ' GETS NEGATED AUTOMATICALLY AFTER IT IS
2070	!ASSERTED.  ASSERTING 'BUS REQ' SHOULD CAUSE THE BUS ARBITRATOR TO
2071	!GENERATE A 'GRANT' SIGNAL WHICH NEGATES THE 'BUS REQ' FLOP.
2072	
2073		BEGIN
2074		LABEL BLOCK1;
2075		BIND
2076			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR100,RP');
2077	
2078		DO (0) WHILE
2079	BLOCK1:
2080		BEGIN
2081		INIT();					!ASSERT AND NEGATE 'RESET'
2082		WRT210(BUS_REQ);			!SET BUS REQ
2083		IF ( RD_301 AND BUSREQ ) NEQ 0	!DID BUS REQ CLEAR?
2084		THEN
2085			ERR(1)		!NO, REPORT ERROR
2086		ELSE
2087			NOERR(1);	!YES, DO FAULT ISOLATION ANYWAY
2088	!*MESSAGE 1
2089	!*STIMULUS:
2090	!*	ASSERT AND NEGATE 'RESET'
2091	!*	WRT 210/100	- ASSERT 'BUS REQ'
2092	!*RESPONSE:
2093	!*	'BUS REQ' DIDN'T NEGATE
2094	!]ERROR 1
2095	!]BUSREQ BUS_REQ REQ_CTL GRANT GRANT_1 BUS_ARB TCLKD TCLKC RCLKH RD_300 ADR0L2_H NTWK
2096	!]NO ERROR 1
2097	!]TCLKD TCLKC RCLKH NTWK
2098	
2099		IF FLP_CHK(1,FLP_PTR)
2100			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2101		0				!TO PREVENT INFO MSG WHEN COMPILING
2102		END;
2103	
2104		END;
2105	
2106	GLOBAL ROUTINE TST4: NOVALUE =
2107	
2108	!THIS TEST CHECKS THAT 'NEXM' ASSERTS IF A BUS REQUEST IS MADE WITH
2109	!'MEM' SET BUT WITHOUT SENDING A MEMORY COMMAND OVER THE BUS.
2110	!AN ERROR WOULD INDICATE A FAILURE IN EITHER THE BUS ARBITRATOR LOGIC
2111	!OR THE NEXM LOGIC.
2112	!AFTER 'NEXM' IS ASSERTED, A 'WRT 114' PULSE IS GENERATED TO NEGATE IT.
2113	
2114		BEGIN
2115		LABEL BLOCK1;
2116		BIND
2117			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR0,LR210,DR300,RP');
2118		LOCAL
2119			ERFLG;
2120	
2121		ERFLG = 0;		!INIT ERROR FLAG
2122		DO (0) WHILE
2123	BLOCK1:
2124		BEGIN
2125		INIT();					!ASSERT AND NEGATE 'RESET'
2126		WRT114(0);				!GENERATE WRT 114 PULSE TO CLEAR NEXM
2127		WRT210(MEM + BUS_REQ);		!SET 'MEM' AND BUS REQ
2128		IF ( RD_301 AND NEXM ) EQL 0		!DID NEXM SET?
2129		THEN
2130			BEGIN
2131			ERFLG = -1;	!SET ERROR FLAG
2132			ERR(1)		!NO, REPORT ERROR
2133			END
2134		ELSE
2135			NOERR(1);	!YES, DO FAULT ISOLATION
2136	!*MESSAGE 1
2137	!*STIMULUS:
2138	!*	ASSERT AND NEGATE 'RESET'
2139	!*	WRT 114/0 (TO NEGATE NEXM)
2140	!*	WRT 210/300	- ASSERT 'MEM' AND 'BUS REQ'.
2141	!*RESPONSE:
2142	!*	'NEXM' DIDN'T ASSERT
2143	!]ERROR 1
2144	!]NEXM NEXM_LTCH RCLKD GRANT_1 MEM RESETL_L WRT210 WRT114 MEM_BUSY  RD_300 ADR0L2_H NTWK
2145	!]NO ERROR 1
2146	!]RESETL_L NTWK
2147	
2148		IF FLP_CHK(1,FLP_PTR)
2149			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2150	
2151		WRT114(0);				!GENERATE WRT 114 PULSE TO CLEAR NEXM
2152		IF ( RD_301 AND NEXM ) NEQ 0		!DID NEXM CLEAR?
2153		THEN
2154			BEGIN
2155			ERFLG = -1;	!SET ERROR FLAG
2156			ERR(2);		!NO, REPORT ERROR
2157			END;
2158	!*MESSAGE 2
2159	!*STIMULUS:
2160	!*	ASSERT AND NEGATE 'RESET'
2161	!*	WRT 114/0 (TO NEGATE NEXM)
2162	!*	WRT 210/300	- ASSERT 'MEM' AND 'BUS REQ'
2163	!*	WRT 114/0 (TO NEGATE NEXM)
2164	!*RESPONSE:
2165	!*	'NEXM' DIDN'T NEGATE
2166	!]ERROR 2
2167	!]WRT114 NEXM_LTCH NEXM RD_300 ADR0L2_H NTWK
2168	
2169		IF FLP_CHK(2,FLP_PTR)
2170			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2171		0				!TO PREVENT INFO MSG WHEN COMPILING
2172		END;
2173	
2174	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
2175	
2176		IF .ERFLG EQL 0
2177		THEN
2178			NOERR(2);
2179	!]NO ERROR 2
2180	!]NEXM RD_300 ADR0L2_H NTWK
2181	
2182		END;
2183	
2184	GLOBAL ROUTINE TST5: NOVALUE =
2185	
2186	!THIS TEST CHECKS THAT 'GRANT' IS NOT STUCK TOGGLING, I.E., ASSERTING
2187	!AND NEGATING UNCONTROLLABLY.  THIS COULD HAPPEN IF 'CONSOLE REQ' IS
2188	!STUCK ASSERTED.  THIS FAULT WOULD HAVE CAUSED THE PREVIOUS TEST TO
2189	!FAIL AT NEGATING 'NEXM'.  IT WOULD HAVE ASSERTED AGAIN AUTOMATICALLY
2190	!AFTER BEING NEGATED BY WRT 114.  IN THIS TEST, NEXM IS ASSERTED BUT
2191	!BEFORE WRT 114 IS DONE, A RESET IS DONE.  THIS CLEARS 'MEM', WHICH
2192	!PREVENTS A TOGGLING 'GRANT' FROM REASSERTING NEXM.
2193	!SO, IF THE PREVIOUS TEST FAILS AND THIS ONE DOESN'T THEN 'GRANT' IS
2194	!STUCK TOGGLING.  IF BOTH TESTS FAIL THEN 'GRANT' IS NOT STUCK TOGGLING.
2195	!IF THE PREVIOUS TEST PASSES, THIS TEST WON'T BE RUN.
2196	
2197		BEGIN
2198		LABEL BLOCK1;
2199		BIND
2200			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR300,LR100,DR200,DR0,LR114,DR0,RP');
2201	
2202		INIT();					!ASSERT AND NEGATE 'RESET'
2203		DO (0) WHILE
2204	BLOCK1:
2205		BEGIN
2206		WRT210(MEM + BUS_REQ);		!SET 'MEM' AND BUS REQ
2207		INIT();					!ASSERT AND NEGATE 'RESET'
2208		WRT114(0);				!GENERATE WRT 114 PULSE TO CLEAR NEXM
2209		IF ( RD_301 AND NEXM ) NEQ 0		!DID NEXM CLEAR?
2210		THEN
2211			ERR(1);		!NO, REPORT ERROR
2212	!*MESSAGE 1
2213	!*STIMULUS:
2214	!*	ASSERT AND NEGATE 'RESET'
2215	!*	WRT 210/300	- ASSERT 'MEM' AND 'BUS REQ'
2216	!*	ASSERT AND NEGATE 'RESET'
2217	!*	WRT 114/0 (TO NEGATE NEXM)
2218	!*RESPONSE:
2219	!*	NEXM DIDN'T NEGATE
2220	!]ERROR 1
2221	!]CONS_REQ NTWK
2222	
2223		IF FLP_CHK(1,FLP_PTR)
2224			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2225		0				!TO PREVENT INFO MSG WHEN COMPILING
2226		END;
2227	
2228		END;
2229	
2230	GLOBAL ROUTINE TST6: NOVALUE =
2231	
2232	!THIS TEST CHECKS THAT 'NEXM' DOES NOT ASSERT IF 'MEM' IS NOT
2233	!ASSERTED.
2234	
2235		BEGIN
2236		LABEL BLOCK1;
2237		BIND
2238			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR0,LR210,DR100,RP');
2239		DO (0) WHILE
2240	BLOCK1:
2241		BEGIN
2242		INIT();					!ASSERT AND NEGATE 'RESET'
2243		WRT115(0);				!MAKE SURE 'COM/ADR' IS NEGATED
2244		WRT210(BUS_REQ);			!SET BUS REQ WITHOUT 'MEM'
2245		IF ( RD_301 AND NEXM ) NEQ 0		!DID NEXM STAY CLEARED?
2246		THEN
2247			ERR(1);		!NO,REPORT ERROR
2248	!*MESSAGE 1
2249	!*STIMULUS:
2250	!*	ASSERT AND NEGATE 'RESET'
2251	!*	WRT 115/0		- INSURE THAT 'COM/ADR' WILL BE NEGATED
2252	!*	WRT 210/100	- ASSERT 'BUS REQ' WITHOUT 'MEM'.
2253	!*RESPONSE:
2254	!*	NEXM ASSERTED
2255	!]ERROR 1
2256	!]MEMH NTWK
2257	
2258		IF FLP_CHK(1,FLP_PTR)
2259			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2260		0				!TO PREVENT INFO MSG WHEN COMPILING
2261		END;
2262	
2263		END;
2264	
2265	GLOBAL ROUTINE TST7: NOVALUE =
2266	
2267	!THIS TEST CHECKS THAT ASSERTING 'CLOSE LATCHS' CAUSES 'R CLK ENB' TO
2268	!NEGATE AND VICE-VERSA.
2269	
2270		BEGIN
2271		LABEL BLOCK1;
2272		BIND
2273			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,DR0,RP');
2274		LOCAL
2275			ERFLG;
2276	
2277		ERFLG = 0;		!INIT ERROR FLAG
2278		DO (0) WHILE
2279	BLOCK1:
2280		BEGIN
2281		INIT();			!DO A RESET
2282		WRT210(0);				!CLEAR CLOSE LATCHS
2283		WRT210(CLOSE_LATCH);			!SET CLOSE LATCHS
2284		IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
2285		THEN
2286			BEGIN
2287			ERR(1);		!NO, REPORT ERROR
2288			ERFLG = -1;	!SET ERROR FLAG
2289			END;
2290	!*MESSAGE 1
2291	!*STIMULUS:
2292	!*	WRT 210/0	- NEGATE 'CLOSE LATCHS'
2293	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'. THIS SHOULD NEGATE
2294	!*			 'R CLK ENB'.
2295	!*RESPONSE:
2296	!*	'R CLK ENB (0) H' DIDN'T ASSERT
2297	!]ERROR 1
2298	!]TCLKD TCLKB C_LTCH1 RCLK_ENB0 C_LTCHS R_CLK_ENB RD_302 ADR0L6_H NTWK
2299	
2300		IF FLP_CHK(1,FLP_PTR)
2301			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2302	
2303		WRT210(0);				!CLEAR CLOSE LATCHS
2304		IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB SET?
2305		THEN
2306			BEGIN
2307			ERR(2);		!NO, REPORT ERROR
2308			ERFLG = -1;	!SET ERROR FLAG
2309			END;
2310	!*MESSAGE 2
2311	!*STIMULUS:
2312	!*	WRT 210/0	- NEGATE 'CLOSE LATCHS'
2313	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'. THIS SHOULD NEGATE
2314	!*			 'R CLK ENB'.
2315	!*	WRT 210/0	- NEGATE 'CLOSE LATCHS'. THIS SHOULD ASSERT
2316	!*			  'R CLK ENB'.
2317	!*RESPONSE:
2318	!*	'R CLK ENB (0) H' DIDN'T NEGATE
2319	!]ERROR 2
2320	!]RCLK_ENB0 R_CLK_ENB LTCH_DATA_ENB C_LTCH1 C_LTCHS GRANT BUSREQ RD_302 ADR0L6_H NTWK
2321	
2322		IF FLP_CHK(2,FLP_PTR)
2323			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2324		0				!TO PREVENT INFO MSG WHEN COMPILING
2325		END;
2326	
2327		IF .ERFLG NEQ 0		!IF WE HAD NO ERRORS, THEN
2328		THEN
2329			NOERR(1);	!DO SOME FAULT ISOLATION
2330	!]NO ERROR 1
2331	!]C_LTCH1 C_LTCHS TCLKD TCLKB RD_302 ADR0L6_H RCLK_ENB0 NTWK
2332	
2333		END;
2334	
2335	GLOBAL ROUTINE TST8: NOVALUE =
2336	
2337	!THIS TEST CHECKS THAT THE SINGLE PULSING OF THE MAIN CLOCK WORKS.
2338	!TO DO THIS, THE CLOCK IS STOPPED AND 'CLOSE LATCHS' IS ASSERTED.  THEN
2339	!8 CLOCK TICKS ARE GENERATED.  IF 'R CLK ENB' DOESN'T NEGATE, THERE
2340	!IS A FAULT.
2341	
2342		BEGIN
2343		LABEL BLOCK1;
2344		DO (0) WHILE
2345	BLOCK1:
2346		BEGIN
2347		INIT();					!DO A RESET
2348		STOP_CLK;				!STOP THE CLOCK
2349		WRT210(CLOSE_LATCH);			!ASSERT CLOSE LATCHS
2350		IF ( RD_303 AND R_CLK_ENB0) NEQ 0	!DID 'R CLK ENB' NEGATE?
2351		THEN
2352			ERR(1);		!YES, REPORT ERROR
2353	!*MESSAGE 1
2354	!*STIMULUS:
2355	!*	WRT 205/100	- STOP CLOCK
2356	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'
2357	!*RESPONSE:
2358	!*	'R CLK ENB' NEGATED EVEN THOUGH CLOCK SHOULD HAVE BEEN STOPPED.
2359	!]ERROR 1
2360	!]MNT_ENBL NTWK
2361		TICK(8);				!GENERATE 8 CLOCK TICKS
2362		IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB NEGATE?
2363			THEN NOERR(1)			!YES
2364			ELSE ERR(2);			!NO
2365	!*MESSAGE 2
2366	!*STIMULUS:
2367	!*	ASSERT AND NEGATE 'RESET'
2368	!*	WRT 205/100	- STOP CLOCK
2369	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'.
2370	!*	GENERATE 8 CLOCK TICKS
2371	!*RESPONSE:
2372	!*	'R CLK ENB (0) H' DIDN'T ASSERT
2373	!]ERROR 2
2374	!]MNT_ENBL MNT_CLK NTWK
2375	!]NO ERROR 1
2376	!]MNT_ENBL MNT_CLK NTWK
2377	
2378		IF LOOP_CHK(2)
2379			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2380		0				!TO PREVENT INFO MSG WHEN COMPILING
2381		END;
2382		INIT();			!DO A RESET
2383	
2384		END;
2385	
2386	GLOBAL ROUTINE TST9: NOVALUE =
2387	
2388	!THIS TEST CHECKS THAT DOING A RESET WILL NEGATE 'CLOSE LATCHS'.  THE
2389	!NEGATION OF 'CLOSE LATCHS' IS DETECTED BY THE ASSERTION OF 'R CLK ENB'.
2390	
2391		BEGIN
2392		LABEL BLOCK1;
2393		BIND
2394			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,RP');
2395	
2396		INIT();			!DO A RESET
2397		DO (0) WHILE
2398	BLOCK1:
2399		BEGIN
2400		WRT210(CLOSE_LATCH);			!SET CLOSE LATCHS
2401		INIT();					!DO A RESET
2402		IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB SET?
2403		THEN
2404			ERR(1);		!NO, REPORT ERROR
2405	!*MESSAGE 1
2406	!*STIMULUS:
2407	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'. THIS SHOULD ASSERT
2408	!*			  'R CLK ENB (0) H'.
2409	!*	ASSERT AND NEGATE 'RESET'.  THIS SHOULD NEGATE 'CLOSE LATCHS',
2410	!*		WHICH SHOULD CAUSE 'R CLK ENB (0) H' TO NEGATE.
2411	!*RESPONSE:
2412	!*	'R CLK ENB (0) H' DIDN'T NEGATE
2413	!]ERROR 1
2414	!]REG210 RESETB_H NTWK
2415	
2416		IF FLP_CHK(1,FLP_PTR)
2417			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2418		0				!TO PREVENT INFO MSG WHEN COMPILING
2419		END;
2420	
2421		END;
2422	
2423	GLOBAL ROUTINE TST10: NOVALUE =
2424	
2425	!THIS TEST CHECKS THAT 'R CLK ENB' GETS ASSERTED WHEN 'LATCH DATA (1)'
2426	!IS ASSERTED ALONG WITH A BUS REQUEST.
2427	
2428		BEGIN
2429		LABEL BLOCK1;
2430		BIND
2431			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR103,RP');
2432	
2433		DO (0) WHILE
2434	BLOCK1:
2435		BEGIN
2436		INIT();					!DO A RESET
2437		WRT210(BUS_REQ + LATCH_DATA + CLOSE_LATCH); !ATTEMPT TO SET R CLK ENB
2438		IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB SET?
2439		THEN
2440			ERR(1);		!NO, REPORT ERROR
2441	!*MESSAGE 1
2442	!*STIMULUS:
2443	!*	ASSERT AND NEGATE 'RESET'
2444	!*	WRT 210/103   - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK
2445	!*		        ENB (0) H'. ASSERTING 'BUS REQ' WILL CAUSE
2446	!*		        'GRANT (1)' TO ASSERT. THIS TOGETHER WITH
2447	!*		        'LATCH DATA SENT' SHOULD CAUSE 'R CLK ENB (0) H'
2448	!*		        TO NEGATE.
2449	!*RESPONSE:
2450	!*	'R CLK ENB (0) H' DIDN'T NEGATE
2451	!]ERROR 1
2452	!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB DATA_ENB RTN_DATA LTCH_DATA GRANT_1 NTWK
2453	
2454		IF FLP_CHK(1,FLP_PTR)
2455			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2456		0				!TO PREVENT INFO MSG WHEN COMPILING
2457		END;
2458	
2459		END;
2460	
2461	GLOBAL ROUTINE TST11: NOVALUE =
2462	
2463	!THIS TEST CHECKS THAT 'R CLK ENB' DOESN'T ASSERT ON A BUS REQUEST
2464	!WHEN 'LATCH DATA (1)' IS NOT ASSERTED.
2465	
2466		BEGIN
2467		LABEL BLOCK1;
2468		BIND
2469			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR101,RP');
2470		DO (0) WHILE
2471	BLOCK1:
2472		BEGIN
2473		INIT();					!DO A RESET
2474		WRT210(BUS_REQ + CLOSE_LATCH);		!DON'T SET LATCH DATA (1)
2475		IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
2476		THEN
2477			ERR(1);		!NO, REPORT ERROR
2478	!*MESSAGE 1
2479	!*STIMULUS:
2480	!*	ASSERT AND NEGATE 'RESET'
2481	!*	WRT 210/101  - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK ENB
2482	!*		       (0) H'.  ASSERTING 'BUS REQ' WILL ASSERT 'GRANT
2483	!*		       (1)'.  BUT WITHOUT 'LATCH DATA SENT' ASSERTED,
2484	!*		       'R CLK ENB (0) H' SHOULD STAY ASSERTED.
2485	!*RESPONSE:
2486	!*	'R CLK ENB (0) H' DIDN'T ASSERT
2487	!]ERROR 1
2488	!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB LTCH_DATA C_LTCHS C_LTCH1 NTWK
2489	
2490		IF FLP_CHK(1,FLP_PTR)
2491			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2492		0				!TO PREVENT INFO MSG WHEN COMPILING
2493		END;
2494	
2495		END;
2496	
2497	GLOBAL ROUTINE TST12: NOVALUE =
2498	
2499	!THIS TEST CHECKS THAT 'R CLK ENB' DOESN'T ASSERT WHEN 'LATCH DATA (1)'
2500	!IS ASSERTED WITHOUT A BUS REQUEST.
2501	
2502		BEGIN
2503		LABEL BLOCK1;
2504		BIND
2505			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR3,RP');
2506	
2507		DO (0) WHILE
2508	BLOCK1:
2509		BEGIN
2510		INIT();					!DO A RESET
2511		WRT210(LATCH_DATA + CLOSE_LATCH);		!DON'T SET BUS REQ
2512		IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
2513		THEN
2514			ERR(1);		!NO, REPORT ERROR
2515	!*MESSAGE 1
2516	!*STIMULUS:
2517	!*	ASSERT AND NEGATE 'RESET'
2518	!*	WRT 210/3  - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK ENB
2519	!*		     (0) H'.  ASSERTING 'LATCH DATA SENT' WITHOUT 'BUS
2520	!*		     REQ' SHOULD NOT CAUSE 'R CLK ENB (0) H' TO NEGATE.
2521	!*RESPONSE:
2522	!*	'R CLK ENB (0) H' NEGATED
2523	!]ERROR 1
2524	!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB GRANT_1 C_LTCHS C_LTCH1 NTWK
2525	
2526		IF FLP_CHK(1,FLP_PTR)
2527			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2528		0				!TO PREVENT INFO MSG WHEN COMPILING
2529		END;
2530	
2531		END;
2532	
2533	GLOBAL ROUTINE TST13: NOVALUE =
2534	
2535	!THIS TEST CHECKS THAT GENERATING A 'WRT 210' SIGNAL NEGATES THE 'LATCH DATA
2536	!ENB (1)' FLOP.  FIRST, 'R CLK ENB' IS ASSERTED BY ASSERTING 'LATCH DATA
2537	!SENT' WITH A BUS REQUEST.  THEN 'LATCH DATA (1)' IS NEGATED.  THIS
2538	!NEGATION GENERATES THE 'WRT 210' PULSE.  IF THE 'LATCH DATA ENB (1)' FLOP
2539	!NEGATES, THEN 'R CLK ENB' NEGATES.
2540	
2541		BEGIN
2542		LABEL BLOCK1;
2543		BIND
2544			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR103,DR1,RP');
2545		DO (0) WHILE
2546	BLOCK1:
2547		BEGIN
2548		INIT();					!DO A RESET
2549		WRT210(BUS_REQ + LATCH_DATA + CLOSE_LATCH); !SET R CLK ENB
2550		WRT210(CLOSE_LATCH);			!CLEAR LATCH DATA (1)
2551		IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID R CLK ENB CLEAR?
2552		THEN
2553			ERR(1);		!NO, REPORT ERROR
2554	!*MESSAGE 1
2555	!*STIMULUS:
2556	!*	ASSERT AND NEGATE 'RESET'
2557	!*	WRT 210/103   - ASSERTING 'CLOSE LATCHS' WILL ASSERT 'R CLK
2558	!*		        ENB (0) H'. ASSERTING 'BUS REQ' WILL CAUSE
2559	!*		        'GRANT (1)' TO ASSERT. THIS TOGETHER WITH
2560	!*		        'LATCH DATA SENT' SHOULD CAUSE 'R CLK ENB (0) H'
2561	!*		        TO NEGATE.
2562	!*	WRT 210/1     - WRITING TO REG 210 SHOULD NEGATE 'LATCH DATA
2563	!*		        SENT'.  THIS SHOULD ASSERT 'R CLK ENB (0) H'.
2564	!*RESPONSE:
2565	!*	'R CLK ENB (0) H' DIDN'T ASSERT
2566	!]ERROR 1
2567	!]R_CLK_ENB T_CLK_B LTCH_DATA_ENB C_LTCH1 C_LTCHS NTWK
2568	
2569		IF FLP_CHK(1,FLP_PTR)
2570			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2571		0				!TO PREVENT INFO MSG WHEN COMPILING
2572		END;
2573	
2574		END;
2575	
2576	GLOBAL ROUTINE TST14: NOVALUE =
2577	
2578	!THIS TEST CHECKS THAT THE ASSERTION OF 'BUS REQ' CAUSES 'R CLK ENB'
2579	!TO ASSERT.  SINCE 'BUS REQ' IS A PULSE, THE CLOCK IS STOPPED FOR THIS
2580	!TEST AND MAINTENANCE CLOCK PULSES ARE GENERATED.
2581	
2582		BEGIN
2583		LABEL BLOCK1;
2584		BIND
2585			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR1,DR101,RP');
2586	
2587		DO (0) WHILE
2588	BLOCK1:
2589		BEGIN
2590		INIT();					!DO A RESET
2591		WRT210(CLOSE_LATCH);			!NEGATE 'R CLK ENB'
2592		SYNC_CLK();				!STOP THE CLOCK AND SYNC IT
2593		WRT210(BUS_REQ + CLOSE_LATCH);		!SET BUS REQ
2594		TICK(1);				!GENERATE A T CLK
2595		IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID R CLK ENB ASSERT?
2596		THEN
2597			ERR(1);		!NO, REPORT ERROR
2598	!*MESSAGE 1
2599	!*STIMULUS:
2600	!*	ASSERT AND NEGATE 'RESET'
2601	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO ASSERT 'R CLK
2602	!*			  ENB (0) H'.
2603	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2604	!*	WRT 210/101	- ASSERT 'BUS REQ'.
2605	!*	ASSERT T CLK	- THIS SHOULD NEGATE 'R CLK ENB (0) H'.
2606	!*RESPONSE:
2607	!*	'R CLK ENB (0) H' DIDN'T NEGATE
2608	!]ERROR 1
2609	!]R_CLK_ENB NTWK
2610	
2611		IF FLP_CHK(1,FLP_PTR)
2612			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2613		0				!TO PREVENT INFO MSG WHEN COMPILING
2614		END;
2615	
2616		INIT();			!DO A RESET
2617		END;
2618	
2619	GLOBAL ROUTINE TST15: NOVALUE =
2620	
2621	!THIS TEST CHECKS THAT SINGLE CLOCKING OF THE CPU BOARDS WORKS
2622	!CORRECTLY.  THAT IS, THE SIGNALS 'CRA/M CLK ENABLE' AND 'DPE/M CLK
2623	!ENABLE' ASSERT AND NEGATE AT THE PROPER TIMES.  SINCE THESE SIGNALS
2624	!ARE PULSES, THE TEST IS DONE WITH THE MAIN CLOCK STOPPED USING SINGLE
2625	!CLOCK PULSES.
2626	
2627	!FIRST, THE SINGLE CLK FLOP IS ASSERTED AND 2 T-CLK/R-CLK CYCLES
2628	!ARE GENERATED.  BOTH ENABLE SIGNALS SHOULD ASSERT.
2629	
2630		BEGIN
2631		LOCAL
2632			CERFLG,
2633			DERFLG,
2634			DATA;
2635		LABEL BLOCK1;
2636		BIND
2637			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');
2638	
2639		DERFLG = CERFLG = 0;	!INIT ERROR FLAG
2640		DO (0) WHILE
2641	BLOCK1:
2642		BEGIN
2643		INIT();					!DO A RESET
2644		RESET_CRAM();				!DO A CRA/M RESET
2645		SYNC_CLK();				!STOP CLOCK AND SYNC IT
2646		WRT206(SINGLE_CLK);			!SETUP FOR SINGLE CLOCKING
2647		CYCLE(2);				!GENERATE 2 T-CLK/R-CLK CYCLES
2648		DATA = RD_303;			!GET READ DATA
2649		IF ( .DATA AND CR_CLK_ENB ) EQL 0	!DID CRA/M CLK ENABLE ASSERT
2650		THEN
2651			BEGIN
2652			ERRM(1);		!NO, REPORT ERROR
2653			CERFLG = -1;	!SET CRM CLK ENB ERROR FLAG
2654			END;
2655	!*MESSAGE 1
2656	!*STIMULUS:
2657	!*	ASSERT AND NEGATE 'RESET'
2658	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2659	!*	ASSERT AND NEGATE 'CRA/M RESET'
2660	!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
2661	!*	GENERATE 2 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'CRA/M CLK
2662	!*		ENABLE' TO ASSERT.
2663	!*RESPONSE:
2664	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT
2665	
2666		IF FLP_CHK(1,FLP_PTR)
2667			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2668	
2669		IF ( .DATA AND DP_CLK_ENBL ) NEQ 0	!DID DPE/M CLK ENABLE ASSERT?
2670		THEN
2671			BEGIN
2672			ERRM(2);		!NO, REPORT ERROR
2673			DERFLG = -1;	!SET DPE/M CLK ENB ERROR FLAG
2674			END;
2675	!*MESSAGE 2
2676	!*STIMULUS:
2677	!*	ASSERT AND NEGATE 'RESET'
2678	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2679	!*	ASSERT AND NEGATE 'CRA/M RESET'
2680	!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
2681	!*	GENERATE 2 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'DPE/M CLK
2682	!*		ENABLE' TO ASSERT.
2683	!*RESPONSE:
2684	!*	'DPE/M CLK ENABLE' DIDN'T ASSERT
2685	
2686		IF FLP_CHK(2,FLP_PTR)
2687			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2688	
2689	!NOW GENERATE A 3RD T-CLK/R-CLK CYCLE.  THIS SHOULD NEGATE THE ENABLES.
2690	
2691		CYCLE(1);				!GENERATE T CLK/R CLK CYCLE
2692		DATA = RD_303;			!GET READ DATA
2693		IF ( .DATA AND CR_CLK_ENB ) NEQ 0	!DID CRA/M CLK ENABLE NEGATE?
2694		THEN
2695			BEGIN
2696			ERRM(3);		!NO, REPORT ERROR
2697			CERFLG = -1;	!SET CRM CLK ENB ERROR FLAG
2698			END;
2699	!*MESSAGE 3
2700	!*STIMULUS:
2701	!*	ASSERT AND NEGATE 'RESET'
2702	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2703	!*	ASSERT AND NEGATE 'CRA/M RESET'
2704	!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
2705	!*	GENERATE 3 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'CRA/M CLK
2706	!*		ENABLE' TO ASSERT THEN NEGATE.
2707	!*RESPONSE:
2708	!*	'CRA/M CLK ENABLE' DIDN'T NEGATE
2709	
2710		IF FLP_CHK(3,FLP_PTR)
2711			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2712	
2713		IF ( .DATA AND DP_CLK_ENBL ) EQL 0	!DID DPE/M CLK ENABLE NEGATE?
2714		THEN
2715			BEGIN
2716			ERRM(4);		!NO, REPORT ERROR
2717			DERFLG = -1;	!SET DPE/M CLK ENB ERROR FLAG
2718			END;
2719	!*MESSAGE 4
2720	!*STIMULUS:
2721	!*	ASSERT AND NEGATE 'RESET'
2722	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2723	!*	ASSERT AND NEGATE 'CRA/M RESET'
2724	!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
2725	!*	GENERATE 3 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'DPE/M CLK
2726	!*		ENABLE' TO ASSERT THEN NEGATE.
2727	!*RESPONSE:
2728	!*	'DPE/M CLK ENABLE' DIDN'T NEGATE
2729	
2730		IF FLP_CHK(4,FLP_PTR)
2731			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2732	
2733	!GENERATE A 4TH T CLK/R CLK CYCLE AND CHECK THAT THE ENABLES ARE STILL
2734	!NEGATED.
2735	
2736		CYCLE(1);				!GENERATE T CLK/R CLK CYCLE
2737		DATA = RD_303;			!GET READ DATA
2738		IF ( .DATA AND CR_CLK_ENB ) NEQ 0	!DID CRA/M CLK ENABLE NEGATE?
2739		THEN
2740			BEGIN
2741			ERRM(5);		!NO, REPORT ERROR
2742			CERFLG = -1;	!SET CRM CLK ENB ERROR FLAG
2743			END;
2744	!*MESSAGE 5
2745	!*STIMULUS:
2746	!*	ASSERT AND NEGATE 'RESET'
2747	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2748	!*	ASSERT AND NEGATE 'CRA/M RESET'
2749	!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
2750	!*	GENERATE 4 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'CRA/M CLK
2751	!*		ENABLE' TO ASSERT THEN NEGATE.
2752	!*RESPONSE:
2753	!*	'CRA/M CLK ENABLE' DIDN'T STAY NEGATE
2754	
2755		IF FLP_CHK(5,FLP_PTR)
2756			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2757	
2758		IF ( .DATA AND DP_CLK_ENBL ) EQL 0	!DID DPE/M CLK ENABLE NEGATE?
2759		THEN
2760			BEGIN
2761			ERRM(6);		!NO, REPORT ERROR
2762			DERFLG = -1;	!SET DPE/M CLK ENB ERROR FLAG
2763			END;
2764	!*MESSAGE 6
2765	!*STIMULUS:
2766	!*	ASSERT AND NEGATE 'RESET'
2767	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2768	!*	ASSERT AND NEGATE 'CRA/M RESET'
2769	!*	WRT 206/2	- ASSERT  'SINGLE CLK'.
2770	!*	GENERATE 4 T-CLK/R-CLK CYCLES. THIS SHOULD CAUSE 'DPE/M CLK
2771	!*		ENABLE' TO ASSERT THEN NEGATE.
2772	!*RESPONSE:
2773	!*	'DPE/M CLK ENABLE' DIDN'T STAY NEGATED.
2774	
2775		IF FLP_CHK(6,FLP_PTR)
2776			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2777		0				!TO PREVENT INFO MSG WHEN COMPILING
2778		END;
2779	
2780	!CHECK IF ONLY 'CRA/M CLK ENABLE' FAILED.
2781	
2782		IF (.CERFLG NEQ 0) AND (.DERFLG EQL 0)
2783		THEN
2784			FAILURE(1);	!DO FAULT ISOLATION
2785	!]ERROR 1
2786	!]CR_CLK_ENB CLK_ENBS NTWK
2787	
2788	!CHECK IF ONLY 'DPE/M CLK ENABLE' FAILED.
2789	
2790		IF (.CERFLG EQL 0) AND (.DERFLG NEQ 0)
2791		THEN
2792			FAILURE(2);	!DO FAULT ISOLATION
2793	!]ERROR 2
2794	!]DP_CLK_ENB CLK_ENBS PF_1 NTWK
2795	
2796	!CHECK IF BOTH ENABLES FAILED
2797	
2798		IF (.CERFLG NEQ 0) AND (.DERFLG NEQ 0)
2799		THEN
2800			FAILURE(3);	!DO FAULT ISOLATION
2801	!]ERROR 3
2802	!]CLK_ENBS ENB SING_CLK CLK_RUN T_CLK WRT206 CSLBUF1 R_CLK NTWK
2803	
2804	!CHECK IF WE HAD NO ERRORS
2805	
2806		IF (.CERFLG EQL 0) AND (.DERFLG EQL 0)
2807		THEN
2808			NOERR(1);	!DO FAULT ISOLATION
2809	!]NO ERROR 1
2810	!]SING_CLK WRT206 CSLBUF1 T_CLK R_CLK NTWK
2811	
2812		INIT();			!DO A RESET
2813		END;
2814	
2815	GLOBAL ROUTINE TST16: NOVALUE =
2816	
2817	!THIS TEST CHECKS THAT 'CRA/M CLK ENABLE' DOESN'T ASSERT IF 'SINGLE CLK'
2818	!AND 'CLK RUN' ARE NEGATED.
2819	
2820		BEGIN
2821		LABEL BLOCK1;
2822		BIND
2823			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR0,RP');
2824	
2825		DO (0) WHILE
2826	BLOCK1:
2827		BEGIN
2828		INIT();					!DO A RESET
2829		RESET_CRAM();				!DO A CRA/M RESET
2830		SYNC_CLK();				!STOP CLOCK AND SYNC IT
2831		WRT206(0);				!NEGATE SINGLE CLK AND CLK RUN
2832		CYCLE(2);				!GENERATE 2 T CLK/R CLK CYCLES
2833		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID CRA/M CLK ENABLE STAY NEGATED?
2834		THEN
2835			ERR(1);		!NO, REPORT ERROR
2836	!*MESSAGE 1
2837	!*STIMULUS:
2838	!*	ASSERT AND NEGATE 'RESET'
2839	!*	ASSERT AND NEGATE 'CRA/M RESET'
2840	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2841	!*	WRT 206/0
2842	!*	GENERATE 2 T-CLK/R-CLK CYCLES. WITH 'SINGLE CLK' AND 'CLK RUN'
2843	!*		NEGATED, 'CRA/M CLK ENABLE' SHOULDN'T ASSERT.
2844	!*RESPONSE:
2845	!*	'CRA/M CLK ENABLE' ASSERTED
2846	!]ERROR 1
2847	!]SING_CLK CLK_RUN ENB CLK_ENBS CR_CLK_ENB NTWK
2848	
2849		IF FLP_CHK(1,FLP_PTR)
2850			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2851		0				!TO PREVENT INFO MSG WHEN COMPILING
2852		END;
2853		INIT();			!DO A RESET
2854	
2855		END;
2856	
2857	GLOBAL ROUTINE TST17: NOVALUE =
2858	
2859	!THIS TEST CHECKS THAT THE KS10 BUS CONTROL SIGNALS ('COM/ADR CYCLE',
2860	!ETC.) CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
2861	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
2862	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB
2863	!AND DATA CYCLE.
2864	
2865		BEGIN
2866		LOCAL
2867			CORRECT,
2868			ACTUAL;
2869		OWN
2870			DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
2871		LABEL BLOCK1;
2872		BIND
2873			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR115,DR12,LR114,DR5,LR210,DR140,RP'),
2874					UPLIT(%ASCIZ'LR100,DR200,DR0,LR115,DR5,LR114,DR12,LR210,DR140,RP'));
2875		MAP
2876			FLP_PTR: VECTOR;
2877	
2878	!SETUP BUS BITS 0-11 SO THAT THEY ARE NOT A VALID COMMAND.  SO WHEN
2879	!COM/ADR IS ASSERTED, NOTHING WILL HAPPEN.
2880	
2881		WRT113(%O'10');				!SET BUS BITS 0-3 = 1000
2882		WRT112(%O'10');				!SET BUS BITS 0-3 = 1000
2883		WRT111(0);				!CLEAR BUS BITS 4-11
2884		WRT110(0);				!CLEAR BUS BITS 4-11
2885		ERROR_FLAG = 0;		!INIT ERROR FLAG
2886		INCR I FROM 0 TO 1 BY 1 DO
2887		BEGIN
2888		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
2889		DO (0) WHILE
2890	BLOCK1:
2891		BEGIN
2892		INIT();					!DO A RESET
2893		SYNC_CLK();				!STOP CLOCK AND SYNC IT
2894		WRT115(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
2895		WRT114((NOT .CORRECT) AND %O'17');	!WRITE COMPLEMENT TO DATA LOCS
2896		WRT210(BUS_REQ + XMIT_ADR);		!SETUP TO CLOCK DATA
2897		TICK(10);				!CLOCK IT INTO RECEIVER
2898		ACTUAL = RD_102 AND %O'17';		!GET DATA FROM RECEIVERS
2899		ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
2900	!*MESSAGE 1
2901	!*STIMULUS:
2902	!*	ASSERT AND NEGATE 'RESET'
2903	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2904	!*	WRT 115/CORRECT DATA
2905	!*	WRT 114/CORRECT DATA COMPLEMENTED
2906	!*	WRT 210/140
2907	!*	GENERATE 10 CLOCK TICKS
2908	!*RESPONSE:
2909	!*	KS10 BUS CONTROL SIGNALS ARE INCORRECT.  THEY ARE READ BACK
2910	!*	FROM REGISTER 102.
2911	!]ERROR 1
2912	!]R_DATA CMD_XCVR CSLBUF2 NTWK
2913	!]ERROR 2
2914	!]R_IODATA CMD_XCVR CSLBUF0 NTWK
2915	!]ERROR 3
2916	!]R_COMADR CMD_XCVR CSLBUF1 NTWK
2917	!]ERROR 4
2918	!]R_BADATA CMD_XCVR CSLBUF3 NTWK
2919	!]ERROR 5
2920	!]ADR0L6_L DATA_CYC STAT_RD X_D1 XMIT_DATA CMD_XCVR NTWK
2921	!]ERROR 6
2922	!]WRT114 RD_100 ADR0L6_L ADR1L_H CMD_XCVR T_ENB XMIT_ADR NTWK
2923	
2924		IF FLP_CHK(1,.FLP_PTR[.I])
2925		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2926		0				!TO PREVENT INFO MSG WHEN COMPILING
2927		END;
2928		END;
2929	
2930	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
2931	
2932		IF .ERROR_FLAG EQL 0
2933		THEN
2934			NOERR(1);
2935	!]NO ERROR 1
2936	!]RD_100 ADR0L6_L ADR1L_H NTWK
2937	
2938	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
2939	
2940		WRT114(0);
2941		WRT115(0);
2942		INIT();			!DO A RESET
2943	
2944		END;
2945	
2946	GLOBAL ROUTINE TST18: NOVALUE =
2947	
2948	!THIS TEST CHECKS THAT THE KS10 BUS CONTROL SIGNALS ('COM/ADR CYCLE',
2949	!ETC.) CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
2950	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
2951	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB
2952	!AND DATA CYCLE.
2953	
2954		BEGIN
2955		LOCAL
2956			CORRECT,
2957			ACTUAL;
2958		OWN
2959			DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
2960		LABEL BLOCK1;
2961		BIND
2962			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR12,LR115,DR5,LR210,DR140,RP'),
2963					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR5,LR115,DR12,LR210,DR140,RP'));
2964		MAP
2965			FLP_PTR: VECTOR;
2966	
2967	!SETUP BUS BITS 0-11 SO THAT THEY ARE NOT A VALID COMMAND.  SO WHEN
2968	!COM/ADR IS ASSERTED, NOTHING WILL HAPPEN.
2969	
2970		WRT113(%O'10');				!SET BUS BITS 0-3 = 1000
2971		WRT112(%O'10');				!SET BUS BITS 0-3 = 1000
2972		WRT111(0);				!CLEAR BUS BITS 4-11
2973		WRT110(0);				!CLEAR BUS BITS 4-11
2974		ERROR_FLAG = 0;		!INIT ERROR FLAG
2975		INCR I FROM 0 TO 1 BY 1 DO
2976		BEGIN
2977		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
2978		DO (0) WHILE
2979	BLOCK1:
2980		BEGIN
2981		INIT();					!DO A RESET
2982		SYNC_CLK();				!STOP CLOCK AND SYNC IT
2983		WRT114(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
2984		WRT115((NOT .CORRECT) AND %O'17');	!WRITE COMPLEMENT TO COM/ADR LOCS
2985		WRT210(BUS_REQ + XMIT_DATA);		!SETUP TO CLOCK DATA
2986		TICK(14);				!CLOCK IT INTO RECEIVER
2987		ACTUAL = RD_102 AND %O'17';		!GET DATA FROM RECEIVERS
2988		ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
2989	!*MESSAGE 1
2990	!*STIMULUS:
2991	!*	ASSERT AND NEGATE 'RESET'
2992	!*	STOP CLOCK AND SYNC TO STATE WITH T CLK AND R CLK NEGATED
2993	!*	WRT 114/CORRECT DATA
2994	!*	WRT 115/CORRECT DATA COMPLEMENTED
2995	!*	WRT 210/120
2996	!*	GENERATE 10 CLOCK TICKS
2997	!*RESPONSE:
2998	!*	KS10 BUS CONTROL SIGNALS ARE INCORRECT.  THEY ARE READ BACK
2999	!*	FROM REGISTER 102.
3000	!]ERROR 1
3001	!]R_DATA CMD_XCVR CSLBUF2 NTWK
3002	!]ERROR 2
3003	!]R_IODATA CMD_XCVR CSLBUF0 NTWK
3004	!]ERROR 3
3005	!]R_COMADR CMD_XCVR CSLBUF1 NTWK
3006	!]ERROR 4
3007	!]R_BADATA CMD_XCVR CSLBUF3 NTWK
3008	!]ERROR 5
3009	!]ADR0L6_H DATA_CYC CMD_XCVR NTWK
3010	!]ERROR 6
3011	!]WRT114 RD_100 ADR0L6_L ADR1L_H CMD_XCVR T_ENB XMIT_DATA NTWK
3012		IF FLP_CHK(1,.FLP_PTR[.I])
3013		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3014		0				!TO PREVENT INFO MSG WHEN COMPILING
3015		END;
3016		END;
3017	
3018	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
3019	
3020		IF .ERROR_FLAG EQL 0
3021		THEN
3022			NOERR(1);
3023	!]NO ERROR 1
3024	!]RD_100 ADR0L6_L ADR1L_H ADR0L6_H NTWK
3025	
3026	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
3027	
3028		WRT114(0);
3029		WRT115(0);
3030		INIT();			!DO A RESET
3031	
3032		END;
3033	
3034	GLOBAL ROUTINE TST19: NOVALUE =
3035	
3036	!THIS TEST CHECKS THAT 'DATA ACK' ASSERTS AND 'R CLK ENB' NEGATES WHEN
3037	!A BUS REQUEST IS MADE WITH 'MEM' AND 'R DATA' ASSERTED.
3038	
3039	
3040		BEGIN
3041		LOCAL
3042			ERFLG;
3043		LABEL BLOCK1;
3044		BIND
3045			FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP'),
3046			FLP_PTR2 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP');
3047	
3048		ERFLG = 0;		!INIT ERROR FLAG
3049		DO (0) WHILE
3050	BLOCK1:
3051		BEGIN
3052		INIT();					!DO A RESET
3053		RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
3054		WRT114(DATA_CYCLE);			!LOAD I/O BUFFER SO 'R DATA' WILL ASSERT
3055		WRT210(MEM + BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
3056		IF ( RD_301 AND DATA_ACK ) EQL 0	!DID 'DATA ACK' ASSERT?
3057		THEN
3058			BEGIN
3059			ERR(1);		!NO, REPORT ERROR
3060			ERFLG = -1;	!SET ERROR FLAG
3061			END;
3062	!*MESSAGE 1
3063	!*STIMULUS:
3064	!*	ASSERT AND NEGATE 'RESET'
3065	!*	RD 0		- TO NEGATE 'DATA ACK'
3066	!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
3067	!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3068	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3069	!*			  'LATCH DATA ENB (1)'.
3070	!*			- 'R DATA' AND 'MEM' WILL ASSERT 'RETURN DATA'
3071	!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
3072	!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL ASSERT
3073	!*			  'DATA ACK'.
3074	!*RESPONSE:
3075	!*	'DATA ACK' DIDN'T ASSERT
3076	!]ERROR 1
3077	!]DATAACK RD_0 DATA_ACK DATA_ENB R_CLK_L RTN_DATA MEMH NTWK
3078	
3079		IF FLP_CHK(1,FLP_PTR1)
3080			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3081		IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID 'R CLK ENB' NEGATE?
3082		THEN
3083			ERR(2);		!NO, REPORT ERROR
3084	!*MESSAGE 2
3085	!*STIMULUS:
3086	!*	ASSERT AND NEGATE 'RESET'
3087	!*	RD 0		- TO NEGATE 'DATA ACK'
3088	!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
3089	!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3090	!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
3091	!*			  'R CLK ENB'
3092	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3093	!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
3094	!*			  ASSERT 'R CLK ENB'
3095	!*			- 'R DATA' AND 'MEM' WILL ASSERT 'RETURN DATA'
3096	!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
3097	!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL NEGATE
3098	!*			  'R CLK ENB'.
3099	!*RESPONSE:
3100	!*	'R CLK ENB' DIDN'T NEGATE
3101	!]ERROR 2
3102	!]R_CLK_L DATA_ENB RTN_DATA NTWK
3103	
3104		IF FLP_CHK(2,FLP_PTR2)
3105			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3106	
3107		RD_0;				!NEGATE 'DATA ACK'
3108		IF (RD_301 AND DATA_ACK) NEQ 0	!DID 'DATA ACK' NEGATE?
3109		THEN
3110			BEGIN
3111			ERR(3);		!NO, REPORT ERROR
3112			ERFLG = -1;	!SET ERROR FLAG
3113			END;
3114	!*MESSAGE 3
3115	!*STIMULUS:
3116	!*	ASSERT AND NEGATE 'RESET'
3117	!*	RD 0		- TO NEGATE 'DATA ACK'
3118	!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
3119	!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3120	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3121	!*			  'LATCH DATA ENB (1)'.
3122	!*			- 'R DATA' AND 'MEM' WILL ASSERT 'RETURN DATA'
3123	!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
3124	!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL ASSERT
3125	!*			  'DATA ACK'.
3126	!*	RD 0		- TO NEGATE 'DATA ACK'
3127	!*RESPONSE:
3128	!*	'DATA ACK' DIDN'T NEGATE.
3129	!]ERROR 3
3130	!]DATA_ACK DATA_ENB RD_0 DATAACK NTWK
3131		IF FLP_CHK(3,FLP_PTR1)
3132			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3133		0				!TO PREVENT INFO MSG WHEN COMPILING
3134		END;
3135	
3136	!IF WE HAD NO ERROR FOR 'DATA ACK' THEN DO FAULT ISOLATION
3137	
3138		IF .ERFLG EQL 0
3139		THEN
3140			NOERR(1);
3141	!]NO ERROR 1
3142	!]R_CLK_L MEMH DATA_ACK DATAACK RD_0 NTWK
3143	
3144		END;
3145	
3146	GLOBAL ROUTINE TST20: NOVALUE =
3147	
3148	!THIS TEST CHECKS THAT 'DATA ACK' ASSERTS AND 'R CLK ENB' NEGATES WHEN
3149	!A BUS REQUEST IS MADE WITH 'R I/O DATA' ASSERTED.
3150	
3151		BEGIN
3152		LABEL BLOCK1;
3153		BIND
3154			FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR123,RP'),
3155			FLP_PTR2 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR123,RP');
3156		DO (0) WHILE
3157	BLOCK1:
3158		BEGIN
3159		INIT();					!DO A RESET
3160		RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
3161		WRT114(IO_DATA);			!LOAD I/O BUFFER SO 'R I/O DATA' WILL ASSERT
3162		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
3163		IF ( RD_301 AND DATA_ACK ) EQL 0	!DID 'DATA ACK' ASSERT?
3164		THEN
3165			ERR(1);		!NO, REPORT ERROR
3166	!*MESSAGE 1
3167	!*STIMULUS:
3168	!*	ASSERT AND NEGATE 'RESET'
3169	!*	RD 0		- TO NEGATE 'DATA ACK'
3170	!*	WRT 114/2	- SO 'R I/O DATA' WILL ASSERT
3171	!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3172	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3173	!*			  'LATCH DATA ENB (1)'.
3174	!*			- 'R I/O DATA' WILL ASSERT 'RETURN DATA'
3175	!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
3176	!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL ASSERT
3177	!*			  'DATA ACK'.
3178	!*RESPONSE:
3179	!*	'DATA ACK' DIDN'T ASSERT
3180	!]ERROR 1
3181	!]DATAACK RD_0 DATA_ACK DATA_ENB R_CLK_L RTN_DATA NTWK
3182	
3183		IF FLP_CHK(1,FLP_PTR1)
3184			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3185		IF ( RD_303 AND R_CLK_ENB0 ) EQL 0	!DID 'R CLK ENB' NEGATE?
3186		THEN
3187			ERR(2);		!NO, REPORT ERROR
3188	!*MESSAGE 2
3189	!*STIMULUS:
3190	!*	ASSERT AND NEGATE 'RESET'
3191	!*	RD 0		- TO NEGATE 'DATA ACK'
3192	!*	WRT 114/2	- SO 'R I/O DATA' WILL ASSERT
3193	!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3194	!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
3195	!*			  'R CLK ENB'
3196	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3197	!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
3198	!*			  ASSERT 'R CLK ENB'
3199	!*			- 'R I/O DATA' WILL ASSERT 'RETURN DATA'
3200	!*			- 'RETURN DATA' AND 'LATCH DATA ENB (1)' WILL
3201	!*			  ASSERT 'DATA ENB' WHICH IN TURN WILL NEGATE
3202	!*			  'R CLK ENB'.
3203	!*RESPONSE:
3204	!*	'R CLK ENB' DIDN'T NEGATE
3205	!]ERROR 2
3206	!]R_CLK_L DATA_ENB RTN_DATA NTWK
3207	
3208		IF FLP_CHK(2,FLP_PTR2)
3209			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3210		0				!TO PREVENT INFO MSG WHEN COMPILING
3211		END;
3212	
3213		END;
3214	
3215	GLOBAL ROUTINE TST21: NOVALUE =
3216	
3217	!THIS TEST CHECKS THAT 'DATA ACK' DOESN'T ASSERT AND 'R CLK ENB'
3218	!DOESN'T NEGATE WHEN A BUS REQUEST IS MADE WITH 'MEM' AND 'R I/O DATA'
3219	!NEGATED.
3220	
3221		BEGIN
3222		LABEL BLOCK1;
3223		BIND
3224			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR123,RP');
3225		DO (0) WHILE
3226	BLOCK1:
3227		BEGIN
3228		INIT();					!DO A RESET
3229		RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
3230		WRT114(DATA_CYCLE);			!LOAD I/O BUFFER SO 'R DATA' WILL ASSERT
3231		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
3232		IF ( RD_301 AND DATA_ACK ) NEQ 0	!IS 'DATA ACK' NEGATED?
3233		THEN
3234			ERR(1);		!NO, REPORT ERROR
3235	!*MESSAGE 1
3236	!*STIMULUS:
3237	!*	ASSERT AND NEGATE 'RESET'
3238	!*	RD 0		- TO NEGATE 'DATA ACK'
3239	!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
3240	!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3241	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3242	!*			  'LATCH DATA ENB (1)'.
3243	!*			- WITH 'MEM' AND 'R I/O DATA' NEGATED, 'RETURN
3244	!*			  DATA' SHOULD NOT ASSERT.
3245	!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
3246	!*			  NOT ASSERT AND THEREFORE 'DATA ACK' WILL NOT
3247	!*			  ASSERT.
3248	!*RESPONSE:
3249	!*	'DATA ACK' ASSERTED
3250	!]ERROR 1
3251	!]RTN_DATA DATA_ENB DATA_ACK DATAACK NTWK
3252	
3253		IF LOOP_CHK(1)
3254			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3255		IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID 'R CLK ENB' ASSERT?
3256		THEN
3257			ERR(2);		!NO, REPORT ERROR
3258	!*MESSAGE 2
3259	!*STIMULUS:
3260	!*	ASSERT AND NEGATE 'RESET'
3261	!*	RD 0		- TO NEGATE 'DATA ACK'
3262	!*	WRT 114/1	- SO 'R DATA' WILL ASSERT
3263	!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3264	!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
3265	!*			  'R CLK ENB'
3266	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3267	!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
3268	!*			  ASSERT 'R CLK ENB'
3269	!*			- WITH 'MEM' AND 'R I/O DATA' NEGATED, 'RETURN
3270	!*			  DATA' SHOULD NOT ASSERT.
3271	!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
3272	!*			  NOT ASSERT AND THEREFORE 'R CLK ENB' WILL NOT
3273	!*			  NEGATE.
3274	!*RESPONSE:
3275	!*	'R CLK ENB' NEGATED
3276	!]ERROR 2
3277	!]RTN_DATA DATA_ENB NTWK
3278	
3279		IF FLP_CHK(2,FLP_PTR)
3280			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3281		0				!TO PREVENT INFO MSG WHEN COMPILING
3282		END;
3283	
3284		END;
3285	
3286	GLOBAL ROUTINE TST22: NOVALUE =
3287	
3288	!THIS TEST CHECKS THAT 'DATA ACK' DOESN'T ASSERT AND 'R CLK ENB'
3289	!DOESN'T NEGATE WHEN A BUS REQUEST IS MADE WITH 'R DATA' AND
3290	!'R I/O DATA' NEGATED.
3291	
3292		BEGIN
3293		LABEL BLOCK1;
3294		BIND
3295			FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP'),
3296			FLP_PTR2 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR323,RP');
3297		DO (0) WHILE
3298	BLOCK1:
3299		BEGIN
3300		INIT();					!DO A RESET
3301		RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
3302		WRT114(0);				!LOAD I/O BUFFER SO 'R DATA' AND
3303							!'R I/O DATA' WILL NEGATE
3304		WRT210(MEM + BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !START BUS REQUEST
3305		IF ( RD_301 AND DATA_ACK ) NEQ 0	!IS 'DATA ACK' NEGATED?
3306		THEN
3307			ERR(1);		!NO, REPORT ERROR
3308	!*MESSAGE 1
3309	!*STIMULUS:
3310	!*	ASSERT AND NEGATE 'RESET'
3311	!*	RD 0		- TO NEGATE 'DATA ACK'
3312	!*	WRT 114/0	- SO 'R DATA' AND 'R I/O DATA' WILL NEGATE
3313	!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3314	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3315	!*			  'LATCH DATA ENB (1)'.
3316	!*			- WITH 'R DATA' AND 'R I/O DATA' NEGATED,
3317	!*			  'RETURN DATA' SHOULD NOT ASSERT.
3318	!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
3319	!*			  NOT ASSERT AND THEREFORE 'DATA ACK' WILL NOT
3320	!*			  ASSERT.
3321	!*RESPONSE:
3322	!*	'DATA ACK' ASSERTED
3323	!]ERROR 1
3324	!]RTN_DATA DATA_ENB DATA_ACK DATAACK NTWK
3325	
3326		IF FLP_CHK(1,FLP_PTR1)
3327			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3328	
3329		IF ( RD_303 AND R_CLK_ENB0 ) NEQ 0	!DID 'R CLK ENB' ASSERT?
3330		THEN
3331			ERR(2);		!NO, REPORT ERROR
3332	!*MESSAGE 2
3333	!*STIMULUS:
3334	!*	ASSERT AND NEGATE 'RESET'
3335	!*	RD 0		- TO NEGATE 'DATA ACK'
3336	!*	WRT 114/0	- SO 'R DATA' AND 'R I/O DATA' WILL NEGATE
3337	!*	WRT 210/323	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3338	!*			- ASSERTING 'CLOSE LATCHS' WILL NEGATE
3339	!*			  'R CLK ENB'
3340	!*			- 'GRANT (1)' AND 'LATCH DATA (1)' WILL ASSERT
3341	!*			  'LATCH DATA ENB (1)' WHICH IN TURN WILL
3342	!*			  ASSERT 'R CLK ENB'
3343	!*			- WITH 'R DATA' AND 'R I/O DATA' NEGATED,
3344	!*			  'RETURN DATA' SHOULD NOT ASSERT.
3345	!*			- WITH 'RETURN DATA' NEGATED, 'DATA ENB' WILL
3346	!*			  NOT ASSERT AND THEREFORE 'R CLK ENB' WILL NOT
3347	!*			  NEGATE.
3348	!*RESPONSE:
3349	!*	'R CLK ENB' NEGATED
3350	!]ERROR 2
3351	!]RTN_DATA DATA_ENB NTWK
3352	
3353		IF FLP_CHK(2,FLP_PTR2)
3354			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3355		0				!TO PREVENT INFO MSG WHEN COMPILING
3356		END;
3357	
3358		END;
3359	
3360	GLOBAL ROUTINE TST23: NOVALUE =
3361	
3362	!THIS TEST CHECKS THAT 'DATA ACK' DOESN'T ASSERT WHEN A BUS REQUEST IS
3363	!MADE WITH 'LATCH DATA (1)' NEGATED.
3364	
3365		BEGIN
3366		LABEL BLOCK1;
3367		BIND
3368			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR121,RP');
3369		DO (0) WHILE
3370	BLOCK1:
3371		BEGIN
3372		INIT();					!DO A RESET
3373		RD_0;					!MAKE SURE 'DATA ACK' IS NEGATED
3374		WRT114(IO_DATA);			!LOAD I/O BUFFER SO 'R I/O DATA' WILL ASSERT
3375		WRT210(BUS_REQ + XMIT_DATA + CLOSE_LATCH); !START BUS REQUEST
3376		IF ( RD_301 AND DATA_ACK ) NEQ 0	!IS 'DATA ACK' NEGATED?
3377		THEN
3378			ERR(1);		!NO, REPORT ERROR
3379	!*MESSAGE 1
3380	!*STIMULUS:
3381	!*	ASSERT AND NEGATE 'RESET'
3382	!*	RD 0		- TO NEGATE 'DATA ACK'
3383	!*	WRT 114/2	- SO 'R I/O DATA' WILL ASSERT
3384	!*	WRT 210/123	- ASSERTING 'BUS REQ' WILL ASSERT 'GRANT'
3385	!*			- WITH 'LATCH DATA (1)' NEGATED, 'LATCH DATA
3386	!*			  ENB (1)' WILL NOT ASSERT.
3387	!*			- 'R I/O DATA' WILL ASSERT 'RETURN DATA'
3388	!*			- WITH 'LATCH DATA ENB (1)' NEGATED, 'DATA ENB'
3389	!*			  WILL NOT ASSERT AND THEREFORE 'DATA ACK' WILL
3390	!*			  NOT ASSERT.
3391	!*RESPONSE:
3392	!*	'DATA ACK' ASSERTED
3393	!]ERROR 1
3394	!]DATA_ENB DATA_ACK DATAACK NTWK
3395	
3396		IF FLP_CHK(1,FLP_PTR)
3397			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3398		0				!TO PREVENT INFO MSG WHEN COMPILING
3399		END;
3400	
3401		END;
3402	
3403	GLOBAL ROUTINE TST24: NOVALUE =
3404	
3405	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 00-03'
3406	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
3407	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
3408	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
3409	!R CLK ENB AND DATA CYCLE.
3410	
3411		BEGIN
3412		LOCAL
3413			CORRECT,
3414			ACTUAL;
3415		OWN
3416			DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
3417		LABEL BLOCK1;
3418		BIND
3419			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR113,DR12,LR112,DR5,LR210,DR141,RP'),
3420					UPLIT(%ASCIZ'LR100,DR200,DR0,LR113,DR5,LR112,DR12,LR210,DR141,RP'));
3421		MAP
3422			FLP_PTR: VECTOR;
3423	
3424		ERROR_FLAG = 0;		!INIT ERROR FLAG
3425		INCR I FROM 0 TO 1 BY 1 DO
3426		BEGIN
3427		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
3428		DO (0) WHILE
3429	BLOCK1:
3430		BEGIN
3431		INIT();					!DO A RESET
3432		WRT113(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
3433		WRT112((NOT .CORRECT) AND %O'17');	!WRITE COMPLEMENT TO DATA LOCS
3434		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH);	!CLOCK DATA INTO RECEIVERS
3435		ACTUAL = RD_103 AND %O'17';		!GET DATA FROM RECEIVERS
3436		ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
3437	!*MESSAGE 1
3438	!*STIMULUS:
3439	!*	ASSERT AND NEGATE 'RESET'
3440	!*	WRT 113/CORRECT DATA
3441	!*	WRT 112/CORRECT DATA COMPLEMENTED
3442	!*	WRT 210/141
3443	!*RESPONSE:
3444	!*	'R DATA 00-03' DID NOT GET GATED ONTO THE BUS CORRECTLY.
3445	!]ERROR 1
3446	!]RDATA_03 BUS0_3 CSLBUF0 NTWK
3447	!]ERROR 2
3448	!]RDATA_02 BUS0_3 CSLBUF1 NTWK
3449	!]ERROR 3
3450	!]RDATA_01 BUS0_3 CSLBUF2 NTWK
3451	!]ERROR 4
3452	!]RDATA_00 BUS0_3 CSLBUF3 NTWK
3453	!]ERROR 5
3454	!]ADR0L6_L DATA_CYC STAT_RD X_D1 XMIT_DATA BUS0_3 NTWK
3455	!]ERROR 6
3456	!]WRT112 R_CLK_B RD_0 ADR0L6_H ADR1L_H BUS0_3 T_ENB XMIT_ADR NTWK
3457	
3458		IF FLP_CHK(1,.FLP_PTR[.I])
3459		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3460		0				!TO PREVENT INFO MSG WHEN COMPILING
3461		END;
3462		END;
3463	
3464	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
3465	
3466		IF .ERROR_FLAG EQL 0
3467		THEN
3468			NOERR(1);
3469	!]NO ERROR 1
3470	!]RD_0 ADR0L6_H ADR0L6_L WRT112 R_CLK_B NTWK
3471	
3472		END;
3473	
3474	GLOBAL ROUTINE TST25: NOVALUE =
3475	
3476	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 00-03'
3477	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
3478	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
3479	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
3480	!R CLK ENB AND DATA CYCLE.
3481	
3482		BEGIN
3483		LOCAL
3484			CORRECT,
3485			ACTUAL;
3486		OWN
3487			DATA_TABLE: VECTOR[2] INITIAL (%O'12',%O'5');
3488		LABEL BLOCK1;
3489		BIND
3490			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR112,DR12,LR113,DR5,LR210,DR123,RP'),
3491					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR112,DR5,LR113,DR12,LR210,DR123,RP'));
3492		MAP
3493			FLP_PTR: VECTOR;
3494	
3495		ERROR_FLAG = 0;		!INIT ERROR FLAG
3496		INCR I FROM 0 TO 1 BY 1 DO
3497		BEGIN
3498		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
3499		DO (0) WHILE
3500	BLOCK1:
3501		BEGIN
3502		INIT();					!DO A RESET
3503		WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
3504		WRT112(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
3505		WRT113((NOT .CORRECT) AND %O'17');	!WRITE THAT TO COM/ADR LOCS
3506		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
3507		ACTUAL = RD_103 AND %O'17';		!GET DATA FROM RECEIVERS
3508		ERR_CHK_4(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
3509	!*MESSAGE 1
3510	!*STIMULUS:
3511	!*	ASSERT AND NEGATE 'RESET'
3512	!*	WRT 114/2		- LOAD BUFFER SO 'R I/O DATA' ASSERTS
3513	!*	WRT 112/CORRECT DATA
3514	!*	WRT 113/CORRECT DATA COMPLEMENTED
3515	!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
3516	!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
3517	!*				  AND 'DATA CYCLE'.  THIS GATES THE
3518	!*				  CONTENTS OF THE DATA LOCATIONS ONTO
3519	!*				  THE KS10 BUS.
3520	!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
3521	!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
3522	!*RESPONSE:
3523	!*	'R DATA 00-03' DID NOT GET GATED ONTO THE BUS CORRECTLY.
3524	!]ERROR 1
3525	!]RDATA_03 BUS0_3 CSLBUF0 NTWK
3526	!]ERROR 2
3527	!]RDATA_02 BUS0_3 CSLBUF1 NTWK
3528	!]ERROR 3
3529	!]RDATA_01 BUS0_3 CSLBUF2 NTWK
3530	!]ERROR 4
3531	!]RDATA_00 BUS0_3 CSLBUF3 NTWK
3532	!]ERROR 5
3533	!]ADR0L6_H DATA_CYC BUS0_3 NTWK
3534	!]ERROR 6
3535	!]WRT112 R_CLK_B RD_0 ADR0L6_H ADR1L_H BUS0_3 T_ENB XMIT_DATA X_D1 NTWK
3536	
3537		IF FLP_CHK(1,.FLP_PTR[.I])
3538		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3539		0				!TO PREVENT INFO MSG WHEN COMPILING
3540		END;
3541		END;
3542	
3543	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
3544	
3545		IF .ERROR_FLAG EQL 0
3546		THEN
3547			NOERR(1);
3548	!]NO ERROR 1
3549	!]RD_0 ADR0L6_H ADR0L6_L WRT112 R_CLK_B NTWK
3550	
3551		END;
3552	
3553	GLOBAL ROUTINE TST26: NOVALUE =
3554	
3555	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 04-11'
3556	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
3557	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
3558	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
3559	!R CLK ENB AND DATA CYCLE.
3560	
3561		BEGIN
3562		LOCAL
3563			CORRECT,
3564			ACTUAL;
3565		OWN
3566			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
3567		LABEL BLOCK1;
3568		BIND
3569			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR252,LR110,DR125,LR210,DR141,RP'),
3570					UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR125,LR110,DR252,LR210,DR141,RP'),
3571					UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR63,LR110,DR314,LR210,DR141,RP'),
3572					UPLIT(%ASCIZ'LR100,DR200,DR0,LR111,DR314,LR110,DR63,LR210,DR141,RP'));
3573		MAP
3574			FLP_PTR: VECTOR;
3575	
3576		ERROR_FLAG = 0;		!INIT ERROR FLAG
3577		INCR I FROM 0 TO 3 BY 1 DO
3578		BEGIN
3579		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
3580		DO (0) WHILE
3581	BLOCK1:
3582		BEGIN
3583		INIT();					!DO A RESET
3584		WRT111(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
3585		WRT110((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
3586		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
3587		ACTUAL = RD_3 AND %O'377';		!GET DATA FROM RECEIVERS
3588		ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
3589	!*MESSAGE 1
3590	!*STIMULUS:
3591	!*	ASSERT AND NEGATE 'RESET'
3592	!*	WRT 111/CORRECT DATA
3593	!*	WRT 110/CORRECT DATA COMPLEMENTED
3594	!*	WRT 210/141
3595	!*RESPONSE:
3596	!*	'R DATA 04-11' DID NOT GET GATED ONTO THE BUS CORRECTLY.
3597	!]ERROR 1
3598	!]RDATA_11 NTWK
3599	!]ERROR 2
3600	!]RDATA_10 NTWK
3601	!]ERROR 3
3602	!]RDATA_09 NTWK
3603	!]ERROR 4
3604	!]RDATA_08 NTWK
3605	!]ERROR 5
3606	!]RDATA_07 NTWK
3607	!]ERROR 6
3608	!]RDATA_06 NTWK
3609	!]ERROR 7
3610	!]RDATA_05 NTWK
3611	!]ERROR 8
3612	!]RDATA_04 NTWK
3613	!]ERROR 9
3614	!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
3615	!]ERROR 10
3616	!]BUS4_7 NTWK
3617	!]ERROR 11
3618	!]ADR0L6_L BUS8_11 NTWK
3619	!]ERROR 12
3620	!]BUS4_7 NTWK
3621	!]ERROR 13
3622	!]BUS8_11 NTWK
3623	!]ERROR 14
3624	!]WRT110 RD_0 T_ENB XMIT_ADR R_CLK_B NTWK
3625	
3626		IF FLP_CHK(1,.FLP_PTR[.I])
3627		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3628		0				!TO PREVENT INFO MSG WHEN COMPILING
3629		END;
3630		END;
3631	
3632	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
3633	
3634		IF .ERROR_FLAG EQL 0
3635		THEN
3636			NOERR(1);
3637	!]NO ERROR 1
3638	!]R_CLK_B RD_0 WRT110 ADR0L6_L NTWK
3639	
3640		END;
3641	
3642	GLOBAL ROUTINE TST27: NOVALUE =
3643	
3644	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 04-11'
3645	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
3646	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
3647	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
3648	!R CLK ENB AND DATA CYCLE.
3649	
3650		BEGIN
3651		LOCAL
3652			CORRECT,
3653			ACTUAL;
3654		OWN
3655			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
3656		LABEL BLOCK1;
3657		BIND
3658			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR252,LR111,DR125,LR210,DR123,RP'),
3659					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR125,LR111,DR252,LR210,DR123,RP'),
3660					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR63,LR111,DR314,LR210,DR123,RP'),
3661					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR110,DR314,LR111,DR63,LR210,DR123,RP'));
3662		MAP
3663			FLP_PTR: VECTOR;
3664	
3665		ERROR_FLAG = 0;		!INIT ERROR FLAG
3666		INCR I FROM 0 TO 3 BY 1 DO
3667		BEGIN
3668		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
3669		DO (0) WHILE
3670	BLOCK1:
3671		BEGIN
3672		INIT();					!DO A RESET
3673		WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
3674		WRT110(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
3675		WRT111((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
3676		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
3677		ACTUAL = RD_3 AND %O'377';		!GET DATA FROM RECEIVERS
3678		ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
3679	!*MESSAGE 1
3680	!*STIMULUS:
3681	!*	ASSERT AND NEGATE 'RESET'
3682	!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
3683	!*	WRT 110/CORRECT DATA
3684	!*	WRT 111/CORRECT DATA COMPLEMENTED
3685	!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
3686	!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
3687	!*				  AND 'DATA CYCLE'.  THIS GATES THE
3688	!*				  CONTENTS OF THE DATA LOCATIONS ONTO
3689	!*				  THE KS10 BUS.
3690	!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
3691	!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
3692	!*RESPONSE:
3693	!*	'R DATA 04-11' DID NOT GET GATED ONTO THE BUS CORRECTLY.
3694	!]ERROR 1
3695	!]RDATA_11 NTWK
3696	!]ERROR 2
3697	!]RDATA_10 NTWK
3698	!]ERROR 3
3699	!]RDATA_09 NTWK
3700	!]ERROR 4
3701	!]RDATA_08 NTWK
3702	!]ERROR 5
3703	!]RDATA_07 NTWK
3704	!]ERROR 6
3705	!]RDATA_06 NTWK
3706	!]ERROR 7
3707	!]RDATA_05 NTWK
3708	!]ERROR 8
3709	!]RDATA_04 NTWK
3710	!]ERROR 9
3711	!]DATA_CYC NTWK
3712	!]ERROR 10
3713	!]BUS4_7 NTWK
3714	!]ERROR 11
3715	!]BUS8_11 NTWK
3716	!]ERROR 12
3717	!]BUS4_7 NTWK
3718	!]ERROR 13
3719	!]ADR0L6_L BUS8_11 NTWK
3720	!]ERROR 14
3721	!]WRT110 RD_0 T_ENB XMIT_DATA X_D1 R_CLK_B NTWK
3722		IF FLP_CHK(1,.FLP_PTR[.I])
3723		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3724		0				!TO PREVENT INFO MSG WHEN COMPILING
3725		END;
3726		END;
3727	
3728	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
3729	
3730		IF .ERROR_FLAG EQL 0
3731		THEN
3732			NOERR(1);
3733	!]NO ERROR 1
3734	!]ADR0L6_L RD_0 WRT110 R_CLK_B NTWK
3735	
3736		END;
3737	
3738	GLOBAL ROUTINE TST28: NOVALUE =
3739	
3740	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 12-19'
3741	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
3742	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
3743	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
3744	!R CLK ENB AND DATA CYCLE.
3745	
3746		BEGIN
3747		LOCAL
3748			CORRECT,
3749			ACTUAL;
3750		OWN
3751			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
3752		LABEL BLOCK1;
3753		BIND
3754			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR252,LR106,DR125,LR210,DR141,RP'),
3755					UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR125,LR106,DR252,LR210,DR141,RP'),
3756					UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR63,LR106,DR314,LR210,DR141,RP'),
3757					UPLIT(%ASCIZ'LR100,DR200,DR0,LR107,DR314,LR106,DR63,LR210,DR141,RP'));
3758		MAP
3759			FLP_PTR: VECTOR;
3760	
3761		ERROR_FLAG = 0;		!INIT ERROR FLAG
3762		INCR I FROM 0 TO 3 BY 1 DO
3763		BEGIN
3764		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
3765		DO (0) WHILE
3766	BLOCK1:
3767		BEGIN
3768		INIT();					!DO A RESET
3769		WRT107(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
3770		WRT106((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
3771		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
3772		ACTUAL = RD_2 AND %O'377';		!GET DATA FROM RECEIVERS
3773		ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
3774	!*MESSAGE 1
3775	!*STIMULUS:
3776	!*	ASSERT AND NEGATE 'RESET'
3777	!*	WRT 107/CORRECT DATA
3778	!*	WRT 106/CORRECT DATA COMPLEMENTED
3779	!*	WRT 210/141
3780	!*RESPONSE:
3781	!*	'R DATA 12-19' DID NOT GET GATED ONTO THE BUS CORRECTLY.
3782	!]ERROR 1
3783	!]RDATA_19 NTWK
3784	!]ERROR 2
3785	!]RDATA_18 NTWK
3786	!]ERROR 3
3787	!]RDATA_17 NTWK
3788	!]ERROR 4
3789	!]RDATA_16 NTWK
3790	!]ERROR 5
3791	!]RDATA_15 NTWK
3792	!]ERROR 6
3793	!]RDATA_14 NTWK
3794	!]ERROR 7
3795	!]RDATA_13 NTWK
3796	!]ERROR 8
3797	!]RDATA_12 NTWK
3798	!]ERROR 9
3799	!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
3800	!]ERROR 10
3801	!]BUS12_15 NTWK
3802	!]ERROR 11
3803	!]ADR0L6_L BUS16_19 NTWK
3804	!]ERROR 12
3805	!]T_ENB R_CLK_B BUS12_15 NTWK
3806	!]ERROR 13
3807	!]T_ENB_A R_CLK_A BUS16_19 NTWK
3808	!]ERROR 14
3809	!]WRT106 RD_0 NTWK
3810	
3811		IF FLP_CHK(1,.FLP_PTR[.I])
3812		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3813		0				!TO PREVENT INFO MSG WHEN COMPILING
3814		END;
3815		END;
3816	
3817	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
3818	
3819		IF .ERROR_FLAG EQL 0
3820		THEN
3821			NOERR(1);
3822	!]NO ERROR 1
3823	!]ADR0L6_L RD_0 WRT106 R_CLK_B R_CLK_A NTWK
3824	
3825		END;
3826	
3827	GLOBAL ROUTINE TST29: NOVALUE =
3828	
3829	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 12-19'
3830	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
3831	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
3832	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
3833	!R CLK ENB AND DATA CYCLE.
3834	
3835		BEGIN
3836		LOCAL
3837			CORRECT,
3838			ACTUAL;
3839		OWN
3840			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
3841		LABEL BLOCK1;
3842		BIND
3843			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR252,LR107,DR125,LR210,DR123,RP'),
3844					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR125,LR107,DR252,LR210,DR123,RP'),
3845					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR63,LR107,DR314,LR210,DR123,RP'),
3846					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR106,DR314,LR107,DR63,LR210,DR123,RP'));
3847		MAP
3848			FLP_PTR: VECTOR;
3849	
3850		ERROR_FLAG = 0;		!INIT ERROR FLAG
3851		INCR I FROM 0 TO 3 BY 1 DO
3852		BEGIN
3853		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
3854		DO (0) WHILE
3855	BLOCK1:
3856		BEGIN
3857		INIT();					!DO A RESET
3858		WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
3859		WRT106(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
3860		WRT107((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
3861		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
3862		ACTUAL = RD_2 AND %O'377';		!GET DATA FROM RECEIVERS
3863		ERR_CHK_8(.CORRECT,.ACTUAL);		!GO COMPARE CORRECT AND ACTUAL
3864	!*MESSAGE 1
3865	!*STIMULUS:
3866	!*	ASSERT AND NEGATE 'RESET'
3867	!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
3868	!*	WRT 106/CORRECT DATA
3869	!*	WRT 107/CORRECT DATA COMPLEMENTED
3870	!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
3871	!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
3872	!*				  AND 'DATA CYCLE'.  THIS GATES THE
3873	!*				  CONTENTS OF THE DATA LOCATIONS ONTO
3874	!*				  THE KS10 BUS.
3875	!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
3876	!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
3877	!*RESPONSE:
3878	!*	'R DATA 12-19' DID NOT GET GATED ONTO THE BUS CORRECTLY.
3879	!]ERROR 1
3880	!]RDATA_19 NTWK
3881	!]ERROR 2
3882	!]RDATA_18 NTWK
3883	!]ERROR 3
3884	!]RDATA_17 NTWK
3885	!]ERROR 4
3886	!]RDATA_16 NTWK
3887	!]ERROR 5
3888	!]RDATA_15 NTWK
3889	!]ERROR 6
3890	!]RDATA_14 NTWK
3891	!]ERROR 7
3892	!]RDATA_13 NTWK
3893	!]ERROR 8
3894	!]RDATA_12 NTWK
3895	!]ERROR 9
3896	!]DATA_CYC NTWK
3897	!]ERROR 10
3898	!]BUS12_15 NTWK
3899	!]ERROR 11
3900	!]BUS16_19 NTWK
3901	!]ERROR 12
3902	!]T_ENB R_CLK_B BUS12_15 NTWK
3903	!]ERROR 13
3904	!]ADR0L6_L T_ENB_A R_CLK_A BUS16_19 NTWK
3905	!]ERROR 14
3906	!]WRT106 RD_0 NTWK
3907	
3908		IF FLP_CHK(1,.FLP_PTR[.I])
3909		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3910		0				!TO PREVENT INFO MSG WHEN COMPILING
3911		END;
3912		END;
3913	
3914	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
3915	
3916		IF .ERROR_FLAG EQL 0
3917		THEN
3918			NOERR(1);
3919	!]NO ERROR 1
3920	!]ADR0L6_L RD_0 WRT106 R_CLK_B R_CLK_A NTWK
3921	
3922		END;
3923	
3924	GLOBAL ROUTINE TST30: NOVALUE =
3925	
3926	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 20-27'
3927	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
3928	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
3929	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
3930	!R CLK ENB AND DATA CYCLE.
3931	
3932		BEGIN
3933		LOCAL
3934			CORRECT,
3935			ACTUAL;
3936		OWN
3937			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
3938		LABEL BLOCK1;
3939		BIND
3940			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR252,LR104,DR125,LR210,DR141,RP'),
3941					UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR125,LR104,DR252,LR210,DR141,RP'),
3942					UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR63,LR104,DR314,LR210,DR141,RP'),
3943					UPLIT(%ASCIZ'LR100,DR200,DR0,LR105,DR314,LR104,DR63,LR210,DR141,RP'));
3944		MAP
3945			FLP_PTR: VECTOR;
3946	
3947		ERROR_FLAG = 0;		!INIT ERROR FLAG
3948		INCR I FROM 0 TO 3 BY 1 DO
3949		BEGIN
3950		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
3951		DO (0) WHILE
3952	BLOCK1:
3953		BEGIN
3954		INIT();					!DO A RESET
3955		WRT105(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
3956		WRT104((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
3957		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
3958		ACTUAL = RD_1 AND %O'377';		!GET DATA FROM RECEIVERS
3959		ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
3960	!*MESSAGE 1
3961	!*STIMULUS:
3962	!*	ASSERT AND NEGATE 'RESET'
3963	!*	WRT 105/CORRECT DATA
3964	!*	WRT 104/CORRECT DATA COMPLEMENTED
3965	!*	WRT 210/141
3966	!*RESPONSE:
3967	!*	'R DATA 20-27' DID NOT GET GATED ONTO THE BUS CORRECTLY.
3968	!]ERROR 1
3969	!]RDATA_27 NTWK
3970	!]ERROR 2
3971	!]RDATA_26 NTWK
3972	!]ERROR 3
3973	!]RDATA_25 NTWK
3974	!]ERROR 4
3975	!]RDATA_24 NTWK
3976	!]ERROR 5
3977	!]RDATA_23 NTWK
3978	!]ERROR 6
3979	!]RDATA_22 NTWK
3980	!]ERROR 7
3981	!]RDATA_21 NTWK
3982	!]ERROR 8
3983	!]RDATA_20 NTWK
3984	!]ERROR 9
3985	!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
3986	!]ERROR 10
3987	!]BUS20_23 NTWK
3988	!]ERROR 11
3989	!]ADR0L6_L BUS24_27 NTWK
3990	!]ERROR 12
3991	!]BUS20_23 NTWK
3992	!]ERROR 13
3993	!]BUS24_27 NTWK
3994	!]ERROR 14
3995	!]R_CLK_A T_ENB_A WRT104 RD_0 NTWK
3996	
3997		IF FLP_CHK(1,.FLP_PTR[.I])
3998		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3999		0				!TO PREVENT INFO MSG WHEN COMPILING
4000		END;
4001		END;
4002	
4003	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
4004	
4005		IF .ERROR_FLAG EQL 0
4006		THEN
4007			NOERR(1);
4008	!]NO ERROR 1
4009	!]ADR0L6_L RD_0 WRT104 R_CLK_A NTWK
4010	
4011		END;
4012	
4013	GLOBAL ROUTINE TST31: NOVALUE =
4014	
4015	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 20-27'
4016	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
4017	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
4018	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
4019	!R CLK ENB AND DATA CYCLE.
4020	
4021		BEGIN
4022		LOCAL
4023			CORRECT,
4024			ACTUAL;
4025		OWN
4026			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
4027		LABEL BLOCK1;
4028		BIND
4029			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR252,LR105,DR125,LR210,DR123,RP'),
4030					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR125,LR105,DR252,LR210,DR123,RP'),
4031					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR63,LR105,DR314,LR210,DR123,RP'),
4032					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR104,DR314,LR105,DR63,LR210,DR123,RP'));
4033		MAP
4034			FLP_PTR: VECTOR;
4035	
4036		ERROR_FLAG = 0;		!INIT ERROR FLAG
4037		INCR I FROM 0 TO 3 BY 1 DO
4038		BEGIN
4039		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
4040		DO (0) WHILE
4041	BLOCK1:
4042		BEGIN
4043		INIT();					!DO A RESET
4044		WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
4045		WRT104(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
4046		WRT105((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
4047		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
4048		ACTUAL = RD_1 AND %O'377';		!GET DATA FROM RECEIVERS
4049		ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
4050	!*MESSAGE 1
4051	!*STIMULUS:
4052	!*	ASSERT AND NEGATE 'RESET'
4053	!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
4054	!*	WRT 104/CORRECT DATA
4055	!*	WRT 105/CORRECT DATA COMPLEMENTED
4056	!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
4057	!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
4058	!*				  AND 'DATA CYCLE'.  THIS GATES THE
4059	!*				  CONTENTS OF THE DATA LOCATIONS ONTO
4060	!*				  THE KS10 BUS.
4061	!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
4062	!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
4063	!*RESPONSE:
4064	!*	'R DATA 20-27' DID NOT GET GATED ONTO THE BUS CORRECTLY.
4065	!]ERROR 1
4066	!]RDATA_27 NTWK
4067	!]ERROR 2
4068	!]RDATA_26 NTWK
4069	!]ERROR 3
4070	!]RDATA_25 NTWK
4071	!]ERROR 4
4072	!]RDATA_24 NTWK
4073	!]ERROR 5
4074	!]RDATA_23 NTWK
4075	!]ERROR 6
4076	!]RDATA_22 NTWK
4077	!]ERROR 7
4078	!]RDATA_21 NTWK
4079	!]ERROR 8
4080	!]RDATA_20 NTWK
4081	!]ERROR 9
4082	!]DATA_CYC NTWK
4083	!]ERROR 10
4084	!]BUS20_23 NTWK
4085	!]ERROR 11
4086	!]BUS24_27 NTWK
4087	!]ERROR 12
4088	!]BUS20_23 NTWK
4089	!]ERROR 13
4090	!]ADR0L6_L BUS24_27 NTWK
4091	!]ERROR 14
4092	!]R_CLK_A T_ENB_A WRT104 RD_0 NTWK
4093	
4094		IF FLP_CHK(1,.FLP_PTR[.I])
4095		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4096		0				!TO PREVENT INFO MSG WHEN COMPILING
4097		END;
4098		END;
4099	
4100	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
4101	
4102		IF .ERROR_FLAG EQL 0
4103		THEN
4104			NOERR(1);
4105	!]NO ERROR 1
4106	!]ADR0L6_L RD_0 WRT104 R_CLK_A NTWK
4107	
4108		END;
4109	
4110	GLOBAL ROUTINE TST32: NOVALUE =
4111	
4112	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 28-35'
4113	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE COM/ADR LOCATIONS
4114	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
4115	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
4116	!R CLK ENB AND DATA CYCLE.
4117	
4118		BEGIN
4119		LOCAL
4120			CORRECT,
4121			ACTUAL;
4122		OWN
4123			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
4124		LABEL BLOCK1;
4125		BIND
4126			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR252,LR102,DR125,LR210,DR141,RP'),
4127					UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR125,LR102,DR252,LR210,DR141,RP'),
4128					UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR63,LR102,DR314,LR210,DR141,RP'),
4129					UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR314,LR102,DR63,LR210,DR141,RP'));
4130		MAP
4131			FLP_PTR: VECTOR;
4132	
4133		ERROR_FLAG = 0;		!INIT ERROR FLAG
4134		INCR I FROM 0 TO 3 BY 1 DO
4135		BEGIN
4136		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
4137		DO (0) WHILE
4138	BLOCK1:
4139		BEGIN
4140		INIT();					!DO A RESET
4141		WRT103(.CORRECT);				!WRITE TEST DATA TO COM/ADR LOCS
4142		WRT104((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO DATA LOCS
4143		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
4144		ACTUAL = RD_0 AND %O'377';		!GET DATA FROM RECEIVERS
4145		ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
4146	!*MESSAGE 1
4147	!*STIMULUS:
4148	!*	ASSERT AND NEGATE 'RESET'
4149	!*	WRT 103/CORRECT DATA
4150	!*	WRT 102/CORRECT DATA COMPLEMENTED
4151	!*	WRT 210/141
4152	!*RESPONSE:
4153	!*	'R DATA 28-35' DID NOT GET GATED ONTO THE BUS CORRECTLY.
4154	!]ERROR 1
4155	!]RDATA_35 NTWK
4156	!]ERROR 2
4157	!]RDATA_34 NTWK
4158	!]ERROR 3
4159	!]RDATA_33 NTWK
4160	!]ERROR 4
4161	!]RDATA_32 NTWK
4162	!]ERROR 5
4163	!]RDATA_31 NTWK
4164	!]ERROR 6
4165	!]RDATA_30 NTWK
4166	!]ERROR 7
4167	!]RDATA_29 NTWK
4168	!]ERROR 8
4169	!]RDATA_28 NTWK
4170	!]ERROR 9
4171	!]DATA_CYC STAT_RD X_D1 XMIT_DATA NTWK
4172	!]ERROR 10
4173	!]BUS28_31 NTWK
4174	!]ERROR 11
4175	!]ADR0L6_L BUS32_35 NTWK
4176	!]ERROR 12
4177	!]BUS28_31 NTWK
4178	!]ERROR 13
4179	!]BUS32_35 NTWK
4180	!]ERROR 14
4181	!]R_CLK_A T_ENB_A WRT102 RD_0 NTWK
4182	
4183		IF FLP_CHK(1,.FLP_PTR[.I])
4184		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4185		0				!TO PREVENT INFO MSG WHEN COMPILING
4186		END;
4187		END;
4188	
4189	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
4190	
4191		IF .ERROR_FLAG EQL 0
4192		THEN
4193			NOERR(1);
4194	!]NO ERROR 1
4195	!]RD_0 WRT102 ADR0L6_L R_CLK_A NTWK
4196	
4197		END;
4198	
4199	GLOBAL ROUTINE TST33: NOVALUE =
4200	
4201	!THIS TEST CHECKS THAT THE KS10 BUS DATA SIGNALS 'DATA 28-35'
4202	!CAN BE CORRECTLY CLOCKED ONTO THE BUS FROM THE DATA LOCATIONS
4203	!IN THE 4-BY-4 MEMORY CHIP.  THIS CHECKS OUT THE 8646 TRANSCEIVERS,
4204	!THE 4-BY-4 MEMORY CHIP, AND THE ASSOCIATED CONTROL SIGNALS - T ENB,
4205	!R CLK ENB AND DATA CYCLE.
4206	
4207		BEGIN
4208		LOCAL
4209			CORRECT,
4210			ACTUAL;
4211		OWN
4212			DATA_TABLE: VECTOR[4] INITIAL (%O'252',%O'125',%O'63',%O'314');
4213		LABEL BLOCK1;
4214		BIND
4215			FLP_PTR = UPLIT(UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR252,LR103,DR125,LR210,DR123,RP'),
4216					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR125,LR103,DR252,LR210,DR123,RP'),
4217					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR63,LR103,DR314,LR210,DR123,RP'),
4218					UPLIT(%ASCIZ'LR100,DR200,DR0,LR114,DR2,LR102,DR314,LR103,DR63,LR210,DR123,RP'));
4219		MAP
4220			FLP_PTR: VECTOR;
4221	
4222		ERROR_FLAG = 0;		!INIT ERROR FLAG
4223		INCR I FROM 0 TO 3 BY 1 DO
4224		BEGIN
4225		CORRECT = .DATA_TABLE[.I];		!GET TEST DATA
4226		DO (0) WHILE
4227	BLOCK1:
4228		BEGIN
4229		INIT();					!DO A RESET
4230		WRT114(IO_DATA);			!LOAD I/O BUFFER SO R I/O DATA ASSERTS
4231		WRT102(.CORRECT);				!WRITE TEST DATA TO DATA LOCS
4232		WRT103((NOT .CORRECT) AND %O'377');	!WRITE COMPLEMENT TO COM/ADR LOCS
4233		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA INTO RECEIVERS
4234		ACTUAL = RD_0 AND %O'377';		!GET DATA FROM RECEIVERS
4235		ERR_CHK_8(.CORRECT,.ACTUAL);	!COMPARE CORRECT AND ACTUAL
4236	!*MESSAGE 1
4237	!*STIMULUS:
4238	!*	ASSERT AND NEGATE 'RESET'
4239	!*	WRT 114/2		- LOAD BFFER SO 'R I/O DATA' ASSERTS
4240	!*	WRT 102/CORRECT DATA
4241	!*	WRT 103/CORRECT DATA COMPLEMENTED
4242	!*	WRT 210/123		- ASSERTING 'BUS REQ' AND 'XMIT DATA
4243	!*				  (1)' WILL ASSERT 'T ENB', 'T ENB A',
4244	!*				  AND 'DATA CYCLE'.  THIS GATES THE
4245	!*				  CONTENTS OF THE DATA LOCATIONS ONTO
4246	!*				  THE KS10 BUS.
4247	!*				- ASSERTING 'LATCH DATA (1)' WILL LATCH
4248	!*				  THIS DATA IN THE 8646 TRANSCEIVERS.
4249	!*RESPONSE:
4250	!*	'R DATA 28-35' DID NOT GET GATED ONTO THE BUS CORRECTLY.
4251	!]ERROR 1
4252	!]RDATA_35 NTWK
4253	!]ERROR 2
4254	!]RDATA_34 NTWK
4255	!]ERROR 3
4256	!]RDATA_33 NTWK
4257	!]ERROR 4
4258	!]RDATA_32 NTWK
4259	!]ERROR 5
4260	!]RDATA_31 NTWK
4261	!]ERROR 6
4262	!]RDATA_30 NTWK
4263	!]ERROR 7
4264	!]RDATA_29 NTWK
4265	!]ERROR 8
4266	!]RDATA_28 NTWK
4267	!]ERROR 9
4268	!]DATA_CYC NTWK
4269	!]ERROR 10
4270	!]BUS28_31 NTWK
4271	!]ERROR 11
4272	!]BUS32_35 NTWK
4273	!]ERROR 12
4274	!]BUS28_31 NTWK
4275	!]ERROR 13
4276	!]ADR0L6_L BUS32_35 NTWK
4277	!]ERROR 14
4278	!]R_CLK_A T_ENB_A WRT102 RD_0 NTWK
4279	
4280		IF FLP_CHK(1,.FLP_PTR[.I])
4281		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4282		0				!TO PREVENT INFO MSG WHEN COMPILING
4283		END;
4284		END;
4285	
4286	!IF WE HAD NO ERRORS, DO SOME FAULT ISOLATION
4287	
4288		IF .ERROR_FLAG EQL 0
4289		THEN
4290			NOERR(1);
4291	!]NO ERROR 1
4292	!]RD_0 WRT102 ADR0L6_L R_CLK_A NTWK
4293	
4294		END;
4295	
4296	GLOBAL ROUTINE TST34: NOVALUE =
4297	
4298	!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' ISN'T
4299	!STUCK ASSERTED.
4300	
4301		BEGIN
4302		LABEL BLOCK1;
4303		BIND
4304			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR1,RP');
4305	
4306		LOCAL
4307			DATA;
4308		DO (0) WHILE
4309	BLOCK1:
4310		BEGIN
4311		INIT();					!DO A RESET
4312		WRT106(%O'252');			!WRITE DATA TO DATA LOC
4313		WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
4314		WRT210(CLOSE_LATCH);			!CLOSE THE TRANSCEIVER LATCHES
4315		DATA = RD_2 AND %O'377';		!READ R DATA 12-19
4316		IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
4317			THEN ERRCA(1,0,.DATA,3);	!YES
4318	!*MESSAGE 1
4319	!*STIMULUS:
4320	!*	ASSERT AND NEGATE 'RESET'
4321	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4322	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4323	!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4324	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4325	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4326	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4327	!*RESPONSE:
4328	!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
4329	!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
4330	!*	THEY SHOULDN'T HAVE BEEN.
4331	!]ERROR 1
4332	!]XMIT_ENBS NTWK
4333	
4334		IF FLP_CHK(1,FLP_PTR)
4335			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4336		IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
4337			THEN ERRCA(2,0,.DATA,3);	!YES
4338	!*MESSAGE 2
4339	!*STIMULUS:
4340	!*	ASSERT AND NEGATE 'RESET'
4341	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4342	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4343	!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4344	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4345	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4346	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4347	!*RESPONSE:
4348	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
4349	!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
4350	!*	HAVE BEEN.
4351	!]ERROR 2
4352	!]XMIT_ENBS NTWK
4353	
4354		IF FLP_CHK(2,FLP_PTR)
4355			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4356	
4357		IF .DATA EQL %O'120'			!WERE BITS 12-15 TRANSMITTED?
4358			THEN ERRCA(3,0,.DATA,3);	!YES
4359	!*MESSAGE 3
4360	!*STIMULUS:
4361	!*	ASSERT AND NEGATE 'RESET'
4362	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4363	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4364	!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4365	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4366	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4367	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4368	!*RESPONSE:
4369	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
4370	!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
4371	!]ERROR 3
4372	!]XMIT_ENBS NTWK
4373	
4374		IF FLP_CHK(3,FLP_PTR)
4375			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4376	
4377		IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
4378			THEN ERRCA(4,0,.DATA,3);	!YES
4379	!*MESSAGE 4
4380	!*STIMULUS:
4381	!*	ASSERT AND NEGATE 'RESET'
4382	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4383	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4384	!*	WRT 210/1	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4385	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4386	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4387	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4388	!*RESPONSE:
4389	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
4390	!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
4391	!]ERROR 4
4392	!]XMIT_ENBS NTWK
4393	
4394		IF FLP_CHK(4,FLP_PTR)
4395			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4396		0				!TO PREVENT INFO MSG WHEN COMPILING
4397		END;
4398	
4399		END;
4400	
4401	GLOBAL ROUTINE TST35: NOVALUE =
4402	
4403	!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' DON'T
4404	!ASSERT WHEN 'XMIT DATA (1)' AND 'XMIT ADR (1)' ARE NEGATED DURING
4405	!A BUS REQUEST.
4406	
4407		BEGIN
4408		LABEL BLOCK1;
4409		BIND
4410			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR101,RP');
4411	
4412		LOCAL
4413			DATA;
4414		DO (0) WHILE
4415	BLOCK1:
4416		BEGIN
4417		INIT();					!DO A RESET
4418		WRT106(%O'252');			!WRITE DATA TO DATA LOC
4419		WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
4420		WRT210(BUS_REQ + CLOSE_LATCH);		!GENERATE BUS REQUEST AND CLOSE LATCHES
4421		DATA = RD_2 AND %O'377';		!READ R DATA 12-19
4422		IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
4423			THEN ERRCA(1,0,.DATA,3);	!YES
4424	!*MESSAGE 1
4425	!*STIMULUS:
4426	!*	ASSERT AND NEGATE 'RESET'
4427	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4428	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4429	!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
4430	!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4431	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4432	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4433	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4434	!*RESPONSE:
4435	!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
4436	!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
4437	!*	THEY SHOULDN'T HAVE BEEN.
4438	!]ERROR 1
4439	!]XMIT_ENBS NTWK
4440	
4441		IF FLP_CHK(1,FLP_PTR)
4442			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4443		IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
4444			THEN ERRCA(2,0,.DATA,3);	!YES
4445	!*MESSAGE 2
4446	!*STIMULUS:
4447	!*	ASSERT AND NEGATE 'RESET'
4448	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4449	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4450	!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
4451	!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4452	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4453	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4454	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4455	!*RESPONSE:
4456	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
4457	!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
4458	!*	HAVE BEEN.
4459	!]ERROR 2
4460	!]XMIT_ENBS NTWK
4461	
4462		IF FLP_CHK(2,FLP_PTR)
4463			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4464	
4465		IF .DATA EQL 120			!WERE BITS 12-15 TRANSMITTED?
4466			THEN ERRCA(3,0,.DATA,3);	!YES
4467	!*MESSAGE 3
4468	!*STIMULUS:
4469	!*	ASSERT AND NEGATE 'RESET'
4470	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4471	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4472	!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
4473	!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4474	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4475	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4476	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4477	!*RESPONSE:
4478	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
4479	!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
4480	!]ERROR 3
4481	!]XMIT_ENBS NTWK
4482	
4483		IF FLP_CHK(3,FLP_PTR)
4484			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4485	
4486		IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
4487			THEN ERRCA(4,0,.DATA,3);	!YES
4488	!*MESSAGE 4
4489	!*STIMULUS:
4490	!*	ASSERT AND NEGATE 'RESET'
4491	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4492	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4493	!*	WRT 210/2	- 'BUS REQ' WILL ASSERT 'GRANT
4494	!*			  ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4495	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4496	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4497	!*			  AND ALL ZEROS SHOULD BE TRANSMITTED.
4498	!*RESPONSE:
4499	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
4500	!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
4501	!]ERROR 4
4502	!]XMIT_ENBS NTWK
4503	
4504		IF FLP_CHK(4,FLP_PTR)
4505			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4506		0				!TO PREVENT INFO MSG WHEN COMPILING
4507		END;
4508	
4509		END;
4510	
4511	GLOBAL ROUTINE TST36: NOVALUE =
4512	
4513	!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' DON'T
4514	!ASSERT WHEN 'XMIT DATA (1)' IS ASSERTED WITHOUT A BUS REQUEST.
4515	
4516		BEGIN
4517		LABEL BLOCK1;
4518		BIND
4519			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR20,DR21,RP');
4520	
4521		LOCAL
4522			DATA;
4523		DO (0) WHILE
4524	BLOCK1:
4525		BEGIN
4526		INIT();					!DO A RESET
4527		WRT106(%O'252');			!WRITE DATA TO DATA LOC
4528		WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
4529		WRT210(XMIT_DATA);			!ASSERT 'XMIT DATA (1)'
4530		WRT210(XMIT_DATA + CLOSE_LATCH);	!NOW CLOSE THE LATCHES
4531		DATA = RD_2 AND %O'377';		!READ R DATA 12-19
4532		IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
4533			THEN ERRCA(1,0,.DATA,3);	!YES
4534	!*MESSAGE 1
4535	!*STIMULUS:
4536	!*	ASSERT AND NEGATE 'RESET'
4537	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4538	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4539	!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
4540	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4541	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4542	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4543	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4544	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4545	!*RESPONSE:
4546	!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
4547	!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
4548	!*	THEY SHOULDN'T HAVE BEEN.
4549	!]ERROR 1
4550	!]XMIT_ENBS NTWK
4551	
4552		IF FLP_CHK(1,FLP_PTR)
4553			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4554		IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
4555			THEN ERRCA(2,0,.DATA,3);	!YES
4556	!*MESSAGE 2
4557	!*STIMULUS:
4558	!*	ASSERT AND NEGATE 'RESET'
4559	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4560	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4561	!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
4562	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4563	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4564	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4565	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4566	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4567	!*RESPONSE:
4568	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
4569	!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
4570	!*	HAVE BEEN.
4571	!]ERROR 2
4572	!]XMIT_ENBS NTWK
4573	
4574		IF FLP_CHK(2,FLP_PTR)
4575			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4576	
4577		IF .DATA EQL 120			!WERE BITS 12-15 TRANSMITTED?
4578			THEN ERRCA(3,0,.DATA,3);	!YES
4579	!*MESSAGE 3
4580	!*STIMULUS:
4581	!*	ASSERT AND NEGATE 'RESET'
4582	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4583	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4584	!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
4585	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4586	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4587	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4588	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4589	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4590	!*RESPONSE:
4591	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
4592	!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
4593	!]ERROR 3
4594	!]XMIT_ENBS NTWK
4595	
4596		IF FLP_CHK(3,FLP_PTR)
4597			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4598	
4599		IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
4600			THEN ERRCA(4,0,.DATA,3);	!YES
4601	!*MESSAGE 4
4602	!*STIMULUS:
4603	!*	ASSERT AND NEGATE 'RESET'
4604	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4605	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4606	!*	WRT 210/20	- ASSERT 'XMIT DATA (1)'
4607	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4608	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4609	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4610	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4611	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4612	!*RESPONSE:
4613	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
4614	!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
4615	!]ERROR 4
4616	!]XMIT_ENBS NTWK
4617	
4618		IF FLP_CHK(4,FLP_PTR)
4619			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4620		0				!TO PREVENT INFO MSG WHEN COMPILING
4621		END;
4622	
4623		END;
4624	
4625	GLOBAL ROUTINE TST37: NOVALUE =
4626	
4627	!THIS TEST CHECKS THAT 'T ENB' OR 'T ENB A' OR 'DATA CYCLE' DON'T
4628	!ASSERT WHEN 'XMIT ADR (1)' IS ASSERTED WITHOUT A BUS REQUEST.
4629	
4630		BEGIN
4631		LABEL BLOCK1;
4632		BIND
4633			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR106,DR252,LR107,DR125,LR210,DR40,DR41,RP');
4634	
4635		LOCAL
4636			DATA;
4637		DO (0) WHILE
4638	BLOCK1:
4639		BEGIN
4640		INIT();					!DO A RESET
4641		WRT106(%O'252');			!WRITE DATA TO DATA LOC
4642		WRT107(%O'125');			!WRITE COMPLEMENT TO COM/ADR LOC
4643		WRT210(XMIT_ADR);			!ASSERT 'XMIT ADR (1)'
4644		WRT210(XMIT_ADR + CLOSE_LATCH);		!NOW CLOSE THE LATCHES
4645		DATA = RD_2 AND %O'377';		!READ R DATA 12-19
4646		IF .DATA EQL %O'252'			!DID 'DATA' DATA GET TRANSMITTED?
4647			THEN ERRCA(1,0,.DATA,3);	!YES
4648	!*MESSAGE 1
4649	!*STIMULUS:
4650	!*	ASSERT AND NEGATE 'RESET'
4651	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4652	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4653	!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
4654	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4655	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4656	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4657	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4658	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4659	!*RESPONSE:
4660	!*	DATA FROM 'DATA' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES THAT
4661	!*	'T ENB', 'T ENB A', AND 'DATA CYCLE' WERE ALL ASSERTED WHEN
4662	!*	THEY SHOULDN'T HAVE BEEN.
4663	!]ERROR 1
4664	!]XMIT_ENBS NTWK
4665	
4666		IF FLP_CHK(1,FLP_PTR)
4667			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4668		IF .DATA EQL %O'125'			!WAS 'COM/ADR' DATA TRANSMITTED?
4669			THEN ERRCA(2,0,.DATA,3);	!YES
4670	!*MESSAGE 2
4671	!*STIMULUS:
4672	!*	ASSERT AND NEGATE 'RESET'
4673	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4674	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4675	!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
4676	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4677	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4678	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4679	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4680	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4681	!*RESPONSE:
4682	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED.  THIS IMPLIES
4683	!*	THAT 'T ENB' AND 'T ENB A' WERE ASSERTED WHEN THEY SHOULDN'T
4684	!*	HAVE BEEN.
4685	!]ERROR 2
4686	!]XMIT_ENBS NTWK
4687	
4688		IF FLP_CHK(2,FLP_PTR)
4689			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4690	
4691		IF .DATA EQL 120			!WERE BITS 12-15 TRANSMITTED?
4692			THEN ERRCA(3,0,.DATA,3);	!YES
4693	!*MESSAGE 3
4694	!*STIMULUS:
4695	!*	ASSERT AND NEGATE 'RESET'
4696	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4697	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4698	!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
4699	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4700	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4701	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4702	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4703	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4704	!*RESPONSE:
4705	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 12-15'.
4706	!*	THIS IMPLIES THAT 'T ENB' WAS INCORRECTLY ASSERTED.
4707	!]ERROR 3
4708	!]XMIT_ENBS NTWK
4709	
4710		IF FLP_CHK(3,FLP_PTR)
4711			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4712	
4713		IF .DATA EQL 5				!WERE BITS 16-19 TRANSMITTED?
4714			THEN ERRCA(4,0,.DATA,3);	!YES
4715	!*MESSAGE 4
4716	!*STIMULUS:
4717	!*	ASSERT AND NEGATE 'RESET'
4718	!*	WRT 106/252	- PUT DATA INTO 'DATA' LOCATIONS
4719	!*	WRT 107/125	- PUT DATA INTO 'COM/ADR' LOCATIONS
4720	!*	WRT 210/20	- ASSERT 'XMIT ADR (1)'
4721	!*	WRT 210/21	- ASSERTING 'CLOSE LATCHS' WILL LATCH THE
4722	!*			  TRANSMITTED DATA INTO 'R DATA 12-19'. IN THIS
4723	!*			  CASE, THE 'T ENB' SIGNALS SHOULD BE NEGATED
4724	!*			  SINCE 'GRANT' WILL NOT GET ASSERTED. SO
4725	!*			  ALL ZEROS SHOULD BE TRANSMITTED.
4726	!*RESPONSE:
4727	!*	DATA FROM 'COM/ADR' LOCATIONS GOT TRANSMITTED TO 'R DATA 16-19'.
4728	!*	THIS IMPLIES THAT 'T ENB A' WAS INCORRECTLY ASSERTED.
4729	!]ERROR 4
4730	!]XMIT_ENBS NTWK
4731	
4732		IF FLP_CHK(4,FLP_PTR)
4733			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4734		0				!TO PREVENT INFO MSG WHEN COMPILING
4735		END;
4736	
4737		END;
4738	
4739	GLOBAL ROUTINE TST38: NOVALUE =
4740	
4741	!THIS TEST CHECKS THAT 'STATUS RD (1)' ASSERTS WHEN 'R COM/ADR' ASSERTS
4742	!WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' ASSERTED AND 'R DATA 19'
4743	!ASSERTED.
4744	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
4745	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
4746	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
4747	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
4748	
4749		BEGIN
4750		LABEL BLOCK1;
4751		BIND
4752			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
4753	
4754		LOCAL
4755			DATA;
4756		DO (0) WHILE
4757	BLOCK1:
4758		BEGIN
4759		INIT();					!DO A RESET
4760		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
4761		INIT();					!DO A RESET
4762		WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
4763		WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
4764		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
4765		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
4766		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
4767		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
4768		WRT110(%O'63');				!WRITE DATA TO 110
4769		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
4770		SYNC_CLK();			!STOP CLOCK AND SYNC IT
4771		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
4772		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
4773		DATA = RD_3;				!READ 'R DATA 04-11'
4774		IF .DATA NEQ %O'63'			!DID DATA GET TRANSMITTED?
4775		THEN
4776			ERRCA(1,%O'63',.DATA,3);	!NO, REPORT ERROR
4777	!*MESSAGE 1
4778	!*STIMULUS:
4779	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
4780	!*	ASSERT AND NEGATE 'RESET'
4781	!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
4782	!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
4783	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
4784	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
4785	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
4786	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
4787	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
4788	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
4789	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
4790	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
4791	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
4792	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
4793	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
4794	!*			  BUS AND INTO THE RECEIVERS.  THE 4TH CYCLE
4795	!*			  WILL ASSERT 'STATUS RD (1)', WHICH WILL ASSERT
4796	!*			  'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE 5TH
4797	!*			  CYCLE SHOULD CLOCK THE DATA FROM THE DATA
4798	!*			  LOCS ONTO THE BUS AND INTO THE RECEIVERS.
4799	!*RESPONSE:
4800	!*	'R DATA 04-11' IS NOT THE TEST DATA.  THIS IMPLIES THAT
4801	!*	'STATUS RD (1)' IS NOT ASSERTED.
4802	!]ERROR 1
4803	!]STAT_RD NTWK
4804	
4805		IF FLP_CHK(1,FLP_PTR)
4806			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4807		0				!TO PREVENT INFO MSG WHEN COMPILING
4808	
4809		END;
4810	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
4811		INIT();			!DO A RESET
4812		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
4813		WRT210(0);
4814		WRT114(0);
4815		WRT115(0);
4816	
4817		END;
4818	
4819	GLOBAL ROUTINE TST39: NOVALUE =
4820	
4821	!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
4822	!ASSERTS WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' ASSERTED AND
4823	!'R DATA 19' NEGATED.
4824	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
4825	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
4826	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
4827	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
4828	
4829		BEGIN
4830		LABEL BLOCK1;
4831		BIND
4832			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
4833	
4834		LOCAL
4835			DATA;
4836		DO (0) WHILE
4837	BLOCK1:
4838		BEGIN
4839		INIT();					!DO A RESET
4840		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
4841		INIT();					!DO A RESET
4842		WRT107(0);				!NEGATE 'R DATA 19' IN COM/ADR LOC
4843		WRT106(0);				!NEGATE 'R DATA 19' IN DATA LOC
4844		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
4845		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
4846		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
4847		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
4848		WRT110(%O'63');				!WRITE DATA TO 110
4849		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
4850		SYNC_CLK();			!STOP CLOCK AND SYNC IT
4851		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
4852		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
4853		DATA = RD_3;				!READ 'R DATA 04-11'
4854		IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
4855		THEN
4856			ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
4857	!*MESSAGE 1
4858	!*STIMULUS:
4859	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
4860	!*	ASSERT AND NEGATE 'RESET'
4861	!*	WRT 107/0	- NEGATE 'R DATA 19' IN COM/ADR LOC
4862	!*	WRT 106/0	- NEGATE 'R DATA 19' IN DATA LOC
4863	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
4864	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
4865	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
4866	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
4867	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
4868	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
4869	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
4870	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
4871	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
4872	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
4873	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
4874	!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 19'
4875	!*			  NEGATED, 'STATUS RD (1)' WILL NOT ASSERT ON
4876	!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
4877	!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
4878	!*			  ONTO THE BUS AND INTO THE RECEIVERS.
4879	!*RESPONSE:
4880	!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
4881	!*	'STATUS RD (1)' IS ASSERTED.
4882	!]ERROR 1
4883	!]STAT_RD NTWK
4884	
4885		IF FLP_CHK(1,FLP_PTR)
4886			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4887		0				!TO PREVENT INFO MSG WHEN COMPILING
4888	
4889		END;
4890	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
4891		INIT();			!DO A RESET
4892		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
4893		WRT210(0);
4894		WRT114(0);
4895		WRT115(0);
4896	
4897		END;
4898	
4899	GLOBAL ROUTINE TST40: NOVALUE =
4900	
4901	!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
4902	!ASSERTS WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' NEGATED AND
4903	!'R DATA 19' ASSERTED.
4904	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
4905	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
4906	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
4907	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
4908	
4909		BEGIN
4910		LABEL BLOCK1;
4911		LOCAL
4912			DATA;
4913		DO (0) WHILE
4914	BLOCK1:
4915		BEGIN
4916		INIT();					!DO A RESET
4917		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
4918		INIT();					!DO A RESET
4919		WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
4920		WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
4921		WRT113(0);				!NEGATE 'R DATA 00' IN COM/ADR LOC
4922		WRT112(0);				!NEGATE 'R DATA 00' IN DATA LOC
4923		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
4924		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
4925		WRT110(%O'63');				!WRITE DATA TO 110
4926		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
4927		SYNC_CLK();			!STOP CLOCK AND SYNC IT
4928		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
4929		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
4930		DATA = RD_3;				!READ 'R DATA 4-11'
4931		IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
4932		THEN
4933			ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
4934	!*MESSAGE 1
4935	!*STIMULUS:
4936	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
4937	!*	ASSERT AND NEGATE 'RESET'
4938	!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
4939	!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
4940	!*	WRT 113/0	- NEGATE 'R DATA 00' IN COM/ADR LOC
4941	!*	WRT 112/0	- NEGATE 'R DATA 00' IN DATA LOC
4942	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
4943	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
4944	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
4945	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
4946	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
4947	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
4948	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
4949	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
4950	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
4951	!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 00'
4952	!*			  NEGATED, 'STATUS RD (1)' WILL NOT ASSERT ON
4953	!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
4954	!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
4955	!*			  ONTO THE BUS AND INTO THE RECEIVERS.
4956	!*RESPONSE:
4957	!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
4958	!*	'STATUS RD (1)' IS ASSERTED.
4959	!]ERROR 1
4960	!]STAT_RD NTWK
4961	
4962		IF LOOP_CHK(1)
4963			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4964		0				!TO PREVENT INFO MSG WHEN COMPILING
4965	
4966		END;
4967	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
4968		INIT();			!DO A RESET
4969		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
4970		WRT210(0);
4971		WRT114(0);
4972		WRT115(0);
4973	
4974		END;
4975	
4976	GLOBAL ROUTINE TST41: NOVALUE =
4977	
4978	!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WITH 'R COM/ADR'
4979	!NEGATED WITH 'R DATA 14-17' = ZEROS, 'R DATA 00' ASSERTED AND
4980	!'R DATA 19' ASSERTED.
4981	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
4982	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
4983	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
4984	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
4985	
4986		BEGIN
4987		LABEL BLOCK1;
4988		BIND
4989			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
4990	
4991		LOCAL
4992			DATA;
4993		DO (0) WHILE
4994	BLOCK1:
4995		BEGIN
4996		INIT();					!DO A RESET
4997		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
4998		INIT();					!DO A RESET
4999		WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
5000		WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
5001		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
5002		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
5003		WRT115(0);				!NEGATE 'R COM/ADR' IN COM/ADR LOC
5004		WRT114(0);				!NEGATE 'R COM/ADR' IN DATA LOC
5005		WRT110(%O'63');				!WRITE DATA TO 110
5006		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5007		SYNC_CLK();			!STOP CLOCK AND SYNC IT
5008		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
5009		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
5010		DATA = RD_3;				!READ 'R DATA 04-11'
5011		IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
5012		THEN
5013			ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
5014	!*MESSAGE 1
5015	!*STIMULUS:
5016	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
5017	!*	ASSERT AND NEGATE 'RESET'
5018	!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
5019	!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
5020	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
5021	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
5022	!*	WRT 115/0	- NEGATE 'R COM/ADR' IN COM/ADR LOC
5023	!*	WRT 114/0	- NEGATE 'R COM/ADR' IN DATA LOC
5024	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
5025	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5026	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
5027	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
5028	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
5029	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
5030	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
5031	!*			  BUS AND INTO THE RECEIVERS. WITH 'R COM/ADR'
5032	!*			  NEGATED, 'STATUS RD (1)' WILL NOT ASSERT ON
5033	!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
5034	!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
5035	!*			  ONTO THE BUS AND INTO THE RECEIVERS.
5036	!*RESPONSE:
5037	!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
5038	!*	'STATUS RD (1)' IS ASSERTED.
5039	!]ERROR 1
5040	!]STAT_RD NTWK
5041	
5042		IF FLP_CHK(1,FLP_PTR)
5043			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5044		0				!TO PREVENT INFO MSG WHEN COMPILING
5045	
5046		END;
5047		INIT();			!DO A RESET
5048		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5049		WRT210(0);
5050	
5051		END;
5052	
5053	GLOBAL ROUTINE TST42: NOVALUE =
5054	
5055	!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
5056	!ASSERTS WITH 'R DATA 14-17' = 10, 'R DATA 00' ASSERTED AND
5057	!'R DATA 19' NEGATED.
5058	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
5059	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
5060	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
5061	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
5062	
5063		BEGIN
5064		LABEL BLOCK1;
5065		BIND
5066			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
5067	
5068		LOCAL
5069			DATA;
5070		DO (0) WHILE
5071	BLOCK1:
5072		BEGIN
5073		INIT();					!DO A RESET
5074		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5075		INIT();					!DO A RESET
5076		WRT107(%O'41');				!ASSERT 'R DATA 14 AND 19' IN COM/ADR LOC
5077		WRT106(%O'41');				!ASSERT 'R DATA 14 AND 19' IN DATA LOC
5078		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
5079		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
5080		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
5081		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
5082		WRT110(%O'63');				!WRITE DATA TO 110
5083		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5084		SYNC_CLK();			!STOP CLOCK AND SYNC IT
5085		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
5086		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
5087		DATA = RD_3;				!READ 'R DATA 04-11'
5088		IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
5089		THEN
5090			ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
5091	!*MESSAGE 1
5092	!*STIMULUS:
5093	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
5094	!*	ASSERT AND NEGATE 'RESET'
5095	!*	WRT 107/41	- ASSERT 'R DATA 14 AND 19' IN COM/ADR LOC
5096	!*	WRT 106/41	- ASSERT 'R DATA 14 AND 19' IN DATA LOC
5097	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
5098	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
5099	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
5100	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
5101	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
5102	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5103	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
5104	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
5105	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
5106	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
5107	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
5108	!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 14'
5109	!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
5110	!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
5111	!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
5112	!*			  ONTO THE BUS AND INTO THE RECEIVERS.
5113	!*RESPONSE:
5114	!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
5115	!*	'STATUS RD (1)' IS ASSERTED.
5116	!]ERROR 1
5117	!]STAT_RD NTWK
5118	
5119		IF FLP_CHK(1,FLP_PTR)
5120			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5121		0				!TO PREVENT INFO MSG WHEN COMPILING
5122	
5123		END;
5124	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
5125		INIT();			!DO A RESET
5126		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5127		WRT210(0);
5128		WRT114(0);
5129		WRT115(0);
5130	
5131		END;
5132	
5133	GLOBAL ROUTINE TST43: NOVALUE =
5134	
5135	!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
5136	!ASSERTS WITH 'R DATA 14-17' = 4, 'R DATA 00' ASSERTED AND
5137	!'R DATA 19' NEGATED.
5138	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
5139	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
5140	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
5141	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
5142	
5143		BEGIN
5144		LABEL BLOCK1;
5145		BIND
5146			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
5147	
5148		LOCAL
5149			DATA;
5150		DO (0) WHILE
5151	BLOCK1:
5152		BEGIN
5153		INIT();					!DO A RESET
5154		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5155		INIT();					!DO A RESET
5156		WRT107(%O'21');				!ASSERT 'R DATA 15 AND 19' IN COM/ADR LOC
5157		WRT106(%O'21');				!ASSERT 'R DATA 15 AND 19' IN DATA LOC
5158		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
5159		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
5160		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
5161		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
5162		WRT110(%O'63');				!WRITE DATA TO 110
5163		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5164		SYNC_CLK();			!STOP CLOCK AND SYNC IT
5165		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
5166		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
5167		DATA = RD_3;				!READ 'R DATA 04-11'
5168		IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
5169		THEN
5170			ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
5171	!*MESSAGE 1
5172	!*STIMULUS:
5173	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
5174	!*	ASSERT AND NEGATE 'RESET'
5175	!*	WRT 107/21	- ASSERT 'R DATA 15 AND 19' IN COM/ADR LOC
5176	!*	WRT 106/21	- ASSERT 'R DATA 15 AND 19' IN DATA LOC
5177	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
5178	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
5179	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
5180	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
5181	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
5182	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5183	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
5184	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
5185	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
5186	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
5187	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
5188	!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 15'
5189	!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
5190	!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
5191	!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
5192	!*			  ONTO THE BUS AND INTO THE RECEIVERS.
5193	!*RESPONSE:
5194	!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
5195	!*	'STATUS RD (1)' IS ASSERTED.
5196	!]ERROR 1
5197	!]STAT_RD NTWK
5198	
5199		IF FLP_CHK(1,FLP_PTR)
5200			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5201		0				!TO PREVENT INFO MSG WHEN COMPILING
5202	
5203		END;
5204	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
5205		INIT();			!DO A RESET
5206		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5207		WRT210(0);
5208		WRT114(0);
5209		WRT115(0);
5210	
5211		END;
5212	
5213	GLOBAL ROUTINE TST44: NOVALUE =
5214	
5215	!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
5216	!ASSERTS WITH 'R DATA 14-17' = 2, 'R DATA 00' ASSERTED AND
5217	!'R DATA 19' NEGATED.
5218	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
5219	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
5220	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
5221	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
5222	
5223		BEGIN
5224		LABEL BLOCK1;
5225		BIND
5226			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
5227	
5228		LOCAL
5229			DATA;
5230		DO (0) WHILE
5231	BLOCK1:
5232		BEGIN
5233		INIT();					!DO A RESET
5234		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5235		INIT();					!DO A RESET
5236		WRT107(%O'11');				!ASSERT 'R DATA 16 AND 19' IN COM/ADR LOC
5237		WRT106(%O'11');				!ASSERT 'R DATA 16 AND 19' IN DATA LOC
5238		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
5239		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
5240		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
5241		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
5242		WRT110(%O'63');				!WRITE DATA TO 110
5243		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5244		SYNC_CLK();			!STOP CLOCK AND SYNC IT
5245		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
5246		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
5247		DATA = RD_3;				!READ 'R DATA 04-11'
5248		IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
5249		THEN
5250			ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
5251	!*MESSAGE 1
5252	!*STIMULUS:
5253	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
5254	!*	ASSERT AND NEGATE 'RESET'
5255	!*	WRT 107/11	- ASSERT 'R DATA 16 AND 19' IN COM/ADR LOC
5256	!*	WRT 106/11	- ASSERT 'R DATA 16 AND 19' IN DATA LOC
5257	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
5258	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
5259	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
5260	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
5261	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
5262	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5263	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
5264	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
5265	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
5266	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
5267	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
5268	!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 16'
5269	!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
5270	!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
5271	!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
5272	!*			  ONTO THE BUS AND INTO THE RECEIVERS.
5273	!*RESPONSE:
5274	!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
5275	!*	'STATUS RD (1)' IS ASSERTED.
5276	!]ERROR 1
5277	!]STAT_RD NTWK
5278	
5279		IF FLP_CHK(1,FLP_PTR)
5280			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5281		0				!TO PREVENT INFO MSG WHEN COMPILING
5282	
5283		END;
5284	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
5285		INIT();			!DO A RESET
5286		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5287		WRT210(0);
5288		WRT114(0);
5289		WRT115(0);
5290	
5291		END;
5292	
5293	GLOBAL ROUTINE TST45: NOVALUE =
5294	
5295	!THIS TEST CHECKS THAT 'STATUS RD (1)' DOESN'T ASSERT WHEN 'R COM/ADR'
5296	!ASSERTS WITH 'R DATA 14-17' = 1, 'R DATA 00' ASSERTED AND
5297	!'R DATA 19' NEGATED.
5298	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
5299	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
5300	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
5301	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
5302	
5303		BEGIN
5304		LABEL BLOCK1;
5305		BIND
5306			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
5307	
5308		LOCAL
5309			DATA;
5310		DO (0) WHILE
5311	BLOCK1:
5312		BEGIN
5313		INIT();					!DO A RESET
5314		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5315		INIT();					!DO A RESET
5316		WRT107(5);				!ASSERT 'R DATA 17 AND 19' IN COM/ADR LOC
5317		WRT106(5);				!ASSERT 'R DATA 17 AND 19' IN DATA LOC
5318		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
5319		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
5320		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
5321		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
5322		WRT110(%O'63');				!WRITE DATA TO 110
5323		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5324		SYNC_CLK();			!STOP CLOCK AND SYNC IT
5325		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
5326		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
5327		DATA = RD_3;				!READ 'R DATA 04-11'
5328		IF .DATA EQL %O'63'			!DID DATA GET TRANSMITTED?
5329		THEN
5330			ERRCA(1,0,.DATA,3);	!YES, REPORT ERROR
5331	!*MESSAGE 1
5332	!*STIMULUS:
5333	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS' TO NEGATE 'STATUS RD (1)'
5334	!*	ASSERT AND NEGATE 'RESET'
5335	!*	WRT 107/5	- ASSERT 'R DATA 17 AND 19' IN COM/ADR LOC
5336	!*	WRT 106/5	- ASSERT 'R DATA 17 AND 19' IN DATA LOC
5337	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
5338	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
5339	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
5340	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
5341	!*	WRT 110/63	- PUT TEST DATA IN BUFFER
5342	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5343	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
5344	!*	WRT 210/140	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'
5345	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
5346	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
5347	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
5348	!*			  BUS AND INTO THE RECEIVERS. WITH 'R DATA 17'
5349	!*			  ASSERTED, 'STATUS RD (1)' WILL NOT ASSERT ON
5350	!*			  THE 4TH CYCLE.  SO ON THE 5TH CYCLE THE DATA
5351	!*			  FROM THE DATA LOCS SHOULD NOT GET TRANSMITTED
5352	!*			  ONTO THE BUS AND INTO THE RECEIVERS.
5353	!*RESPONSE:
5354	!*	'R DATA 04-11' IS THE TEST DATA.  THIS IMPLIES THAT
5355	!*	'STATUS RD (1)' IS ASSERTED.
5356	!]ERROR 1
5357	!]STAT_RD NTWK
5358	
5359		IF FLP_CHK(1,FLP_PTR)
5360			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5361		0				!TO PREVENT INFO MSG WHEN COMPILING
5362	
5363		END;
5364	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
5365		INIT();			!DO A RESET
5366		WRT210(CLOSE_LATCH);			!INSURE THAT 'STATUS RD (1)' NEGATES
5367		WRT210(0);
5368		WRT114(0);
5369		WRT115(0);
5370	
5371		END;
5372	
5373	GLOBAL ROUTINE TST46: NOVALUE =
5374	
5375	!THIS TEST CHECKS THAT 'STATUS RD (1)' IS NEGATED BY THE ASSERTION
5376	!OF 'CLOSE LATCHS'. FIRST, 'STATUS RD (1)' IS ASSERTED.
5377	!THE ASSERTION OF 'STATUS RD (1)' IS INFERRED BY THE ASSERTION OF
5378	!'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE ASSERTION OF THESE SIGNALS
5379	!IS INFERRED BY THE TRANSMISSION OF DATA FROM THE 'DATA'
5380	!LOCATIONS IN THE I/O BUFFER MEMORY TO THE RECEIVERS.
5381	!THEN 'CLOSE LATCHS' IS ASSERTED.  THE NEGATION OF 'STATUS RD (1)'
5382	!IS INFERRED BY THE FAILURE TO TRANSMIT DATA FROM I/O BUFFER 114 TO
5383	!'R COM/ADR'.  THAT IS, 'R COM/ADR' NEGATES.
5384	
5385		BEGIN
5386		LABEL BLOCK1;
5387		BIND
5388			FLP_PTR = UPLIT(%ASCIZ'LR210,DR1,LR100,DR200,DR0,LR210,DR140,RP');
5389	
5390		LOCAL
5391			DATA;
5392		DO (0) WHILE
5393	BLOCK1:
5394		BEGIN
5395		INIT();					!DO A RESET
5396		WRT210(CLOSE_LATCH);		!MAKE SURE 'STATUS RD (1)' NEGATES
5397		INIT();					!DO A RESET
5398		WRT107(1);				!ASSERT 'R DATA 19' IN COM/ADR LOC
5399		WRT106(1);				!ASSERT 'R DATA 19' IN DATA LOC
5400		WRT113(%O'10');				!ASSERT 'R DATA 00' IN COM/ADR LOC
5401		WRT112(%O'10');				!ASSERT 'R DATA 00' IN DATA LOC
5402		WRT115(4);				!ASSERT 'R COM/ADR' IN COM/ADR LOC
5403		WRT114(4);				!ASSERT 'R COM/ADR' IN DATA LOC
5404		WRT110(0);				!NEGATE 'R DATA 4-11' IN DATA LOCS
5405		WRT111(0);				!NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5406		SYNC_CLK();			!STOP CLOCK AND SYNC IT
5407		WRT210(BUS_REQ + XMIT_ADR);		!CLOCK SIGNALS IN RECEIVERS
5408		CYCLE(5);			!GENERATE 5 T-CLK/R-CLK CYCLES
5409		WRT210(CLOSE_LATCH);			!ASSERT 'CLOSE LATCHS'
5410		CYCLE(4);			!GENERATE 4 T-CLK/R-CLK CYCLES
5411		IF ( RD_102 AND RCOM_ADR ) NEQ 0	!DID 'STATUS RD (1)' NEGATE,
5412							!CLEARING 'R COM/ADR'?
5413		THEN
5414			ERR(1);		!NO, REPORT ERROR
5415	!*MESSAGE 1
5416	!*STIMULUS:
5417	!*	WRT 210/1	- MAKE SURE 'STATUS RD (1)' IS NEGATED
5418	!*	ASSERT AND NEGATE 'RESET'
5419	!*	WRT 107/1	- ASSERT 'R DATA 19' IN COM/ADR LOC
5420	!*	WRT 106/1	- ASSERT 'R DATA 19' IN DATA LOC
5421	!*	WRT 113/10	- ASSERT 'R DATA 00' IN COM/ADR LOC
5422	!*	WRT 112/10	- ASSERT 'R DATA 00' IN DATA LOC
5423	!*	WRT 115/4	- ASSERT 'R COM/ADR' IN COM/ADR LOC
5424	!*	WRT 114/4	- ASSERT 'R COM/ADR' IN DATA LOC
5425	!*	WRT 110/0	- NEGATE 'R DATA 4-11' IN DATA LOCS
5426	!*	WRT 111/0	- NEGATE 'R DATA 4-11' IN COM/ADR LOCS
5427	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED
5428	!*	WRT 210/120	- ASSERT 'BUS REQ' AND 'XMIT ADR (1)'.
5429	!*	GENERATE 5 T-CLK/R-CLK CYCLES - THE 2ND CYCLE WILL ASSERT
5430	!*			  'T ENB' AND 'T ENB A'. THE 3RD CYCLE WILL
5431	!*			  CLOCK THE DATA FROM THE COM/ADR LOCS ONTO THE
5432	!*			  BUS AND INTO THE RECEIVERS.  THE 4TH CYCLE
5433	!*			  WILL ASSERT 'STATUS RD (1)', WHICH WILL ASSERT
5434	!*			  'T ENB', 'T ENB A' AND 'DATA CYCLE'.  THE 5TH
5435	!*			  CYCLE SHOULD CLOCK THE DATA FROM THE DATA
5436	!*			  LOCS ONTO THE BUS AND INTO THE RECEIVERS.
5437	!*	WRT 210/1	- ASSERT 'CLOSE LATCHS'
5438	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THE 2ND CYCLE ASSERTS FLOP E418
5439	!*			  WHICH SHOULD NEGATE 'STATUS RD (1)'.  THIS
5440	!*			  WILL NEGATE 'T ENB','T ENB A' AND 'DATA CYCLE'
5441	!*			  ON THE 4TH CYCLE ZEROS SHOULD GET CLOCKED ONTO
5442	!*			  THE BUS AND INTO THE RECEIVERS.
5443	!*RESPONSE:
5444	!*	'R COM/ADR' DIDN'T NEGATE.  THIS IMPLIES THAT 'T ENB',
5445	!*	'T ENB A' AND 'DATA CYCLE' DID NOT NEGATE, WHICH IN TURN
5446	!*	IMPLIES THAT 'STATUS RD (1)' DID NOT NEGATE.
5447	!]ERROR 1
5448	!]STAT_RD NTWK
5449	
5450		IF FLP_CHK(1,FLP_PTR)
5451			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5452		0				!TO PREVENT INFO MSG WHEN COMPILING
5453	
5454		END;
5455	!MAKE SURE BUS CONTROL BITS ARE CLEARED IN I/O BUFFERS
5456		INIT();			!DO A RESET
5457		WRT114(0);
5458		WRT115(0);
5459	
5460		END;
5461	
5462	GLOBAL ROUTINE TST47: NOVALUE =
5463	
5464	!THIS TEST CHECKS THAT DATA CAN BE CLOCKED FROM THE CSL BOARD INTO THE
5465	!THE TRANSCEIVERS ON THE CRA BOARD AND THEN READ BACK FROM THE CRA BOARD
5466	!INTO THE CSL BOARD TRANSCEIVERS.
5467	
5468		BEGIN
5469		LABEL BLOCK1;
5470		BIND
5471			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR144,LR205,DR11,LR210,DR115,RP');
5472	
5473		LOCAL
5474			TEMP;
5475	
5476		DO (0) WHILE
5477	BLOCK1:
5478		BEGIN
5479		INIT();					!DO A RESET
5480		WRT103(%O'252');			!PUT DATA INTO I/O BUFFER
5481		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA TRANSCEIVERS
5482		WRT205(%O'11');				!SET DIAG FN TO READ BUS BITS
5483		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !GET DATA FROM CRA BOARD
5484		TEMP = RD_0;				!READ LATCHED DATA
5485		IF  .TEMP NEQ %O'252'		 !DID DATA MAKE THE ROUND TRIP?
5486		THEN
5487			ERRCA(1,%O'252',.TEMP,3); !NO, REPORT ERROR
5488	!*MESSAGE 1
5489	!*STIMULUS:
5490	!*	ASSERT AND NEGATE 'RESET'
5491	!*	WRT 103/252		- SETUP DATA TO BE TRANSMITTED
5492	!*	WRT 210/144		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
5493	!*				  AND 'GRANT (1)'.
5494	!*				- 'GRANT' AND 'XMIT ADR (1)' WILL CAUSE
5495	!*				  THE TEST DATA TO BE GATED ONTO THE
5496	!*				  KS10 BUS.
5497	!*				- 'GRANT (1)' AND 'CRA R CLK' WILL CAUSE
5498	!*				  THE TEST DATA TO BE LATCHED INTO THE
5499	!*				  TRANSCEIVERS ON THE CRA BOARD.
5500	!*	WRT 205/11		- SET DIAG FUNCTION BITS = 11
5501	!*	WRT 210/115		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
5502	!*				- 'GRANT' AND 'CRA T CLK ENB(1)' WILL
5503	!*				  ASSERT 'CRA T CLK ENABLE' WHICH WILL
5504	!*				  GATE THE CRA TRANSCEIVER DATA ONTO THE
5505	!*				  KS10 BUS.
5506	!*				- 'CLOSE LATCHS' WILL LATCH THAT DATA IN
5507	!*				  THE CSL TRANSCEIVERS.
5508	!*RESPONSE:
5509	!*	THE DATA LATCHED IN THE CSL TRANSCEIVERS FOR DATA BITS 28-35
5510	!*	(ER 0) IS NOT WHAT WAS TRANSMITTED.  EITHER 'CRA R CLK #20'
5511	!*	OR 'CRA T CLK ENABLE' DID NOT ASSERT PROPERLY, OR THE DIAG FN
5512	!*	BITS DID NOT GET SET CORRECTLY.
5513	!]ERROR 1
5514	!]CRA_R_CLK T_CLK_EN C_R_C_E C_T_C_E DFN_11 NTWK
5515	
5516		IF FLP_CHK(1,FLP_PTR)
5517			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5518		0				!TO PREVENT INFO MSG WHEN COMPILING
5519		END;
5520		END;
5521	
5522	GLOBAL ROUTINE TST48: NOVALUE =
5523	
5524	!THIS TEST CHECKS THAT 'CRA R CLK\#20\' DOESN'T ASSERT WHEN 'CRA R
5525	!CLK' IS NEGATED.  THIS IS DONE BY WRITING A DATA PATTERN TO THE CRA
5526	!BOARD TRANSCEIVERS, THEN TRYING TO READ IT BACK WITHOUT ASSERTING
5527	!'CRA R CLK'.  ALL ZEROS SHOULD BE READ BACK.
5528		BEGIN
5529		LABEL BLOCK1;
5530		BIND
5531			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR103,DR252,LR210,DR144,LR103,DR125,LR205,DR11,LR210,DR140,DR111,RP');
5532		LOCAL
5533			TEMP;
5534	
5535		DO (0) WHILE
5536	BLOCK1:
5537		BEGIN
5538		INIT();					!DO A RESET
5539		WRT103(%O'252');			!PUT DATA INTO I/O BUFFER
5540		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA TRANSCEIVERS
5541		WRT103(%O'125');
5542		WRT210(BUS_REQ + XMIT_ADR);		!ATTEMPT TO CLOCK DATA WITHOUT 'CRA R CLK'
5543		WRT205(%O'11');				!SET DIAG FN TO READ BUS BITS
5544		WRT210(BUS_REQ + CRA_T_CLK + CLOSE_LATCH);	!READ BACK WITHOUT 'CRA R CLK'
5545		TEMP = RD_0;				!READ LATCHED DATA
5546		IF  .TEMP NEQ %O'252'		 	!DID DATA GET READ BACK?
5547		THEN
5548			ERRCA(1,0,.TEMP,3);	!YES, REPORT ERROR
5549	!*MESSAGE 1
5550	!*STIMULUS:
5551	!*	ASSERT AND NEGATE 'RESET'
5552	!*	WRT 103/252		- SETUP DATA TO BE TRANSMITTED
5553	!*	WRT 210/144		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
5554	!*				  AND 'GRANT (1)'.
5555	!*				- 'GRANT' AND 'XMIT ADR (1)' WILL CAUSE
5556	!*				  THE TEST DATA TO BE GATED ONTO THE
5557	!*				  KS10 BUS.
5558	!*				- 'GRANT (1)' AND 'CRA R CLK' WILL CAUSE
5559	!*				  THE TEST DATA TO BE LATCHED INTO THE
5560	!*				  TRANSCEIVERS ON THE CRA BOARD.
5561	!*	WRT 205/11		- SET DIAG FUNCTION BITS = 11
5562	!*	WRT 210/111		- 'CRA T CLK ENB (1)' AND 'GRANT'
5563	!*				  ASSERT 'CRA T CLK ENABLE'.  WITHOUT
5564	!*				  'CRA R CLK', 'CRA T CLK C' SHOULD NOT
5565	!*				  ASSERT AND ALL ZEROS WILL BE PLACED ON
5566	!*				  THE KS10 BUS.
5567	!*				- 'CLOSE LATCHS' WILL LATCH THAT DATA IN
5568	!*				  THE CSL TRANSCEIVERS.
5569	!*RESPONSE:
5570	!*	THE DATA LATCHED IN THE CSL TRANSCEIVERS FOR DATA BITS 28-35
5571	!*	(ER 0) IS WHAT WAS TRANSMITTED. THIS MEANS THAT 'CRA R CLK #20'
5572	!*	ASSERTED WITHOUT 'CRA R CLK' BEING ASSERTED.
5573	!]ERROR 1
5574	!]C_R_C_E CRA_R_CLK NTWK
5575	
5576		IF FLP_CHK(1,FLP_PTR)
5577			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5578		0				!TO PREVENT INFO MSG WHEN COMPILING
5579		END;
5580		END;
5581	
5582	GLOBAL ROUTINE TST49: NOVALUE =
5583	
5584	!THIS TEST CHECKS THAT THE 'CRA T CLK ENABLE' SIGNAL DOES NOT ASSERT
5585	!WHEN 'GRANT' IS ASSERTED WITHOUT 'CRA T CLK ENB (1)'.
5586	!THIS IS DONE BY CLOCKING DATA TO THE CRA BOARD THEN TRYING TO READ IT
5587	!BACK WITHOUT ASSERTING 'CRA T CLK ENB (1)'.  IF THE DATA GETS READ
5588	!BACK, THEN 'CRA T CLK ENABLE' WAS IMPROPERLY ASSERTED.
5589	
5590		BEGIN
5591		LABEL BLOCK1;
5592		BIND
5593			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR205,DR11,LR210,DR144,DR105,RP');
5594	
5595		LOCAL
5596			TEMP;
5597	
5598		DO (0) WHILE
5599	BLOCK1:
5600		BEGIN
5601		INIT();					!DO A RESET
5602		WRT103(%O'252');			!PUT DATA INTO I/O BUFFER
5603		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA TRANSCEIVERS
5604		WRT205(%O'11');				!SET DIAG FN TO READ BUS BITS
5605		WRT210(BUS_REQ + + CRA_R_CLK + CLOSE_LATCH);	!READ BACK WITHOUT'CRA T CLK ENB (1)'
5606		TEMP = RD_0;				!READ LATCHED DATA
5607		IF  .TEMP EQL %O'252'		 	!DID DATA GET READ BACK?
5608		THEN
5609			ERRCA(1,0,.TEMP,3);	!YES, REPORT ERROR
5610	!*MESSAGE 1
5611	!*STIMULUS:
5612	!*	ASSERT AND NEGATE 'RESET'
5613	!*	WRT 103/252		- SETUP DATA TO BE TRANSMITTED
5614	!*	WRT 210/144		- ASSERTING 'BUS REQ' ASSERTS 'GRANT'
5615	!*				  AND 'GRANT (1)'.
5616	!*				- 'GRANT' AND 'XMIT ADR (1)' WILL CAUSE
5617	!*				  THE TEST DATA TO BE GATED ONTO THE
5618	!*				  KS10 BUS.
5619	!*				- 'GRANT (1)' AND 'CRA R CLK' WILL CAUSE
5620	!*				  THE TEST DATA TO BE LATCHED INTO THE
5621	!*				  TRANSCEIVERS ON THE CRA BOARD.
5622	!*	WRT 205/11		- SET DIAG FUNCTION BITS = 11
5623	!*	WRT 210/105		- 'GRANT' ALONE SHOULD NOT
5624	!*				  NOT ASSERT 'CRA T CLK ENABLE'.  SO ALL
5625	!*				  ZEROS SHOULD BE ON THE KS10 BUS.
5626	!*				- 'CLOSE LATCHS' WILL LATCH THAT DATA IN
5627	!*				  THE CSL TRANSCEIVERS.
5628	!*RESPONSE:
5629	!*	THE DATA LATCHED IN THE CSL TRANSCEIVERS FOR DATA BITS 28-35
5630	!*	(ER 0) IS WHAT WAS TRANSMITTED.  THIS MEANS THAT 'CRA T CLK
5631	!*	ENABLE' GOT ASSERTED WITHOUT 'CRA T CLK ENB (1)' BEING ASSERTED.
5632	!]ERROR 1
5633	!]C_T_C_E T_CLK_EN NTWK
5634		IF FLP_CHK(1,FLP_PTR)
5635			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5636		0				!TO PREVENT INFO MSG WHEN COMPILING
5637		END;
5638		END;
5639	
5640	GLOBAL ROUTINE TST50: NOVALUE =
5641	
5642	!THIS TEST CHECKS THAT DATA CAN BE WRITTEN INTO THE CRAM AND READ BACK.
5643	!THIS REQUIRES CORRECT FUNCTIONING OF THE DIAG FN BITS AND THE 'CRAM
5644	!WRITE' SIGNAL.  OTHER SIGNALS INVOLVED, SUCH AS THE 'SINGLE CLK', ARE
5645	!TESTED BY PREVIOUS TESTS AND ARE ASSUMED TO BE FUNCTIONING CORRECTLY.
5646		BEGIN
5647		LABEL BLOCK1;
5648		BIND
5649			FLP_PTR1 = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR144,LR204,DR40,DR0,LR206,DR2,LR210,DR115,RP');
5650		LOCAL
5651			TEMP;
5652	
5653		DO (0) WHILE
5654	BLOCK1:
5655		BEGIN
5656		INIT();					!DO A RESET
5657		WRT103(%O'125');			!PUT DATA IN I/O BUFFER
5658		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
5659		WRT205(0);				!SET DIAG FN = 0
5660		WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM
5661		WRT204(0);				!NEGATE WRITE SIGNAL
5662		WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
5663		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 0-11
5664		TEMP = RD_0;				!GET BITS 4-11
5665		IF (.TEMP NEQ %O'125')			!DID CRAM GET WRITTEN?
5666		THEN
5667			ERRCA(1,%O'125',.TEMP,3) !NO, REPORT ERROR
5668		ELSE
5669			NOERR(1);		!ELSE, JUST DO ISOLATION
5670	!*MESSAGE 1
5671	!*STIMULUS:
5672	!*	ASSERT AND NEGATE 'RESET'
5673	!*	WRT 103/125		- PUT DATA INTO CSL I/O BUFFER
5674	!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
5675	!*	WRT 205/0		- SET DIAG FN BITS = 0
5676	!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
5677	!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
5678	!*				  CRAM BITS 0-11.
5679	!*	WRT 204/0		- NEGATE 'CRAM WRITE'
5680	!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
5681	!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
5682	!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
5683	!*				  CEIVERS.
5684	!*RESPONSE:
5685	!*	THE RAM DATA READ BACK WAS NOT WHAT SHOULD HAVE BEEN WRITTEN.
5686	!*	THIS MEANS THAT EITHER THE DIAG FN BITS, THE 'CRAM WRITE'
5687	!*	SIGNAL OR THE 'CRA/M RESET' SIGNAL ARE FAULTY.
5688	!]ERROR 1
5689	!]DFN_0 CRM_WRT WRT204 CSLBUF5 NTWK
5690	!]NO ERROR 1
5691	!]DFN_0 CRM_WRT WRT204 NTWK
5692		IF FLP_CHK(1,FLP_PTR1)
5693			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5694		0				!TO PREVENT INFO MSG WHEN COMPILING
5695		END;
5696		END;
5697	
5698	GLOBAL ROUTINE TST51: NOVALUE =
5699	
5700	!THIS TEST CHECKS THAT DATA CAN BE WRITTEN INTO THE CRAM BITS 12-23 AND
5701	!READ BACK.
5702	!THIS REQUIRES CORRECT FUNCTIONING OF THE DIAG FN BITS AND THE 'CRAM
5703	!WRITE' SIGNAL.  OTHER SIGNALS INVOLVED, SUCH AS THE 'SINGLE CLK', ARE
5704	!TESTED BY PREVIOUS TESTS AND ARE ASSUMED TO BE FUNCTIONING CORRECTLY.
5705		BEGIN
5706		LABEL BLOCK1;
5707		BIND
5708			FLP_PTR = UPLIT(%ASCIZ'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR205,DR4,LR210,DR115,RP');
5709	
5710		LOCAL
5711			TEMP;
5712	
5713		DO (0) WHILE
5714	BLOCK1:
5715		BEGIN
5716		MR();					!DO A RESET
5717		WRT103(%O'252');			!PUT DATA IN I/O BUFFER
5718		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
5719		WRT205(1);				!SET DIAG FN = 1
5720		WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM BITS 12-23
5721		WRT204(0);				!NEGATE WRITE SIGNAL
5722		WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
5723		WRT205(4);				!SET DIAG FN = 4
5724		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 12-23
5725		TEMP = RD_0;				!GET BITS 16-23
5726		IF (.TEMP NEQ %O'252')			!DID CRAM GET WRITTEN?
5727		THEN
5728			ERRCA(1,%O'252',.TEMP,3); !NO, REPORT ERROR
5729	!*MESSAGE 1
5730	!*STIMULUS:
5731	!*	ASSERT AND NEGATE 'RESET'
5732	!*	WRT 103/252		- PUT DATA INTO CSL I/O BUFFER
5733	!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
5734	!*	WRT 205/1		- SET DIAG FN BITS = 1
5735	!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
5736	!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
5737	!*				  CRAM BITS 12-23.
5738	!*	WRT 204/0		- NEGATE 'CRAM WRITE'
5739	!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
5740	!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
5741	!*	WRT 205/4		- SET DIAG FN = 4 TO READ BACK CRAM
5742	!*				  BITS 12-23.
5743	!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
5744	!*				  CEIVERS.
5745	!*RESPONSE:
5746	!*	THE RAM DATA READ BACK WAS NOT WHAT SHOULD HAVE BEEN WRITTEN.
5747	!*	THIS MEANS THAT EITHER THE DIAG FN BITS, THE 'CRAM WRITE'
5748	!*	SIGNAL OR THE 'CRA/M RESET' SIGNAL ARE FAULTY.
5749	!]ERROR 1
5750	!]DFN_1 DFN_4 NTWK
5751		IF FLP_CHK(1,FLP_PTR)
5752			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5753		0				!TO PREVENT INFO MSG WHEN COMPILING
5754		END;
5755		END;
5756	
5757	GLOBAL ROUTINE TST52: NOVALUE =
5758	
5759	!THIS TEST CHECKS THAT DATA CAN BE WRITTEN INTO THE CRAM BITS 24-35 AND
5760	!READ BACK.
5761	!THIS REQUIRES CORRECT FUNCTIONING OF THE DIAG FN BITS AND THE 'CRAM
5762	!WRITE' SIGNAL.  OTHER SIGNALS INVOLVED, SUCH AS THE 'SINGLE CLK', ARE
5763	!TESTED BY PREVIOUS TESTS AND ARE ASSUMED TO BE FUNCTIONING CORRECTLY.
5764	
5765		BEGIN
5766		LABEL BLOCK1;
5767		BIND
5768			FLP_PTR = UPLIT(%ASCIZ'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR205,DR5,LR210,DR115,RP');
5769		LOCAL
5770			TEMP;
5771	
5772		DO (0) WHILE
5773	BLOCK1:
5774		BEGIN
5775		MR();					!DO A RESET
5776		WRT103(%O'125');			!PUT DATA IN I/O BUFFER
5777		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
5778		WRT205(2);				!SET DIAG FN = 2
5779		WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM BITS 24-35
5780		WRT204(0);				!NEGATE WRITE SIGNAL
5781		WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
5782		WRT205(5);				!SET DIAG FN = 5
5783		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 24-35
5784		TEMP = RD_0;				!GET BITS 28-35
5785		IF (.TEMP NEQ %O'125')			!DID CRAM GET WRITTEN?
5786		THEN
5787			ERRCA(1,%O'125',.TEMP,3); !NO, REPORT ERROR
5788	!*MESSAGE 1
5789	!*STIMULUS:
5790	!*	ASSERT AND NEGATE 'RESET'
5791	!*	WRT 103/125		- PUT DATA INTO CSL I/O BUFFER
5792	!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
5793	!*	WRT 205/2		- SET DIAG FN BITS = 2
5794	!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
5795	!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
5796	!*				  CRAM BITS 24-35.
5797	!*	WRT 204/0		- NEGATE 'CRAM WRITE'
5798	!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
5799	!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
5800	!*	WRT 205/5		- SET DIAG FN = 5 TO READ BACK CRAM
5801	!*				  BITS 24-35.
5802	!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
5803	!*				  CEIVERS.
5804	!*RESPONSE:
5805	!*	THE RAM DATA READ BACK WAS NOT WHAT SHOULD HAVE BEEN WRITTEN.
5806	!*	THIS MEANS THAT EITHER THE DIAG FN BITS, THE 'CRAM WRITE'
5807	!*	SIGNAL OR THE 'CRA/M RESET' SIGNAL ARE FAULTY.
5808	!]ERROR 1
5809	!]DFN_2 DFN_5 NTWK
5810		IF FLP_CHK(1,FLP_PTR)
5811			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5812		0				!TO PREVENT INFO MSG WHEN COMPILING
5813		END;
5814		END;
5815	
5816	GLOBAL ROUTINE TST53: NOVALUE =
5817	
5818	!THIS TEST CHECK THAT THE 'CRA/M RESET' SIGNAL CAN BE ASSERTED
5819	!CORRECTLY.
5820	!THIS IS DONE BY LATCHING ALL ONES INTO CRAM BITS 4-11, ASSERTING
5821	!'CRA/M RESET', THEN READING THOSE BITS FOR ZERO.
5822	
5823		BEGIN
5824		LABEL BLOCK1;
5825		BIND
5826			FLP_PTR = UPLIT(%ASCIZ'LR204,DR1,DR0,RP');
5827		LOCAL
5828			TEMP;
5829	
5830		DO (0) WHILE
5831	BLOCK1:
5832		BEGIN
5833		MR();					!DO A RESET
5834		WRT103(%O'777');			!PUT DATA IN I/O BUFFER
5835		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
5836		WRT205(0);				!SET DIAG FN = 0
5837		WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM BITS 4-11
5838		WRT204(0);				!NEGATE WRITE SIGNAL
5839		WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
5840		WRT204(CRAM_RESET);			!ASSERT 'CRA/M RESET'
5841		WRT204(0);				!NEGATE IT
5842		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 0-11
5843		TEMP = RD_0;				!GET BITS 4-11
5844		IF (.TEMP NEQ 0)			!DID CRAM GET CLEARED?
5845		THEN
5846			ERRCA(1,0,.TEMP,3); !NO, REPORT ERROR
5847	!*MESSAGE 1
5848	!*STIMULUS:
5849	!*	ASSERT AND NEGATE 'RESET'
5850	!*	WRT 103/777		- PUT DATA INTO CSL I/O BUFFER
5851	!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
5852	!*	WRT 205/0		- SET DIAG FN BITS = 0
5853	!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
5854	!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
5855	!*				  CRAM BITS 0-11.
5856	!*	WRT 204/0		- NEGATE 'CRAM WRITE'
5857	!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
5858	!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
5859	!*	WRT 204/1		- ASSERT 'CRA/M RESET'. THIS SHOULD
5860	!*				  CLEAR ALL LATCHED CRAM BITS.
5861	!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
5862	!*				  CEIVERS.
5863	!*RESPONSE:
5864	!*	THE RAM DATA READ BACK WAS NOT ZEROS.  THIS MEANS THAT THE
5865	!*	'CRA/M RESET' SIGNAL DID NOT GET ASSERTED.
5866	!]ERROR 1
5867	!]CRM_RESET WRT204 NTWK
5868	
5869		IF FLP_CHK(1,FLP_PTR)
5870			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5871		0				!TO PREVENT INFO MSG WHEN COMPILING
5872		END;
5873		END;
5874	
5875	GLOBAL ROUTINE TST54: NOVALUE =
5876	
5877	!THIS TEST CHECKS THAT THE 'CRAM WRITE' SIGNAL IS NOT STUCK ASSERTED.
5878	!THIS IS DONE BY WRITING A '125' INTO CRAM BITS 4-11 BY ASSERTING
5879	!'CRAM WRITE', THEN CLOCKING A '252' INTO THE BUS BUFFER ON THE CRA
5880	!BOARD (IF 'CRAM WRITE' IS STUCK ASSERTED, THIS NEW DATA WILL BE
5881	!WRITTEN INTO BITS 4-11). CRAM BITS 4-11 ARE THEN READ BACK AND CHECKED
5882	!THAT IT IS '125'.
5883		BEGIN
5884		LABEL BLOCK1;
5885		BIND
5886			FLP_PTR = UPLIT(%ASCIZ'LR204,DR40,DR0,RP');
5887		LOCAL
5888			TEMP;
5889	
5890		DO (0) WHILE
5891	BLOCK1:
5892		BEGIN
5893		INIT();					!DO A RESET
5894		WRT103(%O'125');			!PUT DATA IN I/O BUFFER
5895		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
5896		WRT205(0);				!SET DIAG FN = 0
5897		WRT204(CRAM_WRT);			!WRITE DATA INTO CRAM
5898		WRT204(0);				!NEGATE WRITE SIGNAL
5899		WRT103(%O'252');			!PUT NEW DATA INTO I/O BUFFER
5900		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
5901		WRT206(SINGLE_CLK);			!LATCH CRAM DATA ON CRA BOARD
5902		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ CRAM BITS 0-11
5903		TEMP = RD_0;				!GET BITS 4-11
5904		IF (.TEMP EQL %O'252')			!DID CRAM BITS CHANGE?
5905		THEN
5906			ERRCA(1,%O'125',.TEMP,3); !YES
5907	!*MESSAGE 1
5908	!*STIMULUS:
5909	!*	ASSERT AND NEGATE 'RESET'
5910	!*	WRT 103/125		- PUT DATA INTO CSL I/O BUFFER
5911	!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
5912	!*	WRT 205/0		- SET DIAG FN BITS = 0
5913	!*	WRT 204/40		- ASSERT 'CRAM WRITE'. THIS SHOULD
5914	!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
5915	!*				  CRAM BITS 0-11.
5916	!*	WRT 204/0		- NEGATE 'CRAM WRITE'
5917	!*	WRT 103/252		- PUT DATA INTO CSL I/O BUFFER
5918	!*	WRT 210/144		- CLOCK DATA INTO CRA BUS BUFFER
5919	!*	WRT 206/2		- ASSERT 'SINGLE CLK (1)'. THIS SHOULD
5920	!*				  CLOCK THE RAM DATA INTO CRA LATCHES.
5921	!*	WRT 210/115		- CLOCK THE RAM DATA INTO THE CSL TRANS-
5922	!*				  CEIVERS.
5923	!*RESPONSE:
5924	!*	THE CRAM BITS 4-11 GOT CHANGED FROM '125' TO '252' WITHOUT
5925	!*	ASSERTING 'CRAM WRITE'.  THIS MEANS THAT 'CRAM WRITE' MUST BE
5926	!*	STUCK ASSERTED.
5927	!]ERROR 1
5928	!]CRM_WRT NTWK
5929		IF FLP_CHK(1,FLP_PTR)
5930			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5931		0				!TO PREVENT INFO MSG WHEN COMPILING
5932		END;
5933		END;
5934	
5935	GLOBAL ROUTINE TST55: NOVALUE =
5936	
5937	!THIS TEST CHECKS THAT THE 'CRAM ADR LOAD' SIGNAL WORKS CORRECTLY.
5938	!THIS IS DONE BY WRITING ALL ONES TO THE CRA BUS BUFFER, ASSERTING
5939	!'CRAM ADR LOAD', THEN READING BACK THAT ADDRESS THROUGH THE NEXT
5940	!CRAM ADDRESS.
5941	
5942		BEGIN
5943		LABEL BLOCK1;
5944		BIND
5945			FLP_PTR = UPLIT(%ASCIZ'LR204,DR20,DR0,RP');
5946		LOCAL
5947			TEMP;
5948	
5949		DO (0) WHILE
5950	BLOCK1:
5951		BEGIN
5952		INIT();					!DO A RESET
5953		RESET_CRAM();				!RESET CRAM BITS
5954		WRT103(%O'377');			!PUT DATA IN I/O BUFFER
5955		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
5956		WRT204(CRAM_ADR_LD);			!LOAD DATA INTO DIAG ADDR
5957		WRT204(0);				!NEGATE LOAD SIGNAL
5958		WRT205(1);				!SET DIAG FN = 1
5959		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ NEXT CRAM ADDR
5960		TEMP = RD_0;				!GET BITS 4-11
5961		IF (.TEMP EQL %O'377')			!DID DIAG ADDR GET LOADED?
5962			THEN NOERR(1)			!YES
5963			ELSE ERRCA(1,%O'377',.TEMP,3); !NO
5964	!*MESSAGE 1
5965	!*STIMULUS:
5966	!*	ASSERT AND NEGATE 'RESET'
5967	!*	ASSERT AND NEGATE 'CRA/M RESET'
5968	!*	WRT 103/377		- PUT DATA INTO CSL I/O BUFFER
5969	!*	WRT 210/144		- CLOCK DATA INTO CRA BOARD TRANSCEIVERS
5970	!*	WRT 204/20		- ASSERT 'CRAM ADR LOAD'. THIS SHOULD
5971	!*				  CAUSE THE DATA TO BE WRITTEN INTO THE
5972	!*				  'DIAG ADDR' BITS.
5973	!*	WRT 204/0		- NEGATE 'CRAM ADR LOAD'
5974	!*	WRT 205/1		- SET DIAG FN BITS = 1. THIS SELECT THE
5975	!*				  NEXT CRAM ADDRESS TO BE READ.
5976	!*	WRT 210/115		- CLOCK THE ADDRESS INTO THE CSL TRANS-
5977	!*				  CEIVERS.
5978	!*RESPONSE:
5979	!*	THE NEXT CRAM ADDRESS BITS 4-11 WERE NOT READ BACK AS ALL ONES.
5980	!*	THIS MEANS THAT THE 'CRAM ADR LOAD' SIGNAL IS FAULTY.
5981	!]ERROR 1
5982	!]CRM_ADR_LD DFN_1 NTWK
5983	!]NO ERROR 1
5984	!]CRM_ADR_LD DFN_1 NTWK
5985	
5986		IF FLP_CHK(1,FLP_PTR)
5987			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5988		0				!TO PREVENT INFO MSG WHEN COMPILING
5989		END;
5990	
5991		END;
5992	
5993	GLOBAL ROUTINE TST56: NOVALUE =
5994	
5995	!THIS TEST CHECKS THAT THE 'RESET L' SIGNAL CLEARS THE 'CRAM ADR LOAD'
5996	!SIGNAL.
5997	!THIS IS DONE BY WRITING ALL ONES TO THE CRA BUS BUFFER, ASSERTING
5998	!'CRAM ADR LOAD', WRITING ALL ZEROS TO THE CRA BUS BUFFER, TOGGLING 
5999	!'RESET L', ASSERTING AND NEGATING 'CRAM ADR LOAD', THEN READING BACK
6000	!THE NEXT CRAM ADDRESS.  IF 'RESET L' DOES NOT CLEAR 'CRAM ADR LOAD',
6001	!THEN THE SECOND ASSERTION OF 'CRAM ADR LOAD' WILL NOT DO ANYTHING,
6002	!I.E., THE ZERO DATA WILL NOT GET LOADED INTO THE NEXT CRAM ADDRESS.
6003	
6004		BEGIN
6005		LABEL BLOCK1;
6006		BIND
6007			FLP_PTR = UPLIT(%ASCIZ'LR204,DR20,LR100,DR200,DR0,RP');
6008	
6009		LOCAL
6010			TEMP;
6011	
6012		DO (0) WHILE
6013	BLOCK1:
6014		BEGIN
6015		INIT();					!DO A RESET
6016		RESET_CRAM();				!RESET CRAM BITS
6017		WRT103(%O'777');			!PUT DATA IN I/O BUFFER
6018		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
6019		WRT204(CRAM_ADR_LD);			!LOAD DATA INTO DIAG ADDR
6020		WRT103(0);				!PUT DATA IN I/O BUFFER
6021		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA TO CRA BOARD
6022		INIT();					!TOGGLE 'RESET L'
6023		WRT204(CRAM_ADR_LD);			!LOAD DATA INTO DIAG ADDR
6024		WRT204(0);				!NEGATE LOAD SIGNAL
6025		WRT205(1);				!SET DIAG FN = 1
6026		WRT210(BUS_REQ + CRA_T_CLK + + CRA_R_CLK + CLOSE_LATCH); !READ NEXT CRAM ADDR
6027		TEMP = RD_0;				!GET BITS 4-11
6028		IF .TEMP NEQ 0			!DID DIAG ADDR GET ZEROED?
6029		THEN
6030			ERRCA(1,0,.TEMP,3); !NO
6031	!*MESSAGE 1
6032	!*STIMULUS:
6033	!*	ASSERT AND NEGATE 'RESET'
6034	!*	ASSERT AND NEGATE 'CRA/M RESET'
6035	!*	WRT 103/777		- PUT ONES INTO CSL I/O BUFFER
6036	!*	WRT 210/144		- CLOCK ONES INTO CRA BOARD TRANSCEIVERS
6037	!*	WRT 204/20		- ASSERT 'CRAM ADR LOAD'. THIS SHOULD
6038	!*				  CAUSE ONES TO BE WRITTEN INTO THE
6039	!*				  'DIAG ADDR' BITS.
6040	!*	WRT 103/0		- PUT ZEROES INTO CSL I/O BUFFER
6041	!*	WRT 210/144		- CLOCK ZEROES TO CRA BOARD TRANSCEIVERS
6042	!*	ASSERT AND NEGATE 'RESET'
6043	!*	WRT 204/20		- ASSERT 'CRAM ADR LOAD'. THIS SHOULD
6044	!*				  CAUSE ZEROES TO BE WRITTEN INTO THE
6045	!*				  'DIAG ADDR' BITS.
6046	!*	WRT 204/0		- NEGATE 'CRAM ADR LOAD'
6047	!*	WRT 205/1		- SET DIAG FN BITS = 1. THIS SELECT THE
6048	!*				  NEXT CRAM ADDRESS TO BE READ.
6049	!*	WRT 210/115		- CLOCK THE ADDRESS INTO THE CSL TRANS-
6050	!*				  CEIVERS.
6051	!*RESPONSE:
6052	!*	THE NEXT CRAM ADDRESS BITS 4-11 WERE NOT READ BACK AS ZEROES.
6053	!*	THIS MEANS THAT THE 'CRAM ADR LOAD' SIGNAL DID NOT GET CLEARED
6054	!*	BY THE 'RESET L' SIGNAL.
6055	!]ERROR 1
6056	!]REG204 NTWK
6057	
6058		IF FLP_CHK(1,FLP_PTR)
6059			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6060		0				!TO PREVENT INFO MSG WHEN COMPILING
6061		END;
6062	
6063		END;
6064	
6065	GLOBAL ROUTINE TST57: NOVALUE =
6066	
6067	!THIS TEST CHECKS THAT 'HALT LOOP' ASSERTS WHEN 'CRM2 # 15B' AND
6068	!'CPM CMD LD' ARE ASSERTED.
6069	
6070	
6071		BEGIN
6072		LABEL BLOCK1;
6073		LOCAL
6074			ERFLG;
6075		BIND
6076			UC_PTR = PLIT(U_SPEC_N U_N(4) U);
6077	
6078		ERFLG = 0;		!INIT ERROR FLAG
6079		INIT();			!DO A RESET
6080		LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
6081		DO (0) WHILE
6082	BLOCK1:
6083		BEGIN
6084		SET_C(0);				!SET CRAM START ADDR TO ZERO
6085		INIT();					!DO A RESET
6086		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6087		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
6088		SEND_NUL();
6089		CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
6090		IF ( RD_300 AND HALT_LOOP) EQL 0	!DID 'HALT LOOP' ASSERT?
6091		THEN
6092			BEGIN
6093			ERR(1);		!NO, REPORT ERROR
6094			ERFLG = -1;	!SET ERROR FLAG
6095			END;
6096	!*MESSAGE 1
6097	!*STIMULUS:
6098	!*	ASSERT AND NEGATE 'RESET'
6099	!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELD TO '10'
6100	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
6101	!*			  INTO THEIR LATCHES.
6102	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
6103	!*			  'CRAM CLK' AND 'SPEC' ASSERT 'CPM CMD LD'.
6104	!*			  'CPM CMD LD' AND 'CRM2 # 15B' SHOULD ASSERT
6105	!*			  'HALT LOOP'.
6106	!*RESPONSE:
6107	!*	'HALT LOOP' DID NOT ASSERT.
6108	!]ERROR 1
6109	!]HLT_LP CMD_LD CRAM_CLK HALT_LOOP NTWK
6110		IF LOOP_CHK(1)
6111			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6112	
6113		RESET_CRAM();				!RESET CRAM BITS
6114		INIT();					!DO A RESET
6115		IF ( RD_300 AND HALT_LOOP) NEQ 0	!DID 'HALT LOOP' NEGATE?
6116		THEN
6117			BEGIN
6118			ERR(2);		!NO, REPORT ERROR
6119			ERFLG = -1;	!SET ERROR FLAG
6120			END;
6121	!*MESSAGE 2
6122	!*STIMULUS:
6123	!*	ASSERT AND NEGATE 'RESET'
6124	!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELD TO '10'
6125	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
6126	!*			  INTO THEIR LATCHES.
6127	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
6128	!*			  'CRAM CLK' AND 'SPEC' ASSERT 'CPM CMD LD'.
6129	!*			  'CPM CMD LD' AND 'CRM2 # 15B' SHOULD ASSERT
6130	!*			  'HALT LOOP'.
6131	!*	RESET CRAM BITS
6132	!*	ASSERT AND NEGATE RESET	- THIS SHOULD NEGATE 'HALT LOOP'
6133	!*RESPONSE:
6134	!*	'HALT LOOP' DID NOT NEGATE WHEN 'RESET' WAS TOGGLED.
6135	!]ERROR 2
6136	!]HLT_LP HALT_LOOP NTWK
6137		IF LOOP_CHK(2)
6138			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6139		0				!TO PREVENT INFO MSG WHEN COMPILING
6140		END;
6141	
6142	!IF WE HAD NO ERRORS DO SOME FAULT ISOLATION
6143	
6144		IF .ERFLG EQL 0
6145		THEN
6146			NOERR(1);
6147	!]NO ERROR 1
6148	!]HALT_LOOP NTWK
6149	
6150		CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0
6151	
6152		END;
6153	
6154	GLOBAL ROUTINE TST58: NOVALUE =
6155	
6156	!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T ASSERT WHEN 'CRM2 #
6157	!15B' IS ASSERTED BUT 'CRA2 SPEC/CONSOLE' IS NEGATED.
6158	
6159		BEGIN
6160		LABEL BLOCK1;
6161		BIND
6162			UC_PTR = PLIT( U_N(4) U);
6163	
6164		INIT();			!DO A RESET
6165		LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
6166		DO (0) WHILE
6167	BLOCK1:
6168		BEGIN
6169		SET_C(0);				!SET CRAM START ADDR TO ZERO
6170		INIT();					!DO A RESET
6171		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6172		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
6173		SEND_NUL();
6174		CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
6175		IF ( RD_300 AND HALT_LOOP) NEQ 0	!IS 'HALT LOOP' NEGATED?
6176		THEN
6177			ERR(1);		!NO, REPORT ERROR
6178	!*MESSAGE 1
6179	!*STIMULUS:
6180	!*	ASSERT AND NEGATE 'RESET'
6181	!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO DEFAULT
6182	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
6183	!*			  INTO THEIR LATCHES.
6184	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
6185	!*			  WITH 'CRA2 SPEC/CONSOLE' NEGATED, 'CPM CMD LD'
6186	!*			  SHOULD NOT ASSERT. SO, 'HALT LOOP (1)' SHOULD
6187	!*			  NOT ASSERT.
6188	!*RESPONSE:
6189	!*	'HALT LOOP' ASSERTED.
6190	!]ERROR 1
6191	!]HLT_LP CMD_LD NTWK
6192		IF LOOP_CHK(1)
6193			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6194		0				!TO PREVENT INFO MSG WHEN COMPILING
6195	
6196		END;
6197		CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0
6198	
6199		END;
6200	
6201	GLOBAL ROUTINE TST59: NOVALUE =
6202	
6203	!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T ASSERT WHEN 'CRM2 #
6204	!15B' IS NEGATED WITH 'CRA2 SPEC/CONSOLE' ASSERTED.
6205	
6206		BEGIN
6207		LABEL BLOCK1;
6208		BIND
6209			UC_PTR = PLIT(U_SPEC_N U_N(0) U);
6210	
6211		INIT();			!DO A RESET
6212		LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
6213		DO (0) WHILE
6214	BLOCK1:
6215		BEGIN
6216		SET_C(0);				!SET CRAM START ADDR TO ZERO
6217		INIT();					!DO A RESET
6218		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6219		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
6220		SEND_NUL();
6221		CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
6222		IF ( RD_300 AND HALT_LOOP) NEQ 0	!IS 'HALT LOOP' NEGATED?
6223		THEN
6224			ERR(1);		!NO, REPORT ERROR
6225	!*MESSAGE 1
6226	!*STIMULUS:
6227	!*	ASSERT AND NEGATE 'RESET'
6228	!*	NEGATE CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
6229	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM BITS
6230	!*			  INTO THEIR LATCHES.
6231	!*	WRT 206/2	- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM CLK'.
6232	!*			  WITH 'CRA2 SPEC/CONSOLE' ASSERTED,'CPM CMD LD'
6233	!*			  ASSERT. BUT WITH 'CRM2 # 15B' NEGATED,
6234	!*			  'HALT LOOP (1)' SHOULD NOT ASSERT.
6235	!*RESPONSE:
6236	!*	'HALT LOOP' ASSERTED.
6237	!]ERROR 1
6238	!]HLT_LP NTWK
6239		IF LOOP_CHK(1)
6240			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6241		0				!TO PREVENT INFO MSG WHEN COMPILING
6242	
6243		END;
6244		CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0
6245	
6246		END;
6247	
6248	GLOBAL ROUTINE TST60: NOVALUE =
6249	
6250	!THIS TEST CHECKS THAT 'HALT LOOP (1)' NEGATES WHEN 'CRM2 # 16B'
6251	!AND 'CRA2 SPEC/CONSOLE' ARE ASSERTED WHEN 'CRAM CLK' ASSERTS.
6252	
6253		BEGIN
6254		LABEL BLOCK1;
6255		BIND
6256			UC_PTR = PLIT( U_J(1) U_SPEC_N U_N(4) U,
6257					U_SPEC_N U_N(2) U);
6258	
6259		INIT();			!DO A RESET
6260		LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
6261		DO (0) WHILE
6262	BLOCK1:
6263		BEGIN
6264		SET_C(0);				!SET NEXT ADDRESS TO 0
6265		INIT();					!DO A RESET
6266		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6267		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO SET 'HALT LOOP'
6268		SEND_NUL();
6269		CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
6270		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO CLEAR 'HALT LOOP'
6271		IF ( RD_300 AND HALT_LOOP) NEQ 0	!IS 'HALT LOOP' NEGATED?
6272		THEN
6273			ERR(1);		!NO, REPORT ERROR
6274	!*MESSAGE 1
6275	!*STIMULUS:
6276	!*	ASSERT AND NEGATE 'RESET'
6277	!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
6278	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6279	!*				  BITS INTO THEIR LATCHES.
6280	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CAUSES 'HALT
6281	!*				  LOOP (1)' TO ASSERT.
6282	!*	SET 'CRM2 # 16B' AND CLEAR 'CRM2 # 15B' AND SET 'SPEC' TO '10'
6283	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM
6284	!*				  CLK' AND CLOCK CRAM BITS INTO CONTROL
6285	!*				  FLOPS ON CRA BOARD.  WITH 'CRA2 SPEC/
6286	!*				  CONSOLE' ASSERTED, 'CPM CMD LD' SHOULD
6287	!*				  ASSERT. BUT WITH 'CRM2 # 15B' NEGATED
6288	!*				  AND 'CRM2 # 16B' ASSERTED, 'HALT LOOP
6289	!*				  (1)' SHOULD NEGATE.
6290	!*RESPONSE:
6291	!*	'HALT LOOP' IS ASSERTED.
6292	!]ERROR 1
6293	!]HLT_LP CMD_LD CRAM_CLK NTWK
6294	
6295		IF LOOP_CHK(1)
6296			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6297		0				!TO PREVENT INFO MSG WHEN COMPILING
6298		END;
6299		CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0
6300	
6301		END;
6302	
6303	GLOBAL ROUTINE TST61: NOVALUE =
6304	
6305	!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T NEGATE WHEN 'CRM2 # 16B'
6306	!IS NEGATED AND 'CRA2 SPEC/CONSOLE' IS ASSERTED.
6307	
6308		BEGIN
6309		LABEL BLOCK1;
6310		BIND
6311			UC_PTR = PLIT( U_J(1) U_SPEC_N U_N(4) U,
6312					U_SPEC_N U_N(0) U);
6313	
6314		INIT();			!DO A RESET
6315		LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
6316		DO (0) WHILE
6317	BLOCK1:
6318		BEGIN
6319		SET_C(0);				!SET NEXT ADDRESS TO 0
6320		INIT();					!DO A RESET
6321		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6322		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO SET 'HALT LOOP'
6323		SEND_NUL();
6324		CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
6325		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
6326		IF ( RD_300 AND HALT_LOOP) EQL 0	!IS 'HALT LOOP' ASSERTED?
6327		THEN
6328			ERR(1);		!NO, REPORT ERROR
6329	!*MESSAGE 1
6330	!*STIMULUS:
6331	!*	ASSERT AND NEGATE 'RESET'
6332	!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
6333	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6334	!*				  BITS INTO THEIR LATCHES.
6335	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CAUSES 'HALT
6336	!*				  LOOP (1)' TO ASSERT.
6337	!*	CLEAR 'CRM2 # 16B' AND 'CRM2 # 15B' AND SET 'SPEC' TO '10'
6338	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM
6339	!*				  CLK' AND CLOCK CRAM BITS INTO CONTROL
6340	!*				  FLOPS ON CRA BOARD.  WITH 'CRA2 SPEC/
6341	!*				  CONSOLE' ASSERTED, 'CPM CMD LD' SHOULD
6342	!*				  ASSERT. BUT WITH 'CRM2 # 16B' NEGATED,
6343	!*				  'HALT LOOP (1)' SHOULD NOT NEGATE.
6344	!*RESPONSE:
6345	!*	'HALT LOOP' NEGATED.
6346	!]ERROR 1
6347	!]HLT_LP NTWK
6348	
6349		IF LOOP_CHK(1)
6350		THEN
6351			LEAVE BLOCK1 WITH 1;
6352		0				!TO PREVENT INFO MSG WHEN COMPILING
6353		END;
6354		CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0
6355	
6356		END;
6357	
6358	GLOBAL ROUTINE TST62: NOVALUE =
6359	
6360	!THIS TEST CHECKS THAT 'HALT LOOP (1)' DOESN'T NEGATE WHEN 'CRM2 # 16B'
6361	!IS ASSERTED BUT 'CRA2 SPEC/CONSOLE' IS NEGATED.
6362	
6363		BEGIN
6364		LABEL BLOCK1;
6365		BIND
6366			UC_PTR = PLIT( U_J(1) U_SPEC_N U_N(4) U,
6367					 U_N(2) U);
6368	
6369		INIT();			!DO A RESET
6370		LOAD_U(0,UC_PTR);			!LOAD UCODE INTO CRAM
6371		DO (0) WHILE
6372	BLOCK1:
6373		BEGIN
6374		SET_C(0);				!SET NEXT ADDRESS TO 0
6375		INIT();					!DO A RESET
6376		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6377		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK' TO SET 'HALT LOOP'
6378		SEND_NUL();
6379		CHK_ERR_MSG(HALTED);			!CHECK FOR 'HLTD' MESSAGE
6380		WRT206(SINGLE_CLK);			!ASSERT 'CRAM CLK'
6381		IF ( RD_300 AND HALT_LOOP) EQL 0	!IS 'HALT LOOP' ASSERTED?
6382		THEN
6383			ERR(1);		!NO, REPORT ERROR
6384	!*MESSAGE 1
6385	!*STIMULUS:
6386	!*	ASSERT AND NEGATE 'RESET'
6387	!*	SET CRAM BIT 'CRM2 # 15B' AND SET 'SPEC' FIELDS TO '10'
6388	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6389	!*				  BITS INTO THEIR LATCHES.
6390	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CAUSES 'HALT
6391	!*				  LOOP (1)' TO ASSERT.
6392	!*	SET 'CRM2 # 16B' AND CLEAR 'CRM2 # 15B' AND SET 'SPEC' TO '70'
6393	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' ASSERTS 'CRAM
6394	!*				  CLK' AND CLOCK CRAM BITS INTO CONTROL
6395	!*				  FLOPS ON CRA BOARD.  WITH 'CRA2 SPEC/
6396	!*				  CONSOLE' NEGATED, 'CPM CMD LD' SHOULD
6397	!*				  NOT ASSERT. THEREFORE, 'HALT LOOP (1)'
6398	!*				  SHOULD NOT NEGATE.
6399	!*RESPONSE:
6400	!*	'HALT LOOP' NEGATED.
6401	!]ERROR 1
6402	!]HLT_LP CMD_LD NTWK
6403	
6404		IF LOOP_CHK(1)
6405		THEN
6406			LEAVE BLOCK1 WITH 1;
6407		0				!TO PREVENT INFO MSG WHEN COMPILING
6408		END;
6409		CLEAR_CRAM();				!CLEAR CRAM BITS IN LOC 0
6410	
6411		END;
6412	
6413	GLOBAL ROUTINE TST63: NOVALUE =
6414	
6415	!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE'
6416	!CONTROL FLOPS CAN BE ASSERTED.  THIS IS DONE BY ASSERTING THE FIRST
6417	!STAGE FLOPS THEN GENERATING A SINGLE CLOCK PULSE TO TOGGLE 'ENABLE (0)'
6418	!THEN A 'RESET' IS DONE TO CHECK THAT THE CONTROL FLOPS GET NEGATED.
6419		BEGIN
6420		LABEL BLOCK1;
6421		BIND
6422			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,RP');
6423		LOCAL
6424			RUN_ERFLG,
6425			EXE_ERFLG,
6426			CON_ERFLG,
6427			TEMP;
6428	
6429		RUN_ERFLG = EXE_ERFLG = CON_ERFLG = 0;	!INIT ERROR FLAG
6430		DO (0) WHILE
6431	BLOCK1:
6432		BEGIN
6433		INIT();					!DO A RESET
6434		RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
6435		WRT212(7);				!ASSERT 1ST STAGE FLOPS
6436		WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
6437		TEMP = RD_300;			!READ STATES OF FLOPS
6438		IF (.TEMP AND RUN_1 ) EQL 0		!DID 'RUN (1)' ASSERT?
6439		THEN
6440			BEGIN
6441			ERR(1);		!NO, REPORT ERROR
6442			RUN_ERFLG = -1;		!SET ERROR FLAG
6443			END;
6444	!*MESSAGE 1
6445	!*STIMULUS:
6446	!*	ASSERT AND NEGATE 'RESET'
6447	!*	ASSERT AND NEGATE 'CRA/M RESET'
6448	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6449	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6450	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6451	!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
6452	!*RESPONSE:
6453	!*	'RUN (1)' DID NOT ASSERT.
6454	!]ERROR 1
6455	!]WRT212 RUN_1 RUN NTWK
6456		IF FLP_CHK(1,FLP_PTR)
6457			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6458	
6459		IF (.TEMP AND EXECUTE_B ) EQL 0		!DID 'EXECUTE B' ASSERT?
6460		THEN
6461			BEGIN
6462			ERR(2);		!NO, REPORT ERROR
6463			EXE_ERFLG = -1;		!SET ERROR FLAG
6464			END;
6465	!*MESSAGE 2
6466	!*STIMULUS:
6467	!*	ASSERT AND NEGATE 'RESET'
6468	!*	ASSERT AND NEGATE 'CRA/M RESET'
6469	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6470	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6471	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6472	!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
6473	!*RESPONSE:
6474	!*	'EXECUTE B' DID NOT ASSERT.
6475	!]ERROR 2
6476	!]WRT212 EXEC_B EXEC NTWK
6477		IF FLP_CHK(2,FLP_PTR)
6478			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6479	
6480		IF (.TEMP AND CONTINUE_H ) EQL 0		!DID 'CONTINUE' ASSERT?
6481		THEN
6482			BEGIN
6483			ERR(3);		!NO, REPORT ERROR
6484			CON_ERFLG = -1;		!SET ERROR FLAG
6485			END;
6486	!*MESSAGE 3
6487	!*STIMULUS:
6488	!*	ASSERT AND NEGATE 'RESET'
6489	!*	ASSERT AND NEGATE 'CRA/M RESET'
6490	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6491	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6492	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6493	!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
6494	!*RESPONSE:
6495	!*	'CONTINUE' DID NOT ASSERT.
6496	!]ERROR 3
6497	!]WRT212 CONT_H CONT NTWK
6498		IF FLP_CHK(3,FLP_PTR)
6499			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6500	
6501		INIT();					!DO A RESET
6502		TEMP = RD_300;			!READ STATE OF FLOPS
6503		IF (.TEMP AND RUN_1) NEQ 0		!DID 'RUN (1)' NEGATE?
6504		THEN
6505			BEGIN
6506			ERR(4);		!NO, REPORT ERROR
6507			RUN_ERFLG = -1;		!SET ERROR FLAG
6508			END;
6509	!*MESSAGE 4
6510	!*STIMULUS:
6511	!*	ASSERT AND NEGATE 'RESET'
6512	!*	ASSERT AND NEGATE 'CRA/M RESET'
6513	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6514	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6515	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6516	!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
6517	!*	ASSERT AND NEGATE 'RESET'
6518	!*RESPONSE:
6519	!*	'RUN (1)' DID NOT NEGATE.
6520	!]ERROR 4
6521	!]RUN_1 RUN NTWK
6522		IF FLP_CHK(4,FLP_PTR)
6523			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6524	
6525		IF (.TEMP AND EXECUTE_B) NEQ 0		!DID 'EXECUTE B' NEGATE?
6526		THEN
6527			BEGIN
6528			ERR(5);		!NO, REPORT ERROR
6529			EXE_ERFLG = -1;		!SET ERROR FLAG
6530			END;
6531	!*MESSAGE 5
6532	!*STIMULUS:
6533	!*	ASSERT AND NEGATE 'RESET'
6534	!*	ASSERT AND NEGATE 'CRA/M RESET'
6535	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6536	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6537	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6538	!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
6539	!*	ASSERT AND NEGATE 'RESET'
6540	!*RESPONSE:
6541	!*	'EXECUTE B' DID NOT NEGATE.
6542	!]ERROR 5
6543	!]EXEC_B EXEC NTWK
6544		IF FLP_CHK(5,FLP_PTR)
6545			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6546	
6547		IF (.TEMP AND CONTINUE_H) NEQ 0		!DID 'CONTINUE' NEGATE?
6548		THEN
6549			BEGIN
6550			ERR(6);		!NO, REPORT ERROR
6551			CON_ERFLG = -1;		!SET ERROR FLAG
6552			END;
6553	!*MESSAGE 6
6554	!*STIMULUS:
6555	!*	ASSERT AND NEGATE 'RESET'
6556	!*	ASSERT AND NEGATE 'CRA/M RESET'
6557	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6558	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6559	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6560	!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
6561	!*	ASSERT AND NEGATE 'RESET'
6562	!*RESPONSE:
6563	!*	'CONTINUE' DID NOT NEGATE.
6564	!]ERROR 6
6565	!]CONT_H CONT NTWK
6566		IF FLP_CHK(6,FLP_PTR)
6567			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6568		0				!TO PREVENT INFO MSG WHEN COMPILING
6569		END;
6570	!CHECK IF ANY OF THE SIGNALS WE IN ERROR.  IF NOT DO SOME ISOLATION.
6571	
6572		IF .RUN_ERFLG EQL 0
6573		THEN
6574			NOERR(1);
6575	!]NO ERROR 1
6576	!]WRT212 RUN NTWK
6577	
6578		IF .EXE_ERFLG EQL 0
6579		THEN
6580			NOERR(2);
6581	!]NO ERROR 2
6582	!]WRT212 EXEC NTWK
6583	
6584		IF .CON_ERFLG EQL 0
6585		THEN
6586			NOERR(3);
6587	!]NO ERROR 3
6588	!]WRT212 CONT NTWK
6589	
6590		END;
6591	
6592	GLOBAL ROUTINE TST64: NOVALUE =
6593	
6594	!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE'
6595	!CAN BE NEGATED BY NEGATING THERE DATA INPUTS AND CLOCKING THEM.
6596	
6597		BEGIN
6598		LABEL BLOCK1;
6599		BIND
6600			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,LR212,DR0,LR206,DR2,RP');
6601	
6602		LOCAL
6603			TEMP;
6604	
6605		DO (0) WHILE
6606	BLOCK1:
6607		BEGIN
6608		INIT();					!DO A RESET
6609		RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
6610		WRT212(7);				!ASSERT 1ST STAGE FLOPS
6611		WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
6612		WRT212(0);				!NEGATE 1ST STAGE FLOPS
6613		WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
6614		TEMP = RD_300;			!READ STATES OF FLOPS
6615		IF (.TEMP AND RUN_1 ) NEQ 0		!DID 'RUN (1)' NEGATE?
6616		THEN
6617			ERR(1);		!NO, REPORT ERROR
6618	!*MESSAGE 1
6619	!*STIMULUS:
6620	!*	ASSERT AND NEGATE 'RESET'
6621	!*	ASSERT AND NEGATE 'CRA/M RESET'
6622	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6623	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6624	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6625	!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
6626	!*	WRT 212/0		- NEGATE 1ST STAGE FLOPS
6627	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6628	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6629	!*				  SHOULD CLOCK THE 'RUN (1)' FLOP.
6630	!*RESPONSE:
6631	!*	'RUN (1)' DID NOT NEGATE.
6632	!]ERROR 1
6633	!]RUN_1 NTWK
6634		IF FLP_CHK(1,FLP_PTR)
6635			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6636	
6637		IF (.TEMP AND EXECUTE_B ) NEQ 0		!DID 'EXECUTE B' NEGATE?
6638		THEN
6639			ERR(2);		!NO, REPORT ERROR
6640	!*MESSAGE 2
6641	!*STIMULUS:
6642	!*	ASSERT AND NEGATE 'RESET'
6643	!*	ASSERT AND NEGATE 'CRA/M RESET'
6644	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6645	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6646	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6647	!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
6648	!*	WRT 212/0		- NEGATE 1ST STAGE FLOPS
6649	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6650	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6651	!*				  SHOULD CLOCK THE 'EXECUTE B' FLOP.
6652	!*RESPONSE:
6653	!*	'EXECUTE B' DID NOT NEGATE.
6654	!]ERROR 2
6655	!]EXEC_B NTWK
6656		IF FLP_CHK(2,FLP_PTR)
6657			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6658	
6659		IF (.TEMP AND CONTINUE_H ) NEQ 0		!DID 'CONTINUE' NEGATE?
6660		THEN
6661			ERR(3);		!NO, REPORT ERROR
6662	!*MESSAGE 3
6663	!*STIMULUS:
6664	!*	ASSERT AND NEGATE 'RESET'
6665	!*	ASSERT AND NEGATE 'CRA/M RESET'
6666	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6667	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6668	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6669	!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
6670	!*	WRT 212/0		- NEGATE 1ST STAGE FLOPS
6671	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6672	!*				  TOGGLE 'ENABLE (0)' WHICH IN TURN
6673	!*				  SHOULD CLOCK THE 'CONTINUE' FLOP.
6674	!*RESPONSE:
6675	!*	'CONTINUE' DID NOT NEGATE.
6676	!]ERROR 3
6677	!]CONT_H NTWK
6678		IF FLP_CHK(3,FLP_PTR)
6679			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6680		0				!TO PREVENT INFO MSG WHEN COMPILING
6681		END;
6682	
6683		END;
6684	
6685	GLOBAL ROUTINE TST65: NOVALUE =
6686	
6687	!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE'
6688	!NEGATE WHEN CRAM BITS 'CRM2 # 14B', 'CRM2 # 13B' AND 'CRM2 # 12B' ARE
6689	!ASSERTED ALONG WITH 'CRA2 SPEC/CONSOLE' WHEN A CLOCK PULSE OCCURS.
6690	
6691		BEGIN
6692		LABEL BLOCK1;
6693		BIND
6694			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,DR2,RP');
6695	
6696		LOCAL
6697			TEMP;
6698		BIND
6699			UC_PTR = PLIT(U_SPEC_N U_N(70) U);
6700	
6701		INIT();					!DO A RESET
6702		LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
6703		DO (0) WHILE
6704	BLOCK1:
6705		BEGIN
6706		SET_C(0);				!SET CRAM START ADDR TO ZERO
6707		INIT();					!DO A RESET
6708		RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
6709		WRT212(7);				!ASSERT 1ST STAGE FLOPS
6710		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6711		WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
6712		TEMP = RD_300;			!READ STATES OF FLOPS
6713		IF (.TEMP AND RUN_1 ) NEQ 0		!DID 'RUN (1)' NEGATE?
6714		THEN
6715			ERR(1);		!NO, REPORT ERROR
6716	!*MESSAGE 1
6717	!*STIMULUS:
6718	!*	SET CRAM BIT 'CRM2 # 14B' AND SET 'SPEC' FIELD TO '10'
6719	!*	ASSERT AND NEGATE 'RESET'
6720	!*	ASSERT AND NEGATE 'CRA/M RESET'
6721	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6722	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6723	!*				  BITS INTO THEIR LATCHES.
6724	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6725	!*				  CAUSE 'CPM CMD LD' TO ASSERT, WHICH
6726	!*				  TOGETHER WITH 'CRM2 # 14B' WILL CLEAR
6727	!*				  THE 1ST STAGE FLOP.  WHEN 'ENABLE (0)'
6728	!*				  TOGGLES, THE 'RUN (1)' FLOP WON'T
6729	!*				  ASSERT.
6730	!*RESPONSE:
6731	!*	'RUN (1)' DID NOT NEGATE.
6732	!]ERROR 1
6733	!]RUN_1 NTWK
6734		IF FLP_CHK(1,FLP_PTR)
6735			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6736	
6737		IF (.TEMP AND EXECUTE_B ) NEQ 0		!DID 'EXECUTE B' NEGATE?
6738		THEN
6739			ERR(2);		!NO, REPORT ERROR
6740	!*MESSAGE 2
6741	!*STIMULUS:
6742	!*	SET CRAM BIT 'CRM2 # 13B' AND SET 'SPEC' FIELD TO '10'
6743	!*	ASSERT AND NEGATE 'RESET'
6744	!*	ASSERT AND NEGATE 'CRA/M RESET'
6745	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6746	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6747	!*				  BITS INTO THEIR LATCHES.
6748	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6749	!*				  CAUSE 'CPM CMD LD' TO ASSERT, WHICH
6750	!*				  TOGETHER WITH 'CRM2 # 13B' WILL CLEAR
6751	!*				  THE 1ST STAGE FLOP.  WHEN 'ENABLE (0)'
6752	!*				  TOGGLES, THE 'EXECUTE B' FLOP WON'T
6753	!*				  ASSERT.
6754	!*RESPONSE:
6755	!*	'EXECUTE B' DID NOT NEGATE.
6756	!]ERROR 2
6757	!]EXEC_B NTWK
6758		IF FLP_CHK(2,FLP_PTR)
6759			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6760	
6761		IF (.TEMP AND CONTINUE_H ) NEQ 0		!DID 'CONTINUE' NEGATE?
6762		THEN
6763			ERR(3);		!NO, REPORT ERROR
6764	!*MESSAGE 3
6765	!*STIMULUS:
6766	!*	SET CRAM BIT 'CRM2 # 12B' AND SET 'SPEC' FIELD TO '10'
6767	!*	ASSERT AND NEGATE 'RESET'
6768	!*	ASSERT AND NEGATE 'CRA/M RESET'
6769	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6770	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6771	!*				  BITS INTO THEIR LATCHES.
6772	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS SHOULD
6773	!*				  CAUSE 'CPM CMD LD' TO ASSERT, WHICH
6774	!*				  TOGETHER WITH 'CRM2 # 12B' WILL CLEAR
6775	!*				  THE 1ST STAGE FLOP.  WHEN 'ENABLE (0)'
6776	!*				  TOGGLES, THE 'CONTINUE' FLOP WON'T
6777	!*				  ASSERT.
6778	!*RESPONSE:
6779	!*	'CONTINUE' DID NOT NEGATE.
6780	!]ERROR 3
6781	!]CONT_H NTWK
6782		IF FLP_CHK(3,FLP_PTR)
6783			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6784		0				!TO PREVENT INFO MSG WHEN COMPILING
6785		END;
6786	
6787		END;
6788	
6789	GLOBAL ROUTINE TST66: NOVALUE =
6790	
6791	!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE' STILL
6792	!ASSERTS WHEN CRAM BITS 'CRM2 # 14B', 'CRM2 # 13B' AND 'CRM2 # 12B' ARE
6793	!NEGATED AND 'CRA2 SPEC/CONSOLE' IS ASSERTED WHEN A CLOCK PULSE OCCURS.
6794	
6795		BEGIN
6796		LABEL BLOCK1;
6797		BIND
6798			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,DR2,RP');
6799	
6800		LOCAL
6801			TEMP;
6802		BIND
6803			UC_PTR = PLIT(U_SPEC_N U_N(0) U);
6804	
6805		INIT();					!DO A RESET
6806		LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
6807		DO (0) WHILE
6808	BLOCK1:
6809		BEGIN
6810		SET_C(0);				!SET CRAM START ADDR TO ZERO
6811		INIT();					!DO A RESET
6812		RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
6813		WRT212(7);				!ASSERT 1ST STAGE FLOPS
6814		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6815		WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
6816		TEMP = RD_300;			!READ STATES OF FLOPS
6817		IF (.TEMP AND RUN_1 ) EQL 0		!DID 'RUN (1)' ASSERT?
6818		THEN
6819			ERR(1);			!NO
6820	!*MESSAGE 1
6821	!*STIMULUS:
6822	!*	CLEAR CRAM BIT 'CRM2 # 14B' AND SET 'SPEC' FIELD TO '10'
6823	!*	ASSERT AND NEGATE 'RESET'
6824	!*	ASSERT AND NEGATE 'CRA/M RESET'
6825	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6826	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6827	!*				  BITS INTO THEIR LATCHES.
6828	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
6829	!*				  'ENABLE (0)' WHICH SHOULD ASSERT
6830	!*				  'RUN (1)'.  SINCE 'CRM2 # 14B' IS
6831	!*				  NEGATED, THE 1ST STAGE FLOP SHOULD NOT
6832	!*				  GET NEGATED.
6833	!*RESPONSE:
6834	!*	'RUN (1)' DID NOT ASSERT.
6835	!]ERROR 1
6836	!]RUN_1 NTWK
6837		IF FLP_CHK(1,FLP_PTR)
6838			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6839	
6840		IF (.TEMP AND EXECUTE_B ) EQL 0		!DID 'EXECUTE B' ASSERT?
6841		THEN
6842			ERR(2);			!NO
6843	!*MESSAGE 2
6844	!*STIMULUS:
6845	!*	CLEAR CRAM BIT 'CRM2 # 13B' AND SET 'SPEC' FIELD TO '10'
6846	!*	ASSERT AND NEGATE 'RESET'
6847	!*	ASSERT AND NEGATE 'CRA/M RESET'
6848	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6849	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6850	!*				  BITS INTO THEIR LATCHES.
6851	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
6852	!*				  'ENABLE (0)' WHICH SHOULD ASSERT
6853	!*				  'EXECUTE B'.  SINCE 'CRM2 # 13B' IS
6854	!*				  NEGATED, THE 1ST STAGE FLOP SHOULD NOT
6855	!*				  GET NEGATED.
6856	!*RESPONSE:
6857	!*	'EXECUTE B' DID NOT ASSERT.
6858	!]ERROR 2
6859	!]EXEC_B NTWK
6860		IF FLP_CHK(2,FLP_PTR)
6861			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6862	
6863		IF (.TEMP AND CONTINUE_H ) EQL 0		!DID 'CONTINUE' ASSERT?
6864		THEN
6865			ERR(3);			!NO
6866	!*MESSAGE 3
6867	!*STIMULUS:
6868	!*	CLEAR CRAM BIT 'CRM2 # 12B' AND SET 'SPEC' FIELD TO '10'
6869	!*	ASSERT AND NEGATE 'RESET'
6870	!*	ASSERT AND NEGATE 'CRA/M RESET'
6871	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6872	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6873	!*				  BITS INTO THEIR LATCHES.
6874	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
6875	!*				  'ENABLE (0)' WHICH SHOULD ASSERT
6876	!*				  'CONTINUE'.  SINCE 'CRM2 # 12B' IS
6877	!*				  NEGATED, THE 1ST STAGE FLOP SHOULD NOT
6878	!*				  GET NEGATED.
6879	!*RESPONSE:
6880	!*	'CONTINUE' DID NOT ASSERT.
6881	!]ERROR 3
6882	!]CONT_H NTWK
6883		IF FLP_CHK(3,FLP_PTR)
6884			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6885		0				!TO PREVENT INFO MSG WHEN COMPILING
6886		END;
6887		INIT();					!DO A RESET
6888	
6889		END;
6890	
6891	GLOBAL ROUTINE TST67: NOVALUE =
6892	
6893	!THIS TEST CHECKS THAT THE 'RUN (1)', 'EXECUTE B' AND 'CONTINUE' STILL
6894	!ASSERTS WHEN CRAM BITS 'CRM2 # 14B', 'CRM2 # 13B' AND 'CRM2 # 12B' ARE
6895	!ASSERTED AND 'CRA2 SPEC/CONSOLE' IS NEGATED WHEN A CLOCK PULSE OCCURS.
6896	
6897		BEGIN
6898		LABEL BLOCK1;
6899		BIND
6900			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR212,DR7,LR206,DR2,DR2,RP');
6901	
6902		LOCAL
6903			TEMP;
6904		BIND
6905			UC_PTR = PLIT( U_N(70) U);
6906	
6907		INIT();			!DO A RESET
6908		LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
6909		DO (0) WHILE
6910	BLOCK1:
6911		BEGIN
6912		SET_C(0);				!SET CRAM START ADDR TO ZERO
6913		INIT();					!DO A RESET
6914		RESET_CRAM();				!CLEAR ALL CRAM CONTROL BITS
6915		WRT212(7);				!ASSERT 1ST STAGE FLOPS
6916		WRT206(SINGLE_CLK);			!CLOCK RAM BITS INTO LATCHES
6917		WRT206(SINGLE_CLK);			!TOGGLE 'ENABLE (0)'
6918		TEMP = RD_300;			!READ STATES OF FLOPS
6919		IF (.TEMP AND RUN_1 ) EQL 0		!DID 'RUN (1)' ASSERT?
6920		THEN
6921			ERR(1);			!NO
6922	!*MESSAGE 1
6923	!*STIMULUS:
6924	!*	SET CRAM BIT 'CRM2 # 14B' AND SET 'SPEC' FIELD TO '70'
6925	!*	ASSERT AND NEGATE 'RESET'
6926	!*	ASSERT AND NEGATE 'CRA/M RESET'
6927	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6928	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6929	!*				  BITS INTO THEIR LATCHES.
6930	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
6931	!*				  'ENABLE (0)' WHICH SHOULD ASSERT
6932	!*				  'RUN (1)'.  SINCE 'CRA2 SPEC/CONSOLE'
6933	!*				  IS NEGATED, THE 1ST STAGE FLOP SHOULD
6934	!*				  NOT GET NEGATED.
6935	!*RESPONSE:
6936	!*	'RUN (1)' DID NOT ASSERT.
6937	!]ERROR 1
6938	!]RUN_1 NTWK
6939		IF FLP_CHK(1,FLP_PTR)
6940			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6941	
6942		IF (.TEMP AND EXECUTE_B ) EQL 0		!DID 'EXECUTE B' ASSERT?
6943		THEN
6944			ERR(2);			!NO
6945	!*MESSAGE 2
6946	!*STIMULUS:
6947	!*	SET CRAM BIT 'CRM2 # 13B' AND SET 'SPEC' FIELD TO '70'
6948	!*	ASSERT AND NEGATE 'RESET'
6949	!*	ASSERT AND NEGATE 'CRA/M RESET'
6950	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6951	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6952	!*				  BITS INTO THEIR LATCHES.
6953	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
6954	!*				  'ENABLE (0)' WHICH SHOULD ASSERT
6955	!*				  'EXECUTE B'. SINCE 'CRA2 SPEC/CONSOLE'
6956	!*				  IS NEGATED, THE 1ST STAGE FLOP SHOULD
6957	!*				  NOT GET NEGATED.
6958	!*RESPONSE:
6959	!*	'EXECUTE B' DID NOT ASSERT.
6960	!]ERROR 2
6961	!]EXEC_B NTWK
6962		IF FLP_CHK(2,FLP_PTR)
6963			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6964	
6965		IF (.TEMP AND CONTINUE_H ) EQL 0		!DID 'CONTINUE' ASSERT?
6966		THEN
6967			ERR(3);			!NO
6968	!*MESSAGE 3
6969	!*STIMULUS:
6970	!*	SET CRAM BIT 'CRM2 # 12B' AND SET 'SPEC' FIELD TO '70'
6971	!*	ASSERT AND NEGATE 'RESET'
6972	!*	ASSERT AND NEGATE 'CRA/M RESET'
6973	!*	WRT 212/7		- ASSERT 1ST STAGE FLOPS
6974	!*	WRT 206/2		- ASSERTING 'SINGLE CLK' CLOCKS THE CRAM
6975	!*				  BITS INTO THEIR LATCHES.
6976	!*	WRT 206/2		- ASSERT 'SINGLE CLK'. THIS TOGGLES
6977	!*				  'ENABLE (0)' WHICH SHOULD ASSERT
6978	!*				  'CONTINUE'. SINCE 'CRA2 SPEC/CONSOLE'
6979	!*				  IS NEGATED, THE 1ST STAGE FLOP SHOULD
6980	!*				  NOT GET NEGATED.
6981	!*RESPONSE:
6982	!*	'CONTINUE' DID NOT ASSERT.
6983	!]ERROR 3
6984	!]CONT_H NTWK
6985		IF FLP_CHK(3,FLP_PTR)
6986			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
6987		0				!TO PREVENT INFO MSG WHEN COMPILING
6988		END;
6989		MR();				!DO A MASTER RESET
6990	
6991		END;
6992	
6993	GLOBAL ROUTINE TST68: NOVALUE =
6994	
6995	!THIS TEST CHECKS THAT THE PARITY GENERATION NETWORKS FOR THE KS10 BUS
6996	!WORK CORRECTLY.  SPECIFICALLY, IT CHECKS THAT THE PARITY GENERATORS
6997	!IN THE 8646 TRANSCEIVERS AND THE 74S280 PARITY GEN CHIPS WORK CORRECTLY
6998	!THIS IS DONE BY CLOCKING DATA PATTERNS THROUGH THE 8646 TRANSCEIVERS
6999	!THEN LATCHING THE PATTERNS IN THE RECEIVE LATCHES.
7000	
7001		BEGIN
7002		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
7003		BIND
7004			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR210,DR141,RP');
7005		LOCAL
7006			TEMP;
7007	
7008		DO (0) WHILE
7009	BLOCK1:
7010		BEGIN
7011		INIT();					!DO A RESET
7012		WRT103(%O'21');				!WRITE DATA PATTERN INTO BUFFERS
7013		WRT105(%O'21');
7014		WRT107(%O'20');
7015		WRT111(%O'21');
7016		WRT113(1);
7017		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7018		TEMP = RD_103;			!READ STATE OF PARITY BITS
7019		IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
7020		THEN
7021			ERR(1);			!NO
7022	!*MESSAGE 1
7023	!*STIMULUS:
7024	!*	ASSERT AND NEGATE 'RESET'
7025	!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
7026	!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
7027	!*	WRT 107/20		  R DATA 00-35 TO BE 042104010421
7028	!*	WRT 111/21
7029	!*	WRT 113/1
7030	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7031	!*				  THE SIGNALS TPR1-4 SHOULD ALL BE
7032	!*				  ASSERTED AND SIGNALS TD18 AND TD19
7033	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7034	!*				  'R PAR RIGHT' TO BE NEGATED.
7035	!*RESPONSE:
7036	!*	'R PAR RIGHT' IS ASSERTED.
7037	!]ERROR 1
7038	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7039		IF FLP_CHK(1,FLP_PTR)
7040			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7041	
7042		IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
7043		THEN
7044			ERR(2);			!NO
7045	!*MESSAGE 2
7046	!*STIMULUS:
7047	!*	ASSERT AND NEGATE 'RESET'
7048	!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
7049	!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
7050	!*	WRT 107/20		  R DATA 00-35 TO BE 042104010421
7051	!*	WRT 111/21
7052	!*	WRT 113/1
7053	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7054	!*				  THE SIGNALS TPL1-4 SHOULD ALL BE
7055	!*				  ASSERTED AND SIGNALS TD16 AND TD17
7056	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7057	!*				  'R PAR LEFT' TO BE NEGATED.
7058	!*RESPONSE:
7059	!*	'R PAR LEFT' IS ASSERTED.
7060	!]ERROR 2
7061	!]RPAR_LEFT R_PAR_LFT XMIT_PAR_LFT NTWK
7062		IF FLP_CHK(2,FLP_PTR)
7063			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7064		0				!TO PREVENT INFO MSG WHEN COMPILING
7065		END;
7066	
7067		WRT103(1);				!CHANGE DATA PATTERN
7068		WRT107(%O'25');
7069		WRT111(%O'20');
7070	
7071		DO (0) WHILE
7072	BLOCK2:
7073		BEGIN
7074		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7075		TEMP = RD_103;			!READ STATE OF PARITY BITS
7076		IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
7077		THEN
7078			ERR(3);			!NO
7079	!*MESSAGE 3
7080	!*STIMULUS:
7081	!*	ASSERT AND NEGATE 'RESET'
7082	!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
7083	!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
7084	!*	WRT 107/25		  R DATA 00-35 TO BE 042005210401
7085	!*	WRT 111/20
7086	!*	WRT 113/1
7087	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7088	!*				  THE SIGNALS TPR1,TPR3,TPR4 AND TD19
7089	!*				  SHOULD BE ASSERTED. TPR2 AND TD18
7090	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7091	!*				  'R PAR RIGHT' TO BE NEGATED.
7092	!*RESPONSE:
7093	!*	'R PAR RIGHT' IS ASSERTED.
7094	!]ERROR 3
7095	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7096		IF FLP_CHK(3,FLP_PTR)
7097			THEN LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
7098	
7099		IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
7100		THEN
7101			ERR(4);			!NO
7102	!*MESSAGE 4
7103	!*STIMULUS:
7104	!*	ASSERT AND NEGATE 'RESET'
7105	!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
7106	!*	WRT 105/21		  THIS PATTERN SHOULD CAUSE
7107	!*	WRT 107/25		  R DATA 00-35 TO BE 042005210401
7108	!*	WRT 111/20
7109	!*	WRT 113/1
7110	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7111	!*				  THE SIGNALS TPL1,TPL3,TPL4 AND TD17
7112	!*				  SHOULD BE ASSERTED. TPL2 AND TD16
7113	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7114	!*				  'R PAR LEFT' TO BE NEGATED.
7115	!*RESPONSE:
7116	!*	'R PAR LEFT' IS ASSERTED.
7117	!]ERROR 4
7118	!]R_PAR_LFT XMIT_PAR_LFT RPAR_LEFT NTWK
7119		IF FLP_CHK(4,FLP_PTR)
7120			THEN LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
7121		0				!TO PREVENT INFO MSG WHEN COMPILING
7122		END;
7123	
7124		WRT105(%O'20');				!CHANGE DATA PATTERN
7125		WRT107(%O'37');
7126		WRT111(0);
7127	
7128		DO (0) WHILE
7129	BLOCK3:
7130		BEGIN
7131		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7132		TEMP = RD_103;			!READ STATE OF PARITY BITS
7133		IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
7134		THEN
7135			ERR(5);			!NO
7136	!*MESSAGE 5
7137	!*STIMULUS:
7138	!*	ASSERT AND NEGATE 'RESET'
7139	!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
7140	!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
7141	!*	WRT 107/37		  R DATA 00-35 TO BE 040007610001
7142	!*	WRT 111/0
7143	!*	WRT 113/1
7144	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7145	!*				  THE SIGNALS TPR1,TPR4,TD18 AND TD19
7146	!*				  SHOULD BE ASSERTED. TPR2 AND TPR3
7147	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7148	!*				  'R PAR RIGHT' TO BE NEGATED.
7149	!*RESPONSE:
7150	!*	'R PAR RIGHT' IS ASSERTED.
7151	!]ERROR 5
7152	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7153		IF FLP_CHK(5,FLP_PTR)
7154			THEN LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
7155	
7156		IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
7157		THEN
7158			ERR(6);			!NO
7159	!*MESSAGE 6
7160	!*STIMULUS:
7161	!*	ASSERT AND NEGATE 'RESET'
7162	!*	WRT 103/1		- WRITE DATA PATTERN TO BUFFERS
7163	!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
7164	!*	WRT 107/37		  R DATA 00-35 TO BE 040007610001
7165	!*	WRT 111/0
7166	!*	WRT 113/1
7167	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7168	!*				  THE SIGNALS TPL1,TPL4,TD16 AND TD17
7169	!*				  SHOULD BE ASSERTED. TPL2 AND TPL3
7170	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7171	!*				  'R PAR RIGHT' TO BE NEGATED.
7172	!*RESPONSE:
7173	!*	'R PAR LEFT' IS ASSERTED.
7174	!]ERROR 6
7175	!]R_PAR_LFT XMIT_PAR_LFT RPAR_LEFT NTWK
7176		IF FLP_CHK(6,FLP_PTR)
7177			THEN LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
7178		0				!TO PREVENT INFO MSG WHEN COMPILING
7179		END;
7180	
7181		WRT103(%O'21');				!CHANGE DATA PATTERN
7182		WRT107(%O'32');
7183		WRT111(1);
7184	
7185		DO (0) WHILE
7186	BLOCK4:
7187		BEGIN
7188		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7189		TEMP = RD_103;			!READ STATE OF PARITY BITS
7190		IF (.TEMP AND PAR_RIGHT ) NEQ 0		!DID 'R PAR RIGHT' NEGATE?
7191		THEN
7192			ERR(7);			!NO
7193	!*MESSAGE 7
7194	!*STIMULUS:
7195	!*	ASSERT AND NEGATE 'RESET'
7196	!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
7197	!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
7198	!*	WRT 107/32		  R DATA 00-35 TO BE 040106410021
7199	!*	WRT 111/0
7200	!*	WRT 113/1
7201	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7202	!*				  THE SIGNALS TPR1,TPR2,TPR4 AND TD18
7203	!*				  SHOULD BE ASSERTED. TPR3 AND TD19
7204	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7205	!*				  'R PAR RIGHT' TO BE NEGATED.
7206	!*RESPONSE:
7207	!*	'R PAR RIGHT' IS ASSERTED.
7208	!]ERROR 7
7209	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7210		IF FLP_CHK(7,FLP_PTR)
7211			THEN LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP
7212	
7213		IF (.TEMP AND PAR_LEFT ) NEQ 0		!DID 'R PAR LEFT' NEGATE?
7214		THEN
7215			ERR(8);			!NO
7216	!*MESSAGE 8
7217	!*STIMULUS:
7218	!*	ASSERT AND NEGATE 'RESET'
7219	!*	WRT 103/21		- WRITE DATA PATTERN TO BUFFERS
7220	!*	WRT 105/20		  THIS PATTERN SHOULD CAUSE
7221	!*	WRT 107/32		  R DATA 00-35 TO BE 040106410021
7222	!*	WRT 111/0
7223	!*	WRT 113/1
7224	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7225	!*				  THE SIGNALS TPL1,TPL2,TPL4 AND TD16
7226	!*				  SHOULD BE ASSERTED. TPL3 AND TD17
7227	!*				  SHOULD BE NEGATED.  THIS SHOULD CAUSE
7228	!*				  'R PAR LEFT' TO BE NEGATED.
7229	!*RESPONSE:
7230	!*	'R PAR LEFT' IS ASSERTED.
7231	!]ERROR 8
7232	!]RPAR_LEFT R_PAR_LFT XMIT_PAR_LFT NTWK
7233		IF FLP_CHK(8,FLP_PTR)
7234			THEN LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP
7235		0				!TO PREVENT INFO MSG WHEN COMPILING
7236		END;
7237	
7238		WRT103(%O'20');				!CHANGE DATA PATTERN
7239		WRT105(0);
7240		WRT107(0);
7241		WRT113(0);
7242	
7243		DO (0) WHILE
7244	BLOCK5:
7245		BEGIN
7246		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7247		TEMP = RD_103;			!READ STATE OF PARITY BITS
7248		IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
7249		THEN
7250			ERR(9);			!NO
7251	!*MESSAGE 9
7252	!*STIMULUS:
7253	!*	ASSERT AND NEGATE 'RESET'
7254	!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
7255	!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
7256	!*	WRT 107/0		  R DATA 00-35 TO BE 000100000020
7257	!*	WRT 111/1
7258	!*	WRT 113/0
7259	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7260	!*				  THE SIGNALS TPR1,TPR3,TPR4,TD18 AND
7261	!*				  TD19 SHOULD BE NEGATED. TPR3
7262	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7263	!*				  'R PAR RIGHT' TO BE ASSERTED.
7264	!*RESPONSE:
7265	!*	'R PAR RIGHT' IS NEGATED.
7266	!]ERROR 9
7267	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7268		IF FLP_CHK(9,FLP_PTR)
7269			THEN LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP
7270	
7271		IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
7272		THEN
7273			ERR(10);			!NO
7274	!*MESSAGE 10
7275	!*STIMULUS:
7276	!*	ASSERT AND NEGATE 'RESET'
7277	!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
7278	!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
7279	!*	WRT 107/0		  R DATA 00-35 TO BE 000100000020
7280	!*	WRT 111/1
7281	!*	WRT 113/0
7282	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7283	!*				  THE SIGNALS TPL1,TPL3,TPL4,TD16 AND
7284	!*				  TD17 SHOULD BE NEGATED. TPL3
7285	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7286	!*				  'R PAR LEFT' TO BE ASSERTED.
7287	!*RESPONSE:
7288	!*	'R PAR LEFT' IS NEGATED.
7289	!]ERROR 10
7290	!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
7291		IF FLP_CHK(10,FLP_PTR)
7292			THEN LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP
7293		0				!TO PREVENT INFO MSG WHEN COMPILING
7294		END;
7295	
7296		WRT105(1);				!CHANGE DATA PATTERN
7297		WRT107(5);
7298		WRT111(%O'21');
7299	
7300		DO (0) WHILE
7301	BLOCK6:
7302		BEGIN
7303		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7304		TEMP = RD_103;			!READ STATE OF PARITY BITS
7305		IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
7306		THEN
7307			ERR(11);			!NO
7308	!*MESSAGE 11
7309	!*STIMULUS:
7310	!*	ASSERT AND NEGATE 'RESET'
7311	!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
7312	!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
7313	!*	WRT 107/5		  R DATA 00-35 TO BE 002101200420
7314	!*	WRT 111/21
7315	!*	WRT 113/0
7316	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7317	!*				  THE SIGNALS TPR1,TPR4 AND TD18
7318	!*				  SHOULD BE NEGATED. TPR2,TPR3 AND TD19
7319	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7320	!*				  'R PAR RIGHT' TO BE ASSERTED.
7321	!*RESPONSE:
7322	!*	'R PAR RIGHT' IS NEGATED.
7323	!]ERROR 11
7324	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7325		IF FLP_CHK(11,FLP_PTR)
7326			THEN LEAVE BLOCK6 WITH 1;	!LEAVE BLOCK TO LOOP
7327	
7328		IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
7329		THEN
7330			ERR(12);			!NO
7331	!*MESSAGE 12
7332	!*STIMULUS:
7333	!*	ASSERT AND NEGATE 'RESET'
7334	!*	WRT 103/20		- WRITE DATA PATTERN TO BUFFERS
7335	!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
7336	!*	WRT 107/5		  R DATA 00-35 TO BE 002101200420
7337	!*	WRT 111/21
7338	!*	WRT 113/0
7339	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7340	!*				  THE SIGNALS TPL1,TPL4 AND TD16
7341	!*				  SHOULD BE NEGATED. TPL2,TPL3 AND TD17
7342	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7343	!*				  'R PAR LEFT' TO BE ASSERTED.
7344	!*RESPONSE:
7345	!*	'R PAR LEFT' IS NEGATED.
7346	!]ERROR 12
7347	!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
7348		IF FLP_CHK(12,FLP_PTR)
7349			THEN LEAVE BLOCK6 WITH 1;	!LEAVE BLOCK TO LOOP
7350		0				!TO PREVENT INFO MSG WHEN COMPILING
7351		END;
7352	
7353		WRT103(0);				!CHANGE DATA PATTERN
7354		WRT107(%O'17');
7355		WRT111(%O'20');
7356	
7357		DO (0) WHILE
7358	BLOCK7:
7359		BEGIN
7360		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7361		TEMP = RD_103;			!READ STATE OF PARITY BITS
7362		IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
7363		THEN
7364			ERR(13);			!NO
7365	!*MESSAGE 13
7366	!*STIMULUS:
7367	!*	ASSERT AND NEGATE 'RESET'
7368	!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
7369	!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
7370	!*	WRT 107/17		  R DATA 00-35 TO BE 002003600400
7371	!*	WRT 111/20
7372	!*	WRT 113/0
7373	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7374	!*				  THE SIGNALS TPR1,TPR2 AND TPR4
7375	!*				  SHOULD BE NEGATED. TPR3,TD18 AND TD19
7376	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7377	!*				  'R PAR RIGHT' TO BE ASSERTED.
7378	!*RESPONSE:
7379	!*	'R PAR RIGHT' IS NEGATED.
7380	!]ERROR 13
7381	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7382		IF FLP_CHK(13,FLP_PTR)
7383			THEN LEAVE BLOCK7 WITH 1;	!LEAVE BLOCK TO LOOP
7384	
7385		IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
7386		THEN
7387			ERR(14);			!NO
7388	!*MESSAGE 14
7389	!*STIMULUS:
7390	!*	ASSERT AND NEGATE 'RESET'
7391	!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
7392	!*	WRT 105/1		  THIS PATTERN SHOULD CAUSE
7393	!*	WRT 107/17		  R DATA 00-35 TO BE 002003600400
7394	!*	WRT 111/20
7395	!*	WRT 113/0
7396	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7397	!*				  THE SIGNALS TPL1,TPL2 AND TPL4
7398	!*				  SHOULD BE NEGATED. TPL3,TD16 AND TD17
7399	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7400	!*				  'R PAR LEFT' TO BE ASSERTED.
7401	!*RESPONSE:
7402	!*	'R PAR LEFT' IS NEGATED.
7403	!]ERROR 14
7404	!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
7405		IF FLP_CHK(14,FLP_PTR)
7406			THEN LEAVE BLOCK7 WITH 1;	!LEAVE BLOCK TO LOOP
7407		0				!TO PREVENT INFO MSG WHEN COMPILING
7408		END;
7409	
7410		WRT105(0);				!CHANGE DATA PATTERN
7411		WRT107(%O'12');
7412		WRT111(0);
7413	
7414		DO (0) WHILE
7415	BLOCK8:
7416		BEGIN
7417		WRT210(BUS_REQ + XMIT_ADR + CLOSE_LATCH); !CLOCK DATA INTO RECEVIERS
7418		TEMP = RD_103;			!READ STATE OF PARITY BITS
7419		IF (.TEMP AND PAR_RIGHT ) EQL 0		!DID 'R PAR RIGHT' ASSERT?
7420		THEN
7421			ERR(15);			!NO
7422	!*MESSAGE 15
7423	!*STIMULUS:
7424	!*	ASSERT AND NEGATE 'RESET'
7425	!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
7426	!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
7427	!*	WRT 107/12		  R DATA 00-35 TO BE 000002400000
7428	!*	WRT 111/0
7429	!*	WRT 113/0
7430	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7431	!*				  THE SIGNALS TPR1,TPR2,TPR3,TPR4 AND
7432	!*				  TD19 SHOULD BE NEGATED. TD18
7433	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7434	!*				  'R PAR RIGHT' TO BE ASSERTED.
7435	!*RESPONSE:
7436	!*	'R PAR RIGHT' IS NEGATED.
7437	!]ERROR 15
7438	!]R_PAR_RT RPAR_RIGHT XMIT_PAR_RT NTWK
7439		IF FLP_CHK(15,FLP_PTR)
7440			THEN LEAVE BLOCK8 WITH 1;	!LEAVE BLOCK TO LOOP
7441	
7442		IF (.TEMP AND PAR_LEFT ) EQL 0		!DID 'R PAR LEFT' ASSERT?
7443		THEN
7444			ERR(16);			!NO
7445	!*MESSAGE 16
7446	!*STIMULUS:
7447	!*	ASSERT AND NEGATE 'RESET'
7448	!*	WRT 103/0		- WRITE DATA PATTERN TO BUFFERS
7449	!*	WRT 105/0		  THIS PATTERN SHOULD CAUSE
7450	!*	WRT 107/12		  R DATA 00-35 TO BE 000002400000
7451	!*	WRT 111/0
7452	!*	WRT 113/0
7453	!*	WRT 210/141		- CLOCK DATA INTO RECEIVER LATCHES.
7454	!*				  THE SIGNALS TPL1,TPL2,TPL3,TPL4 AND
7455	!*				  TD17 SHOULD BE NEGATED. TD16
7456	!*				  SHOULD BE ASSERTED.  THIS SHOULD CAUSE
7457	!*				  'R PAR LEFT' TO BE ASSERTED.
7458	!*RESPONSE:
7459	!*	'R PAR LEFT' IS NEGATED.
7460	!]ERROR 16
7461	!]R_PAR_LFT RPAR_LEFT XMIT_PAR_LFT NTWK
7462		IF FLP_CHK(16,FLP_PTR)
7463			THEN LEAVE BLOCK8 WITH 1;	!LEAVE BLOCK TO LOOP
7464		0				!TO PREVENT INFO MSG WHEN COMPILING
7465		END;
7466	
7467		END;
7468	
7469	GLOBAL ROUTINE TST69: NOVALUE =
7470	
7471	!THIS TEST CHECKS THAT THE KS10 CPU CLOCK ENABLE SIGNALS 'CRA/M CLK
7472	!ENABLE' AND 'DPE/M CLK ENABLE', ASSERT AND NEGATE CORRECTLY WHEN
7473	!'CLK RUN' IS ASSERTED AND 'CRA6 T00' AND 'CRA6 T01' ARE NEGATED.
7474	!THIS TEST IS CONDUCTED IN SINGLE-PULSING MODE USING THE MAINTENANCE
7475	!CLOCK FLOP TO PRODUCE CONTROLLED T-CLK/R-CLK SIGNALS.
7476	
7477		BEGIN
7478		LOCAL
7479			TEMP;
7480		BIND
7481			UC_PTR = PLIT(U_T(0) U);
7482		LABEL BLOCK1;
7483		BIND
7484			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');
7485	
7486		MR();				!DO A MASTER RESET
7487		LOAD_U(0,UC_PTR);			!LOAD UCODE WITH T00,T01 = 0
7488		DO (0) WHILE
7489	BLOCK1:
7490		BEGIN
7491		SET_C(0);				!SET CRAM START ADDR TO ZERO
7492		INIT();					!DO A RESET
7493		SYNC_CLK();				!SYNC T-CLKS/R-CLKS
7494		RESET_CRAM();				!NEGATE 'T00' AND 'T01'
7495		WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
7496		CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
7497		WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
7498		CYCLE(2);				!GENERATE 2 T CLKS
7499		TEMP = RD_303;
7500		IF ( .TEMP AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
7501		THEN
7502			ERR(1);		!NO,REPORT ERROR
7503	!*MESSAGE 1
7504	!*STIMULUS:
7505	!*	LOAD UCODE WITH T00 = T01 = 0.
7506	!*	ASSERT AND NEGATE 'RESET'
7507	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7508	!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
7509	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7510	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7511	!*				'ENABLE (1)' WHICH RESETS ALL THE
7512	!*				CPU CLOCK CONTROL FLOPS.
7513	!*	WRT 206/1		- ASSERT 'CLK RUN'
7514	!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
7515	!*				 TO ASSERT WHICH IN TURN CAUSES 'CRA/M
7516	!*				 CLK ENABLE' TO ASSERT.
7517	!*RESPONSE:
7518	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
7519	!]ERROR 1
7520	!]R_CLK CLK_ENBS ENB T_CNT_DN READ_DLY RD_DLY WRT_DLY CLK_RUN NTWK
7521		IF FLP_CHK(1,FLP_PTR)
7522			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7523	
7524		IF ( .TEMP AND DP_CLK_ENBL ) NEQ 0	!DID 'DPE/M CLK ENABLE' ASSERT?
7525		THEN
7526			ERR(2);		!NO,REPORT ERROR
7527	!*MESSAGE 2
7528	!*STIMULUS:
7529	!*	LOAD UCODE WITH T00 = T01 = 0.
7530	!*	ASSERT AND NEGATE 'RESET'
7531	!*	STOP CLOCK AND SYNC TO A T-CLK/R-CLK NEGATED STATE
7532	!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
7533	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7534	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7535	!*				'ENABLE (1)' WHICH RESETS ALL THE
7536	!*				CPU CLOCK CONTROL FLOPS.
7537	!*	WRT 206/1		- ASSERT 'CLK RUN'
7538	!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
7539	!*				 TO ASSERT WHICH IN TURN CAUSES 'DPE/M
7540	!*				 CLK ENABLE' TO ASSERT.
7541	!*RESPONSE:
7542	!*	'DPE/M CLK ENABLE' DIDN'T ASSERT.
7543	!]ERROR 2
7544	!]R_CLK PF_1 CLK_ENBS ENB T_CNT_DN READ_DLY RD_DLY WRT_DLY CLK_RUN NTWK
7545		IF FLP_CHK(2,FLP_PTR)
7546			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7547	
7548		CYCLE(1);				!GENERATE ANOTHER T-CLK CYCLE
7549		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' NEGATE?
7550		THEN
7551			ERR(3);		!NO,REPORT ERROR
7552	!*MESSAGE 3
7553	!*STIMULUS:
7554	!*	LOAD UCODE WITH T00 = T01 = 0.
7555	!*	ASSERT AND NEGATE 'RESET'
7556	!*	STOP CLOCK AND SYNC TO A T-CLK/R-CLK NEGATED STATE
7557	!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
7558	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7559	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7560	!*				'ENABLE (1)' WHICH RESETS ALL THE
7561	!*				CPU CLOCK CONTROL FLOPS.
7562	!*	WRT 206/1		- ASSERT 'CLK RUN'
7563	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
7564	!*				 TO ASSERT THEN NEGATE WHICH SHOULD
7565	!*				 CAUSE 'CRA/M CLK ENABLE' TO ASSERT THEN
7566	!*				 NEGATE.
7567	!*RESPONSE:
7568	!*	'CRA/M CLK ENABLE' DIDN'T NEGATE.
7569	!]ERROR 3
7570	!]R_CLK CLK_ENBS ENB SING_CLK NTWK
7571		IF FLP_CHK(3,FLP_PTR)
7572			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7573	
7574		CYCLE(1);				!GENERATE ANOTHER T-CLK CYCLE
7575		IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
7576		THEN
7577			ERR(4);		!NO,REPORT ERROR
7578	!*MESSAGE 4
7579	!*STIMULUS:
7580	!*	LOAD UCODE WITH T00 = T01 = 0.
7581	!*	ASSERT AND NEGATE 'RESET'
7582	!*	STOP CLOCK AND SYNC TO A T-CLK/R-CLK NEGATED STATE
7583	!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
7584	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7585	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7586	!*				'ENABLE (1)' WHICH RESETS ALL THE
7587	!*				CPU CLOCK CONTROL FLOPS.
7588	!*	WRT 206/1		- ASSERT 'CLK RUN'
7589	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS SHOULD CAUSE 'ENABLE (1)'
7590	!*				 TO ASSERT, NEGATE THEN ASSERT AGAIN.
7591	!*				 THIS CAUSES 'CRA/M CLK ENABLE' TO
7592	!*				 ASSERT, NEGATE THEN ASSERT AGAIN.
7593	!*RESPONSE:
7594	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
7595	!]ERROR 4
7596	!]R_CLK CLK_ENBS ENB T_CNT_DN READ_DLY RD_DLY WRT_DLY CLK_RUN NTWK
7597		IF FLP_CHK(4,FLP_PTR)
7598			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7599		0				!TO PREVENT INFO MSG WHEN COMPILING
7600		END;
7601		MR();				!DO A MASTER RESET
7602	
7603		END;
7604	
7605	GLOBAL ROUTINE TST70: NOVALUE =
7606	
7607	!THIS TEST CHECKS THAT THE 'CLK RUN' PRE-FLOP, WHICH IS THE ONE WHICH
7608	!THE 8080 ASSERTS TO ASSERT 'CLK RUN', GETS NEGATED BY 'RESETB'.  THIS
7609	!IS DONE BY ASSERTING FLOP , DOING A RESET, THEN GENERATING 2 T-CLKS AND
7610	!CHECKING THAT 'CRA/M CLK ENABLE' DOESN'T ASSERT.
7611	
7612		BEGIN
7613		LABEL BLOCK1;
7614		BIND
7615			FLP_PTR = UPLIT(%ASCIZ'LR205,DR100,LR206,DR1,LR100,DR200,DR0,RP');
7616	
7617		DO (0) WHILE
7618	BLOCK1:
7619		BEGIN
7620		INIT();					!DO A RESET
7621		STOP_CLK;				!STOP T-CLKS/R-CLKS
7622		RESET_CRAM();				!NEGATE 'T00' AND 'T01'
7623		WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
7624		INIT();					!DO A RESET
7625		STOP_CLK;				!STOP T-CLKS/R-CLKS AGAIN
7626		CYCLE(2);				!GENERATE 2 T CLKS
7627		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
7628		THEN
7629			ERR(1);		!NO,REPORT ERROR
7630	!*MESSAGE 1
7631	!*STIMULUS:
7632	!*	ASSERT AND NEGATE 'RESET'
7633	!*	WRT 205/100		- STOP CLOCKS
7634	!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
7635	!*	WRT 206/1		- ASSERT 'CLK RUN' PRE-FLOP
7636	!*	ASSERT AND NEGATE 'RESET'
7637	!*	WRT 205/100		- STOP CLOCKS
7638	!*	GENERATE 2 T-CLK/R-CLK CYCLES - SINCE THE 'CLK RUN' PRE-FLOP
7639	!*				SHOULD BE NEGATED, 'ENABLE (1)' AND
7640	!*				'CRA/M CLK ENABLE' SHOULDN'T ASSERT.
7641	!*RESPONSE:
7642	!*	'CRA/M CLK ENABLE' ASSERTED.
7643	!]ERROR 1
7644	!]CLK_ENBS ENB SING_CLK CLK_RUN NTWK
7645		IF FLP_CHK(1,FLP_PTR)
7646			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7647		0				!TO PREVENT INFO MSG WHEN COMPILING
7648	
7649		END;
7650		MR();				!DO A MASTER RESET
7651	
7652		END;
7653	
7654	GLOBAL ROUTINE TST71: NOVALUE =
7655	
7656	!THIS TEST CHECKS THAT THE 'CLK RUN' FLOP GETS NEGATED BY 'RESETB'.
7657	!THIS IS DONE BY ASSERTING THE 'CLK RUN' PRE-FLOP, GENERATING 1 T-CLK,
7658	!DOING A RESET, THEN GENERATING ANOTHER T-CLK AND CHECKING THAT
7659	!'CRA/M CLK ENABLE' DOESN'T ASSERT.
7660	
7661		BEGIN
7662		LABEL BLOCK1;
7663		BIND
7664			FLP_PTR = UPLIT(%ASCIZ'LR206,DR1,LR100,DR200,DR0,RP');
7665	
7666		DO (0) WHILE
7667	BLOCK1:
7668		BEGIN
7669		INIT();					!DO A RESET
7670		STOP_CLK;				!STOP T-CLKS/R-CLKS
7671		RESET_CRAM();				!NEGATE 'T00' AND 'T01'
7672		WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
7673		CYCLE(1);				!GENERATE 1 T-CLK
7674		INIT();					!DO A RESET
7675		STOP_CLK;				!STOP T-CLKS/R-CLKS AGAIN
7676		CYCLE(1);				!GENERATE 1 T-CLK
7677		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
7678		THEN
7679			ERR(1);		!NO,REPORT ERROR
7680	!*MESSAGE 1
7681	!*STIMULUS:
7682	!*	ASSERT AND NEGATE 'RESET'
7683	!*	WRT 205/100		- STOP CLOCKS
7684	!*	ASSERT AND NEGATE 'CRA/M RESET' - THIS NEGATES 'T00' AND 'T01'
7685	!*	WRT 206/1		- ASSERT 'CLK RUN'
7686	!*	GENERATE 1 T-CLK/R-CLK CYCLE	- THIS SHOULD ASSERT 'CLK RUN'
7687	!*	ASSERT AND NEGATE 'RESET'
7688	!*	WRT 205/100		- STOP CLOCKS
7689	!*	GENERATE 1 T-CLK/R-CLK CYCLE - SINCE 'CLK RUN' SHOULD BE
7690	!*				NEGATED 'ENABLE (1)' AND 'CRA/M CLK
7691	!*				ENABLE' SHOULD NOT ASSERT.
7692	!*RESPONSE:
7693	!*	'CRA/M CLK ENABLE' ASSERTED.
7694	!]ERROR 1
7695	!]CLK_ENBS ENB CLK_RUN SING_CLK NTWK
7696		IF FLP_CHK(1,FLP_PTR)
7697			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7698		0				!TO PREVENT INFO MSG WHEN COMPILING
7699	
7700		END;
7701		MR();				!DO A MASTER RESET
7702	
7703		END;
7704	
7705	GLOBAL ROUTINE TST72: NOVALUE =
7706	
7707	!THIS TEST CHECKS THAT THE 'ENABLE (1)' SIGNAL FUNCTIONS CORRECTLY WHEN
7708	!'CRA6 T00' IS NEGATED AND 'CRA6 T01' IS ASSERTED WITH 'CLK RUN'
7709	!ASSERTED.  THIS CONDITION SHOULD CAUSE 'ENABLE (1)' TO ASSERT EVERY
7710	!THIRD T-CLK/R-CLK CYCLE.  THE ASSERTION OF 'ENABLE (1)' IS INFERRED
7711	!FROM THE ASSERTION OF 'CRA/M CLK ENABLE'.
7712	
7713		BEGIN
7714		LABEL BLOCK1;
7715		BIND
7716			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');
7717		BIND
7718			UC_PTR = PLIT(U_T(1) U);
7719	
7720		MR();				!DO A MASTER RESET
7721		LOAD_U(0,UC_PTR);			!LOAD UCODE SO 'T01' = 1
7722		DO (0) WHILE
7723	BLOCK1:
7724		BEGIN
7725		SET_C(0);				!SET CRAM START ADDR TO ZERO
7726		INIT();					!DO A RESET
7727		SYNC_CLK();				!SYNC T-CLKS/R-CLKS
7728		RESET_CRAM();				!CLEAR CRAM BITS
7729		WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
7730		CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
7731		WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
7732		CYCLE(2);				!GENERATE 2 T-CLK
7733		IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
7734		THEN
7735			ERR(1);		!NO,REPORT ERROR
7736	!*MESSAGE 1
7737	!*STIMULUS:
7738	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
7739	!*		'T01' AND NEGATES 'T00'.
7740	!*	ASSERT AND NEGATE 'RESET'
7741	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7742	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7743	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7744	!*				'ENABLE (1)' WHICH RESETS ALL THE
7745	!*				CPU CLOCK CONTROL FLOPS.
7746	!*	WRT 206/1		- ASSERT 'CLK RUN'
7747	!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THIS SHOULD CAUSE 'CLK RUN' TO
7748	!*				  ASSERT ON THE FIRST CYCLE, THEN
7749	!*				  'ENABLE (1)' AND 'CRA/M CLK ENABLE'
7750	!*				  SHOULD ASSERT ON THE SECOND CYCLE.
7751	!*RESPONSE:
7752	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
7753	!]ERROR 1
7754	!]T_COUNT_DONE NTWK
7755		IF FLP_CHK(1,FLP_PTR)
7756			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7757	
7758		CYCLE(1);				!GENERATE 1 T-CLK
7759		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' NEGATE?
7760		THEN
7761			ERR(2);		!NO,REPORT ERROR
7762	!*MESSAGE 2
7763	!*STIMULUS:
7764	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
7765	!*		'T01' AND NEGATES 'T00'.
7766	!*	ASSERT AND NEGATE 'RESET'
7767	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7768	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7769	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7770	!*				'ENABLE (1)' WHICH RESETS ALL THE
7771	!*				CPU CLOCK CONTROL FLOPS.
7772	!*	WRT 206/1		- ASSERT 'CLK RUN'
7773	!*	GENERATE 3 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE ASSERTS 'CLK 
7774	!*				RUN'. THE 2ND CYCLE ASSERTS 'ENABLE (1)'
7775	!*				WHICH ASSERTS 'CRA/M CLK ENABLE'. THE
7776	!*				3RD CYCLE SHOULD NEGATE 'T COUNT DONE
7777	!*				(1)' AND 'CRA/M CLK ENABLE'.
7778	!*RESPONSE:
7779	!*	'CRA/M CLK ENABLE' DIDN'T NEGATE.
7780	!]ERROR 2
7781	!]T_COUNT_DONE NTWK
7782		IF FLP_CHK(2,FLP_PTR)
7783			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7784	
7785		CYCLE(1);				!GENERATE 1 T-CLK
7786		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
7787		THEN
7788			ERR(3);		!NO,REPORT ERROR
7789	!*MESSAGE 3
7790	!*STIMULUS:
7791	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
7792	!*		'T01' AND NEGATES 'T00'.
7793	!*	ASSERT AND NEGATE 'RESET'
7794	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7795	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7796	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7797	!*				'ENABLE (1)' WHICH RESETS ALL THE
7798	!*				CPU CLOCK CONTROL FLOPS.
7799	!*	WRT 206/1		- ASSERT 'CLK RUN'
7800	!*	GENERATE 4 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE ASSERTS 'CLK
7801	!*				RUN'. THE 2ND CYCLE ASSERTS 'ENABLE (1)'
7802	!*				WHICH IN TURN ASSERTS 'CRA/M CLK ENABLE'
7803	!*				THE 3RD CYCLE NEGATES 'T COUNT DONE (1)'
7804	!*				AND 'CRA/M CLK ENABLE'. 'T COUNT DONE
7805	!*				(1)' SHOULD STAY NEGATED ON THE 4TH
7806	!*				CYCLE. THEREFORE, 'ENABLE (1)' AND
7807	!*				'CRA/M CLK ENABLE' SHOULD STAY NEGATED.
7808	!*RESPONSE:
7809	!*	'CRA/M CLK ENABLE' ASSERTED.
7810	!]ERROR 3
7811	!]T_COUNT_DONE NTWK
7812		IF FLP_CHK(3,FLP_PTR)
7813			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7814	
7815		CYCLE(1);				!GENERATE 1 T-CLK
7816		IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
7817		THEN
7818			ERR(4);		!NO,REPORT ERROR
7819	!*MESSAGE 4
7820	!*STIMULUS:
7821	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
7822	!*		'T01' AND NEGATES 'T00'.
7823	!*	ASSERT AND NEGATE 'RESET'
7824	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7825	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7826	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7827	!*				'ENABLE (1)' WHICH RESETS ALL THE
7828	!*				CPU CLOCK CONTROL FLOPS.
7829	!*	WRT 206/1		- ASSERT 'CLK RUN'
7830	!*	GENERATE 5 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE ASSERTS 'CLK
7831	!*				RUN'. THE 2ND CYCLE ASSERTS 'ENABLE (1)'
7832	!*				WHICH IN TURN ASSERTS 'CRA/M CLK ENABLE'
7833	!*				THE 3RD CYCLE NEGATES 'T COUNT DONE (1)'
7834	!*				AND 'CRA/M CLK ENABLE'. 'T COUNT DONE
7835	!*				(1)' SHOULD STAY NEGATED ON THE 4TH
7836	!*				CYCLE. THEREFORE, 'ENABLE (1)' AND
7837	!*				'CRA/M CLK ENABLE' SHOULD STAY NEGATED.
7838	!*				THE 5TH CYCLE ASSERTS 'T COUNT DONE (1)'
7839	!*				WHICH SHOULD CAUSE 'ENABLE (1)' AND
7840	!*				'CRA/M CLK ENABLE' TO ASSERT.
7841	!*RESPONSE:
7842	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
7843	!]ERROR 4
7844	!]T_COUNT_DONE NTWK
7845		IF FLP_CHK(4,FLP_PTR)
7846			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7847		0				!TO PREVENT INFO MSG WHEN COMPILING
7848		END;
7849		MR();				!DO A MASTER RESET
7850	
7851		END;
7852	
7853	GLOBAL ROUTINE TST73: NOVALUE =
7854	
7855	!THIS TEST CHECKS THAT THE 'ENABLE (1)' SIGNAL FUNCTIONS CORRECTLY WHEN
7856	!'CRA6 T01' IS NEGATED AND 'CRA6 T00' IS ASSERTED WITH 'CLK RUN'
7857	!ASSERTED.  THIS CONDITION SHOULD CAUSE 'ENABLE (1)' TO ASSERT EVERY
7858	!FOURTH T-CLK/R-CLK CYCLE, STARTING WITH THE 3RD CYCLE.  THE ASSERTION
7859	!OF 'ENABLE (1)' IS INFERRED FROM THE ASSERTION OF 'CRA/M CLK ENABLE'.
7860	
7861		BEGIN
7862		LABEL BLOCK1;
7863		BIND
7864			UC_PTR = PLIT(U_T(2) U);
7865		BIND
7866			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');
7867	
7868		LOAD_U(0,UC_PTR);			!LOAD UCODE SO 'T01' = 1
7869		DO (0) WHILE
7870	BLOCK1:
7871		BEGIN
7872		SET_C(0);				!SET CRAM START ADDR TO ZERO
7873		INIT();					!DO A RESET
7874		SYNC_CLK();				!SYNC T-CLKS/R-CLKS
7875		RESET_CRAM();				!CLEAR CRAM BITS
7876		WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
7877		CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
7878		WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
7879		CYCLE(2);				!GENERATE 2 T-CLKS
7880		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
7881		THEN
7882			ERR(1);		!NO,REPORT ERROR
7883	!*MESSAGE 1
7884	!*STIMULUS:
7885	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
7886	!*		'T00' AND NEGATES 'T01'.
7887	!*	ASSERT AND NEGATE 'RESET'
7888	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7889	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7890	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7891	!*				'ENABLE (1)' WHICH RESETS ALL THE
7892	!*				CPU CLOCK CONTROL FLOPS.
7893	!*	WRT 206/1		- ASSERT 'CLK RUN'
7894	!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
7895	!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
7896	!*				ASSERT 'ENABLE (1)' BECAUSE 'T COUNT
7897	!*				DONE (1)' SHOULD STILL BE NEGATED.
7898	!*RESPONSE:
7899	!*	'CRA/M CLK ENABLE' ASSERTED PREMATURELY.  THIS IMPLIES THAT
7900	!*	'T COUNT DONE (1)' MUST HAVE ASSERTED PREMATURELY.
7901	!]ERROR 1
7902	!]T_COUNT_DONE NTWK
7903		IF FLP_CHK(1,FLP_PTR)
7904			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7905	
7906		CYCLE(1);				!GENERATE 1 T-CLK
7907		IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
7908		THEN
7909			ERR(2);		!NO,REPORT ERROR
7910	!*MESSAGE 2
7911	!*STIMULUS:
7912	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
7913	!*		'T00' AND NEGATES 'T01'.
7914	!*	ASSERT AND NEGATE 'RESET'
7915	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7916	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7917	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7918	!*				'ENABLE (1)' WHICH RESETS ALL THE
7919	!*				CPU CLOCK CONTROL FLOPS.
7920	!*	WRT 206/1		- ASSERT 'CLK RUN'
7921	!*	GENERATE 3 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
7922	!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
7923	!*				ASSERT 'ENABLE (1)' BECAUSE 'T COUNT
7924	!*				DONE (1)' SHOULD STILL BE NEGATED.  THE
7925	!*				3RD CYCLE SHOULD ASSERT 'T COUNT DONE
7926	!*				(1)', 'ENABLE (1)', AND 'CRA/M CLK
7927	!*				ENABLE'.
7928	!*RESPONSE:
7929	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.  THIS IMPLIES THAT 'T COUNT
7930	!*	DONE (1)' PROBABLY DIDN'T ASSERT.
7931	!]ERROR 2
7932	!]T_COUNT_DONE NTWK
7933		IF FLP_CHK(2,FLP_PTR)
7934			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7935		0				!TO PREVENT INFO MSG WHEN COMPILING
7936		END;
7937		MR();				!DO A MASTER RESET
7938	
7939		END;
7940	
7941	GLOBAL ROUTINE TST74: NOVALUE =
7942	
7943	!THIS TEST CHECKS THAT THE 'ENABLE (1)' SIGNAL FUNCTIONS CORRECTLY WHEN
7944	!'CRA6 T01' IS ASSERTED AND 'CRA6 T00' IS ASSERTED WITH 'CLK RUN'
7945	!ASSERTED.  THIS CONDITION SHOULD CAUSE 'ENABLE (1)' TO ASSERT EVERY
7946	!FIFTH T-CLK/R-CLK CYCLE, STARTING WITH THE 4TH CYCLE.  THE ASSERTION
7947	!OF 'ENABLE (1)' IS INFERRED FROM THE ASSERTION OF 'CRA/M CLK ENABLE'.
7948	
7949		BEGIN
7950		LABEL BLOCK1;
7951		BIND
7952			UC_PTR = PLIT(U_T(3) U);
7953		BIND
7954			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR204,DR1,DR0,LR206,DR2,RP');
7955	
7956		MR();				!DO A MASTER RESET
7957		LOAD_U(0,UC_PTR);			!LOAD UCODE SO 'T01' = 1
7958		DO (0) WHILE
7959	BLOCK1:
7960		BEGIN
7961		SET_C(0);				!SET CRAM START ADDR TO ZERO
7962		INIT();					!DO A RESET
7963		SYNC_CLK();				!SYNC T-CLKS/R-CLKS
7964		RESET_CRAM();				!CLEAR CRAM BITS
7965		WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
7966		CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
7967		WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
7968		CYCLE(2);				!GENERATE 2 T-CLKS
7969		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
7970		THEN
7971			ERR(1);		!NO,REPORT ERROR
7972	!*MESSAGE 1
7973	!*STIMULUS:
7974	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
7975	!*		'T00' AND 'T01'.
7976	!*	ASSERT AND NEGATE 'RESET'
7977	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
7978	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
7979	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
7980	!*				'ENABLE (1)' WHICH RESETS ALL THE
7981	!*				CPU CLOCK CONTROL FLOPS.
7982	!*	WRT 206/1		- ASSERT 'CLK RUN'
7983	!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
7984	!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
7985	!*				ASSERT 'ENABLE (1)' BECAUSE 'T COUNT
7986	!*				DONE (1)' SHOULD STILL BE NEGATED.
7987	!*RESPONSE:
7988	!*	'CRA/M CLK ENABLE' ASSERTED PREMATURELY.  THIS IMPLIES THAT
7989	!*	'T COUNT DONE (1)' MUST HAVE ASSERTED PREMATURELY.
7990	!]ERROR 1
7991	!]T_COUNT_DONE NTWK
7992		IF FLP_CHK(1,FLP_PTR)
7993			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
7994	
7995		CYCLE(1);				!GENERATE 1 T-CLK
7996		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
7997		THEN
7998			ERR(2);		!NO,REPORT ERROR
7999	!*MESSAGE 2
8000	!*STIMULUS:
8001	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
8002	!*		'T00' AND 'T01'.
8003	!*	ASSERT AND NEGATE 'RESET'
8004	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
8005	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
8006	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
8007	!*				'ENABLE (1)' WHICH RESETS ALL THE
8008	!*				CPU CLOCK CONTROL FLOPS.
8009	!*	WRT 206/1		- ASSERT 'CLK RUN'
8010	!*	GENERATE 3 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
8011	!*				RUN' TO ASSERT. THE 2ND AND 3RD CYCLES
8012	!*				DO NOT ASSERT 'ENABLE (1)' BECAUSE
8013	!*				'T COUNT DONE (1)' SHOULD STILL BE
8014	!*				NEGATED.
8015	!*RESPONSE:
8016	!*	'CRA/M CLK ENABLE' ASSERTED PREMATURELY.  THIS IMPLIES THAT
8017	!*	'T COUNT DONE (1)' MUST HAVE ASSERTED PREMATURELY.
8018	!]ERROR 2
8019	!]T_COUNT_DONE NTWK
8020		IF FLP_CHK(2,FLP_PTR)
8021			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8022		CYCLE(1);				!GENERATE 1 T-CLK
8023		IF ( RD_303 AND CR_CLK_ENB ) EQL 0	!DID 'CRA/M CLK ENABLE' ASSERT?
8024		THEN
8025			ERR(3);		!NO,REPORT ERROR
8026	!*MESSAGE 3
8027	!*STIMULUS:
8028	!*	LOAD CRAM AND CLOCK BITS INTO CONTROL LATCHES - THIS ASSERTS
8029	!*		'T00' AND 'T01'.
8030	!*	ASSERT AND NEGATE 'RESET'
8031	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
8032	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
8033	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
8034	!*				'ENABLE (1)' WHICH RESETS ALL THE
8035	!*				CPU CLOCK CONTROL FLOPS.
8036	!*	WRT 206/1		- ASSERT 'CLK RUN'
8037	!*	GENERATE 4 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
8038	!*				RUN' TO ASSERT. THE 2ND AND 3RD CYCLES
8039	!*				DO NOT ASSERT 'ENABLE (1)' BECAUSE
8040	!*				'T COUNT DONE (1)' SHOULD STILL BE
8041	!*				NEGATED. THE 4TH CYCLE SHOULD CAUSE
8042	!*				'T COUNT DONE (1)' TO ASSERT, WHICH
8043	!*				SHOULD CAUSE 'ENABLE (1)' AND 'CRA/M
8044	!*				CLK ENABLE' TO ASSERT.
8045	!*RESPONSE:
8046	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.  THIS IMPLIES THAT 'T COUNT
8047	!*	DONE (1)' PROBABLY DIDN'T ASSERT.
8048	!]ERROR 3
8049	!]T_COUNT_DONE NTWK
8050		IF FLP_CHK(3,FLP_PTR)
8051			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8052		0				!TO PREVENT INFO MSG WHEN COMPILING
8053		END;
8054		MR();				!DO A MASTER RESET
8055	
8056		END;
8057	
8058	GLOBAL ROUTINE TST75: NOVALUE =
8059	
8060	!THIS TEST CHECKS THAT 'PE (1)' DOES NOT ASSERT WHEN THERE ARE NO
8061	!PARITY ERRORS PRESENT AND 'PE DETECT' IS ASSERTED.
8062	
8063		BEGIN
8064		LABEL BLOCK1;
8065		DO (0) WHILE
8066	BLOCK1:
8067		BEGIN
8068		RESET_CRAM();			!RESET THE CRAM BITS
8069		WRT100(RESET);			!ASSERT 'RESET'
8070		WRT100(PE_DET_ENB);		!NEGATE 'RESET' AND ASSERT 'PE DETECT'
8071		SEND_NUL();
8072		CHK_ERR_MSG(PAR_ERR);		!CHECK FOR UNEXPECTED PAR ERR MSG
8073		IF ( RD_301 AND PE_1) NEQ 0	!IS 'PE (1)' NEGATED?
8074		THEN
8075			ERR(1);		!NO,REPORT ERROR
8076	!*MESSAGE 1
8077	!*STIMULUS:
8078	!*	RESET CRAM BITS
8079	!*	WRT 100/200		- ASSERT 'RESET'
8080	!*	WRT 100/100		- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8081	!*RESPONSE:
8082	!*	'PE (1)' ASSERTED.  THIS IMPLIES THAT EITHER THERE IS AN
8083	!*	UNEXPECTED PARITY ERROR SOMEWHERE OR THERE IS A FAULT IN THE
8084	!*	PE DETECT LOGIC.
8085	!]ERROR 1
8086	!]PE PE_LTCH CPU_PE REC_BUS_PE NTWK
8087		IF LOOP_CHK(1)
8088			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8089		0				!TO PREVENT INFO MSG WHEN COMPILING
8090		END;
8091	
8092		END;
8093	
8094	GLOBAL ROUTINE TST76: NOVALUE =
8095	
8096	!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT WHEN 'DP PE DETECT' IS
8097	!ASSERTED BUT THERE IS NO DATA PATH PARITY ERROR, I.E., 'DPE4 PARITY ERR
8098	!RIGHT', 'DPE4 PAR ERR LEFT', AND 'DPM6 DPM PAR ERR' ARE ALL NEGATED.
8099	
8100		BEGIN
8101		LABEL BLOCK1;
8102		DO (0) WHILE
8103	BLOCK1:
8104		BEGIN
8105		WRT100(RESET);				!ASSERT 'RESET'
8106		WRT100(PE_DET_ENB + DP_PE_DET);		!ASSERT 'DP PE DETECT' AND 'PE DETECT'
8107		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8108		CHK_ERR_MSG(PAR_ERR);			!JUST IN CASE WE GOT PE
8109		IF ( RD_301 AND PE_1 ) NEQ 0		!IS 'PE (1)' NEGATED?
8110		THEN
8111			ERR(1);		!NO,REPORT ERROR
8112	!*MESSAGE 1
8113	!*STIMULUS:
8114	!*	WRT 100/200	- ASSERT 'RESET'
8115	!*	WRT 100/120	- NEGATE 'RESET' AND ASSERT 'DP PE DETECT' AND
8116	!*			  'PE DETECT'.
8117	!*RESPONSE:
8118	!*	'PE (1)' ASSERTED.
8119	!]ERROR 1
8120	!]PE PE_LTCH CPU_PE REC_BUS_PE DP_PAR_ERR RAM_ER_DLY NTWK
8121		IF LOOP_CHK(1)
8122			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8123		0				!TO PREVENT INFO MSG WHEN COMPILING
8124		END;
8125	
8126		END;
8127	
8128	GLOBAL ROUTINE TST77: NOVALUE =
8129	
8130	!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT WHEN 'CRM DETECT' IS
8131	!ASSERTED BUT THERE IS NO CRAM PARITY ERROR, I.E., 'CRM3 PARITY ERROR'
8132	!AND 'CRA6 CRAM PARITY ERR' ARE BOTH NEGATED.
8133	
8134		BEGIN
8135		LABEL BLOCK1;
8136		DO (0) WHILE
8137	BLOCK1:
8138		BEGIN
8139		RESET_CRAM();				!CLEAR CRAM BITS
8140		WRT100(RESET);				!ASSERT 'RESET'
8141		WRT100(PE_DET_ENB + CRM_PE_DET);		!ASSERT 'CRM DETECT' AND 'PE DETECT'
8142		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8143		CHK_ERR_MSG(PAR_ERR);			!JUST IN CASE WE GOT PE
8144		IF ( RD_301 AND PE_1 ) NEQ 0		!IS 'PE (1)' NEGATED?
8145		THEN
8146			ERR(1);		!NO,REPORT ERROR
8147	!*MESSAGE 1
8148	!*STIMULUS:
8149	!*	WRT 204/1	- ASSERT 'CRA/M RESET'. THIS SHOULD NEGATE ALL
8150	!*			  CRAM BITS, GIVING GOOD PARITY.
8151	!*	WRT 204/0	- CLEAR 'CRA/M RESET'
8152	!*	WRT 100/200	- ASSERT 'RESET'
8153	!*	WRT 100/140	- NEGATE 'RESET' AND ASSERT 'CRM DETECT' AND
8154	!*			  'PE DETECT'.
8155	!*RESPONSE:
8156	!*	'PE (1)' ASSERTED.
8157	!]ERROR 1
8158	!]PE PE_LTCH CPU_PE REC_BUS_PE NTWK
8159		IF LOOP_CHK(1)
8160			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8161		0				!TO PREVENT INFO MSG WHEN COMPILING
8162		END;
8163	
8164		END;
8165	
8166	GLOBAL ROUTINE TST78: NOVALUE =
8167	
8168	!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT WHEN A CRAM PARITY ERROR
8169	!EXISTS BUT 'CRM DETECT' IS NEGATED.
8170	
8171		BEGIN
8172		LABEL BLOCK1;
8173		DO (0) WHILE
8174	BLOCK1:
8175		BEGIN
8176		MR();				!DO A MASTER RESET
8177		CLEAR_CRAM();			!DO AN 'LC0,DC0'
8178		MOD_FLD(0,1);			!SET JUST ONE BIT TO CAUSE ODD PARITY
8179		WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
8180		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8181		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8182		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8183		IF ( RD_301 AND PE_1 ) NEQ 0	!IS 'PE (1)' NEGATED?
8184		THEN
8185			ERR(1);		!NO,REPORT ERROR
8186	!*MESSAGE 1
8187	!*STIMULUS:
8188	!*	MR		- DO A MASTER RESET
8189	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8190	!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8191	!*			  PARITY.
8192	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8193	!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
8194	!*			  ERR'.
8195	!*	WRT 100/100	- ASSERT 'PE DETECT'. SINCE 'CRM DETECT' IS NOT
8196	!*			  ASSERTED, 'PE (1)' SHOULD NOT ASSERT.
8197	!*RESPONSE:
8198	!*	'PE (1)' ASSERTED.
8199	!]ERROR 1
8200	!]CRM_DET PE PE_LTCH CPU_PE REC_BUS_PE NTWK
8201		IF LOOP_CHK(1)
8202			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8203		0				!TO PREVENT INFO MSG WHEN COMPILING
8204		END;
8205	
8206		END;
8207	
8208	GLOBAL ROUTINE TST79: NOVALUE =
8209	
8210	!THIS TEST CHECKS THAT 'PE (1)' ASSERTS WHEN 'CRA6 CRAM PARITY ERR' IS
8211	!ASSERTED AND 'CRM DETECT' IS ASSERTED. IT ALSO CHECKS THAT 'CRA PE'
8212	!ASSERTS.
8213	!AFTER 'PE (1)' IS ASSERTED, A CHECK IS MADE TO SEE THAT 'WRT 100 L'
8214	!NEGATES IT.
8215	
8216		BEGIN
8217		LABEL BLOCK1;
8218		LOCAL
8219			ERFLG;
8220	
8221		ERFLG = -1;	!INIT ERROR FLAG
8222		DO (0) WHILE
8223	BLOCK1:
8224		BEGIN
8225		MR();				!DO A MASTER RESET
8226		CLEAR_CRAM();			!DO AN 'LC0,DC0'
8227		MOD_FLD(0,1);			!SET JUST ONE BIT TO CAUSE ODD PARITY
8228		WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
8229		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8230		IF ( RD_100 AND CRA_PE ) NEQ 0	!DID 'CRA PE' ASSERT?
8231		THEN
8232			ERR(1);		!NO,REPORT ERROR
8233	!*MESSAGE 1
8234	!*STIMULUS:
8235	!*	MR		- DO A MASTER RESET
8236	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8237	!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8238	!*			  PARITY.
8239	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8240	!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
8241	!*			  ERR'. THIS SHOULD ASSERT 'CRA PE'.
8242	!*RESPONSE:
8243	!*	'CRA PE' DID NOT ASSERT.
8244	!]ERROR 1
8245	!]CRA_PE CRA_PE_LTCH PE_LTCH NTWK
8246		IF LOOP_CHK(1)
8247			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8248	
8249		WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
8250		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8251		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8252		IF ( RD_301 AND PE_1 ) EQL 0	!DID 'PE (1)' ASSERT?
8253		THEN
8254			BEGIN
8255			ERR(2);		!NO,REPORT ERROR
8256			ERFLG = -1;	!SET ERROR FLAG
8257			END;
8258	!*MESSAGE 2
8259	!*STIMULUS:
8260	!*	MR		- DO A MASTER RESET
8261	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8262	!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8263	!*			  PARITY.
8264	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8265	!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
8266	!*			  ERR'.
8267	!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
8268	!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
8269	!*RESPONSE:
8270	!*	'PE (1)' DID NOT ASSERT.
8271	!]ERROR 2
8272	!]PE PE_LTCH CPU_PE CRM_DET PE_DET NTWK
8273		IF LOOP_CHK(2)
8274			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8275	
8276		WRT100(PE_DET_ENB);	!NEGATE 'CRM DETECT' AND GENERATE 'WRT 100 L'
8277		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' NEGATE?
8278		THEN
8279			BEGIN
8280			ERR(3);		!NO,REPORT ERROR
8281			ERFLG = -1;	!SET ERROR FLAG
8282			END;
8283	!*MESSAGE 3
8284	!*STIMULUS:
8285	!*	MR		- DO A MASTER RESET
8286	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8287	!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8288	!*			  PARITY.
8289	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8290	!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
8291	!*			  ERR'.
8292	!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
8293	!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
8294	!*	WRT 100/100	- NEGATE 'CRM DETECT'. THE 'WRT 100 L' SIGNAL
8295	!*			  SHOULD NEGATE 'PE (1)'.
8296	!*RESPONSE:
8297	!*	'PE (1)' DID NOT NEGATE.
8298	!]ERROR 3
8299	!]PE_LTCH CPU_PE CRM_DET PE REC_BUS_PE NTWK
8300		IF LOOP_CHK(3)
8301			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8302		0				!TO PREVENT INFO MSG WHEN COMPILING
8303		END;
8304	
8305	!IF WE HAD NO ERRORS FOR 2 AND 3, DO SOME FAULT ISOLATION
8306	
8307		IF .ERFLG EQL 0 
8308		THEN
8309			NOERR(1);
8310	!]NO ERROR 1
8311	!]PE NTWK
8312	
8313		END;
8314	
8315	GLOBAL ROUTINE TST80: NOVALUE =
8316	
8317	!THIS TEST CHECKS THAT 'PE (1)' ASSERTS WHEN 'CRM3 PARITY ERROR' IS
8318	!ASSERTED AND 'CRM DETECT' IS ASSERTED. IT ALSO CHECKS THAT 'CRAM PE'
8319	!ASSERTS.
8320	!AFTER 'PE (1)' IS ASSERTED, A CHECK IS MADE TO SEE THAT 'CRA/M RESET'
8321	!NEGATES IT.
8322	
8323		BEGIN
8324		LABEL BLOCK1;
8325		DO (0) WHILE
8326	BLOCK1:
8327		BEGIN
8328		MR();				!DO A MASTER RESET
8329		CLEAR_CRAM();			!DO AN 'LC0,DC0'
8330		MOD_FLD(7,2);			!SET JUST ONE BIT TO CAUSE ODD PARITY
8331		WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
8332		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8333		IF ( RD_100 AND CRAM_PE ) NEQ 0	!DID 'CRAM PE' ASSERT?
8334		THEN
8335			ERR(1);		!NO,REPORT ERROR
8336	!*MESSAGE 1
8337	!*STIMULUS:
8338	!*	MR		- DO A MASTER RESET
8339	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8340	!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8341	!*			  PARITY.
8342	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8343	!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY
8344	!*			  ERROR'. THIS SHOULD ASSERT 'CRAM PE'.
8345	!*RESPONSE:
8346	!*	'CRAM PE' DID NOT ASSERT.
8347	!]ERROR 1
8348	!]CRM_PE_LTCH CRM_PE PE_LTCH NTWK
8349		IF LOOP_CHK(1)
8350			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8351	
8352		WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
8353		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8354		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8355		IF ( RD_301 AND PE_1 ) EQL 0	!DID 'PE (1)' ASSERT?
8356		THEN
8357			ERR(2);		!NO,REPORT ERROR
8358	!*MESSAGE 2
8359	!*STIMULUS:
8360	!*	MR		- DO A MASTER RESET
8361	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8362	!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8363	!*			  PARITY.
8364	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8365	!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY ERROR'.
8366	!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
8367	!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
8368	!*RESPONSE:
8369	!*	'PE (1)' DID NOT ASSERT.
8370	!]ERROR 2
8371	!]PE_LTCH CPU_PE CRM_DET PE_DET NTWK
8372		IF LOOP_CHK(2)
8373			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8374		RESET_CRAM();			!ASSERT AND NEGATE 'CRA/M RESET'
8375		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' NEGATE?
8376		THEN
8377			ERR(3);		!NO,REPORT ERROR
8378	!*MESSAGE 3
8379	!*STIMULUS:
8380	!*	MR		- DO A MASTER RESET
8381	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8382	!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8383	!*			  PARITY.
8384	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8385	!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY ERROR'.
8386	!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
8387	!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
8388	!*	WRT 204/1	- ASSERT 'CRA/M RESET'. THIS SHOULD CAUSE
8389	!*			  'PE (1)' TO NEGATE.
8390	!*	WRT 204/0	- THEN NEGATE IT.
8391	!*RESPONSE:
8392	!*	'PE (1)' DID NOT NEGATE.
8393	!]ERROR 3
8394	!]PE_LTCH CPU_PE CRM_DET REC_BUS_PE NTWK
8395		IF LOOP_CHK(3)
8396			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8397		0				!TO PREVENT INFO MSG WHEN COMPILING
8398		END;
8399	
8400		END;
8401	
8402	GLOBAL ROUTINE TST81: NOVALUE =
8403	
8404	!THIS TEST CHECKS THAT 'PE (1)' DOESN'T ASSERT IF 'PE DETECT' IS
8405	!NEGATED.
8406	
8407		BEGIN
8408		LABEL BLOCK1;
8409		DO (0) WHILE
8410	BLOCK1:
8411		BEGIN
8412		MR();				!DO A MASTER RESET
8413		CLEAR_CRAM();			!DO AN 'LC0,DC0'
8414		MOD_FLD(7,2);			!SET JUST ONE BIT TO CAUSE ODD PARITY
8415		WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
8416		WRT100(CRM_PE_DET);		!ASSERT 'CRM DETECT' WITHOUT 'PE DETECT'
8417		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8418		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8419		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8420		THEN
8421			ERR(1);		!NO,REPORT ERROR
8422	!*MESSAGE 1
8423	!*STIMULUS:
8424	!*	MR		- DO A MASTER RESET
8425	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8426	!*	LF7,DF2		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8427	!*			  PARITY.
8428	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8429	!*			  INTO LATCHES AND ASSERTS 'CRM3 PARITY ERROR'.
8430	!*	WRT 100/40	- ASSERT 'CRM DETECT'. WITH 'PE DETECT' NEGATED,
8431	!*			  'PE (1)' SHOULD NOT ASSERT.
8432	!*RESPONSE:
8433	!*	'PE (1)' ASSERTED.
8434	!]ERROR 1
8435	!]PE_LTCH PE_DET NTWK
8436		IF LOOP_CHK(1)
8437			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8438		0				!TO PREVENT INFO MSG WHEN COMPILING
8439		END;
8440		INIT();					!DO A RESET
8441	
8442		END;
8443	
8444	GLOBAL ROUTINE TST82: NOVALUE =
8445	
8446	!THIS TEST CHECKS THAT 'PE (1)' STAYS ASSERTED AFTER THE SOURCE OF
8447	!THE PARITY ERROR GOES AWAY, IN THIS CASE, 'CRA6 CRAM PARITY ERR'.  IT
8448	!ALSO CHECKS THAT 'CRA PE' STAYS ASSERTED.
8449	
8450		BEGIN
8451		LABEL BLOCK1;
8452		DO (0) WHILE
8453	BLOCK1:
8454		BEGIN
8455		MR();				!DO A MASTER RESET
8456		CLEAR_CRAM();			!DO AN 'LC0,DC0'
8457		MOD_FLD(2,%O'4000');			!SET JUST ONE BIT TO CAUSE ODD PARITY
8458		WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
8459		WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
8460		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8461		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8462		WRT103(0);			!CLEAR BUFFERS TO WRITE ZEROS TO CRA BOARD
8463		WRT105(0);
8464		WRT205(2);			!SET DIAG FN = 2
8465		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK ZEROS TO CRA BOARD
8466		WRT204(CRAM_WRT);		!WRITE ZEROS INTO CRAM
8467		WRT204(0);			!CLEAR CRAM WRITE BIT
8468		WRT206(SINGLE_CLK);		!CLOCK CRAM INTO LATCHES
8469		IF ( RD_301 AND PE_1 ) EQL 0	!DID 'PE (1)' STAY ASSERTED?
8470		THEN
8471			ERR(1);		!NO,REPORT ERROR
8472	!*MESSAGE 1
8473	!*STIMULUS:
8474	!*	MR		- DO A MASTER RESET
8475	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8476	!*	LF2,DF4000	- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8477	!*			  PARITY.
8478	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8479	!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
8480	!*			  ERR'.
8481	!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
8482	!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
8483	!*	WRT 103/0	- WRITE 8080 I/O BUFFERS WITH ZEROS
8484	!*	WRT 105/0
8485	!*	WRT 205/2	- SET DIAG FN BITS = 2
8486	!*	WRT 210/144	- CLOCK ZEROS TO CRA BOARD.
8487	!*	WRT 204/40	- CLOCK DATA INTO CRAM
8488	!*	WRT 204/0
8489	!*	WRT 206/2	- ASSERT 'SINGLE CLK'. THIS CLOCK CRAM DATA INTO
8490	!*			  LATCHES AND SHOULD CLEAR 'CRA6 CRAM PARITY
8491	!*			  ERR'.  'PE (1)' SHOULD STAY ASSERTED.
8492	!*RESPONSE:
8493	!*	'PE (1)' NEGATED.
8494	!]ERROR 1
8495	!]PE_LTCH CPU_PE CRM_DET PE_DET NTWK
8496		IF LOOP_CHK(1)
8497			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8498	
8499		IF ( RD_100 AND CRA_PE) NEQ 0	!DID 'CRA PE' STAY ASSERTED?
8500		THEN
8501			ERR(2);		!NO,REPORT ERROR
8502	!*MESSAGE 2
8503	!*STIMULUS:
8504	!*	MR		- DO A MASTER RESET
8505	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8506	!*	LF2,DF4000	- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8507	!*			  PARITY.
8508	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8509	!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
8510	!*			  ERR'.
8511	!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
8512	!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
8513	!*	WRT 103/0	- WRITE 8080 I/O BUFFERS WITH ZEROS
8514	!*	WRT 105/0
8515	!*	WRT 205/2	- SET DIAG FN BITS = 2
8516	!*	WRT 210/144	- CLOCK ZEROS TO CRA BOARD.
8517	!*	WRT 204/40	- CLOCK DATA INTO CRAM
8518	!*	WRT 204/0
8519	!*	WRT 206/2	- ASSERT 'SINGLE CLK'. THIS CLOCK CRAM DATA INTO
8520	!*			  LATCHES AND SHOULD CLEAR 'CRA6 CRAM PARITY
8521	!*			  ERR'.  'CRA PE' SHOULD STAY ASSERTED.
8522	!*RESPONSE:
8523	!*	'CRA PE' DIDN'T STAY ASSERTED.
8524	!]ERROR 2
8525	!]PE_LTCH CRA_PE_LTCH CRA_PE PE_DET NTWK
8526		IF LOOP_CHK(2)
8527			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8528		0				!TO PREVENT INFO MSG WHEN COMPILING
8529		END;
8530	
8531		END;
8532	
8533	GLOBAL ROUTINE TST83: NOVALUE =
8534	
8535	!THIS TEST CHECKS THAT 'ENABLE (1)' DOESN'T ASSERT WHEN 'CLK RUN' IS
8536	!ASSERTED BUT 'PE (1)' IS ALSO ASSERTED (I.E., 'PE (0) H' IS NEGATED).
8537	
8538		BEGIN
8539		LABEL BLOCK1;
8540		DO (0) WHILE
8541	BLOCK1:
8542		BEGIN
8543		MR();				!DO A MASTER RESET
8544		CLEAR_CRAM();			!DO AN 'LC0,DC0'
8545		MOD_FLD(2,%O'4000');		!SET JUST ONE BIT TO CAUSE ODD PARITY
8546		WRT206(SINGLE_CLK);		!CLOCK ODD PARITY INTO LATCHES TO SET PAR ERR
8547		WRT100(PE_DET_ENB + CRM_PE_DET); !ASSERT 'PE DETECT' AND 'CRM DETECT'
8548		SEND_NUL();				!FORCE SENDING OF WRITE CMDS
8549		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8550		SYNC_CLK();			!STOP CLOCK AND SYNC IT
8551		WRT206(SINGLE_CLK);			!ASSERT SINGLE CLK
8552		CYCLE(3);				!CLOCK CRAM BITS INTO LATCHES
8553		WRT206(CLK_RUN);			!ASSERT 'CLK RUN'
8554		CYCLE(2);				!GENERATE 2 T-CLKS
8555		IF ( RD_303 AND CR_CLK_ENB ) NEQ 0	!DID 'CRA/M CLK ENABLE' STAY NEGATED?
8556		THEN
8557			ERR(1);		!NO, REPORT
8558	!*MESSAGE 1
8559	!*STIMULUS:
8560	!*	MR		- DO A MASTER RESET
8561	!*	LC0,DC0		- CLEAR ALL CRAM BITS
8562	!*	LF0,DF1		- ASSERT ONE BIT IN THE CRAM. THIS GIVES BAD
8563	!*			  PARITY.
8564	!*	WRT 206/2	- ASSERT 'SINGLE_CLK'. THIS CLOCKS CRAM BITS
8565	!*			  INTO LATCHES AND ASSERTS 'CRA6 CRAM PARITY
8566	!*			  ERR'.
8567	!*	WRT 100/140	- ASSERT 'PE DETECT' AND 'CRM DETECT'. THIS
8568	!*			  SHOULD CAUSE 'PE (1)' TO ASSERT.
8569	!*	STOP CLOCK AND SYNC TO A T CLK/R CLK NEGATED STATE
8570	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
8571	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS ASSERTS AND NEGATES 
8572	!*				'ENABLE (1)' WHICH RESETS ALL THE
8573	!*				CPU CLOCK CONTROL FLOPS.
8574	!*	WRT 206/1		- ASSERT 'CLK RUN'
8575	!*	GENERATE 2 T-CLK/R-CLK CYCLES	- THE FIRST CYCLE CAUSES 'CLK
8576	!*				RUN' TO ASSERT. THE 2ND CYCLE DOES NOT
8577	!*				ASSERT 'ENABLE (1)' BECAUSE 'PE (0) H'
8578	!*				IS NEGATED.
8579	!*RESPONSE:
8580	!*	'CRA/M CLK ENABLE' ASSERTED.  THIS MEANS THAT 'PE (1)' BEING
8581	!*	ASSERTED DID NOT INHIBIT ASSERTION OF 'ENABLE (1)'.
8582	!]ERROR 1
8583	!]ENABLE_PE NTWK
8584		IF LOOP_CHK(1)
8585			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8586		0				!TO PREVENT INFO MSG WHEN COMPILING
8587		END;
8588	
8589		END;
8590	
8591	GLOBAL ROUTINE TST84: NOVALUE =
8592	
8593	!THIS TEST CHECKS THAT 'RECEIVE PE' LOGIC DOES NOT GENERATE A PARITY
8594	!ERROR WHEN GOOD PARITY IS RECEIVED ON THE KS10 BUS. SINCE IT IS NOT
8595	!POSSIBLE TO GENERATE BAD PARITY ON THE BUS, I CANNOT CHECK THAT THE
8596	!CSL BOARD DETECTS BAD PARITY WHEN IT EXISTS.
8597	
8598		BEGIN
8599		LABEL BLOCK1;
8600		DO (0) WHILE
8601	BLOCK1:
8602		BEGIN
8603		MR();				!DO A MASTER RESET
8604		WRT114(IO_DATA);		!SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8605		WRT102(0);			!SETUP DATA IN BUFFERS
8606		WRT104(0);
8607		WRT106(0);
8608		WRT110(0);
8609		WRT112(0);
8610		SEND_NUL();
8611		WRT100(RESET);			!ASSERT RESET
8612		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8613		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8614		SEND_NUL();			!SEND CMDS
8615		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8616		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8617		THEN
8618			ERR(1);		!NO, REPORT ERROR
8619	!*MESSAGE 1
8620	!*STIMULUS:
8621	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8622	!*	WRT 102/0	- SETUP BUFFERS WITH TEST DATA
8623	!*	WRT 104/0
8624	!*	WRT 106/0
8625	!*	WRT 110/0
8626	!*	WRT 112/0
8627	!*	WRT 100/200	- ASSERT 'RESET'
8628	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8629	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8630	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8631	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8632	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8633	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8634	!*			  NOT ASSERT.
8635	!*RESPONSE:
8636	!*	'PE (1)' ASSERTED.
8637	!]ERROR 1
8638	!]REC_PE NTWK
8639		IF LOOP_CHK(1)
8640			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8641	
8642		WRT110(1);			!CHANGE BUFFER DATA
8643		WRT100(RESET);			!ASSERT RESET
8644		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8645		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8646		SEND_NUL();			!SEND CMDS
8647		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8648		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8649		THEN
8650			ERR(2);		!NO, REPORT ERROR
8651	!*MESSAGE 2
8652	!*STIMULUS:
8653	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8654	!*	WRT 102/0	- SETUP BUFFERS WITH TEST DATA
8655	!*	WRT 104/0
8656	!*	WRT 106/0
8657	!*	WRT 110/1
8658	!*	WRT 112/0
8659	!*	WRT 100/200	- ASSERT 'RESET'
8660	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8661	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8662	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8663	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8664	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8665	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8666	!*			  NOT ASSERT.
8667	!*RESPONSE:
8668	!*	'PE (1)' ASSERTED.
8669	!]ERROR 2
8670	!]REC_PE NTWK
8671		IF LOOP_CHK(2)
8672			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8673	
8674		WRT102(1);			!CHANGE BUFFER DATA
8675		WRT104(1);
8676		WRT106(%O'24');
8677		WRT110(%O'21');
8678		WRT100(RESET);			!ASSERT RESET
8679		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8680		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8681		SEND_NUL();			!SEND CMDS
8682		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8683		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8684		THEN
8685			ERR(3);		!NO, REPORT ERROR
8686	!*MESSAGE 3
8687	!*STIMULUS:
8688	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8689	!*	WRT 102/1	- SETUP BUFFERS WITH TEST DATA
8690	!*	WRT 104/1
8691	!*	WRT 106/24
8692	!*	WRT 110/21
8693	!*	WRT 112/0
8694	!*	WRT 100/200	- ASSERT 'RESET'
8695	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8696	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8697	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8698	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8699	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8700	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8701	!*			  NOT ASSERT.
8702	!*RESPONSE:
8703	!*	'PE (1)' ASSERTED.
8704	!]ERROR 3
8705	!]REC_PE NTWK
8706		IF LOOP_CHK(3)
8707			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8708	
8709		WRT110(%O'20');			!CHANGE BUFFER DATA
8710		WRT100(RESET);			!ASSERT RESET
8711		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8712		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8713		SEND_NUL();			!SEND CMDS
8714		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8715		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8716		THEN
8717			ERR(4);		!NO, REPORT ERROR
8718	!*MESSAGE 4
8719	!*STIMULUS:
8720	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8721	!*	WRT 102/1	- SETUP BUFFERS WITH TEST DATA
8722	!*	WRT 104/1
8723	!*	WRT 106/24
8724	!*	WRT 110/20
8725	!*	WRT 112/0
8726	!*	WRT 100/200	- ASSERT 'RESET'
8727	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8728	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8729	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8730	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8731	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8732	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8733	!*			  NOT ASSERT.
8734	!*RESPONSE:
8735	!*	'PE (1)' ASSERTED.
8736	!]ERROR 4
8737	!]REC_PE NTWK
8738		IF LOOP_CHK(4)
8739			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8740	
8741		WRT102(%O'20');			!CHANGE BUFFER DATA
8742		WRT104(%O'21');
8743		WRT106(%O'25');
8744		WRT110(0);
8745		WRT112(1);
8746		WRT100(RESET);			!ASSERT RESET
8747		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8748		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8749		SEND_NUL();			!SEND CMDS
8750		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8751		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8752		THEN
8753			ERR(5);		!NO, REPORT ERROR
8754	!*MESSAGE 5
8755	!*STIMULUS:
8756	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8757	!*	WRT 102/20	- SETUP BUFFERS WITH TEST DATA
8758	!*	WRT 104/21
8759	!*	WRT 106/25
8760	!*	WRT 110/0
8761	!*	WRT 112/1
8762	!*	WRT 100/200	- ASSERT 'RESET'
8763	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8764	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8765	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8766	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8767	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8768	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8769	!*			  NOT ASSERT.
8770	!*RESPONSE:
8771	!*	'PE (1)' ASSERTED.
8772	!]ERROR 5
8773	!]REC_PE NTWK
8774		IF LOOP_CHK(5)
8775			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8776	
8777		WRT110(1);			!CHANGE BUFFER DATA
8778		WRT100(RESET);			!ASSERT RESET
8779		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8780		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8781		SEND_NUL();			!SEND CMDS
8782		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8783		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8784		THEN
8785			ERR(6);		!NO, REPORT ERROR
8786	!*MESSAGE 6
8787	!*STIMULUS:
8788	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8789	!*	WRT 102/20	- SETUP BUFFERS WITH TEST DATA
8790	!*	WRT 104/21
8791	!*	WRT 106/25
8792	!*	WRT 110/1
8793	!*	WRT 112/1
8794	!*	WRT 100/200	- ASSERT 'RESET'
8795	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8796	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8797	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8798	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8799	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8800	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8801	!*			  NOT ASSERT.
8802	!*RESPONSE:
8803	!*	'PE (1)' ASSERTED.
8804	!]ERROR 6
8805	!]REC_PE NTWK
8806		IF LOOP_CHK(6)
8807			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8808	
8809		WRT102(%O'21');			!CHANGE BUFFER DATA
8810		WRT104(%O'20');
8811		WRT106(1);
8812		WRT110(%O'21');
8813		WRT100(RESET);			!ASSERT RESET
8814		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8815		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8816		SEND_NUL();			!SEND CMDS
8817		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8818		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8819		THEN
8820			ERR(7);		!NO, REPORT ERROR
8821	!*MESSAGE 7
8822	!*STIMULUS:
8823	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8824	!*	WRT 102/21	- SETUP BUFFERS WITH TEST DATA
8825	!*	WRT 104/20
8826	!*	WRT 106/1
8827	!*	WRT 110/21
8828	!*	WRT 112/1
8829	!*	WRT 100/200	- ASSERT 'RESET'
8830	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8831	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8832	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8833	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8834	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8835	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8836	!*			  NOT ASSERT.
8837	!*RESPONSE:
8838	!*	'PE (1)' ASSERTED.
8839	!]ERROR 7
8840	!]REC_PE NTWK
8841		IF LOOP_CHK(7)
8842			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8843	
8844		WRT110(%O'20');			!CHANGE BUFFER DATA
8845		WRT100(RESET);			!ASSERT RESET
8846		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8847		WRT210(BUS_REQ + XMIT_DATA + LATCH_DATA + CLOSE_LATCH); !CLOCK DATA ONTO BUS
8848		SEND_NUL();			!SEND CMDS
8849		CHK_ERR_MSG(PAR_ERR);		!JUST IN CASE 'PE (1)' ASSERTED
8850		IF ( RD_301 AND PE_1 ) NEQ 0	!DID 'PE (1)' STAY NEGATED?
8851		THEN
8852			ERR(8);		!NO, REPORT ERROR
8853	!*MESSAGE 8
8854	!*STIMULUS:
8855	!*	WRT 114/2	- SETUP BUFFER SO 'R I/O DATA' WILL ASSERT
8856	!*	WRT 102/21	- SETUP BUFFERS WITH TEST DATA
8857	!*	WRT 104/20
8858	!*	WRT 106/1
8859	!*	WRT 110/20
8860	!*	WRT 112/1
8861	!*	WRT 100/200	- ASSERT 'RESET'
8862	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8863	!*	WRT 210/123	- ASSERTING 'BUS REQ' AND 'XMIT DATA (1)' CLOCKS
8864	!*			  THE BUFFER DATA ONTO THE KS10 BUS.  'LATCH
8865	!*			  DATA' AND 'R I/O DATA' WILL ASSERT 'DATA ENB'.
8866	!*			  SINCE THE DATA HAS GOOD PARITY, 'REC PE'
8867	!*			  SHOULD BE NEGATED AND THEREFORE 'PE (1)' WILL
8868	!*			  NOT ASSERT.
8869	!*RESPONSE:
8870	!*	'PE (1)' ASSERTED.
8871	!]ERROR 8
8872	!]REC_PE NTWK
8873		IF LOOP_CHK(8)
8874			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8875		0				!TO PREVENT INFO MSG WHEN COMPILING
8876		END;
8877	
8878		END;
8879	
8880	GLOBAL ROUTINE TST85: NOVALUE =
8881	
8882	!THIS TEST CHECKS THAT 'RECEIVE PE', 'RAM ERROR' AND 'DP PE' ARE NOT
8883	!ASSERTED.
8884	
8885		BEGIN
8886		LABEL BLOCK1;
8887		BIND
8888			FLP_PTR = UPLIT(%ASCIZ'LR204,DR1,DR0,LR100,DR200,DR0,RP');
8889	
8890		LOCAL
8891			TEMP;
8892		DO (0) WHILE
8893	BLOCK1:
8894		BEGIN
8895		RESET_CRAM();			!CLEAR CRAM BITS
8896		INIT();				!DO A RESET
8897		TEMP = RD_100;			!READ STATUS
8898		IF (.TEMP AND REC_PE) EQL 0	!IS 'REC PE' NEGATED?
8899		THEN
8900			ERR(1);		!NO, REPORT ERROR
8901	!*MESSAGE 1
8902	!*STIMULUS:
8903	!*	ASSERT AND NEGATE 'CRA/M RESET'
8904	!*	ASSERT AND NEGATE 'RESET'
8905	!*RESPONSE:
8906	!*	'REC PE' IS ASSERTED.
8907	!]ERROR 1
8908	!]REC_PE REC_PE_LTCH RECEIVE_PE NTWK
8909		IF FLP_CHK(1,FLP_PTR)
8910			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8911	
8912		IF (.TEMP AND DP_PE) EQL 0	!IS 'DP PE' ASSERTED?
8913		THEN
8914			ERR(2);		!NO, REPORT ERROR
8915	!*MESSAGE 2
8916	!*STIMULUS:
8917	!*	ASSERT AND NEGATE 'CRA/M RESET'
8918	!*	ASSERT AND NEGATE 'RESET'
8919	!*RESPONSE:
8920	!*	'DP PE' IS ASSERTED.
8921	!]ERROR 2
8922	!]DP_PE_LTCH DP_PAR_ERR DP_PE NTWK
8923		IF FLP_CHK(2,FLP_PTR)
8924			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8925	
8926		IF (RD_303 AND RAM_ERR) EQL 0	!IS 'RAM ERROR' NEGATED?
8927		THEN
8928			ERR(3);		!NO, REPORT ERROR
8929	!*MESSAGE 3
8930	!*STIMULUS:
8931	!*	ASSERT AND NEGATE 'CRA/M RESET'
8932	!*	ASSERT AND NEGATE 'RESET'
8933	!*RESPONSE:
8934	!*	'RAM ERROR' IS ASSERTED.
8935	!]ERROR 3
8936	!]RAM_ER_DLY RAM_ER_LTCH RAM_ERROR NTWK
8937		IF FLP_CHK(3,FLP_PTR)
8938			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8939		0				!TO PREVENT INFO MSG WHEN COMPILING
8940		END;
8941	
8942		END;
8943	
8944	GLOBAL ROUTINE TST86: NOVALUE =
8945	
8946	!THIS TEST CHECKS THAT A MEMORY PARITY ERROR CAUSE 'PE (1)' TO ASSERT.
8947	
8948		BEGIN
8949		LABEL BLOCK1;
8950		DO (0) WHILE
8951	BLOCK1:
8952		BEGIN
8953		WRT100(RESET);			!ASSERT 'RESET'
8954		WRT100(PE_DET_ENB);		!ASSERT 'PE DETECT'
8955		IO_DEPOSIT(%O'100000',%O'40000000000'); !SET MEM PARITY ERROR
8956		SEND_NUL();			!FORCE SENDING OF CMD LINE
8957		CHK_ERR_MSG(PAR_ERR);		!CHECK FOR PAR ERR MSG
8958		IF (RD_100 AND MEM_PE) NEQ 0	!DID 'MEM PARITY ERR' ASSERT?
8959		THEN
8960			ERR(1);		!NO, REPORT ERROR
8961	!*MESSAGE 1
8962	!*STIMULUS:
8963	!*	WRT 100/200	- ASSERT 'RESET'
8964	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8965	!*	LI 100000		- LOAD I/O ADDRESS 100000
8966	!*	DI 40000000000		- SET 'PAR ERR' BIT IN MEMORY STATUS REG
8967	!*				  THIS SHOULD ASSERT 'MEM PARITY ERR'
8968	!*RESPONSE:
8969	!*	'MEM PARITY ERR' DID NOT ASSERT.
8970	!]ERROR 1
8971	!]MEM_PAR_ERR NTWK
8972		IF LOOP_CHK(1)
8973			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8974	
8975		IF (RD_301 AND PE_1) EQL 0	!DID 'PE (1)' ASSERT?
8976		THEN
8977			ERR(2);		!NO, REPORT ERROR
8978	!*MESSAGE 2
8979	!*STIMULUS:
8980	!*	WRT 100/200	- ASSERT 'RESET'
8981	!*	WRT 100/100	- NEGATE 'RESET' AND ASSERT 'PE DETECT'
8982	!*	ASSERT AND NEGATE 'RESET'
8983	!*	LI 100000		- LOAD I/O ADDRESS 100000
8984	!*	DI 40000000000		- SET 'PAR ERR' BIT IN MEMORY STATUS REG
8985	!*	WRT 100/100		- ASSERT 'PE DETECT'.  SINCE 'MEM PARITY
8986	!*				  ERR' IS ASSERTED, 'PE (1)' SHOULD
8987	!*				  ASSERT.
8988	!*RESPONSE:
8989	!*	'PE (1)' DID NOT ASSERT.
8990	!]ERROR 2
8991	!]PE_LTCH NTWK
8992		IF LOOP_CHK(2)
8993			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
8994		0				!TO PREVENT INFO MSG WHEN COMPILING
8995		END;
8996		INIT();				!CLEAR PARITY ERROR
8997	
8998		END;
8999	
9000	GLOBAL ROUTINE TST87: NOVALUE =
9001	
9002	!THIS TEST CHECKS THAT THE '10 INT' FLOP CAN BE ASSERTED AND NEGATED.
9003	
9004		BEGIN
9005		LABEL BLOCK1;
9006		LOCAL
9007			ERFLG;
9008		BIND
9009			FLP_PTR = UPLIT(%ASCIZ'LR205,DR0,DR40,RP');
9010	
9011		ERFLG = 0;		!INIT ERROR FLAG
9012		DO (0) WHILE
9013	BLOCK1:
9014		BEGIN
9015		WRT205(0);			!NEGATE '10 INT'
9016		WRT205(CLR_INT);		!ASSERT '10 INT'
9017		IF (RD_301 AND TEN_INT) EQL 0	!DID '10 INT' ASSERT?
9018		THEN
9019			BEGIN
9020			ERR(1);		!NO, REPORT ERROR
9021			ERFLG = -1;	!SET ERROR FLAG
9022			END;
9023	!*MESSAGE 1
9024	!*STIMULUS:
9025	!*	WRT 205/0		- NEGATE '10 INT'
9026	!*	WRT 205/1		- ASSERT '10 INT'
9027	!*RESPONSE:
9028	!*	'10 INT' DID NOT ASSERT.
9029	!]ERROR 1
9030	!]TEN_INT_LTCH TEN_INT NTWK
9031		IF FLP_CHK(1,FLP_PTR)
9032			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9033	
9034		WRT205(0);			!NEGATE '10 INT'
9035		IF (RD_301 AND TEN_INT) NEQ 0	!DID '10 INT' NEGATE?
9036		THEN
9037			BEGIN
9038			ERR(2);		!NO, REPORT ERROR
9039			ERFLG = -1;	!SET ERROR FLAG
9040			END;
9041	!*MESSAGE 2
9042	!*STIMULUS:
9043	!*	WRT 205/0		- NEGATE '10 INT'
9044	!*	WRT 205/1		- ASSERT '10 INT'
9045	!*	WRT 205/0		- NEGATE '10 INT'
9046	!*RESPONSE:
9047	!*	'10 INT' DID NOT NEGATE.
9048	!]ERROR 2
9049	!]TEN_INT_LTCH TEN_INT NTWK
9050		IF FLP_CHK(2,FLP_PTR)
9051			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9052		0				!TO PREVENT INFO MSG WHEN COMPILING
9053		END;
9054	
9055	!IF WE HAD NO ERRORS, THEN THE READ MUX IS OKAY.
9056	
9057		IF .ERFLG EQL 0
9058		THEN
9059			NOERR(1);
9060	!]NO ERROR 1
9061	!]TEN_INT NTWK
9062	
9063		END;
9064	
9065	GLOBAL ROUTINE TST88: NOVALUE =
9066	
9067	!THIS TEST CHECKS THAT THE '10 INT' FLOP ASSERTS WHEN 'DPMB CSL
9068	!INTERRUPT' ASSERTS.
9069	!IT THEN CHECKS THAT 'DP RESET' NEGATES 'DPMB CSL INTERRUPT'.
9070	
9071		BEGIN
9072		LABEL BLOCK1;
9073		BIND
9074			FLP_PTR1 = UPLIT(%ASCIZ'MR,X10,LR205,DR0,CP,RP'),
9075			FLP_PTR2 = UPLIT(%ASCIZ'LR204,DR4,DR0,RP');
9076		BIND
9077			UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(2000) U_SPEC_APRFLAGS U);
9078	
9079		MR();				!DO A MASTER RESET
9080		LOAD_U(0,UC_PTR);
9081		DO (0) WHILE
9082	BLOCK1:
9083		BEGIN
9084		MR();				!DO A MASTER RESET
9085		SET_C(0);			!SET NEXT ADDR TO 0
9086		WRT205(0);			!MAKE SURE '10 INT' IS NEGATED
9087		CP(1);				!EXECUTE THE MICRO-INSTR
9088		IF (RD_301 AND TEN_INT) EQL 0	!DID '10 INT' ASSERT?
9089		THEN
9090			ERR(1);		!NO, REPORT ERROR
9091	!*MESSAGE 1
9092	!*STIMULUS:
9093	!*	LOAD MICROINSTRUCTION AT LOC 0
9094	!*	MR		- DO A MASTER RESET
9095	!*	WRT 205/0	- MAKE SURE '10 INT' IS NEGATED.
9096	!*	CP 1		- EXECUTE THE MICRO-INSTRUCTION. THIS SHOULD
9097	!*			  CAUSE 'DPMB CSL INTERRUPT' TO ASSERT, WHICH
9098	!*			  IN TURN SHOULD CAUSE '10 INT' TO ASSERT.
9099	!*RESPONSE:
9100	!*	'10 INT' DID NOT ASSERT.
9101	!]ERROR 1
9102	!]TEN_INT_LTCH NTWK
9103		IF FLP_CHK(1,FLP_PTR1)
9104			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9105	
9106		WRT204(DP_RESET);		!ASSERT 'DP RESET'
9107		WRT204(0);			!NEGATE IT
9108		WRT205(0);			!TRY TO NEGATE '10 INT'
9109		IF (RD_301 AND TEN_INT) NEQ 0	!DID '10 INT' NEGATE?
9110		THEN
9111			ERR(2);		!NO, REPORT ERROR
9112	!*MESSAGE 2
9113	!*STIMULUS:
9114	!*	LOAD MICROINSTRUCTION AT LOC 0
9115	!*	MR		- DO A MASTER RESET
9116	!*	WRT 205/0	- MAKE SURE '10 INT' IS NEGATED.
9117	!*	CP 1		- EXECUTE THE MICRO-INSTRUCTION. THIS SHOULD
9118	!*			  CAUSE 'DPMB CSL INTERRUPT' TO ASSERT, WHICH
9119	!*			  IN TURN SHOULD CAUSE '10 INT' TO ASSERT.
9120	!*	WRT 204/4	- ASSERT 'DP RESET'.  THIS SHOULD NEGATE 'DPMB
9121	!*			  CSL INTERRUPT', THUS ALLOWING '10 INT' TO BE
9122	!*			  NEGATED.
9123	!*	WRT 204/0	- NEGATE 'DP RESET'
9124	!*	WRT 205/0	- NEGATE '10 INT'.
9125	!*RESPONSE:
9126	!*	'10 INT' DID NOT NEGATE.  THIS IMPLIES THAT 'DP RESET' DID NOT
9127	!*	NEGATE 'DPMB CSL INTERRUPT'.
9128	!]ERROR 2
9129	!]TEN_INT_LTCH DP_RESET NTWK
9130		IF FLP_CHK(2,FLP_PTR2)
9131			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9132		0				!TO PREVENT INFO MSG WHEN COMPILING
9133		END;
9134	
9135		END;
9136	
9137	GLOBAL ROUTINE TST89: NOVALUE =
9138	
9139	!THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
9140	!CORRECTLY.  SPECIFICALLY, THAT 'CRA/M CLK ENABLE' NEGATES AND 'DPE/M
9141	!CLK ENABLE' ASSERTS WHEN 'CRM2 MULTI SHIFT' AND 'FE SIGN' ARE ASSERTED.
9142	
9143		BEGIN
9144		LABEL BLOCK1;
9145		BIND
9146			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR206,DR2,DR2,RP');
9147	
9148		LOCAL
9149			TEMP;
9150		BIND
9151			UC_PTR = PLIT( U_J(1) U_T(0) U_LOADFE U_N(711000) U,
9152				   U_J(2) U_T(0) U_MULTI_SHIFT U);
9153	
9154		MR();				!DO A MASTER RESET
9155		LOAD_U(0,UC_PTR);		!LOAD 2 MICRO-INSTR
9156		DO (0) WHILE
9157	BLOCK1:
9158		BEGIN
9159		SET_C(0);			!SET NEXT ADDR TO 0
9160		INIT();					!DO A RESET
9161		SYNC_CLK();			!STOP CLK AND SYNC IT
9162		RESET_CRAM();				!CLEAR CRAM BITS
9163		WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
9164		CYCLE(4);			!EXECUTE 1ST MICRO-INSTR
9165		WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
9166		CYCLE(4);			!EXECUTE 2ND MICRO-INSTR
9167		TEMP = RD_303;			!READ STATES OF CLK ENABLES
9168		IF (.TEMP AND CR_CLK_ENB) NEQ 0	!IS 'CRA/M CLK ENABLE' NEGATED?
9169		THEN
9170			ERR(1);		!NO, REPORT ERROR
9171	!*MESSAGE 1
9172	!*STIMULUS:
9173	!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
9174	!*	ASSERT AND NEGATE 'RESET'
9175	!*	SET NEXT ADDRESS TO 0
9176	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9177	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9178	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
9179	!*			  THIS LOADS 'FE SIGN' WITH A 1.
9180	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9181	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
9182	!*			  THIS ASSERTS 'MULTI SHIFT'.'MULTI SHIFT' AND
9183	!*			  'FE SIGN' SHOULD ASSERT 'FS (1)'.  THIS WILL
9184	!*			  HOLD 'ENABLE (1)' ASSERTED AND CAUSE 'CRA/M
9185	!*			  CLK ENABLE' TO NEGATE WHILE 'DPE/M CLK ENABLE'
9186	!*			  IS ASSERTED.
9187	!*RESPONSE:
9188	!*	'CRA/M CLK ENABLE' DIDN'T NEGATE.
9189	!]ERROR 1
9190	!]SHFT_LOGIC NTWK
9191		IF FLP_CHK(1,FLP_PTR)
9192			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9193	
9194		IF (.TEMP AND DP_CLK_ENBL) NEQ 0	!DID 'DPE/M CLK ENABLE' ASSERT?
9195		THEN
9196			ERR(2);		!NO, REPORT ERROR
9197	!*MESSAGE 2
9198	!*STIMULUS:
9199	!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
9200	!*	ASSERT AND NEGATE 'RESET'
9201	!*	SET NEXT ADDRESS TO 0
9202	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9203	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9204	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
9205	!*			  THIS LOADS 'FE SIGN' WITH A 1.
9206	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9207	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
9208	!*			  THIS ASSERTS 'MULTI SHIFT'.'MULTI SHIFT' AND
9209	!*			  'FE SIGN' SHOULD ASSERT 'FS (1)'.  THIS WILL
9210	!*			  HOLD 'ENABLE (1)' ASSERTED AND CAUSE 'CRA/M
9211	!*			  CLK ENABLE' TO NEGATE WHILE 'DPE/M CLK ENABLE'
9212	!*			  IS ASSERTED.
9213	!*RESPONSE:
9214	!*	'DPE/M CLK ENABLE' DIDN'T STAY ASSERTED.
9215	!]ERROR 2
9216	!]SHFT_LOGIC NTWK
9217		IF FLP_CHK(2,FLP_PTR)
9218			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9219		0				!TO PREVENT INFO MSG WHEN COMPILING
9220		END;
9221		MR();				!DO A MASTER RESET
9222	
9223		END;
9224	
9225	GLOBAL ROUTINE TST90: NOVALUE =
9226	
9227	!THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
9228	!CORRECTLY.  SPECIFICALLY, THAT 'DPE/M CLK ENABLE' NEGATES AND 'CRA/M
9229	!CLK ENABLE' ASSERTS WHEN 'CRM2 MULTI SHIFT' IS ASSERTED AND 'FE SIGN'
9230	!IS NEGATED.
9231	
9232		BEGIN
9233		LABEL BLOCK1;
9234		BIND
9235			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR206,DR2,DR2,RP');
9236	
9237		LOCAL
9238			TEMP;
9239		BIND
9240			UC_PTR = PLIT( U_J(1) U_T(0) U_LOADFE U_N(710000) U,
9241				   U_J(2) U_T(0) U_MULTI_SHIFT U);
9242	
9243		MR();				!DO A MASTER RESET
9244		LOAD_U(0,UC_PTR);		!LOAD 2 MICRO-INSTR
9245		DO (0) WHILE
9246	BLOCK1:
9247		BEGIN
9248		SET_C(0);				!SET CRAM START ADDR TO ZERO
9249		INIT();					!DO A RESET
9250		SYNC_CLK();			!STOP CLK AND SYNC IT
9251		RESET_CRAM();				!CLEAR CRAM BITS
9252		WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
9253		CYCLE(4);			!EXECUTE 1ST MICRO-INSTR
9254		WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
9255		TICK(9);			!GENERATE 9 T-CLK/R-CLKS
9256		TEMP = RD_303;			!READ STATES OF CLK ENABLES
9257		IF (.TEMP AND CR_CLK_ENB) EQL 0	!IS 'CRA/M CLK ENABLE' ASSERTED?
9258		THEN
9259			ERR(2);		!NO, REPORT ERROR
9260	!*MESSAGE 1
9261	!*STIMULUS:
9262	!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
9263	!*	ASSERT AND NEGATE 'RESET'
9264	!*	SET NEXT ADDRESS TO 0
9265	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9266	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9267	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
9268	!*			  THIS LOADS 'FE SIGN' WITH A 0.
9269	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9270	!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
9271	!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
9272	!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
9273	!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
9274	!*RESPONSE:
9275	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
9276	!]ERROR 1
9277	!]SHFT_LOGIC NTWK
9278		IF FLP_CHK(1,FLP_PTR)
9279			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9280	
9281		IF (.TEMP AND DP_CLK_ENBL) EQL 0	!DID 'DPE/M CLK ENABLE' NEGATE?
9282		THEN
9283			ERR(2);		!NO, REPORT ERROR
9284	!*MESSAGE 2
9285	!*STIMULUS:
9286	!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
9287	!*	ASSERT AND NEGATE 'RESET'
9288	!*	SET NEXT ADDRESS TO 0
9289	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9290	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9291	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
9292	!*			  THIS LOADS 'FE SIGN' WITH A 0.
9293	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9294	!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
9295	!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
9296	!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
9297	!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
9298	!*RESPONSE:
9299	!*	'DPE/M CLK ENABLE' DIDN'T NEGATE.
9300	!]ERROR 2
9301	!]SHFT_LOGIC NTWK
9302		IF FLP_CHK(2,FLP_PTR)
9303			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9304		0				!TO PREVENT INFO MSG WHEN COMPILING
9305		END;
9306		MR();				!DO A MASTER RESET
9307	
9308		END;
9309	
9310	GLOBAL ROUTINE TST91: NOVALUE =
9311	
9312	!THIS TEST CHECKS THAT THE FAST SHIFTING CONTROL LOGIC FUNCTIONS
9313	!CORRECTLY.  SPECIFICALLY, THAT 'DPE/M CLK ENABLE' AND 'CRA/M CLK
9314	!ENABLE' ASSERT WHEN 'CRM2 MULTI SHIFT' IS NEGATED AND 'FE SIGN' IS
9315	!ASSERTED.
9316	
9317		BEGIN
9318		LABEL BLOCK1;
9319		BIND
9320			FLP_PTR = UPLIT(%ASCIZ'LR100,DR200,DR0,LR206,DR2,DR2,RP');
9321	
9322		LOCAL
9323			TEMP;
9324		BIND
9325			UC_PTR = PLIT( U_J(1) U_T(0) U_LOADFE U_N(7110000) U,
9326				   U_J(2) U_T(0) U);
9327	
9328		MR();				!DO A MASTER RESET
9329		LOAD_U(0,UC_PTR);		!LOAD 2 MICRO-INSTR
9330		DO (0) WHILE
9331	BLOCK1:
9332		BEGIN
9333		SET_C(0);				!SET CRAM START ADDR TO ZERO
9334		INIT();					!DO A RESET
9335		SYNC_CLK();			!STOP CLK AND SYNC IT
9336		RESET_CRAM();				!CLEAR CRAM BITS
9337		WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
9338		CYCLE(4);			!EXECUTE 1ST MICRO-INSTR
9339		WRT206(SINGLE_CLK);		!ASSERT 'SINGLE CLK'
9340		TICK(9);			!GENERATE 9 T-CLK/R-CLKS
9341		TEMP = RD_303;			!READ STATES OF CLK ENABLES
9342		IF (.TEMP AND CR_CLK_ENB) EQL 0	!IS 'CRA/M CLK ENABLE' ASSERTED?
9343		THEN
9344			ERR(1);		!NO, REPORT ERROR
9345	!*MESSAGE 1
9346	!*STIMULUS:
9347	!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
9348	!*	ASSERT AND NEGATE 'RESET'
9349	!*	SET NEXT ADDRESS TO 0
9350	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9351	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9352	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
9353	!*			  THIS LOADS 'FE SIGN' WITH A 1.
9354	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9355	!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
9356	!*			  WITH 'MULTI SHIFT' NEGATED, 'CRA/M CLK ENABLE'
9357	!*			  AND 'DPE/M CLK ENABLE' SHOULD BOTH ASSERT.
9358	!*RESPONSE:
9359	!*	'CRA/M CLK ENABLE' DIDN'T ASSERT.
9360	!]ERROR 1
9361	!]SHFT_LOGIC NTWK
9362		IF FLP_CHK(1,FLP_PTR)
9363			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9364	
9365		IF (.TEMP AND DP_CLK_ENBL) NEQ 0	!DID 'DPE/M CLK ENABLE' ASSERT?
9366		THEN
9367			ERR(2);		!NO, REPORT ERROR
9368	!*MESSAGE 2
9369	!*STIMULUS:
9370	!*	LOAD 2 MICRO-INSTRUCTIONS AT LOC 0
9371	!*	ASSERT AND NEGATE 'RESET'
9372	!*	SET NEXT ADDRESS TO 0
9373	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9374	!*	GENERATE 4 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 0.
9375	!*			  THIS LOADS 'FE SIGN' WITH A 1.
9376	!*	WRT 206/2	- ASSERT 'SINGLE CLK'
9377	!*	GENERATE 2 T-CLK/R-CLK CYCLES - THIS EXECUTES MICRO-INSTR AT 1.
9378	!*			  THIS ASSERTS 'MULTI SHIFT'.  WITH 'FE SIGN'
9379	!*			  NEGATED, 'CRA/M CLK ENABLE' SHOULD ASSERT AND
9380	!*			  'DPE/M CLK ENABLE' SHOULD NEGATE.
9381	!*RESPONSE:
9382	!*	'DPE/M CLK ENABLE' DIDN'T ASSERT.
9383	!]ERROR 2
9384	!]SHFT_LOGIC NTWK
9385		IF FLP_CHK(2,FLP_PTR)
9386			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9387		0				!TO PREVENT INFO MSG WHEN COMPILING
9388		END;
9389		MR();				!DO A MASTER RESET
9390	
9391		END;
9392	
9393	GLOBAL ROUTINE TST92: NOVALUE =
9394	
9395	!THIS TEST CHECKS THAT DOING AN 'EM' COMMAND DOES NOT GIVE A 'NXM'
9396	!ERROR.
9397	
9398		BEGIN
9399		LABEL BLOCK1;
9400	
9401		MR();				!DO A MASTER RESET
9402		DO (0) WHILE
9403	BLOCK1:
9404		BEGIN
9405		EM_CHK(0);			!EXAMINE MEM LOC 0
9406		IF (RD_301 AND NEXM) NEQ 0	!IS 'NEXM' NEGATED?
9407		THEN
9408			ERR(1);		!NO, REPORT ERROR
9409	!*MESSAGE 1
9410	!*STIMULUS:
9411	!*	EM 0		- EXAMINE MEMORY LOCATION 0. SHOULD NOT GET
9412	!*			  A 'NEXM' ERROR.
9413	!*RESPONSE:
9414	!*	'NEXM' ASSERTED.
9415	!]ERROR 1
9416	!]MEM_BUSY NTWK
9417		IF LOOP_CHK(1)
9418			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9419		0				!TO PREVENT INFO MSG WHEN COMPILING
9420		END;
9421		WRT114(0);			!MAKE SURE 'NEXM' CLEARS.
9422		WRT115(0);			!MAKE SURE 'COM/ADR' IS CLEARED
9423	
9424		END;
9425	
9426	GLOBAL ROUTINE TST93: NOVALUE =
9427	
9428	!THIS TEST CHECKS THAT THE 'CSL4 INT 10' SIGNAL ASSERTS AND NEGATES
9429	!CORRECTLY AND THAT THE 'PI REQ 1-7' SIGNALS CAN BE READ CORRECTLY.
9430	!THE ASSERTION OF 'INT 10' IS INFERRED BY THE ASSERTION OF A 'PI REQ'
9431	!SIGNAL.  FOUR MICROINSTRUCTIONS ARE EXECUTED TO ACCOMPLISH THIS.
9432	
9433		BEGIN
9434		LABEL BLOCK1;
9435		BIND
9436			FLP_PTR1 = UPLIT(%ASCIZ'MR,X10,LR116,DR1,CP2,RP'),
9437			FLP_PTR2 = UPLIT(%ASCIZ'MR,X10,LR116,DR1,CP4,RP');
9438		BIND
9439			UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0  U_DBUS_DBM U_N(21) U_SPEC_APR_EN U,
9440					U_J(2) U,
9441					U_J(3) U,
9442					U_J(0) U_SPEC_APRFLAGS U);
9443		OWN
9444			PI_MASK: VECTOR[7] INITIAL (200,100,40,20,10,4,2);
9445	
9446		MR();				!DO A MASTER RESET
9447		LOAD_U(0,UC_PTR);
9448		INCR PI_REQ FROM 1 TO 7 BY 1
9449		DO
9450			DO (0) WHILE
9451	BLOCK1:
9452			BEGIN
9453			MR();			!DO A MASTER RESET
9454			LC(0);			!SET CRAM ADDRESS = 0
9455			MOD_FLD(3,%O'20' + .PI_REQ); !SETUP MAGIC # FIELD
9456			WRT116(CSL_INT);	!ASSERT 'INT 10' PRE-FLOP
9457			CP(2);			!EXECUTE THE 2 MICRO-INSTRS
9458			IF (RD_101 AND .PI_MASK[.PI_REQ-1]) EQL 0 !DID CORRECT PI REQ BIT ASSERT?
9459			THEN
9460				ERRS(.PI_REQ,1,PI_REQ);		!NO
9461	!*MESSAGE 1
9462	!*STIMULUS:
9463	!*	LOAD 4 MICRO-INSTRUCTIONS STARTING AT LOC 0
9464	!*	MR		- DO A MASTER RESET
9465	!*	LC 0		- SET CRAM ADDRESS = 0
9466	!*	LF3		- SET DIAG FN TO MODIFY MAGIC # FIELD
9467	!*	DF 2\O0		- SET MAGIC # TO ENABLE APR FLAG 31 AND TO
9468	!*			  SELECT PI REQ \O0.
9469	!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
9470	!*	CP 2		- EXECUTE THE 2 MICRO-INSTRUCTIONS. THIS SHOULD
9471	!*			  CAUSE 'INT 10' TO ASSERT WHICH WILL CAUSE
9472	!*			  'DPMB APR FLAG 31' TO ASSERT.  THIS IN TURN
9473	!*			  ASSERTS 'DPMB APR INT REQ' WHICH CAUSES 'BUS
9474	!*			  PI REQ \O0' TO ASSERT.
9475	!*RESPONSE:
9476	!*	'BUS PI REQ \O0' DID NOT ASSERT.
9477	!]ERROR 1
9478	!]PI_REQ1 INT_10 WRT116 NTWK
9479	!]ERROR 2
9480	!]PI_REQ2 INT_10 WRT116 NTWK
9481	!]ERROR 3
9482	!]PI_REQ3 INT_10 WRT116 NTWK
9483	!]ERROR 4
9484	!]PI_REQ4 INT_10 WRT116 NTWK
9485	!]ERROR 5
9486	!]PI_REQ5 INT_10 WRT116 NTWK
9487	!]ERROR 6
9488	!]PI_REQ6 INT_10 WRT116 NTWK
9489	!]ERROR 7
9490	!]PI_REQ7 INT_10 WRT116 NTWK
9491			IF FLP_CHK(1,FLP_PTR1)
9492			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9493	
9494			CP(2);			!EXECUTE THE NEXT 2 MICRO-INSTRS
9495			IF (RD_101 AND .PI_MASK[.PI_REQ-1]) NEQ 0 !DID CORRECT PI REQ BIT NEGATE?
9496			THEN
9497				ERRS(.PI_REQ+7,2,PI_REQ);		!NO
9498	!*MESSAGE 2
9499	!*STIMULUS:
9500	!*	LOAD 4 MICRO-INSTRUCTIONS STARTING AT LOC 0
9501	!*	MR		- DO A MASTER RESET
9502	!*	LC 0		- SET CRAM ADDRESS = 0
9503	!*	LF3		- SET DIAG FN TO MODIFY MAGIC # FIELD
9504	!*	DF 2\O0		- SET MAGIC # TO ENABLE APR FLAG 31 AND TO
9505	!*			  SELECT PI REQ \O0.
9506	!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
9507	!*	CP 4		- EXECUTE THE 4 MICRO-INSTRUCTIONS. THIS SHOULD
9508	!*			  CAUSE 'INT 10' TO ASSERT WHICH WILL CAUSE
9509	!*			  'DPMB APR FLAG 31' TO ASSERT.  THIS IN TURN
9510	!*			  ASSERTS 'DPMB APR INT REQ' WHICH CAUSES 'BUS
9511	!*			  PI REQ \O0' TO ASSERT. THE 4TH CLOCK PULSE
9512	!*			  SHOULD NEGATE 'INT 10' WHICH WILL ALLOW THE
9513	!*			  4TH MICRO-INSTR TO NEGATE 'DPMB APR FLAG 31'.
9514	!*			  THIS WILL NEGATE 'PI REQ \O0'.
9515	!*RESPONSE:
9516	!*	'PI REQ \O0' DID NOT NEGATE.
9517	!]ERROR 8
9518	!]PI_REQ1 INT_10 WRT116 NTWK
9519	!]ERROR 9
9520	!]PI_REQ2 INT_10 WRT116 NTWK
9521	!]ERROR 10
9522	!]PI_REQ3 INT_10 WRT116 NTWK
9523	!]ERROR 11
9524	!]PI_REQ4 INT_10 WRT116 NTWK
9525	!]ERROR 12
9526	!]PI_REQ5 INT_10 WRT116 NTWK
9527	!]ERROR 13
9528	!]PI_REQ6 INT_10 WRT116 NTWK
9529	!]ERROR 14
9530	!]PI_REQ7 INT_10 WRT116 NTWK
9531			IF FLP_CHK(2,FLP_PTR2)
9532			THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9533		0				!TO PREVENT INFO MSG WHEN COMPILING
9534			END;
9535		MR();
9536	
9537		END;
9538	
9539	GLOBAL ROUTINE TST94: NOVALUE =
9540	
9541	!THIS TEST CHECKS THAT 'RESET L' SIGNAL NEGATES THE 2ND-STAGE CONTROL
9542	!FLOP FOR THE 'INT 10' SIGNAL. THIS IS DONE BY ASSERTING THE 1ST STAGE
9543	!FLOP AND GENERATING ONE CLOCK PULSE TO ASSERT THE 2ND-STAGE FLOP.
9544	!THEN A RESET IS DONE.  ANOTHER CLOCK PULSE IS GENERATED.  IF THE 2ND
9545	!STAGE FLOP NEGATED, 'PI REQ 1' WILL NOT ASSERT.
9546	
9547		BEGIN
9548		LABEL BLOCK1;
9549		BIND
9550			FLP_PTR = UPLIT(%ASCIZ'MR,X10,LR116,DR1,CP1,LR100,DR200,DR0,CP1,RP');
9551		BIND
9552			UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0  U_DBUS_DBM U_N(21) U_SPEC_APR_EN U,
9553					U_J(2) U);
9554	
9555		MR();				!DO A MASTER RESET
9556		LOAD_U(0,UC_PTR);
9557		DO (0) WHILE
9558	BLOCK1:
9559		BEGIN
9560		MR();			!DO A MASTER RESET
9561		LC(0);			!SET CRAM ADDRESS = 0
9562		WRT116(CSL_INT);	!ASSERT 'INT 10' PRE-FLOP
9563		CP(1);			!EXECUTE 1 MICRO-INSTR
9564		INIT();			!ASSERT AND NEGATE 'RESET'
9565		CP(1);			!EXECUTE THE 2ND MICRO-INSTR
9566		IF (RD_101 AND PI_REQ_1) NEQ 0 !DID PI REQ BIT STAY NEGATED?
9567			THEN
9568				ERR(1);		!NO
9569	!*MESSAGE 1
9570	!*STIMULUS:
9571	!*	LOAD 2 MICRO-INSTRUCTIONS STARTING AT LOC 0
9572	!*	MR		- DO A MASTER RESET
9573	!*	LC 0		- SET CRAM ADDRESS = 0
9574	!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
9575	!*	CP 1		- EXECUTE 1 MICRO-INSTRUCTION. THIS SHOULD
9576	!*			  CAUSE THE 2ND-STAGE FLOP TO ASSERT AND SETUP
9577	!*			  THE CPU SO THAT 'INT 10' WILL CAUSE A PI REQ.
9578	!*	WRT 100/200	- ASSERT 'RESET'. THIS SHOULD NEGATE 2ND-STAGE
9579	!*			  FLOP.
9580	!*	WRT 100/0	- NEGATE 'RESET'
9581	!*	CP 1		- EXECUTE THE 2ND MICRO-INSTRUCTION.  SINCE THE
9582	!*			  2ND-STAGE FLOP IS NEGATED, 'INT 10' SHOULD NOT
9583	!*			  ASSERT AND 'PI REQ 1' SHOULD NOT ASSERT.
9584	!*RESPONSE:
9585	!*	'PI REQ 1' ASSERTED.
9586	!]ERROR 1
9587	!]INT_10 PI_REQ1 NTWK
9588		IF FLP_CHK(1,FLP_PTR)
9589		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9590		0				!TO PREVENT INFO MSG WHEN COMPILING
9591	
9592		END;
9593		MR();
9594	
9595		END;
9596	
9597	GLOBAL ROUTINE TST95: NOVALUE =
9598	
9599	!THIS TEST CHECKS THAT THE 1ST-STAGE CONTROL FLOP FOR THE 'INT 10'
9600	! SIGNAL CAN BE NEGATED BY WRITING A ZERO INTO BIT 0 OF 8080 REGISTER
9601	! 116.
9602	!THE FLOP IS FIRST ASSERTED THEN NEGATED. THEN 2 MICRO-INSTRUCTIONS
9603	!ARE EXECUTED.  IF THE FLOP NEGATED CORRECTLY, 'PI REQ 1' WILL NOT
9604	!ASSERT. IF THE FLOP DID NOT NEGATE, 'PI REQ 1' WILL ASSERT.
9605	
9606		BEGIN
9607		LABEL BLOCK1;
9608		BIND
9609			FLP_PTR = UPLIT(%ASCIZ'MR,X10,LR116,DR1,DR0,CP2,RP');
9610		BIND
9611			UC_PTR = PLIT( U_J(1) U_ALU_OR U_RSRC_D0  U_DBUS_DBM U_N(21) U_SPEC_APR_EN U,
9612					U_J(2) U);
9613	
9614		MR();				!DO A MASTER RESET
9615		LOAD_U(0,UC_PTR);
9616		DO (0) WHILE
9617	BLOCK1:
9618		BEGIN
9619		MR();			!DO A MASTER RESET
9620		LC(0);			!SET CRAM ADDRESS = 0
9621		WRT116(CSL_INT);	!ASSERT 'INT 10' PRE-FLOP
9622		WRT116(0);		!NEGATE 'INT 10' PRE-FLOP
9623		CP(2);			!EXECUTE 2 MICRO-INSTR
9624		IF (RD_101 AND PI_REQ_1) NEQ 0 !DID PI REQ BIT STAY NEGATED?
9625			THEN
9626				ERR(1);		!NO
9627	!*MESSAGE 1
9628	!*STIMULUS:
9629	!*	LOAD 2 MICRO-INSTRUCTIONS STARTING AT LOC 0
9630	!*	MR		- DO A MASTER RESET
9631	!*	LC 0		- SET CRAM ADDRESS = 0
9632	!*	WRT 116/1	- ASSERT 'INT 10' PRE-FLOP.
9633	!*	WRT 116/0	- NEGATE 'INT 10' PRE-FLOP
9634	!*	CP 2		- EXECUTE THE 2 MICRO-INSTRUCTIONS.  SINCE FLOP
9635	!*			  IS NEGATED, 'INT 10' SHOULD NOT ASSERT
9636	!*			  AND 'PI REQ 1' SHOULD NOT ASSERT.
9637	!*RESPONSE:
9638	!*	'PI REQ 1' ASSERTED.
9639	!]ERROR 1
9640	!]PI_REQ1 INT_10 NTWK
9641		IF FLP_CHK(1,FLP_PTR)
9642		THEN LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9643		0				!TO PREVENT INFO MSG WHEN COMPILING
9644	
9645		END;
9646		MR();
9647	
9648		END;
9649	
9650	GLOBAL ROUTINE TST96: NOVALUE =
9651	
9652	!THIS TESTS VERIFIES THAT A 'PAGE FAIL' WILL CAUSE 'ENABLE (1)' TO
9653	!ASSERT PRE-EMPTIVELY.  IT SHOULD ALSO CAUSE 'CRA/M CLK ENABLE' TO
9654	!ASSERT WHILE 'DPE/M CLK ENABLE' STAYS NEGATED.
9655	
9656		BEGIN
9657		LABEL BLOCK1,ERBLK1;
9658		BIND
9659			UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
9660					U_J(2) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
9661					U_J(3) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
9662					U_J(4) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(403010) U_SPEC_LDPAGE U,
9663					U_J(5) U,
9664					U_J(6) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(432012) U,
9665					U_J(0) U_MEM U_N(2) U),
9666			UC_PTR1 = PLIT(U_J(0) U_SPEC_MEMCLR U);
9667		LOCAL
9668			ACTUAL;
9669	
9670		MR();				!DO A MASTER RESET
9671		LOAD_U(0,UC_PTR);	!LOAD MICROCODE FOR PAGE FAIL
9672		DO (0) WHILE
9673	BLOCK1:
9674		BEGIN
9675		MR();				!DO A MASTER RESET
9676		SET_C(0);				!SET CRAM START ADDR TO ZERO
9677		INIT();					!DO A RESET
9678		SYNC_CLK();		!GO STOP CLOCK AND SYNC IT
9679		RESET_CRAM();				!CLEAR CRAM BITS
9680		WRT206(SINGLE_CLK);	!ASSERT 'SINGLE CLK'
9681		CYCLE(3);		!CLOCK CRAM BITS INTO LATCHES
9682		WRT206(CLK_RUN);	!ASSERT 'CLK RUN'
9683		CYCLE(33);		!GENERATE ENOUGH T-CLK CYCLES TO CAUSE PAGE FAILURE
9684		ACTUAL = RD_303 AND 6;		!READ ENABLE STATUS
9685		IF .ACTUAL EQL 0		!ARE ENABLES COMPLEMENTED?
9686		THEN
9687			ERR(1);		!YES, REPORT ERROR
9688	!*MESSAGE 1
9689	!*STIMULUS:
9690	!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP
9691	!*	X1 0		- SET CRAM ADDR = 0.
9692	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9693	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
9694	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS TOGGLES 'ENABLE (1)' WHICH
9695	!*		RESETS ALL THE CPU CONTROL FLOPS AND LATCHES THE CRAM
9696	!*		BITS FOR THE 1ST MICRO-INSTR.
9697	!*	WRT 206/1	- ASSERT  'CLK RUN'.
9698	!*	GENERATE 33 T-CLK/R-CLK CYCLES -
9699	!*		  THE FIRST 5 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
9700	!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
9701	!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
9702	!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
9703	!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD
9704	!*		  CAUSE 'CRA/M CLK ENABLE' TO ASSERT WHILE 'DPE/M CLK
9705	!*		  ENABLE' IS NEGATED.
9706	!*RESPONSE:
9707	!*	'CRA/M CLK ENABLE' DID NOT ASSERT AND 'DPE/M CLK ENABLE' DID NOT
9708	!*	NEGATE.
9709	!]ERROR 1
9710	!]PF_1 PF_ST_1 ENB NTWK
9711		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
9712		THEN
9713			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9714	
9715		IF .ACTUAL EQL 4		!DID 'DPE/M CLK ENABLE' NEGATE?
9716		THEN
9717			ERR(2);		!NO, REPORT ERROR
9718	!*MESSAGE 2
9719	!*STIMULUS:
9720	!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP
9721	!*	X1 0		- SET CRAM ADDR = 0.
9722	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9723	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
9724	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS TOGGLES 'ENABLE (1)' WHICH
9725	!*		RESETS ALL THE CPU CONTROL FLOPS AND LATCHES THE CRAM
9726	!*		BITS FOR THE 1ST MICRO-INSTR.
9727	!*	WRT 206/1	- ASSERT  'CLK RUN'.
9728	!*	GENERATE 33 T-CLK/R-CLK CYCLES -
9729	!*		  THE FIRST 3 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
9730	!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
9731	!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
9732	!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
9733	!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD
9734	!*		  CAUSE 'CRA/M CLK ENABLE' TO ASSERT WHILE 'DPE/M CLK
9735	!*		  ENABLE' IS NEGATED.
9736	!*RESPONSE:
9737	!*	'CRA/M CLK ENABLE' ASSERTED BUT 'DPE/M CLK ENABLE' DIDN'T
9738	!*	NEGATE.
9739	!]ERROR 2
9740	!]PF_1 PF_ST_1 ENB NTWK
9741		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
9742		THEN
9743			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9744		IF .ACTUAL EQL 2		!DID 'CRA/M CLK ENABLE' ASSERT?
9745		THEN
9746			ERR(3);		!NO, REPORT ERROR
9747	!*MESSAGE 3
9748	!*STIMULUS:
9749	!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP
9750	!*	X1 0		- SET CRAM ADDR = 0.
9751	!*	STOP CLOCK AND SYNC IT SO T-CLK AND R-CLK ARE NEGATED.
9752	!*	WRT 206/2	- ASSERT 'SINGLE CLK'.
9753	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS TOGGLES 'ENABLE (1)' WHICH
9754	!*		RESETS ALL THE CPU CONTROL FLOPS AND LATCHES THE CRAM
9755	!*		BITS FOR THE 1ST MICRO-INSTR.
9756	!*	WRT 206/1	- ASSERT  'CLK RUN'.
9757	!*	GENERATE 33 T-CLK/R-CLK CYCLES -
9758	!*		  THE FIRST 3 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
9759	!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
9760	!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
9761	!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
9762	!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD
9763	!*		  CAUSE 'CRA/M CLK ENABLE' TO ASSERT WHILE 'DPE/M CLK
9764	!*		  ENABLE' IS NEGATED.
9765	!*RESPONSE:
9766	!*	'DPE/M CLK ENABLE' NEGATED BUT 'CRA/M CLK ENABLE' DIDN'T ASSERT.
9767	!]ERROR 3
9768	!]PF_1 PF_ST_1 ENB NTWK
9769		IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
9770		THEN
9771			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9772		0				!TO PREVENT INFO MSG WHEN COMPILING
9773	
9774		END;
9775		MR();				!DO A MASTER RESET
9776		LOAD_U(0,UC_PTR1);	!LOAD MEM CLR INSTR
9777		CP_NOSS(3);		!EXECUTE INSTR TO CLEAR PAGE FAULT
9778		SEND_NUL();
9779	
9780		END;
9781	
9782	GLOBAL ROUTINE TST97: NOVALUE =
9783	
9784	!THIS TEST CHECKS THAT THE 'TRAP EN' SIGNAL CAN BE ASSERTED AND NEGATED
9785	!CORRECTLY.
9786	!THIS IS DONE BY DOING A 'TRAP CYCLE' SKIP MICROSEQUENCE.  WITH 'TRAP
9787	!EN' ASSERTED, THE SKIP SHOULD OCCUR.  WITH IT NEGATED, THE SKIP SHOULD
9788	!NOT OCCUR.
9789	
9790		BEGIN
9791		LABEL BLOCK1,BLOCK2;
9792		BIND
9793			UC_PTR = PLIT(U_J(1) U_N(20000) U_SPEC_APR_EN U_DBUS_DBM U_ALU_OR U_RSRC_D0 U,
9794					U_J(2) U_N(1000) U_SPEC_FLAGS U,
9795					U_J(3) U_SPEC_NICOND U,
9796					U_J(3776) U_SKIP_TRAP_CYC U);
9797		LOCAL
9798			ACTUAL;
9799	
9800		MR();				!DO A MASTER RESET
9801		LOAD_U(0,UC_PTR);	!LOAD MICRO-INSTR
9802		DO (0) WHILE
9803	BLOCK1:
9804		BEGIN
9805		TP(1);			!ASSERT 'CSL4 TRAP EN'
9806		SET_C(0);		!SET CRAM ADDR TO 0
9807		ACTUAL = STEP_U_NEXT(4);	!EXECUTE NICOND SKIP AND READ NEXT ADDR
9808		IF .ACTUAL NEQ %O'3777'		!DID WE SKIP CORRECTLY?
9809		THEN
9810			ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
9811	!*MESSAGE 1
9812	!*STIMULUS:
9813	!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1' AND DO A TRAP CYCLE SKIP
9814	!*		TO 3776.
9815	!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
9816	!*	X1 0		- SET NEXT CRAM ADDR TO 0.
9817	!*	CP 4		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
9818	!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
9819	!*			  'DPE9 TRAP 1'.  THE 3RD INSTR ASSERTS 'SPEC/
9820	!*			  NICOND' WHICH SHOULD ASSERT 'TRAP CYCLE'.
9821	!*			  THE 4TH INSTR DOES A TRAP CYCLE SKIP.
9822	!*RESPONSE:
9823	!*	THE NEXT CRAM ADDR DID NOT SKIP TO 3777. THIS IMPLIES THAT
9824	!*	'TRAP EN' DID NOT ASSERT.
9825	!]ERROR 1
9826	!]TRAP_EN NTWK
9827		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
9828		THEN
9829			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9830		0				!TO PREVENT INFO MSG WHEN COMPILING
9831		END;
9832	
9833		DO (0) WHILE
9834	BLOCK2:
9835		BEGIN
9836		TP(0);			!TURN OFF TRAP ENABLES
9837		SET_C(2);		!SET CRAM ADDR TO 2
9838		ACTUAL = STEP_U_NEXT(2);	!EXECUTE TRAP CYCLE SKIP AND READ NEXT ADDR
9839		IF .ACTUAL NEQ %O'3776'		!DID WE DISPATCH CORRECTLY?
9840		THEN
9841			ERRCA(2,%O'3776',.ACTUAL,4);	!NO, REPORT ERROR
9842	!*MESSAGE 2
9843	!*STIMULUS:
9844	!*	LOAD MICRO-INSTR TO ASSERT 'SPEC/NICOND' AND DO A TRAP CYCLE
9845	!*		SKIP TO 3776.
9846	!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
9847	!*			  'DPE9 TRAP 1,2 AND 3'.
9848	!*	X1 3		- SET NEXT CRAM ADDR TO 3.
9849	!*	CP 2		- THE 1ST INSTR WILL ASSERT 'SPEC/NICOND'. WITH
9850	!*			  ALL TRAPS NEGATED, 'NICOND 9' IS ASSERTED. SO
9851	!*			  'TRAP CYCLE' WILL BE NEGATED. WITH 'TRAP
9852	!*			  CYCLE' NEGATED, THE 2ND INSTR WHICH DOES A
9853	!*			  TRAP CYCLE SKIP, SHOULD NOT SKIP.
9854	!*RESPONSE:
9855	!*	THE NEXT CRAM ADDR DID SKIP TO 3777. THIS IMPLIES THAT THE
9856	!*	'TRAP EN' SIGNAL DID NOT NEGATE.
9857	!]ERROR 2
9858	!]TRAP_EN NTWK
9859		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
9860		THEN
9861			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
9862		0				!TO PREVENT INFO MSG WHEN COMPILING
9863		END;
9864	
9865		END;
9866	
9867	GLOBAL ROUTINE TST98: NOVALUE =
9868	
9869	!THIS TEST CHECKS THAT THE 'EXECUTE' SIGNAL IS BUFFERED CORRECTLY ONTO
9870	!THE CRA BOARD.
9871	!TO DO THIS, A CONSOLE EXECUTE MODE SKIP IS EXECUTED. WITH THE 'EXECUTE'
9872	!SIGNAL ASSERTED, THE MICRO-CODE SHOULD SKIP.  WITH IT NEGATED, THE
9873	!MICRO-CODE SHOULD NOT SKIP.
9874	
9875		BEGIN
9876		LABEL BLOCK1,BLOCK2;
9877		BIND
9878			UC_PTR = PLIT(U_J(3776) U_SKIP_EXECUTE U);
9879		LOCAL
9880			ACTUAL;
9881	
9882		MR();				!DO A MASTER RESET
9883		LOAD_U(0,UC_PTR);	!LOAD MICROCODE
9884		DO (0) WHILE
9885	BLOCK1:
9886		BEGIN
9887		WRT212(EXECUTE);	!ASSERT 'EXECUTE' PRE-FLOP
9888		CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'EXECUTE'
9889		SET_C(0);		!SET CRAM ADDR TO 0
9890		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
9891		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
9892		THEN
9893			ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
9894	!*MESSAGE 1
9895	!*STIMULUS:
9896	!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
9897	!*	WRT 212/2	- ASSERT 'EXECUTE' PRE-FLOP
9898	!*	CP 1		- ASSERT 'EXECUTE'
9899	!*	X1 0		- SET CRAM ADDR TO 0
9900	!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
9901	!*RESPONSE:
9902	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777. THIS IMPLIES THAT
9903	!*	THE 'EXECUTE' SIGNAL DID NOT ASSERT ON THE CRA BOARD.
9904	!]ERROR 1
9905	!]EXEC_DRVR NTWK
9906		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
9907		THEN
9908			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9909		0				!TO PREVENT INFO MSG WHEN COMPILING
9910		END;
9911	
9912		DO (0) WHILE
9913	BLOCK2:
9914		BEGIN
9915		WRT212(0);		!NEGATE 'EXECUTE' PRE-FLOP
9916		CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'EXECUTE'
9917		SET_C(0);		!SET CRAM ADDR TO 0
9918		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
9919		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
9920		THEN
9921			ERRCA(2,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
9922	!*MESSAGE 2
9923	!*STIMULUS:
9924	!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
9925	!*	WRT 212/0	- NEGATE 'EXECUTE' PRE-FLOP
9926	!*	CP 1		- NEGATE 'EXECUTE'
9927	!*	X1 0		- SET CRAM ADDR TO 0
9928	!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
9929	!*RESPONSE:
9930	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777. THIS IMPLIES THAT
9931	!*	THE 'EXECUTE' SIGNAL DID NOT NEGATE ON THE CRA BOARD.
9932	!]ERROR 3
9933	!]EXEC_DRVR NTWK
9934		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
9935		THEN
9936			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
9937		0				!TO PREVENT INFO MSG WHEN COMPILING
9938		END;
9939	
9940		END;
9941	
9942	GLOBAL ROUTINE TST99: NOVALUE =
9943	
9944	!THIS TEST CHECKS THAT THE 'CONTINUE' SIGNAL ASSERTS AND NEGATES
9945	!CORRECTLY ON THE CRA BOARD.
9946	!TO DO THIS, THE 'CONTINUE' SIGNAL IS ASSERTED ON THE CSL BOARD AND
9947	!A 'NOT CONTINUE' SKIP MICRO-INSTRUCTION IS EXECUTED.  NO SKIP SHOULD
9948	!OCCUR.  THEN THE 'CONTINUE' SIGNAL IS NEGATED.  THIS TIME A SKIP SHOULD
9949	!OCCUR.
9950	
9951		BEGIN
9952		LABEL BLOCK1,BLOCK2;
9953		BIND
9954			UC_PTR = PLIT(U_J(3776) U_SKIP_CONTINUE U);
9955		LOCAL
9956			ACTUAL;
9957	
9958		MR();				!DO A MASTER RESET
9959		LOAD_U(0,UC_PTR);	!LOAD MICROCODE
9960		DO (0) WHILE
9961	BLOCK1:
9962		BEGIN
9963		WRT212(CONTINUE);	!ASSERT 'CONTINUE' PRE-FLOP
9964		CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'CONTINUE'
9965		SET_C(0);		!SET CRAM ADDR TO 0
9966		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
9967		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
9968		THEN
9969			ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
9970	!*MESSAGE 1
9971	!*STIMULUS:
9972	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
9973	!*	WRT 212/2	- ASSERT 'CONTINUE' PRE-FLOP
9974	!*	CP 1		- ASSERT 'CONTINUE'
9975	!*	X1 0		- SET CRAM ADDR TO 0
9976	!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP. SINCE
9977	!*			  'CONTINUE' IS ASSERTED, NO SKIP SHOULD OCCUR.
9978	!*RESPONSE:
9979	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777. THIS IMPLIES THAT THE
9980	!*	'CONTINUE' SIGNAL DID NOT ASSERT ON THE CRA BOARD.
9981	!]ERROR 1
9982	!]CONT_DRVR NTWK
9983		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
9984		THEN
9985			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
9986		0				!TO PREVENT INFO MSG WHEN COMPILING
9987		END;
9988	
9989		DO (0) WHILE
9990	BLOCK2:
9991		BEGIN
9992		WRT212(0);		!NEGATE 'CONTINUE' PRE-FLOP
9993		CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'CONTINUE'
9994		SET_C(0);		!SET CRAM ADDR TO 0
9995		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
9996		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
9997		THEN
9998			ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
9999	!*MESSAGE 2
10000	!*STIMULUS:
10001	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
10002	!*	WRT 212/0	- NEGATE 'CONTINUE' PRE-FLOP
10003	!*	CP 1		- NEGATE 'CONTINUE'
10004	!*	X1 0		- SET CRAM ADDR TO 0
10005	!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP.  SINCE
10006	!*			  'CONTINUE' IS NEGATED, WE SHOULD SKIP TO 3777.
10007	!*RESPONSE:
10008	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777. THIS IMPLIES THAT
10009	!*	THE 'CONTINUE' SIGNAL DID NOT NEGATE ON THE CRA BOARD.
10010	!]ERROR 2
10011	!]CONT_DRVR NTWK
10012		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
10013		THEN
10014			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
10015		0				!TO PREVENT INFO MSG WHEN COMPILING
10016		END;
10017		END;
10018	
10019	GLOBAL ROUTINE TST100: NOVALUE =
10020	
10021	!THIS TEST CHECKS THAT THE '1 MSEC EN' FLOP GETS ASSERTED AND NEGATED
10022	!CORRECTLY.
10023	!THIS IS DONE BY ASSERTING '1 MSEC EN', ALLOWING THE TIMER TO TIME OUT,
10024	!THEN EXECUTING A 'NOT 1 MSEC TIMER' SKIP MICROINSTRUCTION. NO SKIP
10025	!SHOULD OCCUR.  THEN '1 MSEC EN' IS NEGATED AND THE SAME SEQUENCE IS
10026	!PERFORMED. THIS TIME A SKIP SHOULD OCCUR.
10027	
10028		BEGIN
10029		LABEL BLOCK1,BLOCK2;
10030		BIND
10031			UC_PTR = PLIT(U_J(3776) U_SKIP_1_MS U);
10032		LOCAL
10033			ACTUAL;
10034	
10035		MR();				!DO A MASTER RESET
10036		LOAD_U(0,UC_PTR);	!LOAD MICROCODE
10037		DO (0) WHILE
10038	BLOCK1:
10039		BEGIN
10040		WRT100(EN_1MS);		!ENABLE 1 MSEC TIME-OUT
10041		SET_C(0);		!SET CRAM ADDR TO 0
10042		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
10043		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
10044		THEN
10045			ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
10046	!*MESSAGE 1
10047	!*STIMULUS:
10048	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
10049	!*	WRT 100/4	- ENABLE 1 MSEC TIMER. THIS SHOULD CAUSE 'DPMC
10050	!*			  1 MSEC' TO ASSERT.
10051	!*	X1 0		- SET CRAM ADDR TO 0
10052	!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP. SINCE
10053	!*			  '1 MSEC' IS ASSERTED, NO SKIP SHOULD OCCUR.
10054	!*RESPONSE:
10055	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777. THIS IMPLIES THAT THE
10056	!*	'1 MSEC EN' SIGNAL DID NOT ASSERT.
10057	!]ERROR 1
10058	!]MSEC_EN NTWK
10059		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
10060		THEN
10061			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
10062		0				!TO PREVENT INFO MSG WHEN COMPILING
10063		END;
10064	
10065		DO (0) WHILE
10066	BLOCK2:
10067		BEGIN
10068		WRT100(0);		!NEGATE '1 MSEC TIMER' ENABLE
10069		SET_C(0);		!SET CRAM ADDR TO 0
10070		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
10071		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
10072		THEN
10073			ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
10074	!*MESSAGE 2
10075	!*STIMULUS:
10076	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
10077	!*	WRT 100/0	- NEGATE '1 MSEC TIMER' ENABLE. THIS SHOULD
10078	!*			  CAUSE 'DPMC 1 MSEC' TO NEGATE.
10079	!*	X1 0		- SET CRAM ADDR TO 0
10080	!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP.  SINCE
10081	!*			  '1 MSEC' IS NEGATED, WE SHOULD SKIP TO 3777.
10082	!*RESPONSE:
10083	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777. THIS IMPLIES THAT
10084	!*	THE '1 MSEC EN' SIGNAL DID NOT NEGATE.
10085	!]ERROR 2
10086	!]MSEC_EN NTWK
10087		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
10088		THEN
10089			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
10090		0				!TO PREVENT INFO MSG WHEN COMPILING
10091		END;
10092	
10093		END;
10094	
10095	GLOBAL ROUTINE TST101: NOVALUE =
10096	
10097	!THIS TEST CHECKS THAT THE SUBROUTINE STACK POINTER GETS RESET WHEN
10098	!'STACK RESET' IS ASSERTED.
10099	! A MICROINSTRUCTION AT LOCATION ZERO JUMPS TO LOCATION 2.  FROM
10100	! LOCATION 2, A CALL IS EXECUTED TO LOCATION 4.  THERE A CALL IS
10101	! EXECUTED TO LOCATION 6.  THEN A 'STACK RESET' IS DONE AND A RETURN
10102	! INSTRUCTION IS EXECUTED.  THIS RETURN SHOULD GO TO LOCATION 2 INSTEAD
10103	! OF 4.
10104		BEGIN
10105		LABEL BLOCK1;
10106		BIND
10107			UC_PTR = PLIT(U_J(2) U,
10108					U,
10109					U_J(4) U_CALL U,
10110					U,
10111					U_J(6) U_CALL U,
10112					U,
10113					 U_DISP_RETURN U);
10114		LOCAL
10115			ACTUAL;
10116	
10117		MR();				!DO A MASTER RESET
10118		WRT204(STK_RESET);		!DO A STACK RESET
10119		WRT204(0);
10120		LOAD_U(0,UC_PTR);	!LOAD MICRO-INSTRS
10121		DO (0) WHILE
10122	BLOCK1:
10123		BEGIN
10124		SET_C(0);
10125		CP(3);			!EXECUTE ALL THE CALL INSTRS
10126		WRT204(STK_RESET);		!DO A STACK RESET
10127		WRT204(0);
10128		ACTUAL = STEP_U_NEXT(1);	!EXECUTE RETURN AND READ NEXT ADDR
10129		IF .ACTUAL NEQ 2		!ARE WE AT CORRECT RETURN ADDR?
10130		THEN
10131			ERRCA(1,2,.ACTUAL,4);	!NO, REPORT ERROR
10132	!*MESSAGE 1
10133	!*STIMULUS:
10134	!*	LOAD MICRO-INSTRUCTIONS TO JUMP FROM 0 TO 2, DO A CALL FROM 2 TO
10135	!*		4, DO A CALL FROM 4 TO 6, AND DO A RETURN FROM 6.
10136	!*	X1 0	- SET THE CRAM ADDRESS TO ZERO.
10137	!*	CP 3	- THREE CLOCK PULSES EXECUTE THE CALL INSTRS AT LOCS 2
10138	!*		  AND 4.
10139	!*	WRT 204/2	- DO A STACK RESET.
10140	!*	WRT 204/0
10141	!*	CP 1	- EXECUTE THE RETURN INSTR AT LOC 6.  AFTER THE STACK
10142	!*		  RESET, THIS SHOULD CAUSE THE NEXT CRAM ADDR TO BE 2
10143	!*		  INSTEAD OF 4.
10144	!*RESPONSE:
10145	!*	THE NEXT CRAM ADDRESS AFTER EXECUTING THE RETURN IS NOT 2.
10146	!*	THIS IMPLIES THAT 'STACK RESET' DID NOT ASSERT.
10147	!]ERROR 1
10148	!]STK_RESET NTWK
10149		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
10150		THEN
10151			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
10152		0				!TO PREVENT INFO MSG WHEN COMPILING
10153		END;
10154		END;
10155	
10156	GLOBAL ROUTINE TST102: NOVALUE =
10157	
10158	!THIS TEST CHECKS THAT THE CPU CLOCK CONTROL CIRCUITRY WORKS CORRECTLY
10159	!WHEN THE CPU EXECUTES A MEMORY READ SEQUENCE.  WHAT SHOULD HAPPEN IS
10160	!THAT THE CLOCK ENABLES GET DISABLED UNTIL THE MEMORY RESPONDS WITH THE
10161	!DATA.
10162	
10163		BEGIN
10164		LABEL BLOCK1,BLOCK2;
10165		LOCAL
10166			ERFLG;
10167		BIND
10168			UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
10169				      U_J(2) U_MEM U_N(43012) U,
10170				      U_J(3) U_MEM U_N(2) U,
10171				      U_J(3) U);
10172	
10173		ERFLG = 0;		!INIT ERROR FLAG
10174		MR();				!DO A MASTER RESET
10175		LOAD_U(0,UC_PTR);	!LOAD MICROCODE FOR MEM READ
10176		DO (0) WHILE
10177	BLOCK1:
10178		BEGIN
10179		MR();				!DO A MASTER RESET
10180		SET_C(0);	!SET CRAM ADDR = 0
10181		INIT();		!DO A RESET
10182		SYNC_CLK();	!GO STOP CLOCK AND SYNC IT
10183		RESET_CRAM();				!CLEAR CRAM BITS
10184		WRT206(SINGLE_CLK);	!ASSERT 'SINGLE CLK'
10185		CYCLE(3);		!INIT CLOCK CONTROL FLOPS
10186		WRT206(CLK_RUN);	!ASSERT 'CLK RUN'
10187		CYCLE(9);		!EXECUTE FIRST 3 MICRO-INSTRS
10188	
10189	!CPU CLOCKING SHOULD NOW BE DISABLED UNTIL MEMORY RESPONDS WITH THE
10190	!READ DATA.  IT SHOULD TAKE AT LEAST 8 T-CLK CYCLES BEFORE THE CLOCKS
10191	!ARE ENABLED AGAIN.
10192	
10193		INCR I FROM 1 TO 8 BY 1 DO
10194			BEGIN
10195			CYCLE(1);	!GENERATE A T-CLK CYCLE
10196			IF (RD_303 AND CR_CLK_ENB) NEQ 0  !DID 'CRA/M CLK ENABLE ASSERT TOO EARLY?
10197			THEN
10198				BEGIN
10199				ERFLG = -1;	!SET ERROR FLAG
10200				ERRS(1,1,I);	!YES, REPORT ERROR
10201				EXITLOOP;
10202				END;
10203			END;
10204	!*MESSAGE 1
10205	!*STIMULUS:
10206	!*	LOAD MICRO-INSTRS TO DO A MEMORY READ.
10207	!*	X1 0	- SET THE CRAM ADDRESS TO 0.
10208	!*	STOP CLOCK AND SYNC IT WITH T-CLK AND R-CLK NEGATED.
10209	!*	WRT 206/2   - ASSERT 'SINGLE CLK'.
10210	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS INITS ALL THE CLOCK CONTROL
10211	!*		FLOPS AND LATCHES THE CRAM BITS FOR THE FIRST MICRO-
10212	!*		INSTRUCTION.
10213	!*	WRT 206/1   - ASSERT 'CLK RUN'.
10214	!*	GENERATE 9 T-CLK/R-CLK CYCLES - THIS EXECUTES THE FIRST 3 MICRO-
10215	!*		INSTRUCTIONS. AFTER THE LAST ONE, THE CPU SHOULD BE
10216	!*		WAITING FOR THE MEMORY TO RESPOND WITH THE READ DATA.
10217	!*		THE CPU CLOCK ENABLES SHOULD NOW BE DISABLED FOR AT
10218	!*		LEAST 8 T-CLK/R-CLK CYCLES.
10219	!*	GENERATE \O0 T-CLK/R-CLK CYCLES - 'CRA/M CLK ENABLE' SHOULD
10220	!*		STAY NEGATED.
10221	!*RESPONSE:
10222	!*	'CRA/M CLK ENABLE' ASSERTED BEFORE IT SHOULD HAVE.
10223	!]ERROR 1
10224	!]CLK_ENBS ENB RD_DATA READ_DLY RD_DLY NTWK
10225		IF LOOP_CHK(1)		!CHECK FOR LOOPING ON ERROR
10226		THEN
10227			LEAVE BLOCK1 WITH 1;
10228	
10229	!NOW CHECK THAT 'CRA/M CLK ENABLE' ASSERTS WITHIN 8 CYCLES.
10230	
10231		IF .ERFLG EQL 0		!IF WE DIDN'T ALREADY HAVE AN ERROR
10232		THEN
10233	BLOCK2:	BEGIN
10234			BEGIN
10235			INCR I FROM 1 TO 8 BY 1 DO
10236				BEGIN
10237				CYCLE(1);	!GENERATE A T-CLK CYCLE
10238				IF (RD_303 AND CR_CLK_ENB) EQL 0   !DID IT ASSERT?
10239				THEN
10240					LEAVE BLOCK2;
10241				END;
10242	
10243	!IF WE GET THIS FAR, 'CRA/M CLK ENABLE' NEVER ASSERTED.
10244			ERR(2);
10245			END;
10246	!*MESSAGE 2
10247	!*STIMULUS:
10248	!*	LOAD MICRO-INSTRS TO DO A MEMORY READ.
10249	!*	X1 0	- SET THE CRAM ADDRESS TO 0.
10250	!*	STOP CLOCK AND SYNC IT WITH T-CLK AND R-CLK NEGATED.
10251	!*	WRT 206/2   - ASSERT 'SINGLE CLK'.
10252	!*	GENERATE 3 T-CLK/R-CLK CYCLES - THIS INITS ALL THE CLOCK CONTROL
10253	!*		FLOPS AND LATCHES THE CRAM BITS FOR THE FIRST MICRO-
10254	!*		INSTRUCTION.
10255	!*	WRT 206/1   - ASSERT 'CLK RUN'.
10256	!*	GENERATE 9 T-CLK/R-CLK CYCLES - THIS EXECUTES THE FIRST 3 MICRO-
10257	!*		INSTRUCTIONS. AFTER THE LAST ONE, THE CPU SHOULD BE
10258	!*		WAITING FOR THE MEMORY TO RESPOND WITH THE READ DATA.
10259	!*		THE CPU CLOCK ENABLES SHOULD NOW BE DISABLED FOR AT
10260	!*		LEAST 8 T-CLK/R-CLK CYCLES.
10261	!*	GENERATE 8 T-CLK/R-CLK CYCLES - 'CRA/M CLK ENABLE' SHOULD
10262	!*		STAY NEGATED WAITING FOR MEMORY TO RESPOND.
10263	!*	GENERATE 8 T-CLK/R-CLK CYCLE - 'CRA/M CLK ENABLE' SHOULD ASSERT.
10264	!*RESPONSE:
10265	!*	'CRA/M CLK ENABLE' DID NOT ASSERT.
10266	!]ERROR 2
10267	!]CLK_ENBS ENB RD_DATA READ_DLY RD_DLY NTWK
10268			IF LOOP_CHK(2)		!CHECK FOR LOOPING ON ERROR
10269			THEN
10270				LEAVE BLOCK1 WITH 1;
10271			END;
10272		0				!TO PREVENT INFO MSG WHEN COMPILING
10273		END;
10274		MR();				!DO A MASTER RESET
10275		END;
10276	END
10277	ELUDOM

AC0				1038+#	1042+#	1046+#	1050+#	1054+#	1058+#	1062+#	1066+#	1070+#	1074+#	1078+#	1082+#
				1086+#	1090+#	1094+#	1098+#	1102+#	1106+#	1110+#	1114+#	1118+#	1122+#	1126+#	1173+#
ACTUAL				1735	1771	1775	1776	1802	1838	1842	1843	2868	2898#	2899	2957
				2987#	2988	3414	3435#	3436	3485	3507#	3508	3564	3587#	3588	3653
				3677#	3678	3749	3772#	3773	3838	3862#	3863	3935	3958#	3959	4024
				4048#	4049	4121	4144#	4145	4210	4234#	4235	9668	9684#	9685	9715
				9744	9798	9807#	9808	9810	9838#	9839	9841	9880	9890#	9891	9893
				9918#	9919	9921	9956	9966#	9967	9969	9995#	9996	9998	10033	10042#
				10043	10045	10070#	10071	10073	10115	10128#	10129	10131
ADDR				1049+	1050+	1234+	1235+	1236+	1237+
ADPT1_PE			 409+#
ADPT2_PE			 370+#
ADPT3_PE			 375+#
ADPT4_PE			 408+#
BAD_DATA			 274+#
BEGIN_XLIST			1232+#
BLISS36				   4
BLOCK1				1915	1926	1946	1965	1985	2001	2009	2030	2051	2074	2079	2100
				2115	2123	2149	2170	2198	2204	2224	2236	2240	2259	2271	2279
				2301	2323	2343	2345	2379	2392	2398	2417	2429	2434	2455	2467
				2471	2491	2503	2508	2527	2542	2546	2570	2583	2588	2612	2635
				2641	2667	2687	2711	2731	2756	2776	2821	2826	2850	2871	2890
				2925	2960	2979	3013	3043	3050	3080	3105	3132	3152	3157	3184
				3209	3222	3226	3254	3280	3293	3298	3327	3354	3366	3370	3397
				3417	3429	3459	3488	3500	3538	3567	3581	3627	3656	3670	3723
				3752	3766	3812	3841	3855	3909	3938	3952	3998	4027	4041	4095
				4124	4138	4184	4213	4227	4281	4302	4309	4335	4355	4375	4395
				4408	4415	4442	4463	4484	4505	4517	4524	4553	4575	4597	4619
				4631	4638	4667	4689	4711	4733	4750	4757	4806	4830	4837	4886
				4910	4914	4963	4987	4994	5043	5064	5071	5120	5144	5151	5200
				5224	5231	5280	5304	5311	5360	5386	5393	5451	5469	5477	5517
				5529	5536	5577	5591	5599	5635	5647	5654	5693	5706	5714	5752
				5766	5773	5811	5824	5831	5870	5884	5891	5930	5943	5950	5987
				6005	6013	6059	6072	6082	6111	6138	6160	6167	6193	6207	6214
				6240	6254	6262	6296	6309	6317	6351	6364	6372	6406	6420	6431
				6457	6478	6499	6523	6545	6567	6598	6606	6635	6657	6679	6692
				6704	6735	6759	6783	6796	6808	6838	6861	6884	6898	6910	6940
				6963	6986	7002	7009	7040	7063	7482	7489	7522	7546	7572	7598
				7613	7618	7646	7662	7667	7697	7714	7723	7756	7783	7813	7846
				7862	7870	7904	7934	7950	7959	7993	8021	8051	8064	8066	8088
				8101	8103	8122	8135	8137	8160	8172	8174	8202	8217	8223	8247
				8274	8301	8324	8326	8350	8373	8396	8408	8410	8437	8451	8453
				8497	8527	8539	8541	8585	8599	8601	8640	8672	8707	8739	8775
				8807	8842	8874	8886	8893	8910	8924	8938	8949	8951	8973	8993
				9005	9013	9032	9051	9072	9082	9104	9131	9144	9157	9192	9218
				9233	9246	9279	9303	9318	9331	9363	9386	9399	9403	9418	9434
				9451	9492	9532	9548	9558	9589	9607	9617	9642	9657	9673	9713
				9743	9771	9791	9803	9829	9876	9885	9908	9952	9961	9985	10029
				10038	10061	10105	10122	10151	10164	10177	10227	10270
BLOCK2				7002	7072	7097	7120	9791	9834	9861	9876	9913	9936	9952	9990
				10014	10029	10066	10089	10164	10233	10240
BLOCK3				7002	7129	7154	7177
BLOCK4				7002	7186	7211	7234
BLOCK5				7002	7244	7269	7292
BLOCK6				7002	7301	7326	7349
BLOCK7				7002	7358	7383	7406
BLOCK8				7002	7415	7440	7463
BOOT				 425+#
BUSREQ				 428+#	2013	2033	2083
BUS_REQ				 313+#	2012	2082	2127	2206	2244	2437	2474	2549	2593	2896	2985
				3055	3162	3231	3304	3375	3434	3506	3586	3676	3771	3861	3957
				4047	4143	4233	4420	4771	4851	4928	5008	5085	5165	5245	5325
				5407	5481	5483	5540	5542	5544	5603	5605	5658	5663	5718	5724
				5777	5783	5835	5842	5895	5900	5902	5955	5959	6018	6021	6026
				7017	7074	7131	7188	7246	7303	7360	7417	8465	8613	8645	8680
				8712	8748	8780	8815	8847
CACHE_ENB			 212+#
CE				1290+
CERFLG				2632	2639#	2653#	2697#	2742#	2782	2790	2798	2806
CH				1292+	1604
CHK_ERR_MSG			1275+	1610	1929	6089	6174	6221	6269	6324	6379	8072	8108	8143
				8182	8251	8354	8418	8461	8549	8615	8647	8682	8714	8750	8782
				8817	8849	8957
CLEAR_CRAM			  56	1620	1626*	6150	6197	6244	6299	6354	6409	8177	8226	8329
				8413	8456	8544
CLK_RUN				 302+#	7497	7623	7672	7731	7878	7967	8553	9682	10186
CLOSE_LATCH			 307+#	2283	2349	2400	2437	2474	2511	2549	2550	2591	2593	3055
				3162	3231	3304	3375	3434	3506	3586	3676	3771	3861	3957	4047
				4143	4233	4314	4420	4530	4644	4760	4812	4840	4892	4917	4969
				4997	5048	5074	5126	5154	5206	5234	5286	5314	5366	5396	5409
				5483	5544	5605	5663	5724	5783	5842	5902	5959	6026	7017	7074
				7131	7188	7246	7303	7360	7417	8613	8645	8680	8712	8748	8780
				8815	8847
CLR_INT				 296+#	9016
CNT				1353
COM_ADR				 273+#
CONS_ENB			 426+#
CONTINUE			 318+#	9963
CONTINUE_H			 413+#	6480	6547	6659	6761	6863	6965
CONTROL				1261+*
CON_ERFLG			6426	6429#	6484#	6551#	6584
CORRECT				1735	1771	1775	1776	1802	1838	1842	1843	2867	2888#	2894	2895
				2899	2956	2977#	2983	2984	2988	3413	3427#	3432	3433	3436	3484
				3498#	3504	3505	3508	3563	3579#	3584	3585	3588	3652	3668#	3674
				3675	3678	3748	3764#	3769	3770	3773	3837	3853#	3859	3860	3863
				3934	3950#	3955	3956	3959	4023	4039#	4045	4046	4049	4120	4136#
				4141	4142	4145	4209	4225#	4231	4232	4235
CP				1231+	1280+	9087	9457	9494	9563	9565	9623	10125
CP_NOSS				1281+	1615	9777	9888	9916	9964	9993
CRAM_ADDR			1228+
CRAM_ADR_LD			 286+#	5956	6019	6023
CRAM_PE				 374+#	8333
CRAM_RESET			 282+#	1694	5840
CRAM_WRT			 287+#	5660	5720	5779	5837	5897	8466
CRA_PE				 371+#	8230	8499
CRA_R_CLK			 309+#	5481	5483	5540	5603	5605	5658	5663	5718	5724	5777	5783
				5835	5842	5895	5900	5902	5955	5959	6018	6021	6026	8465
CRA_T_CLK			 310+#	5483	5544	5663	5724	5783	5842	5902	5959	6026
CRM_PE_DET			 214+#	8141	8249	8352	8416	8459	8547
CR_CLK_ENB			 443+#	2649	2693	2738	2833	7500	7549	7575	7627	7677	7733	7759
				7786	7816	7880	7907	7969	7996	8023	8555	9168	9257	9342	10196
				10238
CR_LF				1034+#	1038+	1066+
CS				1291+
CSL_INT				 278+#	9456	9562	9621
CTY_BIT				 420+#
CTY_CHAR_LEN			 419+#
CYCLE				1353#	2647	2691	2736	2832	4772	4852	4929	5009	5086	5166	5246
				5326	5408	5410	7496	7498	7548	7574	7626	7673	7676	7730	7732
				7758	7785	7815	7877	7879	7906	7966	7968	7995	8022	8552	8554
				9164	9166	9253	9338	9681	9683	10185	10187	10195	10237
DATA				1234+	1236+	2634	2648#	2649	2669	2692#	2693	2713	2737#	2738	2758
				4307	4315#	4316	4317	4336	4337	4357	4358	4377	4378	4413	4421#
				4422	4423	4443	4444	4465	4466	4486	4487	4522	4531#	4532	4533
				4554	4555	4577	4578	4599	4600	4636	4645#	4646	4647	4668	4669
				4691	4692	4713	4714	4755	4773#	4774	4776	4835	4853#	4854	4856
				4912	4930#	4931	4933	4992	5010#	5011	5013	5069	5087#	5088	5090
				5149	5167#	5168	5170	5229	5247#	5248	5250	5309	5327#	5328	5330
				5391
DATA0				 267+#
DATA1				 266+#
DATA10				 254+#
DATA11				 253+#
DATA12				 249+#
DATA13				 248+#
DATA14				 247+#
DATA15				 246+#
DATA16				 245+#
DATA17				 244+#
DATA18				 243+#
DATA19				 242+#
DATA2				 265+#
DATA20				 238+#
DATA21				 237+#
DATA22				 236+#
DATA23				 235+#
DATA24				 234+#
DATA25				 233+#
DATA26				 232+#
DATA27				 231+#
DATA28				 227+#
DATA29				 226+#
DATA3				 264+#
DATA30				 225+#
DATA31				 224+#
DATA32				 223+#
DATA33				 222+#
DATA34				 221+#
DATA35				 220+#
DATA4				 260+#
DATA5				 259+#
DATA6				 258+#
DATA7				 257+#
DATA8				 256+#
DATA9				 255+#
DATA_ACK			 424+#	3056	3108	3163	3232	3305	3376
DATA_CYCLE			 271+#	3054	3230
DATA_TABLE			2870	2888	2959	2977	3416	3427	3487	3498	3566	3579	3655	3668
				3751	3764	3840	3853	3937	3950	4026	4039	4123	4136	4212	4225
DC_0				1657#	1660
DC_035				1299+
DERFLG				2633	2639#	2673#	2717#	2762#	2782	2790	2798	2806
DEST				 608+	 609+
DI				1236+#
DIAG1				 291+#
DIAG10				 294+#
DIAG2				 292+#
DIAG4				 293+#
DISCREP				1769	1776#	1781	1790	1836	1843#	1848	1857	1866	1875	1884	1893
DM				1234+#	1606
DM_CHK				1301+
DN				1305+
DP				 621+	 622+	 642+	 643+
DP_CLK_ENBL			 442+#	2669	2713	2758	7524	9194	9281	9365
DP_PE_DET			 213+#	8106
DP_PE				 372+#	8912
DP_RESET			 284+#	9106
EB_AC				1024+#	1148+
EC				1297+
EC_AC				1025+#	1149+
EI				1237+#
EI_AC				1021+#	1145+
EI_CHK				1308+
EJ				1295+
EJ_AC				1022+#	1146+
EK_AC				1023+#	1147+
EM				1235+#
EM_AC				1026+#	1150+
EM_CHK				1304+	9405
END_LIST			1233+#
EN_1MS				 211+#	10040
EOP_UUO				1140+#
ERBLK1				9657
ERFLG				1917	1924#	1934#	1952#	1967	2000	2007#	2017#	2037#	2058	2119	2121#
				2131#	2155#	2176	2275	2277#	2288#	2308#	2327	3042	3048#	3060#	3112#
				3138	6074	6078#	6094#	6119#	6144	8219	8221#	8256#	8281#	8307	9007
				9011#	9021#	9039#	9057	10166	10173#	10199#	10231
ERMCAS				1269+
ERMCA				1268+	1775	1842
ERMS				1270+
ERR				1263+	1933	1951	1975	2016	2036	2085	2132	2156	2211	2247	2287
				2307	2352	2364	2404	2440	2477	2514	2553	2597	2835	3059	3083
				3111	3165	3187	3234	3257	3307	3331	3378	5414	6093	6118	6177
				6224	6273	6328	6383	6441	6462	6483	6506	6528	6550	6617	6639
				6661	6715	6739	6763	6819	6842	6865	6921	6944	6967	7021	7044
				7078	7101	7135	7158	7192	7215	7250	7273	7307	7330	7364	7387
				7421	7444	7502	7526	7551	7577	7629	7679	7735	7761	7788	7818
				7882	7909	7971	7998	8025	8075	8111	8146	8185	8232	8255	8280
				8335	8357	8377	8421	8471	8501	8557	8618	8650	8685	8717	8753
				8785	8820	8852	8900	8914	8928	8960	8977	9020	9038	9090	9111
				9170	9196	9259	9283	9344	9367	9408	9568	9626	9687	9717	9746
				10244
ERRCAS				1265+
ERRCA				1264+	4317	4337	4358	4378	4423	4444	4466	4487	4533	4555	4578
				4600	4647	4669	4692	4714	4776	4856	4933	5013	5090	5170	5250
				5330	5487	5548	5609	5667	5728	5787	5846	5906	5963	6030	9810
				9841	9893	9921	9969	9998	10045	10073	10131
ERRFLG				1337+
ERRM				1267+	2652	2672	2696	2716	2741	2761
ERROR_FLAG			1373	1774#	1841#	2885#	2932	2974#	3020	3424#	3466	3495#	3545	3576#
				3634	3665#	3730	3761#	3819	3850#	3916	3947#	4005	4036#	4102	4133#
				4191	4222#	4288
ERR_CHK_4			  59	1735*	2899	2988	3436	3508
ERR_CHK_8			  60	1802*	3588	3678	3773	3863	3959	4049	4145	4235
ER_AC				1020+#	1144+
EXECUTE_B			 414+#	6459	6525	6637	6737	6840	6942
EXE_ERFLG			6425	6429#	6463#	6529#	6578
EXNEXT				1238+	1284+
EX_NXT				1231+	1238+#
FAILURE				1272+	1784	1793	1799	1851	1860	1869	1878	1887	1896	1902	2784
				2792	2800
FILNAM_ADR			1173+
FLP_CHK				1274+	1945	1964	1984	2029	2050	2099	2148	2169	2223	2258	2300
				2322	2416	2454	2490	2526	2569	2611	2666	2686	2710	2730	2755
				2775	2849	2924	3012	3079	3104	3131	3183	3208	3279	3326	3353
				3396	3458	3537	3626	3722	3811	3908	3997	4094	4183	4280	4334
				4354	4374	4394	4441	4462	4483	4504	4552	4574	4596	4618	4666
				4688	4710	4732	4805	4885	5042	5119	5199	5279	5359	5450	5516
				5576	5634	5692	5751	5810	5869	5929	5986	6058	6456	6477	6498
				6522	6544	6566	6634	6656	6678	6734	6758	6782	6837	6860	6883
				6939	6962	6985	7039	7062	7096	7119	7153	7176	7210	7233	7268
				7291	7325	7348	7382	7405	7439	7462	7521	7545	7571	7597	7645
				7696	7755	7782	7812	7845	7903	7933	7992	8020	8050	8909	8923
				8937	9031	9050	9103	9130	9191	9217	9278	9302	9362	9385	9491
				9531	9588	9641
FLP_PTR				1922#	1945	1964	1984	2003#	2029	2050	2076#	2099	2117#	2148	2169
				2200#	2223	2238#	2258	2273#	2300	2322	2394#	2416	2431#	2454	2469#
				2490	2505#	2526	2544#	2569	2585#	2611	2637#	2666	2686	2710	2730
				2755	2775	2823#	2849	2873#	2876	2924	2962#	2965	3012	3224#	3279
				3368#	3396	3419#	3422	3458	3490#	3493	3537	3569#	3574	3626	3658#
				3663	3722	3754#	3759	3811	3843#	3848	3908	3940#	3945	3997	4029#
				4034	4094	4126#	4131	4183	4215#	4220	4280	4304#	4334	4354	4374
				4394	4410#	4441	4462	4483	4504	4519#	4552	4574	4596	4618	4633#
				4666	4688	4710	4732	4752#	4805	4832#	4885	4989#	5042	5066#	5119
				5146#	5199	5226#	5279	5306#	5359	5388#	5450	5471#	5516	5531#	5576
				5593#	5634	5708#	5751	5768#	5810	5826#	5869	5886#	5929	5945#	5986
				6007#	6058	6422#	6456	6477	6498	6522	6544	6566	6600#	6634	6656
				6678	6694#	6734	6758	6782	6798#	6837	6860	6883	6900#	6939	6962
				6985	7004#	7039	7062	7096	7119	7153	7176	7210	7233	7268	7291
				7325	7348	7382	7405	7439	7462	7484#	7521	7545	7571	7597	7615#
				7645	7664#	7696	7716#	7755	7782	7812	7845	7866#	7903	7933	7954#
				7992	8020	8050	8888#	8909	8923	8937	9009#	9031	9050	9146#	9191
				9217	9235#	9278	9302	9320#	9362	9385	9550#	9588	9609#	9641
FLP_PTR1			3045#	3079	3131	3154#	3183	3295#	3326	5649#	5692	9074#	9103	9436#
				9491
FLP_PTR2			3046#	3104	3155#	3208	3296#	3353	9075#	9130	9437#	9531
FORCE_PAR			 210+#
FRDPAG				1175+#
FSELECT				1173+#
FUNC				 568+	 569+
HALTED				1180+#	6089	6174	6221	6269	6324	6379
HALT_LOOP			 416+#	6090	6115	6175	6222	6271	6326	6381
I				2886	2888	2924	2975	2977	3012	3425	3427	3458	3496	3498	3537
				3577	3579	3626	3666	3668	3722	3762	3764	3811	3851	3853	3908
				3948	3950	3997	4037	4039	4094	4134	4136	4183	4223	4225	4280
				10193	10200	10235
INIT				  58	1698*	2005	2064	2081	2125	2202	2207	2242	2281	2347	2382
				2396	2401	2436	2473	2510	2548	2590	2616	2643	2812	2828	2853
				2892	2942	2981	3030	3052	3159	3228	3300	3372	3431	3502	3583
				3672	3768	3857	3954	4043	4140	4229	4311	4417	4526	4640	4759
				4761	4811	4839	4841	4891	4916	4918	4968	4996	4998	5047	5073
				5075	5125	5153	5155	5205	5233	5235	5285	5313	5315	5365	5395
				5397	5456	5479	5538	5601	5656	5893	5952	6015	6022	6079	6085
				6114	6164	6170	6211	6217	6259	6265	6314	6320	6369	6375	6433
				6501	6608	6701	6707	6805	6811	6887	6907	6913	7011	7492	7620
				7624	7669	7674	7726	7873	7962	8440	8896	8996	9160	9249	9334
				9564	9677	10181
INIT_UCODE			1513#	1611
IO_DATA				 272+#	3161	3374	3503	3673	3858	4044	4230	8604
IO_DEPOSIT			1236+	1306+	8955
IO_EXAMINE			1237+	1307+
J				1780	1781	1784	1847	1848	1851
KLINIK_BIT			 418+#
KLINIK_CARR			 434+#
KLINIK_LEN			 417+#
LANGUAGE			   4
LATCH_DATA			 308+#	2437	2511	2549	3055	3162	3231	3304	3506	3676	3861	4047
				4233	8613	8645	8680	8712	8748	8780	8815	8847
LC				1229+#	9454	9561	9620
LCA				1229+	1298+
LOADUC				1228+	1287+
LOAD_U				1228+#	1611	6080	6165	6212	6260	6315	6370	6702	6806	6908	7487
				7721	7868	7957	9080	9155	9244	9329	9447	9556	9615	9671	9776
				9801	9883	9959	10036	10120	10175
LOOP_CHK			1273+	2378	3253	4962	6110	6137	6192	6239	6295	6349	6404	8087
				8121	8159	8201	8246	8273	8300	8349	8372	8395	8436	8496	8526
				8584	8639	8671	8706	8738	8774	8806	8841	8873	8972	8992	9417
				9711	9741	9769	9827	9859	9906	9934	9983	10012	10059	10087	10149
				10225	10268
LPONTST				1334+
MAINT_CLK			 298+#
MEM				 314+#	2127	2206	3055	3304
MEMSIZE				1262+
MEM_DEPOSIT			1234+	1302+
MEM_EXAMINE			1235+	1303+
MEM_PE				 373+#	8958
MEM_REF_ERR			1181+#
MMC_REF_ERR			 380+#
MNT_CLK_ENB			 297+#	1354
MOD_FLD				1300+	8178	8227	8330	8414	8457	8545	9455
MR				1288+	1659	5716	5775	5833	6989	7486	7601	7650	7701	7720	7849
				7937	7956	8054	8176	8225	8328	8412	8455	8543	8603	9079	9084
				9154	9221	9243	9306	9328	9389	9401	9446	9453	9535	9555	9560
				9593	9614	9619	9646	9670	9675	9775	9800	9882	9958	10035	10117
				10174	10179	10274
MSCSLT				   3#
MSGADR				1045+	1046+	1069+	1070+
MSGFIL				1361#
MSGWORD				1041+	1042+
MSG_CHK_UUO			1165+#
N				1231+
NEXM				 429+#	2128	2152	2209	2245	9406
NOERR				1271+	1969	2060	2087	2135	2178	2329	2363	2808	2934	3022	3140
				3468	3547	3636	3732	3821	3918	4007	4104	4193	4290	5669	5962
				6146	6574	6580	6586	8309	9059
NO_SUBSET			1333+
NUM				1061+	1062+	1081+	1082+	1085+	1086+	1089+	1090+	1093+	1094+	1097+	1098+
				1101+	1102+	1105+	1106+	1109+	1110+	1113+	1114+	1117+	1118+	1121+	1122+
				1125+	1126+
O_CRAM_ADDR			 564+	 565+	1229+	1230+
O_N				 874+	 875+
O_SN				 915+	 916+
PAR_ERR				1182+#	1610	1929	8072	8108	8143	8182	8251	8354	8418	8461	8549
				8615	8647	8682	8714	8750	8782	8817	8849	8957
PAR_LEFT			 406+#	7042	7099	7156	7213	7271	7328	7385	7442
PAR_RIGHT			 407+#	7019	7076	7133	7190	7248	7305	7362	7419
PBELL				1129+#
PE				1289+	1603
PE_1				 427+#	1973	8073	8109	8144	8183	8252	8277	8355	8375	8419	8469
				8616	8648	8683	8715	8751	8783	8818	8850	8975
PE_DET_ENB			 215+#	8070	8106	8141	8180	8249	8276	8352	8459	8547	8612	8644
				8679	8711	8747	8779	8814	8846	8954
PI_MASK				9444	9458	9495
PI_REQ				9448	9455	9458	9460	9495	9497
PI_REQ_1			 387+#	9566	9624
PI_REQ_2			 386+#
PI_REQ_3			 385+#
PI_REQ_4			 384+#
PI_REQ_5			 383+#
PI_REQ_6			 382+#
PI_REQ_7			 381+#
PM_AC				1027+#	1151+
PNTSIX				1041+#
POCT_SUP			1125+#
POINT				1256+
PRGNAM				1362#
PRINT_CRLF			1037+#
PRINT_DEC			1061+#
PRINT_MSG			1045+#
PRINT_OCT_1			1085+#
PRINT_OCT_11			1117+#
PRINT_OCT_12			1121+#
PRINT_OCT_2			1089+#
PRINT_OCT_3			1093+#
PRINT_OCT_4			1097+#
PRINT_OCT_5			1101+#
PRINT_OCT_6			1105+#
PRINT_OCT_7			1109+#
PRINT_OCT_8			1113+#
PRINT_TXT			1053+#
PRINT_WORD			1049+#
PRT_CRLF_F			1065+#
PRT_DEC_F			1081+#
PRT_MSG_F			1069+#
PRT_TXT_F			1073+#
PTR				1920#	1928
PTSTNUM				1279+
PTXT_CRLF			1057+#
PTXT_CRLF_F			1077+#
RAC_LO				 398+#
RAM_ERR				 441+#	8926
RBAD_DATA			 394+#
RCOM_ADR			 393+#	5411
RDATA				 391+#
RDATA0				 405+#
RDATA1				 404+#
RDATA10				 360+#
RDATA11				 359+#
RDATA12				 355+#
RDATA13				 354+#
RDATA14				 353+#
RDATA15				 352+#
RDATA16				 351+#
RDATA17				 350+#
RDATA18				 349+#
RDATA19				 348+#
RDATA2				 403+#
RDATA20				 344+#
RDATA21				 343+#
RDATA22				 342+#
RDATA23				 341+#
RDATA24				 340+#
RDATA25				 339+#
RDATA26				 338+#
RDATA27				 337+#
RDATA28				 333+#
RDATA29				 332+#
RDATA3				 402+#
RDATA30				 331+#
RDATA31				 330+#
RDATA32				 329+#
RDATA33				 328+#
RDATA34				 327+#
RDATA35				 326+#
RDATA4				 366+#
RDATA5				 365+#
RDATA6				 364+#
RDATA7				 363+#
RDATA8				 362+#
RDATA9				 361+#
RD_0				1239+#	3053	3107	3160	3229	3301	3373	4144	4234	5484	5545	5606
				5664	5725	5784	5843	5903	5960	6027
RD_1				1240+#	3958	4048
RD_100				1243+#	8230	8333	8499	8897	8958
RD_101				1244+#	9458	9495	9566	9624
RD_102				1245+#	1948	2898	2987	5411
RD_103				1246+#	3435	3507	7018	7075	7132	7189	7247	7304	7361	7418
RD_2				1241+#	3772	3862	4315	4421	4531	4645
RD_3				1242+#	3587	3677	4773	4853	4930	5010	5087	5167	5247	5327
RD_300				1247+#	6090	6115	6175	6222	6271	6326	6381	6437	6502	6614	6712
				6816	6918
RD_301				1248+#	1973	2013	2033	2083	2128	2152	2209	2245	3056	3108	3163
				3232	3305	3376	8073	8109	8144	8183	8252	8277	8355	8375	8419
				8469	8616	8648	8683	8715	8751	8783	8818	8850	8975	9017	9035
				9088	9109	9406
RD_303				1249+#	2284	2304	2350	2362	2402	2438	2475	2512	2551	2595	2648
				2692	2737	2833	3081	3185	3255	3329	7499	7549	7575	7627	7677
				7733	7759	7786	7816	7880	7907	7969	7996	8023	8555	8926	9167
				9256	9341	9684	10196	10238
REC_PE				 376+#	8898
REG_EXAMINE			1239+	1240+	1241+	1242+	1243+	1244+	1245+	1246+	1247+	1248+	1249+	1309+
REM_DIAG_ENB			 436+#
REM_DIAG_PRO			 437+#
REPEAT				1278+
REPLACEI			1258+
RESET_CRAM			  57	1663*	2644	2829	5953	6016	6113	6434	6609	6708	6812	6914
				7494	7622	7671	7728	7875	7964	8068	8139	8374	8895	9162	9251
				9336	9679	10183
RESET				 216+#	1731	8069	8105	8140	8611	8643	8678	8710	8746	8778	8813
				8845	8953
RIO_BUSY			 395+#
RIO_DATA			 392+#
RMEM_BUSY			 396+#
RPT_ERR_FLAG			1336+	1599#
RRESET				 397+#	1930	1948
RUN				 320+#
RUN_1				 415+#	6438	6503	6615	6713	6817	6919
RUN_ERFLG			6424	6429#	6442#	6507#	6572
R_CLK_ENB0			 444+#	2284	2304	2350	2362	2402	2438	2475	2512	2551	2595	3081
				3185	3255	3329
SCANI				1257+
SC_0				1296+	1605
SEL				 663+	 664+	 674+	 675+	 685+	 686+
SEND_CMD_LINE			1157+#
SEND_EB_LINE			1148+#
SEND_EC_LINE			1149+#
SEND_EI_LINE			1145+#
SEND_EJ_LINE			1146+#
SEND_EK_LINE			1147+#
SEND_EM_LINE			1150+#
SEND_ER_LINE			1144+#
SEND_INFO			1169+#
SEND_LINE			1277+	1660	1928
SEND_NUL			1282+	1609	1617	1623	1729	6088	6173	6220	6268	6323	6378	8071
				8107	8142	8181	8229	8250	8332	8353	8417	8460	8548	8610	8614
				8646	8681	8713	8749	8781	8816	8848	8956	9778
SEND_PM_LINE			1151+#
SEND_UUO_1			1161+#
SEND_X1A_LINE			1152+#
SEND_X1B_LINE			1153+#
SETNXT				1230+	1283+
SET_C				1230+#	1614	6084	6169	6216	6264	6319	6374	6706	6810	6912	7491
				7725	7872	7961	9085	9159	9248	9333	9676	9806	9837	9889	9917
				9965	9994	10041	10069	10124	10180
SINGLE_CLK			 303+#	2646	5662	5722	5781	5839	5901	6086	6087	6171	6172	6218
				6219	6266	6267	6270	6321	6322	6325	6376	6377	6380	6436	6611
				6613	6710	6711	6814	6815	6916	6917	7495	7729	7876	7965	8179
				8228	8331	8415	8458	8468	8546	8551	9163	9165	9252	9254	9337
				9339	9680	10184
SOURCE_ADDR			1228+
SPEC_ASK			  54	1447*
SPEC_DIALOGUE			  52	1381*
SPEC_PRT			  53	1414*
SRC				 581+	 582+	 594+	 595+
SS_MODE				 285+#
STEP_U_NEXT			1231+#	9807	9838	9890	9918	9966	9995	10042	10070	10128
STK_RESET			 283+#	10118	10126
STOP_CLK			1354#	2006	2348	7621	7625	7670	7675
SYNC_CLK			1329+	2592	2645	2830	2893	2982	4770	4850	4927	5007	5084	5164
				5244	5324	5406	7493	7727	7874	7963	8550	9161	9250	9335	9678
				10182
TE				1294+
TEMP				1918	1928#	1930	5474	5484#	5485	5487	5533	5545#	5546	5548	5596
				5606#	5607	5609	5651	5664#	5665	5667	5711	5725#	5726	5728	5770
				5784#	5785	5787	5828	5843#	5844	5846	5888	5903#	5904	5906	5947
				5960#	5961	5963	6010	6027#	6028	6030	6427	6437#	6438	6459	6480
				6502#	6503	6525	6547	6603	6614#	6615	6637	6659	6697	6712#	6713
				6737	6761	6801	6816#	6817	6840	6863	6903	6918#	6919	6942	6965
				7006	7018#	7019	7042	7075#	7076	7099	7132#	7133	7156	7189#	7190
				7213	7247#	7248	7271	7304#	7305	7328	7361#	7362	7385	7418#	7419
				7442	7479	7499#	7500	7524	8891	8897#	8898	8912	9149	9167#	9168
				9194	9238	9256#	9257	9281	9323	9341#	9342	9365
TEN_INT				 430+#	9017	9035	9088	9109
TERM_CARR			 435+#
TEST_EDIT			1366#
TEST_INIT			  55	1480*
TEST_VERSION			1365#
TEXT				1053+	1054+	1057+	1058+	1073+	1074+	1077+	1078+
TICK				1330+	1353	2361	2594	2897	2986	9255	9340
TIMOUT				1335+
TP				1293+	9805	9836
TRAP_ENB			 295+#
TST1				  61	1905*
TST10				  70	2423*
TST100				 160	10019*
TST101				 161	10095*
TST102				 162	10156*
TST11				  71	2461*
TST12				  72	2497*
TST13				  73	2533*
TST14				  74	2576*
TST15				  75	2619*
TST16				  76	2815*
TST17				  77	2857*
TST18				  78	2946*
TST19				  79	3034*
TST2				  62	1991*
TST20				  80	3146*
TST21				  81	3215*
TST22				  82	3286*
TST23				  83	3360*
TST24				  84	3403*
TST25				  85	3474*
TST26				  86	3553*
TST27				  87	3642*
TST28				  88	3738*
TST29				  89	3827*
TST3				  63	2067*
TST30				  90	3924*
TST31				  91	4013*
TST32				  92	4110*
TST33				  93	4199*
TST34				  94	4296*
TST35				  95	4401*
TST36				  96	4511*
TST37				  97	4625*
TST38				  98	4739*
TST39				  99	4819*
TST4				  64	2106*
TST40				 100	4899*
TST41				 101	4976*
TST42				 102	5053*
TST43				 103	5133*
TST44				 104	5213*
TST45				 105	5293*
TST46				 106	5373*
TST47				 107	5462*
TST48				 108	5522*
TST49				 109	5582*
TST5				  65	2184*
TST50				 110	5640*
TST51				 111	5698*
TST52				 112	5757*
TST53				 113	5816*
TST54				 114	5875*
TST55				 115	5935*
TST56				 116	5993*
TST57				 117	6065*
TST58				 118	6154*
TST59				 119	6201*
TST6				  66	2230*
TST60				 120	6248*
TST61				 121	6303*
TST62				 122	6358*
TST63				 123	6413*
TST64				 124	6592*
TST65				 125	6685*
TST66				 126	6789*
TST67				 127	6891*
TST68				 128	6993*
TST69				 129	7469*
TST7				  67	2265*
TST70				 130	7605*
TST71				 131	7654*
TST72				 132	7705*
TST73				 133	7853*
TST74				 134	7941*
TST75				 135	8058*
TST76				 136	8094*
TST77				 137	8128*
TST78				 138	8166*
TST79				 139	8208*
TST8				  68	2335*
TST80				 140	8315*
TST81				 141	8402*
TST82				 142	8444*
TST83				 143	8533*
TST84				 144	8591*
TST85				 145	8880*
TST86				 146	8944*
TST87				 147	9000*
TST88				 148	9065*
TST89				 149	9137*
TST9				  69	2386*
TST90				 150	9225*
TST91				 151	9310*
TST92				 152	9393*
TST93				 153	9426*
TST94				 154	9539*
TST95				 155	9597*
TST96				 156	9650*
TST97				 157	9782*
TST98				 158	9867*
TST99				 159	9942*
TTI_CLR				1135+#
TTI_DEC				1136+#
TTI_YES				1134+#
TT_ALTM				1133+#
U				 922+#	1514	1515	1516	1517	1518	1519	1520	1521	1522	1523	1524
				1525	1526	6076	6162	6209	6256	6257	6311	6312	6366	6367	6699
				6803	6905	7481	7718	7864	7952	9077	9151	9152	9240	9241	9325
				9326	9439	9440	9441	9442	9552	9553	9611	9612	9659	9660	9661
				9662	9663	9664	9665	9666	9793	9794	9795	9796	9878	9954	10031
				10107	10108	10109	10110	10111	10112	10113	10168	10169	10170	10171
UC_PTR				6076#	6080	6162#	6165	6209#	6212	6256#	6260	6311#	6315	6366#	6370
				6699#	6702	6803#	6806	6905#	6908	7481#	7487	7718#	7721	7864#	7868
				7952#	7957	9077#	9080	9151#	9155	9240#	9244	9325#	9329	9439#	9447
				9552#	9556	9611#	9615	9659#	9671	9793#	9801	9878#	9883	9954#	9959
				10031#	10036	10107#	10120	10168#	10175
UC_PTR1				9666#	9776
UUO				1017+	1039+	1043+	1047+	1051+	1055+	1059+	1063+	1067+	1071+	1075+	1079+
				1083+	1087+	1091+	1095+	1099+	1103+	1107+	1111+	1115+	1119+	1123+	1127+
				1129+	1133+	1134+	1135+	1136+	1140+	1144+	1145+	1146+	1147+	1148+	1149+
				1150+	1151+	1152+	1153+	1157+	1161+	1165+	1169+	1174+	1175+
U_0				 565+	 569+	 582+	 595+	 609+	 622+	 643+	 927+	 942+	 944+	 970+#
U_0_DEFAULT			 944+	 957+#	 970+
U_1				 664+	 675+	 686+	 706+	 710+	 715+	 719+	 723+	 728+	 732+	 761+	 771+
				 784+	 804+	 833+	 933+	 939+	 942+	 945+	 971+#
U_1_DEFAULT			 945+	 958+#	 971+
U_2				 839+	 843+	 847+	 851+	 855+	 859+	 863+	 867+	 871+	 875+	 881+	 894+
				 907+	 916+	 942+	 946+	 972+#
U_2_DEFAULT			 946+	 959+#	 972+
U_3				 702+	 933+	 939+	 947+	 973+#
U_3_DEFAULT			 947+	 960+#	 973+
U_A				 621+#	 624+	 625+	 626+	 627+	 628+	 629+	 630+	 631+	 632+	 633+	 634+
				 635+	 636+	 637+	 638+	 639+
U_ALU_ADD			 571+#	1519
U_ALU_AND			 575+#	1350
U_ALU_MASK			 576+#
U_ALU_OR			 574+#	1352	1518	9077	9439	9552	9611	9660	9661	9793
U_ALU_PARITY_OK			 701+#
U_ALU_RSUB			 573+#
U_ALU_SUB			 572+#
U_ALU_XNOR			 578+#	1351	1520	9662	9664
U_ALU_XOR			 577+#
U_ALU				 568+#	 571+	 572+	 573+	 574+	 575+	 576+	 577+	 578+
U_A_AR				 627+#	1518
U_A_ARX				 628+#	1519	1520
U_A_BR				 629+#
U_A_BRX				 630+#
U_A_EBR				 632+#
U_A_FLG				 635+#
U_A_HR				 626+#
U_A_MAG				 624+#
U_A_MASK			 634+#
U_A_ONE				 631+#
U_A_PC				 625+#
U_A_PI				 636+#
U_A_T0				 638+#
U_A_T1				 639+#	1350	1351
U_A_UBR				 633+#
U_A_XWD1			 637+#
U_B				 642+#	 645+	 646+	 647+	 648+	 649+	 650+	 651+	 652+	 653+	 654+	 655+
				 656+	 657+	 658+	 659+	 660+
U_BYTE				 760+#	 763+	 764+	 765+	 766+	 767+
U_BYTE_1			 763+#
U_BYTE_2			 764+#
U_BYTE_3			 765+#
U_BYTE_4			 766+#
U_BYTE_5			 767+#
U_B_AR				 648+#	1517
U_B_ARX				 649+#	1518	1519
U_B_BR				 650+#	1521
U_B_BRX				 651+#	1522
U_B_EBR				 653+#
U_B_FLG				 656+#
U_B_HR				 647+#
U_B_MAG				 645+#
U_B_MASK			 655+#
U_B_ONE				 652+#
U_B_PC				 646+#
U_B_PI				 657+#
U_B_T0				 659+#
U_B_T1				 660+#	1351
U_B_UBR				 654+#
U_B_XWD1			 658+#
U_CALL				 870+#	10109	10111
U_CHKL				 714+#
U_CHKR				 727+#
U_CRY38				 838+#
U_DBM_APR_FLAGS			 690+#
U_DBM_BYTES			 691+#
U_DBM_DP			 694+#
U_DBM_DP_SWAP			 695+#
U_DBM_EXP			 692+#
U_DBM_MEM			 697+#
U_DBM_MSEC			 693+#
U_DBM_N				 698+#	1523
U_DBM_PF_DISP			 689+#
U_DBM_SCAD			 688+#
U_DBM_VMA			 696+#
U_DBM				 685+#	 688+	 689+	 690+	 691+	 692+	 693+	 694+	 695+	 696+	 697+	 698+
U_DBUS				 674+#	 677+	 678+	 679+	 680+	 681+	 682+
U_DBUS_DBM			 682+#	9077	9439	9552	9611	9660	9661	9793
U_DBUS_DP			 680+#	1348	1515
U_DBUS_PC_FLAGS			 677+#
U_DBUS_PI_NEW			 678+#
U_DBUS_RAM			 681+#	1349
U_DBUS_VMA			 679+#
U_DEST				 608+#	 611+	 612+	 613+	 614+	 615+	 616+	 617+	 618+
U_DEST_A			 611+#
U_DEST_AD			 612+#	1517	1518	1519	1521	1522
U_DEST_AD_DIV2			 618+#
U_DEST_AD_MUL2			 616+#
U_DEST_PASS			 614+#
U_DEST_Q_AD			 613+#
U_DEST_Q_DIV2			 617+#
U_DEST_Q_MUL2			 615+#
U_DISP				 783+#	 786+	 787+	 788+	 789+	 790+	 791+	 792+	 793+	 794+	 795+	 796+
				 797+	 798+	 799+	 800+
U_DISP_ADISP			 792+#
U_DISP_AREAD			 788+#
U_DISP_BDISP			 793+#
U_DISP_BYTE			 798+#
U_DISP_CONSOLE			 786+#
U_DISP_DP			 791+#
U_DISP_DP_LEFT			 789+#
U_DISP_DROM			 787+#
U_DISP_EAMODE			 799+#
U_DISP_MUL			 795+#
U_DISP_NICOND			 797+#
U_DISP_NORM			 790+#
U_DISP_PAGEFAIL			 796+#
U_DISP_RETURN			 794+#	10113
U_DISP_SCAD0			 800+#
U_DIVIDE			 858+#
U_FMWRITE			 850+#	1348
U_GENL				 709+#
U_GENR				 722+#
U_J				 564+#	1514	1515	1516	1517	1518	1519	1520	1521	1522	1523	1524
				1525	1526	6256	6311	6366	9077	9151	9152	9240	9241	9325	9326
				9439	9440	9441	9442	9552	9553	9611	9612	9659	9660	9661	9662
				9663	9664	9665	9666	9793	9794	9795	9796	9878	9954	10031	10107
				10109	10111	10168	10169	10170	10171
U_LOADFE			 846+#	9151	9240	9325
U_LOADSC			 842+#
U_LSRC				 581+#	 584+	 585+	 586+	 587+	 588+	 589+	 590+	 591+
U_LSRC_0A			 588+#	1350	1518	1520
U_LSRC_0B			 587+#
U_LSRC_0Q			 586+#
U_LSRC_AB			 585+#	1351	1519	9662	9664
U_LSRC_AQ			 584+#
U_LSRC_D0			 591+#	1352
U_LSRC_DA			 589+#
U_LSRC_DQ			 590+#
U_MEM				 854+#	9662	9664	9665	10169	10170
U_MULTI_PREC			 862+#
U_MULTI_SHIFT			 866+#	9152	9241
U_N				 874+#	1523	6076	6162	6209	6256	6257	6311	6312	6366	6367	6699
				6803	6905	9077	9151	9240	9325	9439	9552	9611	9660	9661	9662
				9664	9665	9793	9794	10169	10170
U_NO_CLKL			 705+#
U_NO_CLKR			 718+#
U_RAM_AC			 666+#	1348	1349
U_RAM_AC_FN			 667+#
U_RAM_N				 671+#
U_RAM_RAM			 670+#
U_RAM_VMA			 669+#
U_RAM_XR			 668+#
U_RAM				 663+#	 666+	 667+	 668+	 669+	 670+	 671+
U_RSRC				 594+#	 598+	 599+	 600+	 601+	 602+	 603+	 604+	 605+
U_RSRC_0A			 602+#
U_RSRC_0B			 601+#
U_RSRC_0Q			 600+#
U_RSRC_AB			 599+#	9662	9664
U_RSRC_AQ			 598+#
U_RSRC_D0			 605+#	9077	9439	9552	9611	9660	9661	9793
U_RSRC_DA			 603+#
U_RSRC_DQ			 604+#
U_SCAD				 880+#	 883+	 884+	 885+	 886+	 887+	 888+	 889+	 890+
U_SCADA				 893+#	 896+	 897+	 898+	 899+	 900+	 901+	 902+	 903+
U_SCADA_BYTE1			 899+#
U_SCADA_BYTE2			 900+#
U_SCADA_BYTE3			 901+#
U_SCADA_BYTE4			 902+#
U_SCADA_BYTE5			 903+#
U_SCADA_PTR44			 898+#
U_SCADA_SC			 896+#
U_SCADA_SN			 897+#
U_SCADB				 906+#	 909+	 910+	 911+	 912+
U_SCADB_EXP			 910+#
U_SCADB_FE			 909+#
U_SCADB_SHIFT			 911+#
U_SCADB_SIZE			 912+#
U_SCAD_A			 890+#
U_SCAD_ADD			 887+#
U_SCAD_AND			 888+#
U_SCAD_A_DEC			 889+#
U_SCAD_A_MUL2			 883+#
U_SCAD_OR			 884+#
U_SCAD_SUBB			 885+#
U_SCAD_SUB			 886+#
U_SET_GENL			 711+	 931+	 964+#
U_SET_GENR			 724+	 937+	 965+#
U_SET_RSRC			 596+	 925+	 963+#
U_SET				 596+	 711+	 724+	 925+	 931+	 937+	 948+	 974+#
U_SHSTYLE			 770+#	 773+	 774+	 775+	 776+	 777+	 778+	 779+	 780+
U_SHSTYLE_ASHC			 777+#
U_SHSTYLE_DIV			 779+#
U_SHSTYLE_LSHC			 778+#
U_SHSTYLE_NORM			 773+#
U_SHSTYLE_ONES			 775+#
U_SHSTYLE_ROT			 776+#
U_SHSTYLE_ROTC			 780+#
U_SHSTYLE_ZERO			 774+#
U_SKIP				 803+#	 806+	 807+	 808+	 809+	 810+	 811+	 812+	 813+	 814+	 815+	 816+
				 817+	 818+	 819+	 820+	 821+	 822+	 823+	 824+	 825+	 826+	 827+	 828+
				 829+
U_SKIP_1_MS			 829+#	10031
U_SKIP_AC0			 813+#
U_SKIP_ADEQ0			 824+#
U_SKIP_ADLEQ0			 809+#
U_SKIP_ADREQ0			 810+#
U_SKIP_CONTINUE			 828+#	9954
U_SKIP_CRY0			 808+#
U_SKIP_CRY1			 821+#
U_SKIP_CRY2			 816+#
U_SKIP_DP0			 817+#
U_SKIP_DP18			 818+#
U_SKIP_EXECUTE			 826+#	9878
U_SKIP_FPD			 812+#
U_SKIP_INT			 814+#
U_SKIP_IOLGL			 806+#
U_SKIP_IOT			 819+#
U_SKIP_IO_BUSY			 827+#
U_SKIP_JFCL			 820+#
U_SKIP_KERNEL			 811+#
U_SKIP_LE			 815+#
U_SKIP_LLE			 807+#
U_SKIP_SC			 825+#
U_SKIP_TRAP_CYC			 823+#	9796
U_SKIP_TXXX			 822+#
U_SN				 915+#
U_SPEC				 731+#	 734+	 735+	 736+	 737+	 738+	 739+	 740+	 741+	 742+	 743+	 744+
				 745+	 746+	 747+	 748+	 749+	 750+	 751+	 752+	 753+	 754+	 755+	 756+
				 757+
U_SPEC_APRFLAGS			 744+#	9077	9442
U_SPEC_APR_EN			 746+#	1522	9439	9552	9611	9660	9661	9793
U_SPEC_ASHOV			 753+#
U_SPEC_CLRCLK			 735+#	1524
U_SPEC_CLRCSH			 745+#
U_SPEC_CLRIOBSY			 737+#
U_SPEC_CLRIOLAT			 736+#
U_SPEC_EXPTST			 754+#
U_SPEC_FLAGS			 755+#	1523	9794
U_SPEC_INHCRY18			 750+#
U_SPEC_LDACBLK			 756+#	1514
U_SPEC_LDINST			 757+#
U_SPEC_LDPAGE			 738+#	9662
U_SPEC_LDPI			 752+#	1525
U_SPEC_LDPXCT			 740+#
U_SPEC_LOADIR			 751+#	1515
U_SPEC_LOADXR			 743+#
U_SPEC_MEMCLR			 747+#	1526	9659	9666	10168
U_SPEC_N			 734+#	6076	6209	6256	6257	6311	6312	6366	6699	6803
U_SPEC_NICOND			 739+#	9795
U_SPEC_PREV			 742+#
U_SPEC_PXCT_OFF			 749+#
U_SPEC_SWEEP			 748+#
U_SPEC_WAIT			 741+#
U_T				 832+#	7481	7718	7864	7952	9151	9152	9240	9241	9325	9326
V_AC_DP				1348#	1516	1520
V_DP_D				1352#	1517	1521
V_DP__1				1351#	1516	1525
V_DP_0				1350#	1514	1515	1522	1523	1526
V_D_AC				1349#	1517	1521
WAIT				1276+
WRT100				1310+	1731	1732	8069	8070	8105	8106	8140	8141	8180	8249	8276
				8352	8416	8459	8547	8611	8612	8643	8644	8678	8679	8710	8711
				8746	8747	8778	8779	8813	8814	8845	8846	8953	8954	10040	10068
WRT102				1311+	4231	8605	8674	8741	8809
WRT103				1312+	4141	4232	5480	5539	5541	5602	5657	5717	5776	5834	5894
				5899	5954	6017	6020	7012	7067	7181	7238	7353	8462
WRT104				1313+	3956	4045	4142	8606	8675	8742	8810
WRT105				1314+	3955	4046	7013	7124	7239	7296	7410	8463
WRT106				1315+	3770	3859	4312	4418	4527	4641	4763	4843	4920	5000	5077
				5157	5237	5317	5399	8607	8676	8743	8811
WRT107				1316+	3769	3860	4313	4419	4528	4642	4762	4842	4919	4999	5076
				5156	5236	5316	5398	7014	7068	7125	7182	7240	7297	7354	7411
WRT110				1317+	2884	2973	3585	3674	4768	4848	4925	5005	5082	5162	5242
				5322	5404	8608	8642	8677	8709	8744	8777	8812	8844
WRT111				1318+	2883	2972	3584	3675	4769	4849	4926	5006	5083	5163	5243
				5323	5405	7015	7069	7126	7183	7298	7355	7412
WRT112				1319+	2882	2971	3433	3504	4765	4845	4922	5002	5079	5159	5239
				5319	5401	8609	8745
WRT113				1320+	2881	2970	3432	3505	4764	4844	4921	5001	5078	5158	5238
				5318	5400	7016	7241
WRT114				1321+	1621	2126	2151	2208	2895	2940	2983	3028	3054	3161	3230
				3302	3374	3503	3673	3858	4044	4230	4767	4814	4847	4894	4924
				4971	5004	5081	5128	5161	5208	5241	5288	5321	5368	5403	5457
				8604	9421
WRT115				1322+	1622	2243	2894	2941	2984	3029	4766	4815	4846	4895	4923
				4972	5003	5080	5129	5160	5209	5240	5289	5320	5369	5402	5458
				9422
WRT116				1323+	9456	9562	9621	9622
WRT204				1324+	1694	1695	5660	5661	5720	5721	5779	5780	5837	5838	5840
				5841	5897	5898	5956	5957	6019	6023	6024	8466	8467	9106	9107
				10118	10119	10126	10127
WRT205				1325+	1354	5482	5543	5604	5659	5719	5723	5778	5782	5836	5896
				5958	6025	8464	9015	9016	9034	9086	9108
WRT206				1326+	2646	2831	5662	5722	5781	5839	5901	6086	6087	6171	6172
				6218	6219	6266	6267	6270	6321	6322	6325	6376	6377	6380	6436
				6611	6613	6710	6711	6814	6815	6916	6917	7495	7497	7623	7672
				7729	7731	7876	7878	7965	7967	8179	8228	8331	8415	8458	8468
				8546	8551	8553	9163	9165	9252	9254	9337	9339	9680	9682	10184
				10186
WRT210				1327+	2011	2012	2032	2082	2127	2206	2244	2282	2283	2303	2349
				2400	2437	2474	2511	2549	2550	2591	2593	2896	2985	3055	3162
				3231	3304	3375	3434	3506	3586	3676	3771	3861	3957	4047	4143
				4233	4314	4420	4529	4530	4643	4644	4760	4771	4812	4813	4840
				4851	4892	4893	4917	4928	4969	4970	4997	5008	5048	5049	5074
				5085	5126	5127	5154	5165	5206	5207	5234	5245	5286	5287	5314
				5325	5366	5367	5396	5407	5409	5481	5483	5540	5542	5544	5603
				5605	5658	5663	5718	5724	5777	5783	5835	5842	5895	5900	5902
				5955	5959	6018	6021	6026	7017	7074	7131	7188	7246	7303	7360
				7417	8465	8613	8645	8680	8712	8748	8780	8815	8847
WRT212				1328+	6435	6610	6612	6709	6813	6915	9887	9915	9963	9992
WR_CRAM				1285+
X				 731+	 732+	 760+	 761+	 770+	 771+	 783+	 784+	 803+	 804+	 832+	 833+
				 880+	 881+	 893+	 894+	 906+	 907+
X1				1286+
X1A_AC				1028+#	1152+
X1B_AC				1029+#	1153+
XMIT_ADR			 312+#	2896	3434	3586	3771	3957	4143	4643	4644	4771	4851	4928
				5008	5085	5165	5245	5325	5407	5481	5540	5542	5603	5658	5718
				5777	5835	5895	5900	5955	6018	6021	7017	7074	7131	7188	7246
				7303	7360	7417	8465
XMIT_DATA			 311+#	2985	3055	3162	3231	3304	3375	3506	3676	3861	4047	4233
				4529	4530	8613	8645	8680	8712	8748	8780	8815	8847


TIME: 26 SEC.
CORE: 17K
   