;[toed.xkl.com]DXX:<KLAD.SOURCES>SMMON.MAC.2, 18-Apr-96 17:12:27, Edit by GORIN
;changed code in SELECT, it used an indeterminate form of BLT.

;*MAINDEC-10-SMMON

MCNVER=0
DECVER=3

	XLIST
DEFINE	NAME	(MCNVER,DECVER),<

TITLE	SMMON DECSYSTEM 2020 (KS-10) DIAGNOSTIC MONITOR, VERSION MCNVER'.'DECVER >
	LIST
	LALL

NAME	\MCNVER,\DECVER


;*THIS PROGRAM PROVIDES THE PROGRAM LOADING CAPABILITY FOR KS-10
;*DIAGNOSTICS.  PROVIDES FOR LOADING AND RUNNING SINGLE DIAGNOSTICS OR
;*CHAIN EXECUTION OF A SERIES OF DIAGNOSTICS.

;*THIS PROGRAM WILL EXECUTE KS-10 DIAGNOSTICS AND RELIABILITY
;*PROGRAMS THAT ARE CAPABLE OF BEING RUN UNATTENDED.
;*RUNS ON KS10 PROCESSORS

;*IT PROVIDES FOR CONTINUOUS TESTING FOR EQUIPMENT CHECKOUT
;*AND/OR FAST ITERATION OPERATION FOR MARGIN TESTING.

;*ALSO PROVIDES SPECIAL USER MODE OPERATION FOR KS-10.

;*COPYRIGHT 1978,1979
;*DIGITAL EQUIPMENT CORPORATION
;*MARLBORO, MASS. 01752

;*JOHN R. KIRCHOFF

	LOC	137
MCNVER,,DECVER

	NOSYM

;ASSEMBLE AS FOLLOWS:
;	SMMON.MAC

INLEND=26770			;COMMAND LIST END ADDRESS
SUBTTL	PARAMETERS

;*ACCUMULATORS

A=	1
B=	2
W=	4
Q=	5
M=	7

DPNTR=	5			;DISK CMD LIST INPUT POINTER
LET=	6			;LETTERS TYPIN FLAG
NAM=	7			;NAME GENERATION AC'S
NAM1=	10
NAM2=	11
DIGIT=	12			;DIGIT GENERATION AC'S
DIGITA=	13
DIGIT1=	14
DIGIT2=	15
IP=	16			;COMMAND INDEX POINTER
P=	17			;PUSHDOWN POINTER

LDCHN=	16			;USER LOAD CHANNEL

;*COMMAND DEFINITIONS

JOBSA=	120			;JOB STARTING ADDRESS
JOBFF=	121			;JOB FIRST FREE ADDRESS
JOBREL=	44			;JOB HIGHEST RELATIVE ADDRESS
FSELNK=	27772			;FILE SELECT LINK
FRDLNK=	27773			;FILE READ LINK
LDLNK=	27774			;LOAD LINK
DDTLNK=	27775			;DDT LINK
MODLNK=	27776			;MODE CHECK LINK
SUBLNK=	27777			;SUBROUTINE LINK

CHNCMD=	476			;CHANNEL COMMAND LIST

OPDEF	GO	[PUSHJ	P,0]
OPDEF	RTN	[POPJ	P,]
OPDEF	PUT	[PUSH	P,0]
OPDEF	GET	[POP	P,0]
OPDEF	PNTMSG	[GO	$PSIX]
OPDEF	PNTAL	[GO	TOUT]
OPDEF	TTICHR	[GO	TTYIN]
OPDEF	TTIOCT	[GO	TTYOCT]
OPDEF	SWITCH	[GO	$SWITCH]

OPDEF	CTYINI	[JSR	$TYINI]	;CTY INITIALIZATION
OPDEF	CTYCLR	[JSR	$TYCLR]	;CTY CLEAR
OPDEF	CTYTYI	[JSR	$CYTYI]	;CTY INPUT
OPDEF	CTYTYO	[JSR	$CYTYO]	;CTY OUTPUT
OPDEF	KTYTYI	[JSR	$KYTYI]	;CTY INPUT
OPDEF	KTYTYO	[JSR	$KYTYO]	;CTY OUTPUT
OPDEF	BTYTYI	[JSR	$BYTYI]	;CTY INPUT
OPDEF	BTYTYO	[JSR	$BYTYO]	;CTY OUTPUT

;*DIAGNOSTIC SPECIAL ADDRESSES

SUBRTN=	1005			;"SUBRTN" IDENTIFICATION WORD
DIAGNOS=30000			;DIAGNOSTIC START ADDRESS
DIAGMN=	30002			;PROG START ADDRESS
RETURN=	30012			;RETURN ADR STORAGE
$EMODE=	30031			;EXEC ALLOWED
$UMODE=	30032			;USER ALLOWED
ITRCNT=	30024			;PROG ITERATIONS
MONCTL=	30043			;DIAG MON CONTROL FLAG
RANDBS=	30022			;PROG RANDOM BASE
MONFLG=	30042			;SPECIAL USER CONTROL FLAG
MONTEN=	30044			;LOADED BY DIAMON FLAG
MARGIN=	30055			;KI10 MARGIN WORD
SMDDT=	10000			;SMDDT PROGRAM START ADDRESS

.LOC=	20000			;STARTING ADDRESS

;*SPECIAL DIAGNOSTIC START ADDRESSES

SFSTRT=	30004			;SPECIAL FEATURE START
PFSTRT=	30005			;POWER FAIL RESTART
REENTR=	30006			;PROGRAM REENTER START
DDT=	30007			;DDT START
START1=	30013			;START 1
START2=	30014			;START 2
START3=	30015			;START 3
START4=	30016			;START 4
START5=	30017			;START 5

;*SPECIAL PRE-BOOT ADDRESSES

MSRH=	36			;RH-11 BASE ADDRESS
MSDRIVE=37			;DRIVE NUMBER
MSSLAVE=40			;MAGTAPE SLAVE NUMBER
;*KS-10 EPT PARAMETERS

$STD=	440			;PDP-10 DIAGNOSTIC START ADDRESS
$DDT=	441			;PDP-10 DDT START ADDRESS
$STL=	442			;PDP-10 LOADER START ADDRESS
$STM=	443			;PDP-10 MONITOR START ADDRESS

$80STAT=31			;8080 STATUS WORD
$80MM=	1B13			;MAINTENANCE MODE BIT
$80CIW=	32			;8080 TO KS-10 INPUT WORD
$80COW=	33			;KS-10 TO 8080 OUTPUT WORD
$80KIW=	34			;8080 TO KS-10 INPUT WORD - KLINIK
$80KOW=	35			;KS-10 TO 8080 OUTPUT WORD - KLINIK
$80CHR=	1B27			;CHAR AVAIL BIT
$80INT=	012000			;INTERRUPT 8080

;*PROCESSOR CONTROL BITS

IOCLR=	200000			;APR, I/O CLEAR
PICLR=	10000			;PI, PI CLEAR
USERF=	10000			;USER MODE FLAG

TRPENB=	020000			;ENABLE TRAPS
USERF=	10000			;USER MODE FLAG
PAG=	010			;PAGING I/O DEVICE CODE
MUUO=	424			;MUUO STORAGE
MUUOPC=	425			;C(PC) OF MUUO STORAGE
UPMP=	17000			;USER PAGE MAP PAGE
LLDUSB=	140000			;LOAD SM10 USER BASE REGISTER

;*SWITCH ASSIGNMENTS, RH SW'S NOT USED BY CALLED PROG

LPTSW=	20000			;SW 4, PRINT ON LPT
ERSTOP=	2000			;SW 7, STOP ON ERROR
RELIAB=	400			;SW 9, RELIABILITY MODE
CHAIN=	4			;SW 15, INHIBIT PROGRAM TITLE PRINT

XPAND=	400000			;SW 18, EXPANDED CONTROL SEQUENCING

DEFINE	MSG	(ARG),<[SIXBIT\ARG'_\]>

DEFINE	PMSG	(ARG),<
	MOVEI	[SIXBIT\ARG'_\]
	PNTMSG>
;*IO INSTRUCTIONS

OPDEF	TIOE	[710B8]
OPDEF	TION	[711B8]
OPDEF	RDIO	[712B8]
OPDEF	WRIO	[713B8]
OPDEF	BSIO	[714B8]
OPDEF	BCIO	[715B8]
OPDEF	TIOEB	[720B8]
OPDEF	TIONB	[721B8]
OPDEF	RDIOB	[722B8]
OPDEF	WRIOB	[723B8]
OPDEF	BSIOB	[724B8]
OPDEF	BCIOB	[725B8]

;*UNIBUS BIT NUMBERS

EBIT0==1
EBIT1==2
EBIT2==4
EBIT3==10
EBIT4==20
EBIT5==40
EBIT6==100
EBIT7==200
EBIT8==400
EBIT9==1000
EBIT10==2000
EBIT11==4000
EBIT12==10000
EBIT13==20000
EBIT14==40000
SUBTTL	CONTROL SECTION

	LOC	421
	JFCL			;ARITHMETIC TRAP NO-OP
	HALT	.		;PUSHDOWN TRAP ERROR
	HALT	.		;TRAP 3 TRAP ERROR

	LOC	430
	432
	433
	HALT	.		;MUUO NO TRAP ERROR
	HALT	.		;MMUO TRAP ERROR

	LOC	442
	JRST	START		;"STL" START ADDRESS

	LOC	502
	503
	HALT	.		;PAGE FAIL ERROR

	LOC	.LOC

;*START - STARTING ADDRESS AND CONTROL FLAGS

START:	JRST	SELECT
RESTRT:	JRST	RUN
TITLE:	JRST	WHAT
RERUN:	JRST	RERUN1
ONETIM:	JRST	ONETM1
ITERAT:	0
USER:	0
CONSW:	0			;USER MODE SWITCHES
SMFLG:	0
KAIFLG:	0
SUSERF:	0
PASS:	0
ONCE:	0
RANBAS:	0
TTYSPD:	0			;TTY BAUD RATE
MONTYP:	0			;0 = TOPS-10, -1 = TOPS-20
;*ONETM1 - STARTUP & PROCESSOR TYPE DETERMINATION

ONETM1:	MOVE	JOBREL		;SAVE "DIAMON" MAX SIZE
	MOVEM	SVJBREL#
	SETZM	ONCE
	SETZM	CONSW

;*SELECT - START/RESTART INITIALIZATION

SELECT:	SETZM	USER
	JSP	0,.+1
	TLNE	0,USERF
	SETOM	USER		;USER MODE
	SKIPE	USER
	JRST	.+4
	CONO	PI,PICLR
	CONO	APR,IOCLR
	CONO	PAG,0		;PAGING CLEAR
	MOVE	P,[-40,,PLIST]
	SETZM	SMFLG
	SETZM	KAIFLG
	SETZ	1,		;source 0, dest 0
	BLT	1,0		;copy 1 word from 0 to 0
	SKIPN	1		;BLT changes AC on SM10 (and KL10)
	HALT	.		;WRONG PROCESSOR
	SETOM	SMFLG
	GO	SMINT		;KS-10, INIT TTY
	SKIPE	USER
	GO	USRINT		;USER INITIALIZATION
	MOVE	1,PGNAME
	SKIPE	USER
	GO	SNAME		;USER, SET NAME BACK
	SKIPE	ONCE
	JRST	SELX		;NOT FIRST TIME
	MOVEI	HEADER
	PNTAL			;PRINT HEADER
	GO	AUTOSL		;SELECT LOAD DEVICE
;*SELX - DIAMON LINKAGE SETUP

SELX:	MOVEI	30001		;SETUP $START AS
	MOVEM	27774		;LOAD LINK
	MOVEI	FSELECT		;SETUP FILE SELECT LINK
	MOVEM	FSELNK
	MOVEI	FREAD		;SETUP FILE READ LINK
	MOVEM	FRDLNK
	SETZM	PGMGO
	MOVE	[PGMGO,,PGMGO+1]
	BLT	CNSFLG
	MOVE	[SIXBIT/SUBRTN/]
	CAMN	SUBRTN		;IS "SUBRTN" LOADED ?
	JRST	SELX1		;YES

;*AUTOMATICALLY LOAD "SUBSM" AND "SMDDT"

	SKIPN	USER
	JRST	.+5		;EXEC
	MOVEI	IP,[SIXBIT/SUBUSR/
		    0]
	GO	DIAGLD-2	;USER, LOAD "SUBUSR"
	JRST	SELX1		;CAN'T FIND, ALREADY REPORTED
	JRST	.+4
	MOVEI	IP,[SIXBIT/SUBSM/
		    0]
	GO	DIAGLD-2	;EXEC, LOAD "SUBSM"
	JRST	SELX1		;CAN'T FIND, ALREADY REPORTED
	MOVEI	IP,[SIXBIT/SMDDT/
		    0]
	GO	DIAGLD-2	;LOAD DDT ALSO
	JRST	SELX1
	MOVEI	$DDT
	MOVEM	74		;SET USER DDT START ADDRESS
	SKIPE	USER
	SKIPE	MONTYP
	SKIPA
	SETDDT
;*PROCESS OPERATOR COMMAND

SELX1:	SETOM	ONCE
	MOVE	P,[-40,,PLIST]
	MOVEI	IP,SELSTR
	GO	CRLF1		;TYPE A CARRIAGE AND LINE FEED
	MOVE	A,PGNAME	;GET PROGRAM NAME
	GO	SIXBP		;PRINT IT
	SETOM	ASKSW#
	MOVSI	ERSTOP
	MOVEM	CONSW		;SET TO STOP ON ERROR IN CHAIN MODE
	PMSG	< CMD - >
	GO	FLNAME		;GET COMMAND OR FILE NAME
	JFCL
	MOVEI	IP,SELSTR
	SETZM	1
	MOVE	(IP)

CMDLP:	SKIPN	CMDLST(1)	;CHECK FOR SPECIAL COMMANDS
	AOJA	1,CMDLP1	;NOT IN FIRST PART OF LIST
	CAMN	CMDLST(1)
	JRST	CMDEX		;FOUND
	AOJA	1,CMDLP

CMDEX:	MOVE	0,CMDADR(1)	;GET START ADDRESS
	JRST	@0		;GO TO COMMAND ROUTINE

CMDLP1:	SKIPN	CMDLST(1)	;SPECIAL START COMMANDS
	JRST	RUNPR2		;NOT FOUND, MUST BE PROGRAM NAME
	CAMN	CMDLST(1)
	JRST	CMDEX1		;FOUND
	AOJA	1,CMDLP1

CMDEX1:	MOVE	0,CMDADR(1)	;GET SPECIAL START ADDRESS
	HRRM	SADR		;SET FOR START
	JRST	SADRQ		;GO START
SUBTTL	RUNPRG - RETRIEVE AND RUN SINGLE PROGRAM

RUNPRG:	PMSG	<^FILE.EXT - >
	MOVEI	IP,INLIST
	GO	FLNAME		;GET FILE NAME
	JFCL

RUNPR1:	MOVEI	IP,INLIST
	HLRZ	(IP)
	CAIN	(SIXBIT/G/)
	JRST	SADRQ
	SKIPN	(IP)
	JRST	EX4		;NO PROGRAM TO RUN

	HLLZ	1(IP)		;GET EXT
	JUMPN	.+5		;EXT SUPPLIED ?
	SKIPN	DEVFLG		;DOING DEVICE COMMAND FILE ?
	JRST	.+3		;NO
	MOVSI	(SIXBIT/CMD/)	;YES, USE "CMD" AS DEFAULT EXT
	HLLM	1(IP)

	MOVEM	IP,SAVEIP
	SETOM	PGMGO		;SET LOAD & GO FLAG

	GO	DIAGLD		;GO GET PROGRAM
	JRST	.+2

	JRST	DEVCM1		;MUST BE DEVICE COMMAND LIST
	SKIPN	ALTMFLG		;ALTMODE SELECTION ?
	JRST	SELECT		;NO, ERROR
	SETZM	ALTMFLG
	JRST	RUNPRG		;YES, ASK FOR NEXT PROGRAM

RUNPR2:	MOVE	SELSTR
	MOVEM	INLIST
	MOVE	SELSTR+1
	MOVEM	INLIST+1
	SETZM	INLIST+3
	JRST	RUNPR1

TT2CHR:	TTICHR			;INPUT 1ST CHAR
	CAIN	12
	RTN			;ONLY A CR
	MOVEM	0,LET
	TTICHR			;INPUT 2ND CHAR, SHOULD BE CR
	CAIE	12
	JRST	SELECT		;WASN'T
	MOVE	0,LET		;GET 1ST CHAR BACK
	JRST	CPOPJ1		;SKIP RETURN

SELXR:	GO	DEVSEL		;SELECT DEVICE
	JRST	SELX

SNAME:	SKIPE	MONTYP
	SETNM
	SKIPN	MONTYP
	SETNAM	T1,
	RTN
CMDLST:	SIXBIT/H/
	SIXBIT/I/
	SIXBIT/T/
	SIXBIT/D/
	SIXBIT/S/
	SIXBIT/F/
	SIXBIT/L/
	SIXBIT/G/
	SIXBIT/X/
	SIXBIT/R/
	SIXBIT/SMMON/
	SIXBIT/SMMAG/
	SIXBIT/SMAPT/
	0
	SIXBIT/STD/
	SIXBIT/STL/
	SIXBIT/STM/
	SIXBIT/DDT/
	SIXBIT/START/
	SIXBIT/SFSTRT/
	SIXBIT/PFSTRT/
	SIXBIT/REE/
	SIXBIT/START1/
	SIXBIT/START2/
	SIXBIT/START3/
	SIXBIT/START4/
	SIXBIT/START5/
	0
CMDADR:	CMDHLP
	STORED
	TTYCMD
	DEVCMD
	RUNPRG
	DIRECT
	LIST1
	SADRQ
	SAXPN
	SELXR
	SMMON
	SMMAG
	SMAPT
	0
	$STD
	$STL
	$STM
	$DDT
	DIAGNOS
	SFSTRT
	PFSTRT
	REENTR
	START1
	START2
	START3
	START4
	START5
;*WHAT - IDENTIFY LAST PROGRAM

WHAT:	MOVE	P,[-40,,PLIST]
	GO	CRLF1
	MOVE	IP,SAVEIP
	GO	NAMPNT		;PRINT TITLE OF LAST PROGRAM
	JRST	START

;*NAMPNT - PRINT FILE NAME AND EXTENSION

NAMPNT:	MOVE	A,(IP)
	GO	SIXBP
	MOVEI	"."
	GO	PRINT
	HLLZ	A,1(IP)
	GO	SIXBP
	GO	CRLF1
	RTN

;*SIXBP - SIX BIT PRINTER

SIXBP:	MOVEI	B,0		;SO DON'T SHIFT IN JUNK
	SETZM	F
	LSHC	F,6		;GET A SIXBIT CHAR
	ADDI	F,40		;MAKE IT ASCII
	GO	PRINT		;TYPE IT
	JUMPN	A,SIXBP		;IF ANY MORE, TYPE THEM
CPOPJ:	RTN

;*PNT16 - PRINT ASCII CHAR IN AC16

PNT16:	PUT	0
	MOVE	0,16
	GO	PRINT
	GET	0
	RTN

;*CMDHLP, PRINT HELP TEXT

CMDHLP:	SKIPE	HLPCLR#		;HAS HELP BEEN OVERWRITTEN ?
	JRST	.+4		;YES
	MOVEI	HELP		;PRINT HELP
	PNTAL
	JRST	START
	PMSG	<NO HELP>
	JRST	START
SUBTTL	COMMAND LIST PROCESSING

;*STORED - USE INTERNAL COMMAND LIST

STORED:	SETZM	LPTFLG
	GO	CXPND		;SETUP EXPANDED OPERATIONS
	JRST	EX

;*TTYCMD - TELETYPE INPUT COMMAND LIST

TTYCMD:	PMSG	<^NAME]PASSES]RH SWS]ITERATIONS^>
CMNCMD:	MOVEI	IP,INLIST
	GO	FLNAME
	JRST	.-1		;INPUT TILL ^Z
	JRST	STORED

;*DEVCMD - DEVICE COMMAND LIST

DEVCMD:	SETZM	ASKSW
	SETOM	DEVFLG		;SET DEVICE CMD LIST FLAG
	JRST	RUNPRG		;GET COMMAND FILE

DEVCM1:	SETZM	DEVFLG		;CLEAR DEVICE CMD LIST FLAG
	SETOM	DINFLG		;SET "READ" FOR DEVICE IN
	SETZM	PGMGO		;CLEAR FOR COMMAND OPERATION
	MOVE	DPNTR,[POINT 7,31000]
	JRST	CMNCMD		;GO RUN COMMAND LIST

DEVCM2:	MOVE	13,[POINT 7,31000]
	GO	LDACHR		;READ A CHAR
	JRST	.+3		;EOF
	IDPB	16,13
	JRST	.-3
	MOVEI	16,177		;FLAG END OF INPUT
	IDPB	16,13
CPOPJ1:	AOS	(P)		;DONE, RETURN TO "DEVCM1"
	RTN

DEVRD:	ILDB	0,DPNTR		;GET CHARS FROM 31000 UP
	JUMPE	0,.-1		;IGNORE NULLS
	CAIN	0,177
	JRST	CPOPJ1		;177 BYTE SIGNIFIES END
	JRST	READ1		;FOR "READ"
SUBTTL	FLNAME - FILE NAME AND CONTROL INFO INPUT

FLNAME:	SETZM	SCFLAG
	SETZM	SUSERF
	TLO	LET,400000	;SET LETTERS FLAG
	SETZ	NAM1,		;CLEAR CONTROLS
	SETZB	NAM,DIGIT
	MOVEI	NAM2,^D30	;SETUP CHAR POSITIONING

;*FLNMLP - INPUT AND PROCESS CHARACTERS

FLNMLP:	GO	READ
	CAIN	32
	JRST	CPOPJ1		;^Z, LOGICAL END OF INPUT
	CAIN	12
	JRST	CRRTN		;CR, (ACTUALLY LF) COMPLETES LINE
	SKIPE	SCFLAG
	JRST	FLNMLP		;<;> TYPED, IGNORE REST OF LINE
	CAIN	73
	JRST	SCSET		;<;>
	CAIN	177
	JRST	RBOUT		;RUBOUT
	CAIN	55		;MINUS IS SPECIAL USER MODE FLAG
	JRST	MINUS
	CAIN	11
	JRST	TTAB		;TAB IS FIELD SEPARATOR
	JUMPE	FLNMLP		;REJECT 0'S
	JUMPGE	LET,FLNAM2	;JUMP IF ASSEMBLE DIGITS

;*FLNAM1 - FILE NAME PROCESS

FLNAM1:	CAIN	56
	JRST	PERIOD		;DOT, NAME.EXT SEPARATOR
	SUBI	40		;CONVERT TO 6BIT
	JUMPL	RBOUT		;CNTL CHAR, TREAT AS RUBOUT
	JUMPE	RBOUT		;0 IS ERROR
	LSH	0,(NAM2)	;POSITION CHAR
	IOR	NAM,0		;MERGE INTO NAME
	SUBI	NAM2,6		;CHANGE POSITIONING FOR NEXT
	JRST	FLNMLP		;GET NEXT CHAR
;*PERIOD - STORE FILE NAME, GO PROCESS EXTENSION

PERIOD:	MOVEM	NAM,NAM1	;SAVE FILE NAME
	JRST	FLNAME+4	;PROCESS EXTENTION

;*FLNAM2 - PROCESS DIGITS

FLNAM2:	MOVE	DIGITA,0
	LSH	DIGITA,^D33
	LSHC	DIGIT,3		;ASSEMBLE DIGITS
	JRST	FLNMLP

;*TTAB - FIELD SEPARATOR, STORE PREVIOUS FIELD

TTAB:	MOVEM	DIGIT1,DIGIT2
	MOVEM	DIGIT,DIGIT1
	SETZB	LET,DIGIT
	JRST	FLNMLP-1

;*MINUS - SET SPECIAL USER MODE

MINUS:	SETOM	SUSERF		;MINUS, SET SPECIAL USER FLAG
	JRST	FLNAME+3

;*SCSET - SEMICOLON, REST IS COMMENT

SCSET:	SETOM	SCFLAG
	JRST	FLNMLP

;*ZEROAC - ZERO AC'S BEFORE STARTING PROGRAM

ZEROAC:	MOVSI	16,-16
	SETZM	0(16)
	AOBJN	16,.-1
	SETZM	16
	RTN

RBOUT:	PMSG	<XXX^>
	JRST	FLNAME
;*COMMAND LIST FORMAT
;*	NAME
;*	EXT,,ITERATIONS	(BIT 18 SET IF SPEC USER)
;*	PASSES,,SWITCHES

;*CRRTN - CR, STORE COMMAND LIST INFORMATION

CRRTN:	SETZM	SCFLAG
	SKIPN	NAM
	JUMPE	NAM1,FLNAME	;REPEAT IF JUST CR
	SKIPN	NAM1		;NAME ONLY ?
	EXCH	NAM,NAM1	;YES
	MOVEM	NAM1,(IP)	;STORE THE FILE NAME
	HLLZM	NAM,1(IP)	;AND EXTENSION
	TRZ	DIGIT,400000
	SKIPE	SUSERF
	TRO	DIGIT,400000	;SET SPEC USER BIT
	HRRM	DIGIT,1(IP)	;ITERATIONS (IF SPEC USER BIT 18 SET)
	HRL	DIGIT1,DIGIT2	;PASSES,,SWITCHES
	MOVEM	DIGIT1,2(IP)
	ADDI	IP,3		;INCREMENT POINTER
CRRTN1:	SETZM	(IP)		;CLEAR LAST WORD
	CAIL	IP,HELP		;OVERWRITTEN HELP MESSAGE
	SETOM	HLPCLR		;YES, NO MORE HELP AVAILABLE
	CAIGE	IP,INLEND
	RTN

FULL:	PMSG	<^?CMDLST TOO LONG>
	JRST	START

EXNOE:	PMSG	<^%USER ONLY>
	JRST	EXBAD

EXNOU:	PMSG	<^%EXEC ONLY>

EXBAD:	MOVEI	0,1		;SET CMD LIST PASS COUNT TO INHIBIT
	HRLM	0,2(IP)		;FURTHER REQUEST OF THIS PROGRAM
	PMSG	<^%UNCHAINABLE->
	GO	NAMPNT		;INCORRECT FORMAT
	JRST	RET
SUBTTL	EXECUTE THE INPUT COMMAND LIST

;*EX - INITIALIZATION

EX:	SETZM	PASS
	GO	CRLF1
	SKIPN	ASKSW
	GO	LHSWS		;GET LH CONTROL SWITCHES
	SETOM	ASKSW
EX5:	SETZM	RUNCTL
	MOVEI	IP,INLIST	;INIT LIST POINTER
	AOS	PASS

;*EX1 - START PASS

EX1:	MOVEM	IP,SAVEIP
	SETZM	SUSERF
	SKIPN	(IP)
	JRST	EX4		;NO PROGRAMS TO RUN
	HLRZ	1,2(IP)		;GET PASSES TO RUN
	JUMPE	1,.+3		;0, RUN ALWAYS
	CAMGE	1,PASS		;RUN FOR REQUESTED PASSES
	JRST	RET
	MOVE	1(IP)		;PROG RUN IN SPECIAL
	TRNE	400000
	SETOM	SUSERF		;USER MODE ?

;*EX2 - PRINT NAME AND LOAD PROGRAM

EX2:	SWITCH			;READ SWITCHES
	TLNN	0,CHAIN		;INHIBIT TITLE PRINT ?
	GO	NAMPNT
	GO	CKTTY		;CHECK TTY FOR ^C ABORT
	GO	DIAGLD-2	;GET THE PROGRAM
	JRST	RET		;PROGRAM NOT FOUND
	GO	CKTTY		;CHECK TTY FOR ^C ABORT
;*EX3 - SETUP PROGRAM OPERATION PARAMETERS

EX3:	SKIPE	CMDFLG
	JRST	DEVCM1		;REQUESTED NEW COMMAND LIST
	MOVE	IP,SAVEIP
	HRRZ	1,1(IP)		;GET THE ITERATION COUNT
	TRZ	1,400000	;CLEAR SPEC USER, IF SET
	SWITCH			;READ SWITCHES
	TLNN	0,RELIAB	;RELIABILITY MODE ?
	LSH	1,-6		;NO, 100(8):1 REDUCTION
	SKIPN	1
	ADDI	1,1		;ALWAYS ALLOW 1 ITERATION
	MOVEM	1,ITERAT
	MOVN	PASS
	HRL	2(IP)		;SETUP MONITR CONTROL
	MOVE	1,30002
	CAME	1,[JRST	@27774]
	JRST	EXBAD		;INCORRECT FORMAT
	SKIPE	USER		;IN USER MODE ?
	JRST	EXUSR		;YES

EXEXEC:	SKIPE	$EMODE		;EXEC, THIS PROG RUN IN EXEC ?
	JRST	EXNEW		;YES
	JRST	EXNOE		;NO
EXUSR:	SKIPE	$UMODE		;USER, THIS PROGRAM RUN IN USER ?
	JRST	EXNEW		;YES
	JRST	EXNOU		;NO

EXNEW:	SETOM	RUNCTL
	MOVSM	MONCTL		;LH = -PASS COUNT, RH = RH SWITCHES
	MOVE	0,RANBAS	;GENERATE PROG RANDOM BASE NUMBER
	ADD	0,[165742335216]
	ROT	0,-1
	EQVB	0,RANBAS
	MOVEM	0,RANDBS	;PUT IN PROG DATA AREA
;*RERUN1 - DISPATCH TO EXPANDED SETUP

RERUN1:	JRST	XPNRUN

;*RUN - PROGRAM RUN, CLEAR PROCESSOR FOR NEXT

RUN:	SKIPE	USER
	JRST	.+^D8
	BTYTYI
	JRST	.+4
	HALT	.
	CAIN	0,003
	JRST	START		;CONTROL C
	CONO	PI,PICLR
	CONO	APR,IOCLR
	MOVE	P,[-40,,PLIST]
	MOVE	IP,SAVEIP
	GO	SMINT		;CLEAR SM

;*RET - ANY MORE PROGRAMS ON COMMAND LIST

RET:	ADDI	IP,3		;INCREMENT POINTER TO NEXT COMMAND
	SKIPE	(IP)
	JRST	EX1		;RUN NEXT PROGRAM
	SKIPN	RUNCTL		;ANY PROGRAMS RUN THIS PASS ?
	JRST	EX4		;NO
	GO	CRLF1		;PRINT A CARRIAGE RETURN AND LINE FEED
	MOVE	A,PGNAME	;GET PROGRAM NAME
	GO	SIXBP		;PRINT IT
	PMSG	< PASS >
	MOVE	PASS		;PRINT PASS COUNTER
	GO	PNTDEC
	GO	CRLF1
	JRST	EX5

;*EX4 - ALL FINISHED

EX4:	PMSG	<^CMD'S REQUIRED>
	JRST	SELECT
SUBTTL	EXPANDED COMMAND FORMAT SETUP

;*CXPND - EXPANDED ALLOWED

CXPND:	SKIPE	USER
	RTN			;NO EXPANDED FEATURES IN USER MODE

CXPND1:	SWITCH
	TRNN	XPAND		;ALLOW EXPANDED FEATURES ?
	RTN			;NO

;*STRD3 - SPECIAL USER MODE

STRD3:	PMSG	<^Y OR A FOR SPECIAL USER MODE - >
	GO	TT2CHR
	JRST	STRD4		;CR, NO SPECIAL USER
	CAIN	"Y"
	SETOB	0,USRFLG	;IF Y SET FLAG
	CAIN	"A"		;A, USER AFTER 1ST PASS
	JRST	STRD3A
	JUMPGE	0,STRD3		;OTHER IS GOOF

STRD3A:	MOVEM	0,USRFLG	;USRFLG + ='S
				;SPECIAL USER AFTER 1ST PASS
STRD4:	RTN
SUBTTL	SPECIAL RUN SEQUENCING

;*XPNRUN - DETERMINE AND SETUP FOR SPECIAL OPERATIONS

XPNRUN:	MOVE	ITERAT
	MOVEM	USRITR#

XPNRN1:	SKIPE	USER
	JRST	XPNRN2		;USER MODE
	SKIPE	USRFLG
	JRST	USRRUN		;SPECIAL USER MODE OPERATION

XPNRN2:	MOVE	0,ITERAT
	MOVEM	0,ITRCNT
	MOVEI	USSR2
	MOVEM	RETURN

XPNRN3:	GO	ZEROAC
	SETZM	17
	JRST	DIAGMN		;GO TO PROGRAM

;*USRRUN - SPECIAL USER MODE RUN SEQUENCING

USRRUN:	SKIPN	SUSERF		;ALLOW SPECIAL USER ?
	JRST	XPNRN2		;NO, RUN IN EXEC
	MOVEI	1
	MOVEM	ITERAT		;RETURN TO DIAMON AFTER EACH PASS
	SKIPG	USRFLG		;USRFLG - ='S RUN ALL
	JRST	.+4		;PASSES
	MOVE	2,PASS		;USRFLG + AND PASS 1 ='S
	CAIN	2,1		;RUN IN EXEC MODE
	JRST	XPNRN2
	MOVE	ITERAT
	MOVEM	ITRCNT
	SETZM	MONFLG		;CLEAR MONFLG
	MOVSI	1,-400		;SETUP USER PAGE MAP
	MOVE	0,[557776,,557777]
;*SETUP PAGE MAP AND TRAPS

	ADD	0,[2,,2]
	MOVEM	0,UPMP(1)
	AOBJN	1,.-2
	MOVE	0,[UPMP+160,,UPMP+400]	;SET EPPM SAME AS USER 340-377
	BLT	0,UPMP+417
	MOVE	0,[JSR USRERR]
	MOVEM	0,UPMP+420
	MOVEM	0,UPMP+422
	MOVEM	0,UPMP+423
	MOVSI	0,(JFCL)
	MOVEM	0,UPMP+421
	MOVEI	0,MUUOER
	MOVEM	0,UPMP+430
	MOVEM	0,UPMP+431
	MOVEM	0,UPMP+432
	MOVEM	0,UPMP+433
	MOVEI	0,MUUOH		;SETUP FOR HANDLER
	MOVEM	0,UPMP+434
	MOVEM	0,UPMP+435
	MOVEM	0,UPMP+436
	MOVEM	0,UPMP+437
	GO	PAGSM		;SM10
	JRSTF	@.+1
	USERF,,.+1		;ENTER USER MODE
	JRST	1,.+1		;ENTRY
	MOVEI	USSR1
	MOVEM	RETURN
	JRST	XPNRN3		;GO TO PROGRAM

;*USSR1 - PROGRAM COMPLETION CONTROL

USSR1:	77B8			;MUUO 77, RETURN TO EXEC MODE
USSR2:	SKIPE	USER
	JRST	RESTRT		;USER MODE, COMPLETED
	JRST	USSR3
PAGSM:	MOVEI	0,USRERR+1
	MOVEM	0,UPMP+427
	CONO	PAG,TRPENB
	DATAO	PAG,[LLDUSB,,400000!<UPMP_-^D9>]
	RTN

USSR3:	CONO	PAG,TRPENB
	DATAO	PAG,[LLDUSB,,400000]

USSR4:	SKIPE	SUSERF		;RUNNING SPECIAL USER ?
	SOSN	USRITR		;YES, FINISHED USER ITERATIONS ?
	JRST	RESTRT		;FINISHED ALL ITERATIONS
	JRST	XPNRN1		;NOT FINISHED, CONTINUE

;*MUUOER & USRERR - USER ERROR REPORTING

MUUOER:	MOVEI	MSG	<^?MUUO ERROR^>
	JRST	.+3

USRERR:	0
	MOVEI	MSG	<^?USER TRAP ERROR^>
	PNTMSG
	HALT	START
SUBTTL	SPECIAL USER MODE I/O HANDLER

MUUOH:	MOVEM	0,ACS0#		;SAVE AC0 AND AC1
	MOVEM	1,ACS1#
	HLRZ	1,UPMP+MUUO	;GET MUUO INSTRUCTION FIELD
	LSH	1,-^D9
	CAIN	1,257
	JRST	EXC		;IF MAP, DO AS MUUO FOR SM10
	MOVE	1,UPMP+MUUO	;GET MUUO
	JUMPGE	1,JRSTX		;A JRST, JEN OR MUUO
EXC:	MOVE	1,ACS1		;RESTORE AC1
	XCT	UPMP+MUUO	;EXECUTE
	SKIPA
	AOS	UPMP+MUUOPC	;INC RETURN IF CONSO, CONSZ SKIP
EXC1:	MOVEM	1,ACS1		;RESAVE AC1
	JRST	EXC4
EXC5:	MOVE	1,UPMP+MUUOPC	;SETUP RETURN
	TLO	1,USERF
	HLLM	1,EXC2		;SETUP FLAGS
	HRRM	1,EXC3		;SETUP RETURN PC
	MOVE	1,ACS1		;RESTORE AC1
	JRSTF	@.+1		;RESTORE FLAGS, GO TO USER
EXC2:	0,,.+1
EXC3:	JRST	1,0		;ENTRY

EXC4:	CONI	PAG,1
	TRO	1,TRPENB
	CONO	PAG,(1)
	DATAO	PAG,[LLDUSB,,400000!<UPMP_-^D9>]
	JRST	EXC5
JRSTX:	TLNE	1,700000
	JRST	JRSTX1
	TLC	1,077000
	TLCE	1,077000
	JRST	MUUOER		;INCORRECT MUUO
	JRST	USSR2		;MUUO 77, RETURN TO DIAG MON
JRSTX1:	TLNE	1,200
	HALT	@UPMP+MUUOPC	;HALT, POINTING TO ACTUAL HALT
	JRST	10,.+1		;JEN, DISMISS INTERRUPT
	JRST	EXC1

;*SAXPN - STANDALONE EXPANDED RUNNING
;*	  SPECIAL USER AND/OR MARGINS

SAXPN:	SKIPE	USER
	JRST	SELECT		;ILLEGAL IN USER MODE
	SETOM	ITERAT		;RUN PROGRAM FOREVER
	SWITCH
	HRLI	-1
	MOVEM	MONCTL		;LH = -PASS CNT, RH = RH SWS

	GO	STRD3		;SETUP 	EXPANDED FEATURES

	SKIPE	USRFLG		;IF SPECIAL USER WAS SELECTED
	SETOM	SUSERF		;SET FLAG TO RUN THAT WAY

	JRST	XPNRUN		;GO RUN PROGRAM
SUBTTL	MESSAGE PRINTER

;*PNTMSG - PRINT SIXBIT MESSAGES

$PSIX:	PUT	2
	PUT	3
	PUT	4
	HRRZ	4,0		;MESSAGE ADDRESS

$PSIX1:	MOVEI	3,6		;6 CHARS PER 6BIT WORD
	MOVE	1,(4)		;GET FIRST/NEXT WORD OF MESSAGE

$PSIX2:	SETZ	2,
	ROTC	1,6		;C(AC2)= CHAR TO BE PRINTED
	CAIN	2,77
	JRST	$PSIX5		;"BACKARROW", DONE
	CAIN	2,76
	JRST	$PSIX4		;"UPARROW", CR/LF
	CAIN	2,75
	MOVEI	2,151		;"BRACKET", CHANGE TO TAB
	MOVEI	0,40(2)		;CHANGE TO ASCII
	GO	PRINT		;PRINT CHAR
$PSIX3:	SOJN	3,$PSIX2	;PRINTED ALL CHARS FROM THIS WORD ?
	AOJA	4,$PSIX1	;YES, DO NEXT WORD

$PSIX4:	MOVEI	15
	GO	PRINT		;PRINT CR
	MOVEI	12
	GO	PRINT		;PRINT LF
	JRST	$PSIX3

$PSIX5:	GET	4
	GET	3
	GET	2
	RTN

;*PNTAL - PRINT ASCII MESSAGES

TOUTA:	AOSA	.+2		;INCREMENT MSG ADDRESS
TOUT:	HRRM	0,.+1		;C(0) = ADR OF MSG
	MOVE	1,0		;GET CHARACTERS
	TRO	1,1		;SET FLAG BIT
	LSHC	0,7		;CHAR TO 0
	ANDI	177		;MASK
	SKIPN	0		;IF NULL, EXIT
	RTN
	GO	PRINT		;PRINT C(0)
	CAME	1,[400000,,0]
	JRST	TOUT+3		;GET NEXT CHAR IN WORD
	JRST	TOUTA		;GET NEXT WORD
;*PNTOCT - PRINT OCTAL NUMBERS

PNTOCT:	MOVEI	2,6		;OCTAL PRINT
	HRL	1,0
	MOVEI	0,6
	LSHC	0,3
	GO	PRINT
	SOJG	2,PNTOCT+2
	RTN

;*PNTOCS - PRINT OCTAL ZERO SUPPRESSED NUMBERS

PNTOCS:	IDIVI	0,^D8		;OCTAL PRINTER
	HRLM	1,(P)
	SKIPE	0
	GO	PNTOCS
	HLRZ	0,(P)
	ADDI	0,"0"
	JRST	PRINT

;*PNTDEC - PRINT DECIMAL NUMBERS

PNTDEC:	IDIVI	0,^D10		;DECIMAL PRINTER
	HRLM	1,(P)
	SKIPE	0
	GO	PNTDEC
	HLRZ	0,(P)
	ADDI	0,"0"
	JRST	PRINT

;*PRINT - PRINT AN ASCII CHARACTER

PRINT:	AOS	CHRCTR
	MOVEM	1,SAVAC1
	ANDI	177
	MOVEM	0,SAVAC0
	CAIE	11
	JRST	PRINT1		;NOT TAB
	SOS	CHRCTR
	MOVEI	40
	GO	PRINT1
	AOS	1,CHRCTR	;OUTPUT REQUIRED SPACE'S FOR TAB FUNCTION
	TRNE	1,7
	JRST	.-4
	JRST	PRINT2
PRINT1:	CAIN	0,12		;LF ?
	SETZM	CHRCTR		;YES, CLEAR CHAR COUNTER
	CAIN	0,14		;FORM FEED ?
	SETZM	CHRCTR		;YES, CLEAR CHAR COUNTER
	SKIPE	LPTFLG
	JRST	PNTLPT		;PRINT ON LINE PRINTER
	SKIPE	USER
	JRST	PRINT4
	SKIPN	CNTLOF		;CONTROL O'ED ?
	BTYTYO			;TYPE CHAR
	GO	TTYCHK		;CHECK FOR OPERATOR CONTROL
	CAIN	15
	JRST	FILLCR		;FILL CR
	CAIN	12
	JRST	FILLLF		;FILL LF
PRINT2:	MOVE	1,SAVAC1
	MOVE	0,SAVAC0
	RTN			;EXIT

PRINT4:	SKIPE	MONTYP
	JRST	.+3
	OUTCHR
	JRST	PRINT2
	MOVE	1,0
	PBOUT
	JRST	PRINT2

;*MISCELLANEOUS

CRLF1:	PMSG	<^>
	RTN

FILLCR:	SETZM	CNTLOF#		;CLEAR CONTROL O FLAG
	MOVE	1,FCRCNT	;GET CR FILL COUNT
	JRST	FILLX+2		;SEND EXTRA CR

FILLLF:	MOVE	1,FLFCNT	;GET LF FILL COUNT
FILLX:	SOJL	1,PRINT2
	MOVEI	0,0		;USE 000 AS FILLER
	BTYTYO
	JRST	FILLX
;*PNTLPT - LINE PRINTER DRIVER

PNTLPT:	MOVEI	1,^D<<1000*750>/7>
	ANDI	0,177
	LSH	0,1
;	GO	SMLPT
	GO	TTYCHK		;CHECK FOR ABORT
;	GO	SMLPTR		;WAIT APPROX 750 MS
	SOJG	1,.-3
	SKIPG	1		;DID LPT RESPOND ?
	GO	LPTOFL		;ASK OPERATOR TO REENABLE IT
	JRST	PRINT2

;*LPTOFL - LINE PRINTER OFF-LINE

LPTOFL:	PUT	0
	PUT	1
	PUT	SAVAC0
	PUT	SAVAC1
	PUT	CHRCTR
	SETZM	LPTFLG		;SEND MESSAGE TO TTY
	MOVE	1,[POINT 7,LOFMSG]
	ILDB	0,1
	JUMPE	0,.+3
	GO	PRINT
	JRST	.-3
	TTICHR			;WAIT FOR OPERATOR
	CAIE	12
	JRST	.-2
	SETOM	LPTFLG		;REENABLE LINE PRINTER
	GET	CHRCTR
	GET	SAVAC1
	GET	SAVAC0
	GET	1
	GET	0
	RTN
;*TTYCHK - TELETYPE CHECK ROUTINE

TTYCHK:	SKIPE	TTYCFLG#	;INPUT CHECKING ALLOWED ?
	RTN			;NO

	PUT	0
	BTYTYI			;ANY TYPEIN ?
	GET	0
	RTN			;NO

	CAIN	0,003
	JRST	SELECT		;^C, START OVER
	CAIN	0,004
	JRST	TTYIND		;^D, START DDT
	CAIN	0,017
	SETOM	CNTLOF		;^O, INHIBIT OUTPUT
	GET	0
	RTN

LOFMSG:	ASCIZ/
LPT OFF-LINE, TYPE CR WHEN READY - /
SUBTTL	TELETYPE  INPUT

;*TTICHR - INPUT A TELETYPE CHARACTER

TTYIN:	SETZM	CNTLOF
	SETOM	TTYCFLG		;PREVENT INPUT CHECKS ON ECHO
	SKIPE	USER
	JRST	TTYINU
	GO	SMTYI

;*TTYINX - CHECK FOR SPECIAL CHAR PROCESS

TTYINX:	ANDI	177		;CLEAR PARITY BIT
	CAIN	023
	JRST	TTYIN		;XOFF
	CAIN	021
	JRST	TTYIN		;XON
	CAIN	003
	JRST	SELECT		;^C, START OVER
	CAIE	004
	JRST	.+5

;*TTYIND - TRANSFER TO DDT

TTYIND:	MOVE	SMDDT+1		;GET DDT IDENTIFIER
	CAMN	[ASCII/DDT/]
	JRST	$DDT		;^D, START DDT
	JRST	SELECT		;NOT THERE, START OVER
	CAIN	177
	JRST	TTYEXT		;RUBOUT
	SKIPE	SCFLAG		;IN COMMENT ?
	JRST	TTYINA
	CAIN	40		;SPACE, CHANGE TO TAB
	MOVEI	11

;*TTYINA - COMPLETE CHARACTER PROCESS

TTYINA:	CAIN	33
	JRST	TTALTM		;ALTMODE
	CAIN	176
	JRST	TTALTM		;ALTMODE
	CAIN	175
	JRST	TTALTM		;ALTMODE
	SKIPN	USER
	GO	PRINT
	CAIL	140		;CONVERT TO UPPER CASE
	TRZ	40
	CAIE	15		;IF CR
	JRST	TTYEXT
	MOVEI	12		;PRINT AND EXIT WITH LF
	SETZM	CHRCTR
	JRST	TTYINA
TTYEXT:	SETZM	TTYCFLG
	RTN

;*CHECK EXEC TTY FOR ^C ABORT

CKTTY:	SKIPE	USER		;USER MODE ?
	RTN			;YES
	BTYTYI			;EXEC, ANY INPUT
	RTN			;NO
	CAM
	ANDI	177
	CAIN	003		;CONTROL C ?
	JRST	SELECT		;YES, ABORT
	RTN			;NO, CONTINUE
;*TTYINU - USER MODE CHARACTER INPUT

TTYINU:	SKIPE	MONTYP
	JRST	TTYIU1

	INCHWL
	CAIE	0,15		;IF CR, GET LF
	JRST	TTYINX
	INCHRW
	JRST	TTYINX

TTYIU1:	SKIPN	INUPTR		;INPUT CLEARED ?
	JRST	TTYIU2		;YES
	ILDB	0,INUPTR	;GET CHAR FROM INPUT BUFFER
	JUMPE	0,TTYIU2	;NULL, GET NEW LINE
	CAIE	0,15
	JRST	TTYINX
	SETZM	CHRCTR
	ILDB	0,INUPTR	;IF CR, GET LF
	JRST	TTYINX
TTYIU2:	PUT	1
	PUT	2
	PUT	3
	MOVE	1,[POINT 7,D$ISTR]
	MOVEM	1,INUPTR#	;SAVE INPUT POINTER
	MOVE	2,[RD%BRK!RD%TOP!^D78]
	SETZ	3,

	RDTTY			;TOPS-20, GET INPUT LINE
	 JRST	T20ERR
	GET	3
	GET	2
	GET	1
	JRST	TTYIU1
;*USER MODE LH SWITCHES FOR CHAIN OPERATION

LHSWS:	PMSG	<LH SWS - >
	TTIOCT
	JRST	LHSWS
	HRLZM	0,CONSW
	RTN

;*TTIOCT - TELETYPE OCTAL NUMBER INPUT

TTYOCT:	SETZB	DIGIT,DIGITA
TTYOC1:	TTICHR			;INPUT A CHAR
	CAIN	12		;CR(LF), DONE
	JRST	TTYOC2

	CAIL	"0"		;A VALID DIGIT ?
	CAILE	"7"
	JRST	TTYOC3		;NO

	MOVE	DIGITA,0
	LSH	DIGITA,^D33
	LSHC	DIGIT,3		;INSERT NEW OCTAL
	JRST	TTYOC1

TTYOC2:	MOVE	0,DIGIT		;PUT NUMBER IN AC0
	JRST	CPOPJ1

TTYOC3:	SKIPN	USER
	RTN
	SKIPE	MONTYP
	JRST	.+3
	CLRBFI
	RTN
	SETZM	INUPTR
	MOVEI	1,.PRIIN
	CFIBF			;CLEAR INPUT
	RTN
;*READ - COMMAND FILE READ PROCESS

READ:	SKIPE	DINFLG		;DEVICE COMMAND LIST
	JRST	DEVRD		;YES
	JRST	TTYIN		;TTY REQUESTED
READ1:	ANDI	177
	CAIN	177
	RTN			;RUBOUT
	SKIPE	SCFLAG		;IN COMMENT ?
	JRST	.+3		;YES
	CAIN	40		;SPACE, CHANGE TO TAB
	MOVEI	11
	SKIPE	TAPEPF		;PRINT TAPE ?
	GO	PRINT		;YES
	CAIL	140		;CONVERT TO UPPER CASE
	TRZ	40
	CAIN	12		;IF LF IGNORE
	JRST	READ
	CAIN	14		;IF FF IGNORE
	JRST	READ
	CAIN	15		;IF CR CHANGE TO LF
	MOVEI	12
	JRST	TTYEXT

;*TTALTM - ALTMODE PROCESS

TTALTM:	SETOM	ALTMFLG		;SET ALTMODE FLAG
	MOVEI	"$"		;PRINT $ CR/LF
	SKIPN	USER		;DON'T PRINT $ IF USER
	GO	PRINT
	GO	CRLF1
	MOVEI	12		;RETURN WITH LF
	RTN

PNTTAB:	MOVEI	"	"
	JRST	PRINT		;PRINT A TAB & RTN
SUBTTL	SPECIAL ROUTINES

;*SWITCH - READ CONSOLE SWITCHES

$SWITCH:
$SWU:	MOVE	0,CONSW		;GET STORED SWITCHES
	RTN

;*SMINT - SM10 INITIALIZATION

SMINT:	SKIPE	USER
	RTN

	MOVE	[540000,,540001]	;SET UP PAGE TABLES
	MOVSI	1,-160		;TO RESET CONDITION
	MOVEM	600(1)
	ADD	[2,,2]		;SO PAGING
	AOBJN	1,.-2		;CAN BE TURNED ON

	MOVSI	(JFCL)
	MOVEM	421		;NO-OP ARITHMETIC TRAP

	CTYINI			;INITIALIZE CTY

	RTN

SMTYI:	BTYTYI			;GET INPUT CHAR
	JRST	.-1		;NO, WAIT FOR IT
	HALT	.
	JUMPE	 0,SMTYI
	RTN
;*CTY CONTROL ROUTINES

$TYINI:	0
	SETZM	$80CIW		;CLEAR INPUT WORD
	SETZM	$80COW		;CLEAR OUTPUT WORD
	SETZM	$80KIW		;CLEAR INPUT WORD
	SETZM	$80KOW		;CLEAR OUTPUT WORD
	SETZM	MMFLAG#
	MOVE	0,$80STAT	;GET CONSOLE STATUS WORD
	TLNE	0,($80MM)	;MAINTENANCE MODE BIT SET ?
	SETOM	MMFLAG		;YES, SET TTY IN MAINT MODE
	JRST	@$TYINI

$TYCLR:	0
	JRST	@$TYCLR		;NOTHING REQUIRED

$CYTYI:	0
	MOVE	0,$80CIW	;GET INPUT WORD
	TRNN	0,$80CHR	;CHAR FLAG BIT SET ?
	JRST	@$CYTYI		;NO

	SETZM	$80CIW		;CLEAR INPUT WORD
	ANDI	0,177

	AOS	$CYTYI
	AOS	$CYTYI
	JRST	@$CYTYI		;DOUBLE SKIP RETURN, CHAR IN AC0

$KYTYI:	0
	MOVE	0,$80KIW	;GET INPUT WORD
	TRNN	0,$80CHR	;CHAR FLAG BIT SET ?
	JRST	@$KYTYI		;NO

	SETZM	$80KIW		;CLEAR INPUT WORD
	ANDI	0,177

	AOS	$KYTYI
	AOS	$KYTYI
	JRST	@$KYTYI		;DOUBLE SKIP RETURN, CHAR IN AC0

$BYTYI:	0
	CTYTYI			;ANY CTY INPUT ?
	JRST	.+5		;NO
	HALT	.
	AOS	$BYTYI
	AOS	$BYTYI
	JRST	@$BYTYI		;DOUBLE SKIP RETURN, CHAR IN AC0
	KTYTYI			;ANY KLINIK INPUT ?
	JRST	@$BYTYI		;NO
	HALT	.
	JRST	.-6

$COMTI:	0
	SKIPE	MMFLAG		;IN MAINTENANCE MODE ?
	JRST	.+7		;YES

	CTYTYI			;ANY CTY INPUT ?
	JRST	@$COMTI		;NO
	HALT	.
	AOS	$COMTI
	AOS	$COMTI
	JRST	@$COMTI		;DOUBLE SKIP RETURN, CHAR IN AC0

	KTYTYI			;ANY KLINIK INPUT ?
	JRST	@$COMTI		;NO
	HALT	.
	AOS	$COMTI
	AOS	$COMTI
	JRST	@$COMTI		;DOUBLE SKIP RETURN, CHAR IN AC0

$CYTYO:	0
	TRO	0,$80CHR	;SET FLAG BIT
	MOVEM	0,$80COW	;PUT IN COMM AREA
	CONI	APR,0		;GET PRESENT APR
	ANDI	7		;KEEP PI ASSIGNMENT
	TRO	$80INT		;SET INTERRUPT 8080
	CONO	APR,@0		;INTERRUPT 8080
	MOVE	0,$80COW	;GET OUTPUT WORD
	TRNE	0,$80CHR	;8080 SENT THIS CHAR ?
	JRST	.-2		;NO, WAIT
	JRST	@$CYTYO		;YES

$KYTYO:	0
	TRO	0,$80CHR	;SET FLAG BIT
	MOVEM	0,$80KOW	;PUT IN COMM AREA
	CONI	APR,0		;GET PRESENT APR
	ANDI	7		;KEEP PI ASSIGNMENT
	TRO	$80INT		;SET INTERRUPT 8080
	CONO	APR,@0		;INTERRUPT 8080
	MOVE	0,$80KOW	;GET OUTPUT WORD
	TRNE	0,$80CHR	;8080 SENT THIS CHAR ?
	JRST	.-2		;NO, WAIT
	JRST	@$KYTYO		;YES

$BYTYO:	0
	MOVEM	0,$BYTYC#	;SAVE OUTPUT CHAR
	CTYTYO			;OUTPUT CHAR TO CTY
	MOVE	0,$BYTYC	;GET OUTPUT CHAR
	SKIPE	MMFLAG		;IN MAINTENANCE MODE ?
	KTYTYO			;YES, OUTPUT CHAR TO KLINIK
	JRST	@$BYTYO

$COMTO:	0
	SKIPE	MMFLAG		;IN MAINTENANCE MODE ?
	JRST	.+3		;YES
	CTYTYO			;OUTPUT CHAR TO CTY
	JRST	@$COMTO
	KTYTYO			;OUTPUT CHAR TO KLINIK
	JRST	@$COMTO
SUBTTL	PROGRAM FILE SELECTION

;*FSELECT - "SUBRTN" FILE SELECTION

FSELECT:SETOM	SPECIAL#	;SET SPECIAL MODE
	SETZM	NOCMNT
	MOVEM	0,IP		;SET POINTER TO FILE SPEC
	JRST	DIAGLD+2

;*DIAGLD - "DIAMON" FILE SELECTION

	SETOM	NOFNF#		;SET DON'T REPORT IF CAN'T FIND
	SETOM	NOCMNT		;INHIBIT COMMENT PRINTING
	JRST	.+6
	SETOM	NOCMNT#		;INHIBIT COMMENT PRINTING
	JRST	.+2
DIAGLD:	SETZM	NOCMNT
	SETZM	SPECIAL		;SET NORMAL MODE
	SETZM	NOFNF
	SETZM	A10FLG#
	SETZM	LDEVICE#
	SETZM	CMDFLG#

	HLRZ	0,1(IP)
	CAIN	0,(SIXBIT/A10/)
	SETOM	A10FLG

	SKIPE	USER
	JRST	USERLD		;USER MODE

	MOVEI	540027		;SET XB BUFFER UNCACHED
	HRRM	613
	MOVEI	540017		;SET LOAD BUFFERS UNCACHED
	HRRM	607

	CONI	PAG,0		;READ PAGING SYSTEM
	CONO	PAG,@0		;RESET PAGING SYSTEM
	JRST	DSKLD		;NOW LOAD FROM DISK
;*RFILE - FILE FOUND AND SETUP

RFILE:	SETZM	Q		;CLEAR FILE READ WORD COUNTER
	MOVEI	M,5		;SET LDACHR BYTE COUNTER
	SETOM	FBSAV#		;SET 8 BIT READ FILE BYTE COUNTER
	MOVEM	13,SAV13#
	MOVEM	14,SAV14#
	SKIPN	SPECIAL		;FILE FOUND
	JRST	RFILE1		;NORMAL OPERATION

;*FSELF - "SUBRTN" FILE FOUND RETURN

FSELF:	MOVEM	0,ACSAVE	;SAVE ACS
	MOVE	0,[1,,ACSAVE+1]
	BLT	ACSAVE+16
	MOVE	0,LDEVICE	;RETURN DEVICE TYPE
	AOS	(P)
	RTN			;SKIP RETURN TO "SUBRTN"

;*NFERR - FILE NOT FOUND

NFERR:	SKIPE	NOFNF		;REPORT NOT FOUND ?
	RTN			;NO
	SKIPN	SPECIAL		;NOT FOUND
	JRST	NFERR1		;NORMAL OPERATION

;*FSELNF - "SUBRTN" FILE NOT FOUND

FSELNF:	MOVE	0,LDEVICE	;"FSELECT" - NOT FOUND
	RTN			;NON-SKIP, ERROR RETURN
SUBTTL	"SUBRTN" PROGRAM FILE READ

;*FREAD - DETERMINE READ TYPE

FREAD:	MOVEM	0,FRDTYP#
	MOVS	[1,,ACSAVE+1]
	BLT	16		;RESTORE "DIAMON" ACS
	MOVE	ACSAVE
	SKIPGE	FRDTYP
	JRST	FRD36		;READ 36 BIT WORDS
	SKIPE	FRDTYP
	JRST	FRD8		;READ 8 BIT WORDS

;*FREAD3 - CHARACTER READ

FREAD3:	GO	LDACHR		;LOAD AN ASCII CHARACTER
	JRST	FREAD2		;EOF
FREAD1:	MOVEM	0,ACSAVE	;RESAVE "DIAMON" ACS
	MOVE	0,[1,,ACSAVE+1]
	BLT	ACSAVE+16

	MOVE	0,16		;PUT ASCII BYTE IN AC0
	AOS	(P)
	RTN			;SKIP RETURN

;*FREAD2 - END OF FILE

FREAD2:	SETZM	0		;EOF CODE = 0
	RTN			;NON-SKIP RETURN

;*FRD36 - 36 BIT WORD READ

FRD36:	GO	RWORD		;READ 36 BIT WORDS
	JRST	FREAD2		;EOF
	MOVE	16,W		;PUT 36 BIT WORD IN AC16
	JRST	FREAD1		;REST AS ABOVE
;*LDACHR - ASCII CHARACTER PROCESS

LDACHR:	CAIE	M,5		;USED ALL OF THIS 36 BIT WORD ?
	JRST	LDACH1		;NOT YET
	EXCH	13,SAV13
	EXCH	14,SAV14
	GO	RWORD		;YES, READ NEXT 36 BIT WORD
	JRST	LDAEOF		;EOF
	SETZM	M
	EXCH	13,SAV13
	EXCH	14,SAV14

LDACH1:	LDB	16,[POINT 7,W,6
		POINT 7,W,13
		POINT 7,W,20
		POINT 7,W,27
		POINT 7,W,34](M)	;GET ASCII BYTE
	AOS	M		;COUNT IT
LDACH2:	JUMPE	16,LDACHR	;IF NULL, IGNORE
	AOS	(P)		;SKIP RETURN
	RTN

LDAEOF:	EXCH	13,SAV13
	EXCH	14,SAV14
	RTN

;*FRD8 - 8 BIT WORD READ

FRD8:	GO	G8BYT		;GET AN 8 BIT BYTE
	JRST	FREAD2		;EOF
	JRST	FREAD1		;8 BIT BYTE IN AC16

G8BYT:	AOS	M,FBSAV		;ADVANCE FILE BYTE
	ANDI	M,3		;(MOD 4)
	JUMPN	M,G8BY2		;NEED A NEW WORD ?

	GO	RWORD		;YES
	RTN			;EOF

G8BY1:	MOVEM	W,BYTSAV#	;SAVE WORD

G8BY2:	LDB	16,[POINT 8,BYTSAV,17
		    POINT 8,BYTSAV,9
		    POINT 8,BYTSAV,35
		    POINT 8,BYTSAV,27](M)
	JRST	CPOPJ1		;LOAD & SKIP RETURN WITH BYTE
SUBTTL	LDA10 - LOAD PDP-10 ASCIIZED ".A10" FILE

;*LDPROC - FORMAT CONTROL PROCESS

LDA10:
LDPROC:	SETZM	LDOCTF#
	SETZM	LDZBLK#

	GO	LDACHR		;GET FILE TYPE CHAR
	GO	ERR2		;EOF
	CAIN	16,";"
	JRST	LDCMNT		;LINE STARTS WITH ;, COMMENT

	SETZM	LDTBLK#
	CAIN	16,"A"		;A, PDP-10 SUPER ".A10" FILE
	JRST	.+6
	CAIN	16,"T"		;T, PDP-10 ".A10" FILE
	JRST	[SETOM	LDTBLK
		 JRST	.+4]
	CAIE	16,"Z"		;Z, ".A10" CORE ZERO
	GO	LERR3
	SETOM	LDZBLK

	GO	LDACHR		;GET FORMAT CHAR
	GO	ERR2		;EOF

	CAIN	16," "		;SPACE, ASCIIZED
	JRST	.+4
	CAIE	16,"O"		;O, OCTAL
	GO	LERR4
	SETOM	LDOCTF

	MOVE	16,[LDCNT,,LDCNT+1]
	SETZM	LDCNT
	BLT	16,LDATAE	;CLEAR LOAD STORAGE

	MOVEI	13,LDCNT	;SETUP CONVERTED STORAGE POINTER
;*LDCNV - CONVERT ASCIIZED BACK INTO BITS

LDCNV:	SETZM	14		;CLEAR CONVERTED WORD FORMER

LDCNV1:	GO	LDACHR		;LOAD AN ASCII CHAR
	GO	ERR2		;EOF

	CAIN	16,15		;CR, IGNORE
	JRST	LDCNV1

	CAIN	16,12		;LF, END OF LINE
	JRST	LDEOL

	CAIN	16,54		;COMMA, FIELD SEPARATOR
	JRST	LDCMA

	SKIPE	LDOCTF
	JRST	LDCNV3		;LOADING OCTAL FORMAT

	CAIL	16,"5"		;5 TO : ?
	CAILE	16,":"
	JRST	.+6		;NO
	SUBI	16,"5"		;YES, INSERT SUPPRESSED ONES
	LSH	14,6
	TRO	14,77
	SOJGE	16,.-2
	JRST	LDCNV1

	CAIL	16,"0"		;0 TO 4 ?
	CAILE	16,"4"
	JRST	.+5		;NO
	ANDI	16,7		;YES, INSERT SUPPRESSED ZEROS
	LSH	14,6
	SOJGE	16,.-1
	JRST	LDCNV1

	LSH	14,6		;SHIFT WORD FORMER LEFT 6
	ANDI	16,77		;KEEP ASCIIZED OIT BITS

LDCNV2:	OR	14,16		;INSERT NEW OIT
	JRST	LDCNV1

LDCNV3:	LSH	14,3		;SHIFT WORD FORMER LEFT 3, OCTAL
	ANDI	16,7		;KEEP OCTAL OIT BITS
	JRST	LDCNV2

LDCMA:	MOVEM	14,(13)		;STORE CONVERTED WORD
	AOJA	13,LDCNV	;COUNT AND GO FOR NEXT WORD
;*LDEOL - END OF LINE, CHECKSUM LOAD LINE

LDEOL:	MOVEM	14,(13)		;STORE CHECKSUM

	SKIPE	LDOCTF
	JRST	LDTEN		;OCTAL, NO CHECKSUM

	MOVEI	13,LDCNT	;CHECKSUM LOAD STORAGE
	SETZM	14
	ADD	14,(13)
	CAIE	13,LDATAE
	AOJA	13,.-2

	TRNE	14,177777	;16 BIT CHECKSUM = 0 ?
	GO	LERR5		;NO, CHECKSUM ERROR

;*LDTEN - CREATE LOAD ADDRESS AND WORD COUNT

LDTEN:	LDB	13,[POINT 2,LDCNT,27]
	LSH	13,^D16
	OR	13,LDADR	;CREATE PDP-10 LOAD ADDRESS

	LDB	14,[POINT 8,LDCNT,35]	;WORD COUNT

	SKIPN	LDZBLK
	JRST	LDTEN1		;LOAD TEN DATA WORDS

;*LDTENZ - CLEAR TEN CORE, JOB START TO JOB FIRST FREE

LDTENZ:	JUMPE	14,LDPROC	;WC=0, NO ZEROING
	MOVEM	13,JOBSAW	;SETUP JOB START ADDRESS
	ADD	13,LDATA-1(14)
	SOJG	14,.-1		;ADD UP ZERO COUNT
	MOVEM	13,JOBFFW	;SETUP JOB FIRST FREE ADDRESS

	GO	CLRCOR		;CLEAR PDP-10 CORE
	JRST	LDPROC
;*LDTEN1 - TRANSFER TEN WORDS TO MEMORY

LDTEN1:	SKIPN	LDTBLK
	MOVE	13,LDADR
	JUMPE	14,LDDONE	;WC=0, TRANSFER BLOCK

	MOVEI	15,LDATA	;SETUP PICKUP POINTER
	SKIPE	LDDMON
	JRST	LDTEN3		;LOADING DIAG MON

LDTEN2:	MOVE	16,(15)		;GET 36 BIT WORD
	SKIPN	LDTBLK
	JRST	.+6

	MOVE	16,2(15)	;BITS 0 TO 7
	LSH	16,^D16
	OR	16,1(15)	;BITS 8 TO 23
	LSH	16,^D16
	OR	16,0(15)	;BITS 24 TO 35

	MOVEM	16,(13)		;STORE 36 BIT WORD IN MEMORY

	AOS	13		;INCREMENT PDP-10 ADDRESS
	ADDI	15,1		;BUMP PICKUP POINTER
	SKIPE	LDTBLK
	ADDI	15,2
	SUBI	14,1		;DECREMENT WORD COUNT
	SKIPE	LDTBLK
	SUBI	14,2
	JUMPG	14,LDTEN2	;DO TILL ALL WORDS USED
	JRST	LDPROC		;CONTINUE TILL TRANSFER BLOCK

;*LDDONE - COMPLETED, GO TO START ROUTINE

LDDONE:	MOVE	W,13		;SETUP START ADDRESS
	JRST	STARTQ		;GO TO START ROUTINE

;*LDCMNT - LOAD FILE COMMENT LINE

LDCMNT:	PUT	0
	GO	CMNPNT		;PRINT REST OF COMMENT LINE
	GET	0
	JRST	LDPROC

;*CMNPNT - PRINT COMMENT LINE

CMNPNT:	GO	LDACHR
	JRST	ERR2
	CAIN	16,12		;LINE FEED ?
	JRST	.+4		;YES
	SKIPN	NOCMNT
	GO	PNT16		;PRINT COMMENT LINE
	JRST	CMNPNT

	SKIPN	NOCMNT
	GO	PNT16
	RTN

RMS2:	SUB	Q1,T3
	AOJ	Q1,
RMS1:	MOVE	T4,(Q1)		;GET POINTER
	HRRZ	Q3,T4		; X
	HLRO	T3,T4		; -N
	SUB	Q3,T3		; X+N IN Q3
	CAMGE	Q3,Q2		;THIS POINTER TO REQ DATA ?
	JRST	RMS2		;NO, GET NEXT POINTER
	SUBI	Q2,(T4)		;YES, HOW FAR FROM POINTER ?
	ADD	Q1,Q2		;INCREMENT POINTER
	MOVE	T4,(Q1)		;GET REQ DATA
	RTN
SUBTTL	PROGRAM CORE AREA SETUP

;*PRGCOR - SETUP CORE ZEROING FOR ".SAV" FILES

PRGCOR:	SKIPE	A10FLG
	JRST	LDA10		;LOAD ".A10" FILE

	SETZM	Q
	GO	RWORD		;READ FIRST BLOCK/WORD
	GO	ERR2		;EOF, ILLEGAL

	MOVEM	T3,SAVT3#
	MOVEM	T4,SAVT4#
	MOVEM	Q1,SAVQ1#
	MOVEM	Q2,SAVQ2#
	MOVEM	Q3,SAVQ3#
	SKIPE	TOPS10
	SOS	SAVQ1

	SKIPL	T4
	GO	ERR6		;FIRST WORD NOT POINTER
	MOVEI	Q3,^D126(T4)
	MOVEI	Q2,137		;FIRST POINTER LEGAL ?
	CAMGE	Q3,Q2
	GO	ERR6		;NO

	HRRZ	Q1,SAVQ1
	MOVEI	Q2,JOBSA
	GO	RMS1		;GET 'JOBSA'
	HRRZM	T4,JOBSAW#
	SKIPN	Q1,JOBSAW	
	GO	ERR7		;NO STARTING ADDRESS
	CAIN	Q1,140
	GO	ERR7		;PROGRAMS CAN'T START AT 140

	HRRZ	Q1,SAVQ1
	MOVEI	Q2,JOBFF
	GO	RMS1		;GET 'JOBFF'
	MOVEM	T4,JOBFFW#

	GO	CLRCOR		;CLEAR PROGRAM'S CORE AREA
	SKIPE	TOPS10
	AOS	SAVQ1
	MOVE	T3,SAVT3
	MOVE	T4,SAVT4
	MOVE	Q1,SAVQ1
	MOVE	Q2,SAVQ2
	MOVE	Q3,SAVQ3
	JRST	RFILL3		;NOW GO LOAD PROGRAM

;*CLRCOR - CLEAR CORE FOR DIAGNOSTIC SEGMENT
;*	   CLEARS CORE FROM 'JOBSA' TO 'JOBFF'

CLRCOR:	SKIPE	LDDMON
	JRST	CLRCR2		;LOADING DIAG MON
	SKIPN	USER		;USER MODE ?
	JRST	CLRCR1		;NO
	MOVE	JOBREL		;YES, PRESENT JOBREL LT DIAMON'S ?
	CAMG	SVJBREL
	JRST	.+7		;YES
	MOVE	SVJBREL		;NO, REDUCE CORE TO DIAMON'S
	MOVEM	JOBREL
	skipe	montyp
	jrst	.+3
	core
	jrst	err10
	MOVE	JOBFFW		;THIS PRG NEED MORE THAN DIAMON'S ?
	CAMG	SVJBREL
	JRST	.+6		;NO
	MOVEM	JOBREL		;YES, EXPAND CORE FOR PROGRAM
	skipe	montyp
	jrst	.+3
	core
	jrst	err10
CLRCR1:	MOVEM	Q,SAVQ#
	MOVE	Q,JOBSAW
	CAIL	Q,LDBF		;DO NOT, REPEAT NOT, CLEAR "DIAMON" !
	CAIL	Q,DIAGNOS
	SETZM	(Q)
	CAMGE	Q,JOBFFW
	AOJA	Q,.-4
	MOVE	Q,SAVQ
	RTN
;*STARTQ - HERE ON TRANSFER WORD

STARTQ:	SKIPE	MONTYP
	GO	CLOS20		;CLOSE INPUT, TOPS-20
	SKIPE	LDDMON
	JRST	STARTM		;LOADING DIAG MON
	HRRM	T4,SADR		;SAVE STARTING ADDRESS
	TRNN	T4,-1		;ANY ADDRESS ?
	GO	ERR7		;NO, MUST NOT HAVE RIGHT FILE
	SETOM	MONTEN		;SET LOADED BY TEN FLAG
	MOVEI	START		;SETUP RETURN TO DIAMON
	MOVEM	RETURN
	HRRM	120		;SETUP JOB DATA AREA ALSO
STARTV:	SKIPN	PGMGO		;LOAD & GO ?
	JRST	CPOPJ1		;NO, BACK TO MONITOR
	SKIPE	ALTMFLG
	RTN			;ALTMODE, RETURN TO LOADER

SADRQ:	CTYCLR
	MOVE	T1,@SAVEIP
	SKIPE	USER
	GO	SNAME		;USER, IDENTIFY PROGRAM RUNNING
	SKIPE	JOBREL
	JRST	.+3
	MOVE	SVJBREL		;SET JOBREL AS "DIAMON" RUN SIZE
	MOVEM	JOBREL
	GO	ZEROAC		;CLEAR AC'S
	SETZM	17
SADR:	JRST	0		;YES, GO

;*CLOS20 - CLOSE OUT INPUT FILE, TOPS-20

CLOS20:	SETO	1,
	MOVE	2,[.FHSLF,,<LDBF_-^D9>]
	SETZ	3,
	PMAP			;ELIMINATE LAST PAGE
	 ERJMP	.+1
	HLRZ	1,INJFN
	CLOSF			;CLOSE OUT FILE
	 ERJMP	.+1
	SETZM	INJFN
	RTN

;*DSKDIR - DISK PACK DIRECTORY ROUTINE

DSKDIR:	GO	CRLF1
	SETZM	TABCTR#		;CLEAR ENTRY'S PER LINE COUNTER
	SETOM	DDIRFLG		;SET DIRECTORY FLAG
	SKIPE	TOPS10
	JRST	DDIR10		;TOPS-10
	GO	DIRPNT		;DO DIRECTORY
	JRST	SELECT		;DONE
SUBTTL	TOPS-20 DEFINTIONS

OPDEF	JSYS	[104000,,0]
OPDEF	RESET	[JSYS+147]	;RESET
OPDEF	CFIBF	[JSYS+100]	;CLEAR TERMINAL INPUT BUFFER
OPDEF	PBOUT	[JSYS+74]	;OUTPUT A BYTE
OPDEF	SETNM	[JSYS+210]	;SET PROGRAM NAME
OPDEF	RDTTY	[JSYS+523]	;READ TTY INPUT
OPDEF	ERSTR	[JSYS+11]	;PRINT ERROR STRING
OPDEF	GTJFN	[JSYS+20]	;ASSIGN A JFN TO A FILE
OPDEF	OPENF	[JSYS+21]	;OPEN A FILE
OPDEF	CLOSF	[JSYS+22]	;CLOSE A FILE
OPDEF	GTFDB	[JSYS+63]	;READ A FILE DESCRIPTOR BLOCK
OPDEF	PMAP	[JSYS+56]	;MAP FILE PAGES
OPDEF	ERJMP	[JUMP	16,0]	;JUMP ON ERROR
OPDEF	ERCAL	[JUMP	17,0]	;CALL ON ERROR

RD%BRK=	1B0			;REGULAR BREAK SET
RD%TOP=	1B1			;TOPS10 BREAK SET
.FBBYV=	11
.FHSLF=	400000			;SELF
.PRIIN=	100			;PRIMARY INPUT
.PRIOU=	101			;PRIMARY OUTPUT

GJ%OLD=	1B2			;OLD FILE ONLY

GJ%SHT=	1B17			;SHORT CALL FORMAT
OF%RD=	1B19			;READ

.R4TYP=	20			;RP04
.R5TYP=	21			;RP05
.R6TYP=	22			;RP06
.R3TYP=	24			;RM03

N.CLP4=	^D400			;RP04	CYLS PER UNIT
N.CLP5=	^D400			;RP05
N.CLP6=	^D800			;RP06
N.CLP3=	^D820			;RM03

N.SPC4=	^D20*^D19		;RP04 SECTORS PER CYLINDER
N.SPC5=	^D20*^D19		;RP05
N.SPC6=	^D20*^D19		;RP06
N.SPC3=	<^D30*^D5>-2		;RM03 - TOPS-20
T.SPC3=	<^D30*^D5>		;RM03 - TOPS-10

N.SPT4=	^D20			;RP04 SECTORS PER TRACK
N.SPT5=	^D20			;RP05
N.SPT6=	^D20			;RP06
N.SPT3=	^D30			;RM03
SUBTTL	FDB DEFINITIONS

FB%TMP==:1B0			;FILE IS TEMPORARY
FB%PRM==:1B1			;FILE IS PERMANENT
FB%NEX==:1B2			;FILE DOES NOT HAVE AN EXTENSION YET
FB%DEL==:1B3			;FILE IS DELETED
FB%NXF==:1B4			;FILE IS NONEXISTENT
FB%LNG==:1B5			;FILE IS A LONG FILE
FB%SHT==:1B6			;FILE HAS COMPRESSED PAGE TABLE 
FB%DIR==:1B7			;FILE IS A DIRECTORY FILE
FB%NOD==:1B8			;FILE IS NOT TO BE DUMPED BY BACKUP SYSTEM
FB%BAT==:1B9			;FILE HAS AT LEAST ONE BAD PAGE
				; IN IT
FB%FCF==:17B17			;FILE CLASS FIELD
 .FBNRM==:0			;NON-RMS
 .FBRMS==:1			;RMS FILES

.FBHDR==:0			;HEADER WORD
.FBCTL==:1			;FLAGS
.FBEXL==:2			;LINK TO FDB OF NEXT EXTENSION
.FBADR==:3			;DISK ADDRESS OF INDEX BLOCK
.FBPRT==:4			;PROTECTION OF THE FILE
.FBCRE==:5			;TIME AND DATE OF LAST WRITE
.FBUSE==:6			;LAST WRITER ,, AUTHOR (OBS)
.FBAUT==:6			;POINTER TO AUTHOR STRING
.FBGEN==:7			;GENERATION ,, DIR #
 FB%GEN==:777777B17		;GENERATION NUMBER
.FBDRN==:7			;GENERATION ,, DIR #
 FB%DRN==:777777		;DIR NUMBER
.FBACT==:10			;ACCOUNT
.FBBYV==:11			;RETENTION+BYTE SIZE+MODE ,, # OF PAGES
 FB%RET==:77B5			;RETENTION COUNT
 FB%BSZ==:77B11			;BYTE SIZE
 FB%MOD==:17B17			;LAST OPENF MODE
 FB%PGC==:777777		;PAGE COUNT
.FBSIZ==:12			;EOF POINTER
.FBCRV==:13			;TIME AND DATE OF CREATION OF FILE
.FBWRT==:14			;TIME AND DATE OF LAST USER WRITE
.FBREF==:15			;TIME AND DATE OF LAST NON-WRITE ACCESS
.FBCNT==:16			;# OF WRITES ,, # OF REFERENCES
.FBBK0==:17			;BACKUP WORDS (5)
.FBBK1==:20
.FBBK2==:21
.FBBK3==:22
.FBBK4==:23
.FBUSW==:24			;USER SETTABLE WORD
.FBGNL==:25			;LINK TO NEXT GENERATION FILE
.FBNAM==:26			;POINTER TO NAME BLOCK
.FBEXT==:27			;POINTER TO EXTENSION BLOCK
.FBLWR==:30			;POINTER TO LAST WRITER STRING

.FBLN0==:30			;LENGTH OF VERSION 0 FDB
.FBLN1==:31			;LENGTH OF VERSION 1 FDB
.FBLEN==:31			;LENGTH OF THE FDB
.SYMAD=0
.SYMVL=1

LDBF=	17000			;USER LOAD BUFFER
LDBF1=	LDBF+203
LDBF2=	LDBF1+203

A%XB=	27000			;INDEX BLOCK PAGE
A%DIR=	17000			;DIRECTORY DATA PAGE
A%DPG=	17000			;DIRECTORY HEADER PAGE

HBUF=	A%DPG			;HOME BLOCK BUFFER
HOMNAM=	A%DPG+0			;SIXBIT /HOM/
HOMID=	A%DPG+1			;PACK ID
T20SNM=	A%DPG+3			;STRUCTURE NAME
T20LUN=	A%DPG+4			;# UNI IN STR,,THIS UNI #
HOMRXB=	A%DPG+10		;ROOT INDEX BLOCK
HOMPID=	A%DPG+173		;3 WORDS GIVING TOPS-10 OR TOPS-20
HOMCOD=	A%DPG+176		;FUNNY CODE

DIRNUM=	A%DIR+2			;DIR NUMBER
SYMBOT=	A%DIR+3			;BOTTOM OF ST AREA
SYMTOP=	A%DIR+4			;TOP OF ST AREA

DSKSIZ=	^D8

ENTFLG=	400000			;ENTRY IN USE FLAG IN DSKTAB

FILSTR:	POINT 7,D$FIL
DIRSTR:	POINT 7,D$DIR
EXTSTR:	POINT 7,D$EXT

D$DFLT:	ASCIZ	/DIAGNOSTICS/
;*AC USAGE

F=	0			;FLAGS

T1=	1			;TEMP
T2=	2
T3=	3
T4=	4

Q1=	5			;GENERALLY HOLDS A SINGLE CHAR
Q2=	6			;BYTE POINTER TO INPUT STRING
Q3=	7			;BYTE POINTER TO OUTPUT STRING
LBNAC=	7			;TOPS-10 LOGICAL BLOCK NUMBER AC

P1=	10			;PRESERVED
P2=	11
P3=	12			;A NUMBER
P4=	13			;DESTINATION POINTER (DISK ADR, BYTE POINTER)
P5=	14			;DISK ADR OR PARSER STATE

PNT=	15
PNT1=	16

;FLAGS, LEFT HALF OF F

L.CMA=	4			;COMMA TYPED
L.LBK=	2			;LEFT BRACKET TYPED

;FLAGS, RIGHT HALF OF F

R.DSKW=	400			;WILD DISK TYPE, TRY ALL
R.SRIB=	1000			;NEED TO SKIP A BLOCK (RIB AT START)
;SYSTEM PARAMETERS, MUST AGREE WITH MONITOR

BLKCOD=	176			;WORD ADR OF VERIFY CODE
BLKSLF=	177			;WORD ADDRESS OF SELF POINTER
RIBFIR=	0			;WORD ADR OF RIB AOBJN POINTER
RIBNAM=	2			;WORD ADR OF NAME OF FILE IN RIB
RIBEXT=	3			;WORD ADR OF NAME OF FILE IN RIB
RIBSIZ=	5			;LENGTH OF FILE IN WORDS

HOMSNM=	4			;STRUCTURE NAME IN SIXBIT
HOMLUN=	10			;LOGICAL UNIT NUMBER (OCT) IN STR
HOMBSC=	14			;BLOCKS PER SUPERCLUSTER IN HOME BLOCK
HOMSCU=	15			;SUPERCLUSTERS PER UNIT
HOMCNP=	16			;POINTER TO CLUSTER COUNT IN A RET PTR
HOMCKP=	17			;POINTER TO CHECKSUM IN A RET PTR
HOMCLP=	20			;POINTER TO CLUSTER ADDRESS IN A RET PTR
HOMBPC=	21			;BLOCKS PER CLUSTER
HOMREF=	23			;NEED TO REFRESH IF NON-ZERO
HOMCRS=	41			;LBN IN STR OF CRASH.SAV RIB
HOMMFD=	46			;LBN IN STR OF MFD RIB

HBUF=	17000			;HOME BUFFER
RBUF=	17200			;DISK RIB BUFFER
DBUF=	17400			;DATA BUFFER
SUBTTL	TOPS20 DISK DIRECTORY PROCESS

;*LOOK20, FIND REQUESTED FILE

LOOK20:	MOVE	(IP)		;SETUP FILE NAME
	MOVEM	LDNAME
	HLLZ	1(IP)
	MOVEM	LDNAME+1

	SETZM	D$FIL		;CLEAR FILE NAME STORAGE
	MOVE	[D$FIL,,D$FIL+1]
	BLT	D$VER+1

	MOVE	0,FILSTR	;FILE STORE POINTER
	MOVE	1,EXTSTR	;EXT STORE POINTER
	MOVEI	2,0		;FILE TERM CHAR
	SETZM	VERNUM		;VERSION 0

	GO	SIXASC		;SETUP ASCIZ FILE & EXT

	GO	FNDIDX		;GET DIR, THEN FILE INDEX BLOCK
	 RTN			;NOT FOUND

	JRST	CPOPJ1		;FOUND

;*FNDIDX, MAP THE DIRECTORY INTO VIRTUAL ADR DIR

FNDIDX:	GO	FNDDIR		;GO FIND & SETUP DIRECTORY
	 RTN			;NOT FOUND

	GO	MAPDIR		;MAP IN THE DIRECTORY

	MOVE	T1,FILSTR	;GET POINTER TO NAME STRING
	MOVE	T2,EXTSTR	; & POINTER TO EXT STRING
	MOVE	T3,VERNUM#	; & DESIRED VERSION #
				;FALL INTO "GETIDX"
;GETIDX, GET THE INDEX BLOCK FOR THE FILE

GETIDX:	MOVEM	T1,FNDSTR#	;SAVE NAME STRING
	MOVEM	T2,FNDSTE#	; & EXT STRING POINTERS
	MOVEM	T3,FNDSTV	; & VERSION NUMBER

	GO	FIND		;RETURN FDB OFFSET IN P1
	 RTN			;NOT FOUND

GX.NE:	MOVE	Q2,FNDSTE	;COMPARE WITH NEXT EXT

	GO	GETPAG		;MAP IN PAGE CONTAINING FDB

	MOVE	Q3,.FBEXT(T1)	;GET ADR OF EXT STRING BLOCK
	HRLI	Q3,(POINT 7,0)	;SET IT UP AS A STRING POINTER
	ADDI	Q3,1		;POINT TO STRING

	SKIPN	(Q2)
	JRST	GX.NE2		;NULL EXT GIVEN

	GO	STRCMP		;COMPARE EXT STRINGS
	CAIA
	JRST	GX.NV		;FOUND EXT MATCH, LOOK AT VERSION

GX.NE1:	GO	GETPAG		;MAP IN PAGE CONTAINING FDB

	LDB	P1,[POINT 33,.FBEXL(T1),35]	;STEP TO NEXT FDB IN THIS CHAIN
	JUMPN	P1,GX.NE	;BACK IF STILL MORE
	 RTN			;NO MORE, LOSE

GX.NV:	GO	GETPAG		;MAP IN PAGE CONTAINING FDB

	HLRZ	T1,.FBGEN(T1)	;GET GENERATION NUMBER
	SKIPE	FNDSTV#		;IS MOST RECENT WANTED ?
	CAMN	T1,FNDSTV	;IS IT WHAT WE WANT ?
	JRST	GX.DON		;YES, EXIT

GX.NV1:	GO	GETPAG		;MAP IN PAGE CONTAINING FDB

	LDB	P1,[POINT 33,.FBGNL(T1),35]	;STEP TO FDB OF NEXT GENERATION
	JUMPN	P1,.+2
	 RTN			;NO MATCH, ERROR RETURN
	JRST	GX.NV		;TRY AGAIN
GX.DON:	GO	GETPAG		;MAP IN PAGE CONTAINING FDB

	MOVE	T2,.FBCTL(T1)	;GET CONTROL BITS
	TLNE	T2,(FB%DEL!FB%NXF) ;DOES IT EXIST ?
	JRST	GX.NV1		;NO, GO GET ANOTHER THEN

	HRRZ	P5,.FBBYV(T1)	;GET FILE PAGE COUNT
	MOVEM	P5,PAGCNT
	SETZM	INJFN		;START WITH PAGE 0
	SETZM	LDBUF+1		;NO DATA YET

	MOVE	P5,.FBADR(T1)	;GET ADR OF INDEX BLOCK
	TLNE	T2,(FB%LNG)	;LONG FILE ?
	 GO	LNGERR		;YES, FILE TOO LONG TO PROCESS

GX.DN1:	GO	READXB		;READ INDEX BLOCK

	JRST	CPOPJ1		;FOUND, SKIP RETURN

GX.NE2:	MOVEM	Q3,GX.Q3#	;NULL EXT PROCESS
	MOVE	Q2,[POINT 7,[ASCIZ/CMD/]]
	GO	STRCMP
	JRST	.+3
	SETOM	CMDFLG
	JRST	GX.NV		;FOUND

	MOVE	Q3,GX.Q3
	MOVE	Q2,[POINT 7,[ASCIZ/A10/]]
	GO	STRCMP
	JRST	.+3
	SETOM	A10FLG
	JRST	GX.NV		;FOUND

	MOVE	Q3,GX.Q3
	MOVE	Q2,[POINT 7,[ASCIZ/SAV/]]
	GO	STRCMP
	CAIA
	JRST	GX.NV		;FOUND
	JRST	GX.NE1
;*MAPDIR, READ HEADER PAGE OF DIRECTORY

MAPDIR:	MOVEI	P4,A%DIR	;GET ADR FOR DIRECTORY HEADER
	MOVE	P5,A%XB		;GET DISK ADR FOR FIRST PAGE OF DIR

	GO	DSKRD4		;READ HEADER PAGE OF DIRECTORY
	 GO	IOERR		;ERROR READING PAGE

	RTN			;DONE

;*GETPAG, MAP A PAGE OF THE DIRECTORY
;*	ENTRY	- P1/ ADDRESS TO MAP
;*	RETURN	- T1/ MAPPED ADDRESS

GETPAG:	HRRZ	T1,P1		;GET ADR DESIRED FROM FILE
	LSH	T1,-^D9		;CONVERT ADDRESS TO PAGE NUMBER
	CAIL	T1,772		;MAXIMUM XB POINTERS = 512-6
	 GO	LNGERR		;BECAUSE OF LOAD LINKS
	MOVE	P5,A%XB(T1)	;GET DISK ADR OF FILE PAGE
	MOVEI	P4,A%DPG	;GET ADR OF DIRECTORY DATA PAGE
	CAMN	P5,CURPAG#	;DESIRED PAGE ALREADY IN CORE ?
	JRST	GETPG1		;YES, DO NOT NEED TO READ AGAIN

	MOVEM	0,ACSAV1	;SAVE AC'S
	MOVE	[1,,ACSAV1+1]
	BLT	ACSAV1+16

	GO	DSKRD4		;NO, READ THE PAGE
	 GO	IOERR		; - - - ERROR

	MOVS	[1,,ACSAV1+1]	;RESTORE AC'S
	BLT	16
	MOVE	0,ACSAV1

GETPG1:	LDB	T1,[POINT 9,P1,35] ;GET LO-ORDER BITS OF ORIGINAL ADR
	ORI	T1,A%DPG	;ADD ADR OF DIR DATA PAGE
	MOVEM	P5,CURPAG	;UPDATE CURRENTLY IN-CORE PAGE
	RTN			;RETURN
;*FIND, DO A PRIMARY NAME SEARCH IN A DIRECTORY

FIND:	GO	STAOBJN		;BUILD S.T. AOBJN POINTER
	 RTN			;EMPTY

FND.NF:	MOVE	Q2,FNDSTR	;FILE NAME

	GO	GETPAG		;MAP IN PAGE CONTAINING S.T. ENTRY

	LDB	Q3,[POINT 3,.SYMAD(T1),2]	;GET SYMBOL TYPE
	JUMPE	Q3,.+2
	 RTN			;IF NOT NAME TYPE, ERROR

	MOVE	Q3,.SYMVL(T1)	;GET 1ST 5 CHARS OF NAME
	CAME	Q3,@FNDSTR	;IS THIS A MATCH AGAINST STRING ?
	JRST	FND.NM		;NO, NO NEED TO COMPARE NAME STRING

	LDB	Q3,[POINT 33,.SYMAD(T1),35]	;GET FDB ADDRESS

	PUT	P1		;SAVE POINTER INTO SYMBOL TABLE

	MOVE	P1,Q3		;GET ADR OF FDB
	GO	GETPAG		;MAP IN PAGE CONTAINING FDB

	GET	P1		;RESTORE SYMBOL TABLE POINTER

	MOVE	Q3,.FBNAM(T1)	;GET ADR OF NAME STRING BLOCK
	HRLI	Q3,(POINT 7,0)	;SETUP STRING POINTER
	ADDI	Q3,1

	GO	STRCMP		;COMPARE NAME STRINGS

FND.NM:	JRST	[ADD	P1,[1,,1]
		 AOBJN	P1,FND.NF ;NO MATCH, STEP OVER SYMBOL VALUE
		 RTN]		  ;NO MORE NAMES, ERROR

	GO	GETPAG		;MAP IN PAGE CONTAINING S.T. ENTRY

	HRRZ	P1,(T1)		;GET FIRST FILE FDB

	JRST	CPOPJ1		;SKIP RETURN
;*STRCMP, STRING COMPARE ROUTINE

STRCMP:	PUT	P1		;SAVE P1

	MOVE	P1,Q3		;COPY ADR OF STRING IN FILE

	GO	GETPAG		;MAP PAGE CONTAINING STRING BLOCK

	GET	P1		;RESTORE P1

	HRR	Q3,T1		;INSERT MAPPED ADR TO STRING

STRCM1:	ILDB	T1,Q2		;GET 1ST BYTE
	ILDB	T2,Q3		;GET 2ND BYTE
	CAME	T1,T2		;EQUAL ?
	RTN			;NO, LOSE

	JUMPN	T1,STRCM1	;YES, END OF STRING ?

	JRST	CPOPJ1		;YES, SKIP RETURN

;*STAOBJN, BUILD A S.T. AOBJN POINTER

STAOBJN:MOVE	T1,SYMBOT	;START OF ST AREA
	CAIN	T1,776
	 RTN			;EMPTY
	SUB	T1,SYMTOP	;GET -LENGTH
	MOVE	P1,SYMBOT	;BUILD AN AOBJN POINTER
	ADDI	P1,2
	HRLI	P1,2(T1)
	JRST	CPOPJ1
;*MFDPNT, PRINT MASTER FILE DIRECTORY

MFDPNT:	SETOM	MFDFLG
	CTYCLR
	SKIPE	TOPS10
	JRST	MFDP10		;TOPS-10 PACK

	GO	CRLF1
	MOVE	P5,DIORG
	SETZM	CURPAG
	GO	READXB		;READ INDEX BLOCK
	GO	DIRPNT+4	;PRINT MASTER FILE DIRECTORY
	JRST	GETCOM-1

MFDP10:	MOVE	P5,[1,,1]	;PPN [1,1] IS MFD FOR TOPS-10
	MOVEM	P5,PPN
	JRST	DSKDIR+1

;*DIRPNT, PRINT TOPS20 DIRECTORY

DIRPNT:	SETZM	MFDFLG
	SETZM	FIRSTF#
	GO	FNDDIR		;FIND & SETUP DIRECTORY
	 RTN			;NOT FOUND

	GO	MAPDIR		;MAP IN DIRECTORY

	GO	STAOBJN		;BUILD AN S.T. AOBJN POINTER
	 RTN			;EMPTY


DIRPN0:	MOVEM	P1,DIRP1#	;SAVE S.T. POINTER

	GO	GETPAG		;MAP IN PAGE CONTAINING S.T. ENTRY

	LDB	Q3,[POINT 3,.SYMAD(T1),2]
	JUMPE	Q3,.+2
	 RTN			;IF SYMBOL TYPE NOT NAME TYPE, DONE

	LDB	Q3,[POINT 33,.SYMAD(T1),35] ;GET FDB ADDRESS
DIRPN1:	PUT	P1
	MOVE	P1,Q3
	GO	GETPAG		;MAP IN PAGE CONTAINING FDB
	GET	P1

	MOVE	Q3,.FBNAM(T1)	;GET NAME STRING POINTER
	MOVEM	Q3,DIRNAM#
	MOVE	Q3,.FBEXT(T1)	;GET EXT STRING POINTER
	MOVEM	Q3,DIREXT#
	MOVE	Q3,.FBBYV(T1)	;GET FILE BLOCK COUNT
	MOVEM	Q3,DIRBYV#
	MOVE	Q3,.FBSIZ(T1)	;GET FILE BYTE COUNT
	MOVEM	Q3,DIRSIZ#
	MOVE	Q3,.FBEXL(T1)	;GET NEXT EXT LINK
	MOVEM	Q3,DIREXL#

	MOVE	Q3,DIRNAM	;PRINT FILE NAME
	GO	DIRPNX

	PUT	T1
	MOVEI	"."
	GO	PRINT
	GET	T1

	MOVE	Q3,DIREXT	;PRINT FILE EXT
	GO	DIRPNX

	PUT	T1
	PUT	T2
	SKIPE	MFDFLG
	JRST	DIRPN5

	GO	PNTTAB

	MOVE	T1,CHRCTR
	CAIGE	T1,^D16
	GO	PNTTAB		;NECESSARY FOR SHORT NAMES

	SKIPN	FIRSTF
	JRST	.+3
	CAIGE	T1,^D40
	GO	PNTTAB		;FOR 2ND COLUMN SHORT NAME
	MOVE	T1,DIRSIZ	;GET BYTE COUNT
	LDB	Q3,[POINT 6,DIRBYV,11] ;GET BYTE SIZE
	CAIN	Q3,7		;7-BIT BYTES ?
	JRST	DIRPN2		;YES, ASCII DATA
	CAIN	Q3,^D36		;36-BIT BYTES ?
	JRST	DIRPN3		;YES FULL WORD DATA

	HRRZ	DIRBYV		;NEITHER
	LSH	2		;PAGE CNT * 4 = BLOCK CNT
DIRPN2:	IDIVI	T1,5		;7-BIT, COMPUTE WORDS
	SKIPE	T2
	AOS	T1

DIRPN3:	IDIVI	T1,^D128	;36-BIT, COMPUTE BLOCKS
	SKIPE	T2
	AOS	T1

DIRPN4:	MOVE	0,T1
	GO	PNTDEC		;PRINT IT

	MOVE	T1,CHRCTR	;ROOM FOR MORE ON THIS LINE ?
	CAIGE	T1,^D22
	JRST	[GO	PNTTAB
		 SETOM	FIRSTF
		 JRST	DIRPN5+2]
DIRPN5:	GO	CRLF1
	SETZM	FIRSTF
	GET	T2
	GET	T1

	LDB	Q3,[POINT 33,DIREXL,35]
	JUMPN	Q3,DIRPN1	;BACK IF MORE EXT IN FDB CHAIN

	MOVE	P1,DIRP1	;STEP TO NEXT S.T. ENTRY
	ADD	P1,[1,,1]
	AOBJN	P1,DIRPN0	;DO NEXT IF ANY LEFT

	GO	CRLF1
	RTN			;DONE

DIRPNX:	PUT	T1
	ADDI	Q3,1
	PUT	P1
	MOVE	P1,Q3
	GO	GETPAG		;MAP IN PAGE CONTAINING PRINT INFO
	GET	P1
	HRRZ	0,T1		;GET PRINT ADDRESS
	PNTAL
	GET	T1
	RTN
;*DSKRD4, READ FOUR SECTORS (ONE PAGE) FROM DISK

DSKRD4:	MOVE	T1,DSKTYP
	GO	DRVINI		;SET DISK PARAMETERS

	MOVE	T1,P5		;GET DISK ADDRESS
	TLZ	T1,777774	;KEEP JUST ADDRESS BITS
	MOVEM	T1,DSKLBN#
	MOVEM	P4,DSKADR#

	MOVE	T2,NUMCYL#	;COMPUTE UNIT #
	IMUL	T2,N.SCCL#	; & LBN ON UNIT
	IDIV	T1,T2

	MOVEM	T2,LBN#		;SAVE LBN ON UNIT

	HRRZ	P3,DSKTAB(T1)	;GET UNIT #
	MOVEM	P3,CUNIT

	HLRZ	P3,DSKTAB(T1)	;GET CHANNEL #
	TRZ	P3,ENTFLG
	MOVEM	P3,CTYPE

	MOVEM	P4,DSK%P4#	;SETUP BUFFER ADDRESS

	GO	RDPAGE		;READ FULL PAGE, 4 SECTORS
	JRST	DSKRD5		;GOOD
				;FAILED, READ AS INDIVIDUAL SECTORS
	GO	DSKBLK		;READ FIRST SECTOR
	 RTN			;ERROR

	MOVEI	P4,200
	ADDB	P4,DSK%P4	;CHANGE BUFFER ADDRESS
	AOS	LBN
	GO	DSKBLK		;READ SECOND SECTOR
	 RTN			;ERROR

	MOVEI	P4,200
	ADDB	P4,DSK%P4	;CHANGE BUFFER ADDRESS
	AOS	LBN
	GO	DSKBLK		;READ THIRD SECTOR
	 RTN			;ERROR

	MOVEI	P4,200
	ADDB	P4,DSK%P4	;CHANGE BUFFER ADDRESS
	AOS	LBN
	GO	DSKBLK		;READ FOURTH SECTOR
	 RTN			;ERROR

DSKRD5:	CAM			;"GO DSKPNT" ## PRINT DATA READ ##
	JRST	CPOPJ1		;SKIP RETURN
;*DSKPNT, PRINT DISK PAGE JUST READ

DSKPNT:	PUT	P4
	MOVE	P4,DSKADR	;SETUP BUFFER ADDRESS
	HRLI	P4,-1000	; & AOBJN POINTER
	SETZM	DSKPF#

	CTYCLR

	GO	CRLF1

	HLRZ	0,DSKLBN	;PRINT LOGICAL BLOCK NUMBER READ
	GO	PNTOCT
	HRRZ	0,DSKLBN
	GO	PNTOCT
	GO	CRLF1

	JRST	DSKPN2+1	;NOOP THIS TO PRINT DATA

DSKPN1:	SKIPN	(P4)		;ANY DATA ?
	JRST	DSKPN3		;NO

	HRRZ	0,P4		;PRINT BUFFER ADDRESS
	GO	PNTOCT
	MOVEI	"/"
	GO	PRINT

	HLRZ	0,(P4)		;PRINT DATA
	GO	PNTOCT
	MOVEI	" "
	GO	PRINT
	HRRZ	0,(P4)
	GO	PNTOCT
	SETOM	DSKPF

	GO	CRLF1

DSKPN2:	AOBJN	P4,DSKPN1	;DO FULL PAGE

	GO	CRLF1
	GET	P4
	RTN

DSKPN3:	SKIPE	DSKPF
	GO	CRLF1
	SETZM	DSKPF
	JRST	DSKPN2
;*CHKHOM, CHECK HOME BLOCK
;*	CTYPE/ CHANNEL #
;*	CUNIT/ UNIT #
;*	RPTYPE/ DRIVE TYPE CODE

CHKHOM:	MOVE	T1,HOMNAM	;CHECK BLOCK NAME
	CAME	T1,[SIXBIT /HOM/]
	RTN			;BAD

	MOVE	T1,HOMCOD	;CHECK BLOCK CODE
	CAIE	T1,CODHOM
	RTN			;BAD

	GO	PAKTYP		;DETERMINE PACK TYPE
	SKIPE	DEVIDF
	JRST	DEVIDP		;PRINT DEVICE IDENTIFICATION

	SKIPE	TOPS10
	JRST	CHOM10		;CHECK TOPS-10 HOME BLOCK

	MOVE	T1,T20SNM	;CHECK STRUCTURE NAME
	CAME	T1,STRNAM#
	RTN			;NO MATCH

	MOVE	T1,T20LUN	;GET LOGICAL UNIT
	SKIPE	DSKTAB(T1)	;IS THERE ALREADY AN ENTRY ?
	 GO	DPLUNI		;YES, ERROR - DUPLICATE UNITS

	MOVE	P1,CTYPE
	MOVE	P2,CUNIT
	HRRZM	P2,DSKTAB(T1)	;STORE UNIT NUMBER
	MOVEI	T2,ENTFLG(P1)	;GET CHN & ENTRY-IN-USE FLAG
	HRLM	T2,DSKTAB(T1)	;STORE CHANNEL NUMBER
	HLRZ	T1,T1		;GET UNI # IN STR
	SOS	T1
	SKIPN	MAXUNI#		;ALREADY SET ?
	MOVEM	T1,MAXUNI	;NO, SET

	CAME	T1,MAXUNI	;SAME AS OTHERS ?
	 GO	BADSTR		;NO, ERROR

	MOVE	T2,HOMRXB	;GET ROOT XB
	SKIPN	DIORG		;ALREADY SET ?
	MOVEM	T2,DIORG	;NO, SET

	CAME	T2,DIORG	;SAME AS OTHERS ?
	 GO	BADSTR		;NO, ERROR

	SKIPG	T1,DSKTYP	;IS TYPE KNOWN YET ?
	JRST	.+3		;NO
	CAME	T1,RPTYPE	;YES, ALL UNITS SAME TYPE ?
	 GO	BADUNI		;NO

	MOVE	T1,RPTYPE
	MOVEM	T1,DSKTYP
	RTN

;*CHOM10, CHECK TOPS-10 HOME BLOCK

CHOM10:	MOVE	T1,HBUF+HOMSNM	;DESIRED UNIT ?
	MOVE	T2,HBUF+HOMLUN
	CAMN	T1,STRUCT	;CHECK AGAINST SUPPLIED ARGUMENTS
	CAME	T2,SLUNIT
	RTN
	JRST	CPOPJ1		;GOOD

;*RDPAGE, READ FULL TOPS-20 PAGE, 4 SECTORS

RDPAGE:	GO	DSKBLK-2
	AOS	(P)		;FAILED, SKIP RETURN
	RTN			;PASSED
;*DEVID, IDENTIFY DISKS

DEVID:	CTYCLR
	SETOM	DEVIDF

	GO	FNDUNI		;FIND & IDENTIFY DISKS

	JRST	GETCOM-1

DEVIDP:	MOVE	A,T20SNM
	SKIPE	TOPS10
	MOVE	A,HBUF+HOMSNM
	GO	SIXBP		;PRINT STRUCTURE NAME

	GO	PNTTAB

	SKIPE	TOPS10
	JRST	.+^D8

	HLRZ	T20LUN		;PRINT LOGICAL UNIT
	GO	PNTDEC
	MOVEI	","
	GO	PRINT
	HRRZ	T20LUN
	GO	PNTDEC

	GO	PNTTAB

	MOVE	T2,RPTYPE	;PRINT DISK TYPE
	CAIN	T2,.R4TYP
	MOVE	T1,[SIXBIT/RP04/]
	CAIN	T2,.R5TYP
	MOVE	T1,[SIXBIT/RP05/]
	CAIN	T2,.R6TYP
	MOVE	T1,[SIXBIT/RP06/]
	CAIN	T2,.R3TYP
	MOVE	T1,[SIXBIT/RM03/]
	GO	SIXBP

	GO	PNTTAB

	MOVE	T1,[SIXBIT/TOPS10/]
	SKIPN	TOPS10
	MOVE	T1,[SIXBIT/TOPS20/]
	GO	SIXBP

	GO	CRLF1
	RTN
;*PAKTYP, DETERMINE PACK TYPE, TOPS-10 OR TOPS-20

PAKTYP:	SETZM	TOPS10
	MOVE	T1,HOMPID	;GET FIRST WORD OF PACK TYPE
	CAME	T1,T10ID	;TOPS-10 PACK ?
	JRST	PAKTY1		;NO, TRY TOPS-20

	MOVE	T1,HOMPID+1	;VERIFY 2ND WORD
	CAME	T1,T10ID+1
	GO	ERR13		;BAD

	MOVE	T1,HOMPID+2
	CAME	T1,T10ID+2
	GO	ERR13		;BAD

	SETOM	TOPS10		;GOOD TOPS-10 PACK
	RTN
	
PAKTY1:	CAME	T1,T20ID	;TOPS-20 PACK ?
	GO	ERR13		;NOT TOPS-20 EITHER

	MOVE	T1,HOMPID+1	;VERIFY 2ND WORD
	CAME	T1,T20ID+1
	GO	ERR13		;BAD

	MOVE	T1,HOMPID+2
	CAME	T1,T20ID+2
	GO	ERR13		;BAD
	RTN

T10ID:	BYTE	(2)0 (8)"O" (8)"T" (2)0 (8)"S" (8)"P"
	BYTE	(2)0 (8)"1" (8)"-" (2)0 (8)" " (8)"0"
	BYTE	(2)0 (8)" " (8)" " (2)0 (8)" " (8)" "

T20ID:	BYTE	(2)0 (8)" " (8)" " (2)0 (8)"O" (8)"T"
	BYTE	(2)0 (8)"S" (8)"P" (2)0 (8)"2" (8)"-"
	BYTE	(2)0 (8)" " (8)"0" (2)0 (8)" " (8)" "
;*GETCOM, PROMPT FOR AND INPUT DESIRED DISK

	GO	CRLF1
	GO	CRLF1
GETCOM:	GO	GETCXX		;INIT FLAGS

	MOVEI	[ASCIZ/DISK:<DIRECTORY> OR DISK:[P,PN] - /]
	PNTAL

GETCO1:	GO	GETSTR		;GET COMMAND
	JRST	GETCOM-1

	SETZ	P2,		;WHERE TO FORM STRUCTURE NAME
	SKIPN	DEV#		;DEVICE TYPED ?
	JRST	DVX1		;NO, GO FIND DEFAULT

	MOVE	T1,[POINT 7,D$ISTR]
	MOVE	T2,[POINT 6,P2]	;PTR TO NAME
	MOVEI	T3,6		;MAX # OF CHARS

DEVNAM:	ILDB	T4,T1		;GET CHAR
	CAIN	T4,":"		;END OF NAME ?
	JRST	DEVX		;YES

	SUBI	T4,40		;CONVERT TO SIXBIT
	IDPB	T4,T2		;STORE
	SOJG	T3,DEVNAM	;LOOP
	ILDB	T4,T1
	CAIE	T4,":"
	JRST	GETCOM-1	;TOO MANY DEVICE CHARS

DEVX:	MOVEM	P2,STRNAM	;MAKE THIS THE STRUCTURE
;*FDSK, FIND SELECTED STRUCTURE AND ALL UNITS IN STRUCTURE

FDSK:	GO	FNDUNI		;FIND UNIT & SETUP DISK TABLE

	SKIPE	TOPS10
	JRST	CHKSTR+3	;TOPS-10 PACK

	MOVE	T1,MAXUNI	;CHECK FOR FULL DECK
CHKSTR:	SKIPN	DSKTAB(T1)	;ANY ID ?
	 GO	MISUNI		;NO, MISSING STRUCTURE/UNIT
	SOJGE	T1,CHKSTR	;YES, LOOP FOR OTHER UNITS

	SKIPN	T1,DEV		;WAS DEVICE SPECIFIED ?
	MOVE	T1,[POINT 7,D$ISTR] ;NO
	MOVE	Q2,DIRSTR	;SETUP DIRECTORY STORAGE POINTER

DVX3:	ILDB	Q1,T1		;GET FIRST DIR CHAR 
	CAIN	Q1,"?"		;IS IT QMARK, "PRINT MFD" ?
	JRST	MFDPNT		;YES
	CAIN	Q1,0
	JRST	DVX2		;NO DIRECTORY GIVEN, USE "DIAGNOSTICS"
	SKIPE	TOPS10
	JRST	PPNIN		;TOPS-10 PACK
	JRST	.+2

FDSK1:	ILDB	Q1,T1		;GET INPUT CHAR
	JUMPE	Q1,FDSK2	;EOL

	CAIE	Q1,"<"		;IGNORE ANGLE BRACKETS
	CAIN	Q1,">"
	JRST	FDSK1

	IDPB	Q1,Q2		;STORE DIRECTORY STRING
	JRST	FDSK1

DVX1:	MOVE	P2,D$ISTR
	CAMN	P2,[ASCII/?/]	;WAS "?" ONLY TYPED ?
	JRST	DEVID		;YES, IDENTIFY DISKS
	MOVSI	P2,(SIXBIT/PS/)	;NO DEVICE TYPED, USE "PS" AS DEFAULT
	JRST	DEVX

DVX2:	SKIPE	TOPS10
	JRST	FDSK2		;TOPS10 PACK
	MOVE	T1,[POINT 7,D$DFLT]
	JRST	DVX3
FDSK2:	GO	FNDDIR		;FIND & SETUP DIRECTORY
	 JRST	.+2
	RTN			;OK

DIRERR:	PMSG	<^?DIRECTORY NOT FOUND^>
	JRST	DEVSEL		;TRY AGAIN

FNDDIR:	SKIPE	TOPS10
	JRST	FNDD10		;FIND TOPS-10 PACK DIRECTORY

	MOVE	P5,DIORG#	;GET ADDRESS
	SETZM	CURPAG

	GO	READXB		;READ ROOT-DIR XB

	GO	MAPDIR		;MAP IN ROOT-DIR HEADER PAGE

	MOVE	T1,DIRSTR	;GET POINTER TO DIR STRING
	MOVE	T2,[POINT 7,[ASCIZ/DIRECTORY/]]
	MOVEI	T3,0		;GET HIGHEST VERSION #

	GO	GETIDX		;GET INDEX BLOCK OF DIR FILE
	 RTN			;NOT FOUND
	JRST	CPOPJ1		;FOUND

;*READXB, READ THE INDEX BLOCK
;*	READ INTO 27000 TO 27771
;*	LAST 6 LOCATIONS USED FOR LOAD LINKS
;*	WHICH ALLOWS A FILE TO BE MAX OF 2024. BLOCKS

READXB:	MOVE	P4,[FSELNK,,LDATA]
	BLT	P4,LDATA+5	;SAVE LOAD LINKS

	MOVEI	P4,A%XB		;READ INTO XB AREA

	GO	DSKRD4		;READ THE PAGE
	 GO	IOERR		;ERROR

	MOVE	P4,[LDATA,,FSELNK]
	BLT	P4,FSELNK+5	;RESTORE LOAD LINKS

	RTN

GETCXX:	MOVEI	1		;SET DEVICE TYPE TO DISK
	MOVEM	DEVTYP
	SETZM	DEVIDF#
	SETZM	MFDFLG
	SETZM	DDIRF1

	SETZM	DSKTAB		;CLEAR DISK TABLE
	MOVE	T1,[DSKTAB,,DSKTAB+1]
	BLT	T1,DSKTAB+DSKSIZ-1

	SETZM	DSKTYP#		;INDICATE UNIT TYPE UNKNOWN
	SETZM	MAXUNI		;INIT MAXIMUM UNIT
	SETZM	TOPS10#
	SETZM	PPN#

	SETZM	D$DIR		;CLEAR DIRECTORY STORAGE
	MOVE	Q2,[D$DIR,,D$DIR+1]
	BLT	Q2,D$DIR+7
	RTN
;*GETSTR, STRING READ FROM CONSOLE

GETSTR:	MOVE	Q3,[POINT 7,D$ISTR]
	SETZM	D$ISTR
	MOVE	T1,Q3
	SETZM	DEV

GET.W:	TTICHR			;READ A CHAR
	MOVEM	0,Q1

	CAIE	Q1,"U"-100	;CONTROL-U ?
	CAIN	Q1,177		;RUBOUT ?
	JRST	[MOVSI	T1,'XXX'
		 GO	SIXBP	;YES, PRINT LINE DELETE
		 RTN]
	CAIL	Q1,140		;LOWER CASE ?
	SUBI	Q1,40		;YES, MAKE UPPER
	CAIN	Q1,15		;EOL ?
	JRST	GET.EL		;YES, FINISH OUT
	CAIN	Q1,12		;EOL ?
	JRST	GET.EL		;YES, FINISH OUT
	CAIN	Q1,33		;ALTMODE ?
	JRST	GET.EL		;YES, FINISH OUT

	IDPB	Q1,Q3		;STORE CHAR
	CAIE	Q1,":"		;DEVICE NAME TERM ?
	JRST	GET.W		;NO, LOOP

	MOVEM	Q3,DEV#		;YES, SET FLAG
	MOVE	T1,Q3		;NEW COMMAND POINTER
	JRST	GET.W		;LOOP FOR MORE

GET.EL:	GO	CRLF1		;EHCO CR/LF

GET.E1:	SETZ	T2,		;TERMINATING NULL
	IDPB	T2,Q3		;STORE
	JRST	CPOPJ1
;*PPNIN - TOPS-10 DISK AND PROJ PROGRAMMER SPECIFICATION

PPNIN:	SETZM	F
	MOVE	P2,PPNPTR
	SETZB	Q2,W
	MOVEM	F,T3
	MOVE	F,Q1

	GO	PPNCHR+2

	JRST	FDSK2

PPNLP:	MOVE	P2,PPNPTR
	SETZB	Q2,W

PPNCHR:	MOVEM	F,T3
	ILDB	F,T1		;GET INPUT BYTE
	EXCH	F,T3

	CAIG	T3,"Z"
	CAIGE	T3,"A"
	SKIPA
	JRST	PPNLTR			;LETTER

	CAIG	T3,"9"
	CAIGE	T3,"0"
	JRST	PPN0			;NO, BREAK CHARACTER

	LSH	Q2,3			;BUILD OCTAL NUMBER
	ADDI	Q2,-60(T3)		;ADD IN THIS DIGIT

PPNLTR:	TRC	T3,40			;MAKE IT SIXBIT
	TLNE	P2,770000		;ONLY SIX CHARACTERS
	IDPB	T3,P2			;STORE CHAR IN W
	JRST	PPNCHR			;LOOP FOR MORE

PPN0:	CAIE	T3,":"			;UNIT DELIMITER ?
	JRST	PPN1			;NO

	MOVEM	W,STRNAM		;YES, SAVE NAME OF DEVICE
	JRST	PPNLP

PPN1:	CAIE	T3,"]"			;END OF PPN ?
	JRST	PPN2			;NO

	HRRM	Q2,PPN			;YES, SAVE PROGRAMMER NUMBER
	TLZN	F,L.CMA			;CLEAR PPN COMMA FLAG
	RTN				;IT WASN'T ON, BAD !
	JRST	PPNLP

PPN2:	TLNN	F,L.LBK!L.CMA		;ANY SYNTAX REQUESTS ?
	JRST	PPN5			;NO

	TLZE	F,L.LBK			;PPN REQUEST ?
	HRLM	Q2,PPN			;YES, STORE PROJ NO.
	TLZE	F,L.CMA			;PPN PART 2 ?
	HRRM	Q2,PPN			;YES, STORE PROG NO.

PPN5:	CAIN	T3,0
	RTN				;NULL - COMPLETED

PPN3:	CAIE	T3,"["
	JRST	PPN4

	TLO	F,L.LBK			;PPN REQUEST
	JRST	PPNLP

PPN4:	CAIE	T3,","
	RTN				;ILLEGAL CHAR

	TLO	F,L.CMA			;COMMA, PART OF PPN
	JRST	PPNLP
SUBTTL	DEVICE SELECTION

DEVSEL:	SETZM	AUTOFLG#
	MOVEI	IP,LDNAME
	SKIPE	USER
	JRST	DEVUSR
	SETZM	DEVTYP
	GO	UBASEL
	JRST	GETCOM		;GET SELECTION

DEVUSR:	SETOM	DEVTYP
	RTN

;*LIST1 - LIST FILES

LIST1:	SETOM	LSTFLG
	JRST	RUNPRG

;*LSTPNT - LIST FILES (ASCIZ)

LSTPNT:	SETOM	SPECIAL
	PUSH	P,0
	GO	CRLF1
	SWITCH
	TLNE	LPTSW
	SETOM	LPTFLG
	CTYCLR
	POP	P,0
LSTPN1:	GO	LDACHR		;READ A CHAR
	JRST	START		;EOF
	GO	PNT16		;PRINT IT
	JRST	LSTPN1

;*DIRECT - PRINT DIRECTORY

DIRECT:	SKIPE	USER		;ILLEGAL IN USER MODE
	JRST	SELECT
	SWITCH
	TLNE	LPTSW
	SETOM	LPTFLG
	CTYCLR
	JRST	DSKDIR		;DISK DIRECTORY
SUBTTL	UNIBUS ADAPTER SELECTION

UBASEL:	PMSG	<^UBA # - >
	TTIOCT
	JRST	UBASEL
	CAIN	0,0
	JRST	UBAS0
	CAIN	0,1
	JRST	UBAS1
	CAIN	0,2
	JRST	UBAS2
	CAIN	0,3
	JRST	UBAS3

UBASX:	MOVE	T1,RHPNTR
	MOVEM	(T1)
	ADDI	2
	AOBJN	T1,.-2
	MOVEI	UBAP0
	HRRM	UNBMP0
	MOVEI	UNVBIT!UNV36X
	HRRM	$RHUVB
	SETOM	RHIALL#
	RTN

UBAS0:	MOVE	[1,,776700]
	JRST	UBASX
UBAS1:	MOVE	[1,,776700]
	JRST	UBASX
UBAS2:	MOVE	[2,,776700]
	JRST	UBASX
UBAS3:	MOVE	[3,,776700]
	JRST	UBASX

RHPNTR:	-^D21,,RPCS1

;*AUTOSL, AUTOMATICALLY SELECT LOAD DEVICE

AUTOSL:	SKIPE	USER
	JRST	DEVSEL		;USER MODE
	MOVEI	IP,LDNAME
	SETZM	DEVTYP
	MOVE	MSRH
	SKIPN			;ANY RH-11 BASE GIVEN ?
	JRST	DEVSEL		;NO, DO MANUALLY

	SETOM	AUTOFLG

	GO	UBASX		;SETUP INDIRECT POINTER TABLE

	GO	GETCXX		;INIT FLAGS

	MOVSI	P2,(SIXBIT/PS/)
	MOVEM	P2,STRNAM	;SETUP DEFAULT STRUCTURE

	GO	FNDUNI		;FIND UNIT

	SKIPE	TOPS10
	JRST	.+5

	MOVE	T1,MAXUNI	;FULL DECK ?
	SKIPN	DSKTAB(T1)
	 GO	MISUNI		;NO, MISSING UNIT
	SOJGE	T1,.-2

	MOVE	[D$DFLT,,D$DIR]
	BLT	D$DIR+3		;SETUP DEFAULT TOPS-20 DIRECTORY

	GO	FNDDIR		;FIND DEFAULT, TOPS-10 OR TOPS-20
	JRST	.+2
	RTN			;FOUND

	PMSG	<^?DEFAULT DIRECTORY NOT FOUND^>
	JRST	DEVSEL
SUBTTL	DSKLD - INITIAL ENTRY TO LOAD FROM DISK PACK

DSKLD:	SETZM	RHIALL
	MOVEI	2		;LDEV = 2
	MOVEM	LDEVICE
	SETZM	F		;DISK PACK
	SKIPE	TOPS10
	JRST	DSKL10		;TOPS-10 PACK

	GO	LOOK20		;TOPS-20 PACK, TRY TO FIND FILE
	JRST	NFERR		;NOT THERE, FAIL
	JRST	RFILE		;FOUND FILE

DSKL10:	GO	LOOK10		;FIND DIRECTORY
	JRST	DIRERR		;NOT FOUND
	GO	LOOK11		;FIND FILE
	JRST	NFERR		;NOT THERE
	JRST	RFILE		;FOUND FILE

;*RFILE1 - HERE WHEN FILE FOUND

RFILE1:	SKIPE	LSTFLG
	JRST	LSTPNT		;LISTING FILE

	SKIPN	CMDFLG
	SKIPE	DEVFLG		;READING CMD LIST FILE ?
	JRST	DEVCM2		;YES
	JRST	PRGCOR		;SETUP PROGRAM'S CORE AREA

RFILL1:	GO	RWORD		;READ POINTER OR TRANSFER WORD
	GO	ERR2		;EOF, ERROR

RFILL3:	SKIPL	Q3,T4		;WHICH IS IT?
	JRST	STARTQ		;TRANSFER WORD

	SKIPE	LDDMON
	JRST	RFILL4		;LOADING DIAG MON

RFILL2: GO	RWORD		;READ DATA WORD
	GO	ERR2		;EOF, ERROR
	MOVEM	T4,1(Q3)	;STORE IT IN CORE
	AOBJN	Q3,RFILL2	;COUNT THE CORE POINTER
	JRST	RFILL1		;IT RAN OUT, GET ANOTHER
;*RWORD - READ DATA WORD FROM FILE

RWORD:	SKIPE	USER
	JRST	URWD		;USER MODE
	SKIPN	TOPS10
	JRST	URWD		;TOPS-20 EXEC PACK

	JUMPGE	Q,RWNXTB	;NEED ANOTHER BLOCK ?
	MOVE	W,(Q)		;NO, GET A WORD
	AOBJN	Q,.+1		;COUNT IT
	JRST	CPOPJ1		;SKIP RETURN

RWNXTB:	MOVEM	Q3,SAVQ3
	GO	RDDSK		;READ NEXT BLOCK IF ANY
	RTN			;EOF
	MOVE	Q3,SAVQ3
	MOVE	Q,DBUFP		;PREPARE TO COUNT DATA WORDS
	JRST	RWORD+4		;READ FROM THIS BLOCK

RDDSK:	SKIPGE	LENGTH#		;ANY DATA LEFT ?
	RTN			;NO
	MOVNI	A,200		;SEE IF ANY LEFT
	ADDB	A,LENGTH	;COUNT FILE SIZE DOWN
	GO	SELBLK		;SELECT NEXT DATA BLOCK OF FILE
	RTN			;NONE LEFT
	MOVSI	A,-200
	SETZM	DBUF(A)		;CLEAR DATA BUFFER
	AOBJN	A,.-1
	MOVEI	P4,DBUF		;SELECT DATA BUFFER
	JRST	DSKBLK		;READ THE BLOCK AND SKIP RETURN

FNDD10:	GO	LOOK10		;FIND DIRECTORY
	RTN			;NOT THERE
	JRST	CPOPJ1		;FOUND
;*USRINT - USER MODE INIT, SETUP MINIMUM OF 32K OF CORE

USRINT:	SETZM	MONTYP
	MOVE	[112,,11]
	GETTAB
	JRST	.+3		;OOP'S, CAN'T TELL, USE TOPS-10
	CAIN	40000
	SETOM	MONTYP		;TOPS-20
	SETZM	INUPTR		;SET NO INPUT AVAILABLE
	MOVEI	<^D32*^D1024>-1
	CAMG	SVJBREL		;DO WE HAVE 32K MINIMUM ?
	RTN			;YES
	SKIPN	MONTYP
	JRST	.+4
	MOVEM	JOBREL		;NO, EXPAND CORE TO 32K
	MOVEM	SVJBREL		;SAVE MAX CORE NOW
	RTN
	CORE			;EXPAND CORE TO 32K
	GO	ERR10
	MOVE	JOBREL
	MOVEM	SVJBREL		;SAVE MAX CORE NOW
	RTN

;*USERLD, USER MODE LOADER

USERLD:	MOVEI	5
	MOVEM	LDEVICE

	SKIPN	MONTYP
	GO	USLD10		;TOPS-10

	MOVE	(IP)
	MOVEM	LDNAME		;SETUP FILE NAME
	HLLZ	1(IP)
	JUMPE	USLD1		;IF NO EXT, TRY A10 AND SAV

	GO	USLKUP		;LOOKUP FILE
	JRST	RFILE		;FOUND
	JRST	NFERR		;NOT FOUND

USLD1:	MOVSI	(SIXBIT/SAV/)
	GO	USLKUP		;LOOKUP "SAV"
	JRST	RFILE		;FOUND

	MOVSI	(SIXBIT/CMD/)
	GO	USLKUP		;LOOKUP "CMD"
	JRST	RFILE		;FOUND

	MOVSI	(SIXBIT/A10/)
	GO	USLKUP		;LOOKUP "A10"
	JRST	RFILE		;FOUND

	JRST	NFERR		;CAN'T FIND EITHER
USLKUP:	SKIPN	MONTYP
	JRST	USLK10		;TOPS-10

	MOVEM	LDNAME+1	;SETUP EXT

	MOVE	0,[POINT 7,FILASC]
	MOVEI	1,0
	MOVEI	2,"."		;FILE TERM
	GO	SIXASC		;SETUP ASCIZ FILE.EXT

	SKIPE	INJFN
	GO	CLOS20		;CLOSE LAST INPUT FILE

	HRLZI	1,(GJ%OLD!GJ%SHT)
	HRROI	2,FILASC	;ASCIZ FILE.EXT ADR

	GTJFN			;FIND FILE
	 JRST	CPOPJ1		;NOT FOUND

	HRLZM	1,INJFN#
	MOVEI	2,OF%RD

	OPENF			;OPEN FILE
	 JRST	T20ERR		;FAILED

	SETZM	LDBUF+1		;INIT WD COUNT, NO WORDS

	HLRZ	1,INJFN
	MOVE	2,[1,,.FBBYV]
	MOVEI	3,PAGCNT#

	GTFDB			;GET FILE PAGE COUNT

	HRRZS	PAGCNT		;KEEP ONLY PAGE COUNT

	HLRZ	LDNAME+1
	CAIN	(SIXBIT/CMD/)
	SETOM	CMDFLG		;LOADING "CMD"

	CAIN	(SIXBIT/A10/)
	SETOM	A10FLG		;LOADING "A10"
	RTN
;*URWD, USER MODE READ WORD

URWD:	SKIPN	USER
	JRST	.+3
	SKIPN	MONTYP
	JRST	URWD10		;TOPS-10

	SOSLE	LDBUF+1		;TOPS-20
	JRST	URWD1		;WORDS LEFT IN PAGE

	SOSGE	PAGCNT		;COUNT DOWN PAGE COUNT
	RTN			;NONE LEFT, EOF

	SKIPN	USER
	JRST	ERWD		;EXEC DISK READ

	MOVE	1,INJFN
	MOVE	2,[.FHSLF,,<LDBF_-^D9>]
	SETZM	3

	PMAP			;MAP IN FILE PAGE
	 ERJMP	T20ERR		;IF JUMP, ERROR

ERWD1:	MOVEI	1000
	MOVEM	LDBUF+1		;SET WORD COUNT
	MOVE	[POINT 36,LDBF]
	MOVEM	LDBUF		;SET BYTE POINTER
	AOS	INJFN		;INCREMENT FILE PAGE NUMBER

URWD1:	ILDB	W,LDBUF		;GET FILE WORD
	MOVE	Q,LDBUF
	JRST	CPOPJ1

ERWD:	MOVE	P5,INJFN	;GET FILE PAGE INDEX INTO XB
	CAIL	P5,772		;MAXIMUM XB POINTER = 512-6
	 GO	LNGERR		;BECAUSE OF LOAD LINKS
	MOVE	P5,A%XB(P5)	;GET DISK ADDRESS FOR FILE PAGE
	MOVEI	P4,LDBF		;WHERE TO READ IT

	GO	DSKRD4		;READ FILE PAGE
	 GO	IOERR

	JRST	ERWD1
;*USLD10 - TOPS-10 USER MODE LOAD ROUTINES

USLD10:	SETZM	LDBUF+1
	SETZM	LDBUF+2
	OPEN	LDCHN,LDBLK		;SETUP INPUT FILE
	GO	ERR8
	MOVE	[400000,,LDBF+1]
	MOVEM	LDBUF			;SETUP BUFFER POINTER
	MOVE	[201,,LDBF1+1]
	MOVEM	LDBF+1			;CLEAR BUFFER USE BITS
	MOVE	[201,,LDBF2+1]
	MOVEM	LDBF1+1
	MOVE	[201,,LDBF+1]
	MOVEM	LDBF2+1
	RTN

USLK10:	MOVEM	LDNAME+1
	LOOKUP	LDCHN,LDNAME
	JRST	CPOPJ1			;NOT FOUND
	HLRZ	LDNAME+1
	CAIN	(SIXBIT/CMD/)
	SETOM	CMDFLG			;LOADING "CMD" FILE
	CAIN	(SIXBIT/A10/)
	SETOM	A10FLG			;LOADING "A10" FILE
	RTN

URWD10:	SOSLE	LDBUF+2
	JRST	URWD11
	IN	LDCHN,
	JRST	URWD11
	STATZ	LDCHN,740000
	GO	ERR9
	RTN

URWD11:	ILDB	W,LDBUF+1
	MOVE	Q,LDBUF+1
	JRST	CPOPJ1
;*SIXASC, SIXBIT TO ASCIZ STRING CONVERSION

SIXASC:	MOVE	3,0		;SETUP STORAGE POINTER
	MOVEM	1,SIXAS1#	;SAVE EXT STORE POINTER
	MOVEM	2,SIXAS2#	;SAVE FILE TERM CHAR

	MOVE	1,LDNAME
	GO	SIXSTR

	MOVE	0,SIXAS2
	IDPB	0,3		;STORE FILE NAME TERM CHAR

	SKIPE	SIXAS1		;ANY EXT STORE POINTER ?
	MOVE	3,SIXAS1	;YES, USE IT THEN

	HLLZ	1,LDNAME+1
	SKIPE	1
	GO	SIXSTR

	IDPB	1,3		;STORE EXT TERM CHAR

	RTN

SIXSTR:	SETZB	0,2
	LSHC	0,6
	ADDI	0,40
	IDPB	0,3
	JUMPN	1,.-4
	RTN

FILASC:	BLOCK	3

T20ERR:	MOVEI	1,.PRIOU
	HRLOI	2,.FHSLF
	SETZM	3

	ERSTR			;PRINT TOPS-20 ERROR
	 JFCL
	 JFCL
	JRST	SELECT
SUBTTL DSKLDR DISK PACK LOAD ONLY ROUTINE

;*DEVICE BIT DEFINITIONS FOR RH11

RH.RC=	7			;RE-CALIBRATE
RH.DC=	11			;DRIVE CLEAR
RH.RIP=	21			;READ-IN PRESET
RH.PA=	23			;PACK ACKNOWLEDGE
RH.RD=	71			;READ COMMAND

RPNED=	10000			;NON EX DISK
RPRDY=	200			;READY
RPCLR=	40			;CLEAR
RPMOL=	10000			;MEDIUM ON-LINE
RPSC=	100000			;SPECIAL CONDITIONS
RPTRE=	40000			;TRE ERROR
RPATA=	100000			;ATTENTION
RPERR=	40000			;ERROR
RPDVA=	4000			;DRIVE AVAILABLE
RPMCPE=	20000			;MASSBUS CONTROL PARITY ERROR
RPDPR=	400			;DRIVE PRESENT
RPVV=	100			;VOLUME VALID

;*UNIBUS DEFINITIONS

RPPGSZ=	^D128*2			;PAGE SIZE FOR 11 TRANSFER
UBAP0=	763000			;ADDRESS OF UNIBUS MAP
UNVBIT=	40000			;VALID UNIBUS BIT FOR UNIBUS
UNV36X=	100000			;UNIBUS 36 BIT TRANSFER
UNVDPB=	20000			;UNIBUS DISABLE PARITY BIT

;*SYSTEM PARAMETERS, MUST AGREE WITH MONITOR

HOMBK1=	1			;ADDRESS OF HOME BLOCKS
HOMBK2=	^D10
CODHOM=	707070			;VERIFICATION CODE OF HOME BLOCK
CODRIB=	777777			;VERIFICATION CODE OF RIB BLOCK
;*LOOK10 - TOPS-10 SUBROUTINE TO LOOK FOR DIRECTORY

LOOK10:	MOVS	A,STRNAM		;GET DEVICE NAME
	CAIN	A,(SIXBIT/PS/)		;PS IS DEFAULT FOR TOPS20
	JRST	.+3			;DO TOPS10 WILD SEARCH
	SKIPE	A			;BLANK
	CAIN	A,(SIXBIT/DSK/)		;OR JUST DSK?
	TROA	F,R.DSKW		;YES, FLAG WILD DISK NAME
	JRST	LOOK1			;NO, USE SUPPLIED NAME
	MOVE	A,[SIXBIT/KLAD/]	;START AT KLAD
	MOVEM	A,STRNAM		;STORE NAME AWAY
	JRST	LOOK1

LOOK2:	MOVEI	A,010000		;INCREMENT WILD DSK NAME
	ADDB	A,STRNAM
	TRNE	A,200000		;TRIED UP TO DSKO?
	JRST	NOTFN1			;YES, GIVE UP

LOOK1:	MOVE	A,STRNAM		;DEVICE NAME TO LOOK FOR
	MOVEM	A,STRUCT		;TO ARG OF SEARCH ROUTINE
	SETZM	SLUNIT			;CLEAR LOGICAL UNIT NUMBER
	GO	FNDUNI			;TRY TO FIND SUCH A UNIT
	JRST	NOTFND			;NOT THERE

LOOK3:	SKIPN	P3,PPN			;FIRST SEARCH FOR THE UFD
	MOVE	P3,DIAGPPN		;IF NONE, USE DIAG AREA
	MOVSI	P5,(SIXBIT/UFD/)	;EXT IS UFD FOR FILE DIRECTORY	
	MOVEM	P5,EXT#
	MOVE	A,HBUF+HOMMFD		;LBN IN STR OF MFD RIB
	GO	SRCHFD			;SEARCH FOR REQUESTED UFD
	JRST	NOTFND			;NOT THERE
	JRST	CPOPJ1			;DIRECTORY FOUND

NOTFND:	TRNE	F,R.DSKW		;WILD DEVICE ARGUMENT
	JRST	LOOK7			;YES, INCREMENT IT
	SKIPE	MFDFLG
	JRST	GETCOM-2		;END OF MFD PRINT
	SKIPE	DDIRF1
	JRST	SELECT			;END OF DIR PRINT
NOTFN1:	RTN				;NOT FOUND, ERROR RETURN

LOOK7:	MOVE	A,STRNAM		;DID'NT FIND KLAD
	CAME	A,[SIXBIT/KLAD/]
	JRST	.+4
	MOVE	A,[SIXBIT/RED/]		;TRY RED
	MOVEM	A,STRNAM
	JRST	LOOK1
	CAME	A,[SIXBIT/RED/]
	JRST	LOOK2
	SKIPE	AUTOFLG
	JRST	NOTFN1			;DO KLAD & RED ONLY AUTO
	MOVE	A,[SIXBIT/DSK@/]	;TRY DSKA THRU DSKO
	MOVEM	A,STRNAM
	JRST	LOOK2

;*LOOK11 - TOPS-10 SUBROUTINE TO LOOK FOR FILE

LOOK11:	SKIPE	DDIRFLG
	JRST	LOOK5			;DOING DIRECTORY
	MOVE	P3,(IP)			;NAME OF FILE TO SEARCH FOR
	HLLZ	P5,1(IP)		;EXTENSION
	MOVEM	P5,EXT

LOOK4:	HRRZ	A,1(A)			;SUPERCLUSTER ADDRESS OF THE UFD
	IMUL	A,HBUF+HOMBSC		;MAKE IT A BLOCK NUMBER
	GO	SRCHFD			;SEARCH FOR THE FILE IN UFD
	JRST	NOTFND			;NO SUCH FILE
	HRRZ	LBNAC,1(A)		;SUPERCLUSTER OF START OF FILE
	IMUL	LBNAC,HBUF+HOMBSC 	;CONVERT TO LOGICAL BLOCK NUMBER
	GO	SETRIB			;GET THE RIB, CHECK IT
	JRST	NOTFND			;NO LUCK, ASSUME FILE NOT THERE
	HLLZ	B,RBUF+RIBEXT		;GET THE EXTENSION FROM RIB
	CAME	P3,RBUF+RIBNAM	 	;DESIRED NAME?	
	JRST	.+4			;NO
	SKIPN	EXT
	JRST	LOOK6			;NO EXT GIVEN
	CAME	B,EXT			;DESIRED EXTENSION?
	GO	ERR11			;NO, QUIT.  RIB BAD
	JRST	CPOPJ1			;SUCCESSFUL RETURN

LOOK5:	SETOM	DDIRF1			;SET PRINT DIRECTORY
	JRST	LOOK4

LOOK6:	GO	EXTCK			;CHECK FOR "A10" OR "SAV"
	GO	ERR11			;NEITHER
	JRST	CPOPJ1			;OK

EXTCK:	CAMN	T2,[SIXBIT/SAV/]
	JRST	CPOPJ1			;FILE EXT IS "SAV"

	CAME	T2,[SIXBIT/A10/]
	JRST	.+3
	SETOM	A10FLG			;FILE EXT IS "A10"
	JRST	CPOPJ1

	CAME	T2,[SIXBIT/CMD/]
	RTN				;NEITHER
	SETOM	CMDFLG			;FILE EXT IS "CMD"
	JRST	CPOPJ1
;*DDIR10 - TOPS-10 DISK PACK DIRECTORY ROUTINE

DDIR10:	SETZM	F
	GO	LOOK10			;DO DIRECTORY
	JRST	DIRERR			;DIRECTORY NOT FOUND
	GO	LOOK11
	RTN				;DONE

DDIRPNT:MOVE	IP,A			;SETUP POINTER
	PUSH	P,0
	SKIPN	(IP)
	JRST	DDIRP1			;BLANK NAME
	MOVE	A,(IP)			;PRINT NAME & EXT
	SKIPE	MFDFLG
	JRST	DDIRMFD			;PRINT MFD
	GO	SIXBP
	MOVEI	"."
	GO	PRINT
	HLLZ	A,1(IP)
	GO	SIXBP
DDIRP3:	AOS	A,TABCTR		;DONE 4 ENTRIES ON THIS LINE ?
	TRNE	A,3
	JRST	.+3			;NO
	GO	CRLF1			;YES, DO CRLF
	JRST	DDIRP1
	GO	PNTTAB
	ANDI	A,3			;ENTRIES LINE UP ?
	IMULI	A,^D16			;COMPUTE AFTER TAB POSITION
	CAME	A,CHRCTR		;CARRIAGE IN CORRECT PLACE ?
	GO	PNTTAB			;NO, TAB AGAIN
DDIRP1:	POP	P,0
	MOVE	A,IP
	JRST	SCHN2

DDIRMFD:PUT	A
	HLRZ	A
	GO	PNTOCS			;PRINT P
	MOVEI	","
	GO	PRINT
	GET	A
	HRRZ	A
	GO	PNTOCS			;PRINT PN
	JRST	DDIRP3
;*SRCHFD - SUBROUTINE TO SEARCH A UFD OR MFD FOR FILE & EXT
;*	   RIB LBN IN STR OF THE FD IN A

SRCHFD:	SKIPG	LBNAC,A			;STORE BLOCK TO READ RIB FROM
	GO	ERR12			;SHOULDN'T BE EOF
	GO	SETRIB			;SET UP THE RIB
	RTN				;CAN'T READ IT
SCHL1:	GO	RDDSK			;READ THE FILE DIR DATA FROM THIS FD
	RTN				;ERROR RETURN
	MOVE	A,DBUFP
	SKIPE	DDIRF1
	JRST	DDIRP2
SCHL2:	SKIPE	DDIRF1
	JRST	DDIRPNT			;PRINT DIRECTORY
	MOVE	B,(A)			;GET A FILE NAME
	CAME	B,P3			;IS NAME RIGHT?
	JRST	SCHN2			;NO, MOVE ON
	HLLZ	B,1(A)			;CHECK THE EXTENSION
	SKIPN	EXT
	JRST	SCHL2A			;NO EXT, CHECK FOR "A10" OR "SAV"
	CAMN	B,EXT			;IS IT RIGHT TOO?
	JRST	CPOPJ1			;YES.  GOOD RETURN, ANSWER IN (A)
SCHN2:	AOBJN	A,.+1			;MOVE ON TO NEXT FILE IN FD
	AOBJN	A,SCHL2			;COUNT FILE + EXT, CHECK NEXT FILE IN FD
SCHN1:	JRST	SCHL1			;READ ON

SCHL2A:	GO	EXTCK			;CHECK EXT
	JRST	SCHN2			;NO MATCH
	JRST	CPOPJ1			;OK

;*LBNSEL - SUBROUTINE TO SELECT CORRECT UNIT FROM LBN

LBNSEL:	MOVE	A,LBNAC			;GET DESIRED BLOCK NUMBER
	MOVE	B,HBUF+HOMBSC		;COMPUTE SIZE OF UNIT
	IMUL	B,HBUF+HOMSCU
	IDIV	A,B			;SCALE LBN INTO A UNIT AND LOCAL LBN
	MOVE	LBNAC,B			;LBN WITHIN THE UNIT?
	CAMN	A,HBUF+HOMLUN		;ALREADY AT THIS UNIT?
	JRST	CPOPJ1			;YES, NO NEED TO CHANGE UNITS
	MOVEM	A,SLUNIT		;NO, NEED TO FIND IT
	PUSH	P,LBNAC			;SAVE THE LBN WITHIN DESIRED UNIT
	GO	FNDUNI			;FIND THE UNIT
	SOS	-1(P)			;NOT THERE, SET FOR NON-SKIP RETURN
	POP	P,LBNAC			;RESTORE UNIT LBN
	JRST	CPOPJ1			;AND SKIP RETURN

DDIRP2:	LDB	B,[POINT 6,DBUF,5]	;IF 1ST WORD IS POINTER
	CAIN	B,77			;MUST BE SPARE RIB - DONE
	RTN
	JRST	SCHL2
;*SELBLK - SUBROUTINE TO SELECT NEXT BLOCK OF DATA
;*	   THE DATA IS FOUND USING RIB'S STARTING AT 0(S), OR
;*	   IF STUFF LEFT OVER FROM CURRENT RIB, VIA CLUCNT,BLKCNT,CLBN

SELBLK:	AOS	LBNAC,CLBN		;ASSUME WILL USE NEXT BLOCK
	SOSL	BLKCNT			;ANY BLOCKS LEFT IN CURRENT CLUSTER?
	JRST	SEL1			;YES, GO PICK ONE
	SOSL	CLUCNT			;ANY CLUSTERS LEFT IN CURRENT RET PTR?
	JRST	SEL2			;YES, PICK ONE
SEL4L:	SKIPGE	P2			;FAIL IF OUT OF POINTERS
	SKIPN	A,RBUF(P2)		;NEED ANOTHER RET PTR.  EOF YET?
	RTN				;YES, FAIL RETURN
	AOBJN	P2,.+1			;COUNT POINTER FOR NEXT RIB
	MOVE	T3,HBUF+HOMCNP		;GET THE COUNT POINTER
	GO	RIBBYT			;GET COUNT OF CURRENT RET PTR
	JUMPN	B,SEL3			;IF NON-ZERO, GO GET CLUSTER
	MOVE	T3,HBUF+HOMCLP		;NEW UNIT, GET UNIT LOGICAL NUMBER
	GO	RIBBYT
	CAMN	B,HBUF+HOMLUN		;IS THIS UNIT RIGHT ALREADY?
	JRST	SEL4			;YES, DON'T SEARCH
	MOVEM	B,SLUNIT		;NO, SAVE LOG UNIT NUMBER FOR SEARCH
	GO	FNDUNI			;FIND THE UNIT
	RTN				;NOT FOUND, ERROR
SEL4:	JRST	SEL4L			;READ NEXT RIB ON NEW UNIT

SEL3:	SUBI	B,1			;COUNT CLUSTER ABOUT TO BE USED
	MOVEM	B,CLUCNT		;AND SAVE REMAINDER
	MOVE	T3,HBUF+HOMCLP		;GET THE CLUSTER ADDRESS
	GO	RIBBYT
	IMUL	B,HBUF+HOMBPC		;CONVERT TO AN LBN
	MOVEM	B,LBNAC			;PUT IN CORRECT AC
SEL2:	MOVE	A,HBUF+HOMBPC		;BLOCKS IN A CLUSTER
	SUBI	A,1			;MINUS THE ONE ABOUT TO BE READ
	MOVEM	A,BLKCNT		;SAVE THIS COUNT
SEL1:	MOVEM	LBNAC,CLBN		;SAVE CURRENT LBN
	MOVEM	LBNAC,LBN
	TRZE	F,R.SRIB		;SKIP RIB?
	JRST	SELBLK			;YES, GO THRU THIS ROUTINE AGAIN
	JRST	CPOPJ1			;SUCCESSFUL RETURN
;*SETRIB - SUBROUTINE TO SETUP A RIB BLOCK AND CHECK IT

SETRIB:	GO	LBNSEL			;MAKE SURE ON RIGHT UNIT
	RTN				;NOT THERE
	MOVEI	P4,RBUF			;ADDRESS OF THE RIB BUFFER
	MOVEM	LBNAC,LBN
	GO	DSKBLK			;READ THE FILE'S RIB
	RTN				;COULDN'T READ IT
	SETZM	CLUCNT			;NO CLUSTERS LEFT
	SETZM	BLKCNT			;NO BLOCKS LEFT IN CLUSTER
	MOVE	A,RBUF+RIBSIZ		;LENGTH OF FILE
	MOVEM	A,LENGTH		;SAVE FOR EOF TEST
	MOVE	A,RBUF+BLKCOD		;CHECK THE CODE WORD
	CAIE	A,CODRIB
	RTN				;RIB CODE BAD
	TRO	F,R.SRIB		;WANT TO SKIP RIB WHEN READING
	MOVE	P2,RBUF+RIBFIR		;POINTER TO REAL RIB DATA
	JRST	CPOPJ1			;SUCCESSFUL RETURN

;*FNDUNI, FIND A PARTICULAR LOGICAL UNIT IN THE SYSTEM

FNDUNI:	SETZM	TTYPE		;CLEAR SEARCH TEMPS
FNDUL1:	SETZM	TUNIT
FNDUL2:	MOVE	P5,TTYPE	;GET CONTROLLER TYPE
	MOVE	Q2,TUNIT	;AND UNIT NUMBER

	GO	HOME		;TRY TO READ ITS HOME BLOCK
	JRST	FNDUNX		;NO GOOD, ON TO NEXT		

	GO	CHKHOM		;CHECK HOME BLOCK
	JRST	FNDUNX		;NO GOOD, ON TO NEXT
	JRST	CPOPJ1

FNDUNX:	AOS	T1,TUNIT	;COUNT TO NEXT UNIT ON CONTROLLER
	CAIG	T1,UNIMAX	;TOO BIG?		
	JRST	FNDUL2		;NO, GO CHECK THIS ONE
	AOS	T1,TTYPE	;YES, COUNT TO NEXT TYPE OF CONTROLLER
	CAIG	T1,TYPMAX	;ALL OF THOSE GONE BY?		
	JRST	FNDUL1		;NO,TRY THIS ONE
	RTN			;ALL TRIED, RETURN

RIBBYT:	HRRI	T3,A		;WHERE THE WORD IS
	LDB	B,T3		;GET THE DESIRED BYTE
	RTN
;*HOME, DETERMINE WHETHER A UNIT EXISTS, AND IF SO,
;*	 READ ITS HOME BLOCK INTO THE HOME BUFFER
;*	 CALL SEQUENCE:
;*		P5/	CONTROLLER TYPE INDEX
;*		Q2/	UNIT NUMBER, 0-7
;*	  GO HOME
;*	  NOT THERE RETURN
;*	  OK	RETURN

HOME:	MOVEM	Q2,CUNIT	;SAVE CURRENT UNIT TYPE
	MOVEM	P5,CTYPE	;SAVE CONTROLLER TYPE
	GO	DSKINI		;INIT DISK
	RTN			;ERROR, NOT THERE

	MOVEI	P1,HOMBK1	;WANT TO READ FIRST HOME BLOCK
HOM1:	MOVEM	P1,LBN
	MOVEI	P4,HBUF		;READ HOME BLOCK INTO ITS BUFFER
	GO	DSKBLK		;TRY TO READ THE HOME BLOCK
	JRST	HOM2		;CAN'T READ THAT ONE
	MOVE	T1,HOMCOD	;GET THE CODE WORD
	CAIE	T1,CODHOM	;IS IT RIGHT?
	JRST	HOM2		;NO GOOD
	JRST	CPOPJ1		;OK RETURN

HOM2:	CAIN	P1,HOMBK2	;TRIED BOTH BLOCKS?
	RTN			;YES, GIVE FAIL RETURN
	MOVEI	P1,HOMBK2	;NO, TRY ANOTHER ONE
	JRST	HOM1		;READ SECOND HOME BLOCK

DSKINI:	MOVE	Q2,CUNIT	;GET UNIT
	MOVEI	T3,UNIINI	;COMPUTE TABLE OFFSET
	ADD	T3,CTYPE
	JRST	@(T3)		;INIT DISK & SKIP RETURN IF OK
;*DSKBLK - ROUTINE TO READ A BLOCK FROM THE DEVICE AND UNIT IN
;*	   CTYPE & CUNIT INTO THE BUFFER AT (T1)+1, FROM LOGICAL BLOCK
;*	   NUMBER IN P1 SKIP RETURN IF SUCCESSFUL, NON-SKIP IF ANY
;*	   HARDWARE ERRORS

	SETOM	FULPAG#		;READ FULL PAGE, 4 SECTORS
	JRST	.+2
DSKBLK:	SETZM	FULPAG		;READ ONE SECTOR
	JSP	T3,SETCHN	;SETUP CHN CONTROL WORD & CALL PROPER READ ROUTINE

	RHREAD			;1ST RH11/RP04/5/6/RM03

;*UNIINI - INITIALIZE CONTROLLER ROUTINES

UNIINI:	RHINIT			;FIRST RH11/RP04/5/6/RM03

TYPMAX=.-UNIINI-1		;MAXIMUM CONTROLLER ROUTINE
UNIMAX=7			;MAX NUMBER OF UNITS ON A CONTROLLER

;*SETCHN - SUBROUTINE TO SETUP CHANNEL, THEN DISPATCH TO DEVICE
;*	   DEPENDENT ROUTINE

SETCHN:	MOVE	P5,CTYPE	;WHAT CONTROLLER
	ADDI	T3,(P5)
	JRST	@(T3)		;CALL DISPATCH ENTRY
;*RHINIT - INITIALIZATION FOR RH11/RP04/5/6/RM03

RHINIT:	CAILE	Q2,7		;SEE IF LAST DRIVE
	RTN			;YES, EXIT
	MOVEI	T1,RPCLR
	WRIO	T1,@RPCS2	;CLEAR DISK
	WRIO	Q2,@RPCS2	;SELECT DRIVE
	MOVEI	T1,RPDVA
	TION	T1,@RPCS1	;IS DRIVE AVAILABLE ?
	RTN			;NO
	RDIO	T1,@RPDS	;READ DRIVE STATUS
	TRNE	T1,RPATA!RPERR
	RTN			;ERROR IN THIS DRIVE
	TRC	T1,RPDPR!RPRDY
	TRCE	T1,RPDPR!RPRDY
	RTN			;ERROR/ NOT AVAILABLE

	RDIO	T1,@RPDT	;READ DRIVE TYPE
	ANDI	T1,777
	CAIL	T1,20		;RP04=20, RP05=21, RP06=22, RM03=24
	CAILE	T1,24
	RTN			;NO DEVICE OR NOT AN RP04/5/6/RM03
	MOVEM	T1,RPTYPE#
	GO	DRVINI		;INIT DRIVE PARAMETERS

	MOVEI	T1,RH.PA	;PACK ACK COMMAND
	WRIO	T1,@RPCS1	;DO IT
	RDIO	T1,@RPDS	;READ DEVICE STATUS REGISTER
	TRNN	T1,RPMOL	;POWERED UP WITH A PACK ON-LINE ?
	RTN			;NO

	MOVEI	T1,RH.DC
	WRIO	T1,@RPCS1	;DO A DRIVE CLEAR

	SKIPN	RHIALL		;RESET ALL ?
	JRST	CPOPJ1		;NO

	MOVEI	T1,RH.RC
	WRIO	T1,@RPCS1	;DO A RECAL
	GO	WAIT		;WAIT FOR READY
	SKIPG	T1
	RTN			;ERROR
	MOVEI	T1,RH.RIP
	WRIO	T1,@RPCS1	;DO A READ-IN PRESET
	GO	WAIT		;WAIT FOR READY
	SKIPG	T1
	RTN			;ERROR
	JRST	CPOPJ1		;SKIP RETURN
;*DRVINI - INITIALIZE DRIVE PARAMETERS

DRVINI:	PUT	T3
	PUT	T4
	CAIN	T1,.R4TYP	;RP04 ?
	GO	R4TYPE
	CAIN	T1,.R5TYP	;RP05 ?
	GO	R5TYPE
	CAIN	T1,.R6TYP	;RP06 ?
	GO	R6TYPE
	CAIN	T1,.R3TYP	;RM03 ?
	GO	R3TYPE
	MOVEM	T2,NUMCYL#	;SETUP # OF CYL ON DISK
	MOVEM	T3,N.SCCL#	;SETUP # OF SECTORS PER CYL
	MOVEM	T4,N.STRK#	;SETUP # OF SECTORS PER TRACK
	GET	T4
	GET	T3
	RTN

R4TYPE:	MOVEI	T2,N.CLP4
	MOVEI	T3,N.SPC4
	MOVEI	T4,N.SPT4
	RTN

R5TYPE:	MOVEI	T2,N.CLP5
	MOVEI	T3,N.SPC5
	MOVEI	T4,N.SPT5
	RTN

R6TYPE:	MOVEI	T2,N.CLP6
	MOVEI	T3,N.SPC6
	MOVEI	T4,N.SPT6
	RTN

R3TYPE:	MOVEI	T2,N.CLP3
	MOVEI	T3,N.SPC3
	SKIPE	TOPS10
	MOVEI	T3,T.SPC3		;TOPS-10
	MOVEI	T4,N.SPT3
	RTN
;*RHREAD - READ ROUTINE FOR RH11/RP04/5/6/RM03
;*	ENTRY:	P1/ LOGICAL BLOCK NUMBER
;*		Q2/   DRIVE NUMBER
;*		P4/  MEMORY ADDRESS
;*	EXIT:	+1 FOR ERROR
;*		+2 SUCESSFUL

RHREAD:	MOVEI	T4,RH.RD	;RH11 READ
	PUT	0
	PUT	1
	PUT	P2
	MOVEI	P2,5		;RETRY 5 TIMES

DRETRY:	MOVE	T1,LBN		;GET DISK ADDRESS
	IDIV	T1,N.SCCL	;GET CYL IN T1, SECTOR IN T2
	PUT	T2		;SAVE CYL
	MOVEI	RPCLR
	WRIO	@RPCS2		;CLEAR RH11
	MOVE	Q2,CUNIT
	WRIO	Q2,@RPCS2	;SET UNIT NUMBER
	WRIO	T1,@RPDC	;SET DESIRED CYLINDER
	GET	T1		;RESTORE SECTOR WITHIN CYL
	IDIV	T1,N.STRK	;GET TRACK IN T1, SECTOR IN T2
	LSH	T1,^D8		;POSITION IN THE TRACK #
	IOR	T1,T2		;ADD THE SECTOR
	WRIO	T1,@RPDA	;SET DESIRED ADDRESS REGISTER

	MOVE	T1,P4		;GET PHYSICAL ADDRESS IN T1
	PUT	T1
	LSH	T1,-^D9		;SET CORE ADDRESS
$RHUVB:	IORI	T1,UNVBIT!UNV36X
	WRIO	T1,@UNBMP0	;SET UNIBUS MAP
	GET	T1
	ANDI	T1,777
	LSH	T1,2		;CHANGE TO -11 ADDRESS
	WRIO	T1,@RPBA	;SET UNIBUS ADDRESS
	MOVNI	T1,RPPGSZ
	SKIPE	FULPAG
	MOVNI	T1,RPPGSZ*4	;READ FULL PAGE, 4 SECTORS
	WRIO	T1,@RPWC	;SET SIZE OF TRANSFER

TRYIT:	GO	DOIO		;DO I/O
	CONI	PAG,T2
	CONO	PAG,(T2)	;FLUSH CACHE IF ON
	JUMPG	T1,RWSXIT	;IF NO ERRORS, SUCCESS EXIT
	SOJG	P2,TRYECC	;ERROR, TRY ECC CORRECTION
	JRST	RWFXIT		;FAILED

RWSXIT:	AOS	-3(P)		;SKIP RETURN
RWFXIT:	GET	P2
	GET	1
	GET	0
	RTN
;* SUBROUTINE TO ATTEMPT TO DO ECC CORRECTION 

TRYECC:	SKIPE	FULPAG		;FULL PAGE READ ?
	JRST	DRETRY		;YES, NO ECC THEN
	RDIO	T1,@RPER1	;READ ERROR REG 1
	ANDI	T1,177777
	CAIE	T1,100000	;DCK ONLY ?
	JRST	DRETRY		;NO, NOT CORRECTABLE.

	RDIO	T1,@RPEC1	;READ ECC POSITION REGISTER
	ANDI	T1,177777	;SAVE 16 BIT DATA FIELD
	SKIPN	T2,T1		;CHECK POS AND GET IT TO T2
	JRST	DRETRY		;IF 0, ECC BROKEN. DON'T CORRECT

	CAILE	T1,^D4608+^D32-^D11 ;SEE IF POSITION IS WITHIN RANGE
	JRST	DRETRY		;ECC BROKEN. DON'T CORRECT
	SUBI	T1,1		;NORMALIZE THE POSITION COUNT
	MOVEM	T1,ECCPOS#	;FOR FUTURE USE
	RDIO	T1,@RPEC2	;WE NEED ECC PATTERN REG
	LDB	0,[POINT 11,T1,35] ;GET THE 11 BIT BURST PATTERN
	SUBI	T2,^D4607-^D11	;SEE IF POSITION EXCEEDS DATA FIELD
	JUMPLE	T2,NORM		;IF + . WE OVERLAP AND MUST ADJ. PATTERN

; MODIFY ECC PATTERN IF CORRECTION SPILLS OVER THE DATA FIELD

	LSH	0,^D25(T2)	;THROW AWAY APPROPRIATE BITS
	MOVNS	T2,T2		;WANT TO SHIFT LEFT NEXT
	LSH	0,-^D25(T2)	;NOW HAVE CORRECT PATTERN LENGTH

; THE ACTUAL CODE TO CORRECT THE DATA ERROR

NORM:	SETZ	T1,		;AND CLEAR ADJACENT AC
	MOVE	T2,ECCPOS	;GET THE POSITION BACK AGAIN
	IDIVI	T2,^D36		;GET BUFFER OFFSET PLUS REMAINDER
	ADD	T2,P4		;POINTS TO 1ST WORD NEEDING CORRECTION
	ROTC	0,(T3)		;SLIDE THE PATTERN INTO PLACE
	MOVSS	0,0		;HALVES MUST BE SWAPPED
	MOVSS	1,1		; BECAUSE OF RP0X DATA PATH MAPPING
	XORM	0,(T2)		;CORRECT THE FIRST WORD
	XORM	1,1(T2)		;CORRECT THE SECOND WORD
	JRST	RWSXIT		;PASSED RETURN
;*DOIO, PERFORM DISK OPERATION

DOIO:	WRIO	T4,@RPCS1	;DO COMMAND

;*WAIT, WAIT FOR COMPLETION OR ERROR

WAIT:	MOVSI	T1,2		;SET DELAY COUNT
	MOVEI	T2,RPATA!RPERR!RPRDY
	TION	T2,@RPDS	;WAIT FOR COMPLETION OR ERROR
	SOJG	T1,WAIT+1
	JUMPLE	T1,WAITF	;TIMEOUT RETURN

	RDIO	T2,@RPCS1	;READ STATUS
	TRNE	T2,RPERR!RPMCPE
WAITF:	SETO	T1,		;YES, SET T1 MINUS AS FLAG
	RTN

;*RH11CH, CHANNEL TABLE FOR RH11'S

RH11CH:
RPCS1:	0			;STATUS 1
RPWC:	0			;WORD COUNT
RPBA:	0			;BUS ADDRESS
RPDA:	0			;DISK ADDRESS (SECTOR & TRACK)
RPCS2:	0			;STATUS 2
RPDS:	0			;DRIVE STATUS
RPER1:	0			;ERROR REGISTER 1
RPAS:	0			;ATTENTION SUMMARY
RPLA:	0			;LOOK AHEAD
RPDB:	0			;DATA BUFFER
RPMR:	0			;MAINTENANCE
RPDT:	0			;DRIVE TYPE
RPSN:	0			;SERIAL NUMBER
RPOF:	0			;OFFSET
RPDC:	0			;DESIRED CYLINDER
RPCC:	0			;CHAR
RPER2:	0			;ERROR 2
RPER3:	0			;ERROR 3
RPEC1:	0			;ECC
RPEC2:	0			;ECC
UNBMP0:	0			;UNIBUS MAP
;*ERROR - ERROR REPORTING

	SETZM	ONCE		;ABORT ERROR
ERROR:	SETOM	RHIALL
	PUSH	P,1
	GO	CRLF1
	MOVEI	"?"
	GO	PRINT
	POP	P,0
	PNTMSG
	PMSG	< ERROR AT >
	MOVE	0,(P)
	SOS
	GO	PNTOCT		;PRINT PC OF ERROR

	MOVEI	" "
	GO	PRINT
	GO	NAMPNT		;PRINT FILE NAME

	SKIPN	ONCE		;INITIAL LOAD ERROR ?
	JRST	SELX1		;YES

	SKIPE	PGMGO
	JRST	SELECT
	JRST	RUN

;*NFERR1 - PROGRAM NOT FOUND ERROR

NFERR1:	PMSG	<^?PROGRAM NOT FOUND - >
	GO	NAMPNT
	RTN
;*SMMON, SMMAG, SMAPT - LOAD DIAGNOSTIC MONITOR'S

SMMON:	MOVEI	IP,[SIXBIT/SMMON/
		    0]
	JRST	SMAPT+1

SMMAG:	MOVEI	IP,[SIXBIT/SMMAG/
		    0]
	JRST	SMAPT+1

SMAPT:	MOVEI	IP,[SIXBIT/SMAPT/
		    0]

	SETOM	LDDMON
	GO	DIAGLD-2
	JRST	SELX1
	HALT	.

CLRCR2:	SETZM	30000
	MOVE	[30000,,30001]
	BLT	37777
	RTN

STARTM:	SETZM	MSRH		;NO AUTO SELECT
	HRRZ	T4,T4
	MOVE	[30000,,20000]	;TRANSFER DIAG MON
	MOVE	1,[BLT	27767]	;TO CORRECT PLACE
	MOVE	2,[JRST	@T4]	;START IT
	JRST	1

LDTEN3:	CAIGE	13,1000		;LOAD 0 TO 777 DIRECT
	JRST	LDTEN2
	CAIGE	13,20000
	JRST	LDTEN4		;BAD DIAG MON ADDRESS
	ADDI	13,10000	;OFFSET LOAD
	JRST	LDTEN2

LDTEN4:	MOVEI	T1,[SIXBIT/BAD DIAG MON ADDRESS_/]
	JRST	ERROR-1

RFILL4:	HRRZ	16,Q3
	CAIGE	16,777		;LOAD 0 TO 777 DIRECT
	JRST	RFILL2
	CAIGE	16,17777
	JRST	LDTEN4		;BAD DIAG MON ADDRESS
	ADDI	Q3,10000	;OFFSET LOAD
	JRST	RFILL2
;*ERROR REPORT MESSAGES

IOERR:	MOVEI	T1,[SIXBIT/IO ERROR_/]
	JRST	ERROR-1

BADUNI:	MOVEI	T1,[SIXBIT/MISMATCHED UNITS_/]
	JRST	ERROR-1

MISUNI:	MOVEI	T1,[SIXBIT/MISSING UNIT_/]
	JRST	ERROR-1

DPLUNI:	MOVEI	T1,[SIXBIT/DUPL STR UNIT_/]
	JRST	ERROR-1

BADSTR:	MOVEI	T1,[SIXBIT/HOM BLKS BAD_/]
	JRST	ERROR-1

LNGERR:	MOVEI	T1,[SIXBIT/FILE TOO LONG_/]
	JRST	ERROR-1

LERR3:	MOVEI	T1,[SIXBIT/FLTYPE_/]
	JRST	ERROR
LERR4:	MOVEI	T1,[SIXBIT/FORMAT_/]
	JRST	ERROR
LERR5:	MOVEI	T1,[SIXBIT/CKSUM_/]
	JRST	ERROR
ERR2:	MOVEI	T1,[SIXBIT/ILLEOF_/]
	JRST	ERROR
ERR6:	MOVEI	T1,[SIXBIT/1STPTR_/]
	JRST	ERROR
ERR7:	MOVEI	T1,[SIXBIT/STADR_/]
	JRST	ERROR
ERR8:	MOVEI	T1,[SIXBIT/OPEN_/]
	JRST	ERROR
ERR9:	MOVEI	T1,[SIXBIT/RDERR_/]
	JRST	ERROR
ERR10:	MOVEI	T1,[SIXBIT/CORE_/]
	JRST	ERROR
ERR11:	MOVEI	T1,[SIXBIT/BADRIB_/]
	JRST	ERROR
ERR12:	MOVEI	T1,[SIXBIT/RIBEOF_/]
	JRST	ERROR
ERR13:	MOVEI	T1,[SIXBIT/PAKTYP_/]
	JRST	ERROR

DBUFP:	-200,,DBUF		;POINTER TO DATA BLOCK
PPNPTR:	POINT 6,W		;POINTER FOR PPN INPUT
DIAGPPN: 6,,2020		;DEFAULT FOR DIAG AREA ??
SUBTTL	STORAGE ASSIGNMENTS
	LIT
	VAR
PGNAME:	SIXBIT /SMMON/		;PROGRAM NAME
PLIST:	BLOCK	40		;PUSH LIST

PGMGO:	0			;LOAD & GO FLAG
TAPEPF:	0			;PRINT TAPE FLAG
DEVFLG:	0			;CMD LIST FROM DEVICE FLAG
DINFLG:	0			;DEVICE IN FLAG
LPTFLG:	0			;LINE PRINTER FLAG
LSTFLG:	0			;LISTING FLAG
DDIRFLG:0			;DISK DIRECTORY FLAG
DDIRF1:	0
MFDFLG:	0
ALTMFLG:0			;ALTMODE FLAG
CLKFLG:	0
USRFLG:	0
LDDMON:	0			;LOAD DIAG MON
CNSFLG:	0
SCFLAG:	0			;PROCESSING COMMENT FLAG
DEVTYP:	0			;DEVICE TYPE INDICATOR
DF22F:	0			;22BIT DF10 FLAG
SAVEP:	0			;PUSHDOWN POINTER SAVE
SAVEIP:	0			;COMMAND LIST POINTER SAVE
RUNCTL:	0			;RUN CONTROL
CHRCTR:	0			;PRINT CHAR COUNTER
SAVAC0:	0			;AC SAVE
SAVAC1:	0			; "
SAVAC2:	0			; "
FCRCNT:	0			;CR FILLER COUNT
FLFCNT:	0			;LF FILLER COUNT

CLBN:	0			;CURRENT LBN
CLUCNT:	0			;CURRENT CLUSTER COUNT
BLKCNT:	0			;BLOCK COUNT
STRUCT:	0			;STRUCTURE
SLUNIT:	0			;LOGICAL UNIT
TTYPE:	0			;TEMP TYPE
TUNIT:	0			;TEMP UNIT
CTYPE:	0			;CURRENT TYPE
CUNIT:	0			;CURRENT UNIT
ACSAV1:	BLOCK	17
SELSTR:				;COMMAND SELECTION STORE
LDCNT:	0			;A10 LOAD COUNT
LDADR:	0			;A10 LOAD ADDRESS
LDATA:	BLOCK ^D34-16		;A10 DATA STORAGE
ACSAVE:	BLOCK	16
LDATAE:	0			;A10 END OF DATA STORAGE
	0

LDNAME:	0
	0
	0
	0

LDBLK:	13
	SIXBIT/DSK/
	LDBUF

LDBUF:	BLOCK	3

DSKTAB:	BLOCK	DSKSIZ		;LOGICAL/PHYSICAL MAPPING

D$DIR:	BLOCK	8		;DIR NAME STRING STORAGE
D$FIL:	BLOCK	8		;FILE NAME      "
D$EXT:	BLOCK	8		;EXT		"
D$VER:	BLOCK	2		;VERSION	"
D$ISTR:	BLOCK	^D20		;INPUT		"

INLIST:	0
SUBTTL	SPECIAL STARTUP MESSAGES AND INITIALIZATION

;*HEADER

	DEFINE	PTITLE	(MCNVER,DECVER) <
	ASCIZ	%
* SMMON [DSQDC] - DECSYSTEM 2020 DIAGNOSTIC MONITOR - VER MCNVER'.'DECVER *
%   >

HEADER:	PTITLE	\MCNVER,\DECVER

;*HELP

HELP:	ASCIZ	%
NORMAL START = 20000
RESTART/ABORT = 20001
PRINT TEST TITLE = 20002
RESTART CURR TEST = 20003

COMMANDS;
STD=START DIAGNOSTIC
STM=REINITIALIZE START
STL=START LOADER
START=START DIAGNOSTIC
SFSTRT=SPECIAL FEATURE START
PFSTRT=POWER FAIL START
REE=REENTER
DDT=DDT
START1=SPECIAL START 1
START2=SPECIAL START 2
START3=SPECIAL START 3
START4=SPECIAL START 4
START5=SPECIAL START 5
SMMON=LOAD SMMON
SMMAG=LOAD SMMAG
SMAPT=LOAD SMAPT

R=RESELECT, X=XPN, I=INTERNAL, T=TTY, D=DEVICE,
S=SINGLE, F=DIR, L=LIST, G=GO

DEVICES;
UBA #
  0 = UBA 1, RH ADR 776700
  1 = UBA 1, RH ADR 776700
  2 = UBA 2, RH ADR 776700
  3 = UBA 3, RH ADR 776700
  # = UBA ADDRESS
?= IDENTIFY DISKS, DSK:?= MASTER DIRECTORY
%

	END	JRST	ONETIM
