;[TOED.XKL.COM]DXX:<KLAD.SOURCES>DFKCCT.MAC.4, 27-Mar-96 14:55:11, Edit by GORIN
;Fixed EDMOD macro.  Don't load data into bits 0-5 of MA (AC+3).

SUBTTL	MAINDEC-10-DFKCC

	MCNVER==0
	DECVER==2

	XLIST
DEFINE	NAME	(MCNVER,DECVER)<
	LALL

TITLE	DFKCC - DECSYSTEM10 KL10 ADVANCED INSTRUCTION DIAGNOSTIC #3, VER MCNVER,DECVER>
	LIST

	NAME	\MCNVER,\DECVER

;COPYRIGHT (C) 1979
;DIGITAL EQUIPMENT CORPORATION
;MARLBORO, MASS. 01754

;AUTHOR:	JOHN R. KIRCHOFF

;MAINTAINER:	LARGE SYSTEMS DIAGNOSTIC ENGINEERING

	LOC 137
MCNVER,,DECVER

	SEARCH	MONSYM
	SEARCH	MACSYM
	NOSYM

IF2,<PRINTX [STARTING PASS 2]>
SUBTTL	DIAGNOSTIC PARAMETERS

EXCASB==1			;ASSEMBLE FOR EXEC MODE OPERATION
USRASB==1			;ASSEMBLE FOR USER MODE OPERATION
DEBUG==100			;SAVE AN AREA FOR DEBUG (CALLED PATCH)
ITERAT==1			;USER MODE PROGRAM ITERATIONS
PGMEND==1			;THE ASSEMBLY PROGRAM END STATEMENT
KL10==1				;ASSEMBLE FOR KL10
KL10P0==1

SADR1=	BEGIN
SADR2=	BEGIN
SADR3=	BEGIN
SADR4=	SRTDDT
SADR5=	$BEND2
SADR6=	SRTDDT
SADR7=	HALT BEGIN
SADR8=	HALT BEGIN
SADR9=	HALT BEGIN
SADR10=	HALT BEGIN
SADR11=	HALT BEGIN
PAREA1=	0
PAREA2=	17
PAREA3=	SIXBIT /DFKCC/
PAREA4=	SIXBIT /PNT/
PAREA5=	0
PAREA6=	0

.JBINT=134			;TOPS-10 ERROR INTERCEPTING BLOCK

OPDEF	REPTLP	[SOJG REPT,]	;REPEAT LOOP
SUBTTL PROGRAM PARAMETERS

; **********************************************************************
;*ACCUMULATOR ASSIGNMENTS
; **********************************************************************

SLEN=	10
AC=	10
BDH=	10
PADDR=	10
SP=	11
BDL=	11
DLEN=	13
DBH=	13
MA=	13
DP=	14
DBL=	14

SLEN1=	2
SP1=	3
DLEN1=	5
DP1=	4
OP1=	1

AC0=	0
AC1=	1
AC2=	2
AC3=	3
AC4=	4
AC5=	5
AC6=	6
AC7=	7
AC10=	10
AC11=	11
AC12=	12
AC13=	13
AC14=	14
AC15=	15

; **********************************************************************
;*CASE TABLE COMMAND WORD BIT DEFINITIONS - LEFT HALF
; **********************************************************************

; **************************************************
;STRING LENGTH INDICATOR BITS
; **************************************************

EQLEN==	1B0			;STRINGS ARE OF EQUAL LENGTH
SZERO==	1B1			;SOURCE STRING IS ZERO IN LENGTH
DZERO==	1B2			;DESTINATION STRING IS ZERO IN LENGTH
DSZER==	1B3			;SOURCE AND DESTINATION STRING ARE ZERO LENGTH
SLONG==	1B4			;SOURCE STRING IS LONGER THAN DESTIN

; **************************************************
;PATTERN DEFINITION BITS
; **************************************************

ALTPT==	1B5			;PATTERN IS ALTERNATING 1'S AND 0'S
ONEPT==	1B6			;PATTERN IS ALL ONE'S
ONESPT== 1B7			;PATTERN IS EQUAL TO 0,,1

; **************************************************
;FILLER TYPE INDICATOR BITS
; **************************************************

EQFIL==	1B8			;FILLER IS EQUAL TO PATTERN
LFILL==	1B9			;FILLER IS SMALL
GFILL==	1B10			;FILLER IS LARGE

; **************************************************
;BYTE SIZE INDICATOR BITS
; **************************************************

S44==	1B11			;SOURCE BYTE SIZE IS FULL WORD (0= 5 BIT)
D44==	1B12			;DESTIN BYTE SIZE IS FULL WORD (0= 5 BIT)

; **************************************************
;FIRST AND LAST BYTE ADJUST INDICATOR BITS
; **************************************************

ALS==	1B13			;ADJUST LAST BYTE IN SOURCE STRING
ALD==	1B14			;ADJUST LAST BYTE IN DESTINATION STRING
AFS==	1B15			;ADJUST FIRST BYTE IN SOURCE STRING

B0==	1B16			;INDICATOR OF WHERE INTIAL BINARY DATA GOES
HW==	1B17			;INITIAL BINARY DATA TO HIGH OR LOW WORD

; **********************************************************************
;*CASE TABLE COMMAND WORD BIT DEFINITIONS - RIGHT HALF
; **********************************************************************

; **************************************************
;INITIAL FLAG BITS (FOR TRANSLATE INSTRUCTIONS)
; **************************************************

SFL==	1B0
MFL==	1B2
NFL==	1B3

; **************************************************
;TRANSLATION TABLE CONTROL BITS (FOR TRANSLATE INSTRUCTIONS)
;SPECIFIES FUNCTIONS FOR TWO HALFWORDS OF THE TRANSLATION TABLE
; **************************************************

C1==	1B4
C2==	1B5
C3==	1B6
C4==	1B7
C5==	1B8
C6==	1B9

; **************************************************
;DATA SELECTION TABLE INDEX BITS (CVTXXX INSTRUCTIONS)
; **************************************************

DATA0==	1B27
DATA1==	1B28
DATA2==	1B29
DATA==	1B27!1B28!1B29		

; **************************************************
;STRING LENGTH TABLE INDEX BITS (CVTXXX INSTRUCTIONS)
; **************************************************

STRL0==	1B30
STRL1==	1B31
STRL==	1B30!1B31

; **************************************************
;BYTE OFFSET TABLE INDEX  BITS (FOR MOVXX AND CVTXX INSTRUCTIONS)
; **************************************************

OFF0==	1B32
OFF1==	1B33
OFF==	1B32!1B33

; **********************************************************************
; CONT'D - CASE TABLE COMMAND WORD BIT DEFINITIONS - RIGHT HALF
; **********************************************************************

; **************************************************
;INITIAL PATTERN BYTE # DEFINITION BITS (USED IN EDIT INSTRUCTION)
; **************************************************

PB1==	1B34
PB2==	1B35
PB==	1B34!1B35

; **********************************************************************
;BIT DEFINITIONS USED TO SPECIFY FLAG & TRANSLATION TABLE CONTROL BITS
;IN CASE TABLES
; **********************************************************************

SFL1==	400000
MFL1==	200000
NFL1==	100000

C1A==	040000
C2A==	020000
C3A==	010000
C4A==	004000
C5A==	002000
C6A==	001000

; **********************************************************************
;DEFINITION OF THE NUMBER OF PLACES THAT THE INDEX TYPE BITS IN THE
;	CASE WORD MUST BE SHIFTED TO ISOLATE THEM IN THE RIGHT-MOST
;	PART OF THE WORD.FACILITATES EASY ALTERATION OF THE CASE TABLE
;	BIT DEFINITIONS FOR MAINTAINANCE PURPOSES.
; **********************************************************************

OFFSH==		-2
STRLSH==	-4
DATASH==	-6
PBSH==		0

; **********************************************************************
;*INSTRUCTION SKIP DECISION BITS (FOR CMPXX INSTRUCTIONS)
; **********************************************************************

GF==	1B33			;SET IF STR1 > STR2
EF==	1B34			;SET IF STR1 = STR2
LF==	1B35			;SET IF STR1 < STR2

; *******************************************************************
;*EDIT INSTRUCTION PATTERN CODE AND TRANSLATE TABLE DEFINITIONS
; *******************************************************************

STOP==		0
SELECT==	1
SIGST==		2
FLDSEP==	3
EXCHMD==	4
NOP==		5
MESSAG==	100
SKPM==		500
SKPN==		600
SKPA==		700
NOP1==		200
NOP2==		300
NOP3==		400
NOP4==		006

; **********************************************************************
;*EDMOD -- MACRO FOR EDIT INSTRUCTION TEST SUBMODULES
; **********************************************************************

DEFINE	EDMOD	(%TITL,%TIT1,TITLN,TABWD,FILWD,BYTNM)<			LALL

%TITL:	MOVEI	.
	MOVEM	TESTPC

	MOVEI	AC0,BYTNM		;INDEX TO BYTE TYPE TABLE
	MOVEM	BYTYPE		;STORE

	SETZM	OFFSET
	CAIN	AC0,1		;EXCHMD OPERATOR?
	SETOM	OFFSET		;YES

	HRLZ	AC7,EDTCAS-1	;AC7/- #CASES,,0
	HRRI	AC7,EDTCAS	;AC7/- #CASES,,CASE TABLE ADDRESS

%TIT1:	SETZM	SKPWD1		;CLEAR SKIP INDICATOR WORDS
	SETZM	SKPWD2

	GO	CLRSTR		;CLEAR STRING BYTES

	MOVE	AC2,FILWD	;TABLE FILLER BYTE TYPE
	MOVEM	AC2,PATTBL	;STORE THE FILLER IN THE BYTE TABLE
	MOVE	AC0,[PATTBL,,PATTBL+1]
	BLT	AC0,PATTBL+^D9

	GO	EDTSET		;SET UP INSTRUCTION PARAMETERS

	LDB	AC3,PATBN	;GET THE CURRENT PB#
	MOVE	AC1,TABWD(AC3)	;GET TABLE TEST WORD
	MOVEM	AC1,PATTBL	;STORE IT IN THE TABLE

	SKIPE	OFFSET		;EXCHMD BYTE OPERATOR?
	MOVE	MA,[0,,SOURCE]	;YES - place to store mark address

	MOVE	AC0,[PADDR,,ORIGSV] ;SAVE THE INITIAL AC BLOCK
	BLT	AC0,ORIGSV+4

; **************************************************
	GO	EDTSIM		;SIMULATE THE INSTRUCTION
	SETOM	SKPWD1
; **************************************************

	SKIPE	OFFSET		;EXCHMD OPERATOR?
	GO	CLRSTR		;YES - CLEAR STRING AREAS AGAIN

; **************************************************
	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION FOR REAL
	SETOM	SKPWD2
; **************************************************

	GO	EDTCOM		;COMPARE THE RESULTS
	ERROR	%TIT1,13,0,0,,,EDTPNT
									LALL
	AOBJN	AC7,%TIT1	;DO THE NEXT CASE

	SETZM	OFFSET
	JRST	TITLN		;FINISHED - GO TO NEXT SUBMODULE
									SALL>

; **********************************************************************
;*PFMAC -- MACRO WHICH SETS UP, EXECUTES, AND VERIFIES PAGE FAIL
; **********************************************************************

DEFINE PFMAC (INS,PFC,COR,CAS,PRE,TRAN)<				LALL

PRE'ST:	MOVEI	.
	MOVEM	TESTPC

	SETOM	OFFSET		;NO DESTIN STRING OFFSET IN SIMULATORS

	HRLZI	AC1,INS		;AC1/-# PRE INSTR,,0
	HRRI	AC1,PRE'TAB	;AC1/-# PRE INSTR,,OPCODE TABLE ADDR

	SETZM	E0
	SETZM	E0+1

PRE'PF0:	HRREI	AC2,PFC		;AC2/-# PAGE FAIL CASES

	MOVE	AC0,(AC1)	;EXTRA CASE FOR MOVSRJ
	CAIN	AC0,017
	SUBI	AC2,1

	CAIE	AC0,004		;EDIT INSTRUCTION?
	JRST	PRE'PFA

	MOVE	AC0,SELWD	;YES - SET UP THE PATTERN TABLE
	MOVEM	AC0,PATTBL
	MOVE	AC0,[PATTBL,,PATTBL+1]
	BLT	AC0,PATTBL+^D8

	MOVE	AC0,STOPWD
	MOVEM	AC0,PATTBL+^D9

PRE'PFA:	MOVEI	AC3,CAS	;INITIAL AC BLOCK TABLE
	MOVEI	AC4,COR	;ADDR OF INTERMEDIATE RESULT TABLE

	SETZM	SKPWD1		;CLEAR SKIP INDICATOR WORDS
	SETZM	SKPWD2

; **************************************************
;SET UP THE SOURCE AND DESTINATION STRINGS
; **************************************************

	GO	CLRSTR

	SETZM	75750		;CLEAR THE FAIL STRING AREA
	MOVE	AC0,[75750,,75751]
	BLT	AC0,76100

PRE'PF1:	GO	PFACB		;SET UP THE INITIAL AC BLOCK

	MOVE	AC0,(AC1)	;RETRIEVE INSTRUCTION OPCODE
	MOVEM	AC0,INSTR#	;SAVE FOR ERROR PRINTING

	GO	CHKTRN		;SET TRANFG IF TRANLATE INSTRUCTION

	SKIPE	FILLF		;FILLER FAILURE CASE?
	DPB	AC0,[POINT 9,400777,8] ;YES

	SKIPN	FILLF
	DPB	AC0,E0OP	;NO

	SKIPN	TRANFG		;IS IT A TRANSLATE TYPE INSTRUCTION?
	JRST	PRE'PC		;NO

	MOVEI	AC0,E1		;ADDRESS OF TRANSLATION TABLE
	SKIPE	FILLF		;FILLER FAILURE CASE?
	HRRM	AC0,400777	;YES
	HRRM	AC0,E0		;NO

	MOVE	AC0,[1,,1]
	GO	TRAN		;SETUP THE TRANSLATION TABLE
	OR	AC,BIT0		;SET THE SIGNIFICANCE FLAG

PRE'PC:	MOVE	AC0,[AC,,ORIGSV] ;SAVE THE AC BLOCKS
	BLT	AC0,ORIGSV+4

	SKIPE	FILLF		;FILLER FAILURE CASE?
	MOVE	AC0,[0,,PRE'PC2] ;YES
	SKIPN	FILLF
	MOVE	AC0,[0,,PRE'PC1] ;NO
	MOVEM	FAILOC#		;STORE IT

	SETOM	PFTRAP#		;INDICATE THAT TRAP IS EXPECTED
	SETZM	PFERR#		;CLEAR PAGE FAIL ERROR FLAG

	MOVEI	PRE'PFX
	MOVEM	PFHEPC		;SETUP PAGE FAILURE INTERMEDIATE ERROR NEW PC

	GO	PAGSET		;CLEAR AND SETUP THE PAGE MAP

	SKIPE	FILLF		;FILLER FAILURE CASE?
	JRST	PRE'PC2		;YES

; **************************************************
PRE'PC1:	EXTEND	AC,E0		;EXECUTE THE INSTRUCTION FOR REAL
	SETOM	SKPWD2		;NOTE SKIP RETURN
; **************************************************

	JRST	PRE'PF3

; **************************************************
PRE'PC2:	EXTEND AC,400777 	;MAKE E0+1 FAIL
	SETOM	SKPWD2		;NOTE SKIP RETURN
; **************************************************

; **************************************************
;WHEN THE INSTRUCTION PAGE FAILS, THE PAGE FAILURE ROUTINE
;SETS UP THE PAGING SO THE INSTRUCTION CAN CONTINUE.
;THEN IT COMPLETES THE INSTRUCTION AND RETURNS AFTER THE
;INSTRUCTION AND TO HERE.
; **************************************************

PRE'PF3:	SKIPL	PFTRAP		;DID THE PAGE FAIL OCCUR?
	JRST	DO'PRE		;YES - OK

	ERROR	PRE'PF0,13,0,0,^EXTEND INST DID NOT PAGE FAIL,,PNTINS
									LALL
	JRST	PRE'NXT		;GO DO THE NEXT CASE

PRE'PFX:	SKIPN	PFTRAP		;PAGE FAIL ONCE ONLY ?
	JRST	PRE'PF9	;YES, CHECK INTERMEDIATE RESULTS

	ERROR1	13,0,0,^EXTEND INST PAGE FAILED MORE THAN ONCE,,PFPNT
	ERLP2	PRE'PF0
									LALL
	JRST	PRE'NXT

PRE'PF9:	ERROR1	13,0,0,^INTERMEDIATE PAGE FAIL RESULTS ERROR,,PFPNT
	ERLP2	PRE'PF0
									LALL
	JRST	PRE'NXT

; **************************************************
DO'PRE:	GO	PRE'SIM		;SIMULATE THE INSTRUCTION
	SETOM	SKPWD1		;NOTE A SKIP RETURN
; **************************************************

	GO	COMAC		;COMPARE THE FINAL RESULTS
	ERROR	PRE'PF0,13,0,0,^FINAL AC'S INCORRECT,,COMPNT
									LALL
PRE'NXT:	MOVEI	AC0,5		;UPDATE THE CASE AND RESULT BLOCK POINTERS
	ADDM	AC0,AC4
	ADDI	AC0,1
	ADDM	AC0,AC3

	AOJL	AC2,PRE'PF1	;DO THE NEXT PF CASE

	AOBJN	AC1,PRE'PF0	;DO THE NEXT INSTRUCTION
	SETZM	OFFSET
									SALL>
;END OF FILE
