SUBTTL	GLXCOM  --  Common module for Sub-Systems Components

;	Entry points found in GLXCOM

ENTRY	.INIT	;Initialize the common module
ENTRY	.ZPAGA	;Zero a page given its address in S1
ENTRY	.ZPAGN	;Zero a page given its page number in S1
ENTRY	.ZCHNK	;Zero an arbitrary area of memory

ENTRY	.SAVE1	;Co-routine to save P1
ENTRY	.SAVE2	;Co-routine to save P1,P2
ENTRY	.SAVE3	;Co-routine to save P1,P2,P3
ENTRY	.SAVE4	;Co-routine to save P1,P2,P3,P4
ENTRY	.SAVET	;Co-routine to save T1,T2,T3,T4
ENTRY	.SV13	;Co-routine to save 13 (use SAVE Macro)
ENTRY	.SV14	;Co-routine to save 14 (use SAVE Macro)
ENTRY	.SV15	;Co-routine to save 15 (use SAVE Macro)
ENTRY	.SV16	;Co-routine to save 16 (use SAVE Macro)

ENTRY	.RETT	;Set TF= TRUE and return
ENTRY	.RETF	;Set TF= FALSE and return
ENTRY	.RETE	;Set TF= FALSE, set S1=GLXLIB error code and return

ENTRY	.AOS, .SOS , .ZERO ;Support for INCR, DECR AND ZERO

ENTRY	.POPJ

ENTRY	.STOP	;GLXLIB Central STOP CODE processor
SUBTTL Table of contents

;               TABLE OF CONTENTS FOR GLXCOM
;
;
;                        SECTION                                   PAGE
;    1. Table of contents.........................................   2
;    2. Revision History..........................................   3
;    3. Global Storage............................................   4
;    4. .INIT  - Initialize the common code.......................   5
;    5. .ZPAGA - .ZPAGN - .ZCHNK  --  Zero out memory.............   6
;    6. .SAVEx Routines -- Save permanent ACS.....................   7
;    7. .SAVET -- Routine to save the temporary ACS...............   8
;    8. .SVxx  --  Routines for saving random ACS.................   9
;    9. .POPJ, .RETE,.RETT & .RETF -- Common return routines......  10
;   10. .AOS, .SOS and .ZERO - Support for INCR,DECR, ZERO........  11
;   11. STOP CODE Processor.......................................  12
SUBTTL Revision History

COMMENT \

Edit	SPR/QAR		Explanation
----	-------		-----------------------------------------------
0001			First model
0002			Create from SBSCOM
0003			Convert to new OTS format
0004			TOTALLY HACKED UP FOR DIAGNOSTICS


End of Revision History
\
SUBTTL Global Storage


; GLOBAL CRASH INFORMATION

	$$GDATA	.SPC			;PC OF STOP
	$$GDATA	.SCODE			;SIXBIT CODE OF STOP CODE
	$$GDATA	.SERR			;LAST OPERATING SYSTEM ERROR (TOPS-20)
	$$GDATA	.SACS,20		;ACS AT TIME OF STOP 
	$$GDATA	.SPTBL			;BASE OF PAGE TABLE
	$$GDATA	.SPRGM			;NAME OF PROGRAM
	$$GDATA	.SPVER			;VERSION OF PROGRAM
	$$GDATA	.SPLIB			;VERSION OF THE OTS

	$$GDATA	.LGERR			;LAST GALAXY ERROR PROCESSED VIA .RETE
	$$GDATA	.LGEPC			;PC (USUALLY) OF LAST $RETE
SUBTTL .INIT  - Initialize the common code

;This code is set up for the stop code processor.
;	Information is copied to the crash block from parameters
;	not known at load time.

;CALL IS:	S1/ Length of the IB (Initialization Block)
;		S2/ Address of the IB

.INIT:	MOVE	S1,IB.PRG(S2)		;GET PROGRAM NAME
	MOVEM	S1,.SPRGM		;STORE FOR LATER
	MOVE	S1,IB.VER(S2)		;GET PROGRAM VERSION
	MOVEM	S1,.SPVER		;SAVE IT
;	MOVEI	S1,PAGTBL##		;GET ADDRESS OF PAGE TABLE
;	MOVEM	S1,.SPTBL		;STORE FOR LATER
	MOVX	S1,GLXVRS		;GET LIBRARY VERSION NUMBER
	MOVEM	S1,.SPLIB		;SAVE IT AWAY
	MOVX	S1,%%.GLX		;GET GLXLIB MAJOR CHANGE NUMBER
	CAME	S1,IB.PID(S2)		;DO WE MATCH CALLING PROGRAM?
	$STOP(WVG,Wrong version of GLXLIB) ;APPARENTLY NOT
	$RETT				;RETURN
SUBTTL	.ZPAGA - .ZPAGN - .ZCHNK  --  Zero out memory

;ROUTINES TO COMPLETELY ZERO A PAGE OF MEMORY.  .ZPAGA IS
;	CALLED WITH THE ADDRESS OF THE FIRST WORD OF THE PAGE
;	IN S1 AND .ZPAGN IS CALLED WITH THE PAGE NUMBER IN S1.
;	.ZCHNK IS USED TO ZERO A CHUNK OF MEMORY
;	  SIZE IN S1 AND LOCATION S2
;	ALL ACS ARE PRESERVED

.ZPAGN:	PUSH	P,S1			;SAVE PAGE NUMBER
	PG2ADR	S1			;CONVERT PAGE NUMBER TO ADR
	SKIPA				;DON'T SAVE S1 TWICE

.ZPAGA:	PUSH	P,S1			;SAVE S1
	PUSH	P,S2			;AND S2
	MOVE	S2,S1			;GET ADDRESS INTO S2
	MOVX	S1,PAGSIZ		;AND ONE PAGE SIZE INTO S1
	PJRST	ZCHN.1			;JOIN COMMON CODE

.ZCHNK:	PUSH	P,S1			;SAVE CALLER'S SIZE
	PUSH	P,S2			;AND ADDRESS
ZCHN.1:	ADDI	S1,0(S2)		;COMPUTE END ADDRESS
	ZERO	0(S2)			;CLEAR FIRST WORD
	HRLS	S2			;GET ADDR,,ADDR OF CHUNK
	AOS	S2			;AND NOW ADDR,,ADDR+1
	BLT	S2,-1(S1)		;NOW CLEAR THE CHUNK
	POP	P,S2			;RESTORE CALLER'S CHUNK ADDR
	POP	P,S1			;AND HIS SIZE
	$RETT				;AND RETURN
SUBTTL .SAVEx Routines -- Save permanent ACS

;THESE ROUTINES ACT AS CO-ROUTINES WITH THE ROUTINES WHICH CALL THEM,
;	THEREFORE NO CORRESPONDING "RESTORE" ROUTINES ARE NEEDED. WHEN
;	THE CALLING ROUTINE RETURNS TO ITS CALLER, IT ACTUALLY RETURNS
;	VIA THE RESTORE ROUTINES AUTOMATICALLY.

.SAVE1:	EXCH	P1,(P)		;SAVE P1 GET CALLERS ADDRESS
	PUSH	P,.+3		;SAVE RETURN ADDRESS FOR CALLER
	HRLI	P1,-1(P)	;MAKE IT LOOK LIKE RESULT OF JSA
	JRA	P1,(P1)		;CALL THE CALLER
	  CAIA	.		;NON-SKIP RETURN
	AOS	-1(P)		;SKIP RETURN
	JRST	RES1		;RESTORE P1

.SAVE2:	EXCH	P1,(P)		;SAVE P1 GET CALLERS ADDRESS
	PUSH	P,P2		;SAVE P2
	PUSH	P,.+3		;SAVE RETURN ADDRESS
	HRLI	P1,-2(P)	;SETUP FOR THE JRA
	JRA	P1,(P1)		;CALL THE CALLER
	  CAIA	.		;NON-SKIP RETURN
	AOS	-2(P)		;SKIP RETURN
	JRST	RES2		;RESTORE P2,P1

.SAVE3:	EXCH	P1,(P)		;SAVE P1 GET RETURN ADDRESS
	PUSH	P,P2		;SAVE P2
	PUSH	P,P3		;SAVE P3
	PUSH	P,.+3		;SAVE RETURN ADDRESS
	HRLI	P1,-3(P)	;SETUP FOR JRA
	JRA	P1,(P1)		;AND CALL THE CALLER
	  CAIA	.		;NON-SKIP
	AOS	-3(P)		;SKIP RETURN
	JRST	RES3		;AND RESTORE P3,P2,P1

.SAVE4:	EXCH	P1,(P)		;SAVE P1 GET RETURN ADDRESS
	PUSH	P,P2		;SAVE P2
	PUSH	P,P3		;SAVE P3
	PUSH	P,P4		;SAVE P4
	PUSH	P,.+3		;SAVE RETURN ADDRESS
	HRLI	P1,-4(P)	;SETUP FOR RETURN
	JRA	P1,(P1)		;AND RETURN
	  CAIA	.		;NON-SKIP RETURN
	AOS	-4(P)		;SKIP RETURN
RES4:	POP	P,P4		;RESTORE P4
RES3:	POP	P,P3		;RESTORE P3
RES2:	POP	P,P2		;RESTORE P2
RES1:	POP	P,P1		;RESTORE P1
	POPJ	P,		;AND RETURN
SUBTTL .SAVET -- Routine to save the temporary ACS

.SAVET:	EXCH	T1,(P)		;SAVE T1 AND GET RETURN ADDRESS
	PUSH	P,T2		;SAVE T2
	PUSH	P,T3		;SAVE T3
	PUSH	P,T4		;SAVE T4
	PUSH	P,.+3		;SAVE RETURN ADDRESS
	HRLI	T1,-4(P)	;SETUP FOR JRA
	JRA	T1,(T1)		;AND CALL THE CALLER
	  CAIA	.		;RETURN HERE ON NON-SKIP
	AOS	-4(P)		;RETURN HERE ON SKIP
	POP	P,T4		;RESTORE T4
	POP	P,T3		;RESTORE T3
	POP	P,T2		;RESTORE T2
	POP	P,T1		;RESTORE T1
	POPJ	P,		;RETURN
SUBTTL .SVxx  --  Routines for saving random ACS


; THESE ROUTINES ARE CALLED BY THE SAVE MACRO FOR ABSOLUTE AC'S
;	13,14,15, & 16. THE MACRO FIGURES OUT WHICH ONE

.SV13:	EXCH	13,(P)		;SAVE 13 GET CALLERS ADDRESS
	PUSH	P,.+3		;SAVE RETURN ADDRESS FOR CALLER
	HRLI	13,-1(P)	;MAKE IT LOOK LIKE RESULT OF JSA
	JRA	13,(13)		;CALL THE CALLER
	  CAIA	.		;NON-SKIP RETURN
	AOS	-1(P)		;SKIP RETURN
	POP	P,13		;RESTORE 13
	POPJ	P,		;AND RETURN

.SV14:	EXCH	14,(P)		;SAVE 14 GET CALLERS ADDRESS
	PUSH	P,.+3		;SAVE RETURN ADDRESS FOR CALLER
	HRLI	14,-1(P)	;MAKE IT LOOK LIKE RESULT OF JSA
	JRA	14,(14)		;CALL THE CALLER
	  CAIA	.		;NON-SKIP RETURN
	AOS	-1(P)		;SKIP RETURN
	POP	P,14		;RESTORE 14
	POPJ	P,		;AND RETURN

.SV15:	EXCH	15,(P)		;SAVE 15 GET CALLERS ADDRESS
	PUSH	P,.+3		;SAVE RETURN ADDRESS FOR CALLER
	HRLI	15,-1(P)	;MAKE IT LOOK LIKE RESULT OF JSA
	JRA	15,(15)		;CALL THE CALLER
	  CAIA	.		;NON-SKIP RETURN
	AOS	-1(P)		;SKIP RETURN
	POP	P,15		;RESTORE 15
	POPJ	P,		;AND RETURN

.SV16:	EXCH	16,(P)		;SAVE 16 GET CALLERS ADDRESS
	PUSH	P,.+3		;SAVE RETURN ADDRESS FOR CALLER
	HRLI	16,-1(P)	;MAKE IT LOOK LIKE RESULT OF JSA
	JRA	16,(16)		;CALL THE CALLER
	  CAIA	.		;NON-SKIP RETURN
	AOS	-1(P)		;SKIP RETURN
	POP	P,16		;RESTORE 16
	POPJ	P,		;AND RETURN
SUBTTL .POPJ, .RETE,.RETT & .RETF -- Common return routines


; $RETE calls .RETE to set up the last GALAXY error and location
; then set TF = FALSE and return.

.RETE:	HRRZM	TF,.LGEPC	;CALLED VIA JSP TF, SO SET UP PC OF LAST ERROR
	HRRZ	S1,@.LGEPC	;NOW FETCH ERROR CODE
	MOVEM	S1,.LGERR	;AND REMEMBER IT
				;FALL INTO .RETF

; .RETT AND .RETF are called via the $RETT and $RETF macros and can also
; be called directly.  They both set the value of TF, one to TRUE and the other
; to FALSE.  After doing this, they return via a POPJ P,

;The .POPJ  routine can be jumped
; to get a return, without changing the value in the TF register

.RETF:	TDZA	TF,TF		;CLEAR VALUE MEANS FALSE
.RETT:	SETO	TF,		;ALL ONES MEANS TRUE
.POPJ:	POPJ	P,		;RETURN
SUBTTL .AOS, .SOS and .ZERO - Support for INCR,DECR, ZERO

; These routines are never used directly, but are available for the
; INCR, DECR and ZERO macros to use when the field is neither a fullword
; or either half word.

.AOS:	PUSH	P,TF			;SAVE REGISTER WE WILL USE
	HRRZ	TF,-1(P)		;GET LOCATION OF JUMP [POINTR()]
	PUSH	P,@TF			;STORE IN ON THE STACK
	LDB	TF,@0(P)		;GET THE BYTE TO BE INCREASED
	AOJA	TF,ZERO.1		;INCREASE IT AND RETURN

.SOS:	PUSH	P,TF			;SAVE TF
	HRRZ	TF,-1(P)		;PICK UP LOCATION OF CALL
	PUSH	P,@TF			;SAVE ADDR OF POINTER ON STACK
	LDB	TF,@0(P)		;GET THE BYTE
	SOJA	TF,ZERO.1		;DECREASE BY ONE AND RETURN


.ZERO:	PUSH	P,TF			;SAVE TF
	HRRZ	TF,-1(P)		;GET ADDR OF CALL
	PUSH	P,@TF			;SAVE ADDR OF POINTER ON THE STACK
	SETZ	TF,			;GET A ZERO BYTE
ZERO.1:	DPB	TF,@0(P)		;STORE IT BACK
	POP	P,TF			;CLEAR POINTER OF STACK
	POP	P,TF			;RESTORE TF
	POPJ	P,			;THEN RETURN
SUBTTL STOP CODE Processor

; This routine handles the call caused by the 	$STOP Macro

.STOP:	MOVEM	0,.SACS			;STORE FIRST AC
	MOVE	0,[XWD 1,.SACS+1]	;SET FOR THE REST
	BLT	0,.SACS+17		;STORE THEM ALL
	MOVE	T1,0(P)			;GET LOCATION CALLED FROM
	MOVE	T2,@0(T1)		;THEN GET POINTER WORD TO CODE
	HLLZM	T2,.SCODE		;STORE SIXBIT CODE
	MOVEI	T3,@0(T1)		;GET LOCATION THAT XWD FETCHED FROM
	ADDI	T3,1			;THEN INCREMENT TO MODULE NAME
	MOVEI	T1,-1(T1)		;GET ACTUAL LOCATION OF 'PUSHJ P,.STOP'
	MOVEM	T1,.SPC			;REMEMBER IT

	OPDEF	PNTALF	[37B8!17B12!1]
	OPDEF	PNTSXF	[37B8!1B12!2]
	OPDEF	PNT6F	[37B8!6B12!1]
	OPDEF	PCRLF	[37B8!1B12!CRLF]
	OPDEF	PNTCIF	[37B8!1B12!0]

	MOVEI	[ASCIZ/
?STOP CODE - /]
	PNTALF
	HLRZ	0,T2
	PNTSXF
	MOVEI	[ASCIZ/
  REASON: /]
	PNTALF
	HRRZ	0,T2
	PNTALF
	MOVEI	[ASCIZ/
  ERROR PC = /]
	PNTALF
	MOVE	.SPC
	PNT6F
	PCRLF
	EXIT
CRLF:	ASCIZ/
/
	
	REPEAT	0,<
	SETOM	TXTLVL##		;MAKE SURE TEXT WON'T STOP US
	$TEXT(T%TTY,<?Stop code - ^W/T2,LHMASK/ - in module ^W/0(T3)/ on ^H9/[-1]/ at ^C/[-1]/>)
	$TEXT(T%TTY,<  Reason: ^T/0(T2)/>)
	$TEXT(T%TTY,<  Program is ^W/.SPRGM/ Version ^V/.SPVER/ using GLXLIB Version ^V/.SPLIB/>)
	$TEXT(T%TTY,<  Last  GLXLIB error: ^O/.LGERR,RHMASK/ (^E/.LGERR/)>)
IFN FTJSYS,<
	MOVX	S1,.FHSLF		;FOR SELF,
	GETER				;LOOK UP MOST RECENT ERROR
	 ERJMP	.+1			;IGNORE ANY ERRORS
	MOVEM	S2,.SERR		;SAVE THE ERROR
	$TEXT(T%TTY,<  Last TOPS-20 error: ^O/.SERR,RHMASK/ (^A>)
	MOVX	S1,.PRIOU		;TO PRIMARY OUTPUT
	HRLI	S2,.FHSLF		;SET FOR SELF
	SETZ	T1,			;INFINITE BYTES
	ERSTR				;PRINT ERROR STRING
	  JFCL				;
	  JFCL				;TWO POSSIBLE ERROR RETURNS
	$TEXT(T%TTY,<) >)
>
	HRRZ	P1,DDTADR		;GET DDT'S ADDRESS
	JUMPE	P1,STOP.1		;IF NOT THERE, TYPE OUT ACS AND EXIT
	PUSH	P,P1			;SAVE IT ON THE STACK
	$TEXT(T%TTY,<^M^J  Entering DDT	(Crash block starts at loc ^O/[.SPC]/)>)
	MOVSI	16,.SACS		;RESTORE THE ACS
	BLT	16,16			;TO THE USER
	POPJ	P,			;GO ENTER DDT

STOP.1:	$TEXT(T%TTY,<^M^JContents of the ACs  (Crash block starts at location ^O/[.SPC]/)^M^J>)
	MOVEI	S1,0			;START WITH AC 0
STOP.2:$TEXT(T%TTY,< ^O2/S1//^O15/.SACS(S1)/^O15/.SACS+1(S1)/^O15/.SACS+2(S1)/^O15/.SACS+3(S1)/>)
	ADDI	S1,4			;STEP TO NEXT FOUR
	CAIE	S1,20			;LOOP FOR ALL ACS
	JRST	STOP.2			;
	$TEXT(T%TTY,<^M^JLast 9 Stack Locations:^M^J>)
	$TEXT(T%TTY,< -1(P)/^O15/-1(P)/   -2(P)/^O15/-2(P)/   -3(P)/^O15/-3(P)/>)
	$TEXT(T%TTY,< -4(P)/^O15/-4(P)/   -5(P)/^O15/-5(P)/   -6(P)/^O15/-6(P)/>)
	$TEXT(T%TTY,< -7(P)/^O15/-7(P)/   -8(P)/^O15/-8(P)/   -9(P)/^O15/-9(P)/>)
	PJRST	I%EXIT			;EXIT FROM THE PROGRAM
>
COM%L:
	END
