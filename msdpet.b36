%TITLE 'STIRS TESTS FOR M8620 (DPE) BOARD'

MODULE MSDPET	(
		LANGUAGE(BLISS36)
		) =

BEGIN

!
!			  COPYRIGHT (C) 1979 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.  
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
!
! ABSTRACT:
!
!	THIS MODULE CONTAIN THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
!	(STIRS) DIAGNOSTIC FOR THE M8620 (DPE) BOARD.  IT ALSO CONTAINS SEVERAL
!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
!	'MSDPED' MODULES TO PRODUCE THE 'MSDPE.EXE' FILE.
!
! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
!
! AUTHOR: JEAN BASMAJI	, CREATION DATE: 23-MAY-79
!
! MODIFIED BY:
!
!	JEAN BASMAJI, 23-MAY-79; VERSION 0.1
!--


!  PROGRAM DESCRIPTION:
!
!
!		MSDPE PROGRAM IS DESIGNED TO DETECT AND ISOLATE ANY
!	FAULTS ON THE KS10'S M8620 BOARD (DPE).THIS PROGRAM IS LINKED
!	WITH 'MSSTRC' CONTROL MODULE.  IT WILL RUN UNDER 'CSL'
!	PROGRAM WHICH IN TURN IS RUNNING ON A TOPS20 HOST MACHINE.
!	THIS PROGRAM ASSUMES THAT ALL PARTS OF THE KS10 ARE KNOWN 
!	GOOD PARTS EXCEPT THE 'DPE' BOARD UNDER TEST.(FOR DETAILS 
!	SEE DOCUMENTATION ON MSSTRC MODULE).
!		 EACH TEST IN THIS PROGRAM WILL LOAD ITS OWN MICRO
!	INSTRUCTIONS DESIGNED TO DETECT ANY ERROR IN THE LOGIC INVOLVED.
!		THE MAJOR PARTS OF THIS PROGRAM WILL TEST ALL 10
!	SLICES OF THE 2901'S INCLUDING THE SHIFT LOGIC, PI SYSTEM, P.C.
!	FLAGS, RAMFILE (INCLUDING RAMFILE PARITY AND RAMFILE ADRS) AND
!	DROM LOGIC.
!		THE FAULT ISOLATION ANALYSIS DONE IN MSSTRC MODULE WILL
!	INHIBIT RUNNING SOME TESTS, ALSO THIS MODULE WILL INHIBIT 
!	RUNNING OTHER TESTS BY MANIPULATING ITS OWN FLAGS AS FOLLOWS:
!	A)  SWITCH SETTING FLAGS:
!		THIS MODULE WILL ASK FOR 2 SWITCH SETTINGS WHICH CONTROL
!		DROM CONTENTS, RAMFILE AND RAMFILE PARITY TESTS.
!		THOSE TESTS ARE INHIBITED AS A DEFAULT. THEY WILL BE RUN
!		IF SPECIFIED TO DO SO DURING SWITCH SETTING.
!		THOSE TESTS ARE INHIBITED BECAUSE THEY ARE TIME 
!		CONSUMING. DROM CONTENTS (8 TESTS) APPRX. 10 MIN, AND
!		THE RAMFILE TESTS (2 TESTS) APPRX. 15 MIN.
!	B)  OTHER TEST FLAGS:
!		THOSE FLAGS (DECLARED IN THIS MODULE AS OWN) WILL DIRECT
!		THE ERROR ANALYSIS AS WELL AS SKIPPING SOME TESTS.
!		EXAMPLE:
!			IF RAMFILE ADRS OUTPUT PINS TESTS FAIL, 'ADRSFLG'
!		FLAG IS SET TO INHIBIT RUNNING ALL SUBSEQUENT 
!		RAMFILE ADRS TESTS SINCE OTHER FAILING RAMFLE ADRS TESTS 
!		WILL NOT HELP US ANY MORE IN ISOLATING THE FAULT.
!			'PIACTV_FLG' FLAG IS SET IN CERTAIN TESTS 
!		IF AN ERROR OCCURS AND CHECKED LATER DURING THIS PROGRAM,
!		IF CLEAR THE PROGRAM WILL CALL A 'NO ERROR' ROUTINE
!		TO ELIMINATE THE PI ACTIVE LOGIC NETWORK FROM THE
!		CUMULATIVE FAULTY NETWORK BITVECTOR.
!
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	SPEC_DIALOGUE : NOVALUE,		!SPECIAL USER I/O (NOT USED)
	SPEC_ASK : NOVALUE,			!ASK FOR SPECIAL QUESTIONS
	SPEC_PRT,				!PRINT THE SPECIAL SPECS (SWITCHES)
	TEST_INIT : NOVALUE,			!INITIAL TESTING INITIALIZATION
	FUNC_LD : NOVALUE,			!LOADS THE CRAM WITH INSTRUCTIONS TO BE EXECUTED BY ALU FUNC TESTS
	VMA_LD : NOVALUE,			!CHECKS AND LOADES THE VMA WITH A 0
	TST1 : NOVALUE,				!DIAGNOSTIC ADDRESS DISPATCH
	TST2 : NOVALUE,				!OUTPUT ZERO FROM 2901'S
	TST3 : NOVALUE,				!LOAD THA VMA WITH A ZERO AND MEM WRITE
	TST4 : NOVALUE,				!ALU DEST 0,1,2 & 3
	TST5 : NOVALUE,				!WRITE ONES AND ZEROS TO ALU REGISTERS (36 BITS)
	TST6 : NOVALUE,				!CHECK THE B PORT IN THE 2901'S (36 BITS)
	TST7 : NOVALUE,				!CHECK Q REGISTER IN 2901'S (36 BITS)
	TST8 : NOVALUE,				!ALU RAM SHIFTER (36 BITS)
	TST9 : NOVALUE,				!CHECK THE 2 LSB OF THE ALU AND THE ALU REGISTERS
	TST10 : NOVALUE,			!CHECK THE 2 MSB OF THE ALU AND THE ALU REGISTERS
	TST11 : NOVALUE,			!Q SHIFTER (36 BITS)
	TST12 : NOVALUE,			!2 LSB OF THE Q REGISTER
	TST13 : NOVALUE,			!2 MSB OF THE Q REGISTER
	TST14 : NOVALUE,			!CHECK THE ALU (R OR S) FUNCTION
	TST15 : NOVALUE,			!CHECK THE ALU (R + S) FUNCTION
	TST16 : NOVALUE,			!CHECK THE ALU (S - R) FUNCTION
	TST17 : NOVALUE,			!CHECK THE ALU (R - S) FUNCTION
	TST18 : NOVALUE,			!CHECK THE ALU (R AND S) FUNCTION
	TST19 : NOVALUE,			!CHECK THE ALU (RNOT AND S) FUNCTION
	TST20 : NOVALUE,			!CHECK THE ALU (R XOR S) FUNCTION
	TST21 : NOVALUE,			!CHECK THE ALU (R XNOR S) FUNCTION
	TST22 : NOVALUE,			!CHECKS DP CRY1
	TST23 : NOVALUE,			!SKIP ON THE OUTPUT OF THE 2901'S
	TST24 : NOVALUE,			!DP CLKS
	TST25 : NOVALUE,			!LEFT SHIFT LOGIC ON DPE1
	TST26 : NOVALUE,			!RIGHT SHIFT LOGIC ON DPE1
	TST27 : NOVALUE,			!INHIBIT CRY INTO LEFT HALF
	TST28 : NOVALUE,			!SKIP ON ADL=0 & ADR=0
	TST29 : NOVALUE,			!CHECK ALL THE BYTE DISPATCH LOGIC
	TST30 : NOVALUE,			!DBUS SELECT 0 GROUNDED PINS
	TST31 : NOVALUE,			!DBUS SELECT 1
	TST32 : NOVALUE,			!10 BIT VMA COPY
	TST33 : NOVALUE,			!PART OF THE DISP MIX'S
	TST34 : NOVALUE,			!CHECK THE PI REQ LEVEL
	TST35 : NOVALUE,			!PI PRIORITY ENCODER, PI SOFT REQ.
	TST36 : NOVALUE,			!PI ACTIVE AND PI REQ
	TST37 : NOVALUE,			!PI ACTV AND 4 BIT TRNCVR LATCH ON DPEB
	TST38 : NOVALUE,			!PI COMPARE THEN INTERRUPT
	TST39 : NOVALUE,			!P.C. FLAGS
	TST40 : NOVALUE,			!JFCL LOGIC ON DPE9
	TST41 : NOVALUE,			!FPD,TRAP2 AND CRY FLAGS
	TST42 : NOVALUE,			!OV,TRAP1,FOV AND NO DIV FLAGS
	TST43 : NOVALUE,			!FXU,OV AND TRAP1 FLAGS
	TST44 : NOVALUE,			!OV AND TRAP1 FLAGS
	TST45 : NOVALUE,			!USER I/O FLAG
	TST46 : NOVALUE,			!TRAP DECODER ON DPE9
	TST47 : NOVALUE,			!INSTRUCTION REGISTER FF
	TST48 : NOVALUE,			!FPD,USER AND USER I/O FLAGS
	TST49 : NOVALUE,			!DBUS PARITY IMPLEMENTATION LOGIC
	TST50 : NOVALUE,			!DP PARITY IMPLEMENT RAM
	TST51 : NOVALUE,			!RAMFILE
	TST52 : NOVALUE,			!RAMFILE PARITY CHIPS
	TST53 : NOVALUE,			!RAMFILE ADRS OUTPUT PINS S1
	TST54 : NOVALUE,			!RAMFILE ADRS OUTPUT PINS S0
	TST55 : NOVALUE,			!RAMFILE ADRS SELECT 0
	TST56 : NOVALUE,			!RAMFILE ADRS SELECT 2
	TST57 : NOVALUE,			!RAMFILE ADRS SELECT 4
	TST58 : NOVALUE,			!RAMFILE ADRS SELECT 7 (VMA AC REF HI)
	TST59 : NOVALUE,			!RAMFILE ADRS SELECT 7 (VMA AC REF LO)
	TST60 : NOVALUE,			!RAMFILE ADRS SELECT 1
	TST61 : NOVALUE,			!SWEP CASH TO LOAD THE VMA
	TST62 : NOVALUE,			!RAMFILE WRITE ENABLE
	TST63 : NOVALUE,			!DROM ADDRESS INPUT PINS ZEROS
	TST64 : NOVALUE,			!DROM ADDRESS INPUT PINS ONES
	TST65 : NOVALUE,			!OUTPUT PINS OF DROM (A,B,J,AC DISP AND A=J)
	TST66 : NOVALUE,			!OUTPUT PINS OF DROM (A,B,J,AC DISP AND A=J)
	TST67 : NOVALUE,			!OUPUT PINS OF DROM (VMA EN)
	TST68 : NOVALUE,			!OUPUT PINS OF DROM (COND FUNC,READ AND WRT TEST)
	TST69 : NOVALUE,			!CONTENTS OF ALL DROM (ACDISP BIT AND J FIELD)
	TST70 : NOVALUE,			!CONTENTS OF ALL DROM (A=J BIT AND J FIELD)
	TST71 : NOVALUE,			!CONTENTS OF ALL DROM (TXXX BIT)
	TST72 : NOVALUE,			!CONTENTS OF ALL DROM (VMA EN BIT)
	TST73 : NOVALUE,			!CONTENTS OF ALL DROM (WRT TEST & READ BITS)
	TST74 : NOVALUE,			!CONTENTS OF ALL DROM (COND FUNC BIT)
	TST75 : NOVALUE,			!CONTENTS OF ALL DROM (DROM A)
	TST76 : NOVALUE;			!CONTENTS OF ALL DROM (DROM B)

!
! INCLUDE FILES:
!

REQUIRE 'REGBIT.R36';				!8080 I/O REGISTER BIT DEFINITIONS
REQUIRE 'KSU.R36';				!KS10 MICROCODE MACROS
REQUIRE 'CSLMAC.R36';				!'CSL' INTERFACE MACROS
REQUIRE 'STIRSD.R36';				!LINKAGE TO 'MSSTRC' DEFINITIONS

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

GLOBAL LITERAL
    TEST_VERSION = 1,				!VERSION NUMBER FOR TEST MODULE
    TEST_EDIT = 0;				!EDIT NUMBER FOR TEST MODULE


GLOBAL BIND
    MSGFIL = UPLIT (%SIXBIT'MSDPE', %SIXBIT'MSG'),
    PRGNAM = UPLIT (%ASCIZ'KS10 STIMULUS-RESPONSE DIAGNOSTICS FOR THE M8620/DPE BOARD');

!
! OWN STORAGE:
!

OWN
	TEST53_FLG,
	TEST54_FLG,
	TEST55_FLG,
	TEST58_FLG,
	TEST59_FLG,
	PIBUS_FLG,
	PIACTV_FLG,
	PISOFT_FLG,
	DBMDBUS_FLG,
	ADRSFLG,
	LDVMA,					!FLAG TO LOAD THE VMA WITH 0
	PCDBUS_FLG,
	FUNCLD,					!FLAG TO LOAD INSTRUCTIONS FOR ALU FUNC TESTS
	RCVDATA,					!STORAGE FOR ALL RECIEVED DATA
	ER_TAB : VECTOR [10] INITIAL (0),		!STORAGE FOR ERRCAS ROUTINE PRINTOUT
	RAMFILE_FLAG : INITIAL (1),
	DROM_FLAG : INITIAL (1),
	TBL:VECTOR [512]				!STORAGE FOR CORRECT DROM CONTENTS (IN 36 BITS FORMAT)
	    INITIAL(					!INITIALIZE CORRECT DROM DATA
		    %O '000015562100',%O '000117402100',%O '000217402100',%O '000317402100',%O '000217412100',
		    %O '000517402100',%O '000617402100',%O '000717402100',%O '000117422100',%O '000417422100',
		    %O '000117432100',%O '000017432100',%O '000117442100',%O '000017442100',%O '000217442100',
		    %O '000317442100',%O '000017462100',%O '000017472100',%O '000017502100',%O '000017512100',
		    %O '000117512100',%O '000217512100',%O '000417512100',%O '001017512100',%O '000015572100',
		    %O '000115572100',%O '000215572100',%O '000315572100',%O '000415572100',%O '000515572100',
		    %O '000615572100',%O '000715572100',%O '000015562100',%O '000015562100',%O '000015562100',
		    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
		    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
		    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
		    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
		    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
		    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
		    %O '000016612100',%O '000016622100',%O '000016632100',%O '000016642100',%O '000015513000',
		    %O '000016662100',%O '000016672100',%O '110016371100',%O '110016351100',%O '110516311100',
		    %O '110516361100',%O '020514571100',%O '020516151100',%O '020515661100',%O '020516271100',
		    %O '020515051100',%O '021514341100',%O '070116261100',%O '000014673100',%O '030015670100',
		    %O '010015650500',%O '071116261100',%O '001116161100',%O '000016602100',%O '000116602100',
		    %O '000116212100',%O '001516101100',%O '000016201500',%O '000016241100',%O '000016301500',
		    %O '000016341100',%O '070115771100',%O '000216602100',%O '070215771700',%O '070315771700',
		    %O '071115771100',%O '061115770100',%O '071215771700',%O '071315771700',%O '070115761100',
		    %O '000316602100',%O '070215761700',%O '070315761700',%O '071115761100',%O '061115760100',
		    %O '071215761700',%O '071315761700',%O '070115701100',%O '000416602100',%O '070215701700',
		    %O '070315701700',%O '071115701100',%O '061115700100',%O '071215701700',%O '071315701700',
		    %O '070115741100',%O '000516602100',%O '070215741700',%O '070315741700',%O '071115741100',
		    %O '061115740100',%O '071215741700',%O '071315741700',%O '101515151100',%O '001515153000',
		    %O '011614040700',%O '000415041700',%O '101514021100',%O '001514023000',%O '011614020700',
		    %O '000414021700',%O '101514051100',%O '001514053000',%O '011614050700',%O '000414051700',
		    %O '101514031100',%O '001515153000',%O '011614030700',%O '000414031700',%O '101516411100',
		    %O '001516413000',%O '001616411700',%O '001716411700',%O '100515711100',%O '000515713000',
		    %O '001615711700',%O '000615711700',%O '100516001100',%O '000516003000',%O '001616001700',
		    %O '000616001700',%O '100516011100',%O '000516013000',%O '001616011700',%O '000616011700',
		    %O '040016221000',%O '040016321000',%O '040016121000',%O '000014622100',%O '000014663000',
		    %O '050014701000',%O '050014641000',%O '000016652100',%O '001514061500',%O '000016402100',
		    %O '000515472100',%O '000115472100',%O '000015206000',%O '000015402100',%O '000015411100',
		    %O '121515530100',%O '000015442100',%O '000215433100',%O '000215452100',%O '000015462100',
		    %O '000015522100',%O '000015502100',%O '000015542100',%O '000015552100',%O '101515601100',
		    %O '001515603000',%O '001615601700',%O '001715601700',%O '101515611100',%O '001515613000',
		    %O '001615611700',%O '001715611700',%O '000014002100',%O '000114762100',%O '000214762100',
		    %O '000314762100',%O '000414762100',%O '000514762100',%O '000614762100',%O '000714762100',
		    %O '000014761100',%O '000114761100',%O '000214761100',%O '000314761100',%O '000414761100',
		    %O '000514761100',%O '000614761100',%O '000714761100',%O '000014002100',%O '000114402100',
		    %O '000214402100',%O '000314402100',%O '000415202100',%O '000514402100',%O '000614402100',
		    %O '000714402100',%O '000014771100',%O '000114771100',%O '000214771100',%O '000314771100',
		    %O '000414771100',%O '000514771100',%O '000614771100',%O '000714771100',%O '000016113000',
		    %O '000116112100',%O '000216112100',%O '000316112100',%O '000416112100',%O '000516112100',
		    %O '000616112100',%O '000716112100',%O '000014311500',%O '000114311500',%O '000214311500',
		    %O '000314311500',%O '000414311500',%O '000514311500',%O '000614311500',%O '000714311500',
		    %O '000015423000',%O '000115422100',%O '000215422100',%O '000315422100',%O '000415422100',
		    %O '000515422100',%O '000615422100',%O '000715422100',%O '000014371500',%O '000114371500',
		    %O '000214371500',%O '000314371500',%O '000414371500',%O '000514371500',%O '000614371500',
		    %O '000714371500',%O '001514413000',%O '001514413000',%O '001614412700',%O '001714412700',
		    %O '101514421100',%O '001514423000',%O '001614421700',%O '001714421700',%O '101514431100',
		    %O '001514433000',%O '001614431700',%O '001714431700',%O '101514041100',%O '001514043000',
		    %O '001614041700',%O '001714041700',%O '101514441100',%O '001514443000',%O '001614441700',
		    %O '001714441700',%O '000014001100',%O '000014002100',%O '011614040700',%O '011614040700',
		    %O '101514451100',%O '001514453000',%O '001614451700',%O '001714451700',%O '101514461100',
		    %O '001514463000',%O '001614461700',%O '001714461700',%O '101514471100',%O '001514473000',
		    %O '001614471700',%O '001714471700',%O '101514501100',%O '001514503000',%O '001614501700',
		    %O '001714501700',%O '001514513000',%O '001514513000',%O '001614512700',%O '001714512700',
		    %O '101514521100',%O '001514523000',%O '001614521700',%O '001714521700',%O '101514531100',
		    %O '001514533000',%O '001614531700',%O '001714531700',%O '101514541100',%O '001514543000',
		    %O '001614541700',%O '001714541700',%O '101514551100',%O '001514553000',%O '001614551700',
		    %O '001714551700',%O '001514563000',%O '001514563000',%O '001614562700',%O '001714562700',
		    %O '101514101100',%O '001514103000',%O '001614071700',%O '000414041700',%O '101514111100',
		    %O '001514113000',%O '001614131700',%O '000414141700',%O '101514321100',%O '001514323000',
		    %O '011614320700',%O '000414321700',%O '101514241100',%O '001514243000',%O '011614240700',
		    %O '000414241700',%O '101514331100',%O '001514333000',%O '011614330700',%O '000414331700',
		    %O '101514251100',%O '001514253000',%O '011614250700',%O '000414251700',%O '101514301100',
		    %O '001514303000',%O '011614300700',%O '000414301700',%O '101514221100',%O '001514223000',
		    %O '011614220700',%O '000414221700',%O '101514071100',%O '001514073000',%O '001614101700',
		    %O '000414041700',%O '101514121100',%O '001514123000',%O '001614151700',%O '000414161700',
		    %O '101514201100',%O '001514203000',%O '011614200700',%O '000414201700',%O '101514261100',
		    %O '001514263000',%O '011614260700',%O '000414261700',%O '101514211100',%O '001514213000',
		    %O '011614210700',%O '000414211700',%O '101514271100',%O '001514273000',%O '011614270700',
		    %O '000414271700',%O '101514171100',%O '001514173000',%O '011614170700',%O '000414171700',
		    %O '101514231100',%O '001514233000',%O '011614230700',%O '000414231700',%O '000014002100',
		    %O '000014002100',%O '000014752100',%O '000014742100',%O '000014732100',%O '000014722100',
		    %O '000414752100',%O '000414742100',%O '000014002100',%O '000014002100',%O '000014751100',
		    %O '000014741100',%O '000014731100',%O '000014721100',%O '000414751100',%O '000414741100',
		    %O '000514732100',%O '000514722100',%O '000114752100',%O '000114742100',%O '000114732100',
		    %O '000114722100',%O '000514752100',%O '000514742100',%O '000514731100',%O '000514721100',
		    %O '000114751100',%O '000114741100',%O '000114731100',%O '000114721100',%O '000514751100',
		    %O '000514741100',%O '000614732100',%O '000614722100',%O '000214752100',%O '000214742100',
		    %O '000214732100',%O '000214722100',%O '000614752100',%O '000614742100',%O '000614731100',
		    %O '000614721100',%O '000214751100',%O '000214741100',%O '000214731100',%O '000214721100',
		    %O '000614751100',%O '000614741100',%O '000714732100',%O '000714722100',%O '000314752100',
		    %O '000314742100',%O '000314732100',%O '000314722100',%O '000714752100',%O '000714742100',
		    %O '000714731100',%O '000714721100',%O '000314751100',%O '000314741100',%O '000314731100',
		    %O '000314721100',%O '000714751100',%O '000714741100',%O '120017004100',%O '120017204100',
		    %O '121617604700',%O '000316502100',%O '120017540100',%O '120017550100',%O '000616502100',
		    %O '000716502100',%O '121016140100',%O '121416140100',%O '121014600100',%O '121014610100',
		    %O '121016440100',%O '121416440100',%O '000616512100',%O '000716512100',%O '120016140100',
		    %O '120416140100',%O '120014600100',%O '120014610100',%O '120016440100',%O '120416440100',
		    %O '000616522100',%O '000716522100',%O '000016532100',%O '000116532100',%O '000216532100',
		    %O '000316532100',%O '000416532100',%O '000516532100',%O '000616532100',%O '000716532100',
		    %O '000016542100',%O '000116542100',%O '000216542100',%O '000316542100',%O '000416542100',
		    %O '000516542100',%O '000616542100',%O '000716542100',%O '000016552100',%O '000116552100',
		    %O '000216552100',%O '000316552100',%O '000416552100',%O '000516552100',%O '000616552100',
		    %O '000716552100',%O '000016562100',%O '000116562100',%O '000216562100',%O '000316562100',
		    %O '000416562100',%O '000516562100',%O '000616562100',%O '000716562100',%O '000016572100',
		    %O '000116572100',%O '000216572100',%O '000316572100',%O '000416572100',%O '000516572100',
		    %O '000616572100',%O '000716572100'  );

!
! EXTERNAL REFERENCES:
!

GLOBAL ROUTINE SPEC_DIALOGUE : NOVALUE =
    BEGIN
    0							!TO ILLUMINATE BLISS INFO COMMENT
    END;

GLOBAL ROUTINE SPEC_ASK : NOVALUE =
    BEGIN

    REGISTER
	AC0 = 0;

    PRT_TXT_F ('DO YOU WISH TO INHIBIT TESTING OF DROM CONTENTS?');
    DROM_FLAG = TTI_YES;
    PRT_TXT_F ('DO YOU WISH TO INHIBIT RAMFILE TESTING?');
    RAMFILE_FLAG = TTI_YES;
    END;

GLOBAL ROUTINE SPEC_PRT =
    BEGIN

    REGISTER
	AC0 = 0;

	IF .DROM_FLAG NEQ 0
		THEN PTXT_CRLF_F ('DROM CONTENTS TESTING INHIBITED');
	IF .RAMFILE_FLAG NEQ 0
		THEN PTXT_CRLF_F ('RAMFILE TESTING INHIBITED');
	IF (.DROM_FLAG OR .RAMFILE_FLAG) NEQ 0
		THEN RETURN 1;
       0						!TO ILLUMINATE BLISS INFO COMMENT
    END;

GLOBAL ROUTINE TEST_INIT : NOVALUE =
!THIS IS AN INITIALIZING ROUTINE THAT GETS EXECUTED EACH TIME STIRS
!IS STARTED.IT WILL EXECUTE AN INSTRUCTION TO CLEAR PAGE FAIL CONDITION,
!CLEAR VARIOUS FLAGS, DO A MASTER RESET, TURN OFF CRAM ERROR RECOVERY AND
!DISABLE PARITY.
    BEGIN

    BIND
	POINTER = PLIT (U_J(1) U_SPEC_APR_EN U,
			U_J(2) U_SPEC_FLAGS U,
			U_J(3) U_SPEC_CLRCLK U,
			U_J(4) U_SPEC_LDPI U_ALU_XNOR U,
			U_J (4) U_SPEC_MEMCLR U);	!INSTRUCTION TO CLEAR PAGE FAIL STATE

    MR ();					!DO A MASTER RESET
    LOAD_U (0, POINTER);			!LOAD IT
    SET_C(0);
    CP_NOSS (10);				!DON'T SINGLE STEP THE NXT 5 CLOCKS
    SC_0 ();					!TURN OFF CRAM ERROR RECOVERY
    PE (0);					!DISABLE PARITY
    RPT_ERR_FLAG = 1;				!SET THIS FLAG TO REPORT ANY 8080 ERRORS
    NO_SUBSET = 1;
    TEST53_FLG = 1;
    TEST54_FLG = 1;
    TEST55_FLG = 0;
    TEST59_FLG = 0;
    TEST58_FLG = 0;
    PIBUS_FLG = 0;
    PIACTV_FLG = 0;
    PISOFT_FLG = 0;
    ADRSFLG = 0;
    DBMDBUS_FLG = 0;
    PCDBUS_FLG = 0;
    LDVMA = 0;					!CLEAR VMA LOAD WITH 0 FLAG
    FUNCLD = 0;					!CLEAR FLAG TO LOAD INSTRUCTIONS FOR ALU FUNC TESTS
    END;

GLOBAL ROUTINE FUNC_LD : NOVALUE =
!THIS ROUTINE WILL LOAD CRAM LOCATIONS 0,1,2,3,4,5 & 6 WITH INSTRUCTIONS
!TO BE EXECUTED BY ALU FUNC TESTS.IT WILL ALSO EXECUTE INSTRUCTIONS TO
!LOAD VMA AND REQUIRED DATA IN THE 2901'S REGISTERS Q & 0.IT WILL RELOAD
!AND EXECUTE ONLY IF THE THE PROGRAM IS RESTARTED.
!THE INSTRUCTIONS LOADED IN THE CRAM WILL DO THE FOLLOWING:
!CRAM 0 /  LOAD THE VMA WITH ZERO, PUT 0 DATA IN THE Q REGISTER.
!CRAM 1 /  FINISH LOAD VMA CYCLE.
!CRAM 2 /  PUT -1 IN MAGIC # FIELD, PASS IT TO DBM, PASS IT TO DBUS MUX
!	   AND FROM THERE LOAD IT INTO REGISTER 0 SHIFTED RIGHT.
!CRAM 3 /  SHIFT THE -1 IN REGISTER 0 RIGHT AGAIN TO FILL ALL 40 BITS.
!CRAM 4 /  DO THE FUNCTION AND PUT THE RESULT IN REGISTER 1 SHIFTED (RIGHT/LEFT).
!CRAM 5 /  START A MEM WRITE CYCLE AND SHIFT REGISTER 1 (RIGHT/LEFT)AGAIN.
!CRAM 6 /  FINISH THE MEM WRITE CYCLE OUTPUTING REGISTER 1 INTO PHYSICAL MEM.
!NOTE:		(TST3 SHOULD PASS BEFOR THIS ROUTINE IS EXECUTED).

    BEGIN

    BIND
	POINTER = PLIT (U_J (1) U_DEST_Q_AD U_MEM U_N (1012) U,
			U_J(2) U_MEM U_N(2) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD_DIV2 U_DBUS_DBM U_N(777777) U,
			U_J(4) U_ALU_OR U_DEST_AD_DIV2 U,
			U_J(5) U_ALU_OR U_B_PC U_DEST_AD_DIV2 U,
			U_J(6) U_ALU_OR U_LSRC_0B U_B_PC U_DEST_AD_DIV2  U_MEM U_N(11002) U,
			U_J(4) U_ALU_OR U_A_PC U_MEM U_N(2) U);

    IF .FUNCLD EQL 0 THEN 			!HAVE THEY BEEN LOADED YET ?
	BEGIN
	LOAD_U (0, POINTER);			!NO THEN DO IT NOW
	SET_C (0);				!SET CRAM ADRS TO 0
	CP_NOSS (5);				!DON'T SINGLE STEP THE NXT 5 CLOCKS
						!PUT 0 IN THE Q REGISTER OF THE 2901'S
						!PUT ONES IN ALL 40 BITS IN REGISTER 1 OF THE 2901'S
	FUNCLD = -1;				!SET FLAG INSTRUCTIONS AND DATA HAVE BEEN LOADED
	END;

    END;

GLOBAL ROUTINE VMA_LD : NOVALUE =
!THIS ROUTINE WILL EXECUTE 2 INSTRUCTION IN CRAM 0 & 1 TO LOAD THE VMA
!WITH A ZERO.IT WILL NOT EXECUTE IF THE VMA HAS ALREADY BEEN LOADED
    BEGIN

    BIND
	POINTER = PLIT (U_J (1) U_MEM U_N (1012) U,
			U_MEM U_N(2) U);

    IF .LDVMA EQL 0 THEN 			!HAS VMA BEEN LOADED ?
	BEGIN					!NO THEN DO IT NOW
	LOAD_U (0, POINTER);			!PUT INSTRUCTIONS TO LOAD THE VMA WITH 0
	SET_C (0);				!SET CRAM ADRS TO 0
	CP_NOSS (2);				!DON'T SINGLE STEP THE NXT 2 CLOCKS
	LDVMA = -1;				!SET FLAG VMA IS LOADED
	END;
    END;

GLOBAL ROUTINE TST1: NOVALUE =

!THIS TEST CHECKS THAT WE CAN LOAD ADDRESSES USING DIAGNOSTIC FUNCTION
!IN ORDER TO LOAD THE CRAM WITH MICROCODE
!DISP & SKIP SEL BOTH = 0 (GRUOND INPUTS) ON DPEA.IT TRIES TO SET ADDRESS 0
!IF THIS TEST FAILS THAT MEANS NO MICROCODE CAN BE LOADED AND NO TESTS CAN RUN

	BEGIN
	LABEL BLOCK1;
	DO (0) WHILE
BLOCK1:		BEGIN
		SET_C(0);				!SET CRAM ADRS TO 0
		RCVDATA = EX_NXT;			!GET NXT CRAM ADRS
	INCR I FROM 0 TO 3 DO
		BEGIN
		IF (.RCVDATA AND 1^.I) NEQ 0		!IS IT 0
			THEN ERRCAS((1+.I),1,0,.RCVDATA,4,0);!NO
		END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILIMINATE INFO COMMENT

	END;
!*MESSAGE 1
!*	DIAGNOSTIC DIPATCH TEST
!*STIMULUS:
!*	TRIED TO LOAD ADDRESS 000, USING DIAG ADDRESS DISPATCH
!*	TEST FAILED, ABORT PROGRAM 
!*	CANT LOAD ANY MICROCODE
!*	ABORT....ABORT....ABORT....
!*RESPONSE:
!]ERROR 1
!]MSKIP MDISP NTWK
!]ERROR 2
!]MDISP NTWK
!]ERROR 3
!]MDISP NTWK
!]ERROR 4
!]MDISP NTWK
	END;

GLOBAL ROUTINE TST2: NOVALUE =

!THIS TEST CHECKS THAT WE CAN OUTPUT A 0 FROM THE 2901'S.
!IT OUTPUTS A ZERO FROM THE 2901'S INTO THE DP, THEN SKIP TO NXT CRAM 
!ADRS IF OUTPUT ON DP IS 0. THE CURRENT J FIELD IS 0

	BEGIN
	LABEL BLOCK1;
	BIND
	POINTER = PLIT (U_SKIP_ADEQ0 U);
	LOAD_U(0,POINTER);
	SET_C(0);					!SET CRAM ADRS TO 0
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1	 			!CHECK DATA
		THEN ERR(1);				!NO
	IF LOOP_CHK(1) THEN				!IS LOOP ON ERRO SET
		LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	OUTPUT A 0 ONTO DP FROM THE 2901'S
!*	SKIP IF DP EQL TO 0
!*	J = 0
!*RESPONSE:
!*	DP WAS NOT A 0
!]ERROR 1
!]ADEQ0 M2901S NTWK
	END;

GLOBAL ROUTINE TST3: NOVALUE =

!THIS TEST CHECKS THAT WE CAN LOAD THE VMA WITH A ZERO.
!IT OUTPUTS A ZERO FROM THE 2901'S INTO THE DP, LOAD THE VMA WITH DATA 
!PATH CONTENTS, AND WRITE THE SAME CONTENTS INTO PHYSICAL MEMORY.
!IT SHOULD WRITE A ZERO INTO MEM LOCATION ZERO.

	BEGIN
	LABEL BLOCK1;
	BIND
	POINTER = PLIT (U_J(1) U_MEM U_N(11012) U,
			U_J(0) U_MEM U_N(2) U);
	LOAD_U(0,POINTER);
	SET_C(0);					!SET CRAM ADRS TO 0
	DM(0,%O'-1');					!LOAD A -1 INTO MEM 0
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0
		THEN ERRCA(1,0,.RCVDATA,12)		!NO
		ELSE LDVMA = -1;			!SET FLAG VMA IS LOADED WITH ZERO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD THE VMA AND WRITE TO MEM WITH THE 
!*	SAME DATA (DP = 0 FROM A PORT)
!*RESPONSE:
!*	READ DATA FROM MEMORY
!]ERROR 1
!]M2901S MEMVMA NTWK
	IF LOOP_CHK(1) THEN				!IS LOOP ON ERRO SET
		LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST4: NOVALUE =

!THIS TEST CHECKS THE ALU DEST FUNCTION (DEST = 0,1,2 & 3).
!WE REPEAT EXECUTING 5 INSTRUCTIONS THAT WILL DO THE FOLOWING:
!A)  CLEAR THE 2901'S REGISTER 0 AND Q.
!B)  WRITE INTO THE 2901'S SELECTING A DEST (0,1,2 & 3).
!C)  READ REGISTER 0 THEN THE Q AND VERIFY THE CONTENTS IF CHANGED OR NOT.
!ALL DATA IS READ AND VERIFIED FROM MEM 0.THE 5 INSTUCTIONS RESIDE IN 
!CRAM 1,2,3,4 & 5 .CRAM CONTENTS WILL DO THE FOLLOWING:
!CRAM 1/ OUTPUT A ZERO FROM THE AD AND LOAD IT INTO REGISTER 0.
!CRAM 2/ OUTPUT A ZERO FROM THE AD AND LOAD IT INTO THE Q REGISTER.
!CRAM 3/ OUPUT A -1 FROM THE 2901'S AND LOAD IT INTO THE 2901'S SELECTED
!	 REGISTER (0,Q OR NIETHER) BY SETTING DEST (0,1,2 OR 3).
!CRAM 4/ START A MEMOY WRITE CYCLE.LOAD THE VMA WITH A 0
!CRAM 5/ FINISH THE CYCLE BY WRITING INTO PHYSICAL MEM 0 THE CONTENTS 
!	 OF THE SELETED REGISTER (0 OR Q).
!ALL DATA IS VERIFIED AND ERRORS ARE REPORTED.
!DEST & OUTPUT SOURCE IS CHANGED BY MODIFYING FIELDS IN THE CRAM.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8;
	BIND
	POINTER = PLIT (U_J(2) U_DEST_AD U,
			U_J(3) U_DEST_Q_AD U,
			U_J(4) U_ALU_XNOR U_DEST_A U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'			!CHECK DATA
		THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(1) THEN				!IS LOOP ON ERRO SET
		LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO PUPUT Q
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[1] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0 				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(7,%O'7100');				!CHANGE DEST TO 1
	ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,%O'-1');					!SET MEM
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0 				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3337');				!CHANGE LSRC TO OUPUT B
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[1] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(4) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
	MOD_FLD(7,%O'7200');				!MODIFY DEST TO 2
	SET_C(1);					!SET CRAM ADRS TO 2
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0 				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
	IF LOOP_CHK(5) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUTPUT Q
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD CHANGE'));
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(6) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK6 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(7,%O'7300');				!MODIFY DEST TO 3
	ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));
	SET_C(1);					!SET CRAM ADRS TO 2
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
	IF LOOP_CHK(7) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK7 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3337');				!CHANGE LSRC TO OUTPUT B
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE 0 REGISTER SHOULD NOT CHANGE'));
	ER_TAB[1] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	DM(0,%O'-1');					!SET MEM
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
	IF LOOP_CHK(8) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK8 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	WRITE ZERO INTO THE 2901'S Q REGISTER
!*	WRITE (-1) INTO THE 2901'S REGISTER 0 SELECTING DEST = \O0
!*	THEN OUTPUT THE CONTENTS OF REGISTER \S1 INTO MEM 0.\S2
!*RESPONSE:
!*	EXAMINE THE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS MEMVMA NTWK
	END;

GLOBAL ROUTINE TST5: NOVALUE =

!THIS TEST CHECKS THAT THE REGISTERS IN THE 2901'S CAN BE ZEROS AND ONES
!(ONLY 36 BITS ARE CHECKED HERE).
!ALL REGISTERS OF THE 2901'S ARE CHECKED THROUGH A DO 17 LOOP. AT
!EACH PASS THROUGH THE LOOP 2 SEQUENCES OF DATA ARE WRITTEN INTO THE 
!SELECTED REGISTER.AFTER EACH WRITE THE DATA THEN IS PASSED OUT FROM 
!THE REGISTER AND INTO PHYSICAL MEMORY.THE DATA IS READ AND VERIFEID 
!FROM MEMORY.THREE INSTRUCTIONS ARE EXECUTED FOR EACH DATA PASS FROM 
!CRAM 1,2 & 3.ALL EXPECTED DATA IS READ FROM MEM 0.
!THE THREE INSTRUCTIONS DO THE FOLLOWING:
!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER .
!CRAM 2/ START A PHYSICAL MEMORY WRITE CYCLE. LOAD THE VMA WITH A 0
!CRAM 3/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
!	 THE A PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,
	BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
			U_J(3) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0A U_DEST_A U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
	DM(0,0);					!CLEAR MEM
    INCR I FROM 0 TO %O'17' DO
	BEGIN
	LC(3);						!SET CRAM ADRS TO 3
	MOD_FLD(6,(.I OR %O'2060') OR .I^6);		!MODIFY THE SELETED REGISTER (DP A&B ADRS)
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(3,%O'5252');				!MODIFY THE DATA
	MOD_FLD(4,%O'52');				!HERE TOO
	MOD_FLD(6,.I OR %O'6060');			!MODIFY THE SELETED REGISTER (DP B ADRS)
	ER_TAB[0] = .I;					!SET UP FOR ERROR PRINTOUT
	ER_TAB[1] = %O'525252525252';			!SET UP FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);	!NO
			DBMDBUS_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
	MOD_FLD(4,%O'25');				!HERE TOO
	ER_TAB[1] = %O'252525252525';			!SET UP FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB); !NO
			DBMDBUS_FLG = 1;
		     END
		ELSE IF .DBMDBUS_FLG EQL 0
				THEN NOERR(1);
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD THE 2901'S REGISTER \O0 WITH \U1
!*	FROM THE MAGIC # FIELD VIA DBUS
!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT A
!*RESPONSE:
!*	READ THE DATA FROM MEMORY
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA NTWK
!]NO ERROR 1
!]DBMDBUS NTWK
	END;

GLOBAL ROUTINE TST6: NOVALUE =

!THIS TEST CKECKS OUT PORT B IN THE 2901'S (ONLY 36 BITS).
!WE PASS 2 DATA WORDS ONE AT A TIME TO REGISTER 0,THEN PASS IT OUT 
!INTO MEM ZERO THROUGH PORT B.WE EXECUTE THREE INSTRUCTIONS EACH TIME
!THE THREE INSTRUCTIONS RESIDE IN CRAM 1,2 & 3.ALL EXPECTED DATA IS READ
!FROM MEM 0.THE THREE INSTRUCTIONS DO THE FOLLOWING:
!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO REGISTER 0 .
!CRAM 2/ START A PHYSICAL MEMORY WRITE CYCLE. LOAD THE VMA WITH A 0
!CRAM 3/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,
	BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(525252) U,
			U_J(3) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
		THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
	MOD_FLD(4,%O'25');				!HERE TOO
	ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
		THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD THE 2901'S REGISTER 0 WITH \U0
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
!*RESPONSE:
!*	READ THE DATA FROM MEMORY
!]ERROR 1
!]MEMVMA M2901S DPCLKS DBMDBUS DBUSSEL NTWK
	END;

GLOBAL ROUTINE TST7: NOVALUE =

!THIS TEST CKECKS OUT THE Q REGISTER IN THE 2901'S (ONLY 36 BITS).
!WE PASS 2 DATA WORDS ONE AT A TIME TO THE Q REGISTER,THEN PASS IT OUT 
!INTO MEM ZERO THROUGH PORT B.WE EXECUTE THREE INSTRUCTIONS EACH TIME
!THE THREE INSTRUCTIONS RESIDE IN CRAM 1,2 & 3.ALL EXPECTED DATA IS READ
!FROM MEM 0.THE THREE INSTRUCTIONS DO THE FOLLOWING:
!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO THE Q REGISTER.
!CRAM 2/ START A PHYSICAL MEMORY WRITE CYCLE.LOAD THE VMA WITH A 0
!CRAM 3/ OUTPUT THE CONTENTS OF THE THE Q REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,
	BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(525252) U,
			U_J(3) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS

	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
		THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
	MOD_FLD(4,%O'25');				!HERE TOO
	ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
		THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD THE 2901'S Q REGISTER WITH \U0
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
!*RESPONSE:
!*	READ THE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA NTWK
	END;

GLOBAL ROUTINE TST8: NOVALUE =

!THIS TEST CKECKS OUT THE RAM SHIFTER IN THE 2901'S (ONLY 36 BITS).
!WE PASS 2 DATA WORDS ONE AT A TIME TO REGISTER 0 SHIFTED LEFT,THEN 
!PASS IT OUT INTO MEM ZERO THROUGH PORT B.FINALLY WE PASS THE SAME TWO 
!DATA WORDS SHITED RIGHT. WE EXECUTE THREE INSTRUCTIONS FOR EACH DATA
!SHIFT PASS THE THREE INSTRUCTIONS RESIDE IN CRAM 2,3 & 4.ALL EXPECTED 
!DATA IS READ FROM MEM 0.THE THREE INSTRUCTIONS DO THE FOLLOWING:
!CRAM 2/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS SHIFTED (LEFT/RIGHT) INTO REGISTER 0 .
!CRAM 3/ START A PHYSICAL MEMORY WRITE CYCLE. LOAD THE VMA WITH A 0.
!CRAM 4/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(252525) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD_MUL2 U_DBUS_DBM U_N(252525) U,
			U_J(4) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS
	ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
	ER_TAB[1] = 5;					!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
	ER_TAB[3] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));

	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
		THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3337');				!MODIFY TO OUPUT B
	MOD_FLD(0,3);					!MODIFY J FIELD
	ER_TAB[3] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
	SET_C(2);					!SET CRAM ADRS TO 2
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
		THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'5252');				!MODIFY DATA IN # FIELD
	MOD_FLD(4,%O'52');				!HERE TOO
	ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'252525252524'		!CHECK DATA
		THEN ERRCAS(1,1,%O'252525252524',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(3) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEMORY
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TYPE
	LC(4);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3227');				!OUTPUT Q
	MOD_FLD(0,2);					!MODIFY J FIELD
	ER_TAB[1] = 7;					!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
	ER_TAB[3] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK4:	
	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
		THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3337');				!MODIFY TO OUTPUT B
	MOD_FLD(0,3);					!MODIFY J FIELD
	ER_TAB[3] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
	SET_C(2);					!SET CRAM ADRS TO 3
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(3);						!GIVE 2 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'652525252525'		!CHECK DATA
		THEN ERRCAS(1,1,%O'652525252525',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
	MOD_FLD(4,%O'25');				!HERE TOO
	ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'125252525252'		!CHECK DATA
		THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(6) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK6 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,0);					!MODIFY DATA 
	MOD_FLD(4,0);					!TO ZERO
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(7)
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7777');				!MODIFY DATA 
	MOD_FLD(4,%O'77');				!TO 777777
	ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(8)
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TYPE TO LEFT
	ER_TAB[1] = 5;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:	
	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'777777777776'		!CHECK DATA
		THEN ERRCAS(1,1,%O'777777777776',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(9)
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,0);					!MODIFY DATA
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	MOD_FLD(4,0);					!TO 0
	DO (0) WHILE
BLOCK10:BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(10)
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD THE Q REGISTER WITH 252525252525
!*	WRITE A \U0 INTO THE 2901'S SELECTING DEST = \O1
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	THEN OUTPUT THE CONTENTS OF REGISTER \S2 INTO MEM 0.\S3
!*RESPONSE:
!*	EXAMINE THE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA SHIFT NTWK
	END;

GLOBAL ROUTINE TST9: NOVALUE =

!THIS TEST CKECKS OUT THE 2 LSB BITS AND 2 INPUT AND OUTPUT PINS ON 
!THE LEFT END OF THE 2901'S AND ALL THE 2901'S RAM REGISTERS.
!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT LEFT 3
!	    SHIFT RIGHT 3.
!	2 - WRITE 300000300000 INTO THE SELECTED REGISTER THEN SHIFT LEFT 3, SHIFT RIGHT 3.
!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
			U_J(3) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
			U_J(4) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
			U_J(5) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
			U_J(6) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
			U_J(7) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
			U_J(10) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
			U_J(11) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 9 INSTRUCTIONS
    INCR I FROM 0 TO %O'17' DO
	BEGIN
	ER_TAB[0] = .I;					!SET UP FOR ERROR PRINTPUT
	ER_TAB[1] = 0;					!SET UP FOR ERROR PRINTPUT
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(7);						!LOAD CRM ADRS 7
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(6,%O'6060' OR .I);			!MODIFY B FIELD
	MOD_FLD(4,0);					!MODIFY DATA TO 0
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'30');				!MODIFY DATA 300000300000
	ER_TAB[1] = %O'300000300000';			!SET UP FOR ERROR PRINTPUT
	DO (0) WHILE
BLOCK2:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'700000300000'		!CHECK DATA
		THEN ERRCAS(1,1,%O'700000300000',.RCVDATA,12,ER_TAB);   !NO
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD 2901'S REGISTER \O0 WITH \U1
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	SHIFT LEFT 3, SHIFT RIGHT 3
!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
!*RESPONSE:
!*	READ THE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA SHIFT NTWK
	END;

GLOBAL ROUTINE TST10: NOVALUE =

!THIS TEST CKECKS OUT THE 2 MSB BITS AND 2 INPUT AND OUTPUT PINS ON 
!THE RIGHT END OF THE 2901'S AND ALL THE 2901'S RAM REGISTERS.
!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT RIGHT 3
!	    SHIFT LEFT 3.
!	2 - WRITE 6000006 INTO THE SELECTED REGISTER THEN  SHIFT RIGHT 3, SHIFT LEFT 3.
!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
			U_J(3) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
			U_J(4) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
			U_J(5) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
			U_J(6) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
			U_J(7) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
			U_J(10) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
			U_J(11) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 11 INSTRUCTIONS
    INCR I FROM 0 TO %O'17' DO
	BEGIN
	ER_TAB[0] = .I;					!SET UP FOR ERROR PRINTPUT
	ER_TAB[1] = 0;					!SET UP FOR ERROR PRINTPUT
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(7);						!LOAD CRM ADRS 7
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(6,%O'6060' OR .I);			!MODIFY B FIELD
	MOD_FLD(3,0);					!MODIFY DATA TO 0
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,6);					!MODIFY DATA 6000006
	ER_TAB[1] = %O'6000006';			!SET UP FOR ERROR PRINTPUT
	DO (0) WHILE
BLOCK2:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'6000006'			!CHECK DATA
		THEN ERRCAS(1,1,%O'6000006',.RCVDATA,12,ER_TAB);   !NO
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD 2901'S REGISTER \O0 WITH \U1
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	SHIFT RIGHT 3, SHIFT LEFT 3
!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
!*RESPONSE:
!*	READ THE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS SHIFT MEMVMA NTWK
	END;

GLOBAL ROUTINE TST11: NOVALUE =

!THIS TEST CKECKS OUT THE Q SHIFTER IN THE 2901'S (ONLY 36 BITS).
!WE PASS 2 DATA WORDS ONE AT A TIME TO THE Q REGISTER,THEN THE DATA 
!IS  SHIFTED LEFT AND BACK INTO THE Q REGISTER,FINALLY PASS THE DATA
!OUT INTO MEM ZERO THROUGH PORT B.WE PASS THE SAME TWO DATA WORDS SHITED
!RIGHT GOING THROUGH THE SAME SEQUENCE OF EXECUTION. WE EXECUTE FOUR
!INSTRUCTIONS FOR EACH DATA SHIFT PASS THE FOUR INSTRUCTIONS RESIDE IN 
!CRAM 2,3,4 & 5.ALL EXPECTED  DATA IS READ FROM MEM 0.
!THE THREE INSTRUCTIONS DO THE FOLLOWING:
!CRAM 2/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO THE Q REGISTER
!CRAM 3/ SHIFT THE Q REGISTER (LEFT/RIGHT).
!CRAM 4/ START A PHYSICAL MEMORY WRITE CYCLE.
!CRAM 5/ OUTPUT THE CONTENTS OF THE Q REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(252525) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(252525) U,
			U_J(4) U_ALU_OR U_DEST_Q_MUL2 U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS

	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
	ER_TAB[1] = 4;					!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
		THEN ERRCAS(2,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3227');				!MODIFY TO OUPUT Q
	MOD_FLD(0,3);					!MODIFY J FIELD
	SET_C(2);					!SET CRAM ADRS TO 2
	ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
		THEN ERRCAS(2,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'5252');				!MODIFY DATA IN # FIELD
	MOD_FLD(4,%O'52');				!HERE TOO
	ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	
	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'252525252524'		!CHECK DATA
		THEN ERRCAS(2,1,%O'252525252524',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(3) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEMORY
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(7,%O'4600');				!MODIFY SHIFT TYPE
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3337');				!OUTPUT B
	MOD_FLD(0,2);					!MODIFY J FIELD
	ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
	ER_TAB[1] = 6;					!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK4:	
	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'125252525252'		!CHECK DATA
		THEN ERRCAS(2,1,%O'125252525252',.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(5,%O'3227');				!MODIFY TO OUTPUT Q
	MOD_FLD(0,3);					!MODIFY J FIELD
	ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
	SET_C(2);					!SET CRAM ADRS TO 2
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'652525252525'		!CHECK DATA
		THEN ERRCAS(2,1,%O'652525252525',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
	MOD_FLD(4,%O'25');				!HERE TOO
	ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	
	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'125252525252'		!CHECK DATA
		THEN ERRCAS(2,1,%O'125252525252',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,0);					!MODIFY DATA 
	MOD_FLD(4,0);					!TO ZERO
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(2,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(7)
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7777');				!MODIFY DATA 
	MOD_FLD(4,%O'77');				!TO 777777
	ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCAS(2,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(8)
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(7,%O'4400');				!MODIFY SHIFT TYPE TO LEFT
	SET_C(2);					!SET CRAM ADRS TO 2
	ER_TAB[1] = 4;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:BEGIN
	CP(4);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'777777777776'		!CHECK DATA
		THEN ERRCAS(2,1,%O'777777777776',.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(9)
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,0);					!MODIFY DATA
	MOD_FLD(4,0);					!TO 0
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK10:BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(2,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(10)
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	WRITE A \U0 INTO THE 2901'S REGISTER \S2 SELECTING DEST = \O1
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	THEN OUTPUT THE CONTENTS OF REGISTER \S2 INTO MEM 0.
!*RESPONSE:
!*	EXAMINE THE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA NTWK
!]ERROR 2
!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA SHIFT NTWK
	END;

GLOBAL ROUTINE TST12: NOVALUE =

!THIS TEST CKECKS OUT THE 2 LSB BITS OF THE Q REGISTER.
!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT LEFT 3
!	    SHIFT RIGHT 3.
!	2 - WRITE 300000300000 INTO THE SELECTED REGISTER THEN SHIFT LEFT 3, SHIFT RIGHT 3.
!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U,
			U_J(3) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
			U_J(4) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
			U_J(5) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
			U_J(6) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
			U_J(7) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
			U_J(10) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
			U_J(11) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 11 INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
	LEAVE BLOCK1 WITH 1;				!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'30');				!MODIFY DATA 300000300000
	ER_TAB[0] = %O'300000300000';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'300000300000'			!CHECK DATA
		THEN ERRCAS(1,1,%O'300000300000',.RCVDATA,12,ER_TAB);   !NO
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD 2901'S Q REGISTER WITH \U0
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	SHIFT LEFT 3, SHIFT RIGHT 3
!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
!*RESPONSE:
!*	READ THE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS SHIFT MEMVMA NTWK
	END;


GLOBAL ROUTINE TST13: NOVALUE =

!THIS TEST CKECKS OUT THE 2 MSB BITS OF THE Q REGISTER.
!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT RIGHT 3
!	    SHIFT LEFT 3.
!	2 - WRITE 6000006 INTO THE SELECTED REGISTER THEN  SHIFT RIGHT 3, SHIFT LEFT 3.
!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U,
			U_J(3) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
			U_J(4) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
			U_J(5) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
			U_J(6) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
			U_J(7) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
			U_J(10) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
			U_J(11) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD 9 INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
	IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
	LEAVE BLOCK1 WITH 1;				!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,6);					!MODIFY DATA 6000006
	ER_TAB[0] = %O'6000006';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	
	BEGIN
	CP(9);						!GIVE 9 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'6000006'			!CHECK DATA
		THEN ERRCAS(1,1,%O'6000006',.RCVDATA,12,ER_TAB);!NO
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S TEST
!*STIMULUS:
!*	LOAD 2901'S Q REGISTER WITH \U0
!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
!*	SHIFT RIGHT 3, SHIFT LEFT 3
!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
!*RESPONSE:
!*	READ THE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DBUSSEL M2901S DPCLKS SHIFT MEMVMA NTWK
	END;

GLOBAL ROUTINE TST14: NOVALUE =

!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  OR  S ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!THREE DATA SETS ARE TESTED FOR THE OR FUNCTION :
!	0   OR   -1
!	-1  OR    0
!	0   OR    0
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO 0A AND FUNCTION TO OR
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'3007');				!MODIFY LSRC TO AQ
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DADA ?
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'3227');				!MODIFY THE LSRC TO 0Q
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,%O'-1');					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	ALU FUNC (R OR S) :
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	\S0    OR    \S1
!*	THEN WRITE THE DATA OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS SHIFT DBMDBUS DBUSSEL MEMVMA NTWK
	END;

GLOBAL ROUTINE TST15: NOVALUE =

!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  +  S ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!FOUR DATA SETS ARE TESTED FOR THE ( + ) FUNCTION :
!	0   +   -1
!      -1   +    0
!	0   +    0
!      -1   +   -1
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	TEST_FLG = 0;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'447');				!MODIFY LSRC TO 0A AND FUNCTION TO ( + )
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,7);					!MODIFY LSRC TO AQ
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DADA ?
		THEN BEGIN
			ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'227');				!MODIFY THE LSRC TO 0Q
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
BLOCK5:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
	MOD_FLD(5,%O'117');				!MODIFY FUNC TO ( + )
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);!NO
			TEST_FLG = 1;
		    END;
	IF LOOP_CHK(7)
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
	CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	MOD_FLD(5,%O'117');				!MODIFY FUNC TO ( + )
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777776'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'3777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(8)
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	ALU FUNC (R + S) :
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	\S0    +    \S1
!*	THEN WRITE THE DATA OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS SHIFT DBMDBUS DBUSSEL MEMVMA M2902S SPEC18CRY NTWK
	END;

GLOBAL ROUTINE TST16: NOVALUE =

!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( S  -  R ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!TWO DATA SETS ARE TESTED FOR THE (S - R) FUNCTION :
!	0   -   -1
!	-1  -    0
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	LC(5);						!LOAD CRAM ADRS 5
	TEST_FLG = 0;
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'1447');				!MODIFY LSRC TO 0A AND FUNCTION TO S-R
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777776'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'3777776',.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'1007');				!MODIFY LSRC TO AQ
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DADA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	ALU FUNC (S - R) :
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	\S0    -    \S1
!*	THEN WRITE OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS SHIFT DBMDBUS DBUSSEL MEMVMA M2902S SPEC18CRY NTWK
	END;

GLOBAL ROUTINE TST17: NOVALUE =

!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  -  S ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!TWO DATA SETS ARE TESTED FOR THE (R - S) FUNCTION :
!	0   -    0
!      -1   -   -1
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	TEST_FLG = 0;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'2227');				!MODIFY LSRC TO 0A AND FUNC TO R-S
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,%O'777776',.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
	MOD_FLD(5,%O'2117');				!MODIFY FUNC TO (R-S)
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
		THEN BEGIN
			ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
	CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	MOD_FLD(5,%O'2117');				!MODIFY FUNC TO (S - R)
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	ALU FUNC (R - S) :
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	\S0    -    \S1
!*	THEN WRITE THE DATA OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA M2902S SPEC18CRY NTWK
	END;

GLOBAL ROUTINE TST18: NOVALUE =

!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  AND  S ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!THREE DATA SETS ARE TESTED FOR THE (AND) FUNCTION :
!	0   AND   -1
!	-1  AND    0
!	-1  AND   -1
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'4447');				!MODIFY LSRC TO 0A AND FUNC TO (AND)
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'4007');				!MODIFY LSRC TO AQ
	ER_TAB[0] = UPLIT (%ASCIZ'37777777');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DADA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
	MOD_FLD(5,%O'4117');				!MODIFY FUNC TO (R - S)
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
	CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	MOD_FLD(5,%O'4117');				!MODIFY FUNC TO ( AND )
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	ALU FUNC (R AND S) :
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	\S0    AND    \S1
!*	THEN WRITE THE DATA OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
	END;

GLOBAL ROUTINE TST19: NOVALUE =
!					    _
!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  AND  S ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!THREE DATA SETS ARE TESTED FOR THE (NOT R  AND  S) FUNCTION :
! NOT  0   AND    -1
! NOT  0   AND    0
! NOT -1   AND   -1
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'5447');				!MODIFY LSRC TO 0A AND FUNC TO 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'5227');				!MODIFY THE LSRC TO 0Q
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
	CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
	MOD_FLD(5,%O'5117');				!MODIFY FUNC TO 5
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
	CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	MOD_FLD(5,%O'5117');				!MODIFY FUNC TO ( 5 )
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	2901'S FUNC TEST
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*		  _
!*	ALU FUNC (R AND S) :
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	_______
!*	\S0    AND    \S1
!*	THEN WRITE THE DATA OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
	END;

GLOBAL ROUTINE TST20: NOVALUE =

!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  XOR  S ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!FOUR DATA SETS ARE TESTED FOR THE ( XOR ) FUNCTION :
!	0   XOR   -1
!      -1   XOR    0
!	0   XOR    0
!      -1   XOR   -1
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'6447');				!MODIFY LSRC TO 0A AND FUNCTION TO ( XOR )
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'6007');				!MODIFY LSRC TO AQ
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DADA ?
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'6227');				!MODIFY THE LSRC TO 0Q
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
	MOD_FLD(5,%O'6117');				!MODIFY FUNC TO ( XOR )
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
	IF LOOP_CHK(7)
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
	CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	MOD_FLD(5,%O'6117');				!MODIFY FUNC TO ( XOR )
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
	IF LOOP_CHK(8)
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	ALU FUNC (R XOR S) :
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	\S0    XOR    \S1
!*	THEN WRITE THE DATA OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
	END;

GLOBAL ROUTINE TST21: NOVALUE=

!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  XNOR  S ) .
!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
!GLOBAL ROUTINE FUNC_LD).
!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
!FOUR DATA SETS ARE TESTED FOR THE ( XNOR ) FUNCTION :
!	0   XNOR   -1
!      -1   XNOR    0
!	0   XNOR    0
!      -1   XNOR   -1
!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'7447');				!MODIFY LSRC TO 0A AND FUNCTION TO ( XNOR )
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
	IF LOOP_CHK(2)
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'7007');				!MODIFY LSRC TO AQ
	ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DATA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ 0				!CHECK DADA ?
		THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
	IF LOOP_CHK(4)
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'7227');				!MODIFY THE LSRC TO 0Q
	ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(5)
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(6)
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
	MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
	CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
	MOD_FLD(5,%O'7117');				!MODIFY FUNC TO ( XNOR )
	ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
	IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(7)
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
	CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
	MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
	MOD_FLD(5,%O'7117');				!MODIFY FUNC TO ( XNOR )
	ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
	IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
		THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
	IF LOOP_CHK(8)
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	ALU FUNC (R XNOR S) :
!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
!*	MAGIC # FIELD VIA DBUS & DBM
!*	FOR THE \S2 20 BITS OF THE 2901'S
!*	\S0    XNOR    \S1
!*	THEN WRITE THE DATA OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
	END;

GLOBAL ROUTINE TST22: NOVALUE =

!THIS TEST CHECKS DPE9 DP CRY1 (DPE9) AND SKIP ON CRY1(SKIP = 56) (DPEA).
!DIFFERENT DATA SET TO OUPUT THE 2901'S WHICH WILL SET OR CLEAR DPE9 DP CRY1
!A SKIP ON DP CRY1 IS EXECUTED AND THE RESULT IS VERIFIED BY READING THE 
!NXT CRAM ADRS.THE INSTRUCTIONS RESIDE IN CRAM 2,3 & 4.THEY DO THE FOLLOWING:
!CRAM 2/ PASS A DATA INTO THE Q REGISTER OF THE 2901'S VIA DBUS WHICH 
!	 GETS LOADED FROM THE MAGIC # FIELD VIA DBM.
!CRAM 3/ PASS A SECOND DATA INTO REGISTER 0 USING THE SAME PATH AS IN CRAM 2.
!CRAM 3/ ADD THE TWO DATA WORDS IN REGISTER 0 & Q OF THE 2901'S AND 
!	 SKIP ON DPE9 DP CRY1.
!THE ORED J FIELD WITH THE SKIP BIT IS ALWAYS 4.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3;
	OWN DPCRY1_FLG;
	BIND
	POINTER = PLIT (U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(600000) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_Q_MUL2 U_DBUS_DBM U_N(400000) U,
			U_J(4) U_ALU_ADD U_LSRC_AQ U_SKIP_CRY1 U);
	LOAD_U(2,POINTER);				!LOAD 3 INSTRUCTIONS
	DPCRY1_FLG = 0;
	ER_TAB[0] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);		!NO
			DPCRY1_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'40');				!CHANGE DATA
	ER_TAB[1] = UPLIT (%ASCIZ'LO');			!FRO ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);		!NO
			DPCRY1_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!CHANGE DATA
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(4,0);					!CHANGE DATA
	ER_TAB[0] = UPLIT (%ASCIZ'LO');			!FRO ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB)		!NO
		ELSE IF .DPCRY1_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	DP CRY1 FLAG TEST
!*STIMULUS:
!*	DPE1 DP SIGN IS \S0
!*	DPE2 DP 00 IS \S1
!*	DPE2 CARRY OUT IS \S0
!*	DPE9 DP CRY1 SHOULD BE \S1
!*	WE DO A SKIP IF DP CRY1 IS HI
!*RESPONSE:
!*	GET NXT CRAM ADRS
!]ERROR 1
!]M2901S M2902S SHIFT DBMDBUS DBUSSEL SKIP DPCRY1 NTWK
!]NO ERROR 1
!]DPCRY1 NTWK
	END;

GLOBAL ROUTINE TST23: NOVALUE =

!THIS TEST CHECKS SKIP MIX'S ON 2901'S OUTPUT IN DPEA.
!THIS TEST WILL EXECUTE 1 INSTRUCTION IN CRAM 1 THAT WILL DO THE FOLLOWING:
!CRAM 1/ OUT A DATA WORD FROM 2901'S (PASS TO DP VIA DBUS & DBM) 
!	 THEN SKIP ON DP OUTPUT (SKIP=31,51,52,53)
!AFTER EACH TIME THE INSTRUCTION IS EXECUTED SOME FIELDS ARE MODIFIED 
!TO DO THE NXT SKIP SELECT OR MODIFY DATA WORD
!DATA IS VERIFIED BY READIG THE NXT CRAM ADRS 

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
	      BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	BIND
	POINTER = PLIT (U_ALU_ADD U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SKIP_CRY0 U);
	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(1,0,.RCVDATA,4);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	OUTPUT A 0 ON DP(DPE2 CARRY OUT IS LO)
!*	SKIP IF DPE2 CARRY OUT IS SET (SKIP = 31)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 1
!]M2902S SKIP NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(1,%O'6507');				!MODIFY TO SKIP ON DPE2 CARRY 02
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(2,0,.RCVDATA,4);		!NO
!*MESSAGE 2
!*STIMULUS:
!*	OUTPUT A 0 ON DP(DPE2 CARRY 02 IS LO)
!*	SKIP IF DPE2 CARRY 02 IS SET (SKIP = 51)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 2
!]M2902S SKIP NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'3777');				!MODIFY ALU FUNC TO OR
	MOD_FLD(2,2);					!SKIP ON ADL SIGN
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(3,0,.RCVDATA,4);		!NO
!*MESSAGE 3
!*STIMULUS:
!*	OUTPUT A 0 FROM 2901'S
!*	SKIP IF ADL SIGN (SKIP = 52)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 3
!]SKIP NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,3);					!MODIFY TO SKIP ON ADR SIGN
	DO (0) WHILE
BLOCK4:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(4,0,.RCVDATA,4);		!NO
!*MESSAGE 4
!*STIMULUS:
!*	OUTPUT A 0 FROM 2901'S
!*	SKIP IF ADR SIGN (SKIP = 53)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 4
!]SKIP NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7777');				!MODIFY DATA 
	MOD_FLD(4,%O'77');				!TO -1
	DO (0) WHILE
BLOCK5:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(5,1,.RCVDATA,4);		!NO
!*MESSAGE 5
!*STIMULUS:
!*	OUTPUT A -1 FROM 2901'S
!*	SKIP IF ADR SIGN (SKIP = 53)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 5
!]SKIP NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,2);					!MODIFY TO SKIP ON ADL SIGN
	DO (0) WHILE
BLOCK6:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(6,1,.RCVDATA,4);		!NO
!*MESSAGE 6
!*STIMULUS:
!*	OUTPUT A -1 FROM 2901'S
!*	SKIP IF ADL SIGN (SKIP = 52)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 6
!]SKIP NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,1);					!MODIFY TO SKIP ON CARRY 02
	DO (0) WHILE
BLOCK7:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(7,1,.RCVDATA,4);		!NO
!*MESSAGE 7
!*STIMULUS:
!*	PASS -1 2901'S AND OUTPUT ON DP(DPE2 CARRY 02 IS HI)
!*	SKIP ON DPE2 CARRY 02
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 7
!]M2902S SKIP NTWK
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(1,%O'6307');				!MODIFY TO SKIP ON DPE2 CARRY OUT
	DO (0) WHILE
BLOCK8:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(8,1,.RCVDATA,4);		!NO
!*MESSAGE 8
!*STIMULUS:
!*	PASS -1 FROM 2901'S AND OUTPUT ON DP(DPE2 CARRY OUT IS HI)
!*	SKIP ON DPE2 CARRY OUT
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 8
!]M2902S SKIP NTWK
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST24: NOVALUE =

!THIS TEST CHECKS THE DP HOLD L/R IN THE 2901'S (DP CLOCKS).
!WE LOAD A 0 INTO REGISTER 0 WE WRITE THE DATA OUT TO PHYSICAL MEM AND 
!VERIFY IT.NOW WE PUSH A -1 WITH DP HOLD L/R CLEARED.THIS SHOULD DISABLE 
!WRITING THE 0 INTO REGISTER 0.
!WE EXAMINE MEMORY AGAIN AND VERIFY THAT THE 2901'S DID NOT GET LOADED !WITH THE 0.

	BEGIN
	OWN DPFLG;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT(U_J(2) U_DEST_AD U,
		       U_J(3) U_MEM U_N(11012) U,
		       U_J(1) U_ALU_OR U_MEM U_N(2) U);

	LOAD_U(1,POINTER);
	DPFLG = 0;
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,%O'-1');
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(1,0,.RCVDATA,12);	!NO
			DPFLG = 1;
		     END;
!*MESSAGE 1
!*	DP CLKS TEST
!*STIMULUS:
!*	PUT 0 IN REGISTER 0
!*	THEN WRITE IT OUT TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(6,%O'2000');				!CLEAR DP HOLD L/R
	MOD_FLD(5,%O'7447');
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(0,%O'-1');
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0 				!CHECK DATA
		THEN ERRCA(1,0,.RCVDATA,12)	!NO
		ELSE IF .DPFLG EQL 0
				THEN NOERR(1);
!*MESSAGE 2
!*	DP CLKS TEST
!*STIMULUS:
!*	PUT A 0 IN REGISTER 0
!*	TRY TO WRITE A -1 INTO REGISTER 0
!*	WITH DP HOLD L/R CLEARED 
!*	(IT SHOULDN'T WRITE)
!*	THEN WRITE IT OUT TO MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]DPCLKS M2901S MEMVMA NTWK
!]NO ERROR 1
!]DPCLKS NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST25: NOVALUE =

!THIS TEST CHECKS THE LEFT SHIFT LOGIC MIX ON DPE1 (E704,E705,E706,E702).
!FIRST WE CALL VMA_LD ROUTINE TO MAKE SURE THE VMA IS LOADED WITH 0.
!THEN ALL 10 INSTRUCTIONS NEEDED TO PERFORM THIS TEST ARE LOADED INTO 
!THE CRAM SEQUENTIALY STARTING WITH CRAM LOCATION 1.
!NEXT ALL 8 SHSTYLE SELECTS (NORM,LSHC,ZERO,ONES,ROT,ASHC,ROTC & DIV)
!ARE TESTED ON DPE1.AFTER EACH SHSTYLE SELECT TEST, FIELDS ARE MODIFIED 
!IN CRAM TO SET UP THE REQUIRED INSTRUCTIONS TO BE EXECUTED AND DATA TO 
!BE SHIFTED FOR THE NEXT SHSTYLE TEST.DATA IS ALWAYS PASSED TO AND 
!VERIFIED FROM PHYSICAL MEM 0.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,
	      BLOCK11,BLOCK12,BLOCK13,BLOCK14,BLOCK15,BLOCK16;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(20000) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(20000) U,
			U_J(4) U_ALU_OR U_DEST_Q_MUL2 U,
			U_J(5) U_ALU_OR U_DEST_Q_MUL2 U_MULTI_PREC U,
			U_J(6) U_ALU_OR U_DEST_Q_MUL2 U_MULTI_PREC U,
			U_J(7) U_ALU_OR U_DEST_Q_MUL2 U_MULTI_PREC U,
			U_J(10) U_ALU_OR U_DEST_Q_MUL2 U_NO_CLKL U,
			U_J(11) U_ALU_OR U_DEST_Q_MUL2 U_NO_CLKL U,
			U_J(12) U_ALU_OR U_DEST_Q_MUL2 U_NO_CLKL U_MEM U_N(11002) U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U,
			U_J(7) U_ALU_OR U_LSRC_AB U_SHSTYLE_DIV U_DEST_Q_MUL2 U_DIVIDE U);
	VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
	LOAD_U(1,POINTER);				!LOAD 12 INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(10);						!GIVE 12 OCTAL CLOCKS
	RCVDATA = EM(0);
	IF .RCVDATA NEQ %O'400000000002'		!CHECK DATA
		THEN ERRCA(1,%O'400000000002',.RCVDATA,12)	!NO
		ELSE NOERR (1);
!*MESSAGE 1
!*	SHIFT TEST
!*STIMULUS:
!*	DID A LEFT SHIFT  7 TO REGISTER 0 
!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
!*	INITIAL DATA = 20000,,20000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 1
!*	SHIFT BOTH HALFS LEFT 3 WITH MULTI PRECISION SET
!*	SHIFT RIGHT HALF LEFT 3
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 1
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(10);						!GIVE 12 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400000000000'			!CHECK DATA
		THEN ERRCA(2,%O'400000000000',.RCVDATA,12)	!NO
		ELSE NOERR(1);
!*MESSAGE 2
!*STIMULUS:
!*	DID A LEFT SHIFT  7 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
!*	INITIAL DATA = 20000,,20000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 1
!*	SHIFT BOTH HALFS LEFT 3 WITH MULTI PRECISION SET
!*	SHIFT RIGHT HALF LEFT 3
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 2
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'1050');				!MODIFY SPEC SELECT TO 5
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK3:	BEGIN
	DM(0,0);					!CLEAR MEM
	CP(10);						!GIVE  0LCLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400000000000'			!CHECK DATA
		THEN ERRCA(3,%O'400000000000',.RCVDATA,12);	!NO
!*MESSAGE 3
!*STIMULUS:
!*	DID A LEFT SHIFT  7 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
!*	INITIAL DATA = 20000,,20000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 4
!*	SHIFT RIGHT HALF LEFT 3
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 3
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUTPUT REGISTER 0
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(10);						!GIVE 12 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400000000004'			!CHECK DATA
		THEN ERRCA(4,%O'400000000004',.RCVDATA,12);	!NO
!*MESSAGE 4
!*STIMULUS:
!*	DID A LEFT SHIFT  7 TO REGISTER 0
!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
!*	INITIAL DATA = 20000,,20000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 4
!*	SHIFT RIGHT HALF LEFT 3
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 4
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
	MOD_FLD(0,%O'11');				!MODIFY J FIELD
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'1010');				!MODIFY SHDTYLE TO ZERO
	MOD_FLD(6,%O'2060');				!CLOCK BOTH HALFS
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(4,1);					!MODIFY DATA TO 10000010000
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,%O'20');				!MODIFY DATA TO 200000200000
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400010000000'		!CHECK DATA
		THEN ERRCA(5,%O'400010000000',.RCVDATA,12);	!NO
!*MESSAGE 5
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO REGISTER 0
!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
!*	INITIAL DATA = 200000,,200000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 5
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUTPUT Q
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(8);						!GIVE 10 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400000400000'		!CHECK DATA
		THEN ERRCA(6,%O'400000400000',.RCVDATA,12);	!NO
!*MESSAGE 6
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
!*	INITIAL DATA = 10000,,10000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 6
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'1020');				!MODIFY SHSTYLE TO ONES
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400000400007'		!CHECK DATA
		THEN ERRCA(7,%O'400000400007',.RCVDATA,12);	!NO
!*MESSAGE 7
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
!*	INITIAL DATA = 10000,,10000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 7
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUTPUT REGISTER 0
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(8);						!GIVE 10 OCTALC LOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400010000007'		!CHECK DATA
		THEN ERRCA(8,%O'400010000007',.RCVDATA,12);	!NO
!*MESSAGE 8
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO REGISTER 0
!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
!*	INITIAL DATA = 200000,,200000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 8
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'1030');				!MODIFY SHSTYLE TO ROT
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(4,4);					!CHANGE DATA IN Q TO 40000040000
	SET_C(1);					!SET CRAM ADRS TO 1
	MOD_FLD(4,%O'24');				!CHANGE DATA IN REGISTER 0 TO 240000240000
	DO (0) WHILE
BLOCK9:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400012000002'		!CHECK DATA
		THEN ERRCA(9,%O'400012000002',.RCVDATA,12);	!NO
!*MESSAGE 9
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO REGISTER 0
!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
!*	INITIAL DATA = 240000,,240000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM MEM
!]ERROR 9
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!SET CRAM ADRS TO 12
	MOD_FLD(5,%O'3227');				!OUPUT Q
	SET_C(1);
	DO (0) WHILE
BLOCK10:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'2000002'			!CHECK DATA
		THEN ERRCA(10,%O'2000002',.RCVDATA,12)	!NO
		ELSE NOERR(1);
!*MESSAGE 10
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
!*	INITIAL DATA = 40000,,40000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 10
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'1040');				!MODIFY SHSTYLE TO ASHC
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK11:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'2000000'			!CHECK DATA
		THEN ERRCA(11,%O'2000000',.RCVDATA,12);	!NO
!*MESSAGE 11
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
!*	INITIAL DATA = 40000,,40000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 11
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK12:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400012000002'		!CHECK DATA
		THEN ERRCA(12,%O'400012000002',.RCVDATA,12);	!NO
!*MESSAGE 12
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO REGISTER 0
!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
!*	INITIAL DATA IN Q = 40000,,40000
!*	INITIAL DATA IN REGISTER 0 = 240000,,240000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 12
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'1070');				!MODIFY SHSTYLE TO ROTC
	SET_C(1);					!SET CRAM ADRS TO 1
	DM(0,0);					!CLEAR MEM
	DO (0) WHILE
BLOCK13:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400012000002'		!CHECK DATA
		THEN ERRCA(13,%O'400012000002',.RCVDATA,12);	!NO
!*MESSAGE 13
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO REGISTER 0
!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
!*	INITIAL DATA IN Q = 40000,,40000
!*	INITIAL DATA IN REGISTER 0 = 240000,,240000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 13
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUTPUT Q REGISTER
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK14:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'2000002'			!CHECK DATA
		THEN ERRCA(14,%O'2000002',.RCVDATA,12);	!NO
!*MESSAGE 14
!*STIMULUS:
!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
!*	INITIAL DATA IN Q = 40000,,40000
!*	INITIAL DATA IN REGISTER 0 = 240000,,240000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 14
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(4,%O'200');				!SET DIVIDE BIT
	MOD_FLD(5,%O'3117');				!MODIFY LSRC TO AB
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(4,%O'200');				!SET DIVIDE BIT
	MOD_FLD(0,%O'13');				!GO TO 13
	MOD_FLD(5,%O'3117');				!MODIFY LSRC TO AB
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(6,%O'2020');				!MODIFY NO CLKL
	MOD_FLD(2,%O'1060');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(4,1);					!MODIFY DATA TO 10000010000
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,%O'21');				!MODIFY DATA TO 210000210000
	DO (0) WHILE
BLOCK15:BEGIN
	CP(11);						!GIVE 13 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400000000016'		!CHECK DATA
		THEN ERRCA(15,%O'400000000016',.RCVDATA,12);	!NO
!*MESSAGE 15
!*STIMULUS:
!*	DID A LEFT SHIFT  8 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
!*	INITIAL DATA IN Q = 10000,,10000
!*	INITIAL DATA IN REGISTER 0 = 210000,,210000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 8
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 15
!]M2902S M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
	IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(5,%O'3447');				!MODIFY LS5C TO OUPUT REGISTER 0
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK16:BEGIN
	CP(11);						!GIVE 13 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'400010000004'		!CHECK DATA
		THEN ERRCA(16,%O'400010000004',.RCVDATA,12);	!NO
!*MESSAGE 16
!*STIMULUS:
!*	DID A LEFT SHIFT  8 TO REGISTER 0
!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
!*	INITIAL DATA IN Q = 10000,,10000
!*	INITIAL DATA IN REGISTER 0 = 210000,,210000
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS LEFT 8
!*	THEN OUTPUT THE DATA FROM REGISTER R 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 16
!]M2902S M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
!]NO ERROR 1
!]HCLK NTWK
	IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST26: NOVALUE =

!THIS TEST CHECKS THE RIGHT SHIFT LOGIC MIX ON DPE1.
!FIRST WE CALL VMA_LD ROUTINE TO MAKE SURE THE VMA IS LOADED WITH 0.
!THEN ALL 12 INSTRUCTIONS NEEDED TO PERFORM THIS TEST ARE LOADED INTO 
!THE CRAM SEQUENTIALY STARTING WITH CRAM LOCATION 1.
!NEXT ALL 8 SHSTYLE SELECTS (NORM,ONES,ROT,ASHC,LSHC,DIV,ROTC & ZERO)
!ARE TESTED ON DPE1.AFTER EACH SHSTYLE SELECT TEST, FIELDS ARE MODIFIED 
!IN CRAM TO SET UP THE REQUIRED INSTRUCTIONS TO BE EXECUTED AND DATA TO 
!BE SHIFTED FOR THE NEXT SHSTYLE TEST.DATA IS ALWAYS PASSED TO AND 
!VERIFIED FROM PHYSICAL MEM 0.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,
	      BLOCK11,BLOCK12,BLOCK13,BLOCK14,BLOCK15,BLOCK16;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_PC U_DBUS_DBM U_N(200002) U,
			U_J(3) U_ALU_OR U_A_PC U_B_PC U_DEST_AD_MUL2 U_NO_CLKR U,
			U_J(3) U_ALU_OR U_A_PC U_B_PC U_DEST_AD_MUL2 U_NO_CLKR U,
			U_J(5) U_ALU_OR U_A_PC U_DEST_AD U,
			U_J(6) U_ALU_OR U_A_PC U_DEST_Q_AD U,
			U_J(7) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
			U_J(10) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
			U_J(11) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
			U_J(12) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
			U_J(13) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U_MEM U_N(11002) U,
			U_J(4) U_ALU_OR U_MEM U_N(2) U);
	VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
	LOAD_U(1,POINTER);				!LOAD 4 INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	CP(4);						!PUT DATA IN PC REGISTER
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'20000204000'			!CHECK DATA
		THEN ERRCA(1,%O'20000204000',.RCVDATA,12);	!NO
!*MESSAGE 1
!*	SHIFT TEST
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 1
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEM
	LC(13);						!LOAD CRAM ADR 13
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'20000204000'			!CHECK DATA
		THEN ERRCA(2,%O'20000204000',.RCVDATA,12);	!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 2
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(2,%O'1020');				!MODIFY SHSTYLE TO ONES
	SET_C(4);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'174000204000'		!CHECK DATA
		THEN ERRCA(3,%O'174000204000',.RCVDATA,12);	!NO
!*MESSAGE 3
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 3
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEM
	LC(13);						!LOAD CRAM ADRS 13
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'174000204000'		!CHECK DATA
		THEN ERRCA(4,%O'174000204000',.RCVDATA,12);	!NO
!*MESSAGE 4
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 4
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(2,%O'1030');				!MODIFY SHSTYLE TO ROT
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!CHECK DATA
	IF .RCVDATA NEQ %O'40000204000'		!CHECK DATA
		THEN ERRCA(5,%O'40000204000',.RCVDATA,12);	!NO
!*MESSAGE 5
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 5
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEM
	LC(13);						!LOAD CRAM ADRS  13
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
		THEN ERRCA(6,%O'40000204000',.RCVDATA,12);	!NO
!*MESSAGE 6
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 6
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEM
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(2,%O'1040');				!MODIFY SHSTYLE TO ASHC
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
		THEN ERRCA(7,%O'40000204000',.RCVDATA,12);	!NO
!*MESSAGE 7
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 7
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(13);						!LOAD CRAM ADRS 14
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUTPUT REGISTER 0
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'20000204000'			!CHECK DATA
		THEN ERRCA(8,%O'20000204000',.RCVDATA,12);	!NO
!*MESSAGE 8
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 8
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(2,%O'1050');				!MODIFY SHSTYLE TO LSHC
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK9:	BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'204000'			!CHECK DATA
		THEN ERRCA(9,%O'204000',.RCVDATA,12);	!NO
!*MESSAGE 9
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 9
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(13);						!SET CRAM ADRS TO 13
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK10:BEGIN
	CP(8);						!GIVE 10OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
		THEN ERRCA(10,%O'40000204000',.RCVDATA,12);	!NO
!*MESSAGE 10
!*	STIMULUS :
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 10
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEM
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(2,%O'1060');				!MODIFY SHSTYLE TO DIV
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK11:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'40000204000'		!CHECK DATA
		THEN ERRCA(11,%O'40000204000',.RCVDATA,12);	!NO
!*MESSAGE 11
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 11
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(13);						!LOAD CRAM ADRS 13
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK12:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'174000204000'		!CHECK DATA
		THEN ERRCA(12,%O'174000204000',.RCVDATA,12);	!NO
!*MESSAGE 12
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 12
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEM
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(2,%O'1070');				!MODIFY SHSTYLE TO ROTC
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK13:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
		THEN ERRCA(13,%O'40000204000',.RCVDATA,12);	!NO
!*MESSAGE 13
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 13
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	DM(0,0);					!CLEAR MEM
	LC(13);						!LOAD CRAM ADRS 13
	MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK14:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
		THEN ERRCA(14,%O'40000204000',.RCVDATA,12);	!NO
!*MESSAGE 14
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 14
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
	LC(7);						!LOAD CRAM ADRS 7
	MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
	LC(10);						!LOAD CRAM ADRS 10
	MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
	LC(11);						!LOAD CRAM ADRS 11
	MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
	LC(12);						!LOAD CRAM ADRS 12
	MOD_FLD(2,%O'1010');				!MODIFY SHSTYLE TO ZERO
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,%O'40');				!MODIFY DATA TO 400000400000
	CP(4);						!PUT DATA IN PC REGISTER
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK15:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'270000'			!CHECK DATA
		THEN ERRCA(15,%O'270000',.RCVDATA,12);	!NO
!*MESSAGE 15
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y0 = DPE1 DP SIGN H, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 15
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(13);						!LOAD CRAM ADRS 13
	MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
	SET_C(4);					!SET CRAM ADRS TO 4
	DO (0) WHILE
BLOCK16:BEGIN
	CP(8);						!GIVE 10 OCTAL CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'600000270000'		!CHECK DATA
		THEN ERRCA(16,%O'600000270000',.RCVDATA,12);	!NO
!*MESSAGE 16
!*STIMULUS:
!*	DID A RIGHT SHIFT 5 TO REGISTER 0
!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
!*	(Y0 = DPE1 DP SIGN H, IS ALSO SET IN BOTH REGISTERS)
!*	THE FOLLOWING WAS CLOCKED :
!*	SHIFT BOTH HALFS RIGHT 5
!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 16
!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
	IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST27: NOVALUE =

!THIS A TEST FOR THE INHIBIT CARRY INTO LEFT HALF.
!ALL 7 INSTRUCTIONS REQUIRED TO PERFORM THIS TEST ARE LOADED
!SEQUENTIALLY INTO THE CRAM STARTING WITH CRAM LOCATION 1.
!ALL 7 INSTRUCTIONS ARE EXECUTED TWICE.THE INSTUCTIONS DO THE FOLLOWING:
!CRAM 1/ PUT A 0 IN BOTH HALFS OF REGISTER 0
!CRAM 2/ PUT 700000 IN RIGHT HALF OF REGISTER 0
!CRAM 3/ ADD THE CONTENTS OF REGISTER 0 TO ITSELF
!CRAM 4/ ADD THE CONTENTS OF REGISTER 0 TO ITSELF
!CRAM 5/ ADD THE CONTENTS OF REGISTER 0 TO ITSELF
!CRAM 6/ START A MEM WRITE CYCLE
!CRAM 7/ FINISH MEM WRITE CYCLE BY OUTPUTTING THE CONTENTS OF REGISTER 0 TO MEM.
!THE SECOND TIME THE INSTRUCTIONS ARE EXECUTED CRAM 4 IS MODIFIED TO 
!CONTAIN SPEC SELECT = 40 (INHIBIT CARRY INTO LEFT HALF).ALL DATA IS PASSED
!TO AND VERIFIED FROM PHYSICAL MEM 0.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_DEST_AD U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(700000) U_NO_CLKL U,
			U_J(4) U_ALU_ADD U_LSRC_AB U_DEST_AD U,
			U_J(5) U_ALU_ADD U_LSRC_AB U_DEST_AD U,
			U_J(6) U_ALU_ADD U_LSRC_AB U_DEST_AD U,
			U_J(7) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);

	LOAD_U(1,POINTER);				!LOAD 7 INSTRUCTIONS
	TEST_FLG = 0;
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(7);						!GIVE 7 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'7000000'			!CHECK DATA
		THEN BEGIN
			ERRCA(1,%O'7000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 1
!*	DP CRY TEST
!*STIMULUS:
!*	PUT 700000 IN REGISTER 0
!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF 3 TIMES
!*	FINALLY OUTPUT THE CONTENTS OF REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 1
!]M2902S SPEC18CRY NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(1,%O'6747');				!MODIFY SPEC TO INHIBIT CARY
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(7);						!GIVE 7 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'5000000'			!CHECK DATA
		THEN ERRCA(2,%O'5000000',.RCVDATA,12)!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
!*MESSAGE 2
!*STIMULUS:
!*	PUT 700000 IN REGISTER 0
!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF ONCE
!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF AGAIN WITH SPEC FIELD = 40 (CARRY INHIBIT)
!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF A THIRD TIME
!*	FINALLY OUTPUT THE CONTENTS OF REGISTER 0 TO MEM
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 2
!]M2902S SPEC18CRY NTWK
!]NO ERROR 1
!]SPEC18CRY NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST28: NOVALUE =

!THIS TEST CHECKS ADL=0 & ADR=0 OUTPUTS OF THE 2901'S AS WELL AS THE 
!SKIP SELECTS ON THOSE BITS.
!THIS TEST WILL EXECUTE 1 INSTRUCTION IN CRAM 1. THE J FIELD OF THIS
!INSTRUCTION IS 0. IF THE INSTRUCTION SKIPS THE NXT CRAM ADRS BECOMES A 1
!AFTER EACH TIME THE INSTRUCTION IS EXECUTED SKIP SELECT IS MODIFIED 
!TO SELECT A DIFFERENT SET OF CONDITIONS FOR THE SKIP SELCT.
!THE NXT CRAM ADRS IS ALWAYS CHECKED AND VERIFIED.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
	BIND
	POINTER = PLIT (U_ALU_XOR U_LSRC_AB U_SKIP_ADREQ0 U);

	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	ER_TAB[0] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'ADR');		!FOR ERROR PRINTOUT
	ER_TAB[2] = 0;					!FOR ERROR PRINTOUT
	TEST_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,2);					!MODIFY TO SKIP ON ADL=0
	ER_TAB[1] = UPLIT (%ASCIZ'ADL');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(1,%O'6607');				!MODIFY TO SKIP ON ADEQ0
	ER_TAB[1] = UPLIT(%ASCIZ'ADEQ0 ');		!FOR ERROR
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GT NXT ADRS
	IF .RCVDATA NEQ 1
		THEN BEGIN
			ERRCAS(2,1,1,.RCVDATA,4,ER_TAB);
			TEST_FLG = 1;
		    END;
	IF LOOP_CHK(3)
		THEN LEAVE BLOCK3 WITH 1;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(5,%O'7117');				!CHANGE DATA TO A -1
	ER_TAB[0] = UPLIT (%ASCIZ'NOT ');		!FOR ERROR PRINTOUT
	ER_TAB[2] = -1;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(2,1,0,.RCVDATA,4,ER_TAB)	!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 0
		    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(1,%O'6307');				!MODIFY TO SKIP ON ADL
	ER_TAB[1] = UPLIT (%ASCIZ'ADL');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 0
		    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,3);					!SKIP ON ADR
	ER_TAB[1] = UPLIT(%ASCIZ'ADR ');		!FOR ERROR
	DO (0) WHILE
BLOCK6:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK
	IF .RCVDATA NEQ 0
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);
	IF LOOP_CHK(6)
		THEN BEGIN
			SET_C(0);
			LEAVE BLOCK6 WITH 1;
		     END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	DP TEST
!*STIMULUS:
!*	OUTPUT \O2 FROM BOTH HALF OF THE 2901'S
!*	THEN SKIP IF \S1 = 0
!*	THE CURRENT J FIELD IS 0
!*	IT SHOULD \S0SKIP
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]NO ERROR 1
!]ADEQ0 NTWK
!]ERROR 1
!]SKIP NTWK
!]ERROR 2
!]ADEQ0 NTWK
	END;
	
GLOBAL ROUTINE TST29: NOVALUE =

!THIS TEST CHECKS ALL THE BYTE DISPATCH LOGIC ON DPE3.
!THIS TEST WILL SIMPLY PASS A DATA WORD FROM THE MAGIC # FIELD ONTO
!BOTH HALFS OF DP VIA DBUS. AND DO A BYTE DISPATCH.
!AFTER THIS EXECUTION WHICH RESIDES IN CRAM 0 WITH THE ORED J FIELD = 0
!WE EXAMINE THE NXT CRAM ADRS AND VERIFY IT.
!AFTER EACH EXECUTION THE # FIELD IS MODIFIED IN THE CRAM TO SET UP THE
!DATA WORD TO BE PUSHED ONTO DP.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,
	      BLOCK7,BLOCK8,BLOCK9,BLOCK10,BLOCK11,BLOCK12,
	      BLOCK13,BLOCK14,BLOCK15,BLOCK16,BLOCK17,BLOCK18,BLOCK19;
	BIND
	POINTER = PLIT (U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DISP_BYTE U_N(27000) U);

	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	ER_TAB[0] = %O'27000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,2);					!MODIFY DP TO 37000
	ER_TAB[0] = %O'37000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,4);					!DP GETS 47000
	ER_TAB[0] = %O'47000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,7);					!DP GETS 77000
	ER_TAB[0] = %O'77000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!DP GETS 7000
	ER_TAB[0] = %O'7000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,5);					!DP GETS 57000
	ER_TAB[0] = %O'57000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,6);					!DP GETS 67000
	ER_TAB[0] = %O'67000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,1);					!DP GETS 17000
	ER_TAB[0] = %O'17000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'300');				!DP GETS 10300
	ER_TAB[0] = %O'10300';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'500');				!DP GETS 10500
	ER_TAB[0] = %O'10500';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK10:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'600');				!DP GETS 10600
	ER_TAB[0] = %O'10600';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK11:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'700');				!DP GETS 10700
	ER_TAB[0] = %O'10700';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK12:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 7				!CHECK DATA
		THEN ERRCAS(1,1,7,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'4700');				!DP GETS 14700
	ER_TAB[0] = %O'14700';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK13:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'2700');				!DP GETS 12700
	ER_TAB[0] = %O'12700';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK14:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'1700');				!DP GETS 11700
	ER_TAB[0] = %O'11700';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK15:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'700');				!DP GETS
	MOD_FLD(4,%O'10');				!100700
	ER_TAB[0] = %O'100700';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK16:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'17');				!DP GETS 170700
	ER_TAB[0] = %O'170700';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK17:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(17)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK17 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'26');				!DP GETS 260700
	ER_TAB[0] = %O'260700';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK18:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 2				!CHECK DATA
		THEN ERRCAS(1,1,2,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(18)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK18 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'35');				!DP GETS 350700
	ER_TAB[0] = %O'350700';			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK19:BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(19)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK19 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	BYTE DISP LOGIC TEST (DPE3)
!*STIMULUS:
!*	PASS A DATA WORD FROM THE MAGIC # FIELD (\O0)
!*	TO BOTH HALFS OF DP VIA DBUS.
!*	DO A BYTE DISPATCH
!*	EXAMINE NXT CRAM ADRS
!*RESPONSE:
!]ERROR 1
!]BITE NTWK
	END;

GLOBAL ROUTINE TST30: NOVALUE =

!THIS TEST CHECKS ALL THE DBUS MIX'S FOR DBUS SELCT = 0 GROUNDED PINS
!BITS (7,8,13,14,15,16,17 & 18) AS WELL AS THE DBUS PARITY INPUT FOR SELECT 0.
!WE EXECUTE 2 INSTRUCTIONS IN CRAM 1 & 2 DOING THE FOLLOWING:
!CRAM 1/START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A ZERO
!CRAM 2/ FINISH THE MEM CYCLE AND OUTPUT THE DBUS (DBUS SELECT = 0) INTO
!	 MEM VIA THE 2901'S.
!THE DATA IS THEN READ FROM MEM AND ALL THE BITS IN SUBJECT ARE TESTED !FOR LO.ANY DISCREPANCY WILL YIELD AN ERROR.
!CRAM 3/ SELECT DBUS INPUT 0 (PC,FLGS,PI NEW) AND CHKL/R HALFS OF DBUS.
!	 (WE SHOULD NEVER GET A PARITY ERROR).
	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3;
	BIND
	POINTER = PLIT (U_J(2) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U,
			U_J(3) U_DBUS_PC_FLAGS U_CHKL U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'3037400000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(1,0,.RCVDATA,12);		!NO
			PCDBUS_FLG = 1;
		     END
		ELSE IF .DBMDBUS_FLG EQL 0
		THEN NOERR(1);
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	DBUS TEST
!*STIMULUS:
!*	DBUS SELECT 0 GROUND PINS (DPE3 & 4)
!*	START A MEM CYCLE & LOAD THE VMA WITH 0
!*	FINISH MEM CYCLE AND OUTPUT DATA FROM DBUS (DBUS SELECT = 0)
!*	INTO MEM VIA DP
!*	ALL TESTED PINS SHOULD BE LO
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]PCDBUS DBUSSEL NTWK
!]NO ERROR 1
!]DBUSSEL NTWK
	SET_C(3);					!SET CRAM ADRS TO 3
	ER_TAB[0] = UPLIT(%ASCIZ'LEFT');		!FOR ERROR
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = RD_100;				!GET THE DATA
	IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
		THEN ERRCAS(2,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;
	MOD_FLD(7,%O'4304');				!MODIFY TO CHKR
	ER_TAB[0] = UPLIT(%ASCIZ'RIGHT');		!FOR ERROR
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = RD_100;				!GET THE DATA
	IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
		THEN ERRCAS(3,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 2
!*STIMULUS:
!*	DBUS PARITY SELECT 0
!*	CHECK \S0 HALF OF DBUS PAR WITH DBUS SELECT = 0
!*	READ BACK REGISTER 101 AND CHK PARITY BIT
!*	DBUS SELECT 0 PARITY INPUTS SHOULD BE GROUNDED
!*	PARITY ERROR SHOULD NEVER OCCUR
!*RESPONSE:
!]ERROR 2
!]PE DBUSSEL DBUSPL NTWK
!]ERROR 3
!]PE DBUSSEL DBUSPR NTWK
	END;

GLOBAL ROUTINE TST31: NOVALUE =

!THIS TEST CHECKS ALL THE DBUS MIX'S FOR SLECT = 1 (DP).
!WE EXECUTE 4 INSTRUCTIONS WITH 2 DATA SETS 0'S AND 1'S.
!THE INSTRUCTIONS WILL DO THE FOLLOWING:
!CRAM 1/ PASS THE DATA WORD INTO REGISTER 0 OF THE 2901'S VIA DBUS,DBM & MAGIG # FIELD
!CRAM 2/ OUTPUT REGISTER 0 ONTO DP THEN WRITE BACK TO REGISTER 1 VIA 
!	 DBUS (DBUS SELECT = 1).
!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A ZERO
!CRAM 4/ FINISH THE MEM CYCLE AND OUTPUT REGISTER 1 INTO MEMORY.
!THE DATA IS THEN READ AND VERIFIED FROM MEM.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	OWN DPDBUS_FLG;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_A U_B_PC U,
			U_J(4) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_A_PC U_MEM U_N(2) U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
	DPDBUS_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
			DPDBUS_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7777');				!CHANGE DATA
	MOD_FLD(4,%O'77');				!TO -1
	ER_TAB[0] = %O'-1';					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB)	!NO
		ELSE IF .DPDBUS_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	DBUS TEST
!*STIMULUS:
!*	DBUS MIX'S SELECT 1 (DPE3 & 4)
!*	LOAD THE 2901'S REGISTER 0 WITH A \O0
!*	OUTPUT REGISTER 0 ONTO DP AND WRITE IT BACK TO 
!*	REGISTER 1 FROM DBUS (DBUS SELECT = 1)
!*	START AND FINISH A MEM CYCLE OUTPUTING THE CONTENTS 
!*	OF REGISTER 1 INTO PHYSICAL MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]DBMDBUS DPDBUS DBUSSEL NTWK
!]NO ERROR 1
!]DPDBUS NTWK
	END;

GLOBAL ROUTINE TST32: NOVALUE =

!THIS TEST CHECKS THE 10 BIT VMA COPY FLOPS ON DPE5.
!THIS TEST WILL EXECUTE 3 INSTRUCTIONS FOR EACH DATA SET TESTED (0'S & 1'S).
!THE INSTRUCTIONS WILL DO THE FOLLOWING:
!CRAM 1/ PASS THE DATA SET INTO REGISTER 0 OF THE 2901'S VIA DBUS,DBM 
!	 AND THE MAGUC # FIELD.
!CRAM 2/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP, START A PHYSICAL MEM
!	 WRITE CYCLE AND LOAD THE VMA FROM DP (INCLUDING 10 BIT COPY ON DPE5).
!CRAM 3/ FINISH THE MEM CYCLE AND OUTPUT THE CONTENTS OF THE DBUS INTO 
!	 PHYSICAL LOCATION OF MEMORY SPECIFIED BY THE VMA, DBUS SELECT = 0
!	 (DBUS INCLUDES THE 10 BIT VMA COPY).
!DATA IS THEN READ AND VERIFIED FROM MEM THE 10 BIT VMA COPY SHOULD BE !ON BITS 26 - 35.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
			U_J(3) U_ALU_OR U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	TEST_FLG = 0;
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
	ER_TAB[1] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,%O'-1');					!SET MEM 0 TO ONES
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'1777';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN 
			ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
			PCDBUS_FLG = 1;
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'1777');				!SET DATA TO 1777
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	ER_TAB[1] = %O'1777';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	DM(1777,0);					!CLEAR MEM LOCATION 1777
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(1777);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'1777';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'1777'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'1777',.RCVDATA,12,ER_TAB);	!NO
			PCDBUS_FLG = 1;
		     END
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
!*MESSAGE 1
!*	10 BIT VMA COPY TEST
!*STIMULUS:
!*	10 BIT VMA COPY TEST (DPE5)
!*	DEPOSIT \O0 IN MEM \O1
!*	START A MEM CYCLE AND LOAD THE VMA WITH A \O1
!*	FINISH MEM CYCLE AND OUTPUT DBUS TO MEM VIA DP (DBUS SELECT = 0)
!*	DBUS SHOULD INCLUDE 10 BIT VMA COPY (26-35)
!*RESPONSE:
!]ERROR 1
!]TBVMACPY PCDBUS BCLK CCLK NTWK
!]NO ERROR 1
!]TBVMACPY BCLK CCLK NTWK
	END;

GLOBAL ROUTINE TST33: NOVALUE =

!THIS TEST CHECKS THE DISP MIX ON DPEA,(COMBINED WITH DROM TESTS ).
!THIS TEST CHECKS DISP = 31,34,35.
!FOR EACH OF THE THREE DISP TYPES IT DOES THE FOLLOWING:
!  PASS A DATA FROM THE MAGIC # FIELD INTO DBM,THEN PASS IT TO 
!  DBUS AND FROM THERE PASS THROUGH THE 2901'S INTO DP.DISP IS EXECUTED
!  DEPENDING ON DP CONTENTS.WE PASS 2 DATA WORDS INTO DP FOR EACH DISP TYPE,
!  0'S & 1'S.AFTER EACH DATA PASS THEN DISP THE NEXT CRAM ADRS IS READ AND VERIFIED.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
	BIND
	POINTER = PLIT (U_J(0) U_ALU_OR U_LSRC_D0 U_DISP_DP U_DBUS_DBM U_N(777777) U);
	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
	ER_TAB[1] = %O'35';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'17'				!CHECK IT
		THEN ERRCAS(1,1,%O'17',.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,%O'400');				!MODIFY DISP TO TO NORM
	ER_TAB[1] = %O'34';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
	IF (.RCVDATA AND %O'10') EQL %O'10'
		THEN ERRCAS(2,1,7,.RCVDATA,4,ER_TAB)	!NO
		ELSE IF (.RCVDATA AND 7) NEQ 7		!CHECK DATA
			THEN ERRCAS(1,1,7,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,%O'100');				!MODIFY DISP TO DP LEFT (DP 18-21)
	ER_TAB[1] = %O'31';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'17'				!CHECK DATA
		THEN ERRCAS(1,1,%O'17',.RCVDATA,4,ER_TAB);!NO
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,0);					!CHANGE THE # FIELD
	MOD_FLD(4,0);					!TO ZERO
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,%O'400');				!CHAGE DISP TO NORMAL
	ER_TAB[1] = %O'34';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
	IF (.RCVDATA AND %O'10') EQL 0
		THEN ERRCAS(2,1,%O'10',.RCVDATA,4,ER_TAB)!NO
		ELSE IF (.RCVDATA AND 7) NEQ 0		!CHECK IT
			THEN ERRCAS(1,1,%O'10',.RCVDATA,4,ER_TAB);!NO
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(2,%O'500');				!MODIFY DISP TO DP (DP 32-35)
	ER_TAB[1] = %O'35';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK6 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	DISP ON OUTPUT OF DP
!*STIMULUS:
!*	DID A DISP = \O1
!*	DP = \U0, CRAM J = 0
!*	WE GET NXT CRAM ADRS 
!*RESPONSE:
!]ERROR 1
!]DISP NTWK
!]ERROR 2
!]ADEQ0 DISP NTWK
	END;

GLOBAL ROUTINE TST34: NOVALUE =

!THIS TEST CHECKS THE PI REQ LEVELS.
!ONE INSTRUCTION IS EXECUTED TWICE FOR EACH PI LEVEL.AFTER EACH EXECUTION
!FIELDS ARE MODIFIED TO TEST THE NEXT PI LEVEL.THE INSTRUCTION RESIDE 
!IN CRAM 1, AND WILL DO THE FOLLOWIN:
!CRAM 1/ SET APR ENABLES, WHICH SETS APR INT REQ.AT THIS TIME DP SHOULD 
!	 CONTAIN PI LEVEL REQUEST(DP33,34,35)AND APR ENABLES (DP 32)
!	 WE GET THE DATA NEEDED ON THE DP THROUGH THE FOLLOWING PATH:
!		PASS THE DATA FROM THE MAGIG # FIELD INTO DBM.
!		PASS DATA FROM DBM INTO DBUS.
!		PASS DATA FROM DBUS THROUGH THE 2901'S INTO DP.
!	(THIS INSTRUCTION IN CRAM 2 IS EXECUTED TWICE).
!	AFTER THIS EXECUTION THE PI LEVEL REQUESTED SHOULD BE SET.WE 
!	READ AND VERIFY THE PENDING PI REQUEST BY READING REGISTER 101.

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_SPEC_APR_EN U_DBUS_DBM U_N(10) U);
	LOAD_U(1,POINTER);				!LOAD 2 INSTRUCTIONS
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,0,.RCVDATA,3,ER_TAB);	!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'11');				!SET PI REQ 1
	ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET DATA
	IF .RCVDATA NEQ %O'200'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'200',.RCVDATA,3,ER_TAB);!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'12');				!SET PI REQ 2
	ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI LEVEL FROM REG 101
	IF .RCVDATA NEQ %O'100'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'100',.RCVDATA,3,ER_TAB);!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'13');				!SET PI REQ 3
	ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ FROM REG 101
	IF .RCVDATA NEQ %O'40'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'40',.RCVDATA,3,ER_TAB);!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'14');				!SET PI LEVEL 4
	ER_TAB[0] = 4;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ FROM REG 101
	IF .RCVDATA NEQ %O'20'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'20',.RCVDATA,3,ER_TAB);!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'15');				!SET PI LEVEL 5
	ER_TAB[0] = 5;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ FROM REG 101
	IF .RCVDATA NEQ %O'10'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'10',.RCVDATA,3,ER_TAB);!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'16');				!SET PI LEVEL 6
	ER_TAB[0] = 6;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ FROM REG 101
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,4,.RCVDATA,3,ER_TAB);	!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'17');				!SET PI LEVEL 7
	ER_TAB[0] = 7;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ FROM REG 101
	IF .RCVDATA NEQ 2				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,2,.RCVDATA,3,ER_TAB);	!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,7);					!SET PI LEVEL 7
	ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:	BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ FROM REG 101
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,0,.RCVDATA,3,ER_TAB);	!NO
			PIBUS_FLG = 1;
		     END;
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'17');				!SET PI LEVEL 7
	MOD_FLD(1,%O'6707');				!CLEAR
	MOD_FLD(2,0);					!APR EN
	ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK10:BEGIN
	CP(2);						!GIVE 2 CLOCKS
	RCVDATA = RD_101;				!GET PI REQ FROM REG 101
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,3,ER_TAB)	!NO
		ELSE IF .PIBUS_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	BUS PI TEST
!*STIMULUS:
!*	DP 33 - 35 = \O0
!*	DPE5 SPEC/APR EN IS \S1
!*	DPMB APR INT REQ IS \S2
!*	READ THE 8080'S REGISTER 101
!*	(BITS 7-1 CONTAIN BUS PI LEVEL 1-7)
!*RESPONCE:
!]ERROR 1
!]CCLK SPECAPR PIBUS NTWK
!]NO ERROR 1
!]CCLK PIBUS NTWK
	END;

GLOBAL ROUTINE TST35: NOVALUE =

!THIS TEST CHECKS THE PRIORITY INTERRUPT ENCODER ON DPEB, ALL PI 
!SOFT REQUEST LEVELS AND OR GATES.
!THIS TEST IS VERIFIED BY EXECUTING 3 INSTRUCTIONS IN CRAM 1,2 & 3.
!ALL LEVELS OF PI SOFT REQUESTS ARE SELECTED TO INPUT THE ENCODER THROUGH 
!THE OR GATES AFTER WHICH WE WILL GET A PI NEW AT THE OUTPUT OF THE ENCODER.
!ALL OTHER INPUTS TO THE OR GATES ARE ALWAYS HI.WE VERIFY THE OUTPUT OF 
!THE ENCODER (PI NEW) BY PASSING IT THROUGH THE DBUS MUX (DBUS SELECT = 0)
!AND WRITING IT IN THE 2901'S.FROM THERE THE DATA IS WRITTEN OUT TO 
!PHYSICAL MEMORY, READ AND VERIFIED.THIS TEST WILL CALL A ROUTINE VMA_LD 
!WHICH WILL LOAD THE VMA WITH A 0.THE INSTRUCTIONS IN THE CRAM WILL
!DO THE FOLLOWING:
!CRAM 1/ PASS THE REQUIRED DATA TO SELECT PI LEVEL FROM THE MAGIC 
!	 # FIELD INTO DBM.PASS THE DATA FROM DBM INTO DBUS.FINALLY PUT 
!	 THE DATA ON DP PASSING IT FROM DBUS THROUGH THE 2901'S.AND 
!	 LOAD PI SYSTEM AT THE SAME TIME(SPEC SELECT 43).
!CRAM 2/ START A MEM WRITE CYCLE.LOAD THE PI SYSTEM (SPEC SELECT 43).
!	 SELECT DBUS TO GET PI NEW.WRITE THE CONTENTS OF THE DBUS IN 
!	 REGISTER 0 OF THE 2901'S.
!CRAM 3/ FINISH MEM WRITE CYCLE BY OUTPUTING THE CONTENTS OF REGISTER 0 
!	 INTO MEMORY LOCATION SPECIFIED BY THE VMA (VMA = 0).

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_N(777777) U_SPEC_LDPI U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_PI_NEW U_MEM U_N(11002) U_SPEC_LDPI U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);

	VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
	LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	ER_TAB[1] = %O'777777';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7577');				!MODIFY PI SOFT REQ LEVEL TO 7
	ER_TAB[0] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
	ER_TAB[1] = %O'777577';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7400');				!MODIFY PI SOFT REQ TO BE 1
	ER_TAB[1] = %O'777400';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'40000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'40000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7500');				!FORCE SOFT PI REQ LEVEL OF 2
	ER_TAB[1] = %O'777500';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'100000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'100000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
		     END;
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7540');				!MODIFY TO PI LEVEL OF 3
	ER_TAB[1] = %O'777540';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'140000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'140000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
			PCDBUS_FLG = 1;
		     END;
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7560');				!MODIFY PI LEVEL TO 4
	ER_TAB[1] = %O'777560';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'200000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'200000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
			PCDBUS_FLG = 1;
		     END;
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7570');				!MODIFY PI TO 5
	ER_TAB[1] = %O'777570';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'240000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'240000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
		     END;
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7574');				!MODIFY PI TO 6
	ER_TAB[1] = %O'777574';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'300000'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'300000',.RCVDATA,12,ER_TAB);	!NO
			PISOFT_FLG = 1;
		     END;
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'7576');				!MODIFY PI TO 7
	ER_TAB[1] = %O'777576';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:	BEGIN
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB)	!NO
		ELSE IF .PISOFT_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	PI SOFT TEST
!*STIMULUS:
!*	DPEB PI ON IS \S0
!*	BOTH HALFS OF DP CONTAIN \O1
!*	LOAD PI SYSTEM, THEN READ PI NEW THROUGH THE DBUS OUT TO MEM
!*RESPONSE:
!*	EXAMINE THE CONTENTS OF THE DBUS (BITS 19-21 CONTAIN PI NEW)
!]ERROR 1
!]CCLK BCLK PCDBUS PINEW PISOFT SPECPI ORPI NTWK
!]NO ERROR 1
!]PISOFT BCLK CCLK NTWK
	END;

GLOBAL ROUTINE TST36: NOVALUE =

!THIS TEST CHECKS PI ACTIVE AND PI REQ FLOPS ON DPEB AS WELL 
!AS THE AND GATES .
!THIS TEST IS VERIFIED BY EXECUTING 6 INSTRUCTIONS IN CRAM 1,2,2,3,4,5 & 6.
!ALL POSSIBLE COMBINATIONS OF PI ACTIVE AND BUS PI REQUESTS ARE TESTED
!TO VERIFY THE AND GATES.AT THE OUPUT OF THE AND GATES ALL OTHER INPUTS 
!TO THE OR GATES ARE ALWAYS HI.WE VERIFY THE OUTPUT OF THE ENCODER 
!(PI NEW) BY PASSING IT THROUGH THE DBUS MUX (DBUS SELECT = 0)
!AND WRITING IT IN THE 2901'S.FROM THERE THE DATA IS WRITTEN OUT TO 
!PHYSICAL MEMORY, READ AND VERIFIED.THIS TEST WILL CALL A ROUTINE VMA_LD 
!WHICH WILL LOAD THE VMA WITH A 0.THE INSTRUCTIONS IN THE CRAM WILL
!DO THE FOLLOWING:
!CRAM 1 & 2/ THE TWO INSTRUCTIONS WILL SET UP THE REQUIRED BUS PI 
!	     REQUEST (SEE TEST BUS PI REQUEST).
!CRAM 3/ THIS INSTRUCTION WILL SET UP THE REQUIRED DATA TO SELECT PI ACTIVE.
!CRAM 4/ OUPUT THE REQUIRED DATA ONTO THE DP. LOAD THE PI.
!CRAM 5/ START A MEM WRITE CYCLE.LOAD THE PI SYSTEM (SPEC SELECT 43).
!	 SELECT DBUS TO GET PI NEW.WRITE THE CONTENTS OF THE DBUS IN 
!	 REGISTER 0 OF THE 2901'S.
!CRAM 3/ FINISH MEM WRITE CYCLE BY OUTPUTING THE CONTENTS OF REGISTER 0 
!	 INTO MEMORY LOCATION SPECIFIED BY THE VMA (VMA = 0).
	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
	      BLOCK5,BLOCK6,BLOCK7,BLOCK8,
	      BLOCK9,BLOCK10,BLOCK11,BLOCK12,
	      BLOCK13,BLOCK14,BLOCK15;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_SPEC_APR_EN U_DBUS_DBM U_N(10) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_SPEC_APR_EN U_DBUS_DBM U_N(10) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
			U_J(5) U_ALU_OR U_LSRC_D0 U_RSRC_0A U_DBUS_DBM U_N(777777) U_SPEC_LDPI U,
			U_J(6) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_PI_NEW U_MEM U_N(11002) U_SPEC_LDPI U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);
	VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'777777');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'177');				!MODIFY PI ACTIVE TO NONE
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'11');				!REQUEST BUS PI LEVEL 1
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'177,,777777');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'12');				!REQUEST PI LEVEL 2
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'13');				!REQUEST PI LEVEL 3
	ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'14');				!REQUEST PI LEVEL 4
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 4;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'15');				!REQUEST PI LEVEL 5
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 5;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'16');				!REQUEST PI LEVEL 6
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 6;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'17');				!REQUEST PI LEVEL 7
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 7;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!MODIFY PI ACTIVE TO 7
	ER_TAB[1] = UPLIT (%ASCIZ'777777');		!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
BLOCK9:	BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'340000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'16');				!REQUEST PI LEVEL 6
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(3,%O'16');				!REQUEST PI LEVEL 6
	ER_TAB[0] = 6;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK10:BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'300000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'300000',.RCVDATA,12,ER_TAB);!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'15');				!REQUEST PI LEVEL 5
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 5;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK11:BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'240000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'240000',.RCVDATA,12,ER_TAB);!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'14');				!MODIFY REQUEST TO PI LEVEL 4
	ER_TAB[0] = 4;					!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK12:BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'200000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'200000',.RCVDATA,12,ER_TAB);!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'13');				!MODIFY REQUEST TO PI LEVEL 3
	ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK13:BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'140000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'140000',.RCVDATA,12,ER_TAB);!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'12');				!MODIFY REQUEST TO PI LEVEL 2
	ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK14:BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'100000'			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'100000',.RCVDATA,12,ER_TAB);!NO
			PIACTV_FLG = 1;
		     END;
	IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'11');				!MODIFY REQUEST TO PI LEVEL 1
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK15:BEGIN
	CP(6);						!GIVE 6 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'40000'			!CHECK DATA
		THEN ERRCAS(1,1,%O'40000',.RCVDATA,12,ER_TAB)	!NO
		ELSE IF .PIACTV_FLG EQL 0
			THEN NOERR(1);
	IF (.PIACTV_FLG OR .PISOFT_FLG) EQL 0
			THEN NOERR(2);

	IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	PI ACTIVE TEST
!*STIMULUS:
!*	FORCE BUS PI LEVEL TO \O0
!*	LOAD THE PI SYSTEM WITH DP = \S1
!*	READ BACK PI NEW OUT TO MEM THROUGH THE DBUS
!*	EXAMINE MEM (BITS 19 - 21 COJNTAIN PI NEW)
!*RESPONCE:
!]ERROR 1
!]PINEW BCLK CCLK PCDBUS ORPI ANDPI PIACTV PISOFT PIREQ PIBUS SPECPI SPECAPR NTWK
!]NO ERROR 1
!]PIACTV ANDPI NTWK
!]NO ERROR 2
!]PIACTV ORPI ANDPI PISOFT CCLK BCLK NTWK
	END;

GLOBAL ROUTINE TST37: NOVALUE =

!THIS TEST CHECKS THE PI CURRENT FLOP AND ENCODER ,AS WELL AS THE 4 BIT 
!TRANS LATCH ON DPEB.
!SINCE THE TRANS LATCH IS ALWAYS CLOCKED THE DATA WE WILL BE LOOKING 
!FOR HAS TO BE STOPED IN THE LATCH AT THE CORRECT TIME.THERFOR TO VERIFY
!THIS TEST WE STOP THE WHOLE MACHINE AND SINGLE STEP THE MAIN CLOCK ON 
!CSL THROUGH SETTING AND CLEARING THE CLOCK BIT IN REGISTER 205 ON THE BUS.
!TO DO SO WE ALWAYS CALL A ROUTINE SYNC_CLK WHICH STOPS THE CLOCK AND 
!SYNCS THE MACHINE.
!THE OUTPUT OF THE TRNSVR LATCH IS READ AND VERIFIED BY READING BUS 
!REGISTER 2 AT THE CORRECT INSTANT.4 INSTRUCTIONS ARE EXECUTED IN THIS
!TEST IN CRAM 0,1,2 & 3.THEY DO THE FOLLOWING:
!CRAM 0/ PUT THE REQUIRED MEM CONTROL BITS IN REGISTER 0 OF THE 2901'S.
!CRAM 1/ OUPUT THOSE BITS FROM REGISTER 0 ONTO DP EXECUTING A MEM CYCLE 
!	 THAT TAKES THE MEM CYCLE CONTROL BITS FROM DP LEFT.
!CRAM 2/ ABORT ALL MEM CYCLES.
!CRAM 3/ LOAD THE PI FLOP WITH THE REQUIRED DATA FROM DP TO SET UP 
!	 DIFFERENT PI CURRENT LEVELS(THIS INSTRUCTION IS EXECUTED TWICE 
!	 EACH TIME).
!THE MR IS REQUIRED AFTER EACH TIME WE STOP THE CLOCK TO RESTART IT IN
!IN ORDER TO BE ABLE TO MODIFY FIELDS OF THE CRAM.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
	      BLOCK5,BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(241300) U_NO_CLKR U,
			U_J(0) U_ALU_OR U_MEM U_N(36) U,
			U_J(3) U_DEST_AD U_SPEC_MEMCLR U,
			U_J(3) U_ALU_OR U_LSRC_0A U_RSRC_D0 U_SPEC_LDPI U_DBUS_DBM U_N(77400) U);

	LOAD_U(0,POINTER);				!LOAD 4 INSTRUCTIONS
	ER_TAB[0] = %O'77400';				!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT(%ASCIZ'LO');			!FOR ERROR PRINTOUT
	TEST_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'74'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'74',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!DO A MASTER RESET
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'7000');				!MODIFY PI CURRENT TO 7
	ER_TAB[0] = %O'77000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'74'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'74',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!DO A MASTER RESET
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'6000');				!MODIFY PI CURRENT TO 6
	ER_TAB[0] = %O'76000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'30'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'30',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!DO A MASTER RESET
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'4000');				!MODIFY PI CURRENT T0 5
	ER_TAB[0] = %O'74000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'24'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'24',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!MASTER RESET
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!MODIFY PI CURRENT TO 4
	ER_TAB[0] = %O'70000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'60'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'60',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!MASTER RESET
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(4,6);					!MODIFY PI CURRENT TO 3
	ER_TAB[0] = %O'60000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'14'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'14',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!MASTER RESET
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(4,4);					!MODIFY PI CURRENT TO 2
	ER_TAB[0] = %O'40000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'50'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'50',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!MASTER RESET
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(4,0);					!MODIFY PI CURRENT TO 1
	ER_TAB[0] = 0;				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'44'				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'44',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!MASTER RESET
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,%O'1200');				!DISABLE XMIT
	ER_TAB[1] = UPLIT(%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:	BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			IF .TEST_FLG EQL 0
			     THEN FAILURE(2);
			ERRCAS(1,1,0,.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!MASTER RESET
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,%O'1300');				!ENABLE XMIT
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(4,7);					!MODIFY PI CURRENT TO 4
	MOD_FLD(1,%O'6707');				!CLEAR PI 
	MOD_FLD(2,0);					!LOAD
	ER_TAB[0] = %O'70000';				!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT(%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK10:BEGIN
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(3);						!GIVE 3 CLOCKS
	SET_C(0);					!SET CRAM ADRS TO 0
	SYNC_CLK();					!STOP THE CLOCK AND SYNC
	WRT204(1);					!WE NEED THIS
	WRT204(0);					!TO RESET CRAM LATCH
	WRT206(1);					!SET CLK RUN
	TICK(56);					!ALOW 14 T CLOCKS
	RCVDATA = RD_2;					!READ REGISTER 2
	RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'44'				!CHECK DATA
		THEN ERRCAS(1,1,%O'44',.RCVDATA,3,ER_TAB)	!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MR();						!START THE CLOCK AGAIN
	LDVMA = 0;					!CLEAR THIS FLAG
!*MESSAGE 1
!*	PI CURRENT TEST
!*STIMULUS:
!*	DPMC PI XMIT IS \S1
!*	LOAD THE PI SYSTEM \S2
!*	WITH RIGHT HALF OF DP = \O0
!*	SINGLE STEP THE MAIN CLOCK
!*	EXAMINE THE 8080'S REGISTER 2
!*	BITS (14 - 17) CONTAIN THE TRNCVR OUTPUT
!*RESPONSE:
!]ERROR 1
!]BCLK SPECPI PICURNT TRNCVR NTWK
!]ERROR 2
!]TRNCVR NTWK
!]NO ERROR 1
!]SPECPI TRNCVR BCLK NTWK
	END;

GLOBAL ROUTINE TST38: NOVALUE =

!THIS TEST CHECKS THE PI LEVEL COMPARE THEN INTERRUPT ON DPEB.
!THREE INSTRUCTIONS ARE EXECUTED TO PERFORM THIS TEST.AFTER EACH EXECUTION
!FIELDS ARE MODIFIED TO SET UP DIFFERENT PI LEVELS TO INPUT TO THE CHIP
!PI INTERRUPT HI OR LO IS DETECTED THROUGH THE SKIP LOGIC (SKIP = 37)
!WHICH WILL SKIP TO THE NXT CRAM ADRS IF PI INTERRUPT WAS HI.
!NXT CRAM ADRS IS READ AND VERIFIED.THE INSTRUCTIONS IN THE CRAM WILL
!DO THE FOLLOWING:
!CRAM 2/ CLEAR PI STATUS BY LOADING ZEROS IN ALL THE PI FLOPS.
!CRAM 3/ PUT THE REQUIRED BITS TO SET UP A PI SOFT REQ LEVEL IN LEFT 
!	 HALF OF REGISTER 0.
!CRAM 4/ PUT THE REQUIRED BITS TO SET UP A CURRENT PI LEVEL IN THE RIGHT 
!	 HALF OF THE DATA PATH.PU THE LEFT HALF OF REGISTER 0 ON THE 
!	 LEFT HALF OF THE DATA PATH.LOAD THE SYSTEM.SKIP TO THE NXT 
!	 INSTRUCTION IF PI INTERRUPT EN IS SET.
!	(THIS INSTRUCTION NEEDS TO BE EXECUTED 3 TIMES).

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,BLOCK11,BLOCK12;
	BIND
	POINTER = PLIT (U_J(3) U_SPEC_LDPI U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(177) U,
			U_J(4) U_ALU_OR U_LSRC_0A U_RSRC_D0 U_SKIP_INT U_SPEC_LDPI U_DBUS_DBM U_N(177) U);

	LOAD_U(2,POINTER);				!LOAD INSTRUCTIONS
	ER_TAB[0] = UPLIT (%ASCIZ'177,,177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'160');				!MODIFY PI SOFT REQ TO 4
	ER_TAB[0] = UPLIT (%ASCIZ'160,,177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'100');				!MODIFY PI SOFT REQ TO LEVEL 2
	ER_TAB[0] = UPLIT (%ASCIZ'100,,177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!MODIFY PI FOFT REQ TO LEVEL 1
	ER_TAB[0] = UPLIT (%ASCIZ'177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(4,7);					!MODIFY PI CURRENT TO 4
	ER_TAB[0] = UPLIT (%ASCIZ'70177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(3,%O'7577');				!MODIFY PI CURRENT TO 7
	ER_TAB[0] = UPLIT (%ASCIZ'77577');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'177');				!MODIFY PI SOFT REQ TO 7
	ER_TAB[0] = UPLIT (%ASCIZ'177,,77577');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'140');				!MODIFY PI SOFT REQ TO 3
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(3,%O'4177');				!MODIFY PI CURRENT TO LEVEL 5
	ER_TAB[0] = UPLIT (%ASCIZ'140,,74177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'176');				!MODIFY PI SOFT REQ TO 7
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(3,%O'6177');				!MODIFY PI CURRENT LEVEL TO 6
	ER_TAB[0] = UPLIT (%ASCIZ'176,,76177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:	BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'170');				!MODIFY PI SOFT REQ TO 5
	ER_TAB[0] = UPLIT (%ASCIZ'170,,76177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK10:BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'176');				!MODIFY PI SOFT TO 7
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(3,%O'7577');				!MODIFY PI CURNT TO NONE
	ER_TAB[0] = UPLIT(%ASCIZ'176,,77577');		!FOR ERROR
	DO (0) WHILE
BLOCK11:BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'160');				!MODIFY PI SOFT TO 4
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(3,%O'4177');				!MODIFY PI CURNT TO 5
	ER_TAB[0] = UPLIT(%ASCIZ'160,,74177');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK12:BEGIN
	SET_C(2);					!SET CRAM ADRS TO 2
	RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	PI COMPARE TEST
!*STIMULUS:
!*	LOAD THE PI SYSTEM WITH DP = \S0
!*	SKIP ON DPEB INTERRUPT REQ (J = 4)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 1
!]BCLK CCLK SKIP PINEW PIENC PICURNT PISOFT PIACTV ORPI ANDPI SPECPI NTWK
	END;

GLOBAL ROUTINE TST39: NOVALUE =

!THIS TEST CHECKS P.C. FLAGS ON DPE9 .
!IT STARTS BY LOADING THE FLAGS INTO THE FLOPS FROM THE DATA PATH AND 
!AFTER VERIFYING THAT THEY DID GET LOADED WE LOOP THE FLAGS BACK INTO 
!THE FLOPS (MIX SELECT = 0) AND VERIFY THE RESULT.
!THIS TEST VERIFIES ALL INPUTS TO THE MIX'S AS WELL AS ALL THE OUPUTS OF 
!THE FLAG FLOPS .SOME OF THE OR & AND GATES ARE TESTED ALSO.
!ALL FLOP OUTPUTS ARE VERIFIED BY WRITTING THE FLAGS INTO REGISTER 0
!OF THE 2901'S VIA DBUS (DBUS SELECT = 0).THEN WRITTING THE CONTENTS OF 
!REGISTER 0 INTO PHYSICAL MEM.
!THIS TEST REQUIRES EXECUTING 5 MICROINSTRUCTIONS IN CRAM 1,2,3,4 & 5:
!CRAM 1/ PUT THE REQUIRED DATA TO SET THE FLAGS IN REGISTER 0
!	 OF THE 2901'S.
!CRAM 2/ CLEAR USER FLAG AND INITIALIZE.
!CRAM 3/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE FLAGS FROM DP
!CRAM 4/ START A PHYSICAL MEM WRITE CYCLE AND PUT THE FLAGS IN REGISTER 0
!	 VIA DBUS.
!CRAM 5/ FINISH MEM CYCLE AND OUPUT THE CONTENTS OF REGISTER 0 INTO MEMORY.
!WE EXAMINE AND VERIFY THE DATA FROM PHYSICAL MEM 0.
!THIS TEST WILL CALL VMA_LD ROUTINE WHICH LOADS THE VMA WITH A 0.

	BEGIN
	OWN TEST_FLG1,TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD_MUL2 U_DBUS_DBM U_NO_CLKR U,
			U_J(3) U_DEST_AD U_SPEC_FLAGS U_NO_CLKL U,
			U_J(4) U_ALU_OR U_SPEC_FLAGS U_N(4) U,
			U_J(5) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_PC_FLAGS U_MEM U_N(11002) U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);
	VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
	LOAD_U(1,POINTER);				!LOAD 4 INSTRUCTIONS
	TEST_FLG = 0;
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	TEST_FLG = 0;
	DM(0,%O'-1');					!SET MEM TO -1
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'774740000000';		!CLEAR UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(1,0,.RCVDATA,12);	!NO
			PCDBUS_FLG = 1;
			TEST_FLG1 = 1;
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(1);
	IF (.RCVDATA AND %O'200000000000') NEQ 0
		THEN FAILURE(2);
	IF (.RCVDATA AND %O'100000000000') NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(4);
	IF (.RCVDATA AND %O'20000000000') NEQ 0
		THEN FAILURE(5);
	IF (.RCVDATA AND %O'10000000000') NEQ 0
		THEN FAILURE(6);
	IF (.RCVDATA AND %O'4000000000') NEQ 0
		THEN FAILURE(7);
	IF (.RCVDATA AND %O'400000000') NEQ 0
		THEN FAILURE(8);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(9);
	IF (.RCVDATA AND %O'100000000') NEQ 0
		THEN FAILURE(10);
	IF (.RCVDATA AND %O'40000000') NEQ 0
		THEN FAILURE(11);

!*MESSAGE 1
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD THE FLAGS FROM DP (DP LEFT = 0)
!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0

	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!CLEAR LOAD FLAGS
	MOD_FLD(4,1);					!SET HOLD USER
	MOD_FLD(5,%O'7447');
	IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
	DO (0) WHILE					!NO WE DIDN'T
BLOCK2:	BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			TEST_FLG1 = 1;
			ERMCA(2,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'200000000000') NEQ 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'100000000000') NEQ 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'20000000000') NEQ 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'10000000000') NEQ 0
		THEN FAILURE(14);
	IF (.RCVDATA AND %O'4000000000') NEQ 0
		THEN FAILURE(15);
	IF (.RCVDATA AND %O'400000000') NEQ 0
		THEN FAILURE(16);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(17);
	IF (.RCVDATA AND %O'100000000') NEQ 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'40000000') NEQ 0
		THEN FAILURE(12);

!*MESSAGE 2
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD THE FLAGS FROM DP (DP LEFT = 0)
!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
!*	HOLD USER IS SET (DBM 05)
!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
	SET_C(3);					!SET CRAM ADRS TO 3
	IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET ?
		LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD  CRAM ADRS 3
	MOD_FLD(5,%O'3447');
	MOD_FLD(4,0);					!CLEAR HOLD USER
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(3,%O'6360');				!SET FLAG 
	MOD_FLD(4,%O'37');				!BITS IN DP
	IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
	DO (0) WHILE
BLOCK3:	BEGIN
	TEST_FLG = 0;
	DM(0,%O'-1');					!SET MEM TO -1
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(3,0,.RCVDATA,12);		!NO
			TEST_FLG1 = 1;
		     END;

	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(18);
	IF (.RCVDATA AND %O'200000000000') NEQ 0
		THEN FAILURE(19);
	IF (.RCVDATA AND %O'100000000000') NEQ 0
		THEN FAILURE(20);
	IF (.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(21);
	IF (.RCVDATA AND %O'20000000000') NEQ 0
		THEN FAILURE(22);
	IF (.RCVDATA AND %O'10000000000') NEQ 0
		THEN FAILURE(14);
	IF (.RCVDATA AND %O'4000000000') NEQ 0
		THEN FAILURE(23);
	IF (.RCVDATA AND %O'400000000') NEQ 0
		THEN FAILURE(16);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(24);
	IF (.RCVDATA AND %O'100000000') NEQ 0
		THEN FAILURE(21);
	IF (.RCVDATA AND %O'40000000') NEQ 0
		THEN FAILURE(21);

!*MESSAGE 3
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD THE FLAGS WITH 0
!*	LOAD THE FLAGS WITH DP LEFT = 774740
!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
!*	(BIT 15 IS CLEAR ON DBM FLAGS SHOULD NOT LOAD FROM DP)
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,4);					!SET LOAD FLAGS FROM DP
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK4:	BEGIN
	TEST_FLG = 0;
	DM(0,%O'-1');					!SET MEM TO -1
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
	IF .RCVDATA NEQ %O'774740000000'		!CHECK DATA
		THEN BEGIN
			ERMCA(4,%O'774740000000',.RCVDATA,12);!NO
			TEST_FLG1 = 1;
			TEST_FLG = 1;
		     END
		ELSE IF .PCDBUS_FLG EQL 0
			THEN NOERR(1);

	IF (.RCVDATA AND %O'400000000000') EQL 0
		THEN FAILURE(25);
	IF (.RCVDATA AND %O'200000000000') EQL 0
		THEN FAILURE(26);
	IF (.RCVDATA AND %O'100000000000') EQL 0
		THEN FAILURE(27);
	IF (.RCVDATA AND %O'40000000000') EQL 0
		THEN FAILURE(28);
	IF (.RCVDATA AND %O'20000000000') EQL 0
		THEN FAILURE(5);
	IF (.RCVDATA AND %O'10000000000') EQL 0
		THEN FAILURE(6);
	IF (.RCVDATA AND %O'4000000000') EQL 0
		THEN FAILURE(29);
	IF (.RCVDATA AND %O'400000000') EQL 0
		THEN FAILURE(8);
	IF (.RCVDATA AND %O'200000000') EQL 0
		THEN FAILURE(30);
	IF (.RCVDATA AND %O'100000000') EQL 0
		THEN FAILURE(10);
	IF (.RCVDATA AND %O'40000000') EQL 0
		THEN FAILURE(11);

!*MESSAGE 4
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD THE FLAGS FROM DP (DP LEFT = 774740)
!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!CLEAR LOAD FLAG 
	MOD_FLD(4,1);					!SET HOLD USER
	MOD_FLD(5,%O'4447');
	IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
	DO (0) WHILE					!NO WE DIDN'T
BLOCK5:	BEGIN
	TEST_FLG = 0;
	DM(0,%O'-1');					!SET MEM TO -1
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
	IF .RCVDATA NEQ %O'774140000000'		!CHECK DATA
		THEN BEGIN
			ERMCA(5,%O'774140000000',.RCVDATA,12);!NO
			TEST_FLG1 = 1;
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND %O'400000000000') EQL 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'200000000000') EQL 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'100000000000') EQL 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'40000000000') EQL 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'20000000000') EQL 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'10000000000') EQL 0
		THEN FAILURE(14);
	IF (.RCVDATA AND %O'4000000000') EQL 0
		THEN FAILURE(31);
	IF (.RCVDATA AND %O'400000000') NEQ 0
		THEN FAILURE(16);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(9);
	IF (.RCVDATA AND %O'100000000') EQL 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'40000000') EQL 0
		THEN FAILURE(12);

!*MESSAGE 5
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD THE FLAGS FROM DP (DP LEFT = 774740)
!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
!*	HOLD USER FLAG IS SET (DBM 05)
!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
	SET_C(3);					!SET CRAM ADRS TO 3
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!CLEAR HOLD USER
	IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
	DO (0) WHILE					!NO WE DIDN'T
BLOCK6:	BEGIN
	TEST_FLG = 0;
	DM(0,%O'-1');					!SET MEM TO -1
	SET_C(2);					!SET CRAM ADRS TO 2
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
	IF .RCVDATA NEQ %O'764140000000'		!CHECK DATA
		THEN ERMCA(6,%O'764140000000',.RCVDATA,12)!NO
		ELSE IF .TEST_FLG1 EQL 0
			THEN NOERR(2);

	IF (.RCVDATA AND %O'400000000000') EQL 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'200000000000') EQL 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'100000000000') EQL 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'40000000000') EQL 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'20000000000') EQL 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'10000000000') NEQ 0
		THEN FAILURE(14);
	IF (.RCVDATA AND %O'4000000000') EQL 0
		THEN FAILURE(31);
	IF (.RCVDATA AND %O'400000000') NEQ 0
		THEN FAILURE(16);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(9);
	IF (.RCVDATA AND %O'100000000') EQL 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'40000000') EQL 0
		THEN FAILURE(12);

!*MESSAGE 6
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD THE FLAGS FROM DP (DP LEFT = 774740)
!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!]NO ERROR 1
!]PCDBUS NTWK
!]NO ERROR 2
!]SPECPC FCLK NTWK
!]ERROR 1
!]PCDBUS A B C D E H G I SPECPC FCLK NTWK
!]ERROR 2
!]PCDBUS J K L G SPECPC FCLK NTWK
!]ERROR 3
!]PCDBUS FCLK J L M G SPECPC NTWK
!]ERROR 4
!]PCDBUS FCLK A G I B D N H SPECPC NTWK
!]ERROR 5
!]PCDBUS FCLK J O P L G SPECPC NTWK
!]ERROR 6
!]PCDBUS FCLK Q G R SPECPC NTWK
!]ERROR 7
!]PCDBUS FCLK SPECPC Q S G NTWK
!]ERROR 8
!]PCDBUS FCLK SPECPC Q V NTWK
!]ERROR 9
!]PCDBUS FCLK SPECPC A I G B C D U NTWK
!]ERROR 10
!]PCDBUS FCLK SPECPC A I G W H NTWK
!]ERROR 11
!]PCDBUS FCLK SPECPC Q X H G NTWK
!]ERROR 12
!]G H NTWK
!]ERROR 13
!]G L NTWK
!]ERROR 14
!]R G NTWK
!]ERROR 15
!]S NTWK
!]ERROR 16
!]V NTWK
!]ERROR 17
!]U G NTWK
!]ERROR 18
!]C H G NTWK
!]ERROR 19
!]L G NTWK
!]ERROR 20
!]M L G NTWK
!]ERROR 21
!]H G NTWK
!]ERROR 22
!]L G NTWK
!]ERROR 23
!]S G NTWK
!]ERROR 24
!]C U G NTWK
!]ERROR 25
!]PCDBUS FCLK SPECPC A B E F H G I NTWK
!]ERROR 26
!]PCDBUS FCLK SPECPC J K L F G NTWK
!]ERROR 27
!]PCDBUS FCLK J M F L G NTWK
!]ERROR 28
!]PCDBUS FCLK SPECPC A I G B N F H NTWK
!]ERROR 29
!]PCDBUS FCLK SPECPC Q S G NTWK
!]ERROR 30
!]PCDBUS FCLK SPECPC A I G U NTWK
!]ERROR 31
!]PCDBUS FCLK Z S NTWK
	END;

GLOBAL ROUTINE TST40: NOVALUE =

!THIS TEST CHECKS ALL THE JFCL LOGIC ON DPE9 .
!THIS TEST FLOATS A ZERO ON ALL THE AND GATES INPUTS AND VERIFIES THE 
!OUTPUT BY SKIP ON JFCL.IT EXECUTES 3 INSTRUCTIONS IN CRAM 1,2 & 3:
!CRAM 1/ PUT THE REQUIRED DATA TO SET OR CLEAR THE FLAGS AND SET OR 
!	 CLEAR DPEA AC'S ON DP AS WELL AS REGISTER 0.AND LOAD THE FLAGS 
!	 FROM DP.
!CRAM 2/ LOAD THE IR FROM REGISTER 0 OF THE 2901'S.
!CRAM 3/ ENABLE OR DISABLE THE JFCL AND SKIP IN JFCL IS SET (THE ORED J FIELD = 4).
!WE READ THE NXT CRAM ADRS AND VERIFY IT.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
	      BLOCK5,BLOCK6,BLOCK7,BLOCK8,
	      BLOCK9,BLOCK10,BLOCK11,BLOCK12,
	      BLOCK13,BLOCK14,BLOCK15,BLOCK16,BLOCK17;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SPEC_FLAGS U_N(400004) U,
			U_J(3) U_ALU_OR U_SPEC_LOADIR U,
			U_J(4) U_SKIP_JFCL U_SPEC_FLAGS U_N(10) U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	ER_TAB[0] = UPLIT (%ASCIZ'OV FLAG IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 09 IS LO');	!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!CLEAR OV FLAG
	MOD_FLD(3,%O'404');				!SET DPEA 09
	ER_TAB[0] = UPLIT (%ASCIZ'OV FLAG IS LO');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 09 IS HI');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(2,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'40');				!SET OV
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!CLEAR JFCL EN
	ER_TAB[0] = UPLIT (%ASCIZ'OV FLAG IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'10');				!SET JFCL EN
	ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN BEGIN
			ERRCAS(4,1,5,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!CLEAR FLAGS
	MOD_FLD(3,%O'204');				!SET DPEA AC 10
	ER_TAB[0] = UPLIT (%ASCIZ'CRY0 FLAG IS LO');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 10 IS HI');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(5,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'20');				!SET CRY0 FLAG
	MOD_FLD(3,4);					!CLEAR DPEA AC 10
	ER_TAB[0] = UPLIT (%ASCIZ'CRY0 FLAG IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 10 IS LO');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'204');				!SET DPEA AC 10
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!CLEAR JFCL EN
	ER_TAB[1] = UPLIT (%ASCIZ'AC 10 IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK7:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'10');				!SET JFCL EN
	ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK8:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN BEGIN
			ERRCAS(6,1,5,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!CLEAR FLAGS
	MOD_FLD(3,%O'104');				!SET DPEA AC 11
	ER_TAB[0] = UPLIT (%ASCIZ'CRY1 FLAG IS LO');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 11 IS HI');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK9:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(7,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'10');				!SET CRY1 FLAG
	MOD_FLD(3,4);					!CLEAR DPEA AC 11
	ER_TAB[0] = UPLIT (%ASCIZ'CRY1 FLAG IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 11 IS LO');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK10:BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'104');				!SET DPEA AC 11
	LC(3);						!LOAD CRAM ADRS 3
	TEST_FLG = 0;
	MOD_FLD(3,0);					!CLEAR JFCL EN
	ER_TAB[1] = UPLIT (%ASCIZ'AC 11 IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK11:BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'10');				!SET JFCL EN
	ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK12:BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN BEGIN
			ERRCAS(8,1,5,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!CLEAR FLAGS
	MOD_FLD(3,%O'44');				!SET DPEA AC 12
	ER_TAB[0] = UPLIT (%ASCIZ'FOV FLAG IS LO');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 12 IS HI');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK13:BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(9,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,4);					!SET FOV FLAG
	MOD_FLD(3,4);					!CLEAR DPEA AC 12
	ER_TAB[0] = UPLIT (%ASCIZ'FOV FLAG IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'AC 12 IS LO');	!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK14:BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'44');				!SET DPEA AC 12
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!CLEAR JFCL EN
	ER_TAB[1] = UPLIT (%ASCIZ'AC 12 IS HI');	!FOR ERROR PRINTOUT
	ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK15:BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 4				!CHECK DATA
		THEN BEGIN
			ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'10');				!SET JFCL EN
	ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK16:BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN BEGIN
			ERRCAS(10,1,5,.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(1,%O'6747');				!CHANGE TO NO SKIP
	LC(1);						!LOAD CRAM ADRS 3
	MOD_FLD(4,%O'74');				!SET 4 FLAGS
	MOD_FLD(3,%O'744');				!SET ALL DPEA AC'S
	DO (0) WHILE
BLOCK17:BEGIN
	DM(0,%O'-1');					!SET MEM TO -1
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVDATA = .RCVDATA AND %O'740000000000';	!CLEAR UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERMCA(2,0,.RCVDATA,12)	!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);

	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(11);
	IF (.RCVDATA AND %O'200000000000') NEQ 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'100000000000') NEQ 0
		THEN FAILURE(13);
	IF (.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(14);
	IF LOOP_CHK(17)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK17 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	JFCL LOGIC TEST (P.C. FLAGS)
!*STIMULUS:
!*	DPE9 \S0
!*	DPEA \S1
!*	DPE9 JFCL EN IS \S2
!*	ALL OTHER AC & FLAG INPUTS TO THE JFCL GATES ARE LO
!*	SKIP IF JFCL (CURRENT J FIELD IS 4)
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]NO ERROR 1
!]FCLK SPECIR SPECPC NTWK
!]ERROR 1
!]SKIP SPECPC F IR SPECIR FCLK NTWK
!]ERROR 2
!]SKIP SPECPC FCLK A B C D E F G H I NTWK
!]ERROR 3
!]SKIP G F NTWK
!]ERROR 4
!]SKIP SPECPC IR SPECIR FCLK F A B E H G I NTWK
!]ERROR 5
!]SKIP SPECPC FCLK F J K L G NTWK
!]ERROR 6
!]SKIP SPECPC FCLK IR SPECIR J K F L G NTWK
!]ERROR 7
!]SKIP SPECPC FCLK F J M L G NTWK
!]ERROR 8
!]SKIP FCLK K IR SPECIR SPECPC F L G J M NTWK
!]ERROR 9
!]SKIP SPECPC FCLK A B I G D N H F NTWK
!]ERROR 10
!]SKIP FCLK SPECPC IR SPECIR A I G B N F H NTWK
!*MESSAGE 2
!*STIMULUS:
!*	JFCL LOGIC TEST (P.C. FLAGS)
!*	DPE9 OV,CRY0,CRY1 & FOV FLAGS ARE HI
!*	DPEA AC 9,10,11 & 12 ARE HI
!*	DPE9 JFCL EN IS HI
!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 11
!]PCDBUS IR SPECIR SPECPC FCLK F A B C D E I G NTWK
!]ERROR 12
!]PCDBUS IR SPECIR SPECPC FCLK F J K G NTWK
!]ERROR 13
!]PCDBUS IR SPECIR SPECPC FCLK F J M G NTWK
!]ERROR 14
!]PCDBUS IR SPECIR SPECPC FCLK F A B G D N NTWK
	END;

GLOBAL ROUTINE TST41: NOVALUE =

!THIS TEST CHECKS THE DPE9 CARRY FLAG AND GATES .ALSO FPD & TRAP 2
!FLAGS SET AND CLEAR CONTROLLED BY THE MAGIC # FIELD.
!AT FIRST WE CALL A ROUTINE THAT WILL CHECK AND LOAD THE VMA WITH A 0.
!THEN 4 INSTRUCTIONS ARE EXECUTED TO SET OR CLEAR THE RELATED FLAGS
!(CRY0,CRY1,TRAP 2 & FPD).AFTER EACH EXECUTION FIELDS ARE MODIFIED 
!TO SET A DIFFERENT SET OF DATA.
!THE FLAGS ARE VERIFIED BY WRITING THEM INTO THE 2901'S REGISTER 0 VIA 
!DBUS (DBUS SELECT = 0).THEN THE DATA IS PASSED OUT TO MEM READ AND VERIFIED.
!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
!CRAM 1/ LOAD ALL DPEA AC'S WITH ONES,AND PUT PART OF THE DATA IN 
!	 REGISTER 0 (2901'S).
!	 LOADING THE AC'S ON DPEA WITH ONES WILL ENABLE THE JFCL'S.THIS
!	 WAY WE MAKE SURE THE FLAG INPUTS ARE NOT LOOPING FROM THE 
!	 PREVIOUS FLAG OUTPUTS.
!CRAM 2/ ADD THE SECOND DATA TO THE CONTENTS OF REGISTER 0(THIS WILL SET
!	 OR CLEAR DPE2 CARRY OUT) .LOAD THE FLAGS.
!CRAM 3/ START A MEM CYCLE AND PUT THE FLAGS IN THE 2901'S VIA DBUS
!	 (DBUS SELECT = 0).
!CRAM 4/ FINISH THE MEM CYCLE AND OUTPUT THE FLAGS PREVIOUSLY LOADED
!	 IN THE 2901'S OUT TO MEMORY.
!THE DATA IS THEN READ AND VERIFIED FROM MEMORY.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SPEC_LOADIR U_N(600740) U_NO_CLKR U,
			U_J(3) U_ALU_ADD U_LSRC_DA U_DBUS_DBM U_SPEC_FLAGS U_N(622011) U,
			U_J(4) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	TEST_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'320400000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'320400000000'		!CHECK DATA
		THEN BEGIN
			ERMCA(1,%O'320400000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		     END;

	IF (.RCVDATA AND %O'200000000000') EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND %O'100000000000') EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND %O'20000000000') EQL 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'400000000') EQL 0
		THEN FAILURE(4);

!*MESSAGE 1
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	DBM 03 IS CLEAR
!*	DBM 04 & 07 ARE SET
!*	DPE2 CARRY OUT IS SET
!*	DPE9 DP CRY1 IS SET 
!*	DPE9 CARRY FLAGS IS SET
!*	OUTPUT THE FLAGS INTO MEMORY VIA DBUS & DP
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 1
!]PCDBUS FCLK SPECPC J K G NTWK
!]ERROR 2
!]PCDBUS FCLK SPECPC G J M NTWK
!]ERROR 3
!]PCDBUS FCLK SPECPC J P O NTWK
!]ERROR 4
!]PCDBUS SPECPC FCLK V Q NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'11');				!CLEAR DBM 02 & 07
	MOD_FLD(4,%O'66');				!SET DBM 3 & 4
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,0);					!CLEAR CARRY AND DP CRY1
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'320400000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(2,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		    END;

	IF (.RCVDATA AND %O'200000000000') NEQ 0
		THEN FAILURE(5);
	IF (.RCVDATA AND %O'100000000000') NEQ 0
		THEN FAILURE(6);
	IF (.RCVDATA AND %O'20000000000') NEQ 0
		THEN FAILURE(7);
	IF (.RCVDATA AND %O'400000000') NEQ 0
		THEN FAILURE(8);
!*MESSAGE 2
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	DBM 03 & 04 ARE SET
!*	DBM 07 IS CLEAR
!*	DPE2 CARRY OUT IS CLEAR
!*	DPE9 DP CRY1 IS CLEAR 
!*	DPE9 CARRY FLAGS IS SET
!*	OUTPUT THE FLAGS INTO MEMORY VIA DBUS & DP
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 5
!]PCDBUS FCLK SPECPC IR SPECIR G J K L NTWK
!]ERROR 6
!]PCDBUS SPECPC IR SPECIR G FCLK J M L NTWK
!]ERROR 7
!]PCDBUS FCLK SPECPC IR SPECIR O J NTWK
!]ERROR 8
!]PCDBUS FCLK SPECPC IR SPECIR Q V NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'10');				!CLEAR CARRY FLAGS
	MOD_FLD(4,%O'60');				!CLEAR DBM 3 & 4
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,%O'60');				!SET CARRY AND DP CRY1
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'320400000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERMCA(3,0,.RCVDATA,12)		!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);

	IF (.RCVDATA AND %O'200000000000') NEQ 0
		THEN FAILURE(9);
	IF (.RCVDATA AND %O'100000000000') NEQ 0
		THEN FAILURE(10);
	IF (.RCVDATA AND %O'20000000000') NEQ 0
		THEN FAILURE(11);
	IF (.RCVDATA AND %O'400000000') NEQ 0
		THEN FAILURE(12);
!*MESSAGE 3
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	DBM 03,04 & 07 ARE CLEAR
!*	DPE2 CARRY OUT IS SET
!*	DPE9 DP CRY1 IS SET 
!*	DPE9 CARRY FLAGS IS CLEAR
!*	OUTPUT THE FLAGS INTO MEMORY VIA DBUS & DP
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]NO ERROR 1
!]FCLK SPECPC SPECIR NTWK
!]ERROR 9
!]PCDBUS FCLK SPECPC IR SPECIR G J K L NTWK
!]ERROR 10
!]PCDBUS SPECPC IR SPECIR FCLK G J M L NTWK
!]ERROR 11
!]PCDBUS FCLK SPECPC IR SPECIR G P J O L NTWK
!]ERROR 12
!]PCDBUS SPECPC IR SPECIR FCLK Q V NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST42: NOVALUE =

!THIS TEST CHECKS LOADING SOME OF THE FLAGS ON DPE9 FROM THE MAGIC # FIELD.
!THE FLAGS IN SUBJECT ARE OV, TRAP 1,FOV & NO DIV.
!THIS TEST WILL EXECUTE 5 INSTRUCTIONS FOR EACH LOGICAL CONDITION THAT INVOLVE
!THE AND GATES UNDER TEST. 3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0
!AFTER EACH TEST FIELDS ARE MODIFIED TO SET UP DATA FOR THE NXT CONDITION
!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
!CRAM 1/ LOAD THE IR ONE'S . THIS WILL SET UP ALL THE AC'S ON DPEA TO 
!	 BE HI. WITH JFCL EN THIS PROCESS WILL PREVENT THE FLAGS TO INPUT
!	 FROM THE PREVIOUS FLAGS CONTENTS WHEN THE FLAGS ARE LOADED.
!CRAM 2/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
!CRAM 3/ LOAD THE FLAGS IN SUBJECT FROM # FIELD WITH JFCL ENABLED.
!	 (OV, TRAP 1, FOV, NO DIV).
!CRAM 4/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
!CRAM 5/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
!AND VERIFY THE DATA

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777777) U,
			U_J(2) U_N(4) U_SPEC_FLAGS U,
			U_J(3) U_N(701010) U_SPEC_FLAGS U,
			U_J(4) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);

	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	TEST_FLG = 0;
	CP_NOSS(1);					!CLK 1'ST INSTRUCTION TO LOAD THE IR WITH ONES
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'440240000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'440240000000'		!CHECK DATA
		THEN BEGIN
			ERMCA(1,%O'440240000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		     END;

	IF (.RCVDATA AND %O'400000000000') EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND %O'40000000000') EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND %O'200000000') EQL 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'40000000') EQL 0
		THEN FAILURE(4);
!*MESSAGE 1
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV,TRAP 1,FOV & NO DIV FLAGS FROM DBM
!*	DBM BITS 00,01,02 & 08 ARE HI
!*	DPE9 SPEC/PC FLAGS IS HI
!*	WRITE P.C. FLAGS OUT TO MEM VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]PCDBUS FCLK SPECPC A I G B E NTWK
!]ERROR 2
!]PCDBUS SPECPC FCLK A I G B N NTWK
!]ERROR 3
!]PCDBUS SPECPC FCLK A I G B U NTWK
!]ERROR 4
!]PCDBUS SPECPC FCLK Q X NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'10');				!CLEAR DBM BITS
	MOD_FLD(4,0);					!00,01 & 08
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'440240000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(2,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;

	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(5);
	IF (.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(6);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(7);
	IF (.RCVDATA AND %O'40000000') NEQ 0
		THEN FAILURE(8);
!*MESSAGE 2
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV,TRAP 1,FOV & NO DIV FLAGS FROM DBM
!*	DBM BITS 00,01,02 & 08 ARE LO
!*	DPE9 SPEC/PC FLAGS IS HI
!*	WRITE P.C. FLAGS OUT TO MEM VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 5
!]PCDBUS FCLK SPECPC IR SPECIR I A B C D E G NTWK
!]ERROR 6
!]PCDBUS FCLK SPECPC IR SPECIR A B D N I G NTWK
!]ERROR 7
!]PCDBUS FCLK SPECPC I G A B C D U NTWK
!]ERROR 8
!]PCDBUS FCLK SPECPC Q X H G NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'1010');				!SET DBM BITS
	MOD_FLD(4,%O'60');				!00,01 & 08
	MOD_FLD(1,%O'6747');				!CLEAR SEPC/PC FLAGS
	MOD_FLD(2,%O'40');
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'440200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERMCA(3,0,.RCVDATA,12)		!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);

	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(9);
	IF (.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(10);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(11);
!*MESSAGE 3
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV,TRAP 1 & FOV FLAGS FROM DBM
!*	DBM BITS 00,01 & 08 ARE HI
!*	DPE9 SPEC/PC FLAGS IS LO
!*	WRITE P.C. FLAGS OUT TO MEM VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]NO ERROR 1
!]FCLK SPECPC SPECIR NTWK
!]ERROR 9
!]PCDBUS FCLK SPECPC IR SPECIR A B C D E I G NTWK
!]ERROR 10
!]PCDBUS FCLK SPECPC SPECIR IR A B D N I G NTWK
!]ERROR 11
!]PCDBUS FCLK SPECPC I G A B C D U NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST43: NOVALUE =

!THIS TEST CHECKS LOADING OV,TRAP 1 & FXU FLAGS FROM THE OUTPUT OF SCAD 00 & 01
!SELECTING SPEC / EXP TEST.
!THIS TEST WILL EXECUTE 4 INSTRUCTIONS FOR EACH LOGICAL CONDITION THAT INVOLVE
!THE GATES UNDER TEST. 3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0
!AFTER EACH TEST FIELDS ARE MODIFIED TO SET UP DATA FOR THE NXT CONDITION
!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
!CRAM 1/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
!CRAM 2/ LOAD THE FLAGS UNDER TEST FROM OUTPUT OF THE SCAD. DO A SPEC / EXP TEST
!	 AND OUTPUT REQUIRED DATA FORM THE SCAD CONTROLLED BY THE MAGIC # FIELD.
!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
!CRAM 4/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
!AND VERIFY THE DATA

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3;
	BIND
	POINTER = PLIT (U_J(2) U_SPEC_FLAGS U_N(4) U,
			U_J(3) U_SPEC_EXPTST U_N(710000) U,
			U_J(4) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	TEST_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'440300000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(1,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;

	IF(.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(1);
	IF(.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(2);
	IF(.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(3);
	IF(.RCVDATA AND %O'100000000') NEQ 0
		THEN FAILURE(4);
!*MESSAGE 1
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOADS FLAGS FROM OUTPUT OF SCAD (00,01)
!*	SCAD(00,01) BITS ARE LO
!*	DPE9 SPEC/EXP TEST IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]PCDBUS SPECPC SPECEXP FCLK A I Z B C D E H G NTWK
!]ERROR 2
!]PCDBUS FCLK SPECPC SPECEXP A I Z B D N H G NTWK
!]ERROR 3
!]PCDBUS FCLK SPECPC SPECEXP A I Z G B C D U NTWK
!]ERROR 4
!]PCDBUS FCLK SPECPC SPECEXP A I Z G W H NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'1400');				!SET SACD 00
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'440300000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'440300000000'		!CHECK DATA
		THEN BEGIN
			ERMCA(2,%O'440300000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		    END;

	IF(.RCVDATA AND %O'440200000000') EQL 0
		THEN FAILURE(5);
	IF(.RCVDATA AND %O'100000000') EQL 0
		THEN FAILURE(6);
!*MESSAGE 2
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOADS FLAGS FROM OUTPUT OF SCAD (00,01)
!*	SCAD 00 & 01 BITS ARE HI
!*	DPE9 SPEC/EXP TEST IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 5
!]PCDBUS FCLK SPECPC SPECEXP A I Z B D NTWK
!]ERROR 6
!]PCDBUS FCLK SPECPC SPECEXP A I Z B W NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'1400');				!SET SCAD 00 & 01
	MOD_FLD(1,%O'6747');				!CLEAR DPE9 SPEC/EXP TEST
	MOD_FLD(2,%O'40');
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'440300000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERMCA(3,0,.RCVDATA,12)		!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
	IF(.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(7);
	IF(.RCVDATA AND %O'40000000000') NEQ 0
		THEN FAILURE(8);
	IF(.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(9);
	IF(.RCVDATA AND %O'100000000') NEQ 0
		THEN FAILURE(10);
!*MESSAGE 3
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOADS FLAGS FROM OUTPUT OF SCAD (00,01)
!*	SCAD(00,01) BITS ARE HI
!*	DPE9 SPEC/EXP TEST IS LO
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]NO ERROR 1
!]FCLK SPECPC SPECEXP NTWK
!]ERROR 7
!]PCDBUS SPECPC SPECEXP FCLK A I Z G B C D E H NTWK
!]ERROR 8
!]PCDBUS FCLK SPECPC SPECEXP A B D N H G I Z NTWK
!]ERROR 9
!]PCDBUS FCLK SPECPC SPECEXP I Z G A B C D U NTWK
!]ERROR 10
!]PCDBUS FCLK SPECPC SPECEXP A I Z G W H NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST44: NOVALUE =

!THIS TEST CHECKS LOADING OV & TRAP 1 FLAGS FROM THE OUTPUT OF 2901'S DP 00 & 01
!AND DP OVERFLOW SELECTING SPEC / ASH TEST.
!THIS TEST WILL EXECUTE 5 INSTRUCTIONS FOR EACH LOGICAL CONDITION THAT INVOLVE
!THE GATES UNDER TEST. 3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0
!FOR THE AND GATES AND 00,01,10 FOR THE OR GATES.
!AFTER EACH TEST FIELDS ARE MODIFIED TO SET UP DATA FOR THE NXT CONDITION
!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
!CRAM 1/ PUT THE REQUIRED DATA FOR THE DP IN THE 2901'S VIA DBUS,DMB & MAGIC # FIELD.
!CRAM 2/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
!CRAM 3/ LOAD THE FLAGS UNDER TEST FROM OUTPUT OF THE 2901'S. DO A SPEC / ASH TEST
!AND THE OUTPUT THE DATA PREVIOUSLY LOADED IN THE 2901'S ONTO DP.
!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
!CRAM 4/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
!AND VERIFY THE DATA

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
	      BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD_MUL2 U_DBUS_DBM U,
			U_J(3) U_SPEC_FLAGS U_N(4) U,
			U_J(4) U_ALU_OR U_SPEC_ASHOV U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	TEST_FLG = 0;
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(1,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(1);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(2);
!*MESSAGE 1
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP ASH TEST
!*	DP (01,02) BITS ARE LO
!*	DPE9 SPEC/ASH TEST IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]PCDBUS FCLK SPECPC SPECASH Y G I Z A B C D E H NTWK
!]ERROR 2
!]PCDBUS FCLK SPECPC SPECASH I Z Y A B C D U G NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'14');				!SET DP 01 & 02
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(2,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(4);
!*MESSAGE 2
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP ASH TEST
!*	DP (01,02) BITS ARE HI
!*	DPE9 SPEC/ASH TEST IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 3
!]PCDBUS FCLK SPECPC SPECASH A B C D E I Z G Y H NTWK
!]ERROR 4
!]PCDBUS FCLK SPECPC SPECASH I Z Y G A B C D U NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'10');				!SET DP 01
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'400200000000'		!CHECK DATA
		THEN BEGIN
			ERRCAS(5,3,%O'400200000000',.RCVDATA,12,0);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 3
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP ASH TEST
!*	DP 01 IS HI
!*	DP 02 IS LO
!*	DPE9 SPEC/ASH TEST IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 5
!]PCDBUS FCLK SPECPC SPECASH I Z A B C Y NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,4);					!SET DP 02
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'400200000000'		!CHECK DATA
		THEN BEGIN
			ERRCAS(6,4,%O'400200000000',.RCVDATA,12,0);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 4
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP ASH TEST
!*	DP 01 IS LO
!*	DP 02 IS HI
!*	DPE9 SPEC/ASH TEST IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 6
!]PCDBUS FCLK SPECPC SPECASH I Z A B C Y NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(1,%O'6747');				!CLEAR SPEC/ASH TEST
	MOD_FLD(2,%O'60');
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,%O'14');				!SET DP 01 & 02
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(5,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(7);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(8);
!*MESSAGE 5
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP ASH TEST
!*	DP 01 & 02 ARE HI
!*	DPE9 SPEC/ASH TEST IS LO
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 7
!]PCDBUS FCLK SPECPC SPECASH I G Z A B C D E H NTWK
!]ERROR 8
!]PCDBUS FCLK SPECPC SPECASH G A B I Z C D U NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'20');				!SET DP 00
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERMCA(6,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(9);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(10);
!*MESSAGE 6
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP OVERFLOW
!*	DPE9 DP OVERFLOW IS HI
!*	DPE9 CARRY FLAGS IS LO
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 9
!]PCDBUS FCLK SPECPC SPECASH G A B C I Z D E H NTWK
!]ERROR 10
!]PCDBUS FCLK SPECPC SPECASH G A B C D U I Z NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,1);					!SET DPE9 CARRY FLAGS
	SET_C(1);					!SET CRAM ADTS TO 1
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'400200000000'		!CHECK DATA
		THEN BEGIN
			ERRCAS(11,7,%O'400200000000',.RCVDATA,12,0);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 7
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP OVERFLOW
!*	DPE9 DP OVERFLOW IS HI
!*	DPE9 CARRY FLAGS IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 11
!]PCDBUS FCLK SPECPC SPECASH Y I G Z A B C NTWK
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,0);					!CLEAR DP OVERFLOW
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERMCA(8,0,.RCVDATA,12)		!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
	IF (.RCVDATA AND %O'400000000000') NEQ 0
		THEN FAILURE(12);
	IF (.RCVDATA AND %O'200000000') NEQ 0
		THEN FAILURE(13);
!*MESSAGE 8
!*STIMULUS:
!*	P.C. FLAGS TEST
!*	LOAD OV & TRAP 1 FROM DP OVERFLOW
!*	DPE9 DP OVERFLOW IS LO
!*	DPE9 CARRY FLAGS IS HI
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]NO ERROR 1
!]FCLK SPECPC SPECASH NTWK
!]ERROR 12
!]PCDBUS FCLK SPECPC SPECASH Y G I Z A B C D E H NTWK
!]ERROR 13
!]PCDBUS FCLK SPECPC SPECASH A B I Z C D Y U NTWK
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST45: NOVALUE =

!THIS TEST CHECKS MOST OF THE LOGIC GATES INPUT TO USER I/O FLAG.
!THIS TEST WILL EXECUTE 4 INSTRUCTIONS FOR SOME PARTS AND 5 FOR OTHERS 
!FOR EACH LOGICAL CONDITION THAT INVOLVE THE GATES UNDER TEST.
!3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0 FOR THE AND GATES 
!AND 00,01,10 FOR THE OR GATES AFTER EACH TEST FIELDS ARE MODIFIED 
!TO SET UP DATA FOR THE NXT CONDITION
!CRAM 1/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
!CRAM 2/ LOAD THE FLAGS IN SUBJECT FROM # FIELD OR DP WITH THE REQUIRED 
!	 DATA SET UP IN BOTH FIELDS
!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
!CRAM 4/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
!CRAM 5/ LOAD THE FLAGS AGIAN.
!	 (THIS INSTRUCTION IN IS INCLUDED IN THE SECOND PART OF THIS TEST
!	 AFTER VERIFYING THAT I/O FLAG WAS LOADED. THIS INSTRUCTION WILL VERIFY
!	 THAT I/O FLAG CAN BE LOADED FORM ITS PREVIOUS CONTENTS CONDITIONALLY).
!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
!AND VERIFY THE DATA
!(NOTE:	CAN'T TEST PIN 5 ON E106 FOR STUCK HI)

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
	      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,
	      BLOCK11,BLOCK12,BLOCK13,BLOCK14;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4004) U,
			U_J(4) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4) U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	TEST_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
		THEN BEGIN
			ERRCA(1,%O'4000000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 1
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	-DPE9 USER FLAG H IS SET
!*	DPE1 DP 06 IS SET
!*	DPE9 LOAD FLAGS H IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 1
!]PCDBUS FCLK SPECPC Q R G S NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'4000');				!CLEAR DPE9 LOAD FLAGS H
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(2,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 2
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	-DPE9 USER FLAG H IS SET
!*	DPE1 DP 06 IS SET
!*	DPE9 LOAD FLAGS H IS CLEAR
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 2
!]PCDBUS FCLK SPECPC Q R G S NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,4);					!CLEAR DPE1 DP 06
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK3:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(3,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 3
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	-DPE9 USER FLAG H IS SET
!*	DPE1 DP 06 IS CLEAR
!*	DPE9 LOAD FLAGS H IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 3
!]PCDBUS FCLK SPECPC Q G S NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'4004');				!SET BOTH DP 06 & LOAD FLAGS
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,1);					!SET USER FLAG
	DO (0) WHILE
BLOCK4:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(4,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 4
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	-DPE9 USER FLAG H IS CLEAR
!*	DPE1 DP 06 IS SET
!*	DPE9 LOAD FLAGS H IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 4
!]PCDBUS FCLK SPECPC R Q G S NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'400');				!SET DBM 09
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK5:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
		THEN BEGIN
			ERRCA(5,%O'4000000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 5
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 5
!]PCDBUS FCLK SPECPC R Q S G NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,0);					!CLEAR DPE 09
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK6:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(6,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 6
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS CLEAR
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 6
!]PCDBUS FCLK SPECPC Q G S NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'400');				!SET DPE 09
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,0);					!CLEAR USER FLAG
	DO (0) WHILE
BLOCK7:	BEGIN
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(7,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 7
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS CLEAR
!*	DPE1 DP 09 IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 7
!]PCDBUS FCLK SPECPC Q G R S NTWK
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(0,5);					!MODIFY J FIELD TO INCLUDE ANOTHER INSTRUCTION
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(4,1);					!SET USER FLAG
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(8,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 8
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
!*	WE LOAD THE FLAGS AGAIN WITH -DPE9 LOAD FLAGS H CLEAR
!*	THIS SHOULD CLEAR USER I/O FLAG
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 8
!]PCDBUS FCLK SPECPC Q G S Z NTWK
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(3,0);					!SET -DPE9 LOAD FLAGS H
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK9:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
		THEN BEGIN
			ERRCA(9,%O'4000000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 9
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
!*	WE LOAD THE FLAGS AGAIN WITH -DPE9 LOAD FLAGS H SET
!*	THIS SHOULD SET AGAIN  USER I/O FLAG
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 9
!]PCDBUS G FCLK SPECPC Q S Z NTWK
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,0);					!CLEAR DPE 09
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK10:BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(10,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 10
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS CLEAR
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
!*	WE LOAD THE FLAGS AGAIN WITH -DPE9 LOAD FLAGS H SET
!*	THIS SHOULD CLEAR AGAIN USER I/O FLAG
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 10
!]PCDBUS FCLK SPECPC Q G S NTWK
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(4,1);					!SET DBM 05
	MOD_FLD(3,%O'400');				!SET DBM 09
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(4,1);					!SET DBM 05
	MOD_FLD(3,%O'4004');				!SET LOAD FLAGS & DP 06
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK11:BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
		THEN BEGIN
			ERRCA(11,%O'4000000000',.RCVDATA,12);!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 11
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H,DP 06 & DBM 05 SET
!*	THIS SHOULD SET AGAIN USER I/O FLAG
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 11
!]PCDBUS FCLK SPECPC Q R S G T NTWK

	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(4,0);					!CLEAR DBM 05
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK12:BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(12,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 12
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H & DP 06 ARE SET, DBM 05 IS CLEAR
!*	THIS SHOULD CLEAR USER I/O FLAG
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 12
!]PCDBUS FCLK SPECPC Q R G S T NTWK
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(4,1);					!SET DBM 05
	LC(2);						!SET CRAM ADRS 2
	MOD_FLD(3,0);					!CLEAR DBM 09
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK13:BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN BEGIN
			ERRCA(13,0,.RCVDATA,12);		!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 13
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS CLEAR
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H,DP 06 & DBM 05 SET
!*	THIS SHOULD CLEAR AGAIN USER I/O FLAG
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]ERROR 13
!]PCDBUS FCLK SPECPC Q G S T NTWK
	IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'400');				!SET DBM 09
	LC(5);						!LOAD CRAM ADRS 5
	MOD_FLD(3,4);					!CLEAR DP 06
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK14:BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(14,0,.RCVDATA,12)		!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
!*MESSAGE 14
!*STIMULUS:
!*	P.C. FLAGS TEST (USER I/O FLAG)
!*	DPE9 USER FLAG H IS SET
!*	DPE1 DP 09 IS SET
!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H & DBM 05 ARE SET, DP 06 IS CLEAR
!*	THIS SHOULD CLEAR USER I/O FLAG
!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
!*RESPONSE:
!*	EXAMINE DATA FROM MEM 0
!]NO ERROR 1
!]FCLK SPECPC NTWK
!]ERROR 14
!]PCDBUS FCLK SPECPC Q G S NTWK
	IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO IILLUMINATE  BLISS INFO 
	END;
	END;

GLOBAL ROUTINE TST46: NOVALUE =

!THIS TEST CHECKS ALL THE INPUT AND OUTPUT PINS FOR TRAP DECODER ON DPE9 .
!FIRST WE ENABLE TRAPS THROUGH THE 8080. THIS WILL SET PIN 3 ON DECODER.
!THIS TEST WILL EXECUTE 3 INSTRUCTIONS IN CRAM 1,2 & 3:
!CRAM 1/ LOAD THE TRAP FLAGS FROM THE MAGIC # FIELD.
!CRAM 2/ DO A SPEC /APR EN WITH BIT 22 HI ON DP. THIS WILL SET DPEB TRAP EN .
!CRAM 3/ DO A NICOND DISP.
!THE EXECUTION OF THESE INSTRUCTIONS WILL DETECT THE OUTPUT OF THE DECODER
!WHICH SETS CRA2 NICOND 09,10 & 11.
!THE NXT CRAM ADRS IS READ AND VERIFIED.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5;
	BIND
	POINTER = PLIT (U_J(2) U_SPEC_FLAGS U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_APR_EN U_N(20000) U,
			U_J(0) U_DISP_NICOND U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	TEST_FLG = 0;
	TP(1);						!SET TRAP ENABLES
	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
	RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN BEGIN
			ERRCA(1,5,.RCVDATA,4);	!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 1
!*STIMULUS:
!*	SET DPEB TRAP EN
!*	SET CSL4 TRAP EN
!*	DPE9 TRAP 1 FLAG IS CLEAR
!*	DPE9 TRAP 2 FLAG IS CLEAR
!*	WE DO A NICOND DISP
!*	CURRENT J FIELD = 0
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
	THEN
	    LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'1000');				!SET TRAP 1 FLAG
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
	RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 3				!CHECK DATA
		THEN BEGIN
			ERRCA(2,3,.RCVDATA,4);	!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 2
!*STIMULUS:
!*	SET DPEB TRAP EN
!*	SET CSL4 TRAP EN
!*	DPE9 TRAP 1 FLAG IS SET
!*	DPE9 TRAP 2 FLAG IS CLEAR
!*	WE DO A NICOND DISP
!*	CURRENT J FIELD = 0
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'2000');				!SET TRAP 2 FLAG
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
	RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 2				!CHECK DATA
		THEN BEGIN
			ERRCAS(1,3,2,.RCVDATA,4,0);	!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 3
!*STIMULUS:
!*	SET DPEB TRAP EN
!*	SET CSL4 TRAP EN
!*	DPE9 TRAP 1 FLAG IS CLEAR
!*	DPE9 TRAP 2 FLAG IS SET
!*	WE DO A NICOND DISP
!*	CURRENT J FIELD = 0
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'3000');				!SET TRAPS 1 & 2
	DO (0) WHILE
BLOCK4:	BEGIN
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
	RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRCAS(2,4,1,.RCVDATA,4,0);	!NO
			TEST_FLG = 1;
		     END;
!*MESSAGE 4
!*STIMULUS:
!*	SET DPEB TRAP EN
!*	SET CSL4 TRAP EN
!*	DPE9 TRAP 1 FLAG IS SET
!*	DPE9 TRAP 2 FLAG IS SET
!*	WE DO A NICOND DISP
!*	CURRENT J FIELD = 0
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(4,0);					!CLEAR DPEB TRAP EN
	SET_C(1);					!SET CRAM ADRS TO 1
BLOCK5:	BEGIN
	RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
	RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 5				!CHECK DATA
		THEN ERRCAS(2,5,5,.RCVDATA,4,0)		!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
!*MESSAGE 5
!*STIMULUS:
!*	CLEAR DPEB TRAP EN
!*	SET CSL4 TRAP EN
!*	DPE9 TRAP 1 FLAG IS SET
!*	DPE9 TRAP 2 FLAG IS SET
!*	WE DO A NICOND DISP
!*	CURRENT J FIELD = 0
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
	THEN
	    BEGIN
	    SET_C(1);					!SET CRAM ADRS TO 1
	    LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
	    END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!]ERROR 1
!]PIBUS SPECPC SPECAPR TRAP Q FCLK V A B I G C D U NTWK
!]ERROR 2
!]PIBUS SPECPC SPECAPR TRAP FCLK NTWK
!]NO ERROR 1
!]TRAP FCLK CCLK SPECPC SPECAPR NTWK
	TP(0);						!CLEAR TRAP ENABLES
	END;

GLOBAL ROUTINE TST47: NOVALUE =

!THIS TEST CHECKS ALL GATES AND FLOPS RELATED TO AC=0, XR=0, INDIRECT BIT & JRST,0 ON DPEA
!THIS TEST WILL EXECUTE 2 INSTRUCTIONS IN CRAM 1 & 2 THAT WILL DO THE FOLLOWING:
!CRAM 1/ LOAD THE INSTRUCTION REGISTER WITH A DATA WORD FROM THE MAGIC 
!	 # FIELD VIA DBUS & DP
!CRAM 2/ DO A DISP ON JRST,0, INDIRECT & XR=0 (DISP = 66)
!	 DO A SKIP ON AC=0 (SKIP = 36)
!AFTER EACH EXECUTIONS FEILDS ARE MODIFIED IN CRAM 1 TO SET UP THE DATA
!WORD TO BE LOADED IN THE INSTRUCTION REGISTER FOR THE NXT EXECUTION.
!OUTPUT IS VERIFIED BY EXEMINING THE NXT CRAM ADRS.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,
	      BLOCK8,BLOCK9,BLOCK10,BLOCK11,BLOCK12,BLOCK13,BLOCK14;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDINST U_N(254204) U,
		U_DISP_EAMODE U_SKIP_AC0 U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	TEST_FLG = 0;
	SET_C(1);					!SET CRAM ADRS TO 1
	ER_TAB[0] = UPLIT(%ASCIZ'HI');			!FOR ERROR
	ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR
	ER_TAB[2] = UPLIT(%ASCIZ'LO');			!FOR ERROR
	ER_TAB[3] = UPLIT(%ASCIZ'LO');			!FOR ERROR
	ER_TAB[4] = %O'254204';				!FOR ERROR
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'10'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'10',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) NEQ 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) NEQ 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(4);
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'4430');				!CHANGE DATA TO 254430
	ER_TAB[1] = UPLIT(%ASCIZ'HI');			!FOR ERROR
	ER_TAB[4] = %O'254430';				!FOR ERROR
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'14'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'14',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) NEQ 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) NEQ 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) EQL 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(4);
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'4102');				!CHANGE DATA TO 254102
	ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR
	ER_TAB[4] = %O'254102';				!FOR ERROR
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'10'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'10',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) NEQ 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) NEQ 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(4);
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'4041');				!CHANGE DATA TO 254041
	ER_TAB[4] = %O'254041';				!FOR ERROR
	DO (0) WHILE
BLOCK4:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'10'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'10',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) NEQ 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) NEQ 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(4);
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'4000');				!CHAGE DATA TO 254000
	ER_TAB[0] = UPLIT(%ASCIZ'LO');			!FOR ERROR
	ER_TAB[2] = UPLIT(%ASCIZ'HI');			!FOR ERROR
	ER_TAB[3] = UPLIT(%ASCIZ'HI');			!FOR ERROR
	ER_TAB[4] = %O'254000';				!FOR ERROR
	DO (0) WHILE
BLOCK5:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 3				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,3,.RCVDATA,4,ER_TAB);		!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') NEQ 0
		THEN FAILURE(4);
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'65');				!MODIFY DATA TO 654000
	ER_TAB[0] = UPLIT(%ASCIZ'HI');			!FOR ERROR
	ER_TAB[4] = %O'654000';				!FOR ERROR
	DO (0) WHILE
BLOCK6:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,5);					!CHANGE DATA TO 54000
	ER_TAB[4] = %O'54000';				!FOR ERROR
	DO (0) WHILE
BLOCK7:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'21');				!CHANGE DATA TO 214000
	ER_TAB[4] = %O'214000';				!FOR ERROR
	DO (0) WHILE
BLOCK8:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'24');				!CHANGE DATA TO 244000
	ER_TAB[4] = %O'244000';				!FOR ERROR
	DO (0) WHILE
BLOCK9:	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'27');				!CHANGE DATA TO 274000
	ER_TAB[4] = %O'274000';				!FOR ERROR
	DO (0) WHILE
BLOCK10:BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,%O'35');				!CHANGE DATA TO 354000
	ER_TAB[4] = %O'354000';				!FOR ERROR
	DO (0) WHILE
BLOCK11:BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,0);
	MOD_FLD(4,%O'25');				!CHANGE DATA TO 25000
	ER_TAB[4] = %O'25000';				!FOR ERROR
	DO (0) WHILE
BLOCK12:BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'6000');				!CHANGE DATA TO 256000
	ER_TAB[4] = %O'256000';				!FOR ERROR
	DO (0) WHILE
BLOCK13:BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN BEGIN
			ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'5000');				!CHANGE DATA TO 255000
	ER_TAB[4] = %O'255000';				!FOR ERROR
	DO (0) WHILE
BLOCK14:BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'13'				!CHECK DATA
		THEN ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB)	!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
	IF (.RCVDATA AND 1) EQL 0
		THEN FAILURE(1);
	IF (.RCVDATA AND 2) EQL 0
		THEN FAILURE(2);
	IF (.RCVDATA AND 4) NEQ 0
		THEN FAILURE(3);
	IF (.RCVDATA AND %O'10') EQL 0
		THEN FAILURE(5);
	IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*STIMULUS:
!*	LOAD INSTRUCTION REGISTER WITH A \O4
!*	EXECUTE THE FOLOWING:
!*		SKIP ON AC0 (SKIP = 36)
!*		DISP ON XR=0, JRST,0 & INDIRECT BIT (DISP = 66)
!*	THEN EXAMINE NXT CRAM ADRS. IT SHOULD BE:
!*	NXT ADRS = CRAM J + JRST,0 + INDIRECT BIT + XR=0 + AC=0
!*		 =  0000  +   \S0   +      \S1      +  \S2  +  \S3  
!*RESPONSE:
!]NO ERROR 1
!]FCLK SPECIR SPECXR AC0 XR0 IR JRST0 NTWK
!]ERROR 1
!]FCLK SPECIR AC0 IR SKIP NTWK
!]ERROR 2
!]FCLK SPECXR XR0 XR NTWK
!]ERROR 3
!]FCLK SPECXR XR NTWK
!]ERROR 4
!]FCLK AC0 JRST0 IR SPECIR NTWK
!]ERROR 5
!]FCLK IR JRST0 SPECIR NTWK
	END;

GLOBAL ROUTINE TST48: NOVALUE =

!THIS TEST CHECKS THE SKIP MIX'S ON FPD, USER & USER I/O FLAGS.
!THIS TEST WILL EXEUTE 2 INSTRUCTIONS IN CRAM 1 & 2 THAT WILL DO THE FOLLOWING:
!CRAM 1/ LOAD THE FLAGS FROM DP
!CRAM 2/ SKIP IF FLAG IS SET (THE CURRENT J FIELD IS 0000)
!AFTER EACH EXECUTION FIELDS ARE MODIFIED TO TEST SKIP ON NXT FLAG 
!ALSO AFTER EACH EXECUTION RESULT IS VERIFIED BY EXAMINNING THE NXT 
!CRAM ADRS (THE ORED J FIELD IS ALWAYS 0000).

	BEGIN
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4) U,
			U_SKIP_FPD U);
	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	DO (0) WHILE
BLOCK1:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(1,0,.RCVDATA,4);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD FPD FLAG WITH A 0 FROM DP
!*	SKIP IF FPD FLAG IS SET
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 1
!]SKIP NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(2,4);					!CHANGE TO SKIP ON USER FLAG
	DO (0) WHILE
BLOCK2:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(2,1,.RCVDATA,4);		!NO
!*MESSAGE 2
!*STIMULUS:
!*	LOAD USER FLAG WITH A 0 FROM DP
!*	SKIP IF USER FLAG IS CLEAR
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 2
!]SKIP NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(1,%O'6507');
	DO (0) WHILE
BLOCK3:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(3,0,.RCVDATA,4);		!NO
!*MESSAGE 3
!*STIMULUS:
!*	LOAD USER I/O FLAG WITH A 0 FROM DP CONDITIONALLY
!*	SKIP IF USER I/O FLAG IS SET
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 3
!]SKIP NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(4,3);					!MODIFY TO SET
	MOD_FLD(3,%O'404');				!USER, USER I/O & FPD FLAGS
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(1,%O'6307');				!MODIFY TO SKIP ON USER FLAG
	DO (0) WHILE
BLOCK4:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(4,0,.RCVDATA,4);		!NO
!*MESSAGE 4
!*STIMULUS:
!*	LOAD USER FLAG WITH A 1 FROM DP
!*	SKIP IF USER FLAG IS CLEAR
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 4
!]SKIP NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(1,%O'6507');				!MODIFY TO SKIP ON I/O FLAG
	DO (0) WHILE
BLOCK5:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(5,1,.RCVDATA,4);		!NO
!*MESSAGE 5
!*STIMULUS:
!*	LOAD USER I/O FLAG WITH A 1 FROM DP CONDITIONALLY
!*	SKIP IF USER I/O FLAG IS SET
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 5
!]SKIP NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(1,%O'6307');
	MOD_FLD(2,5);					!MODIFY TO SKIP ON FPD FLAG
	DO (0) WHILE
BLOCK6:	BEGIN
	SET_C(1);					!SET CRAM ADRS TO 1
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(6,1,.RCVDATA,4);		!NO
!*MESSAGE 6
!*STIMULUS:
!*	LOAD FPD FLAG WITH A 2 FROM DP
!*	SKIP IF FPD FLAG IS SET
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 6
!]SKIP NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST49: NOVALUE =

!THIS TEST CHECKS ALL THE DBUS PARITY IMPLEMENTATION LOGIC ON DPPE3 & 4.
!THIS TEST WILL OUTPUT A SEQUENCE OF SELECTED DATA WORDS ON THE DBUS
!VIA THE MAGIC # FIELD & DBM.IT WILL READ FROM MEMORY A 0 OR A 1,,1 TO 
!SET OR CLEAR THE MEMORY BUS PARITY BITS.IT WILL ALSO CHCK THE LEFT & 
!RIGHT HALFS OF THE DBUS SEPERATLY. THE OUTPUT IS VERIFIED BY READING THE 8080'S
!REGISTER 100 WHERE BIT 2 (DP PARITY L) INDICATES THE PARITY CONDITION.
!THE EXECUTED INSTRUCTIONS RESIDE IN CRAM 0,1 & 2 :
!CRAM 0/ START A PHYSICAL MEM READ CYCLE & LOAD THE VMA WITH A 0.
!CRAM 1/ FINISH THE CYCLE AND READ FROM PHYSICAL MEM 0.
!(PRIOR TO EXECUTING THOSE 2 INSTRUCTIONS, A 0 DATA IS WRITTEN INTO PHYSICAL
!MEM 0 TO CLEAR BOTH HALFS OF MEMORY BUS PARITY, AND A 1,,1 TO SET THEM).
!CRAM 2/ INPUT A DATA WORD FROM THE MAGIC # FIELD AND OUTPUT IT ON THE
!	 DBUS VIA DBM. CHCK LEFT, RIGHT, BOTH OR NEITHER HALFS OF THE DBUS.
!	 (EACH CONDITION IS TESTED SEPERATLY BY MODIFYING THE PROPER 
!	 FIELD IN THE CRAM).
!THEN WE READ REGISTER 100 AND VERIFY DP PARITY BIT.

	BEGIN
	OWN FLD,TEST_FLG,TESTR_FLG,TESTL_FLG,
	PEDATA:VECTOR[8] INITIAL(%O'666375',%O'220220',%O'444102',%O'11011',
				 %O'102444',%O'733733',%O'375666',%O'557557');
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	BIND
	POINTER = PLIT (U_J(1) U_MEM U_DBUS_DBM U_N(41012) U,
			U_J(2) U_DBUS_DBM U_MEM U_N(2) U,
			U_J(2) U_DBUS_DBM U);

	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	TEST_FLG = 0;
	TESTL_FLG = 0;
	TESTR_FLG = 0;
	SET_C(0);					!SET CRAM ADRS TO 0
	DM(0,0);					!CLEAR THIS LOCATION
	CP_NOSS(2);					!CLK THOSE 2 TO CLEAR MB PARITY
	MR();						!DO A MASTER RESET
	SET_C(2);					!SET CRAM ADRS TO 2
	INCR I FROM 0 TO 7 DO
	BEGIN
	MOD_FLD(7,%O'4304');				!MODIFY TO CHCK RIGHT HALF OF DBUS
	ER_TAB[1] = UPLIT (%ASCIZ'RIGHT');		!THIS FOR ERROR PRINTOUT
	ER_TAB[0] = .PEDATA[.I];			!SET UP FOR ERROR PRINTOUT
	FLD = .PEDATA[.I];				!GET THE CORRECT
	MOD_FLD(3,.FLD);				!FIELDS & MODIFY
	MOD_FLD(4,.FLD<12,6>);				!DATA IN THE MAGIC # FIELD
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(2);						!GIVE 2 CLKS
	RCVDATA = RD_100;				!READ REGISTER 100
	IF (.RCVDATA AND DP_PE) NEQ .I<0,1>^2		!CHK DATA
		THEN BEGIN
			ERRCAS(1,1,%O'353' OR (.RCVDATA AND %O'20') OR .I<0,1>^2,.RCVDATA,3,ER_TAB);	!NO
			TESTR_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(7,%O'4310');				!MODIFY TO CHCK LEFT HALF OF DBUS
	ER_TAB[1] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(2);						!GIVE 2 CLKS
	RCVDATA = RD_100;				!GET DATA FROM REGISTER 100
	IF (.RCVDATA AND DP_PE) NEQ .I<0,1>^2		!CHECK DATA
		THEN BEGIN
			ERRCAS(2,1,%O'353' OR (.RCVDATA AND %O'20') OR .I<0,1>^2,.RCVDATA,3,ER_TAB);!NO
			TESTL_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;
!*MESSAGE 1
!*	PARITY LOGIC TEST ON DPE3,4
!*STIMULUS:
!*	OUTPUT A \O0 ON THE \S1 HALF OF THE DBUS
!*	CHECK \S1 HALF OF DBUS PARITY
!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
!*	IT SHOULD BE SET FOR CORRECT EVEN PARITY OUTPUT
!*	AND CLEAR FOR CORRECT ODD PARITY OUTPUT
!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH LO
!*RESPONSE:
	DM(0,1000001);					!DEPOSIT A 1 IN MEMORY
	DO (0) WHILE
BLOCK3:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = RD_100;				!GET DATA
	IF (.RCVDATA AND DP_PE) NEQ 0			!CHECK DATA
		THEN BEGIN
			ERRCAS(2,2,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
			TESTL_FLG = 1;
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(7,%O'4304');				!MODIFY TO CHCK RIGHT HALF
	ER_TAB[1] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = RD_100;				!GET DATA
	IF (.RCVDATA AND DP_PE) NEQ 0			!CHECK DATA
		THEN BEGIN
			ERRCAS(1,2,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
			TESTR_FLG = 1;
		     END;
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,1);					!MODIFY DBUS DATA
	MOD_FLD(4,0);					!TO 1
	ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK5:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = RD_100;				!GET DATA
	IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
		THEN BEGIN
			ERRCAS(1,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
			TESTR_FLG = 1;
		     END;
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(7,%O'4310');				!MODIFY TO CHCK LEFT HALF
	ER_TAB[1] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK6:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = RD_100;				!GET DATA
	IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
		THEN BEGIN
			ERRCAS(2,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
			TESTL_FLG = 1;
		     END;
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 2
!*	PARITY LOGIC TEST ON DPE3,4
!*STIMULUS:
!*	OUTPUT A \O0 ON THE \S1 HALF OF THE DBUS
!*	CHECK \S1 HALF OF DBUS PARITY
!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
!*	IT SHOULD BE CLEAR FOR CORRECT EVEN PARITY OUTPUT
!*	AND SET FOR CORRECT ODD PARITY OUTPUT
!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH HI
!*RESPONSE:
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,0);					!MODIFY DBUS DATA TO 0
	MOD_FLD(7,%O'4314');				!MODIFY TO CHCK BOTH HALFS
	DO (0) WHILE
BLOCK7:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	CP(4);						!GIVE 4 CLKS
	MR();						!CLEAR THE BAD PARITY CONDITION
	RCVDATA = RD_100;				!GET DATA
	IF .RCVDATA NEQ %O'377'				!CHECK DATA
		THEN BEGIN
			ERRCAS(3,3,%O'377',.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;
!*MESSAGE 3
!*	PARITY LOGIC TEST ON DPE3,4
!*STIMULUS:
!*	OUTPUT A \O0 ON BOTH HALFS OF THE DBUS
!*	CHCK BOTH HALFS OF DBUS PARITY
!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH HI
!*	THIS WILL CAUSE A DP PARITY ERROR
!*	NOW WE DO A MASTER RESET THIS SHOULD CLEAR THE CONDITION
!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
!*RESPONSE:
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(7,%O'4300');				!MODIFY NOT TO CHK DBUS PARITY
	DO (0) WHILE
BLOCK8:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	CP(4);						!GIVE 4 CLOCKS
	RCVDATA = RD_100;				!GET DATA
	IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
		THEN BEGIN
			ERRCAS(3,4,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;
	IF .TESTR_FLG EQL 0
		THEN NOERR(1);
	IF .TESTL_FLG EQL 0
		THEN NOERR(2);
	IF (.TEST_FLG OR .TESTL_FLG OR .TESTR_FLG) EQL 0
		THEN NOERR(3);
!*MESSAGE 4
!*	OUTPUT A \O0 ON BOTH HALFS OF THE DBUS
!*	DON'T CHCK  EITHER HALF OF DBUS PARITY
!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH HI
!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
!*RESPONSE:
!]NO ERROR 1
!]DBUSPER NTWK
!]NO ERROR 2
!]DBUSPEL NTWK
!]NO ERROR 3
!]DBUSPER DBUSPEL PE BCLK NTWK
!]ERROR 1
!]BCLK DBUSPR DBUSPER PE NTWK
!]ERROR 2
!]BCLK DBUSPL DBUSPEL PE NTWK
!]ERROR 3
!]BCLK PE NTWK
	END;

GLOBAL ROUTINE TST50: NOVALUE =

!THIS TEST CHECKS THE DP PARITY IMPLEMENT RAM ON DPE4.
!THIS TEST WILL EXECUTE 2 INSTRUCTIONS IN CRAM 1 & 2 :
!CRAM 1/ WRITE INTO THE 2901'S A DATA WORD PASSED THROUGH FROM THE MAGIC
!	 # FIELD VIA DBUS AND DBM. GENERATE  AND STOR L/R OF THE DP PARITY.
!CRAM 2/ PASS A 0 FROM THE 2901'S INTO DBUS AND CHECK L/R OF THE DBUS 
!	 PARITY.(THIS INSTRUCTION IS EXECUTED TWICE IN ORDER TO ALLOW 
!	 THE PARITY ERROR TO PROPEGATE THROUGH TO THE 8080'S REGISTER 100).
!AFTER EXECUTING THOSE 2 INSTRUCTION WE EXAMINE REGISTER 100 AND VERIFY
!THE DP PARITY BIT SET OR CLEAR.
!ALSO AFTER EACH EXECUTION WE MODIFY FIELDS IN BOTH MICROWORDS TO 
!SELECT A DIFFERENT DATA WORD FOR ODD AND EVEN PARITY, SELECT THE NEXT 
!DP B ADRS, ENABLE OR DISABLE THE PARITY CHECKS ON THE DP AS WELL AS THE
!DBUS FOR TESTING EACH HALF SEPERATLY.

	BEGIN
	OWN PEFLG,TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
	      BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_GENR U_GENL U_N(1) U,
			U_J(2) U_CHKL U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	PEFLG = 0;					!CLEAR THIS FLAG
	TEST_FLG = 0;
	MR();						!CLEAR PARITY REGISTER
	ER_TAB[0] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
	INCR I FROM 0 TO 15 DO
	    BEGIN
		ER_TAB[1] = .I;				!FOR ERROR PRINTOUT
		LC(2);					!LOAD CRAM ADRS 2
		MOD_FLD(6,%O'2000' OR .I);		!MODIFY B FIELD
		LC(1);					!SET CRAM ADRS TO 1
		MOD_FLD(4,%O'1400');			!ENABLE DP PARITY
		MOD_FLD(6,%O'6000' OR .I);		!MODIFY B FIELD
		DO (0) WHILE
BLOCK1:		    BEGIN
			CP(3);				!GIVE 3 CLOCKS
			RCVDATA = RD_100;		!READ REGISTER 100
			IF (.RCVDATA AND DP_PE) NEQ 0	!CHECK DATA
			    THEN BEGIN
					ERRCAS(2,1,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				  END;
			IF LOOP_CHK(1)			!IS LOOP ON ERROR SET ?
			THEN 
			    BEGIN
			    SET_C(1);			!SET CRAM ADRS TO 1
			    LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
			    END;
			0				!TO ILLUMINATE BLISS INFO COMMENT
		    END;
		MOD_FLD(3,0);				!CHANGE DATA TO 0
		DO (0) WHILE
BLOCK2:		    BEGIN
			CP(3);				!GIVE 3 CLOCKS
			RCVDATA = RD_100;		!READ REGISTER 100
			IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
			    THEN BEGIN
					ERRCAS(2,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				  END;
			IF LOOP_CHK(2)			!IS LOOP ON ERROR SET ?
			THEN
			    BEGIN
			    SET_C(1);			!SET CRAM ADRS TO 1
			    LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
			    END;
			0				!TO ILLUMINATE BLISS INFO COMMENT
		    END;
		LC(2);					!LOAD CRAM ADRS 2
		MOD_FLD(7,%O'4304');			!MODIFY TO CHK RIGHT HALF OF DBUS
		ER_TAB[0] = UPLIT (%ASCIZ'RIGHT');	!FOR ERROR PRINTOUT
		DO (0) WHILE
BLOCK3:		    BEGIN
			SET_C(1);			!SET CRAM ADRS TO 1
			CP(3);				!GIVE 3 CLOCKS
			RCVDATA = RD_100;		!READ REGISTER 100
			IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
			    THEN BEGIN
					ERRCAS(1,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				  END;
			IF LOOP_CHK(3)			!IS LOOP ON ERROR SET ?
			    THEN LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		    END;
		MOD_FLD(3,1);				!CHANGE DATA TO ODD PAR
		DO (0) WHILE
BLOCK4:		    BEGIN
			CP(3);				!GIVE 3 CLOCKS
			RCVDATA = RD_100;		!READ REGISTER 100
			IF (.RCVDATA AND DP_PE) NEQ 0	!CHECK DATA
			    THEN BEGIN
					ERRCAS(1,1,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				  END;
			IF LOOP_CHK(4)			!IS LOOP ON ERROR SET ?
			THEN
			    BEGIN
			    SET_C(1);			!SET CRAM ADRS TO 1
			    LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP
			    END;
			0				!TO ILLUMINATE BLISS INFO COMMENT
		    END;
		MOD_FLD(4,0);				!DISABLE BOTH HALFS OF DP PARITY
		DO (0) WHILE
BLOCK5:		    BEGIN
			CP(3);				!GIVE 3 CLOCKS
			RCVDATA = RD_100;		!READ REGISTER 100
			IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
			    THEN BEGIN
					ERRCAS(3,3,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				  END;
			IF LOOP_CHK(5)			!IS LOOP ON ERROR SET ?
			THEN
			    BEGIN
			    SET_C(1);			!SET CRAM ADRS TO 1
			    LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP
			    END;
			0				!TO ILLUMINATE BLISS INFO COMMENT
		    END;
		LC(2);					!LOAD CRAM ADRS 2
		MOD_FLD(7,%O'4310');			!MODIFY TO CHK LEFT HALF OF DBUS
		ER_TAB[0] = UPLIT (%ASCIZ'LEFT');	!FOR ERROR PRINTOUT
		DO (0) WHILE
BLOCK6:		    BEGIN
			SET_C(1);			!SET CRAM ADRS TO 1
			CP(3);				!GIVE 3 CLOCKS
			RCVDATA = RD_100;		!READ REGISTER 100
			IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
			    THEN BEGIN
					ERRCAS(4,3,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				  END;
			IF LOOP_CHK(6)			!IS LOOP ON ERROR SET ?
			    THEN LEAVE BLOCK6 WITH 1;	!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		    END;
	    END;
	IF .TEST_FLG EQL 0
		THEN NOERR(1);
!*MESSAGE 1
!*	DP PARITY TEST
!*STIMULUS:
!*	WRITE INTO THE 2901'S SELECTING DEST = 1, WITH PARITY ODD 
!*	HI FOR BOTH HALFS. ENABLE BOTH HALFS OF DP PARITY.DP B ADRS = \O1
!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALF
!*	OF DBUS PARITY.THIS WILL FORCE A BAD PARITY ON \S0 HALF.
!*	EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS

!*MESSAGE 2
!*	DP PARITY TEST
!*STIMULUS:
!*	WRITE INTO THE 2901'S SELECTING DEST = 1, WITH PARITY ODD 
!*	LO FOR BOTH HALFS. ENABLE BOTH HALFS OF DP PARITY.DP B ADRS = \O1
!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALF
!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS

!*MESSAGE 3
!*	DP PARITY TEST
!*STIMULUS:
!*	WRITE INTO THE 2901'S SELECTING DEST = 1, WITH PARITY ODD 
!*	HI FOR BOTH HALFS. DISABLE BOTH HALFS OF DP PARITY.DP B ADRS = \O1
!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALF
!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]NO ERROR 1
!]DPPE NTWK
!]ERROR 1
!]DPDBUS BCLK PE DBUSPER DBUSPR PWRITE DPPE NTWK
!]ERROR 2
!]DPDBUS BCLK PE DBUSPEL DBUSPL PWRITE DPPE NTWK
!]ERROR 3
!]DPDBUS DPPE PE DBUSPR BCLK PWRITE NTWK
!]ERROR 4
!]DPDBUS DPPE PE DBUSPL BCLK PWRITE NTWK
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(7,%O'4314');				!MODIFY TO CHK BOTH HALFS OF DBUS
	ER_TAB[0] = UPLIT (%ASCIZ'BOTH');		!FOR ERROR PRINTOUT
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(7,%O'4700');				!USE DEST = 7
	MOD_FLD(4,%O'1400');				!ENABLE BOTH HALFS OF DP PARITY
	DO (0) WHILE
BLOCK7:	    BEGIN
		CP(3);					!GIVE 3 CLOCKS
		RCVDATA = RD_100;			!READ REGISTER 100
		IF (.RCVDATA AND DP_PE) NEQ 0		!CHECK DATA
		    THEN BEGIN
				ERRCAS(5,4,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
				PEFLG = 1;
			 END;
		IF LOOP_CHK(7)				!IS LOOP ON ERROR SET ?
		THEN
		    BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
		    END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
	    END;
!*MESSAGE 4
!*	DP PARITY TEST
!*STIMULUS:
!*	WRITE INTO THE 2901'S SELECTING DEST = 7, WITH PARITY ODD 
!*	HI FOR BOTH HALFS. ENABLE BOTH HALFS OF DP PARITY.
!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALFS
!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]ERROR 5
!]PWRITE PE BCLK DPPE NTWK
	MOD_FLD(7,%O'4300');				!SELECT DEST 3
	MOD_FLD(3,0);					!ODD PAR IS LO
	IF .PEFLG EQL 0 THEN
	DO (0) WHILE
BLOCK8:	    BEGIN
		CP(3);					!GIVE 3 CLOCKS
		RCVDATA = RD_100;			!READ REGISTER 100
		IF (.RCVDATA AND DP_PE) NEQ 0		!CHECK DATA
		    THEN ERRCAS(6,5,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB)	!NO
		    ELSE IF .TEST_FLG EQL 0
			THEN NOERR(2);
		IF LOOP_CHK(8)				!IS LOOP ON ERROR SET ?
		THEN
		    BEGIN
		    SET_C(1);				!SET CRAM ADRS TO 1
		    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
		    END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
	    END;
!*MESSAGE 5
!*	DP PARITY TEST
!*STIMULUS:
!*	WRITE INTO THE 2901'S SELECTING DEST = 3, WITH PARITY ODD 
!*	HI FOR BOTH HALFS.DPE5 WRITE PARITY SHOULD BE HI. PARITY SHOULD 
!*	NOT CHANGE IN THE RAM.
!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALFS
!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
!*RESPONSE:
!*	EXAMINE NXT CRAM ADRS
!]NO ERROR 2
!]PWRITE NTWK
!]ERROR 6
!]PWRITE NTWK
	END;

GLOBAL ROUTINE TST51: NOVALUE =

!THIS TEST CHECKS THE RAMFILE ON DPE7 & 8.(EXCEPT RAMFILE PARITY CHIPS).
!IT SELECTS THE RAMFILE ADRS FROM THE VMA WHICH GETS LOADED FROM THE 
!Q REGISTER OF THE 2901'S. THE Q REGISTER IS INCREMENTED BY 1 EACH TIME 
!WE GO THROUGH THE LOOP TO SELECT THE NXT RAMFILE ADRS.
!THE DATA IS WRITTEN INTO THE RAMFILE FROM THE MAGIC # FIELD VIA DBM & DBUS.
!THE DATA IS VERIFIED BY PASSING THE CONTENTS OF THE RAMFILE ADRS POINTED
!TO BY THE VMA THROUGH THE 2901'S AND SKIP IF THE OUTPUT OF THE 2901'S 
!CONTAINS THE CORRECT DATA.
!WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP TO THE CORRECT LOCATION.
!IN CASE OF AN ERROR THE CRAM ADRS IS RESET TO LOCATION 1 AND FEILDS 
!ARE MODIFIED IN ORDER TO WRITE THE CONTENTS OF THE RAMFILE OUT TO THE 
!MEMORY LOCATION POINTED TO BY THE VMA WHICH IS THE SAME AS RAMFILE ADRS 
!UNDER TEST. WE EXAMINE THE CORRESPONDING MEM LOCATION AND PASS IT AS 
!AN ACTUAL DATA FRO THE ERROR PRINTOUT.
!NOTE:	(THIS TEST WILL TAKE APRX. 5 MIN TO PASS. IT WILL NOT ALOW 
!	SINGLE STEP EXCEPT IN CASE OF AN ERROR).

	BEGIN
	OWN RAMFLG,TEST_FLG;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_ADD U_LSRC_DQ U_DBUS_DBM U_DEST_Q_AD U_SPEC_MEMCLR U_N(1) U,
			U_J(2) U_ALU_OR U_LSRC_0Q U_MEM U_N(11012) U,
			U_J(3) U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_RAM_RAM U_DBUS_RAM U_SKIP_ADEQ0 U_MEM U_N(11002) U,
			U_J(1) U_ALU_OR U_LSRC_D0 U_RAM_RAM U_DBUS_RAM U_MEM U_N(2) U,
			U_J(6) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U_N(777777) U,
			U_J(4) U_ALU_XOR U_LSRC_DA U_A_T1 U_RAM_RAM U_DBUS_RAM U_SKIP_ADEQ0 U_MEM U_N(11002) U,
			U_J(7) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(777777) U);
	IF .RAMFILE_FLAG NEQ 0
		THEN RETURN;
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(7);					!SET CRAM ADRS TO 7
	TEST_FLG = 0;
	RAMFLG = 0;
	CP_NOSS(2);					!GIVE 2 CLKS TO LOAD THE ADRS COUNTER INTO THE Q REGISTER
	INCR I FROM 0 TO 1023 DO			!0 TO 1777 OCTAL
	    BEGIN
		ER_TAB[0]  = .I;			!FOR ERROR PRINTOUT
		SET_C(0);				!SET CRAM ADRS TO 0
		CP_NOSS(4);				!DON'T SINGLE STEP THE NXT 4 CLKS
		RCVDATA = EX_NXT;			!GET THE NXT CRAM ADRS
		IF .RCVDATA NEQ 5			!IS IT = TO 5 ?
		THEN 					!NO, THEN WE HAVE AN ERROR
		    BEGIN
			SET_C(1);			!SET CRAM ADRS TO 1
			DO (0) WHILE
BLOCK1:			    BEGIN
				ER_TAB[1] = 0;		!FOR ERROR PRINTOUT
				CP(4);			!GIVE 4 CLOCKS
				TEST_FLG = 1;
				RCVDATA = MEM_EXAMINE(.I);	!GET DATA FROM MEM
				ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);   !CALL THE ERROR ROUTINE
				RAMFLG = 1;
				IF LOOP_CHK(1)		!IS LOOP ON ERROR SET ?
				    THEN LEAVE BLOCK1 WITH 1	!LEAVE BLOCK TO LOOP
				ELSE
				   MOD_FLD(0,5);		!MODIFY J FIELD TO GO TO 5
			    0
			    END;
		    END;
		IF .RAMFLG EQL 0 			!DID WE JUST GET AN ERROR ?
		    THEN CP_NOSS(2)			!NO, PROCEED NORMALLY
		ELSE
		    CP_NOSS(3);				!YES, THEN GIVE 3 CLKS
		RCVDATA = EX_NXT;			!GET NXT CRAM ADRS
		IF .RAMFLG NEQ 0 			!AGAIN, DID WE JUST GET AN ERROR
		    THEN MOD_FLD(0,2);			!YES, THEN REMODIFY THIS FIELD
		IF .RCVDATA NEQ 5			!IS THE NXT CRAM ADRS CORCT
		THEN					!NO, WE HAVE AN ERROR
		    BEGIN
			LC(1);				!LOAD CRAM ADRS 1
			MOD_FLD(0,5);			!MODIFY J FIELD
			DO (0) WHILE
BLOCK2:			    BEGIN
				ER_TAB[1] = %O'-1';	!FOR ERROR PRINTOUT
				TEST_FLG = 1;
				CP(4);			!GIVE 4 CLKS
				RCVDATA = MEM_EXAMINE(.I);	!GET DATA FROM MEMORY
				ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);!CALL ERROR ROUTINE
				IF LOOP_CHK(2)		!IS LOOP ON ERROR SET ?
				    THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
			    0
			    END;
			MOD_FLD(0,2);			!REMODIFY THIS FIELD BEFOR WE EXIT THE ERROR PROCESS
		    END;
		RAMFLG = 0;				!CLEAR THE ERROR FLAG WE ARE LOOPING TO A NEW ADRS
	    END;
	IF .TEST_FLG EQL 0
		THEN NOERR (1);
	LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
!*MESSAGE 1
!*STIMULUS:
!*	LOAD THE VMA WITH RAMFILE ADRS \O0 FROM THE 2901'S Q REGISTER
!*	WRITE A \O1 INTO RAMFILE ADRS SELECTED BY THE VMA
!*	START A PHYSICAL MEM WRITE CYCLE
!*	OUTPUT THE CONTENTS OF THE RAMFILE INTO MEM
!*	(BOTH RAMFILE AND PHYSICAL MEM ADRS'S ARE SELECTED BY THE VMA = \O0)
!*	EXAMINE THE SELECTED MEM LOCATION \O0 AND VERIFY DATA
!*RESPONSE:
!]ERROR 1
!]ADEQ0 RAMDBUS RAMWRITE RAM BCLK NTWK
!]NO ERROR 1
!]RAMWRITE BCLK RAMDBUS RAM NTWK
	END;

GLOBAL ROUTINE TST52: NOVALUE =

!THIS TEST CHECKS THE TWO RAMFILE PARITY CHIPS .
!THIS TEST WILL EXECUTE INSTRUCTIONS THAT WILL WRITE INTO THE RAMFILE
!A DATA WORD GENERATING ODD PARITY HI/LO TO BE STORED IN THE RAMFILE.
!THEN IT READS BACK THE RAMFILE INTO THE DBUS AND CHECK BOTHE HALFS 
!FOR PARITY. IF THE PARITY CHIPS ARE IN FAULT A PARITY ERROR WILL EXIST 
!IN THE 8080'S REGISTER 100. WE EXAMINE THAT REGISTER AND VERIFY IT.
!THE RAMFILE ADRS IS SUPPLIED BY THE VMA WHICH GETS LOADED FROM THE Q
!REGISTER OF THE 2901'S.
!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
!CRAM 0/ INCRAMENT THE Q REGISTER.
!CRAM 1/ OUPTUT THE Q REGISTER ONTO DP AND LOAD THE VMA FROM DP.
!CRAM 2/ PASS A 0 FROM THE MAGIC # FIELD INTO THE DBUS AND WRITE IT 
!	 IN THE RAMFILE ADRS SELECTED BY THE VMA.
!CRAM 3/ READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY THE VMA 
!	 INTO THE DBUS AND CHECK BOTH HALFS OF THE DBUS FOR PARITY.
!	 (THIS INSTRUCTION IS EXECUTED TWICE).
!CRAM 4/ OUPTUT THE Q REGISTER ONTO DP AND LOAD THE VMA FROM DP.
!CRAM 5/ PASS A 1 FROM THE MAGIC # FIELD INTO THE DBUS AND WRITE IT 
!	 IN THE RAMFILE ADRS SELECTED BY THE VMA.
!CRAM 6/ READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY THE VMA 
!	 INTO THE DBUS AND CHECK BOTH HALFS OF THE DBUS FOR PARITY.
!	 (THIS INSTRUCTION IS EXECUTED TWICE).
!AFTER THE EXECUTION OF EACH 3 INSTRUCTIONS (1,2&3) (4,5&6) WE EXAMINE
!REGITER 100 AND VERIFY DP PARITY BIT.
!NOTE:	(THIS TEST WILL TAKE APRX. 5 MIN TO PASS).

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_ADD U_LSRC_DQ U_DBUS_DBM U_DEST_Q_AD U_SPEC_MEMCLR U_N(1) U,
			U_J(2) U_ALU_OR U_LSRC_0Q U_MEM U_N(11012) U,
			U_J(3) U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U,
			U_J(3) U_RAM_RAM U_DBUS_RAM U_CHKL U_CHKR U,
			U_J(5) U_ALU_OR U_LSRC_0Q U_MEM U_N(11012) U,
			U_J(6) U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U_N(1) U,
			U_J(6) U_RAM_RAM U_DBUS_RAM U_CHKL U_CHKR U,
			U_J(7) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(777777) U);

	IF .RAMFILE_FLAG NEQ 0
		THEN RETURN;

	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(7);					!SET CRAM ADRS TO 7
	CP_NOSS(2);					!LOAD THE ADRS COUNTER IN THE Q REGISTER
	TEST_FLG = 0;
	INCR I FROM 0 TO 1023 DO
	    BEGIN
		ER_TAB[0] = .I;				!FOR ERROR PRINTOUT
		ER_TAB[1] = UPLIT (%ASCIZ'LO');		!FOR ERROR PRINTOUT
		SET_C(0);				!SET CRAM ADRS TO 0
		CP_NOSS(1);				!INCREMENT COUNTER
		DO (0) WHILE
BLOCK1:		    BEGIN
			CP(4);				!GIVE 4 CLOCKS
			RCVDATA = RD_100;		!GET THE DATA
			IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
			    THEN BEGIN
					ERRCAS(1,1,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				 END;
			IF LOOP_CHK(1)			!IS LOOP ON ERROR SET ?
			THEN 
			    BEGIN
				SET_C(1);		!SET CRAM ADRS TO 1
				LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
			    END;
			0				!TO ILLUMINATE BLISS INFO COMMENT
		    END;
		ER_TAB[1] = UPLIT (%ASCIZ'HI');		!FOR ERROR PRINTOUT
		DO (0) WHILE
BLOCK2:		    BEGIN
			SET_C(4);			!SET CRAM ADRS TO 4
			CP(4);				!GIVE 4 CLOCKS
			RCVDATA = RD_100;		!GET DATA
			IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
			    THEN BEGIN
					ERRCAS(1,1,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
					TEST_FLG = 1;
				  END;
			IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
			    THEN LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		    END;
	    END;
	IF .TEST_FLG EQL 0
		THEN NOERR(1);
!*MESSAGE 1
!*	RAMFILE PARITY TEST
!*STIMULUS:
!*	LOAD THE VMA WITH RAMFILE ADRS \O0 FROM THE 2901'S Q REGISTER
!*	WRITE INTO THE RAMFILE ADRS POINTED TO BY THE VMA
!*	A DATA WORD TO GENERATE BOTH HALFS OF PARITY \S1 .
!*	OUTPUT THE CONTENTS OF THE RAMFILE THROUGH THE DBUS
!*	AND CHECK BOTH HALFS OF THE DBUS PARITY.
!*	EXAMINE THE 8080'S REGISTER 100 AND VERIFY DP PPARITY BIT.
!*RESPONSE:
!]ERROR 1
!]RAM RAMDBUS RAMPAR RAMADRS RAMSEL RAMWRITE DBUSPEL DBUSPER DBUSPL DBUSPR PE BCLK NTWK
!]NO ERROR 1
!]BCLK RAMWRITE RAMPAR NTWK
	LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
	END;

GLOBAL ROUTINE TST53: NOVALUE =

!THIS TEST CHECKS THE OUTPUT OF THE RAMFILE ADRS LOGIC FOR STUCK HI.
!THIS TEST WILL DO THE FOLLOWING:
!	1) WRITE A ZERO INTO RAMFILE LOCATION 1777.
!	2) WRITE A -1 INTO RAMFILE LOCATION (FLOAT A 0 ACROSS 1777).
!	3) READ BACK RAMFILE LOCATION 1777 AND VERIFY THAT IT DID NOT CHANGE
!THIS TEST WILL EXECUTE THE FOLLOWING INSTRUCTIONS:
!CRAM 0/ PUT THE (1777 WITH A ZERO FLOATING ACROSS) IN 2901'S.
!CRAM 1/ LOAD THE VMA WITH A 1777
!CRAM 2/ WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA.
!CRAM 3/ LOAD THE VMA WITH THE TESTED BIT DATA FROM THE 2901'S
!CRAM 4/ WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA.
!CRAM 5/ LOAD THE VMA WITH A 1777.
!CRAM 6/ READ THE RAMFILE LOCATION POINTED TO BY THE VMA AND SKIP IF 
!	 ITS 0 (THE CURRENT J FIELD IS 0).
!WE READ THE NEXT CRAM ADRS AND VERIFY THAT IT DID SKIP TO CRAM 1 IF
!NO ERROR. AFTER EACH EXECUTION, THE # FIELD IS MODIFIED IN CRAM 0 TO 
!SET UP THE DATA FOR THE NXT RAMFILE ADRS BIT.

	BEGIN
	LABEL BLOCK1;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_B_PC U,
			U_J(2) U_ALU_OR U_A_HR U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U_DEST_AD U_RAM_RAM U_FMWRITE U,
			U_J(4) U_ALU_OR U_A_PC U_MEM U_N(11012) U,
			U_J(5) U_SPEC_MEMCLR U_ALU_XNOR U_RAM_RAM U_FMWRITE U,
			U_J(6) U_ALU_OR U_A_HR U_MEM U_N(11012) U,
			U_ALU_OR U_LSRC_D0 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U,
			U_J(7) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_NO_CLKL U_N(1777) U);

	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(7);					!SET CRAM ADRS TO 7
	CP_NOSS(2);					!GIVE 2 CLKS
	SET_C(0);					!SET CRAM ADRS TO 0
	INCR I FROM 0 TO 9 DO
	BEGIN
		MOD_FLD(3,%O'1777' XOR (1^.I));		!MODIFY THIS FIELD
	ER_TAB[0] = %O'1777' XOR (1^.I);		!FOR ERROR PRINTOUT
	ER_TAB[1] = 9-.I;					!HERE TOO
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);		!NO
			ADRSFLG = 1;
		     END
		ELSE TEST53_FLG = 0;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;

	    END;
!*MESSAGE 1
!*	RAMFILE ADRS TEST
!*STIMULUS:
!*	LOAD THE VMA WITH A 1777
!*	WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA
!*	LOAD THE VMA WITH A \O0
!*	WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA
!*	LOAD THE VMA BACK WITH A 1777
!*	READ THE CONTENTS OF THE RAMFILE POINTED TO BY THE VMA 
!*	AND VERIFY THAT IT DID NOT CHANGE
!*RESPONSE:
!*	RAMFILE CONTENTS DID CHANGE
!*	BIT 0\D1 OF RAMFILE ADRS IS STUCK HI
!]ERROR 1
!]ADEQ0 RAM RAMADRS RAMSEL RAMDBUS TBVMACPY RAMWRITE BCLK NTWK
	END;

GLOBAL ROUTINE TST54: NOVALUE =

!THIS TEST CHECKS THE OUTPUT OF THE RAMFILE ADRS LOGIC FOR STUCK LO.
!THIS TEST WILL DO THE FOLLOWING:
!	1) WRITE A ZERO INTO RAMFILE LOCATION 0.
!	2) WRITE A -1 INTO RAMFILE LOCATION (FLOAT A 1).
!	3) READ BACK RAMFILE LOCATION 0 AND VERIFY THAT IT DID NOT CHANGE
!THIS TEST WILL EXECUTE THE FOLLOWING INSTRUCTIONS:
!CRAM 0/ PUT THE (A 1 FLOATING CROSS THE RAMFILE ADRS) IN 2901'S.
!CRAM 1/ LOAD THE VMA WITH A 0
!CRAM 2/ WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA.
!CRAM 3/ LOAD THE VMA WITH THE TESTED BIT DATA FROM THE 2901'S
!CRAM 4/ WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA.
!CRAM 5/ LOAD THE VMA WITH A 0.
!CRAM 6/ READ THE RAMFILE LOCATION POINTED TO BY THE VMA AND SKIP IF 
!	 ITS 0 (THE CURRENT J FIELD IS 0).
!WE READ THE NEXT CRAM ADRS AND VERIFY THAT IT DID SKIP TO CRAM 1 IF
!NO ERROR. AFTER EACH EXECUTION, THE # FIELD IS MODIFIED IN CRAM 0 TO 
!SET UP THE DATA FOR THE NXT RAMFILE ADRS BIT.

	BEGIN
	LABEL BLOCK1;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_B_PC U,
			U_J(2) U_DEST_AD U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U_RAM_RAM U_FMWRITE U,
			U_J(4) U_ALU_OR U_A_PC U_MEM U_N(11012) U,
			U_J(5) U_SPEC_MEMCLR U_ALU_XNOR U_RAM_RAM U_FMWRITE U,
			U_J(6) U_MEM U_N(11012) U,
			U_ALU_OR U_LSRC_D0 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);

	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	INCR I FROM 0 TO 9 DO
	BEGIN
		MOD_FLD(3,1^.I);			!MODIFY THIS FIELD
	ER_TAB[0] = (1^.I);				!FOR ERROR PRINTOUT
	ER_TAB[1] = 9-.I;					!HERE TOO
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLK & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);		!NO
			ADRSFLG = 1;
		     END
		ELSE TEST54_FLG = 0;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;

	    END;
!*MESSAGE 1
!*	RAMFILE ADRS TEST
!*STIMULUS:
!*	LOAD THE VMA WITH A ZERO
!*	WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA
!*	LOAD THE VMA WITH A \O0
!*	WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA
!*	LOAD THE VMA BACK WITH A ZERO
!*	READ THE CONTENTS OF THE RAMFILE POINTED TO BY THE VMA 
!*	AND VERIFY THAT IT DID NOT CHANGE
!*RESPONSE:
!*	RAMFILE CONTENTS DID CHANGE
!*	BIT 0\D1 OF RAMFILE ADRS IS STUCK LO
!]ERROR 1
!]ADEQ0 RAM RAMADRS RAMSEL RAMDBUS TBVMACPY RAMWRITE BCLK NTWK
	END;

GLOBAL ROUTINE TST55: NOVALUE =

!THIS TEST CHECKS THE RAMFILE ADRS SELECT 0 .
!THIS TEST WILL DO THE FOLLOWING:
!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
!	   (RAMFILE SELECT = 6).
!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY DPE5 CURRENT
!	   AC BLOCKS AND DPEA AC (RAMFILE ADRS SELECT = 0).
!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
!	   THE VMA (RAMFILE SELECT = 6) AND VERIFY IT DID CHANGE TO -1.
!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 6:
!CRAM 0/ LOAD THE CURRENT BLOCK FROM THE MAGIC # FIELD VIA DBUS & DP
!CRAM 1/ LOAD THE IR (DPEA AC) FROM THE MAGIC # FIELD VIA DBUS & DP
!CRAM 2/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
!	 0 OF THE 2901'S.
!CRAM 3/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
!CRAM 4/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
!CRAM 5/ WRITE A -1 INTO THE SAME LOCATION BUT ADDRESSED FROM DPE5 CURRENT
!	 BLOCK AND DPEA AC.(RAMFILE SELECT = 0).
!CRAM 6/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
!	 (RAMFILE SELECT = 6) INTO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
!THOSE INSTRUCTIONS ARE EXECUTED TWICE FOR 2 ADRS SELECT INPUTS 0'S AND 1'S.
!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
!THE NXT ADRS INPUTS.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDACBLK U_N(7000) U,
			U_J(2) U_DBUS_DBM U_SPEC_LOADIR U_N(1777) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(177)U,
			U_J(4) U_ALU_OR U_MEM U_N(11012) U,
			U_J(5) U_RAM_RAM U_SPEC_MEMCLR U_FMWRITE U,
			U_J(6) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_RAM_AC U_FMWRITE U_N(777777) U,
			U_ALU_XOR U_LSRC_DA U_A_T1 U_RAM_RAM U_DBUS_RAM U_SKIP_ADEQ0 U);

	IF .ADRSFLG NEQ 0
		THEN RETURN;
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	ER_TAB[0] = UPLIT (%ASCIZ'ONES');		!FOR ERROR PRINTOUT
	ER_TAB[1] = %O'177';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST55_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,0);					!CHANGE # FIELD TO 0
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(3,0);					!CHANGE # FIELD TO 0
	LC(0);						!LOAD CRAM ADRS TO 0
	MOD_FLD(3,0);					!CHANGE # FIELD TO 0
	ER_TAB[0] = UPLIT (%ASCIZ'ZEROS');		!FOR ERROR PRINTOUT
	ER_TAB[1] = 0;					!HERE TOO
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST55_FLG = 1;
		     END;
	IF .TEST55_FLG EQL 0
		THEN NOERR(1);
	IF (.TEST55_FLG OR .TEST53_FLG) EQL 0
		THEN NOERR(2)
		ELSE IF (.TEST55_FLG OR .TEST54_FLG) EQL 0
			THEN NOERR(2);
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	RAMFILE ADRS TEST (RAMFILE SELECT = 0)
!*STIMULUS:
!*	LOAD DPE5 CURRENT AC BLOCK WITH \S0.
!*	LOAD DPEA AC WITH \S0.
!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O1.
!*	CLEAR RAMFILE LOCATION POINTED TO BY THE VMA (SELECT = 6).
!*	WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY 
!*	DPEA AC & DPE5 AC CURRENT BLOCK (RAMFILE SELECT = 0).
!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
!]NO ERROR 1
!]HCLK FCLK SPECAC SPECIR NTWK
!]NO ERROR 2
!]RAMDBUS NTWK
!]ERROR 1
!]RAM RAMADRS RAMSEL BCLK HCLK TBVMACPY SPECAC SPECIR ADEQ0 IR FCLK ACBLK RAMDBUS RAMWRITE NTWK
	LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
	END;
	
GLOBAL ROUTINE TST56: NOVALUE =

!THIS TEST CHECKS THE RAMFILE ADRS SELECT 2 .
!THIS TEST WILL DO THE FOLLOWING:
!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
!	   (RAMFILE SELECT = 6).
!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY DPE5 CURRENT OR
!	   PREVIOUS AC BLOCKS, AND XR (RAMFILE ADRS SELECT = 2).
!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
!	   THE VMA AND VERIFY IT DID CHANGE TO -1.
!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 7:
!CRAM 0/ TURN ON PXCT AND PXCT 09 ON DPMA.
!CRAM 1/ LOAD THE XR ON DPEA FROM THE MAGIC # FIELD VIA DBUS & DP.
!CRAM 2/ LOAD THE PREVIOUS AND CURRENT BLOCK FROM THE MAGIC # FIELD VIA DBUS & DP
!CRAM 3/ PASS AN ADRS (0,177 OR 160) FROM THE # FIELD VIA DBUS INTO REGITER
!	 0 OF THE 2901'S.
!CRAM 4/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
!CRAM 5/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
!CRAM 6/ WRITE A -1 INTO THE SAME LOCATION BUT ADDRESSED FROM XR
!	   AND XR PREVIOUS (RAMFILE SELECT = 2).
!CRAM 7/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
!	 (RAMFILE SELECT = 6) TO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
!THE NXT ADRS INPUTS.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDPXCT U_N(400) U,
			U_J(2) U_SPEC_LOADXR U_DBUS_DBM U_N(117) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDACBLK U_N(7700) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(177) U,
			U_J(5) U_ALU_OR U_MEM U_N(11012) U,
			U_J(6) U_SPEC_MEMCLR U_RAM_RAM U_FMWRITE U,
			U_J(7) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_RAM_XR U_FMWRITE U_N(777777) U,
			U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);

	IF .ADRSFLG NEQ 0
		THEN RETURN;
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	ER_TAB[0] = UPLIT (%ASCIZ'ONES');		!FRO ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
	ER_TAB[2] = %O'177';				!FRO ERROR PRINTOUT
	TEST_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 10 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,0);					!CHANGE THE VMA TO 0
	LC(2);						!LOAD CRAM ADRS  2
	MOD_FLD(3,%O'7000');				!CLEAR PREVIOUS BLOCK
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(3,%O'100');				!CLEAR THE XR
	SET_C(0);					!SET CRAM ADRS TO 0
	ER_TAB[0] = UPLIT (%ASCIZ'ZEROS');		!FRO ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
	ER_TAB[2] = 0;					!FRO ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 10 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(3);						!LOAD CRAM ADRS 3
	MOD_FLD(3,%O'160');				!CHANGE THE VMA TO 160
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,0);					!LOAD PXCT WITH 0
	ER_TAB[0] = UPLIT (%ASCIZ'LO');			!FRO ERROR PRINTOUT
	ER_TAB[2] = %O'160';				!FRO ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 10 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRS(1,1,ER_TAB)			!NO
		ELSE BEGIN
			IF .TEST_FLG EQL 0
				THEN NOERR(1);
			IF (.TEST_FLG OR .TEST55_FLG) EQL 0
				THEN NOERR(2);
			IF (.TEST_FLG OR .TEST53_FLG) EQL 0
				THEN NOERR(3)
				ELSE IF (.TEST_FLG OR .TEST54_FLG) EQL 0
					THEN NOERR(3);
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	RAMFILE ADRS TEST (RAMFILE SELECT 2)
!*STIMULUS:
!*	TURN PXCT ON AND LOAD PXCT 09 WITH \S1
!*	LOAD THE XR REGISTER WITH ALL \S0 AND LOAD XR PREVIOUS WITH \S1
!*	LOAD AC PREVIOUS BLK WITH ALL \S0 AND CURRENT BLOCK WITH ALL ONES
!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O2.
!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA(SELECT = 6).
!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 2 (XR & XR BLOCK)
!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
!]NO ERROR 1
!]BCLK HCLK SPECAC SPECXR NTWK
!]NO ERROR 2
!]ACBLK BCLK HCLK SPECAC SPECXR NTWK
!]NO ERROR 3
!]RAMDBUS NTWK
!]ERROR 1
!]ADEQ0 RAM XR HCLK SPECAC SPECXR ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
	LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
	END;

GLOBAL ROUTINE TST57: NOVALUE =

!THIS TEST CHECKS THE RAMFILE ADRS SELECT 4 .
!THIS TEST WILL DO THE FOLLOWING:
!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
!	   (RAMFILE SELECT = 6).
!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE 
!	   THE VMA, PREVIOUS BLOCK AND VMA AC REF (RAMFILE SELECT = 4).
!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
!	   THE VMA (RAMFILE SELECT = 6) AND VERIFY IT DID CHANGE TO -1.
!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
!CRAM 0/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
!	   0 OF THE 2901'S.
!CRAM 1/ LOAD THE AC PREVIOUS AND CURRENT BLOCKS WITH A 0.
!CRAM 2/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
!CRAM 3/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
!CRAM 4/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
!	 ADRS SELECT = 4.
!CRAM 5/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
!	 (RAMFILE SELECT = 6) INTO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
!THE NXT ADRS INPUTS.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(1777) U,
			U_J(2) U_SPEC_LDACBLK U,
			U_J(3) U_ALU_OR U_MEM U_N(11012) U,
			U_J(4) U_RAM_RAM U_FMWRITE U,
			U_J(5) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_RAM_VMA U_FMWRITE U_N(777777) U,
			U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);


	IF .ADRSFLG NEQ 0
		THEN RETURN;
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	ER_TAB[0] = %O'1777';				!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
	TEST_FLG = 0;
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	MOD_FLD(3,%O'1000');				!MODIFY THE # FIELD
	ER_TAB[0] = %O'1000';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			TEST_FLG = 1;
			ERRS(1,1,ER_TAB);			!NO
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,%O'12');				!SET NOT PHYSICAL
	MOD_FLD(2,%O'1727');				!SET PREVIOUS
	LC(0);						!SET CRAM ADRS TO 0
	MOD_FLD(3,0);					!LOAD THE VMA WITH A 0
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	ER_TAB[1] = UPLIT (%STRING(%CHAR(13,10),'	SET DPM4 VMA AC REF & VMA PREVIOUS.'));
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRS(1,1,ER_TAB)			!NO
		ELSE BEGIN
			IF .TEST_FLG EQL 0
				THEN NOERR(1);
			IF (.TEST_FLG OR .TEST53_FLG) EQL 0
				THEN NOERR(2)
				ELSE IF (.TEST_FLG OR .TEST54_FLG) EQL 0
					THEN NOERR(2);
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	RAMFILE ADRS TEST (RAMFILE SELECT 4)
!*STIMULUS:
!*	LOAD AC PREVIOUS AND CURRENT TO 0.\S1
!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O0.
!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (SELECT = 6)
!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 4 
!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
!]NO ERROR 1
!]CCLK BCLK HCLK SPECAC NTWK
!]NO ERROR 2
!]RAMDBUS NTWK
!]ERROR 1
!]CCLK RAM HCLK SPECAC ADEQ0 ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
	END;
	
GLOBAL ROUTINE TST58: NOVALUE =

!THIS TEST CHECKS THE RAMFILE ADRS SELECT 7 .(DPM4 VMA AC REF HI)
!THIS TEST WILL DO THE FOLLOWING:
!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
!	   (RAMFILE SELECT = 6).
!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE 
!	   MAGIC # FIELD VIA DBM (RAMFILE SELECT = 7).
!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
!	   THE VMA AND VERIFY IT DID CHANGE TO -1.
!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
!CRAM 0/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
!	   0 OF THE 2901'S.
!CRAM 1/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
!CRAM 2/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
!CRAM 3/ LOAD THE VMA WITH A 0 TO SET VMA AC REF.
!CRAM 4/ PUT A -1 IN REGISTER 0 OF THE 2901'S VIA # FIELD.
!CRAM 5/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
!	 ADRS SELECT IS FROM # FIELD.
!CRAM 6/ LOAD THE VMA FROM REGISTER 0 AGAIN.
!CRAM 7/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
!	 (RAMFILE SELECT = 6) TO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
!THOSE INSTRUCTIONS ARE EXECUTED TWICE FOR 2 ADRS SELECT INPUTS 0'S AND 1'S.
!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
!THE NXT ADRS INPUTS.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(1777) U,
			U_J(2) U_ALU_OR U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U_FMWRITE U_RAM_RAM U,
			U_J(4) U_MEM U_N(10012) U,
			U_J(5) U_SPEC_MEMCLR U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_N(777777) U,
			U_J(6) U_ALU_OR U_LSRC_0B U_B_T1 U_RAM_N U_FMWRITE U_N(1777) U,
			U_J(7) U_ALU_OR U_MEM U_N(11012) U,
			U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);

	IF .ADRSFLG NEQ 0
		THEN RETURN;
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	ER_TAB[0] = %O'1777';				!FROR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST58_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(5);						!LOAD CRAM ADRS 4
	MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
	ER_TAB[0] = 0;					!FROR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST58_FLG = 1;
		     END;
	IF (.TEST58_FLG OR .TEST53_FLG) EQL 0
		THEN NOERR(1)
		ELSE IF (.TEST58_FLG OR .TEST54_FLG) EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	RAMFILE ADRS TEST (RAMFILE SELECT 7)
!*STIMULUS:
!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O0.
!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA(SELECT = 6).
!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 7 WITH DPM4 VMA AC REF HI
!*	( # FIELD = \O0 FOR BOTH HALFS OF THE DBM).
!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
!]NO ERROR 1
!]RAMDBUS NTWK
!]ERROR 1
!]ADEQ0 CCLK RAM RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
	LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
	END;

GLOBAL ROUTINE TST59: NOVALUE =

!THIS TEST CHECKS THE RAMFILE ADRS SELECT 7 .(DPM4 VMA AC REF LO).
!THIS TEST WILL DO THE FOLLOWING:
!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
!	   (RAMFILE SELECT = 6).
!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE 
!	   MAGIC # FIELD VIA DBM (RAMFILE SELECT = 7).
!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
!	   THE VMA AND VERIFY IT DID CHANGE TO -1.
!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
!CRAM 0/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
!	   0 OF THE 2901'S.
!CRAM 1/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
!CRAM 2/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
!CRAM 3/ PUT A -1 IN REGISTER 0 OF THE 2901'S VIA # FIELD.
!CRAM 4/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
!	 ADRS SELECT IS FROM # FIELD.
!CRAM 5/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
!	 (RAMFILE SELECT = 6) TO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
!THOSE INSTRUCTIONS ARE EXECUTED TWICE FOR 2 ADRS SELECT INPUTS 0'S AND 1'S.
!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
!THE NXT ADRS INPUTS.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(1777) U,
			U_J(2) U_ALU_OR U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U_FMWRITE U_RAM_RAM U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_N(777777) U,
			U_J(5) U_ALU_OR U_LSRC_0B U_B_T1 U_RAM_N U_FMWRITE U_N(1777) U,
			U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);

	IF .ADRSFLG NEQ 0
		THEN RETURN;
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	ER_TAB[0] = %O'1777';				!FROR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST59_FLG = 1;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(4);						!LOAD CRAM ADRS 4
	MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
	ER_TAB[0] = 0;					!FROR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST59_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	IF (.TEST55_FLG OR .TEST58_FLG OR .TEST59_FLG) EQL 0
		THEN NOERR(1);
	IF (.TEST59_FLG OR .TEST53_FLG) EQL 0
		THEN NOERR(2)
		ELSE IF (.TEST59_FLG OR .TEST54_FLG) EQL 0
			THEN NOERR(2);
!*MESSAGE 1
!*	RAMFILE ADRS TEST (RAMFILE SELECT 7) WITH VMA AC REF LO
!*STIMULUS:
!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O0.
!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA(SELECT = 6).
!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 7 
!*	( # FIELD = \O0 FOR BOTH HALFS OF THE DBM).
!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
!]ERROR 1
!]ADEQ0 RAM ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
!]NO ERROR 1
!]RAMSEL NTWK
!]NO ERROR 2
!]RAMDBUS NTWK
	LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
	END;

GLOBAL ROUTINE TST60: NOVALUE =

!THIS TEST CHECKS THE RAMFILE ADRS SELECT 1 .
!THIS TEST WILL DO THE FOLLOWING:
!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
!	   (RAMFILE SELECT = 6).
!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE THE VMA.
!	   CURRENT AC BLOCK, DPEA AC + DBM (14,15,16 & 17) (RAMFILE SELECT = 4).
!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
!	   THE VMA (RAMFILE SELECT = 6) AND VERIFY IT DID CHANGE TO -1.
!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
!CRAM 0/ LOAD DPEA AC (0 OR 17).
!CRAM 1/ PASS AN ADRS (0 OR 176 OR 177) FROM THE # FIELD VIA DBUS 
!	 INTO REGITER 0 OF THE 2901'S.
!CRAM 2/ LOAD THE AC CURRENT BLOCKS WITH A 0 OR 7 .
!CRAM 3/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
!CRAM 4/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
!CRAM 5/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
!	 ADRS SELECT = 4.
!CRAM 6/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
!	 (RAMFILE SELECT = 6) INTO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
!THE NXT ADRS INPUTS.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4;
	BIND
	POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U_N(740) U,
			U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(176) U,
			U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDACBLK U_N(7000) U,
			U_J(4) U_ALU_OR U_MEM U_N(11012) U,
			U_J(5) U_RAM_RAM U_FMWRITE U,
			U_J(6) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_B_T1 U_N(777777) U,
			U_J(7) U_ALU_OR U_A_T1 U_RAM_AC_FN U_FMWRITE U_N(1457) U,
			U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);

	IF .ADRSFLG NEQ 0
		THEN RETURN;
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	ER_TAB[0] = 7;					!FOR ERROR PRINTOUT
	ER_TAB[1] = %O'176';				!FOR ERROR PRINTOUT
	ER_TAB[2] = %O'17';				!FOR ERROR PRINTOUT
	ER_TAB[3] = %O'1457';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			TEST_FLG = 1;
			ERRS(1,1,ER_TAB);			!NO
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(3,%O'177');				!VMA GETS 177
	ER_TAB[1] = %O'177';				!FOR ERROR PRINTOUT
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,0);					!DPEA AC GETS 0
	ER_TAB[2] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK2:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(6);						!LOAD CRAM ADRS 6
	MOD_FLD(3,%O'1440');				!AD A 0 TO THE AC
	ER_TAB[3] = %O'1440';				!FOR ERROR PRINTOUT
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,%O'740');				!DPEA AC GETS A 17
	ER_TAB[2] = %O'17';				!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK3:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);			!NO
			TEST_FLG = 1;
		     END;
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAX CRAM ADRS 1
	MOD_FLD(3,0);					!VMA GETS A 0
	ER_TAB[1] = 0;					!FOR ERROR PRINTOUT
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(3,0);					!CURRENT GEST A 0
	ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,0);					!DPEA AC GETS A 0
	ER_TAB[2] = 0;					!FOR ERROR PRINTOUT
	DO (0) WHILE
BLOCK4:	BEGIN
	RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRS(1,1,ER_TAB)			!NO
		ELSE BEGIN
			IF .TEST_FLG EQL 0
				THEN NOERR(1);
			IF (.TEST_FLG OR .TEST53_FLG) EQL 0
				THEN NOERR(2)
				ELSE IF (.TEST_FLG OR .TEST54_FLG) EQL 0
					THEN NOERR(2);
		     END;
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	RAMFILE ADRS TEST (RAMFILE SELECT 1)
!*STIMULUS:
!*	LOAD DPEA AC WITH \O2
!*	LOAD AC CURRENT BLOCK TO \O0
!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O1.
!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (SELECT = 6)
!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 1, DBM = \O3 
!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
!]NO ERROR 1
!]FCLK BCLK ACALU SPECIR SPECAC FCLK NTWK
!]NO ERROR 2
!]RAMDBUS NTWK
!]ERROR 1
!]ADEQ0 IR FCLK RAM HCLK SPECIR SPECAC ACALU ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
	END;
	
GLOBAL ROUTINE TST61: NOVALUE =

!THIS TEST CHECKS SWEEP CASH TO LOAD THE VMA ON DPE5.
!THIS TEST WILL DO THE FOLOWING:
!DEPOSITE A -1 IN MEMORY LOCATION 0 AND EXECUTE THE FOLLOWING:
!CRAM 1/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH 11012
!CRAM 2/ SET CASH SWEEP (SPEC = 24) WITH 0 ON DP AND PHYSICAL SET IN # DFIELD.
!	 (THIS SHOULD LOAD THE VMA WITH A 0).
!CRAM 3/ FINISH THE MEM CYCLE WITH 0 ON DP.
!	 (THIS SHOULD OUTPUT A 0 TO MEM).
!NOW WE EXAMINE MEM LOCATION 0 AND VERIFY THAT IT DID CHANGE TO A 0

	BEGIN
	LABEL BLOCK1;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
			U_J(3) U_SPEC_SWEEP U_N(1000) U,
			U_J(1) U_MEM U_N(2) U);

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	DM(0,%O'-1');					!PUT A -1 IN MEM 0
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(3);						!GIVE 3 CLKS
	RCVDATA = EM(0);				!EXAMINE MEMORY
	IF .RCVDATA EQL 0				!CHECK DATA
		THEN NOERR(1)				!YES
		ELSE ERR(1);				!NO
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	SET SWEEP TEST
!*STIMULUS:
!*	DEPOSITE A -1 IN MEM LOCATION 0
!*	START A MEM CYCLE AND LOAD THE VMA WITH 11012
!*	SWEEP THE CASH (SPEC = 24) WITH A ZERO ON DP 
!*	(SHOULD LOAD THE VMA WITH A 0)
!*	FINISH THE MEM WRITE CYCLE
!*	EXAMINE MEM LOCATION 0 AND VERIFY IT CHANGED TO 0
!]ERROR 1
!]SPECSWEEP SWPVMA NTWK
!]NO ERROR 1
!]SPECSWEEP SWPVMA NTWK
	END;
	
GLOBAL ROUTINE TST62: NOVALUE =

!THIS TEST CHECKS THE RAMFILE WRITE EN FROM DPM4
!THIS TEST WILL DO THE FOLLOWING:
!CRAM 0/ LOAD THE VMA WITH A ZERO WITH NOT PHYSICAL
!CRAM 1/ WRITE A 0 INTO RAMFILE LOCATION 0. (WRITE ENABLE FROM CRAM)
!CRAM 2/ START A MEM WRITE CYCLE.
!CRAM 3/ WRITE A 2 INTO RAMFILE LOCATION 0. (WRITE ENABLE FROM DPM4)
!CRAM 4/ READ BACK THE CONTENTS OF RAMFILE LOCATION 0 AND VERIFY IT 
!	 DID CHANGE TO A 2.

	BEGIN
	OWN TEST_FLG;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(1) U_SPEC_SWEEP U_DEST_AD U,
			U_J(2) U_FMWRITE U_RAM_RAM U,
			U_J(3) U_MEM U_N(10002) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_RAM_RAM U_N(2) U_MEM U,
			U_ALU_XOR U_LSRC_DA U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
			
	LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
	SET_C(0);					!SET CRAM ADRS TO 0
	TEST_FLG = 0;
	ER_TAB[0] = UPLIT(%ASCIZ'HI');			!FOR ERROR
	ER_TAB[1] = UPLIT(%ASCIZ' NOT ');		!FOR ERROR
	DO (0) WHILE
BLOCK1:	BEGIN
	RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN BEGIN
			ERRS(1,1,ER_TAB);		!NO
			TEST_FLG = 0;
		     END;
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(2);						!LOAD CRAM ADRS 2
	MOD_FLD(4,0);					!CLEAR THIS FIELD
	ER_TAB[0] = UPLIT(%ASCIZ'LO');			!FOR ERROR
	ER_TAB[1] = UPLIT(%ASCIZ' ');		!FOR ERROR
	DO (0) WHILE
BLOCK2:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLKS & GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRS(1,1,ER_TAB)			!NO
		ELSE IF .TEST_FLG EQL 0
			THEN NOERR(1);
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
!*MESSAGE 1
!*	RAMFILE WRITE ENABLE TEST
!*STIMULUS:
!*	LOAD THE VMA WITH 0 AND NO PHYSICAL (SET VMA AC REF)
!*	WRITE A 0 INTO RAMFILE LOCATION POINTED TO BY THE VMA 
!*	(WRITE BIT FROM THE CRAM)
!*	WRITE A 2 INTO THE SAME LOCATION 
!*	(ENABLE WRITE FROM DPM4 RAMFILE WRITE) = \S0
!*	EXAMINE THAT RAMFILE LOCATION AND VERIFY IF IT CHANGED
!*RESPONSE:
!*	RAMFILE CONTENTS DID\S1CHANGE
!]ERROR 1
!]ADEQ0 SPECSWEEP SWPVMA RAMADRS RAMWRITE RAM RAMDBUS NTWK
!]NO ERROR 1
!]ADEQ0 RAMWRITE NTWK
	END;

GLOBAL ROUTINE TST63: NOVALUE =
!THIS TEST VERIFIES THAT THE ADDRESSING(INPUT) PINS ON THE DROM CHIPS 
!CAN BE 000.ALSO COMBINED WITH OTHER TESTS IT CHECKS THE OUTPUT OF THE 
!DROM CHIPS.THE ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION THAT WILL
!USE THE FOLOWING PATH:
!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	NUMBER IS LOADED WITH THE DROM ADDRESS.
!ADDRESSING TO ALL 3 DROM CHIPS IS VERIFIED THROUGH CHECKING ALL THE
!CONTENTS OF ADDRESS 000 OF EACH CHIP .

    BEGIN
    LABEL
	BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	BIND
	POINTER = PLIT(U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_N(17) U_DBUS_DBM U_SPEC_LDINST U,
			  U_ALU_OR U_DISP_DROM U);	!GET 2 INSTRUCTIONS	
	BIND
	POINTER1 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
			U_J(5) U_MEM U_N(11042) U,
			U_J(6) U_SPEC_MEMCLR U,
			U_J(7) U_MEM U_N(11002) U,
			U_J(1) U_MEM U_N(2) U);
	BIND
	POINTER2 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
			U_J(3) U_MEM U_N(11001) U,
			U_J(1) U_MEM U_N(1) U);
	BIND
	POINTER3 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
			U_J(3) U_MEM U_N(42) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);
	LOAD_U(0,POINTER);				!LOAD THEM
    DO (0) WHILE 
BLOCK1 :
	BEGIN
	SET_C(0);					!SET CRAM ADDRESS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS AND GET NXT ADRS
	IF .RCVDATA NEQ %O'1556'			!CHECK DATA
	THEN ERRCA(1,%O'1556',.RCVDATA,4);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID A DROM DISPATCH AT DROM LOCATION 000
!*	DROM 000 CONTAINS / 0000,1556,2100
!*	AC DISP BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + CRAM J
!*	         = 1400 +  156   +  0000  = 1556
!]ERROR 1
!]ACDISP IR FCLK SPECIR DRMJ DRMCNTRL DISP NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'300');				!MODIFY DSIPATCH TYPE IN INSTRUCTION TO AREAD
    DO (0) WHILE 
BLOCK2:
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'1556'			!CHECK DATA
	THEN ERRCA(2,%O'1556',.RCVDATA,4);		!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID AN AREAD DISPATCH AT DROM LOCATION 000
!*	DROM 000 CONTAINS / 0000,1556,2100
!*	DROM A=J BIT IS HI, ACDISP BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + CRAM J
!*	         = 1400 +  156   +  0000  = 1556
!]ERROR 2
!]IR SPECIR FCLK DRMCNTRL DRMJ AEQLJ DISP ACDISP NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 0
	MOD_FLD(1,%O'703');				!MODIFY DSIPATCH TYPE
	MOD_FLD(2,%O'600');				!IN INSTRUCTION TO ADISP
    DO (0) WHILE 
BLOCK3:
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
	THEN ERRCA(3,0,.RCVDATA,4);			!NO
!*MESSAGE 3
!*STIMULUS:
!*	DID AN ADISP AT DROM LOCATION 000
!*	DROM 000 CONTAINS / 0000,1556,2100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM A + CRAM J (0-7)
!*	         =  00    + 	 000     = 0000
!]ERROR 3
!]IR FCLK SPECIR DRMAB DISP NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'700');				!MODIFY DSIPATCH TYPETO BDISP
    DO (0) WHILE 
BLOCK4:
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
	THEN ERRCA(4,0,.RCVDATA,4);			!NO
!*MESSAGE 4
!*STIMULUS:
!*	DID A BDISP AT DROM LOCATION 000
!*	DROM 000 CONTAINS / 0000,1556,2100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM B + CRAM J (0-7)
!*		 =   00   +    000	 =0000
!]ERROR 4
!]IR FCLK SPECIR DRMAB DISP NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERRO SET
	THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(1,%O'6507');				!MODIFY TO SKIP 
	MOD_FLD(2,7);					!ON TXXX
	DO (0) WHILE
BLOCK5:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(5,0,.RCVDATA,4);		!NO
!*MESSAGE 5
!*STIMULUS:
!*	D A SKIP ON TXXX (SKIP = 57) FOR DROM LOCATION 000
!*	DROM 000 SHOULD CONTAIN TXXX LO
!*	WE GET NXT CRAM ADRS = CRAM J = 0
!*RESPONSE:
!]ERROR 5
!]IR FCLK SPECIR DRMCNTRL TXXX ADEQ0 SKIP NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LOAD_U(1,POINTER1);				!LOAD INSTRUCTIONS TO VERIFY VMA EN BIT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,%O'-1');					!SET MEM TO 1'S
	CP(7);						!GIVE 7 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(6,0,.RCVDATA,12);	!NO
!*MESSAGE 6
!*STIMULUS:
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE VMA WITH 11012
!*	LOAD THE IR WITH DROM ADDRESS /000
!*	DROM CONTAINS /0000,1556,2100
!*	VMA EN BIT IS HI
!*	LOAD THE VMA WITH 0 IF DROM ASKS
!*	WRITE A ZERO TO PHYSICAL MEM
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 6
!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LDVMA = 0;					!CLEAR FLAG VMA COULD HAVE CHANGED
	VMA_LD();					!LOAD THE VMA WITH A ZERO
	LOAD_U(1,POINTER2);				!LOAD INSTUCTIONS TO VERIFY COND FUNC BIT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK7:	BEGIN
	DM(0,%O'-1');					!SET MEM TO ALL ONES
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCA(7,%O'-1',.RCVDATA,12);	!NO
!*MESSAGE 7
!*STIMULUS:
!*	LOAD THE VMA WITH A ZERO
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE IR WITH DROM ADDRESS /000
!*	DROM CONTAINS /0000,1556,2100
!*	COND FUNC BIT IS LO
!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 7
!]IR FCLK SPECIR DRMCNTRL NTWK
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LOAD_U(1,POINTER3);				!LOAD INSTUCTIONS TO VERIFY RED & WRT TEST BITS
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'60000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(8,0,.RCVDATA,12);		!NO
!*MESSAGE 8
!*STIMULUS:
!*	LOAD THE IR WITH DROM ADDRESS /000
!*	DROM CONTAINS /0000,1556,2100
!*	READ AND WRT TEST BITS ARE LO
!*	START A MEM CYCLE DO AN AREAD IF DROM ASKS
!*	ABORT MEM CYCLE, AND STOR THE VMA FLAGS IN 2901'S VIA DBM & DBUS
!*	START A MEM CYCLE
!*	FINISH MEM CYCLE AND OUTPUT THE VMA FLAGS TO MEM
!*	(BITS 3 & 4 CONTAIN DROM BITS READ AND WRT TEST)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 8
!]IR FCLK SPECIR DRMCNTRL NTWK
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST64: NOVALUE =
!THIS TEST VERIFIES THAT THE ADDRESSING(INPUT) PINS ON THE DROM CHIPS 
!CAN BE 777.ALSO COMBINED WITH OTHER TESTS IT CHECKS THE OUTPUT PINS 
!OF THE DROM CHIPS.THE ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION 
!THAT WILL USE THE FOLOWING PATH:
!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	NUMBER IS LOADED WITH THE DROM ADDRESS.
!ADDRESSING TO ALL 3 DROM CHIPS IS VERIFIED THROUGH CHECKING ALL THE
!CONTENTS OF ADDRESS 777 OF EACH CHIP .

    BEGIN
    LABEL
	BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
	BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(777017)U_SPEC_LDINST U,
			    U_ALU_OR U_DISP_DROM U);	!GET 2 WORDS
	BIND
	POINTER1 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777000) U,
			U_J(5) U_MEM U_N(11042) U,
			U_J(6) U_SPEC_MEMCLR U,
			U_J(7) U_MEM U_N(11002) U,
			U_J(1) U_MEM U_N(2) U);
	BIND
	POINTER2 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777000) U,
			U_J(3) U_MEM U_N(11001) U,
			U_J(1) U_MEM U_N(1) U);
	BIND
	POINTER3 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777000) U,
			U_J(3) U_MEM U_N(42) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);
	LOAD_U(0,POINTER);				!LOAD THE INSTRUCTIONS
    DO (0) WHILE 
BLOCK1 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'1657'			!CHECK DATA
	THEN ERRCA(1,%O'1657',.RCVDATA,4);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID A DROM DISP AT DROM LOCATION 777
!*	DROM 777 CONTAINS / 0007,1657,2100
!*	AC DISP BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + CRAM J
!*	         = 1400 +  257   +  0000  = 1657
!]ERROR 1
!]IR FCLK SPECIR ACDISP DRMCNTRL DISP DRMJ NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'300');				!MODIFY DISP TO AREAD
    DO (0) WHILE 
BLOCK2 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT INSTRUCTION ADRS
	IF .RCVDATA NEQ %O'1657'			!CHECK DATA
	THEN ERRCA(2,%O'1657',.RCVDATA,4);		!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID AN AREAD DISP AT DROM LOCATION 777
!*	DROM 777 CONTAINS / 0007,1657,2100
!*	A = J BIT IS HI, AC DISP BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + CRAM J
!*	         = 1400 +  257   +  0000  = 1657
!]ERROR 2
!]IR FCLK SPECIR DISP ACDISP AEQLJ DRMJ DRMCNTRL NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!SET CRAM ADRS TO 1
	MOD_FLD(1,%O'703');				!MODIFY DISP TYPE
	MOD_FLD(2,%O'600');				!TO ADISP
    DO (0) WHILE 
BLOCK3 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GAT NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
	THEN ERRCA(3,0,.RCVDATA,4);			!NO
!*MESSAGE 3
!*STIMULUS:
!*	DID AN ADISP AT DROM LOCATION 777
!*	DROM 777 CONTAINS / 0007,1657,2100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM A + CRAM J (0-7)
!*	         =  00    + 	 000     = 0000
!]ERROR 3
!]IR FCLK SPECIR DRMAB DISP NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'700');				!MODIFY DISP TYPE TO BDISP
    DO (0) WHILE 
BLOCK4 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ 7				!CHECK DATA
	THEN ERRCA(4,7,.RCVDATA,4);			!NO
!*MESSAGE 4
!*STIMULUS:
!*	DID A BDISP AT DROM LOCATION 777
!*	DROM 777 CONTAINS / 0007,1657,2100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM  + CRAM J (0-7)
!*	         =  07    + 	 000     = 007
!]ERROR 4
!]IR FCLK SPECIR DRMAB DISP NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(1,%O'6507');				!MODIFY TO SKIP
	MOD_FLD(2,7);					!ON TXXX
	DO (0) WHILE
BLOCK5:	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ 1				!CHECK DATA
		THEN ERRCA(5,1,.RCVDATA,4);		!NO
!*MESSAGE 5
!*STIMULUS:
!*	DID A SKIP ON TXXX (SKIP = 57) AT DROM LOCATION 777
!*	DROM 777 SHOULD CONTAIN TXXX HI
!*	WE GET NXT CRAM ADRS = CRAM J + 1 = 1
!*RESPONSE:
!*	EXAMINE DATA FROM PHYSICAL MEM 0
!]ERROR 5
!]IR SPECIR FCLK DRMCNTRL TXXX ADEQ0 SKIP NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LOAD_U(1,POINTER1);				!LOAD INSTRUCTIONS TO VERIFY VMA EN BIT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK6:	BEGIN
	DM(0,%O'-1');					!SET MEM TO 1'S
	CP(7);						!GIVE 7 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(6,0,.RCVDATA,12);	!NO
!*MESSAGE 6
!*STIMULUS:
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE VMA WITH 11012
!*	LOAD THE IR WITH DROM ADDRESS /777
!*	DROM CONTAINS /0007,1657,2100
!*	VMA EN BIT IS HI
!*	LOAD THE VMA WITH 0 IF DROM ASKS
!*	WRITE A ZERO TO PHYSICAL MEM
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 6
!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
	IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LDVMA = 0;					!CLEAR FLAG IT COULD HAVE CHANGED
	VMA_LD();					!LOAD THE VMA WITH A ZERO
	LOAD_U(1,POINTER2);				!LOAD INSTUCTIONS TO VERIFY COND FUNC BIT
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK7:	BEGIN
	DM(0,%O'-1');					!SET MEM TO ALL ONES
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCA(7,%O'-1',.RCVDATA,12);	!NO
!*MESSAGE 7
!*STIMULUS:
!*	LOAD THE VMA WITH A ZERO
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE IR WITH DROM ADDRESS /777
!*	DROM CONTAINS /0007,1657,2100
!*	COND FUNC BIT IS LO
!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 7
!]IR FCLK SPECIR DRMCNTRL NTWK
	IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LOAD_U(1,POINTER3);				!LOAD INSTUCTIONS TO VERIFY RED & WRT TEST BITS
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK8:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'60000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(8,0,.RCVDATA,12);		!NO
!*MESSAGE 8
!*STIMULUS:
!*	LOAD THE IR WITH DROM ADDRESS /777
!*	DROM CONTAINS /0007,1657,2100
!*	READ AND WRT TEST BITS ARE LO
!*	START A MEM CYCLE DO AN AREAD IF DROM ASKS
!*	ABORT MEM CYCLE, AND STOR THE VMA FLAGS IN 2901'S VIA DBM & DBUS
!*	START A MEM CYCLE
!*	FINISH MEM CYCLE AND OUTPUT THE VMA FLAGS TO MEM
!*	(BITS 3 & 4 CONTAIN DROM BITS READ AND WRT TEST)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 8
!]IR FCLK SPECIR DRMCNTRL NTWK
	IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST65: NOVALUE =
!THIS TEST COMBINED WITH OTHER TESTS VERIFIES THE OUTPUT PINS OF 
!THE DROM.SELECTING A DROM LOCATION (126), THE ADDRESS(126) IS
!LOADED BY EXECUTING AN INSTRUCTION THAT WILL USE THE FOLOWING PATH:
!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE OUTPUT OF THE DROM (A,B,J,AC DISP,A=J)PINS  IS VERIFIED BY 
!EXECUTING 4 DISPATCH TYPES, AND CHECKING THE NEXT CRAM ADDRESS.
!INSTRUCTIONS ARE EXECUTED AT CRAM LOCATIONS 0 & 1. THE ORED J FIELD 
!IS ALWAYS ZERO.
    BEGIN
    LABEL
	BLOCK1,
	BLOCK2,
	BLOCK3,
	BLOCK4;
	BIND
	   POINTER = PLIT(U_J(1) U_N(126000) U_DBUS_DBM U_SPEC_LOADIR U,
		    	 U_DISP_DROM U);		!GET 2 WORDS
	LOAD_U(0,POINTER);				!LOAD THEM
    DO (0) WHILE 
BLOCK1 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'1626'			!CHECK DATA
	THEN ERRCA(1,%O'1626',.RCVDATA,4);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID A DROM DISPATCH AT DROM LOCATION 126
!*	DROM 126 CONTAINS / 0711,1626,1100
!*	AC DISP BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + CRAM J
!*	         = 1400 +  226   +  0000  = 1626
!]ERROR 1
!]IR FCLK SPECIR DRMCNTRL ACDISP DRMJ DISP NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'300');				!MODIFY DISP TYPE TO AREAD
    DO (0) WHILE 
BLOCK2 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'47'				!CHECK DATA
	THEN ERRCA(2,%O'47',.RCVDATA,4);		!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID AN AREAD DISPATCH AT DROM LOCATION 126
!*	DROM 126 CONTAINS / 0711,1626,1100
!*	DROM A=J BIT IS LO ACDICP BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 40  +  DROM A
!*	         = 40  +  07     = 47
!]ERROR 2
!]IR FCLK SPECIR DRMCNTRL AEQLJ DRMAB DISP NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!SET CRAM ADRS TO 1
	MOD_FLD(1,%O'703');				!MODIFY DISP TYPE 
	MOD_FLD(2,%O'600');				!TO ADISP
    DO (0) WHILE 
BLOCK3 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ 7				!CHECK DATA
	THEN ERRCA(3,7,.RCVDATA,4);			!NO
!*MESSAGE 3
!*STIMULUS:
!*	DID AN ADISP AT DROM LOCATION 126
!*	DROM 126 CONTAINS / 0711,1626,1100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM A + CRAM J (0-7)
!*	         =  07    + 	 000     = 0007
!]ERROR 3
!]IR FCLK SPECIR DISP DRMAB NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'700');				!MODIFY DISP TYPE TO BDISP
    DO (0) WHILE 
BLOCK4 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'11'				!CHECK DATA
	THEN ERRCA(4,%O'11',.RCVDATA,4);		!NO
!*MESSAGE 4
!*STIMULUS:
!*	DID A BDISP AT DROM LOCATION 126
!*	DROM 126 CONTAINS / 0711,1626,1100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM B + CRAM J (0-7)
!*		 =   11   +    000	 = 0011
!]ERROR 4
!]IR FCLK SPECIR DISP DRMAB NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST66: NOVALUE =
!THIS TEST COMBINED WITH OTHER TESTS VERIFIES THE OUTPUT PINS OF 
!THE DROM.SELECTING A DROM LOCATION (701), THE ADDRESS(701) IS
!LOADED BY EXECUTING AN INSTRUCTION THAT WILL USE THE FOLOWING PATH:
!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE OUTPUT OF THE DROM (A,B,J,AC DISP,A=J)PINS  IS VERIFIED BY 
!EXECUTING 4 DISPATCH TYPES, AND CHECKING THE NEXT CRAM ADDRESS.
!INSTRUCTIONS ARE EXECUTED AT CRAM LOCATIONS 0 & 1. THE ORED J FIELD 
!IS ALWAYS ZERO.
    BEGIN
    LABEL
	BLOCK1,
	BLOCK2,
	BLOCK3,
	BLOCK4,
	BLOCK5;
	BIND
	   POINTER = PLIT (U_J(1) U_N(701000) U_DBUS_DBM U_SPEC_LOADIR U,
			   U_DISP_DROM U);		!GET 2 WORDS
	LOAD_U(0,POINTER);				!LOAD THEM
    DO (0) WHILE 
BLOCK1 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'1720'			!CHECK DATA
	THEN ERRCA(1,%O'1720',.RCVDATA,4);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID A DROM DISPATCH AT DROM LOCATION 701
!*	DROM 701 CONTAINS / 1200,1720,4100
!*	AC DISP BIT IS HI AC FIELD LOADED IS ZERO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + AC FIELD
!*	         = 1400 +  320   +  0000  = 1720
!]ERROR 1
!]IR FCLK SPECIR DRMCNTRL ACDISP DISP DRMJ NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(0);						!LOAD CRAM ADRS 0
	MOD_FLD(3,%O'1740');				!MODIFY AC FIELD IN INSTRUCTION TO 17
    DO (0) WHILE 
BLOCK2 :
	BEGIN
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'1737'			!CHECK DATA
	THEN ERRCA(2,%O'1737',.RCVDATA,4);		!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID A DROM DISPATCH DROM LOCATION
!*	CONTAINS AC DISP BIT HI
!*	AC FIELD IS 17
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + AC FIELD
!*		 =1400  +  320   +  17	      = 1737
!]ERROR 2
!]IR FCLK SPECIR ACDISP DRMCNTRL DISP DRMJ NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
	THEN 
	BEGIN
	    SET_C(0);					!SET CRAM ADRS TO 0
	    LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
	END;
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'300');				!MODIFY DISP TYPE TO AREAD
    DO (0) WHILE 
BLOCK3 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS AND GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'52'				!CHECK DATA
	THEN ERRCA(3,%O'52',.RCVDATA,4);		!NO
!*MESSAGE 3
!*STIMULUS:
!*	DID AN AREAD DISPATCH AT DROM LOCATION 701
!*	DROM 701 CONTAINS / 1200,1720,4100
!*	DROM A=J BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 40  +  DROM A
!*	         = 40  +  12     = 52
!]ERROR 3
!]IR FCLK SPECIR DRMCNTRL DISP DRMAB AEQLJ NTWK
	IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(1,%O'703');				!MODIFY DISP TYPE 
	MOD_FLD(2,%O'600');				!TO ADISP
    DO (0) WHILE 
BLOCK4 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ %O'12'				!CHECK DATA ?
	THEN ERRCA(4,%O'12',.RCVDATA,4);		!NO
!*MESSAGE 4
!*STIMULUS:
!*	DID AN ADISP AT DROM LOCATION 701
!*	DROM 701 CONTAINS / 1200,1720,4100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM A + CRAM J (0-7)
!*	         =  12    + 	 000     = 0012
!]ERROR 4
!]IR FCLK SPECIR DRMAB DISP NTWK
	IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LC(1);						!LOAD CRAM ADRS 1
	MOD_FLD(2,%O'700');				!MODIFY DISP TO BDISP
    DO (0) WHILE 
BLOCK5 :
	BEGIN
	SET_C(0);					!SET CRAM ADRS TO 0
	RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
	IF .RCVDATA NEQ 0				!CHECK DATA
	THEN ERRCA(5,0,.RCVDATA,4);			!NO
!*MESSAGE 5
!*STIMULUS:
!*	DID A BDISP AT DROM LOCATION 701
!*	DROM 701 CONTAINS / 1200,1720,4100
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM B + CRAM J (0-7)
!*		 =   00   +    000	 =0000
!]ERROR 5
!]IR SPECIR FCLK DISP DRMAB NTWK
	IF LOOP_CHK(5)					!IS LOOP ON ERROR SET
	THEN LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST67: NOVALUE =

!THIS TEST CHECKS (VMA EN BIT LO)CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.AND EXECUTE THE FOLLOWING:
!	1)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
!	2)  LOAD THE VMA WITH ADDRESS 11012.
!	3)  LOAD THE IR WITH DROM ADDRESS 240.
!	4)  LOAD THE VMA WITH A ZERO IF DROM ASKS (VMA EN IS LO).
!	5)  WRITE A ZERO TO PHYSICAL MEM.
!	6)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
!USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-7.
!CRAM 1/ START A MEM CYCLE AND LOAD THE VMA WITH 11012.
!CRAM 2/ ABORT THE MEM CYCLE.
!CRAM 3/ LOAD THE IR WITH DROM ADDRESS.
!CRAM 4/ START A MEM CYCLE AND LOAD THE VMA WITH 0 IF DROM ASKS.
!CRAM 5/ ABORT THE MEM CYCLE.
!CRAM 6/ START A PHYSICAL MEM WRITE CYCLE.
!CRAM 7/ FINISH THE MEM WRITE CYCLE.

	BEGIN
	LABEL BLOCK1;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(240000) U,
			U_J(5) U_MEM U_N(11042) U,
			U_J(6) U_SPEC_MEMCLR U,
			U_J(7) U_MEM U_N(11002) U,
			U_J(1) U_MEM U_N(2) U);
	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,%O'-1');					!SET MEM
	CP(7);						!GIVE 7 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ %O'-1'				!CHECK DATA
		THEN ERRCA(1,%O'-1',.RCVDATA,12);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE VMA WITH 11012
!*	LOAD THE IR WITH DROM ADDRESS /240
!*	DROM CONTAINS /0400,1622,1000
!*	VMA EN BIT IS LO
!*	LOAD THE VMA WITH 0 IF DROM ASKS
!*	WRITE A ZERO TO PHYSICAL MEM
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 1
!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LDVMA = 0;					!CLEAR THE FLAG VMA HAS CHANGED
	END;

GLOBAL ROUTINE TST68: NOVALUE =

!THIS TEST CHECKS (COND FUNC, READ & WRT TEST BITS HI)CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.AND EXECUTE THE FOLLOWING
!FOR THE COND FUNC BIT:
!	1)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
!	2)  LOAD THE IR WITH DROM ADDRESS 277.
!	3)  START A PHYSICAL MEM WRITE CYCLE IF DROM ASKS (IF FUNC COND IS HI).
!	4)  FINISH THE MEM CYCLE IF DROM ASKS BY OUTPUTING A ZERO.
!	5)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
!USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-3.
!CRAM 1/ LOAD THE IR WITH DROM ADDRESS.
!CRAM 2/ START A MEM  PHYSICAL WRITE CYCLE IF DROM ASKS.
!CRAM 3/ FINISH THE MEM WRITE CYCLE IF DROM ASKS AND OUTPUT A ZERO.
!THIS TEST CALLS A ROUTINE VMA_LD WHICH CHECKS AND LOADS THE VMA WITH A ZERO
!WE EXECUTE DIFFERENT INSTRUCTIONS FOR THE READ & WRT TEST BITS.

	BEGIN
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(277000) U,
			U_J(3) U_MEM U_N(11011) U,
			U_J(1) U_MEM U_N(1) U);
	BIND
	POINTER1 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(277000) U,
			U_J(3) U_MEM U_N(42) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);
	VMA_LD();					!CHECK AND LOAD THE VMA WITH A ZERO
	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK1:	BEGIN
	DM(0,%O'-1');					!SET MEM TO 1'S
	CP(3);						!GIVE 3 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	IF .RCVDATA NEQ 0				!CHECK DATA
		THEN ERRCA(1,0,.RCVDATA,12);		!NO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD THE VMA WITH A ZERO
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE IR WITH DROM ADDRESS /277
!*	DROM CONTAINS /0017,1561,1700
!*	COND FUNC BIT IS HI
!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 1
!]IR SPECIR FCLK DRMCNTRL MEMVMA NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	LOAD_U(1,POINTER1);				!LOAD INSTUCTIONS TO VERIFY RED & WRT TEST BITS
	SET_C(1);					!SET CRAM ADRS TO 1
	DO (0) WHILE
BLOCK2:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA FROM MEM
	RCVDATA = .RCVDATA AND %O'60000000000';		!CLEAN UNWANTED BITS
	IF .RCVDATA NEQ %O'60000000000'			!CHECK DATA
		THEN ERRCA(2,%O'60000000000',.RCVDATA,12);	!NO
!*MESSAGE 2
!*STIMULUS:
!*	LOAD THE IR WITH DROM ADDRESS /277
!*	DROM CONTAINS /0017,1561,1700
!*	READ AND WRT TEST BITS ARE HI
!*	START A MEM CYCLE DO AN AREAD IF DROM ASKS
!*	ABORT MEM CYCLE, AND STOR THE VMA FLAGS IN 2901'S VIA DBM & DBUS
!*	START A MEM CYCLE
!*	FINISH MEM CYCLE AND OUTPUT THE VMA FLAGS TO MEM
!*	(BITS 3 & 4 CONTAIN DROM BITS READ AND WRT TEST)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 2
!]IR FCLK SPECIR DRMCNTRL NTWK
	IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

	END;
	END;

GLOBAL ROUTINE TST69: NOVALUE =

!THIS TEST CHECKS (ACDISP & J FIELD) CONTENTS IN ALL DROM LOCATIONS.
!IT ALSO CHECKS THE INSTRUCTION REGISTER(IR & AC)FLOPS INPUT AND OUTPUT
!PINS.THIS TEST IS A LOOP OF 512,IT WILL PICK UP CORRECT DROM CONTENTS 
!DATA FROM DATA TABLE (TBL), CHECK ACDISP BIT AND EXECUTE A DROM DISP
!(DISP 12) DOING THE FOLLOWING:
!	1)  IF ACDISP BIT IS LO IT WILL EXECUTE A DROM DIPATCH
!	    AND CHECK THE NEXT ADDRESS = 1400 + DROM J + CRAM J.
!	2)  IF ACDISP BIT IS HI EXECUTE A DROM DISP WITH AC FIELD 00
!	    AND CHECK NXT ADDRESS = 1400 + DROM J + AC FIELD.
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM ADRS 0
!THAT USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
!ALWAYS 0000.EXECUTING THE DISP MODE IS AN INSTRUCTION LOADED IN CRAM 
!ADRS 1.ANY DISCREPANCY IN NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.

    BEGIN
    LOCAL
	J,
	ACDISP,
	DROM_WRD,
	FLD3,
	FLD4;
    LABEL
	BLOCK1,
	BLOCK2;
    BIND
	POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
			 U_DISP_DROM U);		!GET 2 WORDS

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;
    LOAD_U(0, POINTER);					!LOAD THEM
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    LC(0);					!LOAD CRAM ADRS 0
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    MOD_FLD(4,.FLD4);				!MODIFY 2 HI OCTAL DIGITS OF DROM ADRS IN MAGIC #
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET DROM WORD FROM TABLE
		ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		J = .DROM_WRD<12, 12>;			!GET THE J FIELD
		FLD3 = .K<0, 3> ^ 9;			!GET LOW OCTAL DIGIT FOR DROM ADRS
		MOD_FLD(3,.FLD3);			!MODIFY LOW DIGIT OF DROM ADRS IN MAGIG #
		ACDISP = .DROM_WRD<11, 1>;		!GET ACDISP BIT
		IF .ACDISP EQL 0 THEN			!CHECK AC DISP BIT ?
		DO (0)	WHILE 				!AC DISP BIT IS LO
BLOCK1 :
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!2 CLOCKS & GET NXT CRAM ADRS
		IF .RCVDATA NEQ .J			!CHECK IT?
		THEN ERRCAS(1,1,.J,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID A DROM DISPATCH AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	AC DISP BIT LO.
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + CRAM J
		IF LOOP_CHK(1)				!IS LOOP ON ERROR SET?
		THEN 					!YES
		BEGIN
			SET_C(0);			!SET CRAM ADRS TO 0
			LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
		END					!END OF BLOCK1

	    ELSE					!AC DISP BIT IS HI
		DO (0) WHILE
BLOCK2:
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!2 CLOCKS & GET NXT CRAM ADRS
		IF .RCVDATA NEQ .J			!CHECK IT ?
		THEN ERRCAS(1,2,.J,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID A DROM DISPATCH AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	AC DISP BIT HI
!*	AC FIELD IS 00
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + AC FIELD
!]ERROR 1
!]IR FCLK SPECIR ACDISP DRMJ DRMCNTRL DISP NTWK
		IF LOOP_CHK(2)				!IS LOOP ON ERROR SET ?
		THEN 
		BEGIN
			SET_C(0);			!SET CRAM ADRS TO 0
			LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
	      END;
	    END;
	 END;
	END;



GLOBAL ROUTINE TST70: NOVALUE =

!THIS TEST CHECKS (A = J & J FIELD)CONTENTS OF DROM.IT ALSO CHECKS
!THE INSTRUCTION REGISTER(IR)FLOPS INPUT AND OUTPUT PINS, AND THE DROM
!A FIELD WHERE A = J BIT IS LO.THIS TEST IS A LOOP OF 512,IT WILL PICK
!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK A = J BIT
!AND EXECUTE AN AREAD DISP (DISP 13) DOING THE FOLLOWING:
!	1)  IF A = J BIT IS HI IT WILL EXECUTE AN AREAD DIPATCH
!	    AND CHECK THE NEXT ADDRESS = 1400 + DROM J + CRAM J.
!	2)  IF A = J BIT IS LO IT WILL EXECUTE AN AREAD DISPATCH
!	    AND CHECK NXT ADDRESS = 40 + DROM A
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 0 THAT
!USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
!ALWAYS 0000.THE EXECUTED DISP TYPE IS AN INSTRUCTION IN CRAM 1.ANY
!DISCREPANCY IN NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.

    BEGIN
    LOCAL
	A,
	J,
	AEQLJ,
	DROM_WRD,
	FLD3,
	FLD4;
    LABEL
	BLOCK1,
	BLOCK2;
    BIND
	POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
			 U_DISP_AREAD U);		!GET TWO WORDS

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;

    LOAD_U(0, POINTER);					!LOAD THEM
	    LC(0);					!LOAD CRAM ADRS 0
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
		ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		J = .DROM_WRD<12, 12>;			!GET THE J FIELD
		FLD3 = .K<0, 3> ^ 9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
		MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
		AEQLJ = .DROM_WRD<10,1>;		!GET A = J BIT
		IF .AEQLJ NEQ 0 THEN			!IS A = J BIT HI ?
    	DO (0)	WHILE 
BLOCK1 :						!YES A = J BIT IS HI
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS & GET NXT CRAM ADRS
		IF .RCVDATA NEQ .J			!IS NXT CRAM ADRS CORRECT
		THEN ERRCAS(1,1,.J,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID AN AREAD DISPATCH AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	A = J BIT HI
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 1400 + DROM J + CRAM J
!]ERROR 1
!]IR SPECIR FCLK ACDISP DISP AEQLJ DRMCNTRL DRMJ NTWK
		IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
		BEGIN
			SET_C(0);			!SET CRAM ADRS TO 0
			LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
		END
	    ELSE					!NO A = J BIT IS LO
     DO (0) WHILE
BLOCK2:
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
		A = .DROM_WRD<30,6>;			!GET THE A FIELD
		ER_TAB[2] = .A;				!STOR A FIELD FOR ERROR PRINTOUT
		J = .A OR %O'40';			!GET EXPECTED DATA
		IF .RCVDATA NEQ .J			!CHECK DATA ?
		THEN ERRCAS(2,2,.J,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID AN AREAD DISPATCH AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	A = J BIT IS LO
!*	DROM A CONTAINS /\O2
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = 40 + DROM A 
!]ERROR 2
!]IR FCLK SPECIR AEQLJ DRMCNTRL DRMAB NTWK
		IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
		THEN 
		BEGIN
			SET_C(0);			!SET CRAM ADRS TO 0
			LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
		END;
	    END;
	END;
	END;


GLOBAL ROUTINE TST71: NOVALUE =

!THIS TEST CHECKS (TXXX BIT )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK TXXX BIT
!AND EXECUTE A TXXX SKIP (SKIP 57) DOING THE FOLLOWING:
!	1)  IF TXXX BIT IS HI IT WILL EXECUTE A SKIP
!	    AND CHECK THE NEXT ADDRESS = CRAM J + 1
!	2)  IF TXXX BIT IS LO IT WILL EXECUTE A SKIP
!	    AND CHECK NXT ADDRESS = CRAM J + 0 
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 0 THAT
!USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
!ALWAYS 0000.THE EXECUTED SKIP INSTRUCTION IN CRAM 1.ANY DISCREPANCY IN 
!NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.

    BEGIN
    LOCAL
	TXXX,
	DROM_WRD,
	FLD3,
	FLD4;
    LABEL
	BLOCK1,
	BLOCK2;
    BIND
	POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SPEC_LDINST U,
			U_ALU_OR U_SKIP_TXXX U);	!GET 2 WORDS

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;

	LOAD_U(0, POINTER);				!LOAD THEM
	LC(0);						!LOAD CRAM ADRS 0
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
		ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		FLD3 = (.K<0, 3>^9) OR %O'17';		!GET THE LO OCTAL DIGIT OF THE DROM ADRS
		MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
		TXXX = .DROM_WRD<26,1>;			!GET TXXX BIT (COPY BIT 9 B FIELD)
		IF .TXXX NEQ 0 THEN			!IS TXXX BIT HI ?
    	DO (0)	WHILE 
BLOCK1 :						!YES TXXX BIT IS HI
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS & GET NXT CRAM ADRS
		IF .RCVDATA NEQ 1			!IS NXT CRAM ADRS CORRECT
		THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID SKIP ON TXXX AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	TXXX BIT HI
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = CRAM J + 1
		IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 0
		    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
		END
	    ELSE					!NO TXXX BIT IS LO
     DO (0) WHILE
BLOCK2:
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
		IF .RCVDATA NEQ 0			!CHECK DATA ?
		THEN ERRCAS(1,2,0,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 2
!*STIMULUS:
!*	DID SKIP ON TXXX AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	TXXX BIT IS LO
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = CRAM J + 0
!]ERROR 1
!]IR FCLK SPECIR TXXX DRMCNTRL SKIP ADEQ0 NTWK
		IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
		THEN 
		BEGIN

		    SET_C(0);				!SET CRAM ADRS TO 0
		    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
		END;
	    END;
	END;
	END;


GLOBAL ROUTINE TST72: NOVALUE =

!THIS TEST CHECKS (VMA EN BIT )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK VMA EN BIT
!AND EXECUTE THE FOLLOWING:
!	1)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
!	2)  LOAD THE VMA WITH ADDRESS 11012.
!	3)  LOAD THE IR WITH A DROM ADDRESS.
!	4)  LOAD THE VMA WITH A ZERO IF DROM ASKS (IF VMA EN IS HI).
!	5)  WRITE A ZERO TO PHYSICAL MEM.
!	6)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
!USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-7.
!CRAM 1/ START A MEM CYCLE AND LOAD THE VMA WITH 11012.
!CRAM 2/ ABORT THE MEM CYCLE.
!CRAM 3/ LOAD THE IR WITH DROM ADDRESS.
!CRAM 4/ START A MEM CYCLE AND LOAD THE VMA WITH 0 IF DROM ASKS.
!CRAM 5/ ABORT THE MEM CYCLE.
!CRAM 6/ START A PHYSICAL MEM WRITE CYCLE.
!CRAM 7/ FINISH THE MEM WRITE CYCLE.

	BEGIN
    LOCAL
	VMAEN,
	DROM_WRD,
	FLD3,
	FLD4;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
			U_J(3) U_SPEC_MEMCLR U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
			U_J(5) U_MEM U_N(11042) U,
			U_J(6) U_SPEC_MEMCLR U,
			U_J(7) U_MEM U_N(11002) U,
			U_J(1) U_MEM U_N(2) U);

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;

	LOAD_U(1,POINTER);				!LOAD 7 INSTRUCTIONS
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    LC(3);					!LOAD CRAM ADRS 3
	    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
		ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		FLD3 = .K<0, 3>^9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
		LC(3);					!LOAD CRAM ADRS 3
		MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
		VMAEN = .DROM_WRD<6,1>;			!GET VMA EN BIT 
		SET_C(1);				!SET CRAM ADRS TO 1
		IF .VMAEN NEQ 0 THEN			!IS VMA EN BIT HI ?
    	DO (0)	WHILE 
BLOCK1 :						!YES VMA EN BIT IS HI
		BEGIN
		DM(0,%O'-1');				!SET MEM TO ONES
		CP(7);					!GIVE 7 CLOCKS
		RCVDATA = EM(0);			!GET DATA
		IF .RCVDATA NEQ 0			!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE VMA WITH 11012
!*	LOAD THE IR WITH DROM ADDRESS /\O0
!*	DROM CONTAINS /\U1
!*	VMA EN BIT IS HI
!*	LOAD THE VMA WITH 0 IF DROM ASKS
!*	WRITE A ZERO TO PHYSICAL MEM
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
		IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
		LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END
	    ELSE					!NO VMA EN BIT IS LO
     DO (0) WHILE
BLOCK2:
		BEGIN
		DM(0,%O'-1');				!SET MEM TO ONES
		CP(7);					!GIVE 7 CLOCKS
		RCVDATA = EM(0);			!GET DATA
		IF .RCVDATA NEQ %O'-1'			!CHECK DATA ?
		THEN ERRCAS(1,2,%O'-1',.RCVDATA,12,ER_TAB);!NO
!*MESSAGE 2
!*STIMULUS:
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE VMA WITH 11012
!*	LOAD THE IR WITH DROM ADDRESS /\O0
!*	DROM CONTAINS /\U1
!*	VMA EN BIT IS LO
!*	LOAD THE VMA WITH 0 IF DROM ASKS
!*	WRITE A ZERO TO PHYSICAL MEM
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 1
!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
		IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
		THEN 
		    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;
	    END;
	END;
	LDVMA = 0;					!CLEAR FLAG VMA HAS CHANGED
	END;

GLOBAL ROUTINE TST73: NOVALUE =

!THIS TEST CHECKS (WRT TEST & READ BITS )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK COND FUNC BIT
!AND EXECUTE THE FOLLOWING:
!	1)  LOAD THE IR WITH A DROM ADDRESS.
!	2)  START A MEM CYCLE WITH # BIT 12 SET.
!	3)  ABORT THE CYCLE AND LOAD THE VMA FLAGS INTO REGISTER 0 OF
!	    OF THE 2901'S VIA DBM & DBUS.
!	4)  START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0.
!	5)  FINISH THE MEM CYCLE BY OUPUTING THE CONTENTS OF REGISTER 0 INTO MEM.
!	6)  READ PHYSICAL MEM 0 AND AND VERIFY BITS 3 & 4.
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
!USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-3.
!CRAM 1/ LOAD THE IR WITH DROM ADDRESS.
!CRAM 2/ START A MEM CYCLE WITH BIT 12 OF # FIELD SET.
!CRAM 3/ ABORT MEM CYCLE AND SELECT DBM = 5 TO LOAD THE VMA FLAGS.
!	 THEN PASS THE DBM INTO REGISTER 0 OF THE 2901'S VIA DBUS.
!	 (BITS 3 & 4 WILL CONTAIN READ & WRT_TST BITS)
!CRAM 4/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0.
!CRAM 5/ FINISH THE MEM WRITE CYCLE AND OUTPUT THE CONTENTS OF REGISTER 0 TO MEM

	BEGIN
    LOCAL
	WRTTST,READ,RCVREAD,RCVWRTST,DROM_WRD,FLD3,FLD4;
	LABEL BLOCK1;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
			U_J(3) U_MEM U_N(42) U,
			U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
			U_J(5) U_MEM U_N(11012) U,
			U_J(1) U_ALU_OR U_MEM U_N(2) U);

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;

	LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
        LC(1);						!LOAD CRAM ADRS 1
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
		ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		FLD3 = .K<0, 3>^9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
		MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
		WRTTST =  .DROM_WRD<8,1>;		!GET WRTTST BIT FROM TABLE
		READ = .DROM_WRD<9,1>;			!GET READ BIT FROM TABLE
		IF .WRTTST EQL 0 
		THEN
		    ER_TAB[2] = UPLIT (%ASCIZ'LO')
		ELSE
		    ER_TAB[2] = UPLIT (%ASCIZ'HI');
		IF .READ EQL 0
		THEN
		    ER_TAB[4] = UPLIT (%ASCIZ'LO')
		ELSE
		    ER_TAB[4] = UPLIT (%ASCIZ'HI');
	DO (0) WHILE
BLOCK1:	BEGIN
	CP(5);						!GIVE 5 CLOCKS
	RCVDATA = EM(0);				!GET DATA
	RCVWRTST = .RCVDATA<31,1>;
	RCVREAD = .RCVDATA<32,1>;
	IF .RCVWRTST EQL 0
	THEN
	    ER_TAB[3] = UPLIT (%ASCIZ'LO')
	ELSE
	    ER_TAB[3] = UPLIT (%ASCIZ'HI');
	IF .RCVREAD EQL 0
	THEN
	    ER_TAB[5] = UPLIT (%ASCIZ'LO')
	ELSE
	    ER_TAB[5] = UPLIT (%ASCIZ'HI');

	IF (.RCVWRTST NEQ .WRTTST) OR (.RCVREAD NEQ .READ)    !CHECK DATA
		THEN ERRS(1,1,ER_TAB);			!NO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD THE IR WITH DROM ADDRESS /\O0
!*	DROM CONTAINS /\U1
!*	WRT TEST BIT FOUND WAS \S3, IT SHOULD BE \S2
!*	READ BIT FOUND WAS \S5, IT SHOULD BE \S4
!]ERROR 1
!]IR FCLK SPECIR DRMCNTRL NTWK
	IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
		THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;
	     END;
	   END;
	END;


GLOBAL ROUTINE TST74: NOVALUE =

!THIS TEST CHECKS (COND FUNC BIT )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK COND FUNC BIT
!AND EXECUTE THE FOLLOWING:
!	1)  LOAD THE VMA WITH ADDRESS 11012.
!	2)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
!	3)  LOAD THE IR WITH A DROM ADDRESS.
!	4)  START A PHYSICAL MEM WRITE CYCLE IF DROM ASKS (IF FUNC COND IS HI).
!	5)  FINISH THE MEM CYCLE BY IF DROM ASKS BY OUTPUTING A ZERO.
!	6)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
!USES THE FOLOWING PATH:
!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-3.
!CRAM 1/ LOAD THE IR WITH DROM ADDRESS.
!CRAM 2/ START A MEM  PHYSICAL WRITE CYCLE IF DROM ASKS.
!CRAM 3/ FINISH THE MEM WRITE CYCLE IF DROM ASKS AND OUTPUT A ZERO.
!THIS TEST CALLS A ROUTINE VMA_LD WHICH CHECKS AND LOADS THE VMA WITH A ZERO

	BEGIN
    LOCAL
	CONDFUNC,
	DROM_WRD,
	FLD3,
	FLD4;
	LABEL BLOCK1,BLOCK2;
	BIND
	POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
			U_J(3) U_MEM U_N(11001) U,
			U_J(1) U_MEM U_N(1) U);

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;

	VMA_LD();					!CHECK AND LOAD THE VMA WITH A ZERO
	LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
        LC(1);						!LOAD CRAM ADRS 1
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
		ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		FLD3 = .K<0, 3>^9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
		MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
		CONDFUNC = .DROM_WRD<7,1>;		!GET COND FUNC BIT 
		IF .CONDFUNC NEQ 0 THEN			!IS COND FUNC BIT HI ?
    	DO (0)	WHILE 
BLOCK1 :						!YES COND FUNC BIT IS HI
		BEGIN
		DM(0,%O'-1');				!SET MEM TO ONES
		CP(3);					!GIVE 3 CLOCKS
		RCVDATA = EM(0);			!GET DATA
		IF .RCVDATA NEQ 0			!CHECK DATA
		THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	LOAD THE VMA WITH A ZERO
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE IR WITH DROM ADDRESS /\O0
!*	DROM CONTAINS /\U1
!*	COND FUNC BIT IS HI
!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
		IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
		LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END
	    ELSE					!NO VMA EN BIT IS LO
     DO (0) WHILE
BLOCK2:
		BEGIN
		DM(0,%O'-1');				!SET MEM TO ONES
		CP(3);					!GIVE 3 CLOCKS
		RCVDATA = EM(0);			!GET DATA
		IF .RCVDATA NEQ %O'-1'			!CHECK DATA ?
		THEN ERRCAS(1,2,%O'-1',.RCVDATA,12,ER_TAB);!NO
!*MESSAGE 2
!*STIMULUS:
!*	LOAD THE VMA WITH A ZERO
!*	DEPOSITE -1 IN PHYSICAL MEM 0
!*	LOAD THE IR WITH DROM ADDRESS /\O0
!*	DROM CONTAINS /\U1
!*	COND FUNC BIT IS LO
!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
!*RESPONSE:
!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
!]ERROR 1
!]IR FCLK SPECIR DRMCNTRL NTWK
		IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
		THEN 
		    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
	0						!TO ILLUMINATE BLISS INFO COMMENT

		END;
	    END;
	END;
	END;


GLOBAL ROUTINE TST75: NOVALUE =

!THIS TEST CHECKS (DROM A )CONTENTS OF ALL DROM LOCATIONS.IT ALSO CHECKS
!THE INSTRUCTION REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.THIS TEST IS A
!LOOP OF 512,IT WILL PICK UP CORRECT DROM CONTENTS DATA FROM DATA TABLE
!(TBL), AND EXECUTE AN ADISP (DISP 36) AND CHECK NXT ADDRESS =
!CRAM J + DROM A.THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION
!IN CRAM 0 THAT USES THE FOLOWING PATH:
!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
! ALWAYS 0000.EXECUTING THE DISP TYPE IS AN INSTRUCTION IN CRAM 1.ANY
!DISCREPANCY IN NEXT CRAM ADDRESS WILL YIELD AN ERROR PRINTOUT.

    BEGIN
    LOCAL
	A,
	DROM_WRD,
	FLD3,
	FLD4;
    LABEL
	BLOCK1;
    BIND
	POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
			 U_DISP_ADISP U);		!GET 2 WORDS

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;

    LOAD_U(0, POINTER);					!LOAD THEM 
    LC(0);						!LOAD CRAM ADRS 0
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    MOD_FLD(4,.FLD4);				!MODIFY THOSE 2 DIGITS IN INSTRUCTION
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET DROM WORD FROM TABLE
		FLD3 = .K<0, 3> ^ 9;			!GET LO OCTAL DIGIT OF DROM ADRS
		MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
		A = .DROM_WRD<30,6>;			!GET THE A FIELD
		ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		ER_TAB[2] = .A;				!STOR A FIELD FOR ERROR PRINTOUT
		DO (0)	WHILE 
BLOCK1 :
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS AND GET NXT CRAM ADRS	
		IF .RCVDATA NEQ .A			!CHECK DATA
		THEN ERRCAS(1,1,.A,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID AN ADISP AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	DROM A CONTAINS /\O2
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM A + CRAM J
!]ERROR 1
!]IR FCLK SPECIR DRMAB DISP NTWK
		IF LOOP_CHK(1)				!IS LOOP ON ERROR SET
		THEN 
		BEGIN
		    SET_C(0);				!SET CRAM ADRS TO 0
		    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
		END;
		END;
	    END;
	END;


GLOBAL ROUTINE TST76: NOVALUE =

!THIS TEST CHECKS (DROM B )CONTENTS OF ALL DROM LOCATIONS.IT ALSO CHECKS
!THE INSTRUCTION REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.THIS TEST IS A
!LOOP OF 512,IT WILL PICK UP CORRECT DROM CONTENTS DATA FROM DATA TABLE
!(TBL), AND EXECUTE A BDISP (DISP 37) AND CHECK NXT ADDRESS =
!CRAM J + DROM B.THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION
!IN CRAM 0 THAT USES THE FOLOWING PATH:
!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
!	NUMBER IS LOADED WITH THE DROM ADDRESS.
!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
!ALWAYS 0000.THE DISP TYPE IS EXECUTED IN CRAM 1.ANY DISCREPANCY IN 
!NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.

    BEGIN
    LOCAL
	B,
	DROM_WRD,
	FLD3,
	FLD4;
    LABEL
	BLOCK1;
    BIND
	POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
			 U_DISP_BDISP U);		!GET 2 WORDS

    IF .DROM_FLAG NEQ 0 
    THEN
	RETURN;

    LOAD_U(0, POINTER);					!LOAD THEM
    LC(0);						!LOAD CRAM ADDRESS 0
    INCR I FROM 0 TO %O'77' DO
	BEGIN
	    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
	    MOD_FLD(4,.FLD4);				!MODIFY THOSE DIGITS IN INSTRUCTION
	    INCR K FROM 0 TO %O'7' DO
		BEGIN
		DROM_WRD = .TBL[.I^3+.K];		!GET DROM WORD FROM TABLE
		FLD3 = .K<0, 3> ^ 9;			!GET LO OCTAL DIGIT OF DROM ADRS
		MOD_FLD(3,.FLD3);			!MODIFY IT IN INSTRUCTION
		B = .DROM_WRD<24,6>;			!GET THE B FIELD
		ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
		ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
		ER_TAB[2] = .B;				!STOR A FIELD FOR ERROR PRINTOUT
		DO (0)	WHILE 
BLOCK1 :
		BEGIN
		RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS AND GET NXT CRAM ADRS
		IF .RCVDATA NEQ .B			!CHECK THE DATA
		THEN ERRCAS(1,1,.B,.RCVDATA,4,ER_TAB);	!NO
!*MESSAGE 1
!*STIMULUS:
!*	DID A BDISP AT DROM LOCATION /\O0
!*	DROM CONTAINS /\U1
!*	B FEILD IS /\O2
!*RESPONSE:
!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
!*	NXT ADRS = DROM B + CRAM J
!]ERROR 1
!]IR FCLK SPECIR DRMAB DISP NTWK
		IF LOOP_CHK(1)				!IS LOOP ON ERROR SET
		THEN 
		BEGIN
			SET_C(0);			!SET CRAM ADRS TO 0
			LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
		END;
		0					!TO ILLUMINATE BLISS INFO COMMENT
		END;
		END;
	    END;
	END;

END
ELUDOM

   