%TITLE 'STIRS FAULT ISOLATION DATA FOR M8616 (CSL) BOARD'

MODULE MSCSLD	(
		LANGUAGE(BLISS36)
		) =

BEGIN

!
!			  COPYRIGHT (C) 1979 BY
!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
!
! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
! TRANSFERRED.
!
! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
! CORPORATION.
!
! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
!

!++
! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
!
! ABSTRACT:
!
!	THIS MODULE CONTAINS THE FAULT ISOLATION DATA FOR THE KS10
!	STIMULUS/RESPONSE (STIRS) DIAGNOSTIC FOR THE M8616 (CSL) BOARD.
!	IT IS LINKED TO THE 'MSSTRC' AND 'MSCSLT' MODULES TO PRODUCE
!	THE 'MSCSL.EXE' FILE.
!
! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
!
! AUTHOR: RICH MURATORI	, CREATION DATE: 23-MAY-79
!
! MODIFIED BY:
!
!	RICH MURATORI, 23-MAY-79; VERSION 0.1
!--
!
! EQUATED SYMBOLS:
!

    GLOBAL LITERAL
	DATA_VERSION = 1,			!VERSION NUMBER FOR THIS MODULE
	DATA_EDIT = 0;				!EDIT NUMBER FOR THIS MODULE
!
! MACROS:
!

    COMPILETIME
	ALLOC_B = 35,	! PDP-11 STYLE BIT # IN WORD, READY TO OVERFLOW
	ALLOC_W = -1,	! WORD #, SO WE WILL START WITH 0 AFTER OVERFLOW
	ALLOC_N = 0,	! NUMBER OF THINGS ALLOCATED
	ALLOC_N_1 = 0,	! (ALLOC_N - 1) TEMPORARY
	ALLOC_W_1 = 0;	! (ALLOC_W + 1) TEMPORARY

    MACRO
	ALLOC(ALLOC_NAME,ALLOC_SLIT) =	! ALLOCATE FAULT ANALYSIS BITS
	    %ASSIGN(ALLOC_B,ALLOC_B + 1)
	    %IF ALLOC_B EQL 36
	    %THEN
		%ASSIGN(ALLOC_B,0)
		%ASSIGN(ALLOC_W,ALLOC_W + 1)
		COMPILETIME
		    %NAME(W_,%NUMBER(ALLOC_W)) = 0;
	    %FI
	    MACRO
		ALLOC_NAME = %QUOTE %ASSIGN (
		    %QUOTE %EXPAND %NAME(W_,%NUMBER(ALLOC_W)),
		    %QUOTE %EXPAND %NAME(W_,%NUMBER(ALLOC_W)) OR
			(1 ^ %QUOTE %EXPAND %NUMBER(ALLOC_B)))
		%QUOTE % ;
	    BIND
		%NAME(N_,%NUMBER(ALLOC_N)) =
		    %IF %NULL(ALLOC_SLIT)
		    %THEN
			%ASSIGN(ALLOC_N_1,ALLOC_N - 1)
			%NAME(N_,%NUMBER(ALLOC_N_1))
		    %ELSE
			UPLIT(%ASCIZ ALLOC_SLIT)
		    %FI ;
	    %ASSIGN(ALLOC_N,ALLOC_N + 1)
	%,
	DUMP(X,N)[] =		! X0, ... XN
	    %IF %COUNT GEQ N %THEN %EXITMACRO %FI
	    %IF %COUNT NEQ 0 %THEN , %FI
	    %NAME(X,%NUMBER(%COUNT))
	    DUMP(X,N)
	%,
	DUMP_ASSIGN(N)[] =	! %ASSIGN(X0,0) ... %ASSIGN(XN,0)
	    %IF %COUNT GEQ N %THEN %EXITMACRO %FI
	    %QUOTE %ASSIGN (%NAME(W_,%NUMBER(%COUNT)),0)
	    DUMP_ASSIGN(N)
	%;

!SOME SPECIAL MACROS WHICH COMBINE SEVERAL NETWORK MACROS

MACRO
	PI_REQ1 = PIREQ1 PIREQ%,
	PI_REQ2 = PIREQ2 PIREQ%,
	PI_REQ3 = PIREQ3 PIREQ%,
	PI_REQ4 = PIREQ4 PIREQ%,
	PI_REQ5 = PIREQ5 PIREQ%,
	PI_REQ6 = PIREQ6 PIREQ%,
	PI_REQ7 = PIREQ7 PIREQ%,
	TCLKA = T_CLK_A TCLK_CSL R_CLK_E RCLK_CSL%,
	TCLKB = T_CLK_B TCLK_CSL R_CLK_E RCLK_CSL%,
	TCLKC = T_CLK_C TCLK_CSL%,
	TCLKD = T_CLK_D TCLK_CSL%,
	RCLKD = R_CLK_D R_CLK_E RCLK_CSL%,
	RCLKH = R_CLK_H RCLK_CSL%,
	TCLK_CSL = T_CLK_CSL PDLY3 MSTRCLK%,
	RCLK_CSL = R_CLK_CSL PDLY5 MSTRCLK%,
	MSTRCLK = MSTR_CLK MNT_ENBH%;

!NETWORKS ON CSL1

ALLOC( MSTR_CLK , 'CSL1: MASTER CLOCK FLOPS')
ALLOC( T_CLK , 'CSL1: "T CLK H"')
ALLOC( PDLY1 , 'CSL1: PROGRAMMED DELAY NETWORK #1')
ALLOC( PDLY2 , 'CSL1: PROGRAMMED DELAY NETWORK #2')
ALLOC( PDLY3 , 'CSL1: PROGRAMMED DELAY NETWORK #3')
ALLOC( PDLY4 , 'CSL1: PROGRAMMED DELAY NETWORK #4')
ALLOC( PDLY5 , 'CSL1: PROGRAMMED DELAY NETWORK #5')
ALLOC( T_CLK_CSL , 'CSL1: "T CLK CSL\#20\"')
ALLOC( R_CLK , 'CSL1: "R CLK H"')
ALLOC( R_CLK_CSL , 'CSL1: "R CLK CSL\#20\"')
ALLOC( BUS_ARB, 'CSL1: BUS ARBITRATOR')

!NETWORKS ON CSL2

ALLOC( ADR0L2_L, 'CSL2: ADR 0')
ALLOC( ADR0L2_H )
ALLOC( ADR1L_L, 'CSL2: ADR 1')
ALLOC(ADR1L_H )

!NETWORKS ON CSL3

ALLOC( REC_PE, 'CSL3: "REC PE" DETECTOR')
ALLOC( CACHE_EN, 'CSL3: CACHE ENABLE')
ALLOC( CRA_PE_LTCH , 'CSL3: PARITY ERROR LATCH')
ALLOC( CRM_PE_LTCH )
ALLOC( DP_PE_LTCH )
ALLOC( REC_PE_LTCH )
ALLOC( CPU_PE, 'CSL3: "CPU PE" NETWORK')
ALLOC( REC_BUS_PE , 'CSL3: "REC BUS PE" NETWORK')
ALLOC( DP_PAR_ERR , 'CSL3: "DP PAR ERR" NETWORK')
ALLOC( PE_LTCH , 'CSL3: "PE (1)" LATCH')
ALLOC( PE_DET , 'CSL3: PARITY DETECT CONTROL FLOPS')
ALLOC( RST_LTCH )
ALLOC( CRM_DET )
ALLOC( DP_PE_DET )
ALLOC( RAM_ER_DLY , 'CSL3: RAM ERROR LATCHS')
ALLOC( RAM_ER_LTCH )
ALLOC( NEXM_LTCH , 'CSL3: "NEXM" DETECT NETWORK')
ALLOC( MEM , 'CSL3: "MEM" LATCH')
ALLOC( MEMH )
ALLOC( RD_0 , 'CSL3: REG READ SIGNALS')
ALLOC( RD_100 )
ALLOC( RD_300 )
ALLOC( RD_302 )
ALLOC( WRT100 , 'CSL3: REG WRITE SIGNALS')
ALLOC( WRT102 )
ALLOC( WRT104 )
ALLOC( WRT106 )
ALLOC( WRT110 )
ALLOC( WRT112 )
ALLOC( WRT114 )
ALLOC( WRT116 )
ALLOC( WRT204 )
ALLOC( WRT205 )
ALLOC( WRT206 )
ALLOC( WRT210 )
ALLOC( WRT212 )

!NETWORKS ON CSL4

ALLOC( DFN_0, 'CSL4: REGISTER 205')
ALLOC( DFN_1 )
ALLOC( DFN_2 )
ALLOC( DFN_3 )
ALLOC( DFN_4 )
ALLOC( DFN_5 )
ALLOC( DFN_6 )
ALLOC( DFN_7 )
ALLOC( DFN_11 )
ALLOC( TRAP_EN )
ALLOC( CRM_RESET , 'CSL4: REGISTER 204' )
ALLOC( DP_RESET )
ALLOC( STK_RESET )
ALLOC( CRM_WRT )
ALLOC( CRM_ADR_LD )
ALLOC( SS_MODE )
ALLOC( REG204 )
ALLOC( XMIT_DATA , 'CSL4: REGISTER 210')
ALLOC( XMIT_ADR )
ALLOC( C_R_C_E )		!'CRA R CLK ENB (1)'
ALLOC( C_T_C_E )		!'CRA T CLK ENB (1)'
ALLOC( LTCH_DATA )
ALLOC( C_LTCHS )
ALLOC( REG210 )
ALLOC( BUS_REQ , 'CSL4: "BUS REQ" LATCH')
ALLOC( CONS_REQ )
ALLOC( REQ_CTL )
ALLOC( MSEC_EN , 'CSL4: "1 MSEC EN" LATCH')
ALLOC( TEN_INT_LTCH , 'CSL4: "10 INT" LATCH')
ALLOC( GRANT , 'CSL4: "GRANT" DRIVER')
ALLOC( HLT_LP , 'CSL4: "HALT LOOP (1)" LATCH')
ALLOC( EXEC_B , 'CSL4: "EXECUTE" LATCH')
ALLOC( EXEC_DRVR , 'CSL4: "EXECUTE" DRIVER')
ALLOC( RUN_1 , 'CSL4: "RUN" LATCH')
ALLOC( RUN_DRVR , 'CSL4: "RUN" DRIVER')
ALLOC( CONT_H , 'CSL4: "CONTINUE" LATCH')
ALLOC( CONT_DRVR , 'CSL4: "CONTINUE" DRIVER')
ALLOC( INT_10 , 'CSL4: "INT 10" CONTROL NETWORK')
ALLOC( CMD_LD , 'CSL4: "CPM CMD LD" SIGNAL')
ALLOC( DATA_ENB , 'CSL4: "DATA ENB" LATCH')
ALLOC( RTN_DATA, 'CSL4: "RETURN DATA" SIGNAL')
ALLOC( LTCH_DATA_ENB , 'CSL4: "LATCH DATA ENB (1)" SIGNAL')
ALLOC( DATA_ACK , 'CSL4: "DATA ACK" LATCH')
ALLOC( CRA_R_CLK , 'CSL4: "CRA R CLK\#20\" SIGNAL')
ALLOC( R_CLK_ENB , 'CSL4: "R CLK ENB" SIGNAL')
ALLOC( T_CLK_EN , 'CSL4: "CRA T CLK ENABLE" SIGNAL')
ALLOC( STAT_RD , 'CSL4: "STATUS RD (1)" SIGNAL')
ALLOC( GRANT_1 , 'CSL4: CONTROL LATCHES')
ALLOC( X_D1 )
ALLOC( C_LTCH1 )
ALLOC( T_ENB , 'CSL4: TRANSCEIVER TRANSMIT CONTROL SIGNALS')
ALLOC( T_ENB_A )
ALLOC( DATA_CYC )
ALLOC( XMIT_ENBS , 'CSL4: REGISTER 210 AND TRANSCEIVER TRANSMIT CONTROL SIGNALS')

!NETWORKS ON CSL5

ALLOC( RST1 , 'CSL5: "RESET (1)" SIGNAL')
ALLOC( PNL_RST , 'CSL5: "PANEL RESET" SIGNAL')
ALLOC( RESETL_L , 'CSL5: "RESET" SIGNAL DRIVERS')
ALLOC( RESETL_H )
ALLOC( RESETB_L )
ALLOC( RESETB_H)
ALLOC( RESETH )
ALLOC( CRAM_CLK , 'CSL5: "CRAM CLK" SIGNAL')
ALLOC( SING_CLK , 'CSL5: "SINGLE CLK" SIGNAL')
ALLOC( CLK_RUN , 'CSL5: "CLK RUN" SIGNAL')
ALLOC( PF_ST_1 , 'CSL5: "PAGE FAIL START (1)" SIGNAL')
ALLOC( PF_1 , 'CSL5: "PAGE FAIL (1)" SIGNAL')
ALLOC( CLK_ENBS , 'CSL5: CPU CLOCK ENABLES')
ALLOC( SHFT_LOGIC )
ALLOC( ENB , 'CSL5: "ENABLE (1)" SIGNAL')
ALLOC( ENABLE_PE )
ALLOC( PF , 'CSL5: "PAGE FAIL" SIGNAL')
ALLOC( WRT_DLY , 'CSL5: "WRT DLY" SIGNAL')
ALLOC( RD_DATA , 'CSL5: "RD DATA (1)" SIGNAL')
ALLOC( RD_DLY , 'CSL5: "RD DLY" SIGNAL')
ALLOC( READ_DLY , 'CSL5: "READ DLY" SIGNAL')
ALLOC( T_CNT_DN , 'CSL5: "T COUNT DONE (1)" SIGNAL')
ALLOC( T_COUNT_DONE )
ALLOC( ENB_RES , 'CSL5: "ENABLE + RESET" SIGNAL')

!NETWORKS ON CSL6

ALLOC( BUS20_23 , 'CSL6: BUS DATA 20-23 TRANSCEIVER')
ALLOC( BUS24_27 , 'CSL6: BUS DATA 24-27 TRANSCEIVER')
ALLOC( BUS28_31 , 'CSL6: BUS DATA 28-31 TRANSCEIVER')
ALLOC( BUS32_35 , 'CSL6: BUS DATA 32-35 TRANSCEIVER')
ALLOC( ADR0L6_L , 'CSL6: ADR 0' )
ALLOC( ADR0L6_H )
ALLOC( CSLBUF0 , 'CSL6: CSL BUS BUFFER')
ALLOC( CSLBUF1 )
ALLOC( CSLBUF2 )
ALLOC( CSLBUF3 )
ALLOC( CSLBUF4 )
ALLOC( CSLBUF5 )
ALLOC( MNT_ENBL, 'CSL6: "MAINT ENB" SIGNAL')
ALLOC( MNT_ENBH )
ALLOC( MNT_CLK , 'CSL6: "CLK 0" SIGNAL')
ALLOC( XMIT_PAR_RT , 'CSL6,7: TRANSCEIVER PARITY SIGNALS FOR BUS DATA 18-35')
ALLOC( RCV_PAR_RT )

!NETWORKS ON CSL7

ALLOC( BUS4_7 , 'CSL7: BUS DATA 4-7 TRANSCEIVER')
ALLOC( BUS8_11 , 'CSL7: BUS DATA 8-11 TRANSCEIVER')
ALLOC( BUS12_15 , 'CSL7: BUS DATA 12-15 TRANSCEIVER')
ALLOC( BUS16_19 , 'CSL7: BUS DATA 16-19 TRANSCEIVER')

!NETWORKS ON CSL8

ALLOC( BUS0_3 , 'CSL8: BUS DATA 0-3 TRANSCEIVER')
ALLOC( CMD_XCVR , 'CSL8: BUS CONTROL SIGNALS TRANSCEIVER')
ALLOC( RST_XCVR , 'CSL8: "R RESET" TRANSCEIVER')
ALLOC( R_PAR_RT , 'CSL8: "R PAR RIGHT" TRANSCEIVER')
ALLOC( R_PAR_LFT , 'CSL8: "R PAR LEFT" TRANSCEIVER')
ALLOC( XMIT_PAR_LFT , 'CSL7,8: TRANSCEIVER PARITY SIGNALS FOR BUS DATA 00-17')
ALLOC( RCV_PAR_LFT )
ALLOC( MEM_BUSY , 'CSL8: "MEM BUSY" SIGNAL')

!NETWORKS ON CSL9

ALLOC( R_CLK_A , 'CSL9: "R CLK A" SIGNAL')
ALLOC( R_CLK_B , 'CSL9: "R CLK B" SIGNAL')
ALLOC( R_CLK_H , 'CSL9: "R CLK H" SIGNAL')
ALLOC( R_CLK_L , 'CSL9: "R CLK L" SIGNAL')
ALLOC( R_CLK_D , 'CSL9: "R CLK D" SIGNAL')
ALLOC( R_CLK_E , 'CSL9: "R CLK E" SIGNAL')

!NETWORKS ON CSLA

ALLOC( T_CLK_A , 'CSLA: "T CLK A" SIGNAL')
ALLOC( T_CLK_B , 'CSLA: "T CLK B" SIGNAL')
ALLOC( T_CLK_C , 'CSLA: "T CLK C" SIGNAL')
ALLOC( T_CLK_D , 'CSLA: "T CLK D" SIGNAL')
ALLOC( NEXM , 'CSLA: READ MUX 1')
ALLOC( TEN_INT )
ALLOC( BUSREQ )
ALLOC( RAM_ERROR , 'CSLA: READ MUX 2')
ALLOC( RCLK_ENB0 )
ALLOC( CR_CLK_ENB )
ALLOC( DP_CLK_ENB )
ALLOC( EXEC , 'CSLA: READ MUX 3')
ALLOC( RUN )
ALLOC( CONT )
ALLOC( PE )
ALLOC( HALT_LOOP )
ALLOC( DATAACK )
ALLOC( R_RESET , 'CSLA: READ MUX 4')
ALLOC( PIREQ2 )
ALLOC( PIREQ1 )
ALLOC( RECEIVE_PE )
ALLOC( RPAR_LEFT , 'CSLA: READ MUX 5')
ALLOC( PIREQ4 )
ALLOC( CRM_PE )
ALLOC( RDATA_05 )
ALLOC( RDATA_13 )
ALLOC( RDATA_21 )
ALLOC( RDATA_29 )
ALLOC( RDATA_07 , 'CSLA: READ MUX 6')
ALLOC( RDATA_15 )
ALLOC( RDATA_23 )
ALLOC( RDATA_31 )
ALLOC( RDATA_04 )
ALLOC( RDATA_12 )
ALLOC( RDATA_20 )
ALLOC( RDATA_28 )
ALLOC( RDATA_00 , 'CSLA: READ MUX 7')
ALLOC( R_BADATA )
ALLOC( PIREQ5 )
ALLOC( MEM_PAR_ERR )
ALLOC( RDATA_08 )
ALLOC( RDATA_16 )
ALLOC( RDATA_24 )
ALLOC( RDATA_32 )
ALLOC( RDATA_01 , 'CSLA: READ MUX 8')
ALLOC( R_COMADR )
ALLOC( PIREQ6 )
ALLOC( DP_PE )
ALLOC( RDATA_11 )
ALLOC( RDATA_19 )
ALLOC( RDATA_27 )
ALLOC( RDATA_35 )
ALLOC( RPAR_RIGHT , 'CSLA: READ MUX 9')
ALLOC( MEMBUSY )
ALLOC( PIREQ3 )
ALLOC( RDATA_06 )
ALLOC( RDATA_14 )
ALLOC( RDATA_22 )
ALLOC( RDATA_30 )
ALLOC( RDATA_02 , 'CSLA: READ MUX 10')
ALLOC( R_IODATA )
ALLOC( PIREQ7 )
ALLOC( CRA_PE )
ALLOC( RDATA_10 )
ALLOC( RDATA_18 )
ALLOC( RDATA_26 )
ALLOC( RDATA_34 )
ALLOC( RDATA_09 , 'CSLA: READ MUX 11')
ALLOC( RDATA_17 )
ALLOC( RDATA_25 )
ALLOC( RDATA_33 )
ALLOC( RDATA_03 )
ALLOC( R_DATA )
ALLOC( MEM_REF_ERR )
ALLOC( PIREQ , 'CSLA: PI REQ DRIVERS')


    MACRO
	NTWK =
	    %ASSIGN(ALLOC_W_1,ALLOC_W + 1)
	    DUMP(W_,%NUMBER(ALLOC_W_1))
	    DUMP_ASSIGN(%NUMBER(ALLOC_W_1))
	%;

    ! THIS PLIT MAKES A  V E R Y  LONG LISTING WITH EXPANSIONS
    SWITCHES LIST(NOEXPAND);

    GLOBAL BIND
	NET_NAMES = PLIT
	(
	    DUMP(N_,%NUMBER(ALLOC_N))
	);

    ! DOCUMENT WHAT JUST HAPPENED
    %PRINT(%NUMBER(ALLOC_N))
    %PRINT(%NUMBER(ALLOC_W))
    %PRINT(%NUMBER(ALLOC_B))

    GLOBAL LITERAL
	MAXNETS = ALLOC_N;			!NUMBER OF NETWORKS
  