SUBTTL	ARITHMETIC RELIABILITY TEST

;*SIMULATOR -DDT- INITIALIZATION SEQUENCE

SIMDDT:	JRST	SENTRY		;GO TO SIMULATOR

;*INITIALIZING AND CONTROL SEQUENCE

SFSRT1:	SETZM	ERRTLS		;CLEAR ALL TOTALS
	SETZM	TICKS
	SETZM	TSTIMR#
	JRST	BEGIN

START:	PGMINT			;INITIALIZE SUBROUTINES
	JSR	MGNCLR
	SWITCH

	MOVEI	ACSP,ACS	;SETUP SIMULATED AC POINTER
	SKIPN	USER
	JRST	.+3
	CALL	0,[SIXBIT/TIMER/]	;USER RANDOM BASE
	MOVEM	0,RANDBS		;SETUP RANDOM BASE
	SWITCH
	TRNN	RANBAS		;SPECIFY RANDOM NUMBER BASE ?
	JRST	STARTA
	MOVEI	[ASCIZ/
SPECIFY RANDOM NUMBER BASE - /]
	PNTALF
	TTIOCT			;INPUT OCTAL NUMBER
	JRST	.-3		;ERROR
	MOVEM	0,RANDBS
STARTA:	MOVE	RA,RANDBS
	SETOM	.FIXF#		;SET TEST CONTROL FLAGS TO RUN ALL
	SETOM	.FLTF#
	SETOM	.BYTF#
	SETOM	.FASTF#
	SETOM	.SLOWF#
	SETOM	.DFLTF#
	SETZM	CKOUTF#
	MOVEI	1,6
	MOVEM	1,RTIME#

	SWITCH			;SETUP TEST CONTROL FLAGS
	TRNE	ENTDDT		;ENTER DDT SWITCH SET ?
	JRST	DDTEX		;YES
	TRNE	CKOUT		;CHECKOUT (KA10) ?
	SETOM	CKOUTF		;YES
	TRNE	INHFXD
	SETZM	.FIXF		;FIXED POINT INHIBITED
	TRNE	INHFP
	SETZM	.FLTF		;FLOATING POINT INHIBITED
	TRNE	INHBYT
	SETZM	.BYTF		;BYTE'S INHIBITED
	TRNE	INHDFP
	SETZM	.DFLTF		;DOUBLE FLOATING INHIBITED
	TRNE	SLOW
	SETZM	.FASTF		;SIMULATION COMPARISON ONLY
	TRNE	FAST
	SETZM	.SLOWF		;INSTRUCTION RESULT COMPARE ONLY
	TLNN	RELIAB		;RELIABILITY MODE ?
	SETZM	RTIME		;NO, FAST CYCLE OPERATION
	SETCA
	TRNE	INHFXD!INHFP!INHBYT!INHDFP
	JRST	.+5
	MOVEI	[ASCIZ/
OPERATOR INHIBIT OF ALL TESTS, RESTART
/]
	PNTALF
	ERRHLT
	JRST	BEGIN
	TRNE	SLOW!FAST
	JRST	STARTB
	MOVEI	[ASCIZ/
OPERATOR INHIBIT OF BOTH FAST AND SLOW, RESTART
/]
	PNTALF
	ERRHLT
	JRST	BEGIN
PGMNAM:	ASCIZ/
DECSYSTEM10 KI10 ARITHMETIC RELIABILITY TEST (DBKDA)
/

STARTB:	SWITCH
	SKIPE	USER		;USER MODE ?
	JRST	BEGFX		;YES, START TESTING
	TRNE	INHCLK		;EXEC, INHIBIT CLOCK INTERRUPTS ?
	JRST	STARTC		;YES
	MOVE	1,[JSR	ITRCLK]
	MOVEM	1,$ITRHL
	MOVEI	1,^D60
	SKIPE	CYCL60
	MOVEI	1,^D50
	MOVEM	1,HERTZ#
	MOVE	[JSR ITRCH1]
	MOVEM	44
	MOVEM	46
	MOVEM	50
	MOVEM	52
	MOVEM	54
	MOVEM	56
	CONO	APR,CLKENB!CLKCLR!IAPRE1!IAPRC1
	CONO	PI,PARENB!CHNON!PION!PICHNA
	JRST	BEGFX

STARTC:	CONO	PI,PICLR!CHNOFF!PIOFF
	CONO	APR,IAPRE1
	CONO	PI,CHNON!PION!PICHN1
	JRST	BEGFX
;*TESTING SEQUENCE
;*FIXED POINT ARITHMETIC OPERATIONS

BEGFX:	SUBTST
	SETZM	CNTL
	SKIPN	.FIXF
	JRST	BEGFP		;DON'T TEST FIXED
	SKIPN	.FASTF
	JRST	FXS		;FIXED POINT, SLOW ONLY

;*FIXED POINT FAST
;*COMPARE RESULTS OF MUL,DIV,ADD REMAINDER WITH ORIGINAL

FXF:	SUBTST
	MOVEI	LOP,^D20
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
FXF1:	JSR	FSTMDI
	CAI	FIXEDI+4(CNTR)	;FIXED POINT INTERGERS
	JSR	FSTMD
	CAI	FIXED+2(CNTR)	;FIXED POINT
	SOJG	LOP,FXF1

;*FIXED POINT SLOW
;*COMPARE MACHINE RESULTS AGAINST SIMULATION

FXS:	SUBTST
	SKIPN	.SLOWF
	JRST	BEGFP		;DON'T RUN
	MOVEI	LOP,2
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
FXS1:	JSR	MD
	CAI	FIXEDI+10(CNTR)	;FIXED POINT INTERGERS
	JSR	MD
	CAI	FIXED+10(CNTR)	;FIXED POINT
	SOJG	LOP,FXS1
;*TESTING SEQUENCE
;*FLOATING POINT ARITHMETIC OPERATIONS
BEGFP:	SUBTST
	SKIPN	.FLTF
	JRST	BEGBYT		;DON'T TEST FLOATING
	SKIPN	.FASTF
	JRST	FPS		;FLOATING POINT, SLOW ONLY

;*FLOATING POINT FAST
;*COMPARE RESULTS OF DIV THEN MUL
FPF:	SUBTST
	MOVEI	LOP,^D20
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	FSTFP		;FLOATING POINT
	CAI	FPMD+4(CNTR)
	SOJG	LOP,.-2

;*FLOATING POINT SLOW
;*COMPARE MACHINE RESULTS AGAINST SIMULATION
FPS:	SUBTST
	SKIPN	.SLOWF
	JRST	BEGBYT
	MOVEI	LOP,2
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
FPS1:	JSR	MD		;FLOATING POINT ADD/SUB
	CAI	FPAS+10(CNTR)
	JSR	MD		;FLOATING POINT SUB/MUL
	CAI	FPSM+10(CNTR)
	JSR	MD		;FLOATING POINT MUL/DIV
	CAI	FPMD+10(CNTR)
	JSR	MD		;DFN/UFA AND RI MODE
	CAI	MISCFP+10(CNTR)
	JSR	MD		;THE L MODE
	CAI	FPL+10(CNTR)
	SOJG	LOP,FPS1

;*BYTE INSTRUCTION, COMPARE WITH SIMULATION
BEGBYT:	SUBTST
	SKIPN	.BYTF
	JRST	BEGDFP		;DON'T TEST BYTE
	MOVEI	LOP,^D5
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	BYTE		;SIM AND CHECK BYTES
	CAI	BYTES+5(CNTR)
	SOJG	LOP,.-2
;*TESTING SEQUENCE
;*DOUBLE FLOATING POINT

BEGDFP:	SUBTST
	SKIPN	.DFLTF
	JRST	BEGEND		;DON'T TEST DOUBLE FLOATING
	SKIPN	.FASTF
	JRST	DFPS		;DOUBLE FLOATING, SLOW ONLY

;*DOUBLE FLOATING POINT FAST
;*COMPARE RESULTS OF ADD/SUB AND MUL/DIV

DFPF:	SUBTST
	MOVSI	CNTL,DFP
	MOVEI	LOP,^D10
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
	JSR	FSTFP
	CAI	DFPAS+4(CNTR)	;DOUBLE FLOATING POINT
	SOJG	LOP,.-2

;*DOUBLE FLOATING POINT SLOW
;*COMPARE MACHINE RESULTS AGAINST SIMULATION

DFPS:	SUBTST
	MOVSI	CNTL,DFP
	SKIPN	.SLOWF
	JRST	BEGEND
	MOVEI	LOP,^D10
	ASH	LOP,@RTIME	;SETUP RUNNING TIME
DFPS1:	JSR	MD
	CAI	DFPAS+10(CNTR)	;DOUBLE FLOATING POINT
	SOJG	LOP,DFPS1
	JRST	BEGEND
;*TEST OF IMUL AND IDIV
;*DIVIDE THEN MULTIPLY AND ADD REMAINDER

FSTMDI:	0
	MOVE	IT,@.-1		;POINT TO INST
	HRROI	CNTR,-4
FSMDI1:	JSR	RANNOV		;RANDOM, OV NOT POSSIBLE
	SETZM	CNTL
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JFCL	10,FSMDI2	;OV SET, DIVIDE ERROR
	SKIPN	MGNFLG		;MARGIN ALL ?
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,MARGIN	;NO, SET MARGINS
	XCT	@IT		;MULTIPLY
	SKIPN	MGNFLG
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,[IMGNOF,,ISPDOF]
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	JFCL	10,FSMDI2	;MUL OR DIV ERROR
	ADD	AC,DIVAC+1
	CAME	AC,RA		;LOOK FOR ORIG
FSMDI2:	JSR	FSTER		;ERROR
	AOJL	CNTR,FSMDI1	;NEXT PAIR
	JRST	@FSTMDI		;EXIT
;*TEST OF MUL AND DIV
;*DIVIDE THEN MULTIPLY AND ADD REMAINDER

FSTMD:	0
	MOVE	IT,@.-1		;POINT TO INST
	HRROI	CNTR,-2
FSTMD1:	JSR	RANNOV		;RANDOM, OV NOT POSSIBLE
	SETZM	CNTL
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JFCL	10,FSTMD2	;OV SET, DIVIDE ERROR
	JRST	2,@[XWD 0,.+1]	;CLEAR FLAGS
	SKIPN	MGNFLG
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,MARGIN
	XCT	@IT		;MULTIPLY
	SKIPN	MGNFLG
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,[IMGNOF,,ISPDOF]
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	JSP	.+1
	MOVEM	SECFLG#
	JFCL	10,FSTMD2	;MUL OR DIV ERROR
	JFCL	17,.+1
	ADD	AC+1,DIVAC+1
	JFCL	2,CRYFIX	;THE CRY 1 FLAG
	JFCL	4,CRY0FX
	CAMN	AC,RA
	CAME	AC+1,RA+1
FSTMD2:	JSR	FSTER		;MUL OR DIV ERROR
	AOJL	CNTR,FSTMD1	;NEXT PAIR
	JRST	@FSTMD		;EXIT

CRYFIX:	TLC	AC+1,400000
	AOJA	AC,FSTMD2-3

CRY0FX:	TLC	AC+1,400000
	SOJA	AC,FSTMD2-2;*TEST OF FLOATING POINT
;*FP DIV THEN FP MUL

FSTFP:	0
	MOVE	IT,@.-1		;POINT TO A FP INSTRUCTION
	HRROI	CNTR,-4		;4 ITEMS
FSTFP1:	JSR	RANORM		;NORMALIZED RANDOM NUMBERS
	JSR	DOINS		;XCT INST, RECORD FLAGS
	MOVEM	FLAGS,FSTFLG#
	MOVEM	AC,DIVAC
	MOVEM	AC+1,DIVAC+1
	MOVEM	AC+2,DIVAC+2
	MOVEM	AC+3,DIVAC+3
	AOJGE	CNTR,GG		;IF JUMP PROG LOST
	JSR	DOINS		;DO A FMP
	MOVEM	AC,MULAC
	MOVEM	AC+1,MULAC+1
	MOVEM	AC+2,MULAC+2
	MOVEM	AC+3,MULAC+3
	CAME	AC,RA
	JRST	FSTFP3		;POSSIBLE ERROR
FSTFP2:	AOJL	CNTR,FSTFP1	;NEXT PAIR
	JRST	@FSTFP		;EXIT

FSTFP3:	MOVEM	FLAGS,SECFLG	;SAVE SECOND FLAGS
	MOVE	FLAGS,FSTFLG
	MOVE	AC		;RESULT NOT EQUAL TO ORIGINAL
	SUBI	1		;IF LARGER OR SMALLER
	CAMN	RA		;COMPARE IT
	JRST	FSTFP2		;OK
	SUBI	1
	CAMN	RA
	JRST	FSTFP2		;OK
	ADDI	3
	CAMN	RA
	JRST	FSTFP2		;OK
	ADDI	1
	CAME	RA
FSTFP4:	JSR	FSTER		;ERROR, FIND WHAT FAILED
	JRST	FSTFP2		;OK
;*TEST OF BYTE INSTRUCTIONS
;*COMPARE MACHINE RESULTS WITH SIMULATION

BYTE:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-5		;5 ITEMS
BYTE1:	JSR	RANDOM		;GENERATE RANDOM NUMBERS
	MOVSI	CNTL,BYT	;FLAG FOR PRINTER
	LSH	RA+2,-^D30	;MAKE A BYTE
	LSH	AC+2,-^D24	;POINTER
	ANDI	AC+2,77		;IF THE POINTER (RIGHT HALF)
	TRNN	CNTR,2
	CAMG	AC+2,RA+2	;WILL BE INCREMENTED
	TRO	AC+2,10000	;POINT TO AC
	TRO	RA+2,100	;IF NO INCREMENT
	ROT	RA+2,^D30	;POINT TO AC+1
	ROT	AC+2,^D24
	ADDB	AC+2,RA+2	;THE POINTER IN RA+2, AC+2

	JSR	SIMIT		;SIMULATE
	JSR	DOIT		;XCT
	AOJL	CNTR,BYTE1	;ITERATE
	JRST	@BYTE		;EXIT

;*PERFORM THE MACHINE INSTRUCTION

DOINS:	0
	JRST	2,@[XWD 0,.+1]	;CLEAR FLAGS
	TLNE	CNTL,DFP	;DOUBLE FLOAT FLAG SET ?
	JRST	DFPRTN		;YES, DO INSTR ROUTINES
DOINS1:	SKIPN	MGNFLG		;MARGIN ALL ?
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,MARGIN	;NO, SET MARGINS
	XCT	@IT
	SKIPN	MGNFLG
	JRST	.+3
	SKIPE	MARGIN
	DATAO	APR,[IMGNOF,,ISPDOF]
	JSP	.+1		;SAVE FLAGS
	SKIPE	CKOUTF		;CHECKOUT ?
	TLZ	0,400!200	;YES, CLEAR TN0,TN1
	HLLM	FLAGS		;IN FLAG REGISTR
	JRST	@DOINS
;*TEST INSTRUCTION BY COMPARING MACHINE RESULTS
;*WITH SIMULATION RESULTS

MD:	0
	MOVE	IT,@.-1
	HRROI	CNTR,-10	;GROUPS OF 8
MD1:	TLNN	CNTL,DFP	;DOUBLE FLOAT FLAG SET ?
	JRST	MD2		;NO
	SKIPN	CKOUTF		;YES, CHECKOUT ?
	JRST	MD2		;NO
	JSR	RANORM		;YES, GENERATE NORMALIZED RANDOM
	JRST	MD2+1
MD2:	JSR	RANDOM		;GENERATE RANDOM NUMBERS
	HLLZS	CNTL		;CLEAR CONTROL SWITCHES
	JSR	SIMIT		;SIMULATE INSTRUCTION
	JSR	DOIT		;XCT INSTRUCTION
	AOJL	CNTR,MD1	;ITERATE
	JRST	@MD		;EXIT

;*SIMULATE THE INSTRUCTION

SIMIT:	0
	SAVEM	RA,1
	SINST	@IT		;SIMULATE, RESULTS IN ACS
	JRST	@SIMIT

;*COMPARE MACHINE RESULTS AGAINST SIMULATOR

CHECK:	0
	HLR	FLAGS,PCSAV#
	TLZ	FLAGS,USERF!LIP	;CLEAR MISC
	MOVS	FLAGS
	CAME	FLAGS		;COMPARE FLAGS
	HRRI	CNTL,FLAGS
	CAME	AC+3,4(ACSP)	;COMPARE AC+3
	HRRI	CNTL,AC+3
	CAME	AC+2,3(ACSP)	;COMPARE AC+2
	HRRI	CNTL,AC+2
	TLNE	CNTL,DFP	;DOUBLE FLOATING POINT
	JRST	CHECK2		;YES, CHECK RESULT LS +-1
	CAME	AC+1,2(ACSP)	;COMPARE AC+1
	HRRI	CNTL,AC+1
CHECK1:	CAME	AC,1(ACSP)	;COMPARE AC
	HRRI	CNTL,AC
	JRST	@CHECK
;*PERFORM THE INSTRUCTION

DOIT:	0
	JSR	DOINS		;XCT THE INSTRUCTION
	TLNN	CNTL,ER		;BYPASS IF ERROR
	JSR	CHECK		;CHECK FOR VALID DATA
	TRNN	CNTL,-1
	JRST	@DOIT		;EXIT, NO ERRORS
	SKIPN	USER
DOIT1:	DATAO	PI,(CNTL)	;LOAD MI WITH FAILURE
	TLOE	CNTL,ER		;SET ERROR FLAG
	JRST	DOIT4		;SEE IF PRINT ALL ERRORS
	MOVEI	[ASCIZ/
**********
SIMULATION COMPARISION FAILURE
/]
	PNTAL
	JSR	TTLPNT
	JSR	RESULT		;PRINT MACHINE RESULTS
	JSR	PNTSIM		;PRINT SIMULATION

DOIT2:	MOVEM	CNTL,SAVCNT#	;SAVE CNTL
	TRZ	CNTL,-1		;CLEAR RIGHT HALF
	JSR	CHECK
	MOVE	AC,RA
	MOVE	AC+1,RA+1
	MOVE	AC+2,RA+2
	MOVE	AC+3,RA+3
	SWITCH			;READ SWITCHES
	TLNE	ERSTOP		;HALT AND SAVE AC'S?
	JSR	GOING		;YES
	TLNE	LOOPER		;PROCEED SWITCH SET?
	JRST	.+4		;NO
	JSR	DOIT3		;YES, GO RING BELL
	TLZ	CNTL,ER		;CLEAR ER FLAG
	JRST	@DOIT		;AND CONT WITH PROG
	TRNE	CNTL,-1		;HAD AN ERROR?
	JSR	DOIT3		;YES, GO RING BELL
	MOVE	CNTL,SAVCNT	;RESTORE CNTL
	JRST	DOIT+1		;CYCLE ERROR

DOIT3:	0
	TLNN	DING		;RING BELL ON ERROR ?
	JRST	@DOIT3		;NO
	MOVEI	BELL
	PNTAF			;RING TTY BELL
	JRST	@DOIT3
;*DETERMINE IF FIRST OR SECOND OPERATION CAUSED FAILURE

FSTER:	0
	SETZM	FAIL1#
	SUBI	CNTR,1		;POINT TO FIRST INSTRUCTION
	JSR	SIMIT		;SIMULATE
	MOVE	AC,DIVAC	;RESTORE FIRST RESULTS
	MOVE	AC+1,DIVAC+1
	MOVE	AC+2,DIVAC+2
	MOVE	AC+3,DIVAC+3
	TRZ	CNTL,-1
	JSR	CHECK		;CHECK SIM VS ACTUAL
	TRNN	CNTL,-1
	AOJA	CNTR,FSTER2	;LOOKS LIKE SECOND OP FAILED

FSTER1:	MOVEI	[ASCIZ/
**********
INSTRUCTION COMPARISION FAILURE
/]
	PNTAL
	JSR	TTLPNT
	JSR	RESULTS		;FIRST OP FAILED, PRINT RESULTS
	SAVEM	RA,1
	JSR	PNTSIM		;PRINT SIMULATION
	TLO	CNTL,ER		;SET ER FLAG
	JSR	DOIT		;SCOPE LOOP
	SKIPN	FAIL1		;FIRST OP FAILURE ?
	AOJGE	CNTR,GG		;YES, INC CNTR; IF JUMP PROG LOST
	JRST	@FSTER		;EXIT

FSTER2:	SETOM	FAIL1
	MOVE	RA,DIVAC
	MOVE	RA+1,DIVAC+1
	MOVE	RA+2,DIVAC+2
	MOVE	AC+3,DIVAC+3
	MOVE	AC,MULAC
	MOVE	AC+1,MULAC+1
	MOVE	AC+2,MULAC+2
	MOVE	AC+3,MULAC+3
	JSR	SIMIT		;SIMULATE SECOND OP
	HLL	FLAGS,SECFLG	;GET FLAGS FROM SECOND OP
	JSR	CHECK		;CHECK SIM VS ACTUAL
	TRNE	CNTL,-1		;DID SECOND FAIL ?
	JRST	FSTER1		;YES, PRINT RESULTS
	JRST	@FSTER		;NO, SIM SAYS BOTH OK...CONTINUE
;*UUO ROUTINES
;*SIMULATE SINGLE INSTRUCTION, NO PRINTOUT

SIMNST:	SETOM	MASK		;INHIBIT PRINTOUT
	MOVE	[XWD 1,SAVAC+1]
	BLT	SAVAC+17
	HRRZ	$SVUUO
	MOVEM	INPC		;SETUP PC
	SETZM	INSTR
	SETZM	CNTLPC
	SETOM	SNGLIN		;SET SINGLE INSTRUCTION CONTROL
	SETZM	SNGL2		;SET FOR FIRST INSTR
	GO	SENTRY		;GO TO SIMULATOR
	MOVE	PC
	TLZ	400!200		;CLEAR TN0,TN1
	JSP	1,.+1		;GET ACTUAL FLAGS
	TLNN	1,USERF		;USER MODE ?
	TLZ	AROV		;NO,CLEAR OV FLAG
	MOVEM	PCSAV#		;SAVE PC FLAGS
	MOVS	[XWD 1,SAVAC+1]
	BLT	17
	JRST	UUOEXT		;EXIT UUO

;*SIMULATE SINGLE INSTRUCTION, PRINT STATES

SIMMT:	SETZM	MASK		;ALLOW PRINTOUT
	JRST	SIMNST+1	;REST SAME AS ABOVE

CHECK2:	SKIPN	CKOUTF		;CHECKOUT ?
	JRST	CHECK1-2	;NO
	CAMN	AC+1,2(ACSP)	;CHECK DBL FP LS +-1
	JRST	CHECK1
	SUBI	AC+1,1
	CAMN	AC+1,2(ACSP)
	JRST	CHECK1
	ADDI	AC+1,2
	CAMN	AC+1,2(ACSP)
	JRST	CHECK1
	SUBI	AC+1,1
	JRST	CHECK1-1
;*PRINT PROGRAM TITLE AND PASS COUNT

TTLPNT:	0
	SKIPN	ERRFST#
	PNTNM
	SETOM	ERRFST
	AOS	ERRTLS		;INCREMENT ERROR TOTALS
	SKIPE	USER		;USER MODE ?
	JRST	TLPNT1
	MOVE	0,CONSW
	TRNE	INHCLK		;CLOCK INHIBITED ?
	JRST	TLPNT1		;YES
	MOVE	0,TICKS
	CAIL	^D<60*60*10>
	JSR	RUNTIM
TLPNT1:	MOVEI	[ASCIZ/
BASE RANDOM NUMBER = /]
	PNTAL
	MOVE	0,RANDBS
	PNTHW			;PRINT RANDOM NUMBER BASE
	MOVEI	CRLF
	PNTA
	PNTMGN			;PRINT MARGINS
	MOVE	PASCNT
	CAMN	PSCTR1#
	JRST	@TTLPNT
	MOVEI	[ASCIZ/
TEST PASS COUNT = /]
	PNTAL
	MOVE	PASCNT
	MOVEM	PSCTR1
	PNTDEC
	MOVEI	CRLF
	PNTA
	JRST	@TTLPNT

;*ERROR STOP

GOING:	0
	CONI	APR,$SVAPR
	CONI	PI,$SVPI
	CONO	PI,PIOFF
	HALT	@GOING
;*DOUBLE FLOATING POINT ROUTINES

DFPRTN:	SKIPN	CKOUTF		;CHECKOUT ?
	JRST	DOINS1		;NO
	MOVE	[XWD 1,SAVAC+1]
	BLT	SAVAC+17
	MOVE	@IT
	LSH	-^D27
	SUBI	110
	MOVEM	IT		;SETUP TABLE INDEX
	MOVE	0,AC		;SETUP OPERANDS
	MOVE	1,AC+1
	MOVEI	Q,AC+2
	XCT	DFPTAB(IT)	;DO ROUTINE
	MOVEM	0,SVE0#
	MOVEM	1,SVE1#
	MOVS	[XWD 1,SAVAC+1]
	BLT	17
	MOVE	1,SVE0		;SETUP RESULTS
	MOVE	2,SVE1
	JRST	DOINS1+1

;*SOFTWARE ROUTINE POINTER TABLE

DFPTAB:	GO	DFA.0		;DFAD
	GO	DFS.0		;DFSB
	GO	DFM.0		;DFMP
	GO	DFD.0		;DFDV
	JRST	GG		;114
	JRST	GG		;115
	JRST	GG		;116
	JRST	GG		;117
	JRST	GG		;120
	JRST	GG		;121
	GO	FIX.0		;FIX
	JRST	GG		;123
	JRST	GG		;124
	JRST	GG		;125
	GO	FIXR.0		;FIXR
	GO	FLTR.0		;FLTR

;*CHECK PRINT ALL ERRORS SWITCH

DOIT4:	SWITCH
	TLNN	PALERS		;PRINT ALL ERRORS ?
	JRST	DOIT2		;NO, DON'T PRINT...NOT FIRST
	JRST	DOIT1+3
;*RANDOM NUMBER GENERATION
;*FOUR RANDOM IN AC,AC+1,AC+2,AC+3
;*A COPY ALSO IN RA,RA+1,RA+2,RA+3

RANDOM:	0
	SWITCH
	TLNE	RSTART!TOTALS
	JSR	PNTTOT
	MOVE	AC,RA
	ADD	AC,[543217335216]
	ROT	AC,-1
	EQVB	AC,RA		;RANDOM 1
	MOVS	AC+1,RA
	ADD	AC+1,[165742176525]
	ROT	AC+1,-1
	EQVB	AC+1,RA+1	;RANDOM 2
	MOVS	AC+2,RA+1
	ADD	AC+2,[147532173543]
	ROT	AC+2,-1
	EQVB	AC+2,RA+2	;RANDOM 3
	MOVS	AC+3,RA+2
	ADD	AC+3,[731341527517]
	ROT	AC+3,-1
	EQVB	AC+3,RA+3	;RANDOM 4
	JRST	@RANDOM

;*RANDOM NUMBER GENERATION
;*OVERFLOW NOT POSSIBLE FOR DIVIDE

RANNOV:	0
	JSR	RANDOM
	MOVM	AC+2
	MOVMM	RA,TEMP#
	CAMN	TEMP
	JRST	RANNOV+1	;DIVISOR=HI DIVIDEND
	CAML	TEMP
	JRST	.+3
	EXCH	AC,AC+2		;DIVISOR SMALLER, EXCHANGE
	EXCH	RA,RA+2		;TO MAKE LARGER
	JUMPE	RA+2,RANNOV+1
	TRNN	AC+2,-1
	JRST	RANNOV+1	;REJECT IF 0 FOR IDIV1
	TLZ	AC+1,400000
	TLNE	AC,400000
	TLO	AC+1,400000
	MOVEM	AC+1,RA+1
	JRST	@RANNOV
;*RANDOM NUMBER GENERATION
;*NORMALIZED RANDOM FOR FLOATING POINT

RANORM:	0
	JSR	RANDOM
	NORM	RA+3,AC+3
	NORM	RA+2,AC+2
	NORM	RA+1,AC+1
	NORM	RA,AC
	JRST	@RANORM

;*SETUP MARGINS FOR ALL OR JUST INST EXECUTE

MGNCLR:	0
	SETZM	MGNFLG#
	SKIPE	USER		;USER MODE ?
	JRST	@MGNCLR		;YES
	MOVE	0,CONSW
	TRNN	MGNTST		;MARGIN INST EXECUTE ONLY ?
	JRST	@MGNCLR		;NO, MARGIN ALL
	SETOM	MGNFLG		;YES, SET CONTROL FLAG
	SKIPE	MARGIN
	DATAO	APR,[IMGNOF,,ISPDOF] ;CLEAR MARGINS
	JRST	@MGNCLR
GG:	MOVEI	[ASCIZ/
INTERNAL PROGRAM PROBLEM, SUGGEST RELOAD, RESTART !
/]
	PNTALF
	ERRHLT
	JRST	BEGIN

;*SIMULATE AND PRINT THE INSTRUCTION

PNTSIM:	0
	SAVEM	RA,1
	SMT	@IT		;SIMULATE AND PRINT
	JRST	@PNTSIM


;*PRINT FAST TEST FAILURE RESULTS

RESULT:	0
	SETOM	PNTSPC		;SET TO SPACE AFTER OCTALS
	MOVEI	[ASCIZ/
FLAGS FROM MACH & SIMULATE   /]
	PNTAL
	MOVE	FLAGS
	PNTHW
RSLTS1:	MOVEI	[ASCIZ/
MACHINE RESULTS IN AC,AC+1,E   /]
	TLNE	CNTL,BYT	;BYTE ERROR
	MOVEI	[ASCIZ/
MACHINE RESULTS IN AC,POINTER,E   /]
	PNTAL
	MOVE	AC
	PNTOCT			;PRINT MACHINE AC
	TLNE	CNTL,BYT
	EXCH	AC+1,AC+2
	MOVE	AC+1
	PNTOCT			;PRINT AC+1
	MOVE	AC+2
	PNTOCT			;PRINT AC+2, (E)
	MOVEI	CRLF
	PNTA
	JRST	@RESULT
;*THE INSTRUCTIONS TESTED

;*INTERGER FIXED POINT
FIXEDI:	IDIV	AC,AC+2
	IMUL	AC,AC+2
	IDIVI	AC,(AC+2)
	IMULI	AC,(AC+2)
	IDIVM	AC,AC+2
	IMULM	AC,AC+2
	IDIVB	AC,AC+2
	IMULB	AC,AC+2

;*MULTIPLY AND DIVIDE
FIXED:	DIV	AC,AC+2
	MUL	AC,AC+2
	DIVI	AC,(AC+2)
	MULI	AC,(AC+2)
	MULM	AC,AC+2
	DIVM	AC,AC+2
	MULB	AC,AC+2
	DIVB	AC,AC+2

;*FLOATING POINT: ADD, SUBTRACT
FPAS:	FAD	AC,AC+2
	FSB	AC,AC+2
	FADR	AC,AC+2
	FSBR	AC,AC+2
	FADM	AC,AC+2
	FADB	AC,AC+2
	FADRM	AC,AC+2
	FADRB	AC,AC+2

;*FLOATING POINT: SUBTRACT, MULTIPLY
FPSM:	FSBM	AC,AC+2
	FSBB	AC,AC+2
	FSBRM	AC,AC+2
	FSBRB	AC,AC+2
	FMPM	AC,AC+2
	FMPB	AC,AC+2
	FMPRM	AC,AC+2
	FMPRB	AC,AC+2

;*FLOATING POINT: MULTIPLY, DIVIDE
FPMD:	FMP	AC,AC+2
	FDV	AC,AC+2
	FMPR	AC,AC+2
	FDVR	AC,AC+2
	FDVM	AC,AC+2
	FDVB	AC,AC+2
	FDVRM	AC,AC+2
	FDVRB	AC,AC+2;*FLOATING POINT: MISCELLANEOUS
MISCFP:	UFA	AC,AC+2
	DFN	AC,AC+2
	UFA	AC,AC+2
	FSC	AC,(AC+2)
	FADRI	AC,(AC+2)
	FSBRI	AC,(AC+2)
	FMPRI	AC,(AC+2)
	FDVRI	AC,(AC+2)

;*FLOATING POINT: LONG MODE
FPL:	FADL	AC,AC+2
	FSBL	AC,AC+2
	FMPL	AC,AC+2
	FDVL	AC,AC+2
	FMPL	AC,AC+2
	FDVL	AC,AC+2
	FADL	AC,AC+2
	FSBL	AC,AC+2

;*BYTES
BYTES:	IBP	AC,AC+2
	ILDB	AC,AC+2
	IDPB	AC,AC+2
	LDB	AC,AC+2
	DPB	AC,AC+2

;*DOUBLE FLOATING POINT: ADD, SUBTRACT
DFPAS:	DFSB	AC,AC+2
	DFAD	AC,AC+2

;*DOUBLE FLOATING POINT: MULTIPLY, DIVIDE
DFPMD:	DFMP	AC,AC+2
	DFDV	AC,AC+2

;*FLOATING POINT: MISCELLANEOUS
FPMISC:	FLTR	AC,AC+2
	FIX	AC,AC+2
	FIXR	AC,AC+2
	FLTR	AC,AC+2

;*TEST STORAGE

SAVAC:	BLOCK	20

DIVAC:	BLOCK	4

MULAC:	BLOCK	4

VMEM:	ENDSLD
RUNTIM:	0
	CONO	APR,CLKDIS!IAPRE1	;DISABLE CLOCK
	JSR	TSTIMA		;PRINT RUN TIME
	CONO	APR,CLKENB!CLKCLR!IAPRE1!IAPRC1	;ENABLE CLOCK
	JRST	@RUNTIM

;*CLOCK SERVICE ROUTINE

ITRCLK:	0
	CONSO	APR,CLK
	JRSTF	@ITRCLK		;NOT CLOCK
	AOS	TICKS		;INC CLOCK COUNTER
	MOVEM	0,CLKAC0#	;SAVE AC'S
	MOVEM	1,CLKAC1#
	JSR	TSTIME		;CHECK AND PRINT TIME
	MOVE	1,RA		;GET RANDOM NUMBER
	ANDI	1,7
	SKIPN	1		;IF 0, MAKE 1
	AOS	1		;SETUP CLOCK ON RANDOM CHANNEL
	CONO	APR,CLKENB!CLKCLR!IAPRE1(1)
	MOVE	0,CLKAC0
	MOVE	1,CLKAC1
	JEN	@ITRCH1		;RETURN

PNTTOT:	0
	SKIPE	USER		;NO TIME IF USER
	JRST	.+4
	TRNE	INHCLK		;NO TIME IF CLOCK INHIBITED
	JRST	.+2
	JSR	RUNTIM		;PRINT RUN TIME
	MOVEI	[ASCIZ/
TOTAL ERRORS = /]
	PNTAL
	MOVE	ERRTLS
	PNTDEC			;PRINT TOTAL ERRORS
	MOVEI	[ASCIZ/
BASE RANDOM NUMBER = /]
	PNTAL
	MOVE	0,RANDBS
	PNTHW			;PRINT RANDOM NUMBER BASE
	MOVEI	CRLF2
	PNTA
	SWITCH
	TLNN	RSTART		;RESTART PROGRAM ?
	JRST	@PNTTOT
	JRST	SFSTRT		;YES, RESTART AS STAND-ALONE
;*TEST RUN TIME SUBROUTINE
;*PRINTS TIME AT HALF HOUR INTERVALS OR WHEN REQUESTED

TSTIME:	0
	MOVE	TICKS		;HAS HALF HOUR PASSED ?
	SUB	TSTIMR
	MOVE	1,HERTZ
	CAIE	1,^D60		;60 HZ. ?
	JRST	TSTIMB		;NO, 50
	CAIGE	^D<60*60*30>
	JRST	@TSTIME		;NOT HALF HOUR YET
TSTIMC:	SETOM	TIMFRC
	JSR	TSTIMA
	JRST	@TSTIME

TSTIMA:	0
	SKIPE	PNTFLG		;INTERRUPTED OUT OF PRINT ROUTINE
	JRST	@TSTIMA		;YES, DO NEXT CLOCK
	MOVEI	[ASCIZ/
RUN TIME = /]
	PNTALF
	MOVE	TICKS		;GET TIME
	SKIPE	TIMFRC#		;REQUESTED TIME, IF SO DON'T
	MOVEM	TSTIMR		;UPDATE HALF HOUR COMPARE
	IDIV	HERTZ		;CONVERT TO SECONDS
	IDIVI	^D<60*60>	;CONVERT TO HOURS
	MOVEM	1,TIMAC1#	;SAVE MIN:SEC
	PNTDCF			;PRINT HOURS
	MOVEI	[ASCIZ/:/]
	PNTAF
	MOVE	0,TIMAC1	;RETURN MIN:SEC
	IDIVI	^D60		;CONVERT TO MINUTES
	MOVEM	1,TIMAC1	;SAVE :SEC
	PNTDCF			;PRINT MINUTES
	MOVEI	[ASCIZ/:/]
	PNTAF
	MOVE	0,TIMAC1	;RETURN :SEC
	PNTDCF			;PRINT SECONDS
	MOVEI	CRLF
	PNTAF
	SETZM	TIMFRC
	JRST	@TSTIMA

TSTIMB:	CAIGE	^D<60*60*25>	;50 HZ HALF HOUR
	JRST	@TSTIME		;NO
	JRST	TSTIMC
 