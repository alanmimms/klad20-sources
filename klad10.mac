;*KLAD10

DECVER=003
MCNVER=000

	XLIST
DEFINE	NAME	(MCNVER,DECVER),<

TITLE	KLAD10 - DECSYSTEM10 KLAD PACK CREATION PROGRAM, VER MCNVER,DECVER>
	LIST
	LALL

NAME	\MCNVER,\DECVER

;*COPYRIGHT 1976,1977,1979
;*DIGITAL EQUIPMENT CORPORATION
;*MARLBORO, MASS. 01752

;*JOHN R. KIRCHOFF

	SEARCH	UUOSYM,MACTEN

	LOC	134		;.JBINT
0,,INTLOC			;ERROR INTERCEPT BLOCK ADDRESS

	LOC	137
MCNVER,,DECVER

	SALL

	NOSYM
SUBTTL	COMMANDS

COMMENT	%

DEV:/DEVICE		;ASSOCIATE "DEV" WITH DEVICE TO BE USED

/CREATE:# (KLADFE.DIR)	;CREATE DIRECTORY FILE

FILE.EXT/ALLOC:#	;ALLOCATE EMPTY -11 FILE

KLADBT.BIN/BOOT		;WRITE SECONDARY BOOTSTRAP
			;"FILE MUST BE "KLADBT.BIN"
KLADBT.BIN/BOOT:ROM406	;WRITE BOOT BLOCK 0 ALSO AT CYL 406

/LIST			;PRINT -11 DIRECTORY
/LIST:SUM		;PRINT DIR SUM ONLY

FILE.EXT/TO11		;TRANSFER FILE TO -11
FILE.EXT=FILE.EXT/TO11

FILE.EXT/REPLACE	;REPLACE EXISTING -11 FILE
FILE.EXT=FILE.EXT/REPLACE

FILE.EXT=FILE.EXT/TO10	;TRANSFER -11 FILE BACK TO -10

FILE.EXT/DELETE		;DELETE -11 FILE

/ASCII			;EXT OVERRIDE SWITCHES
/BINARY

%
SUBTTL	PMAKER UPDATE INFORMATION

;
; UPDATED OCTOBER 25,1976
;
; ACQUIRE PROGRAM FROM SYSTEMS PROGRAMMING
; NAME CHANGED TO KLAD10 TO DISAVOW THE QUILTY
; ------------------------------------------------

; UPDATED FEB 3, 1975
;
; FIX BLOCK # PROBLEM WHEN WRITTEN TO LOW AREA.
;
; UPDATED FEB 12, 1975
;
; ADD FILE STATUS WORD TO TELL MONITOR NOT TO RECOMPUTE CHECK
; SUM FOR FILE WRITTEN FROM -11.
; ALSO ADD TRDSW TO TAKE CARE WRITTEN WORD COUNT FOR ASCII FILE.
;
; UPDATED MARCH 12, 1975
;
; CHANGE COMMAND SCAN MECHANISM AS A RESULT OF BUG-FIXING
; EFFECTED IN SCAN BY P. CONKLIN.
; ADD BUFFER RECLAIM CAPABILITY AFTER PROCESSING EACH COMMAND.
; FIX /ALLOC SUCH THAT FILE GENERATED BY -11 (USING SPACE
; ALLOCATED BY /ALLOC) MAY BE COPIED TO -10 DIRECTORY.
; USE DSKCHR TO INSURE DISK CONTROLLER IS INDEED AN RP04 CTRLER.
;
; UPDATED JANUARY 15,  1976
;
; ADD OUTPUT SPEC FOR /TO11 AND /TO10 SWITCHES.
; ADD LIBRARY MODE OF OPERATION SUCH THAT INPUT DATA CAN BE
; COPIED TO OUTPUT AREA WHICH IS UNDER DIFFERENT PPN'S, AS A
; RESULT OF THIS CHANGE PIP OPERATION IS NO LONGER REQUIRED.
; /BOOT1 SWITCH WILL CAUSE THE SECONDARY BOOTSTRAP TO BE COPIED
; TO BOTH ABSOLUTE BLOCK #0 (CYLINDER #0) AND BLOCKS #0 - 5
; OF MAINTENANCE CYLINDER (CYLINDER #406).
; ADD /LIST SWITCH TO PROVIDE CAPABILITY TO LIST FRONT-END
; DIRECTORY.  NOTE THAT THE FRONT-END DIRECTORY WILL ALSO
; INCLUDE THOSE FILES WHICH ARE LOCATED IN THE CYLINDERS
; FROM 0 TO 399.
; INDEX FILE IS NO LONGER CREATED FOR THE FRONT-END
; DIRECTORY BECAUSE KLDCP CAN NOT USE IT.
;
;1	MAKE RP06 KLADS - PROBLEM IS THAT YOU CAN'T USE MAINT CYL BIT
;	IN SUSET.UUO AND NOT GO TO MAINT CYLS
;	AREAS AFFECTED:OVER,AHEAD,CTLROK,RADDIR,WRTDIR,RADDAT,WRTDAT
;	LABELS ADDED:MNTBIT
;
;2;2	ADD ^C INTERCEPT FOR PROPER TERMINATION
;	LABELS ADDED:INTLOC
SUBTTL	DEFINITIONS

;*AC USAGE

T0=0
T1=1
T2=2
T3=3
T4=4
T5=5
T6=6
T7=7
T10=10
T16=16
A=11
B=12
C=13
D=14
E=15

P=17

;*COMMAND SCANNER AC'S

ACDEV=1		;DEVICE
ACFILE=2	;FILE NAME
ACEXT=3		;FILE EXTENSION
ACDEL=4		;DELIMITER
ACPNTR=5	;GENERATION POINTER
ACPPN=6		;PROJ,PROG #
FR=7		;FLAG REGISTER (LH)

;*I/O CHANNELS

DAT=1	;GENERAL DATA CHANNEL
RC=2	;READ CHANNEL
WC=3	;WRITE CHANNEL
DIR=4	;DIRECTORY CHANNEL
HOM=5	;HOME BLOCK CHANNEL
$CHN=6	;COMMAND FILE CHANNEL

;*OPDEFS

OPDEF	GO	[PUSHJ	P,]
OPDEF	RTN	[POPJ	P,]
OPDEF	PUT	[PUSH	P,]
OPDEF	GET	[POP	P,]
;*DIRECTORY FILE OFFSETS

DIR0==0		;FILE NAME IN -11 RAD50
DIR1==1		;LH=FILE EXT IN -11 RAD50
		;RH=CREATION DATE (16-BIT SMITHSONIAN DATE)
DIR2==2		;PHYSICAL BLOCK NUMBER (PBN)
DIR3==3		;NO. OF WORDS ALLOCATED FOR A FILE
		;LH=MOST SIGNIFICANT 16 BITS
		;RH=LEAST SIGNIFICANT 16 BITS
DIR4==4		;NO. OF WORDS WRITTEN FOR A FILE
		;LH=MOST SIGNIFICANT 16 BITS
		;RH=LEAST SIGINIFICANT 16 BITS
DIR5==5		;LH= -11 LOADING ADDR (IF P.I.C.= 177777)
		;RH= -11 EXECUTION START ADDR (1 = NOT STARTABLE)
DIR6==6		;LH=FILE TYPE AND FILE STATUS
		;RH=CHECKSUM OF ALL DATA WORDS WRITTEN IN FILE
DIR7=7		;RESERVED, MUST BE WRITTEN AS ZERO

;*HOME BLOCK OFFSETS FOR PDP-11 STRUCTURE

WORD61==61	;RESERVED FOR RSX-20F FILES-11
WORD62==62	; "
WORD63==63	; "
WORD64==64	; "

WORD65==65	;"KLAD10" IN PDP-11 RAD50, PACK IDENTIFIER
WORD66==66	;PBN OF DIRECTORY FILE
WORD67==67	;LH=NCB OF DIRECTORY FILE

		;WORD 70 TO WORD 104 RESERVED.
;*SYMBOL DEFINITIONS

ZESIZE==1			;SIZE OF BOOTSTRAP AREA(CYLINDER 0)
BTSIZE==3			;SIZE OF BOOTSTRAP FILE
BLKSIZ==20			;SIZE OF LOOKUP/ENTER BLOCKS

RADIX	10
HMBK01==1+20*0+380*0		;HOME BLOCK #1
				;1=SECTOR NUMBER
				;0=TRACK NUMBER
				;0=CYLINDER NUMBER
HMBK10==10+20*0+380*0		;HOME BLOCK #10
LOGBLK==0+20*0+380*406		;BEGINNING OF MAINTENANCE CYLINDER

RADIX	8
TO10IC==HEAD10+.BFCTR		;-10 INPUT RING BUF BYTE COUNT
TO10IP==HEAD10+.BFPTR		;-10 INPUT RING BUF BYTE PTR
TO10OC==HEDBLK+.BFCTR		;-10 OUTPUT RING BUF BYTE COUNT
TO10OP==HEDBLK+.BFPTR		;-10 OUTPUT RING BUF BYTE PTR
PHYDEV==DATDEV+.DCUPN		;PHY UNIT FOR DATA FILE(0-399)
DSKUPN==DIRDEV+.DCUPN		;PHY UNIT FOR FILE IN 406-409
E10ALC==ENTBLK+.RBALC		;# OF BLOCKS TO ALLOCATE
E10STS==ENTBLK+.RBSTS		;FILE STATUS WORD
E11ALC==LOOK10+.RBALC		;# OF BLOCKS TO ALLOCATE
E11STS==LOOK10+.RBSTS		;FILE STATUS WORD

SU.SOT=200000			;SUSET. OUTPUT BIT
CTYPF=10000			;SET IF ANY CHARS TYPED FOR A COMMAND

COMMENT	%
;EXTENDED ENTER BLOCK

0   .RBCNT	;0,,COUNT OF ENTRIES
1   .RBPPN	;PROJ,PROG #
2   .RBNAM	;SIXBIT FILE NAME
3   .RBEXT	;SIXBIT EXT,,18-20 HI DATE,21-35 ACCESS DATE
4   .RBPRV	;0-8 PROT,9-12 DATA MODE,13-23 CREATE TIME,24-35 CREATE DATE
5   .RBSIZ
6   .RBVER
7   .RBSPL
10  .RBEST	;0 - EST BLOCKS
11  .RBALC	;# OF CONTIGUOUS BLOCKS
12  .RBPOS
13  .RBTF1
14  .RBNCA
15  .RBMTA
16  .RBDEV
17  .RBSTS	;FILE STATUS, UFD,,FILE - BIT 22 RP.ABC
%
SUBTTL	STORAGE AREA DEFINITIONS
;	========================

;*PURE AREA - THIS AREA WILL NEVER BE CLEARED BY THE SYSTEM

HOLD==^D1500		;THRESHOLD COUNT FOR FRONT-END DIRECTORY
BDF==^D16		;NO. OF DIRFIL ENTRIES PER BLOCK
HALF==BDF/2		;NO. OF -10 WORDS PER ENTRY
PRIME==0		;RELATIVE BLOCK OF PRIME RIB FOR USETI
HOMCLP== HOMBUF+20	;ADDRESS POINTER FOR RETRIEVAL PTRS
HOMBPC== HOMBUF+21	;BLOCKS PER CLUSTER

HOMLST:	IOWD ^D128,HOMBUF	;COMMAND LIST FOR HOME BLOCK
	0
DIRLST:	IOWD ^D128,DIRBUF	;COMMAND LIST FOR DIRECTORY BLOCK
	0
DATLST:	IOWD ^D128,DATBUF	;COMMAND LIST FOR DATA BLOCK
	0
H10LST:	IOWD ^D128,HOMB10	;COMMAND LIST FOR HOME BLK #10
	0
BOTLST:	IOWD	^D128,B11STR	;COMMAND LIST FOR BOOT BLOCK
	0

KLFEDD:	BYTE	(2)0 (8)"L" (8)"K" (2)0 (8)"E" (8)"F"
	BYTE	(2)0 (8)"D" (8)"D" (2)0 (8)"S" (8)"C"
	BYTE	(2)0 (8)" " (8)" " (2)0 (8)" " (8)" "
DIAGNO:	BYTE	(2)0 (8)"I" (8)"D" (2)0 (8)"G" (8)"A"
	BYTE	(2)0 (8)"O" (8)"N" (2)0 (8)"T" (8)"S"
	BYTE	(2)0 (8)"C" (8)"I" (2)0 (8)"S" (8)" "

;*ERROR INTERCEPT CONTROL BLOCK

INTLOC:	XWD	3,ENDALL	;SEND ^C PROCESSING TO CLEAN-UP
	XWD	0,ER.ICC	;SET TO INTERCEPT ^C
	BLOCK	2		;REQUIRED BY SYSTEM

; END OF PURE AREA
;*IMPURE AREA - CLEARED ONCE ONLY WHEN PROGRAM STARTS

START:
PDLIST:	BLOCK	40	;PUSH DOWN LIST

FILNAM:	BLOCK	1	;CONTAINS FILE NAME IN -11 RAD50
EXTION:	BLOCK	1	;CONTAIN EXTENSION IN -11 RAD50
FILLOG:	BLOCK	1	;CURRENT LOG ADDR FOR REGULAR FILE
DIRLOG:	BLOCK	1	;CURRENT LOG ADR FOR DIRECTORY FILE
DIRFST:	BLOCK	1	;1ST LOG ADR FOR DIRECTORY FILE
CYLADD:	BLOCK	1	;CYLINDER
TRKADD:	BLOCK	1	;TRACK
SCTADD:	BLOCK	1	;SECTOR
FILNCB:	BLOCK	1	;NCB FOR REGULAR FILE
DIRNCB:	BLOCK	1	;NCB OF DIRECTORY FILE
NWORDS:	BLOCK	1	;# OF 11-WORDS IN FILE
DIRSW:	BLOCK	1	;DIRECTORY SWITCH
DEVSW:	BLOCK	1	;INDICATE DEVICE SPECIFIED

DIRDEV:	BLOCK	16	;DEVICE INFORMATION FOR DIR FILE
DATDEV:	BLOCK	16	;DEVICE INFORMATION FOR DATA FILE
HOMBUF:	BLOCK	60	;BUFFER CONTAINS HOME BLOCK # 1
HOMBF1:	BLOCK	120	;REST OF HOME BLOCK # 1
HOMB10:	BLOCK	60	;BUFFER CONTAINS HOME BLOCK # 10
HOMBF2:	BLOCK	24	;THIS PART USED BY KLAD10
ENDHOM=.-1		;LENGTH
	BLOCK	74	;REST OF HOME BLOCK # 10

B11STR:	BLOCK	^D128*4	;BOOT BUILD AREA

MNTBIT:	BLOCK	1	;MAINT CYL BIT, ON IF RP04

CMDCNT:	BLOCK	1	;COMMAND LINE COUNT

$CCLF:	BLOCK	1
$CMNTF:	BLOCK	1
$LISTF:	BLOCK	1

; END OF IMPURE AREA
;*COMMAND SPECIFICATION AREA - CLEARED EVERYTIME WHEN 
;*A NEW COMMAND IS ENTERED.

O.STR:			;START OF OUTPUT SPEC STORAGE
O.DEV:	BLOCK	1	;DEVICE
O.NAM1:	BLOCK	1	;NAME
O.EXT:	BLOCK	1	;EXT
O.PRT:	BLOCK	1	;PROTECTION
O.PPN:	BLOCK	1	;PROJ,PROG #
O.DATE:	BLOCK	1	;CREATION DATE
O.TIME:	BLOCK	1	;CREATION TIME
O.VER:	BLOCK	1	;VERSION NUMBER

I.STR:			;START OF INPUT SPEC STORAGE
I.DEV:	BLOCK	1	;DEVICE
I.NAM1:	BLOCK	1	;NAME
I.EXT:	BLOCK	1	;EXT
I.PPN:	BLOCK	1	;PROJ,PROG #

GETBUF:	BLOCK	^D128	;A DEDICATED BUFFER

DATBUF:	BLOCK	^D128	;BUFFER CONTAINING REGULAR DATA BLOCK
DATEND=.-1

DIRBUF:	BLOCK	^D128	;BUFFER CONTAINING DIRECTORY BLOCK
ENDBLK=.-1

OPEN10:	BLOCK	3	;-10 OPEN BLOCK
LOOK10:	BLOCK	BLKSIZ	 ;-10 LOOKUP BLOCK
HEAD10:	BLOCK	3	;-10 BUFFER HEADER
OPNBLK:	BLOCK	3	;-10 OUTPUT OPEN BLOCK
ENTBLK:	BLOCK	BLKSIZ	;-10 ENTER BLOCK
HEDBLK:	BLOCK	3	;-10 OUTPUT BUFFER HEADER

CMDBUF:	BLOCK	^D30	;COMMAND LINE BUFFER
;*PROGRAM CONTROL VARIABLES

AREASW:	BLOCK	1	;INDICATE /AREA SW IS USED
DONESW:	BLOCK	1	;MEANS WHOLE FILE IS READ FROM -11
EOFSW:	BLOCK	1	;MEANS EOF IS DETECTED IN -10 FILE
EOLSW:	BLOCK	1	;END OF COMMAND LINE
EXTSW:	BLOCK	1	;ASCII CONVERSION SW
ROM406:	BLOCK	1	;WRITE BOOT BLOCK 0 ALSO AT CYL 406
ALOSW:	BLOCK	1	;ALLOCATION SW
HADSW:	BLOCK	1	;HAD BLOCK SW
TRDSW:	BLOCK	1	;INDICATE THIS IS THIRD CHAR.
FSTSW:	BLOCK	1	;INDICATE 1ST CHAR OR 36-BIT
PRNTSW:	BLOCK	1	;TO CONTROL CR,LF, WHEN PRINTING -11 DIR
RADIX:	BLOCK	1	;USED BY /LIST
DIRSUM:	BLOCK	1	;GIVE DIR SUM ONLY
JBFFWC:	BLOCK	1	;SAVE BUF RING ADR ON WC CHL
JBFFRC:	BLOCK	1	;SAVE BUF RING ADR ON RC CHL

S.SWH:			;START OF SWITCHES
S.ALO:	BLOCK	1	;FILESPEC/ALLOC:N
S.ELN:	BLOCK	1	;FILESPEC/TO11
S.TEN:	BLOCK	1	;FILESPEC/TO10
S.REP:	BLOCK	1	;FILESPEC/REPLACE
S.DEL:	BLOCK	1	;FILESPEC/DELETE
S.BIN:	BLOCK	1	;FILESPEC/BINARY
S.ASC:	BLOCK	1	;FILESPEC/ASCII
S.ARE:	BLOCK	1	;FILESPEC/AREA:HI OR LOW
S.MOD:	BLOCK	1	;/MODE:DIAG OR SYSTEM
S.BT1:	BLOCK	1	;FILESPEC/BOOT - SECONDARY BOOTSTRAP
S.DEV:	BLOCK	1	;/DEVICE:FILE STRUCTURE
S.CRE:	BLOCK	1	;/CREATE:N
S.LST:	BLOCK	1	;/LIST -11 DIRECTORY
ALL=.-1

; END OF COMMAND SPECIFICATION AREA
SUBTTL	INITIALIZATION AND MAIN COMMAND PROCESS

KLAD10:	RESET
	SETZM	START		;ZERO IMPURE/CMD AREA
	MOVE	T1,[START,,START+1]
	BLT	T1,ALL

	MOVE	P,[-40,,PDLIST] ;INIT PUSH LIST
	MOVSI	T1,100000	;SET MAINT CYL BIT FOR RP04 DEFAULT
	MOVEM	T1,MNTBIT

	SETZM	$CCLF#		;CLEAR INDIRECT COMMAND FLAG
	OUTSTR	[ASCIZ	"
DECSYSTEM10 RP04/RP06 KLAD PACK CREATION PROGRAM, VER 0.2

COMMAND"]

;*MAIN COMMAND SCANNING LOOP

SCAN:	SETZM	O.STR		;CLEAR COMMAND AREA
	MOVE	T1,[O.STR,,O.STR+1]
	BLT	T1,ALL

	AOS	CMDCNT		;COUNT COMMANDS
	MOVE	T1,[POINT 7,CMDBUF]
	MOVEM	T1,CMDPTR#	;SETUP COMMAND STORAGE POINTER
	SKIPE	$CCLF		;PROCESSING INDIRECT FILE ?
	JRST	.+4		;YES
	TTCALL	13,0		;CLEAR ^O
	JFCL
	OUTSTR	[ASCIZ/
*/]				;PROMPT OPERATOR
	SETZM	$CMNTF#

	GO	NAME1		;GET FIRST HALF OF COMMAND
	TLNE	FR,CTYPF	;ANY COMMAND TYPED AT ALL ?
	JRST	.+4		;YES
	CAIE	C,32		;^Z, COMPLETE & EXIT
	JRST	SCAN		;NO
	JRST	ENDALL

	SKIPE	INDIRECT	;INDIRECT SET ?
	JRST	$CCL		;YES, GO SETUP COMMAND FILE

	CAIE	C,"="
	CAIN	C,"_"
	JRST	SCAN2P		;DO 2 PART COMMANDS

	CAIG	C,15
	JRST	SCAN1P
	CAIN	C,33
	JRST	SCAN1P		;DO 1 PART COMMANDS

	JRST	KEYERR		;COMMAND ERROR
;*PROCESS TWO PART COMMANDS

;*SETUP OUTPUT FILE

SCAN2P:	SKIPN	ACDEV		;ASSUME "DEV" IF NOT SPECIFIED
	MOVSI	ACDEV,'DEV'
	MOVEM	ACDEV,O.DEV

	MOVEM	ACFILE,O.NAM1	;SETUP FILE NAME

	MOVEM	ACEXT,O.EXT	;SETUP FILE EXTENSION

	MOVEM	ACPPN,O.PPN	;SETUP PROJ,PROG #

;*SETUP INPUT FILE

	GO	NAME1		;GET INPUT DESCRIPTOR

	TLNN	FR,CTYPF	;ANY TYPED ?
	JRST	FLSPER		;NO, ERROR

SCAN3P:	SKIPN	ACDEV		;ASSUME "DEV" IF NOT SPECIFIED
	MOVSI	ACDEV,'DEV'
	MOVEM	ACDEV,I.DEV

	MOVEM	ACFILE,I.NAM1	;SETUP FILE NAME

	MOVEM	ACEXT,I.EXT	;SETUP FILE EXTENSION

	MOVEM	ACPPN,I.PPN	;SETUP PROJ,PROG #

;*DETERMINE PROCESS

	SKIPE	S.ELN		;/TO11 SWITCH ?
	JRST	TOELVN		;YES, TRANSFER FILE TO -11

	SKIPE	S.REP		;/REPLACE SWITCH ?
	JRST	TOELVN		;YES, REPLACE -11 FILE

	SKIPE	S.TEN		;/TO10 SWITCH ?
	JRST	TOTEN		;YES, RETURN FILE TO -10

	JRST	KEYERR		;COMMAND ERROR
;*PROCESS ONE PART COMMANDS

SCAN1P:	SKIPE	S.ALO		;/ALLOCATE SWITCH ?
	JRST	ALO		;YES, ALLOC -11 EMPTY FILE

	SKIPE	S.ELN		;/TO11 SWITCH ?
	JRST	TOELV1		;YES, TRANSFER FILE TO -11

	SKIPE	S.REP		;/REPLACE SWITCH ?
	JRST	TOELV1		;YES, REPLACE -11 FILE

	SKIPE	S.DEL		;/DELETE SWITCH ?
	JRST	DELETE		;YES, DELETE -11 FILE

	SKIPE	S.LST		;/LIST SWITCH ?
	JRST	LSTDIR		;YES, LIST -11 DIRECTORY

	SKIPE	S.CRE		;/CREATE SWITCH ?
	JRST	DIR11		;YES, CREATE -11 DIRECTORY

	SKIPE	S.DEV		;/DEVICE SWITCH ?
	JRST	DEVSTR		;YES, ASSOCIATE "DEV" WITH STRUCTURE

	SKIPE	S.BT1		;/BOOT1 SWITCH ?
	JRST	BOOT1		;YES, WRITE SECONDARY BOOTSTRAP

	JRST	KEYERR		;COMMAND ERROR

TOELV1:	SKIPN	ACDEV		;ASSUME "DEV" IF NOT SPECIFIED
	MOVSI	ACDEV,'DEV'
	MOVEM	ACDEV,O.DEV

	MOVEM	ACFILE,O.NAM1	;SETUP FILE NAME

	MOVEM	ACEXT,O.EXT	;SETUP FILE EXTENSION

	SETZM	O.PPN

	JRST	SCAN3P		;/TO11, INPUT & OUTPUT FILE SAME NAME
;*INDIRECT COMMAND FILE PROCESS

$CCL:	SKIPE	$CCLF		;ALREADY DOING INDIRECT ?
	JRST	CTLSER		;YES, COMMAND ERROR

	SETOM	$CCLF		;SET COMMAND FILE PROCESS FLAG

	SKIPE	S.LST		;/LIST SWITCH ?
	SETOM	$LISTF		;YES, LIST COMMAND FILE AS PROCESSED

	SKIPN	ACDEV		;ANY DEVICE SPECIFIED ?
	MOVSI	ACDEV,'DEV'	;NO, ASSUME "DEV"
	MOVEM	ACDEV,CCLBLK+1

	MOVEM	ACFILE,CCLDIR	;SETUP FILE NAME

	SKIPN	ACEXT		;ANY EXTENSION SPECIFIED ?
	MOVSI	ACEXT,'CMD'	;NO, ASSUME "CMD"
	MOVEM	ACEXT,CCLDIR+1

	MOVEM	ACPPN,CCLDIR+3	;SETUP PPN

	MOVEI	$IBF
	MOVEM	CCLBLK+2

	OPEN	$CHN,CCLBLK	;OPEN COMMAND CHANNEL
	 JRST	$ERR

	INBUF	$CHN,1		;ONE BUFFER

	LOOKUP	$CHN,CCLDIR	;FIND COMMAND FILE
	 JRST	$ERR		;NOT FOUND

	MOVE	.JBFF		;SAVE FIRST FREE FOR RECLAIM
	MOVEM	$SJBFF#

	JRST	SCAN
$CCLIN:	SOSLE	$IBF+2		;ANY CHARS AVAILABLE ?
	JRST	$CCLI1		;YES

	IN	$CHN,		;NO, INPUT A BUFFER
	 JRST	$CCLI1		;OK

	STATZ	$CHN,740000	;NO, CHECK STATUS
	 JRST	$ERR		;ERROR
	 JRST	ENDALL		;END-OF-FILE

$CCLI1:	ILDB	C,$IBF+1	;GET CHAR

	SKIPE	$LISTF#		;LISTING COMMAND FILE ?
	OUTCHR	C		;YES

	CAIN	C,12		;LF, CLEAR COMMENT FLAG
	SETZM	$CMNTF
	CAIN	C,14		;F/F, CLEAR COMMENT FLAG
	SETZM	$CMNTF

	CAIN	C,";"		;SEMICOLON, SET COMMENT FLAG
	SETOM	$CMNTF

	SKIPE	$CMNTF		;PROCESSING COMMENT ?
	JRST	$CCLIN		;YES

	JRST	TTYIN1		;NO, RETURN TO CHAR PROCESS

$ERR:	OUTSTR	[ASCIZ/
COMMAND FILE ERROR/]
	EXIT

CTLSER:	OUTSTR	[ASCIZ/
?COMMAND CHARACTER ERROR
/]
	JRST	WHTFIL		;PRINT ERRONEOUS COMMAND

CCLBLK:	BLOCK	3
$IBF:	BLOCK	3
CCLDIR:	BLOCK	4
;*COMMAND PROCESS

NAME1:	SETZB	ACDEV,ACDEL	;CLEAR NAME RETURN REGISTERS
	SETZB	ACFILE,ACEXT
	SETZB	ACPPN,INDIRECT#	;INIT PPN TO [0,0]
	TLZ	FR,CTYPF	;CLEAR COMMAND TYPED FLAG

NAME3:	MOVSI	ACPNTR,(POINT 6,0) ;SET POINTER
	SETZ			;SIXBIT NAME STORED IN AC0

GETIOC:	GO	TTYIN		;GET INPUT CHAR

	CAIE	C,"@"
	JRST	.+3
	SETOM	INDIRECT	;INDIRECT COMMAND FILE
	JRST	GETIOC

GETIC1:	CAIE	C,32		;EOF TERMINATES COMMAND
	CAIG	C,15
	JRST	TERM		;OR CR,LF,FF,VT
	CAIN	C,33
	JRST	TERM		;OR ALTMODE

	CAIE	C,"="		;EQUALS OR BACKARROW
	CAIN	C,"_"
	JRST	TERM		;FINISHES FIRST PART OF COMMAND

	TLO	FR,CTYPF	;SET COMMAND TYPED FLAG

	CAIN	C,"/"		;IS THERE A SWITCH ?
	JRST	GETSW		;YES

	CAIN	C,":"
	JRST	DEVICE		;DEVICE SPECIFIED

	CAIN	C,"."
	JRST	NAME2		;FILE NAME SPECIFIED

	CAIN	C,"["
	JRST	GETPPN		;PROJ,PROG # START
	CAIL	C,"A"		;ALL OTHER CHARS SHOULD BE ALPHANUMERIC
	CAILE	C,"Z"		;FOR FILE NAMES
	JRST	[CAIL	C,"0"
		 CAILE	C,"9"
		 JRST	CTLSER	;NOT ALPHANUMERIC, COMMAND ERROR
		 JRST	.+1]
	TRC	C,40		;CONVERT TO SIXBIT
	TLNE	ACPNTR,770000
	IDPB	C,ACPNTR	;STORE UP TO SIX BYTES
	JRST	GETIOC

DEVICE:	SKIPA	ACDEV,0		;DEVICE NAME

NAME2:	MOVE	ACFILE,0	;FILE NAME
	MOVE	ACDEL,C		;SET DELIMITER
	JRST	NAME3		;GET NEXT SYMBOL

TERM:	JUMPE	ACDEL,.+3	;IF NO PREVIOUS DELIMITER
	CAIE	ACDEL,":"	;OR IF PREVIOUS DELIMTER ":"
	JRST	TERM1
	MOVE	ACFILE,0	;SET FILE NAME

TERM1:	CAIE	ACDEL,"."	;IF PERIOD
	RTN
	HLLZ	ACEXT,0		;SET EXTENSION
	RTN
GETPPN:	GO	GETOCT		;BUILD THE PROJ,PROG #
	CAIE	C,","
	JRST	CTLSER		;ERROR, COMMA SEPARATES [P,P]

	HRLZ	ACPPN,A		;PUT PROJ # IN LEFT HALF

	GO	GETOCT
	CAIE	C,"]"
	JRST	CTLSER		;ERROR, BRACKET ENDS [P,P]
	HRR	ACPPN,A		;PUT PROG # IN RIGHT HALF

	JRST	GETIOC

GETOCT:	MOVEI	A,0		;BUILD AN OCTAL NUMBER
GETOC1:	GO	TTYIN
GETOC2:	CAIL	C,"0"
	CAILE	C,"7"
	RTN			;RETURN ON NON-OCTAL CHAR

	LSH	A,3
	ADDI	A,-"0"(C)
	JRST	GETOC1

GETDEC:	MOVEI	0,0		;BUILD A DECIMAL NUMBER
GETDE1:	GO	TTYIN
GETDE2:	CAIL	C,"0"
	CAILE	C,"9"
	RTN			;RETURN ON NON-DECIMAL CHAR

	IMULI	0,^D10
	ADDI	0,-"0"(C)
	JRST	GETDE1

GETSIX:	MOVSI	ACPNTR,(POINT 6,0)
	SETZB	0,A
GETSI1:	GO	TTYIN
GETSI2:	CAIL	C,"A"
	CAILE	C,"Z"
	JRST	[CAIL	C,"0"
		 CAILE	C,"9"
		 JRST	GETSI3
		 JRST	.+1]
	TRC	C,40
	TLNE	ACPNTR,770000
	IDPB	C,ACPNTR
	JRST	GETSI1
GETSI3:	MOVE	A,0
	RTN
GETSW:	PUT	0
	PUT	A
	GO	GETSIX		;GET SIXBIT SWITCH NAME
	JUMPE	0,CTLSER	;ERROR IF NO WORD IN 0
	MOVEM	C,SAVSWC#	;SAVE TERMINATOR

	MOVSI	A,-SWTLEN
	MOVEI	C,77		;SETUP MASK
	TDNE	0,C		;SKIP IF ALL MASKED BITS ARE ZERO
	JRST	.+4		;NO, COMPLETE MASK
	LSH	C,6		;SHIFT MASK BITS LEFT
	TRO	C,77		;SET FIRST SIX AGAIN
	JRST	.-4
	LSH	C,-6		;SHIFT OUT LAST 6 BITS
	SETCAM	C,COMPRS#	;COMPLIMENT MASK BITS
	SETZ	D,		;CLEAR MATCH COUNTER

	MOVE	C,SWTBL(A)	;GET A WORD FROM TABLE
	AND	C,COMPRS	;STRIP UNTYPED POSITIONS
	CAMN	0,C		;SEARCH SWITCH TABLE
	GO	SETSW		;SET CONTROL SWITCH
	AOBJN	A,.-4
	CAIE	D,1		;ONLY ONE MATCH ?
	JRST	KEYERR		;OR NOT FOUND, COMMAND ERROR

	MOVE	C,SAVSWC
	CAIE	C,":"		;SWITCH END WITH COLON ?
	JRST	GETSW1		;NO

	SKIPE	S.MOD		;/MODE: ?
	JRST	GETMOD		;YES
	SKIPE	S.ARE		;/AREA: ?
	JRST	GETARE		;YES
	SKIPE	S.DEV		;/DEV: ?
	JRST	GETDEV		;YES
	SKIPE	S.BT1		;/BOOT: ?
	JRST	GETBT1		;YES
	SKIPE	S.LST		;/LIST: ?
	JRST	GETLST		;YES

	GO	GETDEC		;NO, MUST BE DECIMAL ARGUMENT
	MOVEM	0,S.SWH(E)	;SAVE AS SWITCH ARGUMENT

GETSW1:	GET	A
	GET	0
	JRST	GETIOC+1

SETSW:	SETOM	S.SWH(A)	;SET CONTROL SWITCH FLAG
	MOVE	E,A
	AOS	D		;COUNT MATCHES
	RTN
;*COMMAND SWITCH TABLE

SWTBL:	SIXBIT/ALLOC/
	SIXBIT/TO11/
	SIXBIT/TO10/
	SIXBIT/REPLAC/
	SIXBIT/DELETE/
	SIXBIT/BINARY/
	SIXBIT/ASCII/
	SIXBIT/AREA/
	SIXBIT/MODE/
	SIXBIT/BOOT/
	SIXBIT/DEVICE/
	SIXBIT/CREATE/
	SIXBIT/LIST/
SWTLEN=.-SWTBL

GETMOD:	SETZM	S.MOD
	GO	GETSIX		;/MODE:
	CAMN	0,[SIXBIT/DIAG/]
	JRST	GETSW1
	CAMN	0,[SIXBIT/SYSTEM/]
	JRST	GETSW1
	JRST	KEYERR		;NEITHER, ERROR

GETARE:	SETZM	S.ARE
	GO	GETSIX		;/AREA:
	CAMN	0,[SIXBIT/HIGH/]
	JRST	GETSW1
	CAMN	0,[SIXBIT/LOW/]
	JRST	GETSW1
	JRST	KEYERR		;NEITHER, ERROR

GETDEV:	GO	GETSIX		;/DEV:
	JUMPE	0,KEYERR	;NO DEVICE GIVEN, ERROR
	MOVEM	0,S.DEV		;SAVE SPECIFIED DEVICE
	JRST	GETSW1

GETBT1:	GO	GETSIX		;/BOOT:
	CAME	0,[SIXBIT/ROM406/]
	JRST	KEYERR
	SETOM	ROM406		;"ROM406" - WRITE BOOT 0 ALSO AT CYL 406
	JRST	GETSW1

GETLST:	GO	GETSIX		;/LIST:
	CAME	0,[SIXBIT/SUM/]
	JRST	KEYERR
	SETOM	DIRSUM		;"SUM" - GIVE DIRECTORY SUM ONLY
	JRST	GETSW1
;*COMMAND CHARACTER INPUT ROUTINE

TTYIN:	SKIPE	$CCLF		;PROCESSING COMMAND FILE ?
	JRST	$CCLIN		;YES

	INCHWL	C		;GET A CHAR

TTYIN1:	IDPB	C,CMDPTR	;PUT CHAR IN COMMAND BUFFER
	JUMPE	C,TTYIN		;FLUSH NULLS
	CAIN	C,15
	JRST	TTYIN		;FLUSH CR

	CAIE	C,176		;CHANGE ALL ALTMODES TO NEW
	CAIN	C,175
	MOVEI	C,33

	CAIL	C,"A"+40
	CAILE	C,"Z"+40
	JRST	.+2
	TRZ	C,40		;CHANGE LOWER TO UPPER CASE
	CAIE	C," "
	CAIN	C,"	"
	JRST	TTYIN		;FLUSH SPACES AND TABS

	CAIE	C,32		;IF LINE TEMINATOR
	CAIG	C,15
	SETOM	EOLSW		;SET END OF LINE SWITCH
	CAIN	C,33
	SETOM	EOLSW

	RTN
SUBTTL	ALLOCATE -11 FILE COMMAND PROCESS

ALO:	SKIPN	DIRSW		;DOES DIRECTORY EXIST ?
	JRST	DIRERR		;NO

	SKIPG	S.ALO		;ALLOCATION = 0 ?
	JRST	KEYERR		;YES, ERROR

	SKIPN	ACDEV		;ASSUME "DEV" IF NOT SPECIFIED
	MOVSI	ACDEV,'DEV'
	MOVEM	ACDEV,O.DEV

	MOVEM	ACFILE,O.NAM1	;SETUP FILE NAME

	MOVEM	ACEXT,O.EXT	;SETUP FILE EXTENSION

	MOVEM	ACPPN,O.PPN	;SETUP PROJ,PROG #

	GO	OPNALO		;OPEN FILE, ALLOCATE N BLOCKS
	 JRST	ENTERR

	CLOSE	WC,CL.DLL	;CLOSE FILE, KEEP ALL BLOCKS

	GO	GETBK1		;GET LOGICAL BLOCK # OF FILE

	GO	LOGPHY		;CONVERT LOGICAL BLK # TO TRK,SCT,CYL

	GO	SRHDIR		;FIND 1ST AVAILABLE DIR BLOCK
	 JRST	DIRFUL		;DIRECTORY FULL

	GO	DIRETY		;CREATE A DIRECTORY ENTRY

	DATE	T1,		;GET TODAY'S DATE
	MOVEM	T1,O.DATE
	GO	ALNSET		;PUT IN FILE NAME,EXT,DATE

	MOVE	A,S.ALO		;GET # OF BLOCKS
	IMULI	A,^D256		;CONVERT TO -11 WORDS
	DPB	A,[POINT 16,DIR3(T7),35]
	LSH	A,-^D16
	DPB	A,[POINT 16,DIR3(T7),17]

	JRST	SCAN		;DONE
;*DISK OPEN/ENTER ALLOCATION ROUTINE

OPNALO:	MOVE	T1,O.DEV	;SETUP DEVICE
	MOVEM	T1,OPEN10+1

	OPEN	WC,OPEN10	;OPEN WRITE CHANNEL
	 RTN			;ERROR

	MOVE	T1,O.NAM1	;SETUP FILE NAME
	MOVEM	T1,LOOK10+.RBNAM

	MOVE	T1,O.EXT	;SETUP FILE EXT
	MOVEM	T1,LOOK10+.RBEXT

	MOVE	T1,O.PPN	;SETUP PROJ,PROG #
	SKIPN	T1
	MOVE	T1,[6,,11]	;DEFAULT PPN IS 6,11
	MOVEM	T1,LOOK10+.RBPPN

	MOVEI	T1,577		;SET PROTECTION TO 577
	DPB	T1,[POINT 9,LOOK10+.RBPRV,8]

	MOVEI	T1,17		;SETUP EXTENDED ENTER
	MOVEM	T1,LOOK10

	MOVEI	T1,RP.ABC!RP.NFS ;BIT 22 FOR BAD CHECKSUM
	MOVEM	T1,E11STS

	SKIPL	T1,S.ALO
	MOVEM	T1,E11ALC	;SET BLOCKS ALLOCATED

	ENTER	WC,LOOK10	;ENTER FILE
	 RTN

	JRST	CPOPJ1		;GOOD RETURN
SUBTTL	TRANSFER FILE TO -11 COMMAND PROCESS ROUTINE

TOELVN:	SKIPN	DIRSW		;DOES DIRECTORY EXIST ?
	JRST	DIRERR		;NO, ERROR

	SKIPE	S.TEN		;/TO10 SW SHOULD NOT BE SET
	JRST	ILLSW
	SKIPN	I.NAM1		;INPUT FILE SPECIFIED ?
	JRST	FLSPER		;NO

	SKIPN	O.NAM1		;OUTPUT FILE SPECIFIED ?
	JRST	FLSPER		;NO

	SKIPN	S.REP		;/REPLACE SWITCH ?
	JRST	.+5		;NO
	GO	VINPUT		;YES, DOES FILE EXIST IN F-E DIR ?
	SKIPN	ALOSW
	JRST	NOFL11		;NO, ERROR
	SETZM	(T7)		;YES, CLEAR CURRENT ENTRY

	GO	SEARCH		;SEARCH EXT FOR "BIN" OR "ASCII"

	GO	OPNTEN		;OPEN INPUT FILE
	JRST	LUKERR		;FILE NOT FOUND

	MOVE	T1,LOOK10+.RBVER ;USE INPUT VERSION AS OUTPUT VERSION
	MOVEM	T1,O.VER

	MOVEI	T1,577		;SET PROTECTION TO 577
	MOVEM	T1,O.PRT

	LDB	T1,[POINT 11,LOOK10+.RBPRV,23]
	MOVEM	T1,O.TIME	;USE INPUT TIME AND DATE AS OUTPUT

	LDB	T1,[POINT 3,LOOK10+.RBEXT,20]
	DPB	T1,[POINT 3,O.DATE,23]
	LDB	T1,[POINT 12,LOOK10+.RBPRV,35]
	DPB	T1,[POINT 12,O.DATE,35]

	MOVE	T1,LOOK10+.RBSIZ ;GET FILE SIZE IN WORDS

	SKIPN	EXTSW		;ASCII FILE ?
	JRST	.+5		;NO, INPUT & OUTPUT SAME SIZE
				;ASCII, -11 FILE NEEDS MORE ROOM
	IMULI	T1,5		;5=# OF ASCII CHAR IN -10
	IDIVI	T1,4		;4=# OF ASCII CHAR IN -11
	SKIPE	T2		;SKIP IF REMAINDER = 0
	ADDI	T1,1		;ROUND UP OTHERWISE
	IDIVI	T1,^D128	;DIVIDE BY BLOCK SIZE
	SKIPE	T2		;REMAINDER ZERO ?
	ADDI	T1,1		;NO, ROUND UP
	MOVEM	T1,FILNCB	;SAVE AS FILE # OF CONSEC BLKS
	MOVEM	T1,S.ALO	;ALSO AS BLKS TO BE ALLOCATED

	GO	ETER10		;ENTER FILE NAME
	 JRST	ENTERR		;ERROR

	SETZM	EOFSW		;INIT EOF SW
	SETZM	HADSW		;INIT HAD BLOCK SW
	SETZM	NWORDS		;CLEAR # OF WORDS WRITTEN
	SETOM	TRDSW		;SET THIRD CHAR SW
	SETOM	FSTSW		;SET 1ST CHAR SW

	MOVE	A,[POINT 8,T2,17]
	MOVE	B,[POINT 8,T2,9]
	MOVE	C,[POINT 8,T2,35]
	MOVE	D,[POINT 8,T2,27]

LOOP1:	GO	GET10		;GET A CHARACTER FROM -10

	SKIPGE	EOFSW		;HIT EOF?
	SETZM	FSTSW		;YES
	SKIPL	EXTSW		;NO CONVERSION IF EXTSW=0
	JRST	PUTWRD		;NO CONVERSION

;*HERE IF ASCII CONVERSION REQUIRED
;*INPUT ORDER - A,B,C,D    OUTPUT ORDER - B,A,D,C

	SETZ	T2,
	DPB	T3,A		;PUT CHAR # 1 INTO WORD
	GO	GET10		;GO GET SECOND CHARACTER
	SKIPGE	EOFSW		;HIT EOF?
	SETZM	TRDSW		;YES, RESET 3RD CHAR SW
	DPB	T3,B		;PUT CHAR # 2 INTO WORD
	GO	GET10		;GO GET CHAR # 3
	DPB	T3,C		;PUT CHAR # 3 INTO WORD
	GO	GET10		;GO GET FOURTH CHARACTER
	DPB	T3,D		;PUT CHAR # 4 IN WORD
	MOVE	T3,T2		;COPY FINISHED WORD
;*HERE TO OUTPUT A CHARACTER

PUTWRD:	GO	PUT10		;PUT WORD INTO BUFFER

	MOVEI	T1,1		;GET # OF -11 WORDS
	SKIPE	TRDSW		;GOT THIRD CHAR?
	MOVEI	T1,2		;YES, SO TWO -11 WD

	SKIPE	FSTSW		;EOF AT 1ST CHAR?
	ADDM	T1,NWORDS	;ADD TO TOTAL WORD COUNT
	SKIPL	EOFSW		;EOF DETECTED?
	JRST	LOOP1		;NO, GO GET NEXT CHAR

	JRST	EOF		;YES, GO CLOSE FILE

;*GET A CHARACTER FROM -10 FILE

GET10:	SKIPE	EOFSW		;HAVE WE HIT EOF YET ?
	JRST	GET10Z		;YES, CLEAR CHARACTER

CHKCNT:	SOSGE	TO10IC		;BYTE COUNT=0?
	JRST	IN10		;YES

	ILDB	T3,TO10IP	;GET BUFFER PTR
	RTN			;RETURN, BUFFER FULL

GET10Z:	SETZ	T3,
	RTN

IN10:	IN	RC,
	JRST	GET10

;*END OF INPUT FILE

COMEND:	GETSTS	RC,C		;GET ERROR STATUS
	TRNE	C,74B23		;SEE IF ANY ERRORS
	  JRST	RADERR		;YES, ISSUE READ ERROR

	TRNN	C,1B22		;SEE IF END OF FILE
	  HALT .		;SHOULD NEVER HAPPEN

	SETOM	EOFSW		;INDICATE EOF IS DETECTED
	SETZM	T3		;ZERO THE CHARACTER
	RTN			;RETURN
;*COMPLETE OUTPUT FILE

EOF:	CLOSE	RC,		;CLOSE RC CHANNEL
	RELEAS	RC,
	MOVE	T1,JBFFRC
	MOVEM	T1,.JBFF	;RECLAIM BUF SPACE

	CLOSE	WC,CL.DLL	;CLOSE WC CHANNEL, KEEP ALL BLOCKS
	RELEAS	WC,

	GO	GETBK2		;GET 1ST BLOCK # FROM -10
	MOVEM	T1,FILLOG	;SAVE IT

UPDATE:	GO	SRHDIR			;FIND 1ST AVILABLE ENTRY
	  JRST	DIRFUL			;DIR FILE FULL

	MOVE	T1,FILLOG		;GET 1ST BLK NO. FOR THIS FILE
	GO	LOGPHY			;CONVERT IT INTO PHY ADDR

	GO	DIRETY			;ENTER IT INTO DIR FILE

	GO	ALNSET			;USE OUTPUT FILE

	MOVE	T2,FILNCB		;GET BLOCK COUNT
	IMULI	T2,^D256		;CONVERT IT INTO -11 WORDS
	DPB	T2,[POINT 16,DIR3(T7),35]
	LSH	T2,-<^D16>		;GET HIGH-ORDER PART
	DPB	T2,[POINT 16,DIR3(T7),17] ;SAVE IT AS WORD ALLOCATED

WTDIR4:	MOVE	T2,NWORDS		;GET # OF WORDS WRITTEN
	DPB	T2,[POINT 16,DIR4(T7),35]
	LSH	T2,-<^D16>		;GET HIGH-ORDER PART
	DPB	T2,[POINT 16,DIR4(T7),17] ;SAVE IT AS WORD WRITTEN

	JRST	SCAN			;DONE

PUT10:	SOSG	TO10OC			;DECREMENT BYTE COUNT
	JRST	PUTBUF			;NO MORE ROOM

PUTNXT:	IDPB	T3,TO10OP		;PUT WORD IN BUFFER
	RTN

PUTBUF:	OUT	WC,			;EMPTY BUFFER
	JRST	PUTNXT
	JRST	WRTERR
;*OPEN DEVICE/LOOKUP ON FILE FROM -10

OPNTEN:	MOVEI	T1,HEAD10	;SETUP -10 BUFFER HEADER
	HRRZM	T1,OPEN10+2

	MOVE	T1,I.DEV	;SETUP DEVICE
	MOVEM	T1,OPEN10+1

	MOVEI	T1,.IOASC	;ASCII MODE
	SKIPN	EXTSW		;DO CONVERSION ?
	MOVEI	T1,.IOBIN	;NO, GET BINARY MODE
	MOVEM	T1,OPEN10	;PUT MODE IN OPEN BLOCK

	OPEN	RC,OPEN10	;OPEN READ CHANNEL
	  RTN			;ERROR, RETURN

	MOVE	T1,.JBFF	;GET RING BUF ADR
	MOVEM	T1,JBFFRC	;SAVE IT

	INBUF	RC,^D20		;SETUP 20 INPUT BUFFERS

	MOVE	T1,I.NAM1	;SETUP FILE NAME
	MOVEM	T1,LOOK10+.RBNAM

	MOVE	T1,I.EXT	;SETUP FILE EXT
	MOVEM	T1,LOOK10+.RBEXT

	MOVE	T1,I.PPN	;SETUP PROJ,PROG #
	MOVEM	T1,LOOK10+.RBPPN

	MOVEI	T1,17
	MOVEM	T1,LOOK10

	LOOKUP	RC,LOOK10	;LOOKUP ON FILE FROM -10
	  JRST	NOFL10		;NO FILE FOUND IN -10 DIR

	JRST	CPOPJ1		;GOOD RETURN
;*ENTER FILE ON CHANNEL WC

ETER10:	MOVSI	T1,HEDBLK	;SETUP BUFFER HEADER
	MOVEM	T1,OPNBLK+2
	MOVE	T1,O.DEV	;SETUP DEVICE
	MOVEM	T1,OPNBLK+1
	MOVEI	T1,.IOBIN	;BINARY MODE
	MOVEM	T1,OPNBLK

	OPEN	WC,OPNBLK	;OPEN WRITE CHANNEL
	 RTN			;ERROR

	OUTBUF	WC,^D20		;SETUP 20 OUTPUT BUFFERS

	MOVE	T1,O.NAM1	;SETUP FILE NAME
	MOVEM	T1,ENTBLK+.RBNAM

	MOVE	T1,O.EXT	;SETUP FILE EXT
	MOVEM	T1,ENTBLK+.RBEXT

	MOVE	T1,O.PPN	;SETUP PROJ,PROG #
	SKIPN	T1
	MOVE	T1,[6,,11]	;DEFAULT PPN IS 6,11
	MOVEM	T1,ENTBLK+.RBPPN

	MOVE	T1,O.PRT	;SETUP PROTECTION
	DPB	T1,[POINT 9,ENTBLK+.RBPRV,8]

	LDB	T1,[POINT 3,O.DATE,23]	;SETUP TIME AND DATE
	DPB	T1,[POINT 3,ENTBLK+.RBEXT,20]
	LDB	T1,[POINT 12,O.DATE,35]
	DPB	T1,[POINT 12,ENTBLK+.RBPRV,35]
	MOVE	T1,O.TIME
	DPB	T1,[POINT 11,ENTBLK+.RBPRV,23]

	MOVE	T1,O.VER	;SETUP VERSION
	MOVEM	T1,ENTBLK+.RBVER

	MOVEI	T1,17		;SET # OF WORDS IN EXTENDED ENTER
	MOVEM	T1,ENTBLK

	MOVEI	T1,RP.ABC!RP.NFS ;BIT 22 FOR BAD CHECKSUM
	MOVEM	T1,E10STS	;TELL MON NOT TO CHECK IT

	MOVE	T1,S.ALO	;SET BLOCKS ALLOCATED
	MOVEM	T1,E10ALC

	ENTER	WC,ENTBLK
	  RTN			;ERROR RETURN

	JRST	CPOPJ1		;GIVE SKIP (GOOD) RETURN
;*OPEN DEVICE/ENTER ON FILE FROM -11

OPNELN:	MOVSI	T1,HEDBLK	;SETUP BUFFER HEADER
	MOVEM	T1,OPNBLK+2

	MOVE	T1,O.DEV	;SETUP DEVICE
	MOVEM	T1,OPNBLK+1

	MOVEI	T1,.IOASC	;SETUP MODE
	SKIPN	EXTSW
	MOVEI	T1,.IOBIN
	MOVEM	T1,OPNBLK

	OPEN	WC,OPNBLK	;OPEN WRITE CHANNEL

	MOVE	T1,.JBFF	;SAVE FIRST FREE
	MOVEM	T1,JBFFWC

	OUTBUF	WC,^D10		;SETUP TEN OUTPUT BUFFERS

	MOVE	T1,O.NAM1	;SETUP FILE NAME
	MOVEM	T1,ENTBLK

	MOVE	T1,O.EXT	;SETUP FILE EXT
	MOVEM	T1,ENTBLK+1

	SETZM	ENTBLK+2

	MOVE	T1,O.PPN	;SETUP OUTPUT PROJ,PROG #
	MOVEM	T1,ENTBLK+3

	ENTER	WC,ENTBLK	;ENTER FILE INTO SYSTEM
	 RTN			;ERROR

	JRST	CPOPJ1		;SKIP RETURN
SUBTTL	TRANSFER FILE BACK TO -10 COMMAND PROCESS ROUTINE
;	=================================================

TOTEN:	SKIPN	DIRSW		;CHECK IF DIR. EXISTS
	  JRST	DIRERR		;-11 DIR DOES NOT EXIST

	SKIPE	S.ELN		;TEST /TO11 SWITCH
	  JRST	ILLSW		;ILLEGAL COMBINATION

	SKIPN	I.NAM1		;INPUT NAME SPECIFIED?
	  JRST	FLSPER		;ERROR

	SKIPN	O.NAM1		;OUTPUT NAME SPECIFIED ?
	 JRST	FLSPER		;ERROR

	SKIPN	T1,O.PPN
	 JRST	MSGERR
	CAMN	T1,[6,,11]
	 JRST	MSGERR		;CAN'T WRITE /TO10 INTO 6,11

;*HERE TO FIND -11 FILE IN FRONT-END DIRECTORY

	SETZM	EOFSW		;INIT EOF SW
	SETZM	HADSW		;INIT HAD SW
	SETZM	DONESW
	SETZM	FILLOG		;INIT FIL LOG ADR PTR

	GO	VINPUT		;VERIFY INPUT FILESPEC

	SKIPN	ALOSW		;SKIP IF FILE NAME FOUND
	  JRST	NOFL11		;NO FILE IN -11 DIR

	GO	OPRCDP		;OPEN RC DUMP MODE
	  JRST	OPNERR		;OPEN FAIL
	GO	SEARCH		;YES, DO CONVERSION IF NEEDED

	GO	OPNELN		;OPEN/ENTER FILE TO -10
	  JRST	ENTERR		;OPEN/ENTER FAIL

	MOVEI	D,200		;INIT WORD COUNT
	MOVEI	T16,DATBUF	;INIT BUF ADDR
	MOVE	B,FILNCB	;GET # OF -11 WORDS
	MOVE	A,FILLOG	;GET 1ST LOGICAL BLOCK # FOR THE FILE
	SOS	A

LOOP2:	SKIPGE	DONESW
	JRST	DONE		;GO CLOSE FILE

	GO	GET11		;GET A CHAR FROM -11 FILE

	SKIPN	EXTSW		;NO CONVERSION IF EXTSW=0
	JRST	DOPUT		;NO CONVERSION

;*HERE CONVERT FROM 8-BIT TO 7-BIT ASCII

	MOVE	T2,T3		;COPY THE FOUR CHARACTERS
	LDB	T3,[POINT 8,T2,17];CONVERT CHAR #A

	GO	PUT10

	LDB	T3,[POINT 8,T2,9];CONVERT CHAR #B

	GO	PUT10

	LDB	T3,[POINT 8,T2,35];CONVERT CHAR #C

	GO	PUT10

	LDB	T3,[POINT 8,T2,27];CONVERT CHAR #D

DOPUT:	GO	PUT10
	JRST	LOOP2		;GET NEXT WORD
;*GET A 36-BIT WORD FROM -11 FILE

GET11:	CAIL	D,200		;DATA LEFT IN BUFFER ?
	JRST	IN11		;NO, GET NEXT ONE

	MOVE	T3,(T16)	;GET ONE BYTE
	ADDI	T16,1		;UPDATE BUF ADR POINTER
	ADDI	D,1		;ADD 1 TO COUNTER
	SUBI	B,2		;DECREMENT -11 WORDS READ
	JUMPG	B,GOBACK	;IF MORE LEFT, RETURN

	SETOM	DONESW		;NONE LEFT, SET DONE SWITCH

GOBACK:	RTN			;RETURN

IN11:	ADDI	A,1		;READ NEXT BLK
	MOVE	T3,A		;GET BLK ADDR FROM A
	SETZM	T1		;ZERO T1
	CAIL	T3,LOGBLK	;READING FROM HI CYLINDER?
	MOVE	T1,MNTBIT	;YES, MAINT CYL IF NEEDED
	MOVEI	T2,RC		;GET CHANNEL
	DPB	T2,[POINTR(T1,SU.SCH)];PUT CHANNEL IN ARG REG.
	DPB	T3,[POINTR(T1,SU.SBL)];PUT BLK NO. IN ARG REG

	SUSET.	T1,
	  JRST	SUPERR		;ABORT DUE TO ERROR

	IN	RC,DATLST	;INPUT 1 BUFFER
	JRST	DO11
	 JRST	COMEND		;CHECK IF EOF IS ENCOUNTERED

DO11:	SETZM	D		;ZERO D
	MOVEI	T16,DATBUF	;RE-INITIALIZE BUFFER POINTER
	JRST	GET11

DONE:	CLOSE	RC,
	RELEAS	RC,
	CLOSE	WC,
	RELEAS	WC,
	MOVE	T1,JBFFWC
	MOVEM	T1,.JBFF	;RECLAIM BUF SPACE
	JRST	SCAN
SUBTTL	ASCII AND BINARY FILE TYPE CHECK ROUTINE
;	========================================

SEARCH:	SKIPE	S.BIN		;/BINARY SW SET?
	JRST	OFF		;YES

	SKIPE	S.ASC		;/ASCII SW SET?
	JRST	ON		;YES

	SETZM	EXTSW		;INIT EXT SW
	HLLZ	T1,I.EXT	;GET COPY OF .EXT
	MOVSI	T2,-EXTLEN	;POINT TO FILEXT TABLE

LOOP:	CAME	T1,FILEXT(T2)	;SEE IF CORRECT EXT
	AOBJN	T2,LOOP		;LOOP TO MATCH

	JUMPL	T2,FOUND	;EXT MATCHED

ON:	SETOM	EXTSW		;TURN ON SW
	SKIPE	S.BIN		;/BINARY SW ALSO SET?
	  JRST	ILLSW		;YES, IT IS AN ERROR

FOUND:	RTN			;RETURN

OFF:	SETZM	EXTSW		;TURN OFF SW
	SKIPE	S.ASC		;/ASCII SW ALSO SET?
	  JRST	ILLSW		;YES, ERROR

	RTN			;RETURN

;*TABLE OF NON-ASCII EXTENSIONS
; ----- -- --------- ----------

FILEXT:	SIXBIT	/ABS/
	SIXBIT	/BIN/
	SIXBIT	/BIC/
	SIXBIT	/CIL/
	SIXBIT	/LBO/
	SIXBIT	/LDA/
	SIXBIT	/LDR/
	SIXBIT	/LOD/
	SIXBIT	/MFD/
	SIXBIT	/OBJ/
	SIXBIT	/SAV/
	SIXBIT	/SYM/
	SIXBIT	/SYS/
	SIXBIT	/UFD/
EXTLEN=.-FILEXT
SUBTTL	DELETE -11 FILE COMMAND PROCESS ROUTINE
;	=======================================

DELETE:	SKIPN	DIRSW		;DOES DIRECTORY EXIST ?
	JRST	DIRERR		;NO

	SKIPN	ACDEV
	MOVSI	ACDEV,'DEV'
	MOVEM	ACDEV,I.DEV	;SETUP DEVICE

	MOVEM	ACFILE,I.NAM1	;SETUP NAME
	MOVEM	ACEXT,I.EXT	;SETUP EXT

	MOVE	ACPPN,[6,11]
	MOVEM	ACPPN,I.PPN	;SETUP 6,11 AREA

	GO	VINPUT		;DOES FILE EXIST IN F-E DIRECTORY ?
	SKIPN	ALOSW
	JRST	NOFL11		;NO
	SETZM	(T7)		;YES, CLEAR ENTRY, DELETE FILE

	GO	OPNTEN		;FIND FILE IN 6,11 AREA
	JRST	LUKERR		;NOT FOUND

	CLOSE	RC,

	RENAME	RC,DELNAM	;DELETE FILE OUT OF EXISTANCE
	JRST	DELERR		;ERROR

	RELEAS	RC,

	MOVE	T1,JBFFRC
	MOVEM	T1,.JBFF

	JRST	SCAN

DELNAM:	0
	0
	0
	0
SUBTTL	KLAD10 BOOT GENERATION COMMAND PROCESS ROUTINE
;	==============================================

FB=T5
BC=T6
BYTE=T7

BOOT1:	SKIPN	DIRSW		;DOES DIRECTORY EXIST ?
	 JRST	DIRERR		;NO

	SKIPN	ACDEV
	MOVSI	ACDEV,'DEV'	;SETUP DEVICE
	MOVEM	ACDEV,I.DEV

	CAME	ACFILE,[SIXBIT/KLADBT/]
	JRST	WRNGBT		;WRONG BOOT FILE
	MOVEM	ACFILE,I.NAM1	;SETUP FILE NAME

	MOVEM	ACEXT,I.EXT	;SETUP FILE EXT

	MOVEM	ACPPN,I.PPN	;SETUP PROJ,PROG #

	SETZM	EXTSW		;BINARY MODE

	GO	OPNTEN		;LOOKUP BOOT FILE
	 JRST	LUKERR		;FILE NOT FOUND

	GO	BOOTLD		;LOAD BOOT INTO CORE IMAGE

	GO 	BOOTWT		;WRITE BLKS 1-3 INTO BOOT FILE

	GO	BOOTW0		;WRITE BLK 0 INTO KLAD BLOCK 0

	MOVEI	1		;ALLOCATE 1 BLOCK FOR "RSXBT.ZRO"
	MOVEM	S.ALO

	MOVE	ACFILE,[SIXBIT/RSXBT/]
	MOVE	ACEXT,[SIXBIT/ZRO/]

	SETZB	ACDEV,ACPPN

	JRST	ALO		;ALLOCATE, THEN RETURN TO SCAN
;*BOOT BINARY LOAD ROUTINE

BOOTLD:	SETZM	B11STR		;CLEAR BOOT CORE IMAGE STORAGE
	MOVE	T1,[B11STR,,B11STR+1]
	BLT	T1,B11STR+777

	SETZM	EOFSW
	SETOM	FB
B11LP:	GO	G11BYT		;GET 8 BIT -11 BYTE
	JRST	EOFERR		;ILLEGAL EOF

	JUMPE	BYTE,B11LP	;DISCARD NULLS
	CAIN	BYTE,377
	JRST	B11LP		;DISCARD DELETES

	CAIE	BYTE,1		;VERIFY CONSTANT 1
	JRST	C1ERR		;JUNK, MAYBE NOT A BIN FILE

	MOVEM	BYTE,B11SUM#	;INIT CHECKSUM

	GO	G11BYT		;VERIFY CONSTANT 0
	JRST	EOFERR
	SKIPE	BYTE
	JRST	C0ERR		;JUNK

	GO	G11WD		;GET BYTE COUNT
	JUMPE	T1,ZBCNT	;ZERO BYTE COUNT ?

B11LPA:	MOVEI	BC,-6(T1)	;GET DATA BYTE COUNT
	JUMPL	BC,LT6ERR	;LESS THAN 6 ?

	GO	G11WD		;GET LOAD ADDRESS
	MOVEM	T1,ADR11#
	JUMPE	BC,CPOPJ	;BC=6='S -11 START BLOCK

	MOVE	T16,ADR11	;SETUP BOOT CORE IMAGE
	LSH	T16,-2		;STORE ADDRESS
;*GET -11 DATA WORDS

B11DATA:CAILE	T16,777		;EXCEEDED CORE IMAGE SIZE ?
	JRST	TOOBIG		;YES, BOOT FILE TOO BIG

	GO	G11BYT		;GET -11 BYTE
	JRST	EOFERR

	MOVE	T2,ADR11	;GET -11 ADDRESS
	ANDI	T2,3		;TWO LO BITS INDICATE POSITION
	DPB	BYTE,B11PNT(T2)	;TO STORE IN -10 WORD

	CAIN	T2,3		;DONE 4 BYTES TO -10 ?
	AOS	T16		;YES, ADVANCE TO NEXT -10 WORD
	AOS	ADR11		;ADVANCE -11 ADDRESS
	SOJG	BC,B11DATA	;LOOP TILL -11 BLOCK DONE

	GO	CK11SUM		;VERIFY CHECKSUM

	JRST	B11LP		;GET NEXT BLOCK

B11PNT:	POINT	8,B11STR(T16),17
	POINT	8,B11STR(T16),9
	POINT	8,B11STR(T16),35
	POINT	8,B11STR(T16),27
CK11SUM:GO	G11BYT		;GET CHECKSUM BYTE
	JRST	EOFERR

	MOVE	T1,B11SUM	;VERIFY CHECKSUM RESULT
	TRNN	T1,377		;SHOULD BE 8 BITS OF 0
	RTN
	JRST	CKSERR		;CHECKSUM ERROR

G11WD:	GO	G11BYT		;GET RH BYTE
	JRST	EOFERR
	MOVEM	BYTE,BYTESV#

	GO	G11BYT		;GET LH BYTE
	JRST	EOFERR

	MOVE	T1,BYTE
	LSH	T1,8		;POSITION LH BYTE
	IOR	T1,BYTESV	;INCLUDE RH BYTE
	RTN

G11BYT:	AOS	FB		;ADVANCE FILE BYTE
	ANDI	FB,3		;(MOD 4)
	JUMPN	FB,G11BY2	;IF NOT NEW WORD, JUST FETCH BYTE
	GO	GET10		;GET NEXT 36 BIT WORD
	SKIPE	EOFSW		;END OF FILE ?
	RTN			;YES

G11BY1:	MOVEM	T3,CHRSAV#
	TLNN	T3,(6B2)	;TEST FOR JUNK IN EITHER HALF
	TRNE	T3,6B20
	JRST	JNKERR

G11BY2:	LDB	BYTE,PTRTAB(FB)	;GET PROPER 8 BIT BYTE
	ADDM	BYTE,B11SUM	;ADD TO CHECKSUM
	JRST	CPOPJ1		;SKIP RETURN

PTRTAB:	POINT	8,CHRSAV,17	;8 BIT BYTE PICKUP POINTERS
	POINT	8,CHRSAV,9
	POINT	8,CHRSAV,35
	POINT	8,CHRSAV,27
;*WRITE OUT SECONDARY BOOTSTRAP, BLOCKS 1-3

BOOTWT:	MOVSI	T1,'DEV'	;SETUP DEVICE
	MOVEM	T1,O.DEV

	MOVE	T1,I.NAM1	;SETUP FILE NAME
	MOVEM	T1,O.NAM1

	MOVE	T1,[SIXBIT/RIM/]
	MOVEM	T1,O.EXT	;SETUP FILE EXT

	SETZM	O.PPN		;CLEAR PPN

	MOVEI	T1,577		;SET PROTECTION 577
	MOVEM	T1,O.PRT

	MOVEI	T1,3		;ALLOCATE 3 BLOCKS
	MOVEM	T1,S.ALO

	GO	ETER10		;ENTER FILE
	 JRST	EBOTER

	MOVEI	T16,^D128*3	;SETUP FOR OUTPUT
	MOVEI	T7,B11STR+^D128	;BLOCKS 1-3

	MOVE	T3,(T7)		;PUT BOOT CORE IMAGE INTO FILE
	GO	PUT10
	ADDI	T7,1
	SOJG	T16,.-3

	CLOSE	WC,CL.DLL	;CLOSE WRITE CHANNEL
	RELEAS	WC,

	RTN
;*WRITE BOOT BLOCK 0 ONTO DISK BLOCK 0

BOOTW0:	GO	GETBK2		;GET DISK ADDRESS OF BLOCKS 1-3

	GO	LOGPHY		;AND INSERT INTO BOOT BLOCK 0
	SETZM	B11STR+14	;AT -11 WD 60 & 62

	MOVE	T3,CYLADD
	DPB	T3,[POINT 10,B11STR+14,17]

	MOVE	T3,TRKADD
	DPB	T3,[POINT 5,B11STR+14,27]

	MOVE	T3,SCTADD
	DPB	T3,[POINT 5,B11STR+14,35]

	MOVSI	T1,SU.SOT
	MOVEI	T2,HOM
	MOVEI	T3,0
	DPB	T2,[POINTR(T1,SU.SCH)]
	DPB	T3,[POINTR(T1,SU.SBL)]

	SUSET.	T1,		;SELECT DISK BLOCK 0
	 JRST	SUPERR

	OUT	HOM,BOTLST	;WRITE BOOT BLOCK 0
	JRST	.+2
	JRST	WRTERR

	GO	BOOTZRO		;WRITE BOOT BLK 0 INTO "KLADBT.ZRO"

	SKIPN	ROM406		;ALSO WRITE BOOT 0 AT CYL 406 ?
	RTN			;NO

	MOVSI	T1,SU.SOT	;YES, ALSO WRITE BOOT BLOCK 0
	OR	T1,MNTBIT	;AT CYLINDER 406 BLOCK #0
	MOVEI	T2,HOM
	MOVEI	T3,LOGBLK
	DPB	T2,[POINTR(T1,SU.SCH)]
	DPB	T3,[POINTR(T1,SU.SBL)]

	SUSET.	T1,		;SELECT DISK CYLINDER 406 BLOCK 0
	 JRST	SUPERR

	OUT	HOM,BOTLST	;WRITE BOOT BLOCK 0 AGAIN
	JRST	.+2
	JRST	WRTERR
	RTN
;*WRITE BOOT BLOCK 0 INTO "KLADBT.ZRO"

BOOTZRO:MOVSI	T1,'DEV'
	MOVEM	T1,O.DEV	;SETUP DEVICE

	MOVE	T1,[SIXBIT/KLADBT/]
	MOVEM	T1,O.NAM1	;SETUP NAME.EXT

	MOVE	T1,[SIXBIT/ZRO/]
	MOVEM	T1,O.EXT

	SETZM	O.PPN

	MOVEI	T1,577
	MOVEM	T1,O.PRT	;SET PROTECTION

	LDB	T1,[POINT 11,LOOK10+.RBPRV,23]
	MOVEM	T1,O.TIME

	LDB	T1,[POINT 3,LOOK10+.RBEXT,20]
	DPB	T1,[POINT 3,O.DATE,23]
	LDB	T1,[POINT 12,LOOK10+.RBPRV,35]
	DPB	T1,[POINT 12,O.DATE,35]

	MOVEI	T1,1
	MOVEM	T1,S.ALO	;1 BLOCK

	GO	ETER10		;ENTER FILE
	 JRST	EBOTER

	MOVEI	T16,^D128
	MOVEI	T7,B11STR	;PUT 1ST BOOT BLOCK INTO FILE

	MOVE	T3,(T7)
	GO	PUT10
	ADDI	T7,1
	SOJG	T16,.-3
	CLOSE	WC,CL.DLL	;CLOSE WRITE CHANNEL
	RELEAS	WC,

	GO	GETBK2		;GET DISK ADDRESS
	MOVEM	T1,FILLOG

	GO	SRHDIR		;FIND A DIRECTORY ENTRY
	 JRST	DIRFUL

	MOVE	T1,FILLOG
	GO	LOGPHY		;GET PHYSICAL DISK ADDRESS

	GO	DIRETY		;ENTER INTO F-E DIRECTORY

	GO	ALNSET

	MOVEI	T2,^D256	;SET WORDS ALLOCATED
	DPB	T2,[POINT 16,DIR3(T7),35]
	LSH	T2,-<^D16>
	DPB	T2,[POINT 16,DIR3(T7),17]

	MOVEI	T2,^D256	;SET WORDS WRITTEN
	DPB	T2,[POINT 16,DIR4(T7),35]
	LSH	T2,-<^D16>
	DPB	T2,[POINT 16,DIR4(T7),17]

	RTN
;*BOOT ERROR MESSAGES

TOOBIG:	MOVEI	[ASCIZ	"%BOOT FILE TOO BIG"]
	JRST	WHTFIL

EOFERR:	MOVEI	[ASCIZ	"%BOOT ILLEGAL EOF"]
	JRST	WHTFIL

C1ERR:	MOVEI	[ASCIZ	"%BOOT BIN CONSTANT 1 ERROR"]
	JRST	WHTFIL

C0ERR:	MOVEI	[ASCIZ	"%BOOT BIN CONSTANT 0 ERROR"]
	JRST	WHTFIL

LT6ERR:	MOVEI	[ASCIZ	"%BOOT BYTE COUNT ERROR"]
	JRST	WHTFIL

CKSERR:	MOVEI	[ASCIZ	"%BOOT CHECKSUM ERROR"]
	JRST	WHTFIL

JNKERR:	MOVEI	[ASCIZ	"%BOOT JUNK DATA ERROR"]
	JRST	WHTFIL

ZBCNT:	MOVEI	[ASCIZ	"%BOOT ZERO BYTE COUNT ERROR"]
	JRST	WHTFIL

EBOTER:	MOVEI	[ASCIZ	"%BOOT ENTER ERROR"]
	JRST	WHTFIL

WRNGBT:	MOVEI	[ASCIZ	"%WRONG BOOT FILE"]
	JRST	WHTFIL
SUBTTL	CREATE -11 DIRECTORY ROUTINE
;	============================

DIR11:	SKIPE	I.NAM1		;SKIP IF NO NAME SPECIFIED
	  JRST	ILLSW		;NOT SUPPOSED TO HAVE NAME

	MOVE	T1,DEVSW	;GET DEVICE SW
	AOJE	T1,NODEV	;YES, DEVICE SPECIFIED

	OUTSTR	[ASCIZ /
?SPECIFY DEVICE FILE STRUCTURE
/]
	SKIPE	$CCLF		;DOING COMMAND FILE ?
	EXIT			;YES, EXIT THEN
	JRST	SCAN		;NO DEV SPECIFIED

NODEV:	MOVEI	T1,HOLD		;GET THRESHOLD COUNT
	CAMGE	T1,S.CRE	;SKIP IF N</=1500 IN DEC.
	JRST	THRERR		;EXCEED DIR THRESHOLD

	SETZM	DEVSW		;RESET DEVICE SW
	SKIPE	DIRSW		;-11 DIR EXIST?

	OUTSTR	[ ASCIZ /
%SUPERSEDING EXISTING FRONT-END DIRECTORY
/]

	MOVE	T1,HOMBUF	;1ST WORD OF HOME BLOCK
	CAME 	T1,[SIXBIT/HOM/]
	  JRST	HOMERR		;HOME BLOCK NOT FOUND

	MOVEI	T7,HOMBUF	;HOME BLK ADDR. IN T7
	HLRZ	A,[SIXBIT/KLAD10/]
	GO	SIXR50		;PUT KLAD10 IDENTIFICATION IN HOME BLOCK
	DPB	A,[POINT 16,WORD65(T7),17]

	HRRZ	A,[SIXBIT/KLAD10/]
	GO	SIXR50
	DPB	A,[POINT 16,WORD65(T7),35]

	MOVE	T1,S.CRE	;SAVE N IN T1
	IDIVI	T1,BDF		;BDF=# OF ENTRIES PER BLK
	SKIPE	T2		;EXACT?
	ADDI	T1,1		;NO, ROUNDUP
	MOVEM	T1,DIRNCB	;SAVE AS NCB

	GO	INTCOR		;GET HI-CORE FOR DIRECTORY

	SETOM	DIRSW		;TURN ON DIR SW

	JRST	SCAN
SUBTTL	SPECIFY DEVICE FILE STRUCTURE FOR -11 DIRECTORY
;	===============================================

DEVSTR:	SKIPE	S.CRE		;SKIP IF /CRE NOT CLEAR
	  JRST	ILLSW

	MOVE	T2,S.DEV	;GET STRUCTURE NAME
	MOVEM	T2,DIRDEV
	MOVEM	T2,DATDEV	;SAVE IT
	MOVE	T1,[0,,DIRDEV]	;STATUS AT LOC+0

	DSKCHR	T1,
	  JRST	DEVERR		;DEVICE ERROR

	LDB	T2,[POINT 6,T1,26];GET BITS 21-26
	SUBI	T2,5		;5=RP04/RP06 CTR
	JUMPE	T2,CTLROK	;IT'S RP04/RP06 CTR
	  JRST	CTRERR		;NOT AN RP04/RP06 CTR

CTLROK:	MOVE	T2,MNTBIT
	TRNE	T1,DC.UNT	;IS THIS PACK AN RP04 ?
	SETZ	T2,		;NO, NO MAINT CYL BIT NEEDED
	MOVEM	T2,MNTBIT

	MOVE	T1,[16,,DIRDEV]	;PHYNAME AT LOC+15

	DSKCHR	T1,		;GET PHY DEVICE NAME
	  JRST	DEVERR		;DEVICE ERROR

	MOVE	T1,[16,,DATDEV]

	DSKCHR	T1,
	  JRST	DEVERR		;DEVICE ERROR

USRHPQ:	MOVEI	1
	HPQ			;SET HI-PRI RUN Q
	 JFCL

USRHDQ:	MOVEI	HDQ		;SET HI-PRI DISK Q
	DISK.
	 JFCL
	JRST	.+2
HDQ:	3,,-1
	GO	OPNDIR		;OPEN WITH DIR CHANNEL
	  JRST	OPNERR		;OPEN FAIL

	GO	OPNHOM		;OPEN WITH HOM CHANNEL
	  JRST	OPNERR

	GO	OPNDAT		;OPEN WITH DAT CHANNEL
	  JRST	OPNERR

	MOVEI	T3,HMBK01	;GET HOME BLK #1

	GO	RADHOM		;READ HOME BLK #1
	  JRST	RADERR		;READ ERROR

	SETOM	DEVSW		;SET STRUC. SW
	MOVEI	T2,HOMBUF	;GET HOME BUF ADR
	SKIPN	WORD66(T2)	;DIRECTORY ON DISK?
	JRST	SCAN		;NO

	SETOM	DIRSW		;INDICATE DIR EXISTED
	GO	PHYLOG		;CONVERT PHY TO LOG BLK NO.
	MOVE	T1,DIRNCB	;GET # OF BLOCKS

	GO	INTCOR		;SETUP HI-CORE FOR DIRECTORY

	MOVE	B,DIRLOG	;GET STARTING BLOCK #
	MOVE	C,DIRNCB	;GET # OF BLOCKS

	MOVE	A,[DIRBUF,,400000]
	MOVEI	T7,400177
	MOVEM	A,SAVEA#
	MOVEM	T7,SAVET7#

DIRLP:	MOVE	T3,B
	GO	RADDIR		;READ DIRECTORY BLOCK
	 JRST	RADERR

	BLT	A,(T7)		;TRANSFER BLOCK TO HI-CORE
	MOVE	A,SAVEA
	MOVE	T7,SAVET7
	ADDI	A,200
	ADDI	T7,200
	MOVEM	A,SAVEA
	MOVEM	T7,SAVET7

	SOSE	C		;DONE ALL BLOCKS ?
	AOJA	B,DIRLP		;NO, DO NEXT BLOCK

	JRST	SCAN		;CONTINUE PROCESS
SUBTTL	PROCESSING SUBROUTINES
;	======================

;*LOGPHY - ROUTINE TO CONVERT A LOGICAL BLOCK ADDRESS TO
;*	   A PHYSICAL BLOCK ADDRESS. THE CYLINDER, TRACK,
;*	   AND SECTOR NUMBERS ARE STORED IN THREE LOCATIONS:
;*	   CYLADD, TRKADD, AND SCTADD.
;*
;* CALL:	MOVE T1,LOGICAL BLOCK ADDRESS
;*		GO	LOGPHY
;*		RETURN WITH CYLADD, TRKADD, AND SCTADD SET UP


LOGPHY:	IDIVI	T1,^D380	;DIVIDE BY BPC
	MOVEM	T1,CYLADD	;SAVE CYLINDER NO

	IDIVI	T2,^D20		;DIVIDED BY BPT
	MOVEM	T2,TRKADD	;SAVE TRACK NO.

	MOVEM	T3,SCTADD	;SAVE SECTOR NO.

	RTN			;RETURN TO WHENCE WE CAME ...

;*INITIALIZE HI-CORE FOR DIRECTORY STORAGE

INTCOR:	MOVSI	0,1
	CORE	0,		;DELETE ANY PREVIOUS HI-CORE
	 JRST	ERRCOR

	IMULI	T1,^D128	;COMPUTE WORDS REQUIRED
	SUBI	T1,1
	ADDI	T1,400000
	PUT	T1

	HRLZ	T1,T1		;GET HI-CORE
	CORE	T1,
	 JRST	ERRCOR

	SETZM			;MAKE IT WRITABLE
	SETUWP
	 JRST	ERRCOR

	GET	T1
	SETZM	400000
	MOVE	0,[400000,,400001]
	BLT	0,(T1)		;CLEAR HI-CORE
	RTN
;*OPNHOM - ROUTINE TO OPEN THE DISK ON CHANNEL 'HOM'

OPNHOM:	MOVEI	T5,.IODMP	;OPEN IN DUMP MODE
	MOVE	T6,DSKUPN	;GET DEVICE NAME
	MOVEI	T7,0

	OPEN	HOM,T5
	  RTN			;ERROR RETURN

	JRST	CPOPJ1		;GOOD RETURN

;*RADHOM - ROUTINE TO READ A BLOCK ON CHANNEL 'HOM'

RADHOM:	SETZ	T1,
	MOVEI	T2,HOM
	DPB	T2,[POINTR(T1,SU.SCH)];PUT CHANNEL IN ARG REG.
	DPB	T3,[POINTR(T1,SU.SBL)];PUT BLK NO IN ARG REG

	SUSET.	T1,		;INSERT BLOCK NUMBER
	  JRST	SUPERR		;SUSET. UUO ERROR

	IN	HOM,HOMLST	;BRING IN THE DIRECTORY BLOCK
	  JRST	CPOPJ1		;GOOD RETURN

	RTN			;BAD RETURN

;*WRTHOM - ROUTINE TO WRITE A BLOCK ON CHANNEL 'HOM'

WRTHOM:	MOVSI	T1,SU.SOT	;OUTPUT BIT
	MOVEI	T2,HOM
	DPB	T2,[POINTR(T1,SU.SCH)];SPECIFY CHANNEL NO.
	DPB	T3,[POINTR(T1,SU.SBL)];SPECIFY BLOCK NO.

	SUSET.	T1,
	  JRST	SUPERR		;ERROR

	OUT	HOM,HOMLST	;OUTPUT HOME BLOCK
	  JRST	CPOPJ1		;GOOD RETURN

	RTN			;ERROR RETURN
;*OPNDIR - ROUTINE TO OPEN THE DISK ON CHANNEL 'DIR'

OPNDIR:	MOVEI	T5,.IODMP	;SPECIFY DUMP MODE
	MOVE	T6,DSKUPN	;GET DEVICE NAME(PHYSICAL)
	MOVEI	T7,0		;NO RING BUFFERS

	OPEN	DIR,T5		;ASK FOR DISK
	  RTN			;ERROR RETURN

	JRST	CPOPJ1		;GOOD RETURN

;*RADDIR - ROUTINE TO READ A BLOCK ON CHANNEL 'DIR'
;*	NEED MAINT BIT TO UPDATE FROM OLD KLADS

RADDIR:	SETZ	T1,
	CAIL	T3,LOGBLK	;READING FROM HI-CYL ON RP04 ?
	MOVE	T1,MNTBIT	;YES		
	MOVEI	T2,DIR		;USE DIR CHANNEL
	DPB	T2,[POINTR(T1,SU.SCH)];CHANNEL NO IN ARG REG
	DPB	T3,[POINTR(T1,SU.SBL)];BLK NO. IN ARG REG

	SUSET.	T1,		;INSERT BLOCK NO.
	 JRST	SUPERR		;ERROR, ABORT

	IN	DIR,DIRLST
	  JRST	CPOPJ1

	RTN			;ERROR
;*OPWCDP - ROUTINE TO OPEN IN DUMP MODE TO WRITE

OPWCDP:	MOVEI	T1,.IODMP	;DUMP MODE
	MOVE	T2,DSKUPN	;DEVICE NAME
	SETZM	T3

	OPEN	WC,T1		;OPEN FOR -11 OUTPUT
	  RTN			;ERROR RETURN

	JRST	CPOPJ1		;GOOD RETURN

;*OPNDAT - ROUTINE TO OPEN THE DISK ON CHANNEL 'DAT'

OPNDAT:	MOVEI	T5,.IODMP	;SPECIFY DUMP MODE
	MOVE	T6,DSKUPN	;GET DEVICE NAME(PHYSICAL)
	MOVEI	T7,0		;NO RING BUFFERS

	OPEN	DAT,T5		;ASK FOR DISK
	  RTN			;ERROR RETURN

	JRST	CPOPJ1		;GOOD RETURN

	RTN			;ERROR

;*OPRCDP - ROUTINE TO OPEN IN DUMP MODE TO READ

OPRCDP:	MOVEI	T1,.IODMP	;USE DUMP MODE INPUT
	MOVE	T2,DSKUPN	;GET DEVICE NAME
	SETZM	T3		;NO BUFFER

	OPEN	RC,T1
	  RTN			;ERROR RETURN

	JRST	CPOPJ1		;GOOD RETURN
;*GETBLK - ROUTINE TO GET THE LOGICAL BLOCK NUMBER OF THE
;*	   FIRST BLOCK OF A FILE IN THE TOPS-10 FILE SYSTEM.
;*
;*CALL:		GO	GETBK1
;*		OR
;*		GO	GETBK2
;*		RETURN WITH BLOCK # IN T1

GETBK1:	GO	OPRCDP		;USE DUMP MODE INPUT
	  JRST	OPNERR		;ERROR, ISSUE MESSAGE

	MOVEI	T1,17		;GET # OF ARGUMENTS
	MOVEM	T1,LOOK10	;SAVE # OF ARGS IN LOOKUP BLK

	LOOKUP	RC,LOOK10	;LOOKUP THE FILE
	  JRST	NOFL10		;CANNOT FIND FILE !

	JRST	GOARND		;GO AROUND

GETBK2:	GO	OPRCDP		;USE DUMP MODE INPUT
	  JRST	OPNERR		;ERROR

	MOVEI	T1,17		;GET # OF ARGUMENTS
	MOVEM	T1,ENTBLK	;SAVE IT

	LOOKUP	RC,ENTBLK	;LOOKUP THE OUTPUT FILE
	  JRST	NOFL10		;NO SUCH FILE !

GOARND:	USETI	RC,PRIME	;SET UP TO READ PRIME RIB

	INPUT	RC,[IOWD 200,GETBUF
		    0 ]		;READ THE PRIME RIB

	HRRZ	T1,GETBUF	;GET ADDRESS OF 1ST POINTER
	MOVEI	T1,GETBUF+1(T1)	;GET SECOND POINTER
	HLL	T1,HOMCLP	;FORM BYTE POINTER
	LDB	T1,T1		;GET ADDRESS POINTER
	IMUL	T1,HOMBPC	;COMPUTE RIB LOGICAL BLOCK #
	ADDI	T1,1		;COMPUTE # OF DATA BLOCK 1
	RTN			;RETURN
;*PHYLOG - PHYSICAL TO LOGICAL BLOCK ADDRESS CONVERSION ROUTINE
;*	CONVERT PHYSICAL ADDR TO LOGICAL ADDR
;*	FOR DIRECTORY FILE

PHYLOG:	MOVEI	T7,HOMBUF		;GET HOME BUF ADR
	LDB	T3,[POINT 10,WORD66(T7),17] ;GET CLYDR OF DIR FILE
	IMULI	T3,^D380		;MUTIPLY BY BPC
	LDB	T2,[POINT 5,WORD66(T7),27] ;GET TRACK OF DIR FILE
	IMULI	T2,^D20			;MUTIPLY BY BPT
	LDB	T1,[POINT 5,WORD66(T7),35] ;GET SECTOR OF DIR FILE
	ADD	T3,T2
	ADD	T3,T1			;T3 CONTAINS 1ST LOG ADDR
	MOVEM	T3,DIRLOG		;SAVE IT
	MOVEM	T3,DIRFST		;ALSO SAVE IT AS 1ST ADR
	LDB	T4,[POINT 16,WORD67(T7),17] ;GET NCB OF DIR FILE
	MOVEM	T4,DIRNCB		;SAVE IT
	RTN

;*COVERT -  CONVERT PHY ADDR(FROM DIR FILE) TO LOG ADDR FOR DATA FILE

COVERT:	LDB	T3,[POINT 10,DIR2(T7),17]
	IMULI	T3,^D380		;CYLINDER
	LDB	T2,[POINT 5,DIR2(T7),27]
	IMULI	T2,^D20			;TRACK
	LDB	T1,[POINT 5,DIR2(T7),35]
	ADD	T3,T2
	ADD	T3,T1			;T3 CONTAINS LOG ADDR
	RTN				;RETURN

CPOPJ1:	AOS	(P)		;SKIP RETURN

CPOPJ:	RTN			;NON-SKIP RETURN
;*VINPUT - FE FILE VERIFICATION ROUTINE

VINPUT:	HLRZ	A,I.NAM1	;GET INPUT FILE NAME
	GO	SIXR50		;CONVERT IT TO -11 RAD50
	HRLM	A,FILNAM	;SAVE IT

	HRRZ	A,I.NAM1	;GET 3 MORE SIXBITS
	GO	SIXR50
	HRRM	A,FILNAM

	HLRZ	A,I.EXT		;GET FILE EXT
	GO	SIXR50
	HRLZM	A,EXTION	;SAVE EXT

IENTRY:	MOVE	T5,DIRNCB	;GET NO. OF BLKS IN T5
	IMULI	T5,^D16
	MOVEI	T7,400000	;GET HI-CORE BASE ADDRESS

TLOOP:	MOVE	T10,(T7)	;1ST WORD IN T10
	CAMN	T10,FILNAM	;COMPARE 1ST WORD
	JRST	COMEXT		;GO COMPARE EXT

BACK:	ADDI	T7,HALF		;GET TO NEXT ENTRY
	SOJG	T5,TLOOP	;SEARCH ALL ENTRIES
	RTN			;FILE DOES NOT EXIST

COMEXT:	HLLZ	T10,1(T7)	;GET NEXT WORD
	CAME	T10,EXTION	;CORRECT EXTENSION ?
	JRST	BACK		;NO, GO CHECK NEXT ENTRY

	SETOM	ALOSW		;YES, NAME FOUND

	GO	COVERT		;CONVERT PHY TO LOG BLK NO

	MOVEM	T3,FILLOG	;SAVE 1ST BLK ADDR
	HRRZ	B,DIR4(T7)	;RH OF WD WRITTEN IN B
	HLRZ	C,DIR4(T7)	;LH OF WD WRITTEN IN C
	DPB	C,[POINT 16,B,19] ;RH+LH IN B
	MOVEM	B,FILNCB	;SAVE # OF WORDS IN NCB
	RTN			;RETURN
;*SRHDIR - SEARCH FOR AVAILABLE ENTRY IN DIRECTORY FILE

SRHDIR:	HLRZ	A,O.NAM1	;GET OUTPUT FILE NAME
	GO	SIXR50		;CONVERT IT TO -11 RAD 50
	HRLM	A,FILNAM

	HRRZ	A,O.NAM1
	GO	SIXR50
	HRRM	A,FILNAM

	HLRZ	A,O.EXT
	GO	SIXR50
	HRLZM	A,EXTION

	MOVE	C,DIRNCB	;GET NO. OF BLKS IN C
	IMULI	C,^D16		;COMPUTE ENTRIES
	MOVEI	T7,400000	;SET HI-CORE DIRECTORY BASE ADDRESS

AGAIN:	MOVE	A,(T7)		;GET DIR 1ST WORD IN A
	CAIE	A,0
	CAMN	A,[-2,,-2]	;ENTRY IN USE?
	JRST	FREE		;NOT IN USE

	MOVE	T10,(T7)	;GET DIRECTORY ENTRY NAME
	CAMN	T10,FILNAM
	JRST	SRHEXT		;NAME MATCH, CHECK EXT

	ADDI	T7,HALF		;GET TO NEXT ENTRY
	SOJG	C,AGAIN		;NO
	RTN			;NO ENTRIES AVAILABLE

SRHEXT:	HLLZ	T10,1(T7)
	CAME	T10,EXTION
	JRST	.-5

FREE:	JRST	CPOPJ1		;FOUND A FREE ENTRY
;*DIRETY - CREATE A -11 DIRECTORY ENTRY 

DIRETY:	SETZM	DIR0(T7)		;SET TO ZERO
	MOVSI	T1,DIR0(T7)		;GET SOURCE ADDR
	HRRI	T1,DIR1(T7)		;GET DESTINATION FOR BLT
	BLT	T1,DIR7(T7)		;ZERO OUT 16 BYTES
	MOVE	T3,CYLADD		;GET CYLINDER ADR
	DPB	T3,[POINT 10,DIR2(T7),17] ;CYLINDER NO.
	MOVE	T3,TRKADD		;GET TRACK ADDR
	DPB	T3,[POINT 5,DIR2(T7),27] ;TRACK NO.
	MOVE	T3,SCTADD		;GET SECTOR ADDR
	DPB	T3,[POINT 5,DIR2(T7),35] ;SECTOR NO.
	RTN				;RETURN

ALNSET:	HLRZ	A,O.NAM1		;GET 3 SIXBIT CHARS
	GO	SIXR50			;CONVERT THEM TO -11 RAD50
	DPB	A,[POINT 16,DIR0(T7),17] ;SAVE O.NAM1 IN -11 RAD50

	HRRZ	A,O.NAM1		;SECOND PART
	GO	SIXR50
	DPB	A,[POINT 16,DIR0(T7),35] ;SAVE O.NAM2 IN -11 RAD50

	HLRZ	A,O.EXT			;GET FILE EXTENSION
	GO	SIXR50
	DPB	A,[POINT 16,DIR1(T7),17] ;SAVE EXT IN -11 RAD50

	MOVE	T1,O.DATE		;GET DATE
	DPB	T1,[POINT 16,DIR1(T7),35] ;SAVE DATE
	RTN				;RETURN
;*SIXR50 - SIXBIT TO RAD50 (-11 STYLE) CONVERSION ROUTINE
;*
;*CALL WITH 3 SIXBIT CHARACTERS IN RH OF A
;*RETURN WITH RADIX 50 (-11 STYLE) IN A
;*ALL BAD CHARACTER CODED AS 35'S, THE UNDEFINDED CHAR

SIXR50:	MOVEI	T0,0			;INIT T0
	MOVE	E,[POINT 6,A,17]	;E CONTAINS INPUT

ALOOP:	ILDB	B,E			;GET A BYTE
	IDIVI	B,6			;CODE CONVERT
	LDB	D,TABA(C)		;GET THE R50 BYTE
	IMULI	T0,50			;LEFT SHIFT PREV BYTES
	ADDI	T0,0(D)			;ADD IN THIS ONE
	TLNE	E,770000		;DONE?
	JRST	ALOOP			;NO

	MOVE	A,T0			;YES, ANSWER IS IN A
	RTN				;RETURN

TABA:	POINT	6,TABB(B),05
	POINT	6,TABB(B),11
	POINT	6,TABB(B),17
	POINT	6,TABB(B),23
	POINT	6,TABB(B),29
	POINT	6,TABB(B),35

TABB:	BYTE	(6)0,35,35,35,33,35,35,35,35,35,35,35
	BYTE	(6)35,35,34,35,36,37,40,41,42,43,44,45
	BYTE	(6)46,47,35,35,35,35,35,35,35,01,02,03
	BYTE	(6)04,05,06,07,10,11,12,13,14,15,16,17
	BYTE	(6)20,21,22,23,24,25,26,27,30,31,32,35,35,35,35,35,35,35
;*R50SIX - RAD50 (-11 STYLE) TO SIXBIT CONVERSION ROUTINE
;*
;*CALL WITH RADIX 50 (-11 STYLE) IN A
;*RETURN WITH 3 SIXBIT CHARACTERS IN RH OF A

R50SIX:	SETZM	T0		;INIT T0
	MOVE	C,[POINT 6,T0,17];POINT TO OUTPUT AC
	ANDI	A,177777	;MAKE SURE SIZE OK
	IDIVI	A,3100		;GET 1ST CHAR
	PUT	B		;SAVE OTHER 2 CHARS
	GO	R50OT1		;OUTPUT 1ST CHAR

	GET	A		;RESTORE 2 AND 3
	IDIVI	A,50		;SPLIT APART
	PUT	B		;SAVE LAST CHAR
	GO	R50OT1		;OUTPUT 2ND CHAR

	GET	A		;RESTORE 3RD CHAR
	GO	R50OT1		;OUTPUT LAST CHAR
	MOVE	A,T0		;COPY BACK TO A
	RTN			;EXIT

R50OT1:	IDIVI	A,6		;USUAL CODE CONVERSION
	LDB	D,R50OT2(B)	;GET CHAR IN SIXBIT
	IDPB	D,C		;PUT IN T0
	RTN			;AND RETURN IT

R50OT2:	POINT	6,R50TAB(A),5
	POINT	6,R50TAB(A),11
	POINT	6,R50TAB(A),17
	POINT	6,R50TAB(A),23
	POINT	6,R50TAB(A),29
	POINT	6,R50TAB(A),35

R50TAB:	SIXBIT	\ ABCDEFGHIJKLMNOPQRSTUVWXYZ$.%0123456789?\
SUBTTL	ROUTINE TO HANDLE END OF COMMAND PROCESSING
;	===========================================

;*WRITE OUT DIRECTORY, "KLADFE.DIR"

ENDALL:	SKIPN	DIRSW		;DIRECTORY IN CORE ?
	EXIT			;NO

	SETZM	$CCLF		;CLEAR INDIRECT FLAG

	MOVSI	T1,'DEV'	;SETUP DEVICE
	MOVEM	T1,O.DEV

	MOVE	T1,[SIXBIT/KLADFE/]
	MOVEM	T1,O.NAM1

	MOVE	T1,[SIXBIT/DIR/]
	MOVEM	T1,O.EXT

	SETZM	O.PPN

	MOVEI	T1,577		;SET PROTECTION 577
	MOVEM	T1,O.PRT

	MOVE	T1,DIRNCB	;GET # OF BLOCKS
	MOVEM	T1,S.ALO

	GO	ETER10		;ENTER FILE
	 JRST	EDIRER		;ERROR ENTERING DIRECTORY

	MOVE	T16,DIRNCB	;GET # OF BLOCKS
	IMULI	T16,^D16*^D8	;COMPUTE # OF WORDS
	MOVEI	T7,400000	;SETUP HI-CORE BASE ADDRESS

	MOVE	T3,(T7)		;GET DIRECTORY WORD
	GO	PUT10		;OUTPUT IT
	ADDI	T7,1		;ADVANCE TO NEXT WORD
	SOJG	T16,.-3		;LOOP TILL DONE

	CLOSE	WC,CL.DLL	;CLOSE WRITE CHANNEL
	RELEAS	WC,
;*GET DISK DIRECTORY ADDRESS, PUT IN HOME BLOCK

	GO	GETBK2			;GET 1ST BLOCK FROM -10

	GO	LOGPHY			;CONVERT TO PHYSICAL ADDRESS

	MOVEI	T7,HOMBUF		;GET ADDRESS OF HOME BLOCK
	MOVEI	T3,0

	DPB	T3,[POINT 7,WORD66(T7),17]
	DPB	T3,[POINT 3,WORD66(T7),27]
	DPB	T3,[POINT 3,WORD66(T7),30]

	MOVE	T3,CYLADD		;BITS 0-8 CYLINDER NUMBER
	DPB	T3,[POINT 10,WORD66(T7),17]

	MOVE	T3,TRKADD		;BITS 8-12 TRACK NUMBER
	DPB	T3,[POINT 5,WORD66(T7),27]

	MOVE	T3,SCTADD		;BITS 0-4 SECTOR NUMBER
	DPB	T3,[POINT 5,WORD66(T7),35]

	MOVE	T3,DIRNCB		;DIR NUMBER OF BLOCKS
	DPB	T3,[POINT 16,WORD67(T7),17]
;*WRITE OUT HOME BLOCK #1

	MOVEI	T3,HMBK01		;HOME BLOCK # 1
	GO	WRTHOM			;WRITE IT
	  JRST	WRTERR			;WRITE ERROR

;*HERE TO UPDATE AND WRITE OUT HOME BLOCK # 10

	MOVEI	T3,HMBK10		;GET BLOCK # FOR HOBK10
	SETZ	T1,
	MOVEI	T2,HOM
	DPB	T2,[POINTR(T1,SU.SCH)]	;CHANNEL NO.
	DPB	T3,[POINTR(T1,SU.SBL)]	;BLOCK NO.

	SUSET.	T1,
	  JRST	SUPERR			;SUSET. UUO ERROR

	IN	HOM,H10LST		;BRING IN HOME BLK #10
	JRST	NEXT			;READ OK

	  JRST	RADERR			;READ FAIL

NEXT:	MOVE	T1,[HOMBF1,,HOMBF2]
	BLT	T1,ENDHOM		;COPY HOMBK1 TO HOMB10
	MOVSI	T1,SU.SOT		;SET OUTPUT BIT
	MOVEI	T2,HOM
	DPB	T2,[POINTR(T1,SU.SCH)]	;CHANNEL NO.
	DPB	T3,[POINTR(T1,SU.SBL)]	;BLOCK NO.

	SUSET.	T1,
	  JRST	SUPERR

	OUT	HOM,H10LST		;OUTPUT HMBK10
	JRST	NEXT1			;WRITE OK

	  JRST	WRTERR			;WRITE FAIL

;*CLOSE ALL FILES AND GET OUT

NEXT1:	CLOSE	DIR,			;CLOSE DIR CHANNEL
	CLOSE	DAT,			;CLOSE DAT CHANNEL
	CLOSE	HOM,			;CLOSE HOM CHANNEL
	EXIT				;FINALLY !!!
SUBTTL	LIST FRONT-END DIRECTORY
;	========================

LSTDIR:	SKIPN	DIRSW		;SEE IF DIRECTORY EXISTS
	  JRST	DIRERR		;DOESN'T

	GO	PNTHDR		;PRINT HEADER

	MOVE	T5,DIRNCB	;# OF BLKS USED BY DIRECTORY
	IMULI	T5,^D16		;COMPUTE NUMBER OF ENTRIES
	MOVEI	T7,400000	;SETUP HI-CORE DIR BASE ADDRESS

	SETZM	ENTRYC#		;CLEAR ENTRY COUNTER
	SETZM	TOTALC#		;CLEAR TOTAL ALLOCATED
	SETZM	TOTWT#		;CLEAR TOTAL WRITTEN

SLOOP:	GO	PNTDIR		;PRINT ONE ENTRY

	ADDI	T7,HALF		;GET TO NEXT ENTRY
	SOJG	T5,SLOOP	;ALL ENTRIES SEARCHED ?
	SETZM	DIRSUM

	MOVEI	E,[ASCIZ/
F-E DIRECTORY SIZE	= /]
	GO	TYPE
	MOVE	A,DIRNCB
	IMULI	A,^D16
	GO	PTSIZE

	MOVEI	E,[ASCIZ/
TOTAL ENTRIES		= /]
	GO	TYPE
	MOVE	A,ENTRYC
	GO	PTSIZE

	MOVEI	E,[ASCIZ/
TOTAL ALLOCATED BLOCKS	= /]
	GO	TYPE
	MOVE	A,TOTALC
	GO	PTSIZE

	MOVEI	E,[ASCIZ/
TOTAL WRITTEN BLOCKS	= /]
	GO	TYPE
	MOVE	A,TOTWT
	GO	PTSIZE
	SETZB	0,A
	GO	PRINT

	JRST	SCAN		;YES, EXIT
;*PNTDIR -  PRINT ONE ENTRY FROM -11 DIRECTORY

PNTDIR:	LDB	A,[POINT 16,DIR0(T7),17] ;GET I.NAM1
	CAIE	A,0		;BLANK ENTRY ?
	CAIN	A,177776	;SKIP IF A IS NOT 177776
	RTN			;0 OR -2 MEANS ENTRY IS EMPTY

	AOS	A,ENTRYC
	GO	PTSIZE		;PRINT ENTRY COUNT
	GO	PNTTAB		;INSERT A TAB

	LDB	A,[POINT 16,DIR0(T7),17] ;GET I.NAM1
	GO	R50OUT		;GO CONVERT & PRINT

	LDB	A,[POINT 16,DIR0(T7),35] ;GET I.NAM2
	GO	R50OUT

	MOVEI	D,"."		;INSERT A DOT
	GO	TTYO

	LDB	A,[POINT 16,DIR1(T7),17] ;GET I.EXT
	GO	R50OUT
	GO	PNTTAB		;INSERT A TAB

	HRRZ	A,DIR3(T7)	;RH OF WD ALLOCATED
	HLRZ	C,DIR3(T7)	;LH OF WD ALLOCATED
	DPB	C,[POINT 16,A,19];RH+LH IN A
	IDIVI	A,^D256		;CONVERT IT INTO BLK #
	SKIPE	B		;EXACT ?
	ADDI	A,1		;NO, ROUND UP
	ADDM	A,TOTALC	;ADD TO TOTAL
	GO	PTSIZE		;GO PRINT SIZE
	GO	PNTTAB		;INSERT A TAB

	HRRZ	A,DIR4(T7)	;RH OF WD WRITTEN
	HLRZ	C,DIR4(T7)	;LH OF WD WRITTEN
	DPB	C,[POINT 16,A,19];RH+LH IN A
	IDIVI	A,^D256		;CONVERT IT INTO BLK #
	SKIPE	B		;EXACT ?
	ADDI	A,1		;NO, ROUND UP
	ADDM	A,TOTWT		;ADD TO TOTAL
	GO	PTSIZE		;GO PRINT SIZE
	GO	PNTTAB		;INSERT A TAB

	LDB	T1,[POINT 16,DIR1(T7),35] ;GET DATE
	GO	PTDATE		;PRINT DATE

	SETZB	0,A		;ZERO A
	GO	PRINT		;INSERT CR, LF
	RTN			;RETURN
;*DO THE CONVERSION AND PRINT

R50OUT:	JUMPE	A,PRTNAM	;IF A = 0, PRINT 3 SPACES
	CAIN	A,177776	;SKIP IF A IS NOT 177776
	RTN			;DON'T PRINT IF A IS 177776 OR 0

	GO	R50SIX		;CONVERT R50 TO SIXBIT

PRTNAM:	MOVE	B,[POINT 6,A,17];TYPE JUST RH OF A

LEFT:	ILDB	D,B
	ADDI	D,40
	GO	TTYO		;PRINT

	TLNE	B,770000
	JRST	LEFT

	RTN	

;*PRINT FILE SIZE IN TERMS OF BLOCK #

PTSIZE:	CAIGE	A,^D100		;> 100 ?
	GO	SPACE		;NO

	CAIGE	A,^D10		;> 10 ?
	GO	SPACE		;NO

	JRST	DECPT1

DECPT2:	CAIG	A,11
	GO	ZEROUT		;OUTPUT ZERO

DECPT1:	MOVEI	D,12
	MOVEM	D,RADIX		;SAVE IT AS DIVIDEND

OLOOP:	IDIV	A,RADIX
	HRLM	B,0(P)		;SAVE REMAINDER
	SKIPE	A		;EXACT ?
	GO	OLOOP		;NO

	HLRZ	D,0(P)		;GET REMAINDER
	ADDI	D,"0"
	JRST	TTYO		;GO PRINT IT

ZEROUT:	MOVEI	D,"0"		;OUTPUT ZERO
	JRST	TTYO
;*PRINT DATE IN THE FORM OF DD-MON-YR

PTDATE:	JUMPG	T1,DATE1	;DATE FIELD BLANK ?

NODATE:	RTN			;NO DATE

DATE1:	PUT	T3		;SAVE DATE
	IDIVI	T1,^D31		;GET DAY OF YEAR
	MOVEI	A,1(T2)		;SAVE REMAINDER
	GO	DECPT2		;GO PRINT

	IDIVI	T1,^D12		;GET MONTH OF YEAR
	MOVE	A,MONTAB(T2)	;GET MONTH FROM TABLE
	MOVEI	B,0
	MOVEI	E,A		;SAVE IT IN E
	GO	PNTMON		;PRINT MONTH

	MOVEI	A,^D64(T1)	;GET YEAR
	CAIL	A,^D100		;GET YEAR IN CENTURY
	SUBI	A,^D100
	GO	DECPT2		;PRINT YEAR AND RETURN

	GET	T3
	RTN			;EXIT

MONTAB:	ASCII	/-JAN--FEB--MAR--APR--MAY--JUN-/
	ASCII	/-JUL--AUG--SEP--OCT--NOV--DEC-/
;*PRINT FRONT-END DIRECTORY TO TTY

PNTHDR:	MOVEI	A,[ASCIZ /
FRONT-END DIRECTORY

ENTRY	FILE   EXT	ALLOCB	WRTB	DATE
/]
	GO	PRINT		;DO PRINT

	RTN			;RETURN

;*PRINT MONTH

TYPE:
PNTMON:	TLOA	E,(POINT 7,)	;CONVERT TO BYTE POINTER

PNTM:	GO	TTYO		;OUTPUT CHARACTER
	ILDB	D,E		;GET NEXT CHARACTER
	JUMPN	D,PNTM		;LOOP UNLESS NULL

	RTN			;ALL DONE

;*THE ACTUAL PRINT ROUTINE TO SEND MESSAGE TO TTY

PRINT:	SETZM	PRNTSW		;INIT PRINT SW
	HRLI	A,440700	;INIT A

PRINTT:	ILDB	D,A		;GET ONE CHARACTER
	JUMPE	D,CRLF		;IF NULL, PROMPT WITH CR/LF

	GO	TTYO		;OUTPUT CHARACTER

	JRST	PRINTT		;CONTINUE

CRLF:	SKIPE	PRNTSW		;CRLF PROMPTED ?
	RTN			;YES, EXIT

	SETOM	PRNTSW		;SET PRINT SW
	MOVEI	A,[ASCIZ /
/]				;THIS IS CR, LF
	HRLI	A,440700
	JRST	PRINTT		;PRINT CR,LF

PNTTAB:	MOVEI	D,"	"	;PRINT A TAB
	JRST	TTYO
SPACE2:	GO	SPACE		;OUTPUT 2 SPACES
SPACE:	MOVEI	D," "		;OUTPUT 1 SPACE

TTYO:	SKIPN	DIRSUM
	TTCALL	1,D		;OUTPUT 1 CHARACTER
	RTN			;RETURN
SUBTTL	COMMON ERROR ROUTINE
;	====================

CTRERR:	MOVEI	[ASCIZ	"?NOT AN RP04/RP06 CONTROLLER"]
	JRST	ABORT

DEVERR:	MOVEI	[ASCIZ	"?DEVICE SELECTION ERROR"]
	JRST	ABORT

HOMERR:	MOVEI	[ASCIZ	"?TOPS-10 HOME BLOCK NOT FOUND"]
	JRST	ABORT

SUPERR:	MOVEI	[ASCIZ	"?SUSET. UUO FAILURE"]
	JRST	ABORT

THRERR:	MOVEI	[ASCIZ	"?EXCEEDING FRONT-END DIRECTORY SIZE (1500 IN DECIMAL)"]
	JRST	ABORT

DIRERR:	MOVEI	[ASCIZ	"?FRONT-END DIRECTORY DOES NOT EXIST"]
	JRST	ABORT

ERRCOR:	MOVEI	[ASCIZ	"?CAN'T GET HI-CORE FOR DIRECTORY"]
	JRST	ABORT

EDIRER:	MOVEI	[ASCIZ	"?ERROR CREATING DIRECTORY FILE"]
	EXIT

ABORT:	TTCALL	13,0		;CLEAR ^O
	JFCL
	OUTSTR	[ASCIZ/
/]
	OUTSTR	@0
	OUTSTR	[ASCIZ/
/]
	GO	CMDPNT		;PRINT ERRONEOUS COMMAND LINE
	EXIT
WRTERR:	MOVEI	[ASCIZ	"%ERROR WRITING FILE"]
	JRST	WHTFIL
RADERR:	MOVEI	[ASCIZ	"%ERROR READING FILE"]
	JRST	WHTFIL
DELERR:	MOVEI	[ASCIZ	"%ERROR DELETING FILE"]
	JRST	WHTFIL
ILLSW:	MOVEI	[ASCIZ	"%ILLEGAL SWITCH COMBINATION"]
	JRST	WHTFIL
OPNERR:	MOVEI	[ASCIZ	"%CANNOT OPEN FILE"]
	JRST	WHTFIL
FLSPER:	MOVEI	[ASCIZ	"%FILE NAME NOT SPECIFIED"]
	JRST	WHTFIL
LUKERR:	MOVEI	[ASCIZ	"%CANNOT FIND FILE"]
	JRST	WHTFIL
ENTERR:	MOVEI	[ASCIZ	"%ERROR ENTERING FILE"]
	JRST	WHTFIL
NOFL10:	MOVEI	[ASCIZ	"%NON-EXISTENT FILE IN TOPS-10 DIRECTORY:"]
	JRST	WHTFIL
NOFL11:	MOVEI	[ASCIZ	"%NON-EXISTENT FILE IN FRONT-END DIRECTORY:"]
	JRST	WHTFIL
DIRFUL:	MOVEI	[ASCIZ	"%FRONT-END DIRECTORY IS FULL"]
	JRST	WHTFIL
WHTFIL:	TTCALL	13,0		;CLEAR ^O
	JFCL
	OUTSTR	[ASCIZ/
/]
	OUTSTR	@0		;PRINT ERROR MESSAGE
	OUTSTR	[ASCIZ/
/]
	SKIPE	EOLSW		;COMPLETED INPUT LINE ?
	JRST	.+3		;YES
	GO	TTYIN		;NO, READ REST OF BAD LINE
	JRST	.-3

	GO	CMDPNT		;PRINT ERRONEOUS COMMAND LINE
	JRST	SCAN

CMDPNT:	MOVE	A,CMDCNT	;PRINT COMMAND LINE COUNT
	GO	PTSIZE

	GO	PNTTAB

	MOVEI	A,CMDBUF	;PRINT COMMAND LINE
	GO	PRINT
	RTN

KEYERR:	MOVEI	[ASCIZ	"%KEYWORD ERROR OR SWITCH MISSING"]
	JRST	WHTFIL

MSGERR:	MOVEI	[ASCIZ	"%ILLEGAL TO CLOBBER FRONT-END FILES WITH /TO10 SWITCH"]
	JRST	WHTFIL

	END	KLAD10
 