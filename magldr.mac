SUBTTL	DEVICE SELECTION

OPDEF	TTSIXB	[PUSHJ P,TTYSXB]
OPDEF	TAPOP.	[CALLI 154]

TAB=	17000			;DIRECTORY STORAGE

;*DEVSEL - ASK WHICH DEVICE

DEVSEL:	SETOM	MAGDEV#			;SET MAGTAPE DEVICE FLAG
	MOVEI	-1			;SET MAGTAPE POSITION FLAG
	MOVEM	MAGONCE#		;TO TAPE POSITION UNKNOWN
	SETZM	TAB+1			;MARK DIRECTORY EMPTY
	SKIPN	USER			;SKIP IF USER MODE
	JRST	EXECDV			;NO
	PMSG	<^DEV:(CR FOR DSK) - >
	TTSIXB				;INPUT DEVICE NAME
	JRST	.-3			;ASK AGAIN
	JUMPN	LET,USRMAG		;IF NAME TYPED, MUST BE A MAGTAPE
	SETZM	MAGDEV			;CLEAR MAGTAPE DEVICE FLAG
	MOVSI	'DSK'			;SET UP DEVICE AS DSK
	MOVEM	LDBLK+1			;PUT IN OPEN INFO BLOCK
	MOVE	[201,,LDBF1+1]		;SET UP DATA BUFFER
	MOVEM	LDBF+1			;IN A RING OF THREE BUFFERS
	HRRI	LDBF2+1
	MOVEM	LDBF1+1
	HRRI	LDBF+1
	MOVEM	LDBF2+1
	MOVEI	UREADB			;SET UP READ BLOCK DISPATCH
	MOVEM	READBL			;TO USER MODE READ ROUTINE
	RTN
;*USRMAG - SELECT USER MODE MAGTAPE DEVICE OR DISK

USRMAG:	MOVEM	LET,LDBLK+1		;PUT NAME IN LDBLK
	OPEN	LDCHN,LDBLK		;OPEN DEVICE
	JRST	DEVSEL			;DEVICE NOT AVAILABLE
	MOVEI	LDCHN			;GET CHANNEL NUMBER
	MTCHR.				;READ CHARACTERISTICS OF DEVICE
	JRST	DEVSEL			;DEVICE NOT A MAGNETIC TAPE
	MOVEI	3			;GET CODE FOR 800 BPI
	MOVEM	TAPEDC			;STORE IT
	TRNE	1B31			;CHECK IF 7-TRACK
	JRST	DEN800			;7-TRACK, MUST BE 800 BPI
	MOVE	[XWD 2,[1002		;READ CONTROLLER TYPE CODE
			LDCHN ]]	;  FOR MAGTAPE
	TAPOP.				;OBTAIN THE CODE
	JRST	WHDEN			;ERROR, ASK ANYWAY
	JUMPL	WHDEN			;IF NEGATIVE, ASK FOR DENSITY
	CAIG	3			;IF TM10, DENSITY MUST BE 800
					;IF DX10, DON'T CARE ABOUT DENSITY
	JRST	DEN800			;DON'T ASK
WHDEN:	GO	ASKDEN			;ASK WHICH DENSITY
	AOS	TAPEDC			;SET DENSITY CODE TO 1600 BPI
DEN800:	RELEASE LDCHN,			;RELEASE THE CHANNEL
	MOVE	[MAGRCD+1,,LDBF+1]	;SET UP USER BUFFER
	MOVEM	LDBF+1			; A RING OF ONLY ONE BUFFER
	MOVE	[[EXP UREADB,UREVRS,UFORWD,UREW],,READBL]	;LOAD
	BLT	REW			;DISPATCH LOCATIONS FOR USER ROUTINES
	RTN				;RETURN

ASKDEN:	PMSG	<1600 BPI ? - >
	GO	TT2CHR			;LOOK FOR YES ANSWER
	JRST	.+2			;CARRIAGE RETURN ONLY
	CAIE	"Y"			;SKIP IF Y TYPED
	AOS	(P)			;CAUSE SKIP RETURN
	RTN
;*EXECDV - EXEC MODE DEVICE NAME INPUT

EXECDV:	PMSG	<DEV:T,D,R,M - >
	TTSIXB				;INPUT DEVICE NAME
	JRST	EXECDV			;ASK AGAIN
	JUMPE	LET,EXECDV		;ASK AGAIN IF NO NAME TYPED
	MOVE	C,[POINT 6,LET]		;GET BYTE POINTER TO NAME
	ILDB	A,C			;GET CONTROLLER TYPE CODE
	SETZ	B,			;SET DEVICE CODE TO ZERO
EXECDI:	ILDB	C			;GET NEXT CHARACTER
	JUMPE	EXECDC			;DECODE NUMBER IF NO MORE
	CAIL	'0'			;CHECK IF OCTAL
	CAILE	'7'			;  NUMBER
	JRST	EXECDV			;NO, ERROR
	LSH	B,3			;MAKE ROOM FOR IT
	DPB	[POINT 3,B,35]		;PUT IT IN B
	TLNN	C,700000		;GET 5 CHARACTERS ALREADY?
	JRST	EXECDV			;YES, ERROR
	JRST	EXECDI			;NO, GET ANOTHER
EXECDC:	CAIGE	B,20			;CHECK IF NUMBER 20 OR
	JRST	.+3			;  GREATER
	TRNE	B,3			;YES, IS LAST DIGIT 0 OR 4?
	JRST	EXECDV			;NO, NOT A DEVICE CODE
	SETZM	DX10			;CLEAR DX10 FLAG
	CAIN	A,'T'			;IF CONTROLLER TYPE T
	JRST	TMDEV			;  TM10
	CAIN	A,'D'			;IF D
	JRST	DXDEV			;  DX10
	CAIN	A,'R'			;IF R
	JRST	RH10DV			;  RH10
	CAIN	A,'M'			;IF M
	JRST	RH20DV			;  RH20
	JRST	EXECDV			;ERROR
;*TTSIXB - INPUT SIXBIT WORD

TTYSXB:	SETZ	LET,			;CLEAR LETTER AC
	TTICHR				;INPUT ONE CHARACTER
	CAIN	12			;RETURN +2 IF CARRIAGE RETURN
	JRST	TTYSXX
	CAIL	"0"			;CHECK IF CHARACTER
	CAILE	"Z"			;  IS A LETTER OR DIGIT
	RTN				;NO
	CAIG	"9"			;KEEP CHECKING
	JRST	.+3
	CAIGE	"A"
	RTN
	TLNE	LET,770000		;SIX CHARACTERS ALREADY INPUT?
	RTN				;YES, GIVE ERROR RETURN
	SUBI	40			;CONVERT TO SIXBIT
	LSH	LET,6			;SHIFT PREVIOUS LETTERS
	ORM	LET			;OR WITH THIS LETTER
	JRST	TTYSXB+1		;GET NEXT
TTYSXX:	JUMPE	LET,CPOPJ1		;RETURN NOW IF NO LETTERS TYPED
	TLNE	LET,770000		;LEFT JUSTIFY INPUT LETTERS
	JRST	CPOPJ1			;RETURN +2
	LSH	LET,6			;SHIFT LEFT
	JRST	TTYSXX			;CHECK AGAIN


UNIT:	PMSG	<UNIT # - >
	TTIOCT				;GET UNIT NUMBER
	JRST	EXECDV			;ERROR
	RTN
;*LIST1 - LIST FILES

LIST1:	SETOM	LSTFLG
	JRST	RUNPRG

;*DIRECT - PRINT DIRECTORY

DIRECT:	SKIPN	MAGDEV			;ILLEGAL FOR DSK
	JRST	SELECT
	SETOM	PGMGO			;SET LOAD AND GO FLAG
	SWITCH
	TLNE	LPTSW
	SETOM	LPTFLG
	GO	DTECLR
	MOVEI	IP,[SIXBIT/MAGTAP/
		    SIXBIT/MTA/]	;SET UP DIRECTORY NAME
	SETOM	DIRFLG			;SET PRINTING DIRECTORY FLAG
	GO	DIAGLD			;SET UP THE FILE
	JRST	SELECT			;FILE NOT FOUND
DIRPNT:	GO	RWORD			;READ FIRST WORD OF FILE
	JRST	SELECT			;NO WORDS IN FILE
DIRLIN:	GO	CRLF1			;PRINT A CARRIAGE RETURN, LINE FEED
	MOVEI	M,4			;SET UP ENTRIES PER LINE COUNTER
	SKIPE	LPTFLG			;SKIP IF OUTPUTTING TO LINE PRINTER
	MOVEI	M,8			;YES, SET COUNT TO 8
DIRFIL:	GO	RWORD			;READ FILE NAME
	JRST	DIREND			;END OF FILE
	TLNN	W,770000		;CHECK IF A FILE NAME
	JRST	DIRRCD			;NO, MUST BE END OF RECORD
	MOVE	A,W			;MOVE WORD TO A
	GO	SIXBP			;PRINT IT
	GO	PNTTAB			;PRINT A TAB
	GO	RWORD			;READ EXTENSION
	JRST	DIREND			;END OF FILE
	HLLZ	A,W			;MOVE WORD TO A
	GO	SIXBP			;PRINT IT
	GO	RWORD			;READ NEXT WORD
	JRST	DIREND			;END OF FILE
	SOJLE	M,DIRLIN		;END OF LINE?
	GO	PNTTAB			;NO, PRINT A TAB
	JRST	DIRFIL			;PRINT NEXT FILE NAME
DIREND:	GO	CRLF1			;END THE LINE
	JRST	SELECT			;END OF DIRECTORY
DIRRCD:	TLNE	W,-1			;ABSOLUTE END OF DIRECTORY FILE?
	JRST	DIREND			;YES
	GO	RWORD			;NO, READ HEADER WORD FROM NEXT RECORD
	JRST	DIREND			;END OF FILE
	JRST	DIRFIL			;PRINT THIS FILE NAME
SUBTTL	PROGRAM FILE SELECTION

;*FSELECT - "SUBRTN" FILE SELECTION

FSELECT:SETOM	SPECIAL#		;SET SPECIAL MODE
	SETZM	NOCMNT
	MOVEM	0,IP			;SET POINTER TO FILE SPEC
	JRST	DIAGLD+2

;*DIAGLD - "DIAMON" FILE SELECTION

	SETOM	NOFNF#			;SET DON'T REPORT IF CAN'T FIND
	SETOM	NOCMNT
	JRST	.+6
	SETOM	NOCMNT#			;INHIBIT COMMENT PRINTING
	JRST	.+2
DIAGLD:	SETZM	NOCMNT
	SETZM	SPECIAL			;SET NORMAL MODE
	SETZM	NOFNF
	SETZM	A10FLG#
	SETZM	LDEVICE#

	HLRZ	0,1(IP)
	CAIN	0,(SIXBIT/A10/)
	SETOM	A10FLG

DIAGLA:	SKIPE	USER			;SKIP IF EXEC MODE
	JRST	USERLD			;LOAD FROM DSK

	SKIPN	KLFLG
	JRST	EXECLD			;NOT A KL10
	MOVE	[540026,,540027]	;SET MAGMON BUFFERS UNCACHED
	MOVEM	613
	MOVEI	540025
	HRRM	612

	CONI	PAG,0			;READ PAGING SYSTEM
	TRO	TRPENB			;SET TRAP ENABLE
	CONO	PAG,@0			;RESET PAGING SYSTEM
	JRST	EXECLD			;LOAD EXEC

STOP:	RTN				;NO ACTION NEEDED TO STOP A MAGTAPE
;*RFILE - FILE FOUND AND SETUP

RFILE:	SETZM	Q			;CLEAR FILE READ WORD COUNTER
	MOVEI	M,5			;SET LDACHR BYTE COUNTER
	SETOM	FBSAV#			;SET 8 BIT READ FILE BYTE COUNTER
	MOVEM	13,SAV13#
	MOVEM	14,SAV14#
	SKIPN	SPECIAL			;FILE FOUND
	JRST	RFILE1			;NORMAL OPERATION

;*FSELF - "SUBRTN" FILE FOUND RETURN

FSELF:	MOVEM	0,ACSAVE		;SAVE ACS
	MOVE	0,[1,,ACSAVE+1]
	BLT	ACSAVE+16
	MOVE	0,LDEVICE		;RETURN DEVICE TYPE
	AOS	(P)
	RTN				;SKIP RETURN TO "SUBRTN"

;*NFERR - FILE NOT FOUND

NFERR:	SKIPE	NOFNF			;REPORT NOT FOUND ?
	RTN				;NO
	SKIPN	SPECIAL			;NOT FOUND
	JRST	NFERR1			;NORMAL OPERATION

;*FSELNF - "SUBRTN" FILE NOT FOUND

FSELNF:	MOVE	0,LDEVICE		;"FSELECT" - NOT FOUND
	RTN				;NON-SKIP, ERROR RETURN
SUBTTL	"SUBRTN" PROGRAM FILE READ

;*FREAD - DETERMINE READ TYPE

FREAD:	MOVEM	0,FRDTYP#
	MOVS	[1,,ACSAVE+1]
	BLT	16			;RESTORE "DIAMON" ACS
	MOVE	ACSAVE
	SKIPGE	FRDTYP
	JRST	FRD36			;READ 36 BIT WORDS
	SKIPE	FRDTYP
	JRST	FRD8			;READ 8 BIT WORDS

;*FREAD3 - CHARACTER READ

FREAD3:	GO	LDACHR			;LOAD AN ASCII CHARACTER
	JRST	FREAD2			;EOF

FREAD1:	MOVEM	0,ACSAVE		;RESAVE "DIAMON" ACS
	MOVE	0,[1,,ACSAVE+1]
	BLT	ACSAVE+16

	MOVE	0,16			;PUT ASCII BYTE IN AC0
	AOS	(P)
	RTN				;SKIP RETURN

;*FREAD2 - END OF FILE

FREAD2:	SETZM	0			;EOF CODE = 0
	RTN				;NON-SKIP RETURN

;*FRD36 - 36 BIT WORD READ

FRD36:	GO	RWORD			;READ 36 BIT WORDS
	JRST	FREAD2			;EOF
	MOVE	16,W			;PUT 36 BIT WORD IN AC16
	JRST	FREAD1			;REST AS ABOVE
;*LDACHR - ASCII CHARACTER PROCESS

LDACHR:	CAIE	M,5			;USED ALL OF THIS 36 BIT WORD ?
	JRST	LDACH1			;NOT YET
	SETZM	M			;YES, READ NEXT 36 BIT WORD
	EXCH	13,SAV13
	EXCH	14,SAV14
	GO	RWORD
	JRST	LDAEOF			;EOF
	EXCH	13,SAV13
	EXCH	14,SAV14

LDACH1:	LDB	16,[POINT 7,W,6
		POINT 7,W,13
		POINT 7,W,20
		POINT 7,W,27
		POINT 7,W,34](M)	;GET ASCII BYTE
	AOS	M			;COUNT IT
LDACH2:	JUMPE	16,LDACHR		;IF NULL, IGNORE
	AOS	(P)			;SKIP RETURN
	RTN

LDAEOF:	EXCH	13,SAV13
	EXCH	14,SAV14
	RTN
;*FRD8 - 8 BIT WORD READ

FRD8:	GO	G8BYT			;GET AN 8 BIT BYTE
	JRST	FREAD2			;EOF
	JRST	FREAD1			;8 BIT BYTE IN AC16

G8BYT:	AOS	M,FBSAV			;ADVANCE FILE BYTE
	ANDI	M,3			;(MOD 4)
	JUMPN	M,G8BY2			;NEED A NEW WORD ?

	GO	RWORD			;YES
	RTN				;EOF

G8BY1:	MOVEM	W,BYTSAV#		;SAVE WORD

G8BY2:	LDB	16,[POINT 8,BYTSAV,17
		    POINT 8,BYTSAV,9
		    POINT 8,BYTSAV,35
		    POINT 8,BYTSAV,27](M)
	JRST	CPOPJ1			;LOAD & SKIP RETURN WITH BYTE
SUBTTL	LDA10 - LOAD PDP-10 ASCIIZED ".A10" FILE

;*PDPROC - FORMAT CONTROL PROCESS

LDA10:
LDPROC:	SETZM	LDOCTF#
	SETZM	LDZBLK#

	GO	LDACHR			;GET FILE TYPE CHAR
	GO	LERR2			;EOF
	CAIN	16,";"
	JRST	LDCMNT			;LINE STARTS WITH ;, COMMENT

	SETZM	LDTBLK#
	CAIN	16,"A"			;A, PDP-10 SUPER A10 FILE
	JRST	.+6
	CAIN	16,"T"			;T, PDP-10 ".A10" FILE
	JRST	[SETOM	LDTBLK
		 JRST	.+4]
	CAIE	16,"Z"			;Z, ".A10" CORE ZERO
	GO	LERR3
	SETOM	LDZBLK

	GO	LDACHR			;GET FORMAT CHAR
	GO	LERR2			;EOF

	CAIN	16," "			;SPACE, ASCIIZED
	JRST	.+4
	CAIE	16,"O"			;O, OCTAL
	GO	LERR4
	SETOM	LDOCTF

	MOVE	16,[LDCNT,,LDCNT+1]
	SETZM	LDCNT
	BLT	16,LDATAE		;CLEAR LOAD STORAGE

	MOVEI	13,LDCNT		;SETUP CONVERTED STORAGE POINTER
;*LDCNV - CONVERT ASCIIZED BACK INTO BITS

LDCNV:	SETZM	14			;CLEAR CONVERTED WORD FORMER

LDCNV1:	GO	LDACHR			;LOAD AN ASCII CHAR
	GO	LERR2			;EOF

	CAIN	16,15			;CR, IGNORE
	JRST	LDCNV1

	CAIN	16,12			;LF, END OF LINE
	JRST	LDEOL

	CAIN	16,54			;COMMA, FIELD SEPARATOR
	JRST	LDCMA

	SKIPE	LDOCTF
	JRST	LDCNV3			;LOADING OCTAL FORMAT

	CAIL	16,"5"		;5 TO : ?
	CAILE	16,":"
	JRST	.+6		;NO
	SUBI	16,"5"		;YES, INSERT SUPPRESSED ONES
	LSH	14,6
	TRO	14,77
	SOJGE	16,.-2
	JRST	LDCNV1

	CAIL	16,"0"		;0 TO 4 ?
	CAILE	16,"4"
	JRST	.+5		;NO
	ANDI	16,7		;YES, INSERT SUPPRESSED ZEROS
	LSH	14,6
	SOJGE	16,.-1
	JRST	LDCNV1

	LSH	14,6			;SHIFT WORD FORMER LEFT 6
	ANDI	16,77			;KEEP ASCIIZED OIT BITS

LDCNV2:	OR	14,16			;INSERT NEW OIT
	JRST	LDCNV1

LDCNV3:	LSH	14,3			;SHIFT WORD FORMER LEFT 3, OCTAL
	ANDI	16,7			;KEEP OCTAL OIT BITS
	JRST	LDCNV2

LDCMA:	MOVEM	14,(13)			;STORE CONVERTED WORD
	AOJA	13,LDCNV		;COUNT AND GO FOR NEXT WORD
;*LDEOL - END OF LINE, CHECKSUM LOAD LINE

LDEOL:	MOVEM	14,(13)			;STORE CHECKSUM

	SKIPE	LDOCTF
	JRST	LDTEN			;OCTAL, NO CHECKSUM

	MOVEI	13,LDCNT		;CHECKSUM LOAD STORAGE
	SETZM	14
	ADD	14,(13)
	CAIE	13,LDATAE
	AOJA	13,.-2

	TRNE	14,177777		;16 BIT CHECKSUM = 0 ?
	GO	LERR5			;NO, CHECKSUM ERROR

;*LDTEN - CREATE LOAD ADDRESS AND WORD COUNT

LDTEN:	LDB	13,[POINT 2,LDCNT,27]
	LSH	13,^D16
	OR	13,LDADR		;CREATE PDP-10 LOAD ADDRESS

	LDB	14,[POINT 8,LDCNT,35]	;WORD COUNT

	SKIPN	LDZBLK
	JRST	LDTEN1			;LOAD TEN DATA WORDS

;*LDTENZ - CLEAR TEN CORE, JOB START TO JOB FIRST FREE

LDTENZ:	JUMPE	14,LDPROC		;WC=0, NO ZEROING
	MOVEM	13,JOBSAW		;SETUP JOB START ADDRESS
	ADD	13,LDATA-1(14)
	SOJG	14,.-1			;ADD UP ZERO COUNT
	MOVEM	13,JOBFFW		;SETUP JOB FIRST FREE ADDRESS

	GO	CLRCOR			;CLEAR PDP-10 CORE
	JRST	LDPROC
;*LDTEN1 - TRANSFER TEN WORDS TO MEMORY

LDTEN1:	SKIPN	LDTBLK
	MOVE	13,LDADR
	JUMPE	14,LDDONE		;WC=0, TRANSFER BLOCK

	MOVEI	15,LDATA		;SETUP PICKUP POINTER

LDTEN2:	MOVE	16,(15)			;GET 36 BIT WORD
	SKIPN	LDTBLK
	JRST	.+6
	MOVE	16,2(15)		;BITS 0 TO 7
	LSH	16,^D16
	OR	16,1(15)		;BITS 8 TO 23
	LSH	16,^D16
	OR	16,0(15)		;BITS 24 TO 35

	MOVEM	16,(13)			;STORE 36 BIT WORD IN MEMORY

	AOS	13			;INCREMENT PDP-10 ADDRESS
	ADDI	15,1			;BUMP PICKUP POINTER
	SKIPE	LDTBLK
	ADDI	15,2
	SUBI	14,1			;DECREMENT WORD COUNT
	SKIPE	LDTBLK
	SUBI	14,2
	JUMPG	14,LDTEN2		;DO TILL ALL WORDS USED
	JRST	LDPROC			;CONTINUE TILL TRANSFER BLOCK

;*LDDONE - COMPLETED, GO TO START ROUTINE

LDDONE:	MOVE	W,13			;SETUP START ADDRESS
	JRST	STARTQ			;GO TO START ROUTINE
;*LDCMNT - LOAD FILE COMMENT LINE

LDCMNT:	PUT	0
	GO	CMNPNT			;PRINT REST OF COMMENT LINE
	GET	0
	JRST	LDPROC

;*CMNPNT - PRINT COMMENT LINE

CMNPNT:	GO	LDACHR
	JRST	LERR2
	CAIN	16,12			;LINE FEED ?
	JRST	.+4			;YES
	SKIPN	NOCMNT
	GO	PNT16			;PRINT COMMENT LINE
	JRST	CMNPNT

	SKIPN	NOCMNT
	GO	PNT16
	RTN
SUBTTL	PROGRAM CORE AREA SETUP

T0=4					;W
T1=5					;Q
T2=7					;M
T3=6					;N
T4=3					;C

;*PRGCOR - SETUP CORE ZEROING FOR ".SAV" FILES

PRGCOR:	SKIPE	A10FLG
	JRST	LDA10			;LOAD ".A10" FILE

	SETZM	Q
	GO	RWORD			;READ FIRST BLOCK/WORD
	GO	ERR2			;EOF, ILLEGAL

	MOVEM	T0,SAVT0#
	MOVEM	T1,SAVT1#
	MOVEM	T2,SAVT2#
	MOVEM	T3,SAVT3#
	MOVEM	T4,SAVT4#

	SKIPL	T0
	GO	ERR6			;FIRST WORD NOT POINTER
	MOVEI	T2,^D126(T0)
	MOVEI	T3,137			;FIRST POINTER LEGAL ?
	CAMGE	T2,T3
	GO	ERR6			;NO

	HRRZ	T1,SAVT1
	MOVEI	T3,JOBSA
	GO	RMS1			;GET 'JOBSA'
	HRRZM	T0,JOBSAW#
	SKIPN	T1,JOBSAW	
	GO	ERR7			;NO STARTING ADDRESS
	CAIN	T1,140
	GO	ERR7			;PROGRAMS CAN'T START AT 140

	HRRZ	T1,SAVT1
	MOVEI	T3,JOBFF
	GO	RMS1			;GET 'JOBFF'
	MOVEM	T0,JOBFFW#

	GO	CLRCOR			;CLEAR PROGRAM'S CORE AREA
	MOVE	T0,SAVT0
	MOVE	T1,SAVT1
	MOVE	T2,SAVT2
	MOVE	T3,SAVT3
	MOVE	T4,SAVT4
	JRST	RFILL3			;NOW GO LOAD PROGRAM

RMS2:	SUB	T1,T4
	AOJ	T1,
RMS1:	MOVE	T0,(T1)			;GET POINTER
	HRRZ	T2,T0			; X
	HLRO	T4,T0			; -N
	SUB	T2,T4			; X+N IN T2
	CAMGE	T2,T3			;THIS POINTER TO REQ DATA ?
	JRST	RMS2			;NO, GET NEXT POINTER
	SUBI	T3,(T0)			;YES, HOW FAR FROM POINTER ?
	ADD	T1,T3			;INCREMENT POINTER
	MOVE	T0,(T1)			;GET REQ DATA
	RTN

;*CLRCOR - CLEAR CORE FOR DIAGNOSTIC SEGMENT
;*	   CLEARS CORE FROM 'JOBSA' TO 'JOBFF'

CLRCOR:	SKIPN	USER			;USER MODE ?
	JRST	CLRCR1			;NO
	MOVE	JOBREL			;YES, PRESENT JOBREL LT DIAMON'S ?
	CAMG	SVJBREL
	JRST	.+4			;YES
	MOVE	SVJBREL			;NO, REDUCE CORE TO DIAMON'S
	CORE
	JRST	ERR10
	MOVE	JOBFFW			;THIS PRG NEED MORE THAN DIAMON'S ?
	CAMG	SVJBREL
	JRST	.+3			;NO
	CORE				;YES, EXPAND CORE FOR PROGRAM
	JRST	ERR10
CLRCR1:	MOVEM	Q,SAVQ#
	MOVE	Q,JOBSAW
	CAIL	Q,START			;DO NOT, REPEAT NOT, CLEAR "DIAMON" !
	CAIL	Q,DIAGNOS
	SETZM	(Q)
	CAMGE	Q,JOBFFW
	AOJA	Q,.-4
	MOVE	Q,SAVQ
	RTN
;*LSTPNT - LIST FILES (ASCIZ)

LSTPNT:	SETOM	SPECIAL
	PUSH	P,0
	SWITCH
	TLNE	LPTSW
	SETOM	LPTFLG
	GO	DTECLR
	POP	P,0
LSTPN1:	GO	LDACHR			;READ A CHAR
	JRST	START			;EOF
	GO	PNT16			;PRINT IT
	JRST	LSTPN1


;*RFILE1 - HERE WHEN FILE FOUND

RFILE1:	SKIPE	LSTFLG
	JRST	LSTPNT			;LISTING FILE
	SKIPE	DIRFLG			;PRINTING DIRECTORY?
	JRST	DIRPNT			;YES, PRINT DIR OF MAGTAPE

	SKIPE	DEVFLG			;READING CMD LIST FILE ?
	JRST	DEVCM2			;YES
	JRST	PRGCOR			;SETUP PROGRAM'S CORE AREA

RFILL1:	GO	RWORD			;READ POINTER OR TRANSFER WORD
	GO	ERR2			;EOF, ERROR
RFILL3:	SKIPL	M,W			;WHICH IS IT?
	JRST	STARTQ			;TRANSFER WORD
RFILL2: GO	RWORD			;READ DATA WORD
	GO	ERR2			;EOF, ERROR
	MOVEM	W,1(M)			;STORE IT IN CORE
	AOBJN	M,RFILL2		;COUNT THE CORE POINTER
	JRST	RFILL1			;IT RAN OUT, GET ANOTHER

;*RWORD - READ DATA WORD FROM FILE

RWORD:	SOSLE	LDBUF+2			;CHECK IF ANY WORDS IN BUFFER
	JRST	RWORD2			;YES, GET A WORD
	SKIPN	MAGDEV			;SKIP IF READING FROM MAGTAPE
	JRST	RWORD1			;NO, GO AND READ
	SKIPGE	MAGONCE			;SKIP IF TAPE NO INTO A RECORD
RWORD1:	GO	@READBL			;READ NEXT RECORD
	RTN				;EOF RETURN
RWORD2:	ILDB	W,LDBUF+1		;GET DATA WORD
	MOVE	Q,LDBUF+1		;GET POINTER
	JRST	CPOPJ1			;RETURN +2


;*STARTQ - HERE ON TRANSFER WORD

STARTQ:	SKIPE	USER			;SKIP IF EXEC MODE
	RELEASE	LDCHN,			;RELEASE CHANNEL
	HRRM	W,SADR			;SAVE STARTING ADDRESS
	TRNN	W,-1			;ANY ADDRESS ?
	GO	ERR7			;NO, MUST NOT HAVE RIGHT FILE
	SETOM	MONTEN			;SET LOADED BY TEN FLAG
	MOVEI	START			;SETUP RETURN TO DIAMON
	MOVEM	RETURN
	HRRM	120			;SETUP JOB DATA AREA ALSO
	SKIPN	PGMGO			;LOAD & GO ?
	JRST	CPOPJ1			;NO, BACK TO MONITOR
	SKIPE	ALTMFLG
	RTN				;ALTMODE, RETURN TO LOADER

SADRQ:	GO	DTECLR			;EXEC & KL10, CLEAR DTE
	MOVE	A,@SAVEIP
	SKIPE	USER
	SETNAM	A,			;USER, IDENTIFY PROGRAM RUNNING
	MOVE	SVJBREL			;SET JOBREL AS "DIAMON" RUN SIZE
	MOVEM	JOBREL
	GO	ZEROAC			;CLEAR AC'S
	SETZM	17
SADR:	JRST	0			;YES, GO
SUBTTL	USER MODE LOADER

;*USERLD - LOOKUP FILE ON THE USERS DISK

USERLD:	SETZM	LDBUF+1
	SETZM	LDBUF+2
	OPEN	LDCHN,LDBLK		;SETUP INPUT FILE
	GO	ERR8
	MOVE	[400000,,LDBF+1]
	MOVEM	LDBUF			;SETUP BUFFER POINTER
	SKIPE	MAGDEV			;SKIP IF READING FROM DSK
	JRST	UMAGLD			;NO, GO TO MAG LOADER
	MOVE	[201,,LDBF1+1]
	MOVEM	LDBF+1			;CLEAR BUFFER USE BITS
	MOVE	[201,,LDBF2+1]
	MOVEM	LDBF1+1
	MOVE	[201,,LDBF+1]
	MOVEM	LDBF2+1
	MOVEI	5			;SET UP DSK CODE
	MOVEM	LDEVICE			;FOR SUBRTN
	MOVE	(IP)
	MOVEM	LDNAME			;SETUP FILE NAME
	HLLZ	1(IP)
	JUMPE	USLD1			;IF NO EXT, TRY A10 & SAV

	GO	USLKUP			;LOOKUP FILE
	JRST	RFILE			;FOUND
	JRST	NFERR			;NOT FOUND

USLD1:	MOVSI	(SIXBIT/SAV/)
	GO	USLKUP			;LOOKUP "SAV"
	JRST	RFILE			;FOUND
	MOVSI	(SIXBIT/A10/)
	GO	USLKUP			;LOOKUP "A10"
	JRST	RFILE			;FOUND
	JRST	NFERR			;COUNDN'T FIND EITHER

USLKUP:	MOVEM	LDNAME+1
	LOOKUP	LDCHN,LDNAME
	JRST	CPOPJ1			;NOT FOUND
	HLRZ	LDNAME+1
	CAIN	(SIXBIT/A10/)
	SETOM	A10FLG			;LOADING "A10" FILE
	RTN
;USER MODE TAPE MOTION ROUTINES

;READ A DATA BLOCK

UREADB:	IN	LDCHN,			;INPUT A WORD
	JRST	CPOPJ1			;RETURN +2
	STATZ	LDCHN,740000		;ERROR, SKIP IF ONLY EOF
	GO	ERR9			;NO, FATAL ERROR
RDEOF:	SETZM	MAGONCE			;SET TAPE AT START OF FILE
	RTN				;EOF RETURN

;MOVE TAPE REVERSE

UREVRS:	MTBSF.	LDCHN,			;MOVE TAPE BACKWARD OVER ONE FILE
	RTN

;MOVE TAPE FORWARD

UFORWD:	MTSKF.	LDCHN,			;MOVE TAPE FORWARD OVER FILE
	RTN

;REWIND THE TAPE

UREW:	MTREW.	LDCHN,			;REWIND THE TAPE
	RTN

;*USRINT - USER MODE INIT, SETUP MINIMUM OF 32K OF CORE

USRINT:	MOVEI	<^D32*^D1024>-1
	CAMG	SVJBREL			;DO WE HAVE 32K MINIMUM ?
	RTN				;YES
	CORE				;NO, EXPAND CORE TO 32K
	GO	ERR10
	MOVE	JOBREL
	MOVEM	SVJBREL			;SAVE MAX CORE NOW
	RTN
SUBTTL	MAGTAPE LOADER

UMAGLD:	MOVE	[XWD 3,TAPEDN]		;SET UP TO SELECT DENSITY
	TAPOP.				;SET DENSITY
	SETSTS	LDCHN,613		;NO TAPOP.S, SET STATUS BITS TO 800 BPI
MAGLD:	MOVEI	6			;SET MAGTAPE CODE TO 6
	MOVEM	LDEVICE			;PUT IN LDEVICE FOR SUBRTN
	SKIPLE	MAGONCE			;TAPE POSITION KNOWN?
	GO	@REW			;NO, REWIND
	SKIPGE	MAGONCE			;AT START OF FILE?
	GO	@FORWRD			;NO, MOVE TO START
	SETZM	MAGONCE			;CLEAR FLAG, POSITION KNOWN
	MOVEI	A,TAB+1			;SET UP ADDRESS OF DIRECTORY
	GO	LOOKUP			;LOOK FOR FILE NAME
	JRST	LDDIR			;NOT THERE, GO READ DIRECTORY FILE
FNFND:	MOVEI	-1			;SET TAPE POSITION FLAG
	MOVEM	MAGONCE			; TO POSITION UNKNOWN
	ADD	B,TAB			;COMPUTE FILE NUMBER
	MOVEM	B,PRGNBR#		;SAVE FILE NUMBER
	SUB	B,CURR#			;FIND NUMBER OF FILES TO SPACE
	JUMPL	B,BACKUP		;BACKSPACE TO SELECTED FILE
	JUMPLE	B,.+3			;GO AROUND IF AT FILE
	GO	@FORWRD			;SPACE FORWARD OVER UNWANTED FILES
	SOJG	B,.-1

TRANS:	MOVE	PRGNBR			;GET PROGRAM NUMBER
	ADDI	1			;SET UP FOR POSITION AFTER PROG READ
	MOVEM	CURR			;STORE TAPE POSITION IN CURR
	SETOM	MAGONCE			;SET IN FILE FLAG
	SETZM	LDBUF+2			;CLEAR CHARACTERS IN BUFFER COUNTER
	JRST	RFILE			;GO TO READ FILE

BACKUP:	GO	@REVERS			;BACKSPACE OVER UNWANTED FILES
	AOJLE	B,.-1
	GO	@FORWRD			;MOVE FORWARD OVER FILE MARK
	JRST	TRANS


EXECLD:	SKIPE	DX10			;SKIP IF NOT DX10
	GO	DXINIT			;INITIALIZE THE DX10 CONTROLLER
	MOVSI	4400			;SET UP BYTE POINTER
	MOVEM	LDBUF+1			;IN BUFFER HEADER
	SETZM	LDBUF+2			;CLEAR WORD COUNT
	JRST	MAGLD
;LOOKUP FILE NAME IN DIRECTORY IN CORE
;ENTER WITH ADR OF DIRECTORY RECORD IN A

LOOKUP:	SETZ	B,			;CLEAR FILE COUNTER
LOOKU0:	MOVE	(A)			;GET A FILE NAME
	TLNN	770000			;CHECK IF END OF RECORD
	RTN				;YES, FILE NOT FOUND
	CAME	(IP)			;COMPARE FILE NAME
	JRST	LOOKU3			;NO MATCH, KEEP LOOKING
	HLRZ	1(IP)			;GET SPECIFIED EXTENSION
	HLRZ	C,1(A)			;GET EXTENSION FROM DIRECTORY
	JUMPN	LOOKU1			;JUMP IF EXTENSION SPECIFIED
	CAIN	C,'A10'			;LOOK FOR A10 EXTENSION
	JRST	LOOKU2			;FOUND
	MOVEI	'SAV'			;LOOK FOR SAV EXTENSION
LOOKU1:	CAME	C			;COMPARE WITH EXTENSION
	JRST	LOOKU3			;NO MATCH
LOOKU2:	CAIN	C,'A10'			;IS EXTENSION A10?
	SETOM	A10FLG			;YES, SET FLAG
	JRST	CPOPJ1			;SUCCESSFUL RETURN
LOOKU3:	ADDI	A,3			;MOVE TO NEXT NAME IN LIST
	AOJA	B,LOOKU0		;GO LOOK AT IT
LDDIR:	TLNE	-1			;CHECK IF ENTIRE DIRECTORY
	SKIPE	TAB			;  IS IN CORE
	SKIPA				;NO
	JRST	NFERR			;FILE NOT FOUND
	MOVEI	C,-1			;SET TAPE POSITION FLAG
	MOVEM	C,MAGONCE		;TO POSITION UNKNOWN
	SKIPE	CURR			;SKIP IF AT BOT
	GO	@REW			;NO, REWIND THE TAPE
	MOVEI	C,3			;SPACE FORWARD TO DIRECTORY FILE
	GO	@FORWRD			;  MAGTAP.MTA
	SOJG	C,.-1
	MOVEI	4			;SET CURRENT TAPE POSITION
	MOVEM	CURR			;TO FILE AFTER DIRECTORY
	SETOM	MAGONCE			;SET IN FILE FLAG
LDDIRB:	GO	@READBL			;READ A BLOCK OF DIRECTORY
	GO	ERR13			;ERROR
	MOVE	C,RBUF			;COMPUTE CHECKSUM OF DIRECTORY RECORD
	MOVEI	A,RBUF+1		;INDEX TO DATA WORDS
DIRCK:	ADD	C,(A)			;ADD ENTRIES OF CURRENT FILE
	ADD	C,1(A)
	ADD	C,2(A)
	ADDI	A,3			;INCREASE POINTER OVER ENTRY
	MOVE	B,(A)			;GET NEXT WORD
	TLNE	B,770000		;CHECK IF A FILE NAME
	JRST	DIRCK			;YES, ADD THIS ENTRY
	HLRZ	C			;GET LEFT HALF OF COMPUTED CHECKSUM
	ADDI	(C)			;ADD RIGHT HALF TO IT
	HRRZ				;STRIP TO 18 BITS
	CAIE	(B)			;COMPARE TO CHECKSUM FROM TAPE
	GO	ERR13			;CHECKSUM ERROR
	MOVEI	A,RBUF+1		;SET UP TO LOOK FOR FILE NAME
	GO	LOOKUP			;IN RECORD JUST READ
	JRST	LDDIRN			;NOT HERE, LOOK IN NEXT RECORD OF DIRECTORY
	MOVE	[RBUF,,TAB]		;TRANSFER THIS DIRECTORY
	BLT	TAB+MAGRCD-1		;INTO TAB
	JRST	DIAGLA			;GO POSITION TO FILE

LDDIRN:	TLNN	-1			;CHECK IF LAST RECORD OF DIRECTORY
	JRST	LDDIRB			;NO, READ NEXT DATA BLOCK
	JRST	NFERR			;YES, FILE NOT FOUND
SUBTTL	DX10 MAGTAPE LOAD ROUTINE

;ACCUMULATOR ASSIGNMENTS

F=0					;TEMP
A=1					;TEMP
B=2					;TEMP
C=3					;TEMP
W=4					;WORD RETURNED BY RWORD
Q=5					;COUNTER, DATA WORD BUFFER
M=7					;MEMORY AOBJN POINTER, DATA TO CORE

MAGRCD=^D512				;SIZE OF A MAGTAPE RECORD IN WORDS

;DX10 CONTROL BITS

PDC=220					;DX10 DEVICE CODE
PDC2=224				;DX10 #2
PDC3=34					;DX10 #3
RUNIND=1				;RUN INDICATOR OF 8A PROCESSOR
INHLD=1B25				;INHIBIT LOAD OF ICPC (CONO)
CSRFLG=1B25				;CHANNEL STATUS REGISTER ERROR (CONI)
MPERR=1B26				;8A TIME OUT ERROR
MEMPAR=1B27				;MEMORY PARITY ERROR
NXM=1B28				;NON-EXISTANT MEMORY ERROR
STAVL=1B29				;STATUS AVAILABLE FLAG
CLEAR=1B31				;CLEAR DEVICES
CONT=1B32				;CONTINUE DX10
INTFLG=MPERR+MEMPAR+NXM+STAVL


;DX10 COMMANDS

BSB=	1B1!47B23			;BACKSPACE BLOCK
BSF=1B1!57B23				;BACKSPACE SPACE FILE
FSF=1B1!77B23				;FORWARD SPACE FILE
RDF=1B1!1B2!2B23			;READ FORWARD
CHJMPG=1B2!1B3				;CHANNEL JUMP AND GO
STORE=1B4				;STORE STATUS
REWD=1B1!7B23				;REWIND COMMAND
;DX10 STATUS BITS

BUSY=1B3				;CONTROL UNIT OR DEVICE BUSY
UNITCK=1B6				;UNIT CHECK
UNITEX=1B7				;UNIT EXCEPTION
TYPE0=2B10				;STATUS TYPE CODE 2
SELERR=1B11				;DEVICE SELECTION ERROR
SEQERR=1B12				;SEQUENCE ERROR
DEVPAR=1B13				;DEVICE PARITY ERROR
LENERR=1B14				;LENGTH ERROR
ILLCMD=1B16				;ILLEGAL COMMAND
DSRFLG=1B17				;DEVICE STATUS REGISTER ERROR
SNSERR=1B18				;SENSE BYTE RETRIEVAL ERROR
OPI=1B19				;OPERATION INCOMPLETE

RETRY=^D10				;RETRY COUNT
LOWCMD=20				;LOW COMMAND AREA

DXCLR=2					;RESET DX10 BIT
RSEL=1					;SELECT RSEL REGISTER
MPADR=5					;8A ADDRESS REGISTER CODE
MPCTL=4					;8A CONTROL REGISTER CODE
DAC=12					;DATA ADDRESS COUNTER CODE
UNITNM=	7713				;ADDRESS OF UNIT FROM 8-MEMORY
ENEXM=1B22				;ENABLE EXAMINE
ENDEP=1B23				;ENABLE DEPOSIT
MPHALT=1B19				;8A HALT SWITCH
MPCONT=1B20				;8A CONTINUE SWITCH
MCSTRT=200				;MICRO-CODE START ADDRESS
MCCODE=16				;MICRO-CODE ADDRESS CONTAINING '70'
DXCODE='70'				;CODE IN MCCODE
DXDEV:	CAIG	B,1			;SKIP IF DEVICE CODE OF 0 OR 1
	MOVEI	B,PDC			;  INSERT CODE PDC
	CAIN	B,2			;SKIP IF CODE 2
	MOVEI	B,PDC2			;  INSERT CODE PDC2
	CAIN	B,3			;SKIP IF CODE 3
	MOVEI	B,PDC3			;  INSERT CODE PDC3
	CAIGE	B,20			;SKIP IF A LEGAL CODE
	JRST	EXECDV			;NO, ERROR
	MOVSI	(DATAI)			;GET DATAI INSTRUCTION
	LSH	B,-2			;POSITION DEVICE CODE
	DPB	B,[POINT 7,0,9]		;SET IN DEVICE CODE
	MOVEM	TAPEEX			;SET UP TAPEEX
	TLO	(20B14)			;CONVERT TO CONI INSTRUCTION
	MOVEM	TAPERD			;SET UP TAPERD
	TLZ	(4B14)			;CONVERT TO CONO INSTRUCTION
	HRRI	<LOWCMD_9>!MPERR!MEMPAR!NXM	;SET IN CLEAR BITS
	MOVEM	TAPECL			;SET UP TAPECL
	HRRI	<LOWCMD_9>!STAVL!CLEAR!CONT	;SET IN START BITS
	MOVEM	TAPEGO			;SET UP TAPEGO
	TLC	(30B14)			;CONVERT TO BLKO INSTRUCTION
	HLLZM	TAPELD			;SET UP TAPELD
	SETOM	DX10#			;SET DX10 FLAG
	MOVE	[[EXP DXREAD,DXREVS,DXFORW,DXREW],,READBL]
	BLT	REW			;FILL DISPATCH LOCATIONS
	GO	UNIT			;ASK WHICH UNIT
	CAILE	7			;CHECK FOR LEGAL UNIT NUMBER
	JRST	EXECDV			;NO, START SELECTION AGAIN
	MOVEI	A,5			;SET COUNT TO 5
	DPB	[POINT 4,DXRDF,35	;SET ALL DEVICE COMMANDS
		POINT 4,DXBSB,35	;TO UNIT NUMBER
		POINT 4,DXBSF,35	;SPECIFIED
		POINT 4,DXREWD,35
		POINT 4,DXFSF,35
		POINT 4,DXU,35  ] (A)
	SOJGE	A,.-1			;DEPOSIT 6 TIMES
	RTN
DXINIT:	XCT	TAPERD			;READ CONI STATUS
	TLNE	RUNIND			;SKIP IF DX10 HALTED
	RTN				;DX10 IS RUNNING, RTN NOW
	MOVE	[IOWD 6,EXBUF]		;READ FROM DX10 MEMORY
	GO	BLOCKO			;SELECT ADDRESS CONTAINING CODE
	XCT	TAPEEX			;READ CONTENTS OF MEMORY LOCATION
	TLZN	-1			;CLEAR IBUS REGISTER CODE
	GO	ERR14			;NO CODE, WHERE IS DX10?
	CAIN	DXCODE			;SKIP IF NOT CODE OF MICRO-CODE
	JRST	DXSTRT			;CODE MATCHES, START DX10


;LOAD MICRO-CODE INTO DX10

	MOVEI	-1			;SET TAPE POSITION
	MOVEM	MAGONCE			;  UNKNOWN FLAG
	MOVE	[IOWD ^D11,RDITRG]	;TRIGGER A READ-IN OF DX10
	GO	BLOCKO			;TO GET BOOTSTRAP CODE INTO DX10 MEMORY
	MOVEI	W,5			;SET COUNT TO 5
DXRDI:	MOVE	[IOWD 3,RDIWAT]		;SET HALT SWITCH
	GO	BLOCKO			;SELECT CPMA
	XCT	TAPEEX			;READ CPMA
	ANDI	7777			;CLEAR OTHER BITS
	CAIN	7602			;CHECK IF READ-IN FINISHED
	SOSLE	W			;LOOP TILL SEE ADDRESS 5 TIMES
	JRST	DXRDI			;TO BE SURE IT IS FINISHED

	MOVE	[IOWD ^D30,MCREAD]	;MODIFY BOOTSTRAP CODE IN DX10
	GO	BLOCKO			;AND READ IN MICRO-CODE IMAGE FROM TAPE
	XCT	TAPERD			;WAIT FOR DX10 TO STOP
	TLNE	RUNIND			;BY LOOKING AT RUN INDICATOR
	JRST	.-2			;NOT YET
	TRNN	STAVL			;DID STATUS AVAILABLE SET?
	GO	ERR14			;NO, READ NOT SUCCESSFUL
	MOVE	[IOWD 5,MCLOAD]		;SELECT 8A ADDRESS 0
	GO	BLOCKO			;THEN SELECT CONTROL REGISTER
	MOVE	Q,[POINT 12,30000+MAGRCD]	;GET BYTE POINTER TO MICRO-CODE
	MOVEI	W,10000			;GET WORD COUNT
	MOVE	A,TAPELD		;GET BLKO INSTRUCTION
	TLO	A,(1B12)		;CHANGE TO DATAO
LOAD8A:	ILDB	Q			;GET A PDP-8A WORD
	TRO	ENDEP			;SET ENABLE DEPOSIT BIT
	XCT	A			;DEPOSIT THE WORD
	SOJG	W,LOAD8A		;LOAD ALL WORDS
	SETZM	CURR			;SET CURRENT POSITION AT FILE ZERO
	SETZM	MAGONCE			;SET MAGTAPE POSITION KNOWN


DXSTRT:	MOVE	[IOWD 4,STBUF]		;START THE DX10
	GO	BLOCKO			;  MICRO-CODE
	XCT	TAPECL			;CLEAR THE DX10 ERROR FLAGS
	RTN				;DX10 NOW READY TO USE


BLOCKO:	XCT	TAPELD			;EXECUTE BLKO INSTRUCTION
	RTN				;ALL DONE, RETURN
	JRST	.-2			;KEEP GOING


RDITRG:	DXCLR,,0			;RESET THE DX10
	RSEL,,MPCTL			;SELECT MPCTL
	0				;CLEAR THE SWITCHES
	RSEL,,MPADR			;SELECT MPADR
	0				;SELECT ADDRESS 0
	RSEL,,MPCTL			;SELECT MPCTL
	ENDEP!6562			;DEPOSIT SRI INSTRUCTION
	RSEL,,MPADR			;SELECT MPADR
	0				;SELECT ADDRESS 0
	RSEL,,MPCTL			;SELECT MPCTL
	MPCONT!MPHALT			;EXECUTE THE SRI INSTRUCTION

RDIWAT:	RSEL,,MPCTL			;SELECT MPCTL
	MPHALT				;SET HALT SWITCH
	RSEL,,MPADR			;SELECT MPADR

MCREAD:	7605				;SET ADDRESS
	RSEL,,MPCTL			;SELECT CONTROL
	ENDEP!5211			;DEPOSIT JMP 7611
	RSEL,,MPADR			;SELECT ADDRESS
	7616				;SET ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	ENDEP!6505			;INSERT G8C INSTRUCTION
	ENDEP!1315			;TAD (1000)
	RSEL,,MPADR			;SELECT MPADR
	7644				;SET ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	ENDEP!2312			;DEPOSIT ISZ LMT
	ENDEP!5215			;DEPOSIT JMP RDNXT
	ENDEP!6567			;DEPOSIT SSA
	ENDEP!7402			;DEPOSIT HLT
	RSEL,,MPADR			;SELECT MPADR
	7712				;SET ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	ENDEP!<-4&7777>			;DEPOSIT A -4
DXU:	ENDEP!0				;DEPOSIT UNIT NUMBER (LOADED BY DXDEV)
	ENDEP!7				;REWIND COMMAND
	ENDEP!MAGRCD			;RECORD SIZE
	RSEL,,7				;SELECT 8R REGISTER
	0,,-<MAGRCD*5>_4		;LOAD BYTE COUNT
	RSEL,,6				;SELECT OTHER HALF
	37000				;LOAD ADDRESS
	RSEL,,MPADR			;SELECT MPADR
	7601				;LOAD ADDRESS OF BOOTSTRAP PROGRAM
	RSEL,,MPCTL			;SELECT MPCTL
	MPCONT				;START THE DX10

MCLOAD:	RSEL,,MPCTL			;SELECT MPCTL
	0				;CLEAR SWITCHES
	RSEL,,MPADR			;SELECT MPADR
	0				;LOAD ADDRESS 0
	RSEL,,MPCTL			;SELECT MPCTL
;READ TAPE RECORD

DXREAD:	MOVEI	W,RETRY			;RETRY COUNTER

DXRTRY:	MOVEI	DXRDF			;GET ADDRESS OF CHANNEL PROGRAM
	GO	DXWAIT			;START DX10, WAIT FOR DONE
	JRST	CHECK2			;NO ERROR, GET RECORD SIZE
	MOVE	LOWCMD+1		;GET STATUS
	TLNE	(UNITEX)		;WAS IT EOF?
	JRST	RDEOF			;YES, RETURN +1

CHECK1:	SOSGE	W			;SHOULD WE TRY AGAIN?
	GO	ERR9
	MOVEI	DXBSB			;GET ADDRESS OF CHANNEL PROGRAM
	GO	DXWAIT			;START DX10, WAIT FOR DONE
	JRST	DXRTRY			;NO ERRORS
	GO	ERR11			;ERROR RETURN

CHECK2:	MOVE	LOWCMD+2		;GET BYTE COUNTER
	ASH	-^D22			;SHIFT OUT CPC
	IDIVI	5			;COMPUTE WORDS IN BUFFER
	ADDI	MAGRCD
CHECK3:	MOVEM	LDBUF+2			;PUT IN BUFFER HEADER
	MOVEI	LDBF+2			;SET UP BUFFER POINTER
	HRRM	LDBUF+1			;TO START OF BUFFER
	JRST	CPOPJ1			;SKIP RETURN

;BACKSPACE ONE FILE

DXREVS:	MOVEI	DXBSF			;GET ADDRESS OF CHANNEL PROGRAM
	GO	DXWAIT			;START DX10, WAIT FOR DONE
	RTN				;NO ERRORS
REVSER:	MOVEI	-1			;SET POSITION UNKNOWN
	MOVEM	MAGONCE			;FLAG
	JRST	DIAGLD			;REWIND AND START OVER

;REWIND

DXREW:	MOVEI	DXREWD			;GET ADDRESS OF CHANNEL PROGRAM
	GO	DXWAIT			;START DX10, WAIT FOR DONE
	JFCL
REWEND:	SETZM	CURR			;CURRENT FILE IS NOW 0
	RTN				;RETURN

;SPACE FORWARD ONE FILE

DXFORW:	MOVEI	DXFSF			;GET ADDRESS OF CHANNEL PROGRAM
	GO	DXWAIT			;START DX10, WAIT FOR DONE
	RTN				;NO ERRORS
	GO	ERR12

DXWAIT:	HRLI	(CHJMPG)		;SET JUMP COMMAND TO ADDRESS
	MOVEM	LOWCMD			;PUT IN LOW COMMAND
	SETZM	LOWCMD+3		;CLEAR EXTENDED ADDRESS POINTER
	XCT	TAPEGO			;START THE DX10
	XCT	TAPERD			;READ STATUS
	TRNN	INTFLG			;WAIT FOR DONE
	JRST	.-2			;NOT YET
	TRNE	MPERR!MEMPAR!NXM	;CHECK FOR FATAL ERROR
	GO	ERR14			;YES, REPORT IT
	TRNE	CSRFLG			;DEVICE ERROR?
	AOS	(P)			;SKIP IF NONE
	RTN				;RETURN

DXRDF:	RDF				;READ FORWARD COMMAND
	-<MAGRCD*5>_4,,RBUF		;XFER WORD
	STORE				;STORE STATUS AND HALT

DXBSB:	BSB				;BACKSPACE ONE BLOCK COMMAND
	STORE				;STORE STATUS AND HALT

DXBSF:	BSF				;BACKSPACE ONE FILE COMMAND
	STORE				;STORE STATUS AND HALT


DXREWD:	REWD				;REWIND COMMAND	;REWIND THE TAPE COMMAND
	0				;HALT, WAIT TILL AT BOT

DXFSF:	FSF				;FORWARD SPACE FILE COMMAND
	STORE				;STORE STATUS AND HALT

EXBUF:	RSEL,,MPCTL			;SELECT IBUS REGISTER MPCTL
	0				;CLEAR SWITCHES
	RSEL,,MPADR			;SELECT IBUS REGISTER MPADR
	MCCODE				;LOAD ADDRESS OF CODE WORD
	RSEL,,MPCTL			;SELECT IBUS REGISTER MPCTL
	ENEXM				;CAUSE A MEMORY READ CYCLE
STBUF:	RSEL,,MPADR			;SELECT IBUS REGISTER MPADR
	MCSTRT				;MICRO-CODE START ADDRESS
	RSEL,,MPCTL			;SELECT MPCTL
	MPCONT				;START THE DX10
SUBTTL	TM10 MAGTAPE LOAD ROUTINE


;MAGTAPE CONTROL BITS

TMS=344					;MAG TAPE STATUS (TMS)
TMC=340					;MAG TAPE CONTROL (TMC)
TMC2=350				;MAGTAPE CONTROL #2
TMS2=354				;MAGTAPE STATUS #2
PARITY=1B21				;ODD PARITY
BPI800=1B28				;800 BPI DENSITY
DUMP=1B22				;CORE DUMP MODE
NOOP=0					;NO-OP
NOOP1=10B26				;UNIT READY CHECK
REWIND=1B26				;REWIND UNIT
READX=2B26				;READ
SPACE=6B26				;SPACE FORWARD RECORD
SPACE1=16B26				;SPACE FORWARD FILE
SPACE2=7B26				;SPACE REVERSE RECORD
SPACE3=17B26				;SPACE REVERSE FILE
;MAGTAPE STATUS BITS

DF22=1B9				;DF10 IN 22 BIT MODE
DF10=17B14				;DF10 CHECK BITS
HUNG=1B18				;TRANSPORT HUNG
WIND=1B19				;TRANSPORT REWINDING
BOT=1B20				;BEGINNING OF TAPE
ILLOP=1B21				;ILLEGAL OPERATION
PERR=1B22				;PARITY ERROR
EOF=1B23				;END OF FILE
EOT=1B24				;END OF TAPE (REAL)
RCERR=1B25				;READ/COMP ERROR
RLINC=1B26				;RECORD LENGTH INCORRECT
DATLAT=1B27				;DATA LATE
BADTAP=1B28				;BAD TAPE
JOBDON=1B29				;JOB DONE
IDLE=1B30				;XPORT IDLE
WRTLCK=1B32				;WRITE LOCK
CHAN7=1B33				;SEVEN CHANNEL XPORT
DATA=1B35				;DATA READY

BADBIT=HUNG!ILLOP!EOT!RCERR!DATLAT!BADTAP!PERR	;ERROR BITS
TMDEV:	CAIG	B,1			;IF DEVICE CODE 0 OR 1
	MOVEI	B,TMC			;MAKE CODE TMC
	CAIN	B,2			;IF CODE IS 2
	MOVEI	B,TMC2			;MAKE CODE TMC2
	CAIGE	B,20			;SKIP IF LEGAL CODE
	JRST	EXECDV			;NO, ERROR
	LSH	B,-2			;POSITION DEVICE CODE
	TRO	B,1			;SET LOW ORDER BIT
	MOVSI	(DATAO)			;GET DATAO INSTRUCTION
	DPB	B,[POINT 7,0,9]		;SET IN DEVICE CODE
	MOVEM	TAPELD			;SET UP TAPELD
	TLC	(30B14)			;CONVERT TO CONI TMS,
	MOVEM	TAPERD			;SET UP TAPERD
	TLZ	(74B14)			;CONVERT TO BLKI TMC,
	HRRI	Q			;SET Q IN E FIELD
	MOVEM	TAPEEX			;SET UP TAPEEX
	TLO	Q(20B14)		;CONVERT TO CONO TMC,(Q)
	HLLZM	TAPEGO			;SET UP TAPEGO
	GO	UNIT			;GET UNIT NUMBER
	CAILE	7			;CHECK IF LEGAL
	JRST	EXECDV			;NO, ERROR
	DPB	[POINT 3,TAPEGO,20]	;SET UNIT NUMBER IN CONO INSTRUCTION
	MOVE	[[EXP TMREAD,TMREVS,TMFORW,TMREW],,READBL]
	BLT	REW			;SET UP DISPATCH LOCATIONS TO TM ROUTINES
	MOVEI	Q,NOOP			;GET NOOP COMMAND
	XCT	TAPEGO			;SELECT THE UNIT
	XCT	TAPERD			;READ STATUS
	TRNN	WIND!IDLE		;SKIP IF DRIVE READY
	JRST	EXECDV			;DRIVE OR TM10 NOT READY
	SETZ	A,			;CLEAR A
	TLNE	(DF10)			;SKIP IF A TM10B
	JRST	TMA			;NO, GO AROUND
	MOVSI	A,-MAGRCD		;SET UP CHANNEL COMMAND RECORD SIZE
	TLNE	(DF22)			;SKIP IF DF10 IN 18 BIT MODE
	LSH	A,4			;NO, SHIFT OVER 4 PLACES
	HRRI	A,RBUF-1		;SET IN ADDRESS -1
TMA:	MOVEM	A,CHNCMD		;SET UP CHANNEL COMMAND LIST
	RTN
;READ TAPE RECORD

TMREAD:	MOVEI	W,RETRY			;SET UP RETRY COUNT
	MOVEI	LOWCMD			;GET ADR OF DF ICCW
	XCT	TAPELD			;LOAD INTO TM10
TMRTRY:	MOVEI	CHNCMD			;MAKE THIS INSTRUCTION
	MOVEM	LOWCMD			;  A JUMP TO CHN COMMAND LIST
	MOVEI	Q,DUMP!PARITY!READX!BPI800	;SET UP READ COMMAND
	XCT	TAPEGO			;START TAPE READ
	SKIPE	CHNCMD			;CHANNEL CONNECTED?
	JRST	TMWAIT			;YES, WAIT TILL DONE
	MOVE	Q,[IOWD MAGRCD,RBUF]	;GET BLKI POINTER
TMRDS:	XCT	TAPERD			;READ STATUS
	TRNE	JOBDON			;LOOK FOR JOB DONE
	JRST	CHECK			;SET, CHECK FOR ERRORS
	TRNN	DATA			;LOOK FOR DATA REQUEST
	JRST	TMRDS			;NO, KEEP LOOKING
	XCT	TAPEEX			;READ A WORD
	JRST	TMWAIT			;BLKI SATISFIED
	JRST	TMRDS			;LOOP TILL DONE

TMWAIT:	GO	TMDONE			;WAIT FOR DONE TO SET
CHECK:	TRNE	EOF			;EOF?
	JRST	RDEOF			;YES, RETURN +1
	TRNE	BADBIT			;ANY ERRORS?
	JRST	CHECK0			;YES
	SKIPE	CHNCMD			;CHANNEL CONNECTED?
	MOVE	Q,LOWCMD+1		;YES, GET TERM WORD
	MOVEI	(Q)			;GET BUFFER ADDRESS
WDCNT:	SUBI	RBUF-1			;SUBTRACT START BUFFER ADDRESS
	JRST	CHECK3			;GO SET UP LDBLK

CHECK0:	SOSGE	W			;SHOULD WE TRY AGAIN?
	GO	ERR9			;NO
	SETZM	LOWCMD			;CLEAR DF10 WORD COUNT
	MOVEI	Q,PARITY!DUMP!SPACE2!BPI800	;BACKSPACE ONE RECORD
	GO	TMGO			;MOVE THE TAPE BACKWARD
	JRST	TMRTRY			;TRY AGAIN
TMGO:	XCT	TAPEGO			;START TAPE MOVING
TMDONE:	XCT	TAPERD			;READ STATUS
	TRNN	JOBDON			;SKIP IF JOB DONE IS SET
	JRST	TMDONE			;NO, KEEP ON WAITING
	RTN				;SET, RETURN

TMREVS:	MOVEI	Q,PARITY!DUMP!SPACE3!BPI800	;SET UP COMMAND
	GO	TMGO			;MOVE TAPE REVERSE
	TRNE	BADBIT			;CHECK FOR ERRORS
	JRST	REVSER			;YES, REWIND AND START OVER
	RTN

TMREW:	MOVEI	Q,REWIND!BPI800		;SET UP REWIND
	GO	TMGO			;MOVE TAPE
	MOVEI	Q,NOOP1!BPI800		;NOOP, INTERRUPT WHEN READY
	GO	TMGO			;WAIT
	JRST	REWEND			;DONE

TMFORW:	MOVEI	Q,DUMP!PARITY!SPACE1!BPI800	;SET UP COMMAND
	GO	TMGO			;MOVE TAPE FORWARD
	TRNE	BADBIT-BADTAP		;CHECK FOR ERRORS
	GO	ERR12			;ERROR
	RTN				;DONE
SUBTTL	RH10/RH20 LOAD ROUTINES

;*DEVICE CODE FOR THE RH20

RH0=540
RH1=544
RH2=550
RH3=554
RH4=560
RH5=564
RH6=570
RH7=574

;*DEVICE CODES FOR RH10

DH=270
DH2=274
DH3=360
DH4=364
DH5=370
DH6=374

;*RH20 CONO BIT ASSIGNMENTS

RAECLR=1B24				;REGISTER ACCESS ERROR CLEAR
MBCCLR=1B25				;MASSBUSS CONTROLLER CLEAR
XECLR=1B26				;TRANSFER ERROR CLEAR
MBE=1B27				;MASSBUSS CONTROLLER ENABLE
RCLPA=1B28				;RESET THE COMMAND LIST POINTER
DSCR=1B29				;DELETE SECONDARY COMMAND REGISTER
ATTEN=1B30				;ATTENTION  INTERRUPT (ENABLE)
DNCLR=1B32				;CLEAR COMMAND DONE
PIA=7B35				;PI CHANNEL MASK BITS
BUSLP=1B30				;ENABLE MAINTENANCE LOOPING
RHEBL=1B32				;END OF BLOCK
DTRA=1B26				;TRANFER BIT IN DIAG REG
RHCLK=1B35				;SCLK


;*RH20 CONI BIT ASSIGNMENTS

LNXM=1B4				;MBOX NON-EX MEM
LPAR=1B1				;MBOX PAR ERR
SBERR=1B2				;SBUSS ERR
DBPE=1B18				;DATA BUSS PARITY ERROR
DREX=1B19				;DRIVE EXCEPTION
LWCER=1B20				;LONG WORD COUNT ERROR
SWCER=1B21				;SHORT WORD COUNT ERROR
CHNER=1B22				;CHANNEL ERROR
DRESSER=1B23				;DRIVE RESPONSE ERROR
RAEER=1B24				;REGISTER ACCESS ERROR
CHNRDY=1B25				;CHANNEL NOT BUSY
DOVRER=1B26				;DATA OVERRUN ERROR
MASSEN=1B27				;MASSBUSS ENABLED
DRATTN=1B28				;DRIVE NEEDS ATTENTION
SCRFUL=1B29				;SECONDARY COMMAND REG IS FULL
ATTNEN=1B30				;THE ATTENTION INTERRUPT IS ENABLED
PCRFUL=1B31				;PRIMARY COMMAND REGISTER IS FULL
CMDDN=1B32				;COMMAND IS DONE
PIA=7B35
RH.ERS=DBPE+DREX+DRESSER+RAEER+DOVRER

DF22F=1B6				;DF10 IN 22 BIT MODE ON RH10

;CHANNEL STATUS WORD 1 BIT DEFINTIONS

CH.PAR=1B1				;MEMORY PARITY ERROR
CH.SER=1B2				;NOT SBUS ERROR
CH.WCZ=1B3				;WORD COUNT NOT = 0
CH.NXM=1B4				;CHANNEL NON-EX MEM
CH.LER=1B9				;LAST TRANSFER ERROR
CH.RHE=1B10				;RH20 ERROR
CH.LWC=1B11				;LONG WORD COUNT ERR
CH.SWC=1B12				;SHORT WORD COUNT ERR
CH.OVR=1B13				;CHANNEL OVERRUN ERR
CH.ERS=CH.PAR+CH.SER+CH.WCZ+CH.NXM+CH.LER+CH.RHE+CH.LWC+CH.SWC+CH.OVR



;*DATAO-DATAI FOR THE DRIVE REGISTERS (00-37)

LR=1B6					;LOAD REGISTER BIT
LDBIT=1B24				;LR DEFINITION USED IN HRLI INSTRUCTIONS
PE=1B8					;PARITY ERROR DETECTED
DRAES=1B9				;DISABLE REG ACCESS ERROR STOP
TRA=1B10				;ASYNC TRANSFER IN PROGRESS
DRSEL=7B17				;A MASK FOR DRIVE SELECT BITS
EP=1B18					;WRITE AS EVEN PARITY
PAR=1B19				;PARITY RECEIVED ON LAST REGISTER READ
RDAT=177777B35				;MASK FOR  THE 16 DATA BITS IN THE REG.


;*DATAO-DATAI FOR  RH20 SECONDARY BLOCK ADDRESS REGISTER (70)

LR=1B6					;LOAD REGISTER
DRSEL=7B17				;DRIVE SELECT MASK
RDAT=177777B35				;MASK FOR THE 16 DATA BITS


;*DATAO-DATAI FOR RH20 PRIMARY BLOCK ADDRESS REGISTER (72)

DRSEL=7B17				;MASK FOR DRIVE SELECT BITS
RDAT=177777B35				;MASK FOR THE REGISTERS DATA BITS


;*DATAO-DATAI FOR RH20 SECONDARY TRANSFER CONTROL REGISTER (71)

LR=1B6					;LOAD REGISTER BIT
PCLP=1B7				;RESET THE COMMAND LIST POINTER
XFR==1B0				;CHN TRANSFER INSTRUCTION
SIZE1==1B13				;BYTE COUNT OF 1
CHJMP==1B1				;CHN JUMP  INSTRUCTION
STORE=1B10				;STORE THE M-BOX ERROR STATUS
DRSEL=7B17				;MASK FOR THE DRIVE SELECT 
DTES=1B19				;DISABLE TRANSFER ERROR STOP
BLKCNT=1777B29				;MASK FOR THE BLOCK COUNT
FNCTN=77B35				;MASK FOR THE FUNCTION


;*DATAO-DATAI FOR RH20 PRIMARY TRANSFER REGISTER (73)

DRSEL=7B17				;MASK FOR THE DRIVE SELECT BITS
DTES=1B19				;INHIBIT TRANSFER ERROR STOP
BLKCNT=1777B29				;MASK  FOR THE BLOCK COUNT
FNCTN=77B35				;MASK FOR THE FUNCTION BITS


;*DATAO-DATAI FOR THE RH20 INTERRUPT VECTOR REGISTER (74)

IADDR=777B35				;MASK FOR THE INTERRUPT ADDRESS


;*RH20  REGISTER ASSIGNMENTS

RHDIAG=77B5				;RH DIAGNOSTIC REGISTER
RHWRR=76B5				;RH WRITE REGISTER
RHRDR=75B5				;RH READ REGISTER
RHIVR=74B5				;INTERRUPT VECTOR INDEX REGISTER
RHPTCR=73B5				;PRIMARY TRANSFER CONTROL REGISTER
RHPBAR=72B5				;PRIMARY BLOCK ADDRESS REGISTER
RHSTCR=71B5				;SECONDARY TRANSFER CONTROL REGISTER
RHSBAR=70B5				;SECONDARY BLOCK ADDRESS REGISTER

DHSTRC=40B5				;RH10 TRANSFER CONTROL REGISTER


;* MASSBUSS DEVICE REGISTER BIT ASSIGNMENTS (REGISTERS 00-17)

DRCR=0B5				;CONTROL REGISTER
DRSR=1B5				;STATUS REGISTER
DRER1=2B5				;ERROR REGISTER #1 OF 3
DRMR=3B5				;MAINTAINABILITY REGISTER
DRAS=4B5				;ATTENTION SUMMARY "PSEUDO" REGISTER
DRDTS=5B5				;DESIRED TRACK AND SECTOR REGISTER
DRFC=5B5				;FRAME COUNTER REGISTER
DRDT=6B5				;DRIVE TYPE REGISTER
DRLA=7B5				;TRACK/SECTOR LOOK AHEAD REGISTER
DRER2=14B5				;ERROR REGISTER #2 OF 3
DRTC=11B5				;TAPE CONTROL REGISTER
DROFF=11B5				;OFFSET REGISTER
DRDCY=12B5				;DESIRED CYLINDER ADDRESS REGISTER
DRCCY=13B5				;CURRENT CYLINDER ADDRESS REGISTER
DRSN=10B5				;SERIAL NUMBER REGISTER
DRER3=15B5				;ERROR REGISTER #3 OF 3
DREC1=16B5				;ECC POSITION REGISTER
DREC2=17B5				;ECC PATTERN REGISTER

;LEFT HAND DEFINTIONS FOR DEVICE REGISTERS

DR.CR=0B23
DR.SR=1B23
DR.ER1=2B23
DR.MR=3B23
DR.AS=4B23
DR.FC=5B23
DR.DT=6B23
DR.LA=7B23
DR.ER2=14B23
DR.TC=11B23
DR.OFF=11B23
DR.DCY=12B23
DR.CCY=13B23
DR.SN=10B23
DR.ER3=15B23
DR.EC1=16B23
DR.EC2=17B23

;MAGNETIC TAPE FUNCTION SET
;(FUNCTIONS INCLUDE THE "GO" BIT)

NOOP=1					;A NO-OP
ULOAD=3					;UNLOAD THE DRIVE
RWND=7					;REWIND TAPE
CLEAR=11				;DRIVE CLEAR
RELSE=13				;RELEASE FROM PRESENT PORT
WTFM=27					;WRITE A FILE MARK
SPFWDR=31				;SPACE FORWARD A RECORD
SPBAKR=33				;SPACE BACKWARD A RECORD
WTCKF=51				;WRITE CHECK FORWARD
WTCKR=57				;WRITE CHECK REVERSE
WTF=61					;WRITE FORWARD
WTFLIG=65				;WRITE FORWARD WITH LONG IRG
RDF=71					;READ FORWARD
RDR=77					;READ REVERSE

;* MASSBUSS DEVICE STATUS REGISTER BIT ASSIGNMENTS (DRSR REG-01)

;COMMON BIT ASSIGNMENTS

ATA=1B20				;ATTENTION ACTIVE (CAUSES ATTN SUMMARY)
CERR=1B21				;COMPOSITE ERROR (MUST CHECK ERROR REGS)
PIP=1B22				;POSITIONING IS IN PROGRES
MOL=1B23				;MEDIUM IS ON LINE
WRL=1B24				;DRIVE HAS BEEN MANUALLY WRITE PROTECTED
NEUT=1B26				;DRIVE NOT BUSY ON EITHER PORT
DPR=1B27				;DRIVE PRESENT (ALWAYS=1 IF SINGLE PORT)
DRY=1B28				;DRIVE READY TO ACCEPT ANOTHER COMMAND
VV=1B29					;VOLUME VALID

;FOR MAG-TAPE DEVICES

SLA=1B35				;SLAVE ATTENTION
BOT=1B34				;TAPE AT BOT
EOF=1B33				;END OF FILE DETECTED
IDB=1B32				;IDENTIFICATION BURST READ
SDWN=1B31				;SLOWING-SETTLING DOWN
PES=1B30				;PHASE ENCODED STATUS
SSC=1B29				;SLAVE STATUS CHANGE
EOT=1B25				;END OF TAPE

;*BIT ASSIGNMENTS FOR MASSBUSS FRAME COUNTER REGISTER (DRFC REG-05)

FRAMES=177777B35			;MASK FOR 16-BIT FRAME COUNT
FCE=1B26				;FRAME COUNT ERROR BIT
RH20DV:	SETOM	RH20#			;SET RH20 DEVICE FLAG
	CAILE	B,7			;SKIP IF RH20 NUMBER GIVEN
	JRST	EXECDV			;NO, ERROR
	MOVE	B			;GET NUMBER
	LSH	2			;COMPUTE LOGOUT AREA OF CHANNEL
	ORI	377000			;SET UP RELOCATABLE ADDRESS
	MOVEM	MSLOWC#			;SAVE ADDRESS
	ADDI	2			;GET LOGOUT WORD ADDRESS
	MOVEM	MSLOW2#			;SAVE IT
	MOVE	[RHSTCR!LR!<-1B29&BLKCNT>!RDF!PCLP!STORE]
	MOVEM	MSRD			;STORE READ COMMAND
	MOVEI	MSCMD			;GET ADDRESS OF TRANSFER COMMAND
	TLO	(1B1)			;SET CONTINUE BIT
	MOVEM	MSJUMP#			;SAVE CHANNEL JUMP COMMAND
	MOVEI	RH.ERS			;GET CONI ERROR BITS FOR RH20
	MOVEM	ERRBTS#			;SAVE
	MOVE	A,[POINT 7,[BYTE (7) RH0_-2,RH1_-2,RH2_-2,RH3_-2,RH4_-2,RH5_-2,RH6_-2,RH7_-2]]
	IBP	A			;INCREMENT BYTE POINTER
	SOJGE	B,.-1			;  TO CODE NUMBER REQUESTED
	LDB	B,A			;GET DEVICE CODE
	CAIGE	B,20			;SKIP IF LEGAL CODE
	JRST	EXECDV			;NO, ERROR
	LSH	B,^D26			;POSITION DEVICE CODE
MSDV:	OR	B,[CONO MBCCLR]
	MOVEM	B,TAPECL		;LOAD TAPECL WITH CONO INSTRUCTION
	HRRI	B,MBE!XECLR!RCLPA!DNCLR!RAECLR	;GET START BITS
	MOVEM	B,TAPEGO		;LOAD TAPEGO
	TLO	B,(4B14)		;CHANGE TO CONI
	HLLZM	B,TAPERD		;LOAD TAPERD
	TLZ	B,(20B14)		;CHANGE TO DATAI
	HLLZM	B,TAPEEX		;LOAD TAPEEX
	TLC	B,(14B14)		;CHANGE TO BLKO
	HLLZM	B,TAPELD		;LOAD TAPELD
	GO	UNIT			;GET UNIT NUMBER
	CAILE	77			;CHECK IF LEGAL
	JRST	EXECDV			;NO, ERROR
	DPB	[POINT 3,MSRESO,35]	;LOAD SLAVE NUMBER IN CONTROL REG
	LSH	-3			;GET DRIVE NUMBER
	MOVE	B,[XWD -9,MSRESO]	;GET POINTER TO DATAO WORDS
	MOVSI	A,(POINT 3,(B),17)	;GET BYTE POINTER
	DPB	A			;LOAD DRIVE NUMBER
	AOBJN	B,.-1			;INTO ALL DATAO WORDS
	MOVEI	B,2			;SET DENSITY CODE TO 800 BPI
	GO	ASKDEN			;ASK WHICH DENSITY
	LSH	B,1			;MAKE IT 1600 PBI
	DPB	B,[POINT 3,MSRESO,27]	;LOAD INTO TAPE CONTROL REGISTER
	MOVE	[[EXP MSREAD,MSREVS,MSFORW,MSREW],,READBL]
	BLT	REW			;SET UP DISPATCH LOCATIONS TO MS ROUTINES
	GO	MSRSET			;RESET THE CONTROLLER
	HRROI	MSSTAT-1		;SELECT STATUS REGISTER
	GO	BLOCKO
	XCT	TAPEEX			;READ THE STATUS OF DRIVE SELECTED
	TRNN	MOL			;CHECK IF DRIVE ON-LINE
	JRST	EXECDV			;NO, ERROR
	XCT	TAPERD			;READ CONI STATUS
	MOVSI	A,-^D512		;SET UP WORD COUNT
	TLNE	(DF22F)			;CHECK IF DF10 IN 22 BIT ADDRESS MODE
	LSH	A,4			;YES, SHIFT OVER WORD COUNT
	HRRI	A,RBUF-1		;SET IN ADDRESS
	MOVEM	A,CHNCMD		;STORE IN CHANNEL COMMAND LIST
	RTN
MSREAD:	SKIPN	KLFLG
	JRST	.+10			;NOT A KL10
	MOVE	417
	MOVEM	$SV417#			;SAVE PRESENT ENTRY
	MOVEI	540000			;RELOCATE RH20 CHANNEL AREA
	MOVEM	417			;THRU ADR 377000
	CONI	PAG,0
	TRO	0,TRPENB
	CONO	PAG,@0

RHREAD:	MOVE	MSJUMP			;GET CHANNEL JUMP COMMAND
	MOVEM	@MSLOWC			; IN CHANNEL LOCATION

	MOVEI	W,RETRY			;RETRY COUNTER

MSRTRY:	GO	MSRSET			;RESET THE RH20
	HRROI	MSRD-1			;ISSUE A READ
	GO	BLOCKO			;  COMMAND TO CHANNEL
	XCT	TAPERD			;READ CHANNEL STATUS
	TRNN	CMDDN!DRATTN!ATTNEN	;WAIT FOR DONE FLAG
	JRST	.-2
	TDNE	ERRBTS			;CHECK IF ANY CHANNEL ERRORS
	JRST	CHECK5			;YES, GO SEE IF WANT TO RETRY
	GO	MSRDY			;READ THE STATUS
	JFCL
	TRNE	EOF			;CHECK IF READ AN EOF
	JRST	RDEOF			;YES, GIVE EOF RETURN
	HRROI	MSERR-1			;READ ERROR REGISTER
	GO	BLOCKO			;OF TAPE UNIT
	XCT	TAPEEX			;READ ERROR BITS
	TRNE	FRAMES-FCE		;CHECK IF ERROR OTHER THAN LENGTH ERROR
	JRST	CHECK5			;ERROR
	HRRZ	@MSLOW2			;GET CHANNEL TERMINATION WORD
	SKIPN	RH20			;DON'T SKIP IF CHANNEL A DF10
	JRST	WDCNT
	SOS				;RH20, ADJUST TERMINATION ADDRESS
	PUT	0
	SKIPN	KLFLG
	JRST	.+5
	MOVE	$SV417
	MOVEM	417			;RESTORE C(417)
	CONI	PAG,0
	CONO	PAG,@0			;RESET PAGING
	GET	0
	JRST	WDCNT			;SET UP WORD COUNT IN BUFFER

CHECK5:	SOSGE	W			;SHOULD WE TRY AGAIN?
	GO	ERR9			;NO
	GO	MSRSET			;RESET ERROR STATUS
	HRLI	-2			;SET FRAME COUNT TO -1
	GO	MSGO			;  AND BACKSPACE THE TAPE
	GO	ERR11			;ERROR
	JRST	MSRTRY			;NOW TRY AGAIN
MSREVS:	GO	MSRSET			;RESET ERROR STATUS
	HRROI	MSBSR-1			;BACKSPACE THE TAPE
	GO	MSGO			;  AND WAIT TILL DONE
	TRNN	EOF			;SKIP IF EOF SET
	JRST	REVSER			;ERROR, REWIND AND TRY AGAIN
	RTN

MSFORW:	GO	MSRSET			;RESET ERROR STATUS
	HRROI	MSFSR-1			;SORWARD SPACE THE TAPE
	GO	MSGO			;AND WAIT TILL DONE
	TRNN	EOF			;SKIP IF EOF SET
	GO	ERR12			;ERROR
	RTN

MSREW:	GO	MSRSET			;RESET ERROR STATUS
	HRROI	MSREWD-1		;REWIND THE TAPE
	GO	MSGO			;AND WAIT TILL DONE
	JFCL
	JRST	REWEND			;MARK CURRENT FILE AT 0
MSCMD:	3B1!^D512B13!RBUF		;RH20 CHANNEL COMMAND
MSRESO:	DRTC!LR				;LOAD CONTROL REGISTER
MSCFC:	DRFC!LR!0			;CLEAR FRAME COUNTER
	DRFC!LR!<-1&RDAT>		;SET FRAME COUNTER TO -1
MSBSR:	DRCR!LR!SPBAKR			;BACKSPACE COMMAND
MSRD:	RHSTCR!LR!<-1B29&BLKCNT>!RDF!PCLP!STORE	;READ FROM TAPE
MSSTAT:	DRSR				;SELECT STATUS REGISTER
MSERR:	DRER1				;SELECT ERROR REGISTER
MSFSR:	DRCR!LR!SPFWDR			;SKIP COMMAND
MSREWD:	DRCR!LR!RWND			;REWIND COMMAND

MSRSET:	XCT	TAPECL			;CLEAR TAPE CONTROLLER
	XCT	TAPEGO			;ENABLE THE CONTROLLER
	MOVE	[IOWD 2,MSRESO]		;SELECT AND SET UP DRIVE
	GO	BLOCKO			;CLEAR FRAME COUNTER
	RTN

MSGO:	GO	BLOCKO			;START REQUESTED COMMAND
MSRDY:	HRROI	MSSTAT-1		;SELECT STATUS REGISTER
	GO	BLOCKO
	XCT	TAPEEX			;READ STATUS
	TRNN	PIP			;LOOK FOR DRIVE READY
	TRNN	DRY			;  AND POSITIONING NOT IN PROGRESS
	JRST	MSRDY			;KEEP WAITING
	TRNN	CERR			;CHECK FOR ERRORS
	AOS	(P)			;NO ERROR, SKIP RETURN
	RTN				;RETURN
RH10DV:	SETZM	RH20			;CLEAR RH20 DEVICE FLAG
	CAIL	B,20			;CHECK IF A DEVICE CODE SPECIFIED
	JRST	RH10DC			;YES
	CAILE	B,6			;CHECK IF A LEGAL NUMBER SPECIFIED
	JRST	EXECDV			;NO
	MOVE	A,[POINT 7,[BYTE (7) DH_-2,DH2_-2,DH3_-2,DH4_-2,DH5_-2,DH6_-2]]
	IBP	A			;INCREMENT BYTE POINTER TO REQUESTED
	SOJG	B,.-1			;  DEVICE CODE
	LDB	B,A			;GET DEVICE CODE
	LSH	B,2			;POSITION
RH10DC:	LSH	B,^D24			;POSITION TO PLACE IN INSTRUCTION
	ORI	B,734330		;INITIALIZE RH10 BITS

	MOVEI	LOWCMD			;GET ADDRESS OF ICCW
	MOVEM	MSLOWC			;SAVE IT
	MOVEI	LOWCMD+1		;GET TERMINATION WORD ADDRESS
	MOVEM	MSLOW2			;SAVE IT
	MOVE	[DHSTRC!LR!RDF!<LOWCMD>B29]	;GET RH10
	MOVEM	MSRD			;  READ COMMAND
	MOVEI	CHNCMD			;GET ADDRESS OF DF10 XFER WORD
	MOVEM	MSJUMP			;SAVE DF10 JUMP INSTRUCTION
	MOVEI	577700			;GET RH10 ERROR BITS
	MOVEM	ERRBTS			;SAVE THEM
	JRST	MSDV			;GO SET UP I/O INSTRUCTIONS
;*ERROR - ERROR REPORTING

ERROR:	PUSH	P,1
	GO	CRLF1
	POP	P,1
	GO	SIXBP
	PMSG	< ERROR AT >
	GET	0
	SOS
	GO	PNTOCT			;PRINT PC OF ERROR
	MOVEI	" "
	GO	PRINT
	GO	NAMPNT
	MOVEI	-1			;SET MAGTAPE FLAG TO NOTE
	MOVEM	MAGONCE			;MAGTAPE POSITION IS UNKNOWN
	SKIPN	ONCE			;INITIAL LOAD ERROR ?
	JRST	SELX1			;YES
	SKIPE	PGMGO
	JRST	SELECT
	JRST	RUN



;*NFERR1 - PROGRAM NOT FOUND ERROR

NFERR1:	PMSG	<^PROGRAM NOT FOUND - >
	GO	NAMPNT
	RTN
SUBTTL	ERROR REPORTER

;*ERROR REPORT MESSAGES

ERR2:
LERR2:	MOVE	A,[SIXBIT/ILLEOF/]
	JRST	ERROR
LERR3:	MOVE	A,[SIXBIT/FLTYPE/]
	JRST	ERROR
LERR4:	MOVE	A,[SIXBIT/FORMAT/]
	JRST	ERROR
LERR5:	MOVE	A,[SIXBIT/CKSUM/]
	JRST	ERROR

ERR6:	MOVE	A,[SIXBIT/1STPTR/]
	JRST	ERROR
ERR7:	MOVE	A,[SIXBIT/STADR/]
	JRST	ERROR
ERR8:	MOVE	A,[SIXBIT/OPEN/]
	JRST	ERROR
ERR9:	MOVE	A,[SIXBIT/READ/]
	JRST	ERROR
ERR10:	MOVE	A,[SIXBIT/CORE/]
	JRST	ERROR
ERR11:	MOVE	A,[SIXBIT/BKSPAC/]
	JRST	ERROR
ERR12:	MOVE	A,[SIXBIT/SKPFIL/]
	JRST	ERROR
ERR13:	MOVE	A,[SIXBIT/DIR RD/]
	JRST	ERROR
ERR14:	MOVE	A,[SIXBIT/DEVICE/]
	JRST	ERROR
ERR15:	MOVE	A,[SIXBIT/DENSET/]
	JRST	ERROR
SUBTTL	STORAGE ASSIGNMENTS
	LIT
	VAR
PGNAME:	SIXBIT /MAGMON/			;PROGRAM NAME
PLIST:	BLOCK	40			;PUSH LIST

PGMGO:	0				;LOAD & GO FLAG
TAPEPF:	0				;PRINT TAPE FLAG
DEVFLG:	0				;CMD LIST FROM DEVICE FLAG
DINFLG:	0				;DEVICE IN FLAG
LPTFLG:	0				;LINE PRINTER FLAG
LSTFLG:	0				;LISTING FLAG
DIRFLG:0				;DIRECTORY FLAG
ALTMFLG:0				;ALTMODE FLAG
CLKFLG:	0
USRFLG:	0
CNSFLG:	0
MGNONC:	0
MGNCNT:	0
MGNWRD:	0
MGNADR:	0
RACKF:	0

SCFLAG:	0				;PROCESSING COMMENT FLAG
SAVEIP:	0				;COMMAND LIST POINTER SAVE
RUNCTL:	0				;RUN CONTROL
CHRCTR:	0				;PRINT CHAR COUNTER
SAVAC0:	0				;AC SAVE
SAVAC1:	0				; "
FCRCNT:	0				;CR FILLER COUNT
FLFCNT:	0				;LF FILLER COUNT

READBL:	0				;DISPATCH TO READ A DATA RECORD FROM TAPE
REVERS:	0				;	"	MOVE TAPE REVERSE OVER FILE
FORWRD:	0				;	"	MOVE TAPE FORWARD OVER FILE
REW:	0				;	"	REWIND TAPE


TAPECL:	0				;I/O INSTRUCTION TO CLEAR TAPE UNIT
TAPERD:	0				;	"	 TO READ TAPE STATUS
TAPELD:	0				;	"	 TO LOAD TAPE STATUS
TAPEGO:	0				;	"	 TO START TAPE MOTION
TAPEEX:	0				;	"	 TO READ CONTROLLER STATUS

TAPEDN:	2001				;TAPOP. CODE TO SET DENSITY
	LDCHN				;MAGTAPE CHANNEL NUMBER
TAPEDC:	3				;3 = 800 BPI, 4 = 1600 BPI
SELSTR:					;COMMAND SELECTION STORE
LDCNT:	0				;A10 LOAD COUNT
LDADR:	0				;A10 LOAD ADDRESS
LDATA:	BLOCK ^D34-16			;A10 DATA STORAGE
ACSAVE:	BLOCK	16
LDATAE:	0				;A10 END OF DATA STORAGE
	0

	0
LDNAME:	SIXBIT/NAME/
	SIXBIT/EXT/
	0
	0

LDBLK:	13
	SIXBIT/DSK/
	LDBUF
LDBUF:	BLOCK	3


	LOC	26000-3
LDBF:	0
	201,,LDBF1+1
	0
RBUF:	BLOCK	200

LDBF1:	0
	201,,LDBF2+1
	0
	BLOCK	200

LDBF2:	0
	201,,LDBF+1
	0
	BLOCK	200

	LOC	27001
INLIST:	
SUBTTL	SPECIAL STARTUP MESSAGES AND INITIALIZATION

;*HEADER

DEFINE	PTITLE	(MCNVER,DECVER)	<
	ASCIZ	%
* MAGMON [DDQDE] -DECSYSTEM DIAGNOSTIC MAGTAPE MONITOR - VER MCNVER'.'DECVER *
%   >

HEADER:	PTITLE	\MCNVER,\DECVER
;*HELP

HELP:	ASCIZ	%
NORMAL START = 20000
RESTART/ABORT = 20001
PRINT TEST TITLE = 20002
RESTART CURR TEST = 20003

DEVICES:  EXEC MODE;
T = TM10 CONTROLLER (TU10,TU20,TU30,TU40)  DEVICE CODES 340&344
  T2 = SECOND TM10  DEVICE CODES 350&354
D = DX10/TXO1 CONTROLLER (TU70)  DEVICE CODE 220
  D2 = SECOND DX10  DEVICE CODE 224
  D3 = THIRD DX10   DEVICE CODE 034
R = RH10 CONTROLLER (TU16)  DEVICE CODE 270
  R2 = SECOND RH10  DEVICE CODE 274
  R3 = THIRD RH10   DEVICE CODE 360
  R4 = FOURTH RH10  DEVICE CODE 364
  R5 = FIFTH RH10   DEVICE CODE 370
  R6 = SIXTH RH10   DEVICE CODE 374
THE ABOVE DEVICE LETTERS (T,D,R) MAY ALSO BE FOLLOWED BY A THREE DIGIT
OCTAL NUMBER TO SPECIFY A NON-STANDARD DEVICE CODE
  EX. T360  FOR TM10 WITH DEVICE CODES 360&364

M = RH20 MASSBUS CONTROLLER (TU16,TU45)  DEVICE CODE 540
  M1 = SECOND RH20  DEVICE CODE 544
  M2 = THIRD RH20   DEVICE CODE 550
  M3 = FOURTH RH20  DEVICE CODE 554
  M4 = FIFTH RH20   DEVICE CODE 560
  M5 = SIXTH RH20   DEVICE CODE 564
  M6 = SEVENTH RH20 DEVICE CODE 570
  M7 = EIGHTH RH20  DEVICE CODE 574
ALL DEVICES THEN ASK FOR UNIT #
FOR DEVICES T & D: A SINGLE DIGIT (0 - 7) MUST BE SPECIFIED
  (IF DEVICE IS DX10, ONLY 9-TRACK DRIVES MAY BE USED)
FOR DEVICES M & R: A TWO DIGIT NUMBER IS USED (FIRST DIGIT SPECIFIES
  DRIVE # OF TM02, SECOND DIGIT SPECIFIES SLAVE # OF TRANSPORT)

DEVICES:  USER MODE;
MAGTAPE = PHYSICAL NAME OF UNIT   (EX. MTA0)
DISK = ONLY A CARRIAGE RETURN

COMMANDS;
STD=START DIAGNOSTIC
STM=REINITIALIZE START
STL=START LOADER
START=START DIAGNOSTIC
SFSTRT=SPECIAL FEATURE START
PFSTRT=POWER FAIL START
REE=REENTER
DDT=DDT
START1=SPECIAL START 1
START2=SPECIAL START 2
START3=SPECIAL START 3
START4=SPECIAL START 4
START5=SPECIAL START 5

R=RESELECT, X=XPN, I=INTERNAL, T=TTY, D=DEVICE,
S=SINGLE, F=DIR, L=LIST, G=GO
%
;*TYBAUD - COMPUTE CR & LF FILLERS REQUIRED FOR DIFFERENT BAUD RATES

TYBAUD:	SKIPE	USER
	RTN
	MOVEI	1,60
	CONO	APR,1000		;CLEAR AND WAIT FOR CLOCK
	CONSO	APR,1000
	JRST	.-1
	CONO	APR,1000
	SETZB	0,2

TYBD1:	DATAO	TTY,2			;COUNT # OF CHARS SENT IN 1 SEC
	AOS
TYBD2:	CONSO	TTY,10
	JRST	TYBD3
	JRST	TYBD1			;TTY DONE, SEND ANOTHER CHAR
TYBD3:	CONSO	APR,1000		;HAS CLOCK TICKED ?
	JRST	TYBD2			;NO
	CONO	APR,1000		;YES, COUNT DOWN JIFFIES
	SOJGE	1,TYBD2

TYBD4:	CONSO	TTY,10			;WAIT TILL TTY GETS DONE
	JRST	.-1
	MOVEI	1,5			;5 = 2400 BAUD
	CAIG	0,^D122
	SOS	1			;4 = 1200 BAUD
	CAIG	0,^D62
	SOS	1			;3 = 600 BAUD
	CAIG	0,^D32
	SOS	1			;2 = 300 BAUD
	CAIG	0,^D16
	SOS	1			;1 = 150 BAUD
	CAIG	0,^D12
	SOS	1			;0 = 110 BAUD
	MOVEM	1,TTYSPD		;SAVE

TYBD5:	SETZM	2
	CAIN	1,5
	MOVEI	2,4			;4 FILLERS @ 2400
	CAIN	1,4
	MOVEI	2,2			;2 FILLERS @ 1200
	CAIN	1,3
	MOVEI	2,1			;1 FILLER @ 600
	MOVEM	2,FCRCNT		;FOR CR
	MOVEM	2,FLFCNT		;FOR LF
	CAIE	1,2			;IF 300 BAUD
	RTN
	MOVEI	2,^D9			;USE 9 FILLERS FOR CR
	MOVEM	2,FCRCNT		;IN CASE LA30
	RTN

	END	JRST	ONETIM
       