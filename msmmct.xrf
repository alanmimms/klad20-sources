   1	%TITLE 'STIRS TESTS FOR M8618 (MMC) BOARD'
   2	
   3	MODULE MSMMCT	(
   4			LANGUAGE(BLISS36)
   5			) =
   6	
   7	BEGIN
   8	
   9	!
  10	!			  COPYRIGHT (C) 1979 BY
  11	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.  
  12	!
  13	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
  14	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
  15	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
  16	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
  17	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
  18	! TRANSFERRED.
  19	!
  20	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
  21	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
  22	! CORPORATION.
  23	!
  24	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
  25	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
  26	!
  27	
  28	!++
  29	! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
  30	!
  31	! ABSTRACT:
  32	!
  33	!	THIS MODULE CONTAIN THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
  34	!	(STIRS) DIAGNOSTIC FOR THE M8618 (MMC) BOARD.  IT ALSO CONTAINS SEVERAL
  35	!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
  36	!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
  37	!	'MSMMCD' MODULES TO PRODUCE THE 'MSMMC.EXE' FILE.
  38	!
  39	! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
  40	!
  41	! AUTHOR: Richard Stockdale	, CREATION DATE: 23-MAY-79
  42	!
  43	! MODIFIED BY:
  44	!
  45	!	Richard Stockdale, 23-MAY-79; VERSION 0.1
  46	!--
  47	
  48	
  49	!  PROGRAM DESCRIPTION:
  50	!
  51	!
  52	!    This program is one of a series  of STIRS  diagnostics.  The STIRS
  53	! package  consists  of three modules - the  Control Module MSSTRC, the
  54	! Test Module (MSMMC in this case), and the Data Module (MSMMC in  this
  55	! case.
  56	!
  57	!    The Control Module  handles  the  running  of  the diagnostic  for
  58	! handling all of the  communication  with the CSL program  to the KS10
  59	! and for determining which test to run based on which program switches
  60	! are set (loop on test ...).  Also the Control Module  does  the fault
  61	! isolation calculations based on the data passed by the Test Module in
  62	! ERROR and NOERR routine calls.
  63	!
  64	!    The Test Module does all of the  testing  of  the  MMC board.  The
  65	! Control Module just decides which test to run and then  goes  to  the
  66	! Test Module  and  runs  it.  The Test Module may find errors in which
  67	! case it calls routine ERROR.  In some cases it may call routine NOERR
  68	! it no errors  have  occurred in a particular test or tests.  The Test
  69	! Module also contains  any additional routines required by the various
  70	! tests  and a few routines SPEC_PRT, SPEC_ASK, and TEST_INIT which are
  71	! required  by the Control Module.
  72	!
  73	!    The Test Module (for the MMC board, at least) does fault isolation
  74	! in addition to that done by the Control Module.  This is done only to
  75	! limit amount of testing done to tests which are appropriate  based on
  76	! what errors have already occurred.  The fault  isolation  done by the
  77	! Control Module causes tests not to be run if  there  are  no networks
  78	! specified in the error network description for each error in the test.
  79	! This method will cause a subset of tests to be run.  However, for the
  80	! MMC board, the number of possible faulty networks for each test is so
  81	! broad and covers so much of the board that this method of restricting
  82	! which tests are to be run is insufficient.  So the method selected to
  83	! help  determine  which  tests to run is implemented using the routine 
  84	! RUN_TEST  which  is  called  at the beginning of each test.  RUN_TEST 
  85	! examines a set of  error  flags  set  by individual tests in the Test
  86	! Module.  If any  of  the error flags are set which match a predefined
  87	! set of flags  for the particular test (ie. if flag 1 is set don't run
  88	! Test 14) then the test is not run.  The flags are as follows:
  89	! 
  90	!   MRE_MEM   -   A ?MRE occurred when it shouldnt have on a memory access
  91	!   MRE_IO    -   A ?MRE occurred when it shouldnt have on an I/O access
  92	!   MRE_MEM_NOT - A ?MRE did not occur when it should have on a mem access
  93	!   MRE_IO_NOT -  A ?MRE did not occur when it should have on an I/O access
  94	!   MSR_READ   -  Could not read MSR
  95	!   MSR_WRITE  -  Could not write MSR
  96	!   MEM_READ   -  Could not read memory
  97	!   MEM_WRITE  -  Could not write memory
  98	!   TEST_ABORT -  A conclusive error occurred so abort future testing
  99	!   ECC_SINGLE -  Could not get a single bit ECC error
 100	!   ECC_DOUBLE -  Could not get a double bit ECC error
 101	!   BUS_XCVR   -  Bus transceiver would not work
 102	! 
 103	! The use of these flags can be seen easily by example. For example, if
 104	! the first test to attempt to read  the  MSR fails when it tries to do
 105	! so, then no other tests would be attempted which required the ability
 106	! to read  MSR.   Or  if  an early test fails to set ?MRE then some the 
 107	! timing tests (which require ?MRE  to  be  set in order to run at all)
 108	! would  not  be  run  at all.  The TEST_ABORT flag is set whenever the
 109	! error found in a particular test is such that  the number of possible
 110	! faulty networks is very low.  There is no point in  running  any more
 111	! tests because the fault is well isolated already.
 112	! 
 113	!    Last of all is the Data Module. This really exists only at compile
 114	! time.  It actually gets merged with the Test Module  and  the Control
 115	! Module when MSMMC.EXE is  created.  It is created by a SNOBOL program
 116	! taking  ERROR  and  NOERR network data out the the Test Module source
 117	! code and creating a set of  PLIT's  and so forth for use by the fault
 118	! isolation and error handling of the Control Module.
 119	!			STIRS TESTS FOR MMC - M8618 BOARD
 120	!
 121	!
 122	! SEQUENCE OF TESTS:
 123	!
 124	!	[1] Verify bus transceivers - connection to the bus	TST1
 125	!								TST2
 126	!
 127	!	[2] Verify ability to read/write status			TST3
 128	!
 129	!	[3] Verify ability to read/write memory			TST4
 130	!
 131	!	[4] Verify read/write control bits			TST5
 132	!
 133	!	[5] Examine/deposit memory - Functional test		TST6
 134	!
 135	!	[6] Misc tests:  Verify 8080 reg bits when quiescent	TST7
 136	!			 Verify 8646 parity generation		TST8
 137	!
 138	!	[7] Address logic tests - Board select logic		TST9
 139	!				  Word enable logic		TST10
 140	!				  Row/col logic			TST11
 141	!				  Row/col logic			TST12
 142	!				  Row/col logic			TST13
 143	!
 144	!	[8] Verify MSR - Read address logic			TST14
 145	!			 Write address logic			TST15
 146	!			 Write address logic			TST16
 147	!			 MSR bits				TST17
 148	!			 Parity error checking			TST18
 149	!			 Error address register			TST19
 150	!			 Force bits				TST20
 151	!			 Parity generators			TST21
 152	!			 Force check bits (loading of)		TST22
 153	!			 Err.addr.register (loading of)		TST23
 154	!			 Bus reset				TST24
 155	!			 Mixers & select logic			TST25
 156	!
 157	!	[9] ECC Tests - 'MMC5 READ ERROR'			TST26
 158	!			Detect single bit error			TST27
 159	!			Detect double bit error			TST28
 160	!			'MMC5 ERR HOLD'				TST29
 161	!			Single bit error - no correction	TST30
 162	!			Single bit error - correction		TST31
 163	!			Single bit error - no correction	TST32
 164	!			Single bit error - correction		TST33
 165	!			Double bit error			TST34
 166	!			Double bit error			TST35
 167	!			Double bit error			TST36
 168	!			Double bit error			TST37
 169	!	[10] Examine/deposit memory - Functional test		TST38
 170	!
 171	!	[11] Misc - ?MRE causes 'ERR HOLD','ERR ADD LOAD'	TST39
 172	!		    ?MRE - NXM afterwards			TST40
 173	!
 174	!	[12] Read/write timing - I/O write			TST41
 175	!				 I/O read			TST42
 176	!				 Memory write			TST43
 177	!				 ?NXM				TST44
 178	!				 Good vs. bad data cycle	TST45
 179	!
 180	!	[13] Refresh - 'REF ERR' set by ?MRE			TST46
 181	!		       Refresh timing				TST47
 182	!		       Refresh cycle				TST48
 183	!		       Sync refresh debug routine		TST49
 184	!		       Does mem actually get refreshed?		TST50
 185	!
 186	!	[14] MISC -    ECC - Verification of Check Bits		TST51
 187	!		       not written				TST52
 188	!		       not written				TST53
 189	!		       not written				TST54
 190	!		       not written				TST55
 191	!
 192	! TABLE OF CONTENTS:
 193	!
 194	
 195	FORWARD ROUTINE
 196		TST1:		NOVALUE,	! 8646 Bus Transceivers
 197		TST2:		NOVALUE,	! Verify Control Signals on the Bus
 198		TST3:		NOVALUE,	! Simple Write/Read Status
 199		TST4:		NOVALUE,	! Simple Write/Read Memory
 200		TST5:		NOVALUE,	! 'MMC3 READ','MMC3 WRITE' control bits
 201		TST6:		NOVALUE,	! 8646's, MOS Drivers, Data Path
 202		TST7:		NOVALUE,	! Verify 8080 Reg Bits When Mem Quiet
 203		TST8:		NOVALUE,	! 8646 Parity Gen/Chk
 204		TST9:		NOVALUE,	! Word Group Address Logic
 205		TST10:		NOVALUE,	! Word Group Address Logic
 206	
 207		TST11:		NOVALUE,	! Row/Col Address Logic
 208		TST12:		NOVALUE,	! Row/Col Address Logic
 209		TST13:		NOVALUE,	! Row/Col Address Logic
 210		TST14:		NOVALUE,	! MSR Read Address Logic
 211		TST15:		NOVALUE,	! MSR Write Address Logic
 212		TST16:		NOVALUE,	! MSR Write Address Logic
 213		TST17:		NOVALUE,	! Memory Status Register
 214		TST18:		NOVALUE,	! Parity Error
 215		TST19:		NOVALUE,	! Error Address Register
 216		TST20:		NOVALUE,	! Force Bits
 217	
 218		TST21:		NOVALUE,	! ECC:  Parity Gen's For Check Bits
 219		TST22:		NOVALUE,	! Force Check Bits Loading Of
 220		TST23:		NOVALUE,	! Error Address Register Loading Of
 221		TST24:		NOVALUE,	! Bus Reset
 222		TST25:		NOVALUE,	! Mixers & Select Logic
 223		TST26:		NOVALUE,	! ECC: Determining 'MMC5 READ ERROR'
 224		TST27:		NOVALUE,	! ECC:  Detection of Single Bit Errors
 225		TST28:		NOVALUE,	! ECC:  Detection of Double Bit Errors
 226		TST29:		NOVALUE,	! ECC:  Setting of 'ERR HOLD' Bit
 227		TST30:		NOVALUE,	! ECC:  1-Bit Error No Correction
 228	
 229		TST31:		NOVALUE,	! ECC:  1-Bit Error Correction
 230		TST32:		NOVALUE,	! ECC:  1-Bit Error No Correction
 231		TST33:		NOVALUE,	! ECC:  1-Bit Error Correction
 232		TST34:		NOVALUE,	! ECC:  2-Bit Error No Correction
 233		TST35:		NOVALUE,	! ECC:  2-Bit Error No Correction
 234		TST36:		NOVALUE,	! ECC:  2-Bit Error No Correction
 235		TST37:		NOVALUE,	! ECC:  2-Bit Error No Correction
 236		TST38:		NOVALUE,	! 8646's, MOS Drivers, Data Path
 237		TST39:		NOVALUE,	! ?MRE ==> MMC5 ERR HOLD / ERR ADD LOAD
 238		TST40:		NOVALUE,	! ?MRE / ?NXM
 239		TST41:		NOVALUE,	! Timing Of An I/O Write Instruction
 240		TST42:		NOVALUE,	! Timing Of An I/O Read Instruction
 241		TST43:		NOVALUE,	! Lengh of a Memory Write Access
 242		TST44:		NOVALUE,	! How Long Does ?NXM Tie Up MMC
 243		TST45:		NOVALUE,	! MMC Timing:  Good vs. Bad Data Cycle
 244		TST46:		NOVALUE,	! 'MMC9 REFRESH ERR' Set By ?MRE Error
 245		TST47:		NOVALUE,	! Refresh Timing
 246		TST48:		NOVALUE,	! Timing Test of Refresh Cycle (Length)
 247		TST49:		NOVALUE,	! Sync Refresh Debug Routine
 248		TST50:		NOVALUE,	! Refresh Test - Mem Getting Refreshed?
 249	
 250		TST51:		NOVALUE,	! ECC - Verification of Check Bits
 251	
 252		INIT:		NOVALUE,	! Reset Routine
 253		TEST_INIT:	NOVALUE,	! Initial Testing Initialization
 254		RUN_TEST,			! Determine if this test should be run
 255		SPEC_DIALOGUE:	NOVALUE,	! Special user I/O (not used)
 256		SPEC_PRT:	NOVALUE,	! Print the special specs (switches)
 257		SPEC_ASK:	NOVALUE,	! Ask for special questions
 258		WRITE_STATUS:	NOVALUE,	! Write MSR via 8080 regs
 259		READ_BUS,			! Read current contents of the bus
 260		HANG_MEM:	NOVALUE,	! Hang memory (causes refresh error)
 261		WRITE_COMADR:	NOVALUE,	! Write com/adr data to 8080 regs
 262		WRITE_DATA:	NOVALUE,	! Write data data to 8080 regs
 263		WRITE_CONTROL:	NOVALUE,	! Write control data to 8080 regs
 264		WRITE_CONTROL1:	NOVALUE,	! Write most of the control data
 265		SYNC_REFRESH;			! Synchronize refresh error occurrence
 266	
 267	!
 268	! EQUATED SYMBOLS:
 269	!
 270	
 271	GLOBAL LITERAL
 272		TEST_VERSION = 1,		! Current version and edit
 273		TEST_EDIT = 0;			!   numbers
 274	
 275	LITERAL
 276		ECC_OFF = 1,			! MSR code for turning ECC off
 277		ECC_ON = 0,			! MSR code for turning ECC on
 278		PE_SET = %O'040000000000',	! MSR code for setting PE
 279		PE_CLR = 0,			! MSR code for clearing PE
 280		MSR = %O'100000';		! MSR I/O address
 281	
 282	GLOBAL BIND
 283		MSGFIL = UPLIT (%SIXBIT'MSMMC', %SIXBIT'MSG'),
 284		PRGNAM = UPLIT (%ASCIZ'KS10 STIMULUS-RESPONSE DIAGNOSTIC FOR THE M8618/MMC BOARD');
 285	
 286	!
 287	! OWN STORAGE:
 288	!
 289	
 290	OWN
 291		RUN_ERR_VECT: VECTOR[15],	! Used to determine if test to be run
 292						!   by keeping track of prior errors
 293		DEBUG: INITIAL(0),		! Special debugging switches mostly for
 294		DEBUG1: INITIAL(0),		!   debugging the sync refresh routine
 295		MMA_MAP: VECTOR[8]		! Memory map (1 if that block of 64k
 296		    INITIAL (0,0,0,0,0,0,0,0),	!   exists
 297		MAX_MEM,			! Max amount of memory available
 298		NOERR_MAP: VECTOR[55]		! Vector to keep track of whether or
 299		    INITIAL (-1,-1,-1,-1,-1,-1	!   not an error has occurred in a test
 300		       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
 301		       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
 302		       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,
 303		       -1,-1,-1,-1,-1,-1,-1,-1,-1,-1),
 304		MRE_TICKS: INITIAL (804);	! # of ticks from one ?MRE to the next
 305	BIND
 306		MRE_MEM = RUN_ERR_VECT[0],	! A ?MRE occurred when it shouldnt have
 307		MRE_IO = RUN_ERR_VECT[1],	!   on a memory / I/O access
 308		MRE_MEM_NOT = RUN_ERR_VECT[2],	! A ?MRE did not occur when it should
 309		MRE_IO_NOT = RUN_ERR_VECT[3],	!   have on a memory / I/O access
 310		MSR_READ = RUN_ERR_VECT[4],	! Could not read MSR
 311		MSR_WRITE = RUN_ERR_VECT[5],	! Could not write MSR
 312		MEM_READ = RUN_ERR_VECT[6],	! Could not read memory
 313		MEM_WRITE = RUN_ERR_VECT[7],	! Could not write memory
 314		TEST_ABORT = RUN_ERR_VECT[8],	! A fatal or conclusive error occurred
 315						!   so abort future testing
 316		ECC_SINGLE = RUN_ERR_VECT[9],	! Could not get a single bit ECC error
 317		ECC_DOUBLE = RUN_ERR_VECT[10],	! Could not get a double bit ECC error
 318		BUS_XCVR = RUN_ERR_VECT[11],	! Bus transceiver would not work
 319	
 320		NOERR_1 = NOERR_MAP[1],		! Did an error occur in test N
 321		NOERR_2 = NOERR_MAP[2],		!   if not NOERR_N = 0
 322		NOERR_3 = NOERR_MAP[3],		!   if so  NOERR_N # 0
 323		NOERR_4 = NOERR_MAP[4],		!	  ....
 324		NOERR_5 = NOERR_MAP[5],		!	  ....
 325		NOERR_6 = NOERR_MAP[6],
 326		NOERR_7 = NOERR_MAP[7],
 327		NOERR_8 = NOERR_MAP[8],
 328		NOERR_9 = NOERR_MAP[9],
 329		NOERR_10 = NOERR_MAP[10],
 330	
 331		NOERR_11 = NOERR_MAP[11],
 332		NOERR_12 = NOERR_MAP[12],
 333		NOERR_13 = NOERR_MAP[13],
 334		NOERR_14 = NOERR_MAP[14],
 335		NOERR_15 = NOERR_MAP[15],
 336		NOERR_16 = NOERR_MAP[16],
 337		NOERR_17 = NOERR_MAP[17],
 338		NOERR_18 = NOERR_MAP[18],
 339		NOERR_19 = NOERR_MAP[19],
 340		NOERR_20 = NOERR_MAP[20],
 341	
 342		NOERR_21 = NOERR_MAP[21],
 343		NOERR_22 = NOERR_MAP[22],
 344		NOERR_23 = NOERR_MAP[23],
 345		NOERR_24 = NOERR_MAP[24],
 346		NOERR_25 = NOERR_MAP[25],
 347		NOERR_26 = NOERR_MAP[26],
 348		NOERR_27 = NOERR_MAP[27],
 349		NOERR_28 = NOERR_MAP[28],
 350		NOERR_29 = NOERR_MAP[29],
 351		NOERR_30 = NOERR_MAP[30],
 352	
 353		NOERR_31 = NOERR_MAP[31],
 354		NOERR_32 = NOERR_MAP[32],
 355		NOERR_33 = NOERR_MAP[33],
 356		NOERR_34 = NOERR_MAP[34],
 357		NOERR_35 = NOERR_MAP[35],
 358		NOERR_36 = NOERR_MAP[36],
 359		NOERR_37 = NOERR_MAP[37],
 360		NOERR_38 = NOERR_MAP[38],
 361		NOERR_39 = NOERR_MAP[39],
 362		NOERR_40 = NOERR_MAP[40],
 363	
 364		NOERR_41 = NOERR_MAP[41],
 365		NOERR_42 = NOERR_MAP[42],
 366		NOERR_43 = NOERR_MAP[43],
 367		NOERR_44 = NOERR_MAP[44],
 368		NOERR_45 = NOERR_MAP[45],
 369		NOERR_46 = NOERR_MAP[46],
 370		NOERR_47 = NOERR_MAP[47],
 371		NOERR_48 = NOERR_MAP[48],
 372		NOERR_49 = NOERR_MAP[49],
 373		NOERR_50 = NOERR_MAP[50],
 374	
 375		NOERR_51 = NOERR_MAP[51],
 376		NOERR_52 = NOERR_MAP[52],
 377		NOERR_53 = NOERR_MAP[53],
 378		NOERR_54 = NOERR_MAP[54],
 379		NOERR_55 = NOERR_MAP[55];
 380	
 381	!
 382	! MACROS:
 383	!
 384	
 385	MACRO
 386		PAR_DISABLE = PE(0)%,		! Disable parity error detection
 387		PAR_ENABLE = PE(7)%,		! Enable parity error detection
 388		START_CLK = WRT205(0)%,		! Start the clock (was in ss mode)
 389		STOP_CLK = WRT205(MNT_CLK_ENB)%;! Stop  the clock (put in ss mode)
 390	
 391	!
 392	! STRUCTURES:
 393	!
 394	
 395	STRUCTURE
 396		BTTVECTOR[I;N]=[1]		! A real PDP-10 bit vector
 397			(BTTVECTOR)		!   (36 bits long)
 398			<35-I,1>,
 399		BIT8646[I;N]=[N]		! Special 8646 data path vector
 400			(BIT8646)
 401			<32-I*4+((I+1)/5)*2,4-(I EQL 4 OR I EQL 9)*2>;
 402	!
 403	! INCLUDE FILES:
 404	!
 405	
 406	SWITCHES LIST(NOSOURCE);
 407	REQUIRE 'STIRSD.R36';			! Stirs common declarations
 408	
 409	!
 410	!			  COPYRIGHT (c) 1977, 1978 BY
 411	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 412	!
 413	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 414	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 415	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 416	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 417	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 418	! TRANSFERRED.
 419	!
 420	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 421	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 422	! CORPORATION.
 423	!
 424	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 425	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 426	!
 427	
 428	!++
 429	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 430	!
 431	! ABSTRACT:
 432	!
 433	!	THESE ARE THE COMMON DECLARATIONS WHICH ARE USED BY THE TEST MODULES
 434	!	FOR THE DIFFERENT STIRS DIAGNOSTICS.
 435	!
 436	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 437	!
 438	! AUTHOR: ARON INSINGA, CREATION DATE: 01-SEP-78
 439	!
 440	! MODIFIED BY:
 441	!
 442	!	ARON INSINGA, 23-MAY-79: VERSION 0.1
 443	!--
 444	
 445	!
 446	! MACROS:
 447	!
 448	
 449	    MACRO
 450		LOAD_U(CRAM_ADDR,SOURCE_ADDR) = LOADUC(%O %STRING(CRAM_ADDR),SOURCE_ADDR) %,
 451		LC(O_CRAM_ADDR) = LCA(%O %STRING(O_CRAM_ADDR)) %,
 452		SET_C(O_CRAM_ADDR) = SETNXT(%O %STRING(O_CRAM_ADDR)) %,
 453		STEP_U_NEXT(N) = (CP(N);EX_NXT) %,
 454		BEGIN_XLIST = BEGIN SWITCHES LIST(NOSOURCE); %,
 455		END_LIST = SWITCHES LIST(SOURCE); END %,
 456		DM(ADDR,DATA) = MEM_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
 457		EM(ADDR) = MEM_EXAMINE(%O %STRING(ADDR)) %,
 458		DI(ADDR,DATA) = IO_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
 459		EI(ADDR) = IO_EXAMINE(%O %STRING(ADDR)) %,
 460		EX_NXT = EXNEXT() %,
 461		RD_0	= REG_EXAMINE(%O'0')%,
 462		RD_1	= REG_EXAMINE(%O'1')%,
 463		RD_2	= REG_EXAMINE(%O'2')%,
 464		RD_3	= REG_EXAMINE(%O'3')%,
 465		RD_100	= REG_EXAMINE(%O'100')%,
 466		RD_101	= REG_EXAMINE(%O'101')%,
 467		RD_102	= REG_EXAMINE(%O'102')%,
 468		RD_103	= REG_EXAMINE(%O'103')%,
 469		RD_300	= REG_EXAMINE(%O'300')%,
 470		RD_301	= REG_EXAMINE(%O'301')%,
 471		RD_303	= REG_EXAMINE(%O'303')%;
 472	
 473	!
 474	! EQUATED SYMBOLS:
 475	!
 476	
 477	    BUILTIN
 478		POINT,
 479		SCANI,
 480		REPLACEI;
 481	
 482	    EXTERNAL ROUTINE
 483		CONTROL: NOVALUE, 
 484		MEMSIZE,
 485		ERR: NOVALUE,
 486		ERRCA: NOVALUE,
 487		ERRCAS: NOVALUE,
 488		ERRS: NOVALUE,
 489		ERRM: NOVALUE,
 490		ERMCA: NOVALUE,
 491		ERMCAS: NOVALUE,
 492		ERMS: NOVALUE,
 493		NOERR: NOVALUE,
 494		FAILURE: NOVALUE,
 495		LOOP_CHK,
 496		FLP_CHK,
 497		CHK_ERR_MSG: NOVALUE,
 498		WAIT: NOVALUE,
 499		SEND_LINE,
 500		REPEAT: NOVALUE,
 501		PTSTNUM: NOVALUE,
 502		CP: NOVALUE,
 503		CP_NOSS: NOVALUE,
 504		SEND_NUL,
 505		SETNXT: NOVALUE,
 506		EXNEXT,
 507		WR_CRAM,
 508		X1,
 509		LOADUC: NOVALUE,
 510		MR: NOVALUE,
 511		PE: NOVALUE,
 512		CE: NOVALUE,
 513		CS: NOVALUE,
 514		CH: NOVALUE,
 515	        TP: NOVALUE,
 516	        TE: NOVALUE,
 517		EJ,
 518		SC_0: NOVALUE,
 519		EC,
 520		LCA: NOVALUE,
 521		DC_035: NOVALUE,
 522		MOD_FLD: NOVALUE,
 523		DM_CHK,
 524		MEM_DEPOSIT: NOVALUE,
 525		MEM_EXAMINE,
 526		EM_CHK,
 527		DN: NOVALUE,
 528		IO_DEPOSIT: NOVALUE,
 529		IO_EXAMINE,
 530		EI_CHK,
 531		REG_EXAMINE,
 532		WRT100: NOVALUE,
 533		WRT102: NOVALUE,
 534		WRT103: NOVALUE,
 535		WRT104: NOVALUE,
 536		WRT105: NOVALUE,
 537		WRT106: NOVALUE,
 538		WRT107: NOVALUE,
 539		WRT110: NOVALUE,
 540		WRT111: NOVALUE,
 541		WRT112: NOVALUE,
 542		WRT113: NOVALUE,
 543		WRT114: NOVALUE,
 544		WRT115: NOVALUE,
 545		WRT116: NOVALUE,
 546		WRT204: NOVALUE,
 547		WRT205: NOVALUE,
 548		WRT206: NOVALUE,
 549		WRT210: NOVALUE,
 550		WRT212: NOVALUE,
 551		SYNC_CLK: NOVALUE,
 552		TICK: NOVALUE;
 553	
 554	    EXTERNAL
 555		NO_SUBSET,
 556		LPONTST,
 557		TIMOUT,
 558		RPT_ERR_FLAG,
 559		ERRFLG;
 560	
 561	! END OF "STIRSD.R36"
 562	
 563	REQUIRE 'CSLMAC.R36';			! CSL macros (UUO's etc..)
 564	
 565	!
 566	!			  COPYRIGHT (c) 1977, 1978 BY
 567	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 568	!
 569	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 570	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 571	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 572	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 573	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 574	! TRANSFERRED.
 575	!
 576	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 577	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 578	! CORPORATION.
 579	!
 580	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 581	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 582	!
 583	
 584	!++
 585	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 586	!
 587	! ABSTRACT:
 588	!
 589	!	THIS FILE CONTAINS MACROS WHICH ARE USED TO COMMUNICATE WITH THE
 590	!	'CSL' PROGRAM.  THE MACROS EXPAND TO LUUO CALLS WHICH PERFORM TTY
 591	!	INPUT AND OUTPUT AND SEND ASCIZ COMMAND LINES TO THE 8080.
 592	!
 593	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 594	!
 595	! AUTHOR:  RICH MURATORI	, CREATION DATE:  12-DEC-78
 596	!
 597	! MODIFIED BY:
 598	!
 599	!  RICH MURATORI, 12-DEC-78 : VERSION 0.1
 600	!--
 601	
 602	BUILTIN UUO;
 603	
 604	LITERAL
 605		ER_AC = 1,
 606		EI_AC = 2,
 607		EJ_AC = 3,
 608		EK_AC = 4,
 609		EB_AC = 5,
 610		EC_AC = 6,
 611		EM_AC = 7,
 612		PM_AC = 8,
 613		X1A_AC = 9,
 614		X1B_AC = 10;
 615	
 616	
 617	!MACROS TO DEFINE PRINTING CALLS MADE TO 'CSL' PROGRAM VIA UUO
 618	
 619	BIND CR_LF = UPLIT(%CHAR(13,10,0));
 620	
 621	MACRO
 622		PRINT_CRLF	= BEGIN
 623				  AC0 = CR_LF;
 624				  UUO(0,31,15,0);
 625				  END%,
 626		PNTSIX(MSGWORD)	= BEGIN
 627				  AC0 = MSGWORD;
 628				  UUO(0,31,0,2);
 629				  END%,
 630		PRINT_MSG(MSGADR)= BEGIN
 631				  AC0 = MSGADR;
 632				  UUO(0,31,15,0);
 633				  END%,
 634		PRINT_WORD(ADDR) = BEGIN
 635				   AC0 = ADDR;
 636				   UUO(0,31,0,0);
 637				   END%,
 638		PRINT_TXT(TEXT) = BEGIN
 639				  AC0 = UPLIT(%ASCIZ TEXT);
 640				  UUO(0,31,15,0);
 641				  END%,
 642		PTXT_CRLF(TEXT)	= BEGIN
 643				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
 644				  UUO(0,31,15,0);
 645				  END%,
 646		PRINT_DEC(NUM)	= BEGIN
 647				  AC0 = NUM;
 648				  UUO(0,31,13,0);
 649				  END%,
 650		PRT_CRLF_F	= BEGIN
 651				  AC0 = CR_LF;
 652				  UUO(0,31,15,1);
 653				  END%,
 654		PRT_MSG_F(MSGADR)= BEGIN
 655				  AC0 = MSGADR;
 656				  UUO(0,31,15,1);
 657				  END%,
 658		PRT_TXT_F(TEXT) = BEGIN
 659				  AC0 = UPLIT(%ASCIZ TEXT);
 660				  UUO(0,31,15,1);
 661				  END%,
 662		PTXT_CRLF_F(TEXT) = BEGIN
 663				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
 664				  UUO(0,31,15,1);
 665				  END%,
 666		PRT_DEC_F(NUM)	= BEGIN
 667				  AC0 = NUM;
 668				  UUO(0,31,13,1);
 669				  END%,
 670		PRINT_OCT_1(NUM)= BEGIN
 671				  AC0 = NUM;
 672				  UUO(0,31,1,0);
 673				  END%,
 674		PRINT_OCT_2(NUM)= BEGIN
 675				  AC0 = NUM;
 676				  UUO(0,31,2,0);
 677				  END%,
 678		PRINT_OCT_3(NUM)= BEGIN
 679				  AC0 = NUM;
 680				  UUO(0,31,3,0);
 681				  END%,
 682		PRINT_OCT_4(NUM)= BEGIN
 683				  AC0 = NUM;
 684				  UUO(0,31,4,0);
 685				  END%,
 686		PRINT_OCT_5(NUM)= BEGIN
 687				  AC0 = NUM;
 688				  UUO(0,31,5,0);
 689				  END%,
 690		PRINT_OCT_6(NUM)= BEGIN
 691				  AC0 = NUM;
 692				  UUO(0,31,6,0);
 693				  END%,
 694		PRINT_OCT_7(NUM)= BEGIN
 695				  AC0 = NUM;
 696				  UUO(0,31,7,0);
 697				  END%,
 698		PRINT_OCT_8(NUM)= BEGIN
 699				  AC0 = NUM;
 700				  UUO(0,31,8,0);
 701				  END%,
 702		PRINT_OCT_11(NUM)= BEGIN
 703				  AC0 = NUM;
 704				  UUO(0,31,11,0);
 705				  END%,
 706		PRINT_OCT_12(NUM)= BEGIN
 707				  AC0 = NUM;
 708				  UUO(0,31,12,0);
 709				  END%,
 710		POCT_SUP(NUM)	= BEGIN
 711				  AC0 = NUM;
 712				  UUO(0,31,14,3);
 713				  END%,
 714		PBELL		= UUO(0,31,1,7)%,
 715	
 716	!MACROS TO DEFINE UUO CALLS TO 'CSL' PROGRAM FOR TTY INPUT
 717	
 718		TT_ALTM = UUO(1,31,7,3)%,
 719		TTI_YES = UUO(1,31,1,3)%,
 720		TTI_CLR = UUO(0,31,10,3)%,
 721		TTI_DEC = UUO(1,31,4,3)%,
 722	
 723	!MACRO TO DEFINE END OF PROGRAM UUO
 724	
 725		EOP_UUO = UUO(0,31,14,4)%,
 726	
 727	!MACROS TO DEFINE UUO CALLS TO 'CSL' TO SEND CMD STRINGS WITH RESPONSE
 728	
 729		SEND_ER_LINE = UUO(0,1,ER_AC,0)%,
 730		SEND_EI_LINE = UUO(0,1,EI_AC,0)%,
 731		SEND_EJ_LINE = UUO(0,1,EJ_AC,0)%,
 732		SEND_EK_LINE = UUO(0,1,EK_AC,0)%,
 733		SEND_EB_LINE = UUO(0,1,EB_AC,0)%,
 734		SEND_EC_LINE = UUO(0,1,EC_AC,0)%,
 735		SEND_EM_LINE = UUO(0,1,EM_AC,0)%,
 736		SEND_PM_LINE = UUO(0,1,PM_AC,0)%,
 737		SEND_X1A_LINE = UUO(0,1,X1A_AC,0)%,
 738		SEND_X1B_LINE = UUO(0,1,X1B_AC,0)%,
 739	
 740	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD STRING
 741	
 742		SEND_CMD_LINE = UUO(0,1,0,0)%,
 743	
 744	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD LINE
 745	
 746		SEND_UUO_1 = UUO(0,1,1,0)%,
 747	
 748	!MACRO TO DEFINE ERROR MESSAGE CHECK CALL TO 'CSL'
 749	
 750		MSG_CHK_UUO = UUO(0,3,0,0)%,
 751	
 752	!MACRO TO DEFINE 'CSL' UUO TO PASS CONTROL-T INFO
 753	
 754		SEND_INFO = UUO(0,3,1,0)%,
 755	
 756	!MACROS TO DEFINE FILE HANDLING UUOS TO 'CSL' PROGRAM
 757	
 758		FSELECT(FILNAM_ADR)	= (AC0 = FILNAM_ADR;
 759					  UUO(1,31,5,4))%,
 760		FRDPAG	= UUO(1,31,8,4)%;
 761	
 762	!8080 ERROR MESSAGE FORMATS WHICH ARE CHECKED FOR.
 763	
 764	BIND
 765		HALTED = UPLIT(%ASCIZ '%HLTD'),
 766		MEM_REF_ERR = UPLIT(%ASCIZ '?MRE'),
 767		PAR_ERR = UPLIT(%ASCIZ '?PAR_ERR');
 768	
 769	! END OF 'CSL.MAC'
 770	REQUIRE 'KSU.R36';			! Microcode macros
 771	
 772	!
 773	!			  COPYRIGHT (c) 1977, 1978 BY
 774	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 775	!
 776	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 777	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 778	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 779	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 780	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 781	! TRANSFERRED.
 782	!
 783	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 784	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 785	! CORPORATION.
 786	!
 787	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 788	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 789	!
 790	
 791	
 792	!++
 793	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 794	!
 795	! ABSTRACT:
 796	!
 797	!	 THESE MACROS ALLOW YOU TO WRITE MICROINSTRUCTIONS IN A SYMBOLIC FORM
 798	!	 (DIFFERENT THAN THE NORMAL MICRO CROSS ASSEMBLER) FOR USE AS LITERAL
 799	!	 VALUES WITHIN A BLISS-36 PROGRAM.   MACROS ARE NECESSARY (AS OPPOSED
 800	!	 TO ARITHMETIC EXPRESSIONS) TO HANDLE SOME FIELDS' DEFAULT VALUES IN
 801	!	 THE "RIGHT WAY"; THEY DEFAULT TO THE VALUE WHICH MAY HAVE BEEN SET IN
 802	!	 OTHER FIELDS.   ALSO, IT ALLEVIATES YOU FROM HAVING TO REMEMBER WHICH
 803	!	 OF THE 3 36-BIT PDP-10 WORDS THE FIELD GOES INTO.
 804	!
 805	! FUNCTIONAL DESCRIPTION:
 806	!
 807	!	 TO CREATE A MICROINSTRUCTION, CALL THE MACROS FOR THE FIELDS WHICH
 808	!	 YOU DESIRE TO SPECIFY EXPLICITLY.   SOME OF THEM REQUIRE ARGUMENTS;
 809	!	 SOME OF THEM CALL OTHERS WITH THE APPROPRIATE ARGUMENT.   THESE WILL
 810	!	 EXPAND TO THE NULL LEXEME (THAT IS, THEY GO AWAY).   FINALLY, THE
 811	!	 U MACRO IS CALLED.   IT HANDLES THE TRICKY DEFAULTS, EXPANDS TO 3
 812	!	 DECIMAL CONSTANTS SEPPARATED BY COMMAS, AND RESETS THE COMPILETIME
 813	!	 VARIABLES BACK TO THEIR INITIAL VALUES (MOSTLY, THE MICROINSTRUCTION
 814	!	 WITH ALL OF THE SIMPLE FIELDS WITH THEIR DEFAULT VALUES).   THE U
 815	!	 MACRO MAY BE CALLED AS THE ARGUMENT OF A PLIT.   IT MAY BE CALLED SEVERAL
 816	!	 TIMES WITH A COMMA BETWEEN EACH ONE (AND THE FIELD-SETTING MACROS
 817	!	 BEFORE EACH ONE) TO MAKE A PLIT WITH A BLOCK OF SEVERAL MICROINSTRUCTIONS
 818	!	 SINCE THE HOOKS INTO CSL WILL PERMIT LOADING SEVERAL MICROINSTRUCTIONS
 819	!	 INTO CONTIGUOUS CRAM LOCATIONS WITH ONE CALL.   MACROS MAY BE DEFINED
 820	!	 WHICH SET MANY OF THE FIELDS (JUST LIKE IN MICRO) BY HAVING IT CALL THE
 821	!	 DESIRED FIELD-SETTING MACROS.
 822	!
 823	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 824	!
 825	! AUTHOR: ARON INSINGA, CREATION DATE: 22-AUG-78
 826	!
 827	! MODIFIED BY:
 828	!
 829	!	ARON INSINGA, 28-AUG-78: VERSION 0.1
 830	!--
 831	
 832	!
 833	! TABLE OF CONTENTS:
 834	!
 835	!	JUMP FIELD
 836	!	2901 ALU FUNCTION
 837	!	LEFT SOURCE
 838	!	RIGHT SOURCE
 839	!	DESTINATION (DP, Q, B)
 840	!	DATA PATH ADDRESS A
 841	!	DATA PATH ADDRESS B
 842	!	RAMFILE ADDRESS
 843	!	D-BUS SELECT
 844	!	DBM SELECT
 845	!	FICTICOUS PARITY-VALIDATE BIT
 846	!	CLOCK LEFT HALF OF THE MACHINE
 847	!	STORE PARITY FOR LEFT 2901'S
 848	!	CHECK LEFT HALF D-BUS PARITY
 849	!	CLOCK RIGHT HALF OF THE MACHINE
 850	!	STORE PARITY FOR RIGHT 2901'S
 851	!	CHECK RIGHT HALF D-BUS PARITY
 852	!	SPEC
 853	!	SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
 854	!	SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
 855	!	DISPATCH
 856	!	SKIP STUFF
 857	!	TIME FIELD
 858	!	RANDOM CONTROL BITS
 859	!	INJECT A CARRY
 860	!	LOAD SC FROM SCAD
 861	!	LOAD FE FROM SCAD
 862	!	WRITE THE RAM FILE
 863	!	START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
 864	!	THIS MICROINSTRUCTION IS DOING A DIVIDE
 865	!	MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
 866	!	FAST SHIFT
 867	!	CALL
 868	!	MAGIC NUMBER FIELD (#)
 869	!	SCAD (SHIFT-COUNT ADDER) FUNCTION
 870	!	SCAD A-INPUT MUX
 871	!	SCAD B-INPUT MUX
 872	!	SCAD NUMBER FIELD
 873	!	MICROINSTRUCTION BUILDER
 874	!
 875	!	MICROINSTRUCTION WITH DEFAULT FIELDS
 876	!	MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
 877	!	MICROINSTRUCTION BEING BUILT
 878	!
 879	
 880	!
 881	! MACROS:
 882	!
 883	
 884	    MACRO
 885	
 886		! JUMP FIELD
 887		U_J(O_CRAM_ADDR) =
 888		    %ASSIGN(U_0,U_0 OR ((%O %STRING(O_CRAM_ADDR))^24)) %,
 889	
 890		! 2901 ALU FUNCTION
 891		U_ALU(FUNC) =
 892		    %ASSIGN(U_0,(U_0 AND %O'777707777777') OR ((FUNC)^21)) %,
 893	
 894		U_ALU_ADD = U_ALU(0) %,
 895		U_ALU_SUB = U_ALU(1) %,
 896		U_ALU_RSUB = U_ALU(2) %,
 897		U_ALU_OR = U_ALU(3) %,
 898		U_ALU_AND = U_ALU(4) %,
 899		U_ALU_MASK = U_ALU(5) %,
 900		U_ALU_XOR = U_ALU(6) %,
 901		U_ALU_XNOR = U_ALU(7) %,
 902	
 903		! LEFT SOURCE
 904		U_LSRC(SRC) =
 905		    %ASSIGN(U_0,(U_0 AND %O'777770777777') OR ((SRC)^18)) %,
 906	
 907		U_LSRC_AQ = U_LSRC(0) %,
 908		U_LSRC_AB = U_LSRC(1) %,
 909		U_LSRC_0Q = U_LSRC(2) %,
 910		U_LSRC_0B = U_LSRC(3) %,
 911		U_LSRC_0A = U_LSRC(4) %,
 912		U_LSRC_DA = U_LSRC(5) %,
 913		U_LSRC_DQ = U_LSRC(6) %,
 914		U_LSRC_D0 = U_LSRC(7) %,
 915	
 916		! RIGHT SOURCE
 917		U_RSRC(SRC) =
 918		    %ASSIGN(U_0,(U_0 AND %O'777777077777') OR ((SRC)^15))
 919		    %ASSIGN(U_SET,U_SET OR U_SET_RSRC) %,
 920	
 921		U_RSRC_AQ = U_RSRC(0) %,
 922		U_RSRC_AB = U_RSRC(1) %,
 923		U_RSRC_0Q = U_RSRC(2) %,
 924		U_RSRC_0B = U_RSRC(3) %,
 925		U_RSRC_0A = U_RSRC(4) %,
 926		U_RSRC_DA = U_RSRC(5) %,
 927		U_RSRC_DQ = U_RSRC(6) %,
 928		U_RSRC_D0 = U_RSRC(7) %,
 929	
 930		! DESTINATION (DP, Q, B)
 931		U_DEST(DEST) =
 932		    %ASSIGN(U_0,(U_0 AND %O'777777707777') OR ((DEST)^12)) %,
 933	
 934		U_DEST_A = U_DEST(0) %,
 935		U_DEST_AD = U_DEST(1) %,
 936		U_DEST_Q_AD = U_DEST(2) %,
 937		U_DEST_PASS = U_DEST(3) %,
 938		U_DEST_Q_MUL2 = U_DEST(4) %,
 939		U_DEST_AD_MUL2 = U_DEST(5) %,
 940		U_DEST_Q_DIV2 = U_DEST(6) %,
 941		U_DEST_AD_DIV2 = U_DEST(7) %,
 942	
 943		! DATA PATH ADDRESS A
 944		U_A(DP) =
 945		    %ASSIGN(U_0,U_0 OR ((DP)^6)) %,
 946	
 947		U_A_MAG = U_A(0) %,
 948		U_A_PC = U_A(1) %,
 949		U_A_HR = U_A(2) %,
 950		U_A_AR = U_A(3) %,
 951		U_A_ARX = U_A(4) %,
 952		U_A_BR = U_A(5) %,
 953		U_A_BRX = U_A(6) %,
 954		U_A_ONE = U_A(7) %,
 955		U_A_EBR = U_A(8) %,
 956		U_A_UBR = U_A(9) %,
 957		U_A_MASK = U_A(10) %,
 958		U_A_FLG = U_A(11) %,
 959		U_A_PI = U_A(12) %,
 960		U_A_XWD1 = U_A(13) %,
 961		U_A_T0 = U_A(14) %,
 962		U_A_T1 = U_A(15) %,
 963	
 964		! DATA PATH ADDRESS B
 965		U_B(DP) =
 966		    %ASSIGN(U_0,U_0 OR (DP)) %,
 967	
 968		U_B_MAG = U_B(0) %,
 969		U_B_PC = U_B(1) %,
 970		U_B_HR = U_B(2) %,
 971		U_B_AR = U_B(3) %,
 972		U_B_ARX = U_B(4) %,
 973		U_B_BR = U_B(5) %,
 974		U_B_BRX = U_B(6) %,
 975		U_B_ONE = U_B(7) %,
 976		U_B_EBR = U_B(8) %,
 977		U_B_UBR = U_B(9) %,
 978		U_B_MASK = U_B(10) %,
 979		U_B_FLG = U_B(11) %,
 980		U_B_PI = U_B(12) %,
 981		U_B_XWD1 = U_B(13) %,
 982		U_B_T0 = U_B(14) %,
 983		U_B_T1 = U_B(15) %,
 984	
 985		! RAMFILE ADDRESS
 986		U_RAM(SEL) =
 987		    %ASSIGN(U_1,(U_1 AND %O'77777777777') OR ((SEL)^33)) %,
 988	
 989		U_RAM_AC = U_RAM(0) %,
 990		U_RAM_AC_FN = U_RAM(1) %,
 991		U_RAM_XR = U_RAM(2) %,
 992		U_RAM_VMA = U_RAM(4) %,
 993		U_RAM_RAM = U_RAM(6) %,
 994		U_RAM_N = U_RAM(7) %,
 995	
 996		! D-BUS SELECT
 997		U_DBUS(SEL) =
 998		    %ASSIGN(U_1,(U_1 AND %O'747777777777') OR ((SEL)^30)) %,
 999	
1000		U_DBUS_PC_FLAGS = U_DBUS(0) %,		! LEFT HALF
1001		U_DBUS_PI_NEW = U_DBUS(0) %,		! BITS 19:21
1002		U_DBUS_VMA = U_DBUS(0) %,		! BITS 27:35
1003		U_DBUS_DP = U_DBUS(1) %,
1004		U_DBUS_RAM = U_DBUS(2) %,
1005		U_DBUS_DBM = U_DBUS(3) %,
1006	
1007		! DBM SELECT
1008		U_DBM(SEL) =
1009		    %ASSIGN(U_1,(U_1 AND %O'770777777777') OR ((SEL)^27)) %,
1010	
1011		U_DBM_SCAD = U_DBM(0) %,		! LEFT HALF
1012		U_DBM_PF_DISP = U_DBM(0) %,		! BITS 18:21
1013		U_DBM_APR_FLAGS = U_DBM(0) %,		! BITS 22:35
1014		U_DBM_BYTES = U_DBM(1) %,
1015		U_DBM_EXP = U_DBM(2) %,			! LEFT HALF
1016		U_DBM_MSEC = U_DBM(2) %,		! RIGHT HALF
1017		U_DBM_DP = U_DBM(3) %,
1018		U_DBM_DP_SWAP = U_DBM(4) %,
1019		U_DBM_VMA = U_DBM(5) %,
1020		U_DBM_MEM = U_DBM(6) %,
1021		U_DBM_N = U_DBM(7) %,
1022	
1023		! FICTICOUS PARITY-VALIDATE BIT
1024		U_ALU_PARITY_OK =
1025		    %ASSIGN(U_3,U_3 OR (1^35)) %,
1026	
1027		! CLOCK LEFT HALF OF THE MACHINE
1028		U_NO_CLKL =
1029		    %ASSIGN(U_1,U_1 AND %O'777377777777') %,
1030	
1031		! STORE PARITY FOR LEFT 2901'S
1032		U_GENL =
1033		    %ASSIGN(U_1,U_1 OR (1^25))
1034		    %ASSIGN(U_SET,U_SET OR U_SET_GENL) %,
1035	
1036		! CHECK LEFT HALF D-BUS PARITY
1037		U_CHKL =
1038		    %ASSIGN(U_1,U_1 OR (1^24)) %,
1039	
1040		! CLOCK RIGHT HALF OF THE MACHINE
1041		U_NO_CLKR =
1042		    %ASSIGN(U_1,U_1 AND %O'777737777777') %,
1043	
1044		! STORE PARITY FOR RIGHT 2901'S
1045		U_GENR =
1046		    %ASSIGN(U_1,U_1 OR (1^22))
1047		    %ASSIGN(U_SET,U_SET OR U_SET_GENR) %,
1048	
1049		! CHECK RIGHT HALF D-BUS PARITY
1050		U_CHKR =
1051		    %ASSIGN(U_1,U_1 OR (1^21)) %,
1052	
1053		! SPEC
1054		U_SPEC(X) =
1055		    %ASSIGN(U_1,U_1 OR ((X)^15)) %,
1056	
1057		U_SPEC_N = U_SPEC(%O'10') %,
1058		U_SPEC_CLRCLK = U_SPEC(%O'11') %,
1059		U_SPEC_CLRIOLAT = U_SPEC(%O'12') %,
1060		U_SPEC_CLRIOBSY = U_SPEC(%O'13') %,
1061		U_SPEC_LDPAGE = U_SPEC(%O'14') %,
1062		U_SPEC_NICOND = U_SPEC(%O'15') %,
1063		U_SPEC_LDPXCT = U_SPEC(%O'16') %,
1064		U_SPEC_WAIT = U_SPEC(%O'17') %,
1065		U_SPEC_PREV = U_SPEC(%O'20') %,
1066		U_SPEC_LOADXR = U_SPEC(%O'21') %,
1067		U_SPEC_APRFLAGS = U_SPEC(%O'23') %,
1068		U_SPEC_CLRCSH = U_SPEC(%O'24') %,
1069		U_SPEC_APR_EN = U_SPEC(%O'25') %,
1070		U_SPEC_MEMCLR = U_SPEC(%O'27') %,
1071		U_SPEC_SWEEP = U_SPEC(%O'34') %,
1072		U_SPEC_PXCT_OFF = U_SPEC(%O'36') %,
1073		U_SPEC_INHCRY18 = U_SPEC(%O'40') %,
1074		U_SPEC_LOADIR = U_SPEC(%O'41') %,
1075		U_SPEC_LDPI = U_SPEC(%O'43') %,
1076		U_SPEC_ASHOV = U_SPEC(%O'44') %,
1077		U_SPEC_EXPTST = U_SPEC(%O'45') %,
1078		U_SPEC_FLAGS = U_SPEC(%O'46') %,
1079		U_SPEC_LDACBLK = U_SPEC(%O'47') %,
1080		U_SPEC_LDINST = U_SPEC(%O'61') %,
1081	
1082		! SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
1083		U_BYTE(X) =
1084		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
1085	
1086		U_BYTE_1 = U_BYTE(1) %,
1087		U_BYTE_2 = U_BYTE(2) %,
1088		U_BYTE_3 = U_BYTE(3) %,
1089		U_BYTE_4 = U_BYTE(4) %,
1090		U_BYTE_5 = U_BYTE(5) %,
1091	
1092		! SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
1093		U_SHSTYLE(X) =
1094		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
1095	
1096		U_SHSTYLE_NORM = U_SHSTYLE(0) %,
1097		U_SHSTYLE_ZERO = U_SHSTYLE(1) %,
1098		U_SHSTYLE_ONES = U_SHSTYLE(2) %,
1099		U_SHSTYLE_ROT = U_SHSTYLE(3) %,
1100		U_SHSTYLE_ASHC = U_SHSTYLE(4) %,
1101		U_SHSTYLE_LSHC = U_SHSTYLE(5) %,
1102		U_SHSTYLE_DIV = U_SHSTYLE(6) %,
1103		U_SHSTYLE_ROTC = U_SHSTYLE(7) %,
1104	
1105		! DISPATCH
1106		U_DISP(X) =
1107		    %ASSIGN(U_1,(U_1 AND %O'777777700777') OR ((X)^9)) %,
1108	
1109		U_DISP_CONSOLE = U_DISP(%O'00') %,
1110		U_DISP_DROM = U_DISP(%O'12') %,
1111		U_DISP_AREAD = U_DISP(%O'13') %,
1112		U_DISP_DP_LEFT = U_DISP(%O'31') %,
1113		U_DISP_NORM = U_DISP(%O'34') %,
1114		U_DISP_DP = U_DISP(%O'35') %,
1115		U_DISP_ADISP = U_DISP(%O'36') %,
1116		U_DISP_BDISP = U_DISP(%O'37') %,
1117		U_DISP_RETURN = U_DISP(%O'41') %,
1118		U_DISP_MUL = U_DISP(%O'62') %,
1119		U_DISP_PAGEFAIL = U_DISP(%O'63') %,
1120		U_DISP_NICOND = U_DISP(%O'64') %,
1121		U_DISP_BYTE = U_DISP(%O'65') %,
1122		U_DISP_EAMODE = U_DISP(%O'66') %,
1123		U_DISP_SCAD0 = U_DISP(%O'67') %,
1124	
1125		! SKIP STUFF
1126		U_SKIP(X) =
1127		    %ASSIGN(U_1,(U_1 AND %O'777777777007') OR ((X)^3)) %,
1128	
1129		U_SKIP_IOLGL = U_SKIP(%O'04') %,
1130		U_SKIP_LLE = U_SKIP(%O'12') %,
1131		U_SKIP_CRY0 = U_SKIP(%O'31') %,
1132		U_SKIP_ADLEQ0 = U_SKIP(%O'32') %,
1133		U_SKIP_ADREQ0 = U_SKIP(%O'33') %,
1134		U_SKIP_KERNEL = U_SKIP(%O'34') %,
1135		U_SKIP_FPD = U_SKIP(%O'35') %,
1136		U_SKIP_AC0 = U_SKIP(%O'36') %,
1137		U_SKIP_INT = U_SKIP(%O'37') %,
1138		U_SKIP_LE = U_SKIP(%O'42') %,
1139		U_SKIP_CRY2 = U_SKIP(%O'51') %,
1140		U_SKIP_DP0 = U_SKIP(%O'52') %,
1141		U_SKIP_DP18 = U_SKIP(%O'53') %,
1142		U_SKIP_IOT = U_SKIP(%O'54') %,
1143		U_SKIP_JFCL = U_SKIP(%O'55') %,
1144		U_SKIP_CRY1 = U_SKIP(%O'56') %,
1145		U_SKIP_TXXX = U_SKIP(%O'57') %,
1146		U_SKIP_TRAP_CYC = U_SKIP(%O'61') %,
1147		U_SKIP_ADEQ0 = U_SKIP(%O'62') %,
1148		U_SKIP_SC = U_SKIP(%O'63') %,
1149		U_SKIP_EXECUTE = U_SKIP(%O'64') %,
1150		U_SKIP_IO_BUSY = U_SKIP(%O'65') %,
1151		U_SKIP_CONTINUE = U_SKIP(%O'66') %,
1152		U_SKIP_1_MS = U_SKIP(%O'67') %,
1153	
1154		! TIME FIELD [O.E. "UT" = MDN.E. "OUT"]
1155		U_T(X) =
1156		    %ASSIGN(U_1,(U_1 AND %O'777777777774') OR (X)) %,
1157	
1158		! RANDOM CONTROL BITS
1159	
1160		! INJECT A CARRY
1161		U_CRY38 =
1162		    %ASSIGN(U_2,U_2 OR (1^35)) %,
1163	
1164		! LOAD SC FROM SCAD
1165		U_LOADSC =
1166		    %ASSIGN(U_2,U_2 OR (1^34)) %,
1167	
1168		! LOAD FE FROM SCAD
1169		U_LOADFE =
1170		    %ASSIGN(U_2,U_2 OR (1^33)) %,
1171	
1172		! WRITE THE RAM FILE
1173		U_FMWRITE =
1174		    %ASSIGN(U_2,U_2 OR (1^32)) %,
1175	
1176		! START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
1177		U_MEM =
1178		    %ASSIGN(U_2,U_2 OR (1^31)) %,
1179	
1180		! THIS MICROINSTRUCTION IS DOING A DIVIDE
1181		U_DIVIDE =
1182		    %ASSIGN(U_2,U_2 OR (1^30)) %,
1183	
1184		! MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
1185		U_MULTI_PREC =
1186		    %ASSIGN(U_2,U_2 OR (1^29)) %,
1187	
1188		! FAST SHIFT
1189		U_MULTI_SHIFT =
1190		    %ASSIGN(U_2,U_2 OR (1^28)) %,
1191	
1192		! CALL
1193		U_CALL =
1194		    %ASSIGN(U_2,U_2 OR (1^27)) %,
1195	
1196		! MAGIC NUMBER FIELD (#)
1197		U_N(O_N) =
1198		    %ASSIGN(U_2,U_2 OR (%O %STRING(O_N))) %,
1199	
1200		! MAGIC NUMBER FIELD REDEFINED FOR SHIFT-COUNT ADDER (SCAD) CONTROL
1201	
1202		! SCAD FUNCTION
1203		U_SCAD(X) =
1204		    %ASSIGN(U_2,(U_2 AND %O'777777077777') OR ((X)^15)) %,
1205	
1206		U_SCAD_A_MUL2 = U_SCAD(0) %,
1207		U_SCAD_OR = U_SCAD(1) %,
1208		U_SCAD_SUBB = U_SCAD(2) %,
1209		U_SCAD_SUB = U_SCAD(3) %,
1210		U_SCAD_ADD = U_SCAD(4) %,
1211		U_SCAD_AND = U_SCAD(5) %,
1212		U_SCAD_A_DEC = U_SCAD(6) %,
1213		U_SCAD_A = U_SCAD(7) %,
1214	
1215		! SCAD A INPUT MUX
1216		U_SCADA(X) =
1217		    %ASSIGN(U_2,(U_2 AND %O'777777707777') OR ((X)^12)) %,
1218	
1219		U_SCADA_SC = U_SCADA(0) %,
1220		U_SCADA_SN = U_SCADA(1) %,
1221		U_SCADA_PTR44 = U_SCADA(2) %,
1222		U_SCADA_BYTE1 = U_SCADA(3) %,
1223		U_SCADA_BYTE2 = U_SCADA(4) %,
1224		U_SCADA_BYTE3 = U_SCADA(5) %,
1225		U_SCADA_BYTE4 = U_SCADA(6) %,
1226		U_SCADA_BYTE5 = U_SCADA(7) %,
1227	
1228		! SCAD B INPUT MUX
1229		U_SCADB(X) =
1230		    %ASSIGN(U_2,(U_2 AND %O'777777771777') OR ((X)^10)) %,
1231	
1232		U_SCADB_FE = U_SCADB(0) %,
1233		U_SCADB_EXP = U_SCADB(1) %,
1234		U_SCADB_SHIFT = U_SCADB(2) %,
1235		U_SCADB_SIZE = U_SCADB(3) %,
1236	
1237		! SCAD/SMALL NUMBER FIELD
1238		U_SN(O_SN) =
1239		    %ASSIGN(U_2,(U_2 AND %O'777777776000') OR (%O %STRING(O_SN))) %,
1240	
1241		! MICROINSTRUCTION BUILDER
1242		!	 HANDLE DEFAULTS FOR FIELDS WHICH DEFAULT TO OTHER FIELDS.
1243		!	 EXPAND OUT TO THE 3 WORDS (108 BIT FORMAT) WITH COMMAS.
1244		!	 RESET ALL THE COMPILETIME VARIABLES TO THEIR ORIGINAL VALUES.
1245		U =
1246		    
1247		! DEFAULT RSRC = LSRC
1248		    %IF (U_SET AND U_SET_RSRC) EQL 0
1249		    %THEN
1250			%ASSIGN(U_0,U_0 OR ((U_0^(-3)) AND %O'700000'))
1251		    %FI
1252	
1253		! DEFAULT GENL = ALU_PARITY_OK
1254		    %IF (U_SET AND U_SET_GENL) EQL 0
1255		    %THEN
1256			%ASSIGN(U_1,U_1 OR ((U_3^(-10)) AND %O'000200000000'))
1257		    %FI
1258	
1259		! DEFAULT GENR = ALU_PARITY_OK
1260		    %IF (U_SET AND U_SET_GENR) EQL 0
1261		    %THEN
1262			%ASSIGN(U_1,U_1 OR ((U_3^(-13)) AND %O'000020000000'))
1263		    %FI
1264	
1265		    U_0,U_1,U_2
1266	
1267		    %ASSIGN(U_0,U_0_DEFAULT)
1268		    %ASSIGN(U_1,U_1_DEFAULT)
1269		    %ASSIGN(U_2,U_2_DEFAULT)
1270		    %ASSIGN(U_3,U_3_DEFAULT)
1271		    %ASSIGN(U_SET,0) %;
1272	
1273	!
1274	! EQUATED SYMBOLS:
1275	!
1276	
1277	    LITERAL
1278	
1279		! MICROINSTRUCTION WITH DEFAULT FIELDS
1280		U_0_DEFAULT = %O'000044030000',
1281		U_1_DEFAULT = %O'417440070703',
1282		U_2_DEFAULT = %O'000000000000',
1283		U_3_DEFAULT = %O'000000000000',
1284	
1285		! MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
1286		U_SET_RSRC = %O'1',
1287		U_SET_GENL = %O'2',
1288		U_SET_GENR = %O'4';
1289	
1290	    COMPILETIME
1291	
1292		! MICROINSTRUCTION BEING BUILT
1293		U_0 = U_0_DEFAULT,
1294		U_1 = U_1_DEFAULT,
1295		U_2 = U_2_DEFAULT,
1296		U_3 = U_3_DEFAULT,
1297		U_SET = 0;
1298	
1299	! END OF "KSU.R36"
1300	
1301	SWITCHES LIST(SOURCE);
1302	REQUIRE 'REGBIT.R36';			! 8080 register bit definitions
1303	
1304	!
1305	!			  COPYRIGHT (c) 1977, 1978 BY
1306	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
1307	!
1308	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
1309	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
1310	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
1311	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
1312	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
1313	! TRANSFERRED.
1314	!
1315	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
1316	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
1317	! CORPORATION.
1318	!
1319	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
1320	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
1321	!
1322	
1323	!++
1324	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
1325	!
1326	! ABSTRACT:
1327	!
1328	!	THIS FILE CONTAINS SYMBOLIC BIT DEFINITIONS FOR THE KS10 8080 I/O
1329	!	REGISTERS.  IT IS USED AS A 'REQUIRE' FILE FOR THE STIRS DIAGNOSTICS.
1330	!
1331	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
1332	!
1333	! AUTHOR:  RICH MURATORI	, CREATION DATE:  3-JAN-79
1334	!
1335	! MODIFIED BY:
1336	!
1337	!  RICH MURATORI, 3-JAN-79 : VERSION 0.1
1338	!--
1339	
1340	LITERAL
1341	
1342	!WRITE REGISTER 100
1343	
1344		FORCE_PAR	= 1^1,		!FORCE PARITY RIGHT
1345		EN_1MS		= 1^2,		!1 MSEC ENABLE
1346		CACHE_ENB	= 1^3,		!CACHE ENABLE
1347		DP_PE_DET	= 1^4,		!DP PE DETECT
1348		CRM_PE_DET	= 1^5,		!CRM PE DETECT
1349		PE_DET_ENB	= 1^6,		!PE DETECT ENABLE
1350		RESET		= 1^7,		!RESET
1351	
1352	!WRITE REGISTER 102/103
1353	
1354		DATA35		= 1^0,		!KS10 BUS DATA BIT 35
1355		DATA34		= 1^1,		!KS10 BUS DATA BIT 34
1356		DATA33		= 1^2,		!KS10 BUS DATA BIT 33
1357		DATA32		= 1^3,		!KS10 BUS DATA BIT 32
1358		DATA31		= 1^4,		!KS10 BUS DATA BIT 31
1359		DATA30		= 1^5,		!KS10 BUS DATA BIT 30
1360		DATA29		= 1^6,		!KS10 BUS DATA BIT 29
1361		DATA28		= 1^7,		!KS10 BUS DATA BIT 28
1362	
1363	!WRITE REGISTER 104/105
1364	
1365		DATA27		= 1^0,		!KS10 BUS DATA BIT 27
1366		DATA26		= 1^1,		!KS10 BUS DATA BIT 26
1367		DATA25		= 1^2,		!KS10 BUS DATA BIT 25
1368		DATA24		= 1^3,		!KS10 BUS DATA BIT 24
1369		DATA23		= 1^4,		!KS10 BUS DATA BIT 23
1370		DATA22		= 1^5,		!KS10 BUS DATA BIT 22
1371		DATA21		= 1^6,		!KS10 BUS DATA BIT 21
1372		DATA20		= 1^7,		!KS10 BUS DATA BIT 20
1373	
1374	!WRITE REGISTER 106/107
1375	
1376		DATA19		= 1^0,		!KS10 BUS DATA BIT 19
1377		DATA18		= 1^1,		!KS10 BUS DATA BIT 18
1378		DATA17		= 1^2,		!KS10 BUS DATA BIT 17
1379		DATA16		= 1^3,		!KS10 BUS DATA BIT 16
1380		DATA15		= 1^4,		!KS10 BUS DATA BIT 15
1381		DATA14		= 1^5,		!KS10 BUS DATA BIT 14
1382		DATA13		= 1^6,		!KS10 BUS DATA BIT 13
1383		DATA12		= 1^7,		!KS10 BUS DATA BIT 12
1384	
1385	!WRITE REGISTER 110/111
1386	
1387		DATA11		= 1^0,		!KS10 BUS DATA BIT 11
1388		DATA10		= 1^1,		!KS10 BUS DATA BIT 10
1389		DATA9		= 1^2,		!KS10 BUS DATA BIT 9 
1390		DATA8		= 1^3,		!KS10 BUS DATA BIT 8 
1391		DATA7		= 1^4,		!KS10 BUS DATA BIT 7 
1392		DATA6		= 1^5,		!KS10 BUS DATA BIT 6 
1393		DATA5		= 1^6,		!KS10 BUS DATA BIT 5 
1394		DATA4		= 1^7,		!KS10 BUS DATA BIT 4 
1395	
1396	!WRITE REGISTER 112/113
1397	
1398		DATA3		= 1^0,		!KS10 BUS DATA BIT 3 
1399		DATA2		= 1^1,		!KS10 BUS DATA BIT 2 
1400		DATA1		= 1^2,		!KS10 BUS DATA BIT 1 
1401		DATA0		= 1^3,		!KS10 BUS DATA BIT 0 
1402	
1403	!WRITE REGISTER 114/115
1404	
1405		DATA_CYCLE	= 1^0,		!DATA CYCLE
1406		IO_DATA		= 1^1,		!I/O DATA CYCLE
1407		COM_ADR		= 1^2,		!COM/ADR CYCLE
1408		BAD_DATA	= 1^3,		!BAD DATA CYCLE
1409	
1410	!WRITE REGISTER 116
1411	
1412		CSL_INT		= 1^0,		!CSL INTERRUPT THE 10
1413	
1414	!WRITE REGISTER 204
1415	
1416		CRAM_RESET	= 1^0,		!CRAM RESET
1417		STK_RESET	= 1^1,		!STACK RESET
1418		DP_RESET	= 1^2,		!DP RESET
1419		SS_MODE		= 1^3,		!SINGLE STEP MODE
1420		CRAM_ADR_LD	= 1^4,		!CRAM ADR LOAD
1421		CRAM_WRT	= 1^5,		!CRAM WRITE
1422	
1423	!WRITE REGISTER 205
1424	
1425		DIAG1		= 1^0,		!DIAG FN BIT 1
1426		DIAG2		= 1^1,		!DIAG FN BIT 2
1427		DIAG4		= 1^2,		!DIAG FN BIT 4
1428		DIAG10		= 1^3,		!DIAG FN BIT 10
1429		TRAP_ENB	= 1^4,		!TRAP ENABLE
1430		CLR_INT		= 1^5,		!CLEAR 10 INTERRUPT
1431		MNT_CLK_ENB	= 1^6,		!MAINT CLK ENABLE
1432		MAINT_CLK	= 1^7,		!MAINT CLK PULSE
1433	
1434	!WRITE REGISTER 206
1435	
1436		CLK_RUN		= 1^0,		!CLOCK RUN
1437		SINGLE_CLK	= 1^1,		!SINGLE CLOCK
1438	
1439	!WRITE REGISTER 210
1440	
1441		CLOSE_LATCH	= 1^0,		!CLOSE LATCHS
1442		LATCH_DATA	= 1^1,		!LATCH DATA (1)
1443		CRA_R_CLK	= 1^2,		!CRA R CLK ENB (1)
1444		CRA_T_CLK	= 1^3,		!CRA T CLK ENB (1)
1445		XMIT_DATA	= 1^4,		!XMIT DATA (1)
1446		XMIT_ADR	= 1^5,		!XMIT ADR (1)
1447		BUS_REQ		= 1^6,		!BUS REQ
1448		MEM		= 1^7,		!MEM
1449	
1450	!WRITE REGISTER 212
1451	
1452		CONTINUE	= 1^0,		!CONTINUE
1453		EXECUTE		= 1^1,		!EXECUTE
1454		RUN		= 1^2,		!RUN
1455	
1456	
1457	
1458	!READ REGISTER 0
1459	
1460		RDATA35		= 1^0,		!KS10 BUS DATA BIT 35
1461		RDATA34		= 1^1,		!KS10 BUS DATA BIT 34
1462		RDATA33		= 1^2,		!KS10 BUS DATA BIT 33
1463		RDATA32		= 1^3,		!KS10 BUS DATA BIT 32
1464		RDATA31		= 1^4,		!KS10 BUS DATA BIT 31
1465		RDATA30		= 1^5,		!KS10 BUS DATA BIT 30
1466		RDATA29		= 1^6,		!KS10 BUS DATA BIT 29
1467		RDATA28		= 1^7,		!KS10 BUS DATA BIT 28
1468	
1469	!READ REGISTER 1
1470	
1471		RDATA27		= 1^0,		!KS10 BUS DATA BIT 27
1472		RDATA26		= 1^1,		!KS10 BUS DATA BIT 26
1473		RDATA25		= 1^2,		!KS10 BUS DATA BIT 25
1474		RDATA24		= 1^3,		!KS10 BUS DATA BIT 24
1475		RDATA23		= 1^4,		!KS10 BUS DATA BIT 23
1476		RDATA22		= 1^5,		!KS10 BUS DATA BIT 22
1477		RDATA21		= 1^6,		!KS10 BUS DATA BIT 21
1478		RDATA20		= 1^7,		!KS10 BUS DATA BIT 20
1479	
1480	!READ REGISTER 2
1481	
1482		RDATA19		= 1^0,		!KS10 BUS DATA BIT 19
1483		RDATA18		= 1^1,		!KS10 BUS DATA BIT 18
1484		RDATA17		= 1^2,		!KS10 BUS DATA BIT 17
1485		RDATA16		= 1^3,		!KS10 BUS DATA BIT 16
1486		RDATA15		= 1^4,		!KS10 BUS DATA BIT 15
1487		RDATA14		= 1^5,		!KS10 BUS DATA BIT 14
1488		RDATA13		= 1^6,		!KS10 BUS DATA BIT 13
1489		RDATA12		= 1^7,		!KS10 BUS DATA BIT 12
1490	
1491	!READ REGISTER 3
1492	
1493		RDATA11		= 1^0,		!KS10 BUS DATA BIT 11
1494		RDATA10		= 1^1,		!KS10 BUS DATA BIT 10
1495		RDATA9		= 1^2,		!KS10 BUS DATA BIT 9 
1496		RDATA8		= 1^3,		!KS10 BUS DATA BIT 8 
1497		RDATA7		= 1^4,		!KS10 BUS DATA BIT 7 
1498		RDATA6		= 1^5,		!KS10 BUS DATA BIT 6 
1499		RDATA5		= 1^6,		!KS10 BUS DATA BIT 5 
1500		RDATA4		= 1^7,		!KS10 BUS DATA BIT 4 
1501	
1502	!READ REGISTER 100
1503	
1504		ADPT2_PE	= 1^0,		!UNIBUS ADAPTER 2 PARITY ERR
1505		CRA_PE		= 1^1,		!CRA PARITY ERR
1506		DP_PE		= 1^2,		!DP PARITY ERR
1507		MEM_PE		= 1^3,		!MEM PARITY ERR
1508		CRAM_PE		= 1^4,		!CRAM PARITY ERR
1509		ADPT3_PE	= 1^6,		!UNIBUS ADAPTER 3 PARITY ERR
1510		REC_PE		= 1^7,		!RECEIVED PARITY ERR
1511	
1512	!READ REGISTER 101
1513	
1514		MMC_REF_ERR	= 1^0,		!MEM REFRESH ERR
1515		PI_REQ_7	= 1^1,		!PI REQ 7
1516		PI_REQ_6	= 1^2,		!PI REQ 6
1517		PI_REQ_5	= 1^3,		!PI REQ 5
1518		PI_REQ_4	= 1^4,		!PI REQ 4
1519		PI_REQ_3	= 1^5,		!PI REQ 3
1520		PI_REQ_2	= 1^6,		!PI REQ 2
1521		PI_REQ_1	= 1^7,		!PI REQ 1
1522	
1523	!READ REGISTER 102
1524	
1525		RDATA		= 1^0,		!DATA CYCLE
1526		RIO_DATA	= 1^1,		!I/O DATA CYCLE
1527		RCOM_ADR	= 1^2,		!COM/ADR CYCLE
1528		RBAD_DATA	= 1^3,		!BAD DATA CYCLE
1529		RIO_BUSY	= 1^4,		!I/O BUSY
1530		RMEM_BUSY	= 1^5,		!MEM BUSY
1531		RRESET		= 1^6,		!RESET
1532		RAC_LO		= 1^7,		!AC LO
1533	
1534	!READ REGISTER 103
1535	
1536		RDATA3		= 1^0,		!KS10 BUS DATA BIT 3 
1537		RDATA2		= 1^1,		!KS10 BUS DATA BIT 2 
1538		RDATA1		= 1^2,		!KS10 BUS DATA BIT 1 
1539		RDATA0		= 1^3,		!KS10 BUS DATA BIT 0 
1540		PAR_LEFT	= 1^4,		!PARITY LEFT
1541		PAR_RIGHT	= 1^5,		!PARITY RIGHT
1542		ADPT4_PE	= 1^6,		!UNIBUS ADAPTER 4 PARITY ERR
1543		ADPT1_PE	= 1^7,		!UNIBUS ADAPTER 1 PARITY ERR
1544	
1545	!READ REGISTER 300
1546	
1547		CONTINUE_H	= 1^0,		!CONTINUE
1548		EXECUTE_B	= 1^1,		!EXECUTE
1549		RUN_1		= 1^2,		!RUN
1550		HALT_LOOP	= 1^3,		!DPM HALT LOOP
1551		KLINIK_LEN	= 1^4,		!KLINIK LENGTH (SW)
1552		KLINIK_BIT	= 1^5,		!KLINIK BIT # (SW)
1553		CTY_CHAR_LEN	= 1^6,		!CTY CHARACTER LENGTH (SW)
1554		CTY_BIT		= 1^7,		!CTY BIT # (SW)
1555	
1556	!READ REGISTER 301
1557	
1558		DATA_ACK	= 1^0,		!DATA ACK
1559		BOOT		= 1^1,		!BOOT (SW)
1560		CONS_ENB	= 1^2,		!CONSOLE ENABLE (SW)
1561		PE_1		= 1^3,		!PE(1)
1562		BUSREQ		= 1^4,		!BUS REQUEST
1563		NEXM		= 1^6,		!NEXM
1564		TEN_INT		= 1^7,		!10 INTERRUPT
1565	
1566	!READ REGISTER 302
1567	
1568		KLINIK_CARR	= 1^0,		!KLINIK CARRIER
1569		TERM_CARR	= 1^1,		!TERMINAL CARRIER
1570		REM_DIAG_ENB	= 1^2,		!REMOTE DIAG ENB
1571		REM_DIAG_PRO	= 1^3,		!REMOTE DIAG PROT
1572	
1573	!READ REGISTER 303
1574	
1575		RAM_ERR		= 1^0,		!RAM ERROR
1576		DP_CLK_ENBL	= 1^1,		!DPE/M CLK ENABLE
1577		CR_CLK_ENB	= 1^2,		!CRA/M CLK ENABLE
1578		R_CLK_ENB0	= 1^3;		!R CLK ENB (0) H
1579	
1580	! END OF 'REGBIT.R36'
1581	
1582	GLOBAL ROUTINE TST1: NOVALUE =
1583	!++   ------------------ 8646 BUS TRANCEIVERS ------------------
1584	! TEST DESCRIPTION:  This test checks out the 8646  transceivers
1585	!	on the MMC board which are connected directly to the bus.
1586	!	It verifies that the interface with the bus on the 8646's
1587	!	is not stuck at 0/1.  This test tries not to do anything
1588	!	to the MMC board - just verify its connection to the bus.
1589	!
1590	! TEST ASSUMPTIONS:  None.
1591	!
1592	! TEST PROCEDURE:  Write 8080 registers for a write to memory
1593	!			Com/Adr Cycle Bits 00-35:
1594	!			  Bits 00-03 8080 Reg 113
1595	!			       04-11      Reg 111
1596	!			       12-19      Reg 107
1597	!			       20-27      Reg 105
1598	!			       28-35      Reg 103
1599	!			Data all 0's
1600	!		   Set XMIT_ADR Bit - Put address data on the bus
1601	!		   Read the data off the bus and check it
1602	!		   Repeat the test with 1's on the bus
1603	!
1604	! POSSIBLE ERRORS:  8646 Bus Tranceivers on MMC1 are faulty.
1605	!
1606	!--
1607	
1608	BEGIN
1609	
1610	LOCAL
1611		ERR,				! Temporary variable
1612		TEMP,				! Temporary variable
1613		ERR_FLAG;			! Error flag - set to 1 if an error
1614						!   has occurred so far
1615	OWN
1616		MESSV: VECTOR[2],		! Error output vector
1617		BUS_DATA,			! Bus data read from the bus
1618		TEST_DATA,			! Test data send to the bus
1619		TEST_TEMP_VECT: BIT8646[1],	! Temporary storage area for comparison
1620		MESS_STR: VECTOR[10]		! Message Strings
1621		    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
1622			    UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
1623			    UPLIT(%ASCIZ '16-17'),UPLIT(%ASCIZ '18-21'),
1624			    UPLIT(%ASCIZ '22-25'),UPLIT(%ASCIZ '26-29'),
1625			    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'));
1626	
1627	BIND
1628		TEST_TEMP = TEST_TEMP_VECT;
1629	
1630	LABEL
1631		BLOCK1;
1632	
1633	RPT_ERR_FLAG = 0;			! Don't report unexpected error
1634	NOERR_1 = 0;				! No errors have occurred yet
1635	
1636	DECR TEST_DATA FROM 0 TO -1 BY 1 DO
1637		BEGIN
1638		MESSV[1] = (.TEST_DATA EQL -1);
1639		DO (0) WHILE
1640	BLOCK1:	    BEGIN
1641		    MR(0);			! Master Reset
1642	
1643		    WRT115(0);			! Dont want to start com/adr or a
1644		    WRT114(0);			!   data cycle - just put data on bus
1645		    WRITE_COMADR(.TEST_DATA);		
1646		    WRT210(MEM+BUS_REQ+XMIT_ADR+CLOSE_LATCH);
1647		    BUS_DATA = READ_BUS();	! Find out what is now on the bus
1648		    ERR_FLAG = 0;		! No error has occurred yet
1649	
1650	! Look for and report any single bit errors.
1651	
1652		    INCR BTT FROM 0 TO 35 DO
1653			BEGIN			
1654			TEMP = .BUS_DATA XOR (1 ^ (35-.BTT));
1655			IF .TEMP EQL .TEST_DATA
1656			    THEN BEGIN
1657				 MESSV[0] = .BTT;
1658				 ERR_FLAG = 1;
1659				 ERRCAS(.BTT+1,1,.TEST_DATA,.BUS_DATA,12,MESSV);
1660				 END;
1661			IF LOOP_CHK(.BTT + 1) THEN LEAVE BLOCK1 WITH 1;
1662			END;
1663	
1664	! If no errors have occurred yet check for multiple bit errors matching
1665	!   a single transceiver.
1666	
1667		    ERR = (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .BUS_DATA);
1668		    INCR BTT FROM 0 TO 9 DO
1669			BEGIN
1670			TEST_TEMP = 0;
1671			TEST_TEMP_VECT[.BTT] = %O'777777';
1672			TEMP = .BUS_DATA OR .TEST_TEMP;
1673			IF .TEMP EQL (.TEST_DATA OR .TEST_TEMP) AND (.ERR EQL 1)
1674			    THEN BEGIN
1675				 ERR_FLAG = 1;
1676				 MESSV[0] = .MESS_STR[.BTT];
1677				 ERRCAS(.BTT+37,2,.TEST_DATA,.BUS_DATA,12,MESSV);
1678				 END;
1679			IF LOOP_CHK(.BTT + 37) THEN LEAVE BLOCK1 WITH 1;
1680			END;
1681	
1682	! Well, if no specific error has been found yet and the correct/actual
1683	!   is different then the whole data path is bad or random sections of
1684	!   it are bad so report the fact.
1685	
1686		    IF (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .BUS_DATA)
1687			THEN BEGIN
1688			     ERR_FLAG = 1;
1689			     ERRCAS(47,3,.TEST_DATA,.BUS_DATA,12,MESSV);
1690			     END;
1691		    IF LOOP_CHK(47) THEN LEAVE BLOCK1 WITH 1;
1692		    IF .ERR_FLAG NEQ 0 THEN TEST_ABORT = 1;
1693		    0				! To eliminate INFO compiler message
1694		    END;
1695		END;
1696	
1697	!*MESSAGE 1
1698	!*STIMULUS
1699	!*	WRT 113,105,107,111,103 - Write 0's to the 8080 bus
1700	!*				  data registers
1701	!*	WRT 210/143 - Set:  CONSOLE REQ, T ENB FOR COM/ADR,
1702	!*			    LATCH DATA SENT, R CLK ENB L
1703	!*	RD 103,3,2,1,0 - 8080 Regs should contain the data
1704	!*			 put on the bus
1705	!*RESPONSE
1706	!*	Bus data bit \D0 is stuck at \D1
1707	
1708	!]ERROR 1
1709	!] A1  NTWK
1710	!]NO ERROR 1
1711	!]  NTWK
1712	
1713	!]ERROR 2
1714	!] A1  NTWK
1715	!]NO ERROR 2
1716	!]  NTWK
1717	
1718	!]ERROR 3
1719	!] A1  NTWK
1720	!]NO ERROR 3
1721	!]  NTWK
1722	
1723	!]ERROR 4
1724	!] A1  NTWK
1725	!]NO ERROR 4
1726	!]  NTWK
1727	
1728	!]ERROR 5
1729	!] B1  NTWK
1730	!]NO ERROR 5
1731	!]  NTWK
1732	
1733	!]ERROR 6
1734	!] B1  NTWK
1735	!]NO ERROR 6
1736	!]  NTWK
1737	
1738	!]ERROR 7
1739	!] B1  NTWK
1740	!]NO ERROR 7
1741	!]  NTWK
1742	
1743	!]ERROR 8
1744	!] B1  NTWK
1745	!]NO ERROR 8
1746	!]  NTWK
1747	
1748	!]ERROR 9
1749	!] C1  NTWK
1750	!]NO ERROR 9
1751	!]  NTWK
1752	
1753	!]ERROR 10
1754	!] C1  NTWK
1755	!]NO ERROR 10
1756	!]  NTWK
1757	
1758	!]ERROR 11
1759	!] C1  NTWK
1760	!]NO ERROR 11
1761	!]  NTWK
1762	
1763	!]ERROR 12
1764	!] C1  NTWK
1765	!]NO ERROR 12
1766	!]  NTWK
1767	
1768	!]ERROR 13
1769	!] D1  NTWK
1770	!]NO ERROR 13
1771	!]  NTWK
1772	
1773	!]ERROR 14
1774	!] D1  NTWK
1775	!]NO ERROR 14
1776	!]  NTWK
1777	
1778	!]ERROR 15
1779	!] D1  NTWK
1780	!]NO ERROR 15
1781	!]  NTWK
1782	
1783	!]ERROR 16
1784	!] D1  NTWK
1785	!]NO ERROR 16
1786	!]  NTWK
1787	
1788	!]ERROR 17
1789	!] E1  NTWK
1790	!]NO ERROR 17
1791	!]  NTWK
1792	
1793	!]ERROR 18
1794	!] E1  NTWK
1795	!]NO ERROR 18
1796	!]  NTWK
1797	
1798	!]ERROR 19
1799	!] F1  NTWK
1800	!]NO ERROR 19
1801	!]  NTWK
1802	
1803	!]ERROR 20
1804	!] F1  NTWK
1805	!]NO ERROR 20
1806	!]  NTWK
1807	
1808	!]ERROR 21
1809	!] F1  NTWK
1810	!]NO ERROR 21
1811	!]  NTWK
1812	
1813	!]ERROR 22
1814	!] F1  NTWK
1815	!]NO ERROR 22
1816	!]  NTWK
1817	
1818	!]ERROR 23
1819	!] G1  NTWK
1820	!]NO ERROR 23
1821	!]  NTWK
1822	
1823	!]ERROR 24
1824	!] G1  NTWK
1825	!]NO ERROR 24
1826	!]  NTWK
1827	
1828	!]ERROR 25
1829	!] G1  NTWK
1830	!]NO ERROR 25
1831	!]  NTWK
1832	
1833	!]ERROR 26
1834	!] G1  NTWK
1835	!]NO ERROR 26
1836	!]  NTWK
1837	
1838	!]ERROR 27
1839	!] H1  NTWK
1840	!]NO ERROR 27
1841	!]  NTWK
1842	
1843	!]ERROR 28
1844	!] H1  NTWK
1845	!]NO ERROR 28
1846	!]  NTWK
1847	
1848	!]ERROR 29
1849	!] H1  NTWK
1850	!]NO ERROR 29
1851	!]  NTWK
1852	
1853	!]ERROR 30
1854	!] H1  NTWK
1855	!]NO ERROR 30
1856	!]  NTWK
1857	
1858	!]ERROR 31
1859	!] I1  NTWK
1860	!]NO ERROR 31
1861	!]  NTWK
1862	
1863	!]ERROR 32
1864	!] I1  NTWK
1865	!]NO ERROR 32
1866	!]  NTWK
1867	
1868	!]ERROR 33
1869	!] I1  NTWK
1870	!]NO ERROR 33
1871	!]  NTWK
1872	
1873	!]ERROR 34
1874	!] I1  NTWK
1875	!]NO ERROR 34
1876	!]  NTWK
1877	
1878	!]ERROR 35
1879	!] J1  NTWK
1880	!]NO ERROR 35
1881	!]  NTWK
1882	
1883	!]ERROR 36
1884	!] J1  NTWK
1885	!]NO ERROR 36
1886	!]  NTWK
1887	
1888	!*MESSAGE 2
1889	!*STIMULUS
1890	!*	WRT 113,105,107,111,103 - Write 0's to the 8080 bus
1891	!*				  data registers
1892	!*	WRT 210/143 - Set:  CONSOLE REQ, T ENB FOR COM/ADR,
1893	!*			    LATCH DATA SENT, R CLK ENB L
1894	!*	RD 103,3,2,1,0 - 8080 Regs should contain the data
1895	!*			 put on the bus
1896	!*RESPONSE
1897	!*	Bus data bits \S0 are stuck at \D1
1898	
1899	!]ERROR 37
1900	!] A1  NTWK
1901	!]NO ERROR 37
1902	!]  NTWK
1903	
1904	!]ERROR 38
1905	!] B1  NTWK
1906	!]NO ERROR 38
1907	!]  NTWK
1908	
1909	!]ERROR 39
1910	!] C1  NTWK
1911	!]NO ERROR 39
1912	!]  NTWK
1913	
1914	!]ERROR 40
1915	!] D1  NTWK
1916	!]NO ERROR 40
1917	!]  NTWK
1918	
1919	!]ERROR 41
1920	!] E1  NTWK
1921	!]NO ERROR 41
1922	!]  NTWK
1923	
1924	!]ERROR 42
1925	!] F1  NTWK
1926	!]NO ERROR 42
1927	!]  NTWK
1928	
1929	!]ERROR 43
1930	!] G1  NTWK
1931	!]NO ERROR 43
1932	!]  NTWK
1933	
1934	!]ERROR 44
1935	!] H1  NTWK
1936	!]NO ERROR 44
1937	!]  NTWK
1938	
1939	!]ERROR 45
1940	!] I1  NTWK
1941	!]NO ERROR 45
1942	!]  NTWK
1943	
1944	!]ERROR 46
1945	!] J1  NTWK
1946	!]NO ERROR 46
1947	!]  NTWK
1948	
1949	!*MESSAGE 3
1950	!*STIMULUS
1951	!*	WRT 113,105,107,111,103 - Write 0's to the 8080 bus
1952	!*				  data registers
1953	!*	WRT 210/143 - Set:  CONSOLE REQ, T ENB FOR COM/ADR,
1954	!*			    LATCH DATA SENT, R CLK ENB L
1955	!*	RD 103,3,2,1,0 - 8080 Regs should contain the data
1956	!*			 put on the bus
1957	!*RESPONSE
1958	!*	Bus data bits 00-35 has some bits stuck at \D1
1959	
1960	!]ERROR 47
1961	!] A1 B1 C1 D1 E1 F1 G1 H1 I1 J1 L7 AA  NTWK
1962	!]NO ERROR 47
1963	!]  NTWK
1964	
1965	END;
1966	GLOBAL ROUTINE TST2: NOVALUE =
1967	
1968	!++   ------------ VERIFY CONTROL SIGNALS ON THE BUS ---------------
1969	! TEST DESCRIPTION:  This routine verifies that  the control signals
1970	!	on the bus ('AC LO','RESET','MEM BUSY','I/O BUSY','BAD DATA',
1971	!	'COM ADR','I/O DATA', and 'DATA') are  not  stuck low on the
1972	!	MMC board.  A Master Reset is done - then  these signals are
1973	!	inspected.  None of them should be asserted.
1974	!
1975	! TEST ASSUMPTIONS:  None.
1976	!
1977	! TEST PROCEDURE:  Master Reset
1978	!		   Read 8080 I/O Reg 102
1979	!		   Verify that each bit is 0
1980	!			'RESET'
1981	!			'MEM BUSY'
1982	!			'I/O BUSY'
1983	!			'BAD DATA'
1984	!			'COM ADR'
1985	!			'I/O DATA'
1986	!			'DATA'
1987	!
1988	! POSSIBLE ERRORS:  
1989	!
1990	!--
1991	
1992	BEGIN
1993	
1994	OWN
1995		REG;
1996	
1997	LABEL
1998		BLOCK1;
1999	
2000	IF RUN_TEST(2) THEN RETURN;		! Run this test? Return if no
2001	
2002	RPT_ERR_FLAG = 1;			! Report any unexpected errors
2003	NOERR_2 = 0;				! No errors have occurred yet
2004	
2005	DO (0) WHILE
2006	BLOCK1:	BEGIN
2007		MR();				! Master Reset
2008		REG = RD_102;			! Read 8080 Reg 102
2009		IF (.REG AND RRESET) NEQ 0
2010		    THEN BEGIN			! Not 0?  Error - print error message
2011			 TEST_ABORT = 1;	!   and abort further testing.
2012			 ERRS(1,1,REG);
2013			 END;
2014		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
2015		IF (.REG AND RMEM_BUSY) NEQ 0
2016		    THEN BEGIN			! Not 0?  Error - print error message
2017			 TEST_ABORT = 1;	!   and abort further testing.
2018			 ERRS(2,2,REG);
2019			 END;
2020		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
2021		IF (.REG AND RIO_BUSY) NEQ 0
2022		    THEN BEGIN			! Not 0?  Error - print error message
2023			 TEST_ABORT = 1;	!   and abort further testing.
2024			 ERRS(3,3,REG);
2025			 END;
2026		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
2027		IF (.REG AND RBAD_DATA) NEQ 0
2028		    THEN BEGIN			! Not 0?  Error - print error message
2029			 TEST_ABORT = 1;	!   and abort further testing.
2030			 ERRS(4,4,REG);
2031			 END;
2032		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
2033		IF (.REG AND RCOM_ADR) NEQ 0
2034		    THEN BEGIN			! Not 0?  Error - print error message
2035			 TEST_ABORT = 1;	!   and abort further testing.
2036			 ERRS(5,5,REG);
2037			 END;
2038		IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
2039		IF (.REG AND RIO_DATA) NEQ 0
2040		    THEN BEGIN			! Not 0?  Error - print error message
2041			 TEST_ABORT = 1;	!   and abort further testing.
2042			 ERRS(6,6,REG);
2043			 END;
2044		IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
2045		IF (.REG AND RDATA) NEQ 0
2046		    THEN BEGIN			! Not 0?  Error - print error message
2047			 TEST_ABORT = 1;	!   and abort further testing.
2048			 ERRS(7,7,REG);
2049			 END;
2050		IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
2051		0				! To eliminate INFO compiler message
2052		END;
2053	
2054	!*MESSAGE 1
2055	!*STIMULUS
2056	!*	MR	Master Reset
2057	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
2058	!*RESPONSE
2059	!*	'RESET' signal is asserted     102:  \O0
2060	
2061	!]ERROR 1
2062	!] DB  NTWK
2063	!]NO ERROR 1
2064	!]  NTWK
2065	
2066	!*MESSAGE 2
2067	!*STIMULUS
2068	!*	MR	Master Reset
2069	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
2070	!*RESPONSE
2071	!*	'MEM BUSY' signal is asserted     102:  \O0
2072	
2073	!]ERROR 2
2074	!] N3 I5 AB DB  NTWK
2075	!]NO ERROR 2
2076	!]  NTWK
2077	
2078	!*MESSAGE 3
2079	!*STIMULUS
2080	!*	MR	Master Reset
2081	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
2082	!*RESPONSE
2083	!*	'I/O BUSY' signal is asserted     102:  \O0
2084	
2085	!]ERROR 3
2086	!] F3 DB  NTWK
2087	!]NO ERROR 3
2088	!]  NTWK
2089	
2090	!*MESSAGE 4
2091	!*STIMULUS
2092	!*	MR	Master Reset
2093	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
2094	!*RESPONSE
2095	!*	'BAD DATA' signal is asserted     102:  \O0
2096	
2097	!]ERROR 4
2098	!] AA BA  NTWK
2099	!]NO ERROR 4
2100	!]  NTWK
2101	
2102	!*MESSAGE 5
2103	!*STIMULUS
2104	!*	MR	Master Reset
2105	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
2106	!*RESPONSE
2107	!*	'COM ADR' signal is asserted     102:  \O0
2108	
2109	!]ERROR 5
2110	!] BA  NTWK
2111	!]NO ERROR 5
2112	!]  NTWK
2113	
2114	!*MESSAGE 6
2115	!*STIMULUS
2116	!*	MR	Master Reset
2117	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
2118	!*RESPONSE
2119	!*	'I/O DATA' signal is asserted     102:  \O0
2120	
2121	!]ERROR 6
2122	!] L7 DB  NTWK
2123	!]NO ERROR 6
2124	!]  NTWK
2125	
2126	!*MESSAGE 7
2127	!*STIMULUS
2128	!*	MR	Master Reset
2129	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's
2130	!*RESPONSE
2131	!*	'DATA' signal is asserted     102:  \O0
2132	
2133	!]ERROR 7
2134	!] AA BA  NTWK
2135	!]NO ERROR 7
2136	!]  NTWK
2137	
2138	END;
2139	GLOBAL ROUTINE TST3: NOVALUE =
2140	
2141	!++   ------------------- SIMPLE WRITE/READ STATUS ------------------
2142	! TEST DESCRIPTION:  This routine verifies that something can be done
2143	!	with the MMC board.  This test merely attempts a write status
2144	!	and a read status. If MMC hangs after either (causing ?MRE or
2145	!	?NXM)  or  MMC just doesnt do anything then something is very
2146	!	wrong with the board.
2147	!
2148	! TEST ASSUMPTIONS:  None.
2149	!
2150	! TEST PROCEDURE:  MR
2151	!		   Sync T & R Clocks (in maintenance mode)
2152	!		   Set up 8080 registers for a Com/Adr cycle
2153	!			indicating an I/O read & 0's data
2154	!		   Write control bits needed to do the operation
2155	!		   Tick the clock until 'I/O BUSY' has asserted
2156	!			and cleared or 25 T Clocks (100 ticks)
2157	!			whichever comes first
2158	!		   Verify response:  There should be no errors
2159	!			(particularly no ?MRE)
2160	!
2161	!		   Repeat with an I/O write
2162	!
2163	! POSSIBLE ERRORS:  
2164	!
2165	!--
2166	
2167	BEGIN
2168	
2169	LITERAL
2170		READ_IO = %O'600000100000',	! Read MSR
2171		WRITE_IO = %O'500000100000';	! Write MSR
2172	
2173	OWN
2174		MESSV: VECTOR[5];		! Error message output vector
2175	
2176	BIND
2177		TICK1 = MESSV,
2178		TICK2 = MESSV[1],
2179		REG102 = MESSV[2],
2180		REG102A = MESSV[3],
2181		REG101 = MESSV[4],
2182		REF_ERR = UPLIT(%ASCIZ '?MRE');	! For CHK_ERR_MSG routine
2183	
2184	LABEL
2185		BLOCK1,
2186		BLOCK2;
2187	
2188	IF RUN_TEST(3) THEN RETURN;		! Run this test? Return if no
2189	
2190	RPT_ERR_FLAG = 0;			! Don't report unexpected error
2191	NOERR_3 = 0;				! No errors have occurred yet
2192	
2193	DO (0) WHILE
2194	BLOCK1:	BEGIN
2195	!
2196	!----  READ  ----
2197	!
2198		MR();				! Master Reset
2199		SYNC_CLK();			! Put clock in maintenance mode
2200		WRITE_COMADR(READ_IO);		! Start an I/O read
2201		WRITE_CONTROL();
2202		TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;
2203	
2204		DO  BEGIN
2205		    TICK(4);			! Tick along until 'I/O BUSY' appears
2206		    REG102 = RD_102;		!   in Reg 102 (but not past a timeout
2207		    CHK_ERR_MSG(REF_ERR);	!   error or 100 ticks).  Check for
2208		    TICK1 = .TICK1 + 4;		!   unexpected error messages and
2209		    END				!   discard them.
2210		WHILE (.TICK1 LSS 100 AND (.REG102 AND RIO_BUSY) EQL 0 AND .TIMOUT EQL 0);
2211	
2212		IF .TIMOUT EQL 0		! If it didnt timeout then tick along
2213		    THEN BEGIN			!   until 'I/O BUSY' clears from 102
2214			 DO  BEGIN		!   (but not past a timeout error or
2215			     TICK(4);		!   100 ticks).  Also discard any
2216			     REG102A = RD_102;	!   unexpected error messages gotten.
2217			     CHK_ERR_MSG(REF_ERR);
2218			     TICK2 = .TICK2 + 4;
2219			     END
2220			 WHILE (.TICK2 LSS 100 AND (.REG102A AND RIO_BUSY) NEQ 0 AND .TIMOUT EQL 0);
2221			 END;
2222	
2223	! Now do error handling.
2224	
2225		IF .TIMOUT EQL 1		! Was there a timout error - if yes
2226		    THEN BEGIN			!   set error flags and print error
2227			 NOERR_3 = 1;		!   messages.
2228			 ERRS(1,1,MESSV);
2229			 IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
2230			 RETURN;
2231			 END;
2232		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
2233	
2234		START_CLK;			! All done fiddling so start up clock
2235		SEND_NUL();			!   and discard any more unexpected
2236		CHK_ERR_MSG(REF_ERR);		!   error message that appear.
2237	
2238		REG101 = RD_101;		! Read I/O Reg 101 to see if ?MRE
2239		IF (.REG101 AND 1) EQL 1	!   occurred at any point back there.
2240		    THEN BEGIN			! If so set error flags and print
2241			 MRE_IO = 1;		!   error messages.
2242			 NOERR_3 = 1;
2243			 ERRS(2,2,MESSV);
2244			 END;
2245		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
2246	
2247		IF .TICK1 NEQ 100		! Did the MSR read fail (1st half)?
2248		    THEN BEGIN			! If so set error flags and
2249			 MSR_READ = 1;		!   print error message.
2250			 NOERR_3 = 1;
2251			 ERRS(3,3,MESSV);
2252			 END;
2253		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
2254	
2255		IF .TICK2 EQL 100		! Did the MSR read fail (2nd half)?
2256		    THEN BEGIN			! If so set error flags and print
2257			 MSR_READ = 1;		!   error message.
2258			 NOERR_3 = 1;
2259			 ERRS(4,4,MESSV);
2260			 END;
2261		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
2262		0				! To eliminate INFO compiler message
2263		END;
2264	
2265	DO (0) WHILE
2266	BLOCK2:	BEGIN
2267	!
2268	!----  WRITE  ----
2269	!
2270		MR();				! Master Reset
2271		SYNC_CLK();			! Put clock in maintenance mode
2272		WRITE_COMADR(WRITE_IO);		! Start and I/O write
2273		WRITE_DATA(0);
2274		WRITE_CONTROL();
2275		TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;
2276	
2277		DO  BEGIN			! Tick along until 'I/O BUSY' appears
2278		    TICK(4);			!   in Reg 102 (but not past a timout
2279		    REG102 = RD_102;		!   error or 100 ticks).  Check for
2280		    CHK_ERR_MSG(REF_ERR);	!   unexpected error messages and
2281		    TICK1 = .TICK1 + 4;		!   discard them.
2282		    END
2283		WHILE (.TICK1 LSS 100 AND (.REG102 AND RIO_BUSY) EQL 0 AND .TIMOUT EQL 0);
2284		IF .TIMOUT EQL 0		! If it didnt timeout then tick along
2285		    THEN BEGIN			!   until 'I/O BUSY' clears from 102
2286			 DO  BEGIN		!   (but not past a timeout error or
2287			     TICK(4);		!   100 ticks).  Also discard any
2288			     REG102A = RD_102;	!   unexpected error messages gotten.
2289			     CHK_ERR_MSG(REF_ERR);
2290			     TICK2 = .TICK2 + 4;
2291			     END
2292			 WHILE (.TICK2 LSS 100 AND (.REG102A AND RIO_BUSY) NEQ 0 AND .TIMOUT EQL 0);
2293			 END;
2294	
2295	! Now do error handling.
2296	
2297		IF .TIMOUT EQL 1		! Was there a timout error - if yes
2298		    THEN BEGIN			!   set error flags and print error
2299			 NOERR_3 = 1;		!   messages.
2300			 ERRS(5,5,MESSV);
2301			 IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;
2302			 RETURN;
2303			 END;
2304		IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;
2305	
2306		START_CLK;			! All done fiddling so start up clock
2307		SEND_NUL();			!   and discard any more unexpected
2308		CHK_ERR_MSG(REF_ERR);		!   error message that appear.
2309		
2310		REG101 = RD_101;		! Read I/O Reg 101 to see if ?MRE
2311		IF (.REG101 AND 1) EQL 1	!   occurred at any point back there.
2312		    THEN BEGIN			! If so set error flags and print
2313			 MRE_IO = 1;		!   error messages.
2314			 NOERR_3 = 1;
2315		    	 ERRS(6,6,MESSV);
2316			 END;
2317		IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;
2318	
2319		IF .TICK1 EQL 100		! Did the MSR write fail (1st half)?
2320		    THEN BEGIN			! If so set error flags and
2321			 MSR_WRITE = 1;		!   print error message.
2322			 NOERR_3 = 1;
2323			 ERRS(7,7,MESSV);
2324			 END;
2325		IF LOOP_CHK(7) THEN LEAVE BLOCK2 WITH 1;
2326	
2327		IF .TICK2 EQL 100		! Did the MSR write fail (2nd half)?
2328		    THEN BEGIN			! If so set error flags and print
2329			 MSR_WRITE = 1;		!   error message.
2330			 NOERR_3 = 1;
2331			 ERRS(8,8,MESSV);
2332			 END;
2333		IF LOOP_CHK(8) THEN LEAVE BLOCK2 WITH 1;
2334		0				! To eliminate INFO compiler message
2335		END;
2336	
2337	!*MESSAGE 1
2338	!*STIMULUS
2339	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2340	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2341	!*				Regs 102...115 - Read Mem Stat Reg
2342	!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
2343	!*				REQ,T ENB FOR COM/ADR & DATA,
2344	!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
2345	!*	  (It should assert only on a 'STATUS I/O WRITE') then watch
2346	!*	  for it to clear
2347	!*RESPONSE
2348	!*	KS10 timed out - MMC failed to respond for 60 seconds
2349	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2350	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2351	
2352	!]ERROR 1
2353	!] AA BA AB BB CB DB  NTWK
2354	!]NO ERROR 1
2355	!]  NTWK
2356	
2357	!*MESSAGE 2
2358	!*STIMULUS
2359	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2360	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2361	!*				Regs 102...115 - Read Mem Stat Reg
2362	!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
2363	!*				REQ,T ENB FOR COM/ADR & DATA,
2364	!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
2365	!*	  (It should assert only on a 'STATUS I/O WRITE')
2366	!*	Turn clocks back on then check to see if a ?MRE results
2367	!*RESPONSE
2368	!*	?MRE occurred - MMC hung?
2369	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2370	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2371	!*	8080 REG 101: \O4
2372	
2373	!]ERROR 2
2374	!] A1 K1 E3 F3 L7 A9 B9 C9 AA AB BB CB BC  NTWK
2375	!]NO ERROR 2
2376	!]  NTWK
2377	
2378	!*MESSAGE 3
2379	!*STIMULUS
2380	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2381	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2382	!*				Regs 102...115 - Read Mem Stat Reg
2383	!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
2384	!*				REQ,T ENB FOR COM/ADR & DATA,
2385	!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
2386	!*	  (It should assert only on a 'STATUS I/O WRITE')
2387	!*	Turn clocks back on then check to see if a ?MRE results
2388	!*RESPONSE
2389	!*	'I/O BUSY' appeared in Reg 102 
2390	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2391	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2392	
2393	!]ERROR 3
2394	!] A1 E3 F3 L7 DB BC  NTWK
2395	!]NO ERROR 3
2396	!]  NTWK
2397	
2398	!*MESSAGE 4
2399	!*STIMULUS
2400	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2401	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2402	!*				Regs 102...115 - Read Mem Stat Reg
2403	!*	LR 210,DR 361	    Write 'I/O READ' control bits - CHECK NXM,CONSOLE
2404	!*				REQ,T ENB FOR COM/ADR & DATA,
2405	!*	Tick clock while watching for 'I/O BUSY' in 8080 I/O Reg 102
2406	!*	  (It should assert only on a 'STATUS I/O WRITE')
2407	!*	Turn clocks back on then check to see if a ?MRE results
2408	!*RESPONSE
2409	!*	'I/O BUSY' still asserted in Reg 102
2410	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2411	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2412	
2413	!]ERROR 4
2414	!] A1 E3 F3 L7 DB BC  NTWK
2415	!]NO ERROR 4
2416	!]  NTWK
2417	
2418	!*MESSAGE 5
2419	!*STIMULUS
2420	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2421	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2422	!*				Regs 102...115 - Write 0's to Mem Stat Reg
2423	!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
2424	!*				REQ,T ENB FOR COM/ADR & DATA,
2425	!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
2426	!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
2427	!*RESPONSE
2428	!*	KS10 timed out - MMC failed to respond for 60 seconds
2429	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2430	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2431	
2432	!]ERROR 5
2433	!] AA BA AB BB CB DB  NTWK
2434	!]NO ERROR 5
2435	!]  NTWK
2436	
2437	!*MESSAGE 6
2438	!*STIMULUS
2439	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2440	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2441	!*				Regs 102...115 - Write 0's to Mem Stat Reg
2442	!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
2443	!*				REQ,T ENB FOR COM/ADR & DATA,
2444	!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
2445	!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
2446	!*	Turn clocks back on then check to see if a ?MRE results
2447	!*RESPONSE
2448	!*	?MRE occurred - MMC hung?
2449	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2450	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2451	!*	8080 Reg 101: \O4
2452	
2453	!]ERROR 6
2454	!] A1 K1 E3 F3 L7 A9 B9 C9 AA AB BB CB BC  NTWK
2455	!]NO ERROR 6
2456	!]  NTWK
2457	
2458	!*MESSAGE 7
2459	!*STIMULUS
2460	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2461	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2462	!*				Regs 102...115 - Write 0's to Mem Stat Reg
2463	!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
2464	!*				REQ,T ENB FOR COM/ADR & DATA,
2465	!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
2466	!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
2467	!*	Turn clocks back on then check to see if a ?MRE results
2468	!*RESPONSE
2469	!*	'I/O BUSY' never appeared in Reg 102
2470	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2471	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2472	
2473	!]ERROR 7
2474	!] A1 D1 E1 F1 H1 J1 K1 E3 F3 I3 J3 K3 L3 M3 N3 L7 DB BC  NTWK
2475	!]NO ERROR 7
2476	!]  NTWK
2477	
2478	!*MESSAGE 8
2479	!*STIMULUS
2480	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2481	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2482	!*				Regs 102...115 - Write 0's to Mem Stat Reg
2483	!*	LR 210,DR 361	    Write 'I/O WRITE' control bits - CHECK NXM,CONSOLE
2484	!*				REQ,T ENB FOR COM/ADR & DATA,
2485	!*	Tick clock until 'I/O BUSY' appears in 8080 I/O Reg 102
2486	!*	Tick clock until 'I/O BUSY' clears from 8080 I/O Reg 102
2487	!*	Turn clocks back on then check to see if a ?MRE results
2488	!*RESPONSE
2489	!*	'I/O BUSY' never cleared from Reg 102
2490	!*	Clock ticks given:  to see 'I/O BUSY' - \D0   Reg 102: \O2
2491	!*			  to clear 'I/O BUSY' - \D1   Reg 102: \O3
2492	
2493	!]ERROR 8
2494	!] A1 E3 F3 I3 J3 K3 L3 M3 N3 L7 DB BC  NTWK
2495	!]NO ERROR 8
2496	!]  NTWK
2497	
2498	END;
2499	GLOBAL ROUTINE TST4: NOVALUE =
2500	
2501	!++   ------------------- SIMPLE WRITE/READ MEMORY ------------------
2502	! TEST DESCRIPTION:  This routine verifies that something can be done
2503	!	with the MMC board.  This test merely attempts a write memory
2504	!	and a read memory. If MMC hangs after either (causing ?MRE or
2505	!	?NXM)  or  MMC just doesnt do anything then something is very
2506	!	wrong with the board.
2507	!
2508	! TEST ASSUMPTIONS:  None.
2509	!
2510	! TEST PROCEDURE:  MR
2511	!		   Sync T & R Clocks (In maintenance mode)
2512	!		   Set up 8080 registers for a Com/Adr cycle
2513	!			indicating an mem read & 0's data
2514	!		   Write control bits needed to do the operation
2515	!		   Tick the clock until 'MEM BUSY' has asserted
2516	!			and cleared or 25 T Clocks (100 ticks)
2517	!			whichever comes first
2518	!		   Verify response:  There should be no errors
2519	!			(particularly no ?MRE)
2520	!
2521	!		   Repeat with an mem write
2522	!
2523	! POSSIBLE ERRORS:  
2524	!
2525	!--
2526	
2527	BEGIN
2528	
2529	LITERAL
2530		READ_MEM = %O'200000000000',	! Read mem loc 0
2531		WRITE_MEM = %O'100000000000';	! Write mem loc 0
2532	
2533	OWN
2534		MESSV: VECTOR[6];		! Error message output vector
2535	
2536	BIND
2537		TICK1 = MESSV,
2538		TICK2 = MESSV[1],
2539		REG102 = MESSV[2],
2540		REG102A = MESSV[3],
2541		REG101 = MESSV[4],
2542		REG301 = MESSV[5],
2543		REF_ERR = UPLIT(%ASCIZ '?MRE');
2544	
2545	LABEL
2546		BLOCK1,
2547		BLOCK2;
2548	
2549	IF RUN_TEST(4) THEN RETURN;		! Run this test? Return if no
2550	
2551	RPT_ERR_FLAG = 0;			! Don't report unexpected error
2552	NOERR_4 = 0;				! No errors have occurred yet
2553	
2554	DO (0) WHILE
2555	BLOCK1:	BEGIN
2556	!
2557	!----  READ  ----
2558	!
2559		MR();				! Master Reset
2560		SYNC_CLK();			! Put clocks in maintenance mode
2561		WRITE_COMADR(READ_MEM);		! Start a memory read
2562		WRITE_CONTROL();
2563		TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;
2564	
2565		DO  BEGIN
2566		    TICK(4);			! Tick along until 'MEM BUSY' appears
2567		    REG102 = RD_102;		!   in Reg 102 (but not past a timeout
2568		    CHK_ERR_MSG(REF_ERR);	!   error or 100 ticks).  Check for 
2569		    TICK1 = .TICK1 + 4;		!   unexpected error messages and
2570		    END				!   discard them.
2571		WHILE (.TICK1 LSS 100 AND (.REG102 AND RMEM_BUSY) EQL 0 AND .TIMOUT EQL 0);
2572	
2573		IF .TIMOUT EQL 0		! If it didnt timeout then tick along
2574		    THEN BEGIN			!   until 'MEM BUSY' clears from 102
2575			 DO  BEGIN		!   (but not past a timeout error or
2576			     TICK(4);		!   100 ticks).  Also discard any
2577			     REG102A = RD_102;	!   unexpected error messages gotten.
2578			     CHK_ERR_MSG(REF_ERR);
2579			     TICK2 = .TICK2 + 4;
2580			     END
2581			 WHILE (.TICK2 LSS 100 AND (.REG102A AND RMEM_BUSY) NEQ 0 AND .TIMOUT EQL 0);
2582			 END;
2583	
2584	! Now do error handling.
2585	
2586		IF .TIMOUT EQL 1		! Was there a timeout error - if yes
2587		    THEN BEGIN			!   set error flags and print error
2588			 NOERR_4 = 1;		!   messages.
2589			 ERRS(1,1,MESSV);
2590			 IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
2591			 RETURN;
2592			 END;
2593		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
2594	
2595		START_CLK;			! All done fiddling so start up clock
2596		SEND_NUL();			!   and discard any more unexpected
2597		CHK_ERR_MSG(REF_ERR);		!   error message that appear.
2598	
2599		REG301 = RD_301;		! Read I/O Regs 301 and 101 to see if
2600		REG101 = RD_101;		!   ?NXM or ?MRE occurred at any point
2601		IF (.REG101 AND 1) EQL 1	!   back there.
2602		    THEN BEGIN			! If so set error flags and print
2603			 MRE_MEM = 1;		!   error messages.
2604			 NOERR_4 = 1;
2605		    	 ERRS(2,2,MESSV);
2606			 END;
2607		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
2608	
2609		IF (.REG301 AND NEXM) NEQ 0	! Did we get a ?NXM - If so set
2610		    THEN BEGIN			!   error flags and print error
2611			 NOERR_4 = 1;		!   message.
2612			 ERRS(3,3,MESSV);
2613			 END;
2614		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
2615	
2616		IF .TICK1 EQL 100		! Did the mem read fail (1st half)?
2617		    THEN BEGIN			! If so set error flags and
2618			 NOERR_4 = 1;		!   print error message.
2619			 ERRS(4,4,MESSV);
2620			 END;
2621		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
2622	
2623		IF .TICK2 EQL 100		! Did the mem read fail (2nd half)?
2624		    THEN BEGIN			! If so set error flags and print
2625			 NOERR_4 = 1;		!   error message.
2626			 ERRS(5,5,MESSV);
2627			 END;
2628		IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
2629		0				! To eliminate INFO compiler message
2630		END;
2631	
2632	DO (0) WHILE
2633	BLOCK2:	BEGIN
2634	!
2635	!----  WRITE  ----
2636	!
2637		MR();				! Master Reset
2638		SYNC_CLK();			! Put clock in maintenance mode
2639		WRITE_COMADR(WRITE_MEM);	! Start and mem write
2640		WRITE_DATA(0);			! Tick along until 'MEM BUSY' appears
2641		WRITE_CONTROL();
2642		TICK1 = TICK2 = REG102 = REG102A = REG101 = 0;
2643	
2644		DO  BEGIN			! Tick along until 'MEM BUSY' appears
2645		    TICK(4);			!   in Reg 102 (but not past a timout
2646		    REG102 = RD_102;		!   error or 100 ticks).  Check for
2647		    CHK_ERR_MSG(REF_ERR);	!   unexpected error messages and
2648		    TICK1 = .TICK1 + 4;		!   discard them.
2649		    END
2650		WHILE (.TICK1 LSS 100 AND (.REG102 AND RMEM_BUSY) EQL 0 AND .TIMOUT EQL 0);
2651	
2652		DO  BEGIN			! Now tick along until 'MEM BUSY'
2653		    TICK(4);			!   clears from Reg 102 (but not past
2654		    REG102A = RD_102;		!   a timeout error or 100 ticks).
2655		    CHK_ERR_MSG(REF_ERR);	!   Also discard any unexpected error
2656		    TICK2 = .TICK2 + 4;		!   messages gotten.
2657		    END
2658		WHILE (.TICK2 LSS 100 AND (.REG102A AND RMEM_BUSY) NEQ 0 AND .TIMOUT EQL 0);
2659	
2660	
2661	! Now do error handling.
2662	
2663		IF .TIMOUT EQL 1		! Was there a timout error - if yes
2664		    THEN BEGIN			!   set error flags and print error
2665			 NOERR_4 = 1;		!   messages.
2666			 ERRS(6,6,MESSV);
2667			 IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;
2668			 RETURN;
2669			 END;
2670		IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;
2671	
2672		START_CLK;			! All done fiddling so start up clock
2673		SEND_NUL();			!   and discard any more unexpected
2674		CHK_ERR_MSG(REF_ERR);		!   error message that appear.
2675	
2676		REG301 = RD_301;		! Read I/O Regs 301,101 to see if ?NXM
2677		REG101 = RD_101;		!   or ?MRE occurred at any point back
2678		IF (.REG101 AND 1) EQL 1	!   there.
2679		    THEN BEGIN			! If so set error flags and print
2680			 MRE_MEM = 1;		!   error messages.
2681			 NOERR_4 = 1;
2682		    	 ERRS(7,7,MESSV);
2683			 END;
2684		IF LOOP_CHK(7) THEN LEAVE BLOCK2 WITH 1;
2685	
2686		IF (.REG301 AND NEXM) NEQ 0	! If ?NXM occurred set error flags
2687		    THEN BEGIN			!   and print error messages.
2688			 NOERR_4 = 1;
2689			 ERRS(8,8,MESSV);
2690			 END;
2691		IF LOOP_CHK(8) THEN LEAVE BLOCK2 WITH 1;
2692	
2693		IF .TICK1 EQL 100		! Did the mem write fail (1st half)?
2694		    THEN BEGIN			! If so set error flags and
2695			 NOERR_4 = 1;		!   print error message.
2696			 ERRS(9,9,MESSV);
2697			 END;
2698		IF LOOP_CHK(9) THEN LEAVE BLOCK2 WITH 1;
2699	
2700		IF .TICK2 EQL 100		! Did the mem write fail (2nd half)?
2701		    THEN BEGIN			! If so set error flags and print
2702			 NOERR_4 = 1;		!   error message.
2703			 ERRS(10,10,MESSV);
2704			 END;
2705		IF LOOP_CHK(10) THEN LEAVE BLOCK2 WITH 1;
2706	
2707		0				! To eliminate INFO compiler message
2708		END;
2709	
2710	! If no errors occurred in tests 3 and 4 (MSR read/write and mem read/write)
2711	!   then  the  flops 'MMC3 READ' and 'MMC3 WRITE' have to be ok so eliminate
2712	!   from the STIRS fault isolation vector.  By calling NOERR  specifying the
2713	!   two networks I3 - 'MMC3 READ' and O3 - 'MMC3 WRITE'.
2714	
2715		IF (.NOERR_3 OR .NOERR_4) EQL 0
2716		    THEN NOERR(1);
2717	
2718	!*MESSAGE 1
2719	!*STIMULUS
2720	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2721	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2722	!*				Regs 102...115 - Read mem loc 0
2723	!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
2724	!*				REQ,T ENB FOR COM/ADR & DATA
2725	!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
2726	!*	  then watch for it to disappear
2727	!*RESPONSE
2728	!*	KS10 timed out - MMC failed to respond for 60 seconds
2729	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2730	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2731	
2732	!]ERROR 1
2733	!] AA BA AB BB CB DB  NTWK
2734	!]NO ERROR 1
2735	!] I3 O3  NTWK
2736	
2737	!*MESSAGE 2
2738	!*STIMULUS
2739	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2740	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2741	!*				Regs 102...115 - Read mem loc 0
2742	!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
2743	!*				REQ,T ENB FOR COM/ADR & DATA
2744	!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
2745	!*	Turn clocks back on then check to see if a ?MRE results
2746	!*RESPONSE
2747	!*	?MRE occurred - MMC hung?
2748	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2749	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2750	!*	8080 Regs 101: \O4    301: \O5
2751	
2752	!]ERROR 2
2753	!] A1 K1 EFION3 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
2754	!]NO ERROR 2
2755	!]  NTWK
2756	
2757	!*MESSAGE 3
2758	!*STIMULUS
2759	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2760	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2761	!*				Regs 102...115 - Read mem loc 0
2762	!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
2763	!*				REQ,T ENB FOR COM/ADR & DATA
2764	!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
2765	!*	Turn clocks back on then check to see if a ?MRE results
2766	!*RESPONSE
2767	!*	?NXM occurred
2768	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2769	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2770	!*	8080 Regs 101: \O4    301: \O5
2771	
2772	!]ERROR 3
2773	!] A1 K1 E3 F3 J3 K3 L3 N3 C5 A7 B7 L7 A9 A8 AA AB BB CB DB  NTWK
2774	!]NO ERROR 3
2775	!]  NTWK
2776	
2777	!*MESSAGE 4
2778	!*STIMULUS
2779	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2780	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2781	!*				Regs 102...115 - Read mem loc 0
2782	!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
2783	!*				REQ,T ENB FOR COM/ADR & DATA
2784	!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
2785	!*	Turn clocks back on then check to see if a ?MRE results
2786	!*RESPONSE
2787	!*	'MEM BUSY' never appeared in Reg 102
2788	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2789	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2790	!*	8080 Regs 101: \O4    301: \O5
2791	
2792	!]ERROR 4
2793	!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
2794	!]NO ERROR 4
2795	!]  NTWK
2796	
2797	!*MESSAGE 5
2798	!*STIMULUS
2799	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2800	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2801	!*				Regs 102...115 - Read mem loc 0
2802	!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
2803	!*				REQ,T ENB FOR COM/ADR & DATA
2804	!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
2805	!*	Turn clocks back on then check to see if a ?MRE results
2806	!*RESPONSE
2807	!*	'MEM BUSY' never cleared from Reg 102
2808	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2809	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2810	!*	8080 Regs 101: \O4    301: \O5
2811	
2812	!]ERROR 5
2813	!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
2814	!]NO ERROR 5
2815	!]  NTWK
2816	
2817	!*MESSAGE 6
2818	!*STIMULUS
2819	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2820	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2821	!*				Regs 102...115 - Read mem loc 0
2822	!*	LR 210,DR 360	    Write 'MEM READ' control bits - CHECK NXM,CONSOLE
2823	!*				REQ,T ENB FOR COM/ADR & DATA
2824	!*	Tick clock while watching for 'MEM BUSY' in 8080 I/O Reg 102
2825	!*	  then watch for it to disappear
2826	!*RESPONSE
2827	!*	KS10 timed out - MMC failed to respond for 60 seconds
2828	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2829	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2830	
2831	!]ERROR 6
2832	!] AA BA AB BB CB DB  NTWK
2833	!]NO ERROR 6
2834	!]  NTWK
2835	
2836	!*MESSAGE 7
2837	!*STIMULUS
2838	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2839	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2840	!*				Regs 102...115 - Write 0's to mem loc 0
2841	!*	LR 210,DR 360	    Write 'MEM WRITE' control bits - CHECK NXM,CONSOLE
2842	!*				REQ,T ENB FOR COM/ADR & DATA
2843	!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
2844	!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
2845	!*	Turn clocks back on then check to see if a ?MRE results
2846	!*RESPONSE
2847	!*	?MRE occurred - MMC hung?
2848	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2849	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2850	!*	8080 Regs 101: \O4    301: \O5
2851	
2852	!]ERROR 7
2853	!] A1 K1 EFION3 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
2854	!]NO ERROR 7
2855	!]  NTWK
2856	
2857	!*MESSAGE 8
2858	!*STIMULUS
2859	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2860	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2861	!*				Regs 102...115 - WRITE 0'S TO MEM LOC 0
2862	!*	LR 210,DR 360	    Write 'MEM WRITE' control bits - CHECK NXM,CONSOLE
2863	!*				REQ,T ENB FOR COM/ADR & DATA
2864	!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
2865	!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
2866	!*	Turn clocks back on then check to see if a ?MRE results
2867	!*RESPONSE
2868	!*	?NXM occurred
2869	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2870	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2871	!*	8080 Regs 101: \O4    301: \O5
2872	
2873	!]ERROR 8
2874	!] A1 K1 E3 F3 J3 K3 L3 N3 C5 A7 B7 L7 A9 A8 AA AB BB CB DB  NTWK
2875	!]NO ERROR 8
2876	!]  NTWK
2877	
2878	!*MESSAGE 9
2879	!*STIMULUS
2880	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2881	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2882	!*				Regs 102...115 - WRITE 0'S TO MEM LOC 0
2883	!*	LR 210,DR 360	    WRITE 'MEM WRITE' CONTROL BITS - CHECK NXM,CONSOLE
2884	!*				REQ,T ENB FOR COM/ADR & DATA
2885	!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
2886	!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
2887	!*	Turn clocks back on then check to see if a ?MRE results
2888	!*RESPONSE
2889	!*	'MEM BUSY' never appeared in Reg 102
2890	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2891	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2892	!*	8080 Regs 101: \O4    301: \O5
2893	
2894	!]ERROR 9
2895	!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
2896	!]NO ERROR 9
2897	!]  NTWK
2898	
2899	!*MESSAGE 10
2900	!*STIMULUS
2901	!*	MR,SYNC CLOCKS	    T & R Clocks synced in maintenance mode
2902	!*	LR (REG),DR (DATA)  Write Com/Adr cycle & data cycle data to 8080
2903	!*				Regs 102...115 - Write 0's to mem loc 0
2904	!*	LR 210,DR 360	    Write 'MEM WRITE' write control bits - CHECK NXM,
2905	!*				CONSOLE REQ,T ENB FOR COM/ADR & DATA
2906	!*	Tick clock until 'MEM BUSY' appears in 8080 I/O Reg 102
2907	!*	Tick clock until 'MEM BUSY' clears from 8080 I/O Reg 102
2908	!*	Turn clocks back on then check to see if a ?MRE results
2909	!*RESPONSE
2910	!*	'MEM BUSY' never cleared from Reg 102
2911	!*	Clock ticks given:  to see 'MEM BUSY' - \D0   Reg 102: \O2
2912	!*			  to clear 'MEM BUSY' - \D1   Reg 102: \O3
2913	!*	8080 Regs 101: \O4    301: \O5
2914	
2915	!]ERROR 10
2916	!] A1 K1 EFION3 C5 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB BC  NTWK
2917	!]NO ERROR 10
2918	!]  NTWK
2919	
2920	END;
2921	GLOBAL ROUTINE TST5: NOVALUE =
2922	
2923	!++   ------------ 'MMC3 READ','MMC3 WRITE' CONTROL BITS -----------
2924	! TEST DESCRIPTION:  This routine  verifies that the read/write bits
2925	!	that are loaded  from  the Com/Adr cycle data are valid.  If
2926	!	either of them or both are stuck high/low then the operation
2927	!	will either cause a memory  refresh  error by hanging up the
2928	!	memory or it will succeed. The address attempted to  read or
2929	!	write will be a memory location  of  existent memory so if a
2930	!	read is actually successful no errors will be returned.
2931	!
2932	! TEST ASSUMPTIONS:  None.
2933	!
2934	! TEST PROCEDURE:  MR
2935	!		   Set up 8080 registers for a Com/Adr cycle
2936	!			indicating a read,write,both, or neither
2937	!		   Write control bits needed to do the operation
2938	!		   Verify response:  ?MRE  ?NXM  NO RESPONSE
2939	!			and print out error messages (if error)
2940	!
2941	!		   Correct response:
2942	!			READ	-	NO RESPONSE
2943	!			WRITE	-	NO RESPONSE
2944	!			READ&WRITE  -	?MRE
2945	!			NEITHER    -	?MRE
2946	!
2947	! POSSIBLE ERRORS:  'MMC3 READ' or 'MMC3 WRITE' flip flops are faulty
2948	!
2949	!--
2950	
2951	BEGIN
2952	
2953	LITERAL
2954		READ = 1^34,			! Bit for a read
2955		WRITE = 1^33;			! Bit for a write
2956	
2957	LOCAL
2958		M_REF,
2959		NXM;
2960	
2961	OWN
2962		MESSV: VECTOR[2];		! Error message output vector
2963	
2964	BIND
2965		REF_ERR = UPLIT(%ASCIZ '?MRE');
2966	
2967	LABEL
2968		BLOCK1,
2969		BLOCK2,
2970		BLOCK3,
2971		BLOCK4;
2972	
2973	IF RUN_TEST(5) THEN RETURN;		! Run this test? Return if no
2974	
2975	NOERR_5 = 0;				! No errors have occurred yet
2976	RPT_ERR_FLAG = 0;			! Don't report unexpected error
2977	
2978	!
2979	!----  READ  ----
2980	!
2981	DO (0) WHILE
2982	BLOCK1:	BEGIN
2983		MR();				! Master Reset
2984		WRITE_COMADR(READ);		! Do a read cycle
2985		WRT115(COM_ADR);
2986		WRT114(DATA_CYCLE);
2987		WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA+CLOSE_LATCH);
2988		SEND_NUL();			! Get this sent off to 8080
2989	
2990		IF .TIMOUT EQL 1		! Did a timeout error occur?
2991		    THEN BEGIN			! If so set error flag, print
2992			 NOERR_5 = 1;		!   error message and exit
2993			 ERR(1);
2994			 IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
2995			 RETURN;
2996			 END;
2997		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
2998	
2999		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
3000		MESSV = RD_101;			! Read 8080 Reg 101 and see if 
3001		M_REF = .MESSV AND 1;		!   we got a ?MRE
3002		MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
3003		NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM
3004	
3005		IF .NXM EQL 1 AND .M_REF EQL 0	! If only a ?NXM occurred set
3006		    THEN BEGIN			!   error flag and print error
3007			 NOERR_5 = 1;		!   message
3008			 ERRS(2,2,MESSV);
3009			 END;
3010		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
3011	
3012		IF .NXM EQL 0 AND .M_REF EQL 1	! If only a ?MRE occurred set
3013		    THEN BEGIN			!   error flag and print error
3014			 MRE_MEM = 1;		!   message
3015			 NOERR_5 = 1;
3016		    	 ERRS(3,3,MESSV);
3017			 END;
3018		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
3019	
3020		IF .NXM EQL 1 AND .M_REF EQL 1	! If both a ?MRE and a ?NXM occurred
3021		    THEN BEGIN			!   set error flag and print error
3022			 MRE_MEM = 1;		!   message
3023			 NOERR_5 = 1;
3024		    	 ERRS(4,4,MESSV);
3025			 END;
3026		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
3027		0				! To eliminate INFO compiler message
3028		END;
3029	
3030	!
3031	!----  WRITE  ----
3032	!
3033	DO (0) WHILE
3034	BLOCK2:	BEGIN
3035		MR();				! Master Reset
3036		WRITE_COMADR(WRITE);		! Do a write cycle
3037		WRT115(COM_ADR);
3038		WRT114(DATA_CYCLE);
3039		WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA+CLOSE_LATCH);
3040		SEND_NUL();			! Get this sent off to 8080
3041	
3042		IF .TIMOUT EQL 1		! Did a timeout error occur?
3043		    THEN BEGIN			! If so set error flag, print
3044			 NOERR_5 = 1;		!   error message and exit
3045			 ERR(5);
3046			 IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;
3047			 RETURN;
3048			 END;
3049		IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;
3050	
3051		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
3052		MESSV = RD_101;			! Read 8080 Reg 101 and see if 
3053		M_REF = .MESSV AND 1;		!   we got a ?MRE
3054		MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
3055		NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM
3056	
3057		IF .NXM EQL 1 AND .M_REF EQL 0	! If only a ?NXM occurred set
3058		    THEN BEGIN			!   error flag and print error
3059			 NOERR_5 = 1;		!   message
3060			 ERRS(6,6,MESSV);
3061			 END;
3062		IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;
3063	
3064		IF .NXM EQL 0 AND .M_REF EQL 1	! If only a ?MRE occurred set
3065		    THEN BEGIN			!   error flag and print error
3066			 MRE_MEM = 1;		!   message
3067			 NOERR_5 = 1;
3068			 ERRS(7,7,MESSV);
3069			 END;
3070		IF LOOP_CHK(7) THEN LEAVE BLOCK2 WITH 1;
3071	
3072		IF .NXM EQL 1 AND .M_REF EQL 1	! If both a ?MRE and a ?NXM occurred
3073		    THEN BEGIN			!   set error flag and print error
3074			 MRE_MEM = 1;		!   message
3075			 NOERR_5 = 1;
3076		    	 ERRS(8,8,MESSV);
3077			 END;
3078		IF LOOP_CHK(8) THEN LEAVE BLOCK2 WITH 1;
3079		0				! To eliminate INFO compiler message
3080		END;
3081	
3082	!
3083	!----  READ & WRITE  ----
3084	!
3085	DO (0) WHILE
3086	BLOCK3:	BEGIN
3087		MR();				! Master Reset
3088		WRITE_COMADR(READ+WRITE);	! Do a read and a write cycle
3089		WRT115(COM_ADR);
3090		WRT114(DATA_CYCLE);
3091		WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);
3092		SEND_NUL();			! Get this sent off to 8080
3093	
3094		IF .TIMOUT EQL 1		! Did a timeout error occur?
3095		    THEN BEGIN			! If so set error flag, print
3096			 NOERR_5 = 1;		!   error message and exit
3097			 ERR(9);
3098			 IF LOOP_CHK(9) THEN LEAVE BLOCK3 WITH 1;
3099			 RETURN;
3100			 END;
3101		IF LOOP_CHK(9) THEN LEAVE BLOCK3 WITH 1;
3102	
3103		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
3104		MESSV = RD_101;			! Read 8080 Reg 101 and see if 
3105		M_REF = .MESSV AND 1;		!   we got a ?MRE
3106		MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
3107		NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM
3108	
3109		IF .NXM EQL 1 AND .M_REF EQL 1	! If both ?NXM and ?MRE occurred set
3110		    THEN BEGIN			!   error flag and print error
3111			 NOERR_5 = 1;		!   message
3112			 ERRS(10,10,MESSV);
3113			 END;
3114		IF LOOP_CHK(10) THEN LEAVE BLOCK3 WITH 1;
3115	
3116		IF .NXM EQL 0 AND .M_REF EQL 0	! If neither ?NXM nor ?MRE
3117		    THEN BEGIN			!   occurred set error flag
3118			 MRE_MEM_NOT = 1;	!   and print error message
3119			 NOERR_5 = 1;
3120		    	 ERRS(11,11,MESSV);
3121			 END;
3122		IF LOOP_CHK(11) THEN LEAVE BLOCK3 WITH 1;
3123	
3124		IF .NXM EQL 1 AND .M_REF EQL 0	! If ?NXM occurred but ?MRE did not
3125		    THEN BEGIN			!   set error flag and print error
3126			 MRE_MEM_NOT = 1;	!   message
3127			 NOERR_5 = 1;
3128		    	 ERRS(12,12,MESSV);
3129			 END;
3130		IF LOOP_CHK(12) THEN LEAVE BLOCK3 WITH 1;
3131		0				! To eliminate INFO compiler message
3132		END;
3133	
3134	DO (0) WHILE
3135	BLOCK4:	BEGIN
3136	!
3137	!----  NEITHER READ NOR WRITE  ----
3138	!
3139		MR();				! Master Reset - do this twice to
3140		SEND_NUL();			!   make sure we have recovered
3141		WAIT(1000);			!   from the last thing we did
3142		MR();				!   which generated errors
3143		SEND_NUL();
3144		WAIT(1000);
3145		MR();
3146		SEND_NUL();
3147	
3148		WRITE_COMADR(0);		! Do neither a read nor a write
3149		WRT115(COM_ADR);
3150		WRT114(DATA_CYCLE);
3151		WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);
3152		SEND_NUL();			! Get this sent off to 8080
3153	
3154		IF .TIMOUT EQL 1		! Did a timeout error occur?
3155		    THEN BEGIN			! If so set error flag, print
3156			 NOERR_5 = 1;		!   error message and exit
3157			 ERR(13);
3158			 IF LOOP_CHK(13) THEN LEAVE BLOCK4 WITH 1;
3159			 RETURN;
3160			 END;
3161		IF LOOP_CHK(13) THEN LEAVE BLOCK4 WITH 1;
3162	
3163		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected error
3164		MESSV = RD_101;			! Read 8080 Reg 101 and see if 
3165		M_REF = .MESSV AND 1;		!   we got a ?MRE
3166		MESSV[1] = RD_301;		! Read 8080 Reg 301 and see if
3167		NXM = .MESSV[1] AND NEXM;	!   we got a ?NXM
3168	
3169		IF .NXM EQL 1 AND .M_REF EQL 1	! If both ?NXM and ?MRE occurred set
3170		    THEN BEGIN			!   error flag and print error
3171			 NOERR_5 = 1;		!   message
3172			 ERRS(14,14,MESSV);
3173			 END;
3174		IF LOOP_CHK(14) THEN LEAVE BLOCK4 WITH 1;
3175	
3176		IF .NXM EQL 0 AND .M_REF EQL 0	! If neither ?NXM nor ?MRE
3177		    THEN BEGIN			!   occurred set error flag
3178			 MRE_MEM_NOT = 1;	!   and print error message
3179			 NOERR_5 = 1;
3180		    	 ERRS(15,15,MESSV);
3181			 END;
3182		IF LOOP_CHK(15) THEN LEAVE BLOCK4 WITH 1;
3183	
3184		IF .NXM EQL 1 AND .M_REF EQL 0	! If ?NXM occurred but ?MRE did not
3185		    THEN BEGIN			!   set error flag and print error
3186			 MRE_MEM_NOT = 1;	!   message
3187			 NOERR_5 = 1;
3188		    	 ERRS(16,16,MESSV);
3189			 END;
3190		IF LOOP_CHK(16) THEN LEAVE BLOCK4 WITH 1;
3191		0				! To eliminate INFO compiler message
3192		END;
3193	
3194	!*MESSAGE 1
3195	!*STIMULUS
3196	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3197	!*			     107,109,111,113 - Read mem loc 0
3198	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3199	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3200	!*	NXM should not set - No refresh error should occur
3201	!*RESPONSE
3202	!*	KS10 timed out - MMC failed to respond for 60 seconds
3203	
3204	!]ERROR 1
3205	!] AA BA AB BB CB DB  NTWK
3206	!]NO ERROR 1
3207	!]  NTWK
3208	
3209	!*MESSAGE 2
3210	!*STIMULUS
3211	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3212	!*			     107,109,111,113 - Read mem loc 0
3213	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3214	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3215	!*	NXM should not set - No refresh error should occur
3216	!*RESPONSE
3217	!*	No ref err occurred but NXM set
3218	!*	8080 Regs 101: \O0	301: \O1
3219	
3220	!]ERROR 2
3221	!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB AC BC CC  NTWK
3222	!]NO ERROR 2
3223	!]  NTWK
3224	
3225	!*MESSAGE 3
3226	!*STIMULUS
3227	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3228	!*			     107,109,111,113 - Read mem loc 0
3229	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3230	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3231	!*	NXM should not set - No refresh error should occur
3232	!*RESPONSE
3233	!*	Refresh error occurred & NXM not set
3234	!*	8080 Regs 101: \O0	301: \O1
3235	
3236	!]ERROR 3
3237	!] A1 K1 EFION3 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB AC BC CC  NTWK
3238	!]NO ERROR 3
3239	!]  NTWK
3240	
3241	!*MESSAGE 4
3242	!*STIMULUS
3243	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3244	!*			     107,109,111,113 - Read mem loc 0
3245	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3246	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3247	!*	NXM should not set - No refresh error should occur
3248	!*RESPONSE
3249	!*	NXM set and refresh error occurred
3250	!*	8080 Regs 101: \O0	301: \O1
3251	
3252	!]ERROR 4
3253	!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 A9 B9 C9 AA AB BB CB DB AC BC CC  NTWK
3254	!]NO ERROR 4
3255	!]  NTWK
3256	
3257	!*MESSAGE 5
3258	!*STIMULUS
3259	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3260	!*			     107,109,111,113 - Read mem loc 0
3261	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3262	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3263	!*	NXM should not set - No refresh error should occur
3264	!*RESPONSE
3265	!*	KS10 timed out - MMC failed to respond for 60 seconds
3266	
3267	!]ERROR 5
3268	!] AA BA AB BB CB DB  NTWK
3269	!]NO ERROR 5
3270	!]  NTWK
3271	
3272	!*MESSAGE 6
3273	!*STIMULUS
3274	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3275	!*			     107,109,111,113 - Write mem loc 0
3276	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3277	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3278	!*	NXM should not set - No refresh error should occur
3279	!*RESPONSE
3280	!*	NO ref err occurred but NXM set
3281	!*	8080 Regs 101: \O0	301: \O1
3282	
3283	!]ERROR 6
3284	!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB AC BC CC  NTWK
3285	!]NO ERROR 6
3286	!]  NTWK
3287	
3288	!*MESSAGE 7
3289	!*STIMULUS
3290	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3291	!*			     107,109,111,113 - Write mem loc 0
3292	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3293	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3294	!*	NXM should not set - No refresh error should occur
3295	!*RESPONSE
3296	!*	Refresh error occurred & NXM not set
3297	!*	8080 Regs 101: \O0	301: \O1
3298	
3299	!]ERROR 7
3300	!] A1 K1 EFION3 A7 B7 L7 A8 A9 B9 C9 AA BA AB BB CB DB AC BC CC  NTWK
3301	!]NO ERROR 7
3302	!]  NTWK
3303	
3304	!*MESSAGE 8
3305	!*STIMULUS
3306	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3307	!*			     107,109,111,113 - Write mem loc 0
3308	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3309	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3310	!*	NXM should not set - No refresh error should occur
3311	!*RESPONSE
3312	!*	NXM set and refresh error occurred
3313	!*	8080 Regs 101: \O0	301: \O1
3314	
3315	!]ERROR 8
3316	!] A1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 A9 B9 C9 AA AB BB CB DB AC BC CC  NTWK
3317	!]NO ERROR 8
3318	!]  NTWK
3319	
3320	!*MESSAGE 9
3321	!*STIMULUS
3322	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3323	!*			     107,109,111,113 - Read mem loc 0
3324	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3325	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3326	!*	NXM should not set - No refresh error should occur
3327	!*RESPONSE
3328	!*	KS10 timed out - MMC failed to respond for 60 seconds
3329	
3330	!]ERROR 9
3331	!] AA BA AB BB CB DB  NTWK
3332	!]NO ERROR 9
3333	!]  NTWK
3334	
3335	!*MESSAGE 10
3336	!*STIMULUS
3337	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3338	!*			     107,109,111,113 - Read & write mem loc 0
3339	!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3340	!*			  T ENB FOR COM/ADR & DATA
3341	!*	NXM should not set - Refresh error should occur
3342	!*RESPONSE
3343	!*	Refresh error occurred but NXM was set
3344	!*	8080 Regs 101: \O0	301: \O1
3345	
3346	!]ERROR 10
3347	!] A1 I3 J3 K3 N3 L3 O3 A8 A9 B9 C9 AA AC BC CC  NTWK
3348	!]NO ERROR 10
3349	!]  NTWK
3350	
3351	!*MESSAGE 11
3352	!*STIMULUS
3353	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3354	!*			     107,109,111,113 - Read & write mem loc 0
3355	!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3356	!*			  T ENB FOR COM/ADR & DATA
3357	!*	NXM should not set - Refresh error should occur
3358	!*RESPONSE
3359	!*	NXM did not set but refresh error did not occur
3360	!*	8080 Regs 101: \O0	301: \O1
3361	
3362	!]ERROR 11
3363	!] A1 I3 N3 O3 A9 B9 C9 AA BB AC BC CC  NTWK
3364	!]NO ERROR 11
3365	!]  NTWK
3366	
3367	!*MESSAGE 12
3368	!*STIMULUS
3369	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3370	!*			     107,109,111,113 - Read & write mem loc 0
3371	!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3372	!*			  T ENB FOR COM/ADR & DATA
3373	!*	NXM should not set - Refresh error should occur
3374	!*RESPONSE
3375	!*	Refresh error did not occur & NXM set
3376	!*	8080 Regs 101: \O0	301: \O1
3377	
3378	!]ERROR 12
3379	!] A1 I3 J3 K3 N3 O3 A8 AA AB BB AC BC CC  NTWK
3380	!]NO ERROR 12
3381	!]  NTWK
3382	
3383	!*MESSAGE 13
3384	!*STIMULUS
3385	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,
3386	!*			     107,109,111,113 - Read mem loc 0
3387	!*	LR 210,DR 361	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3388	!*			  T ENB FOR COM/ADR & DATA, CLOSE LATCHES
3389	!*	NXM should not set - No refresh error should occur
3390	!*RESPONSE
3391	!*	KS10 timed out - MMC failed to respond for 60 seconds
3392	
3393	!]ERROR 13
3394	!] AA BA AB BB CB DB  NTWK
3395	!]NO ERROR 13
3396	!]  NTWK
3397	
3398	!*MESSAGE 14
3399	!*STIMULUS
3400	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,107,
3401	!*		   109,111,113 - Neither read nor write mem loc 0
3402	!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3403	!*			  T ENB FOR COM/ADR & DATA
3404	!*	NXM should not set - Refresh error should occur
3405	!*RESPONSE
3406	!*	Refresh error occurred but NXM was set
3407	!*	8080 Regs 101: \O0	301: \O1
3408	
3409	!]ERROR 14
3410	!] A1 I3 J3 K3 N3 L3 O3 A8 A9 B9 C9 AA AC BC CC  NTWK
3411	!]NO ERROR 14
3412	!]  NTWK
3413	
3414	!*MESSAGE 15
3415	!*STIMULUS
3416	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,107,
3417	!*		   109,111,113 - Neither read nor write mem loc 0
3418	!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3419	!*			  T ENB FOR COM/ADR & DATA
3420	!*	NXM should not set - Refresh error should occur
3421	!*RESPONSE
3422	!*	NXM not set but refresh error did not occur
3423	!*	8080 Regs 101: \O0	301: \O1
3424	
3425	!]ERROR 15
3426	!] A1 I3 N3 O3 A9 B9 C9 AA BB AC BC CC  NTWK
3427	!]NO ERROR 15
3428	!]  NTWK
3429	
3430	!*MESSAGE 16
3431	!*STIMULUS
3432	!*	LR (REG),DR (DATA)  Write Com/Adr data to 8080 Regs 103,105,107,
3433	!*		   109,111,113 - Neither read nor write mem loc 0
3434	!*	LR 210,DR 360	Set up mem cycle - CHECK NXM,CONSOLE REQ,
3435	!*			  T ENB FOR COM/ADR & DATA
3436	!*	NXM should not set - Refresh error should occur
3437	!*RESPONSE
3438	!*	Refresh error did not occur & NXM set
3439	!*	8080 Regs 101: \O0	301: \O1
3440	
3441	!]ERROR 16
3442	!] A1 I3 J3 K3 N3 O3 A8 AA AB BB AC BC CC  NTWK
3443	!]NO ERROR 16
3444	!]  NTWK
3445	
3446	END;
3447	GLOBAL ROUTINE TST6: NOVALUE =
3448	
3449	!++   ------------------ 8646'S, MOS DRIVERS, DATA PATH ---------------
3450	! TEST DESCRIPTION:  This test  performs a basic functional test of the
3451	!	MMC board. Data is written to memory and read back and verified.
3452	!	This  test  is  intended  to  check out the 8646's, the hex MOS
3453	!	drivers, and the data path within the MMC board.
3454	!
3455	! TEST ASSUMPTIONS:  None.
3456	!
3457	! TEST PROCEDURE:  Write a test pattern to mem loc 0
3458	!		   Read it back and verify it
3459	!		   Repeat with several test patterns
3460	!
3461	! POSSIBLE ERRORS:
3462	!
3463	!--
3464	
3465	BEGIN
3466	
3467	OWN
3468	
3469	! All the message strings
3470	
3471		MESS_STR: VECTOR[28]
3472		    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-05'),
3473			    UPLIT(%ASCIZ '06-07'),UPLIT(%ASCIZ '08-11'),
3474			    UPLIT(%ASCIZ '12-15'),UPLIT(%ASCIZ '16-17'),
3475			    UPLIT(%ASCIZ '18-21'),UPLIT(%ASCIZ '22-23'),
3476			    UPLIT(%ASCIZ '24-25'),UPLIT(%ASCIZ '26-29'),
3477			    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
3478			    UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
3479			    UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
3480			    UPLIT(%ASCIZ '16-17'),UPLIT(%ASCIZ '18-21'),
3481			    UPLIT(%ASCIZ '22-25'),UPLIT(%ASCIZ '26-29'),
3482			    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
3483			    UPLIT(%ASCIZ '00-05'),UPLIT(%ASCIZ '06-11'),
3484			    UPLIT(%ASCIZ '12-17'),UPLIT(%ASCIZ '18-23'),
3485			    UPLIT(%ASCIZ '24-29'),UPLIT(%ASCIZ '30-35')),
3486	
3487	! Data patterns
3488	
3489		PATTERN: VECTOR[4]
3490		    INITIAL (%O'111111111111',%O'666666666666',
3491			     %O'0',%O'777777777777'),
3492	
3493	! Misc
3494	
3495		MEM_STAT_VECT: BTTVECTOR[36],
3496	
3497	! For the special data structure definition
3498	
3499		STRUCT: VECTOR[24]
3500		    INITIAL (32,4,30,2,28,2,24,4,20,4,18,2,14,4,
3501			     12,2,10,2,6,4,2,4,0,2);
3502	
3503	LITERAL
3504		NUM_PATTERN = 4;
3505	
3506	STRUCTURE
3507		BIT_VECT[I;N] = [N]		! This structure duplicates the bit
3508		    (BIT_VECT)			!   partitions on the data path
3509		    <.STRUCT[I*2],.STRUCT[I*2+1]>,
3510		BIT_MOS[I;N] = [N]		! This structure maps the MOS drivers
3511		    (BIT_MOS)			!   into the data path
3512		    <30-I*6,6>;
3513	
3514	OWN
3515		CUM_ERR,			! Errors cumulated so far
3516		CUM_NXMM,			! ?NXM errors cumulated so far
3517		NONXM1,				! ?NXM error
3518		NONXM2,				! ?NXM error
3519		SPEC_VECT: VECTOR[4],
3520		MESSV: VECTOR[2],		! Error message output vector
3521		TEST_8646_VECT: BIT8646[1],	! Data path mapped onto transceivers
3522		TEST_MOS_VECT: BIT_MOS[1],	! Miscellaneous structures
3523		TEST_TEMP_VECT: BIT_VECT[1],	!    ...
3524		TEST_DATA_VECT: BIT_VECT[1],
3525		TEST_PATT_VECT: BIT_VECT[1];
3526	
3527	BIND
3528		S0 = SPEC_VECT[0],
3529		S1 = SPEC_VECT[1],
3530		S2 = SPEC_VECT[2],
3531		S3 = SPEC_VECT[3],
3532		TEST_DATA = TEST_DATA_VECT,
3533		TEST_PATT = TEST_PATT_VECT,
3534		MEM_STAT_REG = MEM_STAT_VECT,
3535		TEST_MOS = TEST_MOS_VECT,
3536		TEST_8646 = TEST_8646_VECT,
3537		TEST_TEMP = TEST_TEMP_VECT;
3538	
3539	LOCAL
3540		SPEC_ERR,
3541		NXMM,
3542		ERR,
3543		ERR_FLAG,
3544		TEMP;
3545	
3546	BIND
3547		REF_ERR = UPLIT(%ASCIZ '?MRE');
3548	
3549	LABEL
3550		BLOCK1;
3551	
3552	IF RUN_TEST(6) THEN RETURN;		! Run this test? Return if no
3553	
3554	NOERR_6 = 0;				! No errors have occurred yet
3555	RPT_ERR_FLAG = 0;			! Don't report unexpected error
3556	
3557	CUM_ERR = CUM_NXMM = 0;			! Init misc flags
3558	S0 = S1 = S2 = S3 = 0;
3559	
3560	INCR DATA_LOOP FROM 0 TO NUM_PATTERN-1 DO
3561		BEGIN				! Now start the test:
3562		TEST_PATT=.PATTERN[.DATA_LOOP];	!   Get the data pattern to use
3563		MESSV = .TEST_PATT;		!   Save it for error ouput
3564		MR();				!   Do a Master Reset
3565		IO_DEPOSIT(MSR,ECC_OFF);	!   Make sure ECC is off
3566		CHK_ERR_MSG(REF_ERR);		!   Discard any unexpected errors
3567	
3568		DO (0) WHILE
3569	BLOCK1:	    BEGIN
3570		    TEST_DATA = ERR_FLAG = NONXM2 = 0;
3571		    NONXM1 = DM_CHK(0,.TEST_PATT);	! Write data and see if a ?NXM
3572		    NONXM1 = .NONXM1 OR .TIMOUT;	!   or timeout occurred 
3573		    CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
3574	
3575		    IF .NONXM1 NEQ 1			! If a ?NXM did not occur read
3576			THEN BEGIN			!   back the data. See if ?NXM
3577			     NONXM2 = EM_CHK(0);	!   or timeout occurred this
3578			     NONXM2 = .NONXM2 OR .TIMOUT;!  time.
3579			     CHK_ERR_MSG(REF_ERR);	! Discard any unexpected errors
3580			     IF .NONXM2 NEQ 1 THEN TEST_DATA = EM(0);
3581			     END;
3582	
3583		    NXMM = NOT (.NONXM1 OR .NONXM2);	! 0 if ?NXM did not occur on
3584							!    either write or read
3585		    SPEC_VECT[.DATA_LOOP] = .TEST_DATA XOR .TEST_PATT;
3586		    CUM_NXMM = .NONXM1 + .NONXM2;
3587	
3588	! Now check to see if there are any single bit errors.
3589	
3590		    INCR BTT FROM 0 TO 35 DO
3591			BEGIN
3592			MESSV[1] = .BTT;
3593			TEMP = .TEST_DATA XOR (1 ^ (35-.BTT));
3594			IF .TEMP EQL .TEST_PATT AND .NXMM
3595			    THEN BEGIN
3596				 ERRCAS(.BTT+1,1,.TEST_PATT,.TEST_DATA,12,MESSV);
3597				 ERR_FLAG = 1;
3598				 END;
3599			IF LOOP_CHK(.BTT + 1) THEN LEAVE BLOCK1 WITH 1;
3600			END;
3601	
3602	! Now check to see if there are any multiple bit errors which occurred in
3603	!   only one logical group of bits (such as in the first transceiver...).
3604	!   These particular groups are the subsections of the  transceivers, MOS
3605	!   drivers and mixers on MMC7 which are common to all three. Hence these
3606	!   are the next stage up from a single bit error.
3607	
3608		    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM;
3609		    INCR BTT FROM 0 TO 11 DO
3610			BEGIN
3611			TEST_TEMP = 0;
3612			TEST_TEMP_VECT[.BTT] = %O'777777';
3613			TEMP = .TEST_DATA OR .TEST_TEMP;
3614			IF .TEMP EQL (.TEST_PATT OR .TEST_TEMP) AND .ERR
3615			    THEN BEGIN
3616				 ERR_FLAG = 1;
3617				 MESSV[1] = .MESS_STR[.BTT];
3618				 ERRCAS(.BTT+37,2,.TEST_PATT,.TEST_DATA,12,MESSV);
3619				 END;
3620			IF LOOP_CHK(.BTT + 37) THEN LEAVE BLOCK1 WITH 1;
3621			END;
3622	
3623	! Now check to see if there are any errors which occurred exclusively in
3624	!   the 8646 transceivers.
3625	
3626		    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM;
3627		    INCR BTT FROM 0 TO 9 DO
3628			BEGIN
3629			TEST_8646 = 0;
3630			TEST_8646_VECT[.BTT] = %O'777777';
3631			TEMP = .TEST_DATA OR .TEST_8646;
3632			IF .TEMP EQL (.TEST_PATT OR .TEST_8646) AND .ERR
3633			    THEN BEGIN
3634				 ERR_FLAG = 1;
3635				 MESSV[1] = .MESS_STR[.BTT+12];
3636				 ERRCAS(.BTT+49,2,.TEST_PATT,.TEST_DATA,12,MESSV);
3637				 END;
3638			IF LOOP_CHK(.BTT + 49) THEN LEAVE BLOCK1 WITH 1;
3639			END;
3640	
3641	! Now check to see if there are any errors which occurred exclusively in
3642	!   the MOS drivers on MMC6.
3643	
3644		    ERR =(.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM;
3645		    INCR BTT FROM 0 TO 5 DO
3646			BEGIN
3647			TEST_MOS = 0;
3648			TEST_MOS_VECT[.BTT] = %O'777777';
3649			TEMP = .TEST_DATA OR .TEST_MOS;
3650			IF .TEMP EQL (.TEST_PATT OR .TEST_MOS) AND .ERR
3651			    THEN BEGIN
3652				 ERR_FLAG = 1;
3653				 MESSV[1] = .MESS_STR[.BTT+22];
3654				 ERRCAS(.BTT+59,2,.TEST_PATT,.TEST_DATA,12,MESSV);
3655				 END;
3656			IF LOOP_CHK(.BTT + 59) THEN LEAVE BLOCK1 WITH 1;
3657			END;
3658		    CUM_ERR = .CUM_ERR + .ERR_FLAG;
3659	
3660	! So if no error messages have been printed out yet and the data came
3661	!   back incorrectly, then the error must be a strange  multiple  bit
3662	!   error.  So we will report the whole thing.
3663	
3664		    IF (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .TEST_PATT) AND .NXMM
3665			THEN BEGIN
3666			     ERR_FLAG = CUM_ERR = 1;
3667			     ERRCAS(65,3,.TEST_PATT,.TEST_DATA,12,MESSV);
3668			     END
3669			ELSE BEGIN
3670			     IF (.CUM_ERR EQL 0) AND (.DATA_LOOP EQL .NUM_PATTERN - 1)
3671				THEN NOERR(1);
3672			     END;
3673		    IF LOOP_CHK(65) THEN LEAVE BLOCK1 WITH 1;
3674	
3675	! Do the rest of the error reporting for ?NXM errors.
3676	! Also set error flags for prior errors which occurred.
3677	
3678		    IF .CUM_ERR NEQ 0
3679			THEN BEGIN
3680			     NOERR_6 = 1;		! Test 6 has error
3681			     BUS_XCVR = 1;		! Bus xcvr has a fault
3682			     END;
3683	
3684		    IF .NONXM1 EQL 1			! Report ?NXM on the write
3685			THEN BEGIN
3686			     NOERR_6 = 1;
3687			     ERRS(66,4,MESSV);
3688			     END;
3689		    IF LOOP_CHK(66) THEN LEAVE BLOCK1 WITH 1;
3690	
3691		    IF .NONXM2 EQL 1			! Report ?NXM on the read
3692			THEN BEGIN
3693			     NOERR_6 = 1;
3694			     ERRS(67,5,MESSV);
3695			     END;
3696		    IF LOOP_CHK(67) THEN LEAVE BLOCK1 WITH 1;
3697	
3698		    IF (.S0 EQL .S1) AND (.S0 EQL .S2) AND (.S0 EQL .S3) AND (.S0 NEQ 0)
3699			THEN BEGIN			! Now if the fault has been 
3700			     TEST_ABORT = 1;		!   sufficiently isolated, set
3701			     NOERR_6 = 1;		!   Test Abort switch to abort
3702			     ERRS(72,10,TEMP);		!   all future testing.
3703			     END
3704			ELSE NOERR(3);
3705		    IF .NOERR_6 EQL 0
3706			THEN NOERR(2);
3707	
3708	!*MESSAGE 1
3709	!*STIMULUS:
3710	!*	LA 0	Write to mem loc 0
3711	!*	DM \U0
3712	!*	EM 0	Examine mem loc 0
3713	!*RESPONSE:
3714	!*	Bit \D1 of data returned is incorrect
3715	
3716	!]ERROR 1
3717	!] A1 A2 H2 A6 C7  NTWK
3718	!]NO ERROR 1
3719	!] A_J1 A6 B6 C6 D6 E6 F6  NTWK
3720	
3721	!]ERROR 2
3722	!] A1 A2 H2 A6 C7  NTWK
3723	!]NO ERROR 2
3724	!] A6 B6 C6 D6 E6 F6  NTWK
3725	
3726	!]ERROR 3
3727	!] A1 A2 H2  A6 C7 B9  NTWK
3728	!]NO ERROR 3
3729	!] A2 B2 C2 D2 E2 F2 G2  NTWK
3730	
3731	!]ERROR 4
3732	!] A1 A2 H2 A6 C7  NTWK
3733	!]NO ERROR 4
3734	!]  NTWK
3735	
3736	!]ERROR 5
3737	!] B1 A2 H2 A6 D7  NTWK
3738	!]NO ERROR 5
3739	!]  NTWK
3740	
3741	!]ERROR 6
3742	!] B1 A2 H2 A6 D7  NTWK
3743	!]NO ERROR 6
3744	!]  NTWK
3745	
3746	!]ERROR 7
3747	!] B1 B2 I2 B6 D7  NTWK
3748	!]NO ERROR 7
3749	!]  NTWK
3750	
3751	!]ERROR 8
3752	!] B1 B2 I2 B6 D7  NTWK
3753	!]NO ERROR 8
3754	!]  NTWK
3755	
3756	!]ERROR 9
3757	!] C1 B2 I2 B6 E7  NTWK
3758	!]NO ERROR 9
3759	!]  NTWK
3760	
3761	!]ERROR 10
3762	!] C1 B2 I2 B6 E7  NTWK
3763	!]NO ERROR 10
3764	!]  NTWK
3765	
3766	!]ERROR 11
3767	!] C1 B2 I2 B6 E7  NTWK
3768	!]NO ERROR 11
3769	!]  NTWK
3770	
3771	!]ERROR 12
3772	!] C1 B2 I2 B6 E7  NTWK
3773	!]NO ERROR 12
3774	!]  NTWK
3775	
3776	!]ERROR 13
3777	!] D1 C2 J2 C6 F7  NTWK
3778	!]NO ERROR 13
3779	!]  NTWK
3780	
3781	!]ERROR 14
3782	!] D1 C2 J2 C6 F7  NTWK
3783	!]NO ERROR 14
3784	!]  NTWK
3785	
3786	!]ERROR 15
3787	!] D1 C2 J2 C6 F7  NTWK
3788	!]NO ERROR 15
3789	!]  NTWK
3790	
3791	!]ERROR 16
3792	!] D1 C2 J2 C6 F7  NTWK
3793	!]NO ERROR 16
3794	!]  NTWK
3795	
3796	!]ERROR 17
3797	!] E1 C2 J2 C6 G7  NTWK
3798	!]NO ERROR 17
3799	!]  NTWK
3800	
3801	!]ERROR 18
3802	!] E1 C2 J2 C6 G7  NTWK
3803	!]NO ERROR 18
3804	!]  NTWK
3805	
3806	!]ERROR 19
3807	!] F1 D2 K2 D6 G7  NTWK
3808	!]NO ERROR 19
3809	!]  NTWK
3810	
3811	!]ERROR 20
3812	!] F1 D2 K2 D6 G7  NTWK
3813	!]NO ERROR 20
3814	!]  NTWK
3815	
3816	!]ERROR 21
3817	!] F1 D2 K2 D6 H7  NTWK
3818	!]NO ERROR 21
3819	!]  NTWK
3820	
3821	!]ERROR 22
3822	!] F1 D2 K2 D6 H7  NTWK
3823	!]NO ERROR 22
3824	!]  NTWK
3825	
3826	!]ERROR 23
3827	!] G1 D2 K2 D6 H7  NTWK
3828	!]NO ERROR 23
3829	!]  NTWK
3830	
3831	!]ERROR 24
3832	!] G1 D2 K2 D6 H7  NTWK
3833	!]NO ERROR 24
3834	!]  NTWK
3835	
3836	!]ERROR 25
3837	!] G1 E2 L2 E6 I7  NTWK
3838	!]NO ERROR 25
3839	!]  NTWK
3840	
3841	!]ERROR 26
3842	!] G1 E2 L2 E6 I7  NTWK
3843	!]NO ERROR 26
3844	!]  NTWK
3845	
3846	!]ERROR 27
3847	!] H1 E2 L2 E6 I7  NTWK
3848	!]NO ERROR 27
3849	!]  NTWK
3850	
3851	!]ERROR 28
3852	!] H1 E2 L2 E6 I7  NTWK
3853	!]NO ERROR 28
3854	!]  NTWK
3855	
3856	!]ERROR 29
3857	!] H1 E2 L2 E6 J7  NTWK
3858	!]NO ERROR 29
3859	!]  NTWK
3860	
3861	!]ERROR 30
3862	!] H1 E2 L2 E6 J7  NTWK
3863	!]NO ERROR 30
3864	!]  NTWK
3865	
3866	!]ERROR 31
3867	!] I1 F2 M2 F6 J7  NTWK
3868	!]NO ERROR 31
3869	!]  NTWK
3870	
3871	!]ERROR 32
3872	!] I1 F2 M2 F6 J7  NTWK
3873	!]NO ERROR 32
3874	!]  NTWK
3875	
3876	!]ERROR 33
3877	!] I1 F2 M2 F6 K7  NTWK
3878	!]NO ERROR 33
3879	!]  NTWK
3880	
3881	!]ERROR 34
3882	!] I1 F2 M2 F6 K7  NTWK
3883	!]NO ERROR 34
3884	!]  NTWK
3885	
3886	!]ERROR 35
3887	!] J1 F2 M2 F6 K7  NTWK
3888	!]NO ERROR 35
3889	!]  NTWK
3890	
3891	!]ERROR 36
3892	!] J1 F2 M2 F6 K7  NTWK
3893	!]NO ERROR 36
3894	!]  NTWK
3895	
3896	!*MESSAGE 2
3897	!*STIMULUS:
3898	!*	LA 0	Write to mem loc 0
3899	!*	DM \U0
3900	!*	EM 0	Examine mem loc 0
3901	!*RESPONSE:
3902	!*	Bits \S1 of data returned is incorrect
3903	
3904	!]ERROR 37
3905	!] A1 A2 H2 A6 C7  NTWK
3906	!]NO ERROR 37
3907	!]  NTWK
3908	
3909	!]ERROR 38
3910	!] B1 A2 H2 A6 D7  NTWK
3911	!]NO ERROR 38
3912	!]  NTWK
3913	
3914	!]ERROR 39
3915	!] B1 B2 I2 B6 D7  NTWK
3916	!]NO ERROR 39
3917	!]  NTWK
3918	
3919	!]ERROR 40
3920	!] C1 B2 I2 B6 E7  NTWK
3921	!]NO ERROR 40
3922	!]  NTWK
3923	
3924	!]ERROR 41
3925	!] D1 C2 J2 C6 F7  NTWK
3926	!]NO ERROR 41
3927	!]  NTWK
3928	
3929	!]ERROR 42
3930	!] E1 C2 J2 C6 G7  NTWK
3931	!]NO ERROR 42
3932	!]  NTWK
3933	
3934	!]ERROR 43
3935	!] F1 D2 K2 D6 G7 H7  NTWK
3936	!]NO ERROR 43
3937	!]  NTWK
3938	
3939	!]ERROR 44
3940	!] G1 D2 K2 D6 H7  NTWK
3941	!]NO ERROR 44
3942	!]  NTWK
3943	
3944	!]ERROR 45
3945	!] G1 E2 L2 E6 I7  NTWK
3946	!]NO ERROR 45
3947	!]  NTWK
3948	
3949	!]ERROR 46
3950	!] H1 E2 L2 E6 I7 J7  NTWK
3951	!]NO ERROR 46
3952	!]  NTWK
3953	
3954	!]ERROR 47
3955	!] I1 F2 M2 F6 J7 K7  NTWK
3956	!]NO ERROR 47
3957	!]  NTWK
3958	
3959	!]ERROR 48
3960	!] J1 F2 M2 F6 K7  NTWK
3961	!]NO ERROR 48
3962	!]  NTWK
3963	
3964	!]ERROR 49
3965	!] A1 A2 H2 A6 C7  NTWK
3966	!]NO ERROR 49
3967	!]  NTWK
3968	
3969	!]ERROR 50
3970	!] B1 A2 B2 H2 I2 A6 B6 D7  NTWK
3971	!]NO ERROR 50
3972	!]  NTWK
3973	
3974	!]ERROR 51
3975	!] C1 B2 I2 B6 E7  NTWK
3976	!]NO ERROR 51
3977	!]  NTWK
3978	
3979	!]ERROR 52
3980	!] D1 C2 J2 C6 F7  NTWK
3981	!]NO ERROR 52
3982	!]  NTWK
3983	
3984	!]ERROR 53
3985	!] E1 C2 J2 C6 G7  NTWK
3986	!]NO ERROR 53
3987	!]  NTWK
3988	
3989	!]ERROR 54
3990	!] F1 D2 K2 D6 G7 H7  NTWK
3991	!]NO ERROR 54
3992	!]  NTWK
3993	
3994	!]ERROR 55
3995	!] G1 D2 E2 K2 L2 D6 E6 H7 I7  NTWK
3996	!]NO ERROR 55
3997	!]  NTWK
3998	
3999	!]ERROR 56
4000	!] H1 E2 L2 E6 I7 J7  NTWK
4001	!]NO ERROR 56
4002	!]  NTWK
4003	
4004	!]ERROR 57
4005	!] I1 F2 M2 F6 J7 K7  NTWK
4006	!]NO ERROR 57
4007	!]  NTWK
4008	
4009	!]ERROR 58
4010	!] J1 F2 M2 F6 K7  NTWK
4011	!]NO ERROR 58
4012	!]  NTWK
4013	
4014	!]ERROR 59
4015	!] A1 B1 A2 H2 A6 C7 D7  NTWK
4016	!]NO ERROR 59
4017	!]  NTWK
4018	
4019	!]ERROR 60
4020	!] B1 C1 B2 I2 B6 D7 E7  NTWK
4021	!]NO ERROR 60
4022	!]  NTWK
4023	
4024	!]ERROR 61
4025	!] D1 E1 C2 J2 C6 F7 G7  NTWK
4026	!]NO ERROR 61
4027	!]  NTWK
4028	
4029	!]ERROR 62
4030	!] F1 G1 D2 K2 D6 G7 H7  NTWK
4031	!]NO ERROR 62
4032	!]  NTWK
4033	
4034	!]ERROR 63
4035	!] G1 H1 E2 L2 E6 I7 J7  NTWK
4036	!]NO ERROR 63
4037	!]  NTWK
4038	
4039	!]ERROR 64
4040	!] I1 J1 F2 M2 F6 J7 K7  NTWK
4041	!]NO ERROR 64
4042	!]  NTWK
4043	
4044	!*MESSAGE 3
4045	!*STIMULUS:
4046	!*	LA 0	Write to mem loc 0
4047	!*	DM \U0
4048	!*	EM 0	Examine mem loc 0
4049	!*RESPONSE:
4050	!*	Bits 00-35 of data returned is incorrect
4051	
4052	!]ERROR 65
4053	!] A_J1 A_D3 I_O3 C_K7 B_K8 AA BA AB BB DB AC BC  NTWK
4054	!]NO ERROR 65
4055	!]  NTWK
4056	
4057	!*MESSAGE 4
4058	!*STIMULUS:
4059	!*	LA 0	Write to mem loc 0
4060	!*	DM \U0
4061	!*RESPONSE:
4062	!*	NXM SET
4063	
4064	!]ERROR 66
4065	!] A1 D1 E1 F1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB DB AC BC CC  NTWK
4066	!]NO ERROR 66
4067	!]  NTWK
4068	
4069	!*MESSAGE 5
4070	!*STIMULUS:
4071	!*	LA 0	Write to mem loc 0
4072	!*	DM \U0
4073	!*	EM 0	Examine mem loc 0
4074	!*RESPONSE:
4075	!*	NXM set
4076	
4077	!]ERROR 67
4078	!] A1 D1 E1 F1 K1 EFION3 J3 K3 C5 A7 B7 L7 A8 AA AB BB CB DB AC BC CC  NTWK
4079	!]NO ERROR 67
4080	!]  NTWK
4081	
4082		    SPEC_ERR = 0;
4083		    MESSV[1] = MEM_STAT_REG = EI(100000);
4084		    CHK_ERR_MSG(REF_ERR);
4085		    IF .MEM_STAT_VECT[2] EQL 1
4086			THEN SPEC_ERR = 68 * (.SPEC_ERR EQL 0);
4087		    IF .MEM_STAT_VECT[3] EQL 1
4088			THEN SPEC_ERR = 69 * (.SPEC_ERR EQL 0);
4089		    IF .MEM_STAT_VECT[4] EQL 1
4090			THEN SPEC_ERR = 70 * (.SPEC_ERR EQL 0);
4091		    IF .MEM_STAT_VECT[12] EQL 1
4092			THEN SPEC_ERR = 71 * (.SPEC_ERR EQL 0);
4093		    INCR ERR FROM 68 TO 71 DO
4094			BEGIN
4095			IF .SPEC_ERR EQL .ERR
4096			    THEN BEGIN
4097				 NOERR_6 = 1;
4098				 ERRCAS(.ERR,.ERR-62,.TEST_PATT,.TEST_DATA,12,MESSV);
4099				 END;
4100			IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
4101			END;
4102		    0				! To eliminate INFO compiler message
4103		    END;
4104		END;
4105	
4106	!*MESSAGE 6
4107	!*STIMULUS:
4108	!*	LA 0	Write to mem loc 0
4109	!*	DM \U0
4110	!*	EM 0	Examine mem loc 0
4111	!*	Examine Mem Status Register
4112	!*RESPONSE:
4113	!*	Data returned ok but refresh error set
4114	!*	Mem Stat Reg:  \U1
4115	
4116	!]ERROR 68
4117	!] A1 K1 C7 AA AB BB DB  NTWK
4118	!]NO ERROR 68
4119	!]  NTWK
4120	
4121	!*MESSAGE 7
4122	!*STIMULUS:
4123	!*	LA 0	Write to mem loc 0
4124	!*	DM \U0
4125	!*	EM 0	Examine mem loc 0
4126	!*	Examine Mem Status Register
4127	!*RESPONSE:
4128	!*	Data returned ok but memory parity error set
4129	!*	Mem Stat Reg:  \U1
4130	
4131	!]ERROR 69
4132	!] A_N1 C7 AA AB CB DB  NTWK
4133	!]NO ERROR 69
4134	!]  NTWK
4135	
4136	!*MESSAGE 8
4137	!*STIMULUS:
4138	!*	LA 0	Write to mem loc 0
4139	!*	DM \U0
4140	!*	EM 0	Examine mem loc 0
4141	!*	Examine Mem Status Register
4142	!*RESPONSE:
4143	!*	Data returned ok but ECC shut off
4144	!*	Mem Stat Reg:  \U1
4145	
4146	!]ERROR 70
4147	!] A1 B1 J1 K1 H3 D7 AA AB CB DB  NTWK
4148	!]NO ERROR 70
4149	!]  NTWK
4150	
4151	!*MESSAGE 9
4152	!*STIMULUS:
4153	!*	LA 0	Write to mem loc 0
4154	!*	DM \U0
4155	!*	EM 0	Examine mem loc 0
4156	!*	Examine Mem Status Register
4157	!*RESPONSE:
4158	!*	Data returned ok but power fail set
4159	!*	Mem Stat Reg:  \U1
4160	
4161	!]ERROR 71
4162	!] A1 D1 K1 A5 F7 AA AB CB DB  NTWK
4163	!]NO ERROR 71
4164	!]  NTWK
4165	
4166	!*MESSAGE 10
4167	!*STIMULUS:
4168	!*	LA 0	Write to mem loc 0
4169	!*	DM \U0
4170	!*	EM 0	Examine mem loc 0
4171	!*RESPONSE:
4172	!*	'MMC2 ECC CODE XX' stuck hi/lo - data bit is complemented
4173	
4174	!]ERROR 72
4175	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2  NTWK
4176	!]NO ERROR 72
4177	!]  NTWK
4178	
4179	END;
4180	GLOBAL ROUTINE TST7: NOVALUE =
4181	
4182	!++   --------- VERIFY 8080 I/O REG BITS WHEN MEM IS QUIESCENT -------
4183	! TEST DESCRIPTION: This routine verifies that there are no stuck bits
4184	!	in the memory controller.  When the memory is not busy and has
4185	!	just gotten reset  by  a Master Reset, the 8080 Registers that
4186	!	hold PARITY ERROR, REFRESH ERROR,  MEM BUSY, I/O BUSY, and NXM
4187	!	bits should not be set.
4188	!
4189	! TEST ASSUMPTIONS:  None.
4190	!
4191	! TEST PROCEDURE:  Master Reset
4192	!		   Examine mem location 0 (To turn off ?NXM if it
4193	!			is already set)
4194	!		   Master Reset
4195	!		   ER 102 - Should be all 0's
4196	!		   ER 100 - 'MEM PE' should not be set
4197	!		   ER 301 - 'NXM' should not be set
4198	!
4199	! POSSIBLE ERRORS:  
4200	!
4201	!--
4202	
4203	BEGIN
4204	
4205	OWN
4206		REGV: BTTVECTOR[35];
4207	
4208	BIND
4209		REG = REGV;
4210	
4211	LABEL
4212		BLOCK1;
4213	
4214	IF RUN_TEST(7) THEN RETURN;		! Run this test? Return if no
4215	
4216	NOERR_7 = 0;				! No errors have occurred yet
4217	RPT_ERR_FLAG = 0;			! Don't report unexpected error
4218	
4219	DO (0) WHILE
4220	BLOCK1:	BEGIN
4221		MR();				! Master Reset
4222		RPT_ERR_FLAG = 0;		! Don't report unexpected error
4223		EM(0);				! Examine mem loc 0 (to turn off
4224						!   ?NXM if there is one in Reg 301)
4225		MR();				! Master Reset
4226		REG = RD_102;			! Read 8080 Reg 102
4227	
4228		INCR BTT FROM 30 TO 35 DO	! Check to see if any bits set
4229		    BEGIN			!   which shouldnt be
4230		    IF .REGV[.BTT] NEQ 0
4231			THEN BEGIN		! If so set error flags, print
4232			     TEST_ABORT = 1;	!   error message, and abort
4233			     NOERR_7 = 1;	!   future testing
4234			     ERRS(.BTT-29,.BTT-29,REG);
4235			     END;
4236		    IF LOOP_CHK(.BTT-29) THEN LEAVE BLOCK1 WITH 1;
4237		    END;
4238	
4239		REG = RD_100;			! Now take a look at 8080 Reg 100
4240		IF (.REG AND MEM_PE) EQL 0	! Parity error set?
4241		    THEN BEGIN			! If so set error flags, print
4242			 NOERR_7 = 1;		!   error message, and abort
4243			 TEST_ABORT = 1;	!   future testing
4244			 ERRS(7,7,REG);
4245			 END;
4246		IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
4247	
4248		REG = RD_301;			! Read 8080 Reg 301
4249		IF (.REG AND NEXM) NEQ 0	! ?NXM set?
4250		    THEN BEGIN			! If so set error flags, print
4251			 NOERR_7 = 1;		!   error message, and abort
4252			 ERRS(8,8,REG);		!   future testing
4253			 END;
4254		IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
4255		0				! To eliminate INFO compiler message
4256		END;
4257	
4258	!*MESSAGE 1
4259	!*STIMULUS
4260	!*	MR	Master Reset
4261	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4262	!*	MR	Master Reset
4263	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
4264	!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
4265	!*		  'I/O DATA','DATA' - None should be asserted)
4266	!*RESPONSE
4267	!*	'MEM BUSY' asserted       102:  \O0
4268	
4269	!]ERROR 1
4270	!] DB  NTWK
4271	!]NO ERROR 1
4272	!]  NTWK
4273	
4274	!*MESSAGE 2
4275	!*STIMULUS
4276	!*	MR	Master Reset
4277	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4278	!*	MR	Master Reset
4279	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
4280	!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
4281	!*		  'I/O DATA','DATA' - None should be asserted)
4282	!*RESPONSE
4283	!*	'I/O BUSY' asserted       102:  \O0
4284	
4285	!]ERROR 2
4286	!] DB  NTWK
4287	!]NO ERROR 2
4288	!]  NTWK
4289	
4290	!*MESSAGE 3
4291	!*STIMULUS
4292	!*	MR	Master Reset
4293	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4294	!*	MR	Master Reset
4295	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
4296	!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
4297	!*		  'I/O DATA','DATA' - None should be asserted)
4298	!*RESPONSE
4299	!*	'BAD DATA' asserted       102:  \O0
4300	
4301	!]ERROR 3
4302	!] BA  NTWK
4303	!]NO ERROR 3
4304	!]  NTWK
4305	
4306	!*MESSAGE 4
4307	!*STIMULUS
4308	!*	MR	Master Reset
4309	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4310	!*	MR	Master Reset
4311	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
4312	!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
4313	!*		  'I/O DATA','DATA' - None should be asserted)
4314	!*RESPONSE
4315	!*	'COM ADR' asserted       102:  \O0
4316	
4317	!]ERROR 4
4318	!] BA  NTWK
4319	!]NO ERROR 4
4320	!]  NTWK
4321	
4322	!*MESSAGE 5
4323	!*STIMULUS
4324	!*	MR	Master Reset
4325	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4326	!*	MR	Master Reset
4327	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
4328	!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
4329	!*		  'I/O DATA','DATA' - None should be asserted)
4330	!*RESPONSE
4331	!*	'I/O DATA' asserted       102:  \O0
4332	
4333	!]ERROR 5
4334	!] L7 DB NTWK
4335	!]NO ERROR 5
4336	!]  NTWK
4337	
4338	!*MESSAGE 6
4339	!*STIMULUS
4340	!*	MR	Master Reset
4341	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4342	!*	MR	Master Reset
4343	!*	ER 102	Examine 8080 Reg 102 - Should be all 0's -
4344	!*		  ('MEM BUSY', 'I/O BUSY','BAD DATA', 'COM ADR',
4345	!*		  'I/O DATA','DATA' - None should be asserted)
4346	!*RESPONSE
4347	!*	'DATA' asserted       102:  \O0
4348	
4349	!]ERROR 6
4350	!] AA BA  NTWK
4351	!]NO ERROR 6
4352	!]  NTWK
4353	
4354	!*MESSAGE 7
4355	!*STIMULUS
4356	!*	MR	Master Reset
4357	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4358	!*	MR	Master Reset
4359	!*	ER 100	Examine 8080 Reg 100 - Should show 'MEM PE' not asserted
4360	!*RESPONSE
4361	!*	'MEM PE' asserted       100:  \O0
4362	
4363	!]ERROR 7
4364	!] B7 CB DB  NTWK
4365	!]NO ERROR 7
4366	!]  NTWK
4367	
4368	!*MESSAGE 8
4369	!*STIMULUS
4370	!*	MR	Master Reset
4371	!*	EM 0	Examine mem loc 0 (Turns off ?NXM if it was on)
4372	!*	MR	Master Reset
4373	!*	ER 301	Examine 8080 Reg 301 - Should show 'NXM' not asserted
4374	!*RESPONSE
4375	!*	'NXM' asserted       301:  \O0
4376	
4377	!]ERROR 8
4378	!] A1 D1 E1 F1 K1 N3 J3 K3 A7 B7 L7 A8 AA AB BB CB DB AC BC CC  NTWK
4379	!]NO ERROR 8
4380	!]  NTWK
4381	
4382	END;
4383	GLOBAL ROUTINE TST8: NOVALUE =
4384	
4385	!++   ------------------- 8646 PARITY GEN/CHK --------------------
4386	! TEST DESCRIPTION:  This routine checks out the parity generation
4387	!	and verification logic attached to the KS10 Bus on the MMC
4388	!	board.   The 8646 tranceivers generate the parity in 4 bit
4389	!	chunks and separate parity generators calculate parity for
4390	!	the whole word.   The result of this determines whether or
4391	!	not valid parity was received from the bus. In the case of
4392	!	a read the parity is put on the bus for the device reading
4393	!	the data to verify.
4394	!
4395	! TEST ASSUMPTIONS:  None.
4396	!
4397	! TEST PROCEDURE:  MR
4398	!		   Shut off parity checking by the 8080
4399	!		   Write 0's to mem location 0
4400	!		   Read 8080 I/O Reg 100 to see if CSL board thinks that
4401	!			a parity error occurred
4402	!		   Read Mem Stat Reg to see if MMC board thinks that
4403	!			a parity error occurred
4404	!		   Read mem location 0
4405	!		   Read 8080 I/O Reg 100 and check if a parity
4406	!			error occurred
4407	!
4408	! POSSIBLE ERRORS:  8646 tranceivers are not generating parity correctly
4409	!			or the parity generators on MMC1 are bad
4410	!		    Logic which sets 'MMC7 PARITY ERR' is bad or the
4411	!			inverter which sends the signal to CSL is
4412	!			broken.
4413	!
4414	!--
4415	
4416	BEGIN
4417	
4418	LOCAL
4419		REG_100,			! 8080 Reg 100
4420		CSL_PAR,			! CSL board shows PE
4421		MMC_PAR,			! MMC board shows PE
4422		MEM_STAT,			! Mem Status Register
4423		TEMP;				! Temporary storage
4424	
4425	OWN
4426		MESSV: VECTOR[3];		! Error message output vector
4427	
4428	BIND
4429		REF_ERR = UPLIT(%ASCIZ '?MRE');
4430	
4431	MACRO
4432		PAR_BIT = 32,1%;
4433	
4434	LABEL
4435		BLOCK1,
4436		BLOCK2;
4437	
4438	IF RUN_TEST(8) THEN RETURN;		! Run this test? Return if no
4439	
4440	NOERR_8 = 0;				! No errors have occurred yet
4441	RPT_ERR_FLAG = 0;			! Don't report unexpected error
4442	
4443	PAR_DISABLE;				! Shut off parity checking by 8080
4444	
4445	!
4446	!	1ST HALF - VERIFY PARITY GEN/CHK ON WRITE
4447	!
4448	
4449	DO (0) WHILE
4450	BLOCK1:	BEGIN
4451		MR();				! Master Reset
4452		DM(0,0);			! Write 0's to mem loc 0
4453		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
4454		MESSV = REG_100 = RD_100;	! Read 8080 Reg 100
4455		CSL_PAR = (.REG_100 AND MEM_PE) XOR %O'10';
4456		MESSV[1] = MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
4457		MMC_PAR = .MEM_STAT<PAR_BIT>;
4458	
4459		IF .CSL_PAR NEQ 0 AND .MMC_PAR NEQ 0
4460		    THEN BEGIN			! If both MMC and CSL see PE then
4461			 NOERR_8 = 1;		!   set error flag and print error
4462			 ERRS(1,1,MESSV);	!   message.
4463			 END;
4464		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
4465	
4466		IF .CSL_PAR NEQ 0 AND .MMC_PAR EQL 0
4467		    THEN BEGIN			! If only CSL sees PE then set error
4468			 TEST_ABORT = 1;	!   flags, print error message and
4469			 NOERR_8 = 1;		!   abort future testing
4470			 ERRS(2,2,MESSV);
4471			 END;
4472		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
4473	
4474		IF .CSL_PAR EQL 0 AND .MMC_PAR NEQ 0
4475		    THEN BEGIN			! If only MMC sees PE then set error
4476			 TEST_ABORT = 1;	!   flags, print error message and
4477			 NOERR_8 = 1;		!   abort future testing
4478			 ERRS(3,3,MESSV);
4479			 END;
4480		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
4481		0				! To eliminate INFO compiler message
4482		END;
4483	
4484	!
4485	!	2ND HALF - VERIFY PARITY GEN/CHK ON READ
4486	!
4487	
4488	DO (0) WHILE
4489	BLOCK2:	BEGIN
4490		MR();				! Master Reset
4491		MESSV[2] = EM(0);		! Examine mem loc 0
4492		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
4493		MESSV = REG_100 = RD_100;	! Read 8080 Reg 100
4494		CSL_PAR = ((.REG_100 AND (MEM_PE OR REC_PE)) NEQ (MEM_PE OR REC_PE));
4495		MESSV[1] = MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
4496		MMC_PAR = .MEM_STAT<PAR_BIT>;
4497	
4498		IF .CSL_PAR NEQ 0 AND .MMC_PAR NEQ 0
4499		    THEN BEGIN			! If both MMC and CSL see PE then
4500			 NOERR_8 = 1;		!   set error flag and print error
4501			 ERRS(4,4,MESSV);	!   message.
4502			 END;
4503		IF LOOP_CHK(4) THEN LEAVE BLOCK2 WITH 1;
4504	
4505		IF .CSL_PAR NEQ 0 AND .MMC_PAR EQL 0
4506		    THEN BEGIN			! If only CSL sees PE then set error
4507			 TEST_ABORT = 1;	!   flags, print error message and
4508			 NOERR_8 = 1;		!   abort future testing
4509			 ERRS(5,5,MESSV);
4510			 END;
4511		IF LOOP_CHK(5) THEN LEAVE BLOCK2 WITH 1;
4512	
4513		IF .CSL_PAR EQL 0 AND .MMC_PAR NEQ 0
4514		    THEN BEGIN			! If only MMC sees PE then set error
4515			 TEST_ABORT = 1;	!   flags, print error message and
4516			 NOERR_8 = 1;		!   abort future testing
4517			 ERRS(6,6,MESSV);
4518			 END;
4519		IF LOOP_CHK(6) THEN LEAVE BLOCK2 WITH 1;
4520		0				! To eliminate INFO compiler message
4521		END;
4522	
4523	!*MESSAGE 1
4524	!*STIMULUS
4525	!*	MR,PE 0		Shut off parity error checking by 8080
4526	!*	LA 0,DM 0	Write 0's to memory loc 0 (Parity err should not occur)
4527	!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
4528	!*	EI 100000	Look to see if MSR shows 'PE' also
4529	!*RESPONSE
4530	!*	8080 & M8618 both see 'PARITY ERR' occurred on write
4531	!*	I/O Reg 100: \O0    MSR: \U1
4532	
4533	!]ERROR 1
4534	!] A_N1 E3 F3 B7  NTWK
4535	!]NO ERROR 1
4536	!]  NTWK
4537	
4538	!*MESSAGE 2
4539	!*STIMULUS
4540	!*	MR,PE 0		Shut off parity error checking by 8080
4541	!*	LA 0,DM 0	Write 0's to memory loc 0 (Parity err should not occur)
4542	!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
4543	!*	EI 100000	Look to see if MSR shows 'PE' also
4544	!*RESPONSE
4545	!*	8080 thinks 'PARITY ERR' occurred on write but M8618 doesnt
4546	!*	I/O Reg 100: \O0    MSR: \U1
4547	
4548	!]ERROR 2
4549	!] B7 C7  NTWK
4550	!]NO ERROR 2
4551	!]  NTWK
4552	
4553	!*MESSAGE 3
4554	!*STIMULUS
4555	!*	MR,PE 0		Shut off parity error checking by 8080
4556	!*	LA 0,DM 0	Write 0's to memory loc 0 (Parity err should not occur)
4557	!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
4558	!*	EI 100000	Look to see if MSR shows 'PE' also
4559	!*RESPONSE
4560	!*	M8618 thinks 'PARITY ERR' occurred on write but 8080 doesnt
4561	!*	I/O Reg 100: \O0    MSR: \U1
4562	
4563	!]ERROR 3
4564	!] B7 C7  NTWK
4565	!]NO ERROR 3
4566	!]  NTWK
4567	
4568	!*MESSAGE 4
4569	!*STIMULUS
4570	!*	MR,PE 0		Shut off parity error checking by 8080
4571	!*	LA 0,DM 0	Write 0's to memory loc 0
4572	!*	EM 0		Examine mem loc 0 (Parity err should not occur)
4573	!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
4574	!*	EI 100000	Look to see if MSR shows 'PE' also
4575	!*RESPONSE
4576	!*	8080 & M8618 both see 'PARITY ERR' occurred on read
4577	!*	I/O Reg 100: \O0    MSR: \U1   Mem loc 0: \U2
4578	
4579	!]ERROR 4
4580	!] A_N1 E3 F3 B7  NTWK
4581	!]NO ERROR 4
4582	!]  NTWK
4583	
4584	!*MESSAGE 5
4585	!*STIMULUS
4586	!*	MR,PE 0		Shut off parity error checking by 8080
4587	!*	LA 0,DM 0	Write 0's to memory loc 0
4588	!*	EM 0		Examine mem loc 0 (Parity err should not occur)
4589	!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
4590	!*	EI 100000	Look to see if MSR shows 'PE' also
4591	!*RESPONSE
4592	!*	8080 thinks 'PARITY ERR' occurred on read but M8618 doesnt
4593	!*	I/O Reg 100: \O0    MSR: \U1   Mem loc 0: \U2
4594	
4595	!]ERROR 5
4596	!] B7 C7  NTWK
4597	!]NO ERROR 5
4598	!]  NTWK
4599	
4600	!*MESSAGE 6
4601	!*STIMULUS
4602	!*	MR,PE 0		Shut off parity error checking by 8080
4603	!*	LA 0,DM 0	Write 0's to memory loc 0
4604	!*	EM 0		Examine mem loc 0 (Parity err should not occur)
4605	!*	ER 100		Check to see if 8080 can see 'PE' (Bit 4 of Reg 100)
4606	!*	EI 100000	Look to see if MSR shows 'PE' also
4607	!*RESPONSE
4608	!*	M8618 thinks 'PARITY ERR' occurred on read but 8080 doesnt
4609	!*	I/O Reg 100: \O0    MSR: \U1   Mem loc 0: \U2
4610	
4611	!]ERROR 6
4612	!] B7 C7  NTWK
4613	!]NO ERROR 6
4614	!]  NTWK
4615	
4616	END;
4617	GLOBAL ROUTINE TST9: NOVALUE =
4618	
4619	!++   -------------- BOARD SELECT ADDRESS LOGIC -----------------
4620	! TEST DESCRIPTION:  This routine checks the board select address
4621	!	logic on the  MMC  board.   It  verifies that none of the
4622	!	address lines are stuck at 0/1.
4623	!
4624	! TEST ASSUMPTIONS:  None.
4625	!
4626	! TEST PROCEDURE:  Write RANDOM PATTERN1 to MMA Board 0 Address 0
4627	!				       2 to MMA Board 1 Address 0
4628	!				       3 to MMA Board 2 Address 0
4629	!				       4 to MMA Board 3 Address 0
4630	!				       5 to MMA Board 4 Address 0
4631	!				       6 to MMA Board 5 Address 0
4632	!				       7 to MMA Board 6 Address 0
4633	!				       8 to MMA Board 7 Address 0
4634	!		   In each case check NXM
4635	!		   Read data back from each board and verify it is
4636	!			correct depending on whether or not it is 
4637	!			nonexistent memory.
4638	!
4639	! POSSIBLE ERRORS:  OR gates on MMC8 are faulty
4640	!      (Indirectly) Other address decode logic is faulty
4641	!
4642	!--
4643	
4644	BEGIN
4645	
4646	OWN
4647		MESSV: VECTOR[3],		! Error message output vector
4648		MESS_STR1: VECTOR[8]		! Error message strings
4649		    INITIAL(UPLIT(%ASCIZ '000'),UPLIT(%ASCIZ '001'),
4650			    UPLIT(%ASCIZ '010'),UPLIT(%ASCIZ '011'),
4651			    UPLIT(%ASCIZ '100'),UPLIT(%ASCIZ '101'),
4652			    UPLIT(%ASCIZ '110'),UPLIT(%ASCIZ '111')),
4653		MESS_STR2: VECTOR[2]		! Error message strings
4654		    INITIAL(UPLIT(%ASCIZ ' not '),UPLIT(%ASCIZ ' ')),
4655		PATTERN: VECTOR[8]		! Test data patterns
4656		    INITIAL (%O'765432101234',%O'654321012345',
4657			     %O'543210123456',%O'432101234567',
4658			     %O'321012345676',%O'210123456765',
4659			     %O'101234567654',%O'012345676543');
4660	
4661	LOCAL
4662		CUM_ERR,
4663		ERR_FLAG,
4664		PATT,
4665		DATA_OK,
4666		ERR_NUM,
4667		TEMP,
4668		TEST_DATA,
4669		NONXM;
4670	
4671	BIND
4672		REF_ERR = UPLIT(%ASCIZ '?MRE');
4673	
4674	LABEL
4675		BLOCK1;
4676	
4677	IF RUN_TEST(9) THEN RETURN;		! Run this test? Return if no
4678	
4679	NOERR_9 = 0;				! No errors have occurred yet
4680	RPT_ERR_FLAG = 0;			! Don't report unexpected error
4681	CUM_ERR = 0;
4682	
4683	IO_DEPOSIT(MSR,ECC_OFF);		! Make sure ECC is off on MMC board
4684	CHK_ERR_MSG(REF_ERR);			!   and discard any unexpected errors
4685						!   that may have occurred doing this
4686	DO (0) WHILE
4687	BLOCK1: BEGIN
4688		INCR BOARD FROM 0 TO 7 DO	! Write data to each MMA board
4689		    BEGIN
4690		    MR();			! Master Reset
4691		    NONXM = DM_CHK(.BOARD^16,.PATTERN[.BOARD]);	! See if we would get a
4692		    ERR_NUM = .BOARD*2+1+.MMA_MAP[.BOARD];	!   ?NXM if we wrote
4693		    MESSV[0] = .PATTERN[.BOARD];		! Set up data for error
4694		    MESSV[1] = .MESS_STR1[.BOARD];		!   message in case we
4695		    MESSV[2] = .MESS_STR2[.MMA_MAP[.BOARD]];	!   have an error
4696	
4697		    IF .NONXM EQL .MMA_MAP[.BOARD]	! Did we get ?NXM on existent
4698			THEN BEGIN			!   memory or no ?NXM on non-
4699			     CUM_ERR = 1;		!   existent memory
4700			     ERRS(.ERR_NUM,1,MESSV);
4701			     END;
4702		    IF LOOP_CHK(.ERR_NUM) THEN LEAVE BLOCK1 WITH 1;
4703		    END;
4704	
4705		INCR BOARD FROM 0 TO 7 DO
4706		    BEGIN
4707		    MR();				! Master Reset
4708		    NONXM = EM_CHK(.BOARD ^ 16);	! See if can examine MMA board
4709		    PATT = .PATTERN[.BOARD];
4710		    TEST_DATA = 0;
4711		    IF .NONXM EQL 0
4712			THEN TEST_DATA = MEM_EXAMINE(.BOARD ^ 16);
4713		    DATA_OK = (.TEST_DATA EQL .PATT) AND 1;
4714		    ERR_NUM = 16 + .BOARD * 4;
4715		    ERR_FLAG = 0;
4716		    MESSV[0] = .PATTERN[.BOARD];	! Set up error message
4717		    MESSV[1] = .MESS_STR1[.BOARD];	!   printout
4718	
4719		    IF .MMA_MAP[.BOARD] EQL 0		! Now determine if we have any
4720			THEN BEGIN			!   errors depending on whether
4721			     IF .NONXM NEQ 1		!   or not the memory is out
4722				THEN BEGIN		!   there.
4723				     IF .DATA_OK
4724					THEN ERR_FLAG = 1
4725					ELSE ERR_FLAG = 2;
4726				     END;
4727			     END
4728			ELSE BEGIN
4729			     IF .NONXM NEQ 1
4730				THEN BEGIN
4731				     IF .DATA_OK NEQ 1
4732					THEN ERR_FLAG = 3;
4733				     END
4734				ELSE ERR_FLAG = 4;
4735			     END;
4736	
4737	! Now print out the errors whatever they are.
4738	
4739		    INCR ERR FROM 1 TO 4 DO
4740			BEGIN
4741			IF (.ERR EQL .ERR_FLAG) AND (.ERR_FLAG NEQ 3)
4742			   THEN ERRCAS(.ERR_NUM+.ERR,1+.ERR,.PATT,.TEST_DATA,12,MESSV);
4743			IF LOOP_CHK(.ERR_NUM+.ERR) THEN LEAVE BLOCK1 WITH 1;
4744			END;
4745		    CUM_ERR = .CUM_ERR + .ERR_FLAG;
4746		    IF (.ERR_FLAG NEQ 0) AND (.ERR_FLAG NEQ 3) THEN RETURN;
4747		    END;
4748	
4749		IF .CUM_ERR EQL 0		! No errors?  If not then we can
4750		    THEN NOERR(1);		!   get rid of some networks as
4751		NOERR_9 = .CUM_ERR;		!   not being faulty.
4752		0				! To eliminate INFO compiler message
4753		END;
4754	
4755	!  ERROR 1 - Board 000 - Memory nonexistent - But ?NXM did not occur
4756	!  ERROR 2 - Board 000 - Memory exists - But ?NXM occurred
4757	!  ERROR 3 - Board 001 - Memory nonexistent - But ?NXM did not occur
4758	!  ERROR 4 - Board 001 - Memory exists - But ?NXM occurred
4759	!   ...		...		...
4760	
4761	!*MESSAGE 1
4762	!*STIMULUS:
4763	!*	LA (\S1 Board select + 0 Address) (\S2existent memory)
4764	!*	DM \U0
4765	!*RESPONSE:
4766	!*	NXM\S2set
4767	
4768	!]ERROR 1
4769	!] E1 F1 J3 N3 A8 AA AB  NTWK
4770	!]NO ERROR 1
4771	!] A8  NTWK
4772	
4773	!]ERROR 2
4774	!] E1 F1 J3 N3 A8 AA AB  NTWK
4775	!]NO ERROR 2
4776	!]  NTWK
4777	
4778	!]ERROR 3
4779	!] E1 F1 J3 N3 A8 AA AB  NTWK
4780	!]NO ERROR 3
4781	!]  NTWK
4782	
4783	!]ERROR 4
4784	!] E1 F1 J3 N3 A8 AA AB  NTWK
4785	!]NO ERROR 4
4786	!]  NTWK
4787	
4788	!]ERROR 5
4789	!] E1 F1 J3 N3 A8 AA AB  NTWK
4790	!]NO ERROR 5
4791	!]  NTWK
4792	
4793	!]ERROR 6
4794	!] E1 F1 J3 N3 A8 AA AB  NTWK
4795	!]NO ERROR 6
4796	!]  NTWK
4797	
4798	!]ERROR 7
4799	!] E1 F1 J3 N3 A8 AA AB  NTWK
4800	!]NO ERROR 7
4801	!]  NTWK
4802	
4803	!]ERROR 8
4804	!] E1 F1 J3 N3 A8 AA AB  NTWK
4805	!]NO ERROR 8
4806	!]  NTWK
4807	
4808	!]ERROR 9
4809	!] E1 F1 J3 N3 A8 AA AB  NTWK
4810	!]NO ERROR 9
4811	!]  NTWK
4812	
4813	!]ERROR 10
4814	!] E1 F1 J3 N3 A8 AA AB  NTWK
4815	!]NO ERROR 10
4816	!]  NTWK
4817	
4818	!]ERROR 11
4819	!] E1 F1 J3 N3 A8 AA AB  NTWK
4820	!]NO ERROR 11
4821	!]  NTWK
4822	
4823	!]ERROR 12
4824	!] E1 F1 J3 N3 A8 AA AB  NTWK
4825	!]NO ERROR 12
4826	!]  NTWK
4827	
4828	!]ERROR 13
4829	!] E1 F1 J3 N3 A8 AA AB  NTWK
4830	!]NO ERROR 13
4831	!]  NTWK
4832	
4833	!]ERROR 14
4834	!] E1 F1 J3 N3 A8 AA AB  NTWK
4835	!]NO ERROR 14
4836	!]  NTWK
4837	
4838	!]ERROR 15
4839	!] E1 F1 J3 N3 A8 AA AB  NTWK
4840	!]NO ERROR 15
4841	!]  NTWK
4842	
4843	!]ERROR 16
4844	!] E1 F1 J3 N3 A8 AA AB  NTWK
4845	!]NO ERROR 16
4846	!]  NTWK
4847	
4848	!*MESSAGE 2
4849	!*STIMULUS:
4850	!*	LA (\S1 Board select + 0 Address) (Nonexistent memory)
4851	!*	DM \U0
4852	!*	EM
4853	!*RESPONSE:
4854	!*	NXM not set & data ok
4855	
4856	!*MESSAGE 3
4857	!*STIMULUS:
4858	!*	LA (\S1 Board select + 0 Address) (Nonexistent memory)
4859	!*	DM \U0
4860	!*	EM
4861	!*RESPONSE:
4862	!*	NXM not set & data not ok
4863	
4864	!*MESSAGE 4
4865	!*STIMULUS:
4866	!*	LA (\S1 Board select + 0 Address) (Memory exists)
4867	!*	DM \U0
4868	!*	EM
4869	!*RESPONSE:
4870	!*	NXM not set & data not ok
4871	
4872	!*MESSAGE 5
4873	!*STIMULUS:
4874	!*	LA (\S1 Board select + 0 Address) (Memory exists)
4875	!*	DM \U0
4876	!*	EM
4877	!*RESPONSE:
4878	!*	NXM set
4879	
4880	!  ERROR 17 - Board 000 - Mem non-existent - But ?NXM did not occur - data ok
4881	!  ERROR 18 - Board 000 - Mem non-existent - But ?NXM did not occur - data bad
4882	!  ERROR 19 - Board 000 - Mem exists - But ?NXM did not occur - data bad
4883	!  ERROR 20 - Board 000 - Mem exists - But ?NXM occurred
4884	!   ...		...		...
4885	
4886	!]ERROR 17
4887	!] E1 F1 J3 N3 A8  NTWK
4888	!]NO ERROR 17
4889	!]  NTWK
4890	
4891	!]ERROR 18
4892	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
4893	!]NO ERROR 18
4894	!]  NTWK
4895	
4896	!]ERROR 19
4897	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
4898	!]NO ERROR 19
4899	!]  NTWK
4900	
4901	!]ERROR 20
4902	!] E1 F1 J3 N3 A8 AA AB  NTWK
4903	!]NO ERROR 20
4904	!]  NTWK
4905	
4906	!]ERROR 21
4907	!] E1 F1 J3 N3 A8  NTWK
4908	!]NO ERROR 21
4909	!]  NTWK
4910	
4911	!]ERROR 22
4912	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
4913	!]NO ERROR 22
4914	!]  NTWK
4915	
4916	!]ERROR 23
4917	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
4918	!]NO ERROR 23
4919	!]  NTWK
4920	
4921	!]ERROR 24
4922	!] E1 F1 J3 N3 A8 AA AB  NTWK
4923	!]NO ERROR 24
4924	!]  NTWK
4925	
4926	!]ERROR 25
4927	!] E1 F1 J3 N3 A8  NTWK
4928	!]NO ERROR 25
4929	!]  NTWK
4930	
4931	!]ERROR 26
4932	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
4933	!]NO ERROR 26
4934	!]  NTWK
4935	
4936	!]ERROR 27
4937	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
4938	!]NO ERROR 27
4939	!]  NTWK
4940	
4941	!]ERROR 28
4942	!] E1 F1 J3 N3 A8 AA AB  NTWK
4943	!]NO ERROR 28
4944	!]  NTWK
4945	
4946	!]ERROR 29
4947	!] E1 F1 J3 N3 A8  NTWK
4948	!]NO ERROR 29
4949	!]  NTWK
4950	
4951	!]ERROR 30
4952	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
4953	!]NO ERROR 30
4954	!]  NTWK
4955	
4956	!]ERROR 31
4957	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
4958	!]NO ERROR 31
4959	!]  NTWK
4960	
4961	!]ERROR 32
4962	!] E1 F1 J3 N3 A8 AA AB  NTWK
4963	!]NO ERROR 32
4964	!]  NTWK
4965	
4966	!]ERROR 33
4967	!] E1 F1 J3 N3 A8  NTWK
4968	!]NO ERROR 33
4969	!]  NTWK
4970	
4971	!]ERROR 34
4972	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
4973	!]NO ERROR 34
4974	!]  NTWK
4975	
4976	!]ERROR 35
4977	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
4978	!]NO ERROR 35
4979	!]  NTWK
4980	
4981	!]ERROR 36
4982	!] E1 F1 J3 N3 A8 AA AB  NTWK
4983	!]NO ERROR 36
4984	!]  NTWK
4985	
4986	!]ERROR 37
4987	!] E1 F1 J3 N3 A8  NTWK
4988	!]NO ERROR 37
4989	!]  NTWK
4990	
4991	!]ERROR 38
4992	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
4993	!]NO ERROR 38
4994	!]  NTWK
4995	
4996	!]ERROR 39
4997	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
4998	!]NO ERROR 39
4999	!]  NTWK
5000	
5001	!]ERROR 40
5002	!] E1 F1 J3 N3 A8 AA AB  NTWK
5003	!]NO ERROR 40
5004	!]  NTWK
5005	
5006	!]ERROR 41
5007	!] E1 F1 J3 N3 A8  NTWK
5008	!]NO ERROR 41
5009	!]  NTWK
5010	
5011	!]ERROR 42
5012	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
5013	!]NO ERROR 42
5014	!]  NTWK
5015	
5016	!]ERROR 43
5017	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
5018	!]NO ERROR 43
5019	!]  NTWK
5020	
5021	!]ERROR 44
5022	!] E1 F1 J3 N3 A8 AA AB  NTWK
5023	!]NO ERROR 44
5024	!]  NTWK
5025	
5026	!]ERROR 45
5027	!] E1 F1 J3 N3 A8  NTWK
5028	!]NO ERROR 45
5029	!]  NTWK
5030	
5031	!]ERROR 46
5032	!] A_J1 E1 F1 J3 N3 A8 AA AB  NTWK
5033	!]NO ERROR 46
5034	!]  NTWK
5035	
5036	!]ERROR 47
5037	!] A_J1 A_M2 A_D3 JLMN3 A_HKLM4 D5 A_H6 C_K7 B_H8 AA AB BB  NTWK
5038	!]NO ERROR 47
5039	!]  NTWK
5040	
5041	!]ERROR 48
5042	!] E1 F1 J3 N3 A8 AA AB  NTWK
5043	!]NO ERROR 48
5044	!]  NTWK
5045	
5046	END;
5047	GLOBAL ROUTINE TST10: NOVALUE =
5048	
5049	!++   --------------- WORD GROUP ADDRESS LOGIC ----------------
5050	! TEST DESCRIPTION:  This routine checks the word group address
5051	!	logic on the  MMC  board.  It verifies that none of the
5052	!	address lines 20-21 are stuck at 0/1.
5053	!
5054	! TEST ASSUMPTIONS:  None.
5055	!
5056	! TEST PROCEDURE:  Write PATTERN1 to Word group 00 Address 0
5057	!				2 to Word group 01 Address 0
5058	!		   Read data back from word group 00 and verify it
5059	!
5060	!		   Repeat for word groups 00/10 and 00/11
5061	!
5062	! POSSIBLE ERRORS:  OR, AND Gates on MMC8 faulty
5063	!      (Indirectly) Other address decode logic is faulty
5064	!
5065	!--
5066	
5067	BEGIN
5068	
5069	LITERAL
5070		BIT_20 = %O'100000',		! Address for word group 2
5071		BIT_21 = %O'40000',		! Address for word group 1
5072		FORCE_CLR = %O'700000000000',	! MSR clear 'ERR HOLD'...
5073		DATA1 = %O'111111111111',	! Data pattern to loc 0
5074		DATA2 = %O'222222222222';	! Data pattern to loc word group n
5075	
5076	BIND
5077		REF_ERR = UPLIT(%ASCIZ '?MRE');
5078	
5079	LOCAL
5080		TEMP;
5081	
5082	OWN
5083		MESSV,				! Error message output data
5084		MESS_STR: VECTOR[3]		! Strings for error message
5085		    INITIAL(UPLIT(%ASCIZ '01'),UPLIT(%ASCIZ '10'),UPLIT(%ASCIZ '11'));
5086	
5087	LABEL
5088		BLOCK1;
5089	
5090	IF RUN_TEST(10) THEN RETURN;		! Run this test? Return if no
5091	
5092	NOERR_10 = 0;				! No errors have occurred yet
5093	RPT_ERR_FLAG = 0;			! Don't report unexpected error
5094	
5095	DO (0) WHILE
5096	BLOCK1:	BEGIN
5097		MR();				! Master Reset
5098		IO_DEPOSIT(MSR,ECC_OFF);	! Shut off ECC
5099		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
5100		MEM_DEPOSIT(0,DATA1);		! Write to loc 0
5101		MEM_DEPOSIT(BIT_21,DATA2);	! Write to loc word group 1
5102		TEMP = EM(0);			! Read loc 0
5103	
5104		IF .TEMP EQL DATA2		! Did 'Write loc word group' overwrite
5105		    THEN BEGIN			!   contents of location 0?
5106			 TEST_ABORT = 1;	! If so set error flags, print error
5107			 MESSV = .MESS_STR[0];	!   message and abort future testing
5108			 NOERR_10 = 1;
5109			 ERRCAS(1,1,DATA1,.TEMP,12,MESSV);
5110			 END;
5111		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
5112	
5113		MR();				! Master Reset
5114		MEM_DEPOSIT(0,DATA1);		! Write to loc 0
5115		MEM_DEPOSIT(BIT_20,DATA2);	! Write to loc word group 2
5116		TEMP = EM(0);			! Read loc 0
5117	
5118		IF .TEMP EQL DATA2		! Did 'Write loc word group' overwrite
5119		    THEN BEGIN			!   contents of location 0?
5120			 TEST_ABORT = 1;	! If so set error flags, print error
5121			 MESSV = .MESS_STR[1];	!   message and abort future testing
5122			 NOERR_10 = 1;
5123			 ERRCAS(2,1,DATA1,.TEMP,12,MESSV);
5124			 END;
5125		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
5126	
5127		MR();				! Master Reset
5128		MEM_DEPOSIT(0,DATA1);		! Write to loc 0
5129		MEM_DEPOSIT(BIT_20+BIT_21,DATA2);! Write to loc word group 3
5130		TEMP = EM(0);			! Read loc 0
5131	
5132		IF .TEMP EQL DATA2		! Did 'Write loc word group' overwrite
5133		    THEN BEGIN			!   contents of location 0?
5134			 TEST_ABORT = 1;	! If so set error flags, print error
5135			 MESSV = .MESS_STR[2];	!   message and abort future testing
5136			 NOERR_10 = 1;
5137			 ERRCAS(3,1,DATA1,.TEMP,12,MESSV);
5138			 END;
5139		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
5140		IO_DEPOSIT(MSR,FORCE_CLR);	! Clear any errors caused by this test
5141		0				! To eliminate INFO compiler message
5142		END;
5143	
5144	!*MESSAGE 1
5145	!*STIMULUS:
5146	!*	LA (00 Word group + 0 Address)
5147	!*	DM 111111111111
5148	!*	LA (\S0 Word group + 0 Address)
5149	!*	DM 222222222222
5150	!*	EM 00 (Bits 20,21) 00000 (Bits 22..35)
5151	!*RESPONSE:
5152	!*	DM 22.. Overwrote 11.. (Addr bit 20/21 stuck at 0/1)
5153	
5154	!]ERROR 1
5155	!] J3  NTWK
5156	!]NO ERROR 1
5157	!]  NTWK
5158	
5159	!]ERROR 2
5160	!] J3  NTWK
5161	!]NO ERROR 2
5162	!]  NTWK
5163	
5164	!]ERROR 3
5165	!] J3  NTWK
5166	!]NO ERROR 3
5167	!]  NTWK
5168	
5169	END;
5170	GLOBAL ROUTINE TST11: NOVALUE =
5171	
5172	!++   ------------------- ROW/COL ADDRESS LOGIC ---------------------
5173	! TEST DESCRIPTION:  This routine checks the row/column address logic
5174	!	on the MMC board.  It verifies that none of the address lines
5175	!	22-35 are stuck at 0/1.  This tests the outputs of the mixers
5176	!	on MMC3 so the row address is equal to the column address for
5177	!	each test.
5178	!
5179	! TEST ASSUMPTIONS:  None.
5180	!
5181	! TEST PROCEDURE:  Write PATTERN1 to Row 00000000 Col 00000000
5182	!				2 to Row 00000001 Col 00000001
5183	!		   Read data back and verify it
5184	!
5185	!		   Repeat for row/cols 00000010 00000010
5186	!				       00000100 00000100
5187	!				       00001000 00001000
5188	!				       00010000 00010000
5189	!				       00100000 00100000
5190	!				       01000000 01000000
5191	!				       10000000 10000000
5192	!
5193	! POSSIBLE ERRORS:  Faulty 2x4 mixers on MMC3
5194	!
5195	!--
5196	
5197	BEGIN
5198	
5199	BIND
5200		REF_ERR = UPLIT(%ASCIZ '?MRE');
5201	
5202	LOCAL
5203		NUM_ERR,
5204		TEMP;
5205	
5206	LITERAL
5207		ONES = %O'77777777777777',	! Ones
5208		ADDR = %B'0000000100000001';	! Row 1 Column 1
5209	
5210	OWN
5211		DATA: BTTVECTOR[36];		! Bitvector of data read from mem loc 0
5212	
5213	LABEL
5214		BLOCK1;
5215	
5216	IF RUN_TEST(11) THEN RETURN;		! Run this test? Return if no
5217	
5218	NOERR_11 = 0;				! No errors have occurred yet
5219	RPT_ERR_FLAG = 0;			! Don't report unexpected error
5220	MR();					! Master Reset
5221	
5222	IO_DEPOSIT(MSR,ECC_OFF);		! Shut off ECC
5223	CHK_ERR_MSG(REF_ERR);			! Discard any unexpected errors
5224	
5225	INCR ROWCOL FROM 1 TO 7 DO		! For each row/col address:
5226		BEGIN
5227		DO (0) WHILE
5228	BLOCK1:	    BEGIN
5229		    DM(0,0);			! Write 0's to mem loc 0
5230		    TEMP = ADDR^(.ROWCOL-1);	! Calculate row/col address
5231		    MEM_DEPOSIT(.TEMP,ONES);	! Write 1's to mem loc row/col
5232		    TEMP = EM(0);		! Read mem loc 0
5233	
5234		    NUM_ERR = 0;		! Count up the total number of bits
5235		    INCR BTT FROM 0 TO 35 DO	!   in error (if any). (There must be
5236			BEGIN			!   many incorrect bits to be certain
5237			IF .DATA[.BTT] EQL 1	!   of an addressing error.)
5238			    THEN NUM_ERR = .NUM_ERR + 1;
5239			END;
5240	
5241		    IF .NUM_ERR GEQ 29		! Over 29 bits in error?
5242			THEN BEGIN		! If so set error flags, print error
5243			     TEST_ABORT = 1;	!   message and abort future testing
5244			     NOERR_11 = 1;
5245			     ERRCA(.ROWCOL,0,.TEMP,12);
5246			     END;
5247		    IF LOOP_CHK(.ROWCOL) THEN LEAVE BLOCK1 WITH 1;
5248		    0				! To eliminate INFO compiler message
5249		    END;
5250		END;
5251	
5252	!*MESSAGE 1
5253	!*STIMULUS:
5254	!*	LA (Row col bits) 0000000 0000000
5255	!*	DM 000000000000
5256	!*	LA (Row col bits) 0000001 0000001
5257	!*	DM 777777777777
5258	!*	EM 0
5259	!*RESPONSE:
5260	!*	DM 777.. Overwrote DM 000..
5261	!*	'MMC3 ROW 28 COL 35' stuck at 0/1
5262	
5263	!]ERROR 1
5264	!] D3 NTWK
5265	!]NO ERROR 1
5266	!]  NTWK
5267	
5268	!*MESSAGE 2
5269	!*STIMULUS:
5270	!*	LA (Row col bits) 0000000 0000000
5271	!*	DM 000000000000
5272	!*	LA (Row col bits) 0000010 0000010
5273	!*	DM 777777777777
5274	!*	EM 0
5275	!*RESPONSE:
5276	!*	DM 777.. Overwrote DM 000..
5277	!*	'MMC3 ROW 27 COL 34' Stuck at 0/1
5278	
5279	!]ERROR 2
5280	!] D3 NTWK
5281	!]NO ERROR 2
5282	!]  NTWK
5283	
5284	!*MESSAGE 3
5285	!*STIMULUS:
5286	!*	LA (Row col bits) 0000000 0000000
5287	!*	DM 000000000000
5288	!*	LA (Row col bits) 0000100 0000100
5289	!*	DM 777777777777
5290	!*	EM 0
5291	!*RESPONSE:
5292	!*	DM 777.. Overwrote DM 000..
5293	!*	'MMC3 ROW 26 COL 33' Stuck at 0/1
5294	
5295	!]ERROR 3
5296	!] C3 NTWK
5297	!]NO ERROR 3
5298	!]  NTWK
5299	
5300	!*MESSAGE 4
5301	!*STIMULUS:
5302	!*	LA (Row col bits) 0000000 0000000
5303	!*	DM 000000000000
5304	!*	LA (Row col bits) 0001000 0001000
5305	!*	DM 777777777777
5306	!*	EM 0
5307	!*RESPONSE:
5308	!*	DM 777.. Overwrote DM 000..
5309	!*	'MMC3 ROW 25 COL 32' Stuck at 0/1
5310	
5311	!]ERROR 4
5312	!] C3 NTWK
5313	!]NO ERROR 4
5314	!]  NTWK
5315	
5316	!*MESSAGE 5
5317	!*STIMULUS:
5318	!*	LA (Row col bits) 0000000 0000000
5319	!*	DM 000000000000
5320	!*	LA (Row col bits) 0010000 0010000
5321	!*	DM 777777777777
5322	!*	EM 0
5323	!*RESPONSE:
5324	!*	DM 777.. Overwrote DM 000..
5325	!*	'MMC3 ROW 24 COL 31' Stuck at 0/1
5326	
5327	!]ERROR 5
5328	!] B3 NTWK
5329	!]NO ERROR 5
5330	!]  NTWK
5331	
5332	!*MESSAGE 6
5333	!*STIMULUS:
5334	!*	LA (Row col bits) 0000000 0000000
5335	!*	DM 000000000000
5336	!*	LA (Row col bits) 0100000 0100000
5337	!*	DM 777777777777
5338	!*	EM 0
5339	!*RESPONSE:
5340	!*	DM 777.. Overwrote DM 000..
5341	!*	'MMC3 ROW 23 COL 30' Stuck at 0/1
5342	
5343	!]ERROR 6
5344	!] B3 NTWK
5345	!]NO ERROR 6
5346	!]  NTWK
5347	
5348	!*MESSAGE 7
5349	!*STIMULUS:
5350	!*	LA (Row col bits) 0000000 0000000
5351	!*	DM 000000000000
5352	!*	LA (Row col bits) 1000000 1000000
5353	!*	DM 777777777777
5354	!*	EM 0
5355	!*RESPONSE:
5356	!*	DM 777.. Overwrote DM 000..
5357	!*	'MMC3 ROW 22 COL 29' Stuck at 0/1
5358	
5359	!]ERROR 7
5360	!] A3 NTWK
5361	!]NO ERROR 7
5362	!]  NTWK
5363	
5364	END;
5365	GLOBAL ROUTINE TST12: NOVALUE =
5366	
5367	!++   ------------------ ROW/COL ADDRESS LOGIC ----------------------
5368	! TEST DESCRIPTION:  This routine checks the row/column address logic
5369	!	on the MMC board.  It verifies that none of the address lines
5370	!	22-35 are stuck at 0/1.  This tests the  select  lines on the
5371	!	mixers on MMC3 so the row address  will  be  zero  while  the
5372	!	column address varies and vice versa.
5373	!
5374	! TEST ASSUMPTIONS:  None.
5375	!
5376	! TEST PROCEDURE:  Write 0's to row 0 col 0
5377	!		   write 1's to row N1 col N2
5378	!		   Read data back and verify it
5379	!
5380	!		   Do for row/cols 0000000 0000001
5381	!				   0000000 0000010
5382	!				   0000000 0000100
5383	!				   0000000 0001000
5384	!				   0000000 0010000
5385	!				   0000000 0100000
5386	!				   0000000 1000000
5387	!
5388	!				   0000001 0000000
5389	!				   0000010 0000000
5390	!				   0000100 0000000
5391	!				   0001000 0000000
5392	!				   0010000 0000000
5393	!				   0100000 0000000
5394	!				   1000000 0000000
5395	!
5396	! POSSIBLE ERRORS:  Faulty 2x4 mixers on MMC3
5397	!
5398	!--
5399	
5400	BEGIN
5401	
5402	BIND
5403		REF_ERR = UPLIT(%ASCIZ '?MRE');
5404	
5405	LOCAL
5406		NUM_ERR,
5407		TEMP;
5408	
5409	LITERAL
5410		ONES = %O'777777777777',	! Ones
5411		ADDR = 1;			! Address to write to (gets shifted
5412						!   over for each new row/col address)
5413	OWN
5414		DATA: BTTVECTOR[36];		! Bitvector of data read from mem loc 0
5415	
5416	LABEL
5417		BLOCK1;
5418	
5419	IF RUN_TEST(12) THEN RETURN;		! Run this test? Return if no
5420	
5421	NOERR_12 = 0;				! No errors have occurred yet
5422	RPT_ERR_FLAG = 0;			! Don't report unexpected error
5423	MR();					! Master Reset
5424	
5425	IO_DEPOSIT(MSR,ECC_OFF);		! Shut off ECC
5426	CHK_ERR_MSG(REF_ERR);			! Discard any unexpected errors
5427	
5428	INCR ROWCOL FROM 1 TO 14 DO		! For each address:
5429		BEGIN
5430		DO (0) WHILE
5431	BLOCK1:	    BEGIN
5432		    DM(0,0);			! Write 0's to mem loc 0
5433		    TEMP = ADDR^(.ROWCOL-1);	! Calculate row/col address
5434		    MEM_DEPOSIT(.TEMP,ONES);	! Write 1's to mem loc row/col
5435		    TEMP = EM(0);		! Read mem loc 0 (see if got overwrote)
5436	
5437		    NUM_ERR = 0;		! Count up the total number of bits
5438		    INCR BTT FROM 0 TO 35 DO	!   in error (if any). (There must be
5439			BEGIN			!   many incorrect bits to be certain
5440			IF .DATA[.BTT] EQL 1	!   of an addressing error.)
5441			    THEN NUM_ERR = .NUM_ERR + 1;
5442			END;
5443	
5444		    IF .NUM_ERR GEQ 29		! Over 29 bits in error?
5445			THEN BEGIN		! If so set error flags, print error
5446			     TEST_ABORT = 1;	!   message and abort future testing
5447			     NOERR_12 = 1;
5448			     ERRCA(.ROWCOL,0,.TEMP,12);
5449			     END;
5450		    IF LOOP_CHK(.ROWCOL) THEN LEAVE BLOCK1 WITH 1;
5451		    0				! To eliminate INFO compiler message
5452		    END;
5453		END;
5454	
5455	!*MESSAGE 1
5456	!*STIMULUS:
5457	!*	LA (Row col bits) 0000000 0000000
5458	!*	DM 000000000000
5459	!*	LA (Row col bits) 0000000 0000001
5460	!*	DM 777777777777
5461	!*	EM 0
5462	!*RESPONSE:
5463	!*	DM 777.. Overwrote DM 000..
5464	!*	'MMC3 ROW 28 COL 35' Stuck at 0/1
5465	
5466	!]ERROR 1
5467	!] H1 J1 D3 L3 M3 NTWK
5468	!]NO ERROR 1
5469	!]  NTWK
5470	
5471	!*MESSAGE 2
5472	!*STIMULUS:
5473	!*	LA (Row col bits) 0000000 0000000
5474	!*	DM 000000000000
5475	!*	LA (Row col bits) 0000000 0000010
5476	!*	DM 777777777777
5477	!*	EM 0
5478	!*RESPONSE:
5479	!*	DM 777.. Overwrote DM 000..
5480	!*	'MMC3 ROW 27 COL 34' Stuck at 0/1
5481	
5482	!]ERROR 2
5483	!] H1 J1 D3 L3 M3 NTWK
5484	!]NO ERROR 2
5485	!]  NTWK
5486	
5487	!*MESSAGE 3
5488	!*STIMULUS:
5489	!*	LA (Row col bits) 0000000 0000000
5490	!*	DM 000000000000
5491	!*	LA (Row col bits) 0000000 0000100
5492	!*	DM 777777777777
5493	!*	EM 0
5494	!*RESPONSE:
5495	!*	DM 777.. Overwrote DM 000..
5496	!*	'MMC3 ROW 26 COL 33' Stuck at 0/1
5497	
5498	!]ERROR 3
5499	!] H1 I1 C3 L3 M3 NTWK
5500	!]NO ERROR 3
5501	!]  NTWK
5502	
5503	!*MESSAGE 4
5504	!*STIMULUS:
5505	!*	LA (Row col bits) 0000000 0000000
5506	!*	DM 000000000000
5507	!*	LA (Row col bits) 0000000 0001000
5508	!*	DM 777777777777
5509	!*	EM 0
5510	!*RESPONSE:
5511	!*	DM 777.. Overwrote DM 000..
5512	!*	'MMC3 ROW 25 COL 32' Stuck at 0/1
5513	
5514	!]ERROR 4
5515	!] G1 I1 C3 L3 M3 NTWK
5516	!]NO ERROR 4
5517	!]  NTWK
5518	
5519	!*MESSAGE 5
5520	!*STIMULUS:
5521	!*	LA (Row col bits) 0000000 0000000
5522	!*	DM 000000000000
5523	!*	LA (Row col bits) 0000000 0010000
5524	!*	DM 777777777777
5525	!*	EM 0
5526	!*RESPONSE:
5527	!*	DM 777.. Overwrote DM 000..
5528	!*	'MMC3 ROW 24 COL 31' Stuck at 0/1
5529	
5530	!]ERROR 5
5531	!] G1 I1 B3 L3 M3 NTWK
5532	!]NO ERROR 5
5533	!]  NTWK
5534	
5535	!*MESSAGE 6
5536	!*STIMULUS:
5537	!*	LA (Row col bits) 0000000 0000000
5538	!*	DM 000000000000
5539	!*	LA (Row col bits) 0000000 0100000
5540	!*	DM 777777777777
5541	!*	EM 0
5542	!*RESPONSE:
5543	!*	DM 777.. Overwrote DM 000..
5544	!*	'MMC3 ROW 23 COL 30' Stuck at 0/1
5545	
5546	!]ERROR 6
5547	!] G1 I1 B3 L3 M3 NTWK
5548	!]NO ERROR 6
5549	!]  NTWK
5550	
5551	!*MESSAGE 7
5552	!*STIMULUS:
5553	!*	LA (Row col bits) 0000000 0000000
5554	!*	DM 000000000000
5555	!*	LA (Row col bits) 0000000 1000000
5556	!*	DM 777777777777
5557	!*	EM 0
5558	!*RESPONSE:
5559	!*	DM 777.. Overwrote DM 000..
5560	!*	'MMC3 ROW 22 COL 29' Stuck at 0/1
5561	
5562	!]ERROR 7
5563	!] G1 H1 A3 L3 M3 NTWK
5564	!]NO ERROR 7
5565	!]  NTWK
5566	
5567	!*MESSAGE 8
5568	!*STIMULUS:
5569	!*	LA (Row col bits) 0000000 0000000
5570	!*	DM 000000000000
5571	!*	LA (Row col bits) 0000001 0000000
5572	!*	DM 777777777777
5573	!*	EM 0
5574	!*RESPONSE:
5575	!*	DM 777.. Overwrote DM 000..
5576	!*	'MMC3 ROW 28 COL 35' Stuck at 0/1
5577	
5578	!]ERROR 8
5579	!] H1 J1 D3 L3 M3 NTWK
5580	!]NO ERROR 8
5581	!]  NTWK
5582	
5583	!*MESSAGE 9
5584	!*STIMULUS:
5585	!*	LA (Row col bits) 0000000 0000000
5586	!*	DM 000000000000
5587	!*	LA (Row col bits) 0000010 0000000
5588	!*	DM 777777777777
5589	!*	EM 0
5590	!*RESPONSE:
5591	!*	DM 777.. Overwrote DM 000..
5592	!*	'MMC3 ROW 27 COL 34' Stuck at 0/1
5593	
5594	!]ERROR 9
5595	!] H1 J1 D3 L3 M3 NTWK
5596	!]NO ERROR 9
5597	!]  NTWK
5598	
5599	!*MESSAGE 10
5600	!*STIMULUS:
5601	!*	LA (Row col bits) 0000000 0000000
5602	!*	DM 000000000000
5603	!*	LA (Row col bits) 0000100 0000000
5604	!*	DM 777777777777
5605	!*	EM 0
5606	!*RESPONSE:
5607	!*	DM 777.. Overwrote DM 000..
5608	!*	'MMC3 ROW 26 COL 33' Stuck at 0/1
5609	
5610	!]ERROR 10
5611	!] H1 I1 C3 L3 M3 NTWK
5612	!]NO ERROR 10
5613	!]  NTWK
5614	
5615	!*MESSAGE 11
5616	!*STIMULUS:
5617	!*	LA (Row col bits) 0000000 0000000
5618	!*	DM 000000000000
5619	!*	LA (Row col bits) 0001000 0000000
5620	!*	DM 777777777777
5621	!*	EM 0
5622	!*RESPONSE:
5623	!*	DM 777.. Overwrote DM 000..
5624	!*	'MMC3 ROW 25 COL 32' Stuck at 0/1
5625	
5626	!]ERROR 11
5627	!] G1 I1 C3 L3 M3 NTWK
5628	!]NO ERROR 11
5629	!]  NTWK
5630	
5631	!*MESSAGE 12
5632	!*STIMULUS:
5633	!*	LA (Row col bits) 0000000 0000000
5634	!*	DM 000000000000
5635	!*	LA (Row col bits) 0010000 0000000
5636	!*	DM 777777777777
5637	!*	EM 0
5638	!*RESPONSE:
5639	!*	DM 777.. Overwrote DM 000..
5640	!*	'MMC3 ROW 24 COL 31' Stuck at 0/1
5641	
5642	!]ERROR 12
5643	!] G1 I1 B3 L3 M3 NTWK
5644	!]NO ERROR 12
5645	!]  NTWK
5646	
5647	!*MESSAGE 13
5648	!*STIMULUS:
5649	!*	LA (Row col bits) 0000000 0000000
5650	!*	DM 000000000000
5651	!*	LA (Row col bits) 0100000 0000000
5652	!*	DM 777777777777
5653	!*	EM 0
5654	!*RESPONSE:
5655	!*	DM 777.. Overwrote DM 000..
5656	!*	'MMC3 ROW 23 COL 30' Stuck at 0/1
5657	
5658	!]ERROR 13
5659	!] G1 I1 B3 L3 M3 NTWK
5660	!]NO ERROR 13
5661	!]  NTWK
5662	
5663	!*MESSAGE 14
5664	!*STIMULUS:
5665	!*	LA (Row col bits) 0000000 0000000
5666	!*	DM 000000000000
5667	!*	LA (Row col bits) 1000000 0000000
5668	!*	DM 777777777777
5669	!*	EM 0
5670	!*RESPONSE:
5671	!*	DM 777.. Overwrote DM 000..
5672	!*	'MMC3 ROW 22 COL 29' Stuck at 0/1
5673	
5674	!]ERROR 14
5675	!] G1 H1 A3 L3 M3 NTWK
5676	!]NO ERROR 14
5677	!]  NTWK
5678	
5679	END;
5680	GLOBAL ROUTINE TST13: NOVALUE =
5681	
5682	!++   ----------------- ROW/COL ADDRESS LOGIC -------------------
5683	! TEST DESCRIPTION:  This  routine  tests  the row/column address
5684	!	select  logic on the MMC board.  It verifies that none of
5685	!	the select inputs to the row/col/refresh select chips are
5686	!	stuck 0/1 thereby causing a memory access to always go to
5687	!	the row address, column address, or refresh address.
5688	!
5689	! TEST ASSUMPTIONS:  None.
5690	!
5691	! TEST PROCEDURE:  Write PATTERN1 to Row N1 Col N2
5692	!				2 to Row N2 Col N1
5693	!				3 to Row N1 Col N1
5694	!				4 to Row N2 Col N2
5695	!		   Read data back and verify it for each address
5696	!
5697	!		   Do for row/cols 0000000 0000001
5698	!				   0000000 0000010
5699	!				   0000000 0000100
5700	!				   0000000 0001000
5701	!				   0000000 0010000
5702	!				   0000000 0100000
5703	!				   0000000 1000000
5704	!
5705	! POSSIBLE ERRORS:  Faulty chips in address logic on MMC3.  This test
5706	!	verifies the 2x4 mixers that decode the row/col addresses.
5707	!
5708	!--
5709	
5710	BEGIN
5711	
5712	LITERAL
5713		MIX_1 = %O'004020100400',
5714		MIX_2 = %O'030140603000',
5715		MIX_3 = %O'140603014000',
5716		MIX_4 = %O'603014060300';
5717	
5718	LOCAL
5719		NUM_ERR,		! Number of bits in error in a word
5720					!   (must be >= 5 to be significant)
5721		ERR_OCC,		! Flag to indicate an error occurred
5722		ADDR1,			! Address 1
5723		ADDR2,			! Address 2
5724		ADDR3,			! Address 3
5725		ADDR4,			! Address 4
5726		TEMP1,			! Temporary variable
5727		ERR_FLAG;		! Error flag
5728	
5729	STRUCTURE
5730		BITBLOCK[I,J;M,N]=[1]		! Structure for keeping track of what
5731		    (BITBLOCK)<35-I-J*7,1>;	!   errors have / have not occurred
5732	
5733	OWN
5734		DATA_BIT: BTTVECTOR[36],	! Data read from memory
5735		PATT_BIT: BTTVECTOR[36],	! Data written to memory
5736		ROW_VECT: BITBLOCK[7,4],	! Fault is always writing to row addr
5737		COL_VECT: BITBLOCK[7,4],	! Fault is always writing to col addr
5738		STR_VECT: BITBLOCK[7,4],	! Garbage writes
5739		SSTR_VECT: BITBLOCK[7,4],	! Garbage writes
5740		PATT: VECTOR[4]			! Data patterns to use
5741		      INITIAL (0,-1,%O'252525252525',%O'525252525252'),
5742		TEMP: VECTOR[4];		! Will contain the data read back
5743	
5744	BIND
5745		REF_ERR = UPLIT(%ASCIZ '?MRE'),
5746		VROW = ROW_VECT,		! 1 word == ROW_VECT bit structure
5747		VCOL = COL_VECT,		! 1 word == COL_VECT bit structure
5748		VSTR = STR_VECT,		! 1 word == STR_VECT bit structure
5749		VSSTR = SSTR_VECT;		! 1 word == SSTR_VECT bit structure
5750	LABEL
5751		BLOCK1;
5752	
5753	IF RUN_TEST(13) THEN RETURN;		! Run this test? Return if no
5754	
5755	NOERR_13 = 0;				! No errors have occurred yet
5756	RPT_ERR_FLAG = 0;			! Don't report unexpected error
5757	
5758	DO (0) WHILE
5759	BLOCK1:	BEGIN
5760		MR();				! Master Reset
5761		IO_DEPOSIT(MSR,ECC_OFF);	! Shut off ECC
5762		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
5763		VROW = VCOL = VSTR = VSSTR = 0;
5764	
5765		INCR ROWCOL FROM 0 TO 6 DO	! For each row/col:
5766		    BEGIN
5767		    ADDR1 = 1^.ROWCOL;		! Calculate address 1: row 00 col N2
5768		    ADDR2 = .ADDR1^7;		! Calculate address 2: row N2 col 00
5769		    ADDR3 = 0;			! Calculate address 3: row 00 col 00
5770		    ADDR4 = .ADDR1 + .ADDR2;	! Calculate address 4: row N2 col N2
5771	
5772		    MEM_DEPOSIT(.ADDR1,.PATT[0]); ! Write data pattern 1 to mem loc 1
5773		    MEM_DEPOSIT(.ADDR2,.PATT[1]); ! Write data pattern 2 to mem loc 2
5774		    MEM_DEPOSIT(.ADDR3,.PATT[2]); ! Write data pattern 3 to mem loc 3
5775		    MEM_DEPOSIT(.ADDR4,.PATT[3]); ! Write data pattern 4 to mem loc 4
5776	
5777		    TEMP[0]=MEM_EXAMINE(.ADDR1);  ! Read back mem loc 1
5778		    TEMP[1]=MEM_EXAMINE(.ADDR2);  ! Read back mem loc 2
5779		    TEMP[2]=MEM_EXAMINE(.ADDR3);  ! Read back mem loc 3
5780		    TEMP[3]=MEM_EXAMINE(.ADDR4);  ! Read back mem loc 4
5781	
5782	! If there is a fault in the address logic we might see one address get
5783	!    clobbered by a write to another address.  So the first thing to do
5784	!    after writing and reading the data is to check for matches.
5785	
5786		    INCR TEST FROM 0 TO 3 DO	! Test each location for a match with
5787			BEGIN			!   another.
5788			TEMP1 = -1;		! TEMP1 remains -1 if no matches at all
5789			INCR MATCH TO 3 DO	! Check for match with each address
5790			    BEGIN		!   written to.  It is a match if there
5791			    NUM_ERR = 0;	!   are more than 29 bits correct.
5792			    DATA_BIT = .TEMP[.TEST];
5793			    PATT_BIT = .PATT[.MATCH];
5794			    INCR BTT FROM 0 TO 35 DO
5795				IF .PATT_BIT[.BTT] NEQ .DATA_BIT[.BTT]
5796				    THEN NUM_ERR = .NUM_ERR + 1;
5797			    IF .NUM_ERR LSS 5		! Since < 5 errors TEMP1 gets
5798				THEN TEMP1 = .MATCH;	!  this address matched
5799			    END;
5800	
5801	! If no matches then SSTR_VECT gets the flag.
5802	
5803			IF .TEMP1 EQL -1
5804			    THEN SSTR_VECT[.ROWCOL,.TEST] = 1;
5805	
5806	! If there was a match and it wasn't the correct match (data got overwritten)
5807	!   then  flag  either  STR_VECT, ROW_VECT, or COL_VECT depending on what the
5808	!   match was.
5809	
5810			IF .TEMP1 NEQ .TEST AND .TEMP1 NEQ -1
5811			    THEN BEGIN
5812				 IF .TEMP1 LSS .TEST OR .TEST GEQ 2
5813				    THEN STR_VECT[.ROWCOL,.TEST] = 1
5814				    ELSE IF .TEMP1-.TEST EQL 2
5815					 THEN COL_VECT[.ROWCOL,.TEST] = 1
5816					 ELSE ROW_VECT[.ROWCOL,.TEST] = 1;
5817				 END;
5818			END;
5819		    END;
5820	
5821	! By now we have found out what all of the errors were.  Now to decide
5822	!   what error messages to print out and what networks to call faulty.
5823	! In this section ERR_OCC is true if the error is the one we are looking
5824	!   for.  Then VROW or VCOL or VSTR or VSSTR or combinations of them are
5825	!   used in conjunction  with the masks MIX_1, MIX_2, MIX_3 and MIX_4 to
5826	!   determine  if the error coincides with the particular error call  in
5827	!   the section being handled.
5828	
5829		ERR_FLAG = 0;
5830		ERR_OCC = (.VCOL + .VSTR + .VSSTR EQL 0) AND (.VROW NEQ 0);
5831		IF ((.VROW OR MIX_1) EQL MIX_1) AND .ERR_OCC
5832		    THEN BEGIN
5833			 ERR_FLAG = 1;
5834			 ERR(1);
5835			 END;
5836		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
5837	
5838		IF ((.VROW OR MIX_2) EQL MIX_2) AND .ERR_OCC
5839		    THEN BEGIN
5840			 ERR_FLAG = 1;
5841			 ERR(2);
5842			 END;
5843		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
5844	
5845		IF ((.VROW OR MIX_3) EQL MIX_3) AND .ERR_OCC
5846		    THEN BEGIN
5847			 ERR_FLAG = 1;
5848			 ERR(3);
5849			 END;
5850		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
5851	
5852		IF ((.VROW OR MIX_4) EQL MIX_4) AND .ERR_OCC
5853		    THEN BEGIN
5854			 ERR_FLAG = 1;
5855			 ERR(4);
5856			 END;
5857		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
5858	
5859		ERR_OCC = (.ERR_FLAG + .VROW + .VSTR + .VSSTR EQL 0) AND (.VCOL NEQ 0);
5860		IF ((.VCOL OR MIX_1) EQL MIX_1) AND .ERR_OCC
5861		    THEN BEGIN
5862			 ERR_FLAG = 1;
5863			 ERR(5);
5864			 END;
5865		IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
5866	
5867		IF ((.VCOL OR MIX_2) EQL MIX_2) AND .ERR_OCC 
5868		    THEN BEGIN
5869			 ERR_FLAG = 1;
5870			 ERR(6);
5871			 END;
5872		IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
5873	
5874		IF ((.VCOL OR MIX_3) EQL MIX_3) AND .ERR_OCC 
5875		    THEN BEGIN
5876			 ERR_FLAG = 1;
5877			 ERR(7);
5878			 END;
5879		IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
5880	
5881		IF ((.VCOL OR MIX_4) EQL MIX_4) AND .ERR_OCC 
5882		    THEN BEGIN
5883			 ERR_FLAG = 1;
5884			 ERR(8);
5885			 END;
5886		IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
5887	
5888		IF (.ERR_FLAG+.VCOL+.VSTR+.VSSTR EQL 0) AND .VROW EQL %O'777760000000'
5889		    THEN BEGIN
5890			 ERR_FLAG = 1;
5891			 ERR(9);
5892			 END;
5893		IF LOOP_CHK(9) THEN LEAVE BLOCK1 WITH 1;
5894	
5895		IF (.ERR_FLAG+.VROW+.VSTR+.VSSTR EQL 0) AND .VCOL EQL %O'777760000000'
5896		    THEN BEGIN
5897			 ERR_FLAG = 1;
5898			 ERR(10);
5899			 END;
5900		IF LOOP_CHK(10) THEN LEAVE BLOCK1 WITH 1;
5901	
5902		IF (.ERR_FLAG+.VCOL+.VSTR+.VSSTR EQL 0) AND .VROW NEQ 0
5903		    THEN BEGIN
5904			 ERR_FLAG = 1;
5905			 ERR(11);
5906			 END;
5907		IF LOOP_CHK(11) THEN LEAVE BLOCK1 WITH 1;
5908	
5909		IF (.ERR_FLAG+.VROW+.VSTR+.VSSTR EQL 0) AND .VCOL NEQ 0
5910		    THEN BEGIN
5911			 ERR_FLAG = 1;
5912			 ERR(12);
5913			 END;
5914		IF LOOP_CHK(12) THEN LEAVE BLOCK1 WITH 1;
5915	
5916		IF (.ERR_FLAG+.VSTR+.VSSTR EQL 0) AND (.VROW NEQ 0) AND (.VCOL NEQ 0)
5917		    THEN BEGIN
5918			 ERR_FLAG = 1;
5919			 ERR(13);
5920			 END;
5921		IF LOOP_CHK(13) THEN LEAVE BLOCK1 WITH 1;
5922	
5923		IF (.ERR_FLAG + .VSSTR) EQL 0 AND (.VCOL + .VROW + .VSTR) NEQ 0
5924		    THEN BEGIN
5925			 ERR_FLAG = 1;
5926			 ERR(14);
5927			 END;
5928		IF LOOP_CHK(14) THEN LEAVE BLOCK1 WITH 1;
5929	
5930		IF .ERR_FLAG NEQ 0
5931		    THEN BEGIN
5932			 NOERR_13 = 1;
5933			 TEST_ABORT = 1;
5934			 END;
5935	
5936	!	IF .ERR_FLAG EQL 0  AND .VSSTR NEQ 0    (no longer used for this
5937	!	    THEN BEGIN				 test but this remains
5938	!		 ERR_FLAG = 1;			 here for reference.)
5939	!		 ERR(15);
5940	!		 END;
5941	!	IF LOOP_CHK(15) THEN LEAVE BLOCK1 WITH 1;
5942	
5943		0				! To eliminate INFO compiler message
5944		END;
5945	
5946	! If Tests 9,10,11,12,13 all passed then the Bus Address Register on MMC3 is ok. 
5947	
5948		ERR_FLAG = .NOERR_9 OR .NOERR_10 OR .NOERR_11 OR .NOERR_12;
5949		IF (.ERR_FLAG OR .NOERR_13) EQL 0 THEN NOERR(1);
5950	
5951	!*MESSAGE 1
5952	!*STIMULUS:
5953	!*	Write 0000.. to address  0,N
5954	!*	Write 7777.. to address  N,0
5955	!*	Write 2525.. to address  0,0
5956	!*	Write 5252.. to address  N,N
5957	!*	  For N = 1000000 (binary)
5958	!*RESPONSE:
5959	!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
5960	!*		by 0,0 for address bit 22/29
5961	
5962	!]ERROR 1
5963	!] A3  NTWK
5964	!]NO ERROR 1
5965	!] J3 K3 L3 M3 N3  NTWK
5966	
5967	!*MESSAGE 2
5968	!*STIMULUS:
5969	!*	Write 0000.. to address  0,N
5970	!*	Write 7777.. to address  N,0
5971	!*	Write 2525.. to address  0,0
5972	!*	Write 5252.. to address  N,N
5973	!*	  For N = 0100000 and 0010000 (Binary)
5974	!*RESPONSE:
5975	!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
5976	!*		by 0,0 for address bits 23,24/30,31
5977	
5978	!]ERROR 2
5979	!] B3  NTWK
5980	!]NO ERROR 2
5981	!]  NTWK
5982	
5983	!*MESSAGE 3
5984	!*STIMULUS:
5985	!*	Write 0000.. to address  0,N
5986	!*	Write 7777.. to address  N,0
5987	!*	Write 2525.. to address  0,0
5988	!*	Write 5252.. to address  N,N
5989	!*	  For N = 0001000 and 0000100 (Binary)
5990	!*RESPONSE:
5991	!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
5992	!*		by 0,0 for address bits 25,26/32,33
5993	
5994	!]ERROR 3
5995	!] C3  NTWK
5996	!]NO ERROR 3
5997	!]  NTWK
5998	
5999	!*MESSAGE 4
6000	!*STIMULUS:
6001	!*	Write 0000.. to address  0,N
6002	!*	Write 7777.. to address  N,0
6003	!*	Write 2525.. to address  0,0
6004	!*	Write 5252.. to address  N,N
6005	!*	  For N = 0000010 and 0000001 (Binary)
6006	!*RESPONSE:
6007	!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
6008	!*		by 0,0 for address bits 27,28/34,35
6009	
6010	!]ERROR 4
6011	!] D3  NTWK
6012	!]NO ERROR 4
6013	!]  NTWK
6014	
6015	!*MESSAGE 5
6016	!*STIMULUS:
6017	!*	Write 0000.. to address  0,N
6018	!*	Write 7777.. to address  N,0
6019	!*	Write 2525.. to address  0,0
6020	!*	Write 5252.. to address  N,N
6021	!*	  For N = 1000000 (Binary)
6022	!*RESPONSE:
6023	!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
6024	!*		by N,N for address bits 22/29
6025	
6026	!]ERROR 5
6027	!] A3  NTWK
6028	!]NO ERROR 5
6029	!]  NTWK
6030	
6031	!*MESSAGE 6
6032	!*STIMULUS:
6033	!*	Write 0000.. to address  0,N
6034	!*	Write 7777.. to address  N,0
6035	!*	Write 2525.. to address  0,0
6036	!*	Write 5252.. to address  N,N
6037	!*	  For N = 0100000 and 0010000 (Binary)
6038	!*RESPONSE:
6039	!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
6040	!*		by N,N for address bits 23,24/30,31
6041	
6042	!]ERROR 6
6043	!] B3  NTWK
6044	!]NO ERROR 6
6045	!]  NTWK
6046	
6047	!*MESSAGE 7
6048	!*STIMULUS:
6049	!*	Write 0000.. to address  0,N
6050	!*	Write 7777.. to address  N,0
6051	!*	Write 2525.. to address  0,0
6052	!*	Write 5252.. to address  N,N
6053	!*	  For N = 0001000 and 0000100 (Binary)
6054	!*RESPONSE:
6055	!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
6056	!*		by N,N for address bits 25,26/32,33
6057	
6058	!]ERROR 7
6059	!] C3  NTWK
6060	!]NO ERROR 7
6061	!]  NTWK
6062	
6063	!*MESSAGE 8
6064	!*STIMULUS:
6065	!*	Write 0000.. to address  0,N
6066	!*	Write 7777.. to address  N,0
6067	!*	Write 2525.. to address  0,0
6068	!*	Write 5252.. to address  N,N
6069	!*	  For N = 0000010 and 0000001 (Binary)
6070	!*RESPONSE:
6071	!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
6072	!*		by N,N for address bits 27,28/34,35
6073	
6074	!]ERROR 8
6075	!] D3  NTWK
6076	!]NO ERROR 8
6077	!]  NTWK
6078	
6079	!*MESSAGE 9
6080	!*STIMULUS:
6081	!*	Write 0000.. to address  0,N
6082	!*	Write 7777.. to address  N,0
6083	!*	Write 2525.. to address  0,0
6084	!*	Write 5252.. to address  N,N
6085	!*	  For N = 0000001, 0000010 ... 1000000
6086	!*RESPONSE:
6087	!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
6088	!*		by 0,0 for address bits 22-28/29-35
6089	
6090	!]ERROR 9
6091	!] ABCD3 BB  NTWK
6092	!]NO ERROR 9
6093	!]  NTWK
6094	
6095	!*MESSAGE 10
6096	!*STIMULUS:
6097	!*	Write 0000.. to address  0,N
6098	!*	Write 7777.. to address  N,0
6099	!*	Write 2525.. to address  0,0
6100	!*	Write 5252.. to address  N,N
6101	!*	  For N = 0000001, 0000010 ... 1000000
6102	!*RESPONSE:
6103	!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
6104	!*		by N,N for address bits 22-28/29-35
6105	
6106	!]ERROR 10
6107	!] ABCD3 NTWK
6108	!]NO ERROR 10
6109	!]  NTWK
6110	
6111	!*MESSAGE 11
6112	!*STIMULUS:
6113	!*	Write 0000.. to address  0,N
6114	!*	Write 7777.. to address  N,0
6115	!*	Write 2525.. to address  0,0
6116	!*	Write 5252.. to address  N,N
6117	!*	  For N = 0000001, 0000010 ... 1000000
6118	!*RESPONSE:
6119	!*	'MMCA COL ADD EN H' stuck low - data in 0,N is overwritten
6120	!*	  by 0,0 (for multiple chips)
6121	
6122	!]ERROR 11
6123	!] ABCD3 NTWK
6124	!]NO ERROR 11
6125	!]  NTWK
6126	
6127	!*MESSAGE 12
6128	!*STIMULUS:
6129	!*	Write 0000.. to address  0,N
6130	!*	Write 7777.. to address  N,0
6131	!*	Write 2525.. to address  0,0
6132	!*	Write 5252.. to address  N,N
6133	!*	  For N = 0000001, 0000010 ... 1000000
6134	!*RESPONSE:
6135	!*	'MMCA COL ADD EN H' stuck high - data in 0,N is overwritten
6136	!*	  by N,N (for multiple chips)
6137	
6138	!]ERROR 12
6139	!] ABCD3 NTWK
6140	!]NO ERROR 12
6141	!]  NTWK
6142	
6143	!*MESSAGE 13
6144	!*STIMULUS:
6145	!*	Write 0000.. to address  0,N
6146	!*	Write 7777.. to address  N,0
6147	!*	Write 2525.. to address  0,0
6148	!*	Write 5252.. to address  N,N
6149	!*	  For N = 0000001, 0000010 ... 1000000
6150	!*RESPONSE:
6151	!*	'MMCA COL ADD EN H' stuck low and high - Data in 0,N is overwritten
6152	!*	  by 0,0/N,N (For multiple chips)
6153	
6154	!]ERROR 13
6155	!] ABCD3 NTWK
6156	!]NO ERROR 13
6157	!]  NTWK
6158	
6159	!*MESSAGE 14
6160	!*STIMULUS:
6161	!*	Write 0000.. to address  0,N
6162	!*	Write 7777.. to address  N,0
6163	!*	Write 2525.. to address  0,0
6164	!*	Write 5252.. to address  N,N
6165	!*	  FOR N = 0000001, 0000010 ... 1000000
6166	!*RESPONSE:
6167	!*	Data in various locations is overwritten by later writes
6168	!*	  (This test cannot single out any particular error here)
6169	
6170	!]ERROR 14
6171	!] ABCD3 BB  NTWK
6172	!]NO ERROR 14
6173	!]  NTWK
6174	
6175	!*MESSAGE 15
6176	!*STIMULUS:
6177	!*	Write 0000.. to address  0,N
6178	!*	Write 7777.. to address  N,0
6179	!*	Write 2525.. to address  0,0
6180	!*	Write 5252.. to address  N,N
6181	!*	  FOR N = 0000001, 0000010 ... 1000000
6182	!*RESPONSE:
6183	!*	Data in various locations is overwritten or disappears
6184	!*	  (Possibly -  'MMCB REF ADD EN H' stuck high so writes
6185	!*	  alway go to the address being refreshed at the time)
6186	
6187	!]ERROR 15
6188	!] A_D3 G3 H3 J3 K3 L3 M3 N3 I8 J8 K8 AA BA AB BB  NTWK
6189	!]NO ERROR 15
6190	!]  NTWK
6191	
6192	END;
6193	GLOBAL ROUTINE TST14: NOVALUE =
6194	
6195	!++   ------------------ MSR READ ADDRESS LOGIC ---------------------
6196	! TEST DESCRIPTION:  This routine checks the address decode logic for
6197	!	reading the Memory Status Register.  This logic is handled by
6198	!	one nand gate on the board (MMC7 Print).
6199	!
6200	! TEST ASSUMPTIONS:  None.
6201	!
6202	! TEST PROCEDURE:  Write status - Force bits all 1's
6203	!		   Write data to mem location 00017043
6204	!		   Examine mem loc 00017043 (ECC error results)
6205	!		   Mem Stat Reg now contains addr 00017043
6206	!		   Read IO Reg 00100001	should get ?NDA or
6207	!			       00100002	  if such an IO Reg
6208	!			       00100000	  should exists then
6209	!			       00300000	  not get 00017043
6210	!			       00500000	  back.  (Except for
6211	!			       01100000   IO Reg 00100000)
6212	!			       02100000
6213	!			       04100000
6214	!			       10100000
6215	!			       00000000
6216	!
6217	!	Note:  Address bits 21..33 are ignored by the MMC
6218	!		board in determining an address match.
6219	!
6220	! POSSIBLE ERRORS:  NAND Gate on MMC7 is broken or the inputs to
6221	!			it are bad.
6222	!
6223	!--
6224	
6225	BEGIN
6226	
6227	LITERAL
6228		FORCE_ONES = %O'700040000376',	! Clear errors, write force bits 1's
6229		FORCE_ZEROS = %O'700040000000',	! Clear errors, write force bits 0's
6230		TESTADR = %O'17043';		! Test address for this test (selected
6231						!   so that it doesnt match any IO Reg)
6232	LOCAL
6233		NDA,				! ?NDA occurred
6234		ADDR;				! IO Reg address
6235	
6236	OWN
6237		MESSV: VECTOR[2],		! Error message output string
6238		TEST_ADR_VECT: VECTOR[10]	! IO Register address to write to
6239		    INITIAL(0,MSR+1,MSR+2,MSR,MSR+MSR^1,MSR+MSR^2,
6240			MSR+MSR^3,MSR+MSR^4,MSR+MSR^5,MSR+MSR^6);
6241	
6242	BIND
6243		TEST_ADR = MESSV;
6244	
6245	LABEL
6246		BLOCK1;
6247	
6248	MR();					! Master Reset
6249	IF RUN_TEST(14) THEN RETURN;		! Run this test? Return if no
6250	
6251	NOERR_14 = 0;				! No errors have occurred yet
6252	RPT_ERR_FLAG = 0;			! Don't report unexpected error
6253	
6254	IO_DEPOSIT(MSR,FORCE_ONES);		! Cause an ECC error and have 'Err
6255	MEM_DEPOSIT(TESTADR);			!   Addr Reg' contain the address
6256	MEM_EXAMINE(TESTADR);			!   17043 so that we will know when
6257						!   MSR actually does get read
6258	
6259	INCR ADR FROM 0 TO 9 DO			! For each IO address:
6260		BEGIN
6261		TEST_ADR = .TEST_ADR_VECT[.ADR];
6262		DO (0) WHILE
6263	BLOCK1:	    BEGIN
6264		    NDA = EI_CHK(.TEST_ADR);	! Try to do EI and see if we get ?NDA
6265	
6266		    IF .NDA EQL 1 THEN		! ?NDA occurred.
6267			BEGIN
6268			IF .ADR EQL 3		! If MSR was read and got ?NDA then set
6269			    THEN BEGIN		!   error flags, print error message
6270				 TEST_ABORT = 1;!   and abort future testing
6271				 NOERR_14 = 1;
6272				 ERRS(4,2,MESSV);
6273				 END;
6274			END;
6275	
6276		    IF .NDA NEQ 1 THEN		! ?NDA did not occur.
6277			IF .ADR NEQ 3		! If IO address was not MSR then read
6278			  THEN BEGIN		!   the IO address again, set error
6279			       MESSV[1] = IO_EXAMINE(.TEST_ADR);
6280			       TEST_ABORT = 1;	!   flags, print error message and
6281			       NOERR_14 = 1;	!   abort future testing.
6282			       ERRS(.ADR+1,1,MESSV);
6283			       END;
6284		    IF LOOP_CHK(.ADR+1) THEN LEAVE BLOCK1 WITH 1;
6285		    IF .TEST_ABORT EQL 1 THEN RETURN;
6286		    0				! To eliminate INFO compiler message
6287		    END;
6288		END;
6289	
6290	!*MESSAGE 1
6291	!*STIMULUS
6292	!*	LI 100000	Write Mem Status Reg:  Clear ERR HOLD bit,
6293	!*	DI 700000000376	  Set force bits 1'S (Single bit err), ECC on
6294	!*	LA 17043,DM0	Write 0's into mem loc 17043
6295	!*	EM 17043	Examine mem loc 17043 (Causes ECC error)
6296	!*	EI (IO REG)	Examine IO Reg \O0
6297	!*	Should return ?NDA (Or data other than mem addr 17043 if this
6298	!*	   matched a different I/O Register)
6299	!*RESPONSE
6300	!*	Mem Stat Reg was read (Data is: \U1 )
6301	
6302	!*MESSAGE 2
6303	!*STIMULUS
6304	!*	LI 100000	Write Mem Status Reg:  Clear ERR HOLD bit,
6305	!*	DI 700000000376	  Set force bits 1'S (Single bit err), ECC on
6306	!*	LA 17043,DM0	Write 0's into mem loc 17043
6307	!*	EM 17043	Examine mem loc 17043 (Causes ECC error)
6308	!*	EI (IO REG)	Examine IO Reg \O0
6309	!*	Should Read Mem Stat Reg - Returned address should be 17043
6310	!*RESPONSE
6311	!*	Mem Stat Reg was not read (?NDA returned instead)
6312	
6313	!]ERROR 1
6314	!] K1 L7  NTWK
6315	!]NO ERROR 1
6316	!]  NTWK
6317	
6318	!]ERROR 2
6319	!] K1 L7  NTWK
6320	!]NO ERROR 2
6321	!]  NTWK
6322	
6323	!]ERROR 3
6324	!] K1 L7  NTWK
6325	!]NO ERROR 3
6326	!]  NTWK
6327	
6328	!]ERROR 4
6329	!] K1 L7  NTWK
6330	!]NO ERROR 4
6331	!]  NTWK
6332	
6333	!]ERROR 5
6334	!] K1 L7  NTWK
6335	!]NO ERROR 5
6336	!]  NTWK
6337	
6338	!]ERROR 6
6339	!] K1 L7  NTWK
6340	!]NO ERROR 6
6341	!]  NTWK
6342	
6343	!]ERROR 7
6344	!] K1 L7  NTWK
6345	!]NO ERROR 7
6346	!]  NTWK
6347	
6348	!]ERROR 8
6349	!] K1 L7  NTWK
6350	!]NO ERROR 8
6351	!]  NTWK
6352	
6353	!]ERROR 9
6354	!] K1 L7  NTWK
6355	!]NO ERROR 9
6356	!]  NTWK
6357	
6358	!]ERROR 10
6359	!] K1 L7  NTWK
6360	!]NO ERROR 10
6361	!]  NTWK
6362	
6363	END;
6364	GLOBAL ROUTINE TST15: NOVALUE =
6365	
6366	!++   ----------------- MSR WRITE ADDRESS LOGIC -----------------
6367	! TEST DESCRIPTION:  This routine checks the address decode logic
6368	!	for writing to the Memory Status Register.  This logic is
6369	!	handled by one nand gate on the board (MMC3 Print).
6370	!
6371	! TEST ASSUMPTIONS:  None.
6372	!
6373	! TEST PROCEDURE:  Do a Master Reset
6374	!		   Sync T & R Clocks
6375	!		   Write IO Reg 00000000
6376	!			        00100001
6377	!			        00100002
6378	!			        00100000
6379	!			        00300000
6380	!			        00500000
6381	!			        01100000 (00500000 actually)
6382	!			        02100000
6383	!			        04100000
6384	!			        10100000
6385	!
6386	!		   After each write:  Tick 16 T Clocks and verify that
6387	!					either 'IO BUSY' is or is not set
6388	!				      Turn clocks on and verify ?NDA did or
6389	!					or did not appear as expected
6390	!
6391	!		   Note:  Address bits 21..33 are ignored by the MMC
6392	!			board in determining an address match.
6393	!
6394	! POSSIBLE ERRORS:  Nand gate on MMC3 is broken or the inputs to
6395	!			it are bad.
6396	!
6397	!--
6398	
6399	BEGIN
6400	
6401	LITERAL
6402		WRITE_IO = %O'500000000000';	! Write to IO Register
6403	
6404	OWN
6405		MESSV: VECTOR[2],		! Error message output vector
6406		TEST_ADR_VECT: VECTOR[10]	! IO Register addresses
6407		    INITIAL(0,MSR+1,MSR+2,MSR,MSR+MSR^1,MSR+MSR^2,
6408			MSR+MSR^2,MSR+MSR^4,MSR+MSR^5,MSR+MSR^6);
6409	
6410	BIND
6411		NDA_ERR = UPLIT(%ASCIZ '?NDA'),
6412		TEST_ADR = MESSV[0],
6413		REG102 = MESSV[1];
6414	
6415	LABEL
6416		BLOCK1;
6417	
6418	IF RUN_TEST(15) THEN RETURN;		! Run this test? Return if no
6419	
6420	NOERR_15 = 0;				! No errors have occurred yet
6421	RPT_ERR_FLAG = 0;			! Don't report unexpected error
6422	
6423	INCR ADR FROM 0 TO 9 DO			! For each IO Register address:
6424		BEGIN
6425		TEST_ADR = .TEST_ADR_VECT[.ADR];
6426		DO (0) WHILE
6427	BLOCK1:	    BEGIN
6428		    MR();			! Master Reset
6429		    SYNC_CLK();			! Sync T & R Clocks in maintenance mode
6430	
6431	! Write to IO address and give 20 ticks.  The 20 ticks should do enough of
6432	!   the IO write that if this is a valid MSR address 'IO BUSY' will appear
6433	!   in 8080 Reg 102.
6434	
6435		    WRITE_COMADR(WRITE_IO OR .TEST_ADR);
6436		    WRITE_DATA(0);
6437		    WRITE_CONTROL();
6438		    TICK(20);			! Give 20 ticks
6439		    REG102 = RD_102;		! Read Reg 102
6440	
6441		    START_CLK;			! Start up the clock
6442		    CHK_ERR_MSG(NDA_ERR);	! Check to see if ?NDA occurred
6443	
6444		    IF .ADR NEQ 3 THEN		! Did not try to write to MSR
6445			BEGIN			! Did 'IO BUSY' assert?
6446			IF (.REG102 AND RIO_BUSY) NEQ 0
6447			    THEN BEGIN		! If yes - set error flags, print error
6448				 TEST_ABORT = 1;!   message, abort future testing
6449				 NOERR_15 = 1;
6450				 ERRS(.ADR+1,1,MESSV);
6451				 END;
6452			IF LOOP_CHK(.ADR+1) THEN LEAVE BLOCK1 WITH 1;
6453			IF .TEST_ABORT EQL 1 THEN RETURN;
6454			END;
6455	
6456		    IF .ADR EQL 3 THEN		! Tried to write to MSR
6457			BEGIN			! Did 'IO BUSY' assert?
6458			IF (.REG102 AND RIO_BUSY) EQL 0
6459			    THEN BEGIN		! If no - set error flags, print error
6460				 TEST_ABORT = 1;!   message, abort future testing
6461				 NOERR_15 = 1;
6462				 ERRS(.ADR+1,2,MESSV);
6463				 END;
6464			IF LOOP_CHK(.ADR+1) THEN LEAVE BLOCK1 WITH 1;
6465			IF .TEST_ABORT EQL 1 THEN RETURN;
6466			END;
6467		    0				! To eliminate INFO compiler message
6468		    END;
6469		END;
6470		NOERR(1);			! If we made it this far with no errors
6471						!   then the NAND gate cannot be faulty
6472	
6473	!*MESSAGE 1
6474	!*STIMULUS
6475	!*	MR,SYNC CLKS
6476	!*	LI (IO REG)	Write status to IO Reg \O0
6477	!*	DI 0		   (Data is 0's)
6478	!*	Tick clock 20 ticks (5 T Clocks) - 'I/O BUSY' should not
6479	!*	   appear in 8080 Reg 102
6480	!*RESPONSE
6481	!*	'I/O BUSY' appeared in 8080 Reg 102
6482	!*	8080 Reg 102: \U1
6483	
6484	!*MESSAGE 2
6485	!*STIMULUS
6486	!*	MR,SYNC CLKS
6487	!*	LI (IO REG)	Write status to IO Reg \O0
6488	!*	DI 0		   (Data is 0's)
6489	!*	Tick clock 20 ticks (5 T Clocks) - 'I/O BUSY' should have
6490	!*	   appeared in 8080 Reg 102
6491	!*RESPONSE
6492	!*	'I/O BUSY' did not appear in 8080 Reg 102
6493	!*	8080 Reg 102: \U1
6494	
6495	!]ERROR 1
6496	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6497	!]NO ERROR 1
6498	!] F3  NTWK
6499	
6500	!]ERROR 2
6501	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6502	!]NO ERROR 2
6503	!]  NTWK
6504	
6505	!]ERROR 3
6506	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6507	!]NO ERROR 3
6508	!]  NTWK
6509	
6510	!]ERROR 4
6511	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6512	!]NO ERROR 4
6513	!]  NTWK
6514	
6515	!]ERROR 5
6516	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6517	!]NO ERROR 5
6518	!]  NTWK
6519	
6520	!]ERROR 6
6521	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6522	!]NO ERROR 6
6523	!]  NTWK
6524	
6525	!]ERROR 7
6526	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6527	!]NO ERROR 7
6528	!]  NTWK
6529	
6530	!]ERROR 8
6531	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6532	!]NO ERROR 8
6533	!]  NTWK
6534	
6535	!]ERROR 9
6536	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6537	!]NO ERROR 9
6538	!]  NTWK
6539	
6540	!]ERROR 10
6541	!] A1 D1 E1 F1 J1 K1 F3 DB  NTWK
6542	!]NO ERROR 10
6543	!]  NTWK
6544	
6545	END;
6546	GLOBAL ROUTINE TST16: NOVALUE =
6547	
6548	!++   --------------- MSR WRITE ADDRESS LOGIC -------------------
6549	! TEST DESCRIPTION:  This routine checks the address decode logic
6550	!	for writing to the Memory Status Register.  This logic is
6551	!	handled by one nand gate on the board (MMC3 Print).
6552	!
6553	! TEST ASSUMPTIONS:  None.
6554	!
6555	! TEST PROCEDURE:  Do a Master Reset
6556	!		   Write IO Reg 00100001 Shut off ECC / Shut off PE
6557	!			        00100002 Shut off ECC / Shut off PE
6558	!			        00100000 Shut off ECC / Shut off PE
6559	!			        00300000 Shut off ECC / Shut off PE
6560	!			        00500000 Shut off ECC / Shut off PE
6561	!			        01100000 Shut off ECC / Shut off PE
6562	!			        02100000 Shut off ECC / Shut off PE
6563	!			        04100000 Shut off ECC / Shut off PE
6564	!			        10100000 Shut off ECC / Shut off PE
6565	!			        00000000 Shut off ECC / Shut off PE
6566	!
6567	!		   After each write, read IO Reg and check ?NDA
6568	!		     or check to see if ECC / PE was affected.
6569	!
6570	!		   Note:  Address bits 21..33 are ignored by the MMC
6571	!			board in determining an address match.
6572	!
6573	! POSSIBLE ERRORS:  Nand gate on MMC3 is broken or the inputs to
6574	!			it are bad.
6575	!
6576	!--
6577	
6578	BEGIN
6579	
6580	LITERAL
6581		PE_ECC = %O'060000000000',	! Parity Error set and ECC on
6582		PE_ERR = %O'020000000000';	! Parity Error set and ECC off
6583	
6584	LOCAL
6585		ERRR,
6586		IO_NDA;
6587	
6588	OWN
6589		MESSV: VECTOR[2],		! Error message output vector
6590		TEST_ADR_VECT: VECTOR[10]	! IO Registers to write to
6591		    INITIAL(0,MSR+1,MSR+2,MSR,MSR+MSR^1,MSR+MSR^2,
6592			MSR+MSR^3,MSR+MSR^4,MSR+MSR^5,MSR+MSR^6);
6593	
6594	BIND
6595		TEST_ADR = MESSV[0],
6596		MEM_STAT = MESSV[1];
6597	
6598	LABEL
6599		BLOCK1;
6600	
6601	IF RUN_TEST(16) THEN RETURN;		! Run this test? Return if no
6602	
6603	NOERR_16 = 0;				! No errors have occurred yet
6604	RPT_ERR_FLAG = 0;			! Don't report unexpected error
6605	
6606	INCR ADR FROM 0 TO 9 DO			! For each IO Register:
6607		BEGIN
6608		TEST_ADR = .TEST_ADR_VECT[.ADR];
6609		DO (0) WHILE
6610	BLOCK1:	    BEGIN
6611		    MR();			! Master Reset
6612	
6613	! Write IO address - set Parity Error and turn off ECC
6614	
6615		    IO_DEPOSIT(.TEST_ADR,PE_SET + ECC_OFF);
6616	
6617	! Now see if can read IO address.  Then read MSR to see if it got written to.
6618	
6619		    IO_NDA = EI_CHK(.TEST_ADR);
6620		    MEM_STAT = IO_EXAMINE(MSR);
6621	
6622		    ERRR = .ADR * 2 + 1 + (.ADR GEQ 4);	! Error number
6623	
6624		    IF .ADR NEQ 3 THEN		! Wrote to IO Reg which was not MSR
6625			BEGIN
6626			IF (.MEM_STAT AND PE_ECC) EQL PE_SET AND .IO_NDA EQL 0
6627			    THEN BEGIN		! If the IO Register write succeeded
6628				 TEST_ABORT = 1;!   (PE got set, ?NDA did not occur)
6629				 NOERR_16 = 1;	!   set error flags, print err message
6630				 ERRS(.ERRR,1,MESSV);
6631				 END;
6632			IF LOOP_CHK(.ERRR) THEN LEAVE BLOCK1 WITH 1;
6633			IF .TEST_ABORT EQL 1 THEN RETURN;
6634	
6635			IF (.MEM_STAT AND PE_ECC) EQL PE_SET AND .IO_NDA EQL 1
6636			    THEN BEGIN		! If the IO Register write succeeded
6637				 TEST_ABORT = 1;!   (PE got set, ?NDA occurred) then
6638				 NOERR_16 = 1;	!   set error flags, print err message
6639				 ERRS(.ERRR+1,2,MESSV);
6640				 END;
6641			IF LOOP_CHK(.ERRR+1) THEN LEAVE BLOCK1 WITH 1;
6642			IF .TEST_ABORT EQL 1 THEN RETURN;
6643			END;
6644	
6645		    IF .ADR EQL 3 THEN		! Wrote to IO Reg which was MSR
6646			BEGIN
6647			IF (.MEM_STAT AND PE_ECC) EQL PE_ERR AND .IO_NDA EQL 0
6648			    THEN BEGIN		! If the IO Register write failed
6649				 TEST_ABORT = 1;!  (PE not set, ?NDA did not occur)
6650				 NOERR_16 = 1;	!   set error flags, print err message
6651				 ERRS(7,3,MESSV);
6652				 END;
6653			IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
6654			IF .TEST_ABORT EQL 1 THEN RETURN;
6655	
6656			IF (.MEM_STAT AND PE_ECC) EQL PE_SET AND .IO_NDA EQL 1
6657			    THEN BEGIN		! If the IO Register write failed
6658				 TEST_ABORT = 1;!  (PE got set, ?NDA occurred) then
6659				 NOERR_16 = 1;	!   set error flags, print err message
6660				 ERRS(8,4,MESSV);
6661				 END;
6662			IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
6663			IF .TEST_ABORT EQL 1 THEN RETURN;
6664	
6665			IF (.MEM_STAT AND PE_ECC) EQL PE_ERR AND .IO_NDA EQL 1
6666			    THEN BEGIN		! If the IO Register write failed
6667				 TEST_ABORT = 1;!   (PE not set, ?NDA occurred) then
6668				 NOERR_16 = 1;	!   set error flags, print err message
6669				 ERRS(9,5,MESSV);
6670				 END;
6671			IF LOOP_CHK(9) THEN LEAVE BLOCK1 WITH 1;
6672			IF .TEST_ABORT EQL 1 THEN RETURN;
6673	
6674			END;
6675		    0				! To eliminate INFO compiler message
6676		    END;
6677		END;
6678	
6679	! Call NOERR if the last 3 tests succeeded - we can definitely read/write
6680	!   the Memory Status Register.
6681	
6682		IF (.NOERR_14 OR .NOERR_15 OR .NOERR_16) EQL 0
6683		    THEN NOERR(1);
6684	
6685	!*MESSAGE 1
6686	!*STIMULUS
6687	!*	MR		Ensure ECC on and PE not set
6688	!*	LI (IO Reg)	Write status to IO Reg \O0
6689	!*	DI 040000000001 Shut off ECC / Set PE - (Should return ?NDA)
6690	!*	EI 100000	Examine Mem Stat Reg (Should show ECC on / PE on)
6691	!*RESPONSE
6692	!*	ECC shut off / PE set and no ?NDA occurred on DI \O0
6693	!*	Mem Stat Reg: \U1
6694	
6695	!*MESSAGE 2
6696	!*STIMULUS
6697	!*	MR		Ensure ECC on and PE not set
6698	!*	LI (IO Reg)	Write status to IO Reg \O0
6699	!*	DI 040000000001 Shut off ECC / Set PE - (Should return ?NDA)
6700	!*	EI 100000	Examine Mem Stat Reg (Should show ECC on / PE on)
6701	!*RESPONSE
6702	!*	ECC shut off / PE set (Also, ?NDA occurred on DI \O0)
6703	!*	Mem Stat Reg: \U1
6704	
6705	!*MESSAGE 3
6706	!*STIMULUS
6707	!*	MR		Ensure ECC on and PE not set
6708	!*	LI 100000	Write status to IO Reg 100000
6709	!*	DI 040000000001 Shut off ECC / Set PE
6710	!*	EI 100000	Examine Mem Stat Reg (Should show ECC now off)
6711	!*RESPONSE
6712	!*	ECC still on / PE not set and no ?NDA occurred on EI 100000)
6713	!*	Mem Stat Reg: \U1
6714	
6715	!*MESSAGE 4
6716	!*STIMULUS
6717	!*	MR		Ensure ECC on and PE not set
6718	!*	LI 100000	Write status to IO Reg 100000
6719	!*	DI 040000000001 Shut off ECC / Set PE
6720	!*	EI 100000	Examine Mem Stat Reg (Should show ECC now off)
6721	!*RESPONSE
6722	!*	ECC shut off / PE set but ?NDA occurred on EI 100000)
6723	!*	Mem Stat Reg: \U1
6724	
6725	!*MESSAGE 5
6726	!*STIMULUS
6727	!*	MR		Ensure ECC on and PE not set
6728	!*	LI 100000	Write status to IO Reg 100000
6729	!*	DI 040000000001 Shut off ECC / Set PE
6730	!*	EI 100000	Examine Mem Stat Reg (Should show ECC now off)
6731	!*RESPONSE
6732	!*	ECC still on / PE not set and ?NDA occurred on EI 100000)
6733	!*	Mem Stat Reg: \U1
6734	
6735	!]ERROR 1
6736	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6737	!]NO ERROR 1
6738	!] E3 F3 K1  NTWK
6739	
6740	!]ERROR 2
6741	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6742	!]NO ERROR 2
6743	!]  NTWK
6744	
6745	!]ERROR 3
6746	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6747	!]NO ERROR 3
6748	!]  NTWK
6749	
6750	!]ERROR 4
6751	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6752	!]NO ERROR 4
6753	!]  NTWK
6754	
6755	!]ERROR 5
6756	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6757	!]NO ERROR 5
6758	!]  NTWK
6759	
6760	!]ERROR 6
6761	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6762	!]NO ERROR 6
6763	!]  NTWK
6764	
6765	!]ERROR 7
6766	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6767	!]NO ERROR 7
6768	!]  NTWK
6769	
6770	!]ERROR 8
6771	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6772	!]NO ERROR 8
6773	!]  NTWK
6774	
6775	!]ERROR 9
6776	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6777	!]NO ERROR 9
6778	!]  NTWK
6779	
6780	!]ERROR 10
6781	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6782	!]NO ERROR 10
6783	!]  NTWK
6784	
6785	!]ERROR 11
6786	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6787	!]NO ERROR 11
6788	!]  NTWK
6789	
6790	!]ERROR 12
6791	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6792	!]NO ERROR 12
6793	!]  NTWK
6794	
6795	!]ERROR 13
6796	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6797	!]NO ERROR 13
6798	!]  NTWK
6799	
6800	!]ERROR 14
6801	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6802	!]NO ERROR 14
6803	!]  NTWK
6804	
6805	!]ERROR 15
6806	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6807	!]NO ERROR 15
6808	!]  NTWK
6809	
6810	!]ERROR 16
6811	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6812	!]NO ERROR 16
6813	!]  NTWK
6814	
6815	!]ERROR 17
6816	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6817	!]NO ERROR 17
6818	!]  NTWK
6819	
6820	!]ERROR 18
6821	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6822	!]NO ERROR 18
6823	!]  NTWK
6824	
6825	!]ERROR 19
6826	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6827	!]NO ERROR 19
6828	!]  NTWK
6829	
6830	!]ERROR 20
6831	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6832	!]NO ERROR 20
6833	!]  NTWK
6834	
6835	!]ERROR 21
6836	!] A1 D1 E1 F1 J1 K1 E3  NTWK
6837	!]NO ERROR 21
6838	!]  NTWK
6839	
6840	END;
6841	GLOBAL ROUTINE TST17: NOVALUE =
6842	
6843	!++   ------------------- MEMORY STATUS REGISTER -----------------
6844	! TEST DESCRIPTION:  This  routine  verifies  various  bits in the
6845	!	Mem Status Register. Some of these bits such as 'ERR HOLD',
6846	!	'UNCOR ERR HOLD', 'POWER FAILED', 'REFRESH ERR' are tested
6847	!	only in that they are ok if they do not assert as a result
6848	!	of this test.  These bits except 'POWER FAILED' are tested
6849	!	more completely in later tests.  The remainder are toggled
6850	!	and the state of each verified after each mem status write.
6851	!
6852	!	These bits are:	00-ERR HOLD (RD/WR)	04-ECC ON (READ)
6853	!			01-UNCOR ERR HOLD (R/W)	12-POWER FAILED (READ)
6854	!			02-REFRESH ERR (RD/WR)	35-ECC ON (WRITE)
6855	!			03-PARITY ERR (RD/WR)
6856	!
6857	! TEST ASSUMPTIONS:  None.
6858	!
6859	! TEST PROCEDURE:  Do a Master Reset
6860	!		   Shut off parity checking by 8080
6861	!		   Write status (0000...)
6862	!		   Read status & verify bits 00-04,12
6863	!		   Write status (Bits 00-04,12 set to 1's, remaining
6864	!			bits all 0's)
6865	!		   Read status & verify bits
6866	!
6867	! POSSIBLE ERRORS:  Status bits may be stuck at 0/1
6868	!
6869	!--
6870	
6871	BEGIN
6872	
6873	LITERAL
6874		MASK_AND = %O'017720000000',
6875		MASK_XOR1 = %O'020000100000',
6876		MASK_XOR2 = %O'040000000000';
6877	
6878	OWN
6879		MEM_STAT_VECT: BTTVECTOR[36],
6880		DATA_CORR_VECT: BTTVECTOR[36];
6881	
6882	BIND
6883		MEM_STAT = MEM_STAT_VECT,
6884		DATA_CORR = DATA_CORR_VECT;
6885	
6886	LABEL
6887		BLOCK1,
6888		BLOCK2;
6889	
6890	IF RUN_TEST(17) THEN RETURN;		! Run this test? Return if no
6891	
6892	NOERR_17 = 0;				! No errors have occurred yet
6893	RPT_ERR_FLAG = 0;			! Don't report unexpected error
6894	PAR_DISABLE;				! Disable parity error checking by 8080
6895	
6896	! First write 0's to MSR and see if any faults appear.
6897	
6898	DO (0) WHILE
6899	BLOCK1:	BEGIN
6900		MR();				! Master Reset
6901		DM(0,0);			! Write 0's to mem loc 0
6902		EM(0);				! Examine mem loc 0 (ensures ?NXM off)
6903	
6904		IO_DEPOSIT(MSR,0);		! Write 0's to MSR
6905		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
6906		DATA_CORR = (.MEM_STAT AND MASK_AND) XOR MASK_XOR1;
6907	
6908	! Check for faulty bits 00..04 'ERR HOLD','UNCORR ERR HOLD','REFRESH ERROR',
6909	!  'PARITY ERROR','ECC ON'.
6910	
6911		INCR ERRR FROM 0 TO 4 DO
6912		    BEGIN
6913		    IF .MEM_STAT_VECT[.ERRR] NEQ .DATA_CORR_VECT[.ERRR]
6914			THEN BEGIN
6915			     NOERR_17 = 1;
6916			     ERRCA(.ERRR+1,.DATA_CORR,.MEM_STAT,12);
6917			     END;
6918		    IF LOOP_CHK(.ERRR+1) THEN LEAVE BLOCK1 WITH 1;
6919		    END;
6920	
6921	! Also check 'Power Fail' bit in MSR.
6922	
6923		IF .MEM_STAT_VECT[12] NEQ .DATA_CORR_VECT[12]
6924		    THEN BEGIN
6925			 NOERR_17 = 1;
6926			 ERRCA(6,.DATA_CORR,.MEM_STAT,12);
6927			 END
6928		    ELSE NOERR(2);
6929		IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
6930		0				! To eliminate INFO compiler message
6931		END;
6932	
6933	! Now write 1's to MSR and see if any faults appear.
6934	
6935	DO (0) WHILE
6936	BLOCK2:	BEGIN
6937		IO_DEPOSIT(MSR,%O'777777777777'); ! Write 1's to MSR
6938		MEM_STAT = IO_EXAMINE(MSR);	  ! Read MSR
6939		DATA_CORR = (.MEM_STAT AND MASK_AND) XOR MASK_XOR2;
6940	
6941	! Check for faulty bits 00..04 'ERR HOLD','UNCORR ERR HOLD','REFRESH ERROR',
6942	!  'PARITY ERROR','ECC ON'.
6943	
6944		INCR ERRR FROM 0 TO 4 DO
6945		    BEGIN
6946		    IF .MEM_STAT_VECT[.ERRR] NEQ .DATA_CORR_VECT[.ERRR]
6947			THEN BEGIN
6948			     NOERR_17 = 1;
6949			     ERRCA(.ERRR+7,.DATA_CORR,.MEM_STAT,12);
6950			     END;
6951		    IF LOOP_CHK(.ERRR+7) THEN LEAVE BLOCK2 WITH 1;
6952		    END;
6953	
6954	! Also check 'Power Fail' bit in MSR.
6955	
6956		IF .MEM_STAT_VECT[12] NEQ .DATA_CORR_VECT[12]
6957		    THEN BEGIN
6958			 NOERR_17 = 1;
6959			 ERRCA(12,.DATA_CORR,.MEM_STAT,12);
6960			 END
6961		    ELSE NOERR(2);
6962		IF LOOP_CHK(12) THEN LEAVE BLOCK2 WITH 1;
6963		0				! To eliminate INFO compiler message
6964		END;
6965		IF .NOERR_17 EQL 0
6966		    THEN NOERR(1);
6967	
6968	!*MESSAGE 1
6969	!*STIMULUS:
6970	!*	MR,PE 3		Shut off 8080 parity checking
6971	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
6972	!*	EI 100000	Read Mem Status Reg
6973	!*	'ERR HOLD' should be 0 - ('MR' would turn it off if on)
6974	!*RESPONSE:
6975	!*	'MMC5 ERR HOLD' bit 00 asserted
6976	
6977	!]ERROR 1
6978	!] C5 E5 F5 G5 C7 L7 AA  NTWK
6979	!]NO ERROR 1
6980	!] H3  NTWK
6981	
6982	!*MESSAGE 2
6983	!*STIMULUS:
6984	!*	MR,PE 3		Shut off 8080 parity checking
6985	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
6986	!*	EI 100000	Read Mem Status Reg
6987	!*	'UNCOR ERR HOLD' should be 0
6988	!*RESPONSE:
6989	!*	'MMC4 UNCOR ERR HOLD' bit 01 asserted
6990	
6991	!]ERROR 2
6992	!] J4 B5 G5 C7 L7 AA  NTWK
6993	!]NO ERROR 2
6994	!]  NTWK
6995	
6996	!*MESSAGE 3
6997	!*STIMULUS:
6998	!*	MR,PE 3		Shut off 8080 parity checking
6999	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7000	!*	EI 100000	Read Mem Status Reg
7001	!*	'REFRESH ERR' should be 0 - ('MR' would turn it off if on)
7002	!*RESPONSE:
7003	!*	'MMC9 REF ERR' bit 02 asserted
7004	
7005	!]ERROR 3
7006	!] A1 C7 L7 B9 AA  NTWK
7007	!]NO ERROR 3
7008	!]  NTWK
7009	
7010	!*MESSAGE 4
7011	!*STIMULUS:
7012	!*	MR,PE 3		Shut off 8080 parity checking
7013	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7014	!*	EI 100000	Read Mem Status Reg
7015	!*	'PARITY ERR' should be 0 - ('DI 0' would turn it off if on)
7016	!*RESPONSE:
7017	!*	'MMC7 PARITY ERR' bit 03 asserted
7018	
7019	!]ERROR 4
7020	!] A_J1 N1 E3 F3 B7 C7 L7 AA  NTWK
7021	!]NO ERROR 4
7022	!]  NTWK
7023	
7024	!*MESSAGE 5
7025	!*STIMULUS:
7026	!*	MR,PE 3		Shut off 8080 parity checking
7027	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7028	!*	EI 100000	Read Mem Status Reg
7029	!*	'ECC ON' should be 1 - ('DI 0' turns it on)
7030	!*RESPONSE:
7031	!*	'MMC3 ECC ON' bit 04 not asserted
7032	
7033	!]ERROR 5
7034	!] B1 E3 F3 H3 D7 L7 AA  NTWK
7035	!]NO ERROR 5
7036	!]  NTWK
7037	
7038	!*MESSAGE 6
7039	!*STIMULUS:
7040	!*	MR,PE 3		Shut off 8080 parity checking
7041	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7042	!*	EI 100000	Read Mem Status Reg
7043	!*	'POWER FAILED' should be 0
7044	!*RESPONSE:
7045	!*	'MMC5 POWER FAILED' bit 12 asserted
7046	
7047	!]ERROR 6
7048	!] A5 C7 L7 AA  NTWK
7049	!]NO ERROR 6
7050	!]  NTWK
7051	
7052	!*MESSAGE 7
7053	!*STIMULUS:
7054	!*	MR,PE 3		Shut off 8080 parity checking
7055	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7056	!*	EI 100000	Read Mem Status Reg
7057	!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
7058	!*			  clear 'REF ERR', set 'PE', turn off ECC)
7059	!*	EI 100000	Read Mem Status Reg
7060	!*RESPONSE:
7061	!*	'MMC5 ERR HOLD' bit 00 asserted
7062	
7063	!]ERROR 7
7064	!] C5 E5 F5 G5 C7 L7 AA  NTWK
7065	!]NO ERROR 7
7066	!]  NTWK
7067	
7068	!*MESSAGE 8
7069	!*STIMULUS:
7070	!*	MR,PE 3		Shut off 8080 parity checking
7071	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7072	!*	EI 100000	Read Mem Status Reg
7073	!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
7074	!*			  clear 'REF ERR', set 'PE', turn off ECC)
7075	!*	EI 100000	Read Mem Status Reg
7076	!*RESPONSE:
7077	!*	'MMC4 UNCOR ERR HOLD' bit 01 asserted
7078	
7079	!]ERROR 8
7080	!] J4 B5 G5 C7 L7 AA  NTWK
7081	!]NO ERROR 8
7082	!]  NTWK
7083	
7084	!*MESSAGE 9
7085	!*STIMULUS:
7086	!*	MR,PE 3		Shut off 8080 parity checking
7087	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7088	!*	EI 100000	Read Mem Status Reg
7089	!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
7090	!*			  clear 'REF ERR', set 'PE', turn off ECC)
7091	!*	EI 100000	Read Mem Status Reg
7092	!*RESPONSE:
7093	!*	'MMC9 REF ERR' bit 02 asserted
7094	
7095	!]ERROR 9
7096	!] C7 L7 B9 AA  NTWK
7097	!]NO ERROR 9
7098	!]  NTWK
7099	
7100	!*MESSAGE 10
7101	!*STIMULUS:
7102	!*	MR,PE 3		Shut off 8080 parity checking
7103	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7104	!*	EI 100000	Read Mem Status Reg
7105	!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
7106	!*			  clear 'REF ERR', set 'PE', turn off ECC)
7107	!*	EI 100000	Read Mem Status Reg
7108	!*RESPONSE:
7109	!*	'MMC7 PARITY ERR' bit 03 not asserted
7110	
7111	!]ERROR 10
7112	!] A_J1 N1 E3 F3 B7 C7 L7 AA  NTWK
7113	!]NO ERROR 10
7114	!]  NTWK
7115	
7116	!*MESSAGE 11
7117	!*STIMULUS:
7118	!*	MR,PE 3		Shut off 8080 parity checking
7119	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7120	!*	EI 100000	Read Mem Status Reg
7121	!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
7122	!*			  clear 'REF ERR', set 'PE', turn off ECC)
7123	!*	EI 100000	Read Mem Status Reg
7124	!*RESPONSE:
7125	!*	'MMC3 ECC ON' bit 04 asserted
7126	
7127	!]ERROR 11
7128	!] B1 E3 F3 H3 D7 L7 AA  NTWK
7129	!]NO ERROR 11
7130	!]  NTWK
7131	
7132	!*MESSAGE 12
7133	!*STIMULUS:
7134	!*	MR,PE 3		Shut off 8080 parity checking
7135	!*	LI 100000,DI 0	Write 0's to Mem Stat Reg
7136	!*	EI 100000	Read Mem Status Reg
7137	!*	DI 540040000001	WRITE 1'S TO Mem Stat Reg (Clear 'ERR HOLD',
7138	!*			  clear 'REF ERR', set 'PE', turn off ECC)
7139	!*	EI 100000	Read Mem Status Reg
7140	!*RESPONSE:
7141	!*	'MMC5 POWER FAILED' bit 12 asserted
7142	
7143	!]ERROR 12
7144	!] A5 C7 L7 AA  NTWK
7145	!]NO ERROR 12
7146	!]  NTWK
7147	
7148	END;
7149	GLOBAL ROUTINE TST18: NOVALUE =
7150	
7151	!++   -------------------- PARITY ERROR --------------------------
7152	! TEST DESCRIPTION:  This routine tests parity checking on the MMC
7153	!	board.   Since  bad parity cannot be generated explicitly,
7154	!	the test uses the Mem Status Register to set parity error.
7155	!	then it verifies that parity error actually occurred. Then
7156	!	'PE' is cleared and the fact is verified.  This test is an
7157	!	expansion  of an earlier test which tested various bits of
7158	!	the Memory Status Register.
7159	!
7160	! TEST ASSUMPTIONS:  None.
7161	!
7162	! TEST PROCEDURE:  Do a Master Reset
7163	!		   Shut off 8080 parity checking
7164	!		   Write status (parity error)
7165	!		   Check to see if PE occurred
7166	!		   Write status (no parity error)
7167	!		   Check to see if PE still set
7168	!
7169	! POSSIBLE ERRORS:  Faulty parity error register logic.  Or the
7170	!			route to the PE flop or from it to the
7171	!			8080 is faulty.
7172	!
7173	!--
7174	
7175	BEGIN
7176	
7177	LOCAL
7178		TEMP;
7179	
7180	LABEL
7181		BLOCK1;
7182	
7183	IF RUN_TEST(18) THEN RETURN;		! Run this test? Return if no
7184	
7185	NOERR_18 = 0;				! No errors have occurred yet
7186	RPT_ERR_FLAG = 0;			! Don't report unexpected error
7187	PAR_DISABLE;				! Disable parity error checking by 8080
7188	
7189	DO (0) WHILE
7190	BLOCK1:	BEGIN
7191		MR();				! Master Reset
7192		IO_DEPOSIT(MSR,PE_SET);		! Set PE
7193		SEND_NUL();			! Send it off to 8080
7194	
7195		TEMP = RD_100;			! Read Reg 100 - should show PE exists
7196		IF (.TEMP AND %O'010') NEQ 0	! If it doesnt - set error flag and 
7197		    THEN BEGIN			!   print error message.
7198			 NOERR_18 = 1;
7199			 ERR(1);
7200			 END;
7201		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
7202	
7203		IO_DEPOSIT(MSR,PE_CLR);		! Clear out the PE
7204		TEMP = RD_100;			! Read Reg 100 - should show no PE
7205		IF (.TEMP AND %O'010') EQL 0	! If it does - set error flag and
7206		    THEN BEGIN			!   print error message.
7207			 NOERR_18 = 1;
7208			 ERR(2);
7209			 END;
7210		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
7211		0				! To eliminate INFO compiler message
7212		END;
7213	
7214	! If no errors in Tests 17 or 18 then parity error logic on MMC7 is ok.
7215	
7216		IF (.NOERR_17 OR .NOERR_18) NEQ 0
7217		    THEN NOERR(1);
7218	
7219	! If no errors in Tests 8 or 18 then parity generators on MMC1 are ok.
7220	
7221		IF (.NOERR_8 OR .NOERR_18) NEQ 0
7222		    THEN NOERR(2);
7223	
7224	!*MESSAGE 1
7225	!*STIMULUS
7226	!*	MR,PE 3		Shut off 8080 parity checking
7227	!*	LI 100000	Set 'MMC7 PARITY ERR' by writing
7228	!*	DI 40000000000	  to Mem Status Register
7229	!*	ER 100		Look at 8080 Reg 100 to see if PE detected
7230	!*RESPONSE
7231	!*	8080 Reg 100 is: \O0 - No mem par err detected
7232	
7233	!]ERROR 1
7234	!] E3 F3 H3 B7 C7  NTWK
7235	!]NO ERROR 1
7236	!] B7  NTWK
7237	
7238	!*MESSAGE 2
7239	!*STIMULUS
7240	!*	MR,PE 3		Shut off 8080 parity checking
7241	!*	LI 100000	Set 'MMC7 PARITY ERR' by writing
7242	!*	DI 40000000000	  to Mem Status Register
7243	!*	ER 100		Look at 8080 Reg 100 to see if PE detected
7244	!*	DI 0		Write status to clear 'MMC7 PARITY ERR'
7245	!*RESPONSE
7246	!*	8080 Reg 100 is: \O0 - Mem par err did not go away
7247	
7248	!]ERROR 2
7249	!] A_J1 N1 E3 F3 H3 B7 C7  NTWK
7250	!]NO ERROR 2
7251	!] L1 M1 N1  NTWK
7252	
7253	END;
7254	GLOBAL ROUTINE TST19: NOVALUE =
7255	
7256	!++   ------------------- ERROR ADDRESS REGISTER ------------------
7257	! TEST DESCRIPTION:  This routine checks the error address register
7258	!	on MMC8.  The address is normally loaded into this register
7259	!	directly from the 8646 transceiver upon receipt of a Com/Adr
7260	!	cycle if the Err Hold flag is not set.  This address will be
7261	!	held in the register until a bus reset or a mem status write
7262	!	clears the Err Hold bit.
7263	!
7264	! TEST ASSUMPTIONS:  None.
7265	!
7266	! TEST PROCEDURE:  Write status (Force bits all 1's)
7267	!		   Write a 0 to address 00000000
7268	!		   Read mem loc 00000000 (will cause a single bit ECC
7269	!			error and address will be latched in the Err
7270	!			Adr Reg)
7271	!		   Examine Mem Status Reg and verify address
7272	!		   Write status (Force bits 1's and clear Err Hold)
7273	!		   Repeat with address 17777777
7274	!
7275	!		   When all done reset MMC - Clear Err Hold
7276	!
7277	! POSSIBLE ERRORS:  Faulty chips in the err addr holding register
7278	!			on MMC8
7279	!
7280	!--
7281	
7282	BEGIN
7283	
7284	LITERAL
7285		FORCE_SET = %O'400000000376',	! Set force bits 177
7286		FORCE_CLR = %O'400000000000',	! Clear 'ERR HOLD'
7287		ADR14_21 = %O'17740000',	! Address for flop 1 of err addr reg
7288		ADR22_29 = %O'00037700',	! Address for flop 2 of err addr reg
7289		ADR30_35 = %O'00000077';	! Address for flop 3 of err addr reg
7290	
7291	LOCAL
7292		TEST_ADR,			! Test address we are writing to
7293		TEMP,
7294		TEMP1,
7295		TEMP2,
7296		ERRNO,
7297		ERR_SWITCH,
7298		ERR_TEMP,
7299		ERR_FLAG;
7300	
7301	OWN
7302		MESSV: VECTOR[2],		! Error message output vector
7303		MEM_STAT_REG,
7304		MEM_STAT_ADR,
7305		MSR_CORR,
7306		ADR: VECTOR[2]			! Memory addresses to use
7307		     INITIAL (%O'177777',0);
7308	
7309	LABEL
7310		BLOCK1;
7311	
7312	IF RUN_TEST(19) THEN RETURN;		! Run this test? Return if no
7313	
7314	NOERR_19 = 0;				! No errors have occurred yet
7315	RPT_ERR_FLAG = 0;			! Don't report unexpected error
7316	
7317	INCR TEST FROM 0 TO 1 DO
7318		BEGIN
7319		DO (0) WHILE
7320	BLOCK1:	    BEGIN
7321		    MR();			! Master Reset
7322		    TEST_ADR = MESSV = .ADR[.TEST];
7323		    MSR_CORR = .MESSV OR %O'437700000000';
7324		    IO_DEPOSIT(MSR,FORCE_SET);	! Set force bits
7325		    MEM_DEPOSIT(.TEST_ADR,0);	! Write 0's to test address
7326		    MEM_EXAMINE(.TEST_ADR);	! Read test address - load err adr reg
7327		    MEM_STAT_REG = IO_EXAMINE(MSR);! Read MSR - see what we got
7328		    MEM_STAT_ADR = .MEM_STAT_REG AND %O'17777777';
7329	
7330		    ERR_FLAG = 0;
7331		    IF .MEM_STAT_ADR EQL MSR OR .MEM_STAT_REG GEQ 0
7332			THEN BEGIN		! If either the address was MSR or
7333			     ERR_FLAG = 1;	!   'ERR HOLD' was not set then set
7334			     ECC_SINGLE = 1;	!   error flags and print error message
7335			     NOERR_19 = 1;
7336			     ERRCAS(1,1,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
7337			     END;
7338		    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
7339	
7340		    INCR BTT FROM 14 TO 35 DO	! Now check for single bit errors in 
7341			BEGIN			!   the address and report any found
7342			ERRNO = .BTT - 12;
7343			ERR_TEMP = (.ERR_FLAG EQL 0 AND .TEST_ADR NEQ .MEM_STAT_ADR);
7344			MESSV[1] = .BTT;
7345			TEMP = .MEM_STAT_ADR XOR 1^(35-.BTT);
7346			IF .ERR_TEMP AND (.TEMP EQL .TEST_ADR)
7347			    THEN BEGIN
7348				 TEST_ABORT = 1;
7349				 NOERR_19 = 1;
7350				 ERRCAS(.ERRNO,2,.MSR_CORR,.MEM_STAT_REG,12,MESSV);
7351				 ERR_FLAG = 1;
7352				 END;
7353			IF LOOP_CHK(.ERRNO) THEN LEAVE BLOCK1 WITH 1;
7354			END;
7355	
7356		    TEMP1 = .TEST_ADR OR ADR14_21;	! Now handle multiple errors
7357		    TEMP2 = .MEM_STAT_ADR OR ADR14_21;	!   in flop 1 - report
7358		    ERR_SWITCH = (.ERR_FLAG EQL 0) AND (.TEST_ADR NEQ .MEM_STAT_ADR);
7359		    IF (.TEMP1 EQL .TEMP2) AND (.ERR_SWITCH EQL 1)
7360			THEN BEGIN
7361			     TEST_ABORT = 1;
7362			     NOERR_19 = 1;
7363			     ERRCAS(24,3,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
7364			     ERR_FLAG = 1;
7365			     END;
7366		    IF LOOP_CHK(24) THEN LEAVE BLOCK1 WITH 1;
7367	
7368		    TEMP1 = .TEST_ADR OR ADR22_29;	! Now handle multiple errors
7369		    TEMP2 = .MEM_STAT_ADR OR ADR22_29;	!   in flop 2 - report
7370		    ERR_SWITCH = (.ERR_FLAG EQL 0) AND (.TEST_ADR NEQ .MEM_STAT_ADR);
7371		    IF (.TEMP1 EQL .TEMP2) AND (.ERR_SWITCH EQL 1)
7372			THEN BEGIN
7373			     TEST_ABORT = 1;
7374			     NOERR_19 = 1;
7375			     ERRCAS(25,4,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
7376			     ERR_FLAG = 1;
7377			     END;
7378		    IF LOOP_CHK(25) THEN LEAVE BLOCK1 WITH 1;
7379	
7380		    TEMP1 = .TEST_ADR OR ADR30_35;	! Now handle multiple errors
7381		    TEMP2 = .MEM_STAT_ADR OR ADR30_35;	!   in flop 3 - report
7382		    ERR_SWITCH = (.ERR_FLAG EQL 0) AND (.TEST_ADR NEQ .MEM_STAT_ADR);
7383		    IF (.TEMP1 EQL .TEMP2) AND (.ERR_SWITCH EQL 1)
7384			THEN BEGIN
7385			     TEST_ABORT = 1;
7386			     NOERR_19 = 1;
7387			     ERRCAS(26,5,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
7388			     ERR_FLAG = 1;
7389			     END;
7390		    IF LOOP_CHK(26) THEN LEAVE BLOCK1 WITH 1;
7391	
7392	! If no single or isolated error the whole address must be messed up
7393	!   so report that. 
7394	
7395		    IF .ERR_FLAG EQL 0 AND .TEST_ADR NEQ .MEM_STAT_ADR
7396			THEN BEGIN
7397			     NOERR_19 = 1;
7398			     ERRCAS(27,6,.MSR_CORR,.MEM_STAT_REG,12,TEST_ADR);
7399			     END;
7400			IF LOOP_CHK(27) THEN LEAVE BLOCK1 WITH 1;
7401		    0				! To eliminate INFO compiler message
7402		    END;
7403	
7404	! Clear MMC prior to doing the next part of the loop.
7405	
7406		IO_DEPOSIT(MSR,FORCE_CLR);
7407		END;
7408	
7409	! If Tests 17 and 19 passed then the 'ERR HOLD' logic on MMC5 must be ok
7410	!  so call NOERR and clear that network from the 'possible faulty networks'
7411	!  maintained by STIRS via a call to NOERR.
7412	
7413		IF (.NOERR_17 OR .NOERR_19) EQL 0
7414		    THEN NOERR(1);
7415	
7416	!*MESSAGE 1
7417	!*STIMULUS
7418	!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
7419	!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
7420	!*	LA (ADDR),DM0	Write 0's to mem loc \O0
7421	!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
7422	!*	EI 100000	Examine Mem Status Reg - Should contain memory
7423	!*			  address \O0 (Loaded when ECC error occurred)
7424	!*RESPONSE
7425	!*	'MMC5 ERR HOLD' not set by 'EM' so the address returned in
7426	!*	   Mem Stat Reg is 100000 (MSR)
7427	
7428	!]ERROR 1
7429	!] E3 H4 C5 E5 I5 G6 H6 I8 J8 K8 AA AB  NTWK
7430	!]NO ERROR 1
7431	!] C5  NTWK
7432	
7433	!*MESSAGE 2
7434	!*STIMULUS
7435	!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
7436	!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
7437	!*	LA (ADDR),DM0	Write 0's to mem loc \O0
7438	!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
7439	!*	EI 100000	Examine Mem Status Reg - Should contain memory
7440	!*			  address \O0 (Loaded when ECC error occurred)
7441	!*RESPONSE
7442	!*	Bit \D1 of returned address incorrect
7443	
7444	!]ERROR 2
7445	!] D1 K3 I5 F7 I8  NTWK
7446	!]NO ERROR 2
7447	!]  NTWK
7448	
7449	!]ERROR 3
7450	!] D1 L3 I5 F7 I8  NTWK
7451	!]NO ERROR 3
7452	!]  NTWK
7453	
7454	!]ERROR 4
7455	!] E1 L3 I5 G7 I8  NTWK
7456	!]NO ERROR 4
7457	!]  NTWK
7458	
7459	!]ERROR 5
7460	!] E1 J3 I5 G7 I8  NTWK
7461	!]NO ERROR 5
7462	!]  NTWK
7463	
7464	!]ERROR 6
7465	!] F1 J3 I5 G7 I8  NTWK
7466	!]NO ERROR 6
7467	!]  NTWK
7468	
7469	!]ERROR 7
7470	!] F1 J3 I5 G7 I8  NTWK
7471	!]NO ERROR 7
7472	!]  NTWK
7473	
7474	!]ERROR 8
7475	!] F1 J3 I5 H7 I8  NTWK
7476	!]NO ERROR 8
7477	!]  NTWK
7478	
7479	!]ERROR 9
7480	!] F1 K3 I5 H7 I8  NTWK
7481	!]NO ERROR 9
7482	!]  NTWK
7483	
7484	!]ERROR 10
7485	!] G1 L3 I5 H7 J8  NTWK
7486	!]NO ERROR 10
7487	!]  NTWK
7488	
7489	!]ERROR 11
7490	!] G1 L3 I5 H7 J8  NTWK
7491	!]NO ERROR 11
7492	!]  NTWK
7493	
7494	!]ERROR 12
7495	!] G1 L3 I5 I7 J8  NTWK
7496	!]NO ERROR 12
7497	!]  NTWK
7498	
7499	!]ERROR 13
7500	!] G1 L3 I5 I7 J8  NTWK
7501	!]NO ERROR 13
7502	!]  NTWK
7503	
7504	!]ERROR 14
7505	!] H1 L3 I5 I7 J8  NTWK
7506	!]NO ERROR 14
7507	!]  NTWK
7508	
7509	!]ERROR 15
7510	!] H1 L3 I5 I7 J8  NTWK
7511	!]NO ERROR 15
7512	!]  NTWK
7513	
7514	!]ERROR 16
7515	!] H1 M3 I5 J7 J8  NTWK
7516	!]NO ERROR 16
7517	!]  NTWK
7518	
7519	!]ERROR 17
7520	!] H1 M3 I5 J7 J8  NTWK
7521	!]NO ERROR 17
7522	!]  NTWK
7523	
7524	!]ERROR 18
7525	!] I1 M3 I5 J7 K8  NTWK
7526	!]NO ERROR 18
7527	!]  NTWK
7528	
7529	!]ERROR 19
7530	!] I1 M3 I5 J7 K8  NTWK
7531	!]NO ERROR 19
7532	!]  NTWK
7533	
7534	!]ERROR 20
7535	!] I1 M3 I5 K7 K8  NTWK
7536	!]NO ERROR 20
7537	!]  NTWK
7538	
7539	!]ERROR 21
7540	!] I1 M3 I5 K7 K8  NTWK
7541	!]NO ERROR 21
7542	!]  NTWK
7543	
7544	!]ERROR 22
7545	!] J1 M3 I5 K7 K8  NTWK
7546	!]NO ERROR 22
7547	!]  NTWK
7548	
7549	!]ERROR 23
7550	!] J1 M3 I5 K7 K8  NTWK
7551	!]NO ERROR 23
7552	!]  NTWK
7553	
7554	!*MESSAGE 3
7555	!*STIMULUS
7556	!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
7557	!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
7558	!*	LA (ADDR),DM0	Write 0's to mem loc \O0
7559	!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
7560	!*	EI 100000	Examine Mem Status Reg - Should contain memory
7561	!*			  address \O0 (Loaded when ECC error occurred)
7562	!*RESPONSE
7563	!*	Bits 14..21 of returned address incorrect
7564	
7565	!]ERROR 24
7566	!] J3 K3 L3 N3 I5 I8  NTWK
7567	!]NO ERROR 24
7568	!]  NTWK
7569	
7570	!*MESSAGE 4
7571	!*STIMULUS
7572	!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
7573	!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
7574	!*	LA (ADDR),DM0	Write 0's to mem loc \O0
7575	!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
7576	!*	EI 100000	Examine Mem Status Reg - Should contain memory
7577	!*			  address \O0 (Loaded when ECC error occurred)
7578	!*RESPONSE
7579	!*	Bits 22..29 of returned address incorrect
7580	
7581	!]ERROR 25
7582	!] L3 M3 N3 I5 J8  NTWK
7583	!]NO ERROR 25
7584	!]  NTWK
7585	
7586	!*MESSAGE 5
7587	!*STIMULUS
7588	!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
7589	!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
7590	!*	LA (ADDR),DM0	Write 0's to mem loc \O0
7591	!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
7592	!*	EI 100000	Examine Mem Status Reg - Should contain memory
7593	!*			  address \O0 (Loaded when ECC error occurred)
7594	!*RESPONSE
7595	!*	Bits 30..35 of returned address incorrect
7596	
7597	!]ERROR 26
7598	!] M3 N3 I5 K8  NTWK
7599	!]NO ERROR 26
7600	!]  NTWK
7601	
7602	!*MESSAGE 6
7603	!*STIMULUS
7604	!*	LI 100000	Write Mem Status Reg:  Clear Err Hold bit,
7605	!*	DI 400000000376	  Set force bits 1'S (Single bit err), ECC on
7606	!*	LA (ADDR),DM0	Write 0's to mem loc \O0
7607	!*	EM (ADDR)	Examine mem loc \O0 (Cause a single bit error)
7608	!*	EI 100000	Examine Mem Status Reg - Should contain memory
7609	!*			  address \O0 (Loaded when ECC error occurred)
7610	!*RESPONSE
7611	!*	Bits 14-35 of returned address incorrect (multiple bit errors
7612	!*	  not matching any particular chip)
7613	
7614	!]ERROR 27
7615	!] J3 K3 L3 M3 N3 I5 F7 G7 H7 I7 J7 K7 L7 I8 J8 K8  NTWK
7616	!]NO ERROR 27
7617	!]  NTWK
7618	
7619	END;
7620	GLOBAL ROUTINE TST20: NOVALUE =
7621	
7622	!++   ----------------------- 'FORCE BITS' --------------------------
7623	! TEST DESCRIPTION:   This  routine  tests  the 'FORCE BITS' that are
7624	!	written to the MMC board by a write status.  They are used to
7625	!	calculate the 7 bit ECC code along with bits 00-35. In normal
7626	!	operation the force bits are all 0.  When an ECC error occurs
7627	!	(only during a read) the  memory  address being accessed gets
7628	!	loaded into an error register on MMC8.  Also  the  check bits
7629	!	are loaded into an error register on MMC4. Then a read status
7630	!	can be done to access the check bits which should be the same
7631	!	as the force bits.
7632	!
7633	! TEST ASSUMPTIONS:  None.
7634	!
7635	! TEST PROCEDURE:  MR
7636	!		   Write status (Force bits 1111110)
7637	!		   Write 0's to mem loc 33
7638	!		   Read mem loc 33 (Causes ECC error)
7639	!		   Read status and verify force bits and address
7640	!
7641	! POSSIBLE ERRORS:  Incorrect force bits returned - 'MMC3 FORCE' register,
7642	!			'MMC4 ERR' check bits register, 'MMC4 FORCE' 2x4
7643	!			mixers, or MMC7 4x2 mixers faulty
7644	!		    Incorrect Err Address - MMC7 4x2 mixers, 'MMC8 ERR
7645	!			ADDR' register faulty
7646	!
7647	!--
7648	
7649	BEGIN
7650	
7651	LITERAL
7652		RESET = %O'700000000000',	! Clear 'ERR HOLD','REF ERR','PE'
7653		FORCE_ONES = %O'700040000374',	! Write force bits all ones to MSR
7654		LFOR = %O'761777777777',	! Masks for isolating force bit errors
7655		RFOR = %O'777077777777',	!   to flops on MMC4 or mixers on MMC7.
7656		LFORA = %O'760777777777',	!   LFOR,RFORA - mixers on MMC7.
7657		RFORA = %O'776077777777',	!   LFORA,RFOR - flops on MMC4.  
7658		BITS14_21 = %O'000017740000',	! Error address bit masks corresponding
7659		BITS22_29 = %O'000000037700',	!   to three flops on MMC8
7660		BITS30_35 = %O'000000000077';	!	...
7661	
7662	LOCAL
7663		ERR_OCC,			! Flag to say 'an error occurred'
7664		ERR_FLAG,			! Error flag
7665		TEMP;
7666	
7667	OWN
7668		MESSV,				! Error message output data
7669		STRUCT: VECTOR[5]		! For use in structure declarations
7670		    INITIAL (14,20,22,28,30),	!   STR1,STR2 for mapping error address
7671		MEM_TEMP_VECT: BTTVECTOR[36],
7672		MSR_CORR_VECT: BTTVECTOR[36],
7673		MEM_STAT_VECT: BTTVECTOR[36],
7674	
7675	! Error message strings - MESS_STR and MESS_WSTR
7676	
7677		MESS_STR: VECTOR[12]
7678		    INITIAL(UPLIT(%ASCIZ ' CP'),UPLIT(%ASCIZ ' C40'),
7679			    UPLIT(%ASCIZ ' C20'),UPLIT(%ASCIZ ' C10'),
7680			    UPLIT(%ASCIZ ' C4'),UPLIT(%ASCIZ ' C2'),
7681			    UPLIT(%ASCIZ ' C1'),UPLIT(%ASCIZ 's CP,C40,C20'),
7682			    UPLIT(%ASCIZ 's C4,C2,C1'),UPLIT(%ASCIZ 's CP,C40,C20,C10'),
7683			    UPLIT(%ASCIZ 's C10,C4,C2,C1'),
7684			    UPLIT(%ASCIZ 's CP,C40,C20,C10,C4,C2,C1')),
7685		MESS_WSTR: VECTOR[14]
7686		    INITIAL(UPLIT(%ASCIZ '14,15'),UPLIT(%ASCIZ '20,21'),
7687			    UPLIT(%ASCIZ '22,23'),UPLIT(%ASCIZ '28,29'),
7688			    UPLIT(%ASCIZ '30,31'),UPLIT(%ASCIZ '16..19'),
7689			    UPLIT(%ASCIZ '20..23'),UPLIT(%ASCIZ '24..27'),
7690			    UPLIT(%ASCIZ '28..31'),UPLIT(%ASCIZ '32..35'),
7691			    UPLIT(%ASCIZ '14..21'),UPLIT(%ASCIZ '22..29'),
7692			    UPLIT(%ASCIZ '30..35'),UPLIT(%ASCIZ '14..35'));
7693	
7694	STRUCTURE
7695		STR1[I;N] = [N]
7696		    (STR1)<34-.STRUCT[I],2>,
7697		STR2[I;N] = [N]
7698		    (STR2)<32-I*4-16,4>;
7699	
7700	OWN
7701		MEM_TEMP1_VECT: STR1[1],
7702		MEM_TEMP2_VECT: STR2[1],
7703		TEST1_VECT: STR1[1],
7704		TEST2_VECT: STR2[1];
7705	
7706	BIND
7707		MSR_CORR = MSR_CORR_VECT,
7708		MEM_STAT = MEM_STAT_VECT,
7709		MEM_TEMP = MEM_TEMP_VECT,
7710		MEM_TEMP1 = MEM_TEMP1_VECT,
7711		MEM_TEMP2 = MEM_TEMP2_VECT,
7712		T1_VECT = TEST1_VECT,
7713		T2_VECT = TEST2_VECT;
7714	
7715	LABEL
7716		BLOCK1;
7717	
7718	IF RUN_TEST(20) THEN RETURN;		! Run this test? Return if no
7719	
7720	NOERR_20 = 0;				! No errors have occurred yet
7721	RPT_ERR_FLAG = 0;			! Don't report unexpected error
7722	
7723	DO (0) WHILE
7724	BLOCK1:	BEGIN
7725		MR();				! Master Reset
7726		IO_DEPOSIT(MSR,FORCE_ONES);	! Write force bits to MMC board
7727		DM(33,0);			! Write 0's to mem loc 33 then read it
7728		TEMP = EM(33);			!   back (causes double bit ECC error)
7729		MSR_CORR = %O'637600000033';	! Correct contents of MSR
7730		MEM_STAT = IO_EXAMINE(MSR);	! Actual contents of MSR
7731	
7732	! First check out the first 5 bits of the result - 'ERR HOLD','UNCOR ERR HOLD',
7733	!   'REFRESH ERR','PARITY ERR','ECC'.
7734	
7735		IF .MEM_STAT_VECT[0] NEQ 1	! 'ERR HOLD' should be asserted - if
7736		    THEN BEGIN			!   not - set error flags and print
7737			 ECC_DOUBLE = 1;	!   error message.
7738			 NOERR_20 = 1;
7739			 ERRCA(1,.MSR_CORR,.MEM_STAT,12);
7740			 END;
7741		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
7742	
7743		IF .MEM_STAT_VECT[1] NEQ 1	! 'UNCOR ERR HOLD' should be asserted
7744		    THEN BEGIN			! If not - set error flag and print
7745			 NOERR_20 = 1;		!   error message.
7746			 ERRCA(2,.MSR_CORR,.MEM_STAT,12);
7747			 END;
7748		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
7749	
7750		IF .MEM_STAT_VECT[2] NEQ 0	! 'REF ERR' should not be asserted.
7751		    THEN BEGIN			! If it is - set error flag and print
7752			 NOERR_20 = 1;		!   error message.
7753			 ERRCA(3,.MSR_CORR,.MEM_STAT,12);
7754			 END;
7755		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
7756	
7757		IF .MEM_STAT_VECT[3] NEQ 0	! 'PARITY ERR' should not be asserted.
7758		    THEN BEGIN			! If it is - set error flag and print
7759			 NOERR_20 = 1;		!   error message.
7760			 ERRCA(4,.MSR_CORR,.MEM_STAT,12);
7761			 END;
7762		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
7763	
7764		IF .MEM_STAT_VECT[4] NEQ 1	! 'ECC' should still be on - If it
7765		    THEN BEGIN			!   isn't - set error flags and print
7766			 TEST_ABORT = 1;	!   error message.
7767			 NOERR_20 = 1;
7768			 ERRCA(5,.MSR_CORR,.MEM_STAT,12);
7769			 END;
7770		IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
7771	
7772	! Secondly, check out the next 7 bits - force bits.
7773	
7774	! Now mask out everything except for the force bits and verify that they are
7775	!   correct.  If not correct report the error and set error flag.  This only
7776	!   checks a single bit error (only one bit is in error).
7777	
7778		MEM_TEMP = .MEM_STAT OR %O'017600000000';
7779		ERR_FLAG = 0;
7780		INCR ERRR FROM 5 TO 11 DO
7781		    BEGIN
7782		    IF .MEM_TEMP EQL (.MEM_STAT XOR 1^(35-.ERRR))
7783			THEN BEGIN
7784			     MESSV = .MESS_STR[.ERRR-5];
7785			     NOERR_20 = 1;
7786			     ERRCAS(.ERRR+1,6,.MSR_CORR,.MEM_STAT,12,MESSV);
7787			     ERR_FLAG = 1;
7788			     END;
7789		    IF LOOP_CHK(.ERRR+1) THEN LEAVE BLOCK1 WITH 1;
7790		    END;
7791	
7792	! If an error did occur but we have not yet reported it then the fault
7793	!   could be a multiple bit error in one of the chips that holds the
7794	!   force bits. So first check LFOR - left 3 bits which are a complete
7795	!   mixer on MMC7 and part of a flop on MMC7.
7796	
7797		ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
7798		IF ((.MEM_TEMP AND LFOR) EQL (.MEM_STAT AND LFOR)) AND .ERR_OCC
7799		    THEN BEGIN
7800			 MESSV = .MESS_STR[7];
7801			 NOERR_20 = 1;
7802			 ERRCAS(13,6,.MSR_CORR,.MEM_STAT,12,MESSV);
7803			 ERR_FLAG = 1;
7804			 END;
7805		IF LOOP_CHK(13) THEN LEAVE BLOCK1 WITH 1;
7806	
7807	! Now check RFOR - right 3 bits which are a complete flop on MMC4 and
7808	!   and part of a mixer on MMC7.
7809	
7810		ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
7811		IF ((.MEM_TEMP AND RFOR) EQL (.MEM_STAT AND RFOR)) AND .ERR_OCC
7812		    THEN BEGIN
7813			 MESSV = .MESS_STR[8];
7814			 NOERR_20 = 1;
7815			 ERRCAS(14,6,.MSR_CORR,.MEM_STAT,12,MESSV);
7816			 ERR_FLAG = 1;
7817			 END;
7818		IF LOOP_CHK(14) THEN LEAVE BLOCK1 WITH 1;
7819	
7820	! Now check LFORA - left 4 bits which are a complete mixer on MMC7 and
7821	!   and more than a flop on MMC4.
7822	
7823		ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
7824		IF ((.MEM_TEMP AND LFORA) EQL (.MEM_STAT AND LFORA)) AND .ERR_OCC
7825		    THEN BEGIN
7826			 MESSV = .MESS_STR[9];
7827			 NOERR_20 = 1;
7828			 ERRCAS(15,6,.MSR_CORR,.MEM_STAT,12,MESSV);
7829			 ERR_FLAG = 1;
7830			 END;
7831		IF LOOP_CHK(15) THEN LEAVE BLOCK1 WITH 1;
7832	
7833	! Now check RFORA - left 4 bits which are a complete flop on MMC4 and
7834	!   and more than a mixer on MMC7.
7835	
7836		ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
7837		IF ((.MEM_TEMP AND RFORA) EQL (.MEM_STAT AND RFORA)) AND .ERR_OCC
7838		    THEN BEGIN
7839			 MESSV = .MESS_STR[10];
7840			 NOERR_20 = 1;
7841			 ERRCAS(16,6,.MSR_CORR,.MEM_STAT,12,MESSV);
7842			 ERR_FLAG = 1;
7843			 END;
7844		IF LOOP_CHK(16) THEN LEAVE BLOCK1 WITH 1;
7845	
7846	! Now if no particular errors have been determined so far yet a fault
7847	!   fault really does exist then just report the error.  The fault
7848	!   isolation really can't narrow down on very much however.
7849	
7850		IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
7851		    THEN BEGIN
7852			 MESSV = .MESS_STR[11];
7853			 NOERR_20 = 1;
7854			 ERRCAS(17,6,.MSR_CORR,.MEM_STAT,12,MESSV);
7855			 END;
7856		IF LOOP_CHK(17) THEN LEAVE BLOCK1 WITH 1;
7857	
7858	! Thirdly, check out bit 12 - 'POWER FAIL'.
7859	
7860		IF .MEM_STAT_VECT[12] NEQ 0	! 'POWER FAIL' should not be asserted.
7861		    THEN BEGIN			! If it is - set error flags and print
7862			 NOERR_20 = 1;		!    error message.
7863			 ERRCAS(18,7,.MSR_CORR,.MEM_STAT,12,MESSV);
7864			 END;
7865		IF LOOP_CHK(18) THEN LEAVE BLOCK1 WITH 1;
7866	
7867	! Fourthly check out the remainder of the MSR contents - bits 14 .. 35
7868	!   the error address.
7869	
7870	! If error address register is loaded indiscriminately it may contain the
7871	!   last address sent off to MMC board which is 100000 (address of MSR) so
7872	!   check it out.
7873	
7874		ERR_FLAG = 0;
7875		MEM_TEMP = .MEM_STAT AND %O'777740000033';
7876		IF .MEM_TEMP<0,22> EQL MSR	! If error address is 100000 - set
7877		    THEN BEGIN			!   error flags and print error
7878			 ERR_FLAG = 1;		!   message.
7879			 NOERR_20 = 1;
7880			 ERRCAS(19,8,.MSR_CORR,.MEM_STAT,12,MESSV);
7881			 END;
7882	
7883	! Now check for a single bit error in the address.  If there is a single
7884	!   bit in error (none others incorrect) then set error flags and print
7885	!   error message.
7886	
7887		INCR ERRR FROM 14 TO 35 DO
7888		    BEGIN
7889		    IF .MEM_TEMP EQL (.MEM_STAT XOR 1^(35-.ERRR))
7890			THEN BEGIN
7891			     TEST_ABORT = 1;
7892			     NOERR_20 = 1;
7893			     ERRCAS(.ERRR+6,9,.MSR_CORR,.MEM_STAT,12,ERRR);
7894			     ERR_FLAG = 1;
7895			     END;
7896		    IF LOOP_CHK(.ERRR+5) THEN LEAVE BLOCK1 WITH 1;
7897		    END;
7898	
7899	! There is a multiple bit error in the error address (if there is one at all)
7900	!   so check various bit combinations which are the bits which are common to
7901	!   both the mixers on MMC7 and the error address register on MMC8.  This is
7902	!   the 5 bit combinations which happen to be 2 bits wide - and hence can be
7903	!   represented by a data structure T1_VECT and TEST1_VECT.
7904	! If any errors are found - set error flags and print error message.
7905	
7906		INCR ERRR FROM 0 TO 4 DO
7907		    BEGIN
7908		    IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
7909			THEN BEGIN
7910			     T1_VECT = .MEM_STAT;
7911			     TEST1_VECT[.ERRR] = 0;
7912			     MEM_TEMP1 = .MEM_TEMP;
7913			     MEM_TEMP1_VECT[.ERRR] = 0;
7914			     IF .MEM_TEMP1 EQL .T1_VECT
7915				THEN BEGIN
7916				     MESSV = .MESS_WSTR[.ERRR];
7917				     TEST_ABORT = 1;
7918				     NOERR_20 = 1;
7919				     ERRCAS(.ERRR+42,10,.MSR_CORR,.MEM_STAT,12,MESSV);
7920				     ERR_FLAG = 1;
7921				     END;
7922			     END;
7923		    IF LOOP_CHK(.ERRR+42) THEN LEAVE BLOCK1 WITH 1;
7924		    END;
7925	
7926	! As above but we now are done with the 2 bit combinations so go to the 4 bit
7927	!   combinations which match the mixers on MMC7 and are subsets of the error
7928	!   address register on MMC8.
7929	! If any errors are found - set error flags and print error message.
7930	
7931		INCR ERRR FROM 0 TO 4 DO
7932		    BEGIN
7933		    IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
7934			THEN BEGIN
7935			     T2_VECT = .MEM_STAT;
7936			     TEST2_VECT[.ERRR] = 0;
7937			     MEM_TEMP2 = .MEM_TEMP;
7938			     MEM_TEMP2_VECT[.ERRR] = 0;
7939			     IF .MEM_TEMP2 EQL .T2_VECT
7940				THEN BEGIN
7941				     MESSV = .MESS_WSTR[.ERRR+5];
7942				     TEST_ABORT = 1;
7943				     NOERR_20 = 1;
7944				     ERRCAS(.ERRR+47,10,.MSR_CORR,.MEM_STAT,12,MESSV);
7945				     ERR_FLAG = 1;
7946				     END;
7947			     END;
7948		    IF LOOP_CHK(.ERRR+47) THEN LEAVE BLOCK1 WITH 1;
7949		    END;
7950	
7951	! So far (if no errors have occurred yet) the fault (if there is one) is a
7952	!   multiple bit error which covers a larger area than we have already looked
7953	!   at.  So now we check to see if the error is a multiple bit error probably
7954	!   involving the control logic on one of the three error address register 
7955	!   chips on MMC8.  First check bits 14..21.
7956	! If any errors are found - set error flags and print error message.
7957	
7958		ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
7959		IF ((.MEM_TEMP OR BITS14_21) EQL (.MEM_STAT OR BITS14_21)) AND .ERR_OCC
7960		    THEN BEGIN
7961			 MESSV = .MESS_WSTR[10];
7962			 TEST_ABORT = 1;
7963			 NOERR_20 = 1;
7964			 ERRCA(52,11,.MSR_CORR,.MEM_STAT,12,MESSV);
7965			 ERR_FLAG = 1;
7966			 END;
7967		IF LOOP_CHK(52) THEN LEAVE BLOCK1 WITH 1;
7968	
7969	! Now check bits 22..29 of error address register as described above.
7970	! If any errors are found - set error flags and print error message.
7971	
7972		ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
7973		IF ((.MEM_TEMP OR BITS22_29) EQL (.MEM_STAT OR BITS22_29)) AND .ERR_OCC
7974		    THEN BEGIN
7975			 MESSV = .MESS_WSTR[11];
7976			 TEST_ABORT = 1;
7977			 NOERR_20 = 1;
7978			 ERRCA(53,11,.MSR_CORR,.MEM_STAT,12,MESSV);
7979			 ERR_FLAG = 1;
7980			 END;
7981		IF LOOP_CHK(53) THEN LEAVE BLOCK1 WITH 1;
7982	
7983	! Now check bits 30..35 of error address register as described above.
7984	! If any errors are found - set error flags and print error message.
7985	
7986		ERR_OCC = (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP);
7987		IF ((.MEM_TEMP OR BITS30_35) EQL (.MEM_STAT OR BITS30_35)) AND .ERR_OCC
7988		    THEN BEGIN
7989			 MESSV = .MESS_WSTR[12];
7990			 NOERR_20 = 1;
7991			 ERRCA(54,11,.MSR_CORR,.MEM_STAT,12,MESSV);
7992			 ERR_FLAG = 1;
7993			 END;
7994		IF LOOP_CHK(54) THEN LEAVE BLOCK1 WITH 1;
7995	
7996	! If still no errors have been isolated and there is a fault somewhere
7997	!   there is not much to do except report the results in a generalized
7998	!   error message - there are multiple bit errors in strange places
7999	!   which probably means this board has multiple faults on it.
8000	! If any errors are found - set error flags and print error message.
8001	
8002		IF (.ERR_FLAG EQL 0) AND (.MEM_STAT NEQ .MEM_TEMP)
8003		    THEN BEGIN
8004			 MESSV = .MESS_WSTR[13];
8005			 NOERR_20 = 1;
8006			 ERRCAS(55,11,.MSR_CORR,.MEM_STAT,12,MESSV);
8007			 END;
8008		IF LOOP_CHK(55) THEN LEAVE BLOCK1 WITH 1;
8009	
8010	! All done testing.  Now just reset the board particularly in regard to
8011	!   'UNCOR ERR HOLD' in the MSR which can be cleared only by doing a
8012	!   deposit followed by an examine after a reset has been done.
8013	
8014		IO_DEPOSIT(MSR,RESET);		! Clear the error bits in MSR on MMC
8015		DM(0,0);			! Write 0's to mem loc 0
8016		EM(0);				! Read mem loc 0 (should shut off
8017		0				! To eliminate INFO compiler message
8018		END;				!   'UNCOR ERR HOLD'
8019	
8020	! If Tests 17 and 20 both passed then 'MMC5 ERR HOLD' logic is ok.
8021	
8022		IF (.NOERR_17 OR .NOERR_20) EQL 0 THEN NOERR(1);
8023	
8024	!*MESSAGE 1
8025	!*STIMULUS
8026	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8027	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8028	!*	LA 33,DM 33	Write 0's to mem loc 33
8029	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8030	!*	EI 100000	Read MSR - 'MMC5 ERR HOLD' should be asserted
8031	!*RESPONSE
8032	!*	'MMC5 ERR HOLD' bit 00 not asserted
8033	
8034	!]ERROR 1
8035	!] E3 H4 C5 E5 F5 G5 G6 H6 C7  NTWK
8036	!]NO ERROR 1
8037	!] C5  NTWK
8038	
8039	!*MESSAGE 2
8040	!*STIMULUS
8041	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8042	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8043	!*	LA 33,DM 33	Write 0's to mem loc 33
8044	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8045	!*	EI 100000	Read MSR - 'MMC4 UNCOR ERR HOLD' should be set
8046	!*RESPONSE
8047	!*	'MMC4 UNCOR ERR HOLD' bit 01 not asserted
8048	
8049	!]ERROR 2
8050	!] E3 H3 H4 J4 C5 E5 F5 G5 H5 G6 H6 C7  NTWK
8051	!]NO ERROR 2
8052	!]  NTWK
8053	
8054	!*MESSAGE 3
8055	!*STIMULUS
8056	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8057	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8058	!*	LA 33,DM 33	Write 0's to mem loc 33
8059	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8060	!*	EI 100000	Read MSR - 'MMC9 REF ERR' should not be asserted
8061	!*RESPONSE
8062	!*	'MMC9 REF ERR' bit 02 asserted
8063	
8064	!]ERROR 3
8065	!] E3 H3 C7 A9 B9 C9  NTWK
8066	!]NO ERROR 3
8067	!]  NTWK
8068	
8069	!*MESSAGE 4
8070	!*STIMULUS
8071	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8072	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8073	!*	LA 33,DM 33	Write 0's to mem loc 33
8074	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8075	!*	EI 100000	Read MSR - 'MMC7 PARITY ERR' should not be asserted
8076	!*RESPONSE
8077	!*	'MMC7 PARITY ERR' bit 03 asserted
8078	
8079	!]ERROR 4
8080	!] A_J1 N1 B7 C7  NTWK
8081	!]NO ERROR 4
8082	!]  NTWK
8083	
8084	!*MESSAGE 5
8085	!*STIMULUS
8086	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8087	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8088	!*	LA 33,DM 33	Write 0's to mem loc 33
8089	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8090	!*	EI 100000	Read MSR - 'MMC3 ECC ON' should be asserted
8091	!*RESPONSE
8092	!*	'MMC3 ECC ON' bit 04 not asserted
8093	
8094	!]ERROR 5
8095	!] B1 E3 H3 D7  NTWK
8096	!]NO ERROR 5
8097	!]  NTWK
8098	
8099	!*MESSAGE 6
8100	!*STIMULUS
8101	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8102	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8103	!*	LA 33,DM 33	Write 0's to mem loc 33
8104	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8105	!*	EI 100000	Read MSR - 'MMC4 ERR' check bits should be 1111110
8106	!*RESPONSE
8107	!*	'MMC4 ERR' check bit\S0 incorrect
8108	
8109	!]ERROR 6
8110	!] B1 E3 H3 A4 H4 I4 C5 E5 F5 G5 G6 H6 D7  NTWK
8111	!]NO ERROR 6
8112	!]  NTWK
8113	
8114	!]ERROR 7
8115	!] B1 E3 H3 B4 H4 I4 K4 C5 E5 F5 G5 G6 H6 D7  NTWK
8116	!]NO ERROR 7
8117	!]  NTWK
8118	
8119	!]ERROR 8
8120	!] B1 E3 H3 C4 H4 I4 L4 C5 E5 F5 G5 G6 H6 D7  NTWK
8121	!]NO ERROR 8
8122	!]  NTWK
8123	
8124	!]ERROR 9
8125	!] C1 E3 H3 D4 H4 I4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
8126	!]NO ERROR 9
8127	!]  NTWK
8128	
8129	!]ERROR 10
8130	!] C1 E3 H3 E4 H4 I4 K4 C5 E5 F5 G5 G6 H6 E7  NTWK
8131	!]NO ERROR 10
8132	!]  NTWK
8133	
8134	!]ERROR 11
8135	!] C1 E3 H3 F4 H4 I4 L4 C5 E5 F5 G5 G6 H6 E7  NTWK
8136	!]NO ERROR 11
8137	!]  NTWK
8138	
8139	!]ERROR 12
8140	!] C1 E3 H3 G4 H4 I4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
8141	!]NO ERROR 12
8142	!]  NTWK
8143	
8144	!]ERROR 13
8145	!] E3 H3 A4 B4 C4 H4 I4 K4 L4 C5 E5 F5 G5 G6 H6 D7  NTWK
8146	!]NO ERROR 13
8147	!]  NTWK
8148	
8149	!]ERROR 14
8150	!] E3 H3 E4 F4 G4 H4 I4 K4 L4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
8151	!]NO ERROR 14
8152	!]  NTWK
8153	
8154	!]ERROR 15
8155	!] E3 H3 A4 B4 C4 D4 H4 I4 K4 L4 M4 C5 E5 F5 G5 G6 H6 D7 E7  NTWK
8156	!]NO ERROR 15
8157	!]  NTWK
8158	
8159	!]ERROR 16
8160	!] E3 H3 D4 E4 F4 G4 H4 I4 K4 L4 M4 C5 E5 F5 G5 G6 H6 E7  NTWK
8161	!]NO ERROR 16
8162	!]  NTWK
8163	
8164	!]ERROR 17
8165	!] E3 H3 A_H4 K4 L4 M4 I4 C5 E5 F5 G5 G6 H6 D7 E7  NTWK
8166	!]NO ERROR 17
8167	!]  NTWK
8168	
8169	!*MESSAGE 7
8170	!*STIMULUS
8171	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8172	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8173	!*	LA 33,DM 33	Write 0's to mem loc 33
8174	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8175	!*	EI 100000	Read MSR - 'MMC5 POWER FAILED' should not be asserted
8176	!*RESPONSE
8177	!*	'MMC5 POWER FAILED' bit 12 asserted
8178	
8179	!]ERROR 18
8180	!] A5 F7  NTWK
8181	!]NO ERROR 18
8182	!]  NTWK
8183	
8184	!*MESSAGE 8
8185	!*STIMULUS
8186	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8187	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8188	!*	LA 33,DM 33	Write 0's to mem loc 33
8189	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8190	!*	EI 100000	Read MSR - 'MMC8 ERR ADDR' should be 0
8191	!*RESPONSE
8192	!*	'MMC8 ERR ADDR' is 100000 (Mem Stat Reg)
8193	
8194	!]ERROR 19
8195	!] E3 H3 H4 C5 E5 F5 G5 I5 G6 H6 I8 J8 K8  NTWK
8196	!]NO ERROR 19
8197	!]  NTWK
8198	
8199	!*MESSAGE 9
8200	!*STIMULUS
8201	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8202	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8203	!*	LA 33,DM 33	Write 0's to mem loc 33
8204	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8205	!*	EI 100000	Read MSR - 'MMC8 ERR ADDR' should be 0
8206	!*RESPONSE
8207	!*	'MMC8 ERR ADDR' bit \D0 incorrect
8208	
8209	!]ERROR 20
8210	!] D1 F7 I8  NTWK
8211	!]NO ERROR 20
8212	!]  NTWK
8213	
8214	!]ERROR 21
8215	!] D1 F7 I8  NTWK
8216	!]NO ERROR 21
8217	!]  NTWK
8218	
8219	!]ERROR 22
8220	!] E1 G7 I8  NTWK
8221	!]NO ERROR 22
8222	!]  NTWK
8223	
8224	!]ERROR 23
8225	!] E1 G7 I8  NTWK
8226	!]NO ERROR 23
8227	!]  NTWK
8228	
8229	!]ERROR 24
8230	!] F1 G7 I8  NTWK
8231	!]NO ERROR 24
8232	!]  NTWK
8233	
8234	!]ERROR 25
8235	!] F1 G7 I8  NTWK
8236	!]NO ERROR 25
8237	!]  NTWK
8238	
8239	!]ERROR 26
8240	!] F1 H7 I8  NTWK
8241	!]NO ERROR 26
8242	!]  NTWK
8243	
8244	!]ERROR 27
8245	!] F1 H7 I8  NTWK
8246	!]NO ERROR 27
8247	!]  NTWK
8248	
8249	!]ERROR 28
8250	!] G1 H7 J8  NTWK
8251	!]NO ERROR 28
8252	!]  NTWK
8253	
8254	!]ERROR 29
8255	!] G1 H7 J8  NTWK
8256	!]NO ERROR 29
8257	!]  NTWK
8258	
8259	!]ERROR 30
8260	!] G1 I7 J8  NTWK
8261	!]NO ERROR 30
8262	!]  NTWK
8263	
8264	!]ERROR 31
8265	!] G1 I7 J8  NTWK
8266	!]NO ERROR 31
8267	!]  NTWK
8268	
8269	!]ERROR 32
8270	!] H1 I7 J8  NTWK
8271	!]NO ERROR 32
8272	!]  NTWK
8273	
8274	!]ERROR 33
8275	!] H1 I7 J8  NTWK
8276	!]NO ERROR 33
8277	!]  NTWK
8278	
8279	!]ERROR 34
8280	!] H1 J7 J8  NTWK
8281	!]NO ERROR 34
8282	!]  NTWK
8283	
8284	!]ERROR 35
8285	!] H1 J7 J8  NTWK
8286	!]NO ERROR 35
8287	!]  NTWK
8288	
8289	!]ERROR 36
8290	!] I1 J7 K8  NTWK
8291	!]NO ERROR 36
8292	!]  NTWK
8293	
8294	!]ERROR 37
8295	!] I1 J7 K8  NTWK
8296	!]NO ERROR 37
8297	!]  NTWK
8298	
8299	!]ERROR 38
8300	!] I1 K7 K8  NTWK
8301	!]NO ERROR 38
8302	!]  NTWK
8303	
8304	!]ERROR 39
8305	!] I1 K7 K8  NTWK
8306	!]NO ERROR 39
8307	!]  NTWK
8308	
8309	!]ERROR 40
8310	!] J1 K7 K8  NTWK
8311	!]NO ERROR 40
8312	!]  NTWK
8313	
8314	!]ERROR 41
8315	!] J1 K7 K8  NTWK
8316	!]NO ERROR 41
8317	!]  NTWK
8318	
8319	!*MESSAGE 10
8320	!*STIMULUS
8321	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111110,
8322	!*	DI 700040000374	  Turn on ECC, clear Err Hold, Ref Eff
8323	!*	LA 33,DM 33	Write 0's to mem loc 33
8324	!*	EM 33		Read mem loc 33 (Cause double bit ECC error)
8325	!*	EI 100000	Read MSR - 'MMC8 ERR ADDR' should be 0
8326	!*RESPONSE
8327	!*	'MMC8 ERR ADDR' bits \S0 incorrect
8328	
8329	!]ERROR 42
8330	!] F7 I8  NTWK
8331	!]NO ERROR 42
8332	!]  NTWK
8333	
8334	!]ERROR 43
8335	!] H7 I8  NTWK
8336	!]NO ERROR 43
8337	!]  NTWK
8338	
8339	!]ERROR 44
8340	!] H7 J8  NTWK
8341	!]NO ERROR 44
8342	!]  NTWK
8343	
8344	!]ERROR 45
8345	!] J7 J8  NTWK
8346	!]NO ERROR 45
8347	!]  NTWK
8348	
8349	!]ERROR 46
8350	!] J7 K8  NTWK
8351	!]NO ERROR 46
8352	!]  NTWK
8353	
8354	!]ERROR 47
8355	!] G7 I8  NTWK
8356	!]NO ERROR 47
8357	!]  NTWK
8358	
8359	!]ERROR 48
8360	!] H7 I8 J8  NTWK
8361	!]NO ERROR 48
8362	!]  NTWK
8363	
8364	!]ERROR 49
8365	!] I7 J8  NTWK
8366	!]NO ERROR 49
8367	!]  NTWK
8368	
8369	!]ERROR 50
8370	!] J7 J8 K8  NTWK
8371	!]NO ERROR 50
8372	!]  NTWK
8373	
8374	!]ERROR 51
8375	!] K7 K8  NTWK
8376	!]NO ERROR 51
8377	!]  NTWK
8378	
8379	!]ERROR 52
8380	!] F7 G7 H7 I8  NTWK
8381	!]NO ERROR 52
8382	!]  NTWK
8383	
8384	!]ERROR 53
8385	!] H7 I7 J7 J8  NTWK
8386	!]NO ERROR 53
8387	!]  NTWK
8388	
8389	!]ERROR 54
8390	!] E3 G3 H3 I5 J7 K7 K8  NTWK
8391	!]NO ERROR 54
8392	!]  NTWK
8393	
8394	!]ERROR 55
8395	!] E3 G3 H3 I5 F7 G7 H7 I7 J7 K7 I8 J8 K8  NTWK
8396	!]NO ERROR 55
8397	!]  NTWK
8398	
8399	END;
8400	GLOBAL ROUTINE TST21: NOVALUE =
8401	
8402	!++   ------------ ECC:  PARITY GENERATORS FOR CHECK BITS ---------
8403	! TEST DESCRIPTION:  This routine verifies the parity generators on
8404	!	MMC4 which generate the check bits on a read or on a write.
8405	!	In addition  the 'MMC4 ERR'  check bits holding register is
8406	!	implicitly  checked since no difference between the two can
8407	!	be detected.  Since ECC errors could exist on the MMA board
8408	!	this test is attempted on 3 different memory  locations and
8409	!	the condition which is most prevalent is used as the memory
8410	!	location on which to base the results and is  assumed to be
8411	!	unaffected by ECC errors.
8412	!
8413	! TEST ASSUMPTIONS:  None.
8414	!
8415	! TEST PROCEDURE:  MR
8416	!		   Write status to MMC board - Set force bits (1111111)
8417	!		   Write 1's to mem location 040000,100000,140000
8418	!		   For each memory location do:
8419	!			Examine mem loc (Causes ECC error)
8420	!			Read Mem Status Reg and see if force bits are
8421	!				equal to 1's
8422	!		   If number of matches (check bits are 1's) is
8423	!			greater than 1 then no error exists. Otherwise
8424	!			determine which error exists in one of the
8425	!			error cases.
8426	!
8427	! POSSIBLE ERRORS:  8-D-FLOP chip on MMC4 which holds the check bits
8428	!			is bad
8429	!		    1 or more of the sets of chips which generate the
8430	!			check bits (each set consists of 2 parity
8431	!			generators and 2 xor gates)
8432	!
8433	!--
8434	
8435	BEGIN
8436	
8437	LITERAL
8438		ECC_ON_FORCE = %O'700000000376'; ! Set force bits 1's, turn on ECC
8439	
8440	MACRO
8441		FORCE = 24,7,0%;		! Force bits byte pointer in MSR word
8442	
8443	LOCAL
8444		ERR_FLAG,			! Error flag
8445		MEM_CORR,			! Correct data back from memory
8446		NUM_ERR,			! Number of errors which have occurred
8447		MEM_STAT,			! Mem Status Register
8448		MEM_DATA,			! Data written to memory
8449		TEMP;
8450	
8451	OWN
8452		MESSV: VECTOR[2],		! Error message output string
8453		LAST_STAT,			! MSR from the last try
8454		LAST_ERR,			! Error address from the last try
8455		LAST_FORCE,			! Force bits from the last try
8456		TEST_ADR: VECTOR[3]		! Test addresses to use
8457		    INITIAL (%O'040000',%O'100000',%O'140000'),
8458		MESS_STR: VECTOR[8]		! Error message strings
8459		    INITIAL(UPLIT(%ASCIZ ' CP'),UPLIT(%ASCIZ ' C40'),
8460			    UPLIT(%ASCIZ ' C20'),UPLIT(%ASCIZ ' C10'),
8461			    UPLIT(%ASCIZ ' C4'),UPLIT(%ASCIZ ' C2'),
8462			    UPLIT(%ASCIZ ' C1'),UPLIT(%ASCIZ ' s are'));
8463	
8464	LABEL
8465		BLOCK1;
8466	
8467	IF RUN_TEST(21) THEN RETURN;		! Run this test? Return if no
8468	
8469	NOERR_21 = 0;				! No errors have occurred yet
8470	RPT_ERR_FLAG = 0;			! Don't report unexpected error
8471	
8472	DO (0) WHILE
8473	BLOCK1:	BEGIN
8474		MR();				! Master Reset
8475		IO_DEPOSIT(MSR,ECC_ON_FORCE);	! Write force bits to MSR & turn on ECC
8476	
8477		INCR TEST FROM 0 TO 2 DO	! Write 1's three times to memory
8478		    MEM_DEPOSIT(.TEST_ADR[.TEST],-1);
8479	
8480		NUM_ERR = 0;			! Init number of errors to zero
8481		INCR TEST FROM 0 TO 2 DO	! For each try:
8482		    BEGIN
8483		    MEM_EXAMINE(.TEST_ADR[.TEST]);	! Read mem loc
8484		    MEM_STAT = IO_EXAMINE(MSR);		! Read MSR
8485		    IF .MEM_STAT<FORCE> NEQ %O'177'	! Force bits correct?
8486			THEN BEGIN		
8487			     NUM_ERR = .NUM_ERR + 1;	! If not incr # errors and keep
8488			     LAST_ERR = .TEST;		!    track of force bits, test
8489			     LAST_FORCE = .MEM_STAT<FORCE>;! number, and MSR
8490			     LAST_STAT = .MEM_STAT;
8491			     END;
8492		    MR();				! Master Reset
8493		    END;
8494	
8495	! Now see if a error occurred.  If there were 1 or less errors (a minority)
8496	!  then no error occurred so handle looping in case we were.
8497	
8498		ERR_FLAG = 0;
8499		IF .NUM_ERR LSS 2
8500		    THEN BEGIN
8501			 INCR ERR FROM 1 TO 8 DO
8502			    BEGIN
8503			    IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
8504			    END;
8505			 END;
8506	
8507	! An error occurred for sure - so report it (if it is a particular
8508	!  error ie. unique to a particular flop).
8509	
8510		IF .NUM_ERR GTR 1
8511		    THEN BEGIN
8512			 MESSV[0] = .TEST_ADR[.LAST_FORCE];
8513			 INCR ERR FROM 0 TO 6 DO
8514			    BEGIN
8515			    IF (.LAST_FORCE XOR (1^.ERR)) EQL %O'177'
8516				THEN BEGIN
8517				     ERR_FLAG = 1;
8518				     NOERR_21 = 1;
8519				     ERRCAS(.ERR+1,1,.MEM_CORR,.LAST_STAT,12,MESSV);
8520				     END;
8521			    IF LOOP_CHK(.ERR+1) THEN LEAVE BLOCK1 WITH 1;
8522			    END;
8523	
8524	! If we have an error but can't narrow it down to anything then report
8525	!  it anyway.
8526	
8527			 IF .ERR_FLAG EQL 0 AND .LAST_FORCE NEQ %O'177'
8528			    THEN BEGIN
8529				 NOERR_21 = 1;
8530				 ERRCAS(8,1,.MEM_CORR,.LAST_STAT,12,MESSV);
8531				 END;
8532			 IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
8533			 END;
8534		0				! To eliminate INFO compiler message
8535		END;
8536	
8537	!*MESSAGE 1
8538	!*STIMULUS
8539	!*	MR		Clear everything
8540	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
8541	!*	DI (STATUS)	  Set force bits 1111111, turn on ECC
8542	!*	LA (ADDR),DM -1 Write 1's to mem loc \U0
8543	!*	EM (ADDR)	Examine mem loc (Should cause single bit error)
8544	!*	EI 100000	Read Mem Stat Reg (Check bits should be all 1's)
8545	!*RESPONSE
8546	!*	Check bit\S1 incorrect (MSR data follows)
8547	
8548	!]ERROR 1
8549	!] B1 E3 G3 A4 H4 I4 J4 B5 C5 E5 F5 G5 H5 D7  NTWK
8550	!]NO ERROR 1
8551	!]  NTWK
8552	
8553	!]ERROR 2
8554	!] B1 E3 G3 B4 H4 I4 J4 K4 B5 C5 E5 F5 G5 H5 D7  NTWK
8555	!]NO ERROR 2
8556	!]  NTWK
8557	
8558	!]ERROR 3
8559	!] B1 E3 G3 C4 H4 I4 J4 L4 B5 C5 E5 F5 G5 H5 D7  NTWK
8560	!]NO ERROR 3
8561	!]  NTWK
8562	
8563	!]ERROR 4
8564	!] C1 E3 G3 D4 H4 I4 J4 M4 B5 C5 E5 F5 G5 H5 E7  NTWK
8565	!]NO ERROR 4
8566	!]  NTWK
8567	
8568	!]ERROR 5
8569	!] C1 E3 G3 E4 H4 I4 J4 K4 B5 C5 E5 F5 G5 H5 E7  NTWK
8570	!]NO ERROR 5
8571	!]  NTWK
8572	
8573	!]ERROR 6
8574	!] C1 E3 G3 F4 H4 I4 J4 L4 B5 C5 E5 F5 G5 H5 E7  NTWK
8575	!]NO ERROR 6
8576	!]  NTWK
8577	
8578	!]ERROR 7
8579	!] C1 E3 G3 G4 H4 I4 J4 M4 B5 C5 E5 F5 G5 H5 E7  NTWK
8580	!]NO ERROR 7
8581	!]  NTWK
8582	
8583	!]ERROR 8
8584	!] C1 E3 G3 A_H4 I4 K4 L4 M4 B5 C5 E5 F5 G5 H5 D7 E7  NTWK
8585	!]NO ERROR 8
8586	!]  NTWK
8587	
8588	END;
8589	GLOBAL ROUTINE TST22: NOVALUE =
8590	
8591	!++   ----------------- FORCE CHECK BITS LOADING OF ----------------
8592	! TEST DESCRIPTION:  This routine verifies that the force check bits
8593	!	(held in a holding register on MMC3) are loaded properly and
8594	!	at the right time.  If the logic controlling the register is
8595	!	faulty then the register may be loaded whenever data is sent
8596	!	to memory.
8597	!
8598	! TEST ASSUMPTIONS:  None.
8599	!
8600	! TEST PROCEDURE:  MR
8601	!		   Write status force bits 007
8602	!		   Write 052 to mem loc 125
8603	!		   Read mem loc 125
8604	!		   Read MSR - Check the force bits - Should be
8605	!			equal to 007.  If they are equal to 025
8606	!			or 052 then the force bits register is
8607	!			being written to indiscriminately.
8608	!
8609	!		   Repeat for force bits 170
8610	!
8611	! POSSIBLE ERRORS:  'MMC3 STATUS LOAD EN' stuck high
8612	!		    Force check bits register faulty
8613	!
8614	!--
8615	
8616	BEGIN
8617	
8618	LOCAL
8619		TEMP,
8620		ERR_NUM,
8621		MEM_STAT;
8622	
8623	OWN
8624		MSR_CORR: VECTOR[2]		! Correct data
8625		    INITIAL (%O'420700000125',%O'437000000125'),
8626		FORCE_BITS: VECTOR[2]		! Force bits to be used
8627		    INITIAL (%O'700000000016',%O'700000000360');
8628	
8629	LABEL
8630		BLOCK1;
8631	
8632	IF RUN_TEST(22) THEN RETURN;		! Run this test? Return if no
8633	
8634	NOERR_22 = 0;				! No errors have occurred yet
8635	RPT_ERR_FLAG = 0;			! Don't report unexpected error
8636	
8637	INCR TEST FROM 0 TO 1 DO		! For each set of force bits:
8638		BEGIN
8639		DO (0) WHILE
8640	BLOCK1:	    BEGIN
8641		    MR();				! Master Reset
8642		    IO_DEPOSIT(MSR,.FORCE_BITS[.TEST]);	! Write force bits
8643		    DM(125,052);		! Write 052 to mem loc 125
8644		    EM(125);			! Read mem loc 125 - causes ECC err
8645		    MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
8646		    IF .MEM_STAT GEQ 0		! 'ERR HOLD' not set?  If not then
8647			THEN NOERR_22 = 1;	!   set error flag.
8648	
8649	! Now see if the force bits gotten are the same as expected.  If not then
8650	!   set error flag and print error message.
8651	
8652		    TEMP = .MSR_CORR[.TEST];
8653		    IF (.MEM_STAT<24,7> NEQ .TEMP<24,7>) AND (.NOERR_22 NEQ 1)
8654			THEN BEGIN
8655			     NOERR_22 = 1;
8656			     ERRCA(.TEST+1,.TEMP,.MEM_STAT,12);
8657			     END;
8658		    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
8659		    0				! To eliminate INFO compiler message
8660		    END;
8661		END;
8662	
8663	! If Tests 20 and 22 passed then force bits register on MMC3 is ok.
8664	
8665		IF (.NOERR_22 OR .NOERR_20) EQL 0
8666		    THEN NOERR(1);
8667	
8668	! If Tests 20,21,22 passed then the ECC GEN/CHK logic on MMC4 is ok.
8669	
8670		IF (.NOERR_22 OR .NOERR_21 OR .NOERR_20) EQL 0
8671		    THEN NOERR(2);
8672	
8673	! If Tests (20 and 21) or (21 and 22) passed then 'MMC5 ERR LOAD' And
8674	!   gate is ok.
8675	
8676		IF (.NOERR_20 OR .NOERR_22) EQL 0 OR (.NOERR_21 OR .NOERR_22) EQL 0
8677		    THEN NOERR(3);
8678	
8679	!*MESSAGE 1
8680	!*STIMULUS
8681	!*	MR,LI 100000	Write Mem Stat Reg:  Set Clear Err Hold ...
8682	!*	DI 700000000034	  Set force bits '007'
8683	!*	LA 125,DM 052	Write '052' to mem loc '125'
8684	!*	EM 125		Examine memory loc '125' (Causes ECC error and loads
8685	!*			  force bits into mem stat reg)
8686	!*RESPONSE
8687	!*	Force bits returned incorrect
8688	!*	Memory Status Register correct/actual:
8689	
8690	!]ERROR 1
8691	!] B1 C1 E3 G3 H4 I4 E5 H5 B7 AB  NTWK
8692	!]NO ERROR 1
8693	!] G3  NTWK
8694	
8695	!*MESSAGE 2
8696	!*STIMULUS
8697	!*	MR,LI 100000	Write Mem Stat Reg:  Set Clear Err Hold ...
8698	!*	DI 700000000360	  Set force bits '170'
8699	!*	LA 125,DM 052	Write '052' to mem loc '125'
8700	!*	EM 125		Examine memory loc '125' (Causes ECC error and loads
8701	!*			  force bits into mem stat reg)
8702	!*RESPONSE
8703	!*	Force bits returned incorrect
8704	!*	Memory Status Register correct/actual:
8705	
8706	!]ERROR 2
8707	!] B1 C1 E3 G3 H4 I4 E5 H5 B7 AB  NTWK
8708	!]NO ERROR 2
8709	!] A4 B4 C4 D4 E4 F4 G4 H4 I4 K4 L4 M4  NTWK
8710	
8711	!*MESSAGE 3
8712	!*STIMULUS
8713	!*RESPONSE
8714	!]ERROR 3
8715	!]  NTWK
8716	!]NO ERROR 3
8717	!] B5  NTWK
8718	
8719	END;
8720	GLOBAL ROUTINE TST23: NOVALUE =
8721	
8722	!++   -------------- ERROR ADDRESS REGISTER LOADING OF -------------
8723	! TEST DESCRIPTION:  This routine verifies that 'ERR HOLD' being set
8724	!	does in fact prevent 'MMC5 ERR ADD LOAD' from being asserted
8725	!	when data is read to or written from memory thereafter.
8726	!
8727	! TEST ASSUMPTIONS:  None.
8728	!
8729	! TEST PROCEDURE:  MR
8730	!		   Write 0's to mem loc 222
8731	!		   Write status force bits 177
8732	!		   Write 0's to mem loc 111
8733	!		   Read mem loc 111 (Causes err and 'ERR HOLD' sets)
8734	!		   Read mem loc 222
8735	!		   Read MSR - Check the error  address - should be
8736	!			equal to 111. If it is equal to 222 or MSR
8737	!			then the Error Address Register  is  being
8738	!			written to indiscriminately.
8739	!
8740	! POSSIBLE ERRORS:  
8741	!
8742	!--
8743	
8744	BEGIN
8745	
8746	LITERAL
8747		FORCE_BITS = %O'700000000376';	! Set force bits 177, clear 'ERR HOLD',
8748						!   'REF ERR','PARITY ERR'
8749	LOCAL
8750		ERR_FLAG,			! Error flag
8751		MEM_STAT;			! Memory Status Register
8752	
8753	LABEL
8754		BLOCK1;
8755	
8756	IF RUN_TEST(23) THEN RETURN;		! Run this test? Return if no
8757	
8758	NOERR_23 = 0;				! No errors have occurred yet
8759	RPT_ERR_FLAG = 0;			! Don't report unexpected error
8760	
8761	DO (0) WHILE
8762	BLOCK1:	BEGIN
8763		MR();				! Master Reset
8764		DM(222,0);			! Write 0's to mem loc 222
8765		IO_DEPOSIT(MSR,FORCE_BITS);	! Now change force bits
8766		DM(111,0);			! Write 0's to mem loc 111
8767	
8768	! Now an EM 111 should cause 'ERR HOLD' to be set and error address to 
8769	!   be set to 111.  The EM 222 afterwards should not affect any of the
8770	!   data already in the MSR.
8771	
8772		EM(111);			! Read mem loc 111
8773		EM(222);			! Read mem loc 222
8774		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
8775	
8776		SELECTONE .MEM_STAT<0,22> OF
8777		    SET
8778		    [%O'111']:	BEGIN		! No error if address is 111
8779				ERR_FLAG = 0;
8780				END;
8781		    [%O'222']:	BEGIN		! EM 222 causes a new error address to
8782				TEST_ABORT = 1;	!   be loaded in spite of 'ERR HOLD'
8783				ERR_FLAG = 1;	!   being asserted.
8784				END;
8785		    [MSR]:	BEGIN		! EM 222 might have failed.  But read
8786				TEST_ABORT = 1;	!   MSR causes error address to be that
8787				ERR_FLAG = 2;	!   of MSR.  So either 'ERR HOLD' not
8788				END;		!   set or 'ERR ADDR LOAD' stuck high.
8789		    [OTHERWISE]:BEGIN		! Its garbage - some other error.
8790				ERR_FLAG = 3;
8791				END;
8792		    TES;
8793	
8794		INCR ERR FROM 1 TO 3 DO		! Now print out an error message for
8795		    BEGIN			!   the error if one was found.
8796		    IF .ERR EQL .ERR_FLAG
8797			THEN BEGIN
8798			     NOERR_23 = 1;
8799			     ERRCA(.ERR,%O'437700000111',.MEM_STAT,12);
8800			     END;
8801		    IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
8802		    END;
8803		0				! To eliminate INFO compiler message
8804		END;
8805	
8806		IF .NOERR_23 EQL 0		! If no errors in this test then
8807		    THEN NOERR(1);		!   'MMC5 ERR ADDR LOAD' is ok
8808	
8809	!*MESSAGE 1
8810	!*STIMULUS
8811	!*	MR (Clear everything)
8812	!*	Write 0's to mem loc '222'
8813	!*	Write status to mem (Set force bits '177')
8814	!*	Write 0's to mem loc '111'
8815	!*	Examine mem loc '111' (Causes ECC error and adr latched in Err Adr Reg)
8816	!*	Examine mem loc '222' - Should have no effect on error data
8817	!*	Examine Mem Status Register
8818	!*RESPONSE
8819	!*	EM 222 wiped out Err Adr 111 but EI 100000 did not wipe out 222
8820	!*Mem Status Register C/A:
8821	
8822	!]ERROR 1
8823	!] I5 I8 J8 K8  NTWK
8824	!]NO ERROR 1
8825	!] I5  NTWK
8826	
8827	!*MESSAGE 2
8828	!*STIMULUS
8829	!*	MR (Clear everything)
8830	!*	Write 0's to mem loc '222'
8831	!*	Write status to mem (Set force bits '177')
8832	!*	Write 0's to mem loc '111'
8833	!*	Examine mem loc '111' (Causes ECC error and adr latched in Err Adr Reg)
8834	!*	Examine mem loc '222' - Should have no effect on error data
8835	!*	Examine Mem Status Register
8836	!*RESPONSE
8837	!*	EI 100000 wiped out Err Adr 111
8838	!*Mem Status Register C/A:
8839	
8840	!]ERROR 2
8841	!] I5 I8 J8 K8  NTWK
8842	!]NO ERROR 2
8843	!]  NTWK
8844	
8845	!*MESSAGE 3
8846	!*STIMULUS
8847	!*	MR (Clear everything)
8848	!*	Write 0's to mem loc '222'
8849	!*	Write status to mem (Set force bits '177')
8850	!*	Write 0's to mem loc '111'
8851	!*	Examine mem loc '111' (Causes ECC error and adr latched in Err Adr Reg)
8852	!*	Examine mem loc '222' - Should have no effect on error data
8853	!*	Examine Mem Status Register
8854	!*RESPONSE
8855	!*	Err Adr 111 destroyed somehow
8856	!*Mem Status Register C/A:
8857	
8858	!]ERROR 3
8859	!] D1 E1 F1 G1 H1 I1 J1 F3 N3 I5 F7 G7 H7 I7 J7 K7 L7 I8 J8 K8 AA  NTWK
8860	!]NO ERROR 3
8861	!]  NTWK
8862	
8863	END;
8864	GLOBAL ROUTINE TST24: NOVALUE =
8865	
8866	!++   ---------------------- BUS RESET -----------------------
8867	! TEST DESCRIPTION:  This routine verifies that a Master Reset
8868	!	causes bus reset to be seen on the MMC board resulting
8869	!	in a reset of the MMC board.
8870	!
8871	! TEST ASSUMPTIONS:  None.
8872	!
8873	! TEST PROCEDURE:  Master Reset
8874	!		   Turn off parity error checking by 8080
8875	!		   Write status to MMC board - Set force bits (0111111)
8876	!		   Write 0's to mem location 17043
8877	!		   Examine mem loc 17043 - Causes Err Hold
8878	!					 	  Uncorr Err Hold
8879	!		   Write status to MMC board - Set PE
8880	!					       Turn off ECC
8881	!		   Read/write to mem simultaneously - Hangs memory
8882	!			and causes a mem refresh err within 26 usec.
8883	!		   Do a Master Reset
8884	!		   Read Mem Status Reg - Should show:
8885	!				PE off
8886	!				Ref Err off
8887	!				ECC on
8888	!				Err Hold off
8889	!				Uncor Err Hold on
8890	!				Err Addr not 17043 - Should be 100000
8891	!
8892	! POSSIBLE ERRORS:  'MMC5 ERR HOLD','MMC7 PARITY ERR','MMC9 REF ERR',
8893	!			'MMC4 UNCOR ERR HOLD','MMC5 POWER FAILED',
8894	!			'MMC3 ECC ON' flops are faulty
8895	!		    Err Addr Register on MMC8 does not get loaded if
8896	!			'MMC5 ERR HOLD' is not set
8897	!
8898	!--
8899	
8900	BEGIN
8901	
8902	LITERAL
8903		RESET = %O'700000000000',	! Clear 'ERR HOLD','REF ERR','PAR ERR'
8904		FORCE_SET = %O'700000000176',	! Set force bits 077, do reset (above)
8905		PAR_SET = %O'040000000000',	! Set parity error
8906		UNCOR = %O'000000000000';	! Mask for 'UNCOR ERR HOLD' bit of MSR
8907	
8908	OWN
8909		MEM_STAT_V: BTTVECTOR[36],	! MSR bitvector
8910		TEMP_V: BTTVECTOR[36];		! MSR bitvector (with 'UNCOR ERR HOLD'
8911						!   bit reversed.
8912	BIND
8913		REF_ERR = UPLIT(%ASCIZ '?MRE'),
8914		MEM_STAT = MEM_STAT_V,
8915		TEMP = TEMP_V;
8916	
8917	LABEL
8918		BLOCK1;
8919	
8920	IF RUN_TEST(24) THEN RETURN;		! Run this test? Return if no
8921	
8922	NOERR_24 = 0;				! No errors have occurred yet
8923	RPT_ERR_FLAG = 0;			! Don't report unexpected error
8924	
8925	DO (0) WHILE
8926	BLOCK1:	BEGIN
8927		MR();				! Master Reset
8928	
8929	! Set up MSR with force bits, ECC off, parity error all set.
8930	! Then write to mem and read back so that check bits, Error Address,
8931	!   Err Hold and Uncorr Err Hold are set. Then hang MMC so that ?MRE
8932	!   get asserted also.
8933	
8934		IO_DEPOSIT(MSR,FORCE_SET+ECC_OFF+PAR_SET);
8935		DM(17043,0);			! Write 0's to mem loc 17043
8936		EM(17043);			! Examine mem loc 17043 
8937		HANG_MEM();			! Set ?MRE
8938		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
8939	
8940		TEMP = RD_101;			! Make sure that a ?MRE occurred
8941		IF (.TEMP AND 1) NEQ 1		! If not set error flag and print
8942		    THEN BEGIN			!   error message.
8943			 NOERR_24 = 1;
8944			 ERRS(1,1,TEMP);
8945			 END;
8946		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
8947	
8948	! Now do MR - this should reset most bits in the MSR (except 'UNCORR ERR HOLD')
8949	
8950		MR();				! Master Reset
8951		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
8952		TEMP = .MEM_STAT XOR UNCOR;	! Reverse 'UNCORR ERR HOLD' bit
8953	
8954		INCR ERRR FROM 0 TO 3 DO	! Now make sure 'ERR HOLD','UNCORR ERR
8955		    BEGIN			!   HOLD','REF ERR','PAR ERR' are all
8956		    IF .TEMP_V[.ERRR] NEQ 0	!   zeros - if not set error flag and
8957			THEN BEGIN		!   print error message.
8958			     NOERR_24 = 1;
8959			     ERRS(.ERRR+2,.ERRR+2,MEM_STAT);
8960			     END;
8961		    IF LOOP_CHK(.ERRR+2) THEN LEAVE BLOCK1 WITH 1;
8962		    END;
8963	
8964		IF .MEM_STAT_V[4] NEQ 1		! Now make sure that ECC got turned
8965		    THEN BEGIN			!   back on - If not set error flag
8966			 NOERR_24 = 1;		!   and print error message.
8967			 ERRS(6,6,MEM_STAT);
8968			 END;
8969		IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
8970	
8971		IF .MEM_STAT_V[12] NEQ 0	! Now make sure 'POWER FAIL' is still
8972		    THEN BEGIN			!   off - If not set error flag and
8973			 NOERR_24 = 1;		!   print error message.
8974			 ERRS(7,7,MEM_STAT);
8975			 END;
8976		IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
8977	
8978		IF (.MEM_STAT AND %O'17777777') NEQ MSR	! Now make sure Error Address
8979		    THEN BEGIN				!   shows MSR (since 'ERR HOLD'
8980			 NOERR_24 = 1;			!   was reset) - if not set
8981			 ERRCA(8,MSR,.MEM_STAT,12);	!   error flag and print error
8982			 END;				!   message.
8983		IF LOOP_CHK(8) THEN LEAVE BLOCK1 WITH 1;
8984	
8985		IO_DEPOSIT(MSR,RESET);		! We are all done so just reset MMC
8986		DM(0,0);			!   to clean things up.  Also do a 
8987		EM(0);				!   DM,EM to clear 'UNCORR ERR HOLD'
8988		0				! To eliminate INFO compiler message
8989		END;				!   if it was set.
8990	
8991	!*MESSAGE 1
8992	!*STIMULUS
8993	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
8994	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
8995	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
8996	!*	EM 0		  it - Causes single bit ECC error
8997	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
8998	!*	ER 101		8080 Reg 101 should show 'REF ERR'
8999	!*RESPONSE
9000	!*	Mem ref err not set (8080 IO Reg 101: \U0 )
9001	
9002	!]ERROR 1
9003	!] C7 A9 B9 C9 AA BB BC  NTWK
9004	!]NO ERROR 1
9005	!]  NTWK
9006	
9007	!*MESSAGE 2
9008	!*STIMULUS
9009	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
9010	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
9011	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
9012	!*	EM 0		  it - Causes single bit ECC error
9013	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
9014	!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
9015	!*	MR		Should reset 'MMC5 ERR HOLD'
9016	!*	EI 100000	MSR should show 'MMC5 ERR HOLD' not asserted
9017	!*RESPONSE
9018	!*	'MMC5 ERR HOLD' bit 00 set (Mem Stat Reg: \U0 )
9019	
9020	!]ERROR 2
9021	!] C5 C7 L7 AA CB AC  NTWK
9022	!]NO ERROR 2
9023	!]  NTWK
9024	
9025	!*MESSAGE 3
9026	!*STIMULUS
9027	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
9028	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
9029	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
9030	!*	EM 0		  it - Causes single bit ECC error
9031	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
9032	!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
9033	!*	MR		Should not reset 'MMC4 UNCOR ERR HOLD'
9034	!*	EI 100000	MSR should show 'MMC4 UNCOR ERR HOLD' still set
9035	!*RESPONSE
9036	!*	'MMC4 UNCOR ERR HOLD' bit 01 not set (Mem Stat Reg: \U0 )
9037	
9038	!]ERROR 3
9039	!] J4 E5 G5 H5 C7 CC  NTWK
9040	!]NO ERROR 3
9041	!]  NTWK
9042	
9043	!*MESSAGE 4
9044	!*STIMULUS
9045	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
9046	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
9047	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
9048	!*	EM 0		  it - Causes single bit ECC error
9049	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
9050	!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
9051	!*	MR		Should reset 'MMC9 REF ERR'
9052	!*	EI 100000	MSR should show 'MMC9 REF ERR' not asserted
9053	!*RESPONSE
9054	!*	'MMC9 REF ERR' bit 02 set (Mem Stat Reg: \U0 )
9055	
9056	!]ERROR 4
9057	!] B9 C7 A9 AA CB BC  NTWK
9058	!]NO ERROR 4
9059	!]  NTWK
9060	
9061	!*MESSAGE 5
9062	!*STIMULUS
9063	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
9064	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
9065	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
9066	!*	EM 0		  it - Causes single bit ECC error
9067	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
9068	!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
9069	!*	MR		Should reset 'MMC7 PARITY ERR'
9070	!*	EI 100000	MSR should show 'MMC7 PARITY ERR' not asserted
9071	!*RESPONSE
9072	!*	'MMC7 PARITY ERR' bit 03 set (Mem Stat Reg: \U0 )
9073	
9074	!]ERROR 5
9075	!] B7 C7 CB BC  NTWK
9076	!]NO ERROR 5
9077	!]  NTWK
9078	
9079	!*MESSAGE 6
9080	!*STIMULUS
9081	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
9082	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
9083	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
9084	!*	EM 0		  it - Causes single bit ECC error
9085	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
9086	!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
9087	!*	MR		Should assert 'MMC3 ECC ON'
9088	!*	EI 100000	MSR should show 'MMC3 ECC ON' asserted
9089	!*RESPONSE
9090	!*	ECC still turned off (bit 04) (Mem Stat Reg: \U0 )
9091	
9092	!]ERROR 6
9093	!] E3 H3 D7 CB  NTWK
9094	!]NO ERROR 6
9095	!]  NTWK
9096	
9097	!*MESSAGE 7
9098	!*STIMULUS
9099	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
9100	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
9101	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
9102	!*	EM 0		  it - Causes single bit ECC error
9103	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
9104	!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
9105	!*	MR		Should not affect 'MMC5 POWER FAILED'
9106	!*	EI 100000	MSR should show 'MMC5 POWER FAILED' not asserted
9107	!*RESPONSE
9108	!*	'MMC5 POWER FAILED' bit 12 set (Mem Stat Reg: \U0 )
9109	
9110	!]ERROR 7
9111	!] D1 A5 F7 AC  NTWK
9112	!]NO ERROR 7
9113	!]  NTWK
9114	
9115	!*MESSAGE 8
9116	!*STIMULUS
9117	!*	MR,LI 100000	Write Mem Stat Reg:  Set PE, turn off ECC,
9118	!*	DI 700000000176	  Set force bits to 077, clear Err Hold
9119	!*	LA 17043,DM 0	Write 0's to mem loc 17043 then examine
9120	!*	EM 0		  it - Causes single bit ECC error
9121	!*	CAUSE ?MRE	Hang MMC by issuing only half a memory write
9122	!*	ER 101		Check 8080 Reg 101 for 'REF ERR'
9123	!*	MR		Should reset 'MMC5 ERR HOLD'
9124	!*	EI 100000	Err Addr should be 100000 since 'ERR HOLD' reset
9125	!*RESPONSE
9126	!*	Err Address bits 14..35 incorrect
9127	
9128	!]ERROR 8
9129	!] D1 E1 F1 G1 H1 I1 J1 F3 N3 C5 I5 F7 G7 H7 I7 J7 K7 L7 I8 J8 K8 AA  NTWK
9130	!]NO ERROR 8
9131	!]  NTWK
9132	
9133	END;
9134	GLOBAL ROUTINE TST25: NOVALUE =
9135	
9136	!++   ------------------- MIXERS & SELECT LOGIC ------------------------
9137	! TEST DESCRIPTION:  This  routine  verifies that the 4x2 mixers on MMC7
9138	!	are working properly. Normally either the Memory Status Register
9139	!	data (gathered together from  various parts of the board) or the
9140	!	corrected/uncorrected data  from memory (resulting from a read).
9141	!	the select input on each mixer consists of 'MMC7 READ STATUS'.
9142	!
9143	! TEST ASSUMPTIONS:  None.
9144	!
9145	! TEST PROCEDURE:  Do a Master Reset
9146	!		   Write status - Set force bits '376'
9147	!				  Turn off ECC
9148	!		   Write '360077700000' to mem loc '77777'
9149	!			(Complement of MSR when read)
9150	!		   Examine mem loc '77777'
9151	!		   Read Mem Status Reg
9152	!		   Examine mem loc '77777'
9153	!		   Verify that MSR = '417700077777'
9154	!			  Mem data = '360077700000'
9155	!
9156	! POSSIBLE ERRORS:  Select inputs of 4 x 2 mixers on MMC7 are faulty.
9157	!
9158	!--
9159	
9160	BEGIN
9161	
9162	LOCAL
9163		MESSV,				! Error message output data
9164		ERR_FLAG,			! Error flag
9165		MEM_CONT,			! Memory contents
9166		MSR_CONT;			! MSR contents
9167	
9168	LITERAL
9169		FORCE_SET = %O'700000000377',	! Set force bits to 177
9170		MSR_DATA = %O'417700077777',	! Correct data we should read from MSR
9171		MEM_DATA = %O'360077700000',	! Correct data we should read from mem
9172		MEM_LOC = %O'77777';		! Memory location to use for this test
9173	
9174	STRUCTURE
9175		BIT4[I;N]=[N]			! Structure to look at data in 4 bit
9176		    (BIT4)			!   chunks (matching the mixers on
9177		    <32-I*4,4>;			!   MMC7).
9178	
9179	OWN
9180		T_CONT_VECT: BIT4[9],
9181		T_DATA_VECT: BIT4[9],
9182		MIX_VECT: BIT4[9],
9183		MESS_STR: VECTOR[9]		! Error message output strings
9184		    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
9185			UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
9186			UPLIT(%ASCIZ '16-19'),UPLIT(%ASCIZ '20-23'),
9187			UPLIT(%ASCIZ '24-27'),UPLIT(%ASCIZ '28-31'),
9188			UPLIT(%ASCIZ '32-35'));
9189	
9190	BIND
9191		T_CONT = T_CONT_VECT,
9192		T_DATA = T_DATA_VECT,
9193		MEM_STAT_REG = MIX_VECT;
9194	
9195	LABEL
9196		BLOCK1;
9197	
9198	IF RUN_TEST(25) THEN RETURN;		! Run this test? Return if no
9199	
9200	NOERR_25 = 0;				! No errors have occurred yet
9201	RPT_ERR_FLAG = 0;			! Don't report unexpected error
9202	
9203	DO (0) WHILE
9204	BLOCK1:	BEGIN
9205		MR();				! Master Reset
9206		IO_DEPOSIT(MSR,FORCE_SET);	! Write force bits to MSR
9207		MEM_DEPOSIT(MEM_LOC,MEM_DATA);	! Write data to mem
9208		MEM_EXAMINE(MEM_LOC);		! Read mem
9209		MSR_CONT = IO_EXAMINE(MSR);	! Read MSR
9210		MEM_CONT = MEM_EXAMINE(MEM_LOC);! Read mem
9211	
9212	! Look for errors unique to a single MMC7 mixer. (4 bit chunks)
9213	! Here look at the contents of MSR expected vs. actual.
9214	
9215		ERR_FLAG = 0;
9216		INCR BTT FROM 0 TO 8 DO
9217		    BEGIN
9218		    T_CONT = .MSR_CONT;		! Copy data expected and actual
9219		    T_DATA = MSR_DATA;		!   and mask out the particular
9220		    T_CONT_VECT[.BTT] = %O'777';!   4 bit section we want.
9221		    T_DATA_VECT[.BTT] = %O'777';
9222		    IF (.T_CONT EQL .T_DATA) AND (.MSR_CONT NEQ MSR_DATA)
9223			THEN BEGIN			! If error - set error flags,
9224			     MESSV = .MESS_STR[.BTT];	!   print error message, and
9225			     ERR_FLAG = 1;		!   abort future testing.
9226			     TEST_ABORT = 1;
9227			     NOERR_25 = 1;
9228			     ERRCAS(1+.BTT,1,MSR_DATA,.MSR_CONT,12,MESSV);
9229			     END;
9230		    IF LOOP_CHK(1+.BTT) THEN LEAVE BLOCK1 WITH 1;
9231		    END;
9232	
9233	! If there is an error but not in only one 4-bit segment then report
9234	!   it anyway.  Still work on MSR contents.
9235	
9236	 	IF (.ERR_FLAG EQL 0) AND (.MSR_CONT NEQ MSR_DATA)
9237		    THEN BEGIN
9238			 NOERR_25 = 1;
9239			 ERRCAS(10,2,MSR_DATA,.MSR_CONT,12,MESSV);
9240			 END;
9241		IF LOOP_CHK(10) THEN LEAVE BLOCK1 WITH 1;
9242	
9243	! Look for errors unique to a single MMC7 mixer. (4 bit chunks)
9244	! Here look at the contents of memory expected vs. actual.
9245	
9246		ERR_FLAG = 0;
9247		INCR BTT FROM 0 TO 8 DO
9248		    BEGIN
9249		    T_CONT = .MEM_CONT;		! Copy data expected and actual
9250		    T_DATA = MEM_DATA;		!   and mask out the particular
9251		    T_CONT_VECT[.BTT] = %O'777';!   4 bit section we want.
9252		    T_DATA_VECT[.BTT] = %O'777';
9253		    IF (.T_CONT EQL .T_DATA) AND (.MEM_CONT NEQ MEM_DATA)
9254			THEN BEGIN			! If error - set error flags,
9255			     MESSV = .MESS_STR[.BTT];	!   print error message, and
9256			     ERR_FLAG = 1;		!   abort future testing.
9257			     TEST_ABORT = 1;
9258			     NOERR_25 = 1;
9259			     ERRCAS(11+.BTT,3,MEM_DATA,.MEM_CONT,12,MESSV);
9260			     END;
9261		    IF LOOP_CHK(11+.BTT) THEN LEAVE BLOCK1 WITH 1;
9262		    END;
9263	
9264	! If there is an error but not in only one 4-bit segment then report
9265	!   it anyway.  Still work on memory contents.
9266	
9267		IF (.ERR_FLAG EQL 0) AND (.MEM_CONT NEQ MEM_DATA)
9268		    THEN BEGIN
9269			 NOERR_25 = 1;
9270			 ERRCAS(20,4,MEM_DATA,.MEM_CONT,12,MESSV);
9271			 END;
9272		IF LOOP_CHK(20) THEN LEAVE BLOCK1 WITH 1;
9273		0				! To eliminate INFO compiler message
9274		END;
9275	
9276	! If Test 25 passed then all of the bus transceivers on MMC1 and all of the
9277	!  mixers on MMC7 are ok.
9278	
9279	IF .NOERR_25 EQL 0 THEN NOERR(1);
9280	
9281	! If both Test 14 and Test 25 passed then 'MMC7 READ STATUS' logic is ok.
9282	
9283	IF (.NOERR_25 OR .NOERR_14) EQL 0 THEN NOERR(2);
9284	
9285	! If Tests 6,17,19,22,25 all passed then all of the mixers on MMC7 are ok.
9286	
9287	IF (.NOERR_6 OR .NOERR_17 OR .NOERR_19 OR .NOERR_22 OR .NOERR_25) EQL 0 THEN NOERR(3);
9288	
9289	!*MESSAGE 1
9290	!*STIMULUS
9291	!*	MR		Master Reset
9292	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
9293	!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
9294	!*	LA 77777	Write to mem loc 77777 - data is complement of what
9295	!*	DM 360077700000	  Should be in the MSR when this location is read
9296	!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
9297	!*	EI 100000	Read MSR - should contain '417700077777'
9298	!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
9299	!*RESPONSE
9300	!*	Bits \S0 of Memory Status Register was read improperly
9301	
9302	!]ERROR 1
9303	!] A1 C7 AC  NTWK
9304	!]NO ERROR 1
9305	!] A_J1 A7 C7 D7 E7 F7 G7 H7 I7 J7 K7  NTWK
9306	
9307	!]ERROR 2
9308	!] A_G4 H4 I4 B1 G6 H6 D7 AC  NTWK
9309	!]NO ERROR 2
9310	!] L7  NTWK
9311	
9312	!]ERROR 3
9313	!] A_G4 H4 I4 C1 G6 H6 E7 AC  NTWK
9314	!]NO ERROR 3
9315	!] C7 D7 E7 F7 G7 H7 I7 J7 K7  NTWK
9316	
9317	!]ERROR 4
9318	!] D1 F7 AC  NTWK
9319	!]NO ERROR 4
9320	!]  NTWK
9321	
9322	!]ERROR 5
9323	!] E1 F1 G7 AC  NTWK
9324	!]NO ERROR 5
9325	!]  NTWK
9326	
9327	!]ERROR 6
9328	!] F1 G1 H7 AC  NTWK
9329	!]NO ERROR 6
9330	!]  NTWK
9331	
9332	!]ERROR 7
9333	!] G1 H1 I7 AC  NTWK
9334	!]NO ERROR 7
9335	!]  NTWK
9336	
9337	!]ERROR 8
9338	!] H1 I1 J7 AC  NTWK
9339	!]NO ERROR 8
9340	!]  NTWK
9341	
9342	!]ERROR 9
9343	!] I1 J1 K7 AC  NTWK
9344	!]NO ERROR 9
9345	!]  NTWK
9346	
9347	!*MESSAGE 2
9348	!*STIMULUS
9349	!*	MR		Master Reset
9350	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
9351	!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
9352	!*	LA 77777	Write to mem loc 77777 - data is complement of what
9353	!*	DM 360077700000	  Should be in the MSR when this location is read
9354	!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
9355	!*	EI 100000	Read MSR - should contain '417700077777'
9356	!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
9357	!*RESPONSE
9358	!*	Memory Status Register was read improperly
9359	
9360	!]ERROR 10
9361	!] A7 C7 D7 E7 F7 G7 H7 I7 J7 K7 L7 AA DB AC  NTWK
9362	!]NO ERROR 10
9363	!]  NTWK
9364	
9365	!*MESSAGE 3
9366	!*STIMULUS
9367	!*	MR		Master Reset
9368	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
9369	!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
9370	!*	LA 77777	Write to mem loc 77777 - data is complement of what
9371	!*	DM 360077700000	  Should be in the MSR when this location is read
9372	!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
9373	!*	EI 100000	Read MSR - should contain '417700077777'
9374	!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
9375	!*RESPONSE
9376	!*	Bits \S0 of mem loc 77777 was read improperly
9377	
9378	!]ERROR 11
9379	!] A1 A6 G6 H6 C7 H2 AC  NTWK
9380	!]NO ERROR 11
9381	!]  NTWK
9382	
9383	!]ERROR 12
9384	!] B1 A6 B6 G6 H6 D7 H2 I2 AC  NTWK
9385	!]NO ERROR 12
9386	!]  NTWK
9387	
9388	!]ERROR 13
9389	!] C1 B6 G6 H6 E7 I2 AC  NTWK
9390	!]NO ERROR 13
9391	!]  NTWK
9392	
9393	!]ERROR 14
9394	!] D1 C6 G6 H6 F7 J2 AC  NTWK
9395	!]NO ERROR 14
9396	!]  NTWK
9397	
9398	!]ERROR 15
9399	!] E1 F1 C6 D6 G6 H6 G7 J2 K2 AC  NTWK
9400	!]NO ERROR 15
9401	!]  NTWK
9402	
9403	!]ERROR 16
9404	!] F1 G1 D6 G6 H6 H7 K2 AC  NTWK
9405	!]NO ERROR 16
9406	!]  NTWK
9407	
9408	!]ERROR 17
9409	!] G1 H1 D6 G6 H6 I7 L2 AC  NTWK
9410	!]NO ERROR 17
9411	!]  NTWK
9412	
9413	!]ERROR 18
9414	!] H1 I1 E6 F6 G6 H6 J7 L2 M2 AC  NTWK
9415	!]NO ERROR 18
9416	!]  NTWK
9417	
9418	!]ERROR 19
9419	!] I1 J1 F6 G6 H6 K7 M2 AC  NTWK
9420	!]NO ERROR 19
9421	!]   NTWK
9422	
9423	!*MESSAGE 4
9424	!*STIMULUS
9425	!*	MR		Master Reset
9426	!*	LI 100000	Write Mem Stat Reg:  Set force bits 1111111,
9427	!*	DI 700000000377	  Turn off ECC, clear 'ERR HOLD' if it is set
9428	!*	LA 77777	Write to mem loc 77777 - data is complement of what
9429	!*	DM 360077700000	  Should be in the MSR when this location is read
9430	!*	EM 77777	Read mem loc 77777 (Cause ECC error and init MSR)
9431	!*	EI 100000	Read MSR - should contain '417700077777'
9432	!*	EM 77777	Read mem loc 77777 - should contain '360077700000'
9433	!*RESPONSE
9434	!*	Mem loc 77777 was read improperly
9435	
9436	!]ERROR 20
9437	!] A_M2 A_H6 A7 C7 D7 E7 F7 G7 H7 I7 J7 K7 L7 AA DB AC  NTWK
9438	!]NO ERROR 20
9439	!]  NTWK
9440	
9441	END;
9442	GLOBAL ROUTINE TST26: NOVALUE =
9443	
9444	!++   ------------ ECC: DETERMINATION OF 'MMC5 READ ERROR' -------
9445	! TEST DESCRIPTION:  This routine verifies  some of the ECC logic.
9446	!	In particular it verifies  that there are no stuck pins on
9447	!	the OR  gate  that  determines 'MMC5 READ ERROR'.  It also
9448	!	verfies the double bit  error detection (determined by the
9449	!	parity generator on MMC5). All of the ECC errors generated
9450	!	in this test should be single bit errors.
9451	!
9452	! TEST ASSUMPTIONS:  None.
9453	!
9454	! TEST PROCEDURE:  Write status - Shut off ECC
9455	!				- Set force bits (0000001)
9456	!		   Write 0's to mem location 11111
9457	!		   Examine mem loc 11111 - Sets 'ERR HOLD'
9458	!					 - Does not set 'UNCORR ERR HOLD'
9459	!		   Read Mem Status Reg - should show:
9460	!				'ERR HOLD' on
9461	!				'UNCOR ERR HOLD' off
9462	!				'ERR ADDR' is 11111
9463	!		   Repeat with force bits shifted left a bit at a time
9464	!
9465	! POSSIBLE ERRORS:  OR gate determining 'MMC5 READ ERROR' faulty
9466	!		    Parity generator & AND gate determining
9467	!			'MMC5 UNCORRECTABLE ERROR' is broken.
9468	!
9469	!--
9470	
9471	BEGIN
9472	
9473	MACRO
9474		ERR_HOLD = .MEM_STAT_VECT[0]%;	! Error hold bit
9475	
9476	LITERAL
9477		ECC_OFF = %O'700000000001';	! Shut off ECC
9478	
9479	LOCAL
9480		MEM_CORR;
9481	
9482	OWN
9483		MEM_DATA: VECTOR[2],
9484		MEM_STAT_VECT: BTTVECTOR[36];
9485	
9486	BIND
9487		MEM_DAT = MEM_DATA,
9488		MEM_STAT = MEM_STAT_VECT;
9489	
9490	LABEL
9491		BLOCK1;
9492	
9493	IF RUN_TEST(26) THEN RETURN;		! Run this test? Return if no
9494	
9495	NOERR_26 = 0;				! No errors have occurred yet
9496	RPT_ERR_FLAG = 0;			! Don't report unexpected error
9497	
9498	INCR TEST FROM 1 TO 7 DO		! For a force bit in each bit pos:
9499		BEGIN
9500		DO (0) WHILE
9501	BLOCK1:	    BEGIN
9502		    MR();				! Master Reset
9503		    IO_DEPOSIT(MSR,ECC_OFF+1^.TEST);	! Write force bit to MSR
9504		    DM(11111,0);			! Write 0's to mem loc 11111
9505		    EM(11111);				! Read it back (cause ECC error)
9506	
9507	! Now check the results.
9508	
9509		    MEM_DATA[0] = MEM_STAT = IO_EXAMINE(MSR);
9510		    MEM_CORR = %O'400000011111' OR 1^(.TEST+24);
9511		    MEM_DATA[1] = 1^(.TEST-1);
9512		    IF ERR_HOLD NEQ 1		! If 'ERR HOLD' not asserted (didnt
9513			THEN BEGIN		!   cause ECC error??) - set error
9514			     ECC_SINGLE = 1;	!   flags and print error message.
9515			     NOERR_26 = 1;
9516			     ERRS(1,1,MEM_DAT);
9517			     END;
9518		    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
9519	
9520		    IF (.MEM_STAT_VECT[1] NEQ 0) AND (ERR_HOLD EQL 1)
9521			THEN BEGIN		! 'UNCORR ERR HOLD' should not be
9522			     NOERR_26 = 1;	!   asserted (along with 'ERR HOLD'
9523			     ERRS(2,2,MEM_DAT);	! If it is - set flag, print message.
9524			     END;
9525		    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
9526	
9527		    IF ((.MEM_STAT AND %O'17777777') NEQ %O'11111') AND (ERR_HOLD EQL 1)
9528			THEN BEGIN		! Err Addr should be 11111 - if not
9529			     NOERR_26 = 1;	!   set flag and print error message.
9530			     ERRCAS(3,3,.MEM_CORR,.MEM_STAT,12,MEM_DATA[1]);
9531			     END;
9532		    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
9533		    0				! To eliminate INFO compiler message
9534		    END;
9535		    IF .NOERR_26 EQL 1 THEN RETURN;
9536		0				! To eliminate INFO compiler message
9537		END;
9538	
9539	! If Test 26 passed then 'MMC5 READ ERROR' logic is ok.
9540	
9541		IF .NOERR_26 EQL 0 THEN NOERR(1);
9542	
9543	! If Tests 17 and 26 passed then 'MMC5 ERR HOLD' logic is ok.
9544	
9545		IF (.NOERR_17 OR .NOERR_26) EQL 0 THEN NOERR(2);
9546	
9547	!*MESSAGE 1
9548	!*STIMULUS
9549	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9550	!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
9551	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9552	!*	EM 11111	Should cause single bit ECC err & set 'MMC5 ERR HOLD'
9553	!*RESPONSE
9554	!*	'MMC5 ERR HOLD' bit 00 not set (Mem Stat Reg: \U0 )
9555	
9556	!]ERROR 1
9557	!] H4 C5 E5 H6 C7 AC  NTWK
9558	!]NO ERROR 1
9559	!] E5  NTWK
9560	
9561	!*MESSAGE 2
9562	!*STIMULUS
9563	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9564	!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
9565	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9566	!*	EM 11111	Should cause single bit ECC err
9567	!*RESPONSE
9568	!*	Double bit error was detected - 'MMC4 UNCORR ERR HOLD'
9569	!*	   bit 01 set (Mem Stat Reg: \U0 )
9570	
9571	!]ERROR 2
9572	!] A_G4 H4 J4 K4 L4 M4 G5 H5 G6 H6 C7 AC  NTWK
9573	!]NO ERROR 2
9574	!] C5  NTWK
9575	
9576	!*MESSAGE 3
9577	!*STIMULUS
9578	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9579	!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
9580	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9581	!*	EM 11111	Should cause single bit err & load MMC8 Err Addr Reg
9582	!*RESPONSE
9583	!*	'MMC8 ERR ADDR' incorrect
9584	
9585	!]ERROR 3
9586	!] D1 E1 F1 G1 H1 I1 J1 I5 F7 G7 H7 I7 J7 K7 AC  NTWK
9587	!]NO ERROR 3
9588	!]  NTWK
9589	
9590	END;
9591	GLOBAL ROUTINE TST27: NOVALUE =
9592	
9593	!++   ------------ ECC:  DETECTION OF SINGLE BIT ERRORS ---------
9594	! TEST DESCRIPTION:  This routine verifies some of the ECC logic.
9595	!	In particular it tests the parity generator on MMC5 which
9596	!	determines whether there is a single or double bit error.
9597	!	All of the ECC errors  generated  in  this test should be
9598	!	single bit errors.
9599	!
9600	! TEST ASSUMPTIONS:  None.
9601	!
9602	! TEST PROCEDURE:  Write status - Shut off ECC
9603	!				- Set force bits (0000111)
9604	!		   Write 0's to mem location 11111
9605	!		   Examine mem loc 11111 - Sets 'ERR HOLD'
9606	!					 - Does not set 'UNCORR ERR HOLD'
9607	!		   Read Mem Status Reg - should show:
9608	!				ERR HOLD on
9609	!				UNCOR ERR HOLD off
9610	!				Err Addr is 11111
9611	!		   Repeat with force bits shifted left a bit at a time
9612	!		   Repeat with 0011111 .. and 1111111
9613	!
9614	! POSSIBLE ERRORS:  Parity generator, AND gates, & OR gate determining
9615	!			'MMC5 READ ERROR' and 'MMC5 UNCORRECTIBLE ERR'
9616	!
9617	!--
9618	
9619	BEGIN
9620	
9621	MACRO
9622		ERR_HOLD = .MEM_STAT_VECT[0]%;	! Error hold bit
9623	
9624	LITERAL
9625		ECC_OFF = %O'700000000001';	! Turn off ECC
9626	
9627	LOCAL
9628		TEMP,
9629		ERR_FLAG,			! Error flag
9630		MEM_CORR;			! Correct memory data
9631	
9632	OWN
9633		FORCE_BITS: VECTOR[9]		! Force bits to use for this test
9634		    INITIAL (%B'0000111',%B'0001110',%B'0011100',
9635			%B'0111000',%B'1110000',%B'0011111',%B'0111110',
9636			%B'1111100',%B'1111111'),
9637		MEM_DATA: VECTOR[2],
9638		MEM_STAT_VECT: BTTVECTOR[36];
9639	
9640	BIND
9641		MEM_DAT = MEM_DATA,
9642		MEM_STAT = MEM_STAT_VECT;
9643	
9644	LABEL
9645		BLOCK1;
9646	
9647	IF RUN_TEST(27) THEN RETURN;		! Run this test? Return if no
9648	
9649	NOERR_27 = 0;				! No errors have occurred yet
9650	RPT_ERR_FLAG = 0;			! Don't report unexpected error
9651	ERR_FLAG = 0;
9652	
9653	INCR FORCE FROM 0 TO 8 DO		! For each set of force bits:
9654		BEGIN
9655		DO (0) WHILE
9656	BLOCK1:	    BEGIN
9657		    MR();			! Master Reset
9658		    TEMP = ECC_OFF+.FORCE_BITS[.FORCE]^1;
9659		    IO_DEPOSIT(MSR,.TEMP);	! Write force bits
9660		    DM(11111,0);		! Write to mem loc 11111
9661		    EM(11111);			! Read it back - causes ECC error
9662	
9663	! Now check the results.
9664	
9665		    MEM_DATA[0] = MEM_STAT = IO_EXAMINE(MSR);
9666		    MEM_CORR = %O'400000011111' OR .FORCE_BITS[.FORCE]^23;
9667		    MEM_DATA[1] = .FORCE_BITS[.FORCE];
9668		    IF ERR_HOLD NEQ 1		! If 'ERR HOLD' not asserted (didnt
9669			THEN BEGIN		!   cause ECC error??) - set error
9670			     ECC_SINGLE = 1;	!   flags and print error message.
9671			     NOERR_27 = 1;
9672			     ERRS(1,1,MEM_DAT);
9673			     END;
9674		    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
9675	
9676		    IF ((.MEM_STAT_VECT[1] EQL 0) AND (ERR_HOLD EQL 1)) EQL 0
9677			THEN BEGIN		! 'UNCORR ERR HOLD' should not be
9678			     ERR_FLAG = 1;	!   asserted (along with 'ERR HOLD'
9679			     NOERR_27 = 1;	! If it is - set flag, print message.
9680			     ERRS(2,2,MEM_DAT);
9681			     END;
9682		    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
9683	
9684		    IF ((.MEM_STAT AND %O'17777777') NEQ %O'11111') AND (ERR_HOLD EQL 1)
9685			THEN BEGIN		! Err Addr should be 11111 - if not
9686			     NOERR_27 = 1;	!   set flag and print error message.
9687			     ERRCAS(3,3,.MEM_CORR,.MEM_STAT,12,MEM_DATA[1]);
9688			     END;
9689		    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
9690		    IF .ERR_FLAG EQL 1 THEN RETURN;
9691		    0				! To eliminate INFO compiler message
9692		    END;
9693		    IF .NOERR_27 EQL 1 THEN RETURN;
9694		END;
9695	
9696	! If Tests 17 and 27 both passed then 'MMC5 ERR HOLD' logic is ok.
9697	
9698		IF (.NOERR_17 OR .NOERR_27) EQL 0 THEN NOERR(1);
9699	
9700	!*MESSAGE 1
9701	!*STIMULUS
9702	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9703	!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
9704	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9705	!*	EM 11111	Should cause single bit ECC err & set 'MMC5 ERR HOLD'
9706	!*RESPONSE
9707	!*	'MMC5 ERR HOLD' bit 00 not set (Mem Stat Reg: \U0 )
9708	
9709	!]ERROR 1
9710	!] C5 E5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
9711	!]NO ERROR 1
9712	!] C5  NTWK
9713	
9714	!*MESSAGE 2
9715	!*STIMULUS
9716	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9717	!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
9718	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9719	!*	EM 11111	Should cause single bit ECC err
9720	!*RESPONSE
9721	!*	Double bit error was detected - 'MMC4 UNCORR ERR HOLD'
9722	!*	   Bit 01 set (Mem Stat Reg: \U0 )
9723	
9724	!]ERROR 2
9725	!] J4 G5 H5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
9726	!]NO ERROR 2
9727	!]  NTWK
9728	
9729	!*MESSAGE 3
9730	!*STIMULUS
9731	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9732	!*	DI (STATUS)	  Set force bits \O1, Turn off ECC
9733	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9734	!*	EM 11111	Should cause single bit err & load MMC8 Err Addr Reg
9735	!*RESPONSE
9736	!*	'MMC8 ERR ADDR' incorrect
9737	
9738	!]ERROR 3
9739	!] D1 E1 F1 G1 H1 I1 J1 I5 F7 G7 H7 I7 J7 K7 AC  NTWK
9740	!]NO ERROR 3
9741	!]  NTWK
9742	
9743	END;
9744	GLOBAL ROUTINE TST28: NOVALUE =
9745	
9746	!++   ------------ ECC:  DETECTION OF DOUBLE BIT ERRORS ---------
9747	! TEST DESCRIPTION:  This routine verifies some of the ECC logic.
9748	!	In particular it tests the parity generator on MMC5 which
9749	!	determines whether there is a single or double bit error.
9750	!	All of the ECC errors  generated  in  this test should be
9751	!	double bit errors.
9752	!
9753	! TEST ASSUMPTIONS: None.
9754	!
9755	! TEST PROCEDURE:  Write status - Shut off ECC
9756	!				- Set force bits (0000011)
9757	!		   Write 0's to mem location 11111
9758	!		   Examine mem loc 11111 - Sets 'ERR HOLD'
9759	!					 - Sets 'UNCORR ERR HOLD'
9760	!		   Read Mem Status Reg - should show:
9761	!				Err Hold on
9762	!				Uncor Err Hold on
9763	!				Err Addr is 11111
9764	!		   Repeat with force bits shifted left a bit at a time
9765	!		   Repeat with 0001111 .. and 0111111 ..
9766	!
9767	! POSSIBLE ERRORS:  Parity generator, AND gates, & OR gate determining
9768	!			'MMC5 READ ERROR' and 'MMC5 UNCORRECTIBLE ERR'
9769	!
9770	!--
9771	
9772	BEGIN
9773	
9774	MACRO
9775		ERR_HOLD = .MEM_STAT_VECT[0]%;	! Error hold bit
9776	
9777	LITERAL
9778		RESET = %O'700000000000',	! Clear MSR error bits & turn on ECC
9779		ECC_ON = %O'700000000000';	! Clear MSR error bits & turn on ECC
9780	
9781	LOCAL
9782		TEMP,
9783		ERR_FLAG,			! Error flag
9784		MEM_CORR;			! Correct data expected from memory
9785	
9786	OWN
9787		FORCE_BITS: VECTOR[12]		! Force bits to use for this test
9788		    INITIAL (%B'0000011',%B'0000110',%B'0001100',
9789			%B'0011000',%B'0110000',%B'1100000',%B'0001111',
9790			%B'0011110',%B'0111100',%B'1111000',%B'0111111',
9791			%B'1111110'),
9792		MEM_DATA: VECTOR[2],
9793		MEM_STAT_VECT: BTTVECTOR[36];
9794	
9795	BIND
9796		MEM_DAT = MEM_DATA,
9797		MEM_STAT = MEM_STAT_VECT;
9798	
9799	LABEL
9800		BLOCK1;
9801	
9802	IF RUN_TEST(28) THEN RETURN;		! Run this test? Return if no
9803	
9804	NOERR_28 = 0;				! No errors have occurred yet
9805	RPT_ERR_FLAG = 0;			! Don't report unexpected error
9806	ERR_FLAG = 0;
9807	
9808	INCR FORCE FROM 0 TO 11 DO		! For each set of force bits:
9809		BEGIN
9810		DO (0) WHILE
9811	BLOCK1:	    BEGIN
9812		    MR();			! Master Reset
9813		    TEMP = ECC_ON+.FORCE_BITS[.FORCE]^1;
9814		    IO_DEPOSIT(MSR,.TEMP);	! Write force bits
9815		    DM(11111,0);		! Write to mem loc 11111
9816		    EM(11111);			! Read it back - causes ECC error
9817	
9818	! Now check the results.
9819	
9820		    MEM_DATA[0] = MEM_STAT = IO_EXAMINE(MSR);
9821		    MEM_CORR = %O'400000011111' OR .FORCE_BITS[.FORCE]^23;
9822		    MEM_DATA[1] = .FORCE_BITS[.FORCE];
9823		    IF ERR_HOLD NEQ 1		! If 'ERR HOLD' not asserted (didnt
9824			THEN BEGIN		!   cause ECC error??) - set error
9825			     ECC_DOUBLE = 1;	!   flags and print error message.
9826			     NOERR_28 = 1;
9827			     ERRS(1,1,MEM_DAT);
9828			     END;
9829		    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
9830	
9831		    IF ((.MEM_STAT_VECT[1] EQL 1) AND (ERR_HOLD EQL 1)) NEQ 1
9832			THEN BEGIN		! 'UNCORR ERR HOLD' should be
9833			     ERR_FLAG = 1;	!   asserted (along with 'ERR HOLD'
9834			     NOERR_28 = 1;	! If not - set flag, print message.
9835			     ERRS(2,2,MEM_DAT);
9836			     END;
9837		    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
9838	
9839		    IF ((.MEM_STAT AND %O'17777777') NEQ %O'11111') AND (ERR_HOLD EQL 1)
9840			THEN BEGIN		! Err Addr should be 11111 - if not
9841			     NOERR_28 = 1;	!   set flag and print error message.
9842			     ERRCAS(3,3,.MEM_CORR,.MEM_STAT,12,MEM_DATA[1]);
9843			     END;
9844		    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
9845		    IF .ERR_FLAG EQL 1 THEN RETURN;
9846		    0				! To eliminate INFO compiler message
9847		    END;
9848	
9849		IO_DEPOSIT(MSR,RESET);		! Reset MMC particularly the
9850		DM(0,0);			!   'UNCORR ERR HOLD' which was
9851		EM(0);				!   set by the double bit error.
9852		END;
9853	
9854	! If Tests 26 and 28 passed then 'MMC4 UNCOR ERR HOLD' logic is ok.
9855	
9856		IF (.NOERR_26 OR .NOERR_28) EQL 0 THEN NOERR(1);
9857	
9858	! If Tests 27 and 28 passed then 'MMC4 UNCOR ERR HOLD' logic is ok.
9859	
9860		IF (.NOERR_27 OR .NOERR_28) EQL 0 THEN NOERR(1);
9861	
9862	! If Tests 17 and 28 passed then 'MMC5 ERR HOLD' logic is ok.
9863	
9864		IF (.NOERR_17 OR .NOERR_28) EQL 0 THEN NOERR(2);
9865	
9866	!*MESSAGE 1
9867	!*STIMULUS
9868	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9869	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
9870	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9871	!*	EM 11111	Should cause double bit ECC err & set 'MMC5 ERR HOLD'
9872	!*RESPONSE
9873	!*	'MMC5 ERR HOLD' bit 00 not set (Mem Stat Reg: \U0 )
9874	
9875	!]ERROR 1
9876	!] C5 E5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
9877	!]NO ERROR 1
9878	!] J4  NTWK
9879	
9880	!*MESSAGE 2
9881	!*STIMULUS
9882	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9883	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
9884	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9885	!*	EM 11111	Should cause double bit ERR & set 'MMC4 UNCOR ERR HOLD'
9886	!*RESPONSE
9887	!*	'MMC4 UNCOR ERR HOLD' bit 01 not set (Mem Stat Reg: \U0 )
9888	
9889	!]ERROR 2
9890	!] J4 G5 H5 C7 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
9891	!]NO ERROR 2
9892	!] C5  NTWK
9893	
9894	!*MESSAGE 3
9895	!*STIMULUS
9896	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...
9897	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
9898	!*	LA 11111,DM 0	Write 0's to mem loc 11111
9899	!*	EM 11111	Should cause double bit ERR & load MMC8 Err Addr Reg
9900	!*RESPONSE
9901	!*	'MMC8 ERR ADDR' incorrect
9902	
9903	!]ERROR 3
9904	!] D1 E1 F1 G1 H1 I1 J1 I5 F7 G7 H7 I7 J7 K7 AC  NTWK
9905	!]NO ERROR 3
9906	!]  NTWK
9907	
9908	END;
9909	GLOBAL ROUTINE TST29: NOVALUE =
9910	
9911	!++   ------------ ECC:  SETTING OF 'ERR HOLD' BIT -------------
9912	! TEST DESCRIPTION:  This routine verifies the 'ERR HOLD' bit in
9913	!	the Memory Status Register. It appears as a flop on MMC5
9914	!	and signals  whether or not there is data latched in the
9915	!	error holding register.
9916	!
9917	! TEST ASSUMPTIONS:  None.
9918	!
9919	! TEST PROCEDURE:  Do a Master Reset
9920	!		   Read MSR - Verify 'ERR HOLD' off
9921	!		   Write MSR force bits 0000111
9922	!		   Write 0's to mem loc 22222
9923	!		   Read MSR - Verify 'ERR HOLD' still off
9924	!		   Examine mem loc 22222 (Should set 'ERR HOLD')
9925	!		   Read MSR - Verify 'ERR HOLD' now on
9926	!		   Read MSR - Verify 'ERR HOLD' now off
9927	!
9928	!		   Repeat with 1's to mem loc 22222
9929	!
9930	! POSSIBLE ERRORS:  'MMC5 ERR HOLD' flop faulty or logic just before
9931	!			is faulty
9932	!
9933	!--
9934	
9935	BEGIN
9936	
9937	LITERAL
9938		FORCE_SET = %O'700000000016';	! Set force bits 007, clear errors
9939	
9940	OWN
9941		MESS_STR: VECTOR[2]		! Error message strings
9942		    INITIAL(UPLIT(%ASCIZ '0'),UPLIT(%ASCIZ '-1')),
9943		MESSV: VECTOR[2];		! Error message output vector
9944	
9945	BIND
9946		MEM_STAT = MESSV[0];
9947	
9948	LABEL
9949		BLOCK1,
9950		BLOCK2;
9951	
9952	IF RUN_TEST(29) THEN RETURN;		! Run this test? Return if no
9953	
9954	NOERR_29 = 0;				! No errors have occurred yet
9955	RPT_ERR_FLAG = 0;			! Don't report unexpected error
9956	
9957	! First half of test - writing 0's to memory.
9958	
9959	MESSV[2] = .MESS_STR[0];
9960	DO (0) WHILE
9961	BLOCK1:	BEGIN
9962		MR();				! Master Reset
9963		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure 'ERR HOLD'
9964		IF .MEM_STAT LSS 0		!   is not set - if it is set error
9965		    THEN BEGIN			!   flag and print error message.
9966			 NOERR_29 = 1;
9967			 ERRS(1,1,MESSV);
9968			 END;
9969		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
9970	
9971		IO_DEPOSIT(MSR,FORCE_SET);	! Now write force bits
9972		DM(22222,0);			! Write 0's to mem loc 22222
9973		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure that
9974		IF .MEM_STAT LSS 0		!   'ERR HOLD' is still not set
9975		    THEN BEGIN			! If it is - set error flag and
9976			 NOERR_29 = 1;		!   print error message.
9977			 ERRS(2,2,MESSV);
9978			 END;
9979		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
9980	
9981		EM(22222);			! Now read data back (cause ECC error)
9982		MEM_STAT = IO_EXAMINE(MSR);	! Check MSR (should show 'ERR HOLD' set)
9983		IF .MEM_STAT GEQ 0		! If 'ERR HOLD' not set - set error
9984		    THEN BEGIN			!   flag and print error message
9985			 NOERR_29 = 1;
9986			 ERRS(3,3,MESSV);
9987			 END;
9988		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
9989	
9990		MR();				! Master Reset
9991		MEM_STAT = IO_EXAMINE(MSR);	! Now see if 'ERR HOLD' clears after
9992		IF .MEM_STAT LSS 0		!   a MR - If it doesnt - set error
9993		    THEN BEGIN			!   flag and print error message.
9994			 NOERR_29 = 1;
9995			 ERRS(4,4,MESSV);
9996			 END;
9997		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
9998		0				! To eliminate INFO compiler message
9999		END;
10000	
10001	! If Tests 17 and 29 (so far) passed then 'MMC5 ERR HOLD' logic is ok.
10002	
10003		IF (.NOERR_17 OR .NOERR_29) EQL 0 THEN NOERR(1);
10004	
10005	! If this test already failed there is no need to run the second half.
10006	
10007		IF .NOERR_29 EQL 1 THEN RETURN;
10008	
10009	! Second half of test - writing 0's to memory.
10010	
10011	MESSV[2] = .MESS_STR[1];
10012	DO (0) WHILE
10013	BLOCK2:	BEGIN
10014		MR();				! Master Reset
10015		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure 'ERR HOLD'
10016		IF .MEM_STAT LSS 0		!   is not set - if it is set error
10017		    THEN BEGIN			!   flag and print error message.
10018			 NOERR_29 = 1;
10019			 ERRS(1,1,MESSV);
10020			 END;
10021		IF LOOP_CHK(1) THEN LEAVE BLOCK2 WITH 1;
10022	
10023		IO_DEPOSIT(MSR,FORCE_SET);	! Now write force bits
10024		MEM_DEPOSIT(%O'22222',-1);	! Write 1's to mem loc 22222
10025		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR and make sure that
10026		IF .MEM_STAT LSS 0		!   'ERR HOLD' is still not set
10027		    THEN BEGIN			! If it is - set error flag and
10028			 NOERR_29 = 1;		!   print error message.
10029			 ERRS(2,2,MESSV);
10030			 END;
10031		IF LOOP_CHK(2) THEN LEAVE BLOCK2 WITH 1;
10032	
10033		EM(22222);			! Now read data back (cause ECC error)
10034		MEM_STAT = IO_EXAMINE(MSR);	! Check MSR (should show 'ERR HOLD' set)
10035		IF .MEM_STAT GEQ 0		! If 'ERR HOLD' not set - set error
10036		    THEN BEGIN			!   flag and print error message
10037			 NOERR_29 = 1;
10038			 ERRS(3,3,MESSV);
10039			 END;
10040		IF LOOP_CHK(3) THEN LEAVE BLOCK2 WITH 1;
10041	
10042		MR();				! Master Reset
10043		MEM_STAT = IO_EXAMINE(MSR);	! Now see if 'ERR HOLD' clears after
10044		IF .MEM_STAT LSS 0		!   a MR - If it doesnt - set error
10045		    THEN BEGIN			!   flag and print error message.
10046			 NOERR_29 = 1;
10047			 ERRS(4,4,MESSV);
10048			 END;
10049		IF LOOP_CHK(4) THEN LEAVE BLOCK2 WITH 1;
10050		0				! To eliminate INFO compiler message
10051		END;
10052	
10053	! If Tests 17 and 29 passed then 'MMC5 ERR HOLD' logic is ok.
10054	
10055		IF (.NOERR_17 OR .NOERR_29) EQL 0 THEN NOERR(1);
10056	
10057	!*MESSAGE 1
10058	!*STIMULUS:
10059	!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
10060	!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should not be set)
10061	!*RESPONSE:
10062	!*	'MMC5 ERR HOLD' bit 00 set
10063	
10064	!]ERROR 1
10065	!] C5 E5 AC  NTWK
10066	!]NO ERROR 1
10067	!] C5  NTWK
10068	
10069	!*MESSAGE 2
10070	!*STIMULUS:
10071	!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
10072	!*	EI 100000	Read Mem Status Register
10073	!*	DI 700000000016	Write Mem Stat Reg:  Set force bits 0000111
10074	!*	LA 22222,DM \S1	Write \S1 to mem loc 22222
10075	!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should not be set)
10076	!*RESPONSE:
10077	!*	'MMC5 ERR HOLD' bit 00 set
10078	
10079	!]ERROR 2
10080	!] C5 E5 AC  NTWK
10081	!]NO ERROR 2
10082	!]  NTWK
10083	
10084	!*MESSAGE 3
10085	!*STIMULUS:
10086	!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
10087	!*	EI 100000	Read Mem Status Register
10088	!*	DI 700000000016	Write Mem Stat Reg:  Set force bits 0000111
10089	!*	LA 22222,DM \S1	Write \S1 to mem loc 22222
10090	!*	EI 100000	Read Mem Status Register
10091	!*	EM 22222	Examine mem loc 22222 (Should cause ECC error)
10092	!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should be set)
10093	!*RESPONSE:
10094	!*	'MMC5 ERR HOLD' bit 00 not set
10095	
10096	!]ERROR 3
10097	!] C5 E5 A_G4 H4 K4 L4 M4 G6 H6 AC  NTWK
10098	!]NO ERROR 3
10099	!]  NTWK
10100	
10101	!*MESSAGE 4
10102	!*STIMULUS:
10103	!*	MR		Ensure 'MMC5 ERR HOLD' is not asserted
10104	!*	EI 100000	Read Mem Status Register
10105	!*	DI 700000000016	Write Mem Stat Reg:  Set force bits 0000111
10106	!*	LA 22222,DM \S1	Write \S1 to mem loc 22222
10107	!*	EI 100000	Read Mem Status Register
10108	!*	EM 22222	Examine mem loc 22222 (Should cause ECC error)
10109	!*	EI 100000	Read Mem Status Register
10110	!*	MR		Clear 'MMC5 ERR HOLD'
10111	!*	EI 100000	Read Mem Status Reg: \U0 ('ERR HOLD' should not be set)
10112	!*RESPONSE:
10113	!*	'MMC5 ERR HOLD' bit 00 set
10114	
10115	!]ERROR 4
10116	!] C5 E5 AC  NTWK
10117	!]NO ERROR 4
10118	!]  NTWK
10119	
10120	END;
10121	GLOBAL ROUTINE TST30: NOVALUE =
10122	
10123	!++   ------------ ECC:  1 BIT ERROR NO CORRECTION (DATA 0'S) -------
10124	! TEST DESCRIPTION:  This routine verifies some of the ECC logic.  In
10125	!	particular it verifies that the decoders on MMC2 which decode
10126	!	which bit to correct are ok.  This is accomplished by writing
10127	!	patterns of force bits to cause a read error.   The  patterns
10128	!	used do not match any of the patterns  which  would correct a
10129	!	particular bit. Hence no actual error correction will be made.
10130	!	All of the patterns indicate a single bit error.
10131	!
10132	! TEST ASSUMPTIONS:  None.
10133	!
10134	! TEST PROCEDURE:  MR
10135	!		   Write status to MMC board - Set force bits (0000001)
10136	!		   Write 0's to mem location 0
10137	!		   Examine mem loc 0 - should show data is all 0's (no
10138	!			correction).  If the data is not 0 then read
10139	!			Mem Status Reg and print out relevant data.
10140	!		   Repeat above steps for the remaining patterns which
10141	!			indicate an 'Uncorrectable' single bit error
10142	!
10143	! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
10144	!
10145	!--
10146	
10147	BEGIN
10148	
10149	LITERAL
10150		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
10151	
10152	LOCAL
10153		TEST_DATA,			! Data writen to mem
10154		ERR_FLAG,			! Error flag
10155		MEM_STAT,			! Data read from MSR
10156		MEM_DATA;			! Data read from mem
10157	
10158	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
10159	!   sections match the bits as they are segregated in the ECC section of
10160	!   the MMC board.
10161	! FORCE_BITS - patterns which should not cause any error correction to be
10162	!   done but still indicate a single bit error (an odd number of 1's).
10163	
10164	OWN
10165		MASK: VECTOR[6]
10166		    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
10167			     %O'777777007777',%O'777777770077',%O'777777777700'),
10168		FORCE_BITS: VECTOR[15]
10169		    INITIAL (%B'0000001',%B'0000010',%B'1000011',
10170			%B'0000100',%B'1000101',%B'1000110',%B'0000111',
10171			%B'0111000',%B'1111001',%B'1111010',%B'0111011',
10172			%B'1111100',%B'0111101',%B'0111110',%B'1111111'),
10173		DATA_VECT: VECTOR[2];
10174	
10175	BIND
10176		IO_DATA = DATA_VECT;
10177	
10178	LABEL
10179		BLOCK1;
10180	
10181	IF RUN_TEST(30) THEN RETURN;		! Run this test? Return if no
10182	
10183	NOERR_30 = 0;				! No errors have occurred yet
10184	RPT_ERR_FLAG = 0;			! Don't report unexpected error
10185	
10186	INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
10187		BEGIN
10188		DO (0) WHILE
10189	BLOCK1:	    BEGIN
10190		    MR();			! Master Reset
10191	
10192		    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
10193		    TEST_DATA = EM(0);		!   data comes back after writing 0's
10194	
10195	! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.
10196	
10197		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
10198		    MEM_DEPOSIT(0,0);
10199		    DATA_VECT[1] = .FORCE_BITS[.TEST];
10200		    MEM_DATA = MEM_EXAMINE(0);
10201	
10202	! Now check to see if there is any error and which section of bits it is in.
10203	! For any errors set error flags and print error message.
10204	
10205		    ERR_FLAG = 0;
10206		    INCR BTT FROM 0 TO 5 DO
10207			BEGIN
10208			IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
10209			    THEN BEGIN
10210				 ERR_FLAG = 1;
10211				 IO_DATA = IO_EXAMINE(MSR);
10212				 NOERR_30 = 1;
10213				 ERRCAS(.BTT+1,1,0,.MEM_DATA,12,DATA_VECT);
10214				 END;
10215			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
10216			END;
10217	
10218	! If the error is not in a single section of bits - write out error message.
10219	
10220		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
10221			THEN BEGIN
10222			     ERR_FLAG = 1;
10223			     IO_DATA = IO_EXAMINE(MSR);
10224			     NOERR_30 = 1;
10225			     ERRCAS(7,1,0,.MEM_DATA,12,DATA_VECT);
10226			     END;
10227		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
10228		    IF .ERR_FLAG EQL 1 THEN RETURN;
10229		    0				! To eliminate INFO compiler message
10230		    END;
10231		END;
10232	
10233	!*MESSAGE 1
10234	!*STIMULUS
10235	!*	MR		Clear everything
10236	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
10237	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
10238	!*	LA 0,DM 0	Write 0's to mem loc 0
10239	!*	EM 0		Examine mem loc (Should cause single bit error
10240	!*			  - Data should not be corrected)
10241	!*RESPONSE
10242	!*	Data returned was corrected (Mem Stat Reg: \U0 )
10243	
10244	!]ERROR 1
10245	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10246	!]NO ERROR 1
10247	!]  NTWK
10248	
10249	!]ERROR 2
10250	!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10251	!]NO ERROR 2
10252	!]  NTWK
10253	
10254	!]ERROR 3
10255	!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10256	!]NO ERROR 3
10257	!]  NTWK
10258	
10259	!]ERROR 4
10260	!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10261	!]NO ERROR 4
10262	!]  NTWK
10263	
10264	!]ERROR 5
10265	!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10266	!]NO ERROR 5
10267	!]  NTWK
10268	
10269	!]ERROR 6
10270	!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10271	!]NO ERROR 6
10272	!]  NTWK
10273	
10274	!]ERROR 7
10275	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10276	!]NO ERROR 7
10277	!]  NTWK
10278	
10279	END;
10280	GLOBAL ROUTINE TST31: NOVALUE =
10281	
10282	!++   ------------ ECC:  1 BIT ERROR CORRECTION (DATA 0'S) -----------
10283	! TEST DESCRIPTION:  This routine verifies  some of the ECC logic.  In
10284	!	particular it verifies that  the decoders on MMC2 which decode
10285	!	which bit to correct are ok.  This is  accomplished by writing
10286	!	patterns of force bits to cause a single bit correctable error.
10287	!	The logic corrects  the  data  when it is read and the program
10288	!	verifies that the correct bit was complemented.
10289	!
10290	! TEST ASSUMPTIONS:  None.
10291	!
10292	! TEST PROCEDURE:  MR
10293	!		   Write status to MMC board - Set force bits (1001001)
10294	!		   Write 0's to mem location 0
10295	!		   Examine mem loc 0 - should show data is all 0's with a
10296	!			single bit corrected to a 1. If the data is 0 then
10297	!			read Mem Status Reg and print out relevant data.
10298	!		   Repeat above steps for all other patterns which
10299	!			correct bits 00-35
10300	!
10301	! POSSIBLE ERRORS:  Logic on MMC2 is faulty
10302	!
10303	!--
10304	
10305	BEGIN
10306	
10307	LITERAL
10308		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
10309	
10310	LOCAL
10311		TEST_DATA,			! Data writen to mem
10312		ERR_FLAG,			! Error flag
10313		MEM_CORR,			! Corrected data as it should appear
10314		MEM_STAT,			! Data read from MSR
10315		MEM_DATA;			! Data read from mem
10316	
10317	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
10318	!   sections match the bits as they are segregated in the ECC section of
10319	!   the MMC board.
10320	! FORCE_BITS - patterns which should cause error correction to be done
10321	!   (ie. a single bit error with a valid ECC code).
10322	
10323	OWN
10324		MASK: VECTOR[6]
10325		    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
10326			     %O'777777007777',%O'777777770077',%O'777777777700'),
10327		FORCE_BITS: VECTOR[36]
10328		    INITIAL (%B'1001001',%B'1001010',%B'0001011',
10329			%B'1001100',%B'0001101',%B'0001110',%B'1010001',
10330			%B'1010010',%B'0010011',%B'1010100',%B'0010101',
10331			%B'0010110',%B'0011001',%B'0011010',%B'1011011',
10332			%B'0011100',%B'1011101',%B'1011110',%B'1100001',
10333			%B'1100010',%B'0100011',%B'1100100',%B'0100101',
10334			%B'0100110',%B'0101001',%B'0101010',%B'1101011',
10335			%B'0101100',%B'1101101',%B'1101110',%B'0110001',
10336			%B'0110010',%B'1110011',%B'0110100',%B'1110101',
10337			%B'1110110'),
10338		DATA_VECT: VECTOR[3];
10339	
10340	BIND
10341		IO_DATA = DATA_VECT;
10342	
10343	LABEL
10344		BLOCK1;
10345	
10346	IF RUN_TEST(31) THEN RETURN;		! Run this test? Return if no
10347	
10348	NOERR_31 = 0;				! No errors have occurred yet
10349	RPT_ERR_FLAG = 0;			! Don't report unexpected error
10350	
10351	INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
10352		BEGIN
10353		DO (0) WHILE
10354	BLOCK1:	    BEGIN
10355		    MR();			! Master Reset
10356		    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
10357		    TEST_DATA = EM(0);		!   data comes back after writing 0's
10358	
10359	! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.
10360	
10361		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
10362		    MEM_DEPOSIT(0,0);
10363		    DATA_VECT[1] = .FORCE_BITS[.TEST];
10364		    DATA_VECT[2] = .TEST;
10365		    MEM_DATA = MEM_EXAMINE(0);
10366		    MEM_CORR = 1^(35-.TEST) OR .TEST_DATA;
10367	
10368	! Now check to see if there is any error and which section of bits it is in.
10369	! For any errors set error flags and print error message.
10370	
10371		    ERR_FLAG = 0;
10372		    INCR BTT FROM 0 TO 5 DO
10373			BEGIN
10374			IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .MEM_CORR)
10375			    THEN BEGIN
10376				 ERR_FLAG = 1;
10377				 IO_DATA = IO_EXAMINE(MSR);
10378				 NOERR_31 = 1;
10379				 ERRCAS(.BTT+1,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
10380				 END;
10381			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
10382			END;
10383	
10384	! If the error is not in a single section of bits - write out error message.
10385	
10386		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .MEM_CORR)
10387			THEN BEGIN
10388			     ERR_FLAG = 1;
10389			     IO_DATA = IO_EXAMINE(MSR);
10390			     NOERR_31 = 1;
10391			     ERRCAS(7,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
10392			     END;
10393		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
10394		    IF .ERR_FLAG EQL 1 THEN RETURN;
10395		    0				! To eliminate INFO compiler message
10396		    END;
10397		END;
10398	
10399	!*MESSAGE 1
10400	!*STIMULUS
10401	!*	MR		Clear everything
10402	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
10403	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
10404	!*	LA 0,DM 0	Write 0's to mem loc 0
10405	!*	EM 0		Examine mem loc (Should cause single bit error
10406	!*			  (Bit \D2) - and complement it
10407	!*RESPONSE
10408	!*	Data returned was not corrected (Mem Stat Reg: \U0 )
10409	
10410	!]ERROR 1
10411	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10412	!]NO ERROR 1
10413	!]  NTWK
10414	
10415	!]ERROR 2
10416	!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10417	!]NO ERROR 2
10418	!]  NTWK
10419	
10420	!]ERROR 3
10421	!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10422	!]NO ERROR 3
10423	!]  NTWK
10424	
10425	!]ERROR 4
10426	!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10427	!]NO ERROR 4
10428	!]  NTWK
10429	
10430	!]ERROR 5
10431	!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10432	!]NO ERROR 5
10433	!]  NTWK
10434	
10435	!]ERROR 6
10436	!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10437	!]NO ERROR 6
10438	!]  NTWK
10439	
10440	!]ERROR 7
10441	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10442	!]NO ERROR 7
10443	!]  NTWK
10444	
10445	END;
10446	GLOBAL ROUTINE TST32: NOVALUE =
10447	
10448	!++   ------------ ECC:  1 BIT ERROR NO CORRECTION (DATA 1'S) -------
10449	! TEST DESCRIPTION:  This routine verifies some of the ECC logic.  In
10450	!	particular it verifies that the decoders on MMC2 which decode
10451	!	which bit to correct are ok.  This is accomplished by writing
10452	!	patterns of force bits to cause a  read error.   The patterns
10453	!	used do not match any of  the  patterns which would correct a
10454	!	particular bit. Hence no actual error correction will be made.
10455	!	All of the patterns indicate a single bit error.
10456	!
10457	! TEST ASSUMPTIONS:  None.
10458	!
10459	! TEST PROCEDURE:  MR
10460	!		   Write status to MMC board - Set force bits (0000001)
10461	!		   Write 1's to mem location 0
10462	!		   Examine mem loc 0 - should show data is
10463	!			all 1's (no correction).  If the data is not 0
10464	!			then read Mem Status Reg and print out relevant
10465	!			data.
10466	!		   Repeat above steps for the remaining patterns which
10467	!			indicate an 'uncorrectable' single bit error.
10468	!
10469	! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
10470	!
10471	!--
10472	
10473	BEGIN
10474	
10475	LITERAL
10476		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
10477	
10478	LOCAL
10479		TEST_DATA,			! Data writen to mem
10480		ERR_FLAG,			! Error flag
10481		MEM_STAT,			! Data read from MSR
10482		MEM_DATA;			! Data read from mem
10483	
10484	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
10485	!   sections match the bits as they are segregated in the ECC section of
10486	!   the MMC board.
10487	! FORCE_BITS - patterns which should not cause any error correction to be
10488	!   done but still indicate a single bit error (an odd number of 1's).
10489	
10490	OWN
10491		MASK: VECTOR[6]
10492		    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
10493			     %O'000000770000',%O'000000007700',%O'000000000077'),
10494		FORCE_BITS: VECTOR[15]
10495		    INITIAL (%B'0000001',%B'0000010',%B'1000011',
10496			%B'0000100',%B'1000101',%B'1000110',%B'0000111',
10497			%B'0111000',%B'1111001',%B'1111010',%B'0111011',
10498			%B'1111100',%B'0111101',%B'0111110',%B'1111111'),
10499		DATA_VECT: VECTOR[2];
10500	
10501	BIND
10502		IO_DATA = DATA_VECT;
10503	
10504	LABEL
10505		BLOCK1;
10506	
10507	IF RUN_TEST(32) THEN RETURN;		! Run this test? Return if no
10508	
10509	NOERR_32 = 0;				! No errors have occurred yet
10510	RPT_ERR_FLAG = 0;			! Don't report unexpected error
10511	
10512	INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
10513		BEGIN
10514		DO (0) WHILE
10515	BLOCK1:	    BEGIN
10516		    MR();			! Master Reset
10517	
10518		    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
10519		    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's
10520	
10521	! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.
10522	
10523		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
10524		    MEM_DEPOSIT(0,-1);
10525		    DATA_VECT[1] = .FORCE_BITS[.TEST];
10526		    MEM_DATA = MEM_EXAMINE(0);
10527	
10528	! Now check to see if there is any error and which section of bits it is in.
10529	! For any errors set error flags and print error message.
10530	
10531		    ERR_FLAG = 0;
10532		    INCR BTT FROM 0 TO 5 DO
10533			BEGIN
10534			IF ((.MEM_DATA OR .MASK[.BTT]) EQL -1) AND (.MEM_DATA NEQ .TEST_DATA)
10535			    THEN BEGIN
10536				 ERR_FLAG = 1;
10537				 IO_DATA = IO_EXAMINE(MSR);
10538				 NOERR_32 = 1;
10539				 ERRCAS(.BTT+1,1,-1,.MEM_DATA,12,DATA_VECT);
10540				 END;
10541			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
10542			END;
10543	
10544	! If the error is not in a single section of bits - write out error message.
10545	
10546		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
10547			THEN BEGIN
10548			     ERR_FLAG = 1;
10549			     IO_DATA = IO_EXAMINE(MSR);
10550			     NOERR_32 = 1;
10551			     ERRCAS(7,1,-1,.MEM_DATA,12,DATA_VECT);
10552			     END;
10553		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
10554		    IF .ERR_FLAG EQL 1 THEN RETURN;
10555		    0				! To eliminate INFO compiler message
10556		    END;
10557		END;
10558	
10559	!*MESSAGE 1
10560	!*STIMULUS
10561	!*	MR		Clear everything
10562	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
10563	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
10564	!*	LA 0,DM 0	Write 1's to mem loc 0
10565	!*	EM 0		Examine mem loc (Should cause single bit error
10566	!*			  - But data should not be corrected)
10567	!*RESPONSE
10568	!*	Data returned was corrected (Mem Stat Reg: \U0 )
10569	
10570	!]ERROR 1
10571	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10572	!]NO ERROR 1
10573	!]  NTWK
10574	
10575	!]ERROR 2
10576	!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10577	!]NO ERROR 2
10578	!]  NTWK
10579	
10580	!]ERROR 3
10581	!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10582	!]NO ERROR 3
10583	!]  NTWK
10584	
10585	!]ERROR 4
10586	!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10587	!]NO ERROR 4
10588	!]  NTWK
10589	
10590	!]ERROR 5
10591	!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10592	!]NO ERROR 5
10593	!]  NTWK
10594	
10595	!]ERROR 6
10596	!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10597	!]NO ERROR 6
10598	!]  NTWK
10599	
10600	!]ERROR 7
10601	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10602	!]NO ERROR 7
10603	!]  NTWK
10604	
10605	END;
10606	GLOBAL ROUTINE TST33: NOVALUE =
10607	
10608	!++   ------------ ECC:  1 BIT ERROR CORRECTION (DATA 1'S) -----------
10609	! TEST DESCRIPTION:  This routine verifies  some of the ECC logic.  In
10610	!	particular it verifies  that the decoders on MMC2 which decode
10611	!	which bit to correct are ok.  This is  accomplished by writing
10612	!	patterns of force bits to cause a single bit correctable error.
10613	!	The logic corrects the data when it  is  read  and the program
10614	!	verifies that the correct bit was complemented.
10615	!
10616	! TEST ASSUMPTIONS:  None.
10617	!
10618	! TEST PROCEDURE:  MR
10619	!		   Write status to MMC board - Set force bits (1001001)
10620	!		   Write 1's to mem location 0
10621	!		   Examine mem loc 0 - should show data is all 1's with a
10622	!			single bit corrected to a 0. If the data is 1 then
10623	!			read Mem Status Reg and print out relevant data.
10624	!		   Repeat above steps for all other patterns which
10625	!			correct bits 00-35
10626	!
10627	! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
10628	!
10629	!--
10630	
10631	BEGIN
10632	
10633	LITERAL
10634		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
10635	
10636	LOCAL
10637		TEST_DATA,			! Data writen to mem
10638		ERR_FLAG,			! Error flag
10639		MEM_CORR,			! Corrected data as it should appear
10640		MEM_STAT,			! Data read from MSR
10641		MEM_DATA;			! Data read from mem
10642	
10643	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
10644	!   sections match the bits as they are segregated in the ECC section of
10645	!   the MMC board.
10646	! FORCE_BITS - patterns which should cause error correction to be done
10647	!   (ie. a single bit error with a valid ECC code).
10648	
10649	OWN
10650		MASK: VECTOR[6]
10651		    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
10652			     %O'000000770000',%O'000000007700',%O'000000000077'),
10653		FORCE_BITS: VECTOR[36]
10654		    INITIAL (%B'1001001',%B'1001010',%B'0001011',
10655			%B'1001100',%B'0001101',%B'0001110',%B'1010001',
10656			%B'1010010',%B'0010011',%B'1010100',%B'0010101',
10657			%B'0010110',%B'0011001',%B'0011010',%B'1011011',
10658			%B'0011100',%B'1011101',%B'1011110',%B'1100001',
10659			%B'1100010',%B'0100011',%B'1100100',%B'0100101',
10660			%B'0100110',%B'0101001',%B'0101010',%B'1101011',
10661			%B'0101100',%B'1101101',%B'1101110',%B'0110001',
10662			%B'0110010',%B'1110011',%B'0110100',%B'1110101',
10663			%B'1110110'),
10664		DATA_VECT: VECTOR[3];
10665	
10666	BIND
10667		IO_DATA = DATA_VECT;
10668	
10669	LABEL
10670		BLOCK1;
10671	
10672	IF RUN_TEST(33) THEN RETURN;		! Run this test? Return if no
10673	
10674	NOERR_33 = 0;				! No errors have occurred yet
10675	RPT_ERR_FLAG = 0;			! Don't report unexpected error
10676	
10677	INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
10678		BEGIN
10679		DO (0) WHILE
10680	BLOCK1:	    BEGIN
10681		    MR();			! Master Reset
10682		    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
10683		    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's
10684	
10685	! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.
10686	
10687		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
10688		    MEM_DEPOSIT(0,-1);
10689		    DATA_VECT[1] = .FORCE_BITS[.TEST];
10690		    DATA_VECT[2] = .TEST;
10691		    MEM_DATA = MEM_EXAMINE(0);
10692		    MEM_CORR = (.TEST_DATA XOR (1^(35-.TEST)));
10693	
10694	! Now check to see if there is any error and which section of bits it is in.
10695	! For any errors set error flags and print error message.
10696	
10697		    ERR_FLAG = 0;
10698		    INCR BTT FROM 0 TO 5 DO
10699			BEGIN
10700			IF ((.MEM_DATA OR .MASK[.BTT]) EQL 0) AND (.MEM_DATA EQL .MEM_CORR)
10701			    THEN BEGIN
10702				 ERR_FLAG = 1;
10703				 IO_DATA = IO_EXAMINE(MSR);
10704				 NOERR_33 = 1;
10705				 ERRCAS(.BTT+1,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
10706				 END;
10707			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
10708			END;
10709	
10710	! If the error is not in a single section of bits - write out error message.
10711	
10712		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .MEM_CORR)
10713			THEN BEGIN
10714			     ERR_FLAG = 1;
10715			     IO_DATA = IO_EXAMINE(MSR);
10716			     NOERR_33 = 1;
10717			     ERRCAS(7,1,.MEM_CORR,.MEM_DATA,12,DATA_VECT);
10718			     END;
10719		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
10720		    IF .ERR_FLAG EQL 1 THEN RETURN;
10721		    0				! To eliminate INFO compiler message
10722		    END;
10723		END;
10724	
10725	!*MESSAGE 1
10726	!*STIMULUS
10727	!*	MR		Clear everything
10728	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
10729	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
10730	!*	LA 0,DM -1	Write 1's to mem loc 0
10731	!*	EM 0		Examine mem loc (Should cause single bit error
10732	!*			  (Bit \D2) - and complement it
10733	!*RESPONSE
10734	!*	Data returned was not corrected (Mem Stat Reg: \U0 )
10735	
10736	!]ERROR 1
10737	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10738	!]NO ERROR 1
10739	!]  NTWK
10740	
10741	!]ERROR 2
10742	!] B2 G2 I2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10743	!]NO ERROR 2
10744	!]  NTWK
10745	
10746	!]ERROR 3
10747	!] C2 G2 J2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10748	!]NO ERROR 3
10749	!]  NTWK
10750	
10751	!]ERROR 4
10752	!] D2 G2 K2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10753	!]NO ERROR 4
10754	!]  NTWK
10755	
10756	!]ERROR 5
10757	!] E2 G2 L2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10758	!]NO ERROR 5
10759	!]  NTWK
10760	
10761	!]ERROR 6
10762	!] F2 G2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10763	!]NO ERROR 6
10764	!]  NTWK
10765	
10766	!]ERROR 7
10767	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10768	!]NO ERROR 7
10769	!]  NTWK
10770	
10771	END;
10772	GLOBAL ROUTINE TST34: NOVALUE =
10773	
10774	!++   -------- ECC:  2-BIT ERR NO CORR. (UNUSED CODES/DATA 0'S) ----
10775	! TEST DESCRIPTION:  This routine verifies that no correction occurs
10776	!	when a double bit error occurs.  The  test  writes  a set of
10777	!	double bit error patterns to memory and the reads  them back
10778	!	generating double bit ECC errors.   The  data read should be
10779	!	unchanged.  The force bit patterns  used in this test do not
10780	!	resemble any codes used by the ECC logic.
10781	!
10782	! TEST ASSUMPTIONS:  None.
10783	!
10784	! TEST PROCEDURE:  MR
10785	!		   Write status to MMC board - Set force bits (1000001)
10786	!		   Write 0's to mem location 0
10787	!		   Examine mem loc 0 - Should show data is all 0's
10788	!			(no correction).  If the data is not 0 then
10789	!			read Mem Status Reg and print out relevant data.
10790	!		   Repeat above steps for the remaining patterns
10791	!			which do not resemble any actual ECC codes
10792	!
10793	! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
10794	!
10795	!--
10796	
10797	BEGIN
10798	
10799	LITERAL
10800		RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
10801		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
10802	
10803	LOCAL
10804		TEST_DATA,			! Data writen to mem
10805		ERR_FLAG,			! Error flag
10806		MEM_STAT,			! Data read from MSR
10807		MEM_DATA;			! Data read from mem
10808	
10809	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
10810	!   sections match the bits as they are segregated in the ECC section of
10811	!   the MMC board.
10812	! FORCE_BITS - patterns which should not cause any error correction to be
10813	!   done but still indicate a double bit error (an even number of 1's).
10814	
10815	OWN
10816		MASK: VECTOR[6]
10817		    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
10818			     %O'777777007777',%O'777777770077',%O'777777777700'),
10819		FORCE_BITS: VECTOR[15]
10820		    INITIAL (%B'1000001',%B'1000010',%B'0000011',
10821			%B'1000100',%B'0000101',%B'0000110',%B'1000111',
10822			%B'1111000',%B'0111001',%B'0111010',%B'1111011',
10823			%B'0111100',%B'1111101',%B'1111110',%B'0111111'),
10824		DATA_VECT: VECTOR[2];
10825	
10826	BIND
10827		IO_DATA = DATA_VECT;
10828	
10829	LABEL
10830		BLOCK1;
10831	
10832	IF RUN_TEST(34) THEN RETURN;		! Run this test? Return if no
10833	
10834	NOERR_34 = 0;				! No errors have occurred yet
10835	RPT_ERR_FLAG = 0;			! Don't report unexpected error
10836	
10837	INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
10838		BEGIN
10839		DO (0) WHILE
10840	BLOCK1:	    BEGIN
10841		    MR();			! Master Reset
10842		    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
10843		    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 0's
10844	
10845	! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.
10846	
10847		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
10848		    MEM_DEPOSIT(0,0);
10849		    DATA_VECT[1] = .FORCE_BITS[.TEST];
10850		    MEM_DATA = MEM_EXAMINE(0);
10851	
10852	! Now check to see if there is any error and which section of bits it is in.
10853	! For any errors set error flags and print error message.
10854	
10855		    ERR_FLAG = 0;
10856		    INCR BTT FROM 0 TO 5 DO
10857			BEGIN
10858			IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
10859			    THEN BEGIN
10860				 ERR_FLAG = 1;
10861				 IO_DATA = IO_EXAMINE(MSR);
10862				 NOERR_34 = 1;
10863				 ERRCAS(.BTT+1,1,0,.MEM_DATA,12,DATA_VECT);
10864				 END;
10865			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
10866			END;
10867	
10868	! If the error is not in a single section of bits - write out error message.
10869	
10870		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
10871			THEN BEGIN
10872			     ERR_FLAG = 1;
10873			     IO_DATA = IO_EXAMINE(MSR);
10874			     NOERR_34 = 1;
10875			     ERRCAS(7,1,0,.MEM_DATA,12,DATA_VECT);
10876			     END;
10877		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
10878		    IF .ERR_FLAG EQL 1 THEN RETURN;
10879		    0				! To eliminate INFO compiler message
10880		    END;
10881	
10882		IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
10883		DM(0,0);			!   everything before leaving 
10884		EM(0);				!   this test
10885		END;
10886	
10887	!*MESSAGE 1
10888	!*STIMULUS
10889	!*	MR		Clear everything
10890	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
10891	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
10892	!*	LA 0,DM 0	Write 0's to mem loc 0
10893	!*	EM 0		Examine mem loc (Should cause double bit error
10894	!*			  - Data should not be corrected)
10895	!*RESPONSE
10896	!*	Data returned was corrected (Mem Stat Reg: \U0 )
10897	
10898	!]ERROR 1
10899	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10900	!]NO ERROR 1
10901	!]  NTWK
10902	
10903	!]ERROR 2
10904	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10905	!]NO ERROR 2
10906	!]  NTWK
10907	
10908	!]ERROR 3
10909	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10910	!]NO ERROR 3
10911	!]  NTWK
10912	
10913	!]ERROR 4
10914	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10915	!]NO ERROR 4
10916	!]  NTWK
10917	
10918	!]ERROR 5
10919	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10920	!]NO ERROR 5
10921	!]  NTWK
10922	
10923	!]ERROR 6
10924	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10925	!]NO ERROR 6
10926	!]  NTWK
10927	
10928	!]ERROR 7
10929	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
10930	!]NO ERROR 7
10931	!]  NTWK
10932	
10933	END;
10934	GLOBAL ROUTINE TST35: NOVALUE =
10935	
10936	!++   ------- ECC:  2-BIT ERR NO CORR. (SIMILAR CODES/DATA 0'S) ----
10937	! TEST DESCRIPTION:  This routine verifies that no correction occurs
10938	!	when a double  bit error occurs.   The test  writes a set of
10939	!	double bit error  patterns to memory and the reads them back
10940	!	generating double bit ECC errors.   The data  read should be
10941	!	unchanged.  The force bit patterns used in this test are the
10942	!	same  as the codes used by the ECC  logic  except  the force
10943	!	parity bit (CP) is set to cause a double bit error.
10944	!
10945	! TEST ASSUMPTIONS:  None.
10946	!
10947	! TEST PROCEDURE:  MR
10948	!		   Write status to MMC board - Set force bits (0001001)
10949	!		   Write 0's to mem location 0
10950	!		   Examine mem loc 0 - should show data is all 0's with
10951	!			no bits corrected.  If the data is not 0 then
10952	!			read Mem Status Reg and print out relevant data.
10953	!		   Repeat above steps for the remaining patterns
10954	!			which do resemble an actual ECC code.
10955	!
10956	! POSSIBLE ERRORS:  Logic on MMC2 is faulty
10957	!
10958	!--
10959	
10960	BEGIN
10961	
10962	LITERAL
10963		RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
10964		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
10965	
10966	LOCAL
10967		TEST_DATA,			! Data writen to mem
10968		ERR_FLAG,			! Error flag
10969		MEM_CORR,			! Data which would come back if
10970						!   correction did occur (in error)
10971		MEM_STAT,			! Data read from MSR
10972		MEM_DATA;			! Data read from mem
10973	
10974	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
10975	!   sections match the bits as they are segregated in the ECC section of
10976	!   the MMC board.
10977	! FORCE_BITS - patterns which should not cause any error correction to be
10978	!   done but still indicate a double bit error (an even number of 1's).
10979	
10980	OWN
10981		MASK: VECTOR[6]
10982		    INITIAL (%O'007777777777',%O'770077777777',%O'777700777777',
10983			     %O'777777007777',%O'777777770077',%O'777777777700'),
10984		FORCE_BITS: VECTOR[36]
10985		    INITIAL (%B'0001001',%B'0001010',%B'1001011',
10986			%B'0001100',%B'1001101',%B'1001110',%B'0010001',
10987			%B'0010010',%B'1010011',%B'0010100',%B'1010101',
10988			%B'1010110',%B'1011001',%B'1011010',%B'0011011',
10989			%B'1011100',%B'0011101',%B'0011110',%B'0100001',
10990			%B'0100010',%B'1100011',%B'0100100',%B'1100101',
10991			%B'1100110',%B'1101001',%B'1101010',%B'0101011',
10992			%B'1101100',%B'0101101',%B'0101110',%B'1110001',
10993			%B'1110010',%B'0110011',%B'1110100',%B'0110101',
10994			%B'0110110'),
10995		DATA_VECT: VECTOR[2];
10996	
10997	BIND
10998		IO_DATA = DATA_VECT;
10999	
11000	LABEL
11001		BLOCK1;
11002	
11003	IF RUN_TEST(35) THEN RETURN;		! Run this test? Return if no
11004	
11005	NOERR_35 = 0;				! No errors have occurred yet
11006	RPT_ERR_FLAG = 0;			! Don't report unexpected error
11007	
11008	INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
11009		BEGIN
11010		DO (0) WHILE
11011	BLOCK1:	    BEGIN
11012		    MR();			! Master Reset
11013		    MEM_DEPOSIT(0,0);		! Do a write and read to find out what
11014		    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 0's
11015	
11016	! Set force bits.  Write 0's to mem loc 0.  Read mem loc 0.
11017	
11018		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
11019		    MEM_DEPOSIT(0,0);
11020		    DATA_VECT[1] = .FORCE_BITS[.TEST];
11021		    MEM_DATA = MEM_EXAMINE(0);
11022	
11023	! Now check to see if there is any error and which section of bits it is in.
11024	! For any errors set error flags and print error message.
11025	
11026		    ERR_FLAG = 0;
11027		    INCR BTT FROM 0 TO 5 DO
11028			BEGIN
11029			IF ((.MEM_DATA AND .MASK[.BTT]) EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
11030			    THEN BEGIN
11031				 ERR_FLAG = 1;
11032				 IO_DATA = IO_EXAMINE(MSR);
11033				 NOERR_35 = 1;
11034				 ERRCAS(.BTT+1,1,0,.MEM_DATA,12,DATA_VECT);
11035				 END;
11036			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
11037			END;
11038	
11039	! If the error is not in a single section of bits - write out error message.
11040	
11041		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
11042			THEN BEGIN
11043			     ERR_FLAG = 1;
11044			     IO_DATA = IO_EXAMINE(MSR);
11045			     NOERR_35 = 1;
11046			     ERRCAS(7,1,0,.MEM_DATA,12,DATA_VECT);
11047			     END;
11048		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
11049		    IF .ERR_FLAG EQL 1 THEN RETURN;
11050		    0				! To eliminate INFO compiler message
11051		    END;
11052	
11053		IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
11054		DM(0,0);			!   everything before leaving 
11055		EM(0);				!   this test
11056		END;
11057	
11058	!*MESSAGE 1
11059	!*STIMULUS
11060	!*	MR		Clear everything
11061	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
11062	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
11063	!*	LA 0,DM 0	Write 0's to mem loc 0
11064	!*	EM 0		Examine mem loc (Should cause double bit error
11065	!*			  - Data should not be corrected)
11066	!*RESPONSE
11067	!*	Data returned was corrected (Mem Stat Reg: \U0 )
11068	
11069	!]ERROR 1
11070	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11071	!]NO ERROR 1
11072	!]  NTWK
11073	
11074	!]ERROR 2
11075	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11076	!]NO ERROR 2
11077	!]  NTWK
11078	
11079	!]ERROR 3
11080	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11081	!]NO ERROR 3
11082	!]  NTWK
11083	
11084	!]ERROR 4
11085	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11086	!]NO ERROR 4
11087	!]  NTWK
11088	
11089	!]ERROR 5
11090	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11091	!]NO ERROR 5
11092	!]  NTWK
11093	
11094	!]ERROR 6
11095	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11096	!]NO ERROR 6
11097	!]  NTWK
11098	
11099	!]ERROR 7
11100	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11101	!]NO ERROR 7
11102	!]  NTWK
11103	
11104	END;
11105	GLOBAL ROUTINE TST36: NOVALUE =
11106	
11107	!++   ------- ECC:  2-BIT ERR NO CORR. (UNUSED CODES/DATA 1'S) -----
11108	! TEST DESCRIPTION:  This routine verifies that no correction occurs
11109	!	when a double  bit error occurs.   The test  writes a set of
11110	!	double bit error  patterns to memory and the reads them back
11111	!	generating double bit ECC errors.   The data  read should be
11112	!	unchanged.  The force bit patterns  used in this test do not
11113	!	resemble any codes used by the ECC logic.
11114	!
11115	! TEST ASSUMPTIONS:  None.
11116	!
11117	! TEST PROCEDURE:  MR
11118	!		   Write status to MMC board - Set force bits (1000001)
11119	!		   Write 0's to mem location 0
11120	!		   Examine mem loc 0 - should show data is all 0's (no
11121	!			correction).  If the data is not 0 then read Mem
11122	!			Status Reg and print out relevant data.
11123	!		   Repeat above steps for the remaining patterns
11124	!			which do not resemble any actual ECC codes.
11125	!
11126	! POSSIBLE ERRORS:  Logic on MMC2 is faulty.
11127	!
11128	!--
11129	
11130	BEGIN
11131	
11132	LITERAL
11133		RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
11134		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
11135	
11136	LOCAL
11137		TEST_DATA,			! Data writen to mem
11138		ERR_FLAG,			! Error flag
11139		MEM_STAT,			! Data read from MSR
11140		MEM_DATA,			! Data read from mem
11141		TEMP;
11142	
11143	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
11144	!   sections match the bits as they are segregated in the ECC section of
11145	!   the MMC board.
11146	! FORCE_BITS - patterns which should not cause any error correction to be
11147	!   done but still indicate a double bit error (an even number of 1's).
11148	
11149	OWN
11150		MASK: VECTOR[6]
11151		    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
11152			     %O'000000770000',%O'000000007700',%O'000000000077'),
11153		FORCE_BITS: VECTOR[15]
11154		    INITIAL (%B'1000001',%B'1000010',%B'0000011',
11155			%B'1000100',%B'0000101',%B'0000110',%B'1000111',
11156			%B'1111000',%B'0111001',%B'0111010',%B'1111011',
11157			%B'0111100',%B'1111101',%B'1111110',%B'0111111'),
11158		DATA_VECT: VECTOR[2];
11159	
11160	BIND
11161		IO_DATA = DATA_VECT;
11162	
11163	LABEL
11164		BLOCK1;
11165	
11166	IF RUN_TEST(36) THEN RETURN;		! Run this test? Return if no
11167	
11168	NOERR_36 = 0;				! No errors have occurred yet
11169	RPT_ERR_FLAG = 0;			! Don't report unexpected error
11170	
11171	INCR TEST FROM 0 TO 14 DO		! For each set of force bits:
11172		BEGIN
11173		DO (0) WHILE
11174	BLOCK1:	    BEGIN
11175		    MR();			! Master Reset
11176		    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
11177		    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's
11178	
11179	! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.
11180	
11181		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
11182		    MEM_DEPOSIT(0,-1);
11183		    DATA_VECT[1] = .FORCE_BITS[.TEST];
11184		    MEM_DATA = MEM_EXAMINE(0);
11185	
11186	! Now check to see if there is any error and which section of bits it is in.
11187	! For any errors set error flags and print error message.
11188	
11189		    ERR_FLAG = 0;
11190		    INCR BTT FROM 0 TO 5 DO
11191			BEGIN
11192			IF ((.MEM_DATA OR .MASK[.BTT]) EQL -1) AND (.MEM_DATA NEQ .TEST_DATA)
11193			    THEN BEGIN
11194				 ERR_FLAG = 1;
11195				 IO_DATA = IO_EXAMINE(MSR);
11196				 NOERR_36 = 1;
11197				 ERRCAS(.BTT+1,1,-1,.MEM_DATA,12,DATA_VECT);
11198				 END;
11199			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
11200			END;
11201	
11202	! If the error is not in a single section of bits - write out error message.
11203	
11204		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
11205			THEN BEGIN
11206			     ERR_FLAG = 1;
11207			     IO_DATA = IO_EXAMINE(MSR);
11208			     NOERR_36 = 1;
11209			     ERRCAS(7,1,-1,.MEM_DATA,12,DATA_VECT);
11210			     END;
11211		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
11212		    IF .ERR_FLAG EQL 1 THEN RETURN;
11213		    0				! To eliminate INFO compiler message
11214		    END;
11215		IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
11216		DM(0,0);			!   everything before leaving 
11217		EM(0);				!   this test
11218		END;
11219	
11220	!*MESSAGE 1
11221	!*STIMULUS
11222	!*	MR		Clear everything
11223	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
11224	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
11225	!*	LA 0,DM -1	Write 1's to mem loc 0
11226	!*	EM 0		Examine mem loc (Should cause double bit error
11227	!*			  - Data should not be corrected)
11228	!*RESPONSE
11229	!*	Data returned was corrected (Mem Stat Reg: \U0 )
11230	
11231	!]ERROR 1
11232	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11233	!]NO ERROR 1
11234	!]  NTWK
11235	
11236	!]ERROR 2
11237	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11238	!]NO ERROR 2
11239	!]  NTWK
11240	
11241	!]ERROR 3
11242	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11243	!]NO ERROR 3
11244	!]  NTWK
11245	
11246	!]ERROR 4
11247	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11248	!]NO ERROR 4
11249	!]  NTWK
11250	
11251	!]ERROR 5
11252	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11253	!]NO ERROR 5
11254	!]  NTWK
11255	
11256	!]ERROR 6
11257	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11258	!]NO ERROR 6
11259	!]  NTWK
11260	
11261	!]ERROR 7
11262	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11263	!]NO ERROR 7
11264	!]  NTWK
11265	
11266	END;
11267	GLOBAL ROUTINE TST37: NOVALUE =
11268	
11269	!++   ----- ECC:  2-BIT ERR NO CORR. (SIMILAR CODES/DATA 1'S) ------
11270	! TEST DESCRIPTION:  This routine verifies that no correction occurs
11271	!	when a double  bit error occurs.   The test  writes a set of
11272	!	double bit error  patterns to memory and the reads them back
11273	!	generating double bit ECC errors.   The data  read should be
11274	!	unchanged.  The force bit patterns used in this test are the
11275	!	same  as the codes used by the ECC  logic  except  the force
11276	!	parity bit (CP) is set to cause a double bit error.
11277	!
11278	! TEST ASSUMPTIONS:  None.
11279	!
11280	! TEST PROCEDURE:  MR
11281	!		   Write status to MMC board - Set force bits (1001001)
11282	!		   Write 1's to mem location 0
11283	!		   Examine mem loc 0 - should show data
11284	!			is all 1's with no bits corrected.  If the
11285	!			data is not 1 then read Mem Status Reg and
11286	!			print out relevant data.
11287	!		   Repeat above steps for the remaining patterns
11288	!			which do resemble an actual ECC code.
11289	!
11290	! POSSIBLE ERRORS:  Logic on MMC2 is faulty
11291	!
11292	!--
11293	
11294	BEGIN
11295	
11296	LITERAL
11297		RESET = %O'700000000000',	! Turn on ECC and clear 'ERR HOLD'...
11298		ECC_ON = %O'700000000000';	! Turn on ECC and clear 'ERR HOLD'...
11299	
11300	LOCAL
11301		TEST_DATA,			! Data writen to mem
11302		ERR_FLAG,			! Error flag
11303		MEM_STAT,			! Data read from MSR
11304		MEM_DATA;			! Data read from mem
11305	
11306	! MASK - masks the data read back in 6 bit sections to test.  These 6 bit
11307	!   sections match the bits as they are segregated in the ECC section of
11308	!   the MMC board.
11309	! FORCE_BITS - patterns which should not cause any error correction to be
11310	!   done but still indicate a double bit error (an even number of 1's).
11311	
11312	OWN
11313		MASK: VECTOR[6]
11314		    INITIAL (%O'770000000000',%O'007700000000',%O'000077000000',
11315			     %O'000000770000',%O'000000007700',%O'000000000077'),
11316		FORCE_BITS: VECTOR[36]
11317		    INITIAL (%B'0001001',%B'0001010',%B'1001011',
11318			%B'0001100',%B'1001101',%B'1001110',%B'0010001',
11319			%B'0010010',%B'1010011',%B'0010100',%B'1010101',
11320			%B'1010110',%B'1011001',%B'1011010',%B'0011011',
11321			%B'1011100',%B'0011101',%B'0011110',%B'0100001',
11322			%B'0100010',%B'1100011',%B'0100100',%B'1100101',
11323			%B'1100110',%B'1101001',%B'1101010',%B'0101011',
11324			%B'1101100',%B'0101101',%B'0101110',%B'1110001',
11325			%B'1110010',%B'0110011',%B'1110100',%B'0110101',
11326			%B'0110110'),
11327		DATA_VECT: VECTOR[3];
11328	
11329	BIND
11330		IO_DATA = DATA_VECT;
11331	
11332	LABEL
11333		BLOCK1;
11334	
11335	IF RUN_TEST(37) THEN RETURN;		! Run this test? Return if no
11336	
11337	NOERR_37 = 0;				! No errors have occurred yet
11338	RPT_ERR_FLAG = 0;			! Don't report unexpected error
11339	
11340	INCR TEST FROM 0 TO 35 DO		! For each set of force bits:
11341		BEGIN
11342		DO (0) WHILE
11343	BLOCK1:	    BEGIN
11344		    MR();			! Master Reset
11345		    MEM_DEPOSIT(0,-1);		! Do a write and read to find out what
11346		    TEST_DATA = MEM_EXAMINE(0);	!   data comes back after writing 1's
11347	
11348	! Set force bits.  Write 1's to mem loc 0.  Read mem loc 0.
11349	
11350		    IO_DEPOSIT(MSR,ECC_ON OR .FORCE_BITS[.TEST]^1);
11351		    MEM_DEPOSIT(0,-1);
11352		    DATA_VECT[1] = .FORCE_BITS[.TEST];
11353		    DATA_VECT[2] = .TEST;
11354		    MEM_DATA = MEM_EXAMINE(0);
11355	
11356	! Now check to see if there is any error and which section of bits it is in.
11357	! For any errors set error flags and print error message.
11358	
11359		    ERR_FLAG = 0;
11360		    INCR BTT FROM 0 TO 5 DO
11361			BEGIN
11362			IF ((.MEM_DATA OR .MASK[.BTT]) EQL -1) AND (.MEM_DATA NEQ .TEST_DATA)
11363			    THEN BEGIN
11364				 ERR_FLAG = 1;
11365				 IO_DATA = IO_EXAMINE(MSR);
11366				 NOERR_37 = 1;
11367				 ERRCAS(.BTT+1,1,-1,.MEM_DATA,12,DATA_VECT);
11368				 END;
11369			IF LOOP_CHK(.BTT+1) THEN LEAVE BLOCK1 WITH 1;
11370			END;
11371	
11372	! If the error is not in a single section of bits - write out error message.
11373	
11374		    IF (.ERR_FLAG EQL 0) AND (.MEM_DATA NEQ .TEST_DATA)
11375			THEN BEGIN
11376			     ERR_FLAG = 1;
11377			     IO_DATA = IO_EXAMINE(MSR);
11378			     NOERR_37 = 1;
11379			     ERRCAS(7,1,-1,.MEM_DATA,12,DATA_VECT);
11380			     END;
11381		    IF LOOP_CHK(7) THEN LEAVE BLOCK1 WITH 1;
11382		    IF .ERR_FLAG EQL 1 THEN RETURN;
11383		    0				! To eliminate INFO compiler message
11384		    END;
11385	
11386		IO_DEPOSIT(MSR,RESET);		! Now just make sure we reset
11387		DM(0,0);			!   everything before leaving 
11388		EM(0);				!   this test
11389		END;
11390	
11391	! Now if there have not been any errors in the ECC tests then there
11392	!   are a lot of networks to eliminate via a call to NOERR.
11393	
11394		ERR_FLAG = .NOERR_31 OR .NOERR_32 OR .NOERR_33 OR .NOERR_34;
11395		IF (.ERR_FLAG OR .NOERR_35 OR .NOERR_36 OR .NOERR_37) EQL 0
11396		    THEN NOERR(1);
11397	
11398	!*MESSAGE 1
11399	!*STIMULUS
11400	!*	MR		Clear everything
11401	!*	LI 100000	Write Mem Stat Reg: Clear Err Hold ...,
11402	!*	DI (STATUS)	  Set force bits \O1, turn on ECC
11403	!*	LA 0,DM -1	Write 1's to mem loc 0
11404	!*	EM 0		Examine mem loc (Should cause double bit error
11405	!*			  - Data should not be corrected)
11406	!*RESPONSE
11407	!*	Data returned was corrected (Mem Stat Reg: \U0 )
11408	
11409	!]ERROR 1
11410	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11411	!]NO ERROR 1
11412	!] F5 G5 H5 G6 H6 A7 L7  NTWK
11413	
11414	!]ERROR 2
11415	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11416	!]NO ERROR 2
11417	!]  NTWK
11418	
11419	!]ERROR 3
11420	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11421	!]NO ERROR 3
11422	!]  NTWK
11423	
11424	!]ERROR 4
11425	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11426	!]NO ERROR 4
11427	!]  NTWK
11428	
11429	!]ERROR 5
11430	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11431	!]NO ERROR 5
11432	!]  NTWK
11433	
11434	!]ERROR 6
11435	!] A2 G2 H2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11436	!]NO ERROR 6
11437	!]  NTWK
11438	
11439	!]ERROR 7
11440	!] A2 B2 C2 D2 E2 F2 G2 H2 I2 J2 K2 L2 M2 F5 H5 AA A_G4 H4 K4 L4 M4 G6 H6 AB  NTWK
11441	!]NO ERROR 7
11442	!]  NTWK
11443	
11444	END;
11445	GLOBAL ROUTINE TST38: NOVALUE =
11446	
11447	!++   -------------- 8646'S, MOS DRIVERS, DATA PATH -----------
11448	! TEST DESCRIPTION:  This test performs a basic functional test
11449	!	of the MMC board.  Data is written to  memory  and read
11450	!	back and verified.  This test is  intended to check out
11451	!	the 8646's, the hex MOS  drivers,  and  the  data  path 
11452	!	within the MMC board.  This  test  is  identical to the
11453	!	first part of Test 6 except this time ECC is enabled.
11454	!
11455	! TEST ASSUMPTIONS:  None.
11456	!
11457	! TEST PROCEDURE:  Write a test pattern to mem loc 0
11458	!		   Read it back and verify it
11459	!		   Repeat with several test patterns
11460	!
11461	! POSSIBLE ERRORS:
11462	!
11463	!--
11464	
11465	BEGIN
11466	
11467	OWN
11468	
11469	! All the message strings
11470	
11471		MESS_STR: VECTOR[28]
11472		    INITIAL(UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-05'),
11473			    UPLIT(%ASCIZ '06-07'),UPLIT(%ASCIZ '08-11'),
11474			    UPLIT(%ASCIZ '12-15'),UPLIT(%ASCIZ '16-17'),
11475			    UPLIT(%ASCIZ '18-21'),UPLIT(%ASCIZ '22-23'),
11476			    UPLIT(%ASCIZ '24-25'),UPLIT(%ASCIZ '26-29'),
11477			    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
11478			    UPLIT(%ASCIZ '00-03'),UPLIT(%ASCIZ '04-07'),
11479			    UPLIT(%ASCIZ '08-11'),UPLIT(%ASCIZ '12-15'),
11480			    UPLIT(%ASCIZ '16-17'),UPLIT(%ASCIZ '18-21'),
11481			    UPLIT(%ASCIZ '22-25'),UPLIT(%ASCIZ '26-29'),
11482			    UPLIT(%ASCIZ '30-33'),UPLIT(%ASCIZ '34-35'),
11483			    UPLIT(%ASCIZ '00-05'),UPLIT(%ASCIZ '06-11'),
11484			    UPLIT(%ASCIZ '12-17'),UPLIT(%ASCIZ '18-23'),
11485			    UPLIT(%ASCIZ '24-29'),UPLIT(%ASCIZ '30-35')),
11486	
11487	! Data patterns
11488	
11489		PATTERN: VECTOR[4]
11490		    INITIAL (%O'111111111111',%O'666666666666',
11491			     %O'0',%O'777777777777'),
11492	
11493	! For the special data structure definition
11494	
11495		STRUCT: VECTOR[24]
11496		    INITIAL (32,4,30,2,28,2,24,4,20,4,18,2,14,4,
11497			     12,2,10,2,6,4,2,4,0,2);
11498	
11499	LITERAL
11500		NUM_PATTERN = 4;
11501	
11502	STRUCTURE
11503		BIT_VECT[I;N] = [N]		! This structure duplicates the bit
11504		    (BIT_VECT)			!   partitions on the data path
11505		    <.STRUCT[I*2],.STRUCT[I*2+1]>,
11506		BIT_MOS[I;N] = [N]		! This structure maps the MOS drivers
11507		    (BIT_MOS)			!   into the data path
11508		    <30-I*6,6>;
11509	
11510	OWN
11511		MESSV: VECTOR[2],		! Error message output vector
11512		TEST_8646_VECT: BIT8646[1],	! Data path mapped onto transceivers
11513		TEST_MOS_VECT: BIT_MOS[1],	! Miscellaneous structures
11514		TEST_TEMP_VECT: BIT_VECT[1],	!    ...
11515		TEST_DATA_VECT: BIT_VECT[1],
11516		TEST_PATT_VECT: BIT_VECT[1];
11517	
11518	BIND
11519		TEST_DATA = TEST_DATA_VECT,
11520		TEST_PATT = TEST_PATT_VECT,
11521		TEST_MOS = TEST_MOS_VECT,
11522		TEST_8646 = TEST_8646_VECT,
11523		TEST_TEMP = TEST_TEMP_VECT;
11524	
11525	LOCAL
11526		ERR,
11527		ERR_FLAG,
11528		TEMP;
11529	
11530	LABEL
11531		BLOCK1;
11532	
11533	IF RUN_TEST(38) THEN RETURN;		! Run this test? Return if no
11534	
11535	NOERR_38 = 0;				! No errors have occurred yet
11536	RPT_ERR_FLAG = 0;			! Don't report unexpected error
11537	
11538	INCR DATA_LOOP FROM 0 TO NUM_PATTERN-1 DO
11539		BEGIN				! Now start the test:
11540		TEST_PATT=.PATTERN[.DATA_LOOP];	!   Get the data pattern to use
11541		MESSV = .TEST_PATT;		!   Save it for error output
11542		MR();				!   Do a Master Reset
11543	
11544		DO (0) WHILE
11545	BLOCK1:	    BEGIN
11546		    TEST_DATA = ERR_FLAG = 0;
11547		    MEM_DEPOSIT(0,.TEST_PATT);
11548		    TEST_DATA = EM(0);
11549	
11550	! Now check to see if there are any single bit errors.
11551	
11552		    INCR BTT FROM 0 TO 35 DO
11553			BEGIN
11554			MESSV[1] = .BTT;
11555			TEMP = .TEST_DATA XOR (1 ^ (35-.BTT));
11556			IF .TEMP EQL .TEST_PATT
11557			    THEN BEGIN
11558				 ERRCAS(.BTT+1,1,.TEST_PATT,.TEST_DATA,12,MESSV);
11559				 ERR_FLAG = 1;
11560				 END;
11561			IF LOOP_CHK(.BTT + 1) THEN LEAVE BLOCK1 WITH 1;
11562			END;
11563	
11564	! Now check to see if there are any multiple bit errors which occurred in
11565	!   only one logical group of bits (such as in the first transceiver...).
11566	!   These particular groups are the subsections of the  transceivers, MOS
11567	!   drivers and mixers on MMC7 which are common to all three. Hence these
11568	!   are the next stage up from a single bit error.
11569	
11570		    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT);
11571		    INCR BTT FROM 0 TO 11 DO
11572			BEGIN
11573			TEST_TEMP = 0;
11574			TEST_TEMP_VECT[.BTT] = %O'777777';
11575			TEMP = .TEST_DATA OR .TEST_TEMP;
11576			IF .TEMP EQL (.TEST_PATT OR .TEST_TEMP) AND .ERR
11577			    THEN BEGIN
11578				 ERR_FLAG = 1;
11579				 MESSV[1] = .MESS_STR[.BTT];
11580				 ERRCAS(.BTT+37,2,.TEST_PATT,.TEST_DATA,12,MESSV);
11581				 END;
11582			IF LOOP_CHK(.BTT + 37) THEN LEAVE BLOCK1 WITH 1;
11583			END;
11584	
11585	! Now check to see if there are any errors which occurred exclusively in
11586	!   the 8646 transceivers.
11587	
11588		    ERR = (.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT);
11589		    INCR BTT FROM 0 TO 9 DO
11590			BEGIN
11591			TEST_8646 = 0;
11592			TEST_8646_VECT[.BTT] = %O'777777';
11593			TEMP = .TEST_DATA OR .TEST_8646;
11594			IF .TEMP EQL (.TEST_PATT OR .TEST_8646) AND .ERR
11595			    THEN BEGIN
11596				 ERR_FLAG = 1;
11597				 MESSV[1] = .MESS_STR[.BTT+12];
11598				 ERRCAS(.BTT+49,2,.TEST_PATT,.TEST_DATA,12,MESSV);
11599				 END;
11600			IF LOOP_CHK(.BTT + 49) THEN LEAVE BLOCK1 WITH 1;
11601			END;
11602	
11603	! Now check to see if there are any errors which occurred exclusively in
11604	!   the MOS drivers on MMC6.
11605	
11606		    ERR =(.ERR_FLAG EQL 0) AND (.DATA_LOOP LEQ 2) AND (.TEST_DATA NEQ .TEST_PATT);
11607		    INCR BTT FROM 0 TO 5 DO
11608			BEGIN
11609			TEST_MOS = 0;
11610			TEST_MOS_VECT[.BTT] = %O'777777';
11611			TEMP = .TEST_DATA OR .TEST_MOS;
11612			IF .TEMP EQL (.TEST_PATT OR .TEST_MOS) AND .ERR
11613			    THEN BEGIN
11614				 ERR_FLAG = 1;
11615				 MESSV[1] = .MESS_STR[.BTT+22];
11616				 ERRCAS(.BTT+59,2,.TEST_PATT,.TEST_DATA,12,MESSV);
11617				 END;
11618			IF LOOP_CHK(.BTT + 59) THEN LEAVE BLOCK1 WITH 1;
11619			END;
11620	
11621	! So if no error messages have been printed out yet and the data came
11622	!   back incorrectly, then the error must be a strange  multiple  bit
11623	!   error.  So we will report the whole thing.
11624	
11625		    IF (.ERR_FLAG EQL 0) AND (.TEST_DATA NEQ .TEST_PATT)
11626			THEN BEGIN
11627			     ERR_FLAG = 1;
11628			     ERRCAS(65,3,.TEST_PATT,.TEST_DATA,12,MESSV);
11629			     END;
11630		    IF LOOP_CHK(65) THEN LEAVE BLOCK1 WITH 1;
11631		    IF .ERR_FLAG NEQ 0 THEN NOERR_38 = 1;
11632		    0				! To eliminate INFO compiler message
11633		    END;
11634		END;
11635	
11636	ERR = .NOERR_30 OR .NOERR_31 OR .NOERR_32 OR .NOERR_33 OR .NOERR_34;
11637	ERR = .ERR OR .NOERR_35 OR .NOERR_36 OR .NOERR_37 OR .NOERR_38;
11638	
11639	! If Tests 30,31,32,33,34,35,36,37,38 all passed then the ECC code decoders
11640	!   'MMC2 ECC CODE 10'..'MMC2 ECC CODE 7X' are ok.
11641	
11642	IF .ERR EQL 0 THEN NOERR(1);
11643	
11644	! If Tests 30,31,32,33,34,35,36,37,38 all passed then the XOR gates on
11645	!   MMC2 which determine 'MMC2 CORRECT DATA xx' are ok.
11646	
11647	IF (.ERR OR .NOERR_6) EQL 0 THEN NOERR(2);
11648	
11649	! If Test 38 passed then the hex MOS drivers on MMC6 are ok.
11650	
11651	IF .NOERR_38 EQL 0 THEN NOERR(3);
11652	
11653	! If Tests 17,19,22,25,38 all passed then the mixers on MMC7 which
11654	!   determine 'MMC7 XMITINF xx' are ok.
11655	
11656	IF (.NOERR_38 OR .NOERR_17 OR .NOERR_19 OR .NOERR_22 OR .NOERR_25) EQL 0
11657		THEN NOERR(4);
11658	
11659	!*MESSAGE 1
11660	!*STIMULUS:
11661	!*	LA 0	Write to mem loc 0
11662	!*	DM \U0
11663	!*	EM 0	Examine mem loc 0
11664	!*RESPONSE:
11665	!*	Bit \D1 of data returned is incorrect
11666	
11667	!]ERROR 1
11668	!] A1 A2 H2 A6 C7  NTWK
11669	!]NO ERROR 1
11670	!] A2 B2 C2 D2 E2 F2 G2  NTWK
11671	
11672	!]ERROR 2
11673	!] A1 A2 H2 A6 C7  NTWK
11674	!]NO ERROR 2
11675	!] H2 I2 J2 K2 L2 M2  NTWK
11676	
11677	!]ERROR 3
11678	!] A1 A2 H2  A6 C7 B9  NTWK
11679	!]NO ERROR 3
11680	!] A6 B6 C6 D6 E6 F6  NTWK
11681	
11682	!]ERROR 4
11683	!] A1 A2 H2 A6 C7  NTWK
11684	!]NO ERROR 4
11685	!] C7 D7 E7 F7 G7 H7 I7 J7 K7  NTWK
11686	
11687	!]ERROR 5
11688	!] B1 A2 H2 A6 D7  NTWK
11689	!]NO ERROR 5
11690	!]  NTWK
11691	
11692	!]ERROR 6
11693	!] B1 A2 H2 A6 D7  NTWK
11694	!]NO ERROR 6
11695	!]  NTWK
11696	
11697	!]ERROR 7
11698	!] B1 B2 I2 B6 D7  NTWK
11699	!]NO ERROR 7
11700	!]  NTWK
11701	
11702	!]ERROR 8
11703	!] B1 B2 I2 B6 D7  NTWK
11704	!]NO ERROR 8
11705	!]  NTWK
11706	
11707	!]ERROR 9
11708	!] C1 B2 I2 B6 E7  NTWK
11709	!]NO ERROR 9
11710	!]  NTWK
11711	
11712	!]ERROR 10
11713	!] C1 B2 I2 B6 E7  NTWK
11714	!]NO ERROR 10
11715	!]  NTWK
11716	
11717	!]ERROR 11
11718	!] C1 B2 I2 B6 E7  NTWK
11719	!]NO ERROR 11
11720	!]  NTWK
11721	
11722	!]ERROR 12
11723	!] C1 B2 I2 B6 E7  NTWK
11724	!]NO ERROR 12
11725	!]  NTWK
11726	
11727	!]ERROR 13
11728	!] D1 C2 J2 C6 F7  NTWK
11729	!]NO ERROR 13
11730	!]  NTWK
11731	
11732	!]ERROR 14
11733	!] D1 C2 J2 C6 F7  NTWK
11734	!]NO ERROR 14
11735	!]  NTWK
11736	
11737	!]ERROR 15
11738	!] D1 C2 J2 C6 F7  NTWK
11739	!]NO ERROR 15
11740	!]  NTWK
11741	
11742	!]ERROR 16
11743	!] D1 C2 J2 C6 F7  NTWK
11744	!]NO ERROR 16
11745	!]  NTWK
11746	
11747	!]ERROR 17
11748	!] E1 C2 J2 C6 G7  NTWK
11749	!]NO ERROR 17
11750	!]  NTWK
11751	
11752	!]ERROR 18
11753	!] E1 C2 J2 C6 G7  NTWK
11754	!]NO ERROR 18
11755	!]  NTWK
11756	
11757	!]ERROR 19
11758	!] F1 D2 K2 D6 G7  NTWK
11759	!]NO ERROR 19
11760	!]  NTWK
11761	
11762	!]ERROR 20
11763	!] F1 D2 K2 D6 G7  NTWK
11764	!]NO ERROR 20
11765	!]  NTWK
11766	
11767	!]ERROR 21
11768	!] F1 D2 K2 D6 H7  NTWK
11769	!]NO ERROR 21
11770	!]  NTWK
11771	
11772	!]ERROR 22
11773	!] F1 D2 K2 D6 H7  NTWK
11774	!]NO ERROR 22
11775	!]  NTWK
11776	
11777	!]ERROR 23
11778	!] G1 D2 K2 D6 H7  NTWK
11779	!]NO ERROR 23
11780	!]  NTWK
11781	
11782	!]ERROR 24
11783	!] G1 D2 K2 D6 H7  NTWK
11784	!]NO ERROR 24
11785	!]  NTWK
11786	
11787	!]ERROR 25
11788	!] G1 E2 L2 E6 I7  NTWK
11789	!]NO ERROR 25
11790	!]  NTWK
11791	
11792	!]ERROR 26
11793	!] G1 E2 L2 E6 I7  NTWK
11794	!]NO ERROR 26
11795	!]  NTWK
11796	
11797	!]ERROR 27
11798	!] H1 E2 L2 E6 I7  NTWK
11799	!]NO ERROR 27
11800	!]  NTWK
11801	
11802	!]ERROR 28
11803	!] H1 E2 L2 E6 I7  NTWK
11804	!]NO ERROR 28
11805	!]  NTWK
11806	
11807	!]ERROR 29
11808	!] H1 E2 L2 E6 J7  NTWK
11809	!]NO ERROR 29
11810	!]  NTWK
11811	
11812	!]ERROR 30
11813	!] H1 E2 L2 E6 J7  NTWK
11814	!]NO ERROR 30
11815	!]  NTWK
11816	
11817	!]ERROR 31
11818	!] I1 F2 M2 F6 J7  NTWK
11819	!]NO ERROR 31
11820	!]  NTWK
11821	
11822	!]ERROR 32
11823	!] I1 F2 M2 F6 J7  NTWK
11824	!]NO ERROR 32
11825	!]  NTWK
11826	
11827	!]ERROR 33
11828	!] I1 F2 M2 F6 K7  NTWK
11829	!]NO ERROR 33
11830	!]  NTWK
11831	
11832	!]ERROR 34
11833	!] I1 F2 M2 F6 K7  NTWK
11834	!]NO ERROR 34
11835	!]  NTWK
11836	
11837	!]ERROR 35
11838	!] J1 F2 M2 F6 K7  NTWK
11839	!]NO ERROR 35
11840	!]  NTWK
11841	
11842	!]ERROR 36
11843	!] J1 F2 M2 F6 K7  NTWK
11844	!]NO ERROR 36
11845	!]  NTWK
11846	
11847	!*MESSAGE 2
11848	!*STIMULUS:
11849	!*	LA 0	Write to mem loc 0
11850	!*	DM \U0
11851	!*	EM 0	Examine mem loc 0
11852	!*RESPONSE:
11853	!*	Bits \S1 of data returned is incorrect
11854	
11855	!]ERROR 37
11856	!] A1 A2 H2 A6 C7  NTWK
11857	!]NO ERROR 37
11858	!]  NTWK
11859	
11860	!]ERROR 38
11861	!] B1 A2 H2 A6 D7  NTWK
11862	!]NO ERROR 38
11863	!]  NTWK
11864	
11865	!]ERROR 39
11866	!] B1 B2 I2 B6 D7  NTWK
11867	!]NO ERROR 39
11868	!]  NTWK
11869	
11870	!]ERROR 40
11871	!] C1 B2 I2 B6 E7  NTWK
11872	!]NO ERROR 40
11873	!]  NTWK
11874	
11875	!]ERROR 41
11876	!] D1 C2 J2 C6 F7  NTWK
11877	!]NO ERROR 41
11878	!]  NTWK
11879	
11880	!]ERROR 42
11881	!] E1 C2 J2 C6 G7  NTWK
11882	!]NO ERROR 42
11883	!]  NTWK
11884	
11885	!]ERROR 43
11886	!] F1 D2 K2 D6 G7 H7  NTWK
11887	!]NO ERROR 43
11888	!]  NTWK
11889	
11890	!]ERROR 44
11891	!] G1 D2 K2 D6 H7  NTWK
11892	!]NO ERROR 44
11893	!]  NTWK
11894	
11895	!]ERROR 45
11896	!] G1 E2 L2 E6 I7  NTWK
11897	!]NO ERROR 45
11898	!]  NTWK
11899	
11900	!]ERROR 46
11901	!] H1 E2 L2 E6 I7 J7  NTWK
11902	!]NO ERROR 46
11903	!]  NTWK
11904	
11905	!]ERROR 47
11906	!] I1 F2 M2 F6 J7 K7  NTWK
11907	!]NO ERROR 47
11908	!]  NTWK
11909	
11910	!]ERROR 48
11911	!] J1 F2 M2 F6 K7  NTWK
11912	!]NO ERROR 48
11913	!]  NTWK
11914	
11915	!]ERROR 49
11916	!] A1 A2 H2 A6 C7  NTWK
11917	!]NO ERROR 49
11918	!]  NTWK
11919	
11920	!]ERROR 50
11921	!] B1 A2 B2 H2 I2 A6 B6 D7  NTWK
11922	!]NO ERROR 50
11923	!]  NTWK
11924	
11925	!]ERROR 51
11926	!] C1 B2 I2 B6 E7  NTWK
11927	!]NO ERROR 51
11928	!]  NTWK
11929	
11930	!]ERROR 52
11931	!] D1 C2 J2 C6 F7  NTWK
11932	!]NO ERROR 52
11933	!]  NTWK
11934	
11935	!]ERROR 53
11936	!] E1 C2 J2 C6 G7  NTWK
11937	!]NO ERROR 53
11938	!]  NTWK
11939	
11940	!]ERROR 54
11941	!] F1 D2 K2 D6 G7 H7  NTWK
11942	!]NO ERROR 54
11943	!]  NTWK
11944	
11945	!]ERROR 55
11946	!] G1 D2 E2 K2 L2 D6 E6 H7 I7  NTWK
11947	!]NO ERROR 55
11948	!]  NTWK
11949	
11950	!]ERROR 56
11951	!] H1 E2 L2 E6 I7 J7  NTWK
11952	!]NO ERROR 56
11953	!]  NTWK
11954	
11955	!]ERROR 57
11956	!] I1 F2 M2 F6 J7 K7  NTWK
11957	!]NO ERROR 57
11958	!]  NTWK
11959	
11960	!]ERROR 58
11961	!] J1 F2 M2 F6 K7  NTWK
11962	!]NO ERROR 58
11963	!]  NTWK
11964	
11965	!]ERROR 59
11966	!] A1 B1 A2 H2 A6 C7 D7  NTWK
11967	!]NO ERROR 59
11968	!]  NTWK
11969	
11970	!]ERROR 60
11971	!] B1 C1 B2 I2 B6 D7 E7  NTWK
11972	!]NO ERROR 60
11973	!]  NTWK
11974	
11975	!]ERROR 61
11976	!] D1 E1 C2 J2 C6 F7 G7  NTWK
11977	!]NO ERROR 61
11978	!]  NTWK
11979	
11980	!]ERROR 62
11981	!] F1 G1 D2 K2 D6 G7 H7  NTWK
11982	!]NO ERROR 62
11983	!]  NTWK
11984	
11985	!]ERROR 63
11986	!] G1 H1 E2 L2 E6 I7 J7  NTWK
11987	!]NO ERROR 63
11988	!]  NTWK
11989	
11990	!]ERROR 64
11991	!] I1 J1 F2 M2 F6 J7 K7  NTWK
11992	!]NO ERROR 64
11993	!]  NTWK
11994	
11995	!*MESSAGE 3
11996	!*STIMULUS:
11997	!*	LA 0	Write to mem loc 0
11998	!*	DM \U0
11999	!*	EM 0	Examine mem loc 0
12000	!*RESPONSE:
12001	!*	Bits 00-35 of data returned is incorrect
12002	
12003	!]ERROR 65
12004	!] A_J1 A_D3 I_O3 C_K7 B_K8 AA BA AB BB DB AC BC  NTWK
12005	!]NO ERROR 65
12006	!]  NTWK
12007	
12008	END;
12009	GLOBAL ROUTINE TST39: NOVALUE =
12010	
12011	!++   ------------ ?MRE CAUSES 'MMC5 ERR HOLD / ERR ADD LOAD' ---------
12012	! TEST DESCRIPTION:   This  routine  verifies  that when memory refresh
12013	!	error occurs 'MMC5 ERR HOLD' is asserted thus causing 'MMC5 ERR
12014	!	ADD LOAD' to assert and thereby load the 'ERR ADDR' Register on
12015	!	MMC8 with the address in the MMC board whatever it might be.
12016	!
12017	! TEST ASSUMPTIONS:  None.
12018	!
12019	! TEST PROCEDURE:  Master Reset
12020	!		   Write 0's to mem loc 77777 - Just to quickly load
12021	!			the 8080 address registers
12022	!		   Write control bits to Reg 114,115,210 - To hang
12023	!			memory and cause a ?MRE
12024	!		   Examine Mem Status Register - Verify that 'ERR HOLD'
12025	!			is set and the error address is '77777'
12026	!
12027	! POSSIBLE ERRORS:  
12028	!
12029	!--
12030	
12031	BEGIN
12032	
12033	LOCAL
12034		NUM_ERR,
12035		ERR_FLAG;
12036	
12037	OWN
12038		REG101,
12039		MEM_STAT_VECT: BTTVECTOR[36];
12040	
12041	BIND
12042		MEM_STAT_REG = MEM_STAT_VECT,
12043		REF_ERR = UPLIT(%ASCIZ '?MRE');
12044	
12045	LABEL
12046		BLOCK1;
12047	
12048	IF RUN_TEST(39) THEN RETURN;		! Run this test? Return if no
12049	
12050	NOERR_39 = 0;				! No errors have occurred yet
12051	RPT_ERR_FLAG = 0;			! Don't report unexpected error
12052	
12053	DO (0) WHILE
12054	BLOCK1:	BEGIN
12055		MR();				! Master Reset
12056	
12057		DM(77777,0);			! Write 0's to mem loc 77777 (just to
12058		WRT114(0);			!   load up the 8080 data/addr regs)
12059		WRT115(COM_ADR);		! Now do mem access which causes ?MRE
12060		WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);
12061	
12062		ERR_FLAG = 0;
12063		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
12064		MEM_STAT_REG = IO_EXAMINE(MSR);	! Read MSR (for error printouts)
12065	
12066		REG101 = RD_101;		! Read 8080 Reg 101 and see if a ?MRE
12067		IF (.REG101 AND MMC_REF_ERR) EQL 0!  occurred - If not set error flags,
12068		    THEN BEGIN			!    print error message, and abort
12069			 ERR_FLAG = 1;		!    the rest of this test.
12070			 NOERR_39 = 1;
12071			 ERRS(1,1,REG101);
12072			 END;
12073		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
12074		IF .ERR_FLAG EQL 1 THEN RETURN;
12075	
12076		MEM_STAT_REG = IO_EXAMINE(MSR);	! Now check MSR to see if 'ERR HOLD' is
12077		IF .MEM_STAT_REG GEQ 0		!   set - If not set error flags, print
12078		    THEN BEGIN			!   error message and abort the rest of
12079			 TEST_ABORT = 1;	!   this test.
12080			 NOERR_39 = 1;
12081			 ERRCA(2,%O'520000077777',.MEM_STAT_REG,12);
12082			 END;
12083		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
12084	
12085		NUM_ERR = 0;			! Now see how badly in error the error
12086		INCR BTT FROM 14 TO 35 DO	!   address is - count up the number of
12087		    BEGIN			!   bit positions in error.
12088		    IF .MEM_STAT_VECT[.BTT] NEQ 1
12089			THEN NUM_ERR = .NUM_ERR + 1;
12090		    END;
12091	
12092		IF .NUM_ERR GTR 17		! If the number errors > 17 we can be
12093		    THEN BEGIN			!   reasonably certain that 'ERR ADD
12094			 TEST_ABORT = 1;	!   LOAD' did not assert (in case of
12095			 NOERR_39 = 1;		!   other errors allow up to 5 errors)
12096			 ERRCA(3,%O'520000077777',.MEM_STAT_REG,12); 
12097			 END;
12098		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
12099		0				! To eliminate INFO compiler message
12100		END;
12101	
12102	!*MESSAGE 1
12103	!*STIMULUS
12104	!*	MR		Master Reset
12105	!*	LA 77777,DM 0	Put address into 8080 I/O Regs
12106	!*	LR 114,DR 0	Turn off data cycle bit
12107	!*	LR 115,DR 4	Turn on comadr cycle bit
12108	!*	LR 210,DR 360	Do half of a write to mem (causes ?MRE)
12109	!*RESPONSE
12110	!*	?MRE did not occur    8080 Reg 101:  \O0
12111	
12112	!]ERROR 1
12113	!] A9 B9 C9 AA AB BB  NTWK
12114	!]NO ERROR 1
12115	!]  NTWK
12116	
12117	!*MESSAGE 2
12118	!*STIMULUS
12119	!*	MR		Master Reset
12120	!*	LA 77777,DM 0	Put address into 8080 I/O Regs
12121	!*	LR 114,DR 0	Turn off data cycle bit
12122	!*	LR 115,DR 4	Turn on comadr cycle bit
12123	!*	LR 210,DR 360	Do half of a write to mem (causes ?MRE)
12124	!*	EI 100000	Read Mem Status Reg - Verify 'ERR HOLD' bit
12125	!*			  and error address
12126	!*RESPONSE
12127	!*	MMC5 'ERR HOLD' bit not asserted
12128	!*	Mem Stat Reg:  \U0
12129	
12130	!]ERROR 2
12131	!] C5 AC  NTWK
12132	!]NO ERROR 2
12133	!]  NTWK
12134	
12135	!*MESSAGE 3
12136	!*STIMULUS
12137	!*	MR		Master Reset
12138	!*	LA 77777,DM 0	Put address into 8080 I/O Regs
12139	!*	LR 114,DR 0	Turn off data cycle bit
12140	!*	LR 115,DR 4	Turn on comadr cycle bit
12141	!*	LR 210,DR 360	Do half of a write to mem (causes ?MRE)
12142	!*	EI 100000	Read Mem Status Reg - Verify 'ERR HOLD' bit
12143	!*			 and error address
12144	!*RESPONSE
12145	!*	MMC8 'ERR ADDR' not correct
12146	
12147	!]ERROR 3
12148	!] C5 AC CC NTWK
12149	!]NO ERROR 3
12150	!]  NTWK
12151	
12152	END;
12153	GLOBAL ROUTINE TST40: NOVALUE =
12154	
12155	!++ ------------------------ ?MRE / ?NXM -------------------------------
12156	! TEST DESCRIPTION:   This  routine verifies  that when the MMC board is
12157	!	hung the memory controller will not respond to any commands such
12158	!	as EM or DM but will respond to EI and DI.  MMC is hung and will
12159	!	not perform any memory accesses - But a Read / Write status  can
12160	!	still be done.
12161	!
12162	! TEST ASSUMPTIONS:  None.
12163	!
12164	! TEST PROCEDURE:  Master Reset
12165	!		   Hang mem - Cause a refresh error
12166	!		   Verify that read mem loc 0 results in ?NXM
12167	!		   Verify that write mem loc 0 results in ?NXM
12168	!		   Verify that read status can be done
12169	!		   Verify that write status can be done
12170	!
12171	! POSSIBLE ERRORS:  
12172	!
12173	!--
12174	
12175	BEGIN
12176	
12177	LOCAL
12178		ERR_FLAG;
12179	
12180	OWN
12181		MESSV: VECTOR[6];		! Error message output vector
12182	
12183	BIND
12184		REF_ERR = UPLIT(%ASCIZ '?MRE'),
12185		NXM_ERR = UPLIT(%ASCIZ '?NXM'),
12186		REG101 = MESSV,
12187		REG301 = MESSV[1],
12188		MSR_HANG = MESSV[2],
12189		MSR_EM = MESSV[3],
12190		MSR_DM = MESSV[4],
12191		MEM_EM = MESSV[5];
12192	
12193	LABEL
12194		BLOCK1;
12195	
12196	IF RUN_TEST(40) THEN RETURN;		! Run this test? Return if no
12197	
12198	NOERR_40 = 0;				! No errors have occurred yet
12199	RPT_ERR_FLAG = 0;			! Don't report unexpected error
12200	
12201	DO (0) WHILE
12202	BLOCK1:	BEGIN
12203		MR();				! Master Reset
12204		REG101 = REG301 = 0;
12205		ERR_FLAG = 0;
12206		HANG_MEM();			! Cause a ?MRE
12207		CHK_ERR_MSG(REF_ERR);		! Discard any unexpected errors
12208		MSR_HANG = IO_EXAMINE(MSR);	! Read MSR (should show ?MRE)
12209	
12210		REG101 = RD_101;		! Read 8080 Reg 101 - should show
12211		IF (.REG101 AND MMC_REF_ERR) EQL 0!   that a ?MRE occurred.
12212		    THEN BEGIN
12213			 ERR_FLAG = 1;		! If it doesnt set error flags and
12214			 NOERR_40 = 1;		!   print error message and abort
12215			 ERRS(1,1,MESSV);	!   the rest of this test
12216			 END;
12217		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
12218		IF .ERR_FLAG EQL 1 THEN RETURN;
12219	
12220		MEM_EM = EM(0);			! Try to read mem loc 0
12221		CHK_ERR_MSG(NXM_ERR);		! Discard any CSL error messages
12222		REG301 = RD_301;		! Read 8080 Reg 301 to see if a
12223		IF (.REG301 AND NEXM) EQL 0	!   ?NXM occurred then.
12224		    THEN BEGIN			! If not read MSR then set error
12225			 MSR_EM = IO_EXAMINE(MSR);!  flags, print error message and
12226			 TEST_ABORT = 1;	!    abort future testing.
12227			 NOERR_40 = 1;
12228			 ERRS(2,2,MESSV);
12229			 END;
12230		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
12231	
12232		DM(0,123);			! Try to write to mem loc 0
12233		SEND_NUL();			! Send it out to 8080
12234		CHK_ERR_MSG(NXM_ERR);		! Discard any CSL error messages
12235		REG301 = RD_301;		! Read 8080 Reg 301 to see if a
12236		IF (.REG301 AND NEXM) EQL 0	!     ?NXM occurred then.
12237		    THEN BEGIN			! If not read MSR then set error
12238			 MSR_DM = IO_EXAMINE(MSR);!  flags, print error message and
12239			 TEST_ABORT = 1;	!    abort future testing.
12240			 NOERR_40 = 1;
12241			 ERRS(3,3,MESSV);
12242			 END;
12243		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
12244		0				! To eliminate INFO compiler message
12245		END;
12246	
12247	!*MESSAGE 1
12248	!*STIMULUS
12249	!*	MR		Master Reset
12250	!*	HANG MMC	Cause a memory refresh error
12251	!*RESPONSE
12252	!*	?MRE did not occur    8080 Reg 101:  \O0
12253	
12254	!]ERROR 1
12255	!] A9 B9 C9 AA AB BB  NTWK
12256	!]NO ERROR 1
12257	!]  NTWK
12258	
12259	!*MESSAGE 2
12260	!*STIMULUS
12261	!*	MR		Master Reset
12262	!*	HANG MMC	Cause a memory refresh error
12263	!*	EM 0		Should result in ?NXM
12264	!*RESPONSE
12265	!*	?MRE did occur (8080 Reg 101:  \O0) (Mem Stat Reg:  \U2)
12266	!*	?NXM did not occur   EM 0:  \U5    8080 Reg 301:  \O1
12267	!*	Mem Stat Reg (After EM 0):  \U3
12268	
12269	!]ERROR 2
12270	!] AB  NTWK
12271	!]NO ERROR 2
12272	!]  NTWK
12273	
12274	!*MESSAGE 3
12275	!*STIMULUS
12276	!*	MR		Master Reset
12277	!*	HANG MMC	Cause a memory refresh error
12278	!*	EM 0
12279	!*	LA 0,DM 0	Should result in ?NXM
12280	!*RESPONSE
12281	!*	?MRE did occur (8080 Reg 101:  \O0) (Mem Stat Reg:  \U2)
12282	!*	?NXM did not occur      8080 Reg 301:  \O1
12283	!*	Mem Stat Reg (After DM 0):  \U4
12284	
12285	!]ERROR 3
12286	!] AB  NTWK
12287	!]NO ERROR 3
12288	!]  NTWK
12289	
12290	END;
12291	GLOBAL ROUTINE TST41: NOVALUE =
12292	
12293	!++   ------------ TIMING OF AN I/O WRITE INSTRUCTION ------------
12294	! TEST DESCRIPTION:  This routine verifies the amount of time that
12295	!	a write status takes.  The bus  arbitrator  grants the bus
12296	!	for 3 T Clocks for an I/O instruction.  For a write status
12297	!	to memory the MMC board  needs only this amount of time to
12298	!	complete the request.
12299	!
12300	! TEST ASSUMPTIONS:  None.
12301	!
12302	! TEST PROCEDURE:  Master Reset
12303	!		   SYNC REFRESH - Make sure that the timing of this
12304	!			test is not affected by the occurrence of a
12305	!			mem refresh cycle occurring before it gets
12306	!			started.  Clock is also put into maintenance
12307	!			mode and synced.
12308	!		   Write data into 8080 Regs - For a write status to
12309	!			turn off ?MRE
12310	!		   Tick 3 T Clocks (Actually 13 ticks)
12311	!		   Write data into 8080 Regs - For a write to memory
12312	!			(The previous write status is not yet finished
12313	!			but this write will grab the bus after the 3rd
12314	!			T Clock)
12315	!		   Tick until 'MEM BUSY' appears in 8080 Reg 102
12316	!			(Look for 'MMC REF ERR' shut off in Reg 101)
12317	!		   Verify that the number of ticks it took for a 
12318	!			write status is correct
12319	!		   Verify that 'MMC REF ERR' turned off
12320	!
12321	! POSSIBLE ERRORS:  
12322	!
12323	!--
12324	
12325	BEGIN
12326	
12327	LITERAL
12328		WRITE_MSR = %O'500000100000',	! Write to MSR
12329		WRITE_MEM = %O'100000000000',	! Write to mem loc 0
12330		AFTER = 1,			! Sync Refresh after ?MRE
12331		APPROX = 1;			! Sync Refresh approximately only
12332	
12333	OWN
12334		ERR_FLAG,
12335		REGV: VECTOR[5];		! Error message output vector
12336	
12337	BIND
12338		REG102 = REGV,
12339		REG101 = REGV[1],
12340		REG3 = REGV[2],
12341		TICK2 = REGV[3],
12342		TICK1 = REGV[4];
12343	
12344	LABEL
12345		BLOCK1;
12346	
12347	IF RUN_TEST(41) THEN RETURN;		! Run this test? Return if no
12348	
12349	NOERR_41 = 0;				! No errors have occurred yet
12350	RPT_ERR_FLAG = 0;			! Don't report unexpected error
12351	
12352	DO (0) WHILE
12353	BLOCK1:	BEGIN
12354		MR();				! Master Reset
12355		DEBUG = 0;			! Make sure SYNC does not output
12356		ERR_FLAG = 0;
12357		IF SYNC_REFRESH(APPROX,AFTER)	! Sync the refresh at a point some
12358		    THEN BEGIN			!   time after ?MRE occurred
12359			 ERR_FLAG = 1;		! If this failed set error flags,
12360			 NOERR_41 = 1;		!   print error message, and abort
12361			 ERR(1);		!   this test.
12362			 END;
12363		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
12364		IF .ERR_FLAG EQL 1 THEN RETURN;
12365	
12366		WRITE_COMADR(WRITE_MSR);	! Now write to MSR to shut off the ?MRE
12367		WRITE_DATA(%O'700000000000');	!   left over from the SYNC_REFRESH
12368		WRITE_CONTROL();
12369		TICK(13);			! And give a few ticks to get it going
12370	
12371		WRITE_COMADR(WRITE_MEM);	! Now start a write mem - this should
12372		WRITE_DATA(%O'777777777777');	!   start immmediately after the write
12373		WRITE_CONTROL();		!   status is complete
12374	
12375		TICK1 = 13;			! Now tick along until 'MEM BUSY'
12376		TICK2 = 0;			!   clears from 8080 Reg 102. And
12377		DO  BEGIN			!   keep track of when ?MRE clears
12378		    TICK(1);			!   from Reg 101 (from the write
12379		    TICK1 = .TICK1 + 1;		!   status) also.
12380		    REG102 = RD_102;
12381		    REG101 = RD_101;
12382		    IF (.REG101 AND MMC_REF_ERR) EQL 0 AND .TICK2 EQL 0
12383			THEN TICK2 = .TICK1;
12384		    END
12385		WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 56;
12386	
12387		START_CLK;			! Start the clock back up
12388		IF (.REG102 AND RMEM_BUSY) EQL 0! If 'MEM BUSY' did not appear
12389		    THEN BEGIN			!   in Reg 102 - set error flag
12390			 NOERR_41 = 1;		!   and print error message.
12391			 ERRS(2,2,REGV);
12392			 END;
12393		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
12394	
12395		IF .TICK1 NEQ 34 AND (.REG102 AND RMEM_BUSY) NEQ 0
12396		    THEN BEGIN			! If the number of ticks to see
12397			 NOERR_41 = 1;		!   'MEM BUSY' clear is incorrect
12398			 ERRS(3,3,REGV);	!   set error flag and print error
12399			 END;			!   message
12400		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
12401	
12402		IF .TICK2 NEQ 17 AND (.REG102 AND RMEM_BUSY) NEQ 0
12403		    THEN BEGIN			! If the number of ticks to see ?MRE
12404			 REGV[1]=IO_EXAMINE(MSR);!  clear is incorrect - set error
12405			 NOERR_41 = 1;		!   flag and print error message
12406			 ERRS(4,4,REGV);
12407			 END;
12408		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
12409		0				! To eliminate INFO compiler message
12410		END;
12411	
12412	!*MESSAGE 1
12413	!*STIMULUS
12414	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12415	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12416	!*	  memory controller) (To keep refresh from disrupting this test)
12417	!*RESPONSE
12418	!*	Attempt to sync T & R Clocks failed - could not generate a
12419	!*	  refresh error
12420	
12421	!]ERROR 1
12422	!] A9 B9 C9 AA AB BB  NTWK
12423	!]NO ERROR 1
12424	!]  NTWK
12425	
12426	!*MESSAGE 2
12427	!*STIMULUS
12428	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12429	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12430	!*	  memory controller) (To keep refresh from disrupting this test)
12431	!*	Write 8080 I/O Regs 102..115 for a write status to turn
12432	!*	  off 'MMC REF ERR'
12433	!*	Write '360' TO 8080 I/O Reg 210 control bits for write
12434	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12435	!*	Do 13 ticks (3 T Clocks to do most of the write status)
12436	!*	Write 8080 I/O Regs 102..115 for a write to memory
12437	!*	Write '360' TO 8080 I/O Reg 210 control bits for write
12438	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12439	!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
12440	!*	  (It should occur after 5 more T Clocks to allow I/O
12441	!*	  write to complete and then start memory write cycle)
12442	!*RESPONSE
12443	!*	'MEM BUSY' never appeared in I/O Reg 102: \O0
12444	!*	  (A total of 56 ticks (14 T Clocks) were given since
12445	!*	   the start of the mem I/O status write cycle)
12446	
12447	!]ERROR 2
12448	!] AB BB AC  NTWK
12449	!]NO ERROR 2
12450	!]  NTWK
12451	
12452	!*MESSAGE 3
12453	!*STIMULUS
12454	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12455	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12456	!*	  memory controller) (To keep refresh from disrupting this test)
12457	!*	Write 8080 I/O Regs 102..115 for a write status to turn
12458	!*	  OFF 'MMC REF ERR'
12459	!*	Write '360' TO 8080 I/O Reg 210 control bits for write
12460	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12461	!*	Do 13 ticks (3 T Clocks to do most of the write status)
12462	!*	Write 8080 I/O Regs 102..115 for a write to memory
12463	!*	Write '360' TO 8080 I/O Reg 210 control bits for write
12464	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12465	!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
12466	!*	  (It should occur after 5 more T Clocks to allow I/O
12467	!*	  write to complete and then start memory write cycle)
12468	!*RESPONSE
12469	!*	'MEM BUSY' appeared in I/O Reg 102 after \D4 ticks
12470	!*	  but it should have occurred after 34 ticks (8 T Clocks)
12471	
12472	!]ERROR 3
12473	!] AB BB AC  NTWK
12474	!]NO ERROR 3
12475	!]  NTWK
12476	
12477	!*MESSAGE 4
12478	!*STIMULUS
12479	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12480	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12481	!*	  memory controller) (To keep refresh from disrupting this test)
12482	!*	Write 8080 I/O Regs 102..115 for a write status to turn
12483	!*	  off 'MMC REF ERR'
12484	!*	Write '360' TO 8080 I/O Reg 210 control bits for write
12485	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12486	!*	Do 13 ticks (3 T Clocks to do most of the write status)
12487	!*	Write 8080 I/O Regs 102..115 for a write to memory
12488	!*	Write '360' TO 8080 I/O Reg 210 control bits for write
12489	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12490	!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
12491	!*	  (It should occur after 5 more T Clocks to allow I/O
12492	!*	  write to complete and then start memory write cycle)
12493	!*RESPONSE
12494	!*	Mem status write did not occur properly - 'WRITE STATUS' and
12495	!*	  'WRITE MEM' both succeeded but timing is off
12496	!*	Number of ticks from start of 'WRITE STATUS' to see 'MMC REF ERR'
12497	!*	  shut off in 8080 I/O Reg 101 - \D3 ticks  (Reg 101:  \O1)
12498	!*	Number of ticks from start of 'WRITE STATUS' to see 'MEM BUSY'
12499	!*	  in 8080 I/O Reg 102 - \D4 TICKS (102:  \O0)
12500	!*	Mem Status Reg:  \U1  (Seen after clocks restarted)
12501	
12502	!]ERROR 4
12503	!] AB BB AC  NTWK
12504	!]NO ERROR 4
12505	!]  NTWK
12506	
12507	END;
12508	GLOBAL ROUTINE TST42: NOVALUE =
12509	
12510	!++   ------------ TIMING OF AN I/O READ INSTRUCTION -------------
12511	! TEST DESCRIPTION:  This routine verifies the amount of time that
12512	!	a read status  takes.   The  bus arbitrator grants the bus
12513	!	for 3 T Clocks for an I/O  instruction.  For a read status
12514	!	to memory  the MMC board needs only this amount of time to
12515	!	complete the request.
12516	!
12517	! TEST ASSUMPTIONS:  None.
12518	!
12519	! TEST PROCEDURE:  Master Reset
12520	!		   Write 0's to mem loc 0  -  Read mem loc 0
12521	!			(To initialize 8080 I/O Reg 103 to 0's)
12522	!		   SYNC REFRESH - Make sure that the timing of this
12523	!			test is not affected by the occurrence of a
12524	!			mem refresh cycle occurring before it gets
12525	!			started.  Clock is also put into maintenance
12526	!			mode and synced.
12527	!		   Write data into 8080 Regs - For a write status to
12528	!			turn off ?MRE so that the write memory will
12529	!			not result in ?NXM later on.
12530	!		   Tick until write status is complete.
12531	!		   Write data into 8080 regs - For a read status to
12532	!			see 'MMC REF ERR'
12533	!		   Tick 13 ticks (3 T Clocks)
12534	!		   Write data into 8080 Regs - For a write to memory
12535	!			(The previous read status is not yet finished
12536	!			but this write will grab the bus after the 3rd
12537	!			T Clock)
12538	!		   Tick until 'MEM BUSY' appears in 8080 Reg 102
12539	!			(Look for 'RDATA 4' bit set in 8080 I/O Reg 3 -
12540	!			 Indicating 'ECC ON' bit in Mem Stat Reg - This
12541	!			 will detect the completion of the read status)
12542	!		   Verify that the number of ticks it took for a 
12543	!			read status is correct
12544	!
12545	! POSSIBLE ERRORS:  
12546	!
12547	!--
12548	
12549	BEGIN
12550	
12551	LITERAL
12552		WRITE_MSR = %O'500000100000',	! Write to MSR
12553		READ_MSR = %O'600000100000',	! Read MSR
12554		APPROX = 1,			! Sync refresh only approximately
12555		AFTER = 1,			! Sync refresh and leave after ?MRE
12556		WRITE_MEM = %O'100000000000';	! Write to mem loc 0
12557	
12558	OWN
12559		ERR_FLAG,
12560		REGV: VECTOR[5];		! Error message output vector
12561	
12562	BIND
12563		REG102 = REGV,
12564		REG101 = REGV[1],
12565		REG3 = REGV[2],
12566		TICK2 = REGV[3],
12567		TICK1 = REGV[4];
12568	
12569	LABEL
12570		BLOCK1;
12571	
12572	IF RUN_TEST(42) THEN RETURN;		! Run this test? Return if no
12573	
12574	NOERR_42 = 0;				! No errors have occurred yet
12575	RPT_ERR_FLAG = 0;			! Don't report unexpected error
12576	
12577	DO (0) WHILE
12578	BLOCK1:	BEGIN
12579		MR();				! Master Reset
12580		DEBUG = 0;			! Ensure SYNC does not output
12581		ERR_FLAG = 0;
12582	
12583		IF SYNC_REFRESH(APPROX,AFTER)	! Sync refresh - if this fails
12584		    THEN BEGIN			!   set error flags, print error
12585			 NOERR_42 = 1;		!   message, and abort the test.
12586			 ERR(1);
12587			 ERR_FLAG = 1;
12588			 END;
12589		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
12590		IF .ERR_FLAG EQL 1 THEN RETURN;
12591	
12592		WRITE_COMADR(WRITE_MSR);	! Clear ?MRE so that ?NXM does not
12593		WRITE_DATA(%O'700000000000');	!   occur on the write to mem which
12594		WRITE_CONTROL();		!   is done later
12595		TICK(40);			! Enough ticks to do write status
12596	
12597		WRITE_COMADR(READ_MSR);		! Now initiate the read status - this
12598		WRITE_CONTROL1();		!   is the one we will time
12599		TICK(13);			! Do most of it
12600	
12601		WRITE_COMADR(WRITE_MEM);	! Now start a memory cycle - 'MEM_BUSY'
12602		WRITE_DATA(%O'777777777777');	!   will appear as soon as the read
12603		WRITE_CONTROL();		!   status is done
12604	
12605		TICK1 = 13;			! Now count the number of ticks it
12606		TICK2 = 0;			!   takes to see 'MEM_BUSY' appear
12607		DO  BEGIN
12608		    TICK(1);			! Also keep track of when the data
12609		    TICK1 = .TICK1 + 1;		!   comes back from the read status
12610		    REG102 = RD_102;		!   into Reg 3 (TICK2 has # of ticks)
12611		    REG3 = RD_3;
12612		    IF (.REG3 AND RDATA4) NEQ 0 AND .TICK2 EQL 0
12613			THEN TICK2 = .TICK1;
12614		    END
12615		WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 56;
12616	
12617		START_CLK;			! All done with timing so restart clock
12618		IF (.REG102 AND RMEM_BUSY) EQL 0
12619		    THEN BEGIN			! If 'MEM_BUSY' never appeared set
12620			 NOERR_42 = 1;		!   error flags, and print error
12621			 ERRS(2,2,REGV);	!   message.
12622			 END;
12623		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
12624	
12625		IF .TICK1 NEQ 34 AND (.REG102 AND RMEM_BUSY) NEQ 0
12626		    THEN BEGIN			! Was the timing correct?  If not
12627			 NOERR_42 = 1;		!   set error flags and print error
12628			 ERRS(3,3,REGV);	!   message.
12629			 END;
12630		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
12631	
12632		IF .TICK2 NEQ 18 AND (.REG102 AND RMEM_BUSY) NEQ 0
12633		    THEN BEGIN			! Was timing correct for seeing data
12634			 REGV[1]=IO_EXAMINE(MSR);!  come back from read status?  If not
12635			 NOERR_42 = 1;		!   read current contents of MSR, set
12636			 ERRS(4,4,REGV);	!   error flags and print error message
12637			 END;
12638		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
12639		0				! To eliminate INFO compiler message
12640		END;
12641	
12642	!*MESSAGE 1
12643	!*STIMULUS
12644	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12645	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12646	!*	  memory controller) (To keep refresh from disrupting this test)
12647	!*RESPONSE
12648	!*	Attempt to sync T & R Clocks failed - could not generate a
12649	!*	  refresh error
12650	
12651	!]ERROR 1
12652	!] A9 B9 C9 AA AB BB  NTWK
12653	!]NO ERROR 1
12654	!]  NTWK
12655	
12656	!*MESSAGE 2
12657	!*STIMULUS
12658	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12659	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12660	!*	  memory controller) (To keep refresh from disrupting this test)
12661	!*	Write 8080 I/O Regs 102..115,210 for a write status to turn off
12662	!*	  'MMC REF ERR' (So that MMC will not be hung for a mem access)
12663	!*	Write 8080 I/O Regs 102..115 for a read status to read 'ECC ON'
12664	!*	  (Should appear as 'R DATA 4' bit in 8080 I/O Reg 3)
12665	!*	WRITE '361' TO 8080 I/O REG 210 CONTROL BITS FOR READ
12666	!*	  ('MEM','BUS REQ','XMIT ADR','LATCH DATA SENT','R CLK ENABLE L')
12667	!*	Do 13 ticks (3 T Clocks to do most of the read status)
12668	!*	Write 8080 I/O Regs 102..115 for a write to memory
12669	!*	Write '360' to 8080 I/O Reg 210 control bits for write
12670	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12671	!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
12672	!*	  (It should occur after 5 more T Clocks to allow I/O
12673	!*	  read to complete and then start memory write cycle)
12674	!*RESPONSE
12675	!*	'MEM BUSY' never appeared in I/O Reg 102: \O0
12676	!*	  (A total of 56 ticks (14 T Clocks) were given since
12677	!*	   the start of the Mem I/O Status Read cycle)
12678	!*	Either 'READ STATUS' failed or 'WRITE MEM' failed
12679	
12680	!]ERROR 2
12681	!] AB BB AC  NTWK
12682	!]NO ERROR 2
12683	!]  NTWK
12684	
12685	!*MESSAGE 3
12686	!*STIMULUS
12687	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12688	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12689	!*	  memory controller) (To keep refresh from disrupting this test)
12690	!*	Write 8080 I/O Regs 102..115,210 for a write status to turn off
12691	!*	  'MMC REF ERR' (So that MMC will not be hung for a mem access)
12692	!*	Write 8080 I/O Regs 102..115 for a read status to read 'ECC ON'
12693	!*	  (Should appear as 'R DATA 4' bit in 8080 I/O Reg 3)
12694	!*	Write '361' to 8080 I/O Reg 210 control bits for read
12695	!*	  ('MEM','BUS REQ','XMIT ADR','LATCH DATA SENT','R CLK ENABLE L')
12696	!*	Do 13 ticks (3 T Clocks to do most of the read status)
12697	!*	Write 8080 I/O Regs 102..115 for a write to memory
12698	!*	Write '360' to 8080 I/O Reg 210 control bits for write
12699	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12700	!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
12701	!*	  (It should occur after 5 more T Clocks to allow I/O
12702	!*	  read to complete and then start memory write cycle)
12703	!*RESPONSE
12704	!*	'MEM BUSY' appeared in I/O Reg 102 after \D4 ticks but it
12705	!*	  should have occurred after 34 ticks (8 T Clocks) (Or
12706	!*	  21 ticks (5 T Clocks) after writing 'WRITE MEM' data to
12707	!*	  8080 Regs.  Therefore the 'READ STATUS' took longer or
12708	!*	  shorter than it should have.
12709	
12710	!]ERROR 3
12711	!] AB BB AC  NTWK
12712	!]NO ERROR 3
12713	!]  NTWK
12714	
12715	!*MESSAGE 4
12716	!*STIMULUS
12717	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12718	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12719	!*	  memory controller) (To keep refresh from disrupting this test)
12720	!*	Write 8080 I/O Regs 102..115,210 for a write status to turn off
12721	!*	  'MMC REF ERR' (So that MMC will not be hung for a mem access)
12722	!*	Write 8080 I/O Regs 102..115 for a read status to read 'ECC ON'
12723	!*	  (Should appear as 'R DATA 4' bit in 8080 I/O Reg 3)
12724	!*	Write '361' to 8080 I/O Reg 210 control bits for read
12725	!*	  ('MEM','BUS REQ','XMIT ADR','LATCH DATA SENT','R CLK ENABLE L')
12726	!*	Do 13 ticks (3 T Clocks to do most of the read status)
12727	!*	Write 8080 I/O Regs 102..115 for a write to memory
12728	!*	Write '360' to 8080 I/O Reg 210 control bits for write
12729	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12730	!*	Tick T Clock until 'MEM BUSY' appears in 8080 Reg 102
12731	!*	  (It should occur after 5 more T Clocks to allow I/O
12732	!*	  read to complete and then start memory write cycle)
12733	!*RESPONSE
12734	!*	Mem status read did not occur properly - 'READ STATUS' and
12735	!*	  'WRITE MEM' both succeeded but timing is off
12736	!*	Number of ticks from start of 'READ STATUS' to see 'ECC ON' in
12737	!*	  8080 I/O Reg 3 - \D3 ticks  (Reg 3:  \O2)
12738	!*	Number of ticks from start of 'READ STATUS' to see 'MEM BUSY'
12739	!*	  in 8080 I/O Reg 102 - \D4 ticks (102:  \O0)
12740	!*	Mem Status Reg:  \U1  (Seen after clocks restarted)
12741	
12742	!]ERROR 4
12743	!] AB BB AC  NTWK
12744	!]NO ERROR 4
12745	!]  NTWK
12746	
12747	END;
12748	GLOBAL ROUTINE TST43: NOVALUE =
12749	
12750	!++   ------------ LENGH OF A MEMORY WRITE ACCESS --------------
12751	! TEST DESCRIPTION:  This routine  verifies that a memory  write
12752	!	takes only 7 T Clocks or  1050 NS.  First the clocks are
12753	!	put into maintenance mode  and  synced.  Then a write is
12754	!	done and as soon as 'MEM BUSY' turns  off a second write
12755	!	is done. In this manner the length of a write is verified
12756	!	and the delay between one write and the next is verified
12757	!	(It should be none since the mem cycles  should actually
12758	!	overlap slightly - 1/2 T Clock)
12759	!	If the test fails there is a possiblility that a refresh
12760	!	cycle interfered with the timing so the test is repeated
12761	!	immediately - it it now fails there is definitely an error.
12762	!
12763	! TEST ASSUMPTIONS:  None.
12764	!
12765	! TEST PROCEDURE:  Master Reset
12766	!		   SYNC REFRESH - Make sure that the timing of this
12767	!		     test is not affected by the occurrence of a
12768	!		     mem refresh cycle occurring before it gets
12769	!		     started.  Clock is also put into maintenance
12770	!		     mode and synced.
12771	!		   Write data into 8080 Regs - For a write to mem
12772	!			(This cycle should start on the next T Clock)
12773	!		   Do a T Clock until 'MEM BUSY' is detected (By a read
12774	!			of 8080 I/O Reg 102)
12775	!		   Do a T Clock until 'MEM BUSY' goes away
12776	!		   Write data into 8080 Regs - For a write to mem
12777	!			(This cycle should start on the next T Clock)
12778	!		   Do a T Clock until 'MEM BUSY' is detected (By a read
12779	!			of 8080 I/O Reg 102)
12780	!		   Do a T Clock until 'MEM BUSY' goes away
12781	!		   Verify that the number of T Clocks it took is ok
12782	!
12783	! POSSIBLE ERRORS:  
12784	!
12785	!--
12786	
12787	BEGIN
12788	
12789	LITERAL
12790		WRITE_MSR = %O'500000100000',	! Write to MSR
12791		CLEAR_MRE = %O'100000000000',	! Clear ?MRE on a write to MSR
12792		APPROX = 1,			! Sync refresh only approximately
12793		AFTER = 1,			! Sync refresh and leave after ?MRE
12794		WRITE_MEM = %O'100000000000';	! Write to mem loc 0
12795	
12796	OWN
12797		ERR_FLAG,
12798		TICKV: VECTOR[4],		! Error message output vector
12799		REG;
12800	
12801	BIND
12802		TICK1 = TICKV,
12803		TICK2 = TICKV[1],
12804		TICK3 = TICKV[2],
12805		TICK4 = TICKV[3];
12806	
12807	LABEL
12808		BLOCK1;
12809	
12810	IF RUN_TEST(43) THEN RETURN;		! Run this test? Return if no
12811	
12812	NOERR_43 = 0;				! No errors have occurred yet
12813	RPT_ERR_FLAG = 0;			! Don't report unexpected error
12814	DEBUG = 0;				! Make sure SYNC does not output
12815	
12816	DO (0) WHILE
12817	BLOCK1:	BEGIN
12818		MR();				! Master Reset
12819		IF SYNC_REFRESH(APPROX,AFTER)	! Sync refresh
12820		    THEN BEGIN
12821			 NOERR_43 = 1;		! If it fails - set error flags, print
12822			 ERR(1);		!   error message, and abort the test.
12823			 ERR_FLAG = 1;
12824			 END;
12825		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
12826		IF .ERR_FLAG EQL 1 THEN RETURN;
12827	
12828		WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE caused by SYNC
12829		WRITE_DATA(CLEAR_MRE);
12830		WRITE_CONTROL();
12831		TICK(40);			! Enough ticks to clear it
12832	
12833		WRITE_COMADR(WRITE_MEM);	! Write to mem loc 0
12834		WRITE_CONTROL();
12835		TICK1 = 0;			! Count how many ticks it takes to
12836		DO  BEGIN			!   see 'MEM_BUSY' in 8080 Reg 102
12837		    TICK(1);
12838		    REG = RD_102;
12839		    TICK1 = .TICK1 + 1;
12840		    END
12841		WHILE (.REG AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 60;
12842	
12843		TICK2 = 0;			! Now count how many ticks it takes
12844		DO  BEGIN			!   to see 'MEM_BUSY' clear.
12845		    TICK(1);
12846		    REG = RD_102;
12847		    TICK2 = .TICK2 + 1;
12848		    END
12849		WHILE (.REG AND RMEM_BUSY) NEQ 0 AND .TICK2 LSS 60;
12850	
12851		WRITE_COMADR(WRITE_MEM);	! Now write to memory again and count
12852		WRITE_CONTROL();		!   how many ticks it takes to see
12853		TICK3 = 0;			!   'MEM_BUSY' appear in Reg 102
12854		DO  BEGIN
12855		    TICK(1);
12856		    REG = RD_102;
12857		    TICK3 = .TICK3 + 1;
12858		    END
12859		WHILE (.REG AND RMEM_BUSY) EQL 0 AND .TICK3 LSS 60;
12860	
12861		TICK4 = 0;			! Now see how long it takes for
12862		DO  BEGIN			!   'MEM_BUSY' to clear
12863		    TICK(1);
12864		    REG = RD_102;
12865		    TICK4 = .TICK4 + 1;
12866		    END
12867		WHILE (.REG AND RMEM_BUSY) NEQ 0 AND .TICK4 LSS 60;
12868	
12869	! Now just compare actual vs. expected and do error handling if needed.
12870	
12871		IF .TICK1 NEQ 18 OR .TICK2 NEQ 8 OR .TICK3 NEQ 20 OR .TICK4 NEQ 8
12872		    THEN BEGIN
12873			 NOERR_43 = 1;
12874			 ERRS(2,2,TICKV);
12875			 END;
12876		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
12877		0				! To eliminate INFO compiler message
12878		END;
12879	
12880	!*MESSAGE 1
12881	!*STIMULUS
12882	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12883	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12884	!*	  memory controller) (To keep refresh from disrupting this test)
12885	!*RESPONSE
12886	!*	Attempt to sync T & R Clocks failed - could not generate a
12887	!*	  refresh error
12888	
12889	!]ERROR 1
12890	!] A9 B9 C9 AA AB BB  NTWK
12891	!]NO ERROR 1
12892	!]  NTWK
12893	
12894	!*MESSAGE 2
12895	!*STIMULUS
12896	!*	Sync T & R Clocks to a point shortly after a ?MRE has
12897	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
12898	!*	  memory controller) (To keep refresh from disrupting this test)
12899	!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
12900	!*	Write '360' to 8080 I/O Reg 210 control bits for write
12901	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12902	!*	(A)  Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
12903	!*	     (Should take 18 ticks (4.5 T Clocks))
12904	!*	(B)  Tick T Clock until 'MEM BUSY' clears in 8080 I/O Reg 102
12905	!*	     (Should take 8 ticks (2 T Clocks))
12906	!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
12907	!*	Write '360' to 8080 I/O Reg 210 control bits for write
12908	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
12909	!*	(C)  Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
12910	!*	     (Should take 20 ticks (5 T Clocks))
12911	!*	(D)  Tick T Clock until 'MEM BUSY' clears in 8080 I/O Reg 102
12912	!*	     (Should take 8 ticks (2 T Clocks))
12913	!*RESPONSE
12914	!*	(A) - Took \D0 ticks to see 'MEM BUSY' assert
12915	!*	(B) - Took \D1 ticks to see 'MEM BUSY' clear
12916	!*	(C) - Took \D2 ticks to see 'MEM BUSY' assert
12917	!*	(D) - Took \D3 ticks to see 'MEM BUSY' clear
12918	
12919	!]ERROR 2
12920	!] AA BA AB BB AC  NTWK
12921	!]NO ERROR 2
12922	!]  NTWK
12923	
12924	END;
12925	GLOBAL ROUTINE TST44: NOVALUE =
12926	
12927	!++   ------------ HOW LONG DOES ?NXM TIE UP MMC -------------
12928	! TEST DESCRIPTION:  This test  verifies that when ?NXM occurs
12929	!	the MMC controller quickly signals ?NXM and aborts the
12930	!	memory cycle freeing up memory for the next operation.
12931	!
12932	! TEST ASSUMPTIONS:  None.
12933	!
12934	! TEST PROCEDURE:  Master Reset
12935	!		   Sync T & R Clocks
12936	!		   Write data to 8080 I/O Regs - For a write to
12937	!			mem loc 7777777 (nonexistent)
12938	!		   Tick clock until ?NXM is set
12939	!		   Write data to 8080 I/O Regs - For a write to
12940	!			mem loc 0
12941	!		   Tick clock until 'MEM BUSY' appears
12942	!		   Verify the number of ticks taken
12943	!
12944	! POSSIBLE ERRORS:  
12945	!
12946	!--
12947	
12948	BEGIN
12949	
12950	LITERAL
12951		WRITE_MEM = %O'100000000000',	! Write to mem loc 0
12952		WRITE_NXM = %O'100007777777';	! Write to mem loc ?NXM
12953	
12954	OWN
12955		ERR_FLAG,
12956		REGV: VECTOR[4];		! Error message data vector
12957	
12958	BIND
12959		REG301 = REGV,
12960		REG102 = REGV[1],
12961		TICK1 = REGV[2],
12962		TICK2 = REGV[3];
12963	
12964	LABEL
12965		B2,
12966		BLOCK1;
12967	
12968	IF RUN_TEST(44) THEN RETURN;		! Run this test? Return if no
12969	
12970	NOERR_44 = 0;				! No errors have occurred yet
12971	RPT_ERR_FLAG = 0;			! Don't report unexpected error
12972	
12973	DO (0) WHILE
12974	BLOCK1:	BEGIN
12975		MR();
12976		SYNC_CLK();			! Sync T & R Clocks
12977	
12978	! Try this whole thing twice in case it doesnt work the first time.
12979	!   Occasionally a flaky error may cause it to fail needlessly.
12980	
12981		INCR TRY FROM 0 TO 1 DO
12982		B2: BEGIN
12983		    WRITE_COMADR(WRITE_NXM);	! Write to ?NXM
12984		    WRITE_CONTROL();
12985	
12986		    TICK1 = 0;			! Tick forward until we get
12987		    DO  BEGIN			!   a ?NXM in 8080 Reg 301
12988			TICK(1);
12989			REG301 = RD_301;
12990			TICK1 = .TICK1 + 1;
12991			END
12992		    WHILE (.REG301 AND NEXM) EQL 0 AND .TICK1 LSS 100;
12993	
12994		    ERR_FLAG = 0;
12995		    IF (.REG301 AND NEXM) EQL 0
12996			THEN BEGIN		! If a ?NXM did not occur set
12997			     NOERR_44 = 1;	!   error flags, print error
12998			     ERR_FLAG = 1;	!   message, and abort the test.
12999			     ERRS(1,1,REGV);
13000			     END;
13001		    IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
13002		    IF .ERR_FLAG EQL 1 THEN RETURN;
13003	
13004		    TICK(1);			! Give a tick just for good luck
13005		    WRITE_COMADR(WRITE_MEM);	! Now start the memory write cycle
13006		    WRITE_CONTROL();		!   which should be delayed while MMC
13007		    TICK2 = 0;			!   finishes clearing the NXM cycle.
13008		    DO	BEGIN
13009			TICK(1);		! Tick until 'MEM_BUSY' appears in
13010			REG102 = RD_102;	!   Reg 102
13011			TICK2 = .TICK2 + 1;
13012			END
13013		    WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK2 LSS 100;
13014	
13015		    IF (.REG102 AND RMEM_BUSY) EQL 0
13016			THEN BEGIN		! If 'MEM_BUSY' never appeared do
13017			     IF .TRY EQL 0	!   a retry but if we already did
13018				THEN LEAVE B2;	!   one then set error flags, print
13019			     NOERR_44 = 1;	!   error message.
13020			     ERRS(2,2,REGV);
13021			     END;
13022		    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
13023	
13024		    IF (.REG102 AND RMEM_BUSY) NEQ 0
13025			THEN BEGIN			! So we did see 'MEM_BUSY' -
13026			     IF .TICK2 NEQ 19		!   was it at the right time?
13027				THEN BEGIN
13028				     IF .TRY EQL 0	! If no - retry - but if retry
13029					THEN LEAVE B2;	!   already done then set error
13030				     NOERR_44 = 1;	!   flags, print error message.
13031				     ERRS(3,3,REGV);
13032				     END;
13033			     END;
13034		    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
13035		    END;
13036		TICK(40);			! 40 ticks just to give room for the
13037		0				! To eliminate INFO compiler message
13038		END;				!   the second try
13039	
13040	!*MESSAGE 1
13041	!*STIMULUS
13042	!*	Sync T & R Clocks
13043	!*	Write 8080 I/O Regs 102..115 for a write to mem loc 7777777
13044	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13045	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13046	!*	Tick T Clock until 'NXM' gets set in 8080 I/O Reg 301
13047	!*	  (Should take 16 ticks (4 T Clocks))
13048	!*RESPONSE
13049	!*	'NXM' never appeared in I/O Reg 301: \O0   (\D2 ticks given)
13050	
13051	!]ERROR 1
13052	!] I8 A8 AA AB  NTWK
13053	!]NO ERROR 1
13054	!]  NTWK
13055	
13056	!*MESSAGE 2
13057	!*STIMULUS
13058	!*	Sync T & R Clocks
13059	!*	Write 8080 I/O Regs 102..115 for a write to mem loc 7777777
13060	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13061	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13062	!*	Tick T Clock until 'NXM' gets set in 8080 I/O Reg 301
13063	!*	  (Should take 16 ticks (4 T Clocks)) (It took \D2 ticks)
13064	!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
13065	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13066	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13067	!*	Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
13068	!*	  (Should take 16 ticks (4 T Clocks))
13069	!*RESPONSE
13070	!*	'MEM BUSY' never appeared in Reg 102 (\D3 more ticks)
13071	!*	8080 I/O Regs 301:  \O0   102:  \O1
13072	
13073	!]ERROR 2
13074	!] AA BA AB BB AC  NTWK
13075	!]NO ERROR 2
13076	!]  NTWK
13077	
13078	!*MESSAGE 3
13079	!*STIMULUS
13080	!*	Sync T & R Clocks
13081	!*	Write 8080 I/O Regs 102..115 for a write to mem loc 7777777
13082	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13083	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13084	!*	Tick T Clock until 'NXM' gets set in 8080 I/O Reg 301
13085	!*	  (Should take 16 ticks (4 T Clocks)) (It took \D2 ticks)
13086	!*	Write 8080 I/O Regs 102..115 for a write to mem loc 0
13087	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13088	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13089	!*	Tick T Clock until 'MEM BUSY' gets set in 8080 I/O Reg 102
13090	!*	  (Should take 16 ticks (4 T Clocks))
13091	!*RESPONSE
13092	!*	'MEM BUSY' appeared in I/O Reg 102 but it took \D3 ticks
13093	!*	8080 I/O Regs 301:  \O0   102:  \O1
13094	
13095	!]ERROR 3
13096	!] AA BA AB BB AC  NTWK
13097	!]NO ERROR 3
13098	!]  NTWK
13099	
13100	END;
13101	GLOBAL ROUTINE TST45: NOVALUE =
13102	
13103	!++   ---------- MMC TIMING:  GOOD VS. BAD DATA CYCLE ----------
13104	! TEST DESCRIPTION:  This routine verifies one small part of the
13105	!	timing characteristics  of  the MMC board.  First that a
13106	!	memory read takes 3 clock periods  when there are no ECC
13107	!	errors encountered. And that a read when bad data appears
13108	!	takes an additional clock period.
13109	!
13110	! TEST ASSUMPTIONS:  None.
13111	!
13112	! TEST PROCEDURE:  Master Reset
13113	!		   Write 0's to mem loc 111
13114	!		   Write status force bits 177
13115	!		   Write 0's to mem loc 222 (When read this will
13116	!			cause a single bit error)
13117	!		   Write 0's to mem loc 333 (When read this will
13118	!			cause a double bit error)
13119	!		   SYNC REFRESH - Make sure that the timing of this
13120	!		     test is not affected by the occurrence of a
13121	!		     mem refresh cycle occurring before it gets
13122	!		     started.  Clock is also put into maintenance
13123	!		     mode and synced.
13124	!		   Repeat for each mem location:
13125	!			Write Com/Adr data to 8080 Regs
13126	!			Write control bits to 8080 Regs
13127	!			Tick until 8080 I/O Reg 102 'R COM ADR' turns
13128	!			   on - Error if not correct number of ticks
13129	!			Tick until 8080 I/O Reg 102 'R MEM BUSY' turns
13130	!			   on - Error if not correct number of ticks
13131	!			Tick until 8080 I/O Reg 102 'R MEM BUSY' turns
13132	!			   off - Error if not correct number of ticks
13133	!
13134	! POSSIBLE ERRORS:  
13135	!
13136	!--
13137	
13138	BEGIN
13139	
13140	LITERAL
13141		WRITE_MSR = %O'500000100000',
13142		CLEAR_MRE = %O'100000000000',
13143		READ = %O'200000000000',
13144		APPROX = 1,			! Sync refresh approximately only
13145		AFTER = 1,			! Sync refresh after ?MRE occurred
13146		FORCE_SINGLE = %O'700000000376',! Force bits for a single bit error
13147		FORCE_DOUBLE = %O'700000000374';! Force bits for a double bit error
13148	
13149	OWN
13150		ADR_VECT: VECTOR[3]		! Three addr:  111 - good data
13151		    INITIAL (%O'111',%O'222',	! 	       222 - single bit error
13152			     %O'333'),		! 	       333 - double bit error
13153		T_CORRECT: VECTOR[3]		! Correct number of T-Clocks needed
13154		    INITIAL (12,16,24),		!   for each read
13155		T_CORRECT1: VECTOR[3]		! Correct number of T-Clocks needed
13156		    INITIAL (12,16,24),		!   for each read
13157		REGV: VECTOR[9];		! Error message output vector
13158	
13159	BIND
13160		TICK1 = REGV,			! Ticks to see Com/Adr in Reg 102
13161		REG102A = REGV[1],		! Reg 102 at TICK1
13162		TICK2 = REGV[2],		! Ticks to see Mem Busy in Reg 102
13163		REG102B = REGV[3],		! Reg 102 at TICK2
13164		TICK3 = REGV[4],		! Ticks to see Mem Busy in Reg 102
13165		REG102C = REGV[5],		! Reg 102 at TICK3
13166		MLOC = REGV[6],			! Memory location
13167		T_SHOULD = REGV[7],		! # of T Clocks it should have taken
13168		T_ACTUAL = REGV[8];		! # of T Clocks it actually did take
13169	
13170	LOCAL
13171		T_SHOULD1,
13172		ERR_FLAG;
13173	
13174	LABEL
13175		BLOCK1;
13176	
13177	IF RUN_TEST(45) THEN RETURN;		! Run this test? Return if no
13178	
13179	NOERR_45 = 0;				! No errors have occurred yet
13180	RPT_ERR_FLAG = 0;			! Don't report unexpected error
13181	
13182	DO (0) WHILE
13183	BLOCK1:	BEGIN
13184		MR();
13185		DM(111,0);			! Write good data
13186		IO_DEPOSIT(MSR,FORCE_SINGLE);
13187		DM(222,0);			! Write data with single bit error
13188		IO_DEPOSIT(MSR,FORCE_DOUBLE);
13189		DM(333,0);			! Write data with double bit error
13190	
13191		DEBUG = 0;			! Ensure SYNC doesnt print DEBUG output
13192		IF SYNC_REFRESH(APPROX,AFTER)
13193		    THEN BEGIN			! Sync refresh and abort if SYNC
13194			 ERR(1);		!   failed - set error flags and
13195			 NOERR_45 = 1;		!   abort this test.
13196			 ERR_FLAG = 1;
13197			 END;
13198		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
13199		IF .ERR_FLAG EQL 1 THEN RETURN;
13200	
13201		WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE that SYNC caused
13202		WRITE_DATA(CLEAR_MRE);
13203		WRITE_CONTROL();
13204		TICK(40);			! Give enough ticks to clear it
13205	
13206	! Now we are all set to read the data back and time each read access.
13207	
13208		INCR MEM_LOC FROM 0 TO 2 DO
13209		    BEGIN			! First write control data to 
13210		    MLOC = .ADR_VECT[.MEM_LOC];	!   8080 registers to do read
13211		    T_SHOULD = .T_CORRECT[.MEM_LOC];
13212		    T_SHOULD1 = .T_CORRECT1[.MEM_LOC];
13213		    WRITE_COMADR(READ + .ADR_VECT[.MEM_LOC]);
13214		    WRITE_CONTROL();
13215	
13216		    TICK1 = 0;			! Now tick until we see 'COM/ADR'
13217		    DO	BEGIN			!   in Reg 102 (should be much
13218			TICK(1);		!   less than 60 ticks)
13219			TICK1 = .TICK1 + 1;
13220			REG102A = RD_102;
13221			END
13222		    WHILE (.REG102A AND RCOM_ADR) EQL 0 AND .TICK1 LSS 60;
13223	
13224		    IF (.REG102A AND RCOM_ADR) EQL 0
13225			THEN BEGIN		! If this read failed set error
13226			     ERR_FLAG = 1;	!   flags, print error message
13227			     NOERR_45 = 1;	!   and abort this test.
13228			     ERRS(2,2,REGV);
13229			     END;
13230		    IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
13231		    IF .ERR_FLAG EQL 1 THEN RETURN;
13232	
13233		    TICK2 = 0;			! Now tick until we see 'MEM BUSY'
13234		    DO	BEGIN			!   in Reg 102 (should be much
13235			TICK(1);		!   less than 60 ticks)
13236			TICK2 = .TICK2 + 1;
13237			REG102B = RD_102;
13238			END
13239		    WHILE (.REG102B AND RMEM_BUSY) EQL 0 AND .TICK2 LSS 60;
13240	
13241		    IF (.REG102B AND RMEM_BUSY) EQL 0
13242			THEN BEGIN		! If 'MEM_BUSY' failed to appear
13243			     ERR_FLAG = 1;	!   set error flags, print error
13244			     NOERR_45 = 1;	!   message, and abort the test.
13245			     ERRS(3,3,REGV);
13246			     END;
13247		    IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
13248		    IF .ERR_FLAG EQL 1 THEN RETURN;
13249	
13250		    TICK3 = 0;			! Now tick along until 'MEM_BUSY'
13251		    DO	BEGIN			!   clears - by now we know how
13252			TICK(1);		!   long the read took.
13253			TICK3 = .TICK3 + 1;
13254			REG102C = RD_102;
13255			END
13256		    WHILE (.REG102C AND RMEM_BUSY) NEQ 0 AND .TICK3 LSS 60;
13257	
13258		    IF (.REG102C AND RMEM_BUSY) NEQ 0
13259			THEN BEGIN		! If 'MEM_BUSY' never cleared then
13260			     ERR_FLAG = 1;	!   set error flags, print error
13261			     NOERR_45 = 1;	!   message, and abort the test.
13262			     ERRS(4,4,REGV);
13263			     END;
13264		    IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
13265		    IF .ERR_FLAG EQL 1 THEN RETURN;
13266	
13267		    T_ACTUAL = .TICK3;		! Did the read take exactly as long
13268		    IF (.TICK3 NEQ .T_SHOULD) AND (.TICK3 NEQ .T_SHOULD1)
13269			THEN BEGIN		!   as it should have?
13270			     NOERR_45 = 1;	! If not set error flags and print
13271			     ERRS(5,5,REGV)	!   error message.
13272			     END;
13273		    IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
13274		    END;
13275		0				! To eliminate INFO compiler message
13276		END;
13277	
13278	!*MESSAGE 1
13279	!*STIMULUS
13280	!*	Sync T & R Clocks to a point shortly after a ?MRE has
13281	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
13282	!*	  memory controller) (To keep refresh from disrupting this test)
13283	!*RESPONSE
13284	!*	Attempt to sync T & R Clocks failed - could not generate a
13285	!*	  refresh error
13286	
13287	!]ERROR 1
13288	!] A9 B9 C9 AA AB BB  NTWK
13289	!]NO ERROR 1
13290	!]  NTWK
13291	
13292	!*MESSAGE 2
13293	!*STIMULUS
13294	!*	MR,LA 111,DM 0	Write 0's to mem loc 111
13295	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13296	!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
13297	!*	LA 222,DM 0	Write 0's to mem loc 222
13298	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13299	!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
13300	!*	LA 333,DM 0	Write 0's to mem loc 333
13301	!*	Sync T & R Clocks to a point shortly after a ?MRE has
13302	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
13303	!*	  memory controller) (To keep refresh from disrupting this test)
13304	!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
13305	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13306	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13307	!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
13308	!*	  start of the memory cycle
13309	!*RESPONSE
13310	!*	'COM ADR' not asserted after \D0 ticks
13311	!*	8080 I/O Reg 102:  \O1	
13312	
13313	!]ERROR 2
13314	!] BA  NTWK
13315	!]NO ERROR 2
13316	!]  NTWK
13317	
13318	!*MESSAGE 3
13319	!*STIMULUS
13320	!*	MR,LA 111,DM 0	Write 0's to mem loc 111
13321	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13322	!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
13323	!*	LA 222,DM 0	Write 0's to mem loc 222
13324	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13325	!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
13326	!*	LA 333,DM 0	Write 0's to mem loc 333
13327	!*	Sync T & R Clocks to a point shortly after a ?MRE has
13328	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
13329	!*	  memory controller) (To keep refresh from disrupting this test)
13330	!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
13331	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13332	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13333	!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
13334	!*	  start of the memory cycle - It took \D0 Ticks    102:  \O1
13335	!*	Tick clock until 'MEM BUSY' asserts in Reg 102
13336	!*RESPONSE
13337	!*	'MEM BUSY' never appeared in Reg 102
13338	!*	Reg 102:  \O3   After \D2 Ticks
13339	
13340	!]ERROR 3
13341	!] AA BA AB BB AC  NTWK
13342	!]NO ERROR 3
13343	!]  NTWK
13344	
13345	!*MESSAGE 4
13346	!*STIMULUS
13347	!*	MR,LA 111,DM 0	Write 0's to mem loc 111
13348	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13349	!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
13350	!*	LA 222,DM 0	Write 0's to mem loc 222
13351	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13352	!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
13353	!*	LA 333,DM 0	Write 0's to mem loc 333
13354	!*	Sync T & R Clocks to a point shortly after a ?MRE has
13355	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
13356	!*	  memory controller) (To keep refresh from disrupting this test)
13357	!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
13358	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13359	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13360	!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
13361	!*	  start of the memory cycle - It took \D0 ticks    102:  \O1
13362	!*	Tick clock until 'MEM BUSY' asserts in Reg 102 (It took \D2 ticks)
13363	!*	Tick clock until 'MEM BUSY' clears (It should take \D7 ticks)
13364	!*RESPONSE
13365	!*	'MEM BUSY' still asserted after \D4 ticks
13366	!*	8080 I/O Reg 102:  \O5	
13367	
13368	!]ERROR 4
13369	!] AA BA AB BB AC  NTWK
13370	!]NO ERROR 4
13371	!]  NTWK
13372	
13373	!*MESSAGE 5
13374	!*STIMULUS
13375	!*	MR,LA 111,DM 0	Write 0's to mem loc 111
13376	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13377	!*	DI 700000000376	  Set force bits '177' (Single bit ECC error)
13378	!*	LA 222,DM 0	Write 0's to mem loc 222
13379	!*	LI 100000	Write status to mem - Clear ERR HOLD ..
13380	!*	DI 700000000374	  Set force bits '176' (Double bit ECC error)
13381	!*	LA 333,DM 0	Write 0's to mem loc 333
13382	!*	Sync T & R Clocks to a point shortly after a ?MRE has
13383	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
13384	!*	  memory controller) (To keep refresh from disrupting this test)
13385	!*	Write 8080 I/O Regs 102..115 for a read of mem loc '\O6'
13386	!*	Write '360' to 8080 I/O Reg 210 control bits for write
13387	!*	  ('MEM','BUS REQ','XMIT ADR','XMIT DATA')
13388	!*	Tick clock until 'COM ADR' asserts in 8080 Reg 102 indicating the
13389	!*	  start of the memory cycle - It took \D0 ticks    102:  \O1
13390	!*	Tick clock until 'MEM BUSY' asserts in Reg 102 (It took \D2 ticks)
13391	!*	Tick clock until 'MEM BUSY' clears - 'MEM BUSY' should have been
13392	!*	  asserted for a total of \D7 ticks
13393	!*RESPONSE
13394	!*	Ticks needed to clear 'MEM BUSY' - \D5
13395	!*	MEM BUSY was asserted for \D8 ticks - Timing is off
13396	
13397	!]ERROR 5
13398	!] AA BA AB BB AC  NTWK
13399	!]NO ERROR 5
13400	!]  NTWK
13401	
13402	END;
13403	GLOBAL ROUTINE TST46: NOVALUE =
13404	
13405	!++   -------- 'MMC9 REFRESH ERR' BIT SET BY REFRESH ERROR -------
13406	! TEST DESCRIPTION:   This routine  verifies that the signal 'MMC9
13407	!	REFRESH ERR' can be set by a refresh error and in addition
13408	!	the 8080 can see the complement of this signal in Reg 101.
13409	!
13410	! TEST ASSUMPTIONS:  None.
13411	!
13412	! TEST PROCEDURE:  MR
13413	!		   LR 115  DR 4 (Set Com/Adr cycle)
13414	!		   LR 113  DR 6 (Set Com/Adr bits to a read & a write)
13415	!		   LR 210  DR 361 (Cause the data to go out on the
13416	!			bus to the MMC board)
13417	!		   Read Mem Stat Reg and 8080 Reg 101 and verify
13418	!			that 'REF ERR' shows up in each
13419	!
13420	! POSSIBLE ERRORS:  'MMC9 REF ERR' flop or 'MMC9 REF ERR B L' inverter
13421	!			are faulty.
13422	!
13423	!--
13424	
13425	BEGIN
13426	
13427	LOCAL
13428		ERR_FLAG,
13429		M_REF;
13430	
13431	OWN
13432		MEM_DATA_VECT: VECTOR[2],
13433		MEM_STAT_VECT: BTTVECTOR[36];
13434	
13435	BIND
13436		MEM_DAT = MEM_DATA_VECT,
13437		MEM_STAT = MEM_STAT_VECT,
13438		REF_ERR = UPLIT(%ASCIZ '?MRE');
13439	
13440	LABEL
13441		BLOCK1;
13442	
13443	IF RUN_TEST(46) THEN RETURN;		! Run this test? Return if no
13444	
13445	NOERR_46 = 0;				! No errors have occurred yet
13446	RPT_ERR_FLAG = 0;			! Don't report unexpected error
13447	
13448	DO (0) WHILE
13449	BLOCK1:	BEGIN
13450		MR();				! Master Reset
13451		HANG_MEM();			! Cause ?MRE
13452	
13453	! Get rid of the unexpected error message that CSL will send to STIRS
13454		CHK_ERR_MSG(REF_ERR);
13455	
13456		MEM_DAT = MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
13457		MEM_DATA_VECT[1] = M_REF = RD_101;	! Read Reg 101 (shows ?MRE)
13458		ERR_FLAG = 0;
13459		IF .MEM_STAT_VECT[2] EQL 0		! Did we get ?MRE?
13460		    THEN BEGIN
13461			 IF (.M_REF AND 1) EQL 0	! No - but check Reg 101 to
13462			    THEN ERR_FLAG = 1		!   see if that shows up the
13463			    ELSE BEGIN			!   ?MRE
13464				 TEST_ABORT = 1;
13465				 ERR_FLAG = 3;
13466				 END;
13467			 END
13468		    ELSE BEGIN
13469			 IF (.M_REF AND 1) EQL 0	! Yes - now make sure Reg 101
13470			    THEN BEGIN			!   shows ?MRE also
13471				 TEST_ABORT = 1;
13472				 ERR_FLAG = 2;
13473				 END;
13474			 END;
13475	
13476	! Now we know what type of error occurred if in fact one did so
13477	!   do the error message handling.
13478	
13479		INCR ERR FROM 1 TO 3 DO
13480		    BEGIN
13481		    IF .ERR EQL .ERR_FLAG		! Did this error occur?
13482			THEN BEGIN
13483			     NOERR_46 = 1;		! Yes - set error flag
13484			     ERRS(.ERR,.ERR,MEM_DAT);
13485			     END;
13486		    IF LOOP_CHK(.ERR) THEN LEAVE BLOCK1 WITH 1;
13487		    END;
13488		0				! To eliminate INFO compiler message
13489		END;
13490	
13491	!*MESSAGE 1
13492	!*STIMULUS
13493	!*	LR 115,DR 4	Write Com/Adr data to 8080 Regs - Set 'COM/ADR CYCLE'
13494	!*	LR 114,DR 0	  Set MEM WRITE, do not set 'DATA CYCLE' -- causes
13495	!*	LR 113,DR 1	  ?MRE
13496	!*	LR 210,DR 361	Set up mem cycle - 'CHECK NXM','CONSOLE REQ','T ENB
13497	!*			  FOR COM/ADR & DATA', and 'R CLK ENB L'
13498	!*	EI 100000	Read Mem Stat Reg - should show 'REF ERR'
13499	!*	ER 101		Read 8080 Reg 101 - should show 'MMC REF ERR B'
13500	!*RESPONSE
13501	!*	Neither IO Reg 101 or MSR shows 'REF ERR'
13502	!*	MSR:  \U0	I/O Reg 101:  \O1
13503	
13504	!]ERROR 1
13505	!] A9 B9 C9 AA AB BB  NTWK
13506	!]NO ERROR 1
13507	!]  NTWK
13508	
13509	!*MESSAGE 2
13510	!*STIMULUS
13511	!*	LR 115,DR 4	Write Com/Adr data to 8080 regs - set 'COM/ADR CYCLE'
13512	!*	LR 114,DR 0	  Set MEM WRITE, do not set 'DATA CYCLE' -- causes
13513	!*	LR 113,DR 1	  ?MRE
13514	!*	LR 210,DR 361	Set up mem cycle - 'CHECK NXM','CONSOLE REQ','T ENB
13515	!*			  FOR COM/ADR & DATA', and 'R CLK ENB L'
13516	!*	EI 100000	Read Mem Stat Reg - should show 'REF ERR'
13517	!*	ER 101		Read 8080 Reg 101 - should show 'MMC REF ERR B'
13518	!*RESPONSE
13519	!*	MSR shows 'REF ERR' but I/O Reg 101 does not
13520	!*	MSR:  \U0	I/O Reg 101:  \O1
13521	
13522	!]ERROR 2
13523	!] B9  NTWK
13524	!]NO ERROR 2
13525	!]  NTWK
13526	
13527	!*MESSAGE 3
13528	!*STIMULUS
13529	!*	LR 115,DR 4	Write Com/Adr data to 8080 regs - set 'COM/ADR CYCLE'
13530	!*	LR 114,DR 0	  Set MEM WRITE, do not set 'DATA CYCLE' -- causes
13531	!*	LR 113,DR 1	  ?MRE
13532	!*	LR 210,DR 361	Set up mem cycle - 'CHECK NXM','CONSOLE REQ','T ENB
13533	!*			  FOR COM/ADR & DATA', and 'R CLK ENB L'
13534	!*	EI 100000	Read Mem Stat Reg - should show 'REF ERR'
13535	!*	ER 101		Read 8080 Reg 101 - should show 'MMC REF ERR B'
13536	!*RESPONSE
13537	!*	IO Reg 101 shows 'REF ERR' but MSR does not
13538	!*	MSR:  \U0	I/O Reg 101:  \O1
13539	
13540	!]ERROR 3
13541	!] B9  NTWK
13542	!]NO ERROR 3
13543	!]  NTWK
13544	
13545	END;
13546	GLOBAL ROUTINE TST47: NOVALUE =
13547	
13548	!++   ---------------------- REFRESH TIMING -------------------------
13549	! TEST DESCRIPTION:  This test partially verifies the refresh control
13550	!	logic on MMC7. The logic which this test is trying to test is
13551	!	the binary counters  which determine when a refresh will take
13552	!	place and at what point after that a refresh error will occur
13553	!	if refresh does not happen because memory is hung or busy.
13554	!
13555	! TEST ASSUMPTIONS:  None.
13556	!
13557	! TEST PROCEDURE:  Write Com/Adr data to 8080 I/O Regs to hang MMC
13558	!		   Sync T & R Clocks
13559	!		   Write Com/Adr cycle data to I/O Reg: 210,114,115
13560	!		   Tick until ?MRE occurs
13561	!		   Write status to turn off ?MRE (60 ticks are given after
13562	!		     the ?MRE and 60 more ticks to get the write status
13563	!		     done - 120 ticks so far)
13564	!		   Write Com/Adr data to 8080 I/O Regs to hang MMC
13565	!		   Tick until ?MRE occurs - Should take 684 more ticks
13566	!			or a total of 200 T Clocks since the last
13567	!			?MRE.  If it doesnt there is a fault in 
13568	!			the counters.
13569	!
13570	! POSSIBLE ERRORS:  Binary counters on MMC7 faulty.
13571	!
13572	!--
13573	
13574	BEGIN
13575	
13576	LITERAL
13577		WRITE_MSR = %O'500000100000',
13578		CLEAR_MRE = %O'100000000000',
13579		HANGMEM = %O'300000000000';
13580	
13581	LOCAL
13582		TEMP;
13583	
13584	OWN
13585		ERR_FLAG,
13586		REG,
13587		REGV: VECTOR[9];
13588	
13589	BIND
13590		TICK1 = REGV,
13591		REG101 = REGV[1],
13592		TICK2 = REGV[2],
13593		TICK3 = REGV[3],
13594		TICK9 = REGV[5],
13595		TICK10 = REGV[6],
13596		TICK48 = REGV[7],
13597		TICK170 = REGV[8];
13598	
13599	LABEL
13600		BLOCK1;
13601	
13602	IF RUN_TEST(47) THEN RETURN;		! Run this test? Return if no
13603	
13604	NOERR_47 = 0;				! No errors have occurred yet
13605	REGV[4] = .MRE_TICKS;			! Save # ticks needed for ?MRE for
13606	TICK10 = .MRE_TICKS / 4;		!   error message printout
13607	TICK48 = .MRE_TICKS - 132 - 620;
13608	TICK170 = .MRE_TICKS - 620;
13609	
13610	! Do this section only if the DEBUG flag is set.
13611	
13612	IF .DEBUG NEQ 0 THEN			! This code is intended for debugging
13613		BEGIN				!   purposes.  It is executed only if
13614		MR();				!   DEBUG is non-zero.  It puts clocks
13615		SYNC_CLK();			!   in maintenance mode, does a memory
13616		HANG_MEM();			!   cycle to hang up memory (cause a
13617		TICK1 = 0;			!   ?MRE), then times how long it takes
13618		DO BEGIN			!   to get the ?MRE.  It counts ticks
13619		   TICK(4);			!   4 at a time and allows up to 4000.
13620		   REG101 = RD_101;		! 
13621		   REG = .REG101 AND MMC_REF_ERR;
13622		   TICK1 = .TICK1 + 4;
13623		   END
13624		WHILE (.REG EQL 0) AND (.TICK1 LSS 4000);
13625		ERRS(7,7,REGV);
13626	
13627		TICK(60);			! Tick forward a bit then clear
13628		WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
13629		WRITE_DATA(CLEAR_MRE);		!   more to get it done
13630		WRITE_CONTROL();
13631		TICK(60);
13632		REG = 0;			! Keep on ticking until it is done.
13633		TICK1 = 120;
13634		WHILE (.REG EQL 0) AND (.TICK1 LSS 1000) DO
13635		    BEGIN
13636		    TICK(4);
13637		    TICK1 = .TICK1 + 4;
13638		    REG101 = RD_101;
13639		    REG = .REG101 AND MMC_REF_ERR;
13640		    END;
13641	
13642		HANG_MEM();			! Now see how long it takes to get
13643		REG = 0;			!   the second ?MRE using same
13644		DO BEGIN			!   procedure as above.
13645		   TICK(4);
13646		   REG101 = RD_101;
13647		   REG = .REG101 AND MMC_REF_ERR;
13648		   TICK1 = .TICK1 + 4;
13649		   END
13650		WHILE (.REG EQL 0) AND (.TICK1 LSS 4000);
13651		ERRS(7,7,REGV);
13652	
13653		TICK(60);			! Tick forward a bit then clear
13654		WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
13655		WRITE_DATA(CLEAR_MRE);		!   more to get it done
13656		WRITE_CONTROL();
13657		TICK(60);
13658		REG = 0;			! Keep on ticking until it is done.
13659		TICK1 = 120;
13660		WHILE (.REG EQL 0) AND (.TICK1 LSS 1000) DO
13661		    BEGIN
13662		    TICK(4);
13663		    TICK1 = .TICK1 + 4;
13664		    REG101 = RD_101;
13665		    REG = .REG101 AND MMC_REF_ERR;
13666		    END;
13667	
13668		HANG_MEM();			! Now see how long it takes to
13669		REG = 0;			!   get the third ?MRE using the
13670		DO BEGIN			!   same procedure as above.
13671		   TICK(4);
13672		   REG101 = RD_101;
13673		   REG = .REG101 AND MMC_REF_ERR;
13674		   TICK1 = .TICK1 + 4;
13675		   END
13676		WHILE (.REG EQL 0) AND (.TICK1 LSS 4000);
13677		ERRS(7,7,REGV);
13678	
13679		START_CLK;			! Turn clocks back on and clear
13680		WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
13681		WRITE_DATA(CLEAR_MRE);		!   more to get it done
13682		WRITE_CONTROL();
13683		END;
13684	
13685	! Now get down to the actual test.  The prior section was done only if the
13686	!   DEBUG flag was set.
13687	
13688	INCR TRY FROM 0 TO 2 DO			! Try three times to get test to pass
13689		BEGIN				!   (in case of flaky errors)
13690		DO (0)	WHILE
13691	BLOCK1:	BEGIN
13692		RPT_ERR_FLAG = 0;		! Don't report unexpected error
13693		ERR_FLAG = TICK1 = 0;
13694	
13695	! First cause a ?MRE.  If the refresh logic is faulty the ?MRE may occur
13696	!   at the wrong time so we will give it 2 tries and 1056 ticks to get
13697	!   one.  
13698	
13699		DO  BEGIN
13700		    IF .TICK1 EQL 0 OR .TICK1 EQL 25*132
13701			THEN BEGIN
13702			     MR();			! Master Reset
13703			     SEND_NUL();		! Send it off
13704			     MR();			! Master Reset
13705			     SYNC_CLK();		! Clocks in maintenance mode
13706			     HANG_MEM();		! Cause a ?MRE (after enough
13707			     END;			!   ticks are given)
13708		    TICK(132);				! 132 ticks at a time
13709		    REG101 = RD_101;
13710		    REG = .REG101 AND MMC_REF_ERR;	! ?MRE yet?
13711		    TICK1 = .TICK1 + 132;
13712		    END
13713		WHILE (.REG EQL 0) AND (.TICK1 LSS 50*132);
13714	
13715		IF (.TICK1 EQL 50*132) AND (.REG EQL 0)
13716		    THEN BEGIN			! If we haven't failed 3 tries
13717			 IF .TRY NEQ 2 THEN	!   yet try another one.
13718			    LEAVE BLOCK1 WITH 0;! Couldnt get a ?MRE at all so
13719			 NOERR_47 = 1;		!   set error flags, write out an
13720			 ERR_FLAG = 1;		!   error message and abort the
13721			 ERRS(1,1,REGV);	!   test.
13722			 END;
13723		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
13724		IF .ERR_FLAG EQL 1 THEN RETURN;
13725	
13726		TICK(60);			! Tick forward a bit then clear
13727		WRITE_COMADR(WRITE_MSR);	!   ?MRE and tick forward some
13728		WRITE_DATA(CLEAR_MRE);		!   more to get it done
13729		WRITE_CONTROL();
13730		TICK(60);
13731		REG101 = RD_101;		! Make sure ?MRE got cleared
13732		REG = .REG101 AND MMC_REF_ERR;
13733		IF .REG EQL 1			! ?MRE did not get cleared so
13734		    THEN BEGIN			!   set error flags, write out an
13735			 IF .TRY NEQ 2 THEN	!   error message and abort the
13736			    LEAVE BLOCK1 WITH 0;!   test and future testing.
13737			 ERR_FLAG = 1;		! Note: if three tries have not
13738			 NOERR_47 = 1;		!   been done then don't do error
13739			 TEST_ABORT = 1;	!   handling yet.
13740			 ERRS(2,2,REGV);
13741			 END;
13742		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
13743		IF .ERR_FLAG EQL 1 THEN RETURN;
13744	
13745	! Now try to home in on the error more accurately.  At least we know
13746	!   by now that we can get a ?MRE and that we can predict within 132
13747	!   ticks the occurrence of the next ?MRE (when it should occur).
13748	! Note that the above was not really necessary except that the test
13749	!   would take too long if we went along 4 ticks at a time until we
13750	!   got a ?MRE.
13751	
13752		HANG_MEM();			! Now cause another ?MRE
13753		REG = 0;
13754		TICK(200);			! Move a ways down the track - 
13755		TICK(200);			!   500 ticks
13756		TICK(100);
13757		REG = TICK2 = 0;
13758	
13759		WHILE BEGIN				! Now go 4 ticks at a time
13760		      REG101 = RD_101;			!   until we see ?MRE in
13761		      REG = .REG101 AND MMC_REF_ERR;	!   Reg 101.
13762		      IF (.REG EQL 0) AND (.TICK2 LSS 2000)
13763			THEN 1 ELSE 0
13764		      END
13765		DO BEGIN
13766		    TICK(4);
13767		    TICK2 = .TICK2 + 4;
13768		    END;
13769	
13770		IF .REG EQL 0			! Were we able to cause another
13771		    THEN BEGIN			!   ?MRE within a reasonable 
13772			 IF .TRY NEQ 2 THEN	!   amount of time?  If no set
13773			    LEAVE BLOCK1 WITH 0;!   error flags, print error
13774			 ERR_FLAG = 1;		!   message and abort the test.
13775			 TEST_ABORT = 1;	! If this isn't third try yet 
13776			 NOERR_47 = 1;		!   keep trying.
13777			 ERRS(3,3,REGV);
13778			 END;
13779		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
13780		IF .ERR_FLAG EQL 1 THEN RETURN;
13781	
13782	! Now we are all set to actually time how long it takes for the
13783	!   the binary counters to count down to ?MRE.
13784	
13785		TICK(60);
13786		WRITE_COMADR(WRITE_MSR);	! Clear that ?MRE
13787		WRITE_DATA(CLEAR_MRE);
13788		WRITE_CONTROL();
13789		TICK(60);
13790	
13791		REG101 = RD_101;		! And make sure its cleared
13792		REG = .REG101 AND MMC_REF_ERR;
13793		IF .REG EQL 1			! If not cleared, set error
13794		    THEN BEGIN			!   flags, print error message
13795			 IF .TRY NEQ 2 THEN	!   and abort the test.
13796			    LEAVE BLOCK1 WITH 0;! If not third try yet - keep
13797			 ERR_FLAG = 1;		!   trying.
13798			 TEST_ABORT = 1;
13799			 NOERR_47 = 1;
13800			 ERRS(4,4,REGV);
13801			 END;
13802		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
13803		IF .ERR_FLAG EQL 1 THEN RETURN;
13804	
13805		HANG_MEM();			! Cause the next ?MRE
13806		REG = 0;
13807		TICK(200);			! Tick along a ways
13808		TICK(200);
13809		TICK(240);
13810		TICK3 = 760;			! So far we have done 760 ticks
13811	
13812		REG = 0;			! ?MRE should now occur in 44
13813		WHILE BEGIN			!   more ticks or so. (Actually 
13814		      REG101 = RD_101;		!   MRE_TICKS - 760 more ticks)
13815		      REG = .REG101 AND MMC_REF_ERR;
13816		      IF .REG EQL 0 AND .TICK3 LSS 4000
13817			THEN 1 ELSE 0
13818		      END
13819		DO BEGIN
13820		    TICK(4);			! So tick it along
13821		    TICK3 = .TICK3 + 4;
13822		    END;
13823	
13824		IF .TICK3 NEQ .MRE_TICKS AND .REG EQL 1
13825		    THEN BEGIN			! Did ?MRE occur at the right
13826			 IF .TRY NEQ 2 THEN	!   time? - If no set error flags,
13827			    LEAVE BLOCK1 WITH 0;!   print message and abort the test.
13828			 TEST_ABORT = 1;	! If not third try yet - keep trying
13829			 NOERR_47 = 1;
13830			 ERRS(5,5,REGV);
13831			 END;
13832		IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
13833	
13834		IF .REG EQL 0			! ?MRE did not actually occur again
13835		    THEN BEGIN			!   at all so set error flags, print
13836	  		 IF .TRY NEQ 2 THEN	!   error message and exit.
13837			    LEAVE BLOCK1 WITH 0;! If not third try yet - keep trying.
13838			 TEST_ABORT = 1;
13839			 NOERR_47 = 1;
13840			 ERRS(6,6,REGV);
13841			 END;
13842		IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
13843		0				! To eliminate INFO compiler message
13844		END;
13845		END;
13846	
13847	!*MESSAGE 1
13848	!*STIMULUS
13849	!*	Sync T & R Clocks in maintenance mode
13850	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
13851	!*	  hang memory controller and cause a memory refresh error
13852	!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
13853	!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
13854	!*	At this point we should be within 132 ticks of the time the refresh
13855	!*	  error actually occurred
13856	!*RESULTS
13857	!*	After 6600 ticks (1650 T Clocks) a ?MRE still failed to appear
13858	
13859	!]ERROR 1
13860	!] A9 B9 C9 AA AB BB  NTWK
13861	!]NO ERROR 1
13862	!]  NTWK
13863	
13864	!*MESSAGE 2
13865	!*STIMULUS
13866	!*	Sync T & R Clocks in maintenance mode
13867	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
13868	!*	  hang memory controller and cause a memory refresh error
13869	!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
13870	!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
13871	!*	?MRE did appear after \D0 ticks
13872	!*	Do 60 ticks (15 T Clocks)
13873	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13874	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13875	!*RESPONSE
13876	!*	?MRE did not clear   8080 Reg 101:  \O1
13877	
13878	!]ERROR 2
13879	!] B9  NTWK
13880	!]NO ERROR 2
13881	!]  NTWK
13882	
13883	!*MESSAGE 3
13884	!*STIMULUS
13885	!*	Sync T & R Clocks in maintenance mode
13886	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
13887	!*	  hang memory controller and cause a memory refresh error
13888	!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
13889	!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
13890	!*	?MRE did appear after \D0 ticks
13891	!*	Do 60 ticks (15 T Clocks)
13892	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13893	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13894	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
13895	!*	  hang memory controller and cause a memory refresh error
13896	!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
13897	!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert
13898	!*RESPONSE
13899	!*	No refresh error occurred even after \D2 additional ticks
13900	
13901	!]ERROR 3
13902	!] A9 B9 C9  NTWK
13903	!]NO ERROR 3
13904	!]  NTWK
13905	
13906	!*MESSAGE 4
13907	!*STIMULUS
13908	!*	Sync T & R Clocks in maintenance mode
13909	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
13910	!*	  hang memory controller and cause a memory refresh error
13911	!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
13912	!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
13913	!*	?MRE did appear after \D0 ticks
13914	!*	Do 60 ticks (15 T Clocks)
13915	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13916	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13917	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
13918	!*	  hang memory controller and cause a memory refresh error
13919	!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
13920	!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert - it took
13921	!*	  \D2 additional ticks
13922	!*	Do 60 ticks (15 T Clocks)
13923	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13924	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13925	!*RESPONSE
13926	!*	?MRE did not clear   8080 Reg 101:  \O1
13927	
13928	!]ERROR 4
13929	!] B9  NTWK
13930	!]NO ERROR 4
13931	!]  NTWK
13932	
13933	!*MESSAGE 5
13934	!*STIMULUS
13935	!*	Sync T & R Clocks in maintenance mode
13936	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
13937	!*	  hang memory controller and cause a memory refresh error
13938	!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
13939	!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
13940	!*	?MRE did appear after \D0 ticks
13941	!*	Do 60 ticks (15 T Clocks)
13942	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13943	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13944	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
13945	!*	  hang memory controller and cause a memory refresh error
13946	!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
13947	!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert - It took
13948	!*	  \D2 additional ticks
13949	!*	Do 60 ticks (15 T Clocks)
13950	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13951	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13952	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - To
13953	!*	  hang memory controller and cause a memory refresh error
13954	!*	Tick T Clock forward 640 ticks (160 T Clocks)
13955	!*	Tick T Clock forward 4 ticks (1 T Clock) at a time until a ?MRE
13956	!*	  occurs - It should have taken \D4 ticks since the previous ?MRE
13957	!*RESPONSE
13958	!*	Caused a ?MRE after \D3 ticks - Timing is faulty
13959	
13960	!]ERROR 5
13961	!] A9 B9 C9  NTWK
13962	!]NO ERROR 5
13963	!]  NTWK
13964	
13965	!*MESSAGE 6
13966	!*STIMULUS
13967	!*	Sync T & R Clocks in maintenance mode
13968	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
13969	!*	  hang memory controller and cause a memory refresh error
13970	!*	Tick T Clock forward 132 ticks (33 T Clocks) so that sometime in the
13971	!*	  next \D4 ticks (\D6 T Clocks) 'MMC9 REFRESH ERR' will assert
13972	!*	?MRE did appear after \D0 ticks
13973	!*	Do 60 ticks (15 T Clocks)
13974	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13975	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13976	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
13977	!*	  hang memory controller and cause a memory refresh error
13978	!*	Tick T Clock forward 500 ticks (125 T Clocks) so that sometime in the
13979	!*	  next \D7 to \D8 ticks 'MMC9 REFRESH ERR' will assert - It took
13980	!*	  \D2 additional ticks
13981	!*	Do 60 ticks (15 T Clocks)
13982	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
13983	!*	Do 60 ticks (15 T Clocks) - Now ?MRE should be cleared from Reg 101
13984	!*	Write 8080 Regs 103..115,210 to neither write nor read memory - to
13985	!*	  hang memory controller and cause a memory refresh error
13986	!*	Tick T Clock forward 640 ticks (160 T Clocks)
13987	!*	Tick T Clock forward 4 ticks (1 T Clock) at a time until a ?MRE
13988	!*	  occurs - It should have taken \D4 ticks since the previous ?MRE
13989	!*RESPONSE
13990	!*	No refresh error occurred even after \D3 ticks    REG 101:  \O1
13991	
13992	!]ERROR 6
13993	!] A9 B9 C9  NTWK
13994	!]NO ERROR 6
13995	!]  NTWK
13996	
13997	!*MESSAGE 7
13998	!*STIMULUS
13999	!*RESPONSE
14000	!*	TICKS TO SEE ?MRE \D0   REG101 \O1
14001	
14002	!]ERROR 7
14003	!]  NTWK
14004	!]NO ERROR 7
14005	!]  NTWK
14006	
14007	END;
14008	GLOBAL ROUTINE TST48: NOVALUE =
14009	
14010	!++   ------------ TIMING TEST OF REFRESH CYCLE (LENGTH) ------------
14011	! TEST DESCRIPTION:  This routine  verifies that a refresh cycle does
14012	!	not take longer than 750 NS or 5 T Clocks.  This test sets up
14013	!	the  MMC  board  immediately  before the refresh cycle should
14014	!	occur.  Then a Write I/O Status to memory  is  started to set
14015	!	parity error immediately after the refresh cycle is complete.
14016	!	The timing is then verified.
14017	!
14018	! TEST ASSUMPTIONS:  None
14019	!
14020	! TEST PROCEDURE:  Master Reset
14021	!		   SYNC REFRESH - Set up MMC board such that refresh
14022	!			error has just occurred. To do this the clock
14023	!			is also put into Maintenance Mode and synced.
14024	!		   Write data into 8080 Regs - For a write status to
14025	!			turn off ?MRE
14026	!		   Write data to mem location 0 - To keep memory busy
14027	!			past the point where 'REFRESH REQUEST' gets
14028	!			asserted - so that when the write status is
14029	!			begun the memory will not do it for 5 T Clocks
14030	!			while refresh is occurring
14031	!		   Write data into 8080 regs - For a write status to
14032	!			turn on PE
14033	!		   Do a T Clock until 'PE' is detected (by a read of
14034	!			8080 I/O Reg 100)
14035	!		   Verify that the number of T Clocks it took is ok
14036	!
14037	! POSSIBLE ERRORS:  
14038	!
14039	!--
14040	
14041	BEGIN
14042	
14043	LITERAL
14044		AFTER = 1,			! Sync after the ?MRE
14045		EXACT = 0,			! Sync exactly
14046		CLEAR_MRE = %O'700000000000',
14047		WRITE_MEM = %O'100000000000',
14048		WRITE_MSR = %O'500000100000';
14049	
14050	OWN
14051		RETRY,				! Retry flag
14052		VTICK: INITIAL(86),
14053		ERR_FLAG,			! Error flag set when error occurs
14054		REG101,				! 8080 register 101
14055		MESSV: VECTOR[5];		! Error message data
14056	
14057	BIND
14058		REG102 = MESSV,			! What the error message data
14059		TICK1 = MESSV[1],		!   consists of
14060		TICK2 = MESSV[2],
14061		TICK3 = MESSV[3],
14062		TICK4 = MESSV[4];
14063	
14064	LABEL
14065		BLOCK1;
14066	
14067	IF RUN_TEST(48) THEN RETURN;		! Run this test? Return if no
14068	
14069	NOERR_48 = 0;				! No errors have occurred yet
14070	RPT_ERR_FLAG = 0;			! Don't report unexpected error
14071	RETRY = 0;				! Clear retry count
14072	
14073	DO (0) WHILE
14074	BLOCK1:	BEGIN
14075	
14076	! Get everything set up - flags and sync the clock and refresh
14077	
14078		MR();				! Master Reset
14079		WAIT(100);			! Wait 100 msecs
14080		MR();				! Master Reset
14081		MR();				! Master Reset
14082		DEBUG = 0;			! Make sure DEBUG is off
14083		ERR_FLAG = 0;			! No errors yet
14084		IF SYNC_REFRESH(EXACT,AFTER)
14085		    THEN BEGIN
14086			 IF SYNC_REFRESH(EXACT,AFTER)	! Sync refresh
14087			    THEN BEGIN
14088				 ERR_FLAG = 1;	! It failed so set the error flags
14089				 NOERR_48 = 1;	!   and write out error message
14090				 ERR(1);
14091				 END;
14092			 END;
14093		IF LOOP_CHK(1)			! Loop on error?
14094		    THEN LEAVE BLOCK1 WITH 1;
14095		IF .ERR_FLAG EQL 1 THEN RETURN;	! Did SYNC fail - if so abort test
14096	
14097	! Now we are ready to do the test.  First just clear the ?MRE caused by
14098	!   SYNC_REFRESH and give a few ticks to get close to the point where
14099	!   MMC will want to start a refresh cycle.
14100	
14101		WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE
14102		WRITE_DATA(CLEAR_MRE);
14103		WRITE_CONTROL();
14104		TICK(200);			! Tick forward a ways (486 ticks)
14105		TICK(200);
14106		TICK(.VTICK);
14107		TICK1 = 0;
14108	
14109		REG101 = RD_101;		! Make sure we didnt get ?MRE yet
14110		IF (.REG101 AND MMC_REF_ERR) NEQ 0
14111		    THEN BEGIN				
14112			 ERR_FLAG = 1;		! If ?MRE occurred then set
14113			 TEST_ABORT = 1;	!   error flags, abort all
14114			 NOERR_48 = 1;		!   future testing and write	
14115			 ERRS(2,2,REG101);	!   out an error message
14116			 END;
14117		IF LOOP_CHK(2) THEN LEAVE BLOCK1 WITH 1;
14118		IF .ERR_FLAG EQL 1 THEN RETURN;
14119	
14120	! Now write to memory - while this is occurring 'REFRESH REQUEST' will
14121	!   assert but no refresh will occur because the memory is busy.
14122	! Various error conditions may occur along the way at which point the
14123	!   test will be aborted.   These  errors  are mostly that the memory
14124	!   cycle is not progressing as it should.
14125	
14126		WRITE_COMADR(WRITE_MEM);	! Write to memory and just
14127		WRITE_CONTROL();		!   tick the clock until
14128		TICK1 = 0;			!   Mem Busy appears in
14129		DO BEGIN			!   8080 Reg 102
14130		    TICK(1);
14131		    REG102 = RD_102;
14132		    TICK1 = .TICK1 + 1;
14133		    END
14134		WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK1 LSS 100;
14135	
14136		IF (.REG102 AND RMEM_BUSY) EQL 0
14137		    THEN BEGIN			! If Mem Busy never appeared in
14138			 ERR_FLAG = 1;		!   Reg 102 then abort the test,
14139			 TEST_ABORT = 1;	!   set error flags, and write
14140			 NOERR_48 = 1;		!   out an error message
14141			 ERRS(3,3,MESSV);
14142			 END;
14143		IF LOOP_CHK(3) THEN LEAVE BLOCK1 WITH 1;
14144		IF .ERR_FLAG EQL 1 THEN RETURN;
14145	
14146		TICK2 = 0;			! Now just tick the clock some
14147		DO BEGIN			!   more until Mem Busy goes
14148		    TICK(1);			!   away (at that point the
14149		    REG102 = RD_102;		!   memory cycle would be done).
14150		    TICK2 = .TICK2 + 1;
14151		    END
14152		WHILE (.REG102 AND RMEM_BUSY) NEQ 0 AND .TICK2 LSS 100;
14153	
14154		IF (.REG102 AND RMEM_BUSY) NEQ 0
14155		    THEN BEGIN			! If Mem Busy never cleared from
14156			 ERR_FLAG = 1;		!   Reg 102 then set error flags,
14157			 TEST_ABORT = 1;	!   write out error message and
14158			 NOERR_48 = 1;		!   abort this test and any others.
14159			 ERRS(4,4,MESSV);
14160			 END;
14161		IF LOOP_CHK(4) THEN LEAVE BLOCK1 WITH 1;
14162		IF .ERR_FLAG EQL 1 THEN RETURN;
14163	
14164	! Now we are ready to do the test. Just initiate another write to
14165	!   memory and this time it should take longer than  normal since
14166	!   refresh has to complete before the cycle is started.
14167	
14168		TICK(2);			! Give MMC a chance to start the
14169		WRITE_COMADR(WRITE_MEM);	!   refresh cycle then initiate
14170		WRITE_CONTROL();		!   another memory write cycle
14171	
14172		TICK3 = 0;			! Tick until Mem Busy appears in
14173		DO BEGIN			!   Reg 102
14174		    TICK(1);
14175		    REG102 = RD_102;
14176		    TICK3 = .TICK3 + 1;
14177		    END
14178		WHILE (.REG102 AND RMEM_BUSY) EQL 0 AND .TICK3 LSS 100;
14179	
14180		IF (.REG102 AND RMEM_BUSY) EQL 0
14181		    THEN BEGIN			! Mem Busy never appeared in Reg 102
14182			 ERR_FLAG = 1;		!   so set error flags, write out
14183			 TEST_ABORT = 1;	!   an error message and abort the
14184			 NOERR_48 = 1;		!   test.
14185			 ERRS(5,5,MESSV);
14186			 END;
14187		IF LOOP_CHK(5) THEN LEAVE BLOCK1 WITH 1;
14188		IF .ERR_FLAG EQL 1 THEN RETURN;
14189	
14190		TICK4 = 0;			! Now see how long this write
14191		DO BEGIN			!   takes (until Mem Busy goes
14192		    TICK(1);			!   away).  It should take
14193		    REG102 = RD_102;		!   24 ticks.
14194		    TICK4 = .TICK4 + 1;
14195		    END
14196		WHILE (.REG102 AND RMEM_BUSY) NEQ 0 AND .TICK4 LSS 100;
14197	
14198		IF (.REG102 AND RMEM_BUSY) NEQ 0
14199		    THEN BEGIN			! Mem Busy never cleared - set
14200			 ERR_FLAG = 1;		!   error flags, write out an
14201			 TEST_ABORT = 1;	!   error message, and abort
14202			 NOERR_48 = 1;		!   the test
14203			 ERRS(6,6,MESSV);
14204			 END;
14205		IF LOOP_CHK(6) THEN LEAVE BLOCK1 WITH 1;
14206		IF .ERR_FLAG EQL 1 THEN RETURN;
14207	
14208		IF .TICK4 NEQ 24		! If the number of ticks is not 24
14209		    THEN BEGIN			!   then either refresh never
14210			 RETRY = .RETRY + 1;
14211			 IF .RETRY LSS 3 THEN LEAVE BLOCK1 WITH 1;
14212			 TEST_ABORT = 1;	!   occurred or the timing of it
14213			 NOERR_48 = 1;		!   or the memory cycle is faulty.
14214			 ERRS(7,7,MESSV);
14215			 END;
14216		0				! To eliminate INFO compiler message
14217		END;
14218	
14219	!*MESSAGE 1
14220	!*STIMULUS
14221	!*	Sync T & R Clocks to a point shortly after a ?MRE has
14222	!*	  Occurred (Sync clocks then cause a ?MRE by hanging the
14223	!*	  memory controller) (To keep refresh from disrupting this test)
14224	!*RESPONSE
14225	!*	Attempt to sync T & R Clocks failed - could not generate a
14226	!*	  refresh error
14227	
14228	!]ERROR 1
14229	!] A9 B9 C9 AA AB BB  NTWK
14230	!]NO ERROR 1
14231	!]  NTWK
14232	
14233	!*MESSAGE 2
14234	!*STIMULUS
14235	!*	Sync T & R Clocks to a point immediately after refresh error
14236	!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
14237	!*	  memory controller)
14238	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
14239	!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
14240	!*	  ticks 'MMC9 REFRESH REQ' will assert
14241	!*RESPONSE
14242	!*	'MMC9 REF ERR' did not clear - Write status failed
14243	!*	8080 Reg 101:  \O0
14244	
14245	!]ERROR 2
14246	!] B9  NTWK
14247	!]NO ERROR 2
14248	!]  NTWK
14249	
14250	!*MESSAGE 3
14251	!*STIMULUS
14252	!*	Sync T & R Clocks to a point immediately after refresh error
14253	!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
14254	!*	  memory controller)
14255	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
14256	!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
14257	!*	  ticks 'MMC9 REFRESH REQ' will assert
14258	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
14259	!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
14260	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14261	!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14262	!*	  Reg 102 (so that a refresh cycle will occur immediately before
14263	!*	  after 'MEM BUSY' clears and before the next memory write
14264	!*RESPONSE
14265	!*	'MEM BUSY' never appeared in 8080 I/O Reg 102:  \O0
14266	!*	Number of ticks given:  \D1
14267	
14268	!]ERROR 3
14269	!]  NTWK
14270	!]NO ERROR 3
14271	!]  NTWK
14272	
14273	!*MESSAGE 4
14274	!*STIMULUS
14275	!*	Sync T & R Clocks to a point immediately after refresh error
14276	!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
14277	!*	  memory controller)
14278	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
14279	!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
14280	!*	  ticks 'MMC9 REFRESH REQ' will assert
14281	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - just to keep
14282	!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
14283	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14284	!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14285	!*	  Reg 102 (so that a refresh cycle will occur immediately before
14286	!*	  after 'MEM BUSY' clears and before the next memory write
14287	!*RESPONSE
14288	!*	'MEM BUSY' appeared in 8080 I/O Reg 102 after \D1 ticks but it was
14289	!*	  never cleared    (8080 I/O Reg 102:  \O0)
14290	!*	Number of ticks given:  \D2  (after 'MEM BUSY' was set)
14291	
14292	!]ERROR 4
14293	!]  NTWK
14294	!]NO ERROR 4
14295	!]  NTWK
14296	
14297	!*MESSAGE 5
14298	!*STIMULUS
14299	!*	Sync T & R Clocks to a point immediately after refresh error
14300	!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
14301	!*	  memory controller)
14302	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
14303	!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
14304	!*	  ticks 'MMC9 REFRESH REQ' will assert
14305	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
14306	!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
14307	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14308	!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14309	!*	  Reg 102 (so that a refresh cycle will occur immediately before
14310	!*	  after 'MEM BUSY' clears and before the next memory write
14311	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - It should take
14312	!*	  16 extra ticks (4 T Clocks) since a refresh cycle will be occurring
14313	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14314	!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14315	!*	  Reg 102 - Then verify the number of ticks take for the write
14316	!*RESPONSE
14317	!*	'MEM BUSY' never appeared in 8080 I/O Reg 102:  \O0
14318	!*	Number of ticks given:  \D3
14319	
14320	!]ERROR 5
14321	!]  NTWK
14322	!]NO ERROR 5
14323	!]  NTWK
14324	
14325	!*MESSAGE 6
14326	!*STIMULUS
14327	!*	Sync T & R Clocks to a point immediately after refresh error
14328	!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
14329	!*	  memory controller)
14330	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
14331	!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 
14332	!*	  ticks 'MMC9 REFRESH REQ' will assert
14333	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
14334	!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
14335	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14336	!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14337	!*	  Reg 102 (so that a refresh cycle will occur immediately before
14338	!*	  after 'MEM BUSY' clears and before the next memory write
14339	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - It should take
14340	!*	  16 extra ticks (4 T Clocks) since a refresh cycle will be occurring
14341	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14342	!*	Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14343	!*	  Reg 102 - Then verify the number of ticks take for the write
14344	!*RESPONSE
14345	!*	'MEM BUSY' appeared in 8080 I/O Reg 102 after \D3 ticks but it was
14346	!*	  never cleared    (8080 I/O Reg 102:  \O0)
14347	!*	Number of ticks given:  \D4  (After 'MEM BUSY' was set)
14348	
14349	!]ERROR 6
14350	!]  NTWK
14351	!]NO ERROR 6
14352	!]  NTWK
14353	
14354	!*MESSAGE 7
14355	!*STIMULUS
14356	!*	Sync T & R Clocks to a point immediately after refresh error
14357	!*	  has Occurred (Sync clocks then cause a ?MRE by hanging the
14358	!*	  memory controller)
14359	!*	Write 8080 Regs 102..115,210 for a write status to clear ?MRE
14360	!*	Tick T Clock forward 486 ticks (122 T Clocks) so that in 38
14361	!*	  ticks 'MMC9 REFRESH REQ' will assert
14362	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - Just to keep
14363	!*	  memory busy until after 'MMC9 REFRESH REQ' has been asserted
14364	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14365	!*	(A) Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14366	!*	    Reg 102 (So that a refresh cycle will occur immediately before
14367	!*	    after 'MEM BUSY' clears and before the next memory write
14368	!*	Write 8080 I/O Regs 102..115,210 for a write to mem - It should take
14369	!*	  16 extra ticks (4 T Clocks) since a refresh cycle will be occurring
14370	!*	  (Reg 210 contains '360' - 'MEM','BUS REQ','XMIT ADR','XMIT DATA')
14371	!*	(B) Tick T Clock until 'MEM BUSY' appears and disappears from 8080
14372	!*	    Reg 102 - Then verify the number of ticks take for the write -
14373	!*	    It should take 24 ticks (6 T Clocks) which is 16 ticks longer
14374	!*	    than normal (600 NS - 4 T Clocks)
14375	!*RESPONSE
14376	!*	'MEM BUSY' was asserted for \D4 ticks instead of 24 ticks
14377	!*	(A) Ticks to appear - \D1    Disappear - \D2
14378	!*	(B) Ticks to appear - \D3    Disappear - \D4
14379	
14380	!]ERROR 7
14381	!] A9 B9 C9  NTWK
14382	!]NO ERROR 7
14383	!]  NTWK
14384	
14385	
14386	END;
14387	GLOBAL ROUTINE TST49: NOVALUE =
14388	
14389	!++   -------------- SYNC REFRESH DEBUG ROUTINE -------------------
14390	! TEST DESCRIPTION:  This  routine tests 'SYNC REFRESH' for each of
14391	!	the possible combination of inputs. The test is intended to
14392	!	aid  in  debugging and is left in the module for any future
14393	!	debugging needs.  This test is run by changing the variable
14394	!	'DEBUG1' from a 0 to a 1.  The routine 'SYNC REFRESH'  uses
14395	!	the  variable 'DEBUG'.  If 'DEBUG' is set,  the  particular
14396	!	test calling 'SYNC_REFRESH' will be expected  to supply the
14397	!	text of the error messages used.  If 'DEBUG1' is equal to 0
14398	!	in this test no testing of 'SYNC_REFRESH' will be done.
14399	!
14400	! TEST ASSUMPTIONS:  None
14401	!
14402	! TEST PROCEDURE:  Master Reset
14403	!		   SYNC REFRESH
14404	!		   Write status - turn off ?MRE
14405	!		   Tick 60 times
14406	!		   Write mem - hang mem
14407	!		   Tick clock for the next 1600 ticks (400 T CLOCKS)
14408	!			and watch for 'MEM REF ERR' in Reg 102
14409	!			(stop when ?MRE is seen)
14410	!
14411	!		   Do the above steps for:
14412	!			SYNC_REFRESH(EXACTLY,BEFORE)
14413	!			SYNC_REFRESH(EXACTLY,AFTER)
14414	!			SYNC_REFRESH(APPROX,BEFORE)
14415	!			SYNC_REFRESH(APPROX,AFTER)
14416	!
14417	! POSSIBLE ERRORS:  Sometimes a flaky error may occur and prevent this
14418	!	routine from working successfully.  This  is  sometimes a line
14419	!	problem or maybe a synchronization problem between CSL and the
14420	!	8080.
14421	!--
14422	
14423	BEGIN
14424	
14425	LITERAL
14426		WRITE_MSR = %O'500000100000',
14427		CLEAR_MRE = %O'100000000000',	! Data portion of a write MSR
14428		HANG_MEM = %O'300000000000';	! Read & Write simultaneously
14429	
14430	OWN
14431		RE_ERR,
14432		REGV: VECTOR[2];
14433	
14434	BIND
14435		REG = REGV;
14436	
14437	LABEL
14438		BLOCK1;
14439	
14440	DO (0)	WHILE
14441	BLOCK1:	BEGIN
14442	
14443		IF .DEBUG1 EQL 0			! Only run this routine if the
14444		    THEN RETURN 0;			!   DEBUG1 switch is on
14445	
14446		INCR AHOW FROM 0 TO 1 DO		! Do for exact and approximate
14447		    BEGIN
14448		    INCR AWHEN FROM 0 TO 1 DO		! Do for ?MRE before and after
14449			BEGIN
14450			MR();
14451			REGV[0] = .AHOW;		! Write out what type of a SYNC
14452			REGV[1] = .AWHEN;		!   we are going to do
14453			ERRS(7,7,REGV);
14454			DEBUG = 1;			! Turn on the DEBUG switch so 
14455							!   that SYNC will output
14456			RE_ERR = SYNC_REFRESH(.AHOW,.AWHEN);
14457			IF .RE_ERR EQL 1		! Did it fail to get ?MRE
14458			    THEN ERR(10);
14459			WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE and watch Reg 
14460			WRITE_DATA(CLEAR_MRE);		!   101 to see when the ?MRE
14461			WRITE_CONTROL();		!   actually gets cleared.
14462			INCR TICKN FROM 1 TO 50 DO
14463			    BEGIN
14464			    TICK(4);
14465			    REG = RD_101;
14466			    REGV[1] = .TICKN * 4;
14467			    ERRS(8,8,REGV);
14468			    END;
14469			WRITE_COMADR(HANG_MEM);		! Now hang mem to cause another
14470			WRITE_CONTROL();		!   ?MRE and just find out when
14471			INCR TICKN FROM 1 TO 600 DO	!   the next one occurs so that
14472			    BEGIN			!   we see where SYNC_REFRESH
14473			    TICK(4);			!   left us.
14474			    REG = RD_101;
14475			    REGV[1] = .TICKN * 4;
14476			    ERRS(9,9,REGV);
14477			    IF (.REG AND 1) EQL 1
14478				THEN EXITLOOP 0;
14479			    END;
14480			START_CLK;
14481			END;
14482		    END;
14483		0				! To eliminate INFO compiler message
14484		END;
14485	
14486	!*MESSAGE 1
14487	!*S1:  Number of ticks required to generate ?MRE - \D1   101: \O0
14488	
14489	!]ERROR 1
14490	!]  NTWK
14491	!]NO ERROR 1
14492	!]  NTWK
14493	
14494	!*MESSAGE 2
14495	!*S2:  After 60 more ticks - 101: \O0
14496	
14497	!]ERROR 2
14498	!]  NTWK
14499	!]NO ERROR 2
14500	!]  NTWK
14501	
14502	!*MESSAGE 3
14503	!*S3:  Write 'CLEAR ?MRE' data to 8080 regs
14504	!*S3:  Give 60 more ticks - 101: \O0
14505	
14506	!]ERROR 3
14507	!]  NTWK
14508	!]NO ERROR 3
14509	!]  NTWK
14510	
14511	!*MESSAGE 4
14512	!*S4:  Write 'HANG MEM' data to 8080 regs then tick until ?MRE
14513	!*S4:  Ticks - \D1    101 - \O0
14514	
14515	!]ERROR 4
14516	!]  NTWK
14517	!]NO ERROR 4
14518	!]  NTWK
14519	
14520	!*MESSAGE 5
14521	!*S5:  Tick 60 then write 'CLEAR ?MRE' data to 8080 regs
14522	!*S5:  Give 60 more ticks - 101: \O0
14523	!*S5:  Give 668 more ticks
14524	
14525	!]ERROR 5
14526	!]  NTWK
14527	!]NO ERROR 5
14528	!]  NTWK
14529	
14530	!*MESSAGE 6
14531	!*S6:  Write 'HANG MEM' data to 8080 regs then give 280 ticks
14532	!*S6:  101: \O0
14533	
14534	!]ERROR 6
14535	!]  NTWK
14536	!]NO ERROR 6
14537	!]  NTWK
14538	
14539	!*MESSAGE 7
14540	!*T1:  Call SYNC REFRESH - How \O0   When \O1
14541	
14542	!]ERROR 7
14543	!]  NTWK
14544	!]NO ERROR 7
14545	!]  NTWK
14546	
14547	!*MESSAGE 8
14548	!*T2:  'CLEAR ?MRE' data written to 8080 regs then clock is ticked
14549	!*T2:  Ticks: \D1    101: \O0
14550	
14551	!]ERROR 8
14552	!]  NTWK
14553	!]NO ERROR 8
14554	!]  NTWK
14555	
14556	!*MESSAGE 9
14557	!*T3:  'HANG MEM' data written to 8080 regs then clock is ticked
14558	!*T3:  Ticks: \D1    101: \O0
14559	
14560	!]ERROR 9
14561	!]  NTWK
14562	!]NO ERROR 9
14563	!]  NTWK
14564	
14565	!*MESSAGE 10
14566	!*T4:  SYNC REFRESH returned with failure condition
14567	
14568	!]ERROR 10
14569	!]  NTWK
14570	!]NO ERROR 10
14571	!]  NTWK
14572	
14573	END;
14574	GLOBAL ROUTINE TST50: NOVALUE =
14575	!++   ------------ REFRESH TEST - IS MEM GETTING REFRESHED ---------
14576	! TEST DESCRIPTION:  This test  verifies that the binary counters on
14577	!	MMC9 are sequencing the refresh address through the range of
14578	!	of addresses properly.
14579	!
14580	! TEST ASSUMPTIONS:  Memory will go away within 45 seconds.
14581	!
14582	! TEST PROCEDURE:  Write '777123456000' to memory locations
14583	!			XXXXX XXXXXXX XXXXXXX
14584	!			17.21 22...28 29...35
14585	!			BOARD --ROW-- --COL--
14586	!			00000 1111111 0000000  (0037600)
14587	!			00000 1111110 0000001  (0077401)
14588	!			00000 1111101 0000010  (0137202)
14589	!			 ...    ...     ...
14590	!			00000 1100000 0011111  (1770037)
14591	!			00000 1011111 0100000  (0027640)
14592	!			00000 1011110 0100001  (0067441)
14593	!			 ...    ...     ...
14594	!			00000 1000000 0111111  (0020077)
14595	!
14596	!		   Also write to mem locations: (if the memory is out there)
14597	!			00000 (BOARD SEL) 00000000000000 (ADDR)
14598	!			00001 (BOARD SEL) 00000000000000 (ADDR)
14599	!			 ...		     ........
14600	!			11111 (BOARD SEL) 00000000000000 (ADDR)
14601	!
14602	!		   Wait 45 seconds - if any of the addresses
14603	!			did not get refreshed they should
14604	!			contain garbage now
14605	!		   Read data back and verify it
14606	!
14607	! POSSIBLE ERRORS:  Binary counters on MMC9 which sequence the refresh
14608	!			address
14609	!		    Address decode logic on MMC8 for board address and
14610	!			word group address
14611	!		    Address decode logic on MMC3 for row/col address
14612	!
14613	!--
14614	
14615	BEGIN
14616	
14617	LOCAL
14618		ERR_NUM;
14619	
14620	OWN
14621		ADDR_VECT: VECTOR[96]
14622		INITIAL(%B'11111110000000',%B'11111100000001',
14623			%B'11111010000010',%B'11111000000011',
14624			%B'11110110000100',%B'11110100000101',
14625			%B'11110010000110',%B'11110000000111',
14626			%B'11101110001000',%B'11101100001001',
14627			%B'11101010001010',%B'11101000001011',
14628			%B'11100110001100',%B'11100100001101',
14629			%B'11100010001110',%B'11100000001111',
14630			%B'11011110010000',%B'11011100010001',
14631			%B'11011010010010',%B'11011000010011',
14632			%B'11010110010100',%B'11010100010101',
14633			%B'11010010010110',%B'11010000010111',
14634			%B'11001110011000',%B'11001100011001',
14635			%B'11001010011010',%B'11001000011011',
14636			%B'11000110011100',%B'11000100011101',
14637			%B'11000010011110',%B'11000000011111',
14638			%B'10111110100000',%B'10111100100001',
14639			%B'10111010100010',%B'10111000100011',
14640			%B'10110110100100',%B'10110100100101',
14641			%B'10110010100110',%B'10110000100111',
14642			%B'10101110101000',%B'10101100101001',
14643			%B'10101010101010',%B'10101000101011',
14644			%B'10100110101100',%B'10100100101101',
14645			%B'10100010101110',%B'10100000101111',
14646			%B'10011110110000',%B'10011100110001',
14647			%B'10011010110010',%B'10011000110011',
14648			%B'10010110110100',%B'10010100110101',
14649			%B'10010010110110',%B'10010000110111',
14650			%B'10001110111000',%B'10001100111001',
14651			%B'10001010111010',%B'10001000111011',
14652			%B'10000110111100',%B'10000100111101',
14653			%B'10000010111110',%B'10000000111111',
14654	
14655			%B'0000000000000000000',%B'0000100000000000000',
14656			%B'0001000000000000000',%B'0001100000000000000',
14657			%B'0010000000000000000',%B'0010100000000000000',
14658			%B'0011000000000000000',%B'0011100000000000000',
14659			%B'0100000000000000000',%B'0100100000000000000',
14660			%B'0101000000000000000',%B'0101100000000000000',
14661			%B'0110000000000000000',%B'0110100000000000000',
14662			%B'0111000000000000000',%B'0111100000000000000',
14663			%B'1000000000000000000',%B'1000100000000000000',
14664			%B'1001000000000000000',%B'1001100000000000000',
14665			%B'1010000000000000000',%B'1010100000000000000',
14666			%B'1011000000000000000',%B'1011100000000000000',
14667			%B'1100000000000000000',%B'1100100000000000000',
14668			%B'1101000000000000000',%B'1101100000000000000',
14669			%B'1110000000000000000',%B'1110100000000000000',
14670			%B'1111000000000000000',%B'1111100000000000000'),
14671		MEM_MAP: VECTOR[96],
14672		MESSV: VECTOR[2],
14673		READV: VECTOR[96];
14674	
14675	LITERAL
14676		TEST_DATA = %O'777';
14677	
14678	LABEL
14679		BLOCK1;
14680	
14681	
14682	DO (0) WHILE
14683		BEGIN
14684		MR();					! Master Reset
14685		ERR_NUM = 0;				! Init number of errors gotten
14686		INCR ADDR FROM 0 TO 95 DO		! Write data to mem but only if
14687		    BEGIN				!   the memory actually exists
14688		    IF .ADDR_VECT[.ADDR] LSS .MAX_MEM
14689			THEN BEGIN
14690			     MEM_MAP[.ADDR] = 1;	! Set flag for mem exists
14691			     MEM_DEPOSIT(.ADDR_VECT[.ADDR],TEST_DATA);
14692			     END
14693			ELSE MEM_MAP[.ADDR] = 0;	! Set flag indication NONXM
14694		    READV[.ADDR] = 0;			! Init data read back
14695		    END;
14696	
14697		SEND_NUL();				! Send out the last deposit
14698		WAIT(%O'30000000');			! Wait 30..45 seconds
14699	
14700		INCR ADDR FROM 0 TO 95 DO		! Read back each location
14701		    IF .MEM_MAP[.ADDR] EQL 1		!  - Put data into 'READV'
14702			THEN READV[.ADDR] = MEM_EXAMINE(.ADDR_VECT[.ADDR]);
14703	
14704		INCR ADDR FROM 0 TO 95 DO		! Verify the data read back
14705		    BEGIN
14706		    IF .ERR_NUM GTR 4			! Only print out 5 errors max
14707			THEN EXITLOOP;
14708		    MESSV[0] = TEST_DATA;
14709		    MESSV[1] = .ADDR_VECT[.ADDR];
14710		    IF (.READV[.ADDR] NEQ TEST_DATA) AND (.MEM_MAP[.ADDR] EQL 1)
14711			THEN BEGIN
14712			     ERR_NUM = .ERR_NUM + 1;
14713			     ERRCAS(1,1,TEST_DATA,.READV[.ADDR],12,MESSV);
14714			     END
14715			ELSE NOERR(1);
14716		    END;
14717		0				! To eliminate INFO compiler message
14718		END;
14719	
14720	!*MESSAGE 1
14721	!*STIMULUS
14722	!*	Write '\U0' to 64 locations
14723	!*	Wait 30-45 seconds
14724	!*	Refresh should be occurring and refreshing each location
14725	!*	    just written to
14726	!*RESPONSE
14727	!*	Data returned incorrect - Location '\U1' not refreshed?
14728	
14729	!]ERROR 1
14730	!] A3 B3 C3 D3 B8 C8 D8 E8 F8 G8 H8 C9 BB  NTWK
14731	!]NO ERROR 1
14732	!]  NTWK
14733	
14734	END;
14735	GLOBAL ROUTINE TST51: NOVALUE =
14736	
14737	!++   ------------ ECC: VERIFICATION OF CHECK BITS --------------
14738	! TEST DESCRIPTION:  This routine verifies some of the ECC logic.
14739	!	In particular it verifies that there are no stuck pins on
14740	!	the parity generators which calculate the check bits sent
14741	!	to memory and recalculate  them  when they come back.  In
14742	!	this test a read error will occur if there are any S1 pins
14743	!	on the inputs to the  parity  generators.  If there is no
14744	!	fault no ECC error will occur.
14745	!
14746	! TEST ASSUMPTIONS:  This test is only done if no errors have
14747	!	occurred so far on Tests 1..50.
14748	!
14749	! TEST PROCEDURE:  Master Reset (Force bits will be set to 0's)
14750	!		   Write 1's to memory
14751	!		   Read data back
14752	!		   Did an ECC error occur?
14753	!
14754	! POSSIBLE ERRORS:  Faulty parity generators on MMC4
14755	!		    
14756	!
14757	!--
14758	
14759	BEGIN
14760	
14761	LOCAL
14762		MEM_CORR;
14763	
14764	OWN
14765		MEM_DATA: VECTOR[2],
14766		MEM_STAT_VECT: BTTVECTOR[36];
14767	
14768	BIND
14769		MEM_DAT = MEM_DATA,
14770		MEM_STAT = MEM_STAT_VECT;
14771	
14772	LABEL
14773		BLOCK1;
14774	
14775	IF RUN_TEST(51) THEN RETURN;		! Run this test? Return if no
14776	
14777	NOERR_51 = 0;				! No errors have occurred yet
14778	RPT_ERR_FLAG = 0;			! Don't report unexpected error
14779	
14780	DO (0) WHILE
14781	BLOCK1:	BEGIN
14782		MR();				! Master Reset
14783		MEM_DEPOSIT(0,-1);		! Write 1's to mem loc 0
14784		EM(0);				! Read data back
14785		MEM_STAT = IO_EXAMINE(MSR);	! Read MSR
14786		IF .MEM_STAT LSS 0		! Did an ECC error occur?
14787		    THEN BEGIN
14788			 NOERR_51=1;		! Yes - set error flag and go
14789			 ERRS(1,1,MEM_STAT);	!   report the error
14790			 END;
14791		IF LOOP_CHK(1) THEN LEAVE BLOCK1 WITH 1;
14792		0				! To eliminate INFO compiler message
14793		END;
14794	
14795	!*MESSAGE 1
14796	!*STIMULUS
14797	!*	MR		Master Reset
14798	!*	LA 0,DM -1	Write 1's to mem loc 0
14799	!*	EM 0		Read data back (should not cause ECC error)
14800	!*RESPONSE
14801	!*	ECC error occurred / 'MMC5 ERR HOLD' bit 00 set (Mem Stat Reg: \U0 )
14802	
14803	!]ERROR 1
14804	!] A4 B4 C4 D4 E4 F4 G4 K4 L4 M4  NTWK
14805	!]NO ERROR 1
14806	!]  NTWK
14807	
14808	END;
14809	ROUTINE INIT: NOVALUE =
14810	
14811	!++
14812	! FUNCTIONAL DESCRIPTION:  This routine does a bus RESET.
14813	!
14814	! FORMAL PARAMETERS:  None.
14815	!
14816	! IMPLICIT INPUTS:  None.
14817	!
14818	! IMPLICIT OUTPUTS:  None.
14819	!
14820	! ROUTINE VALUE:  Novalue.
14821	!
14822	! COMPLETION CODES:  None.
14823	!
14824	! SIDE EFFECTS:  None.
14825	!
14826	!--
14827	
14828	BEGIN
14829	
14830	WRT100(RESET);				!Assert RESET
14831	WRT100(0);				!Clear RESET
14832	SEND_NUL();
14833	
14834	END;
14835	GLOBAL ROUTINE TEST_INIT: NOVALUE =
14836	
14837	!++
14838	! FUNCTIONAL DESCRIPTION:  This routine is executed only once - normally
14839	!	just  before  Test 1 is executed.   However if 'LOOP ON TEST' is
14840	!	specified the routine is done before whatever test is being
14841	!	looped on.
14842	!
14843	! FORMAL PARAMETERS:  none.
14844	!
14845	! IMPLICIT INPUTS:  none.
14846	!
14847	! IMPLICIT OUTPUTS:  none.
14848	!
14849	! ROUTINE VALUE:  novalue.
14850	!
14851	! COMPLETION CODES:  none.
14852	!
14853	! SIDE EFFECTS:  none.
14854	!
14855	!--
14856	
14857	BEGIN
14858	
14859	MR();					! Do a MASTER RESET
14860	PAR_ENABLE;				! Enable parity checking by 8080
14861	
14862	INCR I FROM 0 TO 14 DO			! Initialize run error vector to
14863		RUN_ERR_VECT[.I] = 0;		!   zeros (run all tests)
14864	
14865	END;
14866	GLOBAL ROUTINE RUN_TEST(TEST) =
14867	
14868	!++
14869	! FUNCTIONAL DESCRIPTION:   This routine  is  executed at the beginning
14870	!	of every test.  It determines if the  test  should be run based
14871	!	whether prior fatal errors have occurred or not. 'LOOP ON TEST'
14872	!	being set will reset  the error vector ('RUN_ERR_VECT') so that
14873	!	looping  can  occur  regardless  of  what  types of errors have
14874	!	occurred.
14875	!
14876	! FORMAL PARAMETERS:  Test number.
14877	!
14878	! IMPLICIT INPUTS:  None.
14879	!
14880	! IMPLICIT OUTPUTS:  None.
14881	!
14882	! ROUTINE VALUE:  0 - Run the test
14883	!		  1 - Do not run the test.
14884	!
14885	! COMPLETION CODES:  None.
14886	!
14887	! SIDE EFFECTS:  NONE.
14888	!
14889	!--
14890	
14891	BEGIN
14892	
14893	STRUCTURE
14894		BLVECTOR[I,J;N,M] = [N*M]	! A real 55 x 15 array like FORTRAN
14895		(BLVECTOR+I*15+J);
14896	
14897	! ERR_MAP contains a mask of RUN_ERR_VECT  for  each test.  When a test
14898	!  is started, the contents of ERR_MAP is compared with the contents of
14899	!  RUN_ERR_VECT.  If any flags  are  set  in  both for the same type of
14900	!  error the test is not run.
14901	
14902	OWN
14903		ERR_MAP: BLVECTOR[55,15]
14904		    INITIAL(0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST1
14905			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST2
14906			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST3
14907			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST4
14908			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST5
14909			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST6
14910			    1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,	!TST7
14911			    1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,	!TST8
14912			    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST9
14913			    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST10
14914			    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST11
14915			    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST12
14916			    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST13
14917			    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST14
14918			    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST15
14919			    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST16
14920			    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST17
14921			    0,1,0,0,1,1,0,0,1,0,0,0,0,0,0,	!TST18
14922			    1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,	!TST19
14923			    1,1,0,0,1,1,1,1,1,0,1,0,0,0,0,	!TST20
14924			    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST21
14925			    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST22
14926			    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST23
14927			    0,1,1,0,1,1,1,1,1,0,0,0,0,0,0,	!TST24
14928			    1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,	!TST25
14929			    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST26
14930			    1,1,0,0,1,1,1,1,1,1,0,0,0,0,0,	!TST27
14931			    1,1,0,0,1,1,1,1,1,0,1,0,0,0,0,	!TST28
14932			    1,1,0,0,1,1,1,1,1,0,0,0,0,0,0,	!TST29
14933			    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST30
14934			    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST31
14935			    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST32
14936			    1,1,0,0,1,1,1,1,1,1,0,1,0,0,0,	!TST33
14937			    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST34
14938			    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST35
14939			    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST36
14940			    1,1,0,0,1,1,1,1,1,0,1,1,0,0,0,	!TST37
14941			    1,1,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST38
14942			    0,1,1,0,1,0,0,0,1,0,0,0,0,0,0,	!TST39
14943			    1,0,0,0,0,0,1,1,1,0,0,0,0,0,0,	!TST40
14944			    0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,	!TST41
14945			    1,1,1,0,1,1,0,1,1,0,0,0,0,0,0,	!TST42
14946			    1,1,1,0,0,0,0,1,1,0,0,0,0,0,0,	!TST43
14947			    1,0,0,0,0,0,0,1,1,0,0,0,0,0,0,	!TST44
14948			    1,1,0,0,0,1,1,1,1,0,0,0,0,0,0,	!TST45
14949			    0,0,1,0,1,0,0,0,1,0,0,0,0,0,0,	!TST46
14950			    0,1,1,0,0,1,0,0,1,0,0,0,0,0,0,	!TST47
14951			    1,1,1,0,0,1,0,1,1,0,0,0,0,0,0,	!TST48
14952			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST49
14953			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST50
14954			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST51
14955			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST52
14956			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST53
14957			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,	!TST54
14958			    0,0,0,0,0,0,0,0,1,0,0,0,0,0,0);	!TST55
14959	!		    ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^
14960	!		    ! ! ! ! ! ! ! ! ! ! ! ! Unused
14961	!		    ! ! ! ! ! ! ! ! ! ! ! Bus xcvr
14962	!		    ! ! ! ! ! ! ! ! ! ! ECC single
14963	!		    ! ! ! ! ! ! ! ! ! ECC double
14964	!		    ! ! ! ! ! ! ! ! Test Abort
14965	!		    ! ! ! ! ! ! ! Mem write failed
14966	!		    ! ! ! ! ! ! Mem read failed
14967	!		    ! ! ! ! ! MSR write failed
14968	!		    ! ! ! ! MSR read failed
14969	!		    ! ! ! ?MRE IO would not occur
14970	!		    ! ! ?MRE mem would not occur
14971	!		    ! ?MRE IO occurred when shouldnt have
14972	!		    ?MRE mem occurred when shouldnt have
14973	
14974	IF .LPONTST EQL 1			! Are we looping on test?
14975		THEN BEGIN			!  if yes just zero RUN_ERR_VECT to
14976		     INCR I FROM 0 TO 14 DO	!    sure that we dont skip the test
14977			RUN_ERR_VECT[.I] = 0;	!    then return
14978			RETURN 0;
14979		     END;
14980	INCR I FROM 0 TO 14 DO			! If not looping on test determine if
14981		BEGIN				!   this test should be run
14982		IF .RUN_ERR_VECT[.I] * .ERR_MAP[.TEST,.I] NEQ 0
14983		    THEN RETURN 1;		! RETURN 1 to abort the test
14984		END;
14985	RETURN 0;				! RETURN 0 to run the test
14986	END;
14987	GLOBAL ROUTINE SPEC_DIALOGUE: NOVALUE =
14988	
14989	!++
14990	! FUNCTIONAL DESCRIPTION:  This routine inputs special data needed for
14991	!	MMC board testing, namely, the amount of memory which the KS10
14992	!	has.  It takes the  amount  of  memory and calculates a memory
14993	!	mapping (in global vector 'MMA_MAP') which indicates which MMA
14994	!	boards are in the machine.
14995	!
14996	! FORMAL PARAMETERS:  None.
14997	!
14998	! IMPLICIT INPUTS:  This routine will ask for the amount of memory - the
14999	!	program user will be expected to type it in.  This is handled by
15000	!	a call to routine 'MEMSIZE'.
15001	!
15002	! IMPLICIT OUTPUTS:  Global vector 'MMA_MAP' indicates which MMA boards
15003	!	are in the machine.
15004	!
15005	! ROUTINE VALUE:  Novalue.
15006	!
15007	! COMPLETION CODES:  None.
15008	!
15009	! SIDE EFFECTS:  None.
15010	!
15011	!--
15012	
15013	BEGIN
15014	
15015	LOCAL
15016		MEM;
15017	
15018	MEM = MEMSIZE()/64;			! Find out how much memory is
15019	INCR I FROM 0 TO .MEM-1 DO		!   available
15020		BEGIN				! Init MMA_MAP to 1 for each
15021		MMA_MAP[.I] = 1			!   64K chunk of memory
15022		END;
15023	MAX_MEM = .MEM * 1024 * 64 - 1;		! Calculate maximum amount of memory
15024	
15025	END;
15026	GLOBAL ROUTINE SPEC_PRT: NOVALUE =
15027	
15028	!++
15029	! FUNCTIONAL DESCRIPTION:  This routine prints out any special features
15030	!	which may or may not be activated. The MMC testing does not use
15031	!	any additional features so this routine does not do anything at
15032	!	the present time.
15033	!
15034	! FORMAL PARAMETERS:  None.
15035	!
15036	! IMPLICIT INPUTS:  None.
15037	!
15038	! IMPLICIT OUTPUTS:  None.
15039	!
15040	! ROUTINE VALUE:  Novalue.
15041	!
15042	! COMPLETION CODES:  None.
15043	!
15044	! SIDE EFFECTS:  None.
15045	!
15046	!--
15047	
15048	BEGIN
15049	0
15050	END;
15051	
15052	
15053	GLOBAL ROUTINE SPEC_ASK: NOVALUE =
15054	
15055	!++
15056	! FUNCTIONAL DESCRIPTION:  This routine asks for any special features
15057	!	which may or may not be desired. The MMC testing does not use
15058	!	any additional  features so this routine does not do anything
15059	!	at the present time.
15060	!
15061	! FORMAL PARAMETERS:  None.
15062	!
15063	! IMPLICIT INPUTS:  None.
15064	!
15065	! IMPLICIT OUTPUTS:  None.
15066	!
15067	! ROUTINE VALUE:  Novalue.
15068	!
15069	! COMPLETION CODES:  None.
15070	!
15071	! SIDE EFFECTS:  None.
15072	!
15073	!--
15074	
15075	BEGIN
15076	0
15077	END;
15078	ROUTINE WRITE_STATUS (DATA): NOVALUE =
15079	
15080	!++
15081	! FUNCTIONAL DESCRIPTION:  This routine writes status to MEM STAT REG.
15082	!	It is used when the T&R clocks are being single stepped in
15083	!	maintenance mode.
15084	!
15085	! FORMAL PARAMETERS:  .DATA - The 36 bits of data to be written to
15086	!	the MEMORY STATUS REGISTER.
15087	!
15088	! IMPLICIT INPUTS:  None.
15089	!
15090	! IMPLICIT OUTPUTS:  None.
15091	!
15092	! ROUTINE VALUE:  Novalue.
15093	!
15094	! COMPLETION CODES:  None.
15095	!
15096	! SIDE EFFECTS:  None.
15097	!
15098	!--
15099	
15100	BEGIN
15101	
15102	LITERAL
15103		WRITE_MSR = %O'500000100000';
15104	
15105	WRITE_COMADR(WRITE_MSR);		! Write com/adr to 8080 regs
15106	WRITE_DATA(.DATA);			! Write data to 8080 regs
15107	WRITE_CONTROL();			! Write control data to 8080 regs
15108	
15109	END;
15110	ROUTINE READ_BUS =
15111	
15112	!++
15113	! FUNCTIONAL DESCRIPTION:  This routine reads data from the bus.  It looks
15114	!	at the 8080 registers which contain the data that should be on the
15115	!	bus or which has just been latched into the bus tranceivers on the
15116	!	CSL board.
15117	!
15118	! FORMAL PARAMETERS:  None.
15119	!
15120	! IMPLICIT INPUTS:  None.
15121	!
15122	! IMPLICIT OUTPUTS:  None.
15123	!
15124	! ROUTINE VALUE:  36 bits of data - What was on the bus as read from
15125	!	8080 I/O Registers 0,1,2,3,103.
15126	!
15127	! COMPLETION CODES:  None.
15128	!
15129	! SIDE EFFECTS:  None.
15130	!
15131	!--
15132	
15133	BEGIN
15134	
15135	LOCAL
15136		TEMP,
15137		BUS_DATA;
15138	
15139	TEMP=RD_0;				! Read 8080 register 0
15140	BUS_DATA<0,8> = .TEMP<0,8>;		! Copy 8 bits to result
15141	TEMP=RD_1;				! Read 8080 register 1
15142	BUS_DATA<8,8> = .TEMP<0,8>;		! Copy 8 bits to result
15143	TEMP=RD_2;				! Read 8080 register 2
15144	BUS_DATA<16,8> = .TEMP<0,8>;		! Copy 8 bits to result
15145	TEMP=RD_3;				! Read 8080 register 3
15146	BUS_DATA<24,8> = .TEMP<0,8>;		! Copy 8 bits to result
15147	TEMP=RD_103;				! Read 8080 register 103
15148	BUS_DATA<32,4> = .TEMP<0,4>;		! Copy 4 bits to result
15149	
15150	RETURN .BUS_DATA;
15151	
15152	END;
15153	ROUTINE HANG_MEM: NOVALUE =
15154	
15155	!++
15156	! FUNCTIONAL DESCRIPTION:  This routine causes a MEM REFRESH ERROR.  It
15157	!	requests memory but for COM/ADR bits it specifies write access.
15158	!	'COM ADR CYCLE' is  set in 8080 REG 115 but 'DATA CYCLE' is not
15159	!	set in 8080 REG 114 so the  memory  controller hangs after half
15160	!	the cycle is complete.
15161	!
15162	! FORMAL PARAMETERS:  None.
15163	!
15164	! IMPLICIT INPUTS:  None.
15165	!
15166	! IMPLICIT OUTPUTS:  None.
15167	!
15168	! ROUTINE VALUE:  Novalue.
15169	!
15170	! COMPLETION CODES:  None.
15171	!
15172	! SIDE EFFECTS:  MMC board is hung.  A refresh error has occurred.
15173	!
15174	!--
15175	
15176	BEGIN
15177	
15178	WRITE_COMADR(%O'100000000000');		! Specify a write mem of location 0
15179	WRT115(COM_ADR);			! Specify com/adr data out
15180	WRT114(0);				! Do not specify data cycle out
15181	WRT210(MEM+BUS_REQ+XMIT_ADR+XMIT_DATA);	! Do it - half of it will be done and
15182						!   MMC will hang because it doesnt
15183						!   ever get the other half.
15184	SEND_NUL();				! Just make sure that this line gets
15185						!   sent off to the 8080.
15186	END;
15187	ROUTINE WRITE_COMADR(DATA): NOVALUE =
15188	
15189	!++
15190	! FUNCTIONAL DESCRIPTION:  This routine writes data to 8080 I/O registers
15191	!	103..113 for the COM/ADR portion to a memory access.
15192	!
15193	! FORMAL PARAMETERS:  .DATA - The 36 bits of data to be written to
15194	!	8080 REGISTERS 102,104,106,110,112 for a COM/ADR cycle.
15195	!
15196	! IMPLICIT INPUTS:  None.
15197	!
15198	! IMPLICIT OUTPUTS:  None.
15199	!
15200	! ROUTINE VALUE:  Novalue.
15201	!
15202	! COMPLETION CODES:  None.
15203	!
15204	! SIDE EFFECTS:  None.
15205	!
15206	!--
15207	
15208	BEGIN
15209	
15210	WRT103(.DATA<0,8>);			! 1st 8 bits
15211	WRT105(.DATA<8,8>);			! 2nd 8 bits
15212	WRT107(.DATA<16,8>);			! 3rd 8 bits
15213	WRT111(.DATA<24,8>);			! 4th 8 bits
15214	WRT113(.DATA<32,4>);			! last 4 bits
15215	
15216	END;
15217	ROUTINE WRITE_DATA(DATA): NOVALUE =
15218	
15219	!++
15220	! FUNCTIONAL DESCRIPTION:  This  routine  writes  data to 8080 I/O
15221	!	registers 102..112 for the data portion of a memory access.
15222	!
15223	! FORMAL PARAMETERS:  .DATA - The 36 bits of data to be written to
15224	!	8080 registers 103,105,107,111,113 for a data cycle.
15225	!
15226	! IMPLICIT INPUTS:  None.
15227	!
15228	! IMPLICIT OUTPUTS:  None.
15229	!
15230	! ROUTINE VALUE:  Novalue.
15231	!
15232	! COMPLETION CODES:  None.
15233	!
15234	! SIDE EFFECTS:  None.
15235	!
15236	!--
15237	
15238	BEGIN
15239	
15240	WRT102(.DATA<0,8>);			! 1st 8 bits
15241	WRT104(.DATA<8,8>);			! 2nd 8 bits
15242	WRT106(.DATA<16,8>);			! 3rd 8 bits
15243	WRT110(.DATA<24,8>);			! 4th 8 bits
15244	WRT112(.DATA<32,4>);			! last 4 bits
15245	
15246	END;
15247	ROUTINE WRITE_CONTROL: NOVALUE =
15248	
15249	!++
15250	! FUNCTIONAL DESCRIPTION:  This routine writes data to 8080 I/O registers
15251	!	114,115,210 for the cycle control bits portion to a memory access.
15252	!
15253	! FORMAL PARAMETERS:  None.
15254	!
15255	! IMPLICIT INPUTS:  None.
15256	!
15257	! IMPLICIT OUTPUTS:  None.
15258	!
15259	! ROUTINE VALUE:  Novalue.
15260	!
15261	! COMPLETION CODES:  None.
15262	!
15263	! SIDE EFFECTS:  None.
15264	!
15265	!--
15266	
15267	BEGIN
15268	
15269	WRT115(COM_ADR);			! Set up COM/ADR part
15270	WRT114(DATA_CYCLE);			! Set up DATA part
15271	WRT210(MEM + BUS_REQ + XMIT_DATA	! Do it (or at least get ready to if
15272	     + XMIT_ADR);			!   the clock is in maintenance mode)
15273	
15274	END;
15275	ROUTINE WRITE_CONTROL1: NOVALUE =
15276	
15277	!++
15278	! FUNCTIONAL DESCRIPTION:  This routine writes data to 8080 I/O registers
15279	!	115,210 for the cycle control bits portion of a memory read access.
15280	!
15281	! FORMAL PARAMETERS:  None.
15282	!
15283	! IMPLICIT INPUTS:  None.
15284	!
15285	! IMPLICIT OUTPUTS:  None.
15286	!
15287	! ROUTINE VALUE:  Novalue.
15288	!
15289	! COMPLETION CODES:  None.
15290	!
15291	! SIDE EFFECTS:  None.
15292	!
15293	!--
15294	
15295	BEGIN
15296	
15297	WRT115(COM_ADR);			! Set up COM/ADR part
15298	WRT210(MEM + BUS_REQ + XMIT_ADR		! Do it (or at least get ready to if
15299	   + LATCH_DATA + CLOSE_LATCH);		!    clock is in maintenance mode)
15300	
15301	END;
15302	ROUTINE SYNC_REFRESH(HOW,WHEN) =
15303	
15304	!++
15305	! FUNCTIONAL DESCRIPTION:  This routine syncs the  refresh  binary  counter
15306	!	on 'MMC7' to a particular point  depending  on the arguments given.
15307	!	It may be before refresh error is about to occur or it may be after
15308	!	refresh error has just  occurred.  The exactness of the positioning
15309	!	may also be specified.  Some  tests just want to get refresh out of
15310	!	the way so that a memory cycle  will  not  be  delayed by a refresh
15311	!	cycle. Other tests are testing the timing of a refresh cycle so the
15312	!	syncing of the binary counter must be exact.
15313	!
15314	! FORMAL PARAMETERS:  None.
15315	!
15316	! IMPLICIT INPUTS:  How & when the syncing is to occur:
15317	!	How - 0 Exactly
15318	!	      1 Approximate only
15319	!	When - 0 - Before the refresh cycle is to occur
15320	!			(if exact then 3 T clocks before)
15321	!	       1 - After the refresh cycle has just occurred
15322	!			(if exact then exactly after complete)
15323	!
15324	! IMPLICIT OUTPUTS:  None.
15325	!
15326	! ROUTINE VALUE:  0 - Successful syncing of refresh has occurred
15327	!		  1 - Refresh syncing has failed - due to the
15328	!			non-appearance of a MEM REFRESH ERROR
15329	!
15330	! COMPLETION CODES:  Same as routine value.
15331	!
15332	! SIDE EFFECTS:  Causes a refresh error which in effect hangs the
15333	!	the memory controller until the error  is  cleared  via a
15334	!	write  status  or a BUS RESET (or MASTER RESET).  When in
15335	!	this state  and read or write to any memory location will
15336	!	result in a ?NXM since the timer on CSL will time out.
15337	!
15338	!--
15339	
15340	BEGIN
15341	
15342	LITERAL
15343		WRITE_MSR = %O'500000100000',	! Write to MSR
15344		CLEAR_MRE = %O'100000000000',	! Clear ?MRE
15345		HANG = %O'300000000000';	! Com/adr cycle to hang MMC
15346	
15347	OWN
15348		TICK1,				! Clock tick counter
15349		TICK2,				! Clock tick counter
15350		REG,				! Register contents
15351		REG1,				! Register contents
15352		REGV: VECTOR[2];		! Error message output vector
15353	
15354	LOCAL
15355		TEMP,
15356		TRY;				! Number of 132 ticks done to try
15357						!   to generate a ?MRE
15358	LABEL
15359		BLOCK1;
15360	
15361	DO (0)	WHILE
15362	BLOCK1:	BEGIN
15363		RPT_ERR_FLAG = 0;		! Don't report unexpected errors
15364	
15365	! Tick the clock 132 ticks at a  time  until a ?MRE occurs. This will
15366	!  get us within 132 ticks of a refresh error so we very quickly home
15367	!  in on the section of the refresh cycle we want.
15368	! The ?MRE  should  occur  within 8*132 ticks.  The test tries 20*132
15369	!  ticks at a time up to 4 times. If a ?MRE has still failed to occur
15370	!  then this routine fails and returns with an error condition.
15371	
15372		TICK1 = 0;
15373		TRY = 0;
15374		DO  BEGIN
15375		    IF .TICK1 EQL 0
15376			THEN BEGIN
15377			     MR();		! Master RESET
15378			     DM(0,0);		! Write 0's to mem loc 0 (to init 8080
15379			     MR();		!   regs to 0's fast) then sync clocks
15380			     SEND_NUL();
15381			     SYNC_CLK();	! Put clocks into maintenance mode
15382			     HANG_MEM();	! Start a mem cycle now that will cause
15383			     END;		!   MMC to hang and ?MRE to occur.
15384		    TICK(132);			! Tick 132 times
15385		    REG1 = RD_101;		! See if a ?MRE has occurred yet
15386		    REG = .REG1 AND MMC_REF_ERR;
15387		    TICK1 = .TICK1 + 132;	! Keep track of number of ticks done
15388		    IF .TICK1 EQL 20*132	! Did we give it 2640 ticks?
15389			THEN BEGIN		! If so then try again
15390			     TRY = .TRY + 1;
15391			     IF .TRY NEQ 4	! But if already 4th try don't reset
15392				THEN TICK1 = 0;	!   TICK1 - we couldn't get a ?MRE.
15393			     END;
15394		    END
15395		WHILE (.REG EQL 0 AND .TRY LSS 4);
15396	
15397		IF .DEBUG EQL 1			! Are we writing out debug type
15398		    THEN BEGIN			!   output?  If so write out number
15399			 REGV[0] = .REG1;	!   of ticks it took to get ?MRE and
15400			 REGV[1] = .TICK1;	!   the contents of 8080 Reg 101.
15401			 ERRS(1,1,REGV);
15402			 END;
15403	
15404		IF (.TICK1 EQL 20*132) OR (.REG EQL 0)! Did we fail to get ?MRE at all?
15405		    THEN RETURN 1;		! If so - return with 1 (error)
15406	
15407		IF .HOW EQL 1			! Do we want approximate positioning?
15408		    THEN BEGIN			! If so just give 16 more ticks to
15409			 TICK(16);		!   make sure we are past the ?MRE
15410			 RETURN 0;		!   and then return successfully
15411			 END;
15412	
15413	! Now we have to home in on the refresh error more exactly.
15414	
15415		TICK(60);			! Give 60 ticks
15416	
15417		IF .DEBUG EQL 1			! Are we writing out debug type
15418		    THEN BEGIN			!   output?  If so write out the
15419			 REG = RD_101;		!   the contents of 8080 Reg 101.
15420			 ERRS(2,2,REG);
15421			 END;
15422	
15423		WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE and give another
15424		WRITE_DATA(CLEAR_MRE);		!   60 ticks
15425		WRITE_CONTROL();
15426		TICK(60);
15427	
15428		IF .DEBUG EQL 1			! Are we writing out debug type
15429		    THEN BEGIN			!   output?  If so write out the
15430			 REG = RD_101;		!   the contents of 8080 Reg 101.
15431			 ERRS(3,3,REG);
15432			 END;
15433	
15434		HANG_MEM();			! Now hang MMC again to cause another
15435						!   refresh error
15436		REG = TICK2 = 0;
15437		DO  BEGIN			! This time give the ticks in blocks
15438		    TICK(200);			!   of 200 so as to home in on it more
15439		    REG1 = RD_101;		!   quickly and since we already have
15440		    REG = .REG1 AND MMC_REF_ERR;!   a good idea of when it will occur
15441		    TICK2 = .TICK2 + 200;	! We should not quite reach a ?MRE
15442		    END
15443		WHILE (.REG EQL 0 AND .TICK2 LSS 600);
15444	
15445		IF .DEBUG EQL 1			! Are we writing out debug type
15446		    THEN BEGIN			!   output?  If so write out number
15447			 REGV[0] = .REG1;	!   of ticks it took to get ?MRE and
15448			 REGV[1] = .TICK2;	!   the contents of 8080 Reg 101.
15449			 ERRS(4,4,REGV);
15450			 END;
15451	
15452		IF .REG EQL 1			! Did a ?MRE occur prematurely?
15453		    THEN RETURN 1;		! If so - return with a 1 (error)
15454	
15455	! Now home in on the ?MRE until it occurs by ticking 4 ticks at a time.
15456	
15457		REG = 0;
15458		DO  BEGIN
15459		    TICK(4);			! Tick 4 times
15460		    REG1 = RD_101;		! Find out if ?MRE occurred yet
15461		    REG = .REG1 AND MMC_REF_ERR;
15462		    TICK2 = .TICK2 + 4;
15463		    END
15464		WHILE (.REG EQL 0 AND .TICK2 LSS 2000);
15465	
15466		IF .DEBUG EQL 1			! Are we writing out debug type
15467		    THEN BEGIN			!   output?  If so write out number
15468			 REGV[0] = .REG1;	!   of ticks it took to get ?MRE and
15469			 REGV[1] = .TICK2;	!   the contents of 8080 Reg 101.
15470			 ERRS(4,4,REGV);
15471			 END;
15472	
15473		IF .TICK2 EQL 2000		! Did a ?MRE fail to occur?
15474		    THEN RETURN 1;		! If so - return with 1 (error)
15475	
15476	! At this point we know  exactly where we are on the refresh cycle.  We are
15477	!  at the occurrence of a ?MRE which is 200 T clocks from the next ?MRE and
15478	!  100 T clocks from the next REFRESH REQUEST signal.   Depending  on value
15479	!  of WHEN we may be done.
15480	
15481		IF .WHEN EQL 1			! Did we want to be positioned just
15482		    THEN RETURN 0;		!   after the ?MRE - if so return
15483	
15484	! Now we know exactly when the next ?MRE should occur (in 800 ticks or
15485	!  200 T clocks) so we just  clear  the current ?MRE and write data to
15486	!  8080 regs to cause the  next ?MRE.   Then  just  tick  forward  the
15487	!  remaining number of ticks (less 12 or 3 T clocks).
15488	
15489		TICK(60);			! Get a little room after last ?MRE
15490		WRITE_COMADR(WRITE_MSR);	! Clear the ?MRE
15491		WRITE_DATA(CLEAR_MRE);
15492		WRITE_CONTROL();
15493		TICK(60);			! Give the clear time to work
15494	
15495		IF .DEBUG EQL 1			! Are we writing out debug type
15496		    THEN BEGIN			!   output?  If so write out the
15497			 REG = RD_101;		!   the contents of 8080 Reg 101.
15498			 ERRS(5,5,REG);
15499			 END;
15500	
15501		HANG_MEM();			! Now hang the memory controller
15502		TICK(200);			! And give enough ticks to almost
15503		TICK(200);			!   get to the next ?MRE
15504		TICK(200);
15505		TEMP = .MRE_TICKS - 736;
15506		TICK(.TEMP);
15507	
15508		IF .DEBUG EQL 1			! Are we writing out debug type
15509		    THEN BEGIN			!   output?  If so write out the
15510			 REG = RD_101;		!   the contents of 8080 Reg 101.
15511			 ERRS(6,6,REG);
15512			 END;
15513	
15514		RETURN 0;			! All done - return
15515		END;
15516	0					! To eliminate INFO compiler message
15517	END;
15518	END
15519	ELUDOM

AC0				 623+#	 627+#	 631+#	 635+#	 639+#	 643+#	 647+#	 651+#	 655+#	 659+#	 663+#	 667+#
				 671+#	 675+#	 679+#	 683+#	 687+#	 691+#	 695+#	 699+#	 703+#	 707+#	 711+#	 758+#
ADDR				 456+	 457+	 458+	 459+	 634+	 635+	5208#	5230	5411#	5433	6234	14686
				14688	14690	14691	14693	14694	14700	14701	14702	14704	14709	14710	14713
ADDR1				5722	5767#	5768	5770	5772	5777
ADDR2				5723	5768#	5770	5773	5778
ADDR3				5724	5769#	5774	5779
ADDR4				5725	5770#	5775	5780
ADDR_VECT			14621	14688	14691	14702	14709
ADPT1_PE			1543+#
ADPT2_PE			1504+#
ADPT3_PE			1509+#
ADPT4_PE			1542+#
ADR				6259	6261	6268	6277	6282	6284	6423	6425	6444	6450	6452	6456
				6462	6464	6606	6608	6622	6624	6645	7306	7322
ADR14_21			7287#	7356	7357
ADR22_29			7288#	7368	7369
ADR30_35			7289#	7380	7381
ADR_VECT			13150	13210	13213
AFTER				12330#	12357	12555#	12583	12793#	12819	13145#	13192	14044#	14084	14086
AHOW				14446	14451	14456
APPROX				12331#	12357	12554#	12583	12792#	12819	13144#	13192
AWHEN				14448	14452#	14456
B2				12965	12982	13018	13029
BAD_DATA			1408+#
BEGIN_XLIST			 454+#
BIT4				9175#	9176	9180	9181	9182
BIT8646				 399#	 400	1619	3521	11512
BITBLOCK			5730#	5731	5736	5737	5738	5739
BITS14_21			7658#	7959
BITS22_29			7659#	7973
BITS30_35			7660#	7987
BIT_20				5070#	5115	5129
BIT_21				5071#	5101	5129
BIT_MOS				3510#	3511	3522	11506#	11507	11513
BIT_VECT			3507#	3508	3523	3524	3525	11503#	11504	11514	11515	11516
BLISS36				   4
BLOCK1				1631	1640	1661	1679	1691	1998	2006	2014	2020	2026	2032	2038
				2044	2050	2185	2194	2229	2232	2245	2253	2261	2546	2555	2590
				2593	2607	2614	2621	2628	2968	2982	2994	2997	3010	3018	3026
				3550	3569	3599	3620	3638	3656	3673	3689	3696	4100	4212	4220
				4236	4246	4254	4435	4450	4464	4472	4480	4675	4687	4702	4743
				5088	5096	5111	5125	5139	5214	5228	5247	5417	5431	5450	5751
				5759	5836	5843	5850	5857	5865	5872	5879	5886	5893	5900	5907
				5914	5921	5928	6246	6263	6284	6416	6427	6452	6464	6599	6610
				6632	6641	6653	6662	6671	6887	6899	6918	6929	7181	7190	7201
				7210	7310	7320	7338	7353	7366	7378	7390	7400	7716	7724	7741
				7748	7755	7762	7770	7789	7805	7818	7831	7844	7856	7865	7896
				7923	7948	7967	7981	7994	8008	8465	8473	8503	8521	8532	8630
				8640	8658	8754	8762	8801	8918	8926	8946	8961	8969	8976	8983
				9196	9204	9230	9241	9261	9272	9491	9501	9518	9525	9532	9645
				9656	9674	9682	9689	9800	9811	9829	9837	9844	9949	9961	9969
				9979	9988	9997	10179	10189	10215	10227	10344	10354	10381	10393	10505
				10515	10541	10553	10670	10680	10707	10719	10830	10840	10865	10877	11001
				11011	11036	11048	11164	11174	11199	11211	11333	11343	11369	11381	11531
				11545	11561	11582	11600	11618	11630	12046	12054	12073	12083	12098	12194
				12202	12217	12230	12243	12345	12353	12363	12393	12400	12408	12570	12578
				12589	12623	12630	12638	12808	12817	12825	12876	12966	12974	13001	13022
				13034	13175	13183	13198	13230	13247	13264	13273	13441	13449	13486	13600
				13691	13718	13723	13736	13742	13773	13779	13796	13802	13827	13832	13837
				13842	14065	14074	14094	14117	14143	14161	14187	14205	14211	14438	14441
				14679	14773	14781	14791	15359	15362
BLOCK2				2186	2266	2301	2304	2317	2325	2333	2547	2633	2667	2670	2684
				2691	2698	2705	2969	3034	3046	3049	3062	3070	3078	4436	4489
				4503	4511	4519	6888	6936	6951	6962	9950	10013	10021	10031	10040
				10049
BLOCK3				2970	3086	3098	3101	3114	3122	3130
BLOCK4				2971	3135	3158	3161	3174	3182	3190
BLVECTOR			14894#	14895	14903
BOARD				4688	4691	4692	4693	4694	4695	4697	4705	4708	4709	4712	4714
				4716	4717	4719
BOOT				1559+#
BTT				1652	1654	1657	1659	1661	1668	1671	1676	1677	1679	3590	3592
				3593	3596	3599	3609	3612	3617	3618	3620	3627	3630	3635	3636
				3638	3645	3648	3653	3654	3656	4228	4230	4234	4236	5235	5237
				5438	5440	5794	5795	7340	7342	7344	7345	9216	9220	9221	9224
				9228	9230	9247	9251	9252	9255	9259	9261	10206	10208	10213	10215
				10372	10374	10379	10381	10532	10534	10539	10541	10698	10700	10705	10707
				10856	10858	10863	10865	11027	11029	11034	11036	11190	11192	11197	11199
				11360	11362	11367	11369	11552	11554	11555	11558	11561	11571	11574	11579
				11580	11582	11589	11592	11597	11598	11600	11607	11610	11615	11616	11618
				12086	12088
BTTVECTOR			 396#	 397	3495	4206	5211	5414	5734	5735	6879	6880	7671	7672
				7673	8909	8910	9484	9638	9793	12039	13433	14766
BUSREQ				1562+#
BUS_DATA			1617	1647#	1654	1659	1667	1672	1677	1686	1689	15137	15140#	15142#
				15144#	15146#	15148#	15150
BUS_REQ				1447+#	1646	2987	3039	3091	3151	12060	15181	15271	15298
BUS_XCVR			 318#	3681#
CACHE_ENB			1346+#
CE				 512+
CH				 514+
CHK_ERR_MSG			 497+	2207	2217	2236	2280	2289	2308	2568	2578	2597	2647	2655
				2674	2999	3051	3103	3163	3566	3573	3579	4084	4453	4492	4684
				5099	5223	5426	5762	6442	8938	12063	12207	12221	12234	13454
CLEAR_MRE			12791#	12829	13142#	13202	13578#	13629	13655	13681	13728	13787	14046#	14102
				14427#	14460	15344#	15424	15491
CLK_RUN				1436+#
CLOSE_LATCH			1441+#	1646	2987	3039	15299
CLR_INT				1430+#
COL_VECT			5737	5747	5815#
COM_ADR				1407+#	2985	3037	3089	3149	12059	15179	15269	15297
CONS_ENB			1560+#
CONTINUE			1452+#
CONTINUE_H			1547+#
CONTROL				 483+*
CP				 453+	 502+
CP_NOSS				 503+
CRAM_ADDR			 450+
CRAM_ADR_LD			1420+#
CRAM_PE				1508+#
CRAM_RESET			1416+#
CRAM_WRT			1421+#
CRA_PE				1505+#
CRA_R_CLK			1443+#
CRA_T_CLK			1444+#
CRM_PE_DET			1348+#
CR_CLK_ENB			1577+#
CR_LF				 619+#	 623+	 651+
CS				 513+
CSL_INT				1412+#
CSL_PAR				4420	4455#	4459	4466	4474	4494#	4498	4505	4513
CTY_BIT				1554+#
CTY_CHAR_LEN			1553+#
CUM_ERR				3515	3557#	3658#	3666#	3670	3678	4662	4681#	4699#	4745#	4749	4751
CUM_NXMM			3516	3557#	3586#
DATA				 456+	 458+	5211	5237	5414	5440	15078	15106	15187	15210	15211	15212
				15213	15214	15217	15240	15241	15242	15243	15244
DATA0				1401+#
DATA1				1400+#	5073#	5100	5109	5114	5123	5128	5137
DATA10				1388+#
DATA11				1387+#
DATA12				1383+#
DATA13				1382+#
DATA14				1381+#
DATA15				1380+#
DATA16				1379+#
DATA17				1378+#
DATA18				1377+#
DATA19				1376+#
DATA2				1399+#	5074#	5101	5104	5115	5118	5129	5132
DATA20				1372+#
DATA21				1371+#
DATA22				1370+#
DATA23				1369+#
DATA24				1368+#
DATA25				1367+#
DATA26				1366+#
DATA27				1365+#
DATA28				1361+#
DATA29				1360+#
DATA3				1398+#
DATA30				1359+#
DATA31				1358+#
DATA32				1357+#
DATA33				1356+#
DATA34				1355+#
DATA35				1354+#
DATA4				1394+#
DATA5				1393+#
DATA6				1392+#
DATA7				1391+#
DATA8				1390+#
DATA9				1389+#
DATA_ACK			1558+#
DATA_BIT			5734	5792#	5795
DATA_CORR			6884#	6906#	6916	6926	6939#	6949	6959
DATA_CORR_VECT			6880	6884	6913	6923	6946	6956
DATA_CYCLE			1405+#	2986	3038	3090	3150	15270
DATA_LOOP			3560	3562	3585	3608	3626	3644	3670	11538	11540	11570	11588	11606
DATA_OK				4665	4713#	4723	4731
DATA_VECT			10173	10176	10199#	10213	10225	10338	10341	10363#	10364#	10379	10391	10499
				10502	10525#	10539	10551	10664	10667	10689#	10690#	10705	10717	10824	10827
				10849#	10863	10875	10995	10998	11020#	11034	11046	11158	11161	11183#	11197
				11209	11327	11330	11352#	11353#	11367	11379
DC_035				 521+
DEBUG1				 294	14443
DEST				 931+	 932+
DI				 458+#
DIAG1				1425+#
DIAG10				1428+#
DIAG2				1426+#
DIAG4				1427+#
DM				 456+#	4452	5229	5432	6901	7727	8015	8643	8764	8766	8935	8986
				9504	9660	9815	9850	9972	10883	11054	11216	11387	12057	12232	13185
				13187	13189#	15378
DM_CHK				 523+	3571	4691
DN				 527+
DP				 944+	 945+	 965+	 966+
DP_CLK_ENBL			1576+#
DP_PE_DET			1347+#
DP_PE				1506+#
DP_RESET			1418+#
EB_AC				 609+#	 733+
EC				 519+
ECC_DOUBLE			 317#	7737#	9825#
ECC_OFF				 276#	3565	4683	5098	5222	5425	5761	6615	8934	9477#	9503	9625#
				9658
ECC_ON				 277#	9779#	9813	10150#	10197	10308#	10361	10476#	10523	10634#	10687	10801#
				10847	10964#	11018	11134#	11181	11298#	11350
ECC_ON_FORCE			8438#	8475
ECC_SINGLE			 316#	7334#	9514#	9670#
EC_AC				 610+#	 734+
EI				 459+#	4083
EI_AC				 606+#	 730+
EI_CHK				 530+	6264	6619
EJ				 517+
EJ_AC				 607+#	 731+
EK_AC				 608+#	 732+
EM				 457+#	3580	4223	4491	5102	5116	5130	5232	5435	6902	7728	8016
				8644	8772	8773	8936	8987	9505	9661	9816	9851	9981	10033	10193
				10357	10884	11055	11217	11388	11548	12220	14784
EM_AC				 611+#	 735+
EM_CHK				 526+	3577	4708
END_LIST			 455+#
EN_1MS				1345+#
EOP_UUO				 725+#
ERMCAS				 491+
ERMCA				 490+
ERMS				 492+
ERR				 485+	1611	1667#	1673	2993	3045	3097	3157	3542	3608#	3614	3626#
				3632	3644#	3650	4093	4095	4098	4100	4739	4741	4742	4743	5834
				5841	5848	5855	5863	5870	5877	5884	5891	5898	5905	5912	5919
				5926	7199	7208	8501	8503	8513	8515	8519	8521	8794	8796	8799
				8801	11526	11570#	11576	11588#	11594	11606#	11612	11636#	11637#	11642	11647
				12361	12586	12822	13194	13479	13481	13484	13486	14090	14458
ERRCAS				 487+	1659	1677	1689	3596	3618	3636	3654	3667	4098	4742	5109
				5123	5137	7336	7350	7363	7375	7387	7398	7786	7802	7815	7828
				7841	7854	7863	7880	7893	7919	7944	8006	8519	8530	9228	9239
				9259	9270	9530	9687	9842	10213	10225	10379	10391	10539	10551	10705
				10717	10863	10875	11034	11046	11197	11209	11367	11379	11558	11580	11598
				11616	11628	14713
ERRCA				 486+	5245	5448	6916	6926	6949	6959	7739	7746	7753	7760	7768
				7964	7978	7991	8656	8799	8981	12081	12096
ERRFLG				 559+
ERRM				 489+
ERRNO				7296	7342#	7350	7353
ERRR				6585	6622#	6630	6632	6639	6641	6911	6913	6916	6918	6944	6946
				6949	6951	7780	7782	7784	7786	7789	7887	7889	7893	7896	7906
				7911	7913	7916	7919	7923	7931	7936	7938	7941	7944	7948	8954
				8956	8959	8961
ERR_FLAG			1613	1648#	1658#	1667	1675#	1686	1688#	1692	3543	3570#	3597#	3608
				3616#	3626	3634#	3644	3652#	3658	3664	3666#	4663	4715#	4724#	4725#
				4732#	4734#	4741	4745	4746	5727	5829#	5833#	5840#	5847#	5854#	5859
				5862#	5869#	5876#	5883#	5888	5890#	5895	5897#	5902	5904#	5909	5911#
				5916	5918#	5923	5925#	5930	5948#	5949	7299	7330#	7333#	7343	7351#
				7358	7364#	7370	7376#	7382	7388#	7395	7664	7779#	7787#	7797	7803#
				7810	7816#	7823	7829#	7836	7842#	7850	7874#	7878#	7894#	7908	7920#
				7933	7945#	7958	7965#	7972	7979#	7986	7992#	8002	8444	8498#	8517#
				8527	8750	8779#	8783#	8787#	8790#	8796	9164	9215#	9225#	9236	9246#
				9256#	9267	9629	9651#	9678#	9690	9783	9806#	9833#	9845	10154	10205#
				10210#	10220	10222#	10228	10312	10371#	10376#	10386	10388#	10394	10480	10531#
				10536#	10546	10548#	10554	10638	10697#	10702#	10712	10714#	10720	10805	10855#
				10860#	10870	10872#	10878	10968	11026#	11031#	11041	11043#	11049	11138	11189#
				11194#	11204	11206#	11212	11302	11359#	11364#	11374	11376#	11382	11394#	11395
				11527	11546#	11559#	11570	11578#	11588	11596#	11606	11614#	11625	11627#	11631
				12035	12062#	12069#	12074	12178	12205#	12213#	12218	12334	12356#	12359#	12364
				12559	12581#	12587#	12590	12797	12823#	12826	12955	12994#	12998#	13002	13172
				13196#	13199	13226#	13231	13243#	13248	13260#	13265	13428	13458#	13462#	13465#
				13472#	13481	13585	13693#	13720#	13724	13737#	13743	13774#	13780	13797#	13803
				14053	14083#	14088#	14095	14112#	14118	14138#	14144	14156#	14162	14182#	14188
				14200#	14206
ERR_HOLD			9474#	9512	9520	9527	9622#	9668	9676	9684	9775#	9823	9831	9839
ERR_MAP				14903	14982
ERR_NUM				4666	4692#	4700	4702	4714#	4742	4743	8620	14618	14685#	14706	14712#
ERR_OCC				5721	5830#	5831	5838	5845	5852	5859#	5860	5867	5874	5881	7663
				7797#	7798	7810#	7811	7823#	7824	7836#	7837	7958#	7959	7972#	7973
				7986#	7987
ERR_SWITCH			7297	7358#	7359	7370#	7371	7382#	7383
ERR_TEMP			7298	7343#	7346
ER_AC				 605+#	 729+
EXACT				14045#	14084	14086
EXECUTE_B			1548+#
EXNEXT				 460+	 506+
EX_NXT				 453+	 460+#
FAILURE				 494+
FILNAM_ADR			 758+
FLP_CHK				 496+
FORCE_BITS			8626	8642	8747#	8765	9633	9658	9666	9667	9787	9813	9821	9822
				10168	10197	10199	10327	10361	10363	10494	10523	10525	10653	10687	10689
				10819	10847	10849	10984	11018	11020	11153	11181	11183	11316	11350	11352
FORCE_CLR			5072#	5140	7286#	7406
FORCE_DOUBLE			13147#	13188
FORCE_ONES			6228#	6254	7653#	7726
FORCE_PAR			1344+#
FORCE_SET			7285#	7324	8904#	8934	9169#	9206	9938#	9971	10023
FORCE_SINGLE			13146#	13186
FORCE_ZEROS			6229#
FORCE				8441#	8485	8489	9653	9658	9666	9667	9808	9813	9821	9822
FRDPAG				 760+#
FSELECT				 758+#
FUNC				 891+	 892+
HALTED				 765+#
HALT_LOOP			1550+#
HANG				15345#
HANGMEM				13579#
HANG_MEM			 260	8937	12206	13451	13616	13642	13668	13706	13752	13805	14428#	14469
				15153*	15382	15434	15501
HOW				15302	15407
I				 396	 398	 399	 401	3507	3509	3510	3512	5730	5731	7695	7696
				7697	7698	9175	9177	11503	11505	11506	11508	14862	14863	14894	14895
				14976	14977	14980	14982	15019	15021
INIT				 252	14809*
IO_DATA				1406+#	10176#	10211#	10223#	10341#	10377#	10389#	10502#	10537#	10549#	10667#	10703#
				10715#	10827#	10861#	10873#	10998#	11032#	11044#	11161#	11195#	11207#	11330#	11365#
				11377#
IO_DEPOSIT			 458+	 528+	3565	4683	5098	5140	5222	5425	5761	6254	6615	6904
				6937	7192	7203	7324	7406	7726	8014	8475	8642	8765	8934	8985
				9206	9503	9659	9814	9849	9971	10023	10197	10361	10523	10687	10847
				10882	11018	11053	11181	11215	11350	11386	13186	13188
IO_EXAMINE			 459+	 529+	4456	4495	6279	6620	6905	6938	7327	7730	8484	8645
				8774	8951	9209	9509	9665	9820	9963	9973	9982	9991	10015	10025
				10034	10043	10211	10223	10377	10389	10537	10549	10703	10715	10861	10873
				11032	11044	11195	11207	11365	11377	12064	12076	12208	12225	12238	12404
				12634	13456	14785
IO_NDA				6586	6619#	6626	6635	6647	6656	6665
J				5730	5731	14894	14895
KLINIK_BIT			1552+#
KLINIK_CARR			1568+#
KLINIK_LEN			1551+#
LANGUAGE			   4
LAST_ERR			8454	8488#
LAST_FORCE			8455	8489#	8512	8515	8527
LAST_STAT			8453	8490#	8519	8530
LATCH_DATA			1442+#	15299
LC				 451+#
LCA				 451+	 520+
LFOR				7654#	7798
LFORA				7656#	7824
LOADUC				 450+	 509+
LOAD_U				 450+#
LOOP_CHK			 495+	1661	1679	1691	2014	2020	2026	2032	2038	2044	2050	2229
				2232	2245	2253	2261	2301	2304	2317	2325	2333	2590	2593	2607
				2614	2621	2628	2667	2670	2684	2691	2698	2705	2994	2997	3010
				3018	3026	3046	3049	3062	3070	3078	3098	3101	3114	3122	3130
				3158	3161	3174	3182	3190	3599	3620	3638	3656	3673	3689	3696
				4100	4236	4246	4254	4464	4472	4480	4503	4511	4519	4702	4743
				5111	5125	5139	5247	5450	5836	5843	5850	5857	5865	5872	5879
				5886	5893	5900	5907	5914	5921	5928	6284	6452	6464	6632	6641
				6653	6662	6671	6918	6929	6951	6962	7201	7210	7338	7353	7366
				7378	7390	7400	7741	7748	7755	7762	7770	7789	7805	7818	7831
				7844	7856	7865	7896	7923	7948	7967	7981	7994	8008	8503	8521
				8532	8658	8801	8946	8961	8969	8976	8983	9230	9241	9261	9272
				9518	9525	9532	9674	9682	9689	9829	9837	9844	9969	9979	9988
				9997	10021	10031	10040	10049	10215	10227	10381	10393	10541	10553	10707
				10719	10865	10877	11036	11048	11199	11211	11369	11381	11561	11582	11600
				11618	11630	12073	12083	12098	12217	12230	12243	12363	12393	12400	12408
				12589	12623	12630	12638	12825	12876	13001	13022	13034	13198	13230	13247
				13264	13273	13486	13723	13742	13779	13802	13832	13842	14093	14117	14143
				14161	14187	14205	14791
LPONTST				 556+	14974
M				5730	14894
MAINT_CLK			1432+#
MASK				10165	10208	10324	10374	10491	10534	10650	10700	10816	10858	10981	11029
				11150	11192	11313	11362
MASK_AND			6874#	6906	6939
MASK_XOR1			6875#	6906
MASK_XOR2			6876#	6939
MATCH				5789	5793	5798
MAX_MEM				 297	14688	15023#
MEM				1448+#	1646	2987	3039	3091	3151	12060	15016	15018#	15019	15023	15181
				15271	15298
MEMSIZE				 484+	15018
MEM_CONT			9165	9210#	9249	9253	9259	9267	9270
MEM_CORR			8445	8519	8530	9480	9510#	9530	9630	9666#	9687	9784	9821#	9842
				10313	10366#	10374	10379	10386	10391	10639	10692#	10700	10705	10712	10717
				10969	14762
MEM_DAT				9487#	9516	9523	9641#	9672	9680	9796#	9827	9835	13436#	13456#	13484
				14769#
MEM_DATA			8448	9171#	9207	9250	9253	9259	9267	9270	9483	9487	9509#	9511#
				9530	9637	9641	9665#	9667#	9687	9792	9796	9820#	9822#	9842	10156
				10200#	10208	10213	10220	10225	10315	10365#	10374	10379	10386	10391	10482
				10526#	10534	10539	10546	10551	10641	10691#	10700	10705	10712	10717	10807
				10850#	10858	10863	10870	10875	10972	11021#	11029	11034	11041	11046	11140
				11184#	11192	11197	11204	11209	11304	11354#	11362	11367	11374	11379	14765
				14769
MEM_DATA_VECT			13432	13436	13457#
MEM_DEPOSIT			 456+	 524+	5100	5101	5114	5115	5128	5129	5231	5434	5772	5773
				5774	5775	6255	7325	8478	9207	10024	10192	10198	10356	10362	10518
				10524	10682	10688	10842	10848	11013	11019	11176	11182	11345	11351	11547
				14691	14783
MEM_EM				12191#	12220#
MEM_EXAMINE			 457+	 525+	4712	5777	5778	5779	5780	6256	7326	8483	9208	9210
				10200	10365	10519	10526	10683	10691	10843	10850	11014	11021	11177	11184
				11346	11354	14702
MEM_LOC				9172#	9207	9208	9210	13208	13210	13211	13212	13213
MEM_MAP				14671	14690#	14693#	14701	14710
MEM_PE				1507+#	4240	4455	4494
MEM_READ			 312#
MEM_REF_ERR			 766+#
MEM_STAT			4422	4456#	4457	4495#	4496	6596#	6620#	6626	6635	6647	6656	6665
				6883#	6905#	6906	6916	6926	6938#	6939	6949	6959	7708#	7730#	7739
				7746	7753	7760	7768	7778	7782	7786	7797	7798	7802	7810	7811
				7815	7823	7824	7828	7836	7837	7841	7850	7854	7863	7875	7880
				7889	7893	7908	7910	7919	7933	7935	7944	7958	7959	7964	7972
				7973	7978	7986	7987	7991	8002	8006	8447	8484#	8485	8489	8490
				8621	8645#	8646	8653	8656	8751	8774#	8776	8799	8914#	8951#	8952
				8959	8967	8974	8978	8981	9488#	9509#	9527	9530	9642#	9665#	9684
				9687	9797#	9820#	9839	9842	9946#	9963#	9964	9973#	9974	9982#	9983
				9991#	9992	10015#	10016	10025#	10026	10034#	10035	10043#	10044	10155	10314
				10481	10640	10806	10971	11139	11303	13437#	13456#	14770#	14785#	14786	14789
MEM_STAT_ADR			7304	7328#	7331	7343	7345	7357	7358	7369	7370	7381	7382	7395
MEM_STAT_REG			3534#	4083#	7303	7327#	7328	7331	7336	7350	7363	7375	7387	7398
				9193#	12042#	12064#	12076#	12077	12081	12096
MEM_STAT_VECT			3495	3534	4085	4087	4089	4091	6879	6883	6913	6923	6946	6956
				7673	7708	7735	7743	7750	7757	7764	7860	9474	9484	9488	9520
				9622	9638	9642	9676	9775	9793	9797	9831	12039	12042	12088	13433
				13437	13459	14766	14770
MEM_STAT_V			8909	8914	8964	8971
MEM_TEMP			7709#	7778#	7782	7797	7798	7810	7811	7823	7824	7836	7837	7850
				7875#	7876	7889	7908	7912	7933	7937	7958	7959	7972	7973	7986
				7987	8002
MEM_TEMP1			7710#	7912#	7914
MEM_TEMP1_VECT			7701	7710	7913#
MEM_TEMP2			7711#	7937#	7939
MEM_TEMP2_VECT			7702	7711	7938#
MEM_TEMP_VECT			7671	7709
MEM_WRITE			 313#
MESSV				1616	1638#	1657#	1659	1676#	1677	1689	2174	2177	2178	2179	2180
				2181	2228	2243	2251	2259	2300	2315	2323	2331	2534	2537	2538
				2539	2540	2541	2542	2589	2605	2612	2619	2626	2666	2682	2689
				2696	2703	2962	3000#	3001	3002#	3003	3008	3016	3024	3052#	3053
				3054#	3055	3060	3068	3076	3104#	3105	3106#	3107	3112	3120	3128
				3164#	3165	3166#	3167	3172	3180	3188	3520	3563#	3592#	3596	3617#
				3618	3635#	3636	3653#	3654	3667	3687	3694	4083#	4098	4426	4454#
				4456#	4462	4470	4478	4491#	4493#	4495#	4501	4509	4517	4647	4693#
				4694#	4695#	4700	4716#	4717#	4742	5083	5107#	5109	5121#	5123	5135#
				5137	6237	6243	6272	6279#	6282	6405	6412	6413	6450	6462	6589
				6595	6596	6630	6639	6651	6660	6669	7302	7322#	7323	7344#	7350
				7668	7784#	7786	7800#	7802	7813#	7815	7826#	7828	7839#	7841	7852#
				7854	7863	7880	7916#	7919	7941#	7944	7961#	7964	7975#	7978	7989#
				7991	8004#	8006	8452	8512#	8519	8530	9163	9224#	9228	9239	9255#
				9259	9270	9943	9946	9959#	9967	9977	9986	9995	10011#	10019	10029
				10038	10047	11511	11541#	11554#	11558	11579#	11580	11597#	11598	11615#	11616
				11628	12181	12186	12187	12188	12189	12190	12191	12215	12228	12241	14055
				14058	14059	14060	14061	14062	14141	14159	14185	14203	14214	14672	14708#
				14709#	14713
MESS_STR			1620	1676	3471	3617	3635	3653	5084	5107	5121	5135	7677	7784
				7800	7813	7826	7839	7852	8458	9183	9224	9255	9941	9959	10011
				11471	11579	11597	11615
MESS_STR1			4648	4694	4717
MESS_STR2			4653	4695
MESS_WSTR			7685	7916	7941	7961	7975	7989	8004
MIX_1				5713#	5831	5860
MIX_2				5714#	5838	5867
MIX_3				5715#	5845	5874
MIX_4				5716#	5852	5881
MIX_VECT			9182	9193
MLOC				13166#	13210#
MMA_MAP				 295	4692	4695	4697	4719	15021#
MMC_PAR				4421	4457#	4459	4466	4474	4496#	4498	4505	4513
MMC_REF_ERR			1514+#	12067	12211	12382	13621	13639	13647	13665	13673	13710	13732	13761
				13792	13815	14110	15386	15440	15461
MNT_CLK_ENB			 389	1431+#
MOD_FLD				 522+
MR				 510+	1641	2007	2198	2270	2559	2637	2983	3035	3087	3139	3142
				3145	3564	4221	4225	4451	4490	4690	4707	5097	5113	5127	5220
				5423	5760	6248	6428	6611	6900	7191	7321	7725	8474	8492	8641
				8763	8927	8950	9205	9502	9657	9812	9962	9990	10014	10042	10190
				10355	10516	10681	10841	11012	11175	11344	11542	12055	12203	12354#	12579#
				12818	12975	13184	13450	13614	13702	13704	14078	14080	14081#	14450	14684
				14782	14859	15377	15379
MRE_IO				 307#	2241#	2313#
MRE_IO_NOT			 309#
MRE_MEM				 306#	2603#	2680#	3014#	3022#	3066#	3074#
MRE_MEM_NOT			 308#	3118#	3126#	3178#	3186#
MRE_TICKS			 304	13605	13606	13607	13608	13824	15505
MSGADR				 630+	 631+	 654+	 655+
MSGFIL				 283#
MSGWORD				 626+	 627+
MSG_CHK_UUO			 750+#
MSMMCT				   3#
MSR				 280#	3565	4456	4495	4683	5098	5140	5222	5425	5761	6239	6240
				6254	6407	6408	6591	6592	6620	6904	6905	6937	6938	7192	7203
				7324	7327	7331	7406	7726	7730	7876	8014	8475	8484	8642	8645
				8765	8774	8785	8934	8951	8978	8981	8985	9206	9209	9503	9509
				9659	9665	9814	9820	9849	9963	9971	9973	9982	9991	10015	10023
				10025	10034	10043	10197	10211	10223	10361	10377	10389	10523	10537	10549
				10687	10703	10715	10847	10861	10873	10882	11018	11032	11044	11053	11181
				11195	11207	11215	11350	11365	11377	11386	12064	12076	12208	12225	12238
				12404	12634	13186	13188	13456	14785
MSR_CONT			9166	9209#	9218	9222	9228	9236	9239
MSR_CORR			7305	7323#	7336	7350	7363	7375	7387	7398	7707#	7729#	7739	7746
				7753	7760	7768	7786	7802	7815	7828	7841	7854	7863	7880	7893
				7919	7944	7964	7978	7991	8006	8624	8652
MSR_CORR_VECT			7672	7707
MSR_DATA			9170#	9219	9222	9228	9236	9239
MSR_DM				12190#	12238#
MSR_EM				12189#	12225#
MSR_HANG			12188#	12208#
MSR_READ			 310#	2249#	2257#
MSR_WRITE			 311#	2321#	2329#
M_REF				2958	3001#	3005	3012	3020	3053#	3057	3064	3072	3105#	3109	3116
				3124	3165#	3169	3176	3184	13429	13457#	13461	13469
N				 396	 399	 453+	3507	3510	5730	7695	7697	9175	11503	11506	14894
NDA				6233	6264#	6266	6276
NDA_ERR				6411#	6442
NEXM				1563+#	2609	2686	3003	3055	3107	3167	4249	12223	12236	12992	12995
NOERR_1				 320#	1634#
NOERR_10			 329#	5092#	5108#	5122#	5136#	5948
NOERR_11			 331#	5218#	5244#	5948
NOERR_12			 332#	5421#	5447#	5948
NOERR_13			 333#	5755#	5932#	5949
NOERR_14			 334#	6251#	6271#	6281#	6682	9283
NOERR_15			 335#	6420#	6449#	6461#	6682
NOERR_16			 336#	6603#	6629#	6638#	6650#	6659#	6668#	6682
NOERR_17			 337#	6892#	6915#	6925#	6948#	6958#	6965	7216	7413	8022	9287	9545
				9698	9864	10003	10055	11656
NOERR_18			 338#	7185#	7198#	7207#	7216	7221
NOERR_19			 339#	7314#	7335#	7349#	7362#	7374#	7386#	7397#	7413	9287	11656
NOERR_2				 321#	2003#
NOERR_20			 340#	7720#	7738#	7745#	7752#	7759#	7767#	7785#	7801#	7814#	7827#	7840#
				7853#	7862#	7879#	7892#	7918#	7943#	7963#	7977#	7990#	8005#	8022	8665
				8670	8676
NOERR_21			 342#	8469#	8518#	8529#	8670	8676
NOERR_22			 343#	8634#	8647#	8653	8655#	8665	8670	8676	9287	11656
NOERR_23			 344#	8758#	8798#	8806
NOERR_24			 345#	8922#	8943#	8958#	8966#	8973#	8980#
NOERR_25			 346#	9200#	9227#	9238#	9258#	9269#	9279	9283	9287	11656
NOERR_26			 347#	9495#	9515#	9522#	9529#	9535	9541	9545	9856
NOERR_27			 348#	9649#	9671#	9679#	9686#	9693	9698	9860
NOERR_28			 349#	9804#	9826#	9834#	9841#	9856	9860	9864
NOERR_29			 350#	9954#	9966#	9976#	9985#	9994#	10003	10007	10018#	10028#	10037#	10046#
				10055
NOERR_3				 322#	2191#	2227#	2242#	2250#	2258#	2299#	2314#	2322#	2330#	2715
NOERR_30			 351#	10183#	10212#	10224#	11636
NOERR_31			 353#	10348#	10378#	10390#	11394	11636
NOERR_32			 354#	10509#	10538#	10550#	11394	11636
NOERR_33			 355#	10674#	10704#	10716#	11394	11636
NOERR_34			 356#	10834#	10862#	10874#	11394	11636
NOERR_35			 357#	11005#	11033#	11045#	11395	11637
NOERR_36			 358#	11168#	11196#	11208#	11395	11637
NOERR_37			 359#	11337#	11366#	11378#	11395	11637
NOERR_38			 360#	11535#	11631#	11637	11651	11656
NOERR_39			 361#	12050#	12070#	12080#	12095#
NOERR_4				 323#	2552#	2588#	2604#	2611#	2618#	2625#	2665#	2681#	2688#	2695#	2702#
				2715
NOERR_40			 362#	12198#	12214#	12227#	12240#
NOERR_41			 364#	12349#	12360#	12390#	12397#	12405#
NOERR_42			 365#	12574#	12585#	12620#	12627#	12635#
NOERR_43			 366#	12812#	12821#	12873#
NOERR_44			 367#	12970#	12997#	13019#	13030#
NOERR_45			 368#	13179#	13195#	13227#	13244#	13261#	13270#
NOERR_46			 369#	13445#	13483#
NOERR_47			 370#	13604#	13719#	13738#	13776#	13799#	13829#	13839#
NOERR_48			 371#	14069#	14089#	14114#	14140#	14158#	14184#	14202#	14213#
NOERR_49			 372#
NOERR_5				 324#	2975#	2992#	3007#	3015#	3023#	3044#	3059#	3067#	3075#	3096#	3111#
				3119#	3127#	3156#	3171#	3179#	3187#
NOERR_50			 373#
NOERR_51			 375#	14777#	14788#
NOERR_52			 376#
NOERR_53			 377#
NOERR_54			 378#
NOERR_55			 379#
NOERR_6				 325#	3554#	3680#	3686#	3693#	3701#	3705	4097#	9287	11647
NOERR_7				 326#	4216#	4233#	4242#	4251#
NOERR_8				 327#	4440#	4461#	4469#	4477#	4500#	4508#	4516#	7221
NOERR_9				 328#	4679#	4751#	5948
NOERR_MAP			 298	 320	 321	 322	 323	 324	 325	 326	 327	 328	 329	 331
				 332	 333	 334	 335	 336	 337	 338	 339	 340	 342	 343	 344
				 345	 346	 347	 348	 349	 350	 351	 353	 354	 355	 356	 357
				 358	 359	 360	 361	 362	 364	 365	 366	 367	 368	 369	 370
				 371	 372	 373	 375	 376	 377	 378	 379
NOERR				 493+	2716	3671	3704	3706	4750	5949	6470	6683	6928	6961	6966
				7217	7222	7414	8022	8666	8671	8677	8807	9279	9283	9287	9541
				9545	9698	9856	9860	9864	10003	10055	11396	11642	11647	11651	11657
				14715
NONXM				4669	4691#	4697	4708#	4711	4721	4729
NONXM1				3517	3571#	3572#	3575	3583	3586	3684
NONXM2				3518	3570#	3577#	3578#	3580	3583	3586	3691
NO_SUBSET			 555+
NUM				 646+	 647+	 666+	 667+	 670+	 671+	 674+	 675+	 678+	 679+	 682+	 683+
				 686+	 687+	 690+	 691+	 694+	 695+	 698+	 699+	 702+	 703+	 706+	 707+
				 710+	 711+
NUM_ERR				5203	5234#	5238#	5241	5406	5437#	5441#	5444	5719	5791#	5796#	5797
				8446	8480#	8487#	8499	8510	12034	12085#	12089#	12092
NUM_PATTERN			3504#	3560	3670	11500#	11538
NXM				2959	3003#	3005	3012	3020	3055#	3057	3064	3072	3107#	3109	3116
				3124	3167#	3169	3176	3184
NXMM				3541	3583#	3594	3608	3626	3644	3664
NXM_ERR				12185#	12221	12234
ONES				5207#	5231	5410#	5434
O_CRAM_ADDR			 451+	 452+	 887+	 888+
O_N				1197+	1198+
O_SN				1238+	1239+
PAR_BIT				4432#	4457	4496
PAR_DISABLE			 386#	4443	6894	7187
PAR_ENABLE			 387#	14860
PAR_ERR				 767+#
PAR_LEFT			1540+#
PAR_RIGHT			1541+#
PAR_SET				8905#	8934
PATT				4664	4709#	4713	4742	5740	5772	5773	5774	5775	5793
PATTERN				3489	3562	4655	4691	4693	4709	4716	11489	11540
PATT_BIT			5735	5793#	5795
PBELL				 714+#
PE				 386	 387	 511+
PE_1				1561+#
PE_CLR				 279#	7203
PE_DET_ENB			1349+#
PE_ECC				6581#	6626	6635	6647	6656	6665
PE_ERR				6582#	6647	6665
PE_SET				 278#	6615	6626	6635	6656	7192
PI_REQ_1			1521+#
PI_REQ_2			1520+#
PI_REQ_3			1519+#
PI_REQ_4			1518+#
PI_REQ_5			1517+#
PI_REQ_6			1516+#
PI_REQ_7			1515+#
PM_AC				 612+#	 736+
PNTSIX				 626+#
POCT_SUP			 710+#
POINT				 478+
PRGNAM				 284#
PRINT_CRLF			 622+#
PRINT_DEC			 646+#
PRINT_MSG			 630+#
PRINT_OCT_1			 670+#
PRINT_OCT_11			 702+#
PRINT_OCT_12			 706+#
PRINT_OCT_2			 674+#
PRINT_OCT_3			 678+#
PRINT_OCT_4			 682+#
PRINT_OCT_5			 686+#
PRINT_OCT_6			 690+#
PRINT_OCT_7			 694+#
PRINT_OCT_8			 698+#
PRINT_TXT			 638+#
PRINT_WORD			 634+#
PRT_CRLF_F			 650+#
PRT_DEC_F			 666+#
PRT_MSG_F			 654+#
PRT_TXT_F			 658+#
PTSTNUM				 501+
PTXT_CRLF			 642+#
PTXT_CRLF_F			 662+#
RAC_LO				1532+#
RAM_ERR				1575+#
RBAD_DATA			1528+#	2027
RCOM_ADR			1527+#	2033	13222	13224
RDATA				1525+#	2045
RDATA0				1539+#
RDATA1				1538+#
RDATA10				1494+#
RDATA11				1493+#
RDATA12				1489+#
RDATA13				1488+#
RDATA14				1487+#
RDATA15				1486+#
RDATA16				1485+#
RDATA17				1484+#
RDATA18				1483+#
RDATA19				1482+#
RDATA2				1537+#
RDATA20				1478+#
RDATA21				1477+#
RDATA22				1476+#
RDATA23				1475+#
RDATA24				1474+#
RDATA25				1473+#
RDATA26				1472+#
RDATA27				1471+#
RDATA28				1467+#
RDATA29				1466+#
RDATA3				1536+#
RDATA30				1465+#
RDATA31				1464+#
RDATA32				1463+#
RDATA33				1462+#
RDATA34				1461+#
RDATA35				1460+#
RDATA4				1500+#	12612
RDATA5				1499+#
RDATA6				1498+#
RDATA7				1497+#
RDATA8				1496+#
RDATA9				1495+#
RD_0				 461+#	15139
RD_1				 462+#	15141
RD_100				 465+#	4239	4454	4493	7195	7204
RD_101				 466+#	2238	2310	2600	2677	3000	3052	3104	3164	8940	12066	12210
				12381	13457	13620	13638	13646	13664	13672	13709	13731	13760	13791	13814
				14109	14465	14474	15385	15419	15430	15439	15460	15497	15510
RD_102				 467+#	2008	2206	2216	2279	2288	2567	2577	2646	2654	4226	6439
				12380	12610	12838	12846	12856	12864	13010	13220	13237	13254	14131	14149
				14175	14193
RD_103				 468+#	15147
RD_2				 463+#	15143
RD_3				 464+#	12611	15145
RD_300				 469+#
RD_301				 470+#	2599	2676	3002	3054	3106	3166	4248	12222	12235	12989
RD_303				 471+#
READV				14673	14694#	14702#	14710	14713
READ_BUS			 259	1647	15110*
READ_IO				2170#	2200
READ_MEM			2530#	2561
READ_MSR			12553#	12597
REC_PE				1510+#	4494
REF_ERR				2182#	2207	2217	2236	2280	2289	2308	2543#	2568	2578	2597	2647
				2655	2674	2965#	2999	3051	3103	3163	3547#	3566	3573	3579	4084
				4429#	4453	4492	4672#	4684	5077#	5099	5200#	5223	5403#	5426	5745#
				5762	8913#	8938	12043#	12063	12184#	12207	13438#	13454
REG				1995	2008#	2009	2012	2015	2018	2021	2024	2027	2030	2033	2036
				2039	2042	2045	2048	4209#	4226#	4234	4239#	4240	4244	4248#	4249
				4252	12799	12838#	12841	12846#	12849	12856#	12859	12864#	12867	13586	13621#
				13624	13632#	13634	13639#	13643#	13647#	13650	13658#	13660	13665#	13669#	13673#
				13676	13710#	13713	13715	13732#	13733	13753#	13757#	13761#	13762	13770	13792#
				13793	13806#	13812#	13815#	13816	13824	13834	14435#	14465#	14474#	14477	15350
				15386#	15395	15404	15419#	15420	15430#	15431	15436#	15440#	15443	15452	15457#
				15461#	15464	15497#	15498	15510#	15511
REG1				15351	15385#	15386	15399	15439#	15440	15447	15460#	15461	15468
REG101				2181#	2202#	2238#	2239	2275#	2310#	2311	2541#	2563#	2600#	2601	2642#
				2677#	2678	12038	12066#	12067	12071	12186#	12204#	12210#	12211	12339#	12381#
				12382	12564#	13591#	13620#	13621	13638#	13639	13646#	13647	13664#	13665	13672#
				13673	13709#	13710	13731#	13732	13760#	13761	13791#	13792	13814#	13815	14054
				14109#	14110	14115
REG102				2179#	2202#	2206#	2210	2275#	2279#	2283	2539#	2563#	2567#	2571	2642#
				2646#	2650	6413#	6439#	6446	6458	12338#	12380#	12385	12388	12395	12402
				12563#	12610#	12615	12618	12625	12632	12960#	13010#	13013	13015	13024	14058#
				14131#	14134	14136	14149#	14152	14154	14175#	14178	14180	14193#	14196	14198
REG102A				2180#	2202#	2216#	2220	2275#	2288#	2292	2540#	2563#	2577#	2581	2642#
				2654#	2658	13161#	13220#	13222	13224
REG102B				13163#	13237#	13239	13241
REG102C				13165#	13254#	13256	13258
REG3				12340#	12565#	12611#	12612
REG301				2542#	2599#	2609	2676#	2686	12187#	12204#	12222#	12223	12235#	12236	12959#
				12989#	12992	12995
REGV				4206	4209	4230	12335	12338	12339	12340	12341	12342	12391	12398	12404#
				12406	12560	12563	12564	12565	12566	12567	12621	12628	12634#	12636	12956
				12959	12960	12961	12962	12999	13020	13031	13157	13160	13161	13162	13163
				13164	13165	13166	13167	13168	13228	13245	13262	13271	13587	13590	13591
				13592	13593	13594	13595	13596	13597	13605#	13625	13651	13677	13721	13740
				13777	13800	13830	13840	14432	14435	14451#	14452#	14453	14466#	14467	14475#
				14476	15352	15399#	15400#	15401	15447#	15448#	15449	15468#	15469#	15470
REG_100				4419	4454#	4455	4493#	4494
REG_EXAMINE			 461+	 462+	 463+	 464+	 465+	 466+	 467+	 468+	 469+	 470+	 471+	 531+
REM_DIAG_ENB			1570+#
REM_DIAG_PRO			1571+#
REPEAT				 500+
REPLACEI			 480+
RESET				1350+#	7652#	8014	8903#	8985	9778#	9849	10800#	10882	10963#	11053	11133#
				11215	11297#	11386	14830
RETRY				14051	14071#	14210#	14211
RE_ERR				14431	14456#	14457
RFOR				7655#	7811
RFORA				7657#	7837
RIO_BUSY			1529+#	2021	2210	2220	2283	2292	6446	6458
RIO_DATA			1526+#	2039
RMEM_BUSY			1530+#	2015	2571	2581	2650	2658	12385	12388	12395	12402	12615	12618
				12625	12632	12841	12849	12859	12867	13013	13015	13024	13239	13241	13256
				13258	14134	14136	14152	14154	14178	14180	14196	14198
ROWCOL				5225	5230	5245	5247	5428	5433	5448	5450	5765	5767	5804	5813
				5815	5816
ROW_VECT			5736	5746	5816#
RPT_ERR_FLAG			 558+	1633#	2002#	2190#	2551#	2976#	3555#	4217#	4222#	4441#	4680#	5093#
				5219#	5422#	5756#	6252#	6421#	6604#	6893#	7186#	7315#	7721#	8470#	8635#
				8759#	8923#	9201#	9496#	9650#	9805#	9955#	10184#	10349#	10510#	10675#	10835#
				11006#	11169#	11338#	11536#	12051#	12199#	12350#	12575#	12813#	12971#	13180#	13446#
				13692#	14070#	14778#	15363#
RRESET				1531+#	2009
RUN				1454+#
RUN_1				1549+#
RUN_ERR_VECT			 291	 306	 307	 308	 309	 310	 311	 312	 313	 314	 316	 317
				 318	14863#	14977#	14982
RUN_TEST			 254	2000	2188	2549	2973	3552	4214	4438	4677	5090	5216	5419
				5753	6249	6418	6601	6890	7183	7312	7718	8467	8632	8756	8920
				9198	9493	9647	9802	9952	10181	10346	10507	10672	10832	11003	11166
				11335	11533	12048	12196	12347	12572	12810	12968	13177	13443	13602	14067
				14775	14866*
R_CLK_ENB0			1578+#
S0				3528#	3558#	3698
S1				3529#	3558#	3698
S2				3530#	3558#	3698
S3				3531#	3558#	3698
SCANI				 479+
SC_0				 518+
SEL				 986+	 987+	 997+	 998+	1008+	1009+
SEND_CMD_LINE			 742+#
SEND_EB_LINE			 733+#
SEND_EC_LINE			 734+#
SEND_EI_LINE			 730+#
SEND_EJ_LINE			 731+#
SEND_EK_LINE			 732+#
SEND_EM_LINE			 735+#
SEND_ER_LINE			 729+#
SEND_INFO			 754+#
SEND_LINE			 499+
SEND_NUL			 504+	2235	2307	2596	2673	2988	3040	3092	3140	3143	3146	3152
				7193	12233	13703	14697	14832	15184	15380
SEND_PM_LINE			 736+#
SEND_UUO_1			 746+#
SEND_X1A_LINE			 737+#
SEND_X1B_LINE			 738+#
SETNXT				 452+	 505+
SET_C				 452+#
SINGLE_CLK			1437+#
SOURCE_ADDR			 450+
SPEC_ASK			 257	15053*
SPEC_DIALOGUE			 255	14987*
SPEC_ERR			3540	4082#	4086#	4088#	4090#	4092#	4095
SPEC_PRT			 256	15026*
SPEC_VECT			3519	3528	3529	3530	3531	3585#
SRC				 904+	 905+	 917+	 918+
SSTR_VECT			5739	5749	5804#
SS_MODE				1419+#
START_CLK			 388#	2234	2306	2595	2672	6441	12387	12617	13679	14480
STEP_U_NEXT			 453+#
STK_RESET			1417+#
STOP_CLK			 389#
STR1				7695#	7696	7701	7703
STR2				7697#	7698	7702	7704
STRUCT				3499	3509	7669	7696	11495	11505
STR_VECT			5738	5748	5813#
SYNC_CLK			 551+	2199	2271	2560	2638	6429	12976	13615	13705	15381
SYNC_REFRESH			 265	12357	12583	12819	13192	14084	14086	14456	15302*
T1_VECT				7712#	7910#	7914
T2_VECT				7713#	7935#	7939
TE				 516+
TEMP				1612	1654#	1655	1672#	1673	3544	3593#	3594	3613#	3614	3631#	3632
				3649#	3650	3702	4423	4667	5080	5102#	5104	5109	5116#	5118	5123
				5130#	5132	5137	5204	5230#	5231	5232#	5245	5407	5433#	5434	5435#
				5448	5742	5777#	5778#	5779#	5780#	5792	7178	7195#	7196	7204#	7205
				7293	7345#	7346	7665	7728#	8449	8619	8652#	8653	8656	8915#	8940#
				8941	8944	8952#	9628	9658#	9659	9782	9813#	9814	11141	11528	11555#
				11556	11575#	11576	11593#	11594	11611#	11612	13582	15136	15139#	15140	15141#
				15142	15143#	15144	15145#	15146	15147#	15148	15355	15505#	15506
TEMP1				5726	5788#	5798#	5803	5810	5812	5814	7294	7356#	7359	7368#	7371
				7380#	7383
TEMP2				7295	7357#	7359	7369#	7371	7381#	7383
TEMP_V				8910	8915	8956
TEN_INT				1564+#
TERM_CARR			1569+#
TEST				5786	5792	5804	5810	5812	5813	5814	5815	5816	7317	7322	8477
				8478	8481	8483	8488	8637	8642	8652	8656	9498	9503	9510	9511
				10186	10197	10199	10351	10361	10363	10364	10366	10512	10523	10525	10677
				10687	10689	10690	10692	10837	10847	10849	11008	11018	11020	11171	11181
				11183	11340	11350	11352	11353	14866	14982
TEST1_VECT			7703	7712	7911#
TEST2_VECT			7704	7713	7936#
TESTADR				6230#	6255	6256
TEST_ABORT			 314#	1692#	2011#	2017#	2023#	2029#	2035#	2041#	2047#	3700#	4232#	4243#
				4468#	4476#	4507#	4515#	5106#	5120#	5134#	5243#	5446#	5933#	6270#	6280#
				6285	6448#	6453	6460#	6465	6628#	6633	6637#	6642	6649#	6654	6658#
				6663	6667#	6672	7348#	7361#	7373#	7385#	7766#	7891#	7917#	7942#	7962#
				7976#	8782#	8786#	9226#	9257#	12079#	12094#	12226#	12239#	13464#	13471#	13739#
				13775#	13798#	13828#	13838#	14113#	14139#	14157#	14183#	14201#	14212#
TEST_ADR			6243#	6261#	6264	6279	6412#	6425#	6435	6595#	6608#	6615	6619	7292
				7322#	7325	7326	7336	7343	7346	7356	7358	7363	7368	7370	7375
				7380	7382	7387	7395	7398	8456	8478	8483	8512
TEST_ADR_VECT			6238	6261	6406	6425	6590	6608
TEST_DATA			1618	1636	1638	1645	1655	1659	1667	1673	1677	1686	1689	3532#
				3570#	3580#	3585	3593	3596	3608	3613	3618	3626	3631	3636	3644
				3649	3654	3664	3667	4098	4668	4710#	4712#	4713	4742	10153	10193#
				10208	10220	10311	10357#	10366	10479	10519#	10534	10546	10637	10683#	10692
				10804	10843#	10858	10870	10967	11014#	11029	11041	11137	11177#	11192	11204
				11301	11346#	11362	11374	11519#	11546#	11548#	11555	11558	11570	11575	11580
				11588	11593	11598	11606	11611	11616	11625	11628	14676#	14691	14708	14710
				14713
TEST_DATA_VECT			3524	3532	11515	11519
TEST_EDIT			 273#
TEST_INIT			 253	14835*
TEST_MOS			3535#	3647#	3649	3650	11521#	11609#	11611	11612
TEST_MOS_VECT			3522	3535	3648#	11513	11521	11610#
TEST_PATT			3533#	3562#	3563	3571	3585	3594	3596	3608	3614	3618	3626	3632
				3636	3644	3650	3654	3664	3667	4098	11520#	11540#	11541	11547	11556
				11558	11570	11576	11580	11588	11594	11598	11606	11612	11616	11625	11628
TEST_PATT_VECT			3525	3533	11516	11520
TEST_TEMP			1628#	1670#	1672	1673	3537#	3611#	3613	3614	11523#	11573#	11575	11576
TEST_TEMP_VECT			1619	1628	1671#	3523	3537	3612#	11514	11523	11574#
TEST_VERSION			 272#
TEST_8646			3536#	3629#	3631	3632	11522#	11591#	11593	11594
TEST_8646_VECT			3521	3536	3630#	11512	11522	11592#
TEXT				 638+	 639+	 642+	 643+	 658+	 659+	 662+	 663+
TICK				 552+	2205	2215	2278	2287	2566	2576	2645	2653	6438	12369	12378
				12595	12599	12608	12831	12837	12845	12855	12863	12988	13004	13009	13036
				13204	13218	13235	13252	13619	13627	13631	13636	13645	13653	13657	13662
				13671	13708	13726	13730	13754	13755	13756	13766	13785	13789	13807	13808
				13809	13820	14104	14105	14106	14130	14148	14168	14174	14192	14464	14473
				15384	15409	15415	15426	15438	15459	15489	15493	15502	15503	15504	15506
TICK1				2177#	2202#	2208#	2210	2247	2275#	2281#	2283	2319	2537#	2563#	2569#
				2571	2616	2642#	2648#	2650	2693	12342#	12375#	12379#	12383	12385	12395
				12567#	12605#	12609#	12613	12615	12625	12802#	12835#	12839#	12841	12871	12961#
				12986#	12990#	12992	13160#	13216#	13219#	13222	13590#	13617#	13622#	13624	13633#
				13634	13637#	13648#	13650	13659#	13660	13663#	13674#	13676	13693#	13700	13711#
				13713	13715	14059#	14107#	14128#	14132#	14134	15348	15372#	15375	15387#	15388
				15392#	15400	15404
TICK10				13595#	13606#
TICK170				13597#	13608#
TICK2				2178#	2202#	2218#	2220	2255	2275#	2290#	2292	2327	2538#	2563#	2579#
				2581	2623	2642#	2656#	2658	2700	12341#	12376#	12382	12383#	12402	12566#
				12606#	12612	12613#	12632	12803#	12843#	12847#	12849	12871	12962#	13007#	13011#
				13013	13026	13162#	13233#	13236#	13239	13592#	13757#	13762	13767#	14060#	14146#
				14150#	14152	15349	15436#	15441#	15443	15448	15462#	15464	15469	15473
TICK3				12804#	12853#	12857#	12859	12871	13164#	13250#	13253#	13256	13267	13268	13593#
				13810#	13816	13821#	13824	14061#	14172#	14176#	14178
TICK4				12805#	12861#	12865#	12867	12871	14062#	14190#	14194#	14196	14208
TICK48				13596#	13607#
TICK9				13594#
TICKN				14462	14466	14471	14475
TICKV				12798	12802	12803	12804	12805	12874
TIMOUT				 557+	2210	2212	2220	2225	2283	2284	2292	2297	2571	2573	2581
				2586	2650	2658	2663	2990	3042	3094	3154	3572	3578
TP				 515+
TRAP_ENB			1429+#
TRY				12981	13017	13028	13688	13717	13735	13772	13795	13826	13836	15356	15373#
				15390#	15391	15395
TST1				 196	1582*
TST10				 205	5047*
TST11				 207	5170*
TST12				 208	5365*
TST13				 209	5680*
TST14				 210	6193*
TST15				 211	6364*
TST16				 212	6546*
TST17				 213	6841*
TST18				 214	7149*
TST19				 215	7254*
TST2				 197	1966*
TST20				 216	7620*
TST21				 218	8400*
TST22				 219	8589*
TST23				 220	8720*
TST24				 221	8864*
TST25				 222	9134*
TST26				 223	9442*
TST27				 224	9591*
TST28				 225	9744*
TST29				 226	9909*
TST3				 198	2139*
TST30				 227	10121*
TST31				 229	10280*
TST32				 230	10446*
TST33				 231	10606*
TST34				 232	10772*
TST35				 233	10934*
TST36				 234	11105*
TST37				 235	11267*
TST38				 236	11445*
TST39				 237	12009*
TST4				 199	2499*
TST40				 238	12153*
TST41				 239	12291*
TST42				 240	12508*
TST43				 241	12748*
TST44				 242	12925*
TST45				 243	13101*
TST46				 244	13403*
TST47				 245	13546*
TST48				 246	14008*
TST49				 247	14387*
TST5				 200	2921*
TST50				 248	14574*
TST51				 250	14735*
TST6				 201	3447*
TST7				 202	4180*
TST8				 203	4383*
TST9				 204	4617*
TTI_CLR				 720+#
TTI_DEC				 721+#
TTI_YES				 719+#
TT_ALTM				 718+#
T_ACTUAL			13168#	13267#
T_CONT				9191#	9218#	9222	9249#	9253
T_CONT_VECT			9180	9191	9220#	9251#
T_CORRECT			13153	13211
T_CORRECT1			13155	13212
T_DATA				9192#	9219#	9222	9250#	9253
T_DATA_VECT			9181	9192	9221#	9252#
T_SHOULD			13167#	13211#	13268
T_SHOULD1			13171	13212#	13268
U				1245+#
UNCOR				8906#	8952
UUO				 602+	 624+	 628+	 632+	 636+	 640+	 644+	 648+	 652+	 656+	 660+	 664+
				 668+	 672+	 676+	 680+	 684+	 688+	 692+	 696+	 700+	 704+	 708+	 712+
				 714+	 718+	 719+	 720+	 721+	 725+	 729+	 730+	 731+	 732+	 733+	 734+
				 735+	 736+	 737+	 738+	 742+	 746+	 750+	 754+	 759+	 760+
U_0				 888+	 892+	 905+	 918+	 932+	 945+	 966+	1250+	1265+	1267+	1293+#
U_0_DEFAULT			1267+	1280+#	1293+
U_1				 987+	 998+	1009+	1029+	1033+	1038+	1042+	1046+	1051+	1055+	1084+	1094+
				1107+	1127+	1156+	1256+	1262+	1265+	1268+	1294+#
U_1_DEFAULT			1268+	1281+#	1294+
U_2				1162+	1166+	1170+	1174+	1178+	1182+	1186+	1190+	1194+	1198+	1204+	1217+
				1230+	1239+	1265+	1269+	1295+#
U_2_DEFAULT			1269+	1282+#	1295+
U_3				1025+	1256+	1262+	1270+	1296+#
U_3_DEFAULT			1270+	1283+#	1296+
U_A				 944+#	 947+	 948+	 949+	 950+	 951+	 952+	 953+	 954+	 955+	 956+	 957+
				 958+	 959+	 960+	 961+	 962+
U_ALU_ADD			 894+#
U_ALU_AND			 898+#
U_ALU_MASK			 899+#
U_ALU_OR			 897+#
U_ALU_PARITY_OK			1024+#
U_ALU_RSUB			 896+#
U_ALU_SUB			 895+#
U_ALU_XNOR			 901+#
U_ALU_XOR			 900+#
U_ALU				 891+#	 894+	 895+	 896+	 897+	 898+	 899+	 900+	 901+
U_A_AR				 950+#
U_A_ARX				 951+#
U_A_BR				 952+#
U_A_BRX				 953+#
U_A_EBR				 955+#
U_A_FLG				 958+#
U_A_HR				 949+#
U_A_MAG				 947+#
U_A_MASK			 957+#
U_A_ONE				 954+#
U_A_PC				 948+#
U_A_PI				 959+#
U_A_T0				 961+#
U_A_T1				 962+#
U_A_UBR				 956+#
U_A_XWD1			 960+#
U_B				 965+#	 968+	 969+	 970+	 971+	 972+	 973+	 974+	 975+	 976+	 977+	 978+
				 979+	 980+	 981+	 982+	 983+
U_BYTE				1083+#	1086+	1087+	1088+	1089+	1090+
U_BYTE_1			1086+#
U_BYTE_2			1087+#
U_BYTE_3			1088+#
U_BYTE_4			1089+#
U_BYTE_5			1090+#
U_B_AR				 971+#
U_B_ARX				 972+#
U_B_BR				 973+#
U_B_BRX				 974+#
U_B_EBR				 976+#
U_B_FLG				 979+#
U_B_HR				 970+#
U_B_MAG				 968+#
U_B_MASK			 978+#
U_B_ONE				 975+#
U_B_PC				 969+#
U_B_PI				 980+#
U_B_T0				 982+#
U_B_T1				 983+#
U_B_UBR				 977+#
U_B_XWD1			 981+#
U_CALL				1193+#
U_CHKL				1037+#
U_CHKR				1050+#
U_CRY38				1161+#
U_DBM_APR_FLAGS			1013+#
U_DBM_BYTES			1014+#
U_DBM_DP			1017+#
U_DBM_DP_SWAP			1018+#
U_DBM_EXP			1015+#
U_DBM_MEM			1020+#
U_DBM_MSEC			1016+#
U_DBM_N				1021+#
U_DBM_PF_DISP			1012+#
U_DBM_SCAD			1011+#
U_DBM_VMA			1019+#
U_DBM				1008+#	1011+	1012+	1013+	1014+	1015+	1016+	1017+	1018+	1019+	1020+	1021+
U_DBUS				 997+#	1000+	1001+	1002+	1003+	1004+	1005+
U_DBUS_DBM			1005+#
U_DBUS_DP			1003+#
U_DBUS_PC_FLAGS			1000+#
U_DBUS_PI_NEW			1001+#
U_DBUS_RAM			1004+#
U_DBUS_VMA			1002+#
U_DEST				 931+#	 934+	 935+	 936+	 937+	 938+	 939+	 940+	 941+
U_DEST_A			 934+#
U_DEST_AD			 935+#
U_DEST_AD_DIV2			 941+#
U_DEST_AD_MUL2			 939+#
U_DEST_PASS			 937+#
U_DEST_Q_AD			 936+#
U_DEST_Q_DIV2			 940+#
U_DEST_Q_MUL2			 938+#
U_DISP				1106+#	1109+	1110+	1111+	1112+	1113+	1114+	1115+	1116+	1117+	1118+	1119+
				1120+	1121+	1122+	1123+
U_DISP_ADISP			1115+#
U_DISP_AREAD			1111+#
U_DISP_BDISP			1116+#
U_DISP_BYTE			1121+#
U_DISP_CONSOLE			1109+#
U_DISP_DP			1114+#
U_DISP_DP_LEFT			1112+#
U_DISP_DROM			1110+#
U_DISP_EAMODE			1122+#
U_DISP_MUL			1118+#
U_DISP_NICOND			1120+#
U_DISP_NORM			1113+#
U_DISP_PAGEFAIL			1119+#
U_DISP_RETURN			1117+#
U_DISP_SCAD0			1123+#
U_DIVIDE			1181+#
U_FMWRITE			1173+#
U_GENL				1032+#
U_GENR				1045+#
U_J				 887+#
U_LOADFE			1169+#
U_LOADSC			1165+#
U_LSRC				 904+#	 907+	 908+	 909+	 910+	 911+	 912+	 913+	 914+
U_LSRC_0A			 911+#
U_LSRC_0B			 910+#
U_LSRC_0Q			 909+#
U_LSRC_AB			 908+#
U_LSRC_AQ			 907+#
U_LSRC_D0			 914+#
U_LSRC_DA			 912+#
U_LSRC_DQ			 913+#
U_MEM				1177+#
U_MULTI_PREC			1185+#
U_MULTI_SHIFT			1189+#
U_N				1197+#
U_NO_CLKL			1028+#
U_NO_CLKR			1041+#
U_RAM_AC			 989+#
U_RAM_AC_FN			 990+#
U_RAM_N				 994+#
U_RAM_RAM			 993+#
U_RAM_VMA			 992+#
U_RAM_XR			 991+#
U_RAM				 986+#	 989+	 990+	 991+	 992+	 993+	 994+
U_RSRC				 917+#	 921+	 922+	 923+	 924+	 925+	 926+	 927+	 928+
U_RSRC_0A			 925+#
U_RSRC_0B			 924+#
U_RSRC_0Q			 923+#
U_RSRC_AB			 922+#
U_RSRC_AQ			 921+#
U_RSRC_D0			 928+#
U_RSRC_DA			 926+#
U_RSRC_DQ			 927+#
U_SCAD				1203+#	1206+	1207+	1208+	1209+	1210+	1211+	1212+	1213+
U_SCADA				1216+#	1219+	1220+	1221+	1222+	1223+	1224+	1225+	1226+
U_SCADA_BYTE1			1222+#
U_SCADA_BYTE2			1223+#
U_SCADA_BYTE3			1224+#
U_SCADA_BYTE4			1225+#
U_SCADA_BYTE5			1226+#
U_SCADA_PTR44			1221+#
U_SCADA_SC			1219+#
U_SCADA_SN			1220+#
U_SCADB				1229+#	1232+	1233+	1234+	1235+
U_SCADB_EXP			1233+#
U_SCADB_FE			1232+#
U_SCADB_SHIFT			1234+#
U_SCADB_SIZE			1235+#
U_SCAD_A			1213+#
U_SCAD_ADD			1210+#
U_SCAD_AND			1211+#
U_SCAD_A_DEC			1212+#
U_SCAD_A_MUL2			1206+#
U_SCAD_OR			1207+#
U_SCAD_SUBB			1208+#
U_SCAD_SUB			1209+#
U_SET_GENL			1034+	1254+	1287+#
U_SET_GENR			1047+	1260+	1288+#
U_SET_RSRC			 919+	1248+	1286+#
U_SET				 919+	1034+	1047+	1248+	1254+	1260+	1271+	1297+#
U_SHSTYLE			1093+#	1096+	1097+	1098+	1099+	1100+	1101+	1102+	1103+
U_SHSTYLE_ASHC			1100+#
U_SHSTYLE_DIV			1102+#
U_SHSTYLE_LSHC			1101+#
U_SHSTYLE_NORM			1096+#
U_SHSTYLE_ONES			1098+#
U_SHSTYLE_ROT			1099+#
U_SHSTYLE_ROTC			1103+#
U_SHSTYLE_ZERO			1097+#
U_SKIP				1126+#	1129+	1130+	1131+	1132+	1133+	1134+	1135+	1136+	1137+	1138+	1139+
				1140+	1141+	1142+	1143+	1144+	1145+	1146+	1147+	1148+	1149+	1150+	1151+
				1152+
U_SKIP_1_MS			1152+#
U_SKIP_AC0			1136+#
U_SKIP_ADEQ0			1147+#
U_SKIP_ADLEQ0			1132+#
U_SKIP_ADREQ0			1133+#
U_SKIP_CONTINUE			1151+#
U_SKIP_CRY0			1131+#
U_SKIP_CRY1			1144+#
U_SKIP_CRY2			1139+#
U_SKIP_DP0			1140+#
U_SKIP_DP18			1141+#
U_SKIP_EXECUTE			1149+#
U_SKIP_FPD			1135+#
U_SKIP_INT			1137+#
U_SKIP_IOLGL			1129+#
U_SKIP_IOT			1142+#
U_SKIP_IO_BUSY			1150+#
U_SKIP_JFCL			1143+#
U_SKIP_KERNEL			1134+#
U_SKIP_LE			1138+#
U_SKIP_LLE			1130+#
U_SKIP_SC			1148+#
U_SKIP_TRAP_CYC			1146+#
U_SKIP_TXXX			1145+#
U_SN				1238+#
U_SPEC				1054+#	1057+	1058+	1059+	1060+	1061+	1062+	1063+	1064+	1065+	1066+	1067+
				1068+	1069+	1070+	1071+	1072+	1073+	1074+	1075+	1076+	1077+	1078+	1079+
				1080+
U_SPEC_APRFLAGS			1067+#
U_SPEC_APR_EN			1069+#
U_SPEC_ASHOV			1076+#
U_SPEC_CLRCLK			1058+#
U_SPEC_CLRCSH			1068+#
U_SPEC_CLRIOBSY			1060+#
U_SPEC_CLRIOLAT			1059+#
U_SPEC_EXPTST			1077+#
U_SPEC_FLAGS			1078+#
U_SPEC_INHCRY18			1073+#
U_SPEC_LDACBLK			1079+#
U_SPEC_LDINST			1080+#
U_SPEC_LDPAGE			1061+#
U_SPEC_LDPI			1075+#
U_SPEC_LDPXCT			1063+#
U_SPEC_LOADIR			1074+#
U_SPEC_LOADXR			1066+#
U_SPEC_MEMCLR			1070+#
U_SPEC_N			1057+#
U_SPEC_NICOND			1062+#
U_SPEC_PREV			1065+#
U_SPEC_PXCT_OFF			1072+#
U_SPEC_SWEEP			1071+#
U_SPEC_WAIT			1064+#
U_T				1155+#
VCOL				5747#	5763#	5830	5859	5860	5867	5874	5881	5888	5895	5902	5909
				5916	5923
VROW				5746#	5763#	5830	5831	5838	5845	5852	5859	5888	5895	5902	5909
				5916	5923
VSSTR				5749#	5763#	5830	5859	5888	5895	5902	5909	5916	5923
VSTR				5748#	5763#	5830	5859	5888	5895	5902	5909	5916	5923
VTICK				14052	14106
WAIT				 498+	3141	3144	14079	14698
WHEN				15302	15481
WRITE_COMADR			 261	1645	2200	2272	2561	2639	2984	3036	3088	3148	6435	12366
				12371	12592	12597	12601	12828	12833	12851	12983	13005	13201	13213	13628
				13654	13680	13727	13786	14101	14126	14169	14459	14469	15105	15178	15187*
				15423	15490
WRITE_CONTROL			 263	2201	2274	2562	2641	6437	12368	12373	12594	12603	12830	12834
				12852	12984	13006	13203	13214	13630	13656	13682	13729	13788	14103	14127
				14170	14461	14470	15107	15247*	15425	15492
WRITE_CONTROL1			 264	12598	15275*
WRITE_DATA			 262	2273	2640	6436	12367	12372	12593	12602	12829	13202	13629	13655
				13681	13728	13787	14102	14460	15106	15217*	15424	15491
WRITE_IO			2171#	2272	6402#	6435
WRITE_MEM			2531#	2639	12329#	12371	12556#	12601	12794#	12833	12851	12951#	13005	14047#
				14126	14169
WRITE_MSR			12328#	12366	12552#	12592	12790#	12828	13141#	13201	13577#	13628	13654	13680
				13727	13786	14048#	14101	14426#	14459	15103#	15105	15343#	15423	15490
WRITE_NXM			12952#	12983
WRITE_STATUS			 258	15078*
WRT100				 532+	14830	14831
WRT102				 533+	15240
WRT103				 534+	15210
WRT104				 535+	15241
WRT105				 536+	15211
WRT106				 537+	15242
WRT107				 538+	15212
WRT110				 539+	15243
WRT111				 540+	15213
WRT112				 541+	15244
WRT113				 542+	15214
WRT114				 543+	1644	2986	3038	3090	3150	12058	15180	15270
WRT115				 544+	1643	2985	3037	3089	3149	12059	15179	15269	15297
WRT116				 545+
WRT204				 546+
WRT205				 388	 389	 547+
WRT206				 548+
WRT210				 549+	1646	2987	3039	3091	3151	12060	15181	15271	15298
WRT212				 550+
WR_CRAM				 507+
X				1054+	1055+	1083+	1084+	1093+	1094+	1106+	1107+	1126+	1127+	1155+	1156+
				1203+	1204+	1216+	1217+	1229+	1230+
X1				 508+
X1A_AC				 613+#	 737+
X1B_AC				 614+#	 738+
XMIT_ADR			1446+#	1646	2987	3039	3091	3151	12060	15181	15272	15298
XMIT_DATA			1445+#	2987	3039	3091	3151	12060	15181	15271


TIME: 38 SEC.
CORE: 21K
    