	DEFTST	MCODE1			;TELL TEST MACRO OF PROGRAM NAME

	TEST	128,WORKING MEMORY LOAD ALL ZEROS TEST

;*LOAD AND READ ALL ZEROS INTO EACH LOCATION OF WORKING MEMORY

	LDBR	1			;SET UP ADDITIONAL PRINT ROUTINE NUMBER
	MOVB	MPGP6			;IN DXGP3
	LDBR	0			;GET ZEROS
	MOVB	AC1			;PUT IN AC1 AS CORRECT DATA
	MOVB	MPGP2			;WRITE MEMORY ADDRESS
	MOVB	MPGP3			;INTO DXGP1
WMT00:	DATI	MPGP2,MAR		;SELECT MEMORY ADDRESS
	DATI	MPGP3,MARX		;FROM DXGP1
WMT01:	MOV	AC1,MEM			;WRITE DATA INTO MEMORY
	MOVMEM	AC0			;READ MEMORY, PUT INTO AC0
	MOV	AC0,BR			;READ DATA INTO BR
	OSB	AC1			;COMPARE CORRECT WITH BR
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	WMT01,CAN'T LOAD ZEROS CORRECTLY,,PNT
	DATI	MPGP2,AC0		;READ LAST ADDRESS
	JMPZ	.+2			;SKIP IF A -1
	JMP	WMT02			;NO, JUST INCREMENT LOW BITS
	DATI	MPGP3,AC2		;READ HIGH BITS INTO AC2
	LDBR	3			;PUT A 3 IN BR
	OSB	AC2			;COMPARE, SKIP IF HIGH BITS ARE ALREADY 3
	JMPZ	WMT0X			;IF HIGH BITS ALREADY 3, END THIS TEST
	INC	AC2,BR			;INCREMENT HIGH BITS
	MOVB	MPGP3			;WRITE INTO MPGP3
WMT02:	INC	AC0,BR			;INCREMENT LOW BITS
	MOVB	MPGP2			;WRITE INTO MPGP2
	JMP	WMT00			;NOW TEST THIS LOCATION

WMT0X:	REPEAT	TST
	TEST	129,WORKING MEMORY LOAD ALL ONES TEST

;*LOAD AND READ ALL ONES INTO EACH LOCATION OF WORKING MEMORY

	LDBR	-1			;GET ALL ONES
	MOVB	AC1			;PUT IN AC1 AS CORRECT DATA
	LDBR	0			;CLEAR BR
	MOVB	MPGP2			;WRITE MEMORY ADDRESS
	MOVB	MPGP3			;INTO DXGP1
WMT10:	DATI	MPGP2,MAR		;SELECT MEMORY ADDRESS
	DATI	MPGP3,MARX		;FROM DXGP1
WMT11:	MOV	AC1,MEM			;WRITE DATA INTO MEMORY
	MOVMEM	AC0			;READ MEMORY, PUT INTO AC0
	MOV	AC0,BR			;READ DATA INTO BR
	OSB	AC1			;COMPARE CORRECT WITH BR
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	WMT11,CAN'T LOAD ONES CORRECTLY,,PNT
	DATI	MPGP2,AC0		;READ LAST ADDRESS
	JMPZ	.+2			;SKIP IF A -1
	JMP	WMT12			;NO, JUST INCREMENT LOW BITS
	DATI	MPGP3,AC2		;READ HIGH BITS INTO AC2
	LDBR	3			;PUT A 3 IN BR
	OSB	AC2			;COMPARE, SKIP IF HIGH BITS ARE ALREADY 3
	JMPZ	WMT1X			;IF HIGH BITS ALREADY 3, END THIS TEST
	INC	AC2,BR			;INCREMENT HIGH BITS
	MOVB	MPGP3			;WRITE INTO MPGP3
WMT12:	INC	AC0,BR			;INCREMENT LOW BITS
	MOVB	MPGP2			;WRITE INTO MPGP2
	JMP	WMT10			;NOW TEST THIS LOCATION

WMT1X:	REPEAT	TST
	TEST	130,WORKING MEMORY LOAD OF FLOATING ONE PATTERN

;*LOAD AND READ FLOATING ONE PATTERN INTO EACH LOCATION OF WORKING MEMORY

	LDBR	0			;SET UP FOR ADDRESS 0
	MOVB	MPGP2			;WRITE MEMORY ADDRESS
	MOVB	MPGP3			;INTO DXGP1
WMT20:	LDBR	1			;GET A 1
	MOVB	AC1			;PUT IN AC1 AS CORRECT DATA
	DATI	MPGP2,MAR		;SELECT MEMORY ADDRESS
	DATI	MPGP3,MARX		;FROM DXGP1
WMT21:	MOV	AC1,MEM			;WRITE DATA INTO MEMORY
	MOVMEM	AC0			;READ MEMORY, PUT INTO AC0
	MOV	AC0,BR			;READ DATA INTO BR
	OSB	AC1			;COMPARE CORRECT WITH BR
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	WMT21,CAN'T LOAD ZEROS CORRECTLY,,PNT
	SHLR	AC1			;FLOAT BIT TO LEFT IN AC1
	JMPC	WMT23			;GO TO NEXT ADDRESS IF SHIFTED BIT OUT
	JMP	WMT21			;TEST THIS PATTERN
WMT23:	DATI	MPGP2,AC0		;READ LAST ADDRESS
	JMPZ	.+2			;SKIP IF A -1
	JMP	WMT22			;NO, JUST INCREMENT LOW BITS
	DATI	MPGP3,AC2		;READ HIGH BITS INTO AC2
	LDBR	3			;PUT A 3 IN BR
	OSB	AC2			;COMPARE, SKIP IF HIGH BITS ARE ALREADY 3
	JMPZ	WMT2X			;IF HIGH BITS ALREADY 3, END THIS TEST
	INC	AC2,BR			;INCREMENT HIGH BITS
	MOVB	MPGP3			;WRITE INTO MPGP3
WMT22:	INC	AC0,BR			;INCREMENT LOW BITS
	MOVB	MPGP2			;WRITE INTO MPGP2
	JMP	WMT20			;NOW TEST THIS LOCATION

WMT2X:	REPEAT	TST
	TEST	131,WORKING MEMORY LOAD OF FLOATING ZERO PATTERN

;*LOAD AND READ FLOATING ZERO PATTERN INTO EACH LOCATION OF WORKING MEMORY

	LDBR	0			;SET UP FOR ADDRESS 0
	MOVB	MPGP2			;WRITE MEMORY ADDRESS
	MOVB	MPGP3			;INTO DXGP1
WMT30:	LDBR	177			;GET START PATTERN
	MOVB	AC1			;PUT IN AC1 AS CORRECT DATA
	DATI	MPGP2,MAR		;SELECT MEMORY ADDRESS
	DATI	MPGP3,MARX		;FROM DXGP1
WMT31:	MOV	AC1,MEM			;WRITE DATA INTO MEMORY
	MOVMEM	AC0			;READ MEMORY, PUT INTO AC0
	MOV	AC0,BR			;READ DATA INTO BR
	OSB	AC1			;COMPARE CORRECT WITH BR
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	WMT31,CAN'T LOAD ZEROS CORRECTLY,,PNT
	MOV	AC1,BR			;MOVE PATTERN TO BR
	SHR	1			;SHIFT THE ZERO BIT RIGHT
	MOVB	AC1			;PUT NEW PATTERN INTO AC1
	JMPZ	WMT33			;GO TO NEXT ADDRESS IF ZERO SHIFTED OUT
	JMP	WMT31			;TEST THIS PATTERN
WMT33:	DATI	MPGP2,AC0		;READ LAST ADDRESS
	JMPZ	.+2			;SKIP IF A -1
	JMP	WMT32			;NO, JUST INCREMENT LOW BITS
	DATI	MPGP3,AC2		;READ HIGH BITS INTO AC2
	LDBR	3			;PUT A 3 IN BR
	OSB	AC2			;COMPARE, SKIP IF HIGH BITS ARE ALREADY 3
	JMPZ	WMT3X			;IF HIGH BITS ALREADY 3, END THIS TEST
	INC	AC2,BR			;INCREMENT HIGH BITS
	MOVB	MPGP3			;WRITE INTO MPGP3
WMT32:	INC	AC0,BR			;INCREMENT LOW BITS
	MOVB	MPGP2			;WRITE INTO MPGP2
	JMP	WMT30			;NOW TEST THIS LOCATION

WMT3X:	REPEAT	TST
	TEST	132,WORKING MEMORY ADDRESSING TEST

;*WRITE ZEROS INTO MEMORY ADDRESS 0
;*WRITE ONES INTO MEMORY ADDRESSES 1,2,4,10,20,40,100,200,400,1000
;*AFTER EACH WRITE, CHECK THAT ADDRESS 0 STILL CONTAINS ZEROS

;*WRITE ZEROS INTO MEMORY ADDRESS 1
;*WRITE ONES INTO MEMORY ADDRESSES 0,2,4,10,20,40,100,200,400,1000
;*AFTER EACH WRITE, CHECK THAT ADDRESS 1 STILL CONTAINS ZEROS

;*REPEAT AS ABOVE, TESTING MEMORY ADDRESSES 2,4,10,20,40,100,200,400,1000
;*WHILE CHANGING THE OTHER MEMORY ADDRESSES

	LDBR	2			;SET UP ADDITIONAL PRINT ROUTINE NUMBER
	MOVB	MPGP6			;PUT IN DXGP3
	LDBR	0			;GET A ZERO
	MOVB	MPGP10			;STORE ADDRESS UNDER TEST
	MOVB	MPGP11			;IN DXGP4
	MOVB	AC1			;STORE ZEROS AS CORRECT DATA
	LDBR	-1			;STORE ONES AS DATA TO WRITE
	MOVB	AC2			;IN AC2
WMA0:	LDBR	0			;GET A ZERO
	MOVB	MPGP12			;STORE ADDRESS BEING CHANGED
	MOVB	MPGP13			;IN DXGP5
WMA1:	JMPSUB	COMPARE			;COMPARE THE TWO ADDRESSES
	JMPZ	WMA3			;JUMP AROUND IF ADDRESSES ARE THE SAME
WMA2:	DATI	MPGP10,MAR		;LOAD MAR WITH
	DATI	MPGP11,MARX		;ADDRESS UNDER TEST
	MOV	AC1,MEM			;LOAD MEMORY WITH ZEROS
	DATI	MPGP12,MAR		;LOAD MAR WITH
	DATI	MPGP13,MARX		;ADDRESS TO BE CHANGED
	MOV	AC2,MEM			;WRITE ONES TO THIS MEMORY LOCATION
	DATI	MPGP10,MAR		;LOAD MAR WITH
	DATI	MPGP11,MARX		;ADDRESS UNDER TEST
	MOVMEM	AC0			;READ MEMORY CONTENTS INTO AC0
	MOV	AC0,BR			;MOVE IT TO BR
	OSB	AC1			;COMPARE WITH THE ZEROS WRITTEN
	JMPZ	.+2			;SKIP OVER ERROR IF SAME
	ERROR	WMA2,CANNOT ADDRESS ALL MEMORY LOCATIONS,,PNT
WMA3:	JMPSUB	ABC			;SHIFT LEFT THE ADDRESS BEING CHANGED
	JMPZ	WMA1			;JUMP BACK UNLESS ADDRESS OVERFLOWED
	JMPSUB	AUT			;SHIFT LEFT THE ADDRESS UNDER TEST
	JMPZ	WMA0			;RESET ADDRESS BEING CHANGED AND TEST IT
	JMP	WMAX			;GO TO END OF TEST
;SHIFT THE ADDRESS UNDER TEST IN DXGP4 LEFT
;RETURN WITH Z SET UNLESS ADDRESS OVERFLOWS MAR

AUT:	DATI	MPGP11,AC3		;READ HIGH BITS OF ADDRESS
	LDBR	2			;CHECK IF ALREADY A 2
	OSB	AC3			;COMPARE
	JMPZ	NRTN			;RETURN WITH Z BIT CLEAR
	DEC	AC3			;SUBTRACT 1 TO SEE IF ADR WAS 0
	JMPZ	AUTLOW			;IF ZERO, GO READ LOW BITS
	LDBR	2			;ADR WAS 1, MAKE IT 2
	MOVB	MPGP11			;WRITE INTO REGISTER
	RETURN	-1			;RETURN WITH Z BIT SET
AUTLOW:	DATI	MPGP10,AC4		;READ LOW BITS INTO AC4
	DEC	AC4			;SUBTRACT 1 TO SEE IF ADR WAS 0
	JMPZ	AUTZRO			;JUMP IF SO
	SHL	AC4,BR			;SHIFT ADDRESS LEFT
	MOVB	MPGP10			;WRITE NEW ADDRESS
	JMPC	.+2			;SKIP IF BIT SHIFTED OUT OF ADDRESS
	RETURN	-1			;NO, RETURN WITH Z BIT SET
	LDBR	1			;GET A 1
	MOVB	MPGP11			;WRITE AS HIGH ADDRESS BITS
	RETURN	-1			;RETURN WITH Z BIT SET
AUTZRO:	LDBR	1			;GET A 1
	MOVB	MPGP10			;WRITE AS LOW ADDRESS BIT
	RETURN	-1			;RETURN WITH Z BIT SET

;SHIFT THE ADDRESS TO BE CHANGED IN DXGP5 LEFT
;RETURN WITH Z SET UNLESS ADDRESS OVERFLOWS MAR

ABC:	DATI	MPGP13,AC3		;READ HIGH BITS OF ADDRESS
	LDBR	2			;CHECK IF ALREADY A 2
	OSB	AC3			;COMPARE
	JMPZ	NRTN			;RETURN WITH Z BIT CLEAR
	DEC	AC3			;SUBTRACT 1 TO SEE IF ADR WAS 0
	JMPZ	ABCLOW			;IF ZERO, GO READ LOW BITS
	LDBR	2			;ADR WAS 1, MAKE IT 2
	MOVB	MPGP13			;WRITE INTO REGISTER
	RETURN	-1			;RETURN WITH Z BIT SET
ABCLOW:	DATI	MPGP12,AC4		;READ LOW BITS INTO AC4
	DEC	AC4			;SUBTRACT 1 TO SEE IF ADR WAS 0
	JMPZ	ABCZRO			;JUMP IF SO
	SHL	AC4,BR			;SHIFT ADDRESS LEFT
	MOVB	MPGP12			;WRITE NEW ADDRESS
	JMPC	.+2			;SKIP IF BIT SHIFTED OUT OF ADDRESS
	RETURN	-1			;NO, RETURN WITH Z BIT SET
	LDBR	1			;GET A 1
	MOVB	MPGP13			;WRITE AS HIGH ADDRESS BITS
	RETURN	-1			;RETURN WITH Z BIT SET
ABCZRO:	LDBR	1			;GET A 1
	MOVB	MPGP12			;WRITE AS LOW ADDRESS BIT
	RETURN	-1			;RETURN WITH Z BIT SET

;COMPARE THE ADDRESS UNDER TEST WITH THE ADDRESS
;BEING CHANGED, RETURN WITH Z SET IF THEY COMPARE

COMPARE:DATI	MPGP10,AC3		;READ LOW BITS
	DATI	MPGP12,BR		;OF EACH ADDRESS
	OSB	AC3			;COMPARE
	JMPZ	.+2			;SKIP IF THEY COMPARE
	RETURN				;NO, RETURN WITH Z CLEAR
	DATI	MPGP11,AC3		;READ HIGH BITS
	DATI	MPGP13,BR		;OF EACH ADDRESS
	OSB	AC3			;COMPARE
	JMPZ	ZRTN			;IF THEY MATCH, RETURN WITH Z BIT SET
	RETURN				;NO, RETURN WITH Z BIT CLEAR

WMAX:	REPEAT	TST
	LDBR	0			;GET A ZERO
	MOVB	MPGP6			;CLEAR ADDITIONAL MESSAGE INDEX
	TEST	133,DATA BUFFER 0 TEST (MPDB0)
;*WRITE ZEROS INTO DATA BUFFER
;*READ AND CHECK FOR ZEROS

	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	0			;GET ZERO DATA
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB0			;WRITE ZEROS TO MPDB0
	DATI	MPDB0,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE DATA WITH ZEROS
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	TST,CAN'T WRITE ZEROS INTO REGISTER MPDB0

;*WRITE ONES INTO DATA BUFFER
;*READ AND CHECK FOR ONES

DB01:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	-1			;GET ONES DATA
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB0			;WRITE ONES INTO MPDB0
	DATI	MPDB0,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE DATA WITH ONES
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	DB01,CAN'T WRITE ONES INTO REGISTER MPDB0

;*WRITE A FLOATING ONE PATTERN THROUGH THE DATA BUFFER
;*READ AND COMPARE DATA

	LDBR	1			;GET A 1 AS FIRST DATA PATTERN
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
DB0F11:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	MOV	AC1,BR			;GET THE DATA PATTERN FROM AC1
	MOVB	MPDB0			;WRITE DATA INTO MPDB0
	DATI	MPDB0,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE DATA WITH CORRECT
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	DB0F11,CAN'T WRITE INTO REGISTER MPDB0 CORRECTLY
	SHLR	AC1			;SHIFT DATA BIT TO LEFT
	JMPC	.+2			;DID BIT SHIFT OUT TO CARRY BIT?
	JMP	DB0F11			;NO, GO TEST THIS PATTERN

;*WRITE A FLOATING ZERO PATTERN THROUGH THE DATA BUFFER
;*READ AND COMPARE DATA

	LDBR	177			;GET START PATTERN
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
DB0F0:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	MOV	AC1,BR			;GET PATTERN
	MOVB	MPDB0			;WRITE DATA INTO MPDB0
	DATI	MPDB0,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE WITH CORRECT
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	DB0F0,CAN'T WRITE INTO REGISTER MPDB0 CORRECTLY
	MOV	AC1,BR			;GET LAST DATA PATTERN
	SHR	1			;SHIFT THE ZERO BIT RIGHT
	MOVB	AC1			;PUT NEW PATTERN INTO AC1
	JMPZ	.+2			;SKIP IF THE ZERO BIT WAS SHIFTED OUT
	JMP	DB0F0			;NO, TEST WITH THIS PATTERN
	REPEAT	TST
	TEST	134,DATA BUFFER 1 TEST (MPDB1)
;*WRITE ZEROS INTO DATA BUFFER
;*READ AND CHECK FOR ZEROS

	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	0			;GET ZERO DATA
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB1			;WRITE ZEROS TO MPDB1
	DATI	MPDB1,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE DATA WITH ZEROS
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	TST,CAN'T WRITE ZEROS INTO REGISTER MPDB1

;*WRITE ONES INTO DATA BUFFER
;*READ AND CHECK FOR ONES

DB11:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	-1			;GET ONES DATA
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB1			;WRITE ONES INTO MPDB1
	DATI	MPDB1,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE DATA WITH ONES
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	DB11,CAN'T WRITE ONES INTO REGISTER MPDB1

;*WRITE A FLOATING ONE PATTERN THROUGH THE DATA BUFFER
;*READ AND COMPARE DATA

	LDBR	1			;GET A 1 AS FIRST DATA PATTERN
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
DB1F11:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	MOV	AC1,BR			;GET THE DATA PATTERN FROM AC1
	MOVB	MPDB1			;WRITE DATA INTO MPDB1
	DATI	MPDB1,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE DATA WITH CORRECT
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	DB1F11,CAN'T WRITE INTO REGISTER MPDB1 CORRECTLY
	SHLR	AC1			;SHIFT DATA BIT TO LEFT
	JMPC	.+2			;DID BIT SHIFT OUT TO CARRY BIT?
	JMP	DB1F11			;NO, GO TEST THIS PATTERN

;*WRITE A FLOATING ZERO PATTERN THROUGH THE DATA BUFFER
;*READ AND COMPARE DATA

	LDBR	177			;GET START PATTERN
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
DB1F0:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	MOV	AC1,BR			;GET PATTERN
	MOVB	MPDB1			;WRITE DATA INTO MPDB1
	DATI	MPDB1,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE WITH CORRECT
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	DB1F0,CAN'T WRITE INTO REGISTER MPDB1 CORRECTLY
	MOV	AC1,BR			;GET LAST DATA PATTERN
	SHR	1			;SHIFT THE ZERO BIT RIGHT
	MOVB	AC1			;PUT NEW PATTERN INTO AC1
	JMPZ	.+2			;SKIP IF THE ZERO BIT WAS SHIFTED OUT
	JMP	DB1F0			;NO, TEST WITH THIS PATTERN
	REPEAT	TST
	TEST	135,DATA BUFFER 2 TEST (MPDB2)

;*INITIALIZE THE DX20
;*WRITE ZEROS TO MPDB2
;*READ AND CHECK FOR ZERO

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	0			;GET ZERO DATA
	MOVB	AC1			;PUT IN AC1 AS CORRECT DATA
	MOVB	MPDB2			;WRITE TO REGISTER MPDB2
	DATI	MPDB2,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE WITH ZERO DATA
	JMPZ	.+2			;JUMP AROUND IF ALL ZEROS READ
	ERRORA	TST,CAN'T WRITE ZEROS TO REGISTER MPDB2

;*WRITE DB16, DB17 AND PARITY BIT TO ONE
;*READ AND CHECK FOR ONES

DB21:	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	7			;GET BITS FOR DB16, DB17 AND PARITY
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB2			;WRITE INTO REGISTER MPDB2
	DATI	MPDB2,AC0		;READ THE DATA BACK
	OSB	AC0			;COMPARE WITH DATA WRITTEN
	JMPZ	.+2			;JUMP AROUND IF A MATCH
	ERRORA	DB21,CAN'T WRITE ONES INTO DB16, DB17 AND PARITY BITS

;*SET EACH OF DB16, DB17 AND PARITY BITS TO ONE
;*READ AND CHECK DATA

DB216:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	1			;GET BIT FOR DB16
	MOV	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB2			;WRITE INTO REGISTER MPDB2
	DATI	MPDB2,AC0		;READ DATA BACK
	OSB	AC0			;COMPARE WITH CORRECT DATA
	JMPZ	.+2			;SKIP IF CORRECT
	ERRORA	DB216,CAN'T WRITE ONLY DB16 IN REGISTER MPDB2
DB217:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	2			;GET BIT FOR DB17
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB2			;WRITE INTO REGISTER MPDB2
	DATI	MPDB2,AC0		;READ IT BACK
	OSB	AC0			;COMPARE WITH CORRECT DATA
	JMPZ	.+2			;SKIP IF CORRECT
	ERRORA	DB217,CAN'T WRITE ONLY DB17 IN REGISTER MPGP2

DB2P:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	4			;GET BIT FOR DB PARITY
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB2			;WRITE INTO REGISTER MPDB2
	DATI	MPDB2,AC0		;READ IT BACK
	OSB	AC0			;COMPARE WITH CORRECT DATA
	JMPZ	.+2			;SKIP IF CORRECT
	ERRORA	DB2P,CAN'T WRITE ONLY PARITY BIT INTO REGISTER MPDB2

;*WRITE EVEN PARITY BIT TO ONE
;*READ AND CHECK FOR ONE

DB2EV:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	DBEVEN			;GET EVEN PARITY BIT
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	MOVB	MPDB2			;WRITE INTO REGISTER MPDB2
	DATI	MPDB2,AC0		;READ IT BACK
	MOV	AC0,BR			;COPY TO BR
	JMPB4	.+2			;SKIP IF READ A ONE
	ERRORA	DB2EV,CAN'T WRITE EVEN PARITY BIT IN REGISTER MPDB2

;*WITH EVEN PARITY BIT A ONE, WRITE PARITY BIT TO A ONE
;*READ AND CHECK PARITY BIT FOR ZERO

	LDBR	DBEVEN+DBPAR		;GET PARITY BIT
	MOVB	MPDB2			;WRITE INTO REGISTER MPDB2
	DATI	MPDB2,AC0		;READ DATA BUFFER
	MOV	AC0,BR			;GET THE DATA READ
	OSB	AC1			;COMPARE WITH CORRECT DATA IN AC1
	JMPZ	.+2			;SKIP IF A MATCH
	ERRORA	DB2EV,EVEN PARITY BIT DID NOT CAUSE PARITY BIT TO BE COMPLIMENTED,<
WRITING PARITY BIT TO A ONE SHOULD HAVE STORED A ZERO WITH
EVEN PARITY SET>

;*WITH EVEN PARITY BIT A ONE, WRITE PARITY BIT TO A ZERO
;*READ AND CHECK PARITY BIT FOR A ONE

	LDBR	DBEVEN			;GET EVEN PARITY BIT
	MOVB	MPDB2			;WRITE PARITY BIT TO A ZERO
	LDBR	DBEVEN+DBPAR		;SET UP EXPECTED DATA
	MOVB	AC1			;OF PARITY BIT A ONE
	DATI	MPDB2,AC0		;READ REGISTER
	OSB	AC0			;COMPARE WITH EXPECTED DATA
	JMPZ	.+2			;SKIP IF A MATCH
	ERRORA	DB2EV,EVEN PARITY BIT DID NOT CAUSE PARITY BIT TO BE COMPLIMENTED,<
WRITING PARITY BIT A ZERO SHOULD HAVE STORED A ONE WITH
EVEN PARITY SET>

;*INITIALIZE THE DX20
;*READ MPDB2
;*CHECK EVEN PARITY BIT FOR ZERO

	JMPSUB	INITLL			;INITIALIZE THE DX20
	DATI	MPDB2,BR		;READ DATA REGISTER
	JMPB4	.+2			;SKIP IF EVEN PARITY IS SET
	JMP	.+2			;NO, SKIP OVER ERROR
	ERROR	DB2EV,INITIALIZE WILL NOT CLEAR EVEN PARITY BIT

	REPEAT	TST
	TEST	136,DATA BUFFER SELECTION TEST

;*WRITE ZEROS TO MPDB2
;*WRITE ONES TO MPDB1 & MPDB0
;*READ MPDB2 AND CHECK FOR ZEROS

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	0			;GET ZERO DATA
	MOVB	AC1			;SAVE AS CORRECT DATA
	MOVB	MPDB2			;WRITE ZEROS TO MPDB2
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB1			;WRITE INTO MPDB1
	MOVB	MPDB0			;AND MPDB0
	DATI	MPDB2,AC0		;READ DATA IN MPDB2
	MOV	AC0,BR			;MOVE TO BR
	OSB	AC1			;COMPARE WITH DATA WRITTEN
	JMPZ	.+2			;SKIP IF CORRECT
	ERRORA	TST,CAN'T SELECT REGISTER MPDB2,
WRITING INTO REGISTERS MPDB1 AND MPDB0 CHANGED CONTENTS OF MPDB2

;*WRITE ZEROS INTO MPDB1
;*WRITE ONES INTO MPDB0 AND A 7 INTO MPDB2
;*READ MPDB1 AND CHECK FOR ZEROS

DBST1:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	0			;GET ZERO DATA
	MOVB	MPDB1			;WRITE INTO MPDB1
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB0			;WRITE ONES INTO MPDB0
	LDBR	7			;GET A 7
	MOVB	MPDB2			;WRITE INTO MPDB2
	DATI	MPDB1,AC0		;READ CONTENTS OF MPDB1
	MOV	AC0,BR			;MOVE DATA TO BR
	OSB	AC1			;COMPARE WITH ZEROS
	JMPZ	.+2			;SKIP IF A MATCH
	ERRORA	DBST1,CAN'T SELECT MPDB1,
WRITING INTO REGISTERS MPDB0 AND MPDB2 CHANGED CONTENTS OF MPDB1

;*WRITE ZEROS INTO REGISTER MPDB0
;*WRITE ONES INTO MPDB1 AND A 7 INTO MPDB2
;*READ MPDB0 AND CHECK FOR ZEROS

DBST2:	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SET OCCUPIED IN STATUS REGISTER
	LDBR	0			;GET ZERO DATA
	MOVB	MPDB0			;WRITE INTO MPDB0
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB1			;WRITE INTO MPDB1
	LDBR	7			;GET A 7
	MOVB	MPDB2			;WRITE INTO MPDB2
	DATI	MPDB0,AC0		;READ CONTENTS OF MPDB0
	MOV	AC0,BR			;MOVE TO BR
	OSB	AC1			;COMPARE DATA WITH ZEROS
	JMPZ	.+2			;SKIP IF A MATCH
	ERRORA	DBST2,CAN'T SELECT REGISTER MPDB0,
WRITING INTO MPDB1 AND MPDB2 CHANGED CONTENTS OF MPDB0
	REPEAT	TST
	TEST	137,EBL AND TRANSFER DONE TEST

;*INITIALIZE THE DX20
;*SET EBL IN MPSCR1
;*READ MPSCR1 , CHECK THAT DONE IS SET

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;WRITE THE EBL BIT IN MPSCR1
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	JMPSUB	STALL0			;STALL AT LEAST 1500 NS FOR EBL DURATION
	DATI	MPSCR1,AC0		;READ THE REGISTER
	MOV	AC0,BR			;MOVE DATA TO BR
	JMPB0	.+2			;SKIP IF DONE IS SET
	ERRORA	TST,SETTING EBL BIT IN MPSCR1 DID NOT CAUSE DONE TO SET

;*INITIALIZE THE DX20
;*READ MPSCR1, CHECK THAT DONE IS CLEAR

	JMPSUB	INITLL			;INITIALIZE THE DX20
	DATI	MPSCR1,AC0		;READ MPSCR1
	LDBR	0			;GET ZERO DATA
	MOVB	AC1			;PUT IN AC1 AS CORRECT DATA
	MOV	AC0,BR			;GET DATA READ INTO BR
	JMPB0	.+2			;SKIP IF DONE IS STILL SET
	JMP	.+2			;NO, SKIP OVER ERROR
	ERRORA	TST,INITIALIZE DID NOT CLEAR DONE BIT IN MPSCR1

;*INITIALIZE THE DX20
;*SET EBL TO SET DONE
;*SET START IN MPSCR1
;*READ MPSCR1, CHECK THAT DONE IS CLEAR

EBL0:	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1 TO SET DONE
	JMPSUB	STALL0			;STALL FOR DURATION OF EBL PULSE
	LDBR	START			;GET START BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1, SHOULD CLEAR DONE
	DATI	MPSCR1,AC0		;READ MPSCR1
	MOV	AC0,BR			;MOVE DATA TO BR
	JMPB0	.+2			;SKIP IF DONE IS SET
	JMP	.+2			;NO, SKIP OVER ERROR
	ERRORA	EBL0,SETTING START IN MPSCR1 DID NOT CLEAR DONE
	REPEAT	TST
	TEST	138,EXCEPTION TEST

;*INITIALIZE THE DX20
;*SET ILF IN MPSCR1
;*READ MPSCR1
;*CHECK THAT TRA EXC IS NOT SET

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	ILF			;GET ILF BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1
	DATI	MPSCR1,AC0		;READ MPSCR1
	LDBR	ILF+CMPERR		;GET EXPECTED RESULT OF ILF AND COMP ERR
	MOVB	AC1			;SAVE AS CORRECT DATA
	MOV	AC0,BR			;MOVE DATA TO BR
	OSB	AC1			;COMPARE DATA READ WITH ILF BIT
	JMPZ	.+2			;SKIP IF NO OTHER BITS ARE SET
	ERRORA	TST,SETTING ILF WITH OCC=0 CAUSED EXC TO SET IN MPSCR1

;*INITIALIZE THE DX20
;*SET OCC IN MPSCR1
;*SET ILF
;*READ MPSCR1
;*CHECK THAT EXC IS SET

EXC0:	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1
	LDBR	ILF+OCC			;GET ILF BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1
	LDBR	ILF+OCC+EXC+CMPERR	;GET EXPECTED RESULT
	MOVB	AC1			;SAVE IN AC1
	DATI	MPSCR1,AC0		;READ REGISTER
	MOV	AC0,BR			;MOVE DATA TO BR
	OSB	AC1			;COMPARE WITH EXPECTED RESULT
	JMPZ	.+2			;SKIP IF A MATCH
	ERRORA	EXC0,SETTING ILF WHILE OCC=1 SHOULD SET EXC IN MPSCR1,
EXC DID NOT SET

;*INITIALIZE THE DX20
;*CHECK THAT EXC IS CLEAR

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	ILF+CMPERR		;GET EXPECTED RESULT OF ZERO
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	DATI	MPSCR1,AC0		;READ MPSCR1
	MOV	AC0,BR			;MOVE DATA TO BR
	OSB	AC1			;COMPARE RESULT
	JMPZ	.+2			;SKIP IF A MATCH
	ERRORA	EXC0,INITIALIZE DID NOT CLEAR EXC IN MPSCR1

;*INITIALIZE THE DX20
;*SET OCC
;*SET ILF
;*SET EBL
;*READ MPSCR1
;*CHECK THAT EXC IS NOT SET

EXC1:	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	OCC			;GET OCC BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1
	LDBR	ILF+OCC			;GET ILF BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1
	LDBR	EBL+ILF+OCC		;GET EBL BIT
	MOVB	MPSCR1			;WRITE INTO MPSCR1
	LDBR	ILF+CMPERR+OCC+DONE	;GET EXPECTED RESULT
	MOVB	AC1			;SAVE IN AC1 AS CORRECT DATA
	JMPSUB	STALL0			;STALL FOR DURATION OF EBL PULSE
	DATI	MPSCR1,AC0		;READ MPSCR1
	MOV	AC0,BR			;MOVE TO BR
	OSB	AC1			;COMPARE WITH EXPECTED RESULT
	JMPZ	.+2			;SKIP IF A MATCH
	ERRORA	EXC1,EXC WAS SET BY OCC AND ILF,<EBL WAS THEN SET
EBL SHOULD HAVE CLEARED THE EXC BUT IT DID NOT>
	REPEAT	TST
	TEST	139,RECEIVE RUN TEST

;*INITIALIZE THE DX20
;*SET UP FOR A DEVICE READ TRANSFER
;*CHECK THAT RUN IS RECEIVED

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	1			;GET A ONE
	MOVB	MPGP11			;SET UP FOR A ONE BLOCK TRANSFER
	MOVB	MPGP2			;SET UP FOR A ONE WORD TRANSFER
	LDBR	0			;GET A ZERO
	MOVB	MPGP3			;CLEAR THE HIGH ORDER BITS OF WORD COUNT
	MOVB	MPGP10			;CLEAR DATA PATTERN INDEX
	READ				;SET UP THE RH20 FOR A READ TRANSFER
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	GOSUB	RUNWAT			;WAIT FOR RUN TO SET
	DATI	MPSCR0,BR		;READ THE RUN BIT
	JMPB0	.+3			;JUMP AROUND IF RUN IS SET
	JMPSUB	INITLL			;INITIALIZE THE DX20
	ERROR	TST,<RUN WAS NOT RECEIVED FROM RH20 AFTER A READ
COMMAND WAS ISSUED AND LOADED INTO THE DX20>
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL0			;STALL FOR DURATION OF EBL PULSE
	DATI	MPSCR0,BR		;READ THE RUN BIT
	JMPB0	.+2			;JUMP IF RUN IS CLEAR
	JMP	.+2			;NO, GO AROUND ERROR
	ERROR	TST,<RUN DID NOT CLEAR WHEN EBL WAS SENT TO THE RH20
DURING A READ TRANSFER OF ONE BLOCK>
	REPEAT	TST
	TEST	140,DEVICE READ TEST

;*INITIALIZE THE DX20
;*SET UP FOR A ONE WORD DEVICE READ TRANSFER OF ALL ONES
;*SET OCCUPIED
;*CHECK THAT RUN IS SET
;*SET START
;*SET START AGAIN
;*SET EBL
;*CHECK THAT DONE IS SET
;*CLEAR OCCUPIED
;*CHECK THAT RH20 TERMINATED WITH NO ERROR

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	2			;GET A TWO
	MOVB	MPGP10			;LOAD PATTERN CODE INDEX WITH A TWO
	LDBR	1			;GET A ONE
	MOVB	MPGP11			;LOAD BLOCK COUNT WITH A ONE
	READ				;SET UP FOR A ONE WORD READ TRANSFER
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCC TO RH20
	GOSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB0			;LOAD THE DATA BUFFER
	MOVB	MPDB1
	LDBR	3
	MOVB	MPDB2
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND SCLK TO THE RH20
	JMPSUB	STALL0			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND ANOTHER SCLK
	NOP				;DELAY EBL
	JMP	.+1			;AT LEAST 1200 NS
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL0			;STALL FOR DURATION OF EBL PULSE
	DATI	MPSCR1,BR		;READ STATUS
	JMPB0	.+2			;JUMP IF DONE IS SET
	ERROR	TST,<DONE DID NOT SET AFTER COMPLETING A READ TRANSFER
OF ONE WORD AND SENDING EBL TO RH20>

	CHKTRM	TST,<ERROR STATUS SET WHEN ATTEMPTING TO PERFORM A
ONE WORD READ OPERATION>
	REPEAT	TST
	TEST	141,DEVICE READ DATA TEST

;*SET UP FOR A FOUR WORD DEVICE READ TRANSFER
;*SEND FOUR 36-BIT WORDS AS FOLLOWS:
;*	000000 000000
;*	777777 777777
;*	777777 000000
;*	000000 777777
;*TERMINATE AND CHECK FOR NO ERRORS

	JMPSUB	INITLL			;INITIALIZE THE DX20
	LDBR	3			;GET DATA PATTERN INDEX OF 3
	MOVB	MPGP10			;PUT IN REGISTER TO TELL HOST
	LDBR	4			;GET A WORD COUNT OF 4
	MOVB	MPGP2			;PUT IN REGISTER TO TELL HOST
	READ				;SET UP RH20 FOR A READ OPERATION
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	GOSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	0			;GET DATA OF ZERO
	MOVB	MPDB0			;CLEAR THE DATA BUFFER
	MOVB	MPDB1
	MOVB	MPDB2			;ALL 18 BITS
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND FIRST HALF OF FIRST WORD
	JMPSUB	STALL0			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND LAST HALF OF FIRST WORD
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB0			;SET ALL DATA BITS IN DATA BUFFER
	MOVB	MPDB1
	LDBR	3			;ALL 18 BITS
	MOVB	MPDB2			;LOAD 17 & 16
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND FIRST HALF OF SECOND WORD
	JMPSUB	STALL0			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND LAST HALF OF SECOND WORD
	JMPSUB	STALL0			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND FIRST HALF OF THIRD WORD
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	0			;GET ZERO DATA
	MOVB	MPDB0			;CLEAR ALL BITS IN DATA BUFFER
	MOVB	MPDB1
	MOVB	MPDB2			;ALL 18 BITS
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND LAST HALF OF THIRD WORD
	JMPSUB	STALL0			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND FIRST HALF OF FOURTH WORD
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB0			;SET ALL BITS IN DATA BUFFER
	MOVB	MPDB1
	LDBR	3			;ALL 18 BITS
	MOVB	MPDB2
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND LAST HALF OF FOURTH WORD
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL0			;STALL FOR DURATION OF EBL PULSE
	DATI	MPSCR1,BR		;READ DONE BIT
	JMPB0	.+2			;JUMP AROUND IF DONE IS SET
	ERROR	TST,<DONE DID NOT SET AFTER PERFORMING A
FOUR WORD READ TRANSFER AND THEN SENDING EBL TO RH20>
	CHKTRM	TST,<ERROR SET WHILE TRANSFERRING FOUR WORDS OF DATA
IN DEVICE READ TRANSFER>
	REPEAT	TST
	JUMP	BANK1			;GO TO NEXT BANK OF CRAM

INITLL:	JUMP	INITL			;GO TO INITIALIZE ROUTINE IN BANK 1

STALL0:	DATI	MPSCR1			;EXECUTE THREE DATI INSTRUCTIONS
	DATI	MPSCR1			; TO STALL AT LEAST 1500 NS
	DATI	MPSCR1			; FOR EBL PULSE DURATION
	RETURN				;ACTUAL DELAY IS 1830 NS.

	.LOC	2000
BANK1:
	TEST	142,DEVICE READ FLOATING ONE TEST

;*SET UP FOR A 9 WORD DEVICE READ TRANSFER
;*SEND DATA AS FOLLOWS:
;*	000001 000002
;*	000004 000010
;*	000020 000040
;*	000100 000200
;*	000400 001000
;*	002000 004000
;*	010000 020000
;*	040000 100000
;*	200000 400000
;*TERMINATE AND CHECK FOR NO ERRORS

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	^D9			;GET A 9
	MOVB	MPGP2			;PUT IN REGISTER FOR A 9 WORD TRANSFER
	LDBR	4			;SET UP FOR DATA PATTERN INDEX OF 4
	MOVB	MPGP10			;A FLOATING ONE PATTERN IN 18-BIT WORD
	READ				;REQUEST HOST TO START A READ TRANSFER IN RH20
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	0			;GET A ZERO DATA WORD
	MOVB	MPDB1			;CLEAR HIGH BITS OF DATA BUFFER
	MOVB	MPDB2			;INCLUDING BITS 16 AND 17
	LDBR	1			;GET START BIT IN FLOAT ONE PATTERN
DBF1T0:	MOVB	MPDB0			;PUT DATA PATTERN INTO BUFFER
	MOVB	AC2			;SAVE CURRENT PATTERN IN AC2
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND SCLK TO RH20
	SHL	AC2,BR			;SHIFT DATA LEFT ONE PLACE
	JMPC	.+2			;SKIP IF BIT SHIFTED OUT
	JMP	DBF1T0			;NO, SEND ANOTHER BYTE TO RH20
	NOP				;GUARANTEE 1200NS FOR SCLK
	MOVB	MPDB0			;CLEAR LOW BITS OF DATA BUFFER
	LDBR	1			;GET BIT 0 AGAIN
DBF1T1:	MOVB	MPDB1			;PUT DATA PATTERN INTO BUFFER BITS 8-15
	MOVB	AC2			;SAVE CURRENT PATTERN IN AC2
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND SCLK TO RH20
	SHL	AC2,BR			;SHIFT DATA LEFT ONE PLACE
	JMPC	.+2			;SKIP IF BIT SHIFTED OUT
	JMP	DBF1T1			;NO, SEND ANOTHER BYTE TO RH20
	NOP				;GUARANTEE 1200NS FOR SCLK
	MOVB	MPDB1			;CLEAR DATA BUFFER BIT 15
	LDBR	1			;GET BIT 16
	MOVB	MPDB2			;SET IT
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND SCLK TO RH20
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	2			;GET DATA BUFFER BIT 17
	MOVB	MPDB2			;SET IT
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND SCLK TO RH20
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	EBL			;GET EBL
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKTRM	TST,<ERROR SET WHEN ATTEMPTING TO TRANSFER A 9 WORD
FLOATING ONE PATTERN IN DEVICE READ OPERATION>
	REPEAT	TST
	TEST	143,DEVICE READ SHORT RECORD TEST

;*SET UP FOR A 9 WORD DEVICE READ TRANSFER
;*SEND ONE WORD OF ALL ONES
;*TERMINATE AND CHECK FOR AN ERROR

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	^D9			;GET A WORD COUNT OF 9
	MOVB	MPGP2			;PUT IN REGISTER FOR HOST
	READ				;SET UP RH20 FOR A READ TRANSFER
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB0			;SET ALL BITS IN
	MOVB	MPDB1			;DATA BUFFER
	LDBR	3			;GET LAST 2 BITS
	MOVB	MPDB2			;SET DATA BUFFER BITS 16 AND 17
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND ONE SCLK
	JMPSUB	STALL1			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND SECOND SCLK
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKERR	TST,<SENT ONLY ONE WORD WHEN RH20 WAS SET UP TO
EXPECT 9 WORDS IN DEVICE READ TRANSFER>, BUT NO LENGTH ERROR SET
	REPEAT	TST
	TEST	144,DEVICE READ LONG RECORD TEST

;*SET UP FOR A ONE WORD DEVICE READ TRANSFER
;*SEND TWO WORDS OF ALL ONES
;*TERMINATE AND CHECK FOR AN ERROR

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	1			;GET A WORD COUNT OF 1
	MOVB	MPGP2			;PUT IN REGISTER FOR HOST
	READ				;SET UP FOR A DEVICE READ TRANSFER
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	-1			;GET ONES DATA
	MOVB	MPDB0			;SET ALL DATA BUFFER BITS
	MOVB	MPDB1
	LDBR	3			;GET BITS FOR 16 AND 17
	MOVB	MPDB2			;SET BITS 16 AND 17
	LDBR	OCC+START		;GET START BIT
	MOVB	MPSCR1			;SEND ONE SCLK
	JMPSUB	STALL1			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND SECOND SCLK
	JMPSUB	STALL1			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND THIRD SCLK
	JMPSUB	STALL1			;STALL 1700 NANOSECONDS
					; MINIMUM BEFORE SENDING
					; NEXT SCLK
	MOVB	MPSCR1			;SEND FOURTH SCLK
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKERR	TST,<SENT TWO WORDS TO RH20 IN DEVICE READ TRANSFER WHEN
RH20 WAS EXPECTING ONLY ONE WORD>, BUT NO LENGTH ERROR SET
	REPEAT	TST
	TEST	145,MULTIPLE BLOCK DEVICE READ TRANSFER

;*SET UP FOR TWO 4 WORD DEVICE READ TRANSFERS
;*SEND 4 WORDS OF ALL ZEROS
;*SEND EBL
;*CHECK THAT DONE DOES NOT SET
;*SEND 4 WORDS OF ALL ONES
;*SEND EBL
;*CHECK THAT DONE DOES SET
;*TERMINATE AND CHECK FOR NO ERRORS

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	^D8			;GET A WORD COUNT OF 8
	MOVB	MPGP2			;WRITE INTO REGISTER FOR HOST
	LDBR	2			;GET A BLOCK COUNT OF 2
	MOVB	MPGP11			;WRITE INTO REGISTER FOR HOST
	LDBR	0			;GET A ZERO DATA PATTERN INDEX
	MOVB	MPGP10			;WRITE INTO REGISTER FOR HOST
	READ				;SET UP FOR TWO 4-WORD TRANSFERS
	LDBR	OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	0			;GET ZERO DATA
	MOVB	MPDB0			;CLEAR ALL DATA BUFFER BITS
	MOVB	MPDB1
	MOVB	MPDB2
	LDBR	^D8-1			;GET BYTE COUNT -1
	MOVB	AC2			;SAVE IN AC2
	LDBR	OCC+START		;GET START BIT
BLK1:	MOVB	MPSCR1			;SEND AN SCLK TO THE RH20
	DATI	MPSCR1			;STALL
	DECR	AC2			;DECREMENT COUNT OF BYTES TO SEND
	JMPZ	.+2			;SKIP IF COUNT WENT TO -1
	JMP	BLK1			;NO, SEND MORE BYTES
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	OCC+EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	DATI	MPSCR1,BR		;GET DONE BIT
	JMPB0	.+2			;SKIP IF DONE IS SET
	JMP	.+2			;SHOULD NOT SET NOW
	ERROR	TST,STARTED A TWO BLOCK DEVICE READ TRANSFER,<BUT DONE
SET IN STATUS REGISTER AFTER THE FIRST EBL PULSE>

	LDBR	-1			;GET ONES DATA
	MOVB	MPDB0			;SET ALL DATA BITS
	MOVB	MPDB1			;IN DATA BUFFER
	LDBR	3			;GET LAST TWO BITS
	MOVB	MPDB2			;SET DATA BITS 16 AND 17
	LDBR	^D8-1			;GET COUNT OF BYTES TO SEND TO RH20
	MOVB	AC2			;SAVE COUNT IN AC2
	LDBR	OCC+START		;GET START BIT
BLK2:	MOVB	MPSCR1			;SEND AN SCLK TO RH20
	DATI	MPSCR1			;STALL
	DECR	AC2			;DECREMENT COUNT OF BYTES
	JMPZ	.+2			;SKIP IF COUNT WENT TO -1
	JMP	BLK2			;NO, SEND ANOTHER BYTE
	NOP				;GUARANTEE 1200 NS
	JMP	.+1			;FOR SCLK
	LDBR	EBL			;GET EBL
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	DATI	MPSCR1,BR		;READ STATUS REGISTER
	JMPB0	.+2			;SKIP IF DONE SET NOW
	ERROR	TST,<DONE DID NOT SET IN STATUS REGISTER AFTER SECOND
EBL IN A TWO BLOCK DEVICE READ TRANSFER>
	CHKTRM	TST,<ERROR SET WHEN ATTEMPTING TO READ A TWO BLOCK
TRANSFER OF 4 WORDS PER BLOCK>
	REPEAT	TST
	TEST	146,DEVICE WRITE TEST

;*SET UP FOR A ONE WORD DEVICE WRITE TRANSFER OF ALL ONES DATA
;*CHECK THAT WCLK SETS AFTER REQUESTING EACH 18-BIT WORD BY
;*  SETTING START IN REGISTER MPSCR1
;*TERMINATE AND CHECK FOR NO ERRORS

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	1			;SET UP A WORD COUNT OF 1
	MOVB	MPGP2			;WRITE INTO REGISTER FOR HOST
	MOVB	MPGP11			;SET BLOCK COUNT OF 1 FOR HOST
	LDBR	2			;GET PATTERN NUMBER FOR ONES DATA
	MOVB	MPGP10			;WRITE INTO REGISTER FOR HOST
	WRITE				;SET UP FOR A DEVICE WRITE TRANSFER
	LDBR	OCC+DTD			;SET OCCUPIED AND DIRECTION BIT
	MOVB	MPSCR1			;SEND TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	OCC+START+DTD		;GET START BIT
	MOVB	MPSCR1			;SEND AN SCLK TO RH20
	NOP				;GUARANTEE 1200 NS
	NOP
	NOP
	NOP
	DATI	MPSCR0,BR		;READ STATUS BITS
	JMPB7	.+2			;SKIP IF WCLK SET
	JMP	WCLKT1			;NO, GO AROUND
	LDBR	OCC+START+DTD		;GET START BIT
	MOVB	MPSCR1			;SEND TO RH20
	NOP				;GUARANTEE 1200 NS
	NOP
	NOP
	NOP
	DATI	MPSCR0,BR		;READ STATUS BITS
	JMPB7	.+3			;JUMP AROUND IF WCLK IS SET
WCLKT1:	JMPSUB	INITL			;INITIALIZE THE DX20
	ERROR	TST,<WCLK DID NOT SET IN REGISTER MPSCR0 AFTER SENDING
AN SCLK TO RH20 DURING A DEVICE WRITE TRANSFER>

	LDBR	EBL			;SET EBL AND CLEAR OCCUPIED
	MOVB	MPSCR1			;TELL RH20 TO TERMINATE
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKTRM	TST,<ATTEMPTED A ONE WORD DEVICE WRITE TRANSFER
BUT AN ERROR SET IN THE RH20>

;*INITIALIZE THE DX20 AND CHECK THAT WCLK CLEARED

	JMPSUB	INITL			;INITIALIZE THE DX20
	DATI	MPSCR0,BR		;READ STATUS BITS
	JMPB7	.+2			;SKIP IF WCLK IS STILL SET
	JMP	.+2			;IT SHOULD HAVE CLEARED BY INIT
	ERROR	TST,CANNOT CLEAR WCLK IN REGISTER MPSCR0 WITH INIT
	REPEAT	TST
	TEST	147,WCLK CLEAR TEST

;*SET UP FOR A ONE WORD DEVICE WRITE TRANSFER OF ALL ONES DATA
;*CHECK THAT WCLK SETS AFTER REQUESTING EACH 18-BIT WORD BY
;*  SETTING START IN REGISTER MPSCR1
;*TERMINATE AND CHECK FOR NO ERRORS

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	1			;SET UP A WORD COUNT OF 1
	MOVB	MPGP2			;WRITE INTO REGISTER FOR HOST
	MOVB	MPGP11			;SET BLOCK COUNT OF 1 FOR HOST
	LDBR	2			;GET PATTERN NUMBER FOR ONES DATA
	MOVB	MPGP10			;WRITE INTO REGISTER FOR HOST
	WRITE				;SET UP FOR A DEVICE WRITE TRANSFER
	LDBR	OCC+DTD			;SET OCCUPIED AND DIRECTION BIT
	MOVB	MPSCR1			;SEND TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	OCC+START+DTD		;GET START BIT
	MOVB	MPSCR1			;SEND AN SCLK TO RH20
	NOP				;GUARANTEE 1200 NS
	NOP
	NOP
	NOP
	DATI	MPSCR0,BR		;READ STATUS BITS
	JMPB7	.+2			;SKIP IF WCLK SET
	JMP	WCLKT2			;NO, GO AROUND
	LDBR	OCC+START+DTD		;GET START BIT
	MOVB	MPSCR1			;SEND TO RH20
	NOP				;GUARANTEE 1200 NS
	NOP
	NOP
	NOP
	DATI	MPSCR0,BR		;READ STATUS BITS
	JMPB7	.+3			;JUMP AROUND IF WCLK IS SET
WCLKT2:	JMPSUB	INITL			;INITIALIZE THE DX20
	ERROR	TST,<WCLK DID NOT SET IN REGISTER MPSCR0 AFTER SENDING
AN SCLK TO RH20 DURING A DEVICE WRITE TRANSFER>

	LDBR	EBL			;SET EBL AND CLEAR OCCUPIED
	MOVB	MPSCR1			;TELL RH20 TO TERMINATE
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKTRM	TST,<ATTEMPTED A ONE WORD DEVICE WRITE TRANSFER
BUT AN ERROR SET IN THE RH20>

;*SEND ANOTHER SCLK AND CHECK THAT WCLK CLEARED

	LDBR	START+DTD		;GET START BIT
	MOVB	MPSCR1			;SEND AN SCLK TO RH20 AND CLEAR WCLK
	DATI	MPSCR0,BR		;READ STATUS BITS
	JMPB7	.+2			;SKIP IF WCLK IS STILL SET
	JMP	.+2			;IT SHOULD HAVE CLEARED BY START
	ERROR	TST,<CANNOT CLEAR WCLK IN REGISTER MPSCR0 WITH
START DATA TRANSFER>
	REPEAT	TST
	TEST	148,DEVICE WRITE DATA BUFFER TEST

;*SET UP FOR A 4 WORD DEVICE WRITE TRANSFER
;*REQUEST AND CHECK FOR THE FOLLOWING DATA
;*	000000 000000
;*	777777 777777
;*	777777 000000
;*	000000 777777
;*TERMINATE AND CHECK FOR NO ERRORS

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	4			;GET WORD COUNT
	MOVB	MPGP2			;PUT IN MPGP2 FOR HOST
	MOVB	MPGP6			;SET ADDITIONAL PRINT INDEX TO 4
	LDBR	1			;GET A BLOCK COUNT OF ONE
	MOVB	MPGP11			;PUT IN REGISTER FOR HOST
	LDBR	3			;GET PATTERN NUMBER 3
	MOVB	MPGP10			;PUT IN REGISTER FOR HOST
	WRITE				;SET UP THE WRITE OPERATION
	LDBR	OCC+DTD			;SET OCCUPIED AND DTD
	MOVB	MPSCR1			;SEND OCC TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	0			;GET ZERO DATA
	MOVB	MPGP12			;CLEAR THE CORRECT DATA REGISTER
	MOVB	MPGP13
	MOVB	MPGP16
	MOVB	MPGP4			;PUT NUMBER OF HALF WORD IN MPGP4
	JMPSUB	CHKWRD			;GO REQUEST AND CHECK A WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERROR FOUND
	JMPSUB	CHKWRD			;CHECK THE SECOND HALF WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERROR FOUND
	LDBR	-1			;GET ONES DATA
	MOVB	MPGP12			;SET UP CORRECT DATA OF ALL ONES
	MOVB	MPGP13
	LDBR	DB			;GET DATA BITS 17 & 16
	MOVB	MPGP16
	JMPSUB	CHKWRD			;CHECK THIRD HALF WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERROR
	JMPSUB	CHKWRD			;CHECK 4TH HALF WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERROR
	JMPSUB	CHKWRD			;CHECK 5TH HALF WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERRORS
	LDBR	0			;GET ZERO DATA
	MOVB	MPGP12			;PUT ZEROS INTO CORRECT DATA REGISTERS
	MOVB	MPGP13
	MOVB	MPGP16
	JMPSUB	CHKWRD			;CHECK 6TH HALF WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERROR
	JMPSUB	CHKWRD			;CHECK 7TH HALF WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERRORS
	LDBR	-1			;GET ONES DATA
	MOVB	MPGP12			;PUT IN CORRECT DATA REGISTERS
	MOVB	MPGP13
	LDBR	DB			;GET DATA BITS 17 & 16
	MOVB	MPGP16
	JMPSUB	CHKWRD			;CHECK 8TH HALF WORD
	JMPZ	WDBT1			;JUMP AROUND IF ANY ERRORS
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND TO RH20 TO TERMINATE 
	JMP	WDBT2+1			;JUMP AROUND THE ERROR
WDBT1:	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND TO RH20 TO TERMINATE
WDBT2:	ERROR	TST,INCORRECT DATA RECEIVED FROM RH20,,PNT
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKTRM	TST,4 WORD WRITE TRANSFER CAUSED AN RH20 ERROR
	REPEAT	TST
	TEST	149,DEVICE WRITE DATA BUFFER PARITY ERROR TEST

;*SET EVEN PARITY BIT IN DATA BUFFER
;*SET UP FOR A ONE WORD DEVICE WRITE TRANSFER OF ALL ZEROS
;*REQUEST THE WORD
;*WRITE ZEROS TO MPDB2 TO CLEAR THE PARITY BIT IN DATA BUFFER
;*CHECK THAT DATA BUFFER PARITY ERROR IS NOW SET

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	1			;GET A WORD COUNT OF 1
	MOVB	MPGP2			;PUT IN REGISTER FOR HOST
	MOVB	MPGP11			;GET BLOCK COUNT TO 1
	MOVB	MPGP10			;SET DATA PATTERN CODE TO 1
	WRITE				;SET UP RH20 FOR A WRITE TRANSFER
	LDBR	OCC+DTD			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	0			;PUT NUMBER OF HALF WORD
	MOVB	MPGP4			;IN MPGP4
	MOVB	MPGP12			;CLEAR CORRECT
	MOVB	MPGP13			;DATA REGISTER
	LDBR	DBPARE			;SET TO EXPECT
	MOVB	MPGP16			;A PARITY ERROR
	LDBR	DBEVEN			;GET EVEN PARITY BIT
	MOVB	MPDB2			;SET IN DATA BUFFER
	JMPSUB	CHKWRD			;GET FIRST HALF OF WORD
	JMPZ	WDBPT1			;JUMP AROUND IF AN ERROR FOUND
	JMPSUB	CHKWRD			;GET SECOND HALF OF WORD
	JMPZ	WDBPT1			;JUMP AROUND IF AN ERROR FOUND
	LDBR	DTD+EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND TO RH20 TO TERMINATE
	JMP	WDBPT2+1		;JUMP AROUND THE ERROR
WDBPT1:	LDBR	DTD+EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND TO RH20 TO TERMINATE
WDBPT2:	ERROR	TST,<DATA BUFFER PARITY ERROR DID NOT SET DURING
ONE WORD DEVICE WRITE TRANSFER WHILE DATA BUFFER
EVEN PARITY BIT WAS SET>,,PNT

	REPEAT	TST
	TEST	150,DEVICE WRITE FLOATING ONE TEST

;*SET UP FOR A 9 WORD DEVICE WRITE TRANSFER
;*REQUEST AND CHECK FOR THE FOLLOWING DATA:
;*	000001 000002
;*	000004 000010
;*	000020 000040
;*	000100 000200
;*	000400 001000
;*	002000 004000
;*	010000 020000
;*	040000 100000
;*	200000 400000
;*TERMINATE AND CHECK FOR NO ERRORS

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	^D9			;GET A WORD COUNT OF 9
	MOVB	MPGP2			;PUT IN REGISTER FOR HOST
	LDBR	1			;GET BLOCK COUNT OF 1
	MOVB	MPGP11			;PUT IN REGISTER FOR HOST
	LDBR	4			;GET DATA PATTERN NUMBER 4
	MOVB	MPGP10			;PUT IN REGISTER FOR HOST
	WRITE				;SET UP RH20 FOR WRITE TRANSFER
	LDBR	DTD+OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	LDBR	1			;GET A ONE, THE START BIT
	MOVB	MPGP12			;PUT INTO CORRECT DATA BUFFER
	LDBR	0			;GET ZEROS DATA
	MOVB	MPGP13			;CLEAR REST OF CORRECT DATA REGISTERS
	MOVB	MPGP16
	MOVB	MPGP4			;CLEAR WORD COUNT
WFOT1:	JMPSUB	CHKWRD			;REQUEST AND CHECK A WORD FROM RH20
	JMPZ	WFOTE			;JUMP TO ERROR REPORT IF ANY ERROR
	DATI	MPGP12,AC0		;GET DATA PATTERN
	SHL	AC0,BR			;SHIFT DATA LEFT
	MOVB	MPGP12			;PUT NEW DATA BACK
	JMPC	.+2			;SKIP IF BIT WAS SHIFTED OUT
	JMP	WFOT1			;NO, CHECK THIS PATTERN
	LDBR	1			;GET ANOTHER ONE BIT
	MOVB	MPGP13			;PUT IN NEXT BYTE OF WORD
WFOT2:	JMPSUB	CHKWRD			;REQUEST AND CHECK ANOTHER WORD
	JMPZ	WFOTE			;JUMP TO ERROR REPORT IF ANY ERROR
	DATI	MPGP13,AC0		;GET DATA PATTERN
	SHL	AC0,BR			;SHIFT DATA BIT LEFT
	MOVB	MPGP13			;PUT NEW PATTERN BACK
	JMPC	.+2			;SKIP IF BIT SHIFTED OUT
	JMP	WFOT2			;NO, CHECK THIS PATTERN
	LDBR	1			;GET ANOTHER ONE BIT
	MOVB	MPGP16			;WRITE SET BIT 16 IN CORRECT BUFFER
	JMPSUB	CHKWRD			;CHECK THIS WORD
	JMPZ	WFOTE			;JUMP TO ERROR REPORT IF ANY ERROR
	LDBR	2			;GET BIT FOR BIT 17
	MOVB	MPGP16			;PUT IN CORRECT BUFFER
	JMPSUB	CHKWRD			;CHECK THIS WORD
	JMPZ	WFOTE			;JUMP TO ERROR REPORT IF ANY ERROR
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	JMP	WFOTR+1			;JUMP AROUND ERROR REPORT
WFOTE:	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
WFOTR:	ERROR	TST,INCORRECT DATA RECEIVED FROM RH20,,PNT
	CHKTRM	TST,ERROR SET DURING A 9 WORD WRITE TRANSFER
	REPEAT	TST
	TEST	151,DEVICE WRITE SHORT RECORD TEST

;*SET UP FOR A 4 WORD DEVICE WRITE TRANSFER OF ZEROS
;*REQUEST ONE WORD
;*TERMINATE AND CHECK FOR AN ERROR

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	4			;GET WORD COUNT OF 4
	MOVB	MPGP2			;PUT IN REGISTER FOR HOST
	LDBR	1			;GET PATTERN CODE OF 1
	MOVB	MPGP10			;PUT IN REGISTER FOR HOST
	WRITE				;SET UP THE RH20 FOR A WRITE TRANSFER
	LDBR	DTD+OCC			;GET THE OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	JMPSUB	CHKWRD			;REQUEST ONE WORD
	JMPSUB	CHKWRD			;REQUEST SECOND HALF OF WORD
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKERR	TST,<ACCEPTED ONLY ONE WORD OF A 4 WORD TRANSFER
BUT RH20 DID NOT SET ANY ERRORS>
	REPEAT	TST
	TEST	152,DEVICE WRITE LONG RECORD TEST

;*SET UP FOR A ONE WORD DEVICE WRITE TRANSFER OF ZEROS
;*REQUEST 4 WORDS
;*TERMINATE AND CHECK FOR AN ERROR

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	1			;GET WORD COUNT OF 1
	MOVB	MPGP2			;PUT IN REGISTER FOR HOST
	LDBR	1			;GET PATTERN CODE OF 1
	MOVB	MPGP10			;PUT IN REGISTER FOR HOST
	WRITE				;SET UP THE RH20 FOR A WRITE TRANSFER
	LDBR	DTD+OCC			;GET THE OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	JMPSUB	CHKWRD			;REQUEST ONE WORD
	JMPSUB	CHKWRD			;REQUEST SECOND HALF OF WORD
	JMPSUB	CHKWRD			;REQUEST ANOTHER WORD
	JMPSUB	CHKWRD			;AND SECOND HALF
	JMPSUB	CHKWRD			;REQUEST THIRD WORD
	JMPSUB	CHKWRD			;AND SECOND HALF
	JMPSUB	CHKWRD			;REQUEST FOURTH WORD
	JMPSUB	CHKWRD			;AND SECOND HALF
	LDBR	EBL			;GET EBL BIT
	MOVB	MPSCR1			;SEND EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	CHKERR	TST,<ACCEPTED FOUR WORDS OF A ONE WORD TRANSFER
BUT RH20 DID NOT SET ANY ERRORS>
	REPEAT	TST
	TEST	153,DRIVE EXCEPTION TEST

;*SET UP FOR A ONE WORD DEVICE WRITE TRANSFER OF ZEROS
;*REQUEST THE ONE WORD
;*SET MPERR TO GENERATE EXCEPTION
;*TERMINATE AND CHECK FOR AN ERROR

	JMPSUB	INITL			;INITIALIZE THE DX20
	LDBR	1			;GET WORD COUNT OF 1
	MOVB	MPGP2			;PUT IN REGISTER FOR HOST
	WRITE				;SET UP RH20 FOR A WRITE TRANSFER
	LDBR	DTD+OCC			;GET OCCUPIED BIT
	MOVB	MPSCR1			;SEND OCCUPIED TO RH20
	JMPSUB	RUNWAT			;WAIT FOR RUN TO SET
	JMPSUB	CHKWRD			;REQUEST THE WORD
	JMPSUB	CHKWRD			;AND THE SECOND HALF
	LDBR	MPERR+EBL+DTD+OCC	;GET ERROR AND EBL BITS
	MOVB	MPSCR1			;SEND EXCEPTION AN EBL TO RH20
	JMPSUB	STALL1			;STALL FOR DURATION OF EBL PULSE
	LDBR	0			;CLEAR OCC AND MPERR
	MOVB	MPSCR1			;IN STATUS REGISTER
	CHKERR	TST,<TRIED TO ASSERT EXCEPTION WITH MPERR BIT AFTER A
WRITE TRANSFER>,BUT RH20 DID NOT SEE THE EXCEPTION ERROR
	REPEAT	TST
	JMP	END			;GO TO END OF CODE

INITL:	LDBR	INIT			;GET INITIALIZE BIT
	MOVB	IOSEL			;INITIALIZE THE DX20
	LDBR	11			;GET MASSBUS SELECTION CODE
	MOVB	IOSEL			;LOAD INTO I/O SELECT REGISTER
	RETURN

STALL1:	DATI	MPSCR1			;EXECUTE THREE DATI INSTRUCTIONS
	DATI	MPSCR1			;TO STALL AT LEAST 1500 NS
	DATI	MPSCR1			;FOR DURATION OF EBL PULSE
	RETURN				;ACTUAL DELAY IS 1830 NS.

;THIS ROUTINE IS CALLED TO REQUEST AND CHECK A WORD FROM THE RH20
;DURING A DEVICE WRITE TRANSFER

;SENDS ONE SCLK
;CHECK DATA BUFFER FOR CORRECT CONTENTS
;CORRECT DATA IS IN DXGP5 (BITS 15 - 0) AND RH OF DXGP7 (17,16)
;IF DISCREPANCY IS FOUND, ACTUAL DATA IS PLACED IN DXGP6 AND LH OF DXGP7
;Z IS SET ON ERROR RETURN

CHKWRD:	LDBR	OCC+DTD+START		;GET START BIT
	MOVB	MPSCR1			;SEND TO RH20
	NOP				;GUARANTEE 1200 NS
	NOP
	NOP
	NOP
	DATI	MPGP12,BR		;GET CORRECT DATA BITS 7 - 0
	DATI	MPDB0,AC0		;READ ACTUAL DATA
	OSB	AC0			;COMPARE
	JMPZ	.+2			;SKIP IF A MATCH
	JMP	DATERR			;REPORT DATA ERROR
	DATI	MPGP13,BR		;READ CORRECT DATA BITS 15 - 8
	DATI	MPDB1,AC0		;READ ACTUAL DATA
	OSB	AC0			;COMPARE
	JMPZ	.+2			;SKIP IF A MATCH
	JMP	DATERR			;REPORT DATA ERROR
	DATI	MPGP16,BR		;READ REMAINING CORRECT BITS
	DATI	MPDB2,AC0		;READ ACTUAL DATA
	LXORBR	AC0			;XOR THE CORRECT AND ACTUAL
	LDBR	DBPARE+DB		;GET MASK OF WANTED BITS
	LANDBR	AC0			;CLEAR ALL OTHER BITS
	DEC	AC0			;SUBTRACT ONE TO CHECK IF ZERO
	JMPZ	DATGOD			;JUMP IF RESULT WAS -1
DATERR:	DATI	MPDB0,MPGP14		;COPY DATA BUFFER TO
	DATI	MPDB1,MPGP15		;GENERAL PURPOSE REGISTERS
	DATI	MPDB2,MPGP17
	RETURN	-1			;RETURN WITH Z SET TO SIGNAL ERROR
DATGOD:	DATI	MPGP4,AC0		;GET WORD COUNT FROM MPGP4
	INC	AC0,BR			;INCREMENT NUMBER
	MOVB	MPGP4			;PUT NUMBER BACK
	RETURN				;NORMAL RETURN, NO ERRORS
RUNWAT:	LDBR	0			;CLEAR WAIT CNT
	MOVB	AC0
RUNLP:	INCR	AC0			;INCREMENT WAIT CNT
	JMPC	RUNBCK			;JUMP IF TIMED OUT, TEST WILL FAIL
	DATI	MPSCR0,BR		;CHECK "RUN" BIT
	JMPB0	.+2			;JUMP IF SET
	JMP	RUNLP			;ELSE, KEEP WAITING
RUNBCK:	RETURN
END:	.ECRAM

.END
   