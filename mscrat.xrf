   1	%TITLE 'STIRS TESTS FOR M8622 (CRA) BOARD'
   2	
   3	MODULE MSCRAT	(
   4			LANGUAGE(BLISS36)
   5			) =
   6	
   7	BEGIN
   8	
   9	!
  10	!			  COPYRIGHT (C) 1979 BY
  11	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.  
  12	!
  13	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
  14	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
  15	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
  16	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
  17	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
  18	! TRANSFERRED.
  19	!
  20	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
  21	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
  22	! CORPORATION.
  23	!
  24	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
  25	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
  26	!
  27	
  28	!++
  29	! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
  30	!
  31	! ABSTRACT:
  32	!
  33	!	THIS MODULE CONTAIN THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
  34	!	(STIRS) DIAGNOSTIC FOR THE M8622 (CRA) BOARD.  IT ALSO CONTAINS SEVERAL
  35	!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
  36	!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
  37	!	'MSCRAD' MODULES TO PRODUCE THE 'MSCRA.EXE' FILE.
  38	!
  39	! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
  40	!
  41	! AUTHOR: RICH MURATORI	, CREATION DATE: 23-MAY-79
  42	!
  43	! MODIFIED BY:
  44	!
  45	!	RICH MURATORI, 23-MAY-79; VERSION 0.1
  46	!--
  47	
  48	!
  49	! TABLE OF CONTENTS:
  50	!
  51	
  52	FORWARD ROUTINE
  53		SPEC_DIALOGUE: NOVALUE,		!SPECIAL USER DIALOGUE
  54		SPEC_PRT,			!SPECIAL FEATURE PRINTING
  55		SPEC_ASK: NOVALUE,		!SPECIAL FEATURE QUESTIONS
  56		TEST_INIT: NOVALUE,		!INITIALIZATION ROUTINE
  57		CLEAR_CRAM: NOVALUE,		!CLEAR CRAM BITS IN CRAM LOC 0
  58		RESET_CRAM: NOVALUE,		!DO A 'CRA/M RESET'
  59		WRITE_CRAM: NOVALUE,		!WRITE 12 BITS OF DATA INTO CRAM
  60		CLK_DATA: NOVALUE,		!CLOCKS 12 BITS OF DATA TO CRA BOARD
  61		READ_DATA,			!READS 12 BITS OF DATA FROM CRA BOARD
  62		READ_SBR,			!READS KS10 SUBROUTINE STACK RETURN ADDR
  63		EC_BITS,			!READS 96 BITS OF CRAM DATA
  64		TST1 : NOVALUE,			!READING DIAG MUX WITH DIAG FN = 7
  65		TST2 : NOVALUE,			!WRITING AND READING KS10 BUS BITS
  66		TST3 : NOVALUE,			!WRITING AND READING CRAM BITS 0-11
  67		TST4 : NOVALUE,			!WRITING AND READING CRAM BITS 12-23
  68		TST5 : NOVALUE,			!WRITING AND READING CRAM BITS 24-35A
  69		TST6 : NOVALUE,			!WRITING AND READING CRAM BITS 24-35B
  70		TST7 : NOVALUE,			!RESETTING OF CRAM BITS 0-11
  71		TST8 : NOVALUE,			!RESETTING OF CRAM BITS 12-23
  72		TST9 : NOVALUE,			!RESETTING OF CRAM BITS 24-35 A&B
  73		TST10 : NOVALUE,		!SETTING NEXT CRAM ADDR USING DIAG ADR
  74		TST11 : NOVALUE,		!'CURR LOC' CLOCKING
  75		TST12 : NOVALUE,		!SETTING NEXT CRAM ADDR USING J FIELD
  76		TST13 : NOVALUE,		!BITS 0-35 TEST FOR ALL CRAM LOCS
  77		TST14 : NOVALUE,		!CRAM ADDRESS DRIVERS
  78		TST15 : NOVALUE,		!'SBR RET' CLOCKING
  79		TST16 : NOVALUE,		!'SBR RET' BIT TEST
  80		TST17 : NOVALUE,		!SETTING NXT CRAM ADR USING 'SBR RET'
  81		TST18 : NOVALUE,		!SUBROUTINE STACK
  82		TST19 : NOVALUE,		!'STACK RESET'
  83		TST20 : NOVALUE,		!NICOND DISPATCH
  84		TST21 : NOVALUE,		!'SKIP 10' WITH 'TRAP CYCLE' INPUT
  85		TST22 : NOVALUE,		!CONSOLE EXEC MODE SKIPPING
  86		TST23 : NOVALUE,		!'NOT CONTINUE' SKIPPING
  87		TST24 : NOVALUE,		!'NOT 1 MSEC TIMER' SKIPPING
  88		TST25 : NOVALUE,		!'NOT I/O LATCH' SKIPPING
  89		TST26 : NOVALUE,		!'AD EQ 0' SKIPPING
  90		TST27 : NOVALUE,		!'SC SIGN BIT' SKIPPING
  91		TST28 : NOVALUE,		!'DPM3 SCAD 00' DISPATCHING
  92		TST29 : NOVALUE,		!'DPE5 FLAG QR 37' DISPATCHING
  93		TST30 : NOVALUE,		!'DPM6 MEMORY CYCLE' DISPATCHING
  94		TST31 : NOVALUE,		!BYTE DISPATCHING
  95		TST32 : NOVALUE,		!EFFECTIVE ADDRESS MODE DISPATCHING
  96		TST33 : NOVALUE,		!DROM DISPATCHING
  97		TST34 : NOVALUE,		!'AREAD' DISPATCHING
  98		TST35 : NOVALUE,		!PAGE FAIL DISPATCHING TO 7777
  99		TST36 : NOVALUE,		!'SKIP 40' SKIPPING
 100		TST37 : NOVALUE,		!'SKIP 20' SKIPPING
 101		TST38 : NOVALUE,		!'CRA2 RETURN' SIGNAL ASSERTION
 102		TST39 : NOVALUE,		!'SPEC/CONSOLE' SIGNAL ASSERTION
 103		TST40 : NOVALUE;		!CRAM PARITY DETECTION NETWORK
 104	!
 105	! INCLUDE FILES:
 106	!
 107	
 108	REQUIRE 'REGBIT.R36';				!8080 I/O REGISTER BIT DEFINITIONS
 109	
 110	!
 111	!			  COPYRIGHT (c) 1977, 1978 BY
 112	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 113	!
 114	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 115	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 116	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 117	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 118	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 119	! TRANSFERRED.
 120	!
 121	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 122	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 123	! CORPORATION.
 124	!
 125	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 126	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 127	!
 128	
 129	!++
 130	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 131	!
 132	! ABSTRACT:
 133	!
 134	!	THIS FILE CONTAINS SYMBOLIC BIT DEFINITIONS FOR THE KS10 8080 I/O
 135	!	REGISTERS.  IT IS USED AS A 'REQUIRE' FILE FOR THE STIRS DIAGNOSTICS.
 136	!
 137	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 138	!
 139	! AUTHOR:  RICH MURATORI	, CREATION DATE:  3-JAN-79
 140	!
 141	! MODIFIED BY:
 142	!
 143	!  RICH MURATORI, 3-JAN-79 : VERSION 0.1
 144	!--
 145	
 146	LITERAL
 147	
 148	!WRITE REGISTER 100
 149	
 150		FORCE_PAR	= 1^1,		!FORCE PARITY RIGHT
 151		EN_1MS		= 1^2,		!1 MSEC ENABLE
 152		CACHE_ENB	= 1^3,		!CACHE ENABLE
 153		DP_PE_DET	= 1^4,		!DP PE DETECT
 154		CRM_PE_DET	= 1^5,		!CRM PE DETECT
 155		PE_DET_ENB	= 1^6,		!PE DETECT ENABLE
 156		RESET		= 1^7,		!RESET
 157	
 158	!WRITE REGISTER 102/103
 159	
 160		DATA35		= 1^0,		!KS10 BUS DATA BIT 35
 161		DATA34		= 1^1,		!KS10 BUS DATA BIT 34
 162		DATA33		= 1^2,		!KS10 BUS DATA BIT 33
 163		DATA32		= 1^3,		!KS10 BUS DATA BIT 32
 164		DATA31		= 1^4,		!KS10 BUS DATA BIT 31
 165		DATA30		= 1^5,		!KS10 BUS DATA BIT 30
 166		DATA29		= 1^6,		!KS10 BUS DATA BIT 29
 167		DATA28		= 1^7,		!KS10 BUS DATA BIT 28
 168	
 169	!WRITE REGISTER 104/105
 170	
 171		DATA27		= 1^0,		!KS10 BUS DATA BIT 27
 172		DATA26		= 1^1,		!KS10 BUS DATA BIT 26
 173		DATA25		= 1^2,		!KS10 BUS DATA BIT 25
 174		DATA24		= 1^3,		!KS10 BUS DATA BIT 24
 175		DATA23		= 1^4,		!KS10 BUS DATA BIT 23
 176		DATA22		= 1^5,		!KS10 BUS DATA BIT 22
 177		DATA21		= 1^6,		!KS10 BUS DATA BIT 21
 178		DATA20		= 1^7,		!KS10 BUS DATA BIT 20
 179	
 180	!WRITE REGISTER 106/107
 181	
 182		DATA19		= 1^0,		!KS10 BUS DATA BIT 19
 183		DATA18		= 1^1,		!KS10 BUS DATA BIT 18
 184		DATA17		= 1^2,		!KS10 BUS DATA BIT 17
 185		DATA16		= 1^3,		!KS10 BUS DATA BIT 16
 186		DATA15		= 1^4,		!KS10 BUS DATA BIT 15
 187		DATA14		= 1^5,		!KS10 BUS DATA BIT 14
 188		DATA13		= 1^6,		!KS10 BUS DATA BIT 13
 189		DATA12		= 1^7,		!KS10 BUS DATA BIT 12
 190	
 191	!WRITE REGISTER 110/111
 192	
 193		DATA11		= 1^0,		!KS10 BUS DATA BIT 11
 194		DATA10		= 1^1,		!KS10 BUS DATA BIT 10
 195		DATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 196		DATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 197		DATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 198		DATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 199		DATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 200		DATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 201	
 202	!WRITE REGISTER 112/113
 203	
 204		DATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 205		DATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 206		DATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 207		DATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 208	
 209	!WRITE REGISTER 114/115
 210	
 211		DATA_CYCLE	= 1^0,		!DATA CYCLE
 212		IO_DATA		= 1^1,		!I/O DATA CYCLE
 213		COM_ADR		= 1^2,		!COM/ADR CYCLE
 214		BAD_DATA	= 1^3,		!BAD DATA CYCLE
 215	
 216	!WRITE REGISTER 116
 217	
 218		CSL_INT		= 1^0,		!CSL INTERRUPT THE 10
 219	
 220	!WRITE REGISTER 204
 221	
 222		CRAM_RESET	= 1^0,		!CRAM RESET
 223		STK_RESET	= 1^1,		!STACK RESET
 224		DP_RESET	= 1^2,		!DP RESET
 225		SS_MODE		= 1^3,		!SINGLE STEP MODE
 226		CRAM_ADR_LD	= 1^4,		!CRAM ADR LOAD
 227		CRAM_WRT	= 1^5,		!CRAM WRITE
 228	
 229	!WRITE REGISTER 205
 230	
 231		DIAG1		= 1^0,		!DIAG FN BIT 1
 232		DIAG2		= 1^1,		!DIAG FN BIT 2
 233		DIAG4		= 1^2,		!DIAG FN BIT 4
 234		DIAG10		= 1^3,		!DIAG FN BIT 10
 235		TRAP_ENB	= 1^4,		!TRAP ENABLE
 236		CLR_INT		= 1^5,		!CLEAR 10 INTERRUPT
 237		MNT_CLK_ENB	= 1^6,		!MAINT CLK ENABLE
 238		MAINT_CLK	= 1^7,		!MAINT CLK PULSE
 239	
 240	!WRITE REGISTER 206
 241	
 242		CLK_RUN		= 1^0,		!CLOCK RUN
 243		SINGLE_CLK	= 1^1,		!SINGLE CLOCK
 244	
 245	!WRITE REGISTER 210
 246	
 247		CLOSE_LATCH	= 1^0,		!CLOSE LATCHS
 248		LATCH_DATA	= 1^1,		!LATCH DATA (1)
 249		CRA_R_CLK	= 1^2,		!CRA R CLK ENB (1)
 250		CRA_T_CLK	= 1^3,		!CRA T CLK ENB (1)
 251		XMIT_DATA	= 1^4,		!XMIT DATA (1)
 252		XMIT_ADR	= 1^5,		!XMIT ADR (1)
 253		BUS_REQ		= 1^6,		!BUS REQ
 254		MEM		= 1^7,		!MEM
 255	
 256	!WRITE REGISTER 212
 257	
 258		CONTINUE	= 1^0,		!CONTINUE
 259		EXECUTE		= 1^1,		!EXECUTE
 260		RUN		= 1^2,		!RUN
 261	
 262	
 263	
 264	!READ REGISTER 0
 265	
 266		RDATA35		= 1^0,		!KS10 BUS DATA BIT 35
 267		RDATA34		= 1^1,		!KS10 BUS DATA BIT 34
 268		RDATA33		= 1^2,		!KS10 BUS DATA BIT 33
 269		RDATA32		= 1^3,		!KS10 BUS DATA BIT 32
 270		RDATA31		= 1^4,		!KS10 BUS DATA BIT 31
 271		RDATA30		= 1^5,		!KS10 BUS DATA BIT 30
 272		RDATA29		= 1^6,		!KS10 BUS DATA BIT 29
 273		RDATA28		= 1^7,		!KS10 BUS DATA BIT 28
 274	
 275	!READ REGISTER 1
 276	
 277		RDATA27		= 1^0,		!KS10 BUS DATA BIT 27
 278		RDATA26		= 1^1,		!KS10 BUS DATA BIT 26
 279		RDATA25		= 1^2,		!KS10 BUS DATA BIT 25
 280		RDATA24		= 1^3,		!KS10 BUS DATA BIT 24
 281		RDATA23		= 1^4,		!KS10 BUS DATA BIT 23
 282		RDATA22		= 1^5,		!KS10 BUS DATA BIT 22
 283		RDATA21		= 1^6,		!KS10 BUS DATA BIT 21
 284		RDATA20		= 1^7,		!KS10 BUS DATA BIT 20
 285	
 286	!READ REGISTER 2
 287	
 288		RDATA19		= 1^0,		!KS10 BUS DATA BIT 19
 289		RDATA18		= 1^1,		!KS10 BUS DATA BIT 18
 290		RDATA17		= 1^2,		!KS10 BUS DATA BIT 17
 291		RDATA16		= 1^3,		!KS10 BUS DATA BIT 16
 292		RDATA15		= 1^4,		!KS10 BUS DATA BIT 15
 293		RDATA14		= 1^5,		!KS10 BUS DATA BIT 14
 294		RDATA13		= 1^6,		!KS10 BUS DATA BIT 13
 295		RDATA12		= 1^7,		!KS10 BUS DATA BIT 12
 296	
 297	!READ REGISTER 3
 298	
 299		RDATA11		= 1^0,		!KS10 BUS DATA BIT 11
 300		RDATA10		= 1^1,		!KS10 BUS DATA BIT 10
 301		RDATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 302		RDATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 303		RDATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 304		RDATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 305		RDATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 306		RDATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 307	
 308	!READ REGISTER 100
 309	
 310		ADPT2_PE	= 1^0,		!UNIBUS ADAPTER 2 PARITY ERR
 311		CRA_PE		= 1^1,		!CRA PARITY ERR
 312		DP_PE		= 1^2,		!DP PARITY ERR
 313		MEM_PE		= 1^3,		!MEM PARITY ERR
 314		CRAM_PE		= 1^4,		!CRAM PARITY ERR
 315		ADPT3_PE	= 1^6,		!UNIBUS ADAPTER 3 PARITY ERR
 316		REC_PE		= 1^7,		!RECEIVED PARITY ERR
 317	
 318	!READ REGISTER 101
 319	
 320		MMC_REF_ERR	= 1^0,		!MEM REFRESH ERR
 321		PI_REQ_7	= 1^1,		!PI REQ 7
 322		PI_REQ_6	= 1^2,		!PI REQ 6
 323		PI_REQ_5	= 1^3,		!PI REQ 5
 324		PI_REQ_4	= 1^4,		!PI REQ 4
 325		PI_REQ_3	= 1^5,		!PI REQ 3
 326		PI_REQ_2	= 1^6,		!PI REQ 2
 327		PI_REQ_1	= 1^7,		!PI REQ 1
 328	
 329	!READ REGISTER 102
 330	
 331		RDATA		= 1^0,		!DATA CYCLE
 332		RIO_DATA	= 1^1,		!I/O DATA CYCLE
 333		RCOM_ADR	= 1^2,		!COM/ADR CYCLE
 334		RBAD_DATA	= 1^3,		!BAD DATA CYCLE
 335		RIO_BUSY	= 1^4,		!I/O BUSY
 336		RMEM_BUSY	= 1^5,		!MEM BUSY
 337		RRESET		= 1^6,		!RESET
 338		RAC_LO		= 1^7,		!AC LO
 339	
 340	!READ REGISTER 103
 341	
 342		RDATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 343		RDATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 344		RDATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 345		RDATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 346		PAR_LEFT	= 1^4,		!PARITY LEFT
 347		PAR_RIGHT	= 1^5,		!PARITY RIGHT
 348		ADPT4_PE	= 1^6,		!UNIBUS ADAPTER 4 PARITY ERR
 349		ADPT1_PE	= 1^7,		!UNIBUS ADAPTER 1 PARITY ERR
 350	
 351	!READ REGISTER 300
 352	
 353		CONTINUE_H	= 1^0,		!CONTINUE
 354		EXECUTE_B	= 1^1,		!EXECUTE
 355		RUN_1		= 1^2,		!RUN
 356		HALT_LOOP	= 1^3,		!DPM HALT LOOP
 357		KLINIK_LEN	= 1^4,		!KLINIK LENGTH (SW)
 358		KLINIK_BIT	= 1^5,		!KLINIK BIT # (SW)
 359		CTY_CHAR_LEN	= 1^6,		!CTY CHARACTER LENGTH (SW)
 360		CTY_BIT		= 1^7,		!CTY BIT # (SW)
 361	
 362	!READ REGISTER 301
 363	
 364		DATA_ACK	= 1^0,		!DATA ACK
 365		BOOT		= 1^1,		!BOOT (SW)
 366		CONS_ENB	= 1^2,		!CONSOLE ENABLE (SW)
 367		PE_1		= 1^3,		!PE(1)
 368		BUSREQ		= 1^4,		!BUS REQUEST
 369		NEXM		= 1^6,		!NEXM
 370		TEN_INT		= 1^7,		!10 INTERRUPT
 371	
 372	!READ REGISTER 302
 373	
 374		KLINIK_CARR	= 1^0,		!KLINIK CARRIER
 375		TERM_CARR	= 1^1,		!TERMINAL CARRIER
 376		REM_DIAG_ENB	= 1^2,		!REMOTE DIAG ENB
 377		REM_DIAG_PRO	= 1^3,		!REMOTE DIAG PROT
 378	
 379	!READ REGISTER 303
 380	
 381		RAM_ERR		= 1^0,		!RAM ERROR
 382		DP_CLK_ENBL	= 1^1,		!DPE/M CLK ENABLE
 383		CR_CLK_ENB	= 1^2,		!CRA/M CLK ENABLE
 384		R_CLK_ENB0	= 1^3;		!R CLK ENB (0) H
 385	
 386	! END OF 'REGBIT.R36'
 387	REQUIRE 'KSU.R36';				!KS10 MICROCODE MACROS
 388	
 389	!
 390	!			  COPYRIGHT (c) 1977, 1978 BY
 391	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 392	!
 393	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 394	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 395	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 396	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 397	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 398	! TRANSFERRED.
 399	!
 400	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 401	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 402	! CORPORATION.
 403	!
 404	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 405	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 406	!
 407	
 408	
 409	!++
 410	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 411	!
 412	! ABSTRACT:
 413	!
 414	!	 THESE MACROS ALLOW YOU TO WRITE MICROINSTRUCTIONS IN A SYMBOLIC FORM
 415	!	 (DIFFERENT THAN THE NORMAL MICRO CROSS ASSEMBLER) FOR USE AS LITERAL
 416	!	 VALUES WITHIN A BLISS-36 PROGRAM.   MACROS ARE NECESSARY (AS OPPOSED
 417	!	 TO ARITHMETIC EXPRESSIONS) TO HANDLE SOME FIELDS' DEFAULT VALUES IN
 418	!	 THE "RIGHT WAY"; THEY DEFAULT TO THE VALUE WHICH MAY HAVE BEEN SET IN
 419	!	 OTHER FIELDS.   ALSO, IT ALLEVIATES YOU FROM HAVING TO REMEMBER WHICH
 420	!	 OF THE 3 36-BIT PDP-10 WORDS THE FIELD GOES INTO.
 421	!
 422	! FUNCTIONAL DESCRIPTION:
 423	!
 424	!	 TO CREATE A MICROINSTRUCTION, CALL THE MACROS FOR THE FIELDS WHICH
 425	!	 YOU DESIRE TO SPECIFY EXPLICITLY.   SOME OF THEM REQUIRE ARGUMENTS;
 426	!	 SOME OF THEM CALL OTHERS WITH THE APPROPRIATE ARGUMENT.   THESE WILL
 427	!	 EXPAND TO THE NULL LEXEME (THAT IS, THEY GO AWAY).   FINALLY, THE
 428	!	 U MACRO IS CALLED.   IT HANDLES THE TRICKY DEFAULTS, EXPANDS TO 3
 429	!	 DECIMAL CONSTANTS SEPPARATED BY COMMAS, AND RESETS THE COMPILETIME
 430	!	 VARIABLES BACK TO THEIR INITIAL VALUES (MOSTLY, THE MICROINSTRUCTION
 431	!	 WITH ALL OF THE SIMPLE FIELDS WITH THEIR DEFAULT VALUES).   THE U
 432	!	 MACRO MAY BE CALLED AS THE ARGUMENT OF A PLIT.   IT MAY BE CALLED SEVERAL
 433	!	 TIMES WITH A COMMA BETWEEN EACH ONE (AND THE FIELD-SETTING MACROS
 434	!	 BEFORE EACH ONE) TO MAKE A PLIT WITH A BLOCK OF SEVERAL MICROINSTRUCTIONS
 435	!	 SINCE THE HOOKS INTO CSL WILL PERMIT LOADING SEVERAL MICROINSTRUCTIONS
 436	!	 INTO CONTIGUOUS CRAM LOCATIONS WITH ONE CALL.   MACROS MAY BE DEFINED
 437	!	 WHICH SET MANY OF THE FIELDS (JUST LIKE IN MICRO) BY HAVING IT CALL THE
 438	!	 DESIRED FIELD-SETTING MACROS.
 439	!
 440	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 441	!
 442	! AUTHOR: ARON INSINGA, CREATION DATE: 22-AUG-78
 443	!
 444	! MODIFIED BY:
 445	!
 446	!	ARON INSINGA, 28-AUG-78: VERSION 0.1
 447	!--
 448	
 449	!
 450	! TABLE OF CONTENTS:
 451	!
 452	!	JUMP FIELD
 453	!	2901 ALU FUNCTION
 454	!	LEFT SOURCE
 455	!	RIGHT SOURCE
 456	!	DESTINATION (DP, Q, B)
 457	!	DATA PATH ADDRESS A
 458	!	DATA PATH ADDRESS B
 459	!	RAMFILE ADDRESS
 460	!	D-BUS SELECT
 461	!	DBM SELECT
 462	!	FICTICOUS PARITY-VALIDATE BIT
 463	!	CLOCK LEFT HALF OF THE MACHINE
 464	!	STORE PARITY FOR LEFT 2901'S
 465	!	CHECK LEFT HALF D-BUS PARITY
 466	!	CLOCK RIGHT HALF OF THE MACHINE
 467	!	STORE PARITY FOR RIGHT 2901'S
 468	!	CHECK RIGHT HALF D-BUS PARITY
 469	!	SPEC
 470	!	SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
 471	!	SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
 472	!	DISPATCH
 473	!	SKIP STUFF
 474	!	TIME FIELD
 475	!	RANDOM CONTROL BITS
 476	!	INJECT A CARRY
 477	!	LOAD SC FROM SCAD
 478	!	LOAD FE FROM SCAD
 479	!	WRITE THE RAM FILE
 480	!	START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
 481	!	THIS MICROINSTRUCTION IS DOING A DIVIDE
 482	!	MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
 483	!	FAST SHIFT
 484	!	CALL
 485	!	MAGIC NUMBER FIELD (#)
 486	!	SCAD (SHIFT-COUNT ADDER) FUNCTION
 487	!	SCAD A-INPUT MUX
 488	!	SCAD B-INPUT MUX
 489	!	SCAD NUMBER FIELD
 490	!	MICROINSTRUCTION BUILDER
 491	!
 492	!	MICROINSTRUCTION WITH DEFAULT FIELDS
 493	!	MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
 494	!	MICROINSTRUCTION BEING BUILT
 495	!
 496	
 497	!
 498	! MACROS:
 499	!
 500	
 501	    MACRO
 502	
 503		! JUMP FIELD
 504		U_J(O_CRAM_ADDR) =
 505		    %ASSIGN(U_0,U_0 OR ((%O %STRING(O_CRAM_ADDR))^24)) %,
 506	
 507		! 2901 ALU FUNCTION
 508		U_ALU(FUNC) =
 509		    %ASSIGN(U_0,(U_0 AND %O'777707777777') OR ((FUNC)^21)) %,
 510	
 511		U_ALU_ADD = U_ALU(0) %,
 512		U_ALU_SUB = U_ALU(1) %,
 513		U_ALU_RSUB = U_ALU(2) %,
 514		U_ALU_OR = U_ALU(3) %,
 515		U_ALU_AND = U_ALU(4) %,
 516		U_ALU_MASK = U_ALU(5) %,
 517		U_ALU_XOR = U_ALU(6) %,
 518		U_ALU_XNOR = U_ALU(7) %,
 519	
 520		! LEFT SOURCE
 521		U_LSRC(SRC) =
 522		    %ASSIGN(U_0,(U_0 AND %O'777770777777') OR ((SRC)^18)) %,
 523	
 524		U_LSRC_AQ = U_LSRC(0) %,
 525		U_LSRC_AB = U_LSRC(1) %,
 526		U_LSRC_0Q = U_LSRC(2) %,
 527		U_LSRC_0B = U_LSRC(3) %,
 528		U_LSRC_0A = U_LSRC(4) %,
 529		U_LSRC_DA = U_LSRC(5) %,
 530		U_LSRC_DQ = U_LSRC(6) %,
 531		U_LSRC_D0 = U_LSRC(7) %,
 532	
 533		! RIGHT SOURCE
 534		U_RSRC(SRC) =
 535		    %ASSIGN(U_0,(U_0 AND %O'777777077777') OR ((SRC)^15))
 536		    %ASSIGN(U_SET,U_SET OR U_SET_RSRC) %,
 537	
 538		U_RSRC_AQ = U_RSRC(0) %,
 539		U_RSRC_AB = U_RSRC(1) %,
 540		U_RSRC_0Q = U_RSRC(2) %,
 541		U_RSRC_0B = U_RSRC(3) %,
 542		U_RSRC_0A = U_RSRC(4) %,
 543		U_RSRC_DA = U_RSRC(5) %,
 544		U_RSRC_DQ = U_RSRC(6) %,
 545		U_RSRC_D0 = U_RSRC(7) %,
 546	
 547		! DESTINATION (DP, Q, B)
 548		U_DEST(DEST) =
 549		    %ASSIGN(U_0,(U_0 AND %O'777777707777') OR ((DEST)^12)) %,
 550	
 551		U_DEST_A = U_DEST(0) %,
 552		U_DEST_AD = U_DEST(1) %,
 553		U_DEST_Q_AD = U_DEST(2) %,
 554		U_DEST_PASS = U_DEST(3) %,
 555		U_DEST_Q_MUL2 = U_DEST(4) %,
 556		U_DEST_AD_MUL2 = U_DEST(5) %,
 557		U_DEST_Q_DIV2 = U_DEST(6) %,
 558		U_DEST_AD_DIV2 = U_DEST(7) %,
 559	
 560		! DATA PATH ADDRESS A
 561		U_A(DP) =
 562		    %ASSIGN(U_0,U_0 OR ((DP)^6)) %,
 563	
 564		U_A_MAG = U_A(0) %,
 565		U_A_PC = U_A(1) %,
 566		U_A_HR = U_A(2) %,
 567		U_A_AR = U_A(3) %,
 568		U_A_ARX = U_A(4) %,
 569		U_A_BR = U_A(5) %,
 570		U_A_BRX = U_A(6) %,
 571		U_A_ONE = U_A(7) %,
 572		U_A_EBR = U_A(8) %,
 573		U_A_UBR = U_A(9) %,
 574		U_A_MASK = U_A(10) %,
 575		U_A_FLG = U_A(11) %,
 576		U_A_PI = U_A(12) %,
 577		U_A_XWD1 = U_A(13) %,
 578		U_A_T0 = U_A(14) %,
 579		U_A_T1 = U_A(15) %,
 580	
 581		! DATA PATH ADDRESS B
 582		U_B(DP) =
 583		    %ASSIGN(U_0,U_0 OR (DP)) %,
 584	
 585		U_B_MAG = U_B(0) %,
 586		U_B_PC = U_B(1) %,
 587		U_B_HR = U_B(2) %,
 588		U_B_AR = U_B(3) %,
 589		U_B_ARX = U_B(4) %,
 590		U_B_BR = U_B(5) %,
 591		U_B_BRX = U_B(6) %,
 592		U_B_ONE = U_B(7) %,
 593		U_B_EBR = U_B(8) %,
 594		U_B_UBR = U_B(9) %,
 595		U_B_MASK = U_B(10) %,
 596		U_B_FLG = U_B(11) %,
 597		U_B_PI = U_B(12) %,
 598		U_B_XWD1 = U_B(13) %,
 599		U_B_T0 = U_B(14) %,
 600		U_B_T1 = U_B(15) %,
 601	
 602		! RAMFILE ADDRESS
 603		U_RAM(SEL) =
 604		    %ASSIGN(U_1,(U_1 AND %O'77777777777') OR ((SEL)^33)) %,
 605	
 606		U_RAM_AC = U_RAM(0) %,
 607		U_RAM_AC_FN = U_RAM(1) %,
 608		U_RAM_XR = U_RAM(2) %,
 609		U_RAM_VMA = U_RAM(4) %,
 610		U_RAM_RAM = U_RAM(6) %,
 611		U_RAM_N = U_RAM(7) %,
 612	
 613		! D-BUS SELECT
 614		U_DBUS(SEL) =
 615		    %ASSIGN(U_1,(U_1 AND %O'747777777777') OR ((SEL)^30)) %,
 616	
 617		U_DBUS_PC_FLAGS = U_DBUS(0) %,		! LEFT HALF
 618		U_DBUS_PI_NEW = U_DBUS(0) %,		! BITS 19:21
 619		U_DBUS_VMA = U_DBUS(0) %,		! BITS 27:35
 620		U_DBUS_DP = U_DBUS(1) %,
 621		U_DBUS_RAM = U_DBUS(2) %,
 622		U_DBUS_DBM = U_DBUS(3) %,
 623	
 624		! DBM SELECT
 625		U_DBM(SEL) =
 626		    %ASSIGN(U_1,(U_1 AND %O'770777777777') OR ((SEL)^27)) %,
 627	
 628		U_DBM_SCAD = U_DBM(0) %,		! LEFT HALF
 629		U_DBM_PF_DISP = U_DBM(0) %,		! BITS 18:21
 630		U_DBM_APR_FLAGS = U_DBM(0) %,		! BITS 22:35
 631		U_DBM_BYTES = U_DBM(1) %,
 632		U_DBM_EXP = U_DBM(2) %,			! LEFT HALF
 633		U_DBM_MSEC = U_DBM(2) %,		! RIGHT HALF
 634		U_DBM_DP = U_DBM(3) %,
 635		U_DBM_DP_SWAP = U_DBM(4) %,
 636		U_DBM_VMA = U_DBM(5) %,
 637		U_DBM_MEM = U_DBM(6) %,
 638		U_DBM_N = U_DBM(7) %,
 639	
 640		! FICTICOUS PARITY-VALIDATE BIT
 641		U_ALU_PARITY_OK =
 642		    %ASSIGN(U_3,U_3 OR (1^35)) %,
 643	
 644		! CLOCK LEFT HALF OF THE MACHINE
 645		U_NO_CLKL =
 646		    %ASSIGN(U_1,U_1 AND %O'777377777777') %,
 647	
 648		! STORE PARITY FOR LEFT 2901'S
 649		U_GENL =
 650		    %ASSIGN(U_1,U_1 OR (1^25))
 651		    %ASSIGN(U_SET,U_SET OR U_SET_GENL) %,
 652	
 653		! CHECK LEFT HALF D-BUS PARITY
 654		U_CHKL =
 655		    %ASSIGN(U_1,U_1 OR (1^24)) %,
 656	
 657		! CLOCK RIGHT HALF OF THE MACHINE
 658		U_NO_CLKR =
 659		    %ASSIGN(U_1,U_1 AND %O'777737777777') %,
 660	
 661		! STORE PARITY FOR RIGHT 2901'S
 662		U_GENR =
 663		    %ASSIGN(U_1,U_1 OR (1^22))
 664		    %ASSIGN(U_SET,U_SET OR U_SET_GENR) %,
 665	
 666		! CHECK RIGHT HALF D-BUS PARITY
 667		U_CHKR =
 668		    %ASSIGN(U_1,U_1 OR (1^21)) %,
 669	
 670		! SPEC
 671		U_SPEC(X) =
 672		    %ASSIGN(U_1,U_1 OR ((X)^15)) %,
 673	
 674		U_SPEC_N = U_SPEC(%O'10') %,
 675		U_SPEC_CLRCLK = U_SPEC(%O'11') %,
 676		U_SPEC_CLRIOLAT = U_SPEC(%O'12') %,
 677		U_SPEC_CLRIOBSY = U_SPEC(%O'13') %,
 678		U_SPEC_LDPAGE = U_SPEC(%O'14') %,
 679		U_SPEC_NICOND = U_SPEC(%O'15') %,
 680		U_SPEC_LDPXCT = U_SPEC(%O'16') %,
 681		U_SPEC_WAIT = U_SPEC(%O'17') %,
 682		U_SPEC_PREV = U_SPEC(%O'20') %,
 683		U_SPEC_LOADXR = U_SPEC(%O'21') %,
 684		U_SPEC_APRFLAGS = U_SPEC(%O'23') %,
 685		U_SPEC_CLRCSH = U_SPEC(%O'24') %,
 686		U_SPEC_APR_EN = U_SPEC(%O'25') %,
 687		U_SPEC_MEMCLR = U_SPEC(%O'27') %,
 688		U_SPEC_SWEEP = U_SPEC(%O'34') %,
 689		U_SPEC_PXCT_OFF = U_SPEC(%O'36') %,
 690		U_SPEC_INHCRY18 = U_SPEC(%O'40') %,
 691		U_SPEC_LOADIR = U_SPEC(%O'41') %,
 692		U_SPEC_LDPI = U_SPEC(%O'43') %,
 693		U_SPEC_ASHOV = U_SPEC(%O'44') %,
 694		U_SPEC_EXPTST = U_SPEC(%O'45') %,
 695		U_SPEC_FLAGS = U_SPEC(%O'46') %,
 696		U_SPEC_LDACBLK = U_SPEC(%O'47') %,
 697		U_SPEC_LDINST = U_SPEC(%O'61') %,
 698	
 699		! SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
 700		U_BYTE(X) =
 701		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
 702	
 703		U_BYTE_1 = U_BYTE(1) %,
 704		U_BYTE_2 = U_BYTE(2) %,
 705		U_BYTE_3 = U_BYTE(3) %,
 706		U_BYTE_4 = U_BYTE(4) %,
 707		U_BYTE_5 = U_BYTE(5) %,
 708	
 709		! SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
 710		U_SHSTYLE(X) =
 711		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
 712	
 713		U_SHSTYLE_NORM = U_SHSTYLE(0) %,
 714		U_SHSTYLE_ZERO = U_SHSTYLE(1) %,
 715		U_SHSTYLE_ONES = U_SHSTYLE(2) %,
 716		U_SHSTYLE_ROT = U_SHSTYLE(3) %,
 717		U_SHSTYLE_ASHC = U_SHSTYLE(4) %,
 718		U_SHSTYLE_LSHC = U_SHSTYLE(5) %,
 719		U_SHSTYLE_DIV = U_SHSTYLE(6) %,
 720		U_SHSTYLE_ROTC = U_SHSTYLE(7) %,
 721	
 722		! DISPATCH
 723		U_DISP(X) =
 724		    %ASSIGN(U_1,(U_1 AND %O'777777700777') OR ((X)^9)) %,
 725	
 726		U_DISP_CONSOLE = U_DISP(%O'00') %,
 727		U_DISP_DROM = U_DISP(%O'12') %,
 728		U_DISP_AREAD = U_DISP(%O'13') %,
 729		U_DISP_DP_LEFT = U_DISP(%O'31') %,
 730		U_DISP_NORM = U_DISP(%O'34') %,
 731		U_DISP_DP = U_DISP(%O'35') %,
 732		U_DISP_ADISP = U_DISP(%O'36') %,
 733		U_DISP_BDISP = U_DISP(%O'37') %,
 734		U_DISP_RETURN = U_DISP(%O'41') %,
 735		U_DISP_MUL = U_DISP(%O'62') %,
 736		U_DISP_PAGEFAIL = U_DISP(%O'63') %,
 737		U_DISP_NICOND = U_DISP(%O'64') %,
 738		U_DISP_BYTE = U_DISP(%O'65') %,
 739		U_DISP_EAMODE = U_DISP(%O'66') %,
 740		U_DISP_SCAD0 = U_DISP(%O'67') %,
 741	
 742		! SKIP STUFF
 743		U_SKIP(X) =
 744		    %ASSIGN(U_1,(U_1 AND %O'777777777007') OR ((X)^3)) %,
 745	
 746		U_SKIP_IOLGL = U_SKIP(%O'04') %,
 747		U_SKIP_LLE = U_SKIP(%O'12') %,
 748		U_SKIP_CRY0 = U_SKIP(%O'31') %,
 749		U_SKIP_ADLEQ0 = U_SKIP(%O'32') %,
 750		U_SKIP_ADREQ0 = U_SKIP(%O'33') %,
 751		U_SKIP_KERNEL = U_SKIP(%O'34') %,
 752		U_SKIP_FPD = U_SKIP(%O'35') %,
 753		U_SKIP_AC0 = U_SKIP(%O'36') %,
 754		U_SKIP_INT = U_SKIP(%O'37') %,
 755		U_SKIP_LE = U_SKIP(%O'42') %,
 756		U_SKIP_CRY2 = U_SKIP(%O'51') %,
 757		U_SKIP_DP0 = U_SKIP(%O'52') %,
 758		U_SKIP_DP18 = U_SKIP(%O'53') %,
 759		U_SKIP_IOT = U_SKIP(%O'54') %,
 760		U_SKIP_JFCL = U_SKIP(%O'55') %,
 761		U_SKIP_CRY1 = U_SKIP(%O'56') %,
 762		U_SKIP_TXXX = U_SKIP(%O'57') %,
 763		U_SKIP_TRAP_CYC = U_SKIP(%O'61') %,
 764		U_SKIP_ADEQ0 = U_SKIP(%O'62') %,
 765		U_SKIP_SC = U_SKIP(%O'63') %,
 766		U_SKIP_EXECUTE = U_SKIP(%O'64') %,
 767		U_SKIP_IO_BUSY = U_SKIP(%O'65') %,
 768		U_SKIP_CONTINUE = U_SKIP(%O'66') %,
 769		U_SKIP_1_MS = U_SKIP(%O'67') %,
 770	
 771		! TIME FIELD [O.E. "UT" = MDN.E. "OUT"]
 772		U_T(X) =
 773		    %ASSIGN(U_1,(U_1 AND %O'777777777774') OR (X)) %,
 774	
 775		! RANDOM CONTROL BITS
 776	
 777		! INJECT A CARRY
 778		U_CRY38 =
 779		    %ASSIGN(U_2,U_2 OR (1^35)) %,
 780	
 781		! LOAD SC FROM SCAD
 782		U_LOADSC =
 783		    %ASSIGN(U_2,U_2 OR (1^34)) %,
 784	
 785		! LOAD FE FROM SCAD
 786		U_LOADFE =
 787		    %ASSIGN(U_2,U_2 OR (1^33)) %,
 788	
 789		! WRITE THE RAM FILE
 790		U_FMWRITE =
 791		    %ASSIGN(U_2,U_2 OR (1^32)) %,
 792	
 793		! START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
 794		U_MEM =
 795		    %ASSIGN(U_2,U_2 OR (1^31)) %,
 796	
 797		! THIS MICROINSTRUCTION IS DOING A DIVIDE
 798		U_DIVIDE =
 799		    %ASSIGN(U_2,U_2 OR (1^30)) %,
 800	
 801		! MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
 802		U_MULTI_PREC =
 803		    %ASSIGN(U_2,U_2 OR (1^29)) %,
 804	
 805		! FAST SHIFT
 806		U_MULTI_SHIFT =
 807		    %ASSIGN(U_2,U_2 OR (1^28)) %,
 808	
 809		! CALL
 810		U_CALL =
 811		    %ASSIGN(U_2,U_2 OR (1^27)) %,
 812	
 813		! MAGIC NUMBER FIELD (#)
 814		U_N(O_N) =
 815		    %ASSIGN(U_2,U_2 OR (%O %STRING(O_N))) %,
 816	
 817		! MAGIC NUMBER FIELD REDEFINED FOR SHIFT-COUNT ADDER (SCAD) CONTROL
 818	
 819		! SCAD FUNCTION
 820		U_SCAD(X) =
 821		    %ASSIGN(U_2,(U_2 AND %O'777777077777') OR ((X)^15)) %,
 822	
 823		U_SCAD_A_MUL2 = U_SCAD(0) %,
 824		U_SCAD_OR = U_SCAD(1) %,
 825		U_SCAD_SUBB = U_SCAD(2) %,
 826		U_SCAD_SUB = U_SCAD(3) %,
 827		U_SCAD_ADD = U_SCAD(4) %,
 828		U_SCAD_AND = U_SCAD(5) %,
 829		U_SCAD_A_DEC = U_SCAD(6) %,
 830		U_SCAD_A = U_SCAD(7) %,
 831	
 832		! SCAD A INPUT MUX
 833		U_SCADA(X) =
 834		    %ASSIGN(U_2,(U_2 AND %O'777777707777') OR ((X)^12)) %,
 835	
 836		U_SCADA_SC = U_SCADA(0) %,
 837		U_SCADA_SN = U_SCADA(1) %,
 838		U_SCADA_PTR44 = U_SCADA(2) %,
 839		U_SCADA_BYTE1 = U_SCADA(3) %,
 840		U_SCADA_BYTE2 = U_SCADA(4) %,
 841		U_SCADA_BYTE3 = U_SCADA(5) %,
 842		U_SCADA_BYTE4 = U_SCADA(6) %,
 843		U_SCADA_BYTE5 = U_SCADA(7) %,
 844	
 845		! SCAD B INPUT MUX
 846		U_SCADB(X) =
 847		    %ASSIGN(U_2,(U_2 AND %O'777777771777') OR ((X)^10)) %,
 848	
 849		U_SCADB_FE = U_SCADB(0) %,
 850		U_SCADB_EXP = U_SCADB(1) %,
 851		U_SCADB_SHIFT = U_SCADB(2) %,
 852		U_SCADB_SIZE = U_SCADB(3) %,
 853	
 854		! SCAD/SMALL NUMBER FIELD
 855		U_SN(O_SN) =
 856		    %ASSIGN(U_2,(U_2 AND %O'777777776000') OR (%O %STRING(O_SN))) %,
 857	
 858		! MICROINSTRUCTION BUILDER
 859		!	 HANDLE DEFAULTS FOR FIELDS WHICH DEFAULT TO OTHER FIELDS.
 860		!	 EXPAND OUT TO THE 3 WORDS (108 BIT FORMAT) WITH COMMAS.
 861		!	 RESET ALL THE COMPILETIME VARIABLES TO THEIR ORIGINAL VALUES.
 862		U =
 863		    
 864		! DEFAULT RSRC = LSRC
 865		    %IF (U_SET AND U_SET_RSRC) EQL 0
 866		    %THEN
 867			%ASSIGN(U_0,U_0 OR ((U_0^(-3)) AND %O'700000'))
 868		    %FI
 869	
 870		! DEFAULT GENL = ALU_PARITY_OK
 871		    %IF (U_SET AND U_SET_GENL) EQL 0
 872		    %THEN
 873			%ASSIGN(U_1,U_1 OR ((U_3^(-10)) AND %O'000200000000'))
 874		    %FI
 875	
 876		! DEFAULT GENR = ALU_PARITY_OK
 877		    %IF (U_SET AND U_SET_GENR) EQL 0
 878		    %THEN
 879			%ASSIGN(U_1,U_1 OR ((U_3^(-13)) AND %O'000020000000'))
 880		    %FI
 881	
 882		    U_0,U_1,U_2
 883	
 884		    %ASSIGN(U_0,U_0_DEFAULT)
 885		    %ASSIGN(U_1,U_1_DEFAULT)
 886		    %ASSIGN(U_2,U_2_DEFAULT)
 887		    %ASSIGN(U_3,U_3_DEFAULT)
 888		    %ASSIGN(U_SET,0) %;
 889	
 890	!
 891	! EQUATED SYMBOLS:
 892	!
 893	
 894	    LITERAL
 895	
 896		! MICROINSTRUCTION WITH DEFAULT FIELDS
 897		U_0_DEFAULT = %O'000044030000',
 898		U_1_DEFAULT = %O'417440070703',
 899		U_2_DEFAULT = %O'000000000000',
 900		U_3_DEFAULT = %O'000000000000',
 901	
 902		! MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
 903		U_SET_RSRC = %O'1',
 904		U_SET_GENL = %O'2',
 905		U_SET_GENR = %O'4';
 906	
 907	    COMPILETIME
 908	
 909		! MICROINSTRUCTION BEING BUILT
 910		U_0 = U_0_DEFAULT,
 911		U_1 = U_1_DEFAULT,
 912		U_2 = U_2_DEFAULT,
 913		U_3 = U_3_DEFAULT,
 914		U_SET = 0;
 915	
 916	! END OF "KSU.R36"
 917	
 918	REQUIRE 'CSLMAC.R36';				!'CSL' INTERFACE MACROS
 919	
 920	!
 921	!			  COPYRIGHT (c) 1977, 1978 BY
 922	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 923	!
 924	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 925	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 926	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 927	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 928	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 929	! TRANSFERRED.
 930	!
 931	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 932	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 933	! CORPORATION.
 934	!
 935	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 936	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 937	!
 938	
 939	!++
 940	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 941	!
 942	! ABSTRACT:
 943	!
 944	!	THIS FILE CONTAINS MACROS WHICH ARE USED TO COMMUNICATE WITH THE
 945	!	'CSL' PROGRAM.  THE MACROS EXPAND TO LUUO CALLS WHICH PERFORM TTY
 946	!	INPUT AND OUTPUT AND SEND ASCIZ COMMAND LINES TO THE 8080.
 947	!
 948	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 949	!
 950	! AUTHOR:  RICH MURATORI	, CREATION DATE:  12-DEC-78
 951	!
 952	! MODIFIED BY:
 953	!
 954	!  RICH MURATORI, 12-DEC-78 : VERSION 0.1
 955	!--
 956	
 957	BUILTIN UUO;
 958	
 959	LITERAL
 960		ER_AC = 1,
 961		EI_AC = 2,
 962		EJ_AC = 3,
 963		EK_AC = 4,
 964		EB_AC = 5,
 965		EC_AC = 6,
 966		EM_AC = 7,
 967		PM_AC = 8,
 968		X1A_AC = 9,
 969		X1B_AC = 10;
 970	
 971	
 972	!MACROS TO DEFINE PRINTING CALLS MADE TO 'CSL' PROGRAM VIA UUO
 973	
 974	BIND CR_LF = UPLIT(%CHAR(13,10,0));
 975	
 976	MACRO
 977		PRINT_CRLF	= BEGIN
 978				  AC0 = CR_LF;
 979				  UUO(0,31,15,0);
 980				  END%,
 981		PNTSIX(MSGWORD)	= BEGIN
 982				  AC0 = MSGWORD;
 983				  UUO(0,31,0,2);
 984				  END%,
 985		PRINT_MSG(MSGADR)= BEGIN
 986				  AC0 = MSGADR;
 987				  UUO(0,31,15,0);
 988				  END%,
 989		PRINT_WORD(ADDR) = BEGIN
 990				   AC0 = ADDR;
 991				   UUO(0,31,0,0);
 992				   END%,
 993		PRINT_TXT(TEXT) = BEGIN
 994				  AC0 = UPLIT(%ASCIZ TEXT);
 995				  UUO(0,31,15,0);
 996				  END%,
 997		PTXT_CRLF(TEXT)	= BEGIN
 998				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
 999				  UUO(0,31,15,0);
1000				  END%,
1001		PRINT_DEC(NUM)	= BEGIN
1002				  AC0 = NUM;
1003				  UUO(0,31,13,0);
1004				  END%,
1005		PRT_CRLF_F	= BEGIN
1006				  AC0 = CR_LF;
1007				  UUO(0,31,15,1);
1008				  END%,
1009		PRT_MSG_F(MSGADR)= BEGIN
1010				  AC0 = MSGADR;
1011				  UUO(0,31,15,1);
1012				  END%,
1013		PRT_TXT_F(TEXT) = BEGIN
1014				  AC0 = UPLIT(%ASCIZ TEXT);
1015				  UUO(0,31,15,1);
1016				  END%,
1017		PTXT_CRLF_F(TEXT) = BEGIN
1018				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
1019				  UUO(0,31,15,1);
1020				  END%,
1021		PRT_DEC_F(NUM)	= BEGIN
1022				  AC0 = NUM;
1023				  UUO(0,31,13,1);
1024				  END%,
1025		PRINT_OCT_1(NUM)= BEGIN
1026				  AC0 = NUM;
1027				  UUO(0,31,1,0);
1028				  END%,
1029		PRINT_OCT_2(NUM)= BEGIN
1030				  AC0 = NUM;
1031				  UUO(0,31,2,0);
1032				  END%,
1033		PRINT_OCT_3(NUM)= BEGIN
1034				  AC0 = NUM;
1035				  UUO(0,31,3,0);
1036				  END%,
1037		PRINT_OCT_4(NUM)= BEGIN
1038				  AC0 = NUM;
1039				  UUO(0,31,4,0);
1040				  END%,
1041		PRINT_OCT_5(NUM)= BEGIN
1042				  AC0 = NUM;
1043				  UUO(0,31,5,0);
1044				  END%,
1045		PRINT_OCT_6(NUM)= BEGIN
1046				  AC0 = NUM;
1047				  UUO(0,31,6,0);
1048				  END%,
1049		PRINT_OCT_7(NUM)= BEGIN
1050				  AC0 = NUM;
1051				  UUO(0,31,7,0);
1052				  END%,
1053		PRINT_OCT_8(NUM)= BEGIN
1054				  AC0 = NUM;
1055				  UUO(0,31,8,0);
1056				  END%,
1057		PRINT_OCT_11(NUM)= BEGIN
1058				  AC0 = NUM;
1059				  UUO(0,31,11,0);
1060				  END%,
1061		PRINT_OCT_12(NUM)= BEGIN
1062				  AC0 = NUM;
1063				  UUO(0,31,12,0);
1064				  END%,
1065		POCT_SUP(NUM)	= BEGIN
1066				  AC0 = NUM;
1067				  UUO(0,31,14,3);
1068				  END%,
1069		PBELL		= UUO(0,31,1,7)%,
1070	
1071	!MACROS TO DEFINE UUO CALLS TO 'CSL' PROGRAM FOR TTY INPUT
1072	
1073		TT_ALTM = UUO(1,31,7,3)%,
1074		TTI_YES = UUO(1,31,1,3)%,
1075		TTI_CLR = UUO(0,31,10,3)%,
1076		TTI_DEC = UUO(1,31,4,3)%,
1077	
1078	!MACRO TO DEFINE END OF PROGRAM UUO
1079	
1080		EOP_UUO = UUO(0,31,14,4)%,
1081	
1082	!MACROS TO DEFINE UUO CALLS TO 'CSL' TO SEND CMD STRINGS WITH RESPONSE
1083	
1084		SEND_ER_LINE = UUO(0,1,ER_AC,0)%,
1085		SEND_EI_LINE = UUO(0,1,EI_AC,0)%,
1086		SEND_EJ_LINE = UUO(0,1,EJ_AC,0)%,
1087		SEND_EK_LINE = UUO(0,1,EK_AC,0)%,
1088		SEND_EB_LINE = UUO(0,1,EB_AC,0)%,
1089		SEND_EC_LINE = UUO(0,1,EC_AC,0)%,
1090		SEND_EM_LINE = UUO(0,1,EM_AC,0)%,
1091		SEND_PM_LINE = UUO(0,1,PM_AC,0)%,
1092		SEND_X1A_LINE = UUO(0,1,X1A_AC,0)%,
1093		SEND_X1B_LINE = UUO(0,1,X1B_AC,0)%,
1094	
1095	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD STRING
1096	
1097		SEND_CMD_LINE = UUO(0,1,0,0)%,
1098	
1099	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD LINE
1100	
1101		SEND_UUO_1 = UUO(0,1,1,0)%,
1102	
1103	!MACRO TO DEFINE ERROR MESSAGE CHECK CALL TO 'CSL'
1104	
1105		MSG_CHK_UUO = UUO(0,3,0,0)%,
1106	
1107	!MACRO TO DEFINE 'CSL' UUO TO PASS CONTROL-T INFO
1108	
1109		SEND_INFO = UUO(0,3,1,0)%,
1110	
1111	!MACROS TO DEFINE FILE HANDLING UUOS TO 'CSL' PROGRAM
1112	
1113		FSELECT(FILNAM_ADR)	= (AC0 = FILNAM_ADR;
1114					  UUO(1,31,5,4))%,
1115		FRDPAG	= UUO(1,31,8,4)%;
1116	
1117	!8080 ERROR MESSAGE FORMATS WHICH ARE CHECKED FOR.
1118	
1119	BIND
1120		HALTED = UPLIT(%ASCIZ '%HLTD'),
1121		MEM_REF_ERR = UPLIT(%ASCIZ '?MRE'),
1122		PAR_ERR = UPLIT(%ASCIZ '?PAR_ERR');
1123	
1124	! END OF 'CSL.MAC'
1125	REQUIRE 'STIRSD.R36';				!LINKAGE TO 'MSSTRC' DEFINITIONS
1126	
1127	!
1128	!			  COPYRIGHT (c) 1977, 1978 BY
1129	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
1130	!
1131	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
1132	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
1133	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
1134	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
1135	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
1136	! TRANSFERRED.
1137	!
1138	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
1139	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
1140	! CORPORATION.
1141	!
1142	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
1143	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
1144	!
1145	
1146	!++
1147	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
1148	!
1149	! ABSTRACT:
1150	!
1151	!	THESE ARE THE COMMON DECLARATIONS WHICH ARE USED BY THE TEST MODULES
1152	!	FOR THE DIFFERENT STIRS DIAGNOSTICS.
1153	!
1154	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
1155	!
1156	! AUTHOR: ARON INSINGA, CREATION DATE: 01-SEP-78
1157	!
1158	! MODIFIED BY:
1159	!
1160	!	ARON INSINGA, 23-MAY-79: VERSION 0.1
1161	!--
1162	
1163	!
1164	! MACROS:
1165	!
1166	
1167	    MACRO
1168		LOAD_U(CRAM_ADDR,SOURCE_ADDR) = LOADUC(%O %STRING(CRAM_ADDR),SOURCE_ADDR) %,
1169		LC(O_CRAM_ADDR) = LCA(%O %STRING(O_CRAM_ADDR)) %,
1170		SET_C(O_CRAM_ADDR) = SETNXT(%O %STRING(O_CRAM_ADDR)) %,
1171		STEP_U_NEXT(N) = (CP(N);EX_NXT) %,
1172		BEGIN_XLIST = BEGIN SWITCHES LIST(NOSOURCE); %,
1173		END_LIST = SWITCHES LIST(SOURCE); END %,
1174		DM(ADDR,DATA) = MEM_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
1175		EM(ADDR) = MEM_EXAMINE(%O %STRING(ADDR)) %,
1176		DI(ADDR,DATA) = IO_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
1177		EI(ADDR) = IO_EXAMINE(%O %STRING(ADDR)) %,
1178		EX_NXT = EXNEXT() %,
1179		RD_0	= REG_EXAMINE(%O'0')%,
1180		RD_1	= REG_EXAMINE(%O'1')%,
1181		RD_2	= REG_EXAMINE(%O'2')%,
1182		RD_3	= REG_EXAMINE(%O'3')%,
1183		RD_100	= REG_EXAMINE(%O'100')%,
1184		RD_101	= REG_EXAMINE(%O'101')%,
1185		RD_102	= REG_EXAMINE(%O'102')%,
1186		RD_103	= REG_EXAMINE(%O'103')%,
1187		RD_300	= REG_EXAMINE(%O'300')%,
1188		RD_301	= REG_EXAMINE(%O'301')%,
1189		RD_303	= REG_EXAMINE(%O'303')%;
1190	
1191	!
1192	! EQUATED SYMBOLS:
1193	!
1194	
1195	    BUILTIN
1196		POINT,
1197		SCANI,
1198		REPLACEI;
1199	
1200	    EXTERNAL ROUTINE
1201		CONTROL: NOVALUE, 
1202		MEMSIZE,
1203		ERR: NOVALUE,
1204		ERRCA: NOVALUE,
1205		ERRCAS: NOVALUE,
1206		ERRS: NOVALUE,
1207		ERRM: NOVALUE,
1208		ERMCA: NOVALUE,
1209		ERMCAS: NOVALUE,
1210		ERMS: NOVALUE,
1211		NOERR: NOVALUE,
1212		FAILURE: NOVALUE,
1213		LOOP_CHK,
1214		FLP_CHK,
1215		CHK_ERR_MSG: NOVALUE,
1216		WAIT: NOVALUE,
1217		SEND_LINE,
1218		REPEAT: NOVALUE,
1219		PTSTNUM: NOVALUE,
1220		CP: NOVALUE,
1221		CP_NOSS: NOVALUE,
1222		SEND_NUL,
1223		SETNXT: NOVALUE,
1224		EXNEXT,
1225		WR_CRAM,
1226		X1,
1227		LOADUC: NOVALUE,
1228		MR: NOVALUE,
1229		PE: NOVALUE,
1230		CE: NOVALUE,
1231		CS: NOVALUE,
1232		CH: NOVALUE,
1233	        TP: NOVALUE,
1234	        TE: NOVALUE,
1235		EJ,
1236		SC_0: NOVALUE,
1237		EC,
1238		LCA: NOVALUE,
1239		DC_035: NOVALUE,
1240		MOD_FLD: NOVALUE,
1241		DM_CHK,
1242		MEM_DEPOSIT: NOVALUE,
1243		MEM_EXAMINE,
1244		EM_CHK,
1245		DN: NOVALUE,
1246		IO_DEPOSIT: NOVALUE,
1247		IO_EXAMINE,
1248		EI_CHK,
1249		REG_EXAMINE,
1250		WRT100: NOVALUE,
1251		WRT102: NOVALUE,
1252		WRT103: NOVALUE,
1253		WRT104: NOVALUE,
1254		WRT105: NOVALUE,
1255		WRT106: NOVALUE,
1256		WRT107: NOVALUE,
1257		WRT110: NOVALUE,
1258		WRT111: NOVALUE,
1259		WRT112: NOVALUE,
1260		WRT113: NOVALUE,
1261		WRT114: NOVALUE,
1262		WRT115: NOVALUE,
1263		WRT116: NOVALUE,
1264		WRT204: NOVALUE,
1265		WRT205: NOVALUE,
1266		WRT206: NOVALUE,
1267		WRT210: NOVALUE,
1268		WRT212: NOVALUE,
1269		SYNC_CLK: NOVALUE,
1270		TICK: NOVALUE;
1271	
1272	    EXTERNAL
1273		NO_SUBSET,
1274		LPONTST,
1275		TIMOUT,
1276		RPT_ERR_FLAG,
1277		ERRFLG;
1278	
1279	! END OF "STIRSD.R36"
1280	
1281	
1282	!
1283	! MACROS:
1284	!
1285	
1286	!
1287	! EQUATED SYMBOLS:
1288	!
1289	
1290	GLOBAL LITERAL
1291		TEST_VERSION = 1,			!VERSION NUMBER FOR THIS MODULE
1292		TEST_EDIT = 1;				!EDIT NUMBER FOR THIS MODULE
1293	
1294	GLOBAL BIND
1295		MSGFIL = UPLIT(%SIXBIT 'MSCRA',%SIXBIT 'MSG'),
1296		PRGNAM = UPLIT(%ASCIZ 'KS10 STIMULUS-RESPONSE DIAGNOSTIC FOR THE M8622/CRA BOARD');
1297	
1298	
1299	!
1300	! OWN STORAGE:
1301	!
1302	
1303	!
1304	! EXTERNAL REFERENCES:
1305	!
1306	
1307	
1308	GLOBAL ROUTINE SPEC_DIALOGUE: NOVALUE =
1309	!++
1310	! FUNCTIONAL DESCRIPTION
1311	!
1312	!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PERFORM ANY
1313	!	SPECIAL USER DIALOGUE BEFORE THE ACTIVATED FEATURES ARE LISTED.
1314	!	SINCE THIS TEST MODULE HAS NO SPECIAL DIALOGUE, THIS ROUTINE IS NUL.
1315	!
1316	! FORMAL PARAMETERS:
1317	!
1318	!	NONE
1319	!
1320	! IMPLICIT INPUTS:
1321	!
1322	!	NONE
1323	!
1324	! IMPLICIT OUTPUTS:
1325	!
1326	!	NONE
1327	!
1328	! ROUTINE VALUE:
1329	!
1330	!	NONE
1331	!
1332	! SIDE EFFECTS:
1333	!
1334	!	NONE
1335	!
1336	!--
1337		BEGIN
1338		0				!TO PREVENT INFO MSG WHEN COMPILING
1339		END;
1340	
1341	GLOBAL ROUTINE SPEC_PRT =
1342	
1343	!++
1344	! FUNCTIONAL DESCRIPTION
1345	!
1346	!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO PRINT ANY SPECIAL
1347	!	PROGRAM FEATURES WHICH MAY BE ACTIVATED.  SINCE THIS TEST MODULE HAS NO
1348	!	SPECIAL FEATURES, THE ROUTINE IS NUL.
1349	!
1350	! FORMAL PARAMETERS:
1351	!
1352	!	NONE
1353	!
1354	! IMPLICIT INPUTS:
1355	!
1356	!	NONE
1357	!
1358	! IMPLICIT OUTPUTS:
1359	!
1360	!	NONE
1361	!
1362	! ROUTINE VALUE:
1363	!
1364	!	NONE
1365	!
1366	! SIDE EFFECTS:
1367	!
1368	!	NONE
1369	!
1370	!--
1371		BEGIN
1372		0				!TO PREVENT INFO MSG WHEN COMPILING
1373		END;
1374	
1375	GLOBAL ROUTINE SPEC_ASK: NOVALUE =
1376	!++
1377	! FUNCTIONAL DESCRIPTION
1378	!
1379	!	THIS ROUTINE IS CALLED BY THE MAIN CONTROL MODULE TO ASK THE USER IF
1380	!	HE/SHE WISHES TO ACTIVATE FEATURES WHICH ARE PECULIAR TO THIS TEST
1381	!	MODULE.  SINCE THIS MODULE HAS NO SPECIAL FEATURES, THE ROUTINE IS NUL.
1382	!
1383	! FORMAL PARAMETERS:
1384	!
1385	!	NONE
1386	!
1387	! IMPLICIT INPUTS:
1388	!
1389	!	NONE
1390	!
1391	! IMPLICIT OUTPUTS:
1392	!
1393	!	NONE
1394	!
1395	! ROUTINE VALUE:
1396	!
1397	!	NONE
1398	!
1399	! SIDE EFFECTS:
1400	!
1401	!	NONE
1402	!
1403	!--
1404		BEGIN
1405		0				!TO PREVENT INFO MSG WHEN COMPILING
1406		END;
1407	
1408	GLOBAL ROUTINE TEST_INIT: NOVALUE =
1409	
1410	!++
1411	! FUNCTIONAL DESCRIPTION:
1412	!
1413	!	THIS ROUTINE INITIALIZES THE KS10 HARDWARE BEFORE ANY TESTING IS DONE.
1414	!
1415	! FORMAL PARAMETERS:
1416	!
1417	!	NONE
1418	!
1419	! IMPLICIT INPUTS:
1420	!
1421	!	NONE
1422	!
1423	! IMPLICIT OUTPUTS:
1424	!
1425	!	NONE
1426	!
1427	! ROUTINE VALUE:
1428	!
1429	!	NONE
1430	!
1431	! SIDE EFFECTS:
1432	!
1433	!	EXECUTES SEVERAL 8080 COMMAND STRINGS TO WHICH INITIALIZE THE KS10
1434	!	HARDWARE.
1435	!
1436	!--
1437		BEGIN
1438		BIND
1439			UC_PTR = PLIT(U_J(0) U_SPEC_MEMCLR U);
1440	
1441		RPT_ERR_FLAG = 0;		!SET FLAG TO NOT REPORT 8080 CMD ERRORS
1442		PE(0);				!TURN OFF 8080 PARITY DETECTION
1443		SC_0();				!TURN OFF SOFT CRAM ERR RECOVERY
1444		LOADUC(0,UC_PTR);		!LOAD MEM CLR INSTR
1445		CP_NOSS(3);			!EXECUTE INSTR TO CLEAR PAGE FAULT
1446		CLEAR_CRAM();			!CLEAR CRAM BITS IN LOC 0
1447		CP_NOSS(1);			!CLOCK ZERO ADDR INTO CURR LOC
1448		WRT204(7);			!RESET STACK, DP, AND CRAM LATCHES
1449		WRT204(0);
1450		DM(31,0);			!CLEAR KEEP ALIVE AND STATUS WORD SO 8080
1451						! WON'T TRY TO REBOOT IF TESTS GENERATE
1452						! A 'HALTED' MESSAGE.
1453	
1454		WRT114(0);			!MAKE SURE BUS CONTROL BITS ARE
1455		WRT115(0);			!CLEARED IN I/O BUFFERS
1456		SEND_NUL();			!FORCE SENDING OF COMMAND LINE
1457	
1458		CHK_ERR_MSG(PAR_ERR);		!CHECK IN CASE 'PE (1)' IS STUCK
1459		END;
1460	
1461	ROUTINE CLEAR_CRAM: NOVALUE =
1462	
1463	!++
1464	! FUNCTIONAL DESCRIPTION:
1465	!
1466	!	THIS ROUTINE DOES A MASTER RESET OF THE KS10 AND DEPOSITS ALL ZEROS
1467	!	INTO LOCATION 0 OF THE CRAM.
1468	!
1469	! FORMAL PARAMETERS:
1470	!
1471	!	NONE
1472	!
1473	! IMPLICIT INPUTS:
1474	!
1475	!	NONE
1476	!
1477	! IMPLICIT OUTPUTS:
1478	!
1479	!	NONE
1480	!
1481	! ROUTINE VALUE:
1482	!
1483	!	NONE
1484	!
1485	! SIDE EFFECTS:
1486	!
1487	!	DOES A MASTER RESET OF THE KS10 AND DEPOSITS 0 INTO CRAM LOC 0.
1488	!
1489	!--
1490		BEGIN
1491		BIND
1492			DC_0 = UPLIT(%ASCIZ 'LC0,DC0');	!CMD STRING TO DEPOSIT ZEROS
1493	
1494		MR();				!DO A KS10 MASTER RESET
1495		SEND_LINE(DC_0,0);		!INSURE CRAM BITS ARE CLEARED
1496		END;
1497	
1498	ROUTINE RESET_CRAM: NOVALUE =
1499	
1500	!++
1501	! FUNCTIONAL DESCRIPTION:
1502	!
1503	!	THIS ROUTINE IS CALLED TO TOGGLE THE 'CRA/M RESET' SIGNAL IN THE
1504	!	KS10.  THIS CLEARS THE CRAM CONTROL BITS LATCHES.
1505	!
1506	! FORMAL PARAMETERS:
1507	!
1508	!	NONE
1509	!
1510	! IMPLICIT INPUTS:
1511	!
1512	!	NONE
1513	!
1514	! IMPLICIT OUTPUTS:
1515	!
1516	!	NONE
1517	!
1518	! ROUTINE VALUE:
1519	!
1520	!	NONE
1521	!
1522	! SIDE EFFECTS:
1523	!
1524	!	CONCATENATES A COMMAND STRING TO ASSERT AND NEGATE THE 'CRA/M RESET'
1525	!	BIT IN 8080 REGISTER 204 ONTO THE CUMULATIVE COMMAND LINE.
1526	!
1527	!--
1528		BEGIN
1529		WRT204(CRAM_RESET);			!ASSERT CRA/M RESET
1530		WRT204(0);				!THEN NEGATE IT
1531		END;
1532	
1533	ROUTINE WRITE_CRAM(DIAG_FN,DATA): NOVALUE =
1534	
1535	!++
1536	! FUNCTIONAL DESCRIPTION:
1537	!
1538	!	THIS ROUTINE WRITES THE SPECIFIED DATA INTO A 12-BIT FIELD OF THE
1539	!	KS10 CRAM AS DETERMINED BY THE 'DIAG_FN' PARAMETER.  THE LOCATION
1540	!	WHICH GETS WRITTEN INTO WILL BE WHICHEVER ONE WAS LAST REFERENCED BY
1541	!	AN 'LC' OR 'EC' COMMAND.
1542	!
1543	! FORMAL PARAMETERS:
1544	!
1545	!	DIAG_FN		= DIAGNOSTIC FUNCTION CODE - 0 THRU 7
1546	!	DATA		= 12 BITS OF DATA TO BE WRITTEN INTO CRAM
1547	!
1548	! IMPLICIT INPUTS:
1549	!
1550	!	NONE
1551	!
1552	! IMPLICIT OUTPUTS:
1553	!
1554	!	NONE
1555	!
1556	! ROUTINE VALUE:
1557	!
1558	!	NONE
1559	!
1560	! SIDE EFFECTS:
1561	!
1562	!	WRITES SPECIFIED DATA INTO SPECIFIED FIELD OF KS10 CRAM.
1563	!
1564	!--
1565		BEGIN
1566		CLK_DATA(.DATA);		!CLOCK DATA TO CRA BOARD
1567		WRT205(.DIAG_FN);		!SET DIAG FN
1568		WRT204(CRAM_WRT);		!WRITE DATA INTO CRAM
1569		WRT204(0);			!CLEAR WRITE BIT
1570		END;
1571	
1572	ROUTINE CLK_DATA(DATA): NOVALUE =
1573	
1574	!++
1575	! FUNCTIONAL DESCRIPTION:
1576	!
1577	!	THIS ROUTINE CLOCKS THE SPECIFIED 12-BIT DATA INTO THE CRA BOARD
1578	!	TRANSCEIVERS.
1579	!
1580	! FORMAL PARAMETERS:
1581	!
1582	!	DATA		= 12-BIT DATA
1583	!
1584	! IMPLICIT INPUTS:
1585	!
1586	!	NONE
1587	!
1588	! IMPLICIT OUTPUTS:
1589	!
1590	!	NONE
1591	!
1592	! ROUTINE VALUE:
1593	!
1594	!	NONE
1595	!
1596	! SIDE EFFECTS:
1597	!
1598	!	CLOCKS 12 BITS OF DATA INTO THE CRA BOARD TRANSCEIVERS.
1599	!
1600	!--
1601		BEGIN
1602		WRT103(.DATA AND %O'377');	!WRITE BITS 28-35 TO REG 103
1603		WRT105((.DATA AND %O'7400')^-8); !WRITE BITS 24-27 TO REG 105
1604		WRT210(BUS_REQ + XMIT_ADR + CRA_R_CLK); !CLOCK DATA INTO CRA BOARD TRANSCEIVERS
1605		END;
1606	
1607	ROUTINE READ_DATA =
1608	
1609	!++
1610	! FUNCTIONAL DESCRIPTION:
1611	!
1612	!	THIS ROUTINE READS 12 BITS OF DATA FROM THE CRA BOARD DIAGNOSTIC MUX.
1613	!	THE MUX SELECT INPUTS WILL BE DETERMINED BY THE LAST 'LF' COMMAND
1614	!	WHICH LOADS THE DIAGNOSTIC FUNCTION CODE.
1615	!
1616	! FORMAL PARAMETERS:
1617	!
1618	!	NONE
1619	!
1620	! IMPLICIT INPUTS:
1621	!
1622	!	NONE
1623	!
1624	! IMPLICIT OUTPUTS:
1625	!
1626	!	NONE
1627	!
1628	! ROUTINE VALUE:
1629	!
1630	!	12 BIT DATA READ FROM THE CRA BOARD MUX.
1631	!
1632	! SIDE EFFECTS:
1633	!
1634	!	READS 12 BITS OF DATA FROM CRA BOARD MUX.
1635	!
1636	!--
1637		BEGIN
1638		LOCAL
1639			TEMP;
1640		WRT210(BUS_REQ + CRA_T_CLK + CLOSE_LATCH);  !READ CRA BOARD DATA INTO TRANSCEIVERS
1641		TEMP = RD_1 AND %O'17';		!GET BITS 24-27
1642		RETURN (.TEMP^8 OR RD_0);	!RETURN BITS 24-35
1643		END;
1644	
1645	ROUTINE READ_SBR =
1646	
1647	!++
1648	! FUNCTIONAL DESCRIPTION:
1649	!
1650	!	THIS ROUTINE READS THE SUBROUTINE RETURN ADDRESS FROM THE KS10 SUBROUTINE
1651	!	STACK.  IT DOES THIS BY EXECUTING AN 'EJ' COMMAND AND RETURNING THE
1652	!	'SBR' PORTION OF THE RESPONSE.
1653	!
1654	! FORMAL PARAMETERS:
1655	!
1656	!	NONE
1657	!
1658	! IMPLICIT INPUTS:
1659	!
1660	!	NONE
1661	!
1662	! IMPLICIT OUTPUTS:
1663	!
1664	!	NONE
1665	!
1666	! ROUTINE VALUE:
1667	!
1668	!	12 BIT SUBROUTINE RETURN ADDRESS
1669	!
1670	! SIDE EFFECTS:
1671	!
1672	!	EXECUTES AN 'EJ' COMMAND.
1673	!
1674	!--
1675		BEGIN
1676		RETURN .(EJ() + 3);		!EXECUTE 'EJ' CMD AND RETURN 'SBR'
1677		END;
1678	
1679	ROUTINE EC_BITS(ADDR) =
1680	
1681	!++
1682	! FUNCTIONAL DESCRIPTION:
1683	!
1684	!	THIS ROUTINE READS THE SPECIFIED KS10 CRAM ADDRESS AND RETURNS A POINTER
1685	!	TO THE 96-BIT DATA.  TO DO THIS IT EXECUTES AN 'EC' COMMAND.
1686	!
1687	! FORMAL PARAMETERS:
1688	!
1689	!	ADDR		= CRAM ADDRESS TO BE READ
1690	!
1691	! IMPLICIT INPUTS:
1692	!
1693	!	NONE
1694	!
1695	! IMPLICIT OUTPUTS:
1696	!
1697	!	NONE
1698	!
1699	! ROUTINE VALUE:
1700	!
1701	!	POINTER TO 3-WORD BUFFER CONTAINING THE 96-BIT CRAM DATA
1702	!
1703	!	POINTER -> CRAM BITS 0-35
1704	!		   CRAM BITS 36-71
1705	!		   CRAM BITS 72-95
1706	!
1707	! SIDE EFFECTS:
1708	!
1709	!	EXECUTES AN 'EC' COMMAND.
1710	!
1711	!--
1712		BEGIN
1713		LOCAL
1714			TEMP,
1715			PTR;
1716		OWN
1717			EC_BUF: VECTOR[3];	!BUFFER TO RETURN 96-BIT DATA
1718	
1719		PTR = EC(.ADDR);		!PERFORM AN EC CMD
1720		TEMP = .(.PTR + 3);		!GET WORD WITH BITS 0-23 RIGHT ADJUSTED
1721		EC_BUF[0] = .TEMP^12;		!LEFT ADJUST BITS 0-23 IN WORD 0 OF BUFFER
1722		TEMP = .(.PTR + 2);		!GET WORD WITH BITS 24-59
1723		EC_BUF[0] = .EC_BUF[0] OR ((.TEMP^-24) AND %O'7777'); !ADD BITS 24-35 RIGHT ADJUSTED
1724		EC_BUF[1] = (.TEMP AND %O'77777777')^12; !LEFT ADJUST BITS 36-59
1725		TEMP = .(.PTR + 1);		!GET WORD WITH BITS 60-95
1726		EC_BUF[1] = .EC_BUF[1] OR ((.TEMP^-24) AND %O'7777'); !ADD BITS 60-71 RIGHT ADJUSTED
1727		EC_BUF[2] = .TEMP AND %O'77777777';	!PUT BITS 72-95 IN WORD 3 OF BUFFER
1728		RETURN EC_BUF;		!RETURN POINTER TO BUFFER
1729		END;
1730	
1731	GLOBAL ROUTINE TST1: NOVALUE =
1732	
1733	!THIS TEST CHECKS THAT READING FROM THE CRA BOARD WITH DIAG FN = 7
1734	!YIELDS ALL ZEROS.
1735	
1736		BEGIN
1737		LABEL BLOCK1,ERBLK1;
1738		BIND
1739			FLP_PTR = UPLIT(%ASCIZ 'LR205,DR7,LR210,DR111,RP');
1740		LOCAL
1741			ACTUAL;
1742	
1743		DO (0) WHILE
1744	BLOCK1:	BEGIN
1745	
1746		WRT205(7);			!SET DIAG FN TO READ ZERO
1747		ACTUAL = READ_DATA();		!READ DATA FROM CRA BOARD
1748		IF .ACTUAL NEQ 0		!DID WE GET BACK ZEROS?
1749		THEN
1750	ERBLK1:		BEGIN
1751			ERMCA(1,0,.ACTUAL,4); !NO, REPORT ERROR
1752			INCR J FROM 0 TO 11 BY 1 DO
1753				IF .ACTUAL EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
1754				THEN
1755					BEGIN
1756					FAILURE(1);	!GO DO FAULT ISOLATION
1757					LEAVE ERBLK1;
1758					END;
1759			FAILURE(2);
1760			END;
1761	!*MESSAGE 1
1762	!*STIMULUS:
1763	!*	WRT 205/7	- SET DIAG FN = 7 TO READ BACK ZEROS.
1764	!*	WRT 210/111	- CLOCK DATA FROM CRA BOARD TO CSL BOARD USING
1765	!*			  'CRA T CLK ENABLE'.
1766	!*RESPONSE:
1767	!*	DATA READ BACK WAS NOT ALL ZEROS.
1768		IF FLP_CHK(1,FLP_PTR)		!GO CHECK FOR FAST ERROR LOOPING
1769	!]ERROR 1
1770	!]DMX7 BUSBUF XCVRS NTWK
1771	!]ERROR 2
1772	!]DFN7 NTWK
1773		THEN
1774			LEAVE BLOCK1 WITH 1;
1775		0				!TO PREVENT INFO MSG WHEN COMPILING
1776		END;
1777	
1778		END;
1779	
1780	GLOBAL ROUTINE TST2: NOVALUE =
1781	
1782	!THIS TEST CHECKS THAT DATA CAN BE WRITTEN TO AND READ FROM THE CRA
1783	!BOARD.  A DATA PATTERN IS CLOCKED INTO THE CRA BOARD TRANSCEIVERS THEN
1784	!IT IS READ BACK USING DIAG FN 11.
1785	
1786		BEGIN
1787		LABEL BLOCK1,ERBLK1;
1788		BIND
1789			FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR11,LR210,DR111,RP');
1790		OWN
1791			DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
1792		LOCAL
1793			ERFLG,
1794			DISCREP,
1795			CORRECT,
1796			ACTUAL;
1797	
1798		ERFLG = 0;		!INIT ERROR FLAG
1799		INCR I FROM 0 TO 1 BY 1 DO
1800		BEGIN
1801		CORRECT = .DATA[.I];		!GET TEST DATA
1802		DO (0) WHILE
1803	BLOCK1:	BEGIN
1804	
1805		CLK_DATA(.CORRECT);		!CLOCK DATA TO CRA BOARD
1806		WRT205(%O'11');			!SET DIAG FN TO READ BUS BITS
1807		ACTUAL = READ_DATA();		!READ DATA FROM CRA BOARD
1808		IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
1809		THEN
1810	ERBLK1:		BEGIN
1811			ERFLG = -1;		!SET ERROR FLAG
1812			ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
1813			DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
1814			INCR J FROM 0 TO 11 BY 1 DO
1815				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
1816				THEN
1817					BEGIN
1818					FAILURE(1);	!GO DO FAULT ISOLATION
1819					LEAVE ERBLK1;
1820					END;
1821	
1822	!CHECK IF A GROUP OF 4 BITS ARE INCORRECT
1823	
1824			INCR J FROM 0 TO 8 BY 4 DO
1825				IF (.DISCREP AND (NOT %O'17'^.J)) EQL 0
1826				THEN
1827					BEGIN
1828					FAILURE(2);	!DO FAULT ISOLATION
1829					LEAVE ERBLK1;
1830					END;
1831	! IF WE GET THIS FAR THE WHOLE WORD MUST HAVE BEEN IN ERROR.
1832	
1833			FAILURE(3);
1834			END;
1835	!*MESSAGE 1
1836	!*STIMULUS:
1837	!*	WRT 103/DATA	- WRITE DATA PATTERN INTO CSL I/O BUFFER
1838	!*	WRT 105/DATA
1839	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
1840	!*			  'CRA R CLK'.
1841	!*	WRT 205/11	- SET DIAG FN = 11 TO READ BACK BUS DATA BITS.
1842	!*	WRT 210/111	- CLOCK DATA FROM CRA BOARD TO CSL BOARD USING
1843	!*			  'CRA T CLK ENABLE'.
1844	!*RESPONSE:
1845	!*	DATA READ BACK WAS NOT WHAT WAS WRITTEN TO CRA BOARD.
1846	!]ERROR 1
1847	!]XCVRS BUSBUF DMX11 NTWK
1848	!]ERROR 2
1849	!]XCVRS BUSBUF NTWK
1850	!]ERROR 3
1851	!]TCLKC DFN11 NTWK
1852		IF FLP_CHK(1,FLP_PTR)		!GO CHECK FOR FAST ERROR LOOPING
1853		THEN
1854			LEAVE BLOCK1 WITH 1;
1855		0				!TO PREVENT INFO MSG WHEN COMPILING
1856		END;
1857		END;
1858		IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
1859		THEN
1860			NOERR(1);
1861	!]NO ERROR 1
1862	!]XCVRS BUSBUF DMX11 TCLKC DFN11 NTWK
1863	
1864		END;
1865	
1866	GLOBAL ROUTINE TST3: NOVALUE =
1867	
1868	!THIS TEST CHECKS THAT BITS 0-11 CAN BE WRITTEN INTO AND READ BACK FROM
1869	!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
1870	!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
1871	!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
1872	!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
1873	!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
1874	!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.
1875	
1876		BEGIN
1877		LABEL BLOCK1,ERBLK1;
1878		BIND
1879			FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR204,DR40,DR0,LR206,DR2,LR210,DR111,RP');
1880		OWN
1881			DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
1882		LOCAL
1883			ERFLG,
1884			DISCREP,
1885			CORRECT,
1886			ACTUAL;
1887	
1888		ERFLG = 0;		!INIT ERROR FLAG
1889		INCR I FROM 0 TO 1 BY 1 DO
1890		BEGIN
1891		CORRECT = .DATA[.I];		!GET TEST DATA
1892		DO (0) WHILE
1893	BLOCK1:	BEGIN
1894	
1895		SET_C(0);			!SET CRAM ADDRESS TO ZERO
1896		WRITE_CRAM(0,.CORRECT);		!WRITE PATTERN TO CRAM BITS 0-11
1897		WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
1898		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 0-11
1899		IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
1900		THEN
1901	ERBLK1:		BEGIN
1902			ERFLG = -1;		!SET ERROR FLAG
1903			ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
1904			DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
1905			INCR J FROM 0 TO 11 BY 1 DO
1906				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
1907				THEN
1908					BEGIN
1909					FAILURE(.J+1);	!GO DO FAULT ISOLATION
1910					LEAVE ERBLK1;
1911					END;
1912	
1913	!CHECK IF UPPER OR LOWER 6 BITS ARE INCORRECT.
1914	
1915			INCR J FROM 0 TO 1 BY 1 DO
1916				IF .DISCREP EQL %O'77'^(.J*6)
1917				THEN
1918					BEGIN
1919					FAILURE(13+.J);
1920					LEAVE ERBLK1;
1921					END;
1922			IF .ACTUAL EQL 0		!IF ACTUAL IS ALL ZEROS
1923			THEN
1924				BEGIN
1925				FAILURE(15);		!THEN, 'RESET' MUST BE STUCK
1926				LEAVE ERBLK1;
1927				END;
1928	
1929	! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.
1930	
1931			FAILURE(16);
1932			END;
1933	!*MESSAGE 1
1934	!*STIMULUS:
1935	!*	SET CRAM ADDRESS TO ZERO
1936	!*	WRT 205/0	- SET DIAG FN = 0 TO ACCESS CRAM BITS 0-11
1937	!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
1938	!*	WRT 105/DATA
1939	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
1940	!*			  'CRA R CLK'.
1941	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
1942	!*	WRT 204/0	- BITS 0-11.
1943	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
1944	!*			  LATCHES.
1945	!*	WRT 210/111	- CLOCK CRAM BITS 0-11 TO CSL BOARD.
1946	!*RESPONSE:
1947	!*	CRAM BITS 0-11 WERE NOT READ BACK AS THEY WERE WRITTEN.
1948	!]ERROR 1
1949	!]DMX0 CRM0_11 CREG2 NTWK
1950	!]ERROR 2
1951	!]DMX0 CRM0_10 CREG2 NTWK
1952	!]ERROR 3
1953	!]DMX0 CRM0_9 CREG2 NTWK
1954	!]ERROR 4
1955	!]DMX0 CRM0_8 CREG2 NTWK
1956	!]ERROR 5
1957	!]DMX0 CRM0_7 CREG2 NTWK
1958	!]ERROR 6
1959	!]DMX0 CRM0_6 CREG2 NTWK
1960	!]ERROR 7
1961	!]DMX0 CRM0_5 CREG1 NTWK
1962	!]ERROR 8
1963	!]DMX0 CRM0_4 CREG1 NTWK
1964	!]ERROR 9
1965	!]DMX0 CRM0_3 CREG1 NTWK
1966	!]ERROR 10
1967	!]DMX0 CRM0_2 CREG1 NTWK
1968	!]ERROR 11
1969	!]DMX0 CRM0_1 CREG1 NTWK
1970	!]ERROR 12
1971	!]DMX0 CRM0_0 CREG1 NTWK
1972	!]ERROR 13
1973	!]CREG1 CWRT0_5 NTWK
1974	!]ERROR 14
1975	!]CREG2 CWRT6_11 NTWK
1976	!]ERROR 15
1977	!]DFN0 CLKE CLKEN RESET NTWK
1978	!]ERROR 16
1979	!]DFN0 NTWK
1980		IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
1981		THEN
1982			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
1983		0				!TO PREVENT INFO MSG WHEN COMPILING
1984	
1985		END;
1986		END;
1987		IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
1988		THEN
1989			NOERR(1);
1990	!]NO ERROR 1
1991	!]DMX0 CWRT0_5 CWRT6_11 CLKE CLKEN DFN0 NTWK
1992	
1993		CLEAR_CRAM();			!ZERO CRAM LOC 0
1994		END;
1995	
1996	GLOBAL ROUTINE TST4: NOVALUE =
1997	
1998	!THIS TEST CHECKS THAT BITS 12-23 CAN BE WRITTEN INTO AND READ BACK FROM
1999	!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
2000	!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
2001	!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
2002	!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
2003	!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
2004	!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.
2005	
2006		BEGIN
2007		LABEL BLOCK1,ERBLK1;
2008		BIND
2009			FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR205,DR4,LR210,DR111,RP');
2010		OWN
2011			DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
2012		LOCAL
2013			ERFLG,
2014			DISCREP,
2015			CORRECT,
2016			ACTUAL;
2017	
2018		ERFLG = 0;		!INIT ERROR FLAG
2019		INCR I FROM 0 TO 1 BY 1 DO
2020		BEGIN
2021		CORRECT = .DATA[.I];		!GET TEST DATA
2022		DO (0) WHILE
2023	BLOCK1:	BEGIN
2024	
2025		SET_C(0);			!SET CRAM ADDRESS TO ZERO
2026		WRITE_CRAM(1,.CORRECT);		!WRITE PATTERN TO CRAM BITS 12-23
2027		WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
2028		WRT205(4);			!SET DIAG FN TO READ BACK BITS 12-23
2029		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 12-23
2030		IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
2031		THEN
2032	ERBLK1:		BEGIN
2033			ERFLG = -1;		!SET ERROR FLAG
2034			ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
2035			DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
2036			INCR J FROM 0 TO 11 BY 1 DO
2037				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
2038				THEN
2039					BEGIN
2040					FAILURE(.J+1);	!GO DO FAULT ISOLATION
2041					LEAVE ERBLK1;
2042					END;
2043	
2044	!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.
2045	
2046			INCR J FROM 0 TO 5 BY 1 DO
2047				IF .DISCREP EQL %O'101'^.J
2048				THEN
2049					BEGIN
2050					FAILURE(13+.J);		!THEN BITS 12-17 ARE WRONG
2051					LEAVE ERBLK1;
2052					END;
2053	
2054	!CHECK FOR ERROR IN UPPER OR LOWER 6 BITS, BUT NOT BOTH.
2055	
2056			INCR J FROM 0 TO 1 BY 1 DO
2057				IF .DISCREP EQL %O'77'^(.J*6)
2058				THEN
2059					BEGIN
2060					FAILURE(19+.J);
2061					LEAVE ERBLK1;
2062					END;
2063	
2064	!CHECK FOR DISCREPANCY PATTERNS WHICH INDICATE CLOCK FAULTS
2065	
2066			INCR J FROM 0 TO 1 BY 1 DO
2067				IF .DISCREP EQL %O'707'^(.J*6)
2068				THEN
2069					BEGIN
2070					FAILURE(21+.J);		!THEN BITS 12-17 ARE WRONG
2071					LEAVE ERBLK1;
2072					END;
2073	
2074			IF .ACTUAL EQL 0		!IF ACTUAL IS ALL ZEROS
2075			THEN
2076				BEGIN
2077				FAILURE(23);		!THEN, 'RESET' MUST BE STUCK
2078				LEAVE ERBLK1;
2079				END;
2080	
2081	! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.
2082	
2083			FAILURE(24);
2084			END;
2085	!*MESSAGE 1
2086	!*STIMULUS:
2087	!*	SET CRAM ADDRESS TO ZERO
2088	!*	WRT 205/1	- SET DIAG FN = 1 TO ACCESS CRAM BITS 12-23
2089	!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
2090	!*	WRT 105/DATA
2091	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
2092	!*			  'CRA R CLK'.
2093	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
2094	!*	WRT 204/0	- BITS 12-23.
2095	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
2096	!*			  LATCHES.
2097	!*	WRT 205/4	- SET DIAG FN = 4 TO READ CRAM BITS 12-23.
2098	!*	WRT 210/111	- CLOCK CRAM BITS 12-23 TO CSL BOARD.
2099	!*RESPONSE:
2100	!*	CRAM BITS 12-23 WERE NOT READ BACK AS THEY WERE WRITTEN.
2101	!]ERROR 1
2102	!]DMX4 CRM0_23 CREG8 NTWK
2103	!]ERROR 2
2104	!]DMX4 CRM0_22 CREG7 NTWK
2105	!]ERROR 3
2106	!]DMX4 CRM0_21 CREG6 NTWK
2107	!]ERROR 4
2108	!]DMX4 CRM0_20 CREG5 NTWK
2109	!]ERROR 5
2110	!]DMX4 CRM0_19 CREG4 NTWK
2111	!]ERROR 6
2112	!]DMX4 CRM0_18 CREG3 NTWK
2113	!]ERROR 7
2114	!]DMX4 CRM0_17 CREG8 NTWK
2115	!]ERROR 8
2116	!]DMX4 CRM0_16 CREG7 NTWK
2117	!]ERROR 9
2118	!]DMX4 CRM0_15 CREG6 NTWK
2119	!]ERROR 10
2120	!]DMX4 CRM0_14 CREG5 NTWK
2121	!]ERROR 11
2122	!]DMX4 CRM0_13 CREG4 NTWK
2123	!]ERROR 12
2124	!]DMX4 CRM0_12 CREG3 NTWK
2125	!]ERROR 13
2126	!]CREG8 NTWK
2127	!]ERROR 14
2128	!]CREG7 NTWK
2129	!]ERROR 15
2130	!]CREG6 NTWK
2131	!]ERROR 16
2132	!]CREG5 NTWK
2133	!]ERROR 17
2134	!]CREG4 NTWK
2135	!]ERROR 18
2136	!]CREG3 NTWK
2137	!]ERROR 19
2138	!]CWRT12_17 NTWK
2139	!]ERROR 20
2140	!]CWRT18_23 NTWK
2141	!]ERROR 21
2142	!]CLKJ SYNCH NTWK
2143	!]ERROR 22
2144	!]CLKH SYNCH NTWK
2145	!]ERROR 23
2146	!]SYNCH DFN1 DFN4 RESET NTWK
2147	!]ERROR 24
2148	!]DFN1 DFN4 NTWK
2149		IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
2150		THEN
2151			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2152		0				!TO PREVENT INFO MSG WHEN COMPILING
2153	
2154		END;
2155		END;
2156		IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
2157		THEN
2158			NOERR(1);
2159	!]NO ERROR 1
2160	!]DFN1 DMX4 DFN4 CLKJ SYNCH CLKH SYNCH CWRT18_23 CWRT12_17 NTWK
2161	
2162		CLEAR_CRAM();			!ZERO CRAM LOC 0
2163		END;
2164	
2165	GLOBAL ROUTINE TST5: NOVALUE =
2166	
2167	!THIS TEST CHECKS THAT BITS 24-35A CAN BE WRITTEN INTO AND READ BACK FROM
2168	!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
2169	!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
2170	!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
2171	!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
2172	!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
2173	!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.
2174	
2175		BEGIN
2176		LABEL BLOCK1,ERBLK1;
2177		BIND
2178			FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR205,DR5,LR210,DR111,RP');
2179		OWN
2180			DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
2181		LOCAL
2182			ERFLG,
2183			DISCREP,
2184			CORRECT,
2185			ACTUAL;
2186	
2187		ERFLG = 0;		!INIT ERROR FLAG
2188		INCR I FROM 0 TO 1 BY 1 DO
2189		BEGIN
2190		CORRECT = .DATA[.I];		!GET TEST DATA
2191		DO (0) WHILE
2192	BLOCK1:	BEGIN
2193	
2194		SET_C(0);			!SET CRAM ADDRESS TO ZERO
2195		WRITE_CRAM(2,.CORRECT);		!WRITE PATTERN TO CRAM BITS 24-35
2196		WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
2197		WRT205(5);			!SET DIAG FN TO READ BACK BITS 24-35A
2198		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35A
2199		IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
2200		THEN
2201	ERBLK1:		BEGIN
2202			ERFLG = -1;		!SET ERROR FLAG
2203			ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
2204			DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
2205			INCR J FROM 0 TO 11 BY 1 DO
2206				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
2207				THEN
2208					BEGIN
2209					FAILURE(.J+1);	!GO DO FAULT ISOLATION
2210					LEAVE ERBLK1;
2211					END;
2212	
2213	!CHECK FOR ERROR IN UPPER OR LOWER 6 BITS, BUT NOT BOTH.
2214	
2215			INCR J FROM 0 TO 1 BY 1 DO
2216				IF .DISCREP EQL %O'77'^(.J*6)
2217				THEN
2218					BEGIN
2219					FAILURE(13+.J);
2220					LEAVE ERBLK1;
2221					END;
2222	
2223	
2224			IF .ACTUAL EQL 0		!IF ACTUAL IS ALL ZEROS
2225			THEN
2226				BEGIN
2227				FAILURE(15);		!THEN, 'RESET' MUST BE STUCK
2228				LEAVE ERBLK1;
2229				END;
2230	! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.
2231	
2232			FAILURE(16);
2233			END;
2234	!*MESSAGE 1
2235	!*STIMULUS:
2236	!*	SET CRAM ADDRESS TO ZERO
2237	!*	WRT 205/2	- SET DIAG FN = 2 TO WRITE CRAM BITS 24-35A
2238	!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
2239	!*	WRT 105/DATA
2240	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
2241	!*			  'CRA R CLK'.
2242	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
2243	!*	WRT 204/0	- BITS 24-35A.
2244	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
2245	!*			  LATCHES.
2246	!*	WRT 205/5	- SET DIAG FN = 5 TO READ CRAM BITS 24-35A.
2247	!*	WRT 210/111	- CLOCK CRAM BITS 24-35A TO CSL BOARD.
2248	!*RESPONSE:
2249	!*	CRAM BITS 24-35A WERE NOT READ BACK AS THEY WERE WRITTEN.
2250	!]ERROR 1
2251	!]DMX5 CRM0_35 CREG8 NTWK
2252	!]ERROR 2
2253	!]DMX5 CRM0_34 CREG7 NTWK
2254	!]ERROR 3
2255	!]DMX5 CRM0_33 CREG6 NTWK
2256	!]ERROR 4
2257	!]DMX5 CRM0_32 CREG5 NTWK
2258	!]ERROR 5
2259	!]DMX5 CRM0_31 CREG4 NTWK
2260	!]ERROR 6
2261	!]DMX5 CRM0_30 CREG3 NTWK
2262	!]ERROR 7
2263	!]DMX5 CRM0_29 CREG8 NTWK
2264	!]ERROR 8
2265	!]DMX5 CRM0_28 CREG7 NTWK
2266	!]ERROR 9
2267	!]DMX5 CRM0_27 CREG6 NTWK
2268	!]ERROR 10
2269	!]DMX5 CRM0_26 CREG5 NTWK
2270	!]ERROR 11
2271	!]DMX5 CRM0_25 CREG4 NTWK
2272	!]ERROR 12
2273	!]DMX5 CRM0_24 CREG3 NTWK
2274	!]ERROR 13
2275	!]CWRT24_29 NTWK
2276	!]ERROR 14
2277	!]CWRT30_35 NTWK
2278	!]ERROR 15
2279	!]SYNCH RESET DFN2 DFN5 NTWK
2280	!]ERROR 16
2281	!]DFN2 DFN5 NTWK
2282		IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
2283		THEN
2284			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2285		0				!TO PREVENT INFO MSG WHEN COMPILING
2286	
2287		END;
2288		END;
2289		IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
2290		THEN
2291			NOERR(1);
2292	!]NO ERROR 1
2293	!]DFN2 DFN5 DMX5 CWRT24_29 CWRT30_35 NTWK
2294	
2295		CLEAR_CRAM();			!ZERO CRAM LOC 0
2296		END;
2297	
2298	GLOBAL ROUTINE TST6: NOVALUE =
2299	
2300	!THIS TEST CHECKS THAT BITS 24-35B CAN BE WRITTEN INTO AND READ BACK FROM
2301	!A LOCATION IN THE CRAM.  THE CRAM ADDRESS IS SET TO ZERO BUT AT THIS
2302	!POINT IN THE TESTING WE DON'T KNOW THAT THE ADDRESS LINES ARE GOOD. IN
2303	!ANY CASE, WE DON'T CARE WHAT ADDRESS IS REALLY BEING ACCCESSED.
2304	!THIS TEST IS CONCERNED WITH VERIFYING THAT THE DIAG FN BITS GET
2305	!DECODED CORRECTLY ON THE CRA BOARD, ALTHOUGH THE DATA LINES TO AND
2306	!FROM THE CRAM ARE ALSO IMPLICITLY CHECKED.
2307	
2308		BEGIN
2309		LABEL BLOCK1,ERBLK1;
2310		BIND
2311			FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR205,DR6,LR210,DR111,RP');
2312		OWN
2313			DATA: VECTOR[2] INITIAL(%O'5252',%O'2525');
2314		LOCAL
2315			ERFLG,
2316			DISCREP,
2317			CORRECT,
2318			ACTUAL;
2319	
2320		ERFLG = 0;		!INIT ERROR FLAG
2321		INCR I FROM 0 TO 1 BY 1 DO
2322		BEGIN
2323		CORRECT = .DATA[.I];		!GET TEST DATA
2324		DO (0) WHILE
2325	BLOCK1:	BEGIN
2326	
2327		SET_C(0);			!SET CRAM ADDRESS TO ZERO
2328		WRITE_CRAM(2,.CORRECT);		!WRITE PATTERN TO CRAM BITS 24-35
2329		WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
2330		WRT205(6);			!SET DIAG FN TO READ BACK BITS 24-35B
2331		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35B
2332		IF .ACTUAL NEQ .CORRECT		!DID DATA MAKE ROUND TRIP OKAY?
2333		THEN
2334	ERBLK1:		BEGIN
2335			ERFLG = -1;		!SET ERROR FLAG
2336			ERMCA(1,.CORRECT,.ACTUAL,4); !NO, REPORT ERROR
2337			DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
2338			INCR J FROM 0 TO 11 BY 1 DO
2339				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
2340				THEN
2341					BEGIN
2342					FAILURE(.J+1);	!GO DO FAULT ISOLATION
2343					LEAVE ERBLK1;
2344					END;
2345	
2346	! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.
2347	
2348			FAILURE(13);
2349			END;
2350	!*MESSAGE 1
2351	!*STIMULUS:
2352	!*	SET CRAM ADDRESS TO ZERO
2353	!*	WRT 205/2	- SET DIAG FN = 2 TO WRITE CRAM BITS 24-35B
2354	!*	WRT 103/DATA	- WRITE 'CORRECT' DATA INTO CSL I/O BUFFER
2355	!*	WRT 105/DATA
2356	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
2357	!*			  'CRA R CLK'.
2358	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
2359	!*	WRT 204/0	- BITS 24-35B.
2360	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
2361	!*			  LATCHES.
2362	!*	WRT 205/6	- SET DIAG FN = 6 TO READ CRAM BITS 24-35B.
2363	!*	WRT 210/111	- CLOCK CRAM BITS 24-35B TO CSL BOARD.
2364	!*RESPONSE:
2365	!*	CRAM BITS 24-35B WERE NOT READ BACK AS THEY WERE WRITTEN.
2366	!]ERROR 1
2367	!]DMX6 CRM0_35 CREG8 NTWK
2368	!]ERROR 2
2369	!]DMX6 CRM0_34 CREG7 NTWK
2370	!]ERROR 3
2371	!]DMX6 CRM0_33 CREG6 NTWK
2372	!]ERROR 4
2373	!]DMX6 CRM0_32 CREG5 NTWK
2374	!]ERROR 5
2375	!]DMX6 CRM0_31 CREG4 NTWK
2376	!]ERROR 6
2377	!]DMX6 CRM0_30 CREG3 NTWK
2378	!]ERROR 7
2379	!]DMX6 CRM0_29 CREG8 NTWK
2380	!]ERROR 8
2381	!]DMX6 CRM0_28 CREG7 NTWK
2382	!]ERROR 9
2383	!]DMX6 CRM0_27 CREG6 NTWK
2384	!]ERROR 10
2385	!]DMX6 CRM0_26 CREG5 NTWK
2386	!]ERROR 11
2387	!]DMX6 CRM0_25 CREG4 NTWK
2388	!]ERROR 12
2389	!]DMX6 CRM0_24 CREG3 NTWK
2390	!]ERROR 13
2391	!]DFN2 DFN6 NTWK
2392		IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
2393		THEN
2394			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2395		0				!TO PREVENT INFO MSG WHEN COMPILING
2396	
2397		END;
2398		END;
2399		IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
2400		THEN
2401			NOERR(1);
2402	!]NO ERROR 1
2403	!]DFN2 DFN6 DMX6 NTWK
2404	
2405		CLEAR_CRAM();			!ZERO CRAM LOC 0
2406		END;
2407	
2408	GLOBAL ROUTINE TST7: NOVALUE =
2409	
2410	!THIS TEST CHECKS THAT THE 'CRA/M RESET' SIGNAL NEGATES BITS 0-11 IN
2411	!THE CRAM REGISTER.
2412	
2413		BEGIN
2414		LABEL BLOCK1,ERBLK1;
2415		BIND
2416			FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR210,DR111,RP');
2417		LOCAL
2418			ACTUAL;
2419	
2420		DO (0) WHILE
2421	BLOCK1:	BEGIN
2422		SET_C(0);			!SET CRAM ADDRESS TO ZERO
2423		WRITE_CRAM(0,%O'7777');		!WRITE ONES TO CRAM BITS 0-11
2424		WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
2425		WRT204(CRAM_RESET);		!ASSERT 'CRA/M RESET'
2426		WRT204(0);			!NEGATE IT
2427		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 0-11
2428		IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
2429		THEN
2430	ERBLK1:		BEGIN
2431			ERMCA(1,0,.ACTUAL,4); !THEN REPORT IT
2432			IF (.ACTUAL AND %O'77') EQL 0	!IF BITS 6-11 ARE ZERO,
2433			THEN
2434				BEGIN
2435				FAILURE(1);		!THEN 0-5 DIDN'T CLEAR
2436				LEAVE ERBLK1;
2437				END;
2438			IF (.ACTUAL AND %O'7700') EQL 0	!IF BITS 0-5 ARE ZERO,
2439			THEN
2440				BEGIN
2441				FAILURE(2);		!THEN 6-11 DIDN'T CLEAR
2442				LEAVE ERBLK1;
2443				END;
2444	
2445	!IF WE GET THIS FAR ASSUME WHOLE WORD DID NOT CLEAR
2446	
2447			FAILURE(3);
2448			END;
2449	!*MESSAGE 1
2450	!*STIMULUS:
2451	!*	SET CRAM ADDRESS TO ZERO
2452	!*	WRT 205/0	- SET DIAG FN = 0 TO ACCESS CRAM BITS 0-11
2453	!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
2454	!*	WRT 105/17
2455	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
2456	!*			  'CRA R CLK'.
2457	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
2458	!*	WRT 204/0	- BITS 0-11.
2459	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
2460	!*			  LATCHES.
2461	!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
2462	!*	WRT 204/0	- NEGATE IT.
2463	!*	WRT 210/111	- CLOCK CRAM BITS 0-11 TO CSL BOARD.
2464	!*RESPONSE:
2465	!*	CRAM BITS 0-11 WERE NOT NEGATED BY 'CRA/M RESET'.
2466	!]ERROR 1
2467	!]DMX0 CREG1 NTWK
2468	!]ERROR 2
2469	!]DMX0 CREG2 NTWK
2470	!]ERROR 3
2471	!]DMX0 RESET NTWK
2472		IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
2473		THEN
2474			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2475		0				!TO PREVENT INFO MSG WHEN COMPILING
2476	
2477		END;
2478	
2479		CLEAR_CRAM();			!ZERO CRAM LOC 0
2480		END;
2481	
2482	GLOBAL ROUTINE TST8: NOVALUE =
2483	
2484	!THIS TEST CHECKS THAT THE 'CRA/M RESET' SIGNAL NEGATES BITS 12-23 IN
2485	!THE CRAM REGISTER.
2486	
2487		BEGIN
2488		LABEL BLOCK1,ERBLK1;
2489		BIND
2490			FLP_PTR = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR1,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR205,DR4,LR210,DR111,RP');
2491		LOCAL
2492			ACTUAL;
2493	
2494		DO (0) WHILE
2495	BLOCK1:	BEGIN
2496		SET_C(0);			!SET CRAM ADDRESS TO ZERO
2497		WRITE_CRAM(1,%O'7777');		!WRITE ONES TO CRAM BITS 12-23
2498		WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
2499		WRT204(CRAM_RESET);		!ASSERT 'CRA/M RESET'
2500		WRT204(0);			!NEGATE IT
2501		WRT205(4);			!SET DIAG FN TO READ BITS 12-23
2502		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 12-23
2503		IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
2504		THEN
2505	ERBLK1:		BEGIN
2506			ERMCA(1,0,.ACTUAL,4); !THEN REPORT IT
2507	
2508	!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.
2509	
2510			INCR J FROM 0 TO 5 BY 1 DO
2511				IF (.ACTUAL AND (%O'101'^.J)) EQL 0
2512				THEN
2513					BEGIN
2514					FAILURE(1+.J);		!THEN BITS 12-17 ARE WRONG
2515					LEAVE ERBLK1;
2516					END;
2517	
2518	!IF WE GET THIS FAR THE WHOLE WORD DIDN'T CLEAR
2519	
2520			FAILURE(7);
2521			END;
2522	!*MESSAGE 1
2523	!*STIMULUS:
2524	!*	SET CRAM ADDRESS TO ZERO
2525	!*	WRT 205/1	- SET DIAG FN = 1 TO ACCESS CRAM BITS 12-23
2526	!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
2527	!*	WRT 105/17
2528	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
2529	!*			  'CRA R CLK'.
2530	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
2531	!*	WRT 204/0	- BITS 12-23.
2532	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
2533	!*			  LATCHES.
2534	!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
2535	!*	WRT 204/0	- NEGATE IT.
2536	!*	WRT 205/4	-SET DIAG FN = 4 TO READ CRAM BITS 12-23
2537	!*	WRT 210/111	- CLOCK CRAM BITS 12-23 TO CSL BOARD.
2538	!*RESPONSE:
2539	!*	CRAM BITS 12-23 WERE NOT NEGATED BY 'CRA/M RESET'.
2540	!]ERROR 1
2541	!]DMX4 CREG8 NTWK
2542	!]ERROR 2
2543	!]DMX4 CREG7 NTWK
2544	!]ERROR 3
2545	!]DMX4 CREG6 NTWK
2546	!]ERROR 4
2547	!]DMX4 CREG5 NTWK
2548	!]ERROR 5
2549	!]DMX4 CREG4 NTWK
2550	!]ERROR 6
2551	!]DMX4 CREG3 NTWK
2552	!]ERROR 7
2553	!]RESET NTWK
2554		IF FLP_CHK(1,FLP_PTR)		! GO CHECK FOR FAST ERROR LOOPING
2555		THEN
2556			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2557		0				!TO PREVENT INFO MSG WHEN COMPILING
2558	
2559		END;
2560	
2561		CLEAR_CRAM();			!ZERO CRAM LOC 0
2562		END;
2563	
2564	GLOBAL ROUTINE TST9: NOVALUE =
2565	
2566	!THIS TEST CHECKS THAT THE 'CRA/M RESET' SIGNAL NEGATES BITS 24-35 A&B IN
2567	!THE CRAM REGISTER.
2568	
2569		BEGIN
2570		LABEL BLOCK1,ERBLK1,ERBLK2;
2571		BIND
2572			FLP_PTR1 = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR205,DR5,LR210,DR111,RP'),
2573			FLP_PTR2 = UPLIT(%ASCIZ 'LR210,DR144,LR205,DR2,LR204,DR40,DR0,LR206,DR2,LR204,DR1,LR205,DR6,LR210,DR111,RP');
2574		LOCAL
2575			ACTUAL;
2576	
2577		DO (0) WHILE
2578	BLOCK1:	BEGIN
2579		SET_C(0);			!SET CRAM ADDRESS TO ZERO
2580		WRITE_CRAM(2,%O'7777');		!WRITE ONES TO CRAM BITS 24-35A
2581		WRT206(SINGLE_CLK);		!CLOCK CRAM BITS INTO LATCHES
2582		WRT204(CRAM_RESET);		!ASSERT 'CRA/M RESET'
2583		WRT204(0);			!NEGATE IT
2584		WRT205(5);			!SET DIAG FN TO READ BITS 24-35A
2585		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35A
2586		IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
2587		THEN
2588	ERBLK1:		BEGIN
2589			ERMCA(1,0,.ACTUAL,4); !THEN REPORT IT
2590	
2591	!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.
2592	
2593			INCR J FROM 0 TO 5 BY 1 DO
2594				IF (.ACTUAL AND (%O'101'^.J)) EQL 0
2595				THEN
2596					BEGIN
2597					FAILURE(1+.J);		!THEN BITS 12-17 ARE WRONG
2598					LEAVE ERBLK1;
2599					END;
2600	
2601	!IF WE GET THIS FAR THE WHOLE WORD DIDN'T CLEAR
2602	
2603			FAILURE(7);
2604			END;
2605	!*MESSAGE 1
2606	!*STIMULUS:
2607	!*	SET CRAM ADDRESS TO ZERO
2608	!*	WRT 205/2	- SET DIAG FN = 2 TO ACCESS CRAM BITS 24-35A
2609	!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
2610	!*	WRT 105/17
2611	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
2612	!*			  'CRA R CLK'.
2613	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
2614	!*	WRT 204/0	- BITS 24-35A.
2615	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
2616	!*			  LATCHES.
2617	!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
2618	!*	WRT 204/0	- NEGATE IT.
2619	!*	WRT 205/5	- SET DIAG FN = 5 TO READ CRAM BITS 24-35A
2620	!*	WRT 210/111	- CLOCK CRAM BITS 24-35A TO CSL BOARD.
2621	!*RESPONSE:
2622	!*	CRAM BITS 24-35A WERE NOT NEGATED BY 'CRA/M RESET'.
2623	!]ERROR 1
2624	!]DMX5 CREG8 NTWK
2625	!]ERROR 2
2626	!]DMX5 CREG7 NTWK
2627	!]ERROR 3
2628	!]DMX5 CREG6 NTWK
2629	!]ERROR 4
2630	!]DMX5 CREG5 NTWK
2631	!]ERROR 5
2632	!]DMX5 CREG4 NTWK
2633	!]ERROR 6
2634	!]DMX5 CREG3 NTWK
2635	!]ERROR 7
2636	!]RESET NTWK
2637		IF FLP_CHK(1,FLP_PTR1)		! GO CHECK FOR FAST ERROR LOOPING
2638		THEN
2639			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2640	
2641		WRT205(6);			!SET DIAG FN TO READ BITS 24-35B
2642		ACTUAL = READ_DATA();		!READ BACK CRAM BITS 24-35B
2643		IF .ACTUAL NEQ 0		!IF DATA READ BACK IS NOT ZERO
2644		THEN
2645	ERBLK2:		BEGIN
2646			ERMCA(2,0,.ACTUAL,4); !THEN REPORT IT
2647	
2648	!CHECK FOR 2-BIT ERRORS WHICH WOULD BE CAUSED BY FAULTY CONTROL REGISTER.
2649	
2650			INCR J FROM 0 TO 5 BY 1 DO
2651				IF (.ACTUAL AND (%O'101'^.J)) EQL 0
2652				THEN
2653					BEGIN
2654					FAILURE(8+.J);		!THEN BITS 12-17 ARE WRONG
2655					LEAVE ERBLK2;
2656					END;
2657	
2658	!IF WE GET THIS FAR THE WHOLE WORD DIDN'T CLEAR
2659	
2660			FAILURE(14);
2661			END;
2662	!*MESSAGE 2
2663	!*STIMULUS:
2664	!*	SET CRAM ADDRESS TO ZERO
2665	!*	WRT 205/2	- SET DIAG FN = 2 TO ACCESS CRAM BITS 24-35B
2666	!*	WRT 103/377	- WRITES ALL ONES INTO CSL I/O BUFFER
2667	!*	WRT 105/17
2668	!*	WRT 210/144	- CLOCK DATA INTO CRA BOARD TRANSCEIVERS USING
2669	!*			  'CRA R CLK'.
2670	!*	WRT 204/40	- ASSERT 'CRAM WRITE' TO WRITE DATA INTO CRAM
2671	!*	WRT 204/0	- BITS 24-35B.
2672	!*	WRT 206/2	- ASSERT 'SINGLE CLK' TO CLOCK CRAM BITS INTO
2673	!*			  LATCHES.
2674	!*	WRT 204/1	- ASSERT 'CRA/M RESET'.
2675	!*	WRT 204/0	- NEGATE IT.
2676	!*	WRT 205/6	- SET DIAG FN = 6 TO READ CRAM BITS 24-35B
2677	!*	WRT 210/111	- CLOCK CRAM BITS 24-35B TO CSL BOARD.
2678	!*RESPONSE:
2679	!*	CRAM BITS 24-35B WERE NOT NEGATED BY 'CRA/M RESET'.
2680	!]ERROR 8
2681	!]DMX6 CREG8 NTWK
2682	!]ERROR 9
2683	!]DMX6 CREG7 NTWK
2684	!]ERROR 10
2685	!]DMX6 CREG6 NTWK
2686	!]ERROR 11
2687	!]DMX6 CREG5 NTWK
2688	!]ERROR 12
2689	!]DMX6 CREG4 NTWK
2690	!]ERROR 13
2691	!]DMX6 CREG3 NTWK
2692	!]ERROR 14
2693	!]RESET NTWK
2694		IF FLP_CHK(2,FLP_PTR2)		! GO CHECK FOR FAST ERROR LOOPING
2695		THEN
2696			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2697		0				!TO PREVENT INFO MSG WHEN COMPILING
2698		END;
2699	
2700		CLEAR_CRAM();			!ZERO CRAM LOC 0
2701		END;
2702	
2703	GLOBAL ROUTINE TST10: NOVALUE =
2704	
2705	!THIS TEST CHECKS THAT THE CRAM ADDRESS CAN BE SET USING THE 'DIAG ADR'.
2706	!THE CRAM REGISTER IS NEGATED USING 'CRA/M RESET'. THIS SELECTS THE
2707	!DIAG ADR INPUTS TO THE DISPATCH MUXS.  THEN THE DIAG ADR REGISTER IS
2708	!LOADED WITH A DATA PATTERN.  THIS PATTERN SHOULD FEED THROUGH THE
2709	!MUXS AND BE READ BACK AS THE NEXT CRAM ADDRESS.
2710	
2711		BEGIN
2712		LABEL BLOCK1,ERBLK1;
2713		BIND
2714			FLP_PTR = UPLIT(%ASCIZ 'X12525,LR205,DR1,LR210,DR111,RP',
2715					%ASCIZ 'X15252,LR205,DR1,LR210,DR111,RP');
2716		MAP
2717			FLP_PTR: VECTOR;
2718		LOCAL
2719			ERFLG,
2720			DISCREP,
2721			ACTUAL,
2722			TST_ADR;
2723		OWN
2724			ADR: VECTOR[2] INITIAL (%O'2525',%O'5252');
2725	
2726		ERFLG = 0;		!INIT ERROR FLAG
2727		INCR I FROM 0 TO 1 BY 1 DO
2728		BEGIN
2729		TST_ADR = .ADR[.I];		!GET TEST ADDR TO USE
2730		DO (0) WHILE
2731	BLOCK1:	BEGIN
2732		SETNXT(.TST_ADR);			!LOAD THE TST ADR INTO THE DIAG ADDR REG
2733		WRT205(1);			!SET THE DIAG FN TO READ NEXT CRAM ADDR
2734		ACTUAL = READ_DATA();		!READ THE NEXT CRAM ADDR
2735		IF .ACTUAL NEQ .TST_ADR		!IF NXT CRAM ADDR IS NOT CORRECT
2736		THEN
2737	ERBLK1:		BEGIN
2738			ERMCAS(1,.TST_ADR,.ACTUAL,4,TST_ADR); !THEN REPORT IT
2739			ERFLG = 1;		!SET ERROR FLAG
2740			DISCREP = .ACTUAL XOR .TST_ADR; !COMPUTE DISCREPANCIES
2741			INCR J FROM 0 TO 11 BY 1 DO
2742				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
2743				THEN
2744					BEGIN
2745					FAILURE(.J+1);	!GO DO FAULT ISOLATION
2746					LEAVE ERBLK1;
2747					END;
2748	
2749	!CHECK IF A GROUP OF 4 BITS ARE INCORRECT
2750	
2751			INCR J FROM 0 TO 2 BY 1 DO
2752				IF (.DISCREP AND (NOT %O'17'^(.J*4))) EQL 0
2753				THEN
2754					BEGIN
2755					FAILURE(13+.J);	!DO FAULT ISOLATION
2756					LEAVE ERBLK1;
2757					END;
2758	
2759	!IF ADDR IS ALL ONES THEN 'PAGE FAIL' MUST BE ASSERTED.
2760	
2761			IF (.ACTUAL EQL %O'1777') OR
2762			   ((.ACTUAL AND %O'7760') EQL %O'7760') OR
2763			   ((.ACTUAL AND %O'17') EQL %O'17')
2764			THEN
2765				BEGIN
2766				FAILURE(16);		!DO FAULT ISOLATION
2767				LEAVE ERBLK1;
2768				END;
2769	
2770	! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.
2771	
2772			FAILURE(17);
2773			END;
2774	!*MESSAGE 1
2775	!*STIMULUS:
2776	!*	X1 \O0		- THIS EXECUTES AN 8080 SUBROUTINE WHICH:
2777	!*				CLEARS THE CRAM REGISTER,
2778	!*				LOADS THE DIAG ADR = \O0.
2779	!*	WRT 205/1	- SET DIAG FN = 1 TO READ NEXT CRAM ADDR
2780	!*	WRT 210/111	- READ THE NEXT CRAM ADDR
2781	!*RESPONSE:
2782	!*	THE NEXT CRAM ADDR IS NOT WHAT WAS WRITTEN AS 'DIAG ADR'.
2783	!]ERROR 1
2784	!]DADR3 AMX11_00 DMX1 SKIP10 NTWK
2785	!]ERROR 2
2786	!]DADR3 AMX10_00 DMX1 NTWK
2787	!]ERROR 3
2788	!]DADR3 AMX9_00 DMX1 NTWK
2789	!]ERROR 4
2790	!]DADR3 AMX8_00 DMX1 NTWK
2791	!]ERROR 5
2792	!]DADR2 AMX7_00 DMX1 NTWK
2793	!]ERROR 6
2794	!]DADR2 AMX6_00 DMX1 NTWK
2795	!]ERROR 7
2796	!]DADR2 AMX5_00 DMX1 NTWK
2797	!]ERROR 8
2798	!]DADR2 AMX4_00 DMX1 NTWK
2799	!]ERROR 9
2800	!]DADR1 AMX3_00 DMX1 NTWK
2801	!]ERROR 10
2802	!]DADR1 AMX2_00 DMX1 NTWK
2803	!]ERROR 11
2804	!]DADR1 AMX1_00 DMX1 NTWK
2805	!]ERROR 12
2806	!]DADR1 AMX0_00 DMX1 NTWK
2807	!]ERROR 13
2808	!]DADR3 NTWK
2809	!]ERROR 14
2810	!]DADR2 NTWK
2811	!]ERROR 15
2812	!]DADR1 NTWK
2813	!]ERROR 16
2814	!]PFBUF NTWK
2815	!]ERROR 17
2816	!]DADR AMX DFN1 NTWK
2817	!]NO ERROR 1
2818	!]DADR DADR1 DADR2 DADR3 AMX_00 DMX1 DFN1 NTWK
2819		IF FLP_CHK(1,FLP_PTR[.I])	!GO CHECK FOR FAST ERROR LOOPING
2820		THEN
2821			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2822		0				!TO PREVENT INFO MSG WHEN COMPILING
2823	
2824		END;
2825		END;
2826		IF .ERFLG EQL 0		!IF WE HAD NO ERRORS THEN
2827		THEN
2828			NOERR(1);	!DO FAULT ISOLATION
2829	
2830		END;
2831	
2832	GLOBAL ROUTINE TST11: NOVALUE =
2833	
2834	!THIS TEST CHECKS THAT THE 'CURRENT ADDR' REGISTER GETS CLOCKED
2835	!CORRECTLY.  A TEST ADDRESS IS LOADED INTO NEXT CRAM ADDRESS. THEN A
2836	!CPU CLOCK PULSE IS GIVEN WHICH SHOULD CLOCK THE NEXT CRAM ADDR INTO
2837	!THE CURRENT ADDR.  THE CURRENT ADDR IS THEN READ BACK VIA DIAG FN 3.
2838	
2839		BEGIN
2840		LABEL BLOCK1,ERBLK1;
2841		BIND
2842			FLP_PTR = UPLIT(%ASCIZ 'X16314,LR206,DR2,LR205,DR3,X10,LR210,DR111,RP',
2843					%ASCIZ 'X11463,LR206,DR2,LR205,DR3,X10,LR210,DR111,RP');
2844		MAP
2845			FLP_PTR: VECTOR;
2846		LOCAL
2847			ERFLG,
2848			DISCREP,
2849			ACTUAL,
2850			TST_ADR;
2851		OWN
2852			ADR: VECTOR[2] INITIAL (%O'6314',%O'1463');
2853	
2854		ERFLG = 0;		!INIT ERROR FLAG
2855		INCR I FROM 0 TO 1 BY 1 DO
2856		BEGIN
2857		TST_ADR = .ADR[.I];		!GET TEST ADDR TO USE
2858		DO (0) WHILE
2859	BLOCK1:	BEGIN
2860		SETNXT(.TST_ADR);			!LOAD THE TST ADR INTO THE DIAG ADDR REG
2861		WRT206(SINGLE_CLK);		!CLOCK NEXT ADDR INTO CURR ADDR
2862		WRT205(3);			!SET THE DIAG FN TO READ CURRENT CRAM ADDR
2863		SETNXT(0);				!SET NXT ADDR=0 SO FAULT IN DIAG
2864						!MUX SELECTION WILL BE DETECTABLE
2865		ACTUAL = READ_DATA();		!READ THE CURRENT CRAM ADDR
2866		IF .ACTUAL NEQ .TST_ADR		!IF CURR ADDR IS NOT CORRECT
2867		THEN
2868	ERBLK1:		BEGIN
2869			ERFLG = -1;		!SET ERROR FLAG
2870			ERMCAS(1,.TST_ADR,.ACTUAL,4,TST_ADR); !THEN REPORT IT
2871			DISCREP = .ACTUAL XOR .TST_ADR; !COMPUTE DISCREPANCIES
2872			INCR J FROM 0 TO 11 BY 1 DO
2873				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
2874				THEN
2875					BEGIN
2876					FAILURE(.J+1);	!GO DO FAULT ISOLATION
2877					LEAVE ERBLK1;
2878					END;
2879	
2880	!CHECK IF A GROUP OF 4 BITS ARE INCORRECT
2881	
2882			INCR J FROM 0 TO 2 BY 1 DO
2883				IF (.DISCREP AND (NOT %O'17'^(.J*4))) EQL 0
2884				THEN
2885					BEGIN
2886					FAILURE(13+.J);	!DO FAULT ISOLATION
2887					LEAVE ERBLK1;
2888					END;
2889	
2890	! IF WE GET THIS FAR THE WHOLE WORD MUST BEEN INCORRECT.
2891	
2892			FAILURE(13);
2893			END;
2894	!*MESSAGE 1
2895	!*STIMULUS:
2896	!*	X1 \O0		- THIS EXECUTES AN 8080 SUBROUTINE WHICH:
2897	!*				CLEARS THE CRAM REGISTER,
2898	!*				LOADS THE DIAG ADR = \O0.
2899	!*	WRT 206/2	- CLOCK NEXT ADDR INTO CURRENT ADDR
2900	!*	WRT 205/3	- SET DIAG FN = 3 TO READ CURR LOC
2901	!*	X1 0		- THIS EXECUTES AN 8080 SUBROUTINE WHICH:
2902	!*				CLEARS THE CRAM REGISTER,
2903	!*				LOADS THE DIAG ADR = 0.
2904	!*	WRT 210/111	- READ THE CURR LOC
2905	!*RESPONSE:
2906	!*	'CURR LOC' DID NOT GET LOADED CORRECTLY.
2907	!]ERROR 1
2908	!]DADR3 CLOC3 AMX11_00 DMX3 SKIP10 NTWK
2909	!]ERROR 2
2910	!]DADR3 CLOC3 AMX10_00 DMX3 NTWK
2911	!]ERROR 3
2912	!]DADR3 CLOC3 AMX9_00 DMX3 NTWK
2913	!]ERROR 4
2914	!]DADR3 CLOC3 AMX8_00 DMX3 NTWK
2915	!]ERROR 5
2916	!]DADR2 CLOC2 AMX7_00 DMX3 NTWK
2917	!]ERROR 6
2918	!]DADR2 CLOC2 AMX6_00 DMX3 NTWK
2919	!]ERROR 7
2920	!]DADR2 CLOC2 AMX5_00 DMX3 NTWK
2921	!]ERROR 8
2922	!]DADR2 CLOC2 AMX4_00 DMX3 NTWK
2923	!]ERROR 9
2924	!]DADR1 CLOC1 AMX3_00 DMX3 NTWK
2925	!]ERROR 10
2926	!]DADR1 CLOC1 AMX2_00 DMX3 NTWK
2927	!]ERROR 11
2928	!]DADR1 CLOC1 AMX1_00 DMX3 NTWK
2929	!]ERROR 12
2930	!]DADR1 CLOC1 AMX0_00 DMX3 NTWK
2931	!]ERROR 13
2932	!]CLKF CLKEN DADR3 CLOC3 NTWK
2933	!]ERROR 14
2934	!]CLKD CLKEN DADR2 CLOC2 NTWK
2935	!]ERROR 15
2936	!]CLKE CLKEN DADR1 CLOC1 NTWK
2937	!]ERROR 16
2938	!]DFN3 NTWK
2939		IF FLP_CHK(1,FLP_PTR[.I])	!GO CHECK FOR FAST ERROR LOOPING
2940		THEN
2941			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
2942		0				!TO PREVENT INFO MSG WHEN COMPILING
2943	
2944		END;
2945		END;
2946		IF .ERFLG EQL 0			!IF WE HAD NO ERRORS IN THIS TEST
2947		THEN
2948			NOERR(1);
2949	!]NO ERROR 1
2950	!]DADR1 DADR2 DADR3 AMX_00 DMX3 CLOC1 CLOC2 CLOC3 DFN3 NTWK
2951	
2952		END;
2953	
2954	GLOBAL ROUTINE TST12: NOVALUE =
2955	
2956	!THIS TEST CHECKS THAT THE J FIELD OF THE MICRO-INSTRUCTION CAN BE
2957	!GATED CORRECTLY THRU THE CRAM ADDRESS MUXS TO PRODUCE THE NEXT CRAM
2958	!ADDRESS.  CRAM LOCATION 0 IS LOADED WITH A MICRO-INSTR WHICH HAS A J
2959	!FIELD OF 1 WITH NO DISPATCHING OR SKIPPING.  THIS INSTRUCTION IS
2960	!EXECUTED AND THE NEXT CRAM ADDRESS IS CHECKED FOR A 1.  THIS IS
2961	!REPEATED FOR NEXT ADDRESSES OF 2,4,8,10,20,40,100,200,400.
2962	
2963		BEGIN
2964		LOCAL
2965			PTR,
2966			CORRECT,
2967			ACTUAL;
2968		BIND
2969			TEST_PAT = PLIT(-1,-1,-1),
2970			UC_PTR = PLIT(U_J(0) U);
2971		MAP
2972			PTR: REF VECTOR;
2973		LABEL BLOCK1;
2974	
2975		LOADUC(0,UC_PTR);
2976		INCR I FROM 0 TO 11 BY 1 DO
2977		BEGIN
2978		CORRECT = 1^.I;			!COMPUTE NEXT ADDR TO BE USED
2979		LOADUC(.CORRECT,TEST_PAT);	!WRITE -1 TO CORRECT LOCATION
2980		DO (0) WHILE
2981	BLOCK1:	BEGIN
2982	
2983		LC(0);				!SET CRAM ADDR TO ZERO
2984		MOD_FLD(0,.CORRECT);		!MODIFY J FIELD TO TEST ADDR
2985		ACTUAL = STEP_U_NEXT(1);		!GIVE PULSE AND READ NXT ADDR
2986		IF .ACTUAL NEQ .CORRECT		!IS NEXT ADDR = J FIELD?
2987		THEN
2988			ERRCAS(.I+1,1,.CORRECT,.ACTUAL,4,CORRECT); !NO, REPORT ERROR
2989	!*MESSAGE 1
2990	!*STIMULUS:
2991	!*	LOAD CRAM LOCATION ZERO WITH MICRO-INSTR WITH J FIELD = \O0.
2992	!*	CP 1	- GIVE A CLOCK PULSE TO GATE THE J FIELD THRU THE CRAM
2993	!*		  ADDRESS MUXS.
2994	!*RESPONSE:
2995	!*	THE J FIELD DID NOT BECOME THE NEXT CRAM ADDRESS.
2996	!]ERROR 1
2997	!]AMX11 SKIP10 NTWK
2998	!]ERROR 2
2999	!]AMX10 NTWK
3000	!]ERROR 3
3001	!]AMX9 NTWK
3002	!]ERROR 4
3003	!]AMX8 NTWK
3004	!]ERROR 5
3005	!]AMX6_7 NTWK
3006	!]ERROR 6
3007	!]AMX6_7 NTWK
3008	!]ERROR 7
3009	!]AMX4_5 NTWK
3010	!]ERROR 8
3011	!]AMX4_5 NTWK
3012	!]ERROR 9
3013	!]AMX2_3 NTWK
3014	!]ERROR 10
3015	!]AMX2_3 NTWK
3016	!]ERROR 11
3017	!]AMX0_1 NTWK
3018	!]ERROR 12
3019	!]AMX0_1 NTWK
3020		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3021		THEN
3022			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3023	
3024		CP(1);			!CLOCK CRAM BITS AT 'NEXT ADDR' LOCATION INTO REGISTER
3025		PTR = EC_BITS(-1);	!READ BACK THOSE BITS
3026		ACTUAL = .PTR[1];	!GET BITS 36-71
3027		IF .ACTUAL NEQ -1	!ARE ALL BITS ONES AS THEY SHOULD BE?
3028		THEN
3029			ERRCAS(.I+13,2,-1,.ACTUAL,12,CORRECT);	!NO, REPORT ERROR
3030	!*MESSAGE 2
3031	!*STIMULUS:
3032	!*	LOAD CRAM LOCATION \O0 WITH ALL ONES.
3033	!*	LOAD CRAM LOCATION ZERO WITH MICRO-INSTR WITH J FIELD = \O0.
3034	!*	CP 1	- GIVE A CLOCK PULSE TO GATE THE J FIELD THRU THE CRAM
3035	!*		  ADDRESS MUXS.
3036	!*	CP 1	- GIVE ANOTHER PULSE TO CLOCK CRAM BITS FROM LOCATION
3037	!*		  \O0 INTO THE CRAM BIT REGISTER.
3038	!*	EC	- READ BACK THOSE BITS
3039	!*RESPONSE:
3040	!*	BITS 36-71 WERE NOT READ BACK AS ONES.  THIS IMPLIES THAT THE
3041	!*	NEXT ADDRESS BITS WHICH GO TO THE 'CRM' BOARD (CRA1 ADR 00-11)
3042	!*	ARE NOT CORRECT, I.E., NOT EQUAL TO \O0.  THEREFORE, THE CRAM
3043	!*	BITS READ BACK WERE FROM A DIFFERENT LOCATION.
3044	!]ERROR 13
3045	!]AMX11 SKIP10 NTWK
3046	!]ERROR 14
3047	!]AMX10 NTWK
3048	!]ERROR 15
3049	!]AMX9 NTWK
3050	!]ERROR 16
3051	!]AMX8 NTWK
3052	!]ERROR 17
3053	!]AMX6_7 NTWK
3054	!]ERROR 18
3055	!]AMX6_7 NTWK
3056	!]ERROR 19
3057	!]AMX4_5 NTWK
3058	!]ERROR 20
3059	!]AMX4_5 NTWK
3060	!]ERROR 21
3061	!]AMX2_3 NTWK
3062	!]ERROR 22
3063	!]AMX2_3 NTWK
3064	!]ERROR 23
3065	!]AMX0_1 NTWK
3066	!]ERROR 24
3067	!]AMX0_1 NTWK
3068		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
3069		THEN
3070			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3071		0				!TO PREVENT INFO MSG WHEN COMPILING
3072		END;
3073		END;
3074	
3075		END;
3076	
3077	GLOBAL ROUTINE TST13: NOVALUE =
3078	
3079	!THIS TEST CHECKS THAT ONES AND ZEROS CAN BE WRITTEN INTO AND READ FROM
3080	!BITS 0-35 OF EACH CRAM LOCATION.
3081	
3082		BEGIN
3083		LABEL BLOCK1,ERBLK1,ERBLK2;
3084		LOCAL
3085			DISCREP,
3086			ADDR,
3087			PTR,
3088			ACTUAL;
3089		BIND
3090			UC_PTR1 = PLIT(0,0,0),
3091			UC_PTR2 = PLIT(-1,-1,-1);
3092	
3093		LC(0);			!SET CRAM ADDRESS TO 0
3094		PTR = WR_CRAM(0);	!GO WRITE ZEROS TO EACH LOC AND CHECK IT
3095		ACTUAL = .(.PTR + 1);	!GET ACTUAL DATA
3096		ADDR = .(.PTR);		!GET CRAM ADDRESS
3097		IF .ACTUAL NEQ 0	!IF ACTUAL NOT EQUAL TO ZERO, HAD ERROR
3098		THEN
3099	ERBLK1:		BEGIN
3100			ERMCAS(1,0,.ACTUAL,12,ADDR);	!REPORT ERROR
3101			INCR I FROM 0 TO 35 BY 1 DO
3102				IF .ACTUAL EQL 1^.I	!CHECK FOR SINGLE BIT ERROR
3103				THEN
3104					BEGIN
3105					FAILURE(.I+1);	!DO FAULT ISOLATION
3106					LEAVE ERBLK1;
3107					END;
3108	
3109	!IF WE GET THIS FAR IT IS A MULTIPLE BIT ERROR, SO JUST CALL OUT ALL
3110	!CRAM CHIPS.
3111	
3112			FAILURE(37);
3113			END;
3114	!*MESSAGE 1
3115	!*STIMULUS:
3116	!*	WRITE ZEROS TO BITS 0-35 OF CRAM LOCATION \O0.
3117	!*RESPONSE:
3118	!*	NON-ZERO DATA WAS READ BACK FROM LOCATION \O0.
3119	!]ERROR 1
3120	!]CRAM35 NTWK
3121	!]ERROR 2
3122	!]CRAM34 NTWK
3123	!]ERROR 3
3124	!]CRAM33 NTWK
3125	!]ERROR 4
3126	!]CRAM32 NTWK
3127	!]ERROR 5
3128	!]CRAM31 NTWK
3129	!]ERROR 6
3130	!]CRAM30 NTWK
3131	!]ERROR 7
3132	!]CRAM29 NTWK
3133	!]ERROR 8
3134	!]CRAM28 NTWK
3135	!]ERROR 9
3136	!]CRAM27 NTWK
3137	!]ERROR 10
3138	!]CRAM26 NTWK
3139	!]ERROR 11
3140	!]CRAM25 NTWK
3141	!]ERROR 12
3142	!]CRAM24 NTWK
3143	!]ERROR 13
3144	!]CRAM23 NTWK
3145	!]ERROR 14
3146	!]CRAM22 NTWK
3147	!]ERROR 15
3148	!]CRAM21 NTWK
3149	!]ERROR 16
3150	!]CRAM20 NTWK
3151	!]ERROR 17
3152	!]CRAM19 NTWK
3153	!]ERROR 18
3154	!]CRAM18 NTWK
3155	!]ERROR 19
3156	!]CRAM17 NTWK
3157	!]ERROR 20
3158	!]CRAM16 NTWK
3159	!]ERROR 21
3160	!]CRAM15 NTWK
3161	!]ERROR 22
3162	!]CRAM14 NTWK
3163	!]ERROR 23
3164	!]CRAM13 NTWK
3165	!]ERROR 24
3166	!]CRAM12 NTWK
3167	!]ERROR 25
3168	!]CRAM11 NTWK
3169	!]ERROR 26
3170	!]CRAM10 NTWK
3171	!]ERROR 27
3172	!]CRAM9 NTWK
3173	!]ERROR 28
3174	!]CRAM8 NTWK
3175	!]ERROR 29
3176	!]CRAM7 NTWK
3177	!]ERROR 30
3178	!]CRAM6 NTWK
3179	!]ERROR 31
3180	!]CRAM5 NTWK
3181	!]ERROR 32
3182	!]CRAM4 NTWK
3183	!]ERROR 33
3184	!]CRAM3 NTWK
3185	!]ERROR 34
3186	!]CRAM2 NTWK
3187	!]ERROR 35
3188	!]CRAM1 NTWK
3189	!]ERROR 36
3190	!]CRAM0 NTWK
3191	!]ERROR 37
3192	!]CRAM NTWK
3193		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3194		THEN
3195			WHILE 1 DO
3196			BEGIN
3197			LOADUC(.ADDR,UC_PTR1);	!WRITE ZEROS TO CRAM
3198			EC(.ADDR);		!READ THEM BACK
3199			END;
3200	
3201		LC(0);			!SET CRAM ADDRESS TO 0
3202		PTR = WR_CRAM(-1);	!GO WRITE ONES TO EACH LOC AND CHECK IT
3203		ACTUAL = .(.PTR + 1);	!GET ACTUAL DATA
3204		ADDR = .(.PTR);		!GET CRAM ADDRESS
3205		IF .ACTUAL NEQ -1	!IF ACTUAL NOT EQUAL TO ONES, HAD ERROR
3206		THEN
3207	ERBLK2:		BEGIN
3208			ERMCAS(1,-1,.ACTUAL,12,ADDR);	!REPORT ERROR
3209			DISCREP = .ACTUAL XOR -1;	!COMPUTE DISCREPANCIES
3210			INCR I FROM 0 TO 35 BY 1 DO
3211				IF .DISCREP EQL 1^.I	!CHECK FOR SINGLE BIT ERROR
3212				THEN
3213					BEGIN
3214					FAILURE(.I+1);	!DO FAULT ISOLATION
3215					LEAVE ERBLK2;
3216					END;
3217	
3218	!IF WE GET THIS FAR IT IS A MULTIPLE BIT ERROR, SO JUST CALL OUT ALL
3219	!CRAM CHIPS.
3220	
3221			FAILURE(37);
3222			END;
3223	!*MESSAGE 1
3224	!*STIMULUS:
3225	!*	WRITE ONES TO BITS 0-35 OF CRAM LOCATION \O0.
3226	!*RESPONSE:
3227	!*	DATA WHICH WAS NOT ALL ONES WAS READ BACK FROM LOCATION \O0.
3228		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
3229		THEN
3230			WHILE 1 DO
3231			BEGIN
3232			LOADUC(.ADDR,UC_PTR2);	!WRITE ZEROS TO CRAM
3233			EC(.ADDR);		!READ THEM BACK
3234			END;
3235	
3236		END;
3237	
3238	GLOBAL ROUTINE TST14: NOVALUE =
3239	
3240	!THIS TEST CHECKS THAT THE ADDRESSING LOGIC FOR THE CRAM WORKS
3241	!CORRECTLY.
3242	
3243		BEGIN
3244		LABEL BLOCK1;
3245		BIND
3246			ONES = PLIT(-1,-1,-1),
3247			ZEROS = PLIT(0,0,0);
3248		LOCAL
3249			BITS,
3250			ACTUAL,
3251			PTR,
3252			OTHER_ADR;
3253		MAP
3254			PTR: REF VECTOR;
3255	
3256		DO (0) WHILE
3257	BLOCK1:	BEGIN
3258	
3259		INCR I FROM 0 TO 10 BY 1 DO
3260			BEGIN
3261			OTHER_ADR = 1^.I;		!COMPUTE OTHER ADDR
3262			LOADUC(0,ZEROS);	!WRITE ALL ZEROS INTO TEST ADDR
3263			LOADUC(.OTHER_ADR,ONES); !WRITE ONES INTO OTHER ADDR
3264			PTR = EC_BITS(0);	!READ BACK CONTENTS OF TEST ADDR
3265			ACTUAL = .PTR[0];	!GET BITS 0-35
3266			IF .ACTUAL NEQ 0	!CHECK THAT TEST ADDR STAYED ZEROS
3267			THEN
3268				ERRCAS(.I+1,1,0,.ACTUAL,12,OTHER_ADR); !REPORT ERROR
3269	!*MESSAGE 1
3270	!*STIMULUS:
3271	!*	WRITE ZEROS INTO BITS 0-35 OF CRAM LOCATION 0.
3272	!*	WRITE ONES INTO BITS 0-35 OF CRAM LOCATION \O0.
3273	!*RESPONSE:
3274	!*	BITS 0-35 READ BACK FROM LOCATION 0 ARE NOT ALL ZEROS.  THIS
3275	!*	IMPLIES THAT WRITING INTO LOCATION \O0 REALLY WROTE INTO
3276	!*	LOCATION 0, OR VICE-VERSA.
3277	!]ERROR 1
3278	!]CADR11 NTWK
3279	!]ERROR 2
3280	!]CADR10 NTWK
3281	!]ERROR 3
3282	!]CADR9 NTWK
3283	!]ERROR 4
3284	!]CADR8 NTWK
3285	!]ERROR 5
3286	!]CADR7 NTWK
3287	!]ERROR 6
3288	!]CADR6 NTWK
3289	!]ERROR 7
3290	!]CADR5 NTWK
3291	!]ERROR 8
3292	!]CADR4 NTWK
3293	!]ERROR 9
3294	!]CADR3 NTWK
3295	!]ERROR 10
3296	!]CADR2 NTWK
3297	!]ERROR 11
3298	!]CADR1 NTWK
3299			IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3300			THEN
3301				LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3302	
3303			IF (.PTR[1] NEQ 0) OR		!ARE BITS 36-71 ZEROS
3304			   (.PTR[2] NEQ 0)		!ARE BITS 72-95 ZEROS
3305			THEN
3306				ERRCAS(.I+12,2,ZEROS,.PTR + 1,20,OTHER_ADR); !NO, REPORT ERROR
3307	!*MESSAGE 2
3308	!*STIMULUS:
3309	!*	WRITE ZEROS INTO BITS 36-95 OF CRAM LOCATION 0.
3310	!*	WRITE ONES INTO BITS 36-95 OF CRAM LOCATION \O0.
3311	!*RESPONSE:
3312	!*	BITS 36-95 READ BACK FROM LOCATION 0 ARE NOT ALL ZEROS.  THIS
3313	!*	IMPLIES THAT WRITING INTO LOCATION \O0 REALLY WROTE INTO
3314	!*	LOCATION 0, OR VICE-VERSA.
3315	!]ERROR 12
3316	!]AMX11 SKIP10 NTWK
3317	!]ERROR 13
3318	!]AMX10 NTWK
3319	!]ERROR 14
3320	!]AMX9 NTWK
3321	!]ERROR 15
3322	!]AMX8 NTWK
3323	!]ERROR 16
3324	!]AMX6_7 NTWK
3325	!]ERROR 17
3326	!]AMX6_7 NTWK
3327	!]ERROR 18
3328	!]AMX4_5 NTWK
3329	!]ERROR 19
3330	!]AMX4_5 NTWK
3331	!]ERROR 20
3332	!]AMX2_3 NTWK
3333	!]ERROR 21
3334	!]AMX2_3 NTWK
3335	!]ERROR 22
3336	!]AMX0_1 NTWK
3337	!]ERROR 23
3338	!]AMX0_1 NTWK
3339		IF LOOP_CHK(2)			!CHECK FOR ERROR LOOPING
3340		THEN
3341			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3342			END;
3343		0				!TO PREVENT INFO MSG WHEN COMPILING
3344		END;
3345	
3346		END;
3347	
3348	GLOBAL ROUTINE TST15: NOVALUE =
3349	
3350	!THIS TEST CHECKS THAT THE SUBROUTINE RETURN ADDRESS, 'SBR RET', DOES
3351	!NOT GET WRITTEN IF NO 'CALL' IS MADE.
3352	!A DATA PATTERN IS LOADED INTO THE NEXT CRAM ADDRESS AND A SINGLE CLOCK
3353	!PULSE IS GENERATED.  THIS CLOCKS THE ADDRESS INTO 'CURR LOC' AND WRITES
3354	!IT INTO THE SUBROUTINE STACK. THEN ANOTHER CLOCK PULSE IS GENERATED.
3355	!SINCE 'CALL OR RETURN' IS NOT ASSERTED, THE 'SBR RET' LATCHES SHOULD
3356	!NOT GET CLOCKED WITH THE DATA PATTERN FROM THE STACK.
3357	
3358		BEGIN
3359		LABEL BLOCK1;
3360		LOCAL
3361			ADDR,
3362			CORRECT,
3363			ACTUAL;
3364		BIND
3365			UC_PTR = PLIT( U_J(0) U);
3366	
3367		DO (0) WHILE
3368	BLOCK1:	BEGIN
3369	
3370		CORRECT = READ_SBR();		!SET CORRECT = 'SBR RET'
3371		ADDR = NOT .CORRECT;		!SET TEST ADDR = COMPLEMENT OF THAT
3372		CLEAR_CRAM();			!MAKE SURE CRAM BITS ARE ZERO
3373		LOADUC(.ADDR,UC_PTR);		!LOAD NOP MICRO-INSTR INTO ADDR
3374		CP(2);				!CLOCK ADDR INTO 'CURR LOC'
3375		ACTUAL = READ_SBR();		!READ 'SBR RET'
3376		IF .ACTUAL NEQ .CORRECT		!'SBR RET' SHOULDN'T HAVE CHANGED
3377		THEN
3378			ERRCAS(1,1,.CORRECT,.ACTUAL,4,ADDR);
3379	!*MESSAGE 1
3380	!*STIMULUS:
3381	!*	SET CRAM ADDRESS = THE COMPLEMENT OF THE PRESENT VALUE OF
3382	!*		'SBR RET'.
3383	!*	GENERATE 2 CPU CLOCK PULSES - THE FIRST WILL CLOCK THE CRAM
3384	!*		ADDRESS INTO 'CURR LOC' AND INTO THE STACK.  SINCE
3385	!*		'CALL OR RETURN' SHOULD BE NEGATED, THE 2ND PULSE
3386	!*		SHOULD NOT CLOCK THE ADDRESS INTO 'SBR RET'.
3387	!*RESPONSE:
3388	!*	THE VALUE OF 'SBR RET' CHANGED.
3389	!]ERROR 1
3390	!]PFBUF RTN CALLRTN NTWK
3391		IF LOOP_CHK(1)			!CHECK FOR ERROR LOOPING
3392		THEN
3393			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3394		0				!TO PREVENT INFO MSG WHEN COMPILING
3395		END;
3396	
3397		END;
3398	
3399	GLOBAL ROUTINE TST16: NOVALUE =
3400	
3401	! THIS TEST CHECKS THAT ADDRESSES CAN BE CLOCKED FROM THE 'CURR LOC'
3402	! LATCHES THRU THE SUBROUTINE STACK AND INTO THE 'SBR RET' LATCHES.  THE
3403	! CRAM LOCATION CORRESPONDING TO THE TEST PATTERN ADDRESS IS LOADED WITH
3404	! A CALL INSTRUCTION.  THE NEXT ADDRESS IS THEN SET TO BE THAT ADDRESS.
3405	! TWO CLOCK PULSES ARE GENERATED.  THE FIRST WILL CLOCKED THE ADDRESS
3406	! INTO 'CURR LOC'.  THE 2ND WILL DO THE CALL AND CLOCKED THE ADDRESS
3407	! INTO 'SBR RET'.
3408	
3409		BEGIN
3410		OWN
3411			ADR_TAB: VECTOR[4] INITIAL(%O'4210',%O'2104',%O'1042',%O'0421');
3412		BIND
3413			UC_PTR = PLIT(U_CALL U);
3414		LOCAL
3415			DISCREP,
3416			CORRECT,
3417			ACTUAL;
3418		LABEL BLOCK1,ERBLK1;
3419	
3420		INCR I FROM 0 TO 3 BY 1 DO
3421		BEGIN
3422		CORRECT = .ADR_TAB[.I];
3423		DO (0) WHILE
3424	BLOCK1:	BEGIN
3425	
3426		LOADUC(.CORRECT,UC_PTR);	!LOAD CALL INSTR AT TEST ADDR
3427		CP(2);				!GIVE 2 CLK PULSES
3428		ACTUAL = READ_SBR();		!READ 'SBR RET' VALUE
3429		IF .ACTUAL NEQ .CORRECT		!DID ADDR GET LATCHED INTO 'SBR RET'?
3430		THEN
3431	ERBLK1:		BEGIN
3432			ERMCAS(1,.CORRECT,.ACTUAL,4,CORRECT); !NO, REPORT ERROR
3433			DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
3434			INCR J FROM 0 TO 11 BY 1 DO
3435				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
3436				THEN
3437					BEGIN
3438					FAILURE((.J+4) MOD 4);	!GO DO FAULT ISOLATION
3439					LEAVE ERBLK1;
3440					END;
3441	
3442	!IF WE GET THIS FAR, THE WHOLE WORD IS INCORRECT.
3443	
3444			FAILURE(4);
3445			END
3446		ELSE
3447			NOERR(1);
3448	!*MESSAGE 1
3449	!*STIMULUS:
3450	!*	LOAD CRAM ADDR \O0 WITH A CALL MICROINSTRUCTION.
3451	!*	CP 2	- THE FIRST CLOCK PULSE WILL CLOCK THE CRAM ADDR INTO
3452	!*		  'CURR LOC' AND THE CALL MICRO-INSTR INTO THE LATCHES.
3453	!*		  THE 2ND PULSE SHOULD EXECUTE THE CALL MICRO-INSTR.
3454	!*		  THIS SHOULD CLOCK THE 'CURR LOC' CONTENTS THRU THE
3455	!*		  SUBROUTINE STACK RAM AND INTO THE 'SBR RET' LATCHES.
3456	!*RESPONSE:
3457	!*	THE VALUE CLOCKED INTO 'SBR RET' IS NOT EQUAL TO THE ORIGINAL
3458	!*	CRAM ADDR.
3459	!]ERROR 1
3460	!]CLOC3 STACK3 DMX2 SBRET3 NTWK
3461	!]ERROR 2
3462	!]CLOC2 STACK2 DMX2 SBRET2 NTWK
3463	!]ERROR 3
3464	!]CLOC1 STACK1 DMX2 SBRET1 NTWK
3465	!]ERROR 4
3466	!]STKWRT FRSTCYC SYNCH TCLKB DFN2 CLKD CLKEN CALLRTN NTWK
3467	!]NO ERROR 1
3468	!]SBRET1 SBRET2 SBRET3 STKWRT CLKD CLKEN FRSTCYC SYNCH TCLKB NTWK
3469		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3470		THEN
3471			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3472		0				!TO PREVENT INFO MSG WHEN COMPILING
3473		END;
3474		END;
3475	
3476		END;
3477	
3478	GLOBAL ROUTINE TST17: NOVALUE =
3479	
3480	!THIS TEST CHECKS THAT THE 'SBR RET' ADDRESS CAN BE GATED CORRECTLY THRU
3481	!THE CRAM ADDRESS MUXS.  A TEST CRAM ADDRESS IS LOADED WITH A CALL
3482	!MICROINSTRUCTION TO ANOTHER CRAM ADDRESS.  THAT ADDRESS IS LOADED WITH
3483	!A RETURN MICROINSTRUCTION.  TWO CLOCK PULSES ARE GIVEN.  THE 2ND SHOULD
3484	!CLOCK THE RETURN ADDRESS INTO 'SBR RET' AND THE RETURN MICROINSTR INTO
3485	!THE CONTROL LATCHES.  THIS WILL SELECT THE 'SBR RET' INPUTS TO THE CRAM
3486	!ADDR MUXS.  SINCE THE DIAG ADDRESS WILL BE THE SAME VALUE AS THE 'SBR
3487	!RET' SHOULD BE, TO AVOID MASKING A MUX SELECT FAULT, THE DIAG ADDR IS
3488	!CHENGED BEFORE READING BACK THE NEXT CRAM ADDR VALUE.
3489	
3490		BEGIN
3491		OWN
3492			ADR_TAB: VECTOR[2] INITIAL(%O'7777',0);
3493		BIND
3494			UC_PTR1 = PLIT(U_CALL U_J(707) U),
3495			UC_PTR2 = PLIT(U_DISP_RETURN U);
3496		LOCAL
3497			DISCREP,
3498			CORRECT,
3499			ACTUAL;
3500		LABEL BLOCK1,ERBLK1;
3501	
3502		INCR I FROM 0 TO 1 BY 1 DO
3503		BEGIN
3504		CORRECT = .ADR_TAB[.I];
3505		DO (0) WHILE
3506	BLOCK1:	BEGIN
3507	
3508		LOADUC(%O'707',UC_PTR2);	!LOAD RETURN INSTR
3509		LOADUC(.CORRECT,UC_PTR1);	!LOAD CALL INSTR AT TEST ADDR
3510		CP(2);				!GIVE 2 CLK PULSES
3511		CLK_DATA(NOT .CORRECT);		!SET DIAG ADDR TO COMP OF EXPECTED
3512		WRT204(CRAM_ADR_LD);		!LOAD DIAG ADR
3513		WRT204(0);
3514		ACTUAL = EX_NXT;		!READ NEXT CRAM ADDR
3515		IF .ACTUAL NEQ .CORRECT		!DID ADDR GATE THRU TO CRAM ADDR?
3516		THEN
3517	ERBLK1:		BEGIN
3518			ERMCAS(1,.CORRECT,.ACTUAL,4,CORRECT); !NO, REPORT ERROR
3519			DISCREP = .ACTUAL XOR .CORRECT; !COMPUTE DISCREPANCIES
3520			INCR J FROM 0 TO 11 BY 1 DO
3521				IF .DISCREP EQL 1^.J	!IS THERE A  SINGLE BIT ERROR?
3522				THEN
3523					BEGIN
3524					FAILURE(.J +1);	!GO DO FAULT ISOLATION
3525					LEAVE ERBLK1;
3526					END;
3527	
3528	!IF WE GET THIS FAR, THE WHOLE WORD IS INCORRECT.
3529	
3530			FAILURE(13);
3531			END
3532		ELSE
3533			NOERR(1);
3534	!*MESSAGE 1
3535	!*STIMULUS:
3536	!*	LOAD CRAM ADDR \O0 WITH A CALL MICROINSTRUCTION.
3537	!*	LOAD CRAM ADDR 707 WITH RETURN MICROINSTRUCTION.
3538	!*	CP 2	- THE FIRST CLOCK PULSE WILL CLOCK THE CRAM ADDR INTO
3539	!*		  'CURR LOC' AND THE CALL MICRO-INSTR INTO THE LATCHES.
3540	!*		  THE 2ND PULSE SHOULD EXECUTE THE CALL MICRO-INSTR.
3541	!*		  THIS SHOULD CLOCK THE 'CURR LOC' CONTENTS THRU THE
3542	!*		  SUBROUTINE STACK RAM AND INTO THE 'SBR RET' LATCHES.
3543	!*		  IT WILL ALSO LATCH THE RETURN MICRO-INSTR WHICH IN
3544	!*		  TURN WILL SELECT THE 'SBR RET' INPUTS TO THE CRAM
3545	!*		  ADDR MUXS.
3546	!*RESPONSE:
3547	!*	THE NEXT CRAM ADDR IS NOT EQUAL TO THE 'SBR RET' ADDRESS.
3548	!]ERROR 1
3549	!]AMX11 SKIP10 SBRET1 STACK1 NTWK
3550	!]ERROR 2
3551	!]AMX10 SBRET1 STACK1 NTWK
3552	!]ERROR 3
3553	!]AMX9 SBRET1 STACK1 NTWK
3554	!]ERROR 4
3555	!]AMX8 SBRET1 STACK1 NTWK
3556	!]ERROR 5
3557	!]AMX6_7 SBRET2 STACK2 NTWK
3558	!]ERROR 6
3559	!]AMX6_7 SBRET2 STACK2 NTWK
3560	!]ERROR 7
3561	!]AMX4_5 SBRET2 STACK2 NTWK
3562	!]ERROR 8
3563	!]AMX4_5 SBRET2 STACK2 NTWK
3564	!]ERROR 9
3565	!]AMX2_3 SBRET1 STACK3 NTWK
3566	!]ERROR 10
3567	!]AMX2_3 SBRET1 STACK3 NTWK
3568	!]ERROR 11
3569	!]AMX0_1 SBRET1 STACK3 NTWK
3570	!]ERROR 12
3571	!]AMX0_1 SBRET1 STACK3 NTWK
3572	!]ERROR 13
3573	!]CLKD CLKEN CALLRTN STKWRT FRSTCYC SYNCH TCLKB NTWK
3574	!]NO ERROR 1
3575	!]CLKD CLKEN STKWRT FRSTCYC SYNCH TCLKB SBRET1 SBRET2 SBRET3 NTWK
3576		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3577		THEN
3578			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3579		0				!TO PREVENT INFO MSG WHEN COMPILING
3580		END;
3581		END;
3582	
3583		END;
3584	
3585	GLOBAL ROUTINE TST18: NOVALUE =
3586	
3587	!THIS TEST CHECKS THAT THE SUBROUTINE STACK WORKS CORRECTLY. IT EXECUTES
3588	!15 MICRO-INSTRUCTIONS WHICH DO SUBROUTINE CALLS, THEN EXECUTES 15
3589	!INSTRS WHICH DO RETURNS.  AFTER EACH RETURN, THE NEXT CRAM ADDR IS
3590	!CHECKED FOR CORRECTNESS.
3591	
3592		BEGIN
3593		LABEL BLOCK1,ERBLK1;
3594		BIND
3595			UC_PTR = PLIT(U_J(2) U_CALL U,
3596					U_J(1) U_DISP_RETURN U,
3597					U_J(4) U_CALL U,
3598					U_J(1) U_DISP_RETURN U,
3599					U_J(6) U_CALL U,
3600					U_J(1) U_DISP_RETURN U,
3601					U_J(10) U_CALL U,
3602					U_J(1) U_DISP_RETURN U,
3603					U_J(12) U_CALL U,
3604					U_J(1) U_DISP_RETURN U,
3605					U_J(14) U_CALL U,
3606					U_J(1) U_DISP_RETURN U,
3607					U_J(16) U_CALL U,
3608					U_J(1) U_DISP_RETURN U,
3609					U_J(20) U_CALL U,
3610					U_J(1) U_DISP_RETURN U,
3611					U_J(22) U_CALL U,
3612					U_J(1) U_DISP_RETURN U,
3613					U_J(24) U_CALL U,
3614					U_J(1) U_DISP_RETURN U,
3615					U_J(26) U_CALL U,
3616					U_J(1) U_DISP_RETURN U,
3617					U_J(30) U_CALL U,
3618					U_J(1) U_DISP_RETURN U,
3619					U_J(32) U_CALL U,
3620					U_J(1) U_DISP_RETURN U,
3621					U_J(34) U_CALL U,
3622					U_J(1) U_DISP_RETURN U,
3623					U_J(36) U_CALL U,
3624					U_J(1) U_DISP_RETURN U,
3625					U_J(1) U_DISP_RETURN U);
3626		LOCAL
3627			DISCREP,
3628			NUMCLKS,
3629			ACTUAL;
3630	
3631		LOADUC(0,UC_PTR);	!LOAD MICRO-INSTRS
3632		WRT204(STK_RESET);		!RESET STACK
3633		WRT204(0);
3634		DO (0) WHILE
3635	BLOCK1:	BEGIN
3636		SET_C(0);
3637		CP(15);			!EXECUTE ALL THE CALL INSTRS
3638		DECR I FROM 29 TO 1 BY 2 DO 
3639		BEGIN
3640		ACTUAL = STEP_U_NEXT(1);	!EXECUTE RETURN AND READ NEXT ADDR
3641		IF .ACTUAL NEQ .I		!ARE WE AT CORRECT RETURN ADDR?
3642		THEN
3643	ERBLK1:		BEGIN
3644			NUMCLKS = (31-.I)/2;	!COMPUTE # OF RETURN CLK PULSES
3645			ERMCAS(1,.I,.ACTUAL,4,NUMCLKS);	!NO, REPORT ERROR
3646			DISCREP = .ACTUAL XOR .I;	!COMPUTE DISCREPANCIES
3647	
3648	!CHECK IF A GROUP OF 4 BITS ARE INCORRECT
3649	
3650			INCR J FROM 0 TO 2 BY 1 DO
3651				IF (.DISCREP AND (NOT %O'17'^(.J*4))) EQL 0
3652				THEN
3653					BEGIN
3654					FAILURE(1+.J);	!DO FAULT ISOLATION
3655					LEAVE ERBLK1;
3656					END;
3657	
3658	!IF WE GET THIS FAR THE WHOLE WORD IS WRONG
3659	
3660			FAILURE(4);
3661			END;
3662	!*MESSAGE 1
3663	!*STIMULUS:
3664	!*	LOAD MICRO-INSTRUCTIONS STARTING AT LOCATION 0 WHICH WILL
3665	!*		EXECUTE 15 'CALLS' FROM EVEN LOCATIONS, I.E., FROM 0 TO
3666	!*		2 TO 4 TO 6 ETC.  LOCATION 36 AND ALL ODD LOCATIONS UP
3667	!*		TO THAT CONTAIN 'RETURNS' WITH A J FIELD OF 1.
3668	!*	X1 0	- SET CRAM ADDRESS TO 0.
3669	!*	CP 15	- EXECUTE THE 15 CALL INSTRUCTIONS.
3670	!*	CP \O0	- EXECUTE \O0 RETURN INSTRUCTIONS.
3671	!*RESPONSE:
3672	!*	THE NEXT CRAM ADDRESS IS NOT CORRECT.
3673	!]ERROR 1
3674	!]RTN CALLRTN STKADR STACK3 TCLKB STKRST PFBUF NTWK
3675	!]ERROR 2
3676	!]RTN CALLRTN STKADR STACK2 TCLKB STKRST PFBUF NTWK
3677	!]ERROR 3
3678	!]RTN CALLRTN STKADR STACK1 TCLKB STKRST PFBUF NTWK
3679	!]ERROR 4
3680	!]STKADR RTN CALLRTN TCLKB STKRST PFBUF NTWK
3681		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3682		THEN
3683			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3684	
3685		END;
3686		0				!TO PREVENT INFO MSG WHEN COMPILING
3687		END;
3688	
3689		END;
3690	
3691	GLOBAL ROUTINE TST19: NOVALUE =
3692	
3693	!THIS TEST CHECKS THAT THE SUBROUTINE STACK POINTER GETS RESET WHEN
3694	!A 'STACK RESET' IS DONE.
3695	
3696	! A MICROINSTRUCTION AT LOCATION ZERO JUMPS TO LOCATION 2.  FROM
3697	! LOCATION 2, A CALL IS EXECUTED TO LOCATION 4.  THERE A CALL IS
3698	! EXECUTED TO LOCATION 6.  THEN A 'STACK RESET' IS DONE AND A RETURN
3699	! INSTRUCTION IS EXECUTED.  THIS RETURN SHOULD GO TO LOCATION 2 INSTEAD
3700	! OF 4.
3701	
3702		BEGIN
3703		LABEL BLOCK1;
3704		BIND
3705			UC_PTR = PLIT(U_J(2) U,
3706					U,
3707					U_J(4) U_CALL U,
3708					U,
3709					U_J(6) U_CALL U,
3710					U,
3711					 U_DISP_RETURN U);
3712		LOCAL
3713			ACTUAL;
3714	
3715		WRT204(STK_RESET);		!DO A STACK RESET
3716		WRT204(0);
3717		LOADUC(0,UC_PTR);	!LOAD MICRO-INSTRS
3718		DO (0) WHILE
3719	BLOCK1:	BEGIN
3720		SET_C(0);
3721		CP(3);			!EXECUTE ALL THE CALL INSTRS
3722		WRT204(STK_RESET);		!DO A STACK RESET
3723		WRT204(0);
3724		ACTUAL = STEP_U_NEXT(1);	!EXECUTE RETURN AND READ NEXT ADDR
3725		IF .ACTUAL NEQ 2		!ARE WE AT CORRECT RETURN ADDR?
3726		THEN
3727			ERRCA(1,2,.ACTUAL,4);	!NO, REPORT ERROR
3728	!*MESSAGE 1
3729	!*STIMULUS:
3730	!*	LOAD MICRO-INSTRUCTIONS TO JUMP FROM 0 TO 2, DO A CALL FROM 2 TO
3731	!*		4, DO A CALL FROM 4 TO 6, AND DO A RETURN FROM 6.
3732	!*	X1 0	- SET THE CRAM ADDRESS TO ZERO.
3733	!*	CP 3	- THREE CLOCK PULSES EXECUTE THE CALL INSTRS AT LOCS 2
3734	!*		  AND 4.
3735	!*	WRT 204/2	- DO A STACK RESET.
3736	!*	WRT 204/0
3737	!*	CP 1	- EXECUTE THE RETURN INSTR AT LOC 6.  AFTER THE STACK
3738	!*		  RESET, THIS SHOULD CAUSE THE NEXT CRAM ADDR TO BE 2
3739	!*		  INSTEAD OF 4.
3740	!*RESPONSE:
3741	!*	THE NEXT CRAM ADDRESS AFTER EXECUTING THE RETURN IS NOT 2.
3742	!]ERROR 1
3743	!]STKRST PFBUF CALLRTN RTN STKADR STACK NTWK
3744		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3745		THEN
3746			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3747		0				!TO PREVENT INFO MSG WHEN COMPILING
3748	
3749		END;
3750	
3751		END;
3752	
3753	GLOBAL ROUTINE TST20: NOVALUE =
3754	
3755	!THIS TEST CHECKS THAT THE NICOND DISPATCH LOGIC WORKS CORRECTLY.
3756	
3757		BEGIN
3758		LABEL
3759			BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
3760			ERBLK1,ERBLK2,ERBLK3,ERBLK4,ERBLK5;
3761		BIND
3762			UC_PTR = PLIT( U_J(3770) U_DISP_NICOND U),
3763			UC_PTR1 = PLIT(U_J(1) U_N(20000) U_SPEC_APR_EN U_DBUS_DBM U_ALU_OR U_RSRC_D0 U,
3764					U_J(2) U_N(1000) U_SPEC_FLAGS U,
3765					U_J(3770) U_DISP_NICOND U),
3766			UC_PTR2 = PLIT(U_J(2) U_N(2000) U_SPEC_FLAGS U),
3767			UC_PTR3 = PLIT(U_J(2) U_N(3000) U_SPEC_FLAGS U);
3768		LOCAL
3769			DISCREP,
3770			ERFLG,
3771			ACTUAL;
3772	
3773		LOADUC(0,UC_PTR);	!LOAD MICRO-INSTR
3774		ERFLG = 0;		!INIT ERROR FLAG
3775		DO (0) WHILE
3776	BLOCK1:	BEGIN
3777	
3778		TP(0);			!TURN OFF TRAP ENABLES
3779		WRT212(RUN);		!ASSERT 'RUN' PRE-FLOP
3780		CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'RUN'
3781		SET_C(0);		!SET CRAM ADDR TO 0
3782		ACTUAL = STEP_U_NEXT(1);	!EXECUTE NICOND DISP AND READ NEXT ADDR
3783		IF .ACTUAL NEQ %O'3777'		!DID WE DISPATCH CORRECTLY?
3784		THEN
3785	ERBLK1:		BEGIN
3786			ERFLG = 1;	!SET ERROR FLAG
3787			ERMCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
3788			DISCREP = .ACTUAL XOR %O'3777'; !COMPUTE DISCREPANCIES
3789			INCR J FROM 0 TO 2 BY 1 DO
3790				IF .DISCREP EQL 1^.J
3791				THEN
3792					BEGIN
3793					FAILURE(.J+1);
3794					LEAVE ERBLK1;
3795					END;
3796			FAILURE(4);
3797			END;
3798	!*MESSAGE 1
3799	!*STIMULUS:
3800	!*	LOAD MICRO-INSTR TO DO A NICOND DISPATCH TO 377X.
3801	!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
3802	!*			  'DPE9 TRAP 1,2 AND 3'.
3803	!*	WRT 212/4	- ASSERT 'RUN' PRE-FLOP
3804	!*	CP 1		- GIVE A CLOCK PULSE TO ASSERT 'RUN'.
3805	!*	X1 0		- SET NEXT CRAM ADDR TO 0.
3806	!*	CP 1		- EXECUTE THE NICOND DISPATCH.  WITH ALL TRAPS
3807	!*			  NEGATED AND 'RUN' ASSERTED, 'CRA2 NICOND 9, 10
3808	!*			  AND 11' SHOULD ALL BE ASSERTED.
3809	!*RESPONSE:
3810	!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3777.
3811	!]ERROR 1
3812	!]NIC_ENC AMX11 NTWK
3813	!]ERROR 2
3814	!]NIC_ENC AMX10 NTWK
3815	!]ERROR 3
3816	!]NIC_ENC AMX9 NTWK
3817	!]ERROR 4
3818	!]NIC_ENC NTWK
3819		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
3820		THEN
3821			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
3822		0				!TO PREVENT INFO MSG WHEN COMPILING
3823		END;
3824	
3825		WRT212(0);		!NEGATE 'RUN' PRE-FLOP
3826		WRT100(RESET);		!ASSERT 'RESET' TO NEGATE 'RUN'
3827		WRT100(0);
3828		DO (0) WHILE
3829	BLOCK2:	BEGIN
3830	
3831		SET_C(0);		!SET CRAM ADDR TO 0
3832		ACTUAL = STEP_U_NEXT(1);	!EXECUTE NICOND DISP AND READ NEXT ADDR
3833		IF .ACTUAL NEQ %O'3775'		!DID WE DISPATCH CORRECTLY?
3834		THEN
3835	ERBLK2:		BEGIN
3836			ERFLG = 1;	!SET ERROR FLAG
3837			ERMCA(2,%O'3775',.ACTUAL,4);	!NO, REPORT ERROR
3838			DISCREP = .ACTUAL XOR %O'3775'; !COMPUTE DISCREPANCIES
3839			INCR J FROM 0 TO 2 BY 1 DO
3840				IF .DISCREP EQL 1^.J
3841				THEN
3842					BEGIN
3843					FAILURE(.J+1);
3844					LEAVE ERBLK2;
3845					END;
3846			FAILURE(4);
3847			END;
3848	!*MESSAGE 2
3849	!*STIMULUS:
3850	!*	LOAD MICRO-INSTR TO DO A NICOND DISPATCH TO 377X.
3851	!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
3852	!*			  'DPE9 TRAP 1,2 AND 3'.
3853	!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
3854	!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
3855	!*	WRT 100/0	- NEGATE 'RESET'
3856	!*	X1 0		- SET NEXT CRAM ADDR TO 0.
3857	!*	CP 1		- EXECUTE THE NICOND DISPATCH.  WITH ALL TRAPS
3858	!*			  NEGATED AND 'RUN' NEGATED, 'CRA2 NICOND 9
3859	!*			  AND 11' SHOULD ALL BE ASSERTED AND 'CRA2
3860	!*			  NICOND 10' SHOULD BE NEGATED.
3861	!*RESPONSE:
3862	!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3775.
3863		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
3864		THEN
3865			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
3866		0				!TO PREVENT INFO MSG WHEN COMPILING
3867		END;
3868	
3869		LOADUC(0,UC_PTR1);	!LOAD MICROCODE
3870		DO (0) WHILE
3871	BLOCK3:	BEGIN
3872	
3873		TP(1);			!ASSERT 'CSL4 TRAP EN'
3874		SET_C(0);		!SET CRAM ADDR TO 0
3875		ACTUAL = STEP_U_NEXT(3);	!EXECUTE NICOND DISP AND READ NEXT ADDR
3876		IF .ACTUAL NEQ %O'3773'		!DID WE DISPATCH CORRECTLY?
3877		THEN
3878	ERBLK3:		BEGIN
3879			ERFLG = 1;	!SET ERROR FLAG
3880			ERMCA(3,%O'3773',.ACTUAL,4);	!NO, REPORT ERROR
3881			DISCREP = .ACTUAL XOR %O'3773'; !COMPUTE DISCREPANCIES
3882			INCR J FROM 0 TO 2 BY 1 DO
3883				IF .DISCREP EQL 1^.J
3884				THEN
3885					BEGIN
3886					FAILURE(.J+1);
3887					LEAVE ERBLK3;
3888					END;
3889			FAILURE(4);
3890			END;
3891	!*MESSAGE 3
3892	!*STIMULUS:
3893	!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1' AND DO A NICOND DISPATCH
3894	!*		TO 377X.
3895	!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
3896	!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
3897	!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
3898	!*	WRT 100/0	- NEGATE 'RESET'
3899	!*	X1 0		- SET NEXT CRAM ADDR TO 0.
3900	!*	CP 3		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
3901	!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
3902	!*			  'DPE9 TRAP 1'.  THE 3RD INSTR DOES A NICOND
3903	!*			  DISPATCH TO LOCATION 377X. WITH 'TRAP 1'
3904	!*			 ASSERTED, 'CRA2 NICOND 9-11' SHOULD BE = 3.
3905	!*RESPONSE:
3906	!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3773.
3907		IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
3908		THEN
3909			LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
3910		0				!TO PREVENT INFO MSG WHEN COMPILING
3911		END;
3912	
3913		LOADUC(1,UC_PTR2);	!LOAD MICROCODE
3914		DO (0) WHILE
3915	BLOCK4:	BEGIN
3916	
3917		TP(1);			!ASSERT 'CSL4 TRAP EN'
3918		SET_C(0);		!SET CRAM ADDR TO 0
3919		ACTUAL = STEP_U_NEXT(3);	!EXECUTE NICOND DISP AND READ NEXT ADDR
3920		IF .ACTUAL NEQ %O'3772'		!DID WE DISPATCH CORRECTLY?
3921		THEN
3922	ERBLK4:		BEGIN
3923			ERFLG = 1;	!SET ERROR FLAG
3924			ERMCA(4,%O'3772',.ACTUAL,4);	!NO, REPORT ERROR
3925			DISCREP = .ACTUAL XOR %O'3772'; !COMPUTE DISCREPANCIES
3926			INCR J FROM 0 TO 2 BY 1 DO
3927				IF .DISCREP EQL 1^.J
3928				THEN
3929					BEGIN
3930					FAILURE(.J+5);
3931					LEAVE ERBLK4;
3932					END;
3933			FAILURE(4);
3934			END;
3935	!*MESSAGE 4
3936	!*STIMULUS:
3937	!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 2' AND DO A NICOND DISPATCH
3938	!*		TO 377X.
3939	!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
3940	!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
3941	!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
3942	!*	WRT 100/0	- NEGATE 'RESET'
3943	!*	X1 0		- SET NEXT CRAM ADDR TO 0.
3944	!*	CP 3		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
3945	!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
3946	!*			  'DPE9 TRAP 2'.  THE 3RD INSTR DOES A NICOND
3947	!*			  DISPATCH TO LOCATION 377X. WITH 'TRAP 2'
3948	!*			 ASSERTED, 'CRA2 NICOND 9-11' SHOULD BE = 2.
3949	!*RESPONSE:
3950	!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3772.
3951	!]ERROR 5
3952	!]SKIP10 NIC_ENC AMX11 NTWK
3953	!]ERROR 6
3954	!]NIC_ENC AMX10 NTWK
3955	!]ERROR 7
3956	!]NIC_ENC AMX9 NTWK
3957		IF LOOP_CHK(4)		!CHECK FOR ERROR LOOPING
3958		THEN
3959			LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP
3960		0				!TO PREVENT INFO MSG WHEN COMPILING
3961		END;
3962	
3963		LOADUC(1,UC_PTR3);	!LOAD MICROCODE
3964		DO (0) WHILE
3965	BLOCK5:	BEGIN
3966	
3967		TP(1);			!ASSERT 'CSL4 TRAP EN'
3968		SET_C(0);		!SET CRAM ADDR TO 0
3969		ACTUAL = STEP_U_NEXT(3);	!EXECUTE NICOND DISP AND READ NEXT ADDR
3970		IF .ACTUAL NEQ %O'3771'		!DID WE DISPATCH CORRECTLY?
3971		THEN
3972	ERBLK5:		BEGIN
3973			ERFLG = 1;	!SET ERROR FLAG
3974			ERMCA(5,%O'3771',.ACTUAL,4);	!NO, REPORT ERROR
3975			DISCREP = .ACTUAL XOR %O'3771'; !COMPUTE DISCREPANCIES
3976			INCR J FROM 0 TO 2 BY 1 DO
3977				IF .DISCREP EQL 1^.J
3978				THEN
3979					BEGIN
3980					FAILURE(.J+1);
3981					LEAVE ERBLK5;
3982					END;
3983			FAILURE(4);
3984			END;
3985	!*MESSAGE 5
3986	!*STIMULUS:
3987	!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1 AND 2' AND DO A NICOND
3988	!*		DISPATCH TO 377X.
3989	!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
3990	!*	WRT 212/0	- NEGATE 'RUN' PRE-FLOP
3991	!*	WRT 100/200	- ASSERT 'RESET' TO NEGATE 'RUN'
3992	!*	WRT 100/0	- NEGATE 'RESET'
3993	!*	X1 0		- SET NEXT CRAM ADDR TO 0.
3994	!*	CP 3		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
3995	!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
3996	!*			  'DPE9 TRAP 1 AND 2'.  THE 3RD INSTR DOES A
3997	!*			  NICOND DISPATCH TO LOCATION 377X.  WITH
3998	!*			  'TRAP 1 AND 2' ASSERTED, 'CRA2 NICOND 9-11'
3999	!*			  SHOULD BE = 1.
4000	!*RESPONSE:
4001	!*	THE NEXT CRAM ADDR DID NOT DISPATCH TO 3771.
4002		IF LOOP_CHK(5)		!CHECK FOR ERROR LOOPING
4003		THEN
4004			LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP
4005		0				!TO PREVENT INFO MSG WHEN COMPILING
4006		END;
4007	
4008		IF .ERFLG EQL 0		!IF WE DIDN'T HAVE ANY ERRORS THEN
4009		THEN
4010			NOERR(1);	!DO SOME FAULT ISOLATION
4011	!]NO ERROR 1
4012	!]NIC_ENC NTWK
4013		END;
4014	
4015	GLOBAL ROUTINE TST21: NOVALUE =
4016	
4017	!THIS TEST CHECKS THAT NEXT CRAM ADDRESS SKIPPING WORKS CORRECTLY WHEN
4018	!A 'SKIP 10' IS EXECUTED WHICH SELECTS THE 'TRAP CYCLE' INPUT.
4019	
4020		BEGIN
4021		LABEL BLOCK1,BLOCK2;
4022		BIND
4023			UC_PTR = PLIT(U_J(1) U_N(20000) U_SPEC_APR_EN U_DBUS_DBM U_ALU_OR U_RSRC_D0 U,
4024					U_J(2) U_N(1000) U_SPEC_FLAGS U,
4025					U_J(3) U_SPEC_NICOND U,
4026					U_J(3776) U_SKIP_TRAP_CYC U);
4027		LOCAL
4028			ACTUAL;
4029	
4030		LOADUC(0,UC_PTR);	!LOAD MICRO-INSTR
4031		DO (0) WHILE
4032	BLOCK1:	BEGIN
4033	
4034		TP(1);			!ASSERT 'CSL4 TRAP EN'
4035		SET_C(0);		!SET CRAM ADDR TO 0
4036		ACTUAL = STEP_U_NEXT(4);	!EXECUTE NICOND SKIP AND READ NEXT ADDR
4037		IF .ACTUAL NEQ %O'3777'		!DID WE SKIP CORRECTLY?
4038		THEN
4039			ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
4040	!*MESSAGE 1
4041	!*STIMULUS:
4042	!*	LOAD MICRO-INSTRS TO SET 'DPE9 TRAP 1' AND DO A TRAP CYCLE SKIP
4043	!*		TO 3776.
4044	!*	TP 1		- ASSERT 'CSL4 TRAP EN'.
4045	!*	X1 0		- SET NEXT CRAM ADDR TO 0.
4046	!*	CP 4		- EXECUTION OF THE FIRST MICRO-INSTR ASSERTS
4047	!*			  'DPEB TRAP EN'.  THE 2ND INSTR ASSERTS
4048	!*			  'DPE9 TRAP 1'.  THE 3RD INSTR ASSERTS 'SPEC/
4049	!*			  NICOND' WHICH SHOULD ASSERT 'TRAP CYCLE'.
4050	!*			  THE 4TH INSTR DOES A TRAP CYCLE SKIP.
4051	!*RESPONSE:
4052	!*	THE NEXT CRAM ADDR DID NOT SKIP TO 3777.
4053	!]ERROR 1
4054	!]NIC_ENC TRPCYC SKIP10 AMX11 NTWK
4055		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4056		THEN
4057			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4058		0				!TO PREVENT INFO MSG WHEN COMPILING
4059		END;
4060	
4061		DO (0) WHILE
4062	BLOCK2:	BEGIN
4063		TP(0);			!TURN OFF TRAP ENABLES
4064		SET_C(2);		!SET CRAM ADDR TO 2
4065		ACTUAL = STEP_U_NEXT(2);	!EXECUTE TRAP CYCLE SKIP AND READ NEXT ADDR
4066		IF .ACTUAL NEQ %O'3776'		!DID WE DISPATCH CORRECTLY?
4067		THEN
4068			ERRCA(2,%O'3776',.ACTUAL,4);	!NO, REPORT ERROR
4069	!*MESSAGE 2
4070	!*STIMULUS:
4071	!*	LOAD MICRO-INSTR TO ASSERT 'SPEC/NICOND' AND DO A TRAP CYCLE
4072	!*		SKIP TO 3776.
4073	!*	TP 0		- NEGATE 'CSL4 TRAP EN'. THIS WILL NEGATE
4074	!*			  'DPE9 TRAP 1,2 AND 3'.
4075	!*	X1 3		- SET NEXT CRAM ADDR TO 3.
4076	!*	CP 2		- THE 1ST INSTR WILL ASSERT 'SPEC/NICOND'. WITH
4077	!*			  ALL TRAPS NEGATED, 'NICOND 9' IS ASSERTED. SO
4078	!*			  'TRAP CYCLE' WILL BE NEGATED. WITH 'TRAP
4079	!*			  CYCLE' NEGATED, THE 2ND INSTR WHICH DOES A
4080	!*			  TRAP CYCLE SKIP, SHOULD NOT SKIP.
4081	!*RESPONSE:
4082	!*	THE NEXT CRAM ADDR DID SKIP TO 3777.
4083	!]ERROR 2
4084	!]NIC_ENC TRPCYC SKIP10 AMX11 NTWK
4085		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4086		THEN
4087			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4088		0				!TO PREVENT INFO MSG WHEN COMPILING
4089		END;
4090	
4091		END;
4092	
4093	GLOBAL ROUTINE TST22: NOVALUE =
4094	
4095	!THIS TEST CHECKS THAT THE CONSOLE EXECUTE MODE SKIPPING WORKS
4096	!CORRECTLY, I.E., SKIP FIELD = 64.
4097	
4098		BEGIN
4099		LABEL BLOCK1,BLOCK2;
4100		BIND
4101			UC_PTR = PLIT(U_J(3776) U_SKIP_EXECUTE U);
4102		LOCAL
4103			ERFLG,
4104			ACTUAL;
4105	
4106		LOADUC(0,UC_PTR);	!LOAD MICROCODE
4107		DO (0) WHILE
4108	BLOCK1:	BEGIN
4109	
4110		ERFLG = 0;	!INIT ERROR FLAG
4111		WRT212(EXECUTE);	!ASSERT 'EXECUTE' PRE-FLOP
4112		CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'EXECUTE'
4113		SET_C(0);		!SET CRAM ADDR TO 0
4114		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
4115		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
4116		THEN
4117			BEGIN
4118			ERFLG = 1;	!SET ERROR FLAG
4119			ERRCA(1,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
4120			END;
4121	!*MESSAGE 1
4122	!*STIMULUS:
4123	!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
4124	!*	WRT 212/2	- ASSERT 'EXECUTE' PRE-FLOP
4125	!*	CP 1		- ASSERT 'EXECUTE'
4126	!*	X1 0		- SET CRAM ADDR TO 0
4127	!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
4128	!*RESPONSE:
4129	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
4130	!]ERROR 1
4131	!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4132		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4133		THEN
4134			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4135		IF .ERFLG EQL 0
4136		THEN
4137			BEGIN
4138			WRT100(RESET);		!NEGATE 'EXECUTE'
4139			WRT100(0);
4140			ACTUAL = EX_NXT;	!GET NEXT ADDR
4141			IF .ACTUAL NEQ %O'3777'
4142			THEN
4143				BEGIN
4144				ERFLG = 1;
4145				ERRCA(2,%O'3777',.ACTUAL,4);
4146				END;
4147			END;
4148	!*MESSAGE 2
4149	!*STIMULUS:
4150	!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
4151	!*	WRT 212/2	- ASSERT 'EXECUTE' PRE-FLOP
4152	!*	CP 1		- ASSERT 'EXECUTE'
4153	!*	X1 0		- SET CRAM ADDR TO 0
4154	!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP. THIS WILL CAUSE
4155	!*			  THE NEXT CRAM ADDR TO BECOME 3777.
4156	!*	WRT 100/200	- ASSERT 'RESET' ON THE CSL BOARD. THIS WILL 
4157	!*			  NEGATE 'CSL4 EXECUTE'.  BUT WITH 'CRA2 DISP &
4158	!*			  SKIP EN' NEGATED, THE NEXT ADDR SHOULD NOT
4159	!*			  CHANGE.
4160	!*RESPONSE:
4161	!*	THE NEXT CRAM ADDRESS CHANGED FROM 3777. THIS IMPLIES THAT
4162	!*	'CRA2 DISP & SKIP EN' IS STUCK ASSERTED.
4163	!]ERROR 2
4164	!]DSP_SKP_EN SYNCH FRSTCYC NTWK
4165		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4166		THEN
4167			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4168		0				!TO PREVENT INFO MSG WHEN COMPILING
4169		END;
4170	
4171		DO (0) WHILE
4172	BLOCK2:	BEGIN
4173	
4174		WRT212(0);		!NEGATE 'EXECUTE' PRE-FLOP
4175		CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'EXECUTE'
4176		SET_C(0);		!SET CRAM ADDR TO 0
4177		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
4178		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
4179		THEN
4180			BEGIN
4181			ERFLG = 1;
4182			ERRCA(3,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
4183			END;
4184	!*MESSAGE 3
4185	!*STIMULUS:
4186	!*	LOAD MICRO-INSTR TO EXECUTE A CONSOLE EXECUTE MODE SKIP.
4187	!*	WRT 212/0	- NEGATE 'EXECUTE' PRE-FLOP
4188	!*	CP 1		- NEGATE 'EXECUTE'
4189	!*	X1 0		- SET CRAM ADDR TO 0
4190	!*	CP 1		- EXECUTE THE EXECUTE MODE SKIP.
4191	!*RESPONSE:
4192	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
4193	!]ERROR 3
4194	!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4195		IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
4196		THEN
4197			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4198		0				!TO PREVENT INFO MSG WHEN COMPILING
4199		END;
4200		IF .ERFLG EQL 0
4201		THEN
4202			NOERR(1);
4203	!]NO ERROR 1
4204	!]DSP_SKP_EN SYNCH TCLKB NTWK
4205	
4206		END;
4207	
4208	GLOBAL ROUTINE TST23: NOVALUE =
4209	
4210	!THIS TEST CHECKS THAT THE 'NOT CONTINUE' SKIPPING WORKS
4211	!CORRECTLY, I.E., SKIP FIELD = 66.
4212	
4213		BEGIN
4214		LABEL BLOCK1,BLOCK2;
4215		BIND
4216			UC_PTR = PLIT(U_J(3776) U_SKIP_CONTINUE U);
4217		LOCAL
4218			ERFLG,
4219			ACTUAL;
4220	
4221		ERFLG = 0;		!INIT ERROR FLAG
4222		LOADUC(0,UC_PTR);	!LOAD MICROCODE
4223		DO (0) WHILE
4224	BLOCK1:	BEGIN
4225	
4226		WRT212(CONTINUE);	!ASSERT 'CONTINUE' PRE-FLOP
4227		CP_NOSS(1);		!GIVE CLK PULSE TO ASSERT 'CONTINUE'
4228		SET_C(0);		!SET CRAM ADDR TO 0
4229		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
4230		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
4231		THEN
4232			BEGIN
4233			ERFLG = 1;
4234			ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
4235			END;
4236	!*MESSAGE 1
4237	!*STIMULUS:
4238	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
4239	!*	WRT 212/2	- ASSERT 'CONTINUE' PRE-FLOP
4240	!*	CP 1		- ASSERT 'CONTINUE'
4241	!*	X1 0		- SET CRAM ADDR TO 0
4242	!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP. SINCE
4243	!*			  'CONTINUE' IS ASSERTED, NO SKIP SHOULD OCCUR.
4244	!*RESPONSE:
4245	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
4246	!]ERROR 1
4247	!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4248		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4249		THEN
4250			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4251		0				!TO PREVENT INFO MSG WHEN COMPILING
4252		END;
4253	
4254		DO (0) WHILE
4255	BLOCK2:	BEGIN
4256	
4257		WRT212(0);		!NEGATE 'CONTINUE' PRE-FLOP
4258		CP_NOSS(1);		!GIVE CLK PULSE TO NEGATE 'CONTINUE'
4259		SET_C(0);		!SET CRAM ADDR TO 0
4260		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
4261		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
4262		THEN
4263			BEGIN
4264			ERFLG = 1;
4265			ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
4266			END;
4267	!*MESSAGE 2
4268	!*STIMULUS:
4269	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT CONTINUE' SKIP.
4270	!*	WRT 212/0	- NEGATE 'CONTINUE' PRE-FLOP
4271	!*	CP 1		- NEGATE 'CONTINUE'
4272	!*	X1 0		- SET CRAM ADDR TO 0
4273	!*	CP 1		- EXECUTE THE NOT CONTINUE SKIP.  SINCE
4274	!*			  'CONTINUE' IS NEGATED, WE SHOULD SKIP TO 3777.
4275	!*RESPONSE:
4276	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
4277	!]ERROR 2
4278	!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4279		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4280		THEN
4281			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4282		0				!TO PREVENT INFO MSG WHEN COMPILING
4283		END;
4284		IF .ERFLG EQL 0
4285		THEN
4286			NOERR(1);
4287	!]NO ERROR 1
4288	!]DSP_SKP_EN TCLKB SYNCH NTWK
4289	
4290		END;
4291	
4292	GLOBAL ROUTINE TST24: NOVALUE =
4293	
4294	!THIS TEST CHECKS THAT THE 'NOT 1 MSEC TIMER' SKIPPING WORKS
4295	!CORRECTLY, I.E., SKIP FIELD = 66.
4296	
4297		BEGIN
4298		LABEL BLOCK1,BLOCK2;
4299		BIND
4300			UC_PTR = PLIT(U_J(3776) U_SKIP_1_MS U);
4301		LOCAL
4302			ACTUAL;
4303	
4304		LOADUC(0,UC_PTR);	!LOAD MICROCODE
4305		DO (0) WHILE
4306	BLOCK1:	BEGIN
4307	
4308		WRT100(EN_1MS);		!ENABLE 1 MSEC TIME-OUT
4309		SET_C(0);		!SET CRAM ADDR TO 0
4310		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
4311		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
4312		THEN
4313			ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
4314	!*MESSAGE 1
4315	!*STIMULUS:
4316	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
4317	!*	WRT 100/4	- ENABLE 1 MSEC TIMER. THIS SHOULD CAUSE 'DPMC
4318	!*			  1 MSEC' TO ASSERT.
4319	!*	X1 0		- SET CRAM ADDR TO 0
4320	!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP. SINCE
4321	!*			  '1 MSEC' IS ASSERTED, NO SKIP SHOULD OCCUR.
4322	!*RESPONSE:
4323	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
4324	!]ERROR 1
4325	!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4326		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4327		THEN
4328			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4329		0				!TO PREVENT INFO MSG WHEN COMPILING
4330		END;
4331	
4332		DO (0) WHILE
4333	BLOCK2:	BEGIN
4334	
4335		WRT100(0);		!NEGATE '1 MSEC TIMER' ENABLE
4336		SET_C(0);		!SET CRAM ADDR TO 0
4337		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
4338		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
4339		THEN
4340			ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
4341	!*MESSAGE 2
4342	!*STIMULUS:
4343	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT 1 MSEC TIMER' SKIP.
4344	!*	WRT 100/0	- NEGATE '1 MSEC TIMER' ENABLE. THIS SHOULD
4345	!*			  CAUSE 'DPMC 1 MSEC' TO NEGATE.
4346	!*	X1 0		- SET CRAM ADDR TO 0
4347	!*	CP 1		- EXECUTE THE NOT 1 MSEC TIMER SKIP.  SINCE
4348	!*			  '1 MSEC' IS NEGATED, WE SHOULD SKIP TO 3777.
4349	!*RESPONSE:
4350	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
4351	!]ERROR 2
4352	!]SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4353		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4354		THEN
4355			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4356		0				!TO PREVENT INFO MSG WHEN COMPILING
4357		END;
4358	
4359		END;
4360	
4361	GLOBAL ROUTINE TST25: NOVALUE =
4362	
4363	!THIS TEST CHECKS THAT THE 'NOT I/O LATCH' SKIPPING WORKS
4364	!CORRECTLY, I.E., SKIP FIELD = 65.
4365	
4366		BEGIN
4367		LABEL BLOCK1,BLOCK2;
4368		BIND
4369			UC_PTR = PLIT(U_J(3776) U_SKIP_IO_BUSY U),
4370			UC_PTR1 = PLIT(U_J(1) U_SPEC_CLRIOLAT U,
4371					U_J(3776) U_SKIP_IO_BUSY U);
4372		LOCAL
4373			ACTUAL;
4374	
4375		LOADUC(0,UC_PTR);	!LOAD MICROCODE
4376		DO (0) WHILE
4377	BLOCK1:	BEGIN
4378	
4379		WRT115(IO_DATA);	!SET 'I/O DATA CYCLE' IN CSL BUFFER
4380		WRT210(BUS_REQ + XMIT_ADR);	!PUT IT ON BUS
4381		SET_C(0);		!SET CRAM ADDR TO 0
4382		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SKIP INSTR
4383		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
4384		THEN
4385			ERRCA(1,%O'3776',.ACTUAL,4);	!YES, REPORT ERROR
4386	!*MESSAGE 1
4387	!*STIMULUS:
4388	!*	LOAD MICRO-INSTR TO EXECUTE A 'NOT I/O LATCH' SKIP.
4389	!*	WRT 115/2	- ASSERT 'I/O DATA CYCLE' IN CSL I/O BUFFER.
4390	!*	WRT 210/140	- GATE 'I/O DATA CYCLE' ONTO KS10 BUS. THIS
4391	!*			  SHOULD ASSERT 'CRA2 I/O LATCH'.
4392	!*	X1 0		- SET CRAM ADDR TO 0
4393	!*	CP 1		- EXECUTE THE NOT I/O LATCH SKIP. SINCE
4394	!*			  'I/O LATCH' IS ASSERTED, NO SKIP SHOULD OCCUR.
4395	!*RESPONSE:
4396	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
4397	!]ERROR 1
4398	!]IOLTCH SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4399		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4400		THEN
4401			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4402		0				!TO PREVENT INFO MSG WHEN COMPILING
4403		END;
4404	
4405		LOADUC(0,UC_PTR1);	!LOAD MICROCODE
4406		DO (0) WHILE
4407	BLOCK2:	BEGIN
4408	
4409		WRT115(IO_DATA);	!SET 'I/O DATA CYCLE' IN CSL BUFFER
4410		WRT210(BUS_REQ + XMIT_ADR);	!PUT IT ON BUS
4411		SET_C(0);		!SET CRAM ADDR TO 0
4412		ACTUAL = STEP_U_NEXT(2);	!EXECUTE SKIP INSTR
4413		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
4414		THEN
4415			ERRCA(2,%O'3777',.ACTUAL,4);	!NO, REPORT ERROR
4416	!*MESSAGE 2
4417	!*STIMULUS:
4418	!*	LOAD MICRO-INSTRS TO CLEAR 'I/O LATCH' AND TO EXECUTE A 'NOT
4419	!*		I/O LATCH' SKIP.
4420	!*	WRT 115/2	- ASSERT 'I/O DATA CYCLE' IN CSL I/O BUFFER.
4421	!*	WRT 210/140	- GATE 'I/O DATA CYCLE' ONTO KS10 BUS. THIS
4422	!*			  SHOULD ASSERT 'CRA2 I/O LATCH'.
4423	!*	X1 0		- SET CRAM ADDR TO 0
4424	!*	CP 2		- THE 1ST INSTR DOES A 'SPEC/CLR I/O LATCH'.
4425	!*			  THIS SHOULD CLEAR 'I/O LATCH'. THE 2ND INSTR
4426	!*			  EXECUTES THE NOT CONTINUE SKIP.  SINCE
4427	!*			  'I/O LATCH' IS NEGATED,WE SHOULD SKIP TO 3777.
4428	!*RESPONSE:
4429	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
4430	!]ERROR 2
4431	!]SPEC10 IOLTCH SKIP10 AMX11 TCLKB DSP_SKP_EN SYNCH NTWK
4432		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4433		THEN
4434			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4435		0				!TO PREVENT INFO MSG WHEN COMPILING
4436		END;
4437	
4438		END;
4439	
4440	GLOBAL ROUTINE TST26: NOVALUE =
4441	
4442	!THIS TEST CHECKS THAT THE 'AD EQ 0' SKIPPING WORKS CORRECTLY.
4443	
4444		BEGIN
4445		LABEL BLOCK1,BLOCK2;
4446		BIND
4447			UC_PTR = PLIT(U_J(3776) U_SKIP_ADEQ0 U),
4448			UC_PTR1 = PLIT(U_J(3776) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_DEST_PASS U_SKIP_ADEQ0 U);
4449		LOCAL
4450			ACTUAL;
4451	
4452		LOADUC(0,UC_PTR);		!LOAD MICROCODE
4453		DO (0) WHILE
4454	BLOCK1:	BEGIN
4455	
4456		SET_C(0);		!SET CRAM ADDR = 0
4457		ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
4458		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
4459		THEN
4460			ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
4461	!*MESSAGE 1
4462	!*STIMULUS:
4463	!*	LOAD MICRO-INSTR TO DO 'AD EQ 0' SKIP TO LOCATION 3776.
4464	!*	X1 0	- SET CRAM ADDR TO 0
4465	!*	CP 1	- EXECUTE INSTR WHICH ASSERTS 'DPEA AD=0' AND DOES
4466	!*		  A 'AD EQ 0' SKIP (SKIP FIELD = 62).
4467	!*RESPONSE:
4468	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
4469	!]ERROR 1
4470	!]SKIP10 AMX11 NTWK
4471		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4472		THEN
4473			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4474		0				!TO PREVENT INFO MSG WHEN COMPILING
4475		END;
4476	
4477		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
4478		DO (0) WHILE
4479	BLOCK2:	BEGIN
4480	
4481		SET_C(0);		!SET CRAM ADDR = 0
4482		ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
4483		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
4484		THEN
4485			ERRCA(2,%O'3776',.ACTUAL,4); !YES, REPORT ERROR
4486	!*MESSAGE 2
4487	!*STIMULUS:
4488	!*	LOAD MICRO-INSTR TO DO 'AD EQ 0' SKIP TO LOCATION 3776.
4489	!*	X1 0	- SET CRAM ADDR TO 0
4490	!*	CP 1	- EXECUTE INSTR WHICH NEGATES 'DPEA AD=0' AND DOES
4491	!*		  A 'AD EQ 0' SKIP (SKIP FIELD = 62).
4492	!*RESPONSE:
4493	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
4494	!]ERROR 2
4495	!]SKIP10 AMX11 NTWK
4496		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4497		THEN
4498			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4499		0				!TO PREVENT INFO MSG WHEN COMPILING
4500		END;
4501	
4502		END;
4503	
4504	GLOBAL ROUTINE TST27: NOVALUE =
4505	
4506	!THIS TEST CHECKS THAT THE 'SC SIGN BIT' SKIPPING WORKS CORRECTLY.
4507	
4508		BEGIN
4509		LABEL BLOCK1,BLOCK2;
4510		BIND
4511			UC_PTR = PLIT(U_J(1) U_LOADSC U_SCADA_SN U_SN(1000) U_SCAD_A U,
4512					U_J(3776) U_SKIP_SC U),
4513			UC_PTR1 = PLIT(U_J(1) U_LOADSC U_SCADA_SN U_SN(0) U_SCAD_A U);
4514		LOCAL
4515			ACTUAL;
4516	
4517		LOADUC(0,UC_PTR);		!LOAD MICROCODE
4518		DO (0) WHILE
4519	BLOCK1:	BEGIN
4520	
4521		SET_C(0);		!SET CRAM ADDR = 0
4522		ACTUAL = STEP_U_NEXT(2);	!EXECUTE SC SIGN BIT SKIP
4523		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
4524		THEN
4525			ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
4526	!*MESSAGE 1
4527	!*STIMULUS:
4528	!*	LOAD MICRO-INSTRS TO ASSERT 'DPM4 SC SIGN' AND TO DO 'SC SIGN
4529	!*		BIT' SKIP TO LOCATION 3776.
4530	!*	X1 0	- SET CRAM ADDR TO 0
4531	!*	CP 2	- THE FIRST INSTR SHOULD SETUP FOR THE ASSERTION OF
4532	!*		  'DPM SC SIGN'.  THE 2ND INSTR WILL ASSERT IT AND DO A
4533	!*		  SKIP BASED ON THAT ASSERTION.
4534	!*RESPONSE:
4535	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
4536	!]ERROR 1
4537	!]SKIP10 AMX11 NTWK
4538		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4539		THEN
4540			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4541		0				!TO PREVENT INFO MSG WHEN COMPILING
4542		END;
4543	
4544		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
4545		DO (0) WHILE
4546	BLOCK2:	BEGIN
4547	
4548		SET_C(0);		!SET CRAM ADDR = 0
4549		ACTUAL = STEP_U_NEXT(2);	!EXECUTE SC SIGN BIT SKIP
4550		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE SKIP?
4551		THEN
4552			ERRCA(2,%O'3776',.ACTUAL,4); !YES, REPORT ERROR
4553	!*MESSAGE 2
4554	!*STIMULUS:
4555	!*	LOAD MICRO-INSTRS TO NEGATE 'DPM4 SC SIGN' AND TO DO 'SC SIGN
4556	!*		BIT' SKIP TO LOCATION 3776.
4557	!*	X1 0	- SET CRAM ADDR TO 0
4558	!*	CP 2	- THE FIRST INSTR SHOULD SETUP FOR THE NEGATION OF
4559	!*		  'DPM SC SIGN'.  THE 2ND INSTR WILL NEGATE IT AND DO A
4560	!*		  SKIP BASED ON THAT NEGATION.
4561	!*RESPONSE:
4562	!*	THE NEXT CRAM ADDRESS DID SKIP TO 3777.
4563	!]ERROR 2
4564	!]SKIP10 AMX11 NTWK
4565		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4566		THEN
4567			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4568		0				!TO PREVENT INFO MSG WHEN COMPILING
4569		END;
4570	
4571		END;
4572	
4573	GLOBAL ROUTINE TST28: NOVALUE =
4574	
4575	!THIS TEST CHECKS THAT DISPATCHING ON 'DPM3 SCAD 00' WORKS CORRECTLY.
4576	
4577		BEGIN
4578		LABEL BLOCK1,BLOCK2;
4579		BIND
4580			UC_PTR = PLIT(U_J(3775) U_SCADA_SN U_SN(1000) U_SCAD_A U_DISP_SCAD0 U),
4581			UC_PTR1 = PLIT(U_J(3775) U_SCADA_SN U_SN(0) U_SCAD_A U_DISP_SCAD0 U);
4582		LOCAL
4583			ACTUAL;
4584	
4585		LOADUC(0,UC_PTR);		!LOAD MICROCODE
4586		DO (0) WHILE
4587	BLOCK1:	BEGIN
4588	
4589		SET_C(0);		!SET CRAM ADDR = 0
4590		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SCAD 0 DISPATCH
4591		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
4592		THEN
4593			ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
4594	!*MESSAGE 1
4595	!*STIMULUS:
4596	!*	LOAD MICRO-INSTR TO ASSERT 'DPM3 SCAD 00' AND DO A SCAD 00
4597	!*		DISPATCH (67) TO 3775.
4598	!*	X1 0	- SET CRAM ADDR TO 0
4599	!*	CP 1	- EXECUTE THE MICRO-INSTR.  WITH 'SCAD 00' ASSERTED, THE
4600	!*		  NEXT CRAM ADDRESS SHOULD DISPATCH TO 3777.
4601	!*RESPONSE:
4602	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
4603	!]ERROR 1
4604	!]AMX10 NTWK
4605		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4606		THEN
4607			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4608		0				!TO PREVENT INFO MSG WHEN COMPILING
4609		END;
4610	
4611		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
4612		DO (0) WHILE
4613	BLOCK2:	BEGIN
4614	
4615		SET_C(0);		!SET CRAM ADDR = 0
4616		ACTUAL = STEP_U_NEXT(1);	!EXECUTE SCAD 0 DISPATCH
4617		IF .ACTUAL NEQ %O'3775'		!DID WE TAKE SKIP?
4618		THEN
4619			ERRCA(2,%O'3775',.ACTUAL,4); !YES, REPORT ERROR
4620	!*MESSAGE 2
4621	!*STIMULUS:
4622	!*	LOAD MICRO-INSTR TO NEGATE 'DPM3 SCAD 00' AND DO A SCAD 00
4623	!*		DISPATCH (67) TO 3775.
4624	!*	X1 0	- SET CRAM ADDR TO 0
4625	!*	CP 1	- EXECUTE THE MICRO-INSTR.  WITH 'SCAD 00' NEGATED, THE
4626	!*		  NEXT CRAM ADDRESS SHOULD DISPATCH TO 3775.
4627	!*RESPONSE:
4628	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3775.
4629	!]ERROR 2
4630	!]AMX10 NTWK
4631		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4632		THEN
4633			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4634		0				!TO PREVENT INFO MSG WHEN COMPILING
4635		END;
4636	
4637		END;
4638	
4639	GLOBAL ROUTINE TST29: NOVALUE =
4640	
4641	!THIS TEST CHECKS THAT DISPATCHING ON 'DPE5 FLAG QR 37' WORKS CORRECTLY.
4642	
4643		BEGIN
4644		LABEL BLOCK1,BLOCK2;
4645		BIND
4646			UC_PTR = PLIT(U_J(1) U_N(777777) U_DBUS_DBM U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U,
4647					U_J(2) U_DEST_Q_DIV2 U,
4648					U_J(3) U_DEST_Q_DIV2 U,
4649					U_J(4) U_DEST_Q_DIV2 U,
4650					U_J(3773) U_DISP_MUL U),
4651			UC_PTR1 = PLIT(U_J(1) U_DEST_Q_AD U,
4652					U_J(2) U_DEST_Q_DIV2 U,
4653					U_J(3773) U_DISP_MUL U);
4654		LOCAL
4655			ACTUAL;
4656	
4657		LOADUC(0,UC_PTR);		!LOAD MICROCODE
4658		DO (0) WHILE
4659	BLOCK1:	BEGIN
4660	
4661		SET_C(0);		!SET CRAM ADDR = 0
4662		ACTUAL = STEP_U_NEXT(5);	!EXECUTE DISPATCH
4663		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
4664		THEN
4665			ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
4666	!*MESSAGE 1
4667	!*STIMULUS:
4668	!*	LOAD MICRO-INSTRS TO ASSERT 'DPE5 FLAG QR 37' THEN DO A
4669	!*		'MULTIPLY' DISPATCH (62) TO 3773.
4670	!*	X1 0	- SET CRAM ADDR TO 0
4671	!*	CP 5	- THE FIRST INSTR LOADS ONES INTO THE Q REGISTER.
4672	!*		  THE NEXT 3 INSTRS SHIFT THE Q REG RIGHT AND ASSERT
4673	!*		  'DPE1-2 QR 37'.  THE LAST INSTR ASSERTS 'DPE5 FLAG
4674	!*		  QR 37' AND DOES THE 'MULTIPLY' DISPATCH WHICH SHOULD
4675	!*		  GO TO 3777.
4676	!*RESPONSE:
4677	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
4678	!]ERROR 1
4679	!]AMX9 NTWK
4680		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4681		THEN
4682			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4683		0				!TO PREVENT INFO MSG WHEN COMPILING
4684		END;
4685	
4686		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
4687		DO (0) WHILE
4688	BLOCK2:	BEGIN
4689	
4690		SET_C(0);		!SET CRAM ADDR = 0
4691		ACTUAL = STEP_U_NEXT(3);	!EXECUTE DISPATCH
4692		IF .ACTUAL NEQ %O'3773'		!DID WE TAKE SKIP?
4693		THEN
4694			ERRCA(2,%O'3773',.ACTUAL,4); !YES, REPORT ERROR
4695	!*MESSAGE 2
4696	!*STIMULUS:
4697	!*	LOAD MICRO-INSTRS TO NEGATE 'DPE5 FLAG QR 37' THEN DO A
4698	!*		'MULTIPLY' DISPATCH (62) TO 3773.
4699	!*	X1 0	- SET CRAM ADDR TO 0
4700	!*	CP 3	- THE FIRST INSTR LOADS A ZERO INTO BIT 37 OF THE Q
4701	!*		  REGISTER. THE NEXT INSTR SHIFTS THE Q REG RIGHT AND
4702	!*		  NEGATES 'DPE1-2 QR 37'.  THE LAST INSTR NEGATES
4703	!*		  'DPE5 FLAG QR 37' AND DOES A MULTIPLY DISPATCH WHICH
4704	!*		  SHOULD GO TO 3773.
4705	!*RESPONSE:
4706	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3773.
4707	!]ERROR 2
4708	!]AMX9 NTWK
4709		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4710		THEN
4711			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4712		0				!TO PREVENT INFO MSG WHEN COMPILING
4713		END;
4714	
4715		END;
4716	
4717	GLOBAL ROUTINE TST30: NOVALUE =
4718	
4719	!THIS TEST CHECKS THAT DISPATCHING ON 'DPM6 MEMORY CYCLE' WORKS CORRECTLY.
4720	
4721		BEGIN
4722		LABEL BLOCK1,BLOCK2;
4723		BIND
4724			UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
4725					U_J(2) U_N(40002) U_MEM U,
4726					U_J(3767) U_DISP_NICOND U),
4727			UC_PTR1 = PLIT(U_J(1) U_SPEC_MEMCLR U,
4728					U_J(3767) U_DISP_NICOND U);
4729		LOCAL
4730			ACTUAL;
4731	
4732		LOADUC(0,UC_PTR);		!LOAD MICROCODE
4733		DO (0) WHILE
4734	BLOCK1:	BEGIN
4735	
4736		SET_C(0);		!SET CRAM ADDR = 0
4737		ACTUAL = STEP_U_NEXT(3);	!EXECUTE DISPATCH
4738		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
4739		THEN
4740			ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
4741	!*MESSAGE 1
4742	!*STIMULUS:
4743	!*	LOAD MICRO-INSTRS TO ASSERT 'DPM6 MEMORY CYCLE' THEN DO A
4744	!*		'NICOND' DISPATCH (64) TO 3767.
4745	!*	X1 0	- SET CRAM ADDR TO 0
4746	!*	CP 3	- THE FIRST INSTR CLEARS ANY LEFT OVER PAGE FAULTS.
4747	!*		  THE 2ND INSTR STARTS A MEMORY CYCLE. THE 3RD INSTR
4748	!*		  ASSERTS 'DPM6 MEMORY CYCLE' AND DOES A NICOND DISPATCH
4749	!*		  WHICH SHOULD GO TO 3777.
4750	!*RESPONSE:
4751	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
4752	!]ERROR 1
4753	!]AMX8 NTWK
4754		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4755		THEN
4756			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4757		0				!TO PREVENT INFO MSG WHEN COMPILING
4758		END;
4759	
4760		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
4761		DO (0) WHILE
4762	BLOCK2:	BEGIN
4763	
4764		SET_C(0);		!SET CRAM ADDR = 0
4765		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
4766		IF .ACTUAL NEQ %O'3767'		!DID WE TAKE SKIP?
4767		THEN
4768			ERRCA(2,%O'3767',.ACTUAL,4); !YES, REPORT ERROR
4769	!*MESSAGE 2
4770	!*STIMULUS:
4771	!*	LOAD MICRO-INSTRS TO NEGATE 'DPM6 MEMORY CYCLE' THEN DO A
4772	!*		'NICOND' DISPATCH (64) TO 3767.
4773	!*	X1 0	- SET CRAM ADDR TO 0
4774	!*	CP 2	- THE FIRST INSTR DOES A SPEC/MEMORY CLEAR.THE 2ND INSTR
4775	!*		  NEGATES 'DPM6 MEMORY CYCLE' AND DOES A NICOND DISPATCH
4776	!*		  WHICH SHOULD GO TO 3767.
4777	!*RESPONSE:
4778	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3767.
4779	!]ERROR 2
4780	!]AMX8 NTWK
4781		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4782		THEN
4783			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4784		0				!TO PREVENT INFO MSG WHEN COMPILING
4785		END;
4786	
4787		END;
4788	
4789	GLOBAL ROUTINE TST31: NOVALUE =
4790	
4791	!THIS TEST CHECKS THAT 'BYTE' DISPATCHING WORKS CORRECTLY.
4792	
4793		BEGIN
4794		LABEL BLOCK1,BLOCK2,ERBLK1,ERBLK2;
4795		BIND
4796			UC_PTR = PLIT(U_J(3770) U_N(10700) U_DBUS_DBM U_ALU_OR U_LSRC_D0 U_DISP_BYTE U),
4797			UC_PTR1 = PLIT(U_J(3770) U_DISP_BYTE U);
4798		LOCAL
4799			DISCREP,
4800			ACTUAL;
4801	
4802		LOADUC(0,UC_PTR);		!LOAD MICROCODE
4803		DO (0) WHILE
4804	BLOCK1:	BEGIN
4805	
4806		SET_C(0);		!SET CRAM ADDR = 0
4807		ACTUAL = STEP_U_NEXT(1);	!EXECUTE DISPATCH
4808		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE DISPATCH?
4809		THEN
4810	ERBLK1:		BEGIN
4811			ERMCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
4812			DISCREP = .ACTUAL XOR %O'3777'; !COMPUTE DISCREPANCIES
4813			INCR J FROM 0 TO 2 BY 1 DO
4814				IF .DISCREP EQL 1^.J
4815				THEN
4816					BEGIN
4817					FAILURE(.J+1);
4818					LEAVE ERBLK1;
4819					END;
4820			FAILURE(4);
4821			END;
4822	!*MESSAGE 1
4823	!*STIMULUS:
4824	!*	LOAD MICRO-INSTR TO ASSERT 'DPE5 BYTE DISP 9,10,11' AND DO A
4825	!*		BYTE DISPATCH TO 3770.
4826	!*	X1 0	- SET CRAM ADDR TO 0
4827	!*	CP 1	- EXECUTE THE MICRO-INSTR TO ASSERT THE 'BYTE DISP' BITS
4828	!*		  AND DO A BYTE DISPATCH WHICH SHOULD GO TO 3777.
4829	!*RESPONSE:
4830	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3777.
4831	!]ERROR 1
4832	!]AMX11 NTWK
4833	!]ERROR 2
4834	!]AMX10 NTWK
4835	!]ERROR 3
4836	!]AMX9 NTWK
4837	!]ERROR 4
4838	!]AMX9 AMX10 AMX11 NTWK
4839		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4840		THEN
4841			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4842		0				!TO PREVENT INFO MSG WHEN COMPILING
4843		END;
4844	
4845		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
4846		DO (0) WHILE
4847	BLOCK2:	BEGIN
4848	
4849		SET_C(0);		!SET CRAM ADDR = 0
4850		ACTUAL = STEP_U_NEXT(1);	!EXECUTE DISPATCH
4851		IF .ACTUAL NEQ %O'3770'		!DID WE TAKE SKIP?
4852		THEN
4853	ERBLK2:		BEGIN
4854			ERMCA(2,%O'3770',.ACTUAL,4); !YES, REPORT ERROR
4855			DISCREP = .ACTUAL XOR %O'3770'; !COMPUTE DISCREPANCIES
4856			INCR J FROM 0 TO 2 BY 1 DO
4857				IF .DISCREP EQL 1^.J
4858				THEN
4859					BEGIN
4860					FAILURE(.J+5);
4861					LEAVE ERBLK2;
4862					END;
4863			FAILURE(4);
4864			END;
4865	!*MESSAGE 2
4866	!*STIMULUS:
4867	!*	LOAD MICRO-INSTR TO NEGATE 'DPE5 BYTE DISP 9,10,11' AND DO A
4868	!*		BYTE DISPATCH TO 3770.
4869	!*	X1 0	- SET CRAM ADDR TO 0
4870	!*	CP 1	- EXECUTE THE MICRO-INSTR TO NEGATE THE 'BYTE DISP' BITS
4871	!*		  AND DO A BYTE DISPATCH WHICH SHOULD GO TO 3770.
4872	!*RESPONSE:
4873	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3770.
4874	!]ERROR 5
4875	!]SKIP10 AMX11 NTWK
4876	!]ERROR 6
4877	!]AMX10 NTWK
4878	!]ERROR 7
4879	!]AMX9 NTWK
4880	!]ERROR 8
4881	!]AMX9 AMX10 AMX11 NTWK
4882		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4883		THEN
4884			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4885		0				!TO PREVENT INFO MSG WHEN COMPILING
4886		END;
4887	
4888		END;
4889	
4890	GLOBAL ROUTINE TST32: NOVALUE =
4891	
4892	!THIS TEST CHECKS THAT 'EFFECTIVE ADDRESS MODE' DISPATCHING WORKS
4893	!CORRECTLY.
4894	
4895		BEGIN
4896		LABEL BLOCK1,BLOCK2,ERBLK1,ERBLK2;
4897		BIND
4898			UC_PTR = PLIT(U_J(1) U_SPEC_LDINST U_N(20) U_DBUS_DBM U,
4899					U_J(3760) U_DISP_EAMODE U),
4900			UC_PTR1 = PLIT(U_J(1) U_SPEC_LDINST U_N(254017) U_DBUS_DBM U,
4901					U_J(3760) U_DISP_EAMODE U);
4902		LOCAL
4903			DISCREP,
4904			ACTUAL;
4905	
4906		LOADUC(0,UC_PTR);		!LOAD MICROCODE
4907		DO (0) WHILE
4908	BLOCK1:	BEGIN
4909	
4910		SET_C(0);		!SET CRAM ADDR = 0
4911		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
4912		IF .ACTUAL NEQ %O'3776'		!DID WE TAKE DISPATCH?
4913		THEN
4914	ERBLK1:		BEGIN
4915			ERMCA(1,%O'3776',.ACTUAL,4); !NO, REPORT ERROR
4916			DISCREP = .ACTUAL XOR %O'3776'; !COMPUTE DISCREPANCIES
4917			INCR J FROM 0 TO 3 BY 1 DO
4918				IF .DISCREP EQL 1^.J
4919				THEN
4920					BEGIN
4921					FAILURE(.J+1);
4922					LEAVE ERBLK1;
4923					END;
4924			FAILURE(5);
4925			END;
4926	!*MESSAGE 1
4927	!*STIMULUS:
4928	!*	LOAD MICRO-INSTR TO SETUP THE 3 EA MODE DISPATCH SIGNALS AND DO
4929	!*		AN 'EA MODE' DISPATCH TO 3760.
4930	!*	X1 0	- SET CRAM ADDR TO 0
4931	!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
4932	!*		  AND XR LOAD.  THE 2ND INSTR NEGATES 'DPEA JRST,0' AND
4933	!*		  ASSERTS 'DPEA XR=0' AND 'DPEA INDIRECT' THEN DOES AN
4934	!*		  EA MODE DISPATCH WHICH SHOULD GO TO 3776.
4935	!*RESPONSE:
4936	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3776.
4937	!]ERROR 1
4938	!]SKIP10 AMX11 NTWK
4939	!]ERROR 2
4940	!]AMX10 NTWK
4941	!]ERROR 3
4942	!]AMX9 NTWK
4943	!]ERROR 4
4944	!]AMX8 NTWK
4945	!]ERROR 5
4946	!]AMX8 AMX9 AMX10 AMX11 NTWK
4947		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
4948		THEN
4949			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
4950		0				!TO PREVENT INFO MSG WHEN COMPILING
4951		END;
4952	
4953		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
4954		DO (0) WHILE
4955	BLOCK2:	BEGIN
4956	
4957		SET_C(0);		!SET CRAM ADDR = 0
4958		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
4959		IF .ACTUAL NEQ %O'3760'		!DID WE TAKE SKIP?
4960		THEN
4961	ERBLK2:		BEGIN
4962			ERMCA(2,%O'3760',.ACTUAL,4); !YES, REPORT ERROR
4963			DISCREP = .ACTUAL XOR %O'3760';
4964			INCR J FROM 0 TO 3 BY 1 DO
4965				IF .DISCREP EQL 1^.J
4966				THEN
4967					BEGIN
4968					FAILURE(.J+1);
4969					LEAVE ERBLK2;
4970					END;
4971			FAILURE(5);
4972			END;
4973	!*MESSAGE 2
4974	!*STIMULUS:
4975	!*	LOAD MICRO-INSTR TO SETUP THE 3 EA MODE DISPATCH SIGNALS AND DO
4976	!*		AN 'EA MODE' DISPATCH TO 3760.
4977	!*	X1 0	- SET CRAM ADDR TO 0
4978	!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
4979	!*		  AND XR LOAD.  THE 2ND INSTR ASSERTS 'DPEA JRST,0' AND
4980	!*		  NEGATES 'DPEA XR=0' AND 'DPEA INDIRECT' THEN DOES AN
4981	!*		  EA MODE DISPATCH WHICH SHOULD GO TO 3760.
4982	!*RESPONSE:
4983	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 3760.
4984		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
4985		THEN
4986			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
4987		0				!TO PREVENT INFO MSG WHEN COMPILING
4988		END;
4989	
4990		END;
4991	
4992	GLOBAL ROUTINE TST33: NOVALUE =
4993	
4994	!THIS TEST CHECKS THAT 'DROM' DISPATCHING WORKS CORRECTLY.
4995	
4996		BEGIN
4997		LABEL BLOCK1,BLOCK2,ERBLK1,ERBLK2;
4998		BIND
4999			UC_PTR = PLIT(U_J(1) U_SPEC_LDINST U_N(702740) U_DBUS_DBM U,
5000					U_J(0) U_DISP_DROM U),
5001			UC_PTR1 = PLIT(U_J(1) U_SPEC_LDINST U_N(600000) U_DBUS_DBM U,
5002					U_J(0) U_DISP_DROM U);
5003		LOCAL
5004			DISCREP,
5005			ACTUAL;
5006	
5007		LOADUC(0,UC_PTR);		!LOAD MICROCODE
5008		DO (0) WHILE
5009	BLOCK1:	BEGIN
5010	
5011		SET_C(0);		!SET CRAM ADDR = 0
5012		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
5013		IF .ACTUAL NEQ %O'1777'		!DID WE TAKE DISPATCH?
5014		THEN
5015	ERBLK1:		BEGIN
5016			ERMCA(1,%O'1777',.ACTUAL,4); !NO, REPORT ERROR
5017			DISCREP = .ACTUAL XOR %O'1777';	!COMPUTE DISCREPANCIES
5018			INCR J FROM 0 TO 11 BY 1 DO
5019				IF .DISCREP EQL 1^.J
5020				THEN
5021					BEGIN
5022					FAILURE(.J+1);	!DO FAULT ISOLATION
5023					LEAVE ERBLK1;
5024					END;
5025			FAILURE(13);
5026			END;
5027	!*MESSAGE 1
5028	!*STIMULUS:
5029	!*	LOAD MICRO-INSTRS TO SELECT DROM LOCATION WITH 'DROM J 00-03'
5030	!*		EQUAL TO ONES AND 'AC DISP' ASSERTED.  ALSO, ASSERT
5031	!*		'AC 09' TO 'AC 12'.
5032	!*	X1 0	- SET CRAM ADDR TO 0
5033	!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
5034	!*		  AND XR LOAD. THE 2ND INSTR LOADS THE IR WITH 702,
5035	!*		  SELECTING A DROM LOCATION WITH 'DROM J 00-03' = 1S AND
5036	!*		  'AC DISP' ASSERTED.  WITH THE AC FIELD ALL ONES, THE
5037	!*		  DROM DISPATCH THEN SHOULD GO TO 1777.
5038	!*RESPONSE:
5039	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1777.
5040	!]ERROR 1
5041	!]AMX11 NTWK
5042	!]ERROR 2
5043	!]AMX10 NTWK
5044	!]ERROR 3
5045	!]AMX9 NTWK
5046	!]ERROR 4
5047	!]AMX8 NTWK
5048	!]ERROR 5
5049	!]AMX6_7 NTWK
5050	!]ERROR 6
5051	!]AMX6_7 NTWK
5052	!]ERROR 7
5053	!]AMX4_5 NTWK
5054	!]ERROR 8
5055	!]AMX4_5 NTWK
5056	!]ERROR 9
5057	!]AMX2_3 NTWK
5058	!]ERROR 10
5059	!]AMX2_3 NTWK
5060	!]ERROR 11
5061	!]AMX0_1 NTWK
5062	!]ERROR 12
5063	!]AMX0_1 NTWK
5064	!]ERROR 13
5065	!]AMX NTWK
5066		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5067		THEN
5068			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5069		0				!TO PREVENT INFO MSG WHEN COMPILING
5070		END;
5071	
5072		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
5073		DO (0) WHILE
5074	BLOCK2:	BEGIN
5075	
5076		SET_C(0);		!SET CRAM ADDR = 0
5077		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
5078		IF .ACTUAL NEQ %O'1400'		!DID WE TAKE SKIP?
5079		THEN
5080	ERBLK2:		BEGIN
5081			ERMCA(2,%O'1400',.ACTUAL,4); !YES, REPORT ERROR
5082			DISCREP = .ACTUAL XOR %O'1400';	!COMPUTE DISCREPANCIES
5083			INCR J FROM 0 TO 11 BY 1 DO
5084				IF .DISCREP EQL 1^.J
5085				THEN
5086					BEGIN
5087					FAILURE(.J+1);	!DO FAULT ISOLATION
5088					LEAVE ERBLK2;
5089					END;
5090			FAILURE(13);
5091			END;
5092	!*MESSAGE 2
5093	!*STIMULUS:
5094	!*	LOAD MICRO-INSTRS TO CAUSE A DROM DISPATCH FROM A DROM LOACTION
5095	!*		WHICH HAS 'DROM 00-07' = 0 AND 'AC DISP' NEGATED.
5096	!*	X1 0	- SET CRAM ADDR TO 0
5097	!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
5098	!*		  AND XR LOAD.  THE 2ND INSTR LOADS THE IR WITH 600,
5099	!*		  SELECTING A DROM LOCATION WITH 'DROM 00-07' = 0. THE
5100	!*		  DROM DISPATCH SHOULD THEN GO TO 1400.
5101	!*RESPONSE:
5102	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1400.
5103		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
5104		THEN
5105			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
5106		0				!TO PREVENT INFO MSG WHEN COMPILING
5107		END;
5108	
5109		END;
5110	
5111	GLOBAL ROUTINE TST34: NOVALUE =
5112	
5113	!THIS TEST CHECKS THAT 'AREAD' DISPATCHING WORKS CORRECTLY.
5114	
5115		BEGIN
5116		LABEL BLOCK1,BLOCK2,BLOCK3,ERBLK1,ERBLK2,ERBLK3;
5117		BIND
5118			UC_PTR = PLIT(U_J(1) U_SPEC_LDINST U_N(110000) U_DBUS_DBM U,
5119					U_J(17) U_DISP_AREAD U),
5120			UC_PTR1 = PLIT(U_J(1) U_SPEC_LDINST U_N(324000) U_DBUS_DBM U,
5121					U_J(17) U_DISP_AREAD U),
5122			UC_PTR2 = PLIT(U_J(1) U_SPEC_LDINST U_N(221000) U_DBUS_DBM U,
5123					U_J(17) U_DISP_AREAD U);
5124		LOCAL
5125			DISCREP,
5126			ACTUAL;
5127	
5128		LOADUC(0,UC_PTR);		!LOAD MICROCODE
5129		DO (0) WHILE
5130	BLOCK1:	BEGIN
5131	
5132		SET_C(0);		!SET CRAM ADDR = 0
5133		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
5134		IF .ACTUAL NEQ %O'57'		!DID WE TAKE DISPATCH?
5135		THEN
5136	ERBLK1:		BEGIN
5137			ERMCA(1,%O'57',.ACTUAL,4); !NO, REPORT ERROR
5138			DISCREP = .ACTUAL XOR %O'57';	!COMPUTE DISCREPANCIES
5139			INCR J FROM 0 TO 7 BY 1 DO
5140				IF .DISCREP EQL %O'20'^.J
5141				THEN
5142					BEGIN
5143					FAILURE(.J+1);	!DO FAULT ISOLATION
5144					LEAVE ERBLK1;
5145					END;
5146			FAILURE(9);
5147			END;
5148	!*MESSAGE 1
5149	!*STIMULUS:
5150	!*	LOAD MICRO-INSTRS TO SELECT DROM LOCATION WITH 'DROM A=J' = 0
5151	!*		THEN DO AN 'AREAD' DISPATCH.
5152	!*	X1 0	- SET CRAM ADDR TO 0
5153	!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
5154	!*		  AND XR LOAD. THE 2ND INSTR LOADS THE IR WITH 110,
5155	!*		  SELECTING A DROM LOCATION WITH 'DROM A=J' NEGATED.
5156	!*		  WITH THE J FIELD = 17, THE AREAD DISPATCH SHOULD THEN
5157	!*		  GO TO 57.
5158	!*RESPONSE:
5159	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 57.
5160	!]ERROR 1
5161	!]AMX6_7 AREAD NTWK
5162	!]ERROR 2
5163	!]AMX6_7 AREAD NTWK
5164	!]ERROR 3
5165	!]AMX4_5 AREAD NTWK
5166	!]ERROR 4
5167	!]AMX4_5 AREAD NTWK
5168	!]ERROR 5
5169	!]AMX2_3 AREAD NTWK
5170	!]ERROR 6
5171	!]AMX2_3 AREAD NTWK
5172	!]ERROR 7
5173	!]AMX0_1 AREAD NTWK
5174	!]ERROR 8
5175	!]AMX0_1 AREAD NTWK
5176	!]ERROR 9
5177	!]AREAD NTWK
5178		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5179		THEN
5180			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5181		0				!TO PREVENT INFO MSG WHEN COMPILING
5182		END;
5183	
5184		LOADUC(0,UC_PTR1);		!LOAD MICROCODE
5185		DO (0) WHILE
5186	BLOCK2:	BEGIN
5187	
5188		SET_C(0);		!SET CRAM ADDR = 0
5189		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
5190		IF .ACTUAL NEQ %O'1537'		!DID WE TAKE SKIP?
5191		THEN
5192	ERBLK2:		BEGIN
5193			ERMCA(2,%O'1537',.ACTUAL,4); !YES, REPORT ERROR
5194			DISCREP = .ACTUAL XOR %O'1537';	!COMPUTE DISCREPANCIES
5195			INCR J FROM 0 TO 7 BY 1 DO
5196				IF .DISCREP EQL %O'20'^.J
5197				THEN
5198					BEGIN
5199					FAILURE(.J+1);	!DO FAULT ISOLATION
5200					LEAVE ERBLK2;
5201					END;
5202			FAILURE(9);
5203			END;
5204	!*MESSAGE 2
5205	!*STIMULUS:
5206	!*	LOAD MICRO-INSTR TO CAUSE AN 'AREAD' DISPATCH FROM A DROM
5207	!*		LOACTION WHICH HAS 'DROM A=J' ASSERTED AND 'DROM 00-
5208	!*		03' = 5.
5209	!*	X1 0	- SET CRAM ADDR TO 0
5210	!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
5211	!*		  AND XR LOAD.  THE 2ND INSTR LOADS THE IR WITH 324,
5212	!*		  SELECTING A DROM LOCATION WITH 'DROM 00-03' = 5 AND
5213	!*		  'DROM A=J' ASSERTED.  WITH THE J FIELD = 17, THE
5214	!*		  DROM DISPATCH SHOULD THEN GO TO 1537.
5215	!*RESPONSE:
5216	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1537.
5217		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
5218		THEN
5219			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
5220		0				!TO PREVENT INFO MSG WHEN COMPILING
5221		END;
5222	
5223		LOADUC(0,UC_PTR2);		!LOAD MICROCODE
5224		DO (0) WHILE
5225	BLOCK3:	BEGIN
5226	
5227		SET_C(0);		!SET CRAM ADDR = 0
5228		ACTUAL = STEP_U_NEXT(2);	!EXECUTE DISPATCH
5229		IF .ACTUAL NEQ %O'1657'		!DID WE TAKE SKIP?
5230		THEN
5231	ERBLK3:		BEGIN
5232			ERMCA(3,%O'1657',.ACTUAL,4); !YES, REPORT ERROR
5233			DISCREP = .ACTUAL XOR %O'1657';	!COMPUTE DISCREPANCIES
5234			INCR J FROM 0 TO 7 BY 1 DO
5235				IF .DISCREP EQL %O'20'^.J
5236				THEN
5237					BEGIN
5238					FAILURE(.J+1);	!DO FAULT ISOLATION
5239					LEAVE ERBLK3;
5240					END;
5241			FAILURE(9);
5242			END;
5243	!*MESSAGE 3
5244	!*STIMULUS:
5245	!*	LOAD MICRO-INSTR TO CAUSE AN 'AREAD' DISPATCH FROM A DROM
5246	!*		LOACTION WHICH HAS 'DROM A=J' ASSERTED AND 'DROM 00-
5247	!*		03' = 12.
5248	!*	X1 0	- SET CRAM ADDR TO 0
5249	!*	CP 2	-THE 1ST INSTR SETS UP THE DBUS BITS AND ASSERTS SPEC IR
5250	!*		  AND XR LOAD.  THE 2ND INSTR LOADS THE IR WITH 221,
5251	!*		  SELECTING A DROM LOCATION WITH 'DROM 00-03' = 12 AND
5252	!*		  'DROM A=J' ASSERTED.  WITH THE J FIELD = 17, THE
5253	!*		  DROM DISPATCH SHOULD THEN GO TO 1657.
5254	!*RESPONSE:
5255	!*	THE NEXT CRAM ADDRESS DID NOT DISPATCH TO 1657.
5256		IF LOOP_CHK(3)		!CHECK FOR ERROR LOOPING
5257		THEN
5258			LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
5259		0				!TO PREVENT INFO MSG WHEN COMPILING
5260		END;
5261	
5262		END;
5263	
5264	GLOBAL ROUTINE TST35: NOVALUE =
5265	
5266	!THIS TEST CHECKS THAT A PAGE FAIL CAUSES A DISPATCH TO CRAM ADDR 7777.
5267	!IT ALSO VERIFIES THAT THAT DISPATCH IS REALLY DONE AS A SUBROUTINE
5268	!CALL.
5269	
5270		BEGIN
5271		LABEL BLOCK1,ERBLK1;
5272		BIND
5273			UC_PTR = PLIT(U_J(1) U_SPEC_MEMCLR U,
5274					U_J(2) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
5275					U_J(3) U_ALU_OR U_RSRC_D0 U_DBUS_DBM U_N(10000) U_SPEC_APR_EN U,
5276					U_J(4) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(403010) U_SPEC_LDPAGE U,
5277					U_J(5) U,
5278					U_J(6) U_ALU_XNOR U_LSRC_AB U_RSRC_AB U_MEM U_N(432012) U,
5279					U_J(0) U_MEM U_N(2) U),
5280			UC_PTR1 = PLIT(U_J(0) U_SPEC_MEMCLR U_DISP_RETURN U),
5281			UC_PTR2 = PLIT(U_J(0) U_SPEC_MEMCLR U);
5282		LOCAL
5283			DISCREP,
5284			ACTUAL;
5285	
5286		LOADUC(0,UC_PTR);	!LOAD MICROCODE FOR PAGE FAIL
5287		LOAD_U(7777,UC_PTR1);	!LOAD RETURN INSTR
5288		DO (0) WHILE
5289	BLOCK1:	BEGIN
5290	
5291		SET_C(0);		!SET CRAM ADDR = 0
5292		ACTUAL = STEP_U_NEXT(7);	!GENERATE PAGE FAIL
5293		IF .ACTUAL NEQ %O'7777'		!DID WE TRAP?
5294		THEN
5295	ERBLK1:		BEGIN
5296			ERMCA(1,%O'7777',.ACTUAL,4);	!NO, REPORT ERROR
5297			DISCREP = .ACTUAL XOR %O'7777';	!COMPUTE DISCREPANCIES
5298			INCR J FROM 0 TO 11 BY 1 DO
5299				IF .DISCREP EQL 1^.J
5300				THEN
5301					BEGIN
5302					FAILURE(.J+1);	!DO FAULT ISOLATION
5303					LEAVE ERBLK1;
5304					END;
5305			FAILURE(13);
5306			END;
5307	!*MESSAGE 1
5308	!*STIMULUS:
5309	!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP TO ADDR 7777.
5310	!*	X1 0		- SET CRAM ADDR = 0.
5311	!*	CP 7 	- THE FIRST 5 INSTRS CLEAR ANY LEFT OVER PAGE FAULT
5312	!*		  CONDITIONS AND LOAD A ZERO ENTRY INTO THE PAGE
5313	!*		  TABLE AT PAGE -1. THE NEXT 2 INSTRS ATTEMPT A PAGED
5314	!*		  MEMORY REFERENCE TO PAGE -1.  THIS SHOULD CAUSE A PAGE
5315	!*		  FAIL (SINCE 'PAGE VALID' IS NEGATED) WHICH SHOULD TRAP
5316	!*		  THE CRAM ADDR TO 7777.
5317	!*RESPONSE:
5318	!*	THE NEXT CRAM ADDRESS DID NOT TRAP TO 7777.
5319	!]ERROR 1
5320	!]AMX11 NTWK
5321	!]ERROR 2
5322	!]AMX10 NTWK
5323	!]ERROR 3
5324	!]AMX9 NTWK
5325	!]ERROR 4
5326	!]AMX8 NTWK
5327	!]ERROR 5
5328	!]AMX6_7 NTWK
5329	!]ERROR 6
5330	!]AMX6_7 NTWK
5331	!]ERROR 7
5332	!]AMX4_5 NTWK
5333	!]ERROR 8
5334	!]AMX4_5 NTWK
5335	!]ERROR 9
5336	!]AMX2_3 NTWK
5337	!]ERROR 10
5338	!]AMX2_3 NTWK
5339	!]ERROR 11
5340	!]AMX0_1 NTWK
5341	!]ERROR 12
5342	!]AMX0_1 NTWK
5343	!]ERROR 13
5344	!]PFBUF NTWK
5345		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5346		THEN
5347			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5348	
5349		ACTUAL = STEP_U_NEXT(1);	!EXECUTE THE RETRUN INSTR
5350		IF .ACTUAL NEQ 6		!DID WE RETURN OKAY?
5351		THEN
5352			BEGIN
5353			ERMCA(2,6,.ACTUAL,4);	!NO, REPORT ERROR
5354			FAILURE(14);
5355			END;
5356	!*MESSAGE 2
5357	!*STIMULUS:
5358	!*	LOAD MICRO-INSTRS TO CAUSE A PAGE FAIL TRAP TO ADDR 7777 AND
5359	!*		THEN DO A RETURN FROM THERE.
5360	!*	X1 0	- SET CRAM ADDRESS = 0.
5361	!*	CP 7	- CAUSE THE PAGE FAIL AND TRAP TO ADDRESS 7777.
5362	!*	CP 1	- EXECUTE THE RETURN INSTR THERE.  IF THE PAGE FAIL TRAP
5363	!*		  WORKED CORRECTLY, IT WOULD HAVE DONE A PUSH ONTO THE
5364	!*		  STACK. THEN THE RETURN WILL GO TO ADDR 6.
5365	!*RESPONSE:
5366	!*	THE RETURN INSTR AT 7777 DID NOT GO TO ADDR 6.
5367	!]ERROR 14
5368	!]PFBUF STKADR CALLRTN NTWK
5369		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
5370		THEN
5371			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5372		0				!TO PREVENT INFO MSG WHEN COMPILING
5373		END;
5374		LOADUC(0,UC_PTR2);	!LOAD MEM CLR INSTR
5375		CP_NOSS(3);		!EXECUTE INSTR TO CLEAR PAGE FAULT
5376	
5377		END;
5378	
5379	GLOBAL ROUTINE TST36: NOVALUE =
5380	
5381	!THIS TEST CHECKS THAT THE 'SKIP 40' INPUT TO THE NEXT ADDR MUX CAN BE
5382	!ASSERTED AND CAUSES A SKIP.
5383	
5384		BEGIN
5385		LABEL BLOCK1;
5386		BIND
5387			UC_PTR = PLIT(U_J(3776) U_SKIP_ADLEQ0 U);
5388		LOCAL
5389			ACTUAL;
5390	
5391		LOADUC(0,UC_PTR);		!LOAD MICROCODE
5392		DO (0) WHILE
5393	BLOCK1:	BEGIN
5394	
5395		SET_C(0);		!SET CRAM ADDR = 0
5396		ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
5397		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
5398		THEN
5399			ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
5400	!*MESSAGE 1
5401	!*STIMULUS:
5402	!*	LOAD MICRO-INSTR TO DO 'ADL = 0' SKIP TO LOCATION 3776.
5403	!*	X1 0	- SET CRAM ADDR TO 0
5404	!*	CP 1	- EXECUTE INSTR WHICH ASSERTS 'DPE1 ADL=0' AND DOES
5405	!*		  A 'ADL EQ 0' SKIP (SKIP FIELD = 32).
5406	!*RESPONSE:
5407	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
5408	!]ERROR 1
5409	!]AMX11 NTWK
5410		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5411		THEN
5412			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5413		0				!TO PREVENT INFO MSG WHEN COMPILING
5414		END;
5415	
5416		END;
5417	
5418	GLOBAL ROUTINE TST37: NOVALUE =
5419	
5420	!THIS TEST CHECKS THAT THE 'SKIP 20' INPUT TO THE NEXT ADDR MUX CAN BE
5421	!ASSERTED AND CAUSES A SKIP.
5422	
5423		BEGIN
5424		LABEL BLOCK1;
5425		BIND
5426			UC_PTR = PLIT(U_J(3776) U_SKIP_DP0 U_N(777777) U_DBUS_DBM U_ALU_OR U_LSRC_D0 U);
5427		LOCAL
5428			ACTUAL;
5429	
5430		LOADUC(0,UC_PTR);		!LOAD MICROCODE
5431		DO (0) WHILE
5432	BLOCK1:	BEGIN
5433	
5434		SET_C(0);		!SET CRAM ADDR = 0
5435		ACTUAL = STEP_U_NEXT(1);	!EXECUTE AD EQ 0 SKIP
5436		IF .ACTUAL NEQ %O'3777'		!DID WE TAKE SKIP?
5437		THEN
5438			ERRCA(1,%O'3777',.ACTUAL,4); !NO, REPORT ERROR
5439	!*MESSAGE 1
5440	!*STIMULUS:
5441	!*	LOAD MICRO-INSTR TO DO 'ADL SIGN' SKIP TO LOCATION 3776.
5442	!*	X1 0	- SET CRAM ADDR TO 0
5443	!*	CP 1	- EXECUTE INSTR WHICH ASSERTS 'DPE1 ADL SIGN' AND DOES
5444	!*		  A 'ADL SIGN' SKIP (SKIP FIELD = 52).
5445	!*RESPONSE:
5446	!*	THE NEXT CRAM ADDRESS DID NOT SKIP TO 3777.
5447	!]ERROR 1
5448	!]AMX11 NTWK
5449		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5450		THEN
5451			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5452		0				!TO PREVENT INFO MSG WHEN COMPILING
5453		END;
5454	
5455		END;
5456	
5457	GLOBAL ROUTINE TST38: NOVALUE =
5458	
5459	!THIS TEST CHECKS THAT THE 'CRA2 RETURN' SIGNAL GETS ASSERTED ONLY WHEN
5460	!IT IS SUPPOSED TO, I.E., WHEN 'CRA6 DISP SEL 1A' IS ASSERTED AND
5461	!'CRA6 DISP SEL 2A' AND 'CRA6 DISP EN 20' ARE NEGATED.  THIS OCCURS WHEN
5462	!THE DISPATCH FIELDS ARE EQUAL TO 41.
5463	!TO DO THE TEST A 'CALL' IS DONE FROM LOCATION 0 TO LOCATION 1.  FROM
5464	!LOCATION 1 A 'CALL' IS MADE TO LOCATION 2.  AT LOCATION 2 A DISPATCH OF
5465	!'71' IS DONE WITH A J FIELD OF 3.  THIS DISPATCH SHOULD NOT AFFECT THE
5466	!NEXT ADDRESS BUT IF THERE IS A FAULT 'CRA2 RETURN' WILL GET ASSERTED.
5467	!IN THAT CASE, THE SUBROUTINE STACK WILL BE DECREMENTED.  AFTER EXECUTE
5468	!THE INSTRUCTION AT LOCATION 3, THE STACK WILL CONTAIN 0 INSTEAD OF THE
5469	!CORRECT VALUE OF 1.  THIS IS REPEATED TWICE MORE WITH LOCATION 2 HAVING
5470	!DISPATCH FIELDS OF 50 AND 53.
5471	
5472		BEGIN
5473		LABEL BLOCK1;
5474		BIND
5475			UC_PTR = PLIT(U_J(1) U_CALL U,
5476					U_J(2) U_CALL U,
5477					U,
5478					U_J(4) U);
5479		OWN
5480			DISP_TAB: VECTOR[3] INITIAL (%O'71', %O'50', %O'53'),
5481			PTR_TAB: VECTOR[3] INITIAL (PLIT(U_J(3) U_DISP(%O'71') U),
5482						PLIT(U_J(3) U_DISP(%O'50') U),
5483						PLIT(U_J(3) U_DISP(%O'53') U));
5484		LOCAL
5485			ACTUAL;
5486	
5487		LOADUC(0,UC_PTR);	!LOAD MICROCODE
5488		INCR I FROM 0 TO 2 BY 1 DO
5489		BEGIN
5490		LOADUC(2,.PTR_TAB[.I]);	!LOAD DISPATCH INSTR
5491		DO (0) WHILE
5492	BLOCK1:	BEGIN
5493	
5494		WRT204(STK_RESET);		!RESET STACK PTR
5495		WRT204(0);
5496		SET_C(0);		!SET CRAM ADDR = 0
5497		CP(4);			!EXECUTE BAD DISPATCH
5498		ACTUAL = READ_SBR();		!READ 'SBR RET'
5499		IF .ACTUAL NEQ 1		!DID 'CRA2 RETURN' ASSERT?
5500		THEN
5501			ERRCAS(1,1,1,.ACTUAL,4,DISP_TAB[.I]); !YES, REPORT ERROR
5502	!*MESSAGE 1
5503	!*STIMULUS:
5504	!*	LOAD MICRO-INSTRS TO DO 2 'CALLS' AND A DISPATCH '\O0'.
5505	!*	WRT 204/2	- DO A STACK RESET
5506	!*	WRT 204/0
5507	!*	X1 0		- SET  CRAM ADDRESS = 0.
5508	!*	CP 4		- THIS FIRST INSTR DOES A CALL TO LOCATION 1.
5509	!*			  THE 2ND INSTR DOES A CALL TO LOCATION 2. THIS
5510	!*			  SHOULD PUT A 1 AT THE TOP OF THE STACK. THE
5511	!*			  3RD INSTR HAS A DISPATCH FIELD OF \O0 WHICH
5512	!*			  SHOULD DO NOTHING.  THE 4TH INSTR IS JUST
5513	!*			  EXECUTED TO CLOCK THE 'SBR RET' REGISTER. THE
5514	!*			  'SBR RET' SHOULD CONTAIN A 1.
5515	!*RESPONSE:
5516	!*	THE 'SBR RET' DOES NOT CONTAIN A 1. THIS IMPLIES THAT THE
5517	!*	INSTR AT LOC 2 WITH DISPATCH FIELD \O0 INCORRECTLY ASSERTED
5518	!*	'CRA2 RETURN' THUS CAUSING THE STACK TO GET DECREMENTED.
5519	!]ERROR 1
5520	!]RTN NTWK
5521		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5522		THEN
5523			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5524		0				!TO PREVENT INFO MSG WHEN COMPILING
5525		END;
5526		END;
5527	
5528		END;
5529	
5530	GLOBAL ROUTINE TST39: NOVALUE =
5531	
5532	!THIS TEST CHECKS THAT THE 'SPEC/CONSOLE' SIGNAL GETS GENERATED
5533	!CORRECTLY.
5534	
5535		BEGIN
5536		LABEL BLOCK1,BLOCK2;
5537		BIND
5538			UC_PTR = PLIT(U_J(1) U_SPEC_N U_N(10) U),
5539			UC_PTR1 = PLIT(U_J(1) U_N(10) U);
5540	
5541		LOAD_U(0,UC_PTR);			!LOAD CRAM BITS
5542		DO (0) WHILE
5543	BLOCK1:	BEGIN
5544	
5545		WRT100(RESET);		!DO A RESET
5546		WRT100(0);
5547		SET_C(0);		!SET CRAM ADDR = 0
5548		WRT212(4);				!ASSERT 1ST STAGE FLOP
5549		CP(2);			!GIVE 2 CLK PULSES
5550		IF (RD_300 AND RUN_1 ) NEQ 0		!DID 'RUN (1)' NEGATE?
5551		THEN
5552			ERR(1);		!NO, REPORT ERROR
5553	!*MESSAGE 1
5554	!*STIMULUS:
5555	!*	LOAD MICRO-INSTR TO ASSERT 'SPEC/CONSOLE' AND 'CRM2 # 14B'.
5556	!*	ASSERT AND NEGATE 'RESET'
5557	!*	X1 0		- SET CRAM ADDR = 0.
5558	!*	WRT 212/4	- ASSERT  'RUN' PRE-FLOP
5559	!*	CP 2		- THE 1ST CLOCK PULSE WILL EXECUTE THE MICRO-
5560	!*			  INSTR TO ASSERT 'CRA2 SPEC/CONSOLE' AND 'CRM2
5561	!*			  # 14B'.  THIS WILL NEGATE THE 'RUN' PRE-FLOP.
5562	!*			  AT THE SAME TIME THE 'RUN' FLOP WILL BE
5563	!*			  ASSERTED.  THE 2ND PULSE WILL CLOCK THE
5564	!*			  NEGATED OUTPUT OF THE PRE-FLOP INTO THE 'RUN'
5565	!*			  FLOP, THUS NEGATING 'RUN'.
5566	!*RESPONSE:
5567	!*	'RUN (1)' DID NOT NEGATE. THIS IMPLIES THAT 'CRA2 SPEC/CONSOLE'
5568	!*	DID NOT ASSERT.
5569	!]ERROR 1
5570	!]SPEC10 NTWK
5571		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5572		THEN
5573			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5574		0				!TO PREVENT INFO MSG WHEN COMPILING
5575	
5576		END;
5577	
5578		LOAD_U(0,UC_PTR1);			!LOAD CRAM BITS
5579		DO (0) WHILE
5580	BLOCK2:	BEGIN
5581	
5582		WRT100(RESET);		!DO A RESET
5583		WRT100(0);
5584		SET_C(0);		!SET CRAM ADDR = 0
5585		WRT212(4);				!ASSERT 1ST STAGE FLOP
5586		CP(2);			!GIVE 2 CLK PULSES
5587		IF (RD_300 AND RUN_1 ) EQL 0		!DID 'RUN (1)' NEGATE?
5588		THEN
5589			ERR(2);		!YES, REPORT ERROR
5590	!*MESSAGE 2
5591	!*STIMULUS:
5592	!*	LOAD MICRO-INSTR TO NEGATE 'SPEC/CONSOLE' AND ASSERT
5593	!*		'CRM2 # 14B'.
5594	!*	ASSERT AND NEGATE 'RESET'
5595	!*	X1 0		- SET CRAM ADDR = 0.
5596	!*	WRT 212/4	- ASSERT  'RUN' PRE-FLOP
5597	!*	CP 2		- THE 1ST CLOCK PULSE WILL EXECUTE THE MICRO-
5598	!*			  INSTR TO NEGATE 'CRA2 SPEC/CONSOLE' AND
5599	!*			  ASSERT 'CRM2 # 14B'.  THIS SHOULD NOT NEGATE
5600	!*			  THE 'RUN' PRE-FLOP.  AT THE SAME TIME THE
5601	!*			  'RUN' FLOP WILL BE ASSERTED.  THE 2ND PULSE
5602	!*			  WILL CLOCK THE STILL ASSERTED OUTPUT OF THE
5603	!*			  PRE-FLOP INTO THE 'RUN' FLOP, THUS LEAVING
5604	!*			  'RUN' ASSERTED.
5605	!*RESPONSE:
5606	!*	'RUN (1)' NEGATED. THIS IMPLIES THAT 'CRA2 SPEC/CONSOLE'
5607	!*	ASSERTED WHEN IT SHOULDN'T HAVE.
5608	!]ERROR 2
5609	!]SPEC10 NTWK
5610		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
5611		THEN
5612			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
5613		0				!TO PREVENT INFO MSG WHEN COMPILING
5614	
5615		END;
5616	
5617		END;
5618	
5619	GLOBAL ROUTINE TST40: NOVALUE =
5620	
5621	!THIS TEST CHECKS THAT THE PARITY DETECTION NETWORK FUNCTIONS CORRECTLY.
5622	
5623		BEGIN
5624		LABEL BLOCK1,BLOCK2;
5625		LOCAL
5626			ERFLG;
5627		OWN
5628			EVEN_PAR_TBL: VECTOR[16] INITIAL( %O'0',
5629							  %O'400040000000',
5630							  %O'200020000000',
5631							  %O'001000000010',
5632							  %O'000400000004',
5633							  %O'000151030303',
5634							  %O'000152030303',
5635							  %O'000153010303',
5636							  %O'000153020303',
5637							  %O'000153030103',
5638							  %O'000153030203',
5639							  %O'000153030301',
5640							  %O'000153030302',
5641							  %O'776737777777',
5642							  %O'777367777777',
5643							  %O'777727777777'),
5644			ODD_PAR_TBL: VECTOR[29] INITIAL(  %O'100010400000',
5645							  %O'040004200000',
5646							  %O'020000104000',
5647							  %O'010000042000',
5648							  %O'004000001040',
5649							  %O'002000000420',
5650							  %O'000200000000',
5651							  %O'000100000000',
5652							  %O'000000000020',
5653							  %O'000000000004',
5654							  %O'000002000000',
5655							  %O'000001000000',
5656							  %O'000000020000',
5657							  %O'000000010000',
5658							  %O'000000000200',
5659							  %O'000000000100',
5660							  %O'000000000002',
5661							  %O'000000000001',
5662							  %O'000153030303',
5663							  %O'377727777777',
5664							  %O'577753777777',
5665							  %O'677777277777',
5666							  %O'737777537777',
5667							  %O'757777772777',
5668							  %O'767777775377',
5669							  %O'773777777727',
5670							  %O'775777777753',
5671							  %O'777577777777',
5672							  %O'777677777777');
5673		ERFLG = 0;		!INIT ERROR FLAG
5674		LCA(0);			!SET CRAM ADDR = 0
5675		INCR I FROM 0 TO 15 BY 1 DO
5676		BEGIN
5677		DO (0) WHILE
5678	BLOCK1:	BEGIN
5679	
5680		DC_035(.EVEN_PAR_TBL[.I]);	!LOAD PATTERN INTO CRAM
5681		CP(1);				!CLOCK CRAM BITS INTO REGISTER
5682		IF (RD_100 AND CRA_PE) EQL 0	!DID CRA PARITY ERROR ASSERT?
5683		THEN
5684			BEGIN
5685			ERRS(1,1,EVEN_PAR_TBL[.I]);	!YES, REPORT ERROR
5686			ERFLG = -1;		!SET ERROR FLAG
5687			END;
5688	!*MESSAGE 1
5689	!*STIMULUS:
5690	!*	LC 0			- SET CRAM ADDR = 0
5691	!*	DC \O000000000000000000000  - DEPOSIT TEST PATTERN INTO
5692	!*				  BITS 0-35 OF CRAM.  THIS SHOULD YIELD
5693	!*				  VALID EVEN PARITY.
5694	!*RESPONSE:
5695	!*	'CRA PARITY ERR' ASSERTED ON THE CSL BOARD.
5696	!]ERROR 1
5697	!]PARNET NTWK
5698		IF LOOP_CHK(1)		!CHECK FOR ERROR LOOPING
5699		THEN
5700			LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
5701		0				!TO PREVENT INFO MSG WHEN COMPILING
5702		END;
5703		IF .ERFLG NEQ 0
5704		THEN
5705			RETURN;
5706		END;
5707	
5708		LCA(0);			!SET CRAM ADDR = 0
5709		INCR I FROM 0 TO 28 BY 1 DO
5710		BEGIN
5711		DO (0) WHILE
5712	BLOCK2:	BEGIN
5713	
5714		DC_035(.ODD_PAR_TBL[.I]);	!LOAD PATTERN INTO CRAM
5715		CP(1);				!CLOCK CRAM BITS INTO REGISTER
5716		IF (RD_100 AND CRA_PE) NEQ 0	!DID CRA PARITY ERROR ASSERT?
5717		THEN
5718			BEGIN
5719			ERRS(2,2,ODD_PAR_TBL[.I]);	!NO, REPORT ERROR
5720			ERFLG = -1;		!SET ERROR FLAG
5721			END;
5722	!*MESSAGE 2
5723	!*STIMULUS:
5724	!*	LC 0			- SET CRAM ADDR = 0
5725	!*	DC \O000000000000000000000  - DEPOSIT TEST PATTERN INTO
5726	!*				  BITS 0-35 OF CRAM.  THIS SHOULD YIELD
5727	!*				  INVALID ODD PARITY.
5728	!*RESPONSE:
5729	!*	'CRA PARITY ERR' DID NOT ASSERT ON THE CSL BOARD.
5730	!]ERROR 2
5731	!]PARNET NTWK
5732		IF LOOP_CHK(2)		!CHECK FOR ERROR LOOPING
5733		THEN
5734			LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
5735		0				!TO PREVENT INFO MSG WHEN COMPILING
5736		END;
5737		IF .ERFLG NEQ 0
5738		THEN
5739			RETURN;
5740		END;
5741	
5742		END;
5743	END
5744	ELUDOM

AC0				 978+#	 982+#	 986+#	 990+#	 994+#	 998+#	1002+#	1006+#	1010+#	1014+#	1018+#	1022+#
				1026+#	1030+#	1034+#	1038+#	1042+#	1046+#	1050+#	1054+#	1058+#	1062+#	1066+#	1113+#
ACTUAL				1741	1747#	1748	1751	1753	1796	1807#	1808	1812	1813	1886	1898#
				1899	1903	1904	1922	2016	2029#	2030	2034	2035	2074	2185	2198#
				2199	2203	2204	2224	2318	2331#	2332	2336	2337	2418	2427#	2428
				2431	2432	2438	2492	2502#	2503	2506	2511	2575	2585#	2586	2589
				2594	2642#	2643	2646	2651	2721	2734#	2735	2738	2740	2761	2762
				2763	2849	2865#	2866	2870	2871	2967	2985#	2986	2988	3026#	3027
				3029	3088	3095#	3097	3100	3102	3203#	3205	3208	3209	3250	3265#
				3266	3268	3363	3375#	3376	3378	3417	3428#	3429	3432	3433	3499
				3514#	3515	3518	3519	3629	3640#	3641	3645	3646	3713	3724#	3725
				3727	3771	3782#	3783	3787	3788	3832#	3833	3837	3838	3875#	3876
				3880	3881	3919#	3920	3924	3925	3969#	3970	3974	3975	4028	4036#
				4037	4039	4065#	4066	4068	4104	4114#	4115	4119	4140#	4141	4145
				4177#	4178	4182	4219	4229#	4230	4234	4260#	4261	4265	4302	4310#
				4311	4313	4337#	4338	4340	4373	4382#	4383	4385	4412#	4413	4415
				4450	4457#	4458	4460	4482#	4483	4485	4515	4522#	4523	4525	4549#
				4550	4552	4583	4590#	4591	4593	4616#	4617	4619	4655	4662#	4663
				4665	4691#	4692	4694	4730	4737#	4738	4740	4765#	4766	4768	4800
				4807#	4808	4811	4812	4850#	4851	4854	4855	4904	4911#	4912	4915
				4916	4958#	4959	4962	4963	5005	5012#	5013	5016	5017	5077#	5078
				5081	5082	5126	5133#	5134	5137	5138	5189#	5190	5193	5194	5228#
				5229	5232	5233	5284	5292#	5293	5296	5297	5349#	5350	5353	5389
				5396#	5397	5399	5428	5435#	5436	5438	5485	5498#	5499	5501
ADDR				 989+	 990+	1174+	1175+	1176+	1177+	1679	1719	3086	3096#	3100	3197
				3198	3204#	3208	3232	3233	3361	3371#	3373	3378
ADPT1_PE			 349+#
ADPT2_PE			 310+#
ADPT3_PE			 315+#
ADPT4_PE			 348+#
ADR				2724	2729	2852	2857
ADR_TAB				3411	3422	3492	3504
BAD_DATA			 214+#
BEGIN_XLIST			1172+#
BITS				3249
BLISS36				   4
BLOCK1				1737	1744	1774	1787	1803	1854	1877	1893	1982	2007	2023	2151
				2176	2192	2284	2309	2325	2394	2414	2421	2474	2488	2495	2556
				2570	2578	2639	2696	2712	2731	2821	2840	2859	2941	2973	2981
				3022	3070	3083	3244	3257	3301	3341	3359	3368	3393	3418	3424
				3471	3500	3506	3578	3593	3635	3683	3703	3719	3746	3759	3776
				3821	4021	4032	4057	4099	4108	4134	4167	4214	4224	4250	4298
				4306	4328	4367	4377	4401	4445	4454	4473	4509	4519	4540	4578
				4587	4607	4644	4659	4682	4722	4734	4756	4794	4804	4841	4896
				4908	4949	4997	5009	5068	5116	5130	5180	5271	5289	5347	5371
				5385	5393	5412	5424	5432	5451	5473	5492	5523	5536	5543	5573
				5624	5678	5700
BLOCK2				3759	3829	3865	4021	4062	4087	4099	4172	4197	4214	4255	4281
				4298	4333	4355	4367	4407	4434	4445	4479	4498	4509	4546	4567
				4578	4613	4633	4644	4688	4711	4722	4762	4783	4794	4847	4884
				4896	4955	4986	4997	5074	5105	5116	5186	5219	5536	5580	5612
				5624	5712	5734
BLOCK3				3759	3871	3909	5116	5225	5258
BLOCK4				3759	3915	3959
BLOCK5				3759	3965	4004
BOOT				 365+#
BUSREQ				 368+#
BUS_REQ				 253+#	1604	1640	4380	4410
CACHE_ENB			 152+#
CE				1230+
CH				1232+
CHK_ERR_MSG			1215+	1458
CLEAR_CRAM			  57	1446	1461*	1993	2162	2295	2405	2479	2561	2700	3372
CLK_DATA			  60	1566	1572*	1805	3511
CLK_RUN				 242+#
CLOSE_LATCH			 247+#	1640
CLR_INT				 236+#
COM_ADR				 213+#
CONS_ENB			 366+#
CONTINUE			 258+#	4226
CONTINUE_H			 353+#
CONTROL				1201+*
CORRECT				1795	1801#	1805	1808	1812	1813	1885	1891#	1896	1899	1903	1904
				2015	2021#	2026	2030	2034	2035	2184	2190#	2195	2199	2203	2204
				2317	2323#	2328	2332	2336	2337	2966	2978#	2979	2984	2986	2988
				3029	3362	3370#	3371	3376	3378	3416	3422#	3426	3429	3432	3433
				3498	3504#	3509	3511	3515	3518	3519
CP				1171+	1220+	3024	3374	3427	3510	3637	3721	5497	5549	5586	5681
				5715
CP_NOSS				1221+	1445	1447	3780	4112	4175	4227	4258	5375
CRAM_ADDR			1168+
CRAM_ADR_LD			 226+#	3512
CRAM_PE				 314+#
CRAM_RESET			 222+#	1529	2425	2499	2582
CRAM_WRT			 227+#	1568
CRA_PE				 311+#	5682	5716
CRA_R_CLK			 249+#	1604
CRA_T_CLK			 250+#	1640
CRM_PE_DET			 154+#
CR_CLK_ENB			 383+#
CR_LF				 974+#	 978+	1006+
CS				1231+
CSL_INT				 218+#
CTY_BIT				 360+#
CTY_CHAR_LEN			 359+#
DATA				1174+	1176+	1533	1566	1572	1602	1603	1791	1801	1881	1891	2011
				2021	2180	2190	2313	2323
DATA0				 207+#
DATA1				 206+#
DATA10				 194+#
DATA11				 193+#
DATA12				 189+#
DATA13				 188+#
DATA14				 187+#
DATA15				 186+#
DATA16				 185+#
DATA17				 184+#
DATA18				 183+#
DATA19				 182+#
DATA2				 205+#
DATA20				 178+#
DATA21				 177+#
DATA22				 176+#
DATA23				 175+#
DATA24				 174+#
DATA25				 173+#
DATA26				 172+#
DATA27				 171+#
DATA28				 167+#
DATA29				 166+#
DATA3				 204+#
DATA30				 165+#
DATA31				 164+#
DATA32				 163+#
DATA33				 162+#
DATA34				 161+#
DATA35				 160+#
DATA4				 200+#
DATA5				 199+#
DATA6				 198+#
DATA7				 197+#
DATA8				 196+#
DATA9				 195+#
DATA_ACK			 364+#
DATA_CYCLE			 211+#
DC_0				1492#	1495
DC_035				1239+	5680	5714
DEST				 548+	 549+
DI				1176+#
DIAG1				 231+#
DIAG10				 234+#
DIAG2				 232+#
DIAG4				 233+#
DIAG_FN				1533	1567
DISCREP				1794	1813#	1815	1825	1884	1904#	1906	1916	2014	2035#	2037	2047
				2057	2067	2183	2204#	2206	2216	2316	2337#	2339	2720	2740#	2742
				2752	2848	2871#	2873	2883	3085	3209#	3211	3415	3433#	3435	3497
				3519#	3521	3627	3646#	3651	3769	3788#	3790	3838#	3840	3881#	3883
				3925#	3927	3975#	3977	4799	4812#	4814	4855#	4857	4903	4916#	4918
				4963#	4965	5004	5017#	5019	5082#	5084	5125	5138#	5140	5194#	5196
				5233#	5235	5283	5297#	5299
DISP_TAB			5480	5501
DM				1174+#	1450
DM_CHK				1241+
DN				1245+
DP				 561+	 562+	 582+	 583+
DP_CLK_ENBL			 382+#
DP_PE_DET			 153+#
DP_PE				 312+#
DP_RESET			 224+#
EB_AC				 964+#	1088+
EC				1237+	1719	3198	3233
EC_AC				 965+#	1089+
EC_BITS				  63	1679*	3025	3264
EC_BUF				1717	1721#	1723#	1724#	1726#	1727#	1728
EI				1177+#
EI_AC				 961+#	1085+
EI_CHK				1248+
EJ				1235+	1676
EJ_AC				 962+#	1086+
EK_AC				 963+#	1087+
EM				1175+#
EM_AC				 966+#	1090+
EM_CHK				1244+
END_LIST			1173+#
EN_1MS				 151+#	4308
EOP_UUO				1080+#
ERBLK1				1737	1750	1757	1787	1810	1819	1829	1877	1901	1910	1920	1926
				2007	2032	2041	2051	2061	2071	2078	2176	2201	2210	2220	2228
				2309	2334	2343	2414	2430	2436	2442	2488	2505	2515	2570	2588
				2598	2712	2737	2746	2756	2767	2840	2868	2877	2887	3083	3099
				3106	3418	3431	3439	3500	3517	3525	3593	3643	3655	3760	3785
				3794	4794	4810	4818	4896	4914	4922	4997	5015	5023	5116	5136
				5144	5271	5295	5303
ERBLK2				2570	2645	2655	3083	3207	3215	3760	3835	3844	4794	4853	4861
				4896	4961	4969	4997	5080	5088	5116	5192	5200
ERBLK3				3760	3878	3887	5116	5231	5239
ERBLK4				3760	3922	3931
ERBLK5				3760	3972	3981
ERFLG				1793	1798#	1811#	1858	1883	1888#	1902#	1987	2013	2018#	2033#	2156
				2182	2187#	2202#	2289	2315	2320#	2335#	2399	2719	2726#	2739#	2826
				2847	2854#	2869#	2946	3770	3774#	3786#	3836#	3879#	3923#	3973#	4008
				4103	4110#	4118#	4135	4144#	4181#	4200	4218	4221#	4233#	4264#	4284
				5626	5673#	5686#	5703	5720#	5737
ERMCAS				1209+	2738	2870	3100	3208	3432	3518	3645
ERMCA				1208+	1751	1812	1903	2034	2203	2336	2431	2506	2589	2646	3787
				3837	3880	3924	3974	4811	4854	4915	4962	5016	5081	5137	5193
				5232	5296	5353
ERMS				1210+
ERR				1203+	5552	5589
ERRCAS				1205+	2988	3029	3268	3306	3378	5501
ERRCA				1204+	3727	4039	4068	4119	4145	4182	4234	4265	4313	4340	4385
				4415	4460	4485	4525	4552	4593	4619	4665	4694	4740	4768	5399
				5438
ERRFLG				1277+
ERRM				1207+
ER_AC				 960+#	1084+
EVEN_PAR_TBL			5628	5680	5685
EXECUTE_B			 354+#
EXNEXT				1178+	1224+
EX_NXT				1171+	1178+#	3514	4140
FAILURE				1212+	1756	1759	1818	1828	1833	1909	1919	1925	1931	2040	2050
				2060	2070	2077	2083	2209	2219	2227	2232	2342	2348	2435	2441
				2447	2514	2520	2597	2603	2654	2660	2745	2755	2766	2772	2876
				2886	2892	3105	3112	3214	3221	3438	3444	3524	3530	3654	3660
				3793	3796	3843	3846	3886	3889	3930	3933	3980	3983	4817	4820
				4860	4863	4921	4924	4968	4971	5022	5025	5087	5090	5143	5146
				5199	5202	5238	5241	5302	5305	5354
FILNAM_ADR			1113+
FLP_CHK				1214+	1768	1852	1980	2149	2282	2392	2472	2554	2637	2694	2819
				2939
FLP_PTR				1739#	1768	1789#	1852	1879#	1980	2009#	2149	2178#	2282	2311#	2392
				2416#	2472	2490#	2554	2714#	2717	2819	2842#	2845	2939
FLP_PTR1			2572#	2637
FLP_PTR2			2573#	2694
FORCE_PAR			 150+#
FRDPAG				1115+#
FSELECT				1113+#
FUNC				 508+	 509+
HALTED				1120+#
HALT_LOOP			 356+#
I				1799	1801	1889	1891	2019	2021	2188	2190	2321	2323	2727	2729
				2819	2855	2857	2939	2976	2978	2988	3029	3101	3102	3105	3210
				3211	3214	3259	3261	3268	3306	3420	3422	3502	3504	3638	3641
				3644	3645	3646	5488	5490	5501	5675	5680	5685	5709	5714	5719
IO_DATA				 212+#	4379	4409
IO_DEPOSIT			1176+	1246+
IO_EXAMINE			1177+	1247+
J				1752	1753	1814	1815	1824	1825	1905	1906	1909	1915	1916	1919
				2036	2037	2040	2046	2047	2050	2056	2057	2060	2066	2067	2070
				2205	2206	2209	2215	2216	2219	2338	2339	2342	2510	2511	2514
				2593	2594	2597	2650	2651	2654	2741	2742	2745	2751	2752	2755
				2872	2873	2876	2882	2883	2886	3434	3435	3438	3520	3521	3524
				3650	3651	3654	3789	3790	3793	3839	3840	3843	3882	3883	3886
				3926	3927	3930	3976	3977	3980	4813	4814	4817	4856	4857	4860
				4917	4918	4921	4964	4965	4968	5018	5019	5022	5083	5084	5087
				5139	5140	5143	5195	5196	5199	5234	5235	5238	5298	5299	5302
KLINIK_BIT			 358+#
KLINIK_CARR			 374+#
KLINIK_LEN			 357+#
LANGUAGE			   4
LATCH_DATA			 248+#
LC				1169+#	2983	3093	3201
LCA				1169+	1238+	5674	5708
LOADUC				1168+	1227+	1444	2975	2979	3197	3232	3262	3263	3373	3426	3508
				3509	3631	3717	3773	3869	3913	3963	4030	4106	4222	4304	4375
				4405	4452	4477	4517	4544	4585	4611	4657	4686	4732	4760	4802
				4845	4906	4953	5007	5072	5128	5184	5223	5286	5374	5391	5430
				5487	5490
LOAD_U				1168+#	5287	5541	5578
LOOP_CHK			1213+	3020	3068	3193	3228	3299	3339	3391	3469	3576	3681	3744
				3819	3863	3907	3957	4002	4055	4085	4132	4165	4195	4248	4279
				4326	4353	4399	4432	4471	4496	4538	4565	4605	4631	4680	4709
				4754	4781	4839	4882	4947	4984	5066	5103	5178	5217	5256	5345
				5369	5410	5449	5521	5571	5610	5698	5732
LPONTST				1274+
MAINT_CLK			 238+#
MEM				 254+#
MEMSIZE				1202+
MEM_DEPOSIT			1174+	1242+
MEM_EXAMINE			1175+	1243+
MEM_PE				 313+#
MEM_REF_ERR			1121+#
MMC_REF_ERR			 320+#
MNT_CLK_ENB			 237+#
MOD_FLD				1240+	2984
MR				1228+	1494
MSCRAT				   3#
MSGADR				 985+	 986+	1009+	1010+
MSGFIL				1295#
MSGWORD				 981+	 982+
MSG_CHK_UUO			1105+#
N				1171+
NEXM				 369+#
NOERR				1211+	1860	1989	2158	2291	2401	2828	2948	3447	3533	4010	4202
				4286
NO_SUBSET			1273+
NUM				1001+	1002+	1021+	1022+	1025+	1026+	1029+	1030+	1033+	1034+	1037+	1038+
				1041+	1042+	1045+	1046+	1049+	1050+	1053+	1054+	1057+	1058+	1061+	1062+
				1065+	1066+
NUMCLKS				3628	3644#	3645
ODD_PAR_TBL			5644	5714	5719
ONES				3246#	3263
OTHER_ADR			3252	3261#	3263	3268	3306
O_CRAM_ADDR			 504+	 505+	1169+	1170+
O_N				 814+	 815+
O_SN				 855+	 856+
PAR_ERR				1122+#	1458
PAR_LEFT			 346+#
PAR_RIGHT			 347+#
PBELL				1069+#
PE				1229+	1442
PE_1				 367+#
PE_DET_ENB			 155+#
PI_REQ_1			 327+#
PI_REQ_2			 326+#
PI_REQ_3			 325+#
PI_REQ_4			 324+#
PI_REQ_5			 323+#
PI_REQ_6			 322+#
PI_REQ_7			 321+#
PM_AC				 967+#	1091+
PNTSIX				 981+#
POCT_SUP			1065+#
POINT				1196+
PRGNAM				1296#
PRINT_CRLF			 977+#
PRINT_DEC			1001+#
PRINT_MSG			 985+#
PRINT_OCT_1			1025+#
PRINT_OCT_11			1057+#
PRINT_OCT_12			1061+#
PRINT_OCT_2			1029+#
PRINT_OCT_3			1033+#
PRINT_OCT_4			1037+#
PRINT_OCT_5			1041+#
PRINT_OCT_6			1045+#
PRINT_OCT_7			1049+#
PRINT_OCT_8			1053+#
PRINT_TXT			 993+#
PRINT_WORD			 989+#
PRT_CRLF_F			1005+#
PRT_DEC_F			1021+#
PRT_MSG_F			1009+#
PRT_TXT_F			1013+#
PTR				1715	1719#	1720	1722	1725	2965	2972	3025#	3026	3087	3094#	3095
				3096	3202#	3203	3204	3251	3254	3264#	3265	3303	3304	3306
PTR_TAB				5481	5490
PTSTNUM				1219+
PTXT_CRLF			 997+#
PTXT_CRLF_F			1017+#
RAC_LO				 338+#
RAM_ERR				 381+#
RBAD_DATA			 334+#
RCOM_ADR			 333+#
RDATA				 331+#
RDATA0				 345+#
RDATA1				 344+#
RDATA10				 300+#
RDATA11				 299+#
RDATA12				 295+#
RDATA13				 294+#
RDATA14				 293+#
RDATA15				 292+#
RDATA16				 291+#
RDATA17				 290+#
RDATA18				 289+#
RDATA19				 288+#
RDATA2				 343+#
RDATA20				 284+#
RDATA21				 283+#
RDATA22				 282+#
RDATA23				 281+#
RDATA24				 280+#
RDATA25				 279+#
RDATA26				 278+#
RDATA27				 277+#
RDATA28				 273+#
RDATA29				 272+#
RDATA3				 342+#
RDATA30				 271+#
RDATA31				 270+#
RDATA32				 269+#
RDATA33				 268+#
RDATA34				 267+#
RDATA35				 266+#
RDATA4				 306+#
RDATA5				 305+#
RDATA6				 304+#
RDATA7				 303+#
RDATA8				 302+#
RDATA9				 301+#
RD_0				1179+#	1642
RD_1				1180+#	1641
RD_100				1183+#	5682	5716
RD_101				1184+#
RD_102				1185+#
RD_103				1186+#
RD_2				1181+#
RD_3				1182+#
RD_300				1187+#	5550	5587
RD_301				1188+#
RD_303				1189+#
READ_DATA			  61	1607*	1747	1807	1898	2029	2198	2331	2427	2502	2585	2642
				2734	2865
READ_SBR			  62	1645*	3370	3375	3428	5498
REC_PE				 316+#
REG_EXAMINE			1179+	1180+	1181+	1182+	1183+	1184+	1185+	1186+	1187+	1188+	1189+	1249+
REM_DIAG_ENB			 376+#
REM_DIAG_PRO			 377+#
REPEAT				1218+
REPLACEI			1198+
RESET_CRAM			  58	1498*
RESET				 156+#	3826	4138	5545	5582
RIO_BUSY			 335+#
RIO_DATA			 332+#
RMEM_BUSY			 336+#
RPT_ERR_FLAG			1276+	1441#
RRESET				 337+#
RUN				 260+#	3779
RUN_1				 355+#	5550	5587
R_CLK_ENB0			 384+#
SCANI				1197+
SC_0				1236+	1443
SEL				 603+	 604+	 614+	 615+	 625+	 626+
SEND_CMD_LINE			1097+#
SEND_EB_LINE			1088+#
SEND_EC_LINE			1089+#
SEND_EI_LINE			1085+#
SEND_EJ_LINE			1086+#
SEND_EK_LINE			1087+#
SEND_EM_LINE			1090+#
SEND_ER_LINE			1084+#
SEND_INFO			1109+#
SEND_LINE			1217+	1495
SEND_NUL			1222+	1456
SEND_PM_LINE			1091+#
SEND_UUO_1			1101+#
SEND_X1A_LINE			1092+#
SEND_X1B_LINE			1093+#
SETNXT				1170+	1223+	2732	2860	2863
SET_C				1170+#	1895	2025	2194	2327	2422	2496	2579	3636	3720	3781	3831
				3874	3918	3968	4035	4064	4113	4176	4228	4259	4309	4336	4381
				4411	4456	4481	4521	4548	4589	4615	4661	4690	4736	4764	4806
				4849	4910	4957	5011	5076	5132	5188	5227	5291	5395	5434	5496
				5547	5584
SINGLE_CLK			 243+#	1897	2027	2196	2329	2424	2498	2581	2861
SOURCE_ADDR			1168+
SPEC_ASK			  55	1375*
SPEC_DIALOGUE			  53	1308*
SPEC_PRT			  54	1341*
SRC				 521+	 522+	 534+	 535+
SS_MODE				 225+#
STEP_U_NEXT			1171+#	2985	3640	3724	3782	3832	3875	3919	3969	4036	4065	4114
				4177	4229	4260	4310	4337	4382	4412	4457	4482	4522	4549	4590
				4616	4662	4691	4737	4765	4807	4850	4911	4958	5012	5077	5133
				5189	5228	5292	5349	5396	5435
STK_RESET			 223+#	3632	3715	3722	5494
SYNC_CLK			1269+
TE				1234+
TEMP				1639	1641#	1642	1714	1720#	1721	1722#	1723	1724	1725#	1726	1727
TEN_INT				 370+#
TERM_CARR			 375+#
TEST_EDIT			1292#
TEST_INIT			  56	1408*
TEST_PAT			2969#	2979
TEST_VERSION			1291#
TEXT				 993+	 994+	 997+	 998+	1013+	1014+	1017+	1018+
TICK				1270+
TIMOUT				1275+
TP				1233+	3778	3873	3917	3967	4034	4063
TRAP_ENB			 235+#
TST1				  64	1731*
TST10				  73	2703*
TST11				  74	2832*
TST12				  75	2954*
TST13				  76	3077*
TST14				  77	3238*
TST15				  78	3348*
TST16				  79	3399*
TST17				  80	3478*
TST18				  81	3585*
TST19				  82	3691*
TST2				  65	1780*
TST20				  83	3753*
TST21				  84	4015*
TST22				  85	4093*
TST23				  86	4208*
TST24				  87	4292*
TST25				  88	4361*
TST26				  89	4440*
TST27				  90	4504*
TST28				  91	4573*
TST29				  92	4639*
TST3				  66	1866*
TST30				  93	4717*
TST31				  94	4789*
TST32				  95	4890*
TST33				  96	4992*
TST34				  97	5111*
TST35				  98	5264*
TST36				  99	5379*
TST37				 100	5418*
TST38				 101	5457*
TST39				 102	5530*
TST4				  67	1996*
TST40				 103	5619*
TST5				  68	2165*
TST6				  69	2298*
TST7				  70	2408*
TST8				  71	2482*
TST9				  72	2564*
TST_ADR				2722	2729#	2732	2735	2738	2740	2850	2857#	2860	2866	2870	2871
TTI_CLR				1075+#
TTI_DEC				1076+#
TTI_YES				1074+#
TT_ALTM				1073+#
U				 862+#	1439	2970	3365	3413	3494	3495	3595	3596	3597	3598	3599
				3600	3601	3602	3603	3604	3605	3606	3607	3608	3609	3610	3611
				3612	3613	3614	3615	3616	3617	3618	3619	3620	3621	3622	3623
				3624	3625	3705	3706	3707	3708	3709	3710	3711	3762	3763	3764
				3765	3766	3767	4023	4024	4025	4026	4101	4216	4300	4369	4370
				4371	4447	4448	4511	4512	4513	4580	4581	4646	4647	4648	4649
				4650	4651	4652	4653	4724	4725	4726	4727	4728	4796	4797	4898
				4899	4900	4901	4999	5000	5001	5002	5118	5119	5120	5121	5122
				5123	5273	5274	5275	5276	5277	5278	5279	5280	5281	5387	5426
				5475	5476	5477	5478	5481	5482	5483	5538	5539
UC_PTR				1439#	1444	2970#	2975	3365#	3373	3413#	3426	3595#	3631	3705#	3717
				3762#	3773	4023#	4030	4101#	4106	4216#	4222	4300#	4304	4369#	4375
				4447#	4452	4511#	4517	4580#	4585	4646#	4657	4724#	4732	4796#	4802
				4898#	4906	4999#	5007	5118#	5128	5273#	5286	5387#	5391	5426#	5430
				5475#	5487	5538#	5541
UC_PTR1				3090#	3197	3494#	3509	3763#	3869	4370#	4405	4448#	4477	4513#	4544
				4581#	4611	4651#	4686	4727#	4760	4797#	4845	4900#	4953	5001#	5072
				5120#	5184	5280#	5287	5539#	5578
UC_PTR2				3091#	3232	3495#	3508	3766#	3913	5122#	5223	5281#	5374
UC_PTR3				3767#	3963
UUO				 957+	 979+	 983+	 987+	 991+	 995+	 999+	1003+	1007+	1011+	1015+	1019+
				1023+	1027+	1031+	1035+	1039+	1043+	1047+	1051+	1055+	1059+	1063+	1067+
				1069+	1073+	1074+	1075+	1076+	1080+	1084+	1085+	1086+	1087+	1088+	1089+
				1090+	1091+	1092+	1093+	1097+	1101+	1105+	1109+	1114+	1115+
U_0				 505+	 509+	 522+	 535+	 549+	 562+	 583+	 867+	 882+	 884+	 910+#
U_0_DEFAULT			 884+	 897+#	 910+
U_1				 604+	 615+	 626+	 646+	 650+	 655+	 659+	 663+	 668+	 672+	 701+	 711+
				 724+	 744+	 773+	 873+	 879+	 882+	 885+	 911+#
U_1_DEFAULT			 885+	 898+#	 911+
U_2				 779+	 783+	 787+	 791+	 795+	 799+	 803+	 807+	 811+	 815+	 821+	 834+
				 847+	 856+	 882+	 886+	 912+#
U_2_DEFAULT			 886+	 899+#	 912+
U_3				 642+	 873+	 879+	 887+	 913+#
U_3_DEFAULT			 887+	 900+#	 913+
U_A				 561+#	 564+	 565+	 566+	 567+	 568+	 569+	 570+	 571+	 572+	 573+	 574+
				 575+	 576+	 577+	 578+	 579+
U_ALU_ADD			 511+#
U_ALU_AND			 515+#
U_ALU_MASK			 516+#
U_ALU_OR			 514+#	3763	4023	4646	4796	5274	5275	5426
U_ALU_PARITY_OK			 641+#
U_ALU_RSUB			 513+#
U_ALU_SUB			 512+#
U_ALU_XNOR			 518+#	4448	5276	5278
U_ALU_XOR			 517+#
U_ALU				 508+#	 511+	 512+	 513+	 514+	 515+	 516+	 517+	 518+
U_A_AR				 567+#
U_A_ARX				 568+#
U_A_BR				 569+#
U_A_BRX				 570+#
U_A_EBR				 572+#
U_A_FLG				 575+#
U_A_HR				 566+#
U_A_MAG				 564+#
U_A_MASK			 574+#
U_A_ONE				 571+#
U_A_PC				 565+#
U_A_PI				 576+#
U_A_T0				 578+#
U_A_T1				 579+#
U_A_UBR				 573+#
U_A_XWD1			 577+#
U_B				 582+#	 585+	 586+	 587+	 588+	 589+	 590+	 591+	 592+	 593+	 594+	 595+
				 596+	 597+	 598+	 599+	 600+
U_BYTE				 700+#	 703+	 704+	 705+	 706+	 707+
U_BYTE_1			 703+#
U_BYTE_2			 704+#
U_BYTE_3			 705+#
U_BYTE_4			 706+#
U_BYTE_5			 707+#
U_B_AR				 588+#
U_B_ARX				 589+#
U_B_BR				 590+#
U_B_BRX				 591+#
U_B_EBR				 593+#
U_B_FLG				 596+#
U_B_HR				 587+#
U_B_MAG				 585+#
U_B_MASK			 595+#
U_B_ONE				 592+#
U_B_PC				 586+#
U_B_PI				 597+#
U_B_T0				 599+#
U_B_T1				 600+#
U_B_UBR				 594+#
U_B_XWD1			 598+#
U_CALL				 810+#	3413	3494	3595	3597	3599	3601	3603	3605	3607	3609	3611
				3613	3615	3617	3619	3621	3623	3707	3709	5475	5476
U_CHKL				 654+#
U_CHKR				 667+#
U_CRY38				 778+#
U_DBM_APR_FLAGS			 630+#
U_DBM_BYTES			 631+#
U_DBM_DP			 634+#
U_DBM_DP_SWAP			 635+#
U_DBM_EXP			 632+#
U_DBM_MEM			 637+#
U_DBM_MSEC			 633+#
U_DBM_N				 638+#
U_DBM_PF_DISP			 629+#
U_DBM_SCAD			 628+#
U_DBM_VMA			 636+#
U_DBM				 625+#	 628+	 629+	 630+	 631+	 632+	 633+	 634+	 635+	 636+	 637+	 638+
U_DBUS				 614+#	 617+	 618+	 619+	 620+	 621+	 622+
U_DBUS_DBM			 622+#	3763	4023	4646	4796	4898	4900	4999	5001	5118	5120	5122
				5274	5275	5426
U_DBUS_DP			 620+#
U_DBUS_PC_FLAGS			 617+#
U_DBUS_PI_NEW			 618+#
U_DBUS_RAM			 621+#
U_DBUS_VMA			 619+#
U_DEST				 548+#	 551+	 552+	 553+	 554+	 555+	 556+	 557+	 558+
U_DEST_A			 551+#
U_DEST_AD			 552+#
U_DEST_AD_DIV2			 558+#
U_DEST_AD_MUL2			 556+#
U_DEST_PASS			 554+#	4448
U_DEST_Q_AD			 553+#	4646	4651
U_DEST_Q_DIV2			 557+#	4647	4648	4649	4652
U_DEST_Q_MUL2			 555+#
U_DISP				 723+#	 726+	 727+	 728+	 729+	 730+	 731+	 732+	 733+	 734+	 735+	 736+
				 737+	 738+	 739+	 740+	5481	5482	5483
U_DISP_ADISP			 732+#
U_DISP_AREAD			 728+#	5119	5121	5123
U_DISP_BDISP			 733+#
U_DISP_BYTE			 738+#	4796	4797
U_DISP_CONSOLE			 726+#
U_DISP_DP			 731+#
U_DISP_DP_LEFT			 729+#
U_DISP_DROM			 727+#	5000	5002
U_DISP_EAMODE			 739+#	4899	4901
U_DISP_MUL			 735+#	4650	4653
U_DISP_NICOND			 737+#	3762	3765	4726	4728
U_DISP_NORM			 730+#
U_DISP_PAGEFAIL			 736+#
U_DISP_RETURN			 734+#	3495	3596	3598	3600	3602	3604	3606	3608	3610	3612	3614
				3616	3618	3620	3622	3624	3625	3711	5280
U_DISP_SCAD0			 740+#	4580	4581
U_DIVIDE			 798+#
U_FMWRITE			 790+#
U_GENL				 649+#
U_GENR				 662+#
U_J				 504+#	1439	2970	3365	3494	3595	3596	3597	3598	3599	3600	3601
				3602	3603	3604	3605	3606	3607	3608	3609	3610	3611	3612	3613
				3614	3615	3616	3617	3618	3619	3620	3621	3622	3623	3624	3625
				3705	3707	3709	3762	3763	3764	3765	3766	3767	4023	4024	4025
				4026	4101	4216	4300	4369	4370	4371	4447	4448	4511	4512	4513
				4580	4581	4646	4647	4648	4649	4650	4651	4652	4653	4724	4725
				4726	4727	4728	4796	4797	4898	4899	4900	4901	4999	5000	5001
				5002	5118	5119	5120	5121	5122	5123	5273	5274	5275	5276	5277
				5278	5279	5280	5281	5387	5426	5475	5476	5478	5481	5482	5483
				5538	5539
U_LOADFE			 786+#
U_LOADSC			 782+#	4511	4513
U_LSRC				 521+#	 524+	 525+	 526+	 527+	 528+	 529+	 530+	 531+
U_LSRC_0A			 528+#
U_LSRC_0B			 527+#
U_LSRC_0Q			 526+#
U_LSRC_AB			 525+#	4448	5276	5278
U_LSRC_AQ			 524+#
U_LSRC_D0			 531+#	4646	4796	5426
U_LSRC_DA			 529+#
U_LSRC_DQ			 530+#
U_MEM				 794+#	4725	5276	5278	5279
U_MULTI_PREC			 802+#
U_MULTI_SHIFT			 806+#
U_N				 814+#	3763	3764	3766	3767	4023	4024	4646	4725	4796	4898	4900
				4999	5001	5118	5120	5122	5274	5275	5276	5278	5279	5426	5538
				5539
U_NO_CLKL			 645+#
U_NO_CLKR			 658+#
U_RAM_AC			 606+#
U_RAM_AC_FN			 607+#
U_RAM_N				 611+#
U_RAM_RAM			 610+#
U_RAM_VMA			 609+#
U_RAM_XR			 608+#
U_RAM				 603+#	 606+	 607+	 608+	 609+	 610+	 611+
U_RSRC				 534+#	 538+	 539+	 540+	 541+	 542+	 543+	 544+	 545+
U_RSRC_0A			 542+#
U_RSRC_0B			 541+#
U_RSRC_0Q			 540+#
U_RSRC_AB			 539+#	4448	5276	5278
U_RSRC_AQ			 538+#
U_RSRC_D0			 545+#	3763	4023	5274	5275
U_RSRC_DA			 543+#
U_RSRC_DQ			 544+#
U_SCAD				 820+#	 823+	 824+	 825+	 826+	 827+	 828+	 829+	 830+
U_SCADA				 833+#	 836+	 837+	 838+	 839+	 840+	 841+	 842+	 843+
U_SCADA_BYTE1			 839+#
U_SCADA_BYTE2			 840+#
U_SCADA_BYTE3			 841+#
U_SCADA_BYTE4			 842+#
U_SCADA_BYTE5			 843+#
U_SCADA_PTR44			 838+#
U_SCADA_SC			 836+#
U_SCADA_SN			 837+#	4511	4513	4580	4581
U_SCADB				 846+#	 849+	 850+	 851+	 852+
U_SCADB_EXP			 850+#
U_SCADB_FE			 849+#
U_SCADB_SHIFT			 851+#
U_SCADB_SIZE			 852+#
U_SCAD_A			 830+#	4511	4513	4580	4581
U_SCAD_ADD			 827+#
U_SCAD_AND			 828+#
U_SCAD_A_DEC			 829+#
U_SCAD_A_MUL2			 823+#
U_SCAD_OR			 824+#
U_SCAD_SUBB			 825+#
U_SCAD_SUB			 826+#
U_SET_GENL			 651+	 871+	 904+#
U_SET_GENR			 664+	 877+	 905+#
U_SET_RSRC			 536+	 865+	 903+#
U_SET				 536+	 651+	 664+	 865+	 871+	 877+	 888+	 914+#
U_SHSTYLE			 710+#	 713+	 714+	 715+	 716+	 717+	 718+	 719+	 720+
U_SHSTYLE_ASHC			 717+#
U_SHSTYLE_DIV			 719+#
U_SHSTYLE_LSHC			 718+#
U_SHSTYLE_NORM			 713+#
U_SHSTYLE_ONES			 715+#
U_SHSTYLE_ROT			 716+#
U_SHSTYLE_ROTC			 720+#
U_SHSTYLE_ZERO			 714+#
U_SKIP				 743+#	 746+	 747+	 748+	 749+	 750+	 751+	 752+	 753+	 754+	 755+	 756+
				 757+	 758+	 759+	 760+	 761+	 762+	 763+	 764+	 765+	 766+	 767+	 768+
				 769+
U_SKIP_1_MS			 769+#	4300
U_SKIP_AC0			 753+#
U_SKIP_ADEQ0			 764+#	4447	4448
U_SKIP_ADLEQ0			 749+#	5387
U_SKIP_ADREQ0			 750+#
U_SKIP_CONTINUE			 768+#	4216
U_SKIP_CRY0			 748+#
U_SKIP_CRY1			 761+#
U_SKIP_CRY2			 756+#
U_SKIP_DP0			 757+#	5426
U_SKIP_DP18			 758+#
U_SKIP_EXECUTE			 766+#	4101
U_SKIP_FPD			 752+#
U_SKIP_INT			 754+#
U_SKIP_IOLGL			 746+#
U_SKIP_IOT			 759+#
U_SKIP_IO_BUSY			 767+#	4369	4371
U_SKIP_JFCL			 760+#
U_SKIP_KERNEL			 751+#
U_SKIP_LE			 755+#
U_SKIP_LLE			 747+#
U_SKIP_SC			 765+#	4512
U_SKIP_TRAP_CYC			 763+#	4026
U_SKIP_TXXX			 762+#
U_SN				 855+#	4511	4513	4580	4581
U_SPEC				 671+#	 674+	 675+	 676+	 677+	 678+	 679+	 680+	 681+	 682+	 683+	 684+
				 685+	 686+	 687+	 688+	 689+	 690+	 691+	 692+	 693+	 694+	 695+	 696+
				 697+
U_SPEC_APRFLAGS			 684+#
U_SPEC_APR_EN			 686+#	3763	4023	5274	5275
U_SPEC_ASHOV			 693+#
U_SPEC_CLRCLK			 675+#
U_SPEC_CLRCSH			 685+#
U_SPEC_CLRIOBSY			 677+#
U_SPEC_CLRIOLAT			 676+#	4370
U_SPEC_EXPTST			 694+#
U_SPEC_FLAGS			 695+#	3764	3766	3767	4024
U_SPEC_INHCRY18			 690+#
U_SPEC_LDACBLK			 696+#
U_SPEC_LDINST			 697+#	4898	4900	4999	5001	5118	5120	5122
U_SPEC_LDPAGE			 678+#	5276
U_SPEC_LDPI			 692+#
U_SPEC_LDPXCT			 680+#
U_SPEC_LOADIR			 691+#
U_SPEC_LOADXR			 683+#
U_SPEC_MEMCLR			 687+#	1439	4724	4727	5273	5280	5281
U_SPEC_N			 674+#	5538
U_SPEC_NICOND			 679+#	4025
U_SPEC_PREV			 682+#
U_SPEC_PXCT_OFF			 689+#
U_SPEC_SWEEP			 688+#
U_SPEC_WAIT			 681+#
U_T				 772+#
WAIT				1216+
WRITE_CRAM			  59	1533*	1896	2026	2195	2328	2423	2497	2580
WRT100				1250+	3826	3827	4138	4139	4308	4335	5545	5546	5582	5583
WRT102				1251+
WRT103				1252+	1602
WRT104				1253+
WRT105				1254+	1603
WRT106				1255+
WRT107				1256+
WRT110				1257+
WRT111				1258+
WRT112				1259+
WRT113				1260+
WRT114				1261+	1454
WRT115				1262+	1455	4379	4409
WRT116				1263+
WRT204				1264+	1448	1449	1529	1530	1568	1569	2425	2426	2499	2500	2582
				2583	3512	3513	3632	3633	3715	3716	3722	3723	5494	5495
WRT205				1265+	1567	1746	1806	2028	2197	2330	2501	2584	2641	2733	2862
WRT206				1266+	1897	2027	2196	2329	2424	2498	2581	2861
WRT210				1267+	1604	1640	4380	4410
WRT212				1268+	3779	3825	4111	4174	4226	4257	5548	5585
WR_CRAM				1225+	3094	3202
X				 671+	 672+	 700+	 701+	 710+	 711+	 723+	 724+	 743+	 744+	 772+	 773+
				 820+	 821+	 833+	 834+	 846+	 847+
X1				1226+
X1A_AC				 968+#	1092+
X1B_AC				 969+#	1093+
XMIT_ADR			 252+#	1604	4380	4410
XMIT_DATA			 251+#
ZEROS				3247#	3262	3306


TIME: 14 SEC.
CORE: 15K
