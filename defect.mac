TITLE	DEFECT

SUBTTL FILE HAS SUPPORT ROUTINES FOR FORMATTING AND DEFECT HANDLING

	RELOC
	SEARCH	DEFINS,MONSYM

	ENTRY	CNTDEF,DEFECT,GENHDR,LDENT,LDENTH,TDINP

	EXTERN	ABBPT,CWFMT,CWHDC,FFF,FLIST,MXSEC,NUMIN,PNTBCD
	EXTERN	POCDEF,PSDN,QSTN

	XLIST
	BOX	<GENHDR -- ROUTINE BUILDS A BUFFER OF HEADERS>,<
	THIS ROUTINE BUILDS A FULL TRACK OF HEADERS IN CORE.
	THE FORMAT IS 18 BIT MODE AND NO DEFECTS ARE ASSUMED.
	DEFECT INFORMATION IS LATER ADDED BY "DEFECTS".
	CALL SEQ:
	MOVE	1,ARG1		;BUFFER ADDRESS
	MOVE	2,ARG2		;CYLINDER,,SURFACE
	GO	GENHDR		;GENERATE THE HEADERS
	RTN+1			;ALWAYS RETURNS HERE >

GENHDR:	PUT	X		;SAVE AC'S
	PUT	0		
	PUT	2
	PUT	1
	SETZM	X		;SETUP FOR 600 MB

;MOVE 1ST DEFAULT HEADER FROM TABLE INTO BUFFER USING BLT.

	HRRZ	1,(P)		;GET BUFFER START ADDR
	ADD	1,CWHDC(X1)	;ADD NUMBER OF WORDS IN HEADER
	SUBI	1,1		;NOW HAVE BLT END ADDR (E)
	HRLZ	0,HDRTBL(X)	;AC0 = SOURCE,,0 FOR BLT
	HRR	0,(P)		;GET BUFFER ADR  AC0 = SOURCE,,DEST
	BLT	0,(1)		;START THE BLT

;NOW REPEAT FIRST HEADER AS REQUIRED TO FILL UP THE BUFFER

	HRRZ	1,(P)		;START OF BUFFER
	ADD	1,CWFMT(X1)	;ADD IN THE LENGTH
	SUBI	1,1		;AC1 NOW HAS BLT END ADDR.
	HRLZ	0,(P)		;AC0 = SOURCE,,0
	HRR	0,(P)		;AC0 = SOURCE,,SOURCE
	ADD	0,CWHDC(X1)	;AC0 = SOURCE,,DEST
	BLT	0,(1)		;FILL THE BUFFER

;RUN THRU THE BUFFER PLUGGING IN THE HEADER WORDS

	HRRZ	0,-1(P)		;GETS SURFACE NUMBER
	LSH	0,^D8		;SHIFT INTO POSITION
	HLL	0,-1(P)		;NOW HAVE CYLINDER,,SURF, SECT=0
	MOVE	1,(P)		;POINTER TO BUFFER START
HDL:	TLO	0,140000	;SET BOTH GOOD SECTOR FLAGS
	MOVEM	0,(1)		;UPDATE BUFFER WORD
	AOS	0		;INCREMENT SECTOR NUMBER
	ADD	1,CWHDC(X1)	;INCREMENT POINTER CORRECTLY
	LDB	2,[POINT 8,0,35] ;GET SECTOR FIELD
	CAMG	2,MXSEC(X1)	;SEE IF FINISHED
	JRST	HDL		;NOT DONE. LOOP.
	GET	1
	GET	2
	GET	0
	GET	X
	RTN			;EXIT

;TABLE OF POINTERS TO EACH DEFAULT HEADER BLOCK (EXPANDABLE)

HDRTBL:	HT1			;FOR 600-MB RP07

;DEFAULT RP07 HEADER BLOCK (18 BIT MODE, NO DEFECTS)

HT1:	140000,,000000		;GOOD SECTOR FLAGS ARE BOTH=1
	140000,,140000		;WORDS 3 & 4 ARE 140000
	140000,,140000		;WORDS 5 & 6 ARE 140000

	XLIST
	BOX	<DEFECT -- ROUTINE TO PUT DEFECT DATA INTO HEADERS >,<
	THIS ROUTINE HAS
	1.  IT CHECKS TO SEE IF PRINTING OF DISPLACEMENTS IS DESIRED
	2.  IT TRANSLATES DEFECT INFORMATIN FROM THE TRACK DESCRIPTOR
	    RECORD TO THE HEADERS OF THE APPROPRIATE SECTORS.

	CALL SEQ:
	MOVE	1,ARG1		;POINTER TO START OF TD BUFFER
	MOVE	2,ARG2		;POINTER TO START OF TRACK HEADER BUFFER
	GO	DEFECT		;CALL THE ROUTINE
	RTN			;RETURNS +1 ALWAYS >

DEFECT:	PUT	0		;SAVE AC'S
	PUT	1
	PUT	2
	PUT	3
	PUT	X

	SETZM	X		;SETUP FOR 600 MB
	MOVEM	1,TDPTR		;SAVE TRACK DESCRIPTOR BUFFER ADDRESS
	MOVEM	2,HDPTR		;SAVE TRACK BUFFER ADDRESS

;MOVE DEFECT INFORMATION INTO THE DEFECT DISTANCE TABLE
;AT THE SAME TIME, THROW AWAY THE 14000 CODE, AND CONVERT ALL THE
;DISTANCES TO BITS, REALITVE FROM INDEX TO THE START OF THE DEFECT.

	MOVN	3,MXDEF(X)	;-# DEFECTS
	HRLZ	3,3		;-CNT,,0
	MOVE	2,[POINT 18,(1),35] ;POINTS IN FRONT OF FIRST DEFECT
	MOVE	1,TDPTR		;POINTER TO TRACK DESCRIPTOR
	SETZM	TMP#		;TEMPORARY CELL FOR THE RUNNING SUM
DLP:	ILDB	0,2		;GET DEFECT FROM T.D.
	CAIN	0,140000	;DO WE HAVE NULL PATTERN ?
	SETZM	0		;YES. THIS IS A ZERO DISPLACEMENT
	JUMPE	0,DLD		;JUMP IF NO DEFECTCT ON THIS ENTRY
	IMULI	0,^D16		;CONVERTS 16 BIT WORDS TO BITS
	ADDM	0,TMP		;SAVE THE RUNNING SUM
	MOVE	0,TMP		;GET THE RUNNING SUM OF DISTANCES
	SUB	0,SK2(X)	;NORMALIZE TO START RATHER THAN CTR..
DLD:	MOVEM	0,DIST(3)	;PUT IN DISTANCE TABLE
	AOBJN	3,DLP		;LOOP TILL ALL DEFECT DATA XFERRED

;LIST DEFECT DISPLACEMENT ENTRY IF NECESSARY AND INIT POINTERS

	SKIPN	FLIST		;WISH TO LIST DEFECTS
	JRST	.+3		;NO
	MOVE	1,TDPTR		;YES.. GET A POINTER
	GO	LDENT		;LIST ENTRY IF NOT NULL
	GO	PINT		;INIT ALL THE POINTERS

;NOW PROCESS ALL THE ENTRIES IN THE DISTANCE TABLE
;ENTRIES TO THE LEFT OF P2 ARE NOT PROCESSED. THEY ARE THERE BECAUSE
;OF H0 MOVED OR TD MOVED AND ARE ALREADY HANDLED BY THE SCANNER ...

	MOVSI	1,-4		;MAKE AOBJN POINTER
DLD1:	MOVE	0,DIST(1)	;GET NEXT DEFECT DISTANCE
	JUMPE	0,DLDX		;IF=0, THEN WE'RE DONE
	CAML	0,P2		;DON'T PROCESS IF TO LEFT OF P2
	GO	PROD		;NON-0, PROCESS THE DEFECT
	AOBJN	1,DLD1		;BUMP POINTER AND LOOP
DLDX:	GET	X		;DONE. RESTORE AC'S
	GET	3
	GET	2
	GET	1
	GET	0
	RTN			;AND EXIT.
	PAGE


	PAGE
;THIS ROUTINE IS CALLED TO PROCESS DEFECT WHOSE DISTANCE IS IN AC0.
;AC0 IS THE DISTANCE IN BITS FROM INDEX TO THE START OF THE DEFECT
;"HWBPTR" POINTS TO THE CURRENT PLACE IN THE HEADER WHERE THE
;SKIP DATA MUST BE PLACED. THIS ROUTINE MUST INCREMENT THIS BYTE
;POINTER AND SAVE IT WHEN FINISHED. (HWBPTR: POINT 18,1(1),17)
;"HDPTR" IS POINTING TO START OF CURRENT HEADER IN CORE AND GETS UPDATED
;BY POINTER INIT "PINT" OR POINTER ADVANCE "PADV" ROUTINES

PROD:	PUT	5		;SAVE AC'S
	PUT	4
	PUT	3
	PUT	2
	PUT	1
	PUT	0

;SEE IF DEFECT STARTS IN THIS SECTOR, IF NOT, ADVANCE POINTERS TO NEXT SECTOR

PRODL:	MOVE	1,0		;GET SKIP DISTANCE TO AC1
	CAMGE	1,P3		;DEFECT START IN CURRENT SECTOR?
	JRST	CHKHDR		;YES. GO FIND OUT WHERE
	GO	PADV		;NO. ADVANCE POINTERS
	JRST	PRODL		;AND TEST NEXT SECTOR
	PAGE
; ************ PROCESS DEFECTS IN HEADER FIELD ************

;SEE IF DEFECT STARTS IN THE HEADER (STACKED DEFECT CAN'T OCCUR HERE)
;AC1 NOW CONTAINS DEFECT START IN BITS

CHKHDR:	CAML	1,PA		;DOES DEFECT START IN HEADER
	JRST	CHKG3		;NO.
	MOVE	1,HCRCB(X)	;THIS IS THE SKIP DISP (IN BITS)
	GO	RND16		;CONVERT AC1 TO 16 BIT WORDS
	GO	STOREH		;STORE IN HEADER WORD
	MOVE	1,HCRCB(X)	;SIZE OF DISPLACEMENT IN BYTES
	ADDM	1,REFPTR	;REFERENCE POINTER NOW UPDATED
	MOVE	1,SKB(X)	;DO A POINTER UPDATE
	ADDM	1,PB		;UPDATE POINTERS BY THE SIZE OF A SKIP
	ADDM	1,PC
	ADDM	1,PD
	ADDM	1,P3
	JRST	PRODX		;RESTORE AC'S AND EXIT

	PAGE
; ************ PROCESS DEFECTS IN G3 ************

;SEE IF DEFECT STARTS IN G3, IF SO, INSERT THE SKIP IN G3.
;CHECK FOR POSSIBILITY OF A STACKED DEFECT AND HANDLE THE SITUATION.
;AC1 IS NOW HOLDING THE DEFECT START (IN BITS).

CHKG3:	CAML	1,PB		;DEFECT START IN G3?
	JRST	CHKDAT		;NO. GO TRY DATA FIELD.
	SUB	1,REFPTR	;GET DISTANCE FROM REFPTR TO START OF DEFECT

;SEE IF WE HAVE POSSIBILITY OF STACKED DEFECT.
;IF P2A AND REFPTR ARE NOT THE SAME, WE MAY HAVE TO STACK.

	MOVE	2,REFPTR	;GET CURRENT POINTER
	CAMN	2,P2A		;FIRST DEFECT IN THIS SECTOR ?
	JRST	SKG31		;YES. NO NEED TO STACK

;NOT THE FIRST DEFECT IN THIS SECTOR, STACK DEFECTS IF THEY OVERLAP.
;AC1 HAS # BITS FROM REFPTR TO START OF DEFECT


	CAMGE	1,SKB(X)	;DO DEFECTS OVERLAP?
	MOVE	1,SKB(X)	;YES. MUST STACK THEM

;STORE IN THE PROPER HEADER WORD
;UPDATE POINTERS CORRECTLY.
;AC1 NOW HAS THE SKIP DISPLACEMENT IN BITS

SKG31:	GO	RND16		;CONVERT AC1 TO 16 BIT WORDS
	GO	STOREH		;PUT IN HEADER
	IMULI	1,^D16		;CONVERT BACK TO BITS
	ADDM	1,REFPTR	;UPDATE ALL THE POINTERS
	MOVE	1,SKB(X)	;SIZE OF SKIP IN BYTES
	ADDM	1,PB
	ADDM	1,PC
	ADDM	1,PD
	ADDM	1,P3
	JRST	PRODX		;RESTORE AC'S AND EXIT.
	PAGE

; ************ PROCESS DEFECTS IN MOST OF THE DATA FIELD ************

;SEE IF DEFECT START IS IN THE DATA FIELD, IF SO, PROCESS IT.
;NOTE: THE DEFECTS HANDLED HERE, OCCUR "BEFORE" POINTER "PC"
;AC1 CONTAINS START OF THE DEFECT (IN BITS).

CHKDAT:	CAML	1,PC		;IS DEFECT IN DATA FIELD?
	JRST	CHKGGL		;NO. GO SEE IF IN LAST GUARANTEED GOOD

;AC1/ POINTS TO START OF DEFECT IN BITS
;AC3/ USED TO SUM BITS LATER CONVERTED TO 16 BIT WORDS
;AC4/ USED TO SUM BITS LATER CONVERTED TO 18 BIT WORDS

CDA:	SETZM	3		;CLEAR THE 2 RUNNING SUMMERS
	SETZM	4
	SKIPN	LDDA		;WAS THE LAST DEFECT IN THE DATA AREA ?
	JRST	CDC		;NO
	JFCL			;YES

;LAST DEFECT WAS IN THE DATA AREA. CALCULATE 18 BIT DISTANCES FROM
;"REFPTR" TO THE START OF THE DEFECT AND THEN SEE IF THE SKIP MUST
;BE STACKED OR HAVE TO BE SHIFTED TO THE RIGHT IN ORDER TO MAINTAIN
;THE MINIMUM DATA SEGMENT SIZE.

CDB:	SUB	1,REFPTR	;GETS DISTANCE IN BITS
	MOVEM	1,4		;SAVE THE RUNNING SUM
	CAML	1,SKB(X)	;DOES THIS OVERLAP PREVIOUS SKIP ?
	JRST	CDE		;NO.
	MOVE	4,SKB(X)	;YES. THEN FORCE A STACKED SKIP
	JRST	CDD

CDE:	MOVE	2,SKB(X)	;GET SKIP SIZE
	ADD	2,SEG18		;ADD IN THE MIN SEGMENT SIZE
	CAMGE	1,2		;DIST >= MIN SEG + SKIP SIZE ?
	MOVE	4,2		;NO. FORCE THE SIZE
	JRST	CDD

;LAST DEFECT NOT IN THE DATA FIELD. IN FACT, THIS MAY BE THE FIRST
;DEFECT. SUM UP 16 BIT THINGS BETWEEN "REFPTR" AND "PB" AND THEN
;THE 18 BIT DISTANCE BETWEEN "PB" AND THE START OF THE DEFECT.
;INSURE THEA THE MINIMUM DATA SEGMENT IS MAINTAINED.

CDC:	MOVE	2,PB		;GET THE POINTER
	SUB	2,REFPTR	;GETS 16 BIT DISANCES
	ADDM	2,3		;SUM IT UP
	SUB	1,PB		;GETS 18 BIT DISTANCE
	MOVEM	1,4		;SAVE RUNNING SUM
	CAMGE	1,SEG18(X)	;IS DIST >= MIN DATA SEGMENT
	MOVE	4,SEG18(X)	;NO. FORCE IT TO MIN SEG SIZE
	JRST	CDD

;CONVERT THE BITS TO WORDS, SUM THEM UP AND STORE THEM IN  THE
;HEADER. CONVERT THE ROUNDED WORDS BACK TO BITS SO THE POINTERS
;CAN BE UPDATED PROPERLY.

CDD:	MOVE	1,3		;GET 16 BIT SUM
	GO	RND16		;CONVERT AC1 TO WORDS
	MOVEM	1,3		;SAVE IN AC3
	MOVE	1,4		;GET 18 BIT SUM
	GO	RND18		;CONVERT AC4 TO WORDS
	MOVEM	1,4		;SAVE IN AC4
	ADD	1,3		;SUMS 16 AND 18 BIT WORDS
	GO	STOREH		;PUT DISTANCE IN THE HEADER

	IMULI	3,^D16		;BACK TO BITS
	IMULI	4,^D18		;BACK TO BITS
	ADDM	3,REFPTR	;UPDATE REFPTR
	ADDM	4,REFPTR
	SETOM	LDDA		;FLAG SAYS THIS DEFECT IN DATA AREA

;WE'VE ADDED A DEFECT SKIP SO POINTERS PC, PD, P3 MUST BE UPDATED BY
;THE SIZE OF THE SKIP.

	MOVE	1,SKB(X)	;GET SIZE OF SKIP IN BYTES
	ADDM	1,PC
	ADDM	1,PD		;UPDATE POINTERS
	ADDM	1,P3
	JRST	PRODX		;NOW WE EXIT
	PAGE
; ************ PROCES DEFECT AT END OF DATA FIELD OR G4 ************

;DEFECT STARTS BEYOND POINTER "PC"
;DEFECT IS IN EITHER THE FINAL PORTION OF THE DATA FIELD OR
;IN THE G4/G5 AREA. IN EITHER CASE, THE SKIP MUST BE INSERTED IN G4/G5.
;AC1 NOW CONTAINS THE DISTANCE TO THE START OF THE SKIP (IN BITS).
;AC3/ USED TO ACCUMULATE 16 BIT WORD COUNT
;AC4/ USED TO ACCUMULATE 18 BIT WORD COUNT

CHKGGL:	SETZM	3		;CLEAR THE RUNNING SUMS
	SETZM	4
	CAMGE	1,PD		;DEFECT TO RIGHT OF PD? (G4/G5)
	MOVE	1,PD		;NO. INSERT THE SKIP AT "PD"
	SKIPN	LDDA		;YES. LAST DEFECT IN DATA FIELD?
	JRST	CGD		;NO. (EITHER LEFT OR RIGHT)

;LAST DEFECT WAS IN DATA AREA.
;NO NEED TO STACK IN THIS CASE
;GET TOTAL DISTANCE FROM REFPTR TO PD

CGA:	PUT	1		;SAVE AC1
	MOVE	1,PC		;GET POINTER (BITS)
	SUB	1,REFPTR	; (BITS)
	GO	RND18		;CONVERT TO 18 BIT WORDS
	ADD	4,1		;ACCUMULATE THE 18 BIT WORDS TO PC
	GET	1		;RESTORE THE AC
	ADD	4,CRIT18(X)	;+ CRITICAL AREA 18 BIT WORDS
	ADD	3,CRIT16(X)	;ADD IN THE 16 BIT CRITICAL WORDS
	JRST	CGB

;LAST DEFECT OUT OF DATA AREA FIND OUT WHETHER IT'S TO THE LEFT OR
;RIGHT OF THE DATA AREA.

CGD:	MOVE	2,REFPTR	;GET POINTER IN BYTES
	CAML	2,PB		;LESS MEANS TO THE LEFT
	JRST	CGE		;ITS TO THE RIGHT

;REFPTR IS TO THE LEFT OF THE DATA FIELD (IN BYTES).
;RUN UP TO G4 AND SUM THE DISTANCE
;AC1/ DIST TO DEFECT START (BITS)
;AC3/ USED TO SUM 16 BIT WORD DISTANCES
;AC4/ USED TO SUM 18 BIT WORD DISTANCES

CGF:	PUT	1		;SAVE AC1
	MOVE	1,PB		;POINTER (BITS)
	SUB	1,REFPTR	;DISTANCE IN BYTES
	GO	RND16		;CONVERT AC1 TO 16 BIT WORDS
	ADD	3,1		;UPDATE THE RUNNING SUM
	GET	1		;RESTORE AC1
	ADD	4,DFW(X)	;# OF 18 BIT WORDS DATA FIELD
	ADD	3,ECCW(X)	;# OF 16 BIT WORDS OF ECC
	JRST	CGB		;TO COMMON CODE

;NOW ADJUSTED UP TO G4/G5 KNOWING THAT THE LAST DEFECT WAS NOT IN G4/G5
;CALCULATE DISTANCE INTO G4/G5.
;AC1/ START OF DEFECT IN BITS
;AC3/ RUNNING SUM OF 16 BIT WORDS
;AC4/ RUNNING SUM OF 18 BIT WORDS

CGB:	SUB	1,PD		;DISTANCE
	GO	RND16		;CONVERT AC1 TO 16 BIT WORDS
	ADD	3,1		;ADD IT TO THE SUM
	JRST	CGC		;GO AND STORE IT

;THE DEFECT STARTS BEYOND POINTER "PD"
;"REFPTR"  TO THE RIGHT OF "PB"
;LAST DEFECT WAS NOT IN THE DATA FIELD
;CALCULATE DISTANCE AND STACT THE DEFECT IF NECESSARY
;AC1/ DEFECT START (BITS)
;AC3/ RUNNING SUM OF 16 BIT WORDS
;AC4/ RUNNING SUM OF 18 BIT WORDS

CGE:	SUB	1,REFPTR	;DISTANCE IN BITS
	CAMGE	1,SKB(X)	;ARE WE OVERLAPING LAST DEFECT ?
	MOVE	1,SKB(X)	;YES. THEN STACK THEM
	GO	RND16		;CONVERT AC1 TO 16 BIT WORDS
	ADD	3,1		;ADD THEM TO THE RUNNING SUM
	JRST	CGC		;TO COMMON CODE

;FINALLY HAVE DISTANCE IN WORDS TO START OF DEFECT
;SUM THE WORDS, STORE THEM AWAY, UPDATE THE POINTERS

CGC:	MOVE	1,3		;THESE ARE THE 16 BIT WORDS
	ADD	1,4		;PLUS THE 18 BIT WORDS
	GO	STOREH		;PUT IN HEADER
	IMULI	3,^D16		;16 BIT WORDS BACK TO BITS
	IMULI	4,^D18		;18 BIT WORDS BACK TO BITS
	ADDM	3,REFPTR	;UPDATE THE POINTER
	ADDM	4,REFPTR
	MOVE	1,SKB(X)	;SKIP SIZE IN BITS
	ADDM	1,P3		;BUMP POINTER
	SETZM	LDDA		;LAST DEFECT "NOT" IN DATA AREA
	JRST	PRODX		;EXIT ROUTINE

;COMMON EXIT ROUTINE

PRODX:	GET	0		;RESTORE AC'S
	GET	1
	GET	2
	GET	3
	GET	4
	GET	5
	RTN			;AND EXIT.
	PAGE
; ************ POINTER INITIALIZATION AND UPDATE ROUTINES ************

;SUBROUTINE TO INIT POINTERS FOR DEFECT, "PINT" IS THE ENTRY POINT
;SUBROUTINE TO ADVANCE POINTERS FOR DEFECT, "PADV" IS THE ENTRY POINT

PINT:	PUT	0		;SAVE AC'S
	PUT	1
	MOVE	0,[POINT 18,1(1),17] ;POINT TO 1ST DEFECT HEADER WORD
	MOVEM	0,HWBPTR	;SAVE POINTER
	MOVE	1,@TDPTR	;TD1 NOW IN AC1
	SETZM	HN		;CURRENT SECTOR NUMBER
	SETZM	P1		;POINTER TO INDEX
	MOVE	0,G1B(X)	;GAP-1 SIZE
	ADD	0,TDB(X)	;+ SIZE OF TD
	ADD	0,G2B(X)	;+ SIZE OF G2
	TLNE	1,(1B2)		;TD MOVED?
	ADD	0,SKB(X)	;YES. + SKIP SIZE
	TLNE	1,(1B3)		;H0 MOVED?
	ADD	0,SKB(X)	;YES. + SKIP SIZE
	JRST	PCOMM		;TO COMMON CODE

PADV:	PUT	0		;SAVE AC'S
	PUT	1
	AOS	1,HN		;BUMP HEADER NUMBER
	CAMLE	1,ABBPT(X1)	;CHECK TO SEE IF WE RAN OFF TRACK
	GO	FFF		; .... OFF END OF TRACK ....
	MOVE	0,CWHDC(X1)	;# PDP-10 WORDS PER HEADER
	ADDM	0,HDPTR		;MEMORY POINTER NOW UPDATED.
	MOVE	0,[POINT 18,1(1),17] ;POINT TO 1ST DEFECT HEADER WORD
	MOVEM	0,HWBPTR	;NOW INITTED
	MOVE	0,P3		;GET POINTER TO 1ST WORD
PCOMM:	MOVEM	0,P2		;POINT TO START OF HN
	ADD	0,HRB(X)	;+ # OF BITS TO HDR CRC START
	MOVEM	0,P2A		;POINTS TO START OF HEADER CRC FIELD
	MOVEM	0,REFPTR	;FIRST WORD OF HEADER CRC
	ADD	0,HCRCB(X)	;+ SIZE OF HEADER FIELD
	MOVEM	0,PA		;POINT TO START OF GAP-3
	ADD	0,G3B(X)	;+ SIZE OF G3
	MOVEM	0,PB		;POINT TO START OF DATA FIELD
	ADD	0,DFB(X)	;+ SIZE OF DATA FIELD IN BITS
	ADD	0,ECCB(X)	;+ SIZE OF THE ECC FIELD IN BITS
	MOVEM	0,PD		;POINT TO GUARANTEED GOOD BITS AT END
	ADD	0,G4B(X)	;+ SIZE OF G4
	MOVEM	0,P3		;POINTER TO START OF NEXT SECTOR
	PAGE

;SPECIAL CODE TO MOVE P3 TO THE END OF G5 IF LAST SECTOR

	MOVE	0,HN		;GET HEADER NUMBER
	CAME	0,MXSEC(X1)	;IS THIS THE LAST SECT ?
	JRST	PCSET		;NO.
	MOVE	0,TBT(X)	;YES. GET TOTAL BITS/TRACK
	SUB	0,SK2(X)	; - 1/2 SIZE OF A DEFECT SKIP
	MOVEM	0,P3		;THIS IS EFFECTIVELY END OF TRACK

;HERE'S WHERE WE SET UP "PC"

PCSET:	MOVE	0,PD		;GET POINTER TO START OF G4
	SUB	0,CRITD(X)	;SUBTRACT MINIMUM DATA SEGMENT (BITS)
	MOVEM	0,PC		;SAVE PC IN BITS FROM INDEX
	SETZM	LDDA		;CLEAR LAST DEFECT FLAG
	GET	1		;RESTORE
	GET	0
	RTN			;AND EXIT.
	PAGE

;PLACE THE HEADER DEFECT SPECIFIER FROM AC1 INTO THE PROPER HEADER WORD
;AC1/ PROPER DEFECT DISTANCE FROM "REFPTR" IN WORDS

STOREH:	PUT	0		;SAVE AC'S
	PUT	1
	MOVE	0,1		;DEFECT DATA TO AC0
	MOVE	1,HDPTR		;PONTER TO START OF HEADER
	DPB	0,HWBPTR	;PUT WORD AWAY
	IBP	HWBPTR		;UPDATE BYTE POINTER
	GET	1		;RESTORE
	GET	0
	RTN			;EXIT

;CONVERT BIT COUNT IN AC1 TO 16 BIT WORDS (ROUNDING UP)
;SET FLAG "OVF" IF ROUNDING WAS REQUIRED

RND16:	PUT	2		;SAVE AC2
	SETZM	OVF#		;INIT THE OVERFLOW FLAG
	IDIVI	1,^D16		;CONVERT TO 16 BIT WORDS
	JUMPE	2,.+3		;JUMP IF NO ROUNDING REQUIRED
	AOS	1		;OTHERWISE ROUND
	SETOM	OVF		;SET THE OVERFLOW FLAG
	GET	2		;RESTORE THE AC
	RTN			;EXIT

;CONVERT BIT COUNT IN AC1 TO 18 BIT WORDS (ROUNDING UP)
;SET FLAG "OVF" IF ROUNDING WAS REQUIRED

RND18:	PUT	2		;SAVE AC2
	SETZM	OVF#		;INIT THE OVERFLOW FLAG
	IDIVI	1,^D18		;CONVERT TO 18 BIT WORDS
	JUMPE	2,.+3		;JUMP IF NO ROUNDING REQUIRED
	AOS	1		;OTHERWISE ROUND
	SETOM	OVF		;SET THE OVERFLOW FLAG
	GET	2		;RESTORE THE AC
	RTN			;EXIT

	XLIST
	BOX <LDENTH -- PRINTS HEADER MESSAGE FOR LISTING DEFECT ENTRIES>,<
	THIS CAN BE CALLED TO TYPE THE HEADER MESSAGE PRIOR TO LISTING ALL
	THE DEFECT ENTRIES.

	CALL SEQ:
	GO	LDENTH		;THE CALL
	RTN			;RTN1 ALWAYS >

LDENTH:	TEXT	[ASCIZ/

SER #	CYL #	SURF #	DISP-1	DISP-2	DISP-3	DISP-4
/]
	RTN		;EXIT

	XLIST
	BOX <LDENT -- LIST TD DEFECT INFORMATION IF TD IS NOT NULL>,<
	A SUBROUTINE TO LOOK AT EACH OF THE POSSIBLE SKIP SISPLACEMENTS
	AND PRINT ANY DEFECT DISPLACEMENTS FROM THE TRACK DESCRIPTOR RECORD.
	LISTIN IS ASSUMED OR YOU WOULDN'T BE HERE. TDPTR IS POINTING TO THE
	TRACK DESCRIPTOR BUFFER. UP TO 4 DEFECTS ARE HANDLED.

	CALL SEQ:
	MOVE	1,ARG1		;POINTER TO START OF TD
	GO	LDENT		;CALL THE ROUTINE
	RTN1			;RETURNS HERE >

LDENT:	PUT	0		;SAVE AC'S
	PUT	1
	MOVE	0,(1)		;GET IST WORD OF THE TD
	TLNE	0,(1B2!1B3)	;IS TD OR H0 MOVED ?
	JRST	LDE0		;YES. GO PRINT 
	HLRZ	0,1(1)		;GET 1ST DISPLACEMENT
	CAIN	0,140000	;IS THIS A NULL PATTERN ?
	JRST	LISTEX		;YES. NO DEFECT THIS ENTRY.
LDE0:	LDB	0,[POINT 16,R10D(DSW),35] ;GET SERIAL NUMBER
	GO	PNTBCD		;PRINT IT
	TEXT	[ASCIZ/	/]	;TAB OVER
	LDB	0,[POINT 11,(1),17] ;GET CYLINDER NUMBER
	GO	PSDN		;PRINT CYLINDER
	TEXT	[ASCIZ/	/]	;TAB OVER
	LDB	0,[POINT 8,(1),27] ;GET SURFACE NUMBER
	GO	PSDN		;PRINT SURFACE
	TEXT	[ASCIZ/	/]	;TAB OVER
	HLRZ	0,1(1)		;GET THE 1ST DISPLACEMENT
	CAIN	0,140000	;IS THIS A NULL PATTERN ?
	JRST	LISTX		;YES. NO DEFECT THIS ENTRY.
	GO	PSDN		;PRINT IT
	HRRZ	0,1(1)		;GET 2ND DISPLACEMENT
	CAIN	0,140000	;IS THIS A NULL PATTERN ?
	JRST	LISTX		;YES. NO DEFECT THIS ENTRY.
	TEXT	[ASCIZ/	/]	;TAB OVER
	GO	PSDN		;PRINT NEXT DEFECT
	HLRZ	0,2(1)		;GET 3RD DISPLACEMENT
	CAIN	0,140000	;IS THIS A NULL PATTERN ?
	JRST	LISTX		;YES. NO DEFECT THIS ENTRY.
	TEXT	[ASCIZ/	/]	;TAB OVER
	GO	PSDN		;PRINT 3RD DEFECT
	HRRZ	0,2(1)		;GET 4TH DISPLACEMENT
	CAIN	0,140000	;IS THIS A NULL PATTERN ?
	JRST	LISTX		;YES. NO DEFECT THIS ENTRY.
	TEXT	[ASCIZ/	/]	;TAB OVER
	GO	PSDN		;PRINT 4TH DEFECT
LISTX:	MOVE	0(1)		;GET 1ST WORD OF TD ..
	TLNE	0,(1B3)		;IS TD MOVED ?
	TEXT	[ASCIZ/  TD-MOVED/]
	TLNE	0,(1B2)		;IS H0 MOVED ?
	TEXT	[ASCIZ/  H0-MOVED/]
	PCRL			;TERMINATE THE LINE
LISTEX:	GET	1
	GET	0
	RTN			;AND EXIT


	XLIST
	BOX <TDINP -- ROUTINE TO INPUT TRACK DESCRIPTOR OPTIONS>,<
	THIS IS USED BY THE "TDBLD" UTILITY.
	ROUTINE ACCEPTS TD INFORMATION FROM THE USER REGUARDING
	THE CONTENTS OF THE NEW TD. IT BUILDS THE NEW TD IN A BUFFER
	AT TDB1. THIS ROUTNE SCREENS INPUT IN SUCH A WAY THAT ONLY
	LEGAL TD'S CAN BE BUILT......
	
	THE USER CAN SPECIFY UP TO 4 DEFECTS.
	THE USER CAN SPECIFY TD AND/OR H0 MOVED BUT EACH USES UP A DEFECT
	
	CALLING SEQ:
		MOVE	1,ARG1		;POINTER TO 4 WD BUFFER
		MOVE	2,ARG2		;CYL,,SURF,0
		GO	TDINP		;CALL THE ROUTINE
		RTN			;RTN1 ALWAYS.....
	
	NOTES:
	------

	AC10 WILL POINT TO START OF 4 WD TD BUFFER

	AC7 = X

	AC6 IS A BYTE POINTER POINTING IN FRONT OF NEXT DISPLACEMNT WORD

	AC5 WILL HOLD THE LAST LOCATION ON A TRACK (16 BIT WORDS) WHERE
	A DEFECT MAY BE CENTERED. AC5 = LENGTH OF TRACK - 1/2(SKIP SIZE)
	
	AC4 WILL BE USED AS A REFERENCE POINTER BECAUSE THE 1ST DEFECT
	IS MEASURED WITH RESPECT TO INDEX WHILE ALL OTHER DEFECTS ARE MEASURED
	WITH RESPECT TO THE LAST DEFECT. AC4 WILL THEREFORE WILL BE MAINTAINED 
	TO POINT TO THE CURRENT REFERENCE POINT. IT IS INITIALIZED TO 0.
	
	AC3 WILL POINT TO THE SPOT ON THE TRACK (IN 16 BIT WORDS) WHERE THE
	NEXT DEFECT MAY BE CENTERED.
	
	AC2 WILL HOLD THE NUMBER OF DEFECTS STILL AVAILABLE ON THE TRACK.
	4 IS THE MAXIMIM AND TD-MOVED AND H0-MOVED EACH USE 1 UP. 

	FOR 600 MB RP07:
	- THERE ARE 17,472  16-BIT WDS/TRK
	- A DEFECT SKIP IS 108  16-BIT WORDS LONG
	- THE FIRST DEFECT ON A TRACK MAY BE CENTERED AT 169  16-BIT WORDS
	   FROM INDEX IF NITHER H0 OT TD IS MOVED.
	- THE FURTHEST A DEFECT MAY BE CENTERED FROM INDEX IS 17,418  16-BIT
	   WORDS WITHOUT OVERFLOWING THE TRACK. >

TDINP:	PUT	0		;SAVE AC'S
	PUT	1
	PUT	2
	PUT	3
	PUT	4

	PUT	5
	PUT	6
	PUT	X
	PUT	10
	SETZM	X		;SETUP FOR 600 MB

;SET UP ALL THE AC'S FOR USE IN THIS ROUTINE

	MOVE	10,1		;GETS OUR POINTER TO AC10
	MOVE	5,TBT(X)	;WANT TO POINT TO LEGAL CTR OF LAST DEF
	SUB	SK2(X)		;SUB 1/2 SKIP
	IDIVI	5,^D16		;CONVERT BITS TO 16 BIT WORDS
	MOVE	6,[POINT 18,0(10),35] ;POINTS IN FRONT OF 1ST DISPLACEMENT
	SETZM	3		;WANT TO POINT TO CTR OF 1ST LEGAL DEF POS
	ADD	3,G1B(X)	; BITS IN G1
	ADD	3,TDB(X)	; BITS IN TD
	ADD	3,G2B(X)	; BITS IN G2
	ADD	3,HRB(X)	; BITS TO IN H0 UP TO CRC FIELD
	ADD	3,SK2(X)	; HALF SIZE OF SKIP
	IDIVI	3,^D16		;CONVERT BITS TO 16 BIT WORDS
	SETZM	4		;REF PTR POINTING TO INDEX
	MOVE	1,2		;GET CYL,,SURF,0 TO AC1
	IORI	1,377		;NOW CYL,,SURF,377 (TD ADDRESS)
	TLO	1,030000	;SET GOOD SECTOR FLAGS
	MOVE	2,MXDEF(X)	;GET MAX DEFECTS ON TRACK

;BUILD PARTIAL TD IN BUFFER POINTED TO BY AC7

	SETZM	0,(10)		;CLEAR FIRST WORD
	SETZM	3,(10)		;CLEAR LAST WORD
	MOVE	0,[140000,,140000] ;GET 2 NULL PATTERNS
	MOVEM	0,1(10)		;INITS 1ST 2 DISPLACEMENTS
	MOVEM	0,2(10)		;INITS LAST 2 DISPLACEMENTS

;CODE TO HANDLE THE MOVING OF TD

	SKIPA
	PCRLF
	TEXTF	[ASCIZ/WANT TD-MOVED ?/]
	GO	QSTN		;ASK THE QUESTION
	JRST	.-3		;TIMEOUT
	JRST	HZM		;ANSWER IS NO
	TLO	1,(1B3)		;YES. SET TD-MOVED BIT
	SUBI	2,1		;WE'VE USED UP A DEFECT
	PUT	1		;SAVE	1
	MOVE	0,SKB(X)	;GET  SIZE OF SKIP IN BITS
	IDIVI	0,^D16		;CONVRT TO 16 BIT WORDS
	GET	1		;RESTORE 1
	ADD	3,0		;ADD IT TO OUR POINTER

;CODE TO HANDLE THE MOVING OF H0

HZM:	SKIPA
	PCRLF
	TEXTF	[ASCIZ/WANT H0-MOVED ?/]
	GO	QSTN		;ASK THE QUESTION
	JRST	.-3		;TIMEOUT
	JRST	HZN		;ANSWER IS NO
	TLO	1,(1B2)		;ANSWER IS YES. SET THE TD BIT
	SUBI	2,1		;WE'VE USED UP A DEFECT
	PUT	1		;SAVE	1
	MOVE	0,SKB(X)	;GET SIZE OF SKIP IN BITS
	IDIVI	0,^D16		;CONVRT TO 16 BIT WORDS
	GET	1		;RESTORE 1
	ADD	3,0		;ADD IT TO OUR POINTER
HZN:	MOVEM	1,(10)		;PUT TD WORD-1 INTO BUFFER

;HERES LOOP TO INPUT DISPLACEMENTS TILL WE'RE DONE

DISPIN:	JUMPLE	2,TDINPX	;EXIT IF WE'VE USED ALL DEFECTS UP
	CAMLE	3,5		;SEE IF WE HAVE ROOM ON TRACK FOR ANOTHER
	JRST	TDINPX		;NO ROOM
	TEXTF	[ASCIZ/
DO YOU WISH TO ADD ANOTHER DEFECT ?/]
	GO	QSTN		;ASK THE QUESTION
	JRST	.-2		;TIMEOUT
	JRST	TDINPX		;ANSWER IS NO
	TEXTF	[ASCIZ/ENTER DISTANCE (16 BIT WDS) FROM /]
	MOVEI	1,[ASCIZ/CENTER OF LAST DEFECT /]
	SKIPN	4		;SEE IF WE'RE DOING FIRST ONE
	MOVEI	1,[ASCIZ/INDEX /]
	TEXTF	(1)		;PRINT APPROPRIATE MESSAGE
DIER:	TEXTF	[ASCIZ/
THESE VALUES ARE ALLOWED /]
	MOVE	0,3		;GET MIDDLE POINTER
	SUB	0,4		;SUB LEFT POINTER
	MOVE	1,0		;SAVE FOR FUTURE USE
	GO	POCDEF		;PRINT LOWER LIMIT
	TEXTF	[ASCIZ/ THRU /]
	MOVE	0,5		;GET RIGHT PONTER
	SUB	0,4		;SUB STARTING POINTER
	GO	POCDEF		;PRINT UPPER LIMIT
	HRL	0,1		;NOW HAVE LIMITS IN AC0
	TEXTF	[ASCIZ/ - /]
	GO	NUMIN		;INPUT A NUMBER
	JFCL			;TIMEOUT
	JRST	DIER		;INPUT ERROR ...
DIOK:	IDPB	0,6		;PUT DISTANCE AWAY VIA BYTE PTR
	ADD	4,0		;MOVE REF PTR TO THIS POINT ....
	MOVE	3,4		;COPY TO AC3
	MOVE	0,SKB(X)	;GET SKIP SIZE IN BITS
	IDIVI	0,^D16		;CONVERT TO 16 BIT WORDS
	ADD	3,0		;INCREASE VALUE OF POINTER
	SUBI	2,1		;ONE DEFECT IS USED UP ...
	JRST	DISPIN		;LOOP AND TRY FOR ANOTHER ...

;EXIT CODE ..
	
TDINPX:	GET	10		;RESTORE THINGS FROM STACK
	GET	X
	GET	6
	GET	5
	GET	4
	GET	3
	GET	2
	GET	1
	GET	0
	RTN			;EXIT

	XLIST
	BOX <CNTDEF -- ROUTINE TO COUNT DEFECTS FROM A TRACK DESCRIPTOR>,<
	THIS ROUTINE COUNTS THE DEFECTS IN A TRACK DESCRIPTOR POINTED TO BY
	AC1 AND RETURNS THE NUMBER IN AC1. IT IS CAREFULL NOT TO COUNT TWICE
	WHEN A TD OR H0 IS MOVED AND A DEFECT DISPLACEMENT IS ALSO PRESENT
	IN THE TD FOR THE MOVE.

	CALL SEQ:
	MOVE	1,ARG1		;POINTER TO TD IN CORE
	GO	CNTDEF		;THE CALL
	RTN			;# OF DEFECTS IN AC1

	AC'S DURING EXECUTION:
	AC5 - A POINTER. ALL DEFECTS TO LEFT ARE TD OR H0 RELATED
	AC4 - RUNNING SUM OF DEFECT DISPLACEMENTS
	AC3 - POINTER TO TD IN CORE
	AC2 - BYTE POINTER. POINTS IN FRONT OF NEXT DEFECT
	AC1 - COUNT OF NUMBER OF DEFECTS
	AC0 - SCRATCH ....  >

CNTDEF:	PUT	X		;SAVE AC'S
	PUT	5
	PUT	4
	PUT	3
	PUT	2
	PUT	1
	PUT	0

;INITIALIZE AC'S FOR TEST ....

	SETZM	-1(P)		;CLEAR THE COUNT WE RETURN
	SETZM	X		;SETUP FOR 600 MB
	MOVE	3,1		;GET POINTER TO TD BUFFER
	MOVE	2,[POINT 18,0(3),35] ;POINT IN FRONT OF FIRST DISP
	SETZM	4		;CLEAR RUNNING SUM
	MOVE	0,G1B(X)	;G1 IN BITS
	ADD	0,TDB(X)	;TD IN BITS
	ADD	0,G2B(X)	;G2 IN BITS
	ADD	0,HRB(X)	;H0 IN BITS
	ADD	0,SK2(X)	;1/2 SKIP IN BITS

	MOVE	1,0(3)		;GET 1ST WORD OF TD
	TLNN	1,(1B2)		;TD  MOVED ?
	JRST	.+3		;NO
	ADD	0,SKB(X)	;YES. SIZE OF A SKIP IN BITS
	AOS	-1(P)		;COUNT A DEFECT

	TLNN	1,(1B3)		;H0 MOVED ?
	JRST	.+3		;NO.
	ADD	0,SKB(X)	;YES. SIZE OF A SKIP IN BITS
	AOS	-1(P)		;COUNT THE DEFECT

	IDIVI	0,^D16		;CONVERT BITS TO 16 BIT WORDS
	MOVE	5,0		;GE REFERECNE POINTER TO AC5 ....
	SETZM	1		;CLEAR OUT COUNT

;READY TO START COUNTING DISPLACEMENTS

CNTDFL:	ILDB	0,2		;GET DISPLACEMENT
	CAIN	0,140000	;IS IT NULL ?
	JRST	CNTDFX		;YES. FINISHED.
	ADD	4,0		;NO. RUNNING SUMM TO AC4
	CAML	4,5		;DON'T COUNT IF TO LEFT OF PTR
	AOS	-1(P)		;COUNT DEFECT ....
	ADDI	1,1		;BUMP A COUNTER
	CAMGE	1,MXDEF(X)	;TRIED ALL DEFECTS ?
	JRST	CNTDFL		;NO. LOOP

CNTDFX:	GET	0		;RESTORE AC'S
	GET	1
	GET	2
	GET	3
	GET	4
	GET	5
	GET	X
	RTN			;AND EXIT


	XLIST
	BOX <PARAMETERS ASSOCIATED WITH THE TRACK FORMAT>,<
	THIS AREA CONTAINS CONSTANTS FOR RP07'S IN 18 BIT MODE
	WHEN YOU ARE FORMATTING THE MEDIA.
	YOU INDEX WITH A VALUE OF 0 FOR 600-MB RP07
	INDEXING IN THIS PROGRAM IS DONE WITH (X)
	INDEXING IS USED SO NEW DRIVES MAY BE ADDED >

;GAP 1 DESCRIPTOR (CONVERTED TO BITS)

G1B:	^D128*^D8	;128 BYTES

;TRACK DESCRIPTOR (CONVERTED TO BITS)

TDB:	^D16*^D8	;16 BYTES

TDMB:	^D216*^D8	;AMOUNT OF BYTES TD MAY BE MOVED

;G2 DESCRIPTOR (CONVERTED TO BITS)

G2B:	^D74*^D8	;74 BYTES

;HEADER DESCRIPTOR (CONVERTED TO BITS)

HNB:	^D16*^D8	;16 BYTES TOTAL

HRB:	^D12*^D8	;DIST IN BYTES TO HEADER CRC START

HCRCB:	^D4*^D8		;# BYTES IN THE HEADER CRC CHAR.

;G3 DESCRIPTOR (CONVERTED TO BITS)

G3B:	^D64*^D8	;64 BYTES

;DATA FIELD DESCRIPTOR

DFB:	^D256*^D18	;# OF BITS IN THE DATA FIELD

DFW:	^D256		;# OF 18 BIT WORDS IN THE DATA FIELD

;ECC FIELD DESCRIPTOR

ECCB:	^D4*^D8		;# OF BITS IN THE ECC FIELD

ECCW:	^D2		;# OF 16 BIT WORDS IN ECC FIELD

;G4 DESCRIPTOR (CONVERTED TO BITS)

G4B:	^D128*^D8	;128 BYTES

;TOTAL NUMBER OF BITS IN A DATA SECTOR WITHOUT DEFECTS

TBS:	^D8*<^D16+^D64+^D576+^D4+^D128> ;HN+G3+DATA+ECC+G4

;TOTAL NUMBER OF BITS AVAILABLE ON A TRACK

TBT:	^D34944*^D8	;34944 BYTES

;DEFECT SKIP INFORMATION (CONVERTED TO BITS)

SKB:	^D216*^D8	;SIZE OF INSERTED SKIP IN BITS

SK2:	^D108*^D8	;1/2 THE SIZE OF A SKIP

SKGF18: ^D16*^D18	;FIRST 16, 18 BIT WORDS OF SKIP GUARANTEED GOOD

SKGL18: <^D5*^D18>+6	;LAST 5.3333, 18 BIT WORDS OF SKIP GUARANTEED GOOD

SKGF16: ^D18*^D16	;FIRST 18, 16 BIT WORDS GUARANTEED GOOD

SKGL16: ^D6*^D16	;LAST 6, 16 BIT WORDS GUARANTEED GOOD

;MINIMUM DATA FIELD SEGMENT SIZE.

SEG18:	^D16*^D18	;16  18-BIT WORDS

SEG16:	^D18*^D16	;18  16-BIT WORDS

	PAGE

;CRITICAL DATA AREA (IN BITS)......(MIXED 18 & 16 BIT WORDS)
;DISTANCE BETWEEN "PC" & "PD". DEFECTS THAT START HERE MUST BE
;MOVED INTO THE FOLLOWING GAP.

CRITD:	<^D14*^D18>+<^D2*^D16> ;14 DATA WORDS AND 2 ECC WORDS

;A COUPLE OF DATA FIELD DESCRIPTORS  -----(IN WORDS)-----

CRITW:  ^D16		;TOTAL WORDS IN CRITICAL AREA

NCRIT:	<^D256+^D2>-^D14 ;18 BIT WORDS IN DATA FIELD LESS CRIT AREA

CRIT18: ^D14		;# OF 18 BIT WORDS IN THE CRITICAL AREA

CRIT16: ^D2		;# OF 16 BIT WORDS IN THE CRITICAL AREA

;NUMBER OF DEFECTS ALLOWED PER TRACK

MXDEF:	4		;4 DEFECTS PER TRACK MAXIMUM (600-MB)

	XLIST
	BOX <VARIABLES USED DURING THE FORMAT OPERATION>, <
	THESE POINTERS (VARIABLES) ARE ALL USED BY THE ROUTINE
	"DEFECT" AS IT TRIES TO FIGURE OUT WHERE IN EACH OF THE
	SECTORS A DEFECT MUST BE INSERTED. >

P1:	Z	;ALWAYS POINTS TO INDEX

P2:	Z	;ALWAYS THE NUMBER OF BITS FROM INDEX TO FIRST BIT
		;       OF THE CURRENT SECTOR

P2A:	Z	;ALWAYS THE NUMBER OF BITS FROM INDEX TO 1ST BIT OF
		;	THE HEADER CRC FIELD

P3:	Z	;ALWAYS THE NUMBER OF BITS FROM INDEX TO FIRST BIT
		;       OF THE NEXT SECTOR

PA:	Z	;ALWAYS THE NUMBER OF BITS FROM INDEX TO FIRST WORD
		;       OF G3 FOR THE CURRENT SECTOR

PB:	Z	;ALWAYS THE NUMBER OF BITS FROM INDEX TO FIRST WORD
		;       OF THE DATA FIELD OF THE CURRENT SECTOR

PC:	Z	;ALWAYS THE NUMBER OF BITS FROM INDEX TO ("PD"-"CRITD")

PD:	Z	;ALWAYS THE NUMBER OF BITS FROM INDEX TO THE FIRST
		;WORD IN G4 (OR G5)

REFPTR: Z	;THIS POINTER ALWAYS MEASURES DISTANCES FROM
		;INDEX TO THE START OF THE HEADER CRC FOR THIS SECTOR OR
		;TO THE START OF THE LAST DEFECT SKIP. IT IS FROM
		;THIS POINTER THAT WE DETERMINE HOW MANY WORDS THERE
		;ARE TO THE START OF THE NEXT DEFECT. THIS POINTER IS
		;IN BITS

LDDA:	Z	;0  LAST DEFECT NOT IN DATA FIELD
		;-1 LAST DEFECT WAS IN THE DATA FIELD
	PAGE
;POINTERS TO SPECIFIC HEADER INFORMATION

HN:	Z	;ALWAYS CURRENT NUMBER OF SECTOR WE'RE WORKING ON


;POINTER TO START OF TRACK DESCRIPTOR IN CORE ,AND,
;POINTER TO START OF THE CURRENT SECTOR IN CORE ...

TDPTR:	Z	;POINTS TO TRACK DESCRIPTOR BUFFER

HDPTR:	Z	;POINTS TO CURRENT HEADER IN CORE

HWBPTR: Z	;BYTE POINTER TO CURRENT RELATIVE HEADER WORD

;TABLE OF DEFECT DISTANCES DERIVED FROM TRACK DESCRIPTOR DATA
; ENTRIES HAVE FOLLOWING MEANING .....
; D(0) - BIT COUNT FROM INDEX TO START OF FIRST DEFECT
; D(1) - BITS FROM INDEX TO START OF 2ND DEFECT
; D(2) - BITS FROM INDEX TO START OF 3RD DEFECT
; ETC .... AS MANY ENTRIES AS THERE ARE DEFECTS (PLUS-1)

DIST:	BLOCK	4		;4 DEFECTS MAXIMUM FOR RP07
	END
