;PROGRAM START

START:	PGMINT			;INITIALIZE SUBROUTINES
	MOVE	0,RANDBS	;EXEC, SETUP RANDOM 
	SKIPE	USER		;USER, USE TIME OF DAY IN JIFFIES
	CALL	0,[SIXBIT/TIMER/]
	MOVEM	0,RAN		;SETUP RANDOM BASE

;INITIALIZE COMPLEXITY TABLE

	A=0
STARTA:	SETZM	CMPLXT		;STORE A TABLE OF POWERS OF 2
	MOVEI	1,1		;OR 0.
	SWITCH
	TLNN	RELIAB		;RELIABILITY SWITCH SET ?
	SETZM	1		;NO, STORE ZERO'S

	REPEAT	7,<
	MOVEM	1,CMPLXT+1+A
	LSH	1,1
	A=A+1>

;INITIALIZE RUN TIME

	MOVEI	1,1
	TLNE	RELIAB		;RELIABILITY SWITCH SET ?
	MOVEI	1,7		;YES, MULTIPLY RUNNING TIME
	MOVEM	1,RTIME		;STORE IN RTIME

	JRST	TDCN1		;GO PERFORM DIAGNOSTIC

RENTR1:	DROPDV			;CLOSE LOGICAL OUTPUT FILE
	CALL	[SIXBIT .EXIT.]

PGMNAM:	ASCIZ/
PDP-10  KA10 BASIC INSTRUCTION RELIABILITY TEST 2 (DAKBB)
(TESTS, SKIPS, JUMPS, AOX, SOX, CAI, ETC.)
/

;CONSTANTS

RTIME:	0
CMPLXT:	BLOCK	20
SUBTTL	DIAGNOSTIC SECTION
	LALL

;TEST TDCN.  CHECK FOR SKIP /NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=6
TDCN1:	SETUP	100,0
TDCN2:	RANDOM
TDCN3:	SETZ	AC1,		;CLEAR C("AC").
	TDCN	AC1,AC		;C(E)+C(AC)=0. NO SKIP.
	CAME	AC1,RAN		;C(AC) SHOULD = C(E).
	ERR	AC,[0]
	LOOP	TDCN2,TDCN3
;TEST TDCN. CHECKING FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=10
TDCN4:	SETUP	100,0
TDCN5:	RANDOM
	JUMPE	AC,TDCN5	;REJECT IF RAN = 0.
TDCN6:	SETOB	AC1,RAN1	;SET C(AC) TO A -1.
	SETCM	AC2,AC		;SIMULATE TDC
	TDCN	AC1,AC		;C(E)+C(AC) NOT=0. SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC)SHOULD=SIM. ANS.
	ERR	AC,[-1]
	LOOP	TDCN5,TDCN6


;TEST TDCN. CHECKING FOR SKIP /NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=2
TDCN7:	SETUP	100,0
TDCN8:	RANDOM
	JUMPE	AC,TDCN8	;REJECT IF RAN = 0.
TDCN9:	TDCN	AC,AC		;C(E) + C(AC) NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,[0]		;C(AC) SHOULD = 0.
	EERR	,RAN
	LOOP	TDCN8,TDCN9

;TEST TDCN. CHECKING FOR SKIP /NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO NOT RAN CONDITION

	AC=3
TDCNG:	SETUP	100,0
TDCNH:	RANDOM
TDCNI:	SETCM	AC1,AC		;MAKE C("AC")=COMP OF RAN.
	MOVE	RAN1,AC1	;SAVE C(AC) IN CASE OF ERROR.
	TDCN	AC1,AC		;C(E)+C(AC)=0. NO SKIP.
	CAME	AC1,[-1]	;C(AC) SHOULD = A-1.
	ERR	AC,RAN1
	LOOP	TDCNH,TDCNI

;TEST TDCE,TDCN. ROT A MASK BIT IN E AND
;CLEAR THAT BIT IN AC BEFORE TDC. CHECK SKIP/NO SKIP
;AND CORRECT DATA IN AC.

	AC=4
TDCE1:	SETUP	40,0
	MOVEI	AC1,1		;SETUP AC1 TO CONTAIN ONE MASK BIT.
TDCE2:	RANDOM
	ROT	AC1,1		;ROT MASK TO TEST NEXT BIT
TDCE3:	ANDCM	AC,AC1		;CLEAR MASK BIT IN AC.
	MOVE	AC2,AC		;SAVE AC IN AC2.
	TDCN	AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDCN SKIPPED.
	TDCN	AC,AC1		;C(E) + C(AC) NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC1,AC2
	TDCE	AC,AC1		;C(E) + C(AC) = 0...SKIP.
	ER	AC,[ASCII /TST/]
	TDCE	AC,AC1		;C(E) + C(AC) NOT = 0...NO SKIP.
	CAME	AC,AC2		;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC1,AC2
	LOOP	TDCE2,TDCE3

;TEST TDCE, TDCN. ROT A BIT IN E AND
;SET THAT BIT IN AC BEFORE TDC. CHECK FOR
;SKIP /NO SKIP AND CORRECT DATA IN AC.

	AC=5
TDCEA:	SETUP	40,0
	MOVEI	AC1,1		;SETUP AC1 TO CONTAIN MASK BIT.
TDCEB:	RANDOM
	ROT	AC1,1		;ROT MASK TO TEST NEXT BIT.
TDCEC:	IOR	AC,AC1		;SET MASK BIT IN AC.
	MOVE	AC2,AC		;SAVE AC IN AC2.
	TDCE	AC,AC1		;C(E) + C(AC) NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDCE SKIPPED.
	TDCE	AC,AC1		;C(E) + C(AC) = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC1,AC2
	TDCN	AC,AC1		;C(E) + C(AC) NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	TDCN	AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	CAME	AC,AC2		;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC1,AC2
	LOOP	TDCEB,TDCEC

;TEST TDCE, TDCN. ROT A BIT IN AC
;AND CLEAR THAT BIT  E BEFORE TDC
;CHECK FOR SKIP /NO SKIP AND CORRECT DATA IN AC.

	AC=6
TDCN1A:	SETUP	40,0
	MOVEI	AC1,1		;SETUP A BIT IN "AC".
TDCN1B:	RANDOM
	ROT	AC1,1		;ROT BIT TO TEST NEXT BIT.
	MOVE	AC2,AC1		;SAVE IN AC2 FOR FUTURE COMPARE.
TDCN1C:	MOVE	AC1,AC2		;COME HERE AND RESTORE C(AC) IF ERROR OCCURED.
	ANDCM	AC,AC1		;CLEAR BIT IN "E".
	JUMPE	AC,TDCN1B	;REJECT IF = 0.
	TDCN	AC1,AC		;C(E)+C(AC)=0. NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDCN SKIPPED.
	TDCN	AC1,AC		;C(E)+C(AC)NOT=0. SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC)SHOULD=C(AC)BEFORE TDC'S.
	ERR	AC,AC2
	TDCE	AC1,AC		;C(E)+C(AC)=0.SKIP.
	ER	AC1,[ASCII /TST/]
	TDCE	AC1,AC		;C(E)+C(AC)NOT=0. NO SKIP.
	CAME	AC1,AC2		;C(AC) SHOULD = C(AC) BEFORE TDC'S.
	ERR	AC,AC2
	LOOP	TDCN1B,TDCN1C

;TEST TDCE, TDCN. ROT A BIT IN AC AND SET THAT BIT IN
;E BEFORE TDC. CHECK FOR SKIP /NO SKIP AND CORRECT DATA IN AC.

	AC=7
TDCNA1:	SETUP	40,0
	MOVEI	AC1,1		;SET A BIT IN AC
TDCNA2:	RANDOM
	ROT	AC1,1		;ROT BIT TO TEST NEXT BIT.
	MOVE	AC2,AC1		;SAVE "AC". IN CASE OF ERROR
TDCNA3:	MOVE	AC1,AC2		;RESTORE "AC".
	IOR	AC,AC1		;SET BIT IN "E".
	MOVE	AC3,AC		;SIMULATE
	XOR	AC3,AC1		;A TDC.
	TDCE	AC1,AC		;C(E)+C(AC) NOT=0. NO SKIP.
	CAME	AC1,AC3		;C(AC) SHOULD = SIM. ANS.
	ERR	AC,AC2
	MOVE	AC1,AC2		;RESTORE "AC".
	TDCN	AC1,AC		;C(E)+C(AC) NOT=0. SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC3		;C(AC) SHOULD = SIM. ANS.
	ERR	AC,AC2
	MOVE	AC1,AC2		;RESTORE "AC".
	LOOP	TDCNA2,TDCNA3

;TEST TDNE, TDNN. ROT A BIT IN E AND
;CLEAR THAT BIT IN AC BEFORE TDN. CHECK FOR
;SKIP /NO SKIP AND CORRECT DATA IN AC.

	AC=10
TDNN1:	SETUP	40,0
	MOVEI	AC1,1		;SET A BIT IN "E".
TDNN2:	RANDOM
	ROT	AC1,1		;ROT BIT TO TEST NEXT BIT.
TDNN3:	ANDCM	AC,AC1		;CLEAR BIT IN "AC".
	MOVE	AC2,AC		;SAVE C("AC") FOR FUTURE COMPARE.
	TDNN	AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNN SKIPPED.
	TDNE	AC,AC1		;C(E)+C(AC)=0. SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC)SHOULD NOT HAVE CHANGED.
	ERR	AC1,AC2
	LOOP	TDNN2,TDNN3

;TEST TDNE, TDNN. ROT A BIT IN E AND SET THAT BIT IN AC BEFORE TDN. CHECK
;FOR SKIP /NO SKIP AND CORRECT DATA IN AC.

	AC=11
TDNNA:	SETUP	40,0
	MOVEI	AC1,1		;SET A BIT IN "E"
TDNNB:	RANDOM
	ROT	AC1,1		;ROT BIT TO TEST NEXT BIT.
TDNNC:	IOR	AC,AC1		;SET BIT IN "AC".
	MOVE	AC2,AC		;SAVE FOR FUTURE COMPARE.
	TDNE	AC,AC1		;C(E)+(AC)NOT=0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TDNE SKIPPED.
	TDNN	AC,AC1		;C(E)+C(AC)NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC)SHOULD NOT HAVE CHANGED.
	ERR	AC1,AC2
	LOOP	TDNNB,TDNNC

;TEST TDNE, TDNN. ROT A BIT IN AC AND
;CLEAR THAT BIT IN E BEFORE TDN. CHECK FOR
;SKIP /NO SKIP AND CORRECT DATA IN AC.

	AC=12
TDNND:	SETUP	40,0
	MOVEI	AC1,1		;SET A BIT IN "AC"
TDNNE:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	MOVE	AC2,AC1		;SAVE C("AC") SO C("AC") CAN BE
TDNNF:	MOVE	AC1,AC2		;RESTORED IN CASE OF ERROR.
	ANDCM	AC,AC1		;CLEAR BIT IN"E".
	TDNN	AC1,AC		;C(E)+C(AC)=0. NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDNN SKIPPED.
	TDNE	AC1,AC		;C(E)+C(AC)=0. SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC)SHOULD NOT CHANGE
	ERR	AC,AC2
	LOOP	TDNNE,TDNNF

;TEST TDNE, TDNN. ROT A BIT IN AC AND SET THAT BIT IN E
;BEFORE TDN. CHECK FOR SKIP /NO SKIP AND CORRECT DATA IN AC.


	AC=13
TDNN4:	SETUP	40,0
	MOVEI	AC1,1		;SET A BIT IN "AC".
TDNN5:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	MOVE	AC2,AC1		;SAVE C("AC") SO C("AC") CAN BE
TDNN6:	MOVE	AC1,AC2		;RESTORED IN CASE OF ERROR.
	IOR	AC,AC1		;SET BIT IN "E".
	TDNE	AC1,AC		;C(E)+C(AC)NOT=0. NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TDNE SKIPPED.
	TDNN	AC1,AC		;C(E)+C(AC)NOT=0. SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC)SHOULD NOT CHANGE.
	ERR	AC,AC2
	LOOP	TDNN5,TDNN6

;TEST TSC CHECK FOR SKIP /NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=14
TSC1:	SETUP	100,0
TSC2:	RANDOM
TSC3:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVE	AC2,AC		;SIMULATE
	ROT	AC2,22		;A TSC.
	TSC	AC1,AC		;SHOULD NOT SKIP
	CAME	AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERR	AC,RAN1
	LOOP	TSC2,TSC3

;TEST TSC. CHECK FOR SKIP /NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION.

	AC=15

TSC4:	SETUP	100,0
TSC5:	RANDOM
TSC6:	SETZ	AC1,		;CLEAR "E".
	TSC	AC,AC1		;SHOULD NOT SKIP.
	CAME	AC,RAN		;C(AC)SHOULD NOT HAVE CHANGED
	ERR	AC1,RAN
	LOOP	TSC5,TSC6

;TEST TSC.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION.

	AC=6
TSC7:	SETUP	100,0
TSC8:	RANDOM
TSC9:	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVS	AC1,AC		;SIMULATE
	XOR	AC1,AC		;A TSC
	TSC	AC,AC		;SHOULD NOT SKIP
	CAME	AC,AC1		;C(AC)SHOULD=SIM. ANS.
	ERR	RAN1,RAN
	LOOP	TSC8,TSC9

;TEST TSC, TSCA.  TWO TSC'S SHOULD PRODUCE ORIGINAL
;NUMBER IN AC.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=7
TSCA1:	SETUP	100,0
TSCA2:	RANDOM
TSCA3:	MOVE	AC1,AC		;MAKE C("E")=C("AC").
	TSC	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSC SKIPPED.
	TSCA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD BE BACK TO ORIG NUM
	ERR	AC1,RAN
	LOOP	TSCA2,TSCA3


;TEST TSCE, TSCN.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR 0 TO RAN CONDITION.

	AC=10
TSCE1:	SETUP	100,0
TSCE2:	RANDOM
TSCE3:	SETZB	AC1,RAN1	;CLEAR C(E).
	TSCN	AC,AC1		;C(E)+C(AC)=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSCN SKIPPED.
	TSCE	AC,AC1		;C(E)+C(AC)=0, SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD STILL = RAN
	ERR	RAN1,RAN
	LOOP	TSCE2,TSCE3

;TEST TSCE, TSCN.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=10
TSCEA:	SETUP	100,0
TSCEB:	RANDOM
TSCEC:	SETZB	AC1,RAN1	;CLEAR C("AC").
	MOVS	AC2,AC		;SIMULATE TSC.
	TSCN	AC1,AC		;C(E)+C(AC)=0. NO SKIP
	CAME	AC1,AC2		;C(AC) SHOULD = SIM ANS
	ERR	AC,RAN1
	SETZ	AC1,		;CLEAR C("AC").
	TSCE	AC1,AC		;C(E)+C(AC)=0. SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD = SIM ANS
	ERR	AC,RAN1
	LOOP	TSCEB,TSCEC

;TEST TSCE, TSCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=2
TSCE4:	SETUP	100,0
TSCE5:	RANDOM
	JUMPE	AC,TSCE5	;REJECT IF RAN = 0.
	CAMN	AC,[-1]		;C(AC) = -1?
	JRST	TSCE5		;YES. REJECT.
TSCE6:	SETOB	AC1,RAN1	;SET C(E) TO ALL ONES.
	TSCE	AC,AC1		;C(E)+C(AC) NOT=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSCE SKIPPED.
	TSCN	AC,AC1		;C(E)+C(AC) NOT=0, SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIGINAL C(AC)
	ERR	RAN1,RAN
	LOOP	TSCE5,TSCE6

;TEST TSCE, TSCN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1.

	AC=3
TSCED:	SETUP	100,0
TSCEE:	RANDOM
	JUMPE	AC,TSCEE	;REJECT IF RAN = 0.
TSCEF:	SETOB	AC1,RAN1	;SET C("AC") TO ALL ONES.
	TSCE	AC1,AC		;C(E)+C(AC) NOT=0,NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSCE SKIPPED.
	TSCE	AC1,AC		;C(E) + C(AC) = 0. SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC,RAN1
	SETO	AC1,		;RESTORE C(AC).
	TSCN	AC1,AC		;C(E) + C(AC) NOT = 0..SKIP.
	ER	AC1,[ASCII /TST/]
	TSCN	AC1,AC		;C(E) + C(AC) = 0..NO SKIP.
	CAME	AC1,[-1]	;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC,RAN1
	LOOP	TSCEE,TSCEF

;TEST TSCE, TSCN.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR NOT RAN TO RAN
;CONDITION

	AC=4
TSCN1:	SETUP	100,0
TSCN2:	RANDOM
	JUMPE	AC,TSCN2	;REJECT IF C("AC") = 0.
TSCN3:	MOVS	AC1,AC		;MAKE C(E) =
	SETCA	AC1,		;COMP OF C(AC).
	JUMPE	AC1,TSCN2	;REJECT IF E = 0.
	TSCN	AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TSCN SKIPPED.
	TSCN	AC,AC1		;C(E) + C(AC) NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC1,RAN
	TSCE	AC,AC1		;C(E) + C(AC) = 0...SKIP.
	ER	AC,[ASCII /TST/]
	TSCE	AC,AC1		;C(E) + C(AC) NOT = 0...NO SKIP.
	CAME	AC,RAN		;C(AC) SHOULD=ORIGINAL C(AC)
	ERR	AC1,RAN
	LOOP	TSCN2,TSCN3

;TEST TSCE, TSCN.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR RAN TO RAN
;CONDITION

	AC=5
TSCNA:	SETUP	100,0
TSCNB:	RANDOM
	JUMPE	AC,TSCNB	;REJECT IF RAN = 0.
TSCNC:	MOVE	AC1,AC		;MAKE C("E") = C("AC").
	MOVS	AC2,AC		;MAKE SURE
	AND	AC2,AC		;AND CONDITION
	JUMPE	AC2,TSCNB	;DOESN'T = 0.
	XOR	AC2,AC		;ALSO HALVES NOT =.
	JUMPE	AC2,TSCNB	;REJECT IF 0.
	TSCE	AC,AC1		;C(E)+C(AC) NOT=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSCE SKIPPED.
	TSCN	AC,AC1		;C(E)+C(AC) NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIGINAL C(AC)
	ERR	AC1,RAN
	LOOP	TSCNB,TSCNC

;TEST TSO,TSOA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=6
TSO1:	SETUP	100,0
TSO2:	RANDOM
TSO3:	SETZB	AC1,RAN1	;CLEAR C("E").
	MOVE	AC2,AC		;SIMULATE
	ROT	AC2,22		;A TSO
	TSO	AC1,AC		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSO SKIPPED.
	TSOA	AC1,AC		;SHOULD SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD=SIM ANS
	ERR	AC,RAN1
	LOOP	TSO2,TSO3

;TEST TSO, TSOA.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=7
TSO4:	SETUP	100,0
TSO5:	RANDOM
TSO6:	SETZ	AC1,		;CLEAR C(E).
	TSO	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSO SKIPPED.
	TSOA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT HAVE CHANGED.
	ERR	AC1,RAN
	LOOP	TSO5,TSO6

;TEST TSO,TSOA.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION
;C(RAN1)=C(RAN) SWAPPED

	AC=10
TSO7:	SETUP	100,0
TSO8:	RANDOM
TSO9:	MOVS	AC1,AC		;MAKE C("E")=C("AC") SWAPPED
	TSO	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSO SKIPPED.
	TSOA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIGINAL C(AC)
	ERR	AC1,RAN
	LOOP	TSO8,TSO9

;TEST TSO, TSOA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=11
TSOA1:	SETUP	100,0
TSOA2:	RANDOM
TSOA3:	MOVE	AC1,AC		;MAKE C("E")=C("AC")
	MOVS	AC2,AC1		;SIMULATE
	MOVE	AC3,AC		;A
	IOR	AC3,AC2		;TSO
	TSO	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSO SKIPPED.
	TSOA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC3		;C(AC) = SIM. ANS?
	ERR	AC1,AC1		;NO.
	LOOP	TSOA2,TSOA3

;TEST TSOE, TSON.  CHECK FOR SKIP/NO SKIP
;AND CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=12
TSOE1:	SETUP	100,0
TSOE2:	RANDOM
TSOE3:	SETZB	AC1,RAN1	;CLEAR C(E).
	TSON	AC,AC1		;C(E)+C(AC)=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSON SKIPPED.
	TSOE	AC,AC1		;C(E)+C(AC)=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIGINAL C(AC)
	ERR	RAN1,RAN
	LOOP	TSOE2,TSOE3

;TEST TSOE, TSON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=13
TSOEA:	SETUP	100,0
TSOEB:	RANDOM
	JUMPE	AC,TSOEB	;REJECT IF RAN = 0.
TSOEC:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVS	AC2,AC		;SIMULATE TSO
	TSON	AC1,AC		;C(E)+C(AC)=0. NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSON SKIPPED.
	TSON	AC1,AC		;C(E)+C(AC)NOT = 0. SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD=SIM ANS
	ERR	AC,RAN1
	SETZ	AC1,		;CLEAR C(AC)
	TSOE	AC1,AC		;C(E)+C(AC)=0. SKIP
	ER	AC1,[ASCII /TST/]
	TSOE	AC1,AC		;C(E)+C(AC)NOT=0. NO SKIP
	CAME	AC1,AC2		;C(AC)=SIM ANS?
	ERR	AC,RAN1		;NO
	LOOP	TSOEB,TSOEC

;TEST TSOE, TSON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=14
TSOE4:	SETUP	100,0
TSOE5:	RANDOM
	JUMPE	AC,TSOE5	;REJECT IF RAN= 0.
TSOE6:	SETOB	AC1,RAN1	;MAKE C(E) = -1.
	TSOE	AC,AC1		;C(E)+C(AC) NOT=0. NO SKIP
	CAME	AC,[-1]		;C(AC) SHOULD=-1
	ERR	RAN1,RAN
	MOVE	AC,RAN		;RESTORE AC
	TSON	AC,AC1		;C(E)+C(AC) NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,[-1]		;C(AC) SHOULD=-1
	ERR	RAN1,RAN
	LOOP	TSOE5,TSOE6

;TEST TSOE, TSON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION

	AC=15
TSOED:	SETUP	100,0
TSOEE:	RANDOM
	JUMPE	AC,TSOEE	;REJECT IF RAN = 0.
TSOEF:	SETOB	AC1,RAN1	;SET C(AC) TO A -1.
	TSOE	AC1,AC		;C(E)+C(AC) NOT=0. NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSOE SKIPPED.
	TSON	AC1,AC		;C(E)+C(AC) NOT=0. SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD STILL = -1.
	ERR	AC,RAN1
	LOOP	TSOEE,TSOEF

;TEST TSOE, TSON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION

	AC=6
TSON1:	SETUP	100,0
TSON2:	RANDOM
TSON3:	SETCM	AC1,AC		;MAKE C(E) = COMP OF C(AC)
	MOVS	AC1,AC1		;SWAPPED.
	TSON	AC,AC1		;C(E)+C(AC)=0. NO SKIP
	CAME	AC,[-1]		;C(AC) SHOULD=-1
	ERR	AC1,RAN
	MOVE	AC,RAN		;RESTORE AC.
	TSOE	AC,AC1		;C(E)+C(AC)=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,[-1]		;C(AC) SHOULD=-1
	ERR	AC1,RAN
	LOOP	TSON2,TSON3

;TEST TSOE, TSON.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=7
TSONA:	SETUP	100,0
TSONB:	RANDOM
	JUMPE	AC,TSONB	;REJECT IF RAN = 0.
TSONC:	MOVS	AC1,AC		;MAKE C(E) = C(AC) SWAPPED.
	TSOE	AC,AC1		;C(E)+C(AC) NOT=0 NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSOE SKIPPED.
	TSON	AC,AC1		;C(E)+C(AC)) NOT=0 SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=C(ORIG. AC)
	ERR	AC1,RAN
	LOOP	TSONB,TSONC

;TEST TSZ, TSZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=10
TSZ1:	SETUP	100,0
TSZ2:	RANDOM
TSZ3:	SETZ	AC1,		;CLEAR C(E)
	TSZ	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSZ SKIPPED.
	TSZA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIGINAL C(AC)
	ERR	AC1,RAN
	LOOP	TSZ2,TSZ3

;TEST TSZ, TSZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=11
TSZ4:	SETUP	100,0
TSZ5:	RANDOM
TSZ6:	SETZB	AC1,RAN1	;CLEAR C(AC).
	TSZ	AC1,AC		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSZ SKIPPED.
	TSZA	AC1,AC		;SHOULD SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD STILL=0
	ERR	AC,RAN1
	LOOP	TSZ5,TSZ6

;TEST TSZ, TSZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION
;RAN1=C(RAN) SWAPPED

	AC=2
TSZ7:	SETUP	100,0
TSZ8:	RANDOM
TSZ9:	MOVS	AC1,AC		;MAKE C(E)=C(AC) SWAPPED
	TSZ	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSZ SKIPPED.
	TSZA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERR	AC1,RAN
	LOOP	TSZ8,TSZ9

;TEST TSZ, TSZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=3
TSZA1:	SETUP	100,0
TSZA2:	RANDOM
TSZA3:	MOVE	AC1,AC		;MAKE C(E)=C(AC)
	MOVE	AC2,AC		;SIMULATE
	MOVS	AC3,AC		;A
	ORCM	AC2,AC3		;TSZ
	SETCA	AC2,		;INST
	MOVS	AC2,AC2
	TSZ	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSZ SKIPPED.
	TSZA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	ERR	AC1,RAN
	LOOP	TSZA2,TSZA3

;TEST TSZE,TSZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=4
TSZE1:	SETUP	100,0
TSZE2:	RANDOM
TSZE3:	SETZ	AC1,		;CLEAR C(E)
	TSZN	AC,AC1		;C(E)+C(AC)=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSZN SKIPPED.
	TSZE	AC,AC1		;C(E)+C(AC)=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	ERR	AC1,RAN
	LOOP	TSZE2,TSZE3

;TEST TSZE,TSZN.  CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=5
TSZEA:	SETUP	100,0
TSZEB:	RANDOM
TSZEC:	SETZB	AC1,RAN1	;CLEAR C(AC).
	TSZN	AC1,AC		;C(E)+C(AC)=0. NO SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSZN SKIPPED.
	TSZE	AC1,AC		;C(E)+C(AC)=0 SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD STILL = 0
	ERR	AC,RAN1
	LOOP	TSZEB,TSZEC

;TEST TSZE, TSZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION.

	AC=6
TSZE4:	SETUP	100,0
TSZE5:	RANDOM
	JUMPE	AC,TSZE5	;REJECT IF RAN = 0.
TSZE6:	SETO	AC1,		;SET C("E") TO ALL ONES.
	TSZE	AC,AC1		;C(E)+C(AC) NOT=0. NO SKIP
	CAME	AC,[0]		;C(AC) SHOULD HAVE BEEN CLEARED
	ERR	AC1,RAN
	MOVE	AC,RAN		;RESTORE AC
	TSZN	AC,AC1		;C(E)+C(AC) NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,[0]		;C(AC) SHOULD HAVE BEEN CLEARED
	ERR	AC1,RAN
	LOOP	TSZE5,TSZE6

;TEST TSZE, TSZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION

	AC=7
TSZED:	SETUP	100,0
TSZEE:	RANDOM
	JUMPE	AC,TSZEE	;REJECT IF RAN = 0.
TSZEF:	SETOB	AC1,RAN1	;SET C(AC) TO A -1.
	MOVS	AC2,AC		;SIMULATE
	XOR	AC2,AC1		;A TSZ
	TSZE	AC1,AC		;C(E)+C(AC) NOT=0. NO SKIP
	CAME	AC1,AC2		;C(AC) SHOULD=SIM ANS
	ERR	AC,RAN1
	SETO	AC1,		;RESTORE AC
	TSZN	AC1,AC		;(E)+C(AC) NOT=0 SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD=SIM ANS
	ERR	AC,RAN1
	LOOP	TSZEE,TSZEF

;TEST TSZE, TSZN, CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION

	AC=10
TSZN1:	SETUP	100,0
TSZN2:	RANDOM
TSZN3:	SETCM	AC1,AC		;MAKE C("E") = COMP C("AC").
	MOVS	AC1,AC1		;SWAPPED.
	TSZN	AC,AC1		;C(E)+C(AC)=0 NO. SKIP
	CAME	AC,RAN		;C(AC) SHOULD=C(AC) BEFORE TOZ
	ERR	AC1,RAN
	TSZE	AC,AC1		;C(E) +C(AC)=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC)SHOULD=C(AC)BEFORE TOZ
	ERR	AC1,RAN
	LOOP	TSZN2,TSZN3

;TEST TSZE, TSZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=11
TSZNA:	SETUP	100,0
TSZNB:	RANDOM
	JUMPE	AC,TSZNB	;REJECT IF RAN = 0.
TSZNC:	MOVS	AC1,AC		;MAKE C("E") = C("AC") SWAPPED.
	TSZE	AC,AC1		;C(E)+C(AC) NOT=0 NO SKIP.
	CAME	AC,[0]		;C(AC) SHOULD BE ZEROED OUT.
	ERR	AC1,RAN
	MOVE	AC,RAN		;RESTORE AC
	TSZN	AC,AC1		;C(E)+C(AC)NOT=0. SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,[0]		;C(AC) SHOULD BE ZEROED OUT.
	ERR	AC1,RAN
	LOOP	TSZNB,TSZNC

;TEST TSN, TSNA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION.

	AC=12
TSN1:	SETUP	100,0
TSN2:	RANDOM
TSN3:	SETZ	AC1,		;CLEAR C("E")
	TSN	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSN SKIPPED.
	TSNA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC)SHOULD NOT CHANGE
	ERR	AC1,RAN
	LOOP	TSN2,TSN3

;TEST TSN, TSNA CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=13
TSN4:	SETUP	100,0
TSN5:	RANDOM
TSN6:	SETZB	AC1,RAN1	;CLEAR C("AC").
	TSN	AC1,AC		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSN SKIPPED.
	TSNA	AC1,AC		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC1,RAN1	;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC,RAN1
	LOOP	TSN5,TSN6

;TEST TSN, TSNA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=14
TSN7:	SETUP	100,0
TSN8:	RANDOM
TSN9:	MOVS	AC1,AC		;MAKE C("E")=C("AC") SWAPPED
	TSN	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSN SKIPPED.
	TSNA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC)SHOULD NOT CHANGE
	ERR	AC1,RAN
	LOOP	TSN8,TSN9

;TEST TSN, TSNA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION
;RAN1=RAN BEFORE TSN

	AC=15
TSNA1:	SETUP	100,0
TSNA2:	RANDOM
TSNA3:	MOVE	AC1,AC		;MAKE C("E")=C("AC")
	TSN	AC,AC1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSN SKIPPED.
	TSNA	AC,AC1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	ERR	AC1,RAN
	LOOP	TSNA2,TSNA3

;TEST TSNE, TSNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=6
TSNE1:	SETUP	100,0
TSNE2:	RANDOM
TSNE3:	SETZ	AC1,		;CLEAR C("E").
	TSNN	AC,AC1		;C(E)+C(AC)=0.  NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TSNN SKIPPED.
	TSNE	AC,AC1		;C(E)+C(AC)=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	ERR	AC1,RAN
	LOOP	TSNE2,TSNE3

;TEST TSNE, TSNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION.

	AC=7
TSNEA:	SETUP	100,0
TSNEB:	RANDOM
TSNEC:	SETZB	AC1,RAN1	;CLEAR C("AC").
	TSNN	AC1,AC		;C(E)+C(AC)=0.  NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSNN SKIPPED.
	TSNE	AC1,AC		;C(E)+C(AC)=0.  SKIP
	ER	AC1,[ASCII /TST/]
	CAME	AC1,RAN1	;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC,RAN1
	LOOP	TSNEB,TSNEC

;TEST TSNE, TSNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=10
TSNE4:	SETUP	100,0
TSNE5:	RANDOM
TSNE6:	JUMPE	AC,TSNE5	;REJECT IF RAN = 0.
	SETO	AC1,		;SET C("E") TO A-1.
	TSNE	AC,AC1		;C(E)+C(AC) NOT=0. NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TSNE SKIPPED.
	TSNN	AC,AC1		;C(E)+C(AC) NOT=0. SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC)SHOULD NOT CHANGE.
	ERR	AC1,RAN
	LOOP	TSNE5,TSNE6

;TEST TSNE, TSNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION

	AC=11
TSNED:	SETUP	100,0
TSNEE:	RANDOM
	JUMPE	AC,TSNEE	;REJECT IF RAN = 0.
TSNEF:	SETOB	AC1,RAN1	;SET C("AC") TO A -1.
	TSNE	AC1,AC		;C(E)+C(AC) NOT=0. NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TSNE SKIPPED.
	TSNN	AC1,AC		;C(E)+C(AC) NOT=0. SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,RAN1	;C(AC) SHOULD = ORIG. C(AC).
	ERR	AC,RAN1
	LOOP	TSNEE,TSNEF

;TEST TSNE, TSNN  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION

	AC=2
TSNN1:	SETUP	100,0
TSNN2:	RANDOM
	JUMPE	AC,TSNN2	;REJECT IF RAN = 0.
TSNN3:	MOVS	AC1,AC		;MAKE C(E) =
	SETCA	AC1,		;COMP C(AC).
	TSNN	AC,AC1		;C(E) + C(AC) = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TSNN SKIPPED.
	TSNE	AC,AC1		;C(E) + C(AC) = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC)SHOULD NOT CHANGE
	ERR	AC1,RAN
	LOOP	TSNN2,TSNN3

;TEST TSNE, TSNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=3
TSNNA:	SETUP	100,0
TSNNB:	RANDOM
	MOVS	AC2,AC		;MAKE SURE
	AND	AC2,AC		;AND CONDITION
	JUMPE	AC2,TSNNB	;DOESN'T = 0.
TSNNC:	MOVE	AC1,AC		;MAKE C("E") = C("AC").
	TSNE	AC,AC1		;C(E)+C(AC)NOT=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TSNE SKIPPED.
	TSNN	AC,AC1		;C(E)+C(AC)NOT=0. SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	ERR	AC1,RAN
	LOOP	TSNNB,TSNNC

;TEST SKIP, SKIPA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN C(E) AND C(AC)=C(E) AFTER SKIP
;ALSO CHECK FOR OVERFLOW FLAG NOT BEING SET.

	AC=4
SKIP1:	SETUP	100,0
SKIP2:	RANDOM
SKIP3:	JFCL	10,.+1		;CLEAR OV FLAG
	MOVE	RAN1,AC1	;SAVE C(AC) IN CASE OF ERROR.
	SKIP	AC1,AC		;SHOULD NOT SKIP
	SKIPA	AC1,AC		;SHOULD SKIP
	ER	AC,[ASCII /SKP/]
	JFCL	10,.+2		;OV FLAG GET SET?
	JRST	.+2		;NO
	ER	AC,[ASCII /AROV/];YES..SHOULD NOT GET SET ON SKIP INST.
	CAME	AC,RAN		;C(E) SHOULD NOT HAVE CHANGED
	ERR	AC,RAN1
	CAME	AC1,RAN		;C(AC) SHOULD =C(E).
	ERR	AC,RAN1
	LOOP	SKIP2,SKIP3

;TEST SKIPE, SKIPN. CHECK FOR SKIP/ NO SKIP,
;CORRECT DATA IN C(E) AND C(AC)=C(E) AFTER SKIP.

	AC=5
SKIPE1:	SETUP	100,0
	MOVEI	AC1,1		;SETUP C(E) FOR A  FLOATING ONE
SKIPE2:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	MOVE	AC2,AC1		;SAVE FLOATING ONE BIT
SKIPE3:	MOVE	AC1,AC2		;RESTORE C(5) IN CASE OF ERROR
	SKIPE	AC,AC1		;SHOULD NOT SKIP
	SKIPN	AC,AC1		;SHOULD SKIP
	ER	AC1,[ASCII /SKP/]
	CAME	AC1,AC2		;C(E) SHOULD NOT CHANGE
	ERR	AC2,RAN
	CAME	AC,AC2		;C(AC) SHOULD= C(E)
	ERR	AC2,RAN
	LOOP	SKIPE2,SKIPE3


;TEST SKIPN, SKIPE. CHECK FOR SKIP/ NO SKIP,
;CORRECT DATA IN C(E) AND C(AC) = C(E) AFTER SKIP.
;C(AC) = RAN. NUM. AND C(E) = 0.

	AC=3
SKIPN1:	SETUP	100,0
SKIPN2:	RANDOM
SKIPN3:	SETZB	AC1,RAN1	;CLEAR C(E).
	SKIPN	AC,AC1		;C(E) = 0...NO SKIP.
	SKIPE	AC,AC1		;C(E) = 0...SKIP.
	ER	AC1,[ASCII /SKP/]
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	ERR	RAN1,RAN
	CAME	AC1,RAN1	;C(E) SHOULD STILL = 0.
	ERR	RAN1,RAN
	LOOP	SKIPN2,SKIPN3


;TEST SKIPG, SKIPL.  CHECK FOR SKIP/NO SKIP,
;CORRECT DATA IN C(E), AND C(AC)=C(E)AFTER SKIP,
;BY ROTATING A BIT IN E.

	AC=6
SKIPG1:	SETUP	100,0
	MOVEI	AC1,1		;SETUP AC1 FOR FLOATING ONE.
SKIPG2:	RANDOM
	ROT	AC1,1		;ROT AC1 TO TEST NEXT BIT.
	CAMN	AC1,[XWD 400000,0];IS SIGN BIT SET?
	ROT	AC1,1		;YES.  ROT AGAIN
	MOVE	AC2,AC1		;SAVE FLOATING ONE IN AC2.
SKIPG3:	MOVE	AC1,AC2		;RESTORE AC1 IN CASE OF ERROR
	SKIPL	AC,AC1		;SHOULD NOT SKIP.
	SKIPG	AC,AC1		;SKIPG SHOULD SKIP
	ER	AC,[ASCII /SKP/]
	CAME	AC1,AC2		;NOT CHANGE C(E),
	ERR	AC2,RAN
	CAME	AC,AC2		;AND PUT C(E) INTO AC.
	ERR	AC2,RAN
	LOOP	SKIPG2,SKIPG3

;TEST SKIPG, SKIPL.  CHECK FOR SKIP/NO SKIP,
;CORRECT DATA IN C(E), AND C(AC)=C(E) AFTER SKIP,
;BY USEING A NEGATIVE RANDOM NUMBER IN E.

	AC=7
SKIPL1:	SETUP	100,0
SKIPL2:	RANDOM
SKIPL3:	CAML	AC,[0]		;RAN A POSITIVE NUMB
	SETCA	AC,		;YES, COMP TO MAKE IT NEG
	MOVE	AC2,AC		;SAVE AC FOR FUTURE COMPARE
	MOVEM	AC1,RAN1	;SAVE AC1 IN CASE OF ERROR.
	SKIPG	AC1,AC		;SHOULD NOT SKIP
	SKIPL	AC1,AC		;C(E)IS NEG. SHOULD SKIP
	ER	AC,[ASCII /SKP/]
	CAME	AC,AC2		;C(E) SHOULD NOT HAVE CHANGED
	ERR	AC2,RAN1
	CAME	AC1,AC2		;C(AC) SHOULD BE =TO C(E)
	ERR	AC2,RAN1
	LOOP	SKIPL2,SKIPL3

;TEST SKIPGE, SKIPL. CHECK FOR SKIP/NO SKIP,
;C(E) NOT CHANGING, AND C(AC)=C(E) AFTER SKIP,
;BY MAKEING C(E) POSITIVE AND THEN 0

	AC=10
SKPGE1:	SETUP	100,0
SKPGE2:	RANDOM
SKPGE3:	CAMGE	AC,[0]		;RAN POSITIVE?
	SETCA	AC,		;NO.  COMP AND MAKE IT POSITIVE
	MOVE	AC2,AC		;SAVE FOR FUTURE COMPARE
	MOVEM	AC1,RAN1	;SAVE AC1 IN CASE OF ERROR.
	SKIPL	AC1,AC		;C(E) IS POS  SHOULD NOT SKIP
	SKIPGE	AC1,AC		;C(E) IS POSITIVE.  SHOULD SKIP
	ER	AC,[ASCII /SKP/]
	CAME	AC,AC2		;C(E) SHOULD NOT HAVE CHANGED
	ERR	AC2,RAN1
	CAME	AC1,AC2		;C(AC)SHOULD=C(E)
	ERR	AC2,RAN1
	SETZ	AC,		;CLEAR C(E)
	SKIPL	AC1,AC		;C(E)=0...SHOULD NOT SKIP
	SKIPGE	AC1,AC		;C(E)=0...SHOULD SKIP
	ER	AC,[ASCII /SKP/]
	CAME	AC,[0]		;C(E) SHOULD STILL=0
	ERR	AC,AC2
	CAME	AC1,[0]		;C(AC) SHOULD NOW=0
	ERR	AC,AC2
	LOOP	SKPGE2,SKPGE3
;TEST SKIPG, SKIPLE.  CHECK FOR SKIP/NO SKIP,
;C(E) NOT CHANGING AND C(AC)=C(E) AFTER SKIP,
;BY MAKING C(E) NEGATIVE OR 0.

	AC=11
SKPLE1:	SETUP	100,0
SKPLE2:	RANDOM
SKPLE3:	CAMLE	AC,[0]		;RAN NEG OR 0?
	SETCA	AC,		;NO. MAKE IT NEG
	MOVE	RAN1,AC1	;SAVE AC1 IN CASE OF ERROR.
	MOVE	AC2,AC		;SAVE FOR FUTURE COMPARE
	SKIPG	AC1,AC		;C(E) NEG OR 0...SHOULD NOT SKIP
	SKIPLE	AC1,AC		;C(E) NEG OR 0... SHOULD SKIP
	ER	AC,[ASCII /SKP/]
	CAME	AC,AC2		;C(E) SHOULD NOT CHANGE
	ERR	AC2,RAN1
	CAME	AC1,AC2		;C(AC) SHOULD=C(E)
	ERR	AC2,RAN1
	SETZ	AC,		;CLEAR C(E)
	SKIPG	AC1,AC		;C(E)=0...SHOULD NOT SKIP
	SKIPGE	AC1,AC		;C(E)=0.. SHOULD SKIP
	ER	AC,[ASCII /SKP/]
	CAME	AC,[0]		;C(E) SHOULD STILL=0
	ERR	AC,AC2
	CAME	AC1,[0]		;C(AC) SHOULD=0
	ERR	AC,AC2
	LOOP	SKPLE2,SKPLE3

;TEST SKIPLE, SKIPGE. CHECK FOR SKIP/ NO SKIP,
;C(E) NOT CHANGING, AND COORECT STORING
;OF C(E) INTO AC FOR C(E) = POSITIVE RAN. NUM.

	AC=12
SKPLEA:	SETUP	100,0
SKPLEB:	RANDOM
	JUMPE	AC,SKPLEB	;REJECT IF RAN = 0.
SKPLEC:	SETOB	AC1,RAN1	;SET C(AC) TO ALL ONES.
	AND	AC,[XWD 377777,-1];MAKE SURE C(E) IS POS.
	MOVE	AC2,AC		;SAVE C(E) FOR FUTURE COMPARE.
	SKIPLE	AC1,AC		;C(E) IS POS...NO SKIP.
	SKIPGE	AC1,AC		;C(E) IS POS...SKIP.
	ER	AC,[ASCII/SKP/]
	CAME	AC1,AC		;C(AC) SHOULD = C(E).
	ERR	AC2,RAN1
	CAME	AC,AC2		;C(E) SHOULD = ORIG C(E).
	ERR	AC2,RAN1
	LOOP	SKPLEB,SKPLEC


;TEST JUMP, JUMPA. CHECK FOR JUMP/ NO JUMP AND
;NO MODIFICATION OF C(AC) FOR C(AC)=RANDOM NUMBER

	AC=12
JMP1:	SETUP	100,0
JMP2:	RANDOM
JMP3:	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	JUMP	AC,.+2		;SHOULD NOT JUMP.
	JUMPA	AC,.+2		;SHOULD JUMP.
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN		;C(AC) SHOULD STILL=RAN.
	ERRI	RAN1,.-1
	LOOP	JMP2,JMP3

;TEST JUMPE, JUMPN. CHECK FOR JUMP/ NO JUMP AND
;NO MODIFICATION OF C(AC) WITH C(AC) = TO A FLOATING ONE.

	AC=13
JMPE1:	SETUP	100,0
	MOVEI	AC,1		;SETUP AC FOR FLOATING ONE.
JMPE2:	ROT	AC,-1		;ROT TO TEST NEXT BIT
	MOVE	RAN1,AC		;SAVE FOR FUTURE COMPARE.
JMPE3:	MOVE	AC,RAN1		;RESTORE C(AC) IN CASE OF ERROR.
	JUMPE	AC,.+2		;SHOULD NOT JUMP
	JUMPN	AC,.+2		;SHOULD JUMP
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,.-1
	SOJG	AC-1,JMPE2	;ITERATION COUNTER.
	JUMPL	AC-1,JMPE3	;LOOP ON ERROR SWITCH.


;TEST JUMPN, JUMPE. CHECK FOR JUMP/ NO JUMP AND
;NO MODIFICATION OF C(AC) WITH C(AC) = 0.

	AC=14
JMPN1:	SETUP	100,0
JMPN2:	SETZB	AC,RAN1		;CLEAR C(AC).
	JUMPN	AC,.+2		;C(AC) = 0...NO JUMP.
	JUMPE	AC,.+2		;C(AC) = 0...JUMP.
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN1		;C(AC) SHOULD STILL = 0.
	SOJG	AC-1,JMPN2	;ITERATION COUNTER.
	JUMPL	AC-1,JMPN2	;LOOP ON ERROR SWITCH.


;TEST JUMPL, JUMPG. CHECK FOR JUMP/ NO JUMP 
;AND NO MODIFICATION OF C(AC) WITH C(AC)=TO A FLOATING ONE
;WITH SIGN BIT SET.

	AC=14
JMPL1:	SETUP	100,0
	MOVE	AC,[XWD 400000,1];SETUP AC FOR FLOATING ONE BIT
JMPL2:	XOR	AC,[XWD 400000,0];CLEAR SIGN BIT FOR ROT.
JMPL3:	ROT	AC,1		;ROT TO TEST NEXT BIT.
	IOR	AC,[XWD 400000,0];SET SIGN BIT
	MOVEM	AC,RAN1		;SAVE AC FOR FUTURE COMPARE.
JMPL4:	MOVE	AC,RAN1		;RESTORE C(AC) IN CASE OF ERROR.
	JUMPG	AC,.+2		;SHOULD NOT JUMP.
	JUMPL	AC,.+2		;SHOULD JUMP.
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,.-1
	CAMN	RAN1,[XWD 400000,0];IS FLOATING ONE THE SIGN BIT?
	JRST	JMPL3		;YES. ROT AND SET SIGN BIT.
	SOJG	AC-1,JMPL2	;ITERATION COUNTER.
	JUMPL	AC-1,JMPL4	;LOOP ON ERROR SWITCH.

;TEST JUMPG, JUMPL. CHECK FOR JUMP/ NO JUMP
;AND NO MODIFICATION OF C(AC) WITH A FLOATING ONE
;AND SIGN BIT NEVER SET.

	AC=15
JMPG1:	SETUP	100,0
	MOVEI	AC,1		;SETUP AC FOR FLOATING ONE BIT
JMPG2:	ROT	AC,1		;ROT TO TEST NEXT BIT.
	CAMN	AC,[XWD 400000,0];IS BIT IN SIGN POSITION?
	ROT	AC,1		;YES, ROT AGAIN
	MOVE	RAN1,AC		;SAVE FOR FUTURE COMPARE.
JMPG3:	MOVE	AC,RAN1		;RESTORE C(AC) IN CASE OF ERROR.
	JUMPL	AC,.+2		;SHOULD NOT JUMP.
	JUMPG	AC,.+2		;SHOULD JUMP.
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,.-1
	SOJG	AC-1,JMPG2	;ITERATION COUNTER.
	JUMPL	AC-1,JMPG3	;LOOP ON ERROR SWITCH.

;TEST JUMPGE, JUMPL. CHECK FOR JUMP/ NO JUMP
;AND NO MODIFICATION OF C(AC) WITH C(AC)=TO A FLOATING
;ONE WITH SIGN BIT NEVER SET.

	AC=6
JMPGE1:	SETUP	100,0
	MOVEI	AC,1		;SETUP AC FOR FLOATING ONE BIT
JMPGE2:	ROT	AC,1		;ROT TO TEST NEXT BIT
	CAMN	AC,[XWD 400000,0];SIGN BIT SET?
	ROT	AC,1		;YES. ROT AGAIN
	MOVEM	AC,RAN1		;SAVE AC FOR FUTURE COMPARE.
	JUMPL	AC,.+2		;C(AC) IS POSITIVE AND SHOULD NOT JUMP.
JMPGE3:	JUMPGE	AC,.+2		;SHOULD JUMP.
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,.-1
	SETZB	AC,AC1		;CLEAR C(AC).
	JUMPL	AC,.+2		;C(E) IS POSITIVE...SHOULD NOT JUMP
	JUMPGE	AC,.+2		;SHOULD JUMP
	ER	AC,[ASCII /JMP/]
	CAME	AC,AC1		;C(AC) SHOULD STILL = 0.
	ERRI	AC1,.-1
	SOJG	AC-1,JMPGE2	;ITERATION COUNTER.
	MOVE	AC,RAN1		;RESTORE C(AC).
	JUMPL	AC-1,JMPGE3	;LOOP ON ERROR SWITCH.

;TEST JUMPG, JUMPLE. CHECK FOR JUMP/ NO JUMP
;AND NO MODIFICATION OF C(AC) WITH C(AC)=FLOATING ONE
;WITH SIGN BIT SET

	AC=7
JMPLE1:	SETUP	100,0
	MOVE	AC,[XWD 400000,1];SETUP AC FOR FLOATING ONE AND SIGN BITS SET.
JMPLE2:	XOR	AC,[XWD 400000,0];CLEAR SIGN BIT.
	ROT	AC,1		;ROT TO TEST NEXT BIT.
	IOR	AC,[XWD 400000,0];SET SIGN BIT
	MOVEM	AC,RAN1		;SAVE C(AC) FOR FUTURE COMPARE.
JMPLE3:	JUMPG	AC,.+2		;C(AC) IS NEG...SHOULD NOT JUMP.
	JUMPLE	AC,.+2		;SHOULD JUMP.
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,.-1
	SETZB	AC,AC1		;CLEAR C(AC).
	JUMPG	AC,.+2		;C(AC) =0.  SHOULD NOT JUMP
	JUMPLE	AC,.+2		;SHOULD JUMP
	ER	AC,[ASCII /JMP/]
	CAME	AC,AC1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	AC1,.-1
	CAMN	RAN1,[XWD 400000,0];JUST THE SIGN BIT SET?
	MOVE	AC,[XWD 400000,1];YES. REINITIALIZE NUMBER.
	SOJG	AC-1,JMPLE2	;ITERATION COUNTER.
	MOVE	AC,RAN1		;RESTORE C(AC).
	JUMPL	AC-1,JMPLE3	;LOOP ON ERROR SWITCH.


;TEST JUMPLE, JUMPGE. CHECK FOR JUMP/ NO JUMP
;AND NO MODIFICATION OF C(AC) FOR C(AC) = POS. RAN. NUM.

	AC=10
JMPLEA:	SETUP	100,0
JMPLEB:	RANDOM
	JUMPE	AC,JMPLEB	;REJECT IF RAN = 0.
JMPLEC:	AND	AC,[XWD 377777,-1];MAKE SURE C(AC) IS POS.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	JUMPLE	AC,.+2		;C(AC) IS POS...NO JUMP.
	JUMPGE	AC,.+2		;C(AC) IS POS...JUMP.
	ER	AC,[ASCII /JMP/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	RAN1,.-1
	LOOP	JMPLEB,JMPLEC

;TEST AOS,AOSA.  CHECK FOR SKIP/NO SKIP,
;CORRECT DATA IN C(E), AND PROPER LOADING OF C(E) INTO
;C(AC) FOR C(E)=TO RAN
;ALSO CHECK PROPER SETTING OF CRY0, CRY1, AND OVERFLOW FLAGS.

	AC=11
AOS1:	SETUP	100,0
AOS2:	RANDOM
AOS3:	MOVE	AC3,RAN		;SAVE C(E) IN CASE OF ERROR.
	JFCL	17,.+1		;CLEAR THE FLAGS.
	MOVE	RAN1,AC1	;SAVE C(AC) FOR FUTURE COMPARE.
	MOVE	AC2,AC		;SIMULATE
	ADD	AC2,[2]		;2 AOS INST.
	AOS	AC1,AC		;SHOULD NOT SKIP
	AOSA	AC1,AC		;SHOULD SKIP
	ER	AC,[ASCII /AOS/]
	CAME	AC,AC2		;C(E) SHOULD=RAN+2.
	ERR	AC3,RAN1
	CAME	AC1,AC2		;C(AC) SHOULD=C(E)
	ERR	AC3,RAN1
	JFCL	4,CRY0B
	JFCL	2,CRY1B
	JFCL	10,.+2
	JRST	AOS4
	ER	AC1,[ASCII /OV/];OV SET WITHOUT CRY0 OR CRY1 BEING SET.
CRY0B:	CAME	AC3,[-1]
	ER	AC1,[ASCII /CRY0/];CRY0 SHOULD NOT BE SET IF RAN DOESN'T = A -1.
	JFCL	2,.+2		;IF RAN = A -1, BOTH CRY0 AND
	ER	AC1,[ASCII /CRY1/];CRY1 SHOULD BE SET.
	JFCL	10,.+2
	JRST	AOS4
	ER	AC1,[ASCII /OV/];IF BOTH CRY0 AND CRY1 ARE SET, OV SHOULD NOT.
CRY1B:	CAME	AC3,[XWD 377777,-1]
	ER	AC1,[ASCII /CRY1/]
	JFCL	10,.+2
	ER	AC1,[ASCII /OV/];IF CRY1 ONLY IS SET, OV SHOULD BE SET.
AOS4:	LOOP	AOS2,AOS3

;TEST AOSE, AOSN.  CHECK FOR SKIP/NO SKIP,
;CORRECT DATA IN C(E), AND PROPER LOADING OF
;AC WITH C(E).  TESTED WITH C(E)=1,3,7,17,37,+ETC.

	AC=2
AOSE1:	SETUP	100,0
	MOVEI	AC,1		;SETUP C("E") TO =1.
AOSE2:	MOVE	AC3,AC		;SAVE C(E) IN CASE OF ERROR.
AOSE3:	MOVE	AC,AC3		;RESTORE AC IN CASE OF ERROR.
	MOVE	AC2,AC		;SIMULATE
	ADD	AC2,[2]		;TWO AOS INST
	MOVE	RAN1,AC1	;SAVE C(AC).
	AOSE	AC1,AC		;C(E)=A POSITIVE NON ZERO NUMBER..DON'T SKIP
	AOSN	AC1,AC		;C(E)=A POSITIVE NON ZERO NUMBER ..SKIP
	ER	AC,[ASCII /AOS/]
	CAME	AC,AC2		;C(E) SHOULD=SIM ANS
	ERR	AC3,RAN1
	CAME	AC1,AC2		;C(AC) SHOULD=C(E)
	ERR	AC3,RAN1
	MOVE	AC,RAN		;RESTOR C(E)
	ROT	AC,1		;ROT TO TEST NEXT BIT.
	IOR	AC,[1]		;SET BIT 35
	SOJG	AC-1,AOSE2	;ITERATION COUNTER.
	JUMPL	AC-1,AOSE3	;LOOP ON ERROR SWITCH.


;TEST AOSG, AOSE. CHECK FOR SKIP/ NO SKIP,
;CORRECT DATA IN C(E), AND PROPER LOADING
;OR AC WITCH C(E). C(E) = -2 AND C(AC) = RAN. NUM.

	AC=11
AOSGA:	SETUP	100,0
AOSGB:	RANDOM
AOSGC:	MOVE	AC1,[XWD -1,-2]	;MAKE C(E) = -2.
	MOVE	RAN1,AC1	;SAVE C(E) IN CASE OF ERR.
	AOSG	AC,AC1		;C(E) + 1 = -1...NO SKIP.
	AOSE	AC,AC1		;C(E) + 1 = 0...SKIP.
	ER	AC1,[ASCII /AOS/]
	CAME	AC1,AC		;C(AC) SHOULD = C(E)
	ERR	RAN1,RAN
	CAME	AC1,[0]		;C(E) SHOULD = 0.
	ERR	RAN1,RAN
	LOOP	AOSGB,AOSGC


;TEST AOSL, AOSG.  CHECK FOR SKIP/NO SKIP,
;CORRECT DATA IN C(E) AND PROPER STORING
;OF C(E) INTO AC FOR C(E)=+RAN.

	AC=10
AOSL1:	SETUP	100,0
AOSL2:	RANDOM
AOSL3:	TDZ	AC,[XWD 600000,0];MAKE C(E) SO TWO AOS'S WON'T CHANGE SIGN.
	MOVE	AC3,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC2,AC		;SIMULATE
	ADD	AC2,[2]		;2 AOS'S
	MOVE	RAN1,AC1	;SAVE C(AC) IN CASE OF ERROR.
	AOSL	AC1,AC		;C(E) POSITIVE...NO SKIP
	AOSG	AC1,AC		;C(E) POSITIVE...SKIP
	ER	AC1,[ASCII /AOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER AOS.
	ERR	AC3,RAN1
	CAME	AC2,AC		;C(E) SHOULD=SIM ANS
	ERR	AC3,RAN1
	LOOP	AOSL2,AOSL3

;TEST AOSG, AOSL.  CHECK FOR SKIP/NO SKIP,
;CORRECT DATA IN C(E) AND PROPER STORING
;OF C(E) INTO AC FOR C(E) = -RAN NUM WITH END 2 BITS CLEARED

	AC=2
AOSG1:	SETUP	100,0
AOSG2:	RANDOM
AOSG3:	TDO	AC,[XWD 400000,0];MAKE C(E) BEG.
	TDZ	AC,[3]		;CLEAR 2 END BITS SO AOSL WILL ALWAYS SKIP.
	MOVE	AC3,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC2,AC		;SIMULATE
	ADD	AC2,[2]		;2 AOS'S
	MOVE	RAN1,AC1	;SAVE C(AC) IN CASE OF ERROR.
	AOSG	AC1,AC		;C(E) IS NEG...SHOULD NOT SKIP
	AOSL	AC1,AC		;C(E) IS NEG...SHOULD SKIP
	ER	AC1,[ASCII /AOS/]
	CAME	AC1,AC		;C(AC) SHOULD = C(E) AFTER AOS
	ERR	AC3,RAN1
	CAME	AC2,AC		;C(E) SHOULD = SIM ANS.
	ERR	AC3,RAN1
	LOOP	AOSG2,AOSG3

;TEST AOSLE, AOSG.  CHECK FOR SKIP/NO SKIP,
;PROPER STORING OF C(E) INTO AC, AND CORRECT
;DATA IN E FOR C(E) = FLOATING ONE

	AC=3
AOSLE1:	SETUP	100,0
AOSLE2:	MOVEI	AC,1		;SETUP C(E)=FLOATING ONE
AOSLE3:	CAMN	AC,[XWD 200000,0];C(E) = BIT 1 SET?
	MOVEI	AC,1		;YES. REINITIALIZE C(E).
	ROT	AC,1		;ROT TO TEST NEXT BIT.
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
AOSLE4:	MOVE	AC3,AC1		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC2,AC		;SIMULATE
	ADD	AC2,[2]		;2 AOS'S
	AOSLE	AC1,AC		;C(E) IS POSITIVE...NO SKIP
	AOSG	AC1,AC		;C(E) IS POSITIVE...SKIP
	ER	AC1,[ASCII /AOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER AOS
	ERR	RAN1,AC3
	CAME	AC,AC2		;C(E) SHOULD=SIM ANS
	ERR	RAN1,AC3
	MOVE	AC,RAN1		;RESTORE FLOATING ONE.
	SOJG	AC-1,AOSLE3	;ITERATION COUNTER.
	JUMPL	AC-1,AOSLE4	;LOOP ON ERROR SWITCH.

;TEST AOSG, AOSGE.  CHECK FOR SKIP/NO SKIP,
;CORRECT LOADING OF C(E) INTO AC, AND C(E)=
;CORRECT DATA.
;RAN TO RAN1

	AC=4
AOSGE1:	SETUP	100,0
AOSGE2:	MOVE	AC,[XWD -1,-2]	;MAKE C(E) = -2.
	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR.
	AOSG	AC1,AC		;C(E)+1=-1...NO SKIP
	AOSGE	AC1,AC		;C(E)+1=0...SKIP
	ER	AC1,[ASCII /AOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER AOS
	ERR	AC2,[XWD -1,-2]
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERR	AC2,[XWD -1,-2]
	SOJG	AC-1,AOSGE2	;ITERATION COUNTER.
	JUMPL	AC-1,AOSGE2	;LOOP ON ERROR SWITCH.

;TEST AOJ, AOJA. CHECK FOR JUMP/ NO JUMP AND
;CORRECT DATA IN AC FOR C(AC)=RAN.

	AC=6
AOJ1:	SETUP	100,0
AOJ2:	RANDOM
AOJ3:	MOVE	AC1,AC		;SIMULATE
	ADD	AC1,[2]		;2 AOJ'S
	AOJ	AC,.+2		;SHOULD NOT SKIP
	AOJA	AC,.+2		;SHOULD SKIP
	ER	AC,[ASCII /AOJ/]
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	EERRI	,-1
	LOOP	AOJ2,AOJ3

;TEST AOJE, AOJN. CHECK FOR JUMP/ NO JUMP AND
;C(AC) FOR CORRECT DATA WITH C(AC) = TO A FLOATING ONE

	AC=7
AOJE1:	SETUP	100,0
	MOVEI	AC,1		;SETUP AC TO CONTAIN A FLOATING ONE
AOJE2:	ROT	AC,1		;ROT TO TEST NEXT BIT
	MOVE	AC1,AC		;SAVE SO C(AC) CAN BE RESTORED
AOJE3:	MOVE	AC,AC1		;COME HERE AND RESTORE C(AC) IF ERROR
	MOVE	AC2,AC		;SIMULATE
	ADD	AC2,[2]		;2 AOJ'S
	AOJE	AC,.+2		;C(AC) NOT=0...NO SKIP
	AOJN	AC,.+2		;C(AC) NOT=0...SKIP
	ER	AC,[ASCII /AOJ/]		;
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	ERRI	AC1,.-1
	MOVE	AC,AC1		;RESTORE C(AC) BEFORE ROTATE
	SOJG	AC-1,AOJE2	;ITERATION COUNTER.
	JUMPL	AC-1,AOJE3	;LOOP ON ERROR SWITCH.


;TEST AOJG, AOJE. CHECK FOR JUMP/ NO JUMP AND
;C(AC) = CORRECT DATA WITH C(AC) = -2.

	AC=6
AOJGA:	SETUP	100,0
AOJGB:	MOVE	AC,[XWD -1,-2]	;MAKE C(AC) = -2.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	AOJG	AC,.+2		;C(AC) + 1 = -1...NO JUMP.
	AOJE	AC,.+2		;C(AC) + 1 = 0...JUMP.
	ER	AC,[ASCII /AOJ/]
	CAME	AC,[0]		;C(AC) SHOULD = 0.
	ERRI	RAN1,.-1
	SOJG	AC-1,AOJGB	;ITERATION COUNTER.
	JUMPL	AC-1,AOJGB	;LOOP ON ERROR SWITCH.


;TEST AOJL, AOJG.  CHECK FOR JUMP/NO JUMP AND
;C(AC)=CORRECT DATA FOR C(AC)=RAN

	AC=10
AOJL1:	SETUP	100,0
AOJL2:	RANDOM
AOJL3:	TDZ	AC,[XWD 600000,0];MAKE C(AC) SO 2 AOJ'S WON'T CHANGE SIGN.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC1,AC		;SIMULATE 
	ADD	AC1,[2]		;2 AOJ'S.
	AOJL	AC,.+2		;C(AC) IS POS...NO JUMP.
	AOJG	AC,.+2		;C(AC) IS POS...JUMP.
	ER	AC,[ASCII /AOJ/]
	CAME	AC,AC1		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,.-2
	LOOP	AOJL2,AOJL3

;TEST AOJG, AOJL.  CHECK FOR JUMP/NO JUMP AND
;C(AC)=CORRECT DATA FOR C(AC)=-RAN.

	AC=11
AOJG1:	SETUP	100,0
AOJG2:	RANDOM
AOJG3:	TDO	AC,[XWD 400000,0];MAKE C(AC) NEG.
	TDZ	AC,[3]		;CLEAR TWO END BITS SO AOJL WILL ALWAYS SKIP.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC1,AC		;SIMULATE
	ADD	AC1,[2]		;2 AOJ'S
	AOJG	AC,.+2		;C(AC) IS NEG...NO SKIP
	AOJL	AC,.+2		;C(AC) IS NEG...SKIP
	ER	AC,[ASCII /AOJ/]
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,.-2
	LOOP	AOJG2,AOJG3

;TEST AOJG, AOJGE.  CHECK FOR JUMP/NO JUMP AND
;CORRECT DATA IN AC FOR C(AC)=-2

	AC=12
AOJGE1:	SETUP	100,0
AOJGE2:	MOVE	AC,[XWD -1,-2]	;MAKE C(AC) = -2.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	AOJG	AC,.+2		;C(AC)+1=-1. NO SKIP
	AOJGE	AC,.+2		;C(AC)+1=0. SKIP
	ER	AC,[ASCII /AOJ/]
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,.-2
	LOOP	AOJGE2,AOJGE2

;TEST AOJG, AOJLE.  CHECK FOR JUMP/NO JUMP AND
;CORRECT DATA IN AC FOR C(AC)=-2

	AC=13
AOJLE1:	SETUP	100,0
AOJLE2:	MOVE	AC,[XWD -1,-2]	;MAKE C(AC) = -2.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	AOJG	AC,.+2		;C(AC)+1=-1. NO SKIP
	AOJLE	AC,.+2		;C(AC)+1=0. SKIP
	ER	AC,[ASCII /AOJ/]
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,.-2
	SOJG	AC-1,AOJLE2	;ITERATION COUNTER.
	JUMPL	AC-1,AOJLE2	;LOOP ON ERROR SWITCH.

;TEST SOS, SOSA.  CHECK FOR SKIP/NO SKIP,
;PROPER STORING OF C(E) INTO AC, AND CORRECT
;DATA IN E FOR C(E)=RAN

	AC=7
SOS1:	SETUP	100,0
SOS2:	RANDOM
SOS3:	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC3,AC		;SIMULATE
	SUB	AC3,[2]		;2 SOS'S
	SOS	AC1,AC		;SHOULD NOT SKIP
	SOSA	AC1,AC		;SHOULD SKIP
	ER	AC1,[ASCII /SOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER SOS
	EERR	,AC2
	CAME	AC3,AC		;C(E) SHOULD=SIM ANS
	EERR	,AC2
	LOOP	SOS2,SOS3

;TEST SOSE, SOSN.  CHECK FOR SKIP/NO SKIP,
;PROPER STORING C(E) INTO AC, AND CORRECT
;DATA IN E FOR  C(E) = (3,7,17,37,+ETC.).

	AC=10
SOSE1:	SETUP	100,0
SOSE2:	MOVEI	AC,1		;SETUP E TO
SOSE3:	ROT	AC,1		;CONTAIN
	IOR	AC,[1]		;3,7,17,37,+ETC.
SOSE4:	MOVE	AC,RAN1		;RESTORE C(E) IN CASE OF ERROR.
	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC3,AC		;SIMULATE
	SUB	AC3,[2]		;2 SOS'S
	SOSE	AC1,AC		;SHOULD NOT SKIP
	SOSN	AC1,AC		;SHOULD SKIP
	ER	AC1,[ASCII /SOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER SOS
	EERR	,AC2
	CAME	AC3,AC		;C(E) SHOULD=SIM ANS
	EERR	,AC2
	CAMN	RAN1,[-1]	;C(RAN1) = -1?
	JRST	SOSE2		;YES. REINITIALIZE E.
	SOJG	AC-1,SOSE3	;ITERATION COUNTER.
	JUMPL	AC-1,SOSE4	;LOOP ON ERROR SWITCH


;TEST SOSL, SOSE. CHECK FOR SKIP/ NO SKIP,
;PROPER STORING C(E) INTO AC, AND CORRECT
;DATA IN E FOR C(E) = 2.

	AC=7
SOSLA:	SETUP	100,0
SOSLB:	RANDOM
SOSLC:	MOVE	AC1,[2]		;MAKE C(E) = 2.
	MOVE	RAN1,AC1	;SAVE C(E) IN CASE OF ERROR.
	SOSL	AC,AC1		;C(E) -1 = 1...NO SKIP.
	SOSE	AC,AC1		;C(E) -1 = 0...SKIP.
	ER	AC1,[ASCII /SOS/]
	CAME	AC,AC1		;C(AC) SHOULD = C(E).
	ERR	RAN1,RAN
	CAME	AC1,[0]		;C(E) SHOULD = 0.
	ERR	RAN1,RAN
	LOOP	SOSLB, SOSLC


;TEST SOSE,SOSL. CHECK FOR SKIP/NO SKIP,
;PROPER STORING C(E) INTO AC, AND
;CORRECT DATA IN E FOR C(E)=2

	AC=11
SOSL1:	SETUP	100,0
SOSL2:	MOVEI	AC,2		;SETUP C(E) TO = 2.
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR.
	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR.
	SOSL	AC1,AC		;C(E)=1...NO SKIP.
	SOSE	AC1,AC		;C(E)=0...SHOULD SKIP
	ER	AC1,[ASCII /SOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER SOS
	ERR	RAN1,AC2
	CAME	AC,[0]		;C(E) SHOULD NOW=0
	ERR	RAN1,AC2
	SOJG	AC-1,SOSL2	;ITERATION COUNTER.
	JUMPL	AC-1,SOSL2	;LOOP ON ERROR SWITCH.

;TEST SOSG, SOSL. CHECK FOR SKIP/ NO SKIP,
;PROPER STORING OF C(E) INTO AC, AND CORRECT
;DATA IN E FOR C(E)=+RAN.

	AC=12
SOSG1:	SETUP	100,0
SOSG2:	RANDOM
SOSG3:	TDZ	AC,[XWD 400000,0];MAKE C(E) POSITIVE.
	IORI	AC,3		;MAKE SURE C(E)=3.
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR.
	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR.
	MOVE	AC3,AC		;SIMULATE
	SUB	AC3,[2]		;2 SOS'S
	SOSL	AC1,AC		;C(E) IS POSITIVE. SHOULD NOT SKIP
	SOSG	AC1,AC		;C(E) IS POSITIVE. SHOULD SKIP
	ER	AC1,[ASCII /SOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER SOS
	ERR	RAN1,AC2
	CAME	AC,AC3		;C(E) SHOULD=SIM ANS
	ERR	RAN1,AC2
	LOOP	SOSG2,SOSG3

;TEST SOSG, SOSL. CHECK FOR SKIP/ NO SKIP,
;PROPER STORING C(E) INTO AC, AND CORRECT
;DATA IN E FOR C(E)=-RAN

	AC=13
SOSL1A:	SETUP	100,0
SOSL2A:	RANDOM
SOSL3A:	TDO	AC,[XWD 400000,0];MAKE C(E) NEG.
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC3,AC		;SIMULATE
	SUB	AC3,[2]		;2 SOS'S
	SOSG	AC1,AC		;C(E) IS NEG. NO SKIP
	SOSL	AC1,AC		;C(E) IS NEG. SKIP
	ER	AC1,[ASCII /SOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER SOS
	ERR	RAN1,AC2
	CAME	AC,AC3		;C(E) SHOULD=SIM ANS
	ERR	RAN1,AC2
	LOOP	SOSL2A, SOSL3A

;TEST SOSL, SOSLE.  CHECK FOR SKIP/NO SKIP,
;PROPER STORING OF C(E) INTO AC, AND CORRECT
;DATA IN E FOR C(E)=2

	AC=14
SOSLE1:	SETUP	100,0
SOSLE2:	MOVEI	AC,2		;MAKE C(E)=2
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR
	SOSL	AC1,AC		;C(E)-1=1...NO SKIP
	SOSLE	AC1,AC		;C(E)-1=0...SKIP
	ER	AC1,[ASCII /SOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER SOS
	ERR	RAN1,AC2
	CAME	AC,[0]		;C(AC) SHOULD = 0
	ERR	RAN1,AC2
	SOJG	AC-1,SOSLE2	;ITERATION COUNTER.
	JUMPL	AC-1,SOSLE2	;LOOP ON ERROR SWITCH.

;TEST SOSLE, SOSGE.  CHECK FOR SKIP/NO SKIP,
;PROPER STORING OF C(E) INTO AC, AND CORRECT
;DATA IN E FOR C(E)=2

	AC=5
SOSGE1:	SETUP	100,0
SOSGE2:	MOVEI	AC,2		;MAKE C(E)=2
	MOVE	RAN1,AC		;SAVE C(E) IN CASE OF ERROR
	MOVE	AC2,AC1		;SAVE C(AC) IN CASE OF ERROR
	SOSLE	AC1,AC		;C(E)-1=1...NO SKIP
	SOSGE	AC1,AC		;C(E)-1=0...SKIP
	ER	AC1,[ASCII /SOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E) AFTER SOS
	ERR	RAN1,AC2
	CAME	AC,[0]		;C(E) SHOULD=0
	ERR	RAN1,AC2
	SOJG	AC-1,SOSGE2	;ITERATION COUNTER.
	JUMPL	AC-1,SOSGE2	;LOOP ON ERROR SWITCH.

;TEST SOJ, SOJA.  CHECK JUMP/NO JUMP AND
;CORRECT DATA IIN AC FOR C(AC)=RAN.

	AC=2
SOJ1:	SETUP	100,0
SOJ2:	RANDOM
SOJ3:	MOVE	AC1,AC		;SIMULATE
	SUB	AC1,[2]		;2 SOJ'S
	SOJ	AC,.+2		;SHOULD NOT JUMP
	SOJA	AC,.+2		;SHOULD JUMP
	ER	AC,[ASCII /SOJ/]
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	EERRI	,.-2
	LOOP	SOJ2,SOJ3

;TEST SOJE,SOJN.  CHECK JUMP/NO JUMP AND
;CORRECT DATA IN AC FOR C(AC)=MAGIC NUMBERS (7,17,37,ETC.)

	AC=3
SOJE1:	SETUP	100,0
SOJE2:	MOVEI	AC,2		;SETUP AC
SOJE3:	ROT	AC,1		;TO CONTAIN
	IORI	AC,3		;7,17,37,+ETC
	MOVE	RAN1,AC		;SAVE FOR FUTURE COMPARE.
SOJE4:	MOVE	AC,RAN1		;COME HERE AND RESTORE IF THERE IS AN ERROR.
	MOVE	AC1,RAN1	;SIMULATE
	SUB	AC1,[2]		;2 SOJ'S
	SOJE	AC,.+2		;SHOULD NOT SKIP
	SOJN	AC,.+2		;SHOULD SKIP.
	ER	AC,[ASCII /SOJ/]
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,.-2
	CAMN	RAN1,[-1]	;C(RAN1) = -1?
	JRST	SOJE2		;YES, REINITIALIZE C(AC)
	SOJG	AC-1,SOJE3	;ITERATION COUNTER.
	JUMPL	AC-1,SOJE4	;LOOP ON ERROR SWITCH.

;TEST SOJE, SOJL. CHECK FOR JUMP/ NO JUMP AND
;CORRECT DATA IN AC FOR ORIG. C(AC)=2

	AC=4
SOJL1:	SETUP	100,0
SOJL2:	MOVEI	AC,2		;SETUP C(AC) TO = 2.
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR.
	SOJL	AC,.+2		;C(AC) = 1...NO JUMP.
	SOJE	AC,.+2		;C(AC)=0...SHOULD SKIP
	ER	AC,[ASCII /SOJ/]
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,.-2
	SOJG	AC-1,SOJL2	;ITERATION COUNTER.
	JUMPL	AC-1,SOJL2	;LOOP ON ERROR SWITCH.

;TEST SOJG, SOJL. CHECK FOR JUMP/ NO JUMP AND
;CORRECT DATA IN AC FOR C(AC)=+RAN

	AC=5
SOJG1:	SETUP	100,0
SOJG2:	RANDOM
SOJG3:	TDZ	AC,[XWD 400000,0];MAKE C(AC) POSITIVE.
	IOR	AC,[3]		;MAKE SURE SOJ'S SKIP..SET LAST TWO BITS.
	MOVE	AC1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC2,AC		;SIMULATE
	SUB	AC2,[2]		;2 SOJ'S
	SOJL	AC,.+2		;C(AC) IS POSITIVE...SHOULD NOT SKIP
	SOJG	AC,.+2		;C(AC) IS POSITIVE...SHOULD SKIP
	ER	AC,[ASCII /SOJ/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	ERRI	AC1,.-2
	LOOP	SOJG2,SOJG3

;TEST SOJG, SOJL. CHECK FOR JUMP/ NO JUMP AND
;CORRECT DATA IN AC FOR C(AC)=-RAN

	AC=6
SOJL1A:	SETUP	100,0
SOJL2A:	RANDOM
SOJL3A:	TDO	AC,[XWD 400000,0];MAKE C(AC) NEG.
	MOVE	AC1,AC		;SAVE C(AC) IN CASE OF ERROR
	MOVE	AC2,AC		;SIMULATE
	SUB	AC2,[2]		;2 SOJ'S
	SOJG	AC,.+2		;C(AC) IS NEG. SHOULD NOT SKIP
	SOJL	AC,.+2		;C(AC) IS NEG. SHOULD SKIP
	ER	AC,[ASCII /SOJ/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	ERRI	AC1,.-2
	LOOP	SOJL2A, SOJL3A

;TEST SOJL, SOJLE.  CHECK FOR JUMP/NO JUMP AND
;CORRECT DATA IN AC FOR C(AC)=2.

	AC=15
SOJLE1:	SETUP	100,0
SOJLE2:	MOVEI	AC,2		;MAKE C(AC)=2
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	SOJL	AC,.+2		;C(AC)-1=1...NO SKIP
	SOJLE	AC,.+2		;C(AC)-1=0...SKIP
	ER	AC,[ASCII /SOJ/]
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,.-2
	SOJG	AC-1,SOJLE2	;ITERATION COUNTER.
	JUMPL	AC-1,SOJLE2	;LOOP ON ERROR SWITCH.

;TEST SOJLE, SOJGE.  CHECK FOR JUMP/NO JUMP AND
;CORRECT DATA IN AC FOR  C(AC)=2

	AC=6
SOJGE1:	SETUP	100,0
SOJGE2:	MOVEI	AC,2		;MAKE C(AC)=2
	MOVE	RAN1,AC		;SAVE C(AC) IN CASE OF ERROR
	SOJLE	AC,.+2		;C(AC)-1=1...NO SKIP
	SOJGE	AC,.+2		;C(AC)-1=0...SKIP
	ER	AC,[ASCII /SOJ/]
	CAME	AC,[0]		;C(AC) SHOULD=0
	ERRI	RAN1,.-2
	SOJG	AC-1,SOJGE2	;ITERATION COUNTER.
	JUMPL	AC-1,SOJGE2	;LOOP ON ERROR SWITCH.

;TEST AOS, SOSA.  CHECK FOR SKIP/NO SKIP,
;CORRECT LOADING OF C(E) INTO AC, AND C(E)
;=ORIG. C(E) FOR C(E)=RAN

	AC=5
ASSS1:	SETUP	100,0
ASSS2:	RANDOM
ASSS3:	MOVE	RAN1,AC1	;SAVE C(AC) IN CASE OF ERROR.
	AOS	AC1,AC		;SHOULD NOT SKIP
	SOSA	AC1,AC		;SHOULD SKIP
	ER	AC1,[ASCII /AOS/]
	CAME	AC1,AC		;C(AC) SHOULD=C(E)
	EERR	,RAN1
	CAME	AC,RAN		;C(E) SHOULD=ORIG. C(E)
	EERR	,RAN1
	LOOP	ASSS2,ASSS3

;TEST AOJ, SOJA.  CHECK FOR JUMP/NO JUMP AND
;C(AC)=ORIG C(AC) FOR C(AC) = RAN

	AC=6
AJSJ1:	SETUP	100,0
AJSJ2:	RANDOM
AJSJ3:	AOJ	AC,.+2		;SHOULD NOT SKIP
	SOJA	AC,.+2		;SHOULD SKIP
	ER	AC,[ASCII /AOJ/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC)
	EERRI	,.-2
	LOOP	AJSJ2,AJSJ3

;TEST CAM, CAMA.  CHECK FOR SKIP/NO SKIP AND
;C(AC) + C(E) NOT CHANGING WITH A FLOATING ONE
;IN C(E)

	AC=10
CAM1:	SETUP	100,0
	MOVEI	AC1,1		;SETUP C(E) TO=A FLOATING ONE
CAM2:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	MOVE	AC2,AC1		;SAVE FOR FUTURE COMPARE
CAM3:	MOVE	AC1,AC2		;RESTORE C(E) IF ERROR.
	CAM	AC,AC1		;SHOULD NOT SKIP.
	CAMA	AC,AC1		;SHOULD SKIP.
	ER	AC,[ASCII /CAM/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG C(AC).
	ERR	AC2,RAN
	CAME	AC1,AC2		;C(E) SHOULD=ORIG C(E).
	ERR	AC2,RAN
	LOOP	CAM2,CAM3

;TEST CAML,CAMG.  CHECK FOR SKIP/NO SKIP AND
;C(AC)+C(E) NOT BEING CHANGED FOR+RAN1 TO -RAN CONDITION.

	AC=11
CAML1:	SETUP	100,0
CAML2:	RANDOM
CAML3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM
	TDO	AC1,[XWD 400000,0];MAKE C(E) A NEG NUM.
	TDZ	AC,[XWD 400000,0];MAKE C(AC) A POS. NUM.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE
	MOVE	AC2,AC1		;SAVE C(E) FOr FUTURE COMPARE
	CAML	AC,AC1		;C(AC)>C(E)...NO SKIP.
	CAMG	AC,AC1		;C(AC)>C(E)...SKIP
	ER	AC,[ASCII /CAM/]
	CAME	AC,RAN1		;C(AC) SHOULD=ORIG. C(AC)
	ERR	AC2,RAN1
	CAME	AC1,AC2		;C(E) SHOULD=ORIG. C(E)
	ERR	AC2,RAN1
	LOOP	CAML2,CAML3

;TEST CAMLE,CAMG.  CHECK FOR SKIP/NO SKIP AND
;C(AC)+C(E) NOT BEING CHANGED FOR +RAN1 TO -RAN CONDITION.

	AC=2
CAMLE1:	SETUP	100,0
CAMLE2:	RANDOM
CAMLE3:	ROT	AC,11		;C(AC)=SECOND RAN. NUM.
	MOVE	AC1,RAN		;C(E)=1'ST RAN. NUM.
	TDO	AC1,[XWD 400000,0];MAKE C(E) A NEG NUM.
	TDZ	AC,[XWD 400000,0];MAKE C(AC) A POS. NUM.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	MOVE	AC2,AC1		;SAVE C(E) FOR FUTURE COMPARE
	CAMLE	AC,AC1		;C(AC)>C(E). NO SKIP.
	CAMG	AC,AC1		;C(AC)>C(E). SKIP
	ER	AC,[ASCII /CAM/]
	CAME	AC,RAN1		;C(AC) SHOULD=ORIG. C(AC).
	ERR	AC2,RAN1
	CAME	AC1,AC2		;C(E) SHOULD=ORIG C(E)
	ERR	AC2,RAN1
	LOOP	CAMLE2,CAMLE3

;TEST CAML, CAMGE. CHECK FOR SKIP/ NO SKIP AND
;C(AC)+C(E) NOT BEING CHANGED FOR -RAN TO +RAN1 CONDITION

	AC=3
CAMGE1:	SETUP	100,0
CAMGE2:	RANDOM
CAMGE3:	ROT	AC,11		;C(E)=SECOND RAN. NUM
	MOVE	AC1,RAN		;C(AC)=1'ST RAN NUM
	TDO	AC1,[XWD 400000,0];MAKE C(AC) A NEG NUM.
	TDZ	AC,[XWD 400000,0];MAKE C(E) A POS. NUM.
	MOVE	RAN1,AC		;SAVE C(E) FOR FUTURE COMPARE
	MOVE	AC2,AC1		;SAVE C(AC) FOR FUTURE COMPARE
	CAMGE	AC1,AC		;C(AC)<C(E)...NO SKIP
	CAML	AC1,AC		;C(AC)<C(E)...SKIP
	ER	AC1,[ASCII /CAM/]
	CAME	AC1,AC2		;C(AC) SHOULD=ORIG. C(AC)
	ERR	RAN1,AC2
	CAME	RAN1,AC		;C(E) SHOULD=ORIG. C(E)
	ERR	AC2,RAN1
	LOOP	CAMGE2,CAMGE3

;TEST CAMG, CAMGE.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR RAN TO RAN CONDITION

	AC=4
CAMG1:	SETUP	100,0
CAMG2:	RANDOM
CAMG3:	CAMG	AC,RAN		;C(AC)=C(E)...NO SKIP.
	CAMGE	AC,RAN		;C(AC)=C(E)...SKIP
	ER	AC,[ASCII /CAM/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG.C(AC).
	EERR	,RAN
	LOOP	CAMG2,CAMG3

;TEST CAML,CAMLE.  CHECK FOR SKIP/NO SKIP AND
;C(AC)+C(E) NOT BEING CHANGED FOR RAN TO RAN CONDITION

	AC=5
CAMLA:	SETUP	100,0
CAMLB:	RANDOM
CAMLC:	CAML	AC,RAN		;C(AC)=C(E)...NO SKIP.
	CAMLE	AC,RAN		;C(AC)=C(E)...SKIP
	ER	AC,[ASCII /CAM/]
	CAME	AC,RAN		;C(AC) SHOULD=ORIG.C(AC).
	EERR	,RAN
	LOOP	CAMLB,CAMLC

;TEST CAI,CAIA.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR RAN TO RAN1 CONDITION

	AC=6
CAI1:	SETUP	100,0
CAI2:	RANDOM
	MOVE	AC1,AC		;SAVE E.
CAI3:	ROT	AC,11		;C(AC)=SECOND RAN.NUM
	MOVEI	AC,(AC)		;CLEAR LEFT HALF FOR CAI INST.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE
	CAI	AC,(AC1)	;SHOULD NOT SKIP.
	CAIA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII /CAI/]
	CAME	AC,RAN1		;C(AC) SHOULD =ORIG. C(AC)
	ERRI	RAN1,(AC1)
	LOOP	CAI2,CAI3

;TEST CAIE, CAIN.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR RAN TO RAN1 CONDITION.

	AC=7
CAIE1:	SETUP	100,0
CAIE2:	RANDOM
	MOVE	AC1,RAN		;SAVE E.
CAIE3:	MOVEI	AC,(AC)		;CLEAR LEFT SIDE FOR CAI INST.
	XOR	AC,[3154]	;MAKE SURE C(AC) AND E ARE DIFFERENT.
	MOVE	RAN1,AC		;SAVE FOR FUTURE COMPARE
	CAIE	AC,(AC1)	;C(AC) NOT = E...NO SKIP.
	CAIN	AC,(AC1)	;C(AC) NOT = E...SKIP.
	ER	AC,[ASCII /CAI/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG. C(AC).
	ERRI	RAN1,(AC1)
	LOOP	CAIE2,CAIE3

;TEST CAIE, CAIN.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR  RAN TO RAN CONDITION.

	AC=10
CAIN1:	SETUP	100,0
CAIN2:	RANDOM
	MOVE	AC1,RAN		;SAVE E.
CAIN3:	MOVEI	AC,(AC)		;MAKE C(AC) = E.
	MOVE	RAN1,AC		;SAVE FOR FUTURE COMPARE
	CAIN	AC,(AC1)	;C(AC) = E...NO SKIP.
	CAIE	AC,(AC1)	;C(AC) = E...SKIP.
	ER	AC,[ASCII /CAI/]
	CAME	AC,RAN1		;C(AC) SHOULD=ORIG. C(AC).
	ERRI	RAN1,(AC1)
	LOOP	CAIN2,CAIN3

;TEST CAIL,CAIG.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR C(AC) = 2,4,10,20, AND ETC,
;AND E = 1,3,7,17,37,AND ETC.

	AC=11
CAIL1:	SETUP	100,0
	MOVEI	AC,1		;SETUP E TO = 1 LESS
	MOVEI	AC1,2		;THAN C(AC).
CAIL2:	ROTC	AC,1		;ROT TO TEST NEXT BITS.
	IOR	AC,[1]		;SET SO E WILL = 1,3,7,17,AND ETC.
	TDNE	AC1,[XWD 1,0]	;BIT INTO LEFT HAND SIDE?
	JRST	.-5		;YES. REINITIALIZE NUMBERS.
	MOVE	RAN1,AC1	;SAVE C(AC) SO IT CAN BE RESTORED
	MOVE	AC2,AC		;SAVE C(E) SO IT CAN BE RESTORED
CAIL3:	MOVE	AC1,RAN1	;IN CASE OF ERROR.
	CAIL	AC1,(AC)	;C(AC) > E...NO SKIP.
	CAIG	AC1,(AC)	;C(AC) > E...SKIP.
	ER	AC1,[ASCII /CAI/]
	CAME	AC1,RAN1	;C(AC) SHOULD = ORIG. C(AC).
	ERRI	RAN1,(AC)
	SOJG	AC-1,CAIL2	;ITERATION COUNTER.
	MOVE	AC,AC2		;RESTORE C(E).
	JUMPL	AC-1,CAIL3	;LOOP ON ERROR SWITCH.


;TEST CAIG, CAIL.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR C(AC) = 1,3,7,17,37,AND ETC,
;AND E = 2,4,10,20,AND ETC.

	AC=12
CAIG1:	SETUP	100,0
	MOVEI	AC,1		;SETUP C(AC) TO = 1.
	MOVEI	AC1,2		;SETUP E TO = 2.
CAIG2:	ROTC	AC,1		;ROT SO C(AC)=2, E=4.
	IOR	AC,[1]		;SET BIT 35 SO C(AC) = 3,7,17.
	TDNE	AC1,[XWD 1,0]	;BIT INTO LEFT HAND SIDE?
	JRST	.-5		;YES. REINITIALIZE NUMBERS.
	MOVE	RAN1,AC		;SAVE C(AC) SO IT CAN
	MOVE	AC2,AC1		;AND C(E) CAN
CAIG3:	MOVE	AC,RAN1		;BE RESTORED IN CASE OF ERROR.
	CAIG	AC,(AC1)	;C(AC) < E...NO SKIP.
	CAIL	AC,(AC1)	;C(AC) < E...SKIP.
	ER	AC,[ASCII /CAI/]
	CAME	AC,RAN1
	ERRI	RAN1,(AC1)
	SOJG	AC-1,CAIG2	;ITERATION COUNTER.
	MOVE	AC,AC2		;RESTORE C(E).
	JUMPL	AC-1,CAIG3	;LOOP ON ERROR SWITCH.


;TEST CAIG, CAIGE.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR RAN TO RAN CONDITION.

	AC=13
CAIGE1:	SETUP	100,0
CAIGE2:	RANDOM
	MOVE	AC1,RAN		;SAVE E.
CAIGE3:	MOVEI	AC,(AC1)	;MAKE C(AC) = E.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE
	CAIG	AC,(AC1)	;C(AC) = E...NO SKIP.
	CAIGE	AC,(AC1)	;C(AC) = E...SKIP.
	ER	AC,[ASCII /CAI/]
	CAME	AC,RAN1		;C(AC) SHOULD=ORIG. C(AC)
	ERRI	RAN1,(AC1)
	SOJG	AC-1,CAIGE2	;ITERATION COUNTER.
	JUMPL	AC-1,CAIGE3	;LOOP ON ERROR SWITCH.

;TEST CAIL, CAILE.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT CHANGEING FOR RAN TO RAN CONDITION

	AC=14
CAILE1:	SETUP	100,0
CAILE2:	RANDOM
	MOVE	AC1,RAN		;SAVE E.
CAILE3:	MOVEI	AC,(AC1)	;MAKE C(AC) = E.
	MOVE	RAN1,AC		;SAVE FOR FUTURE COMPARE
	CAIL	AC,(AC1)	;C(AC) = E...NO SKIP.
	CAILE	AC,(AC1)	;C(AC) = E...SKIP.
	ER	AC,[ASCII /CAI/]
	CAME	AC,RAN1		;C(AC) SHOULD=ORIG. C(AC).
	ERRI	RAN1,(AC1)
	SOJG	AC-1,CAILE2	;ITERATION COUNTER.
	JUMPL	AC-1,CAILE3	;LOOP ON ERROR SWITCH.

;TEST CAIGE, CAIL.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT CHANGING FOR C(AC) = 1,3,7,17,AND ETC,
;AND E = 2,4,10,20,AND ETC.

	AC=15
CAILA:	SETUP	100,0
	MOVEI	AC,1		;SETUP C(AC) TO = 1 LESS
	MOVEI	AC1,2		;THAN E.
CAILB:	ROTC	AC,1		;ROT TO TEST NEXT BITS.
	IOR	AC,[1]		;SET SO C(AC) = 1,3,7,17,AND ETC.
	TDNE	AC1,[XWD 1,0]	;BIT GONE INTO LEFT HAND SIDE?
	JRST	.-5		;YES. REINITIALIZE NUMBERS.
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
CAILC:	MOVE	AC,RAN1		;RESTORE AC IN CASE OF ERROR.
	CAIGE	AC,(AC1)	;C(AC) < E...NO SKIP.
	CAIL	AC,(AC1)	;C(AC) < E...SKIP.
	ER	AC,[ASCII /CAI/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG. C(AC).
	ERRI	RAN1,(AC1)
	SOJG	AC-1,CAILB	;ITERATION COUNTER.
	JUMPL	AC-1,CAILC	;LOOP ON ERROR SWITCH.


;TEST CAILE, CAIG.  CHECK FOR SKIP/NO SKIP AND
;C(AC) NOT BEING CHANGED FOR C(AC) =2,4,10,20, AND ETC,
;AND E = 1,3,7,17,AND ETC.

	AC=6
CAIGA:	SETUP	100,0
	MOVEI	AC,1		;SETUP E TO = 1 LESS
	MOVEI	AC1,2		;THAN C(AC).
CAIGB:	ROTC	AC,1		;ROT TO TEST NEXT BITS.
	IOR	AC,[1]		;SET SO E WILL = 1,3,7,AND ETC.
	TDNE	AC1,[XWD 1,0]	;BIT INTO LEFT HAND SIDE?
	JRST	.-5		;YES. REINITIALIZE NUMBERS.
	MOVE	RAN1,AC1	;SAVE C(AC) FOR FUTURE COMPARE.
CAIGC:	MOVE	AC1,RAN1	;RESTORE IN CASE OF ERROR.
	CAILE	AC1,(AC)	;C(AC) > E...NO SKIP.
	CAIG	AC1,(AC)	;C(AC) > E...SKIP.
	ER	AC1,[ASCII /CAI/]
	CAME	AC1,RAN1	;C(AC) SHOULD = ORIG. C(AC).
	ERRI	RAN1,(AC)
	SOJG	AC-1,CAIGB	;ITERATION COUNTER.
	JUMPL	AC-1,CAIGC	;LOOP ON ERROR SWITCH.

;TEST ANDI.   CHECK FOR CORRECT DATA IN AC.
;RAN TO RAN1

	AC=10
ANDI4:	SETUP	200,1
ANDI5:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
ANDI6:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULTE
	ORCB	AC1,AC		;AN
	SETCA	AC1,		;ANDI
	ANDI	AC,(AC2)	;DO ANDI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	ANDI5,ANDI6

;TEST ANDCAI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=11
ANCAI4:	SETUP	200,1
ANCAI5:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
ANCAI6:	MOVSS	RAN1,AC		;MAKE C(AC) A DIFF. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULTE AN
	ORCA	AC1,AC		;ANDCAI
	SETCA	AC1,		;INST
	ANDCAI	AC,(AC1)	;DO ANDCAI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	ANCAI5,ANCAI6

;TEST SETMI,  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=2
STMI4:	SETUP	100,0
STMI5:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
STMI6:	MOVSS	RAN1,AC		;MAKE C(AC) A DIFF. RAN. NUM.
	MOVEI	AC1,(AC2)	;SETMI = MOVEI.
	SETMI	AC,(AC2)	;DO SETMI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	STMI5,STMI6

;TEST ANDCMI.  CHECK FOR CORRECT DATA IN C(AC)
;RAN TO RAN1

	AC=4
ANCMIA:	SETUP	200,1
ANCMIB:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
ANCMIC:	MOVSS	RAN1,AC		;MAKE C(AC) A DIFF. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	ORCM	AC1,AC		;AN
	SETCA	AC1,		;ANDCMI
	ANDCMI	AC,(AC2)	;DO ANDCMI.
	CAME	AC,AC1		;C(AC) SHOULD = SIM ANS.
	ERRI	RAN1,(AC2)
	LOOP	ANCMIB,ANCMIC

;TEST SETAI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=4
SETAIA:	SETUP	100,0
SETAIB:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
SETAIC:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	SETAI	AC,(AC2)	;DO SETAI.
	CAME	AC,RAN1		;C(AC) SHOULD NOT CHANGE
	ERRI	RAN1,(AC2)
	LOOP	SETAIB,SETAIC

;TEST XORI.  CHECK C(AC) FOR CORRECT DATA.
;RAN TO RAN1

	AC=5
XORIA:	SETUP	200,1
XORIB:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
XORIC:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	EQV	AC1,AC		;AN
	SETCA	AC1,		;XORI
	XORI	AC,(AC2)	;DO XORI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	XORIB,XORIC

;TEST IORI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=6
IORIA:	SETUP	200,1
IORIB:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
IORIC:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	ANDCM	AC1,AC		;AN
	XOR	AC1,AC		;IORI
	IORI	AC,(AC2)	;DO IORI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	IORIB,IORIC

;TEST ANDCBI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=7
ANCBIA:	SETUP	200,1
ANCBIB:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
ANCBIC:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	IOR	AC1,AC		;AN
	SETCA	AC1,		;ANDCBI
	ANDCBI	AC,(AC2)	;DO ANDCBI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	ANCBIB, ANCBIC

;TEST EQVI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=10
EQVIA:	SETUP	200,1
EQVIB:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
EQVIC:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	XOR	AC1,AC		;AN
	SETCA	AC1,		;EQVI
	EQVI	AC,(AC2)	;DO EQVI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	EQVIB,EQVIC

;TEST SETCAI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=11
STCAI1:	SETUP	200,1
STCAI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
STCAI3:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	SETCM	AC1,AC		;SIMULATE SETCAI
	SETCAI	AC,(AC2)	;DO SETCAI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	STCAI2,STCAI3

;TEST ORCAI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=12
ORCAI1:	SETUP	200,1
ORCAI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
ORCAI3:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	AND	AC1,AC		;AN
	XOR	AC1,AC		;ORCAI
	SETCA	AC1,		;INST.
	ORCAI	AC,(AC2)	;DO ORCAI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	ORCAI2,ORCAI3

;TEST SETCMI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=13
STCMI1:	SETUP	200,1
STCMI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
STCMI3:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	SETCA	AC1,		;A SETCMI
	SETCMI	AC,(AC2)	;DO SETCMI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	STCMI2,STCMI3

;TEST ORCMI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=14
ORCMI1:	SETUP	200,1
ORCMI2:	RANDOM
	MOVEI	AC2,RAN		;SAVE E.
ORCMI3:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	ANDCM	AC1,AC		;AN
	SETCA	AC1,		;ORCMI
	ORCMI	AC,(AC2)	;DO ORCMI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	ORCMI2,ORCMI3

;TEST ORCBI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=5
ORCBI1:	SETUP	200,1
ORCBI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
ORCBI3:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	MOVEI	AC1,(AC2)	;SIMULATE
	ANDCA	AC1,AC		;AN
	XOR	AC1,AC		;ORCBI
	SETCA	AC1,		;INST.
	ORCBI	AC,(AC2)	;DO ORCBI.
	CAME	AC,AC1		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC2)
	LOOP	ORCBI2,ORCBI3

;TEST SETOI.  CHECK C(AC) FOR CORRECT DATA
;RAN TO RAN1

	AC=6
STOI1:	SETUP	100,0
STOI2:	RANDOM
	MOVE	AC2,RAN		;SAVE E.
STOI3:	MOVSS	RAN1,AC		;MAKE C(AC) = SEC. RAN. NUM.
	SETOI	AC,(AC2)	;DO SETOI.
	CAME	AC,[-1]		;C(AC) SHOULD=-1
	ERRI	RAN1,(AC2)
	LOOP	STOI2,STOI3

;TEST TRN, TRNA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=10
TRN1:	SETUP	100,0
TRN2:	RANDOM
TRN3:	TRN	AC,0		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRN SKIPPED.
	TRNA	AC,0		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD STILL=RAN
	EERRI	,0
	LOOP	TRN2,TRN3

;TEST TRN, TRNA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=11
TRN4:	SETUP	100,0
TRN5:	RANDOM
TRN6:	SETZB	AC1,RAN1	;CLEAR C(AC).
	TRN	AC1,(AC)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRN SKIPPED.
	TRNA	AC1,(AC)	;SHOULD SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD STILL=0
	ERRI	RAN1,(AC)
	LOOP	TRN5,TRN6

;TEST TRN, TRNA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=2
TRN7:	SETUP	100,0
TRN8:	RANDOM
TRN9:	MOVE	AC1,AC		;MAKE "E"=C(AC)
	TRN	AC,(AC1)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRN SKIPPED.
	TRNA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	ERRI	AC1,(AC1)
	LOOP	TRN8,TRN9

;TEST TRN,TRNA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION

	AC=3
TRNA1:	SETUP	100,0
TRNA2:	RANDOM
TRNA3:	MOVS	AC1,AC		;MAKE "E"=DIFFERENT RAN NUM
	TRN	AC,(AC1)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRN SKIPPED.
	TRNA	AC,(AC1)	;SHOULD SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	EERRI	,(AC1)
	LOOP	TRNA2,TRNA3

;TEST TRNE,TRNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=4
TRNE1A:	SETUP	100,0
TRNE2A:	RANDOM
TRNE3A:	TRNN	AC,0		;E+C(AC)R=0.  NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRNN SKIPPED.
	TRNE	AC,0		;E+C(AC)R = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	EERRI	,0
	LOOP	TRNE2A,TRNE3A

;TEST TRNE, TRNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=5
TRNE1B:	SETUP	100,0
TRNE2B:	RANDOM
TRNE3B:	SETZB	AC1,RAN1	;CLEAR C(AC).
	TRNN	AC1,(AC)	;E+C(AC)R = 0...NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRNN SKIPPED.
	TRNE	AC1,(AC)	;E+C(AC)R = 0...SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD STILL=0
	ERRI	RAN1,(AC)
	LOOP	TRNE2B,TRNE3B

;TEST TRNE, TRNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=6
TRNE1C:	SETUP	100,0
TRNE2C:	RANDOM
TRNE3C:	IORI	AC,2		;MAKE SURE C(AC)R HAS A BIT SET
	MOVE	RAN1,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	TRNE	AC,-1		;E+C(AC)R NOT=0. NO SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRNE SKIPPED.
	TRNN	AC,-1		;E+C(AC)R NOT=0. SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD NEVER CHANGE.
	ERRI	RAN1,-1
	LOOP	TRNE2C,TRNE3C

;TEST TRNE, TRNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=7
TRNE1D:	SETUP	100,0
TRNE2D:	RANDOM
TRNE3D:	IORI	AC,1		;MAKE SURE E HAS A BIT.
	SETOB	AC1,RAN1	;MAKE C(AC) = -1.
	TRNE	AC1,(AC)	;E+C(AC)R NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRNE SKIPPED.
	TRNN	AC1,(AC)	;E+C(AC)R NOT = 0...SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD STILL = A -1.
	ERRI	RAN1,(AC)
	LOOP	TRNE2D,TRNE3D

;TEST TRNE,TRNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=10
TRNE1E:	SETUP	100,0
TRNE2E:	RANDOM
TRNE3E:	IORI	AC,4		;MAKE SURE C(AC)R HAS A BIT
	MOVE	AC1,AC		;MAKE E=C(AC).
	TRNE	AC,(AC1)	;E + C(AC)R NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRNE SKIPPED.
	TRNN	AC,(AC1)	;E + C(AC)R NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC1		;C(AC) SHOULD = ORIG C(AC).
	ERRI	AC1,(AC1)
	LOOP	TRNE2E,TRNE3E

;TEST TRNE,TRNN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION.

	AC=11
TRNE1F:	SETUP	100,0
TRNE2F:	RANDOM
TRNE3F:	SETCM	AC1,AC		;MAKE "E" = 1'S COMP OF C(AC).
	TRNN	AC,(AC1)	;E+C(AC)R = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRNN SKIPPED.
	TRNE	AC,(AC1)	;E + C(AC)R = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD = ORIG C(AC).
	EERRI	,(AC1)
	LOOP	TRNE2F,TRNE3F

;TEST TRZ, TRZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION

	AC=12
TRZA1:	SETUP	100,0
TRZA2:	RANDOM
TRZA3:	SETCM	AC1,AC		;MAKE "E"=COMP OF C(AC)
	TRZ	AC,(AC1)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRZ SKIPPED.
	TRZA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	EERRI	,(AC1)
	LOOP	TRZA2,TRZA3

;TEST TRZ,TRZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=13
TRZAA:	SETUP	100,0
TRZAB:	RANDOM
	MOVE	AC1,AC		;MAKE "E"=C(AC)
TRZAC:	MOVE	AC2,AC		;SIMULATE
	AND	AC2,[XWD -1,0]	;A (TRZ AC,-1).
	TRZ	AC,(AC1)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRZ SKIPPED.
	TRZA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	ERRI	AC1,(AC1)
	LOOP	TRZAB,TRZAC

;TEST TRZ,TRZA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN1 TO RAN CONDITION

	AC=14
TRZB1:	SETUP	100,0
TRZB2:	RANDOM
TRZB3:	MOVS	AC1,AC		;MAKE "E"=DIFFERENT RAN NUM
	MOVEI	AC2,(AC1)	;SIMULATE
	ORCM	AC2,AC		;A
	SETCA	AC2,		;TRZ
	TRZ	AC,(AC1)	;SHOULD NOT SKIP.
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	EERRI	,(AC1)
	MOVE	AC,RAN		;RESTORE AC
	TRZA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	EERRI	,(AC1)
	LOOP	TRZB2,TRZB3

;TEST TRZE, TRZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR A ROTATING MASK BIT WITH SAME BIT
;CLEARED IN AC.

	AC=5
TRZE1:	SETUP	40,0
	MOVEI	AC1,1		;SETUP E TO HAVE A MASK BIT.
TRZE2:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT
	CAMN	AC1,[XWD 1,0]	;HAS THE BIT GONE TO THE LEFT SIDE?
	MOVEI	AC1,1		;YES, RESTORE E
TRZE3:	ANDCM	AC,AC1		;CLEAR MASK BIT IN AC
	MOVE	AC2,AC		;SAVE FOR COMPARE
	TRZN	AC,(AC1)	;E+C(AC)R = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRZN SKIPPED.
	TRZE	AC,(AC1)	;E+C(AC)R = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD NOT HAVE CHANGED
	ERRI	AC2,(AC1)
	LOOP	TRZE2,TRZE3

;TEST TRZE,TRZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR A ROTATING MASK BIT WITH
;SAME BIT SET IN AC.

	AC=6
TRZEA:	SETUP	40,0
	MOVEI	AC1,1		;SETUP "E" FOR ONE MASK BIT
TRZEB:	RANDOM
	ROT	AC1,1		;ROT BIT TO TEST NEXT BIT
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES, RESTORE.
TRZEC:	IOR	AC,AC1		;SET MASK BIT IN AC
	MOVE	RAN1,AC		;SAVE FOR PRINT IN CASE OF ERROR.
	MOVE	AC2,AC		;SIMULATE
	ANDCM	AC2,AC1		;TRZ.
	TRZE	AC,(AC1)	;E+C(AC)R NOT = 0...NO SKIP.
	CAME	AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(AC1)
	MOVE	AC,RAN1		;RESTORE AC.
	TRZN	AC,(AC1)	;E+C(AC)R NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC1)
	LOOP	TRZEB,TRZEC

;TEST TRZE,TRZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR A ROTATING MASK BIT IN AC
;AND SAME BIT CLEARED IN E.

	AC=7
TRZNA:	SETUP	40,0
	MOVEI	AC1,1		;SETUP A MASK BIT
TRZNB:	RANDOM
	ROT	AC1,1		;ROT BIT TO TEST NEXT BIT
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES, RESTORE AC
	MOVE	AC2,AC1		;SAVE FOR FUTURE COMPARE.
TRZNC:	MOVE	AC1,AC2		;RESTORE "AC" IN CASE OF ERROR
	ANDCM	AC,AC1		;CLEAR BIT IN "E"
	TRZN	AC1,(AC)	;E+C(AC)R = 0...NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRZN SKIPPED.
	TRZE	AC1,(AC)	;E+C(AC)R = 0...SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD NOT CHANGE
	ERRI	AC2,(AC)
	LOOP	TRZNB,TRZNC

;TEST TRZE,TRZN.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR A ROTATING MASK BIT
;IN AC AND SAME BIT SET IN E.

	AC=11
TRZN1:	SETUP	40,0
	MOVEI	AC1,1		;SETUP A MASK BIT
TRZN2:	RANDOM
	ROT	AC1,1		;ROT BIT TO TEST NEXT BIT
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES, RESTORE
	MOVE	AC2,AC1		;SAVE FOR FUTURE COMPARE
TRZN3:	IOR	AC,AC1		;SET MASK BIT IN E
	TRZE	AC1,(AC)	;E+C(AC)R NOT = 0...NO SKIP.
	CAME	AC1,[0]		;C(AC) SHOULD=0
	ERRI	AC2,(AC)
	MOVE	AC1,AC2		;RESTORE MASK BIT
	TRZN	AC1,(AC)	;E+C(AC)R NOT = 0...SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD=0
	ERRI	AC2,(AC)
	MOVE	AC1,AC2		;RESTORE MASK BIT
	LOOP	TRZN2,TRZN3

;TEST TRO,TROA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=11
TRO1:	SETUP	100,0
TRO2:	RANDOM
TRO3:	TRO	AC,0		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRO SKIPPED.
	TROA	AC,0		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD STILL=RAN NUM
	EERRI	,0
	LOOP	TRO2,TRO3

;TEST TRO, TROA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=2
TRO4:	SETUP	100,0
TRO5:	RANDOM
TRO6:	SETZB	AC1,RAN1	;CLEAR C(AC).
	MOVE	AC2,AC		;SIMULATE
	ANDI	AC2,-1		;A TRO
	TRO	AC1,(AC)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRO SKIPPED.
	TROA	AC1,(AC)	;SHOULD ALWAYS SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD=SIM ANS
	ERRI	RAN1,(AC)
	LOOP	TRO5,TRO6

;TEST TRO, TROA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR -1 TO RAN CONDITION

	AC=3
TRO1A:	SETUP	100,0
TRO1B:	RANDOM
TRO1C:	MOVE	AC2,AC		;SIMULATE
	IORI	AC2,-1		;ATRO
	TRO	AC,-1		;SHOULD NOT SKIP
	JRST	.+2
	ER	AC,[ASCII /TST/];TRO SKIPPED.
	TROA	AC,-1		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	EERRI	,-1
	LOOP	TRO1B,TRO1C

;TEST TRO,TROA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO -1 CONDITION.

	AC=4
TRO1D:	SETUP	100,0
TRO1E:	RANDOM
TRO1F:	SETOB	AC1,RAN1	;SET C(AC) TO ALL ONES.
	TRO	AC1,(AC)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRO SKIPPED.
	TROA	AC1,(AC)	;SHOULD ALWAYS SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[-1]	;C(AC) SHOULD STILL = -1.
	ERRI	RAN1,(AC)
	LOOP	TRO1E,TRO1F

;TEST TRO, TROA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR NOT RAN TO RAN CONDITION

	AC=5
TROA1:	SETUP	100,0
TROA2:	RANDOM
TROA3:	SETCM	AC1,AC		;MAKE "E" = COM C(AC)
	MOVE	AC2,AC		;SIMULATE
	ANDCA	AC2,[XWD-1,0]	;A
	SETCA	AC2,		;TRO
	TRO	AC,(AC1)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRO SKIPPED.
	TROA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS
	EERRI	,(AC1)
	LOOP	TROA2,TROA3

;TEST TRO, TROA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO RAN CONDITION

	AC=6
TROA4:	SETUP	100,0
TROA5:	RANDOM
TROA6:	MOVE	AC1,AC		;MAKE E = C(AC)R.
	TRO	AC,(AC1)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRO SKIPPED.
	TROA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD NOT CHANGE
	ERRI	AC1,(AC1)
	LOOP	TROA5,TROA6


;TEST TROE, TRON. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR A FLOATING MASK BIT
;WITH SAME BIT CLEARED IN AC.

	AC=7
TROE1:	SETUP	40,0
	MOVEI	AC1,1		;SETUP E TO HAVE A MASK BIT.
TROE2:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	CAMN	AC1,[XWD 1,0]	;BIT IN LEFT SIDE?
	MOVEI	AC1,1		;YES. REINITIALIZE E.
TROE3:	ANDCM	AC,AC1		;CLEAR MASK BIT IN AC.
	MOVE	RAN1,AC		;SAVE AC IN CASE OF ERROR.
	MOVE	AC2,AC		;SIMULATE
	IOR	AC2,AC1		;A TRO INST.
	TROE	AC,(AC1)	;E + C(AC)R = 0...SKIP.
	ER	AC,[ASCII /TST/]
	TRON	AC,(AC1)	;E + C(AC)R NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(AC1)
	LOOP	TROE2,TROE3


;TEST TROE, TRON. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR A FLOATING MASK BIT IN E
;AND WITH SAME BIT SET IN AC.

	AC=10
TROEA:	SETUP	40,0
	MOVEI	AC1,1		;SETUP E TO HAVE A MASK BIT.
TROEB:	RANDOM
	ROT	AC1,1		;ROT ATO TEST NEST BIT.
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES. REINITIALIZE E.
TROEC:	IOR	AC,AC1		;SET MASK BIT IN AC.
	MOVE	RAN1,AC		;SAVE FOR COMPARE.
	TROE	AC,(AC1)	;E + C(AC) R NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TROE SKIPPED.
	TRON	AC,(AC1)	;E + C(AC)R NOT = 0...SKIP.
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN1		;C(AC) SHOULD = ORIG. C(AC).
	ERRI	RAN1,(AC1)
	LOOP	TROEB, TROEC

;TEST TROE, TRON. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR A FLOATING MASK BIT IN AC
;AND SAME BIT CLEARED IN E.

	AC=11
TRON1:	SETUP	40,0
	MOVEI	AC1,1		;SETUP AC TO HAVE A FLOATING MASK BIT.
TRON2:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES. REINITIALIZE AC.
	MOVE	RAN1,AC1	;SAVE C(AC) SO IT CAN BE
TRON3:	ANDCM	AC,AC1		;CLEAR BIT IN E.
	MOVEI	AC2,(AC)	;SIMULATE
	JUMPE	AC2,TRON2	;REJECT IF "E" = 0.
	IOR	AC2,AC1		;A TRO INST.
	TRON	AC1,(AC)	;E + C(AC)R = 0...NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRON SKIPPED.
	TRON	AC1,(AC)	;E + C(AC)R NOT = 0...SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(AC)
	MOVE	AC1,RAN1	;RESTORE C(AC).
	TROE	AC1,(AC)	;E + C(AC)R = 0...SKIP.
	ER	AC1,[ASCII /TST/]
	TROE	AC1,(AC)	;E + C(AC)R NOT = 0...NO SKIP.
	CAME	AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(AC)
	MOVE	AC1,RAN1	;RESTORE C(AC).
	LOOP	TRON2, TRON3

;TEST TROE, TRON. CHECK FOR SKIP/ NO SKIP AND
;CORRECT DATA IN AC FOR A FLOATING ONE IN AC
;AND SAME BIT SET IN E.

	AC=12
TRONA:	SETUP	40,0
	MOVEI	AC1,1		;SETUP AC TO HAVE A FLOATING ONE.
TRONB:	RANDOM
	ROT	AC1,1		;ROT TO TEST NEXT BIT.
	CAMN	AC1,[XWD 1,0]	;IS BIT ON LEFT SIDE?
	MOVEI	AC1,1		;YES. REINITIALIZE AC.
	MOVE	RAN1,AC1	;SAVE C(AC) SO IT CAN BE
TRONC:	IOR	AC,AC1		;SET BIT IN E.
	MOVEI	AC2,(AC)	;SIMULATE A TRO INST.
	TROE	AC1,(AC)	;E + C(AC)R NOT = 0...NO SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TROE SKIPPED.
	TRON	AC1,(AC)	;E + C(AC)R NOT = 0...SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,AC2		;C(AC) SHOULD = SIM. ANS.
	ERRI	RAN1,(AC)
	MOVE	AC1,RAN1	;RESTORE C(AC).
	LOOP	TRONB, TRONC



;TEST TRC,TRCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR 0 TO RAN CONDITION

	AC=7
TRC1:	SETUP	100,0
TRC2:	RANDOM
TRC3:	TRC	AC,0		;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC,[ASCII /TST/];TRC SKIPPED.
	TRCA	AC,0		;SHOULD SKIP
	ER	AC,[ASCII /TST/]
	CAME	AC,RAN		;C(AC) SHOULD STILL=RAN NUM
	EERRI
	LOOP	TRC2,TRC3
;TEST TRC,TRCA.  CHECK FOR SKIP/NO SKIP AND
;CORRECT DATA IN AC FOR RAN TO 0 CONDITION

	AC=10
TRCA1:	SETUP	100,0
TRCA2:	RANDOM
TRCA3:	SETZB	AC1,RAN1	;CLEAR C(AC).
	TRC	AC1,(AC)	;SHOULD NOT SKIP.
	JRST	.+2
	ER	AC1,[ASCII /TST/];TRC SKIPPED.
	TRCA	AC1,(AC)	;SHOULD ALWAYS SKIP.
	ER	AC1,[ASCII /TST/]
	CAME	AC1,[0]		;C(AC) SHOULD STILL=0
	ERRI	RAN1,(AC)
	LOOP	TRCA2,TRCA3

	JRST	BEGEND		;REPEAT TEST

  