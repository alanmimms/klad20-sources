TITLE SCOPE
SUBTTL SCOPE LOOPING AND ERROR REPORTING ROUTINE

	SEARCH	DEFINS
	SEARCH	MONSYM,UUOSYM

	ENTRY	SCOPE.

;THESE ARE DEFINED IN THE USERS MAINLINE CODE

	EXTERN	ERCNT,ERYET,ERYETU,LOWPM,TSTNAM

;NOTE:  ERFLG IS DEFINED IN DEFINS AS AN AC FOR CONVENIENCE


;THESE ARE DEFINED IN GENERAL UTILITIES FILE

	EXTERN	POCT

	XLIST
	BOX <SCOPE - - ERROR REPORTER AND SCOPE LOOP CONTROLLER>,<
	THIS ROUTINE IS RESPONSIBLE FOR ERROR REPORTING AND
	SCOPE LOOPING WITHIN THIS DIAGNOSTIC. THE ERROR
	LOOPING AND PRINT OPTIONS ARE CONTROLLED BY SWITCHES.


	SWITCH OPTIONS:
	---------------

	SW5=0	NO BELL ON ERROR
	SW5=1	RING BELL ON ERROR (FORCED)

	SW6=0	PROCEED ON ERROR
	SW6=1	LOOP ON FIRST OCCURANCE OF AN ERROR

	SW7=0	DON'T HALT ON ERROR
	SW7=1	HALT ON ERROR (EXEC MODE ONLY)

	SW8=0	PRINT ERROR DATA ON FIRST OCCURANCE OF ERROR ONLY
	SW8=1	PRINT ERROR DATA FOR ALL REPETITIVE ERRORS



	THE FOLLOWING TWO LOCATIONS SHOULD BE INITIALIZED BY THE
	MAINLINE TO 0 AT THE START OF EACH TEST.

	ERFLG	ERROR/NO-ERROR FLAG
	ERCNT	A LOCAL ERROR COUNTER


	TWO FLAGS MUST BE DEFINED IN THE MAINLINE FOR SCOPE.
	"ERYET" & "ERYETU" THEY PROVIDE A WAY FOR THE DIAGNOSTIC
	TO DETERMINE IF IT HAS JUST PROCEEDED ON ERROR FROM THE
	PREVIOUS SCOPE CALL. THIS IS A MEANIGNFUL DECISION SINCE
	THERE ARE OCCASIONS IN BOTH USER AND/OR EXEC MODE WHEN
	PROCEED ON ERROR IS NOT THE MOST APPROPRIATE ACTION.
	THESE FLAGS NEED NOT BE INITIALIZED. THEY ARE CONTROLLED
	BY SCOPE AND THE USER CAN TEST THEM AS DESIRED.


	ERYET=0		(EXEC OR USER) NO ERROR ON LAST SCOPE CALL
	ERYET=-1	(EXEC OR USER) ERROR ON LAST SCOPE CALL

	ERYETU=0	GUARANTEED TO BE ZERO IN EXEC MODE
	ERYETU=0	(USER MODE) NO ERROR ON LAST SCOPE CALL
	ERYETU=-1	(USER MODE) ERROR ON LAST SCOPE CALL


	THE SCOPE/ERROR HANDLER IS CALLED BY EXECUTING A UUO WHOSE
	E-FIELD IS A POINTER TO ADDITIONAL ERROR INFORMATION.
	THE UUO HAS A SKIP AND NON-SKIP RETURN TO PROVIDE THE NECESSARY
	LOOPING CAPABILITIES. THE NON-SKIP RETURN IS THE LOOP ON ERROR
	RETURN AND THE SKIP RETURN IS THE CONTINUE TEST (OR NO ERROR)
	RETURN. PGM BRANCHING IS ACCOMPLISHED BY PLACING APPROPRIATE
	JRSTS IN THE RETURN LOCATIONS.


	A TYPICAL USE WOULD BE AS FOLLOWS:
	----------------------------------

		CONSZ   DEV,ARG		;TEST INSTRUCTION
		SETOM	ERFLG		;DETECTED AN ERROR
		SCOPE	TAG		;CALL THE ROUTINE VIA UUO
		JRST	ERADR		;LOOP RETURN
		JRST	OKADR		;CONTINUE RETURN

	TAG:	ADR1,,ADR2		;POINTERS TO ADDITIONAL CODE
		CONTROL BITS,,[ASCIZ/MSG1/] ;VARIABLE # OF MESSAGES
		CONTROL BITS,,[ASCIZ/MSG2/]
		Z			;END OF LIST MARKER


	THE FIRST WORD OF THE TABLE POINTS TO 2 ADDITIONAL ROUTINES.
	IF EITHER IS ZERO IT WILL BE IGNORED.

	ADR1-POINTER TO ADDITIONAL I/O ROUTINE. NOTE: THIS ROUTINE IS
	EXECUTED EACH TIME THE THE SCOPE ROUTINE IS ABOUT TO TAKE
	THE LOOP RETURN, AND EACH TIME SCOPE IS ENTERED WITH
	THE ERROR FLAG SET.

	ADR2-POINTER TO ADDITIONAL PRINT ROUTINE

	THE SECOND THRU (N OR N-1) WORDS IN THE TABLE, SPECIFY VARIOUS
	ASCIZ MESSAGES THAT WILL BE PRINTED WHEN AN ERROR OCCURS,
	BRANCH WORDS WHOSE RIGHT HAND SIDE SPECIFY WHERE
	FOLLOWING DATA IN THE TABLE IS LOCATED, OR SUBROUTINE
	CALL SPECIFIERS WHOSE RIGHT HAND SIDE IS THE ADDR OF
	A NON-I/O SUBROUTINE TO BE EXECUTED.
	MESSAGES MAY BE OF ANY TYPE. THE ROUTINE WILL AUTOMATICALLY
	GIVE A FREE CRLF AT THE END OF EACH. THE RIGHT HALF OF EACH
	WORD IS A POINTER TO THE START OF THE ASCIZ MESSAGE AND THE
	LEFT HALF OF THE WORD IS USED TO FURNISH MESSAGE CONTROL
	INFORMATION TO THE SCOPE UUO. SCOPE LOOKS AT THE FOLLOWING
	CONTROL BITS FROM THE LEFT SIDE:

	BIT0=0	MESSAGE IS NOT A MODULE CALLOUT MESSAGE
	BIT0=1	MESSAGE IS A MODULE CALLOUT MESSAGE

	BIT1=0	THIS IS A HIGH PROBABILITY MODULE
	BIT1=1	THIS IS A LOW PROBABILITY MODULE

	BIT2=0	MESSAGE IS NOT PRINTED IF TXTINH (SW10) IS SET
	BIT2=1	MESSAGE IS PRINTED REGUARDLESS OF THE STATE OF TXTINH

	BIT3=0	THIS IS NOT A BRANCH WORD
	BIT3=1	THIS IS A BRANCH WORD AND ITS RIGHT HAND SIDE SPECIFIES
		WHERE THE NEXT TABLE DATA IS FOUND.

	BIT4=0	THIS IS NOT THE LAST TABLE ENTRY IF C(RIGHT) NON-0
	BIT4=1	THIS ENTRY IS THE LAST ONE IN THE TABLE

	BIT5=0	THIS WORD DOES NOT DEFINE A SUBROUTINE CALL
	BIT5=1 	THIS WORD DEFINES A SUBROUTINE CALL. EXECUTE
		THE SUBROUTINE WHOSE ADDR IS SPECIFIED BY
		THE RIGHT HALF OF THE WORD. THESE ROUTINES ARE ONLY
		EXECUTED WHEN SCOPE PRINTS ERROR INFORMATION


	THE END OF THE TABLE IS ASSUMED WHEN EITHER A ZERO WORD IS
	ENCOUNTERED IN THE 2ND THRU N WORDS OR A 1 IS FOUND IN SOME
	WORDS CONTROL BIT POSITION 4

	THE ABOVE MENTIONED CONTROLS GIVE THE USER A WAY TO FURNISH
	LONG AND SHORT PRINT MODES, BRANCHING, AND ESTABLISH A 2 LEVEL
	MODULE CALLOUT PRIORITY. LOW PROBABILITY MODULES ARE NOT PRINTED
	UNLESS THE FLAG 'LOWPM' IS SET TO -1.



	THE FOLLOWING PRINTOUT IS THE STANDARD PRINTOUT IN THE
	NORMAL PRINTOUT MODE: ......

	ERROR: TEST-XXX
	SCOPE PC = XXXXXX   TEST PC = XXXXXX
	DATA SWITCHES = XXXXXX XXXXXX

	           ADDITIONAL PRINTING DONE BY THE           
	           OPTIONAL PRINT ROUTINE                    

	ALL MESSAGES FROM THE TABLE

	----------------------------------------




	THE FOLLOWING PRINTOUT IS THE STANDARD PRINTOUT IN THE
	SHORT PRINTOUT MODE (TEXT INHIBIT IS SET):       

	ERROR: SCOPE PC-XXXXXX TST-XXX SW-XXXXXX XXXXXX

	           ADDITIONAL PRINT ROUTINE     


	---------------------------------------- >
	PAGE
SCOPE.:	JFCL
	JFCL
	PUT	$SVUPC		;SAVE THE PC OF THE UUO
	PUT	$SVUUO		;SAVE THE ACTUAL UUO
	PUT	0		;SAVE SOME AC'S
	PUT	1
	PUT	2

;THE STACK NOW LOOKS LIKE THIS
; -5(P) THE RETURN ADDR FOR SCOPE UUO
; -4(P) THE ADDRESS FROM WHICH THE SCOPE UUO WAS CALLED
; -3(P) THE ACTUAL UUO THAT WAS EXECUTED "SCOPE"
; -2(P) AC0 FROM BEFORE THE UUO
; -1(P) AC1 FROM BEFORE THE UUO
;  0(P) AC2 FROM BEFORE THE UUO

	SETZM	ERYET		;AN ERROR THIS TIME FLAG (EXEC USER)
	SETZM	ERYETU		;SAME AS ABOVE BUT USER MODE ONLY
	SKIPN	USER		;IN USER MODE ?
	SWITCH			;NO. THEN DO A SWITCH UUO
	MOVE	2,CONSW		;GET SWITCH SETTINGS
	MOVEM	2,SCPSW#	;SAVE SWITCHES SEEN THIS TIME
	HRRZ	0,-4(P)		;GET PC OF THE SCOPE CALL
	HRRZ	1,SCPPC#	;GET PC OF LAST SCOPE CALL
	CAME	1,0		;ARE THEY THE SAME ?
	MOVEM	0,SCPPC		;NO. UPDATE SCOPE PC
	MOVSI	1,1		;NOW UPDATE LEFT HAND COUNT
	ADDM	1,SCPPC		;THIS DOES IT
	SKIPN	ERFLG		;DID WE HAVE AN ERROR ?
	JRST	BRANCH		;NO. DO SWITCH OPTION TESTS
	AOS	ERRORT#		;BUMP A TOTAL COUNTER
	SETOM	ERYET		;SET FLAG SAYING ERROR THIS TIME
	SKIPE	USER		;IN USER MODE ?
	SETOM	ERYETU		;YES. THEN SET THIS FLAG ALSO
	MOVE	0,SCPPC		;GET CURRENT SCOPE PC
	CAME	0,ERRPC		;SAME AS ERROR PC
	SETZM	ERCNT		;NO. INIT FOR NEW REPORT
	MOVEM	0,ERRPC		;SAVE IT AS ERROR PC
	AOS	ERCNT		;YES. COUNT THE ERROR
SCOPE1:	HRRZ	0,-3(P)		;GET E-FIELD OF UUO
	JUMPE	0,SPC0		;BRANCH IF E-FIELD IS ZERO
	HLRZ	0,@-3(P)	;GET ADDR OF USER I/O OPTION ROUTINE
	JUMPE	0,SPC0		;IS THERE ONE ?
	EXCH	2,0(P)		;RESTORE THE USERS AC'S FOR HIM
	EXCH	1,-1(P)
	EXCH	0,-2(P)
	GO	@-2(P)		;GO TO HIS ROUTINE 
	JFCL			;SUPPORT MULTIPLE RETURNS
	JFCL
	EXCH	2,0(P)		;SAVE USERS AC'S AGAIN
	EXCH	1,-1(P)
	EXCH	0,-2(P)

SPC0:	MOVE	0,ERCNT		;GET THE CURRENT ERROR COUNT
	CAIG	0,1		;IS THIS THE FIRST ERROR ?
	JRST	SPC1		;YES
	TLNN	2,(1B8)		;IS SWITCH 8 SET ?
	JRST	SCP2A		;NO. DON'T REPORT MULTIPLE ERRORS
SPC1:	GO	ERHDR		;PRINT THE STANDARD ERROR HEADING
	HRRZ	0,-3(P)		;GET THE E-FIELD OF THE UUO
	JUMPE	0,SCOPE2	;BRANCH IF E-FIELD IS ZERO
	HRRZ	0,@-3(P)	;GET ADDR OF OPTIONAL PRINT ROUTINE
	JUMPE	0,SCP1A		;IS THERE ONE ?  BRANCH IF NOT.
	EXCH	2,0(P)		;RESTORE USERS AC'S FOR HIM
	EXCH	1,-1(P)
	EXCH	0,-2(P)
	GO	@-2(P)		;EXECUTE USERS ADDITIONAL ROUTINE
	JFCL			;SUPPORT MULTIPLE RETURNS
	JFCL
	EXCH	2,0(P)		;RE-SAVE USERS AC'S FOR HIM
	EXCH	1,-1(P)
	EXCH	0,-2(P)
	TEXT	.CRLF		;A CRLF FOR NEATNESS
SCP1A:	AOS	-3(P)		;BUMP E-FIELD POINTER
	SKIPN	@-3(P)		;IS THERE ANY TABLE DATA
	JRST	SCOPE2		;NO
	MOVE	0,@-3(P)	;FETCH TABLE WORD
	TLNN	0,(1B3)		;IS IT A BRANCH WORD (GO TO) ?
	JRST	SCP1B		;NO. MUST BE A MESSAGE
	SUBI	0,1 		;A BRANCH. ADJUST THE ADDRESS
	HRRM	0,-3(P)		;GIVES AN UPDATED E-FIELD
	JRST	SCP1A		;GET NEXT TABLE WORD
SCP1B:	TLNN	0,(1B5)		;SUBROUTINE CALL ?
	JRST	SCP1C		;NO. TRY NEXT OPTION
	EXCH	2,0(P)		;YES. RESTORE USERS AC'S
	EXCH	1,-1(P)
	EXCH	0,-2(P)
	GO	@-2(P)		;CALL USERS ROUTINE
	JFCL			;SUPPORT MULTIPLE RETURNS
	JFCL
	EXCH	2,0(P)		;SAVE USER AC'S AGAIN
	EXCH	1,-1(P)
	EXCH	0,-2(P)
	JRST	SCPMS3		;GO CHECK FOR LAST ENTRY IN TABLE
SCP1C:	TLNE	0,(1B2)		;WANT TO PRINT IF TXTINH SET ??
	JRST	SCPMS1		;YES
	TLNE	2,TXTINH	;NO. TXTINH SET ??
	JRST	SCPMS3		;YES.
SCPMS1:	TLNN	0,(1B0)		;A MODULE CALLOUT MESSAGE ??
	JRST	SCPMS2		;NO.
	TLNN	0,(1B1)		;YES.  LOW PROBABILITY MODULE ??
	JRST	SCPMS2		;NO.
	SKIPN	LOWPM		;YES.  ARE WE IN EXPANDED MODE ??
	JRST	SCPMS3		;NO.  THEN DON'T PRINT
SCPMS2:	PUT	0		;SAVE. NEED CTRL BITS LATER
	TLZ	0,-1		;CLEAR LEFT BITS SO THE UUO WORKS 
	TEXT	@0		;PRINT THE MSG
	TEXT	.CRLF		;PRINT A CRLF
	GET	0		;NEED THIS FOR CONTROL BITS
SCPMS3:	TLNN	0,(1B4)		;LAST ENTRY ??
	JRST	SCP1A		;NO. GET NXT MESSAGE
SCOPE2:	MOVEI	0,DASH10	;# OF DASHES IN SHORT PRINT MODE
	TLNN	2,TXTINH	;NORMAL OR SHORT MODE ?
	MOVEI	0,DASH40	;NORMAL GETS MORE DASHES
	TEXT	@0		;PRINT MULTIPLE DASHES
	TEXT	.CRLF		;PRINT A CRLF
SCP2A:	TLNN	2,(1B5)		;WANT TO RING BELL ON ERROR ?
	JRST	SCOPE3		;NO
	MOVE	0,BELL		;YES. PICK UP THE CHARACTER
	PNTAF			;AND FORCE PRINT IT
SCOPE3:	SKIPE	USER		;ARE WE IN USER MODE ?
	JRST	BRANCH		;YES. DON'T ALLOW HALTS
	TLNE	2,(1B7)		;WANT TO HALT ON ERROR ?
	ERRHLT			;YES. THEN HALT !!
BRANCH:	MOVE	0,ERCNT		;GET THE ERROR COUNT
	IOR	0,ERFLG		;OR-IN THE FLAG
	SKIPN	0		;TIME TO INIT ERRPC ??
	SETZM	ERRPC		;YES
	TLNN	2,(1B6)		;CONTINUE ON ERROR ?
	SETZM	ERCNT		;YES. CLEAR TOTAL ERROR COUNT
	TLNN	2,(1B6)		;SWITCH 6 SET ?
	JRST	BREX1		;NO. CONTINUE
	SKIPN	ERCNT		;ANY ERROR ?
	JRST	BREX1		;NO. CONTINUE
	HRRZ	0,ERRPC		;GET ERROR PC
	HRRZ	1,SCPPC		;GET SCOPE PC
	CAME	1,0		;TIME TO LOOP YET
	JRST	BREX1		;NO. TAKE SKIP RETURN
	HLRZ	0,ERRPC		;GET THE ASSOCIATED COUNTS
	HLRZ	1,SCPPC		;LIKEWISE
	CAMGE	1,0		;ARE WE THERE YET ?
	JRST	BREX1		;NO. TAKE THE SKIP RETURN
	SETZM	SCPPC		;TIME TO LOOP.
	SKIPE	ERFLG		;ERROR THIS TIME ??
	JRST	BREXC		;YES. NO NEED TO DO I/O. ITS BEEN DONE
	JFCL			;NO. MUST DO I/O ROUTINE
	HRRZ	0,-3(P)		;GET E-FIELD OF UUO
	JUMPE	0,BREXC		;BRANCH IF E-FIELD IS ZERO
	HLRZ	0,@-3(P)	;GET ADDR OF USER I/O OPTION ROUTINE
	JUMPE	0,BREXC		;IS THERE ONE ?
	EXCH	2,0(P)		;RESTORE THE USERS AC'S FOR HIM
	EXCH	1,-1(P)
	EXCH	0,-2(P)
	GO	@-2(P)		;GO TO HIS ROUTINE 
	JFCL			;SUPPORT MULTIPLE RETURNS
	JFCL
	EXCH	2,0(P)		;SAVE USERS AC'S AGAIN
	EXCH	1,-1(P)
	EXCH	0,-2(P)
	JRST	BREXC		;TAKE NON-SKIP RETURN
BREX1:	AOS	-5(P)		;BUMPS THE RETURN ADDRESS
BREXC:	SETZM	ERFLG		;CLEAR ERROR FLAG
	GET	2		;RESTORE THINGS
	GET	1
	GET	0
	GET	$SVUUO
	GET	$SVUPC
	RTN			;AND EXIT THE UUO FROM HERE.
;PRINT THE STANDARD HEADER MESSAGES

ERHDR:	PUT	0		;SAVE AC

;THE STACK NOW LOOKS LIKE THIS
; -7(P) RETURN ADDR FOR THE SCOPE UUO
; -6(P) PC FROM WHICH SCOPE WAS EXECUTED
; -5(P) THE ACTUAL UUO THAT WAS EXECUTED "SCOPE"
; -4(P) AC0 BEFORE SCOPE
; -3(P) AC1 BEFORE SCOPE
; -2(P) AC2 BEFORE SCOPE
; -1(P) RTN ADDR FROM ERHDR
;  0(P) AC0 BEFORE ERHDR

	TEXT	[ASCIZ/
ERROR: /]
	TLNE	2,TXTINH	;NORMAL OR SHORT PRINTOUT
	JRST	ERSHRT		;SHORT PRINTOUT WANTED
ERNRML:	TEXT	[ASCIZ/TEST-/]
	MOVE	0,TSTNAM	;GET TEST NUMBER OR NAME
	TLNN	0,777777	;ANY LEFT SIDE BITS SET ?
	JRST	.+3		;NO. ASSUME OCTAL
	PNTSIX			;YES. ASSUME SIXBIT
	SKIPA
	GO	POCT		;AND PRINT IT IN OCTAL
	TEXT	[ASCIZ/
SCOPE PC = /]
	HRRZ	0,-6(P)		;GET ADR WHERE SCOPE WAS CALLED
	PNT6			;PRINT THE SCOPE PC
	TEXT	[ASCIZ/  START ADR OF TEST = /]
	MOVE	0,TESTPC	;GET THE ADDRESS OF START OF TEST
	PNT6			;AND PRINT IT
	TEXT	[ASCIZ/
DATA SWITCHES = /]
	MOVE	0,2		;PICK UP CURRENT SWITCHES IN EFFECT
	PNTHW			;AND PRINT THEIR STATE
	JRST	HDREX		;AND GO TO COMMON EXIT CODE

ERSHRT:	TEXT	[ASCIZ/SCOPE PC-/]
	HRRZ	0,-6(P)		;PICK UP ERROR PC
	PNT6			;PRINT THE ERROR PC
	TEXT	[ASCIZ/TST-/]
	MOVE	0,TSTNAM	;GET THE TEST NUMBER
	TLNN	0,777777	;ANY LEFT SIDE BITS SET ?
	JRST	.+3		;NO. ASSUME OCTAL
	PNTSIX			;YES. ASSUME SIXBIT
	SKIPA
	GO	POCT		;PRINT THE TEST NUMBER IN OCTAL
	TEXT	[ASCIZ/ SW-/]
	MOVE	0,2		;GET DATA SWITCHES
	PNTHW			;PRINT THEIR STATE
HDREX:	TEXT	.CRLF		;A CRLF
	TEXT	.CRLF
	GET	0		;RESTORE THE AC
	RTN			;AND EXIT

.CRLF:	ASCIZ/
/

DASH10: ASCIZ/----------/

DASH40: ASCIZ/---------------------------------------/

	END
 