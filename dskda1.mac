SUBTTL	MEMORY RELIABILITY TEST

; **********************************************************************
;*BEGMEM - SETUP SECTION
; **********************************************************************

BEGMEM:	SUBTST
	SKIPE	USER
	JRST	TSTEND

	CLRAPR
	CLRPI+CHNON

	SWITCH
	TRNE	INHMEM		;INHIBIT MEMORY TESTING ?
	JRST	TSTEND		;YES

	JSR	TSTIME

	SETOM	MAPNEW		;DO 1024K MAPPING
	MAPMEM

	MOVE	[JRST	PARERR]	;SETUP SPECIAL PARITY ROUTINE
	MOVEM	$PARER

	SETOM	MERFST#		;SET FIRST ERROR FLAG
	SETOM	PARFST#		;SET PARITY FIRST ERROR FLAG
	SETZM	WASERR#		;CLEAR ERROR FLAG

	CONO	APR,LDPAER+LAPRP1
	MEMZRO			;CLEAR MEMORY
	CLRAPR
	CLRPI+CHNON

; **********************************************************************

MEMT0:	JRST	PHYTST		;PERFORM PHYSICAL ADDRESS 
MEMT1:	JRST	PATTST		;PERFORM DATA PATTERNS 

; **********************************************************************

	JRST	TSTEND
SUBTTL	MEMORY RELIABILITY - PHYSICAL ADDRESS TEST

; **********************************************************************
;*PHYTST - TEST EXECUTION CONTROL SEQUENCE
;*	1ST PASS, BOTTOM TO TOP, PHYSICAL ADDRESSES
;*	2ND PASS, TOP TO BOTTOM, COMPLEMENT PHYSICAL ADDRESSES
;*	RELIABILITY - REPEATS CHECK OF PHY ADDRESS 10 TIMES
;*	FAST CYCLE - CHECKS ONCE
; **********************************************************************

PHYTST:	SUBTST

	MOVEI	0
	MOVEM	TSTN#

	JSR	TSTIME

	SETOM	ADRFST#		;SET FIRST PASS FLAG
	MOVEI	PATIX,6		;PATTERN IS PHYSICAL ADDRESS

PHYTS1:	MOVEM	PATIX,PATXSV

	MOVE	TAC,CONSW
	TLNN	TAC,RELIAB
	SKIPA	TAC1,[^D1]
	MOVEI	TAC1,^D10

	SETZM	ADRSCM
	SETOM	GCFST		;SET FIRST TIME FLAG

	GO	PHYFIL		;FILL MEMORY WITH PHYSICAL ADDRESSES
	SETOM	GCFST
	GO	PHYCHK		;CHECK
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5

	SOJG	TAC1,.-4

	SETCMM	ADRFST		;SET FOR SECOND PASS
	AOS	PATIX

PHYDWN:	SUBTST

	SKIPN	ADRFST		;DONE ?
	JRST	PHYTS1		;NO, DO SECOND PASS

	JRST	MEMT1		;YES
SUBTTL	DATA PATTERNS TEST

; **********************************************************************
;*PATTST - TEST EXECUTION CONTROL SEQUENCE
;*	FILL MEMORY
;*	READ/RESTORE EXERCISE MEMORY
;*	BLOCK TRANSFER EXERCISE MEMORY
;*	FAST RATE ADDRESSING RD-COMP-WT EXERCISE MEMORY
; **********************************************************************

PATTST:	SUBTST

	MOVEI	1
	MOVEM	TSTN

	GO	MABIT		;SELECT FAST RATE ADDRESSING BIT

	GO	PATSEL		;SELECT DATA PATTERN

	GO	SEGINI

PATTS2:	SETOM	GCFST#		;SET FIRST TIME FLAG
	SETZB	PATIX,PATXSV#	;CLEAR PATTERN INDEX

PATTS1:	SETZM	SEGIX		;CLEAR SEGMENT INDEX
	SETZM	ADRSCM#		;SET ADDRESS SCHEME TO SEQ
	SETZM	FLTFLG#		;CLEAR FLOATING DATA FLAG
	SETZM	PRANF#		;CLEAR PARITY RANDOM FLAG
	JSR	TSTIME

	XCT	@DPATN(PATIX)	;GENERATE DATA PATTERN
	GO	GETADR		;GET ADDRESS CONTROL WORD
	GO	FILMEM		;FILL MEMORY WITH PATTERN
	GO	GETADR
	GO	MRDRST		;READ/RESTORE MEMORY
	GO	GETADR
	GO	MCHECK		;TEST MEMORY
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5		;LOOP

PATBLT:	SUBTST
	SETOM	ADRSCM		;SET ADDRESS SCHEME TO BLT
	GO	GETADR
	GO	BLTEX		;BLOCK TRANSFER EXERCISE
	GO	GETADR
	GO	MCHECK		;TEST MEMORY
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5		;LOOP

PATFR:	SUBTST
	SKIPGE	SVMA
	JRST	PATTS1		;IF SVMA NEG, DON'T DO FAST RATE
	SETOM	FRFST#		;SET FAST RATE FIRST TIME FLAG
	GO	FASTR		;SETUP FAST RATE ADDRESSING
	JRST	.+10		;FAST RATE COMPLETED
	GO	GETADR
	GO	FRRCW		;RD-COMP-WRT, FAST RATE
	GO	GETADR
	GO	MCHECK		;TEST MEMORY
	GO	ERLPCK		;ERROR LOOP CHECK
	JRST	.-5		;LOOP
	JRST	.-10		;REPEAT FR FOR ALL ADR BITS

	JRST	PATTS1		;REPEAT SEQUENCE FOR NEXT PATTERN
SUBTTL	MEMORY RELIABILITY - SUBROUTINES

; **********************************************************************
;*COMPSZ - CREATE ADDRESS CONTROL POINTERS
; **********************************************************************

COMPSZ:	HRRZ	MAXMEM#
	AOS			;COMPUTE NEG WORD COUNT
	SUBI	400000		;START VIRTUAL ADR IS 400000
	MOVNS
	HRLI	400000
	MOVSM	ADRLST		;SAVE FOR ADRCON POINTERS
	SETZM	ADRLST+1
	RTN

; **********************************************************************
;*SEGSET - SEGMENT SETUP FOR TESTING SEQUENCE
; **********************************************************************

SEGSET:	SKIPE	TSTSEG#		;SINGLE SEGMENT SELECTED ?
	JRST	XPOPJ1		;YES, RETURN +2
	AOS	SEGNBR#		;INC SEGMENT NUMBER
	MOVE	SEGNBR
	CAILE	7		;COMPLETED ALL SEGMENTS ?
	JRST	XPOPJ1		;YES, RETURN +2
	MEMSEG
	FATAL
	JUMPE	.-6		;NO MEMORY IN THIS SEGMENT
	TLZ	400000		;DON'T CARE IF COMBINED MEMORY
	MOVEM	MAXMEM		;SAVE MAXIMUM VIRTUAL ADDRESS
	GO	COMPSZ		;CREATE ADDRESS POINTERS
	RTN

SEGINI:	SETOM	SEGNBR		;INITIALIZE FOR SEGMENT 0
	GO	SEGSET
	RTN
	RTN

; **********************************************************************
;*PHYFIL - PHYSICAL ADDRESS FILL ALL OF MEMORY
;*	1ST - PHYSICAL ADDRESS IN PHYSICAL ADDRESS
;*	2ND - COMPLEMENT PHY ADR IN PHY ADR DOWNWARD
;*	BASIC PART OF ROUTINE OPERATES IN THE FAST AC'S
; **********************************************************************

PHYFIL:	MOVE	TSTAC,[MOVEM	PATRN,(ADRCON)]	;SETUP AC'S
	MOVE	TSTAC+1,[ADDI	PATRN,1]
	MOVE	TSTAC+2,[ADDI	ADRCON,1]
	MOVE	TSTAC+3,[AOJN	CNT,TSTAC]
	MOVE	TSTAC+4,[JRST	PF1]

	SKIPN	ADRFST
	MOVE	TSTAC+2,[SUBI	ADRCON,1]

PF1:	JSR	TSTIME

	MOVE	PSEG#		;GET PHY SEGMENT ADR
	SKIPN	ADRFST
	JRST	PF2		;2ND PASS

	SKIPE	GCFST
	MOVE	MEMLOW		;INITIAL START AT BREAK ABOVE JOBFF
	SKIPN	GCFST
	ADDI	1000		;STEP UP A PAGE
	CAML	[3,,-1]		;COMPLETED ALL 1024K ?
	RTN			;YES

PF3:	MOVEM	PSEG
	SETZM	GCFST
	MEMSEG			;SETUP PHY MEMORY SEGMENT
	FATAL
	JUMPE	0,PF1		;NO MEMORY
	MOVEI	400000		;1ST, START FROM 400000 VIRTUAL
	SKIPN	ADRFST
	TRO	777		;2ND, DOWN FROM 400777 VIRTUAL
	MOVE	ADRCON,0
	MAPADR			;GET ACTUAL PHY ADR
	FATAL
	SKIPN	ADRFST		;1ST, USE PHY ADR
	SETCA			;2ND, USE COMPLEMENT OF PHY ADR
	MOVE	PATRN,0
	HRROI	CNT,-1000
	JRST	TSTAC		;PERFORM ROUTINE IN AC'S

PF2:	SKIPE	GCFST		;2ND PASS, COMP PHY ADR DOWN
	MOVSI	4		;INITIAL START AT 1024K-1
	SUBI	1000
	CAML	MEMLOW		;COMPLETED ?
	JRST	PF3		;NO
	RTN

; **********************************************************************
;*PHYCHK - PHYSICAL ADDRESS CHECK MEMORY
;*	FAST AC ROUTINE ONLY DIFFERENCE FROM "PHYFIL"
;*	ERROR DETECTED GOES TO MEMER0
; **********************************************************************

PHYCHK:	SETZM	MERCNT#
	SETZM	PARCNT#

	MOVE	TSTAC,[CAME	PATRN,(ADRCON)]
	MOVE	TSTAC+1,[GO	MEMER0]
	MOVE	TSTAC+2,[ADDI	PATRN,1]
	MOVE	TSTAC+3,[ADDI	ADRCON,1]
	MOVE	TSTAC+4,[AOJN	CNT,TSTAC]
	MOVE	TSTAC+5,[JRST	PF1]

	SKIPN	ADRFST
	MOVE	TSTAC+3,[SUBI	ADRCON,1]

	JRST	PF1

; **********************************************************************
;*DATA GENERATION ROUTINES
;*	ENTERED VIA XCT, NORMAL RETURN + 1
;*	DATA PATTERN COMPLETED, RETURN AND REPEAT
;*	DATA WORD PUT IN PATRN
; **********************************************************************

ONES:	GO	.+1		;ALL ONES
	SETOM	PATRN
	SKIPN	GCFST		;FIRST TIME
	JRST	GEXT1		;NO, EXIT
	SETZM	GCFST		;CLEAR FIRST TIME FLAG
	RTN

ZEROS:	GO	.+1		;ALL ZEROS
	SETZM	PATRN
	JRST	ONES+2

ALTB:	GO	.+1		;ALTERNATE BITS
	SKIPN	GCFST		;FIRST TIME
	JUMPL	PATRN,GEXT1	;NO, DATA COMPLETE
	SKIPE	GCFST
	MOVE	PATRN,[525252525252]
	JRST	JEX

PRAND:	GO	.+1		;PSEUDO RANDOM, PARITY BIT CHECK
	SETOM	PRANF
	SKIPE	GCFST
	JRST	.+3
	CAMN	PATRN,[123456,,701234]
	JRST	GEXT1		;DATA COMPLETED
	SKIPE	GCFST
	MOVE	PATRN,[123456,,701234]
	ROT	PATRN,3
	JRST	JEX+1

FLZRO:	GO	.+1		;FLOATING ZERO
	SETOM	FLTFLG
	SKIPN	GCFST
	JUMPG	PATRN,GEXT1	;DATA COMPLETED
	SKIPE	GCFST
	SKIPA	PATRN,[735673567356]
JEX:	ROT	PATRN,1		;ROTATE PATTERN WORD
	SETZM	GCFST
	RTN

FLONE:	GO	.+1		;FLOATING ONE
	SETOM	FLTFLG
	SKIPN	GCFST
	JUMPL	PATRN,GEXT1	;DATA COMPLETED
	SKIPE	GCFST
	SKIPA	PATRN,[042104210421]
	JRST	JEX
	JRST	JEX+1

SKPPAT:	GO	.+1		;THIS PATTERN SKIPPED

GEXT1:	SETOM	GCFST		;SET FIRST TIME FLAG
	SETZM	FLTFLG		;CLEAR FLOATING DATA FLAG
	SETZM	PRANF		;CLEAR PARITY RANDOM FLAG
	AOS	PATIX		;INCREMENT PATTERN INDEX
	MOVEM	PATIX,PATXSV
	SOS	(P)		;DECREMENT RETURN
	RTN			;RETURN TO XCT

DONE:	JRST	.+1
	GO	SEGSET
	JRST	PATTS2
	JRST	MEMT1+1

; **********************************************************************
;*PATSEL - DATA PATTERN SELECTION
; **********************************************************************

PATSEL:	MOVEI	SKPPAT		;INITIALIZE PATTERNS TABLE
	MOVEM	DPATN
	MOVEM	DPATN+1
	MOVEM	DPATN+2
	MOVEM	DPATN+3
	MOVEM	DPATN+4
	MOVEM	DPATN+5
	HLRZ	AC12,RANDBS
	ANDI	AC12,7		;GET RANDOM SELECTION DIGIT
	GO	@SETPAT(AC12)	;SETUP PATTERNS TO DO
	RTN

; **********************************************************************
;*GETADR - GET ADDRESS CONTROL WORD FROM LIST
;*	PUT IT IN ADRCON
;*	IF WORD = 0, RETURN +2
;*	OTHERWISE, INCREMENT INDEX, RETURN +1
; **********************************************************************

GETADR:	MOVE	ADRCON,ADRLST(SEGIX)	;GET ADR CONTROL WORD
	JUMPE	ADRCON,.+3	;IS IT 0
	AOS	SEGIX		;NO, INC INDEX
	RTN			;EXIT
	SETZM	SEGIX		;YES, CLEAR INDEX
	AOS	(P)
	RTN			;RETURN +2

; **********************************************************************
;*FILMEM - FILL MEMORY SEGMENT
;*	DATA IN PATRN
;*	ADDRESS CONTROL WORD IN ARDCON
;*	WHEN COMPLETED RETURN -1
;*	ROUTINE OPERATES IN FAST AC'S
; **********************************************************************

FILMEM:	JSR	TSTIME
	SKIPE	FLTFLG		;FLOATING DATA WORD
	JRST	FMFLT		;YES
	SKIPE	PRANF		;PARITY RANDOM
	JRST	FMPRN		;YES
	MOVE	TSTAC,[MOVEM PATRN,(ADRCON)]	;SETUP AC'S
	MOVE	TSTAC+1,[AOBJN ADRCON,TSTAC]
	MOVE	TSTAC+2,[JRST XPOPM1]
	JRST	TSTAC		;PERFORM FILL MEMORY
FMFLT:	MOVE	AC11,PATRN	;DON'T CHANGE PATRN
	MOVE	TSTAC,[MOVEM	AC11,(ADRCON)]	;DATA ROTATES WD TO WD
	MOVE	TSTAC+1,[ROT	AC11,1]
	MOVE	TSTAC+2,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+3,[JRST	XPOPM1]
	JRST	TSTAC
FMPRN:	MOVE	AC12,PATRN
	MOVE	TSTAC,[MOVEM	AC12,(ADRCON)]
	MOVE	TSTAC+1,[MOVNS	AC12]
	MOVE	TSTAC+2,[ROT	AC12,1]
	MOVE	TSTAC+3,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+4,[JRST	XPOPM1]
	JRST	TSTAC

; **********************************************************************
;*MRDRST - READ/RESTORE MEMORY
;*	PERFORMS READ/RESTORE CYCLE 20 TIMES
;*	ADDRESS CONTROL WORD IN ADRCON, USED IN TAC
;*	ITERATION COUNT IN TAC1
;*	ROUTINE OPERATES IN THE FAST AC'S
; **********************************************************************

MRDRST:	JSR	TSTIME
	MOVE	CONSW
	TLNN	RELIAB		;RELIABILITY ?
	SKIPA	TAC1,[^D1]	;NO, PERFORM R/R ONCE
	MOVEI	TAC1,^D20	;YES, PERFORM R/R 20 TIMES
	MOVE	TAC,ADRCON
	MOVE	TSTAC,[MOVE	ADRCON,TAC]	;SETUP AC'S
	MOVE	TSTAC+1,[CAM	(ADRCON)]
	MOVE	TSTAC+2,[AOBJN	ADRCON,TSTAC+1]
	MOVE	TSTAC+3,[SOJN	TAC1,TSTAC]
	MOVE	TSTAC+4,[JRST RDRTN]
	JRST	TSTAC		;PERFORM READ/RESTORE
RDRTN:	JRST	XPOPM1		;RETURN -1

; **********************************************************************
;*BLTEX - BLOCK TRANSFER MEMORY EXERCISE
;*	PERFORM 1 OR 20 TIMES
;*	DOES BLT OF DATA FROM/TO SAME LOCATIONS
;*	ROUTINE OPERATES IN THE FAST AC'S
; **********************************************************************

BLTEX:	JSR	TSTIME
	MOVE	CONSW
	TLNN	RELIAB		;RELIABILITY ?
	SKIPA	TAC1,[^D1]	;NO, PERFORM BLT ONCE
	MOVEI	TAC1,^D20	;YES, PERFORM BLT 20 TIMES
	HRRZ	TAC,ADRCON
	HLRE	AC14,ADRCON
	MOVMS	AC14
	ADD	AC14,TAC	;SETUP AC14 = 0,LAST ADR
	HRLS	TAC		;SETUP TAC = FIRST ADR,FIRST ADR
	MOVE	TSTAC,[MOVE	AC13,TAC]
	MOVE	TSTAC+1,[BLT	AC13,-1(AC14)]
	MOVE	TSTAC+2,[SOJN	TAC1,TSTAC]
	MOVE	TSTAC+3,[JRST	BLTRTN]
	JRST	TSTAC		;PERFORM BLT ROUTINE
BLTRTN:	JRST	XPOPM1		;RETURN -1

; **********************************************************************
;*MCHECK - CHECK MEMORY SEGMENT
;*	ADDRESS CONTROL WORD IN ADRCON
;*	COMPARE DATA IN PATRN
;*	ERROR DETECTED, GOES TO MEMER0
;*	ROUTINE OPERATES IN THE FAST AC'S
; **********************************************************************

MCHECK:	SETZM	MERCNT
	SETZM	PARCNT
	JSR	TSTIME

	SKIPE	FLTFLG		;FLOATING DATA WORD
	JRST	CKFLT		;YES

	SKIPE	PRANF		;PARITY RANDOM
	JRST	CKPRN		;YES

	MOVE	TSTAC,[CAME PATRN,(ADRCON)]	;SETUP AC'S
	MOVE	TSTAC+1,[GO MEMER0]
	MOVE	TSTAC+2,[AOBJN ADRCON,TSTAC]
	MOVE	TSTAC+3,[JRST CKRTN]
	CONO	APR,LDPAER+LAPRP1	;DISABLE PARITY INTERRUPTS
	JRST	TSTAC		;PERFORM ERROR CHECK

CKFLT:	MOVE	AC12,PATRN	;DON'T CHANGE PATRN
	MOVE	TSTAC,[CAME	AC12,(ADRCON)]	;DATA ROTATES WD TO WD
	MOVE	TSTAC+1,[GO	MEMER1]
	MOVE	TSTAC+2,[ROT	AC12,1]
	MOVE	TSTAC+3,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+4,[JRST	CKRTN]
	CONO	APR,LDPAER+LAPRP1	;DISABLE PARITY INTERRUPTS
	JRST	TSTAC

CKPRN:	MOVE	AC13,PATRN	;DON'T CHANGE PATRN
	MOVE	TSTAC,[CAME	AC13,(ADRCON)]
	MOVE	TSTAC+1,[JRST	ERPRN]
	MOVE	TSTAC+2,[MOVNS	AC13]
	MOVE	TSTAC+3,[ROT	AC13,1]
	MOVE	TSTAC+4,[AOBJN	ADRCON,TSTAC]
	MOVE	TSTAC+5,[JRST	CKRTN]
	JRST	CKFLT-3

ERPRN:	MOVEM	AC13,GDWORD
	GO	MEMER2
	JRST	TSTAC+2

CKRTN:	CLRAPR
	CLRPI+CHNON
	JRST	XPOPM1

; **********************************************************************
;*FASTR - FAST RATE ADDRESSING SETUP
;*	SETS UP FAST RATE BIT WHICH IS ADDED
;*	TO THE ADDRESS WORD, STARTS WITH 1B35
;*	GOES TO 1B18
;*	FAST RATE WORD IN FRBIT
;*	NORMAL-RETURN +2, COMPLETED - RETURN +1
; **********************************************************************

FASTR:	SKIPN	SVMA		;ALL MA BITS ?
	JRST	FASTR1		;YES

	MOVE	FRBIT,SVMA
	SKIPE	FRFST		;FIRST TIME ?
	JRST	FASTR2		;YES
	RTN			;NO, DONE, EXIT

FASTR1:	SKIPE	FRFST		;FIRST TIME
	SKIPA	FRBIT,[1]	;YES, START WITH 1B35
	ROT	FRBIT,1		;ROTATE ONE LEFT
	TLNE	FRBIT,1		;ALL BITS DONE
	RTN			;YES, EXIT

FASTR2:	MOVEM	FRBIT,ADRSCM	;SET ADDRESS SCHEME TO FAST RATE
	SETZM	FRFST		;CLEAR FIRST TIME FLAG
	JRST	XPOPJ1		;RETURN +2

; **********************************************************************
;*MABIT - FAST RATE MA BIT SELECTION
; **********************************************************************

MABIT:	MOVE	RANDBS		;GET RANDOM BASE NUMBER
	ANDI	37		;MAKE INTO RANGE 8. TO 39.
	ADDI	10
	CAIL	^D18		;IF 18. TO 35. USE AS FAST RATE BIT
	CAILE	^D35
	JRST	MABIT1		;OTHERWISE, DO ALL FAST RATE MA BITS
	MOVNM	TAC		;SETUP MA BIT IN PROPER POSITION
	MOVSI	400000
	LSH	(TAC)
	MOVEM	SVMA#		;SAVE FOR FAST RATE
	RTN

MABIT1:	SETZM	SVMA
	CAIGE	^D18		;IF 0. TO 17., DON'T DO FAST RATE
	SETOM	SVMA		;IF 36. TO 39. DO ALL FAST RATE BITS
	RTN

; **********************************************************************
;*FRRCW - FAST RATE ADDRESS
;*	READ-COMPLEMENT-WRITE
;*	ADDRESS CONTROL WORD IN ADRCON
;*	USED IN MFIRST, MLAST, ADR, ADRCON
;*	FAST RATE ADDRESS BIT IN FRBIT
;*	ROUTINE OPERATES IN THE FAST AC'S
; **********************************************************************

FRRCW:	JSR	TSTIME
	MOVEM	PATRN,ACEE1#
	MOVEM	PATIX,ACEE2#	;SAVE THREE AC'S
	MOVEM	SEGIX,ACEE3#
	MOVE	AC14,CONSW	;GET SWITCHES
	TLNN	AC14,RELIAB	;FAST MODE
	SKIPA	1,[^D2]		;YES, PERFORM TWICE
	MOVEI	1,^D20		;NO, PERFORM 20 TIMES
	HRRZ	MFIRST,ADRCON	;SETUP MFIRST = 0, FIRST ADR
	HLRE	MLAST,ADRCON
	MOVMS	MLAST
	ADD	MLAST,MFIRST	;SETUP MLAST = 0,LAST ADR
	HLLZ	CNT,ADRCON	;SETUP COUNT = COUNT,0
	CAML	FRBIT,MLAST	;ADDRESS BIT GREATER THAN SEG
	JRST	FREXT		;YES, EXIT
	MOVEM	MFIRST,SVFRST#	;SAVE CONTROL WORDS
	MOVEM	CNT,SVCNT#

	MOVE	TSTAC,[MOVE ADRCON,MFIRST]
	MOVE	TSTAC+1,[SETCMM	(ADRCON)]
	MOVE	TSTAC+2,[AOBJN	CNT,TSTAC+4]
	MOVE	TSTAC+3,[JRST	FRRTN]
	MOVE	TSTAC+4,[ADD	ADRCON,FRBIT]
	MOVE	TSTAC+5,[CAMGE	ADRCON,MLAST]
	MOVE	TSTAC+6,[JRST	TSTAC+1]
	MOVE	TSTAC+7,[AOJA	MFIRST,TSTAC]
	JRST	TSTAC		;PERFORM ROUTINE

FRRTN:	SOJE	1,FREXT		;COMPLETED ITERATIONS ?
	MOVE	MFIRST,SVFRST	;NO, RESET CONTROL WORDS
	MOVE	CNT,SVCNT
	JSR	TSTIME
	JRST	TSTAC		;REPEAT SEQUENCE

FREXT:	MOVE	PATRN,ACEE1
	MOVE	PATIX,ACEE2	;RESTORE AC'S
	MOVE	SEGIX,ACEE3
	JRST	XPOPM1		;EXIT-1

; **********************************************************************
;*DPATN - DATA PATTERNS TEST
;*	PATTERN EXECUTE LIST
; **********************************************************************

DPATN:	ONES			;ALL ONES
	ZEROS			;ALL ZEROS
	ALTB			;ALTERNATE ONES AND ZEROS
	FLONE			;FLOATING ONE
	FLZRO			;FLOATING ZERO
	PRAND			;PSEUDO RANDOM, PARITY BIT CHECK
	DONE			;TEST EXIT

; **********************************************************************
;*DPATPT - PATTERN MNEMONICS LIST
; **********************************************************************

DPATPT:	ASCII	/ONES /
	ASCII	/ZEROS/
	ASCII	/ALTB /
	ASCII	/FLONE/
	ASCII	/FLZRO/
	ASCII	/PRAND/

	ASCII	/PADR /
	ASCII	/CPADR/

; **********************************************************************
;*ERLPCK - LOOP ON ERROR CHECK
; **********************************************************************

ERLPCK:	JSR	TSTIME

	SWITCH
	TLNN	0,LOOPER	;LOOP ON ERROR ?
	JRST	.+3		;NO
	SKIPE	WASERR		;YES, WAS THERE AN ERROR ?
	RTN			;YES, LOOP ON EXERCISE/CHECK
	SETZM	WASERR		;NO LOOP, CLEAR ERROR INDICATOR
	JRST	XPOPJ1		;RETURN +2

; **********************************************************************
;*SETPAT - DATA PATTERNS SETUP LIST
; **********************************************************************

SETPAT:	ALLPAT			;ALL DATA PATTERNS
	SET1S			;ONES
	SET0S			;ZEROS
	SETALT			;ALT BITS
	SETFL1			;FLOATING ONES
	SETFL0			;FLOATING ZEROS
	STFL10			;FLOATING ONES/FLOATING ZEROS
	SETPRN			;PSEUDO RANDOM, PARITY BIT CHECK

ALLPAT:	GO	SET1S
	GO	SET0S
	GO	SETALT
	GO	SETFL1
	GO	SETFL0
	GO	SETPRN
	RTN

SET1S:	MOVEI	ONES
	MOVEM	DPATN
	RTN

SET0S:	MOVEI	ZEROS
	MOVEM	DPATN+1
	RTN

SETALT:	MOVEI	ALTB
	MOVEM	DPATN+2
	RTN

SETFL1:	MOVEI	FLONE
	MOVEM	DPATN+3
	RTN

SETFL0:	MOVEI	FLZRO
	MOVEM	DPATN+4
	RTN

STFL10:	GO	SETFL1
	GO	SETFL0
	RTN

SETPRN:	MOVEI	PRAND
	MOVEM	DPATN+5
	RTN
SUBTTL	MEMORY RELIABILITY, ERROR ROUTINES

; **********************************************************************
;*MEMER0 - ERROR TYPEOUT ROUTINE
;*	PRINTS ERRORS AS THEY OCCUR
;*	TOTALIZES ERRORS FOR TOTALS PRINTOUT
; **********************************************************************

MEMER0:	MOVEM	PATRN,GDWORD#	;SAVE GOOD WORD
	CAIA

MEMER1:	MOVEM	AC12,GDWORD

MEMER2:	MOVEM	0,ACEEE0#	;SAVE AC0

	HRRZ	ADRCON
	MOVEM	ERRPC		;SAVE ERROR PC

	MOVE	0,(ADRCON)	;GET ERROR WORD
	MOVEM	0,BADWRD#	;SAVE

	MOVEM	10,ACE10#	;SAVE AC'S
	MOVEM	11,ACE11#
	MOVEM	12,ACE12#
	MOVEM	13,ACE13#

	MOVE	10,GDWORD	;FIND FAILING BITS
	XOR	10,BADWRD
	MOVEM	10,FAIL#	;SAVE FAILED BITS

	HRRZ	ADRCON		;CONVERT VIRTUAL ADDRESS TO PHYSICAL ADDRESS
	MAPADR
	ERRHLT
	MOVEM	PHYADR#

	SETOM	WASERR		;SET ERROR FLAG

MEMER3:	SKIPN	MERFST		;FIRST ERROR
	JRST	MEMER4		;NO

	JSR	TTLPNT

	PNTMSG	[ASCIZ/
MEMORY DATA ERROR
TN  AS  PAT  ADDRESS      CORRECT         ERROR       FAILED BITS PAR
/]

MEMER4:	SWITCH
	TLNE	PALERS		;PRINT ALL ERRORS ?
	JRST	MEMER5		;YES
	MOVE	MERCNT
	CAIL	^D10		;PRINTED ALLOWED ?
	JRST	MEMER7		;YES

MEMER5:	MOVE	TSTN		;PRINT TEST NUMBER
	PNT1
	PSP

	SKIPLE	ADRSCM		;SEQUENTIAL ADDRESSING ?
	JRST	FRPNT		;NO

	MOVEI	[ASCII/SEQ/]	;YES, PRINT 'SEQ'
	SKIPE	ADRSCM
	MOVEI	[ASCII/BLT/]
	PNTA

MEMER6:	PSP
	MOVEI	DPATPT(PATIX)
	PNTA			;PRINT DATA PATTERN
	PSP

	MOVE	PHYADR
	PNTADR			;PRINT ADDRESS
	PSP
	PSP

	MOVE	GDWORD
	PNTHW			;PRINT CORRECT
	PSP

	MOVE	BADWRD
	PNTHW			;PRINT ERROR
	PSP

	MOVE	FAIL
	PNTHW			;PRINT FAILED BITS

	GO	PARCK		;CHECK PARITY
	PNTCI	"P"		;YES, PRINT 'P'
	PCRL

MEMER7:	SETZM	MERFST		;CLEAR FIRST ERROR FLAG
	SETOM	PARFST		;SET FIRST PARITY FLAG
	AOS	ERRTLS

	SWITCH
	TLNE	0,DING		;RING BELL ON ERROR
	PBELL

	GO	PARCK		;CHECK PARITY
	AOS	TOTPAR		;YES, INCREMENT PARITY TOTAL

	MOVE	10,TSTN		;INCREMENT TEST ERROR TOTAL
	AOS	TOTPAT-1(10)

	MOVE	10,GDWORD	;DETERMINE BITS PICKED UP
	MOVE	11,BADWRD
	ANDCA	10,11
	MOVEM	10,PICKED#	;SAVE
	SETZ	13,
	GO	ERRADD

	MOVE	10,GDWORD	;DETERMINE BITS DROPPED
	MOVE	11,BADWRD
	ANDCM	10,11
	MOVEM	10,DROPED#	;SAVE
	AOS	13
	GO	ERRADD

	SKIPN	PICKED		;ANY DATA PICKUP FAILURES
	JRST	MEMER8		;NO

	MOVE	10,PHYADR	;DETERMINE ADR BITS WITH PICKUP
	LSH	10,^D14
	AOS	13
	GO	ERRADD

MEMER8:	SKIPN	DROPED		;ANY DATA DROPPED FAILURES
	JRST	MEMER9		;NO

	MOVE	10,PHYADR	;DETERMINE ADR BITS WITH DROPOUT
	LSH	10,^D14
	MOVE	13,[3]
	GO	ERRADD

MEMER9:	MOVE	10,ACE10	;RESTORE AC'S
	MOVE	11,ACE11
	MOVE	12,ACE12
	MOVE	13,ACE13

	MOVE	0,GDWORD	;FIX ERROR
	MOVEM	0,(ADRCON)

	GO	ERCHK		;CHK FOR ERROR LIMIT

	MOVE	0,ACEEE0	;RESTORE AC0
	CLRAPR
	CLRPI+CHNON
	RTN			;RETURN TO CHECK

; **********************************************************************
;*ERRADD - ERROR TOTALIZING ADDITION SUBROUTINE
; **********************************************************************

ERRADD:	JFFO	10,.+2		;COMPUTE BIT POSITION
	RTN			;NO ERRORS
	XCT	ADDTOT(13)	;INCREMENT ERROR TOTAL
	MOVNS	11
	HRLZI	12,400000	;CLEAR THIS BIT POSITION
	LSH	12,(11)
	TDZ	10,12
	JRST	.-7		;GET NEXT POSITION WITH FAILURE

ADDTOT:	AOS	PCKDB(11)	;ADD 1 TO DATA PICKUP TOTAL
	AOS	DRPDB(11)	;ADD 1 TO DATA DROPOUT TOTAL
	AOS	PCKAB(11)	;ADD 1 TO ADR BIT WITH DATA PICKUP
	AOS	DRPAB(11)	;ADD 1 TO ADR BIT WITH DATA DROPOUT

FRPNT:	PNTCI	"F"		;FAST RATE ADDRESSING

	MOVE	10,ADRSCM	;GET FAST RATE BIT
	JFFO	10,.+1		;COMPUTE BIT POSITION
	MOVE	11
	PNTDEC			;PRINT IT
	JRST	MEMER6		;CONTINUE PRINTOUT

ERCHK:	SKIPL	MONCTL		;DON'T CHK IF STAND-ALONE
	RTN
	GO	ERRTOT		;ADD ERROR TOTALS
	CAIG	0,^D25		;25 ALLOWABLE ERRORS
	RTN			;OK
	JRST	@RETURN		;EXCEEDED LIMIT

; **********************************************************************
;*TOTAL - TOTAL ERRORS TYPEOUT ROUTINE
; **********************************************************************

TOTAL:	SKIPE	USER		;TEST NOT DONE IN USER MODE
	RTN

	PNTMSG	[ASCIZ/
* MEMORY TOTALS *
DATA ERROR TOTALS = /]
	MOVE	TOTPAT
	PNTDEC	

	PNTMSG	[ASCIZ/
PARITY ERROR TOTALS = /]
	MOVE	TOTPAR
	PNTDEC			;PRINT PARITY TOTALS

	GO	ERRTOT		;ADD ERROR TOTALS
	JUMPE	0,TOTRTN	;NO ERRORS

	PNTMSG	[ASCIZ/

DATA BIT FAILURES
BIT	    PICKUP   DROPOUT
/]

	SETZ	1,
TOTAL1:	MOVE	PCKDB(1)	;ANY ERRORS, THIS BIT
	ADD	DRPDB(1)
	JUMPE	TOTAL2		;NO
	MOVE	1		;YES, PRINT DATA BIT NUMBER
	PNTDEC
	PSP

	MOVE	PCKDB(1)
	PNTDS			;PRINT PICKUP TOTAL

	MOVE	DRPDB(1)
	PNTDS			;PRINT DROPOUT TOTAL

	PCRL

TOTAL2:	AOS	1		;INCREMENT INDEX
	CAIG	1,^D35		;DONE
	JRST	TOTAL1		;NO, REPEAT FOR NEXT BIT

	PNTMSG	[ASCIZ/

ADDRESS BITS WITH DATA FAILURES
BIT         PICKUP   DROPOUT
/]

	SETZ	1,
TOTAL3:	MOVEI	^D14(1)		;PRINT ADR BIT NUMBER
	PNTDEC

	MOVE	PCKAB(1)	;ANY ERRORS, THIS ADR BIT
	ADD	DRPAB(1)
	JUMPE	TOTAL4-1	;NO

	PTAB
	MOVE	PCKAB(1)
	PNTDS			;PRINT PICKUP TOTAL

	MOVE	DRPAB(1)
	PNTDS			;PRINT DROPOUT TOTAL

	PCRL
TOTAL4:	AOS	1		;INCREMENT INDEX
	CAIG	1,^D21		;DONE
	JRST	TOTAL3		;NO, REPEAT FOR NEXT BIT

TOTRTN:	PCRL
	SETOM	MERFST		;SET FIRST ERROR FLAG
	SETOM	PARFST		;SET PARITY FIRST ERROR FLAG
	RTN

; **********************************************************************
;*CLRERR - CLEAR ERROR TOTALS
; **********************************************************************

CLRERR:	SETZM	TOTPHY
	MOVE	[TOTPHY,,TOTPHY+1]
	BLT	DRPAB+^D21
	RTN

XPOPJ1:	AOS	(P)		;RETURN +2
	RTN

XPOPM1:	SOS	(P)		;RETURN-1
	SOS	(P)
	RTN

; **********************************************************************
;*PARCK - CHECK FOR PARITY ERROR
; **********************************************************************

PARCK:	CONSZ	APR,LPARER	;KL10
	RTN
	JRST	XPOPJ1

; **********************************************************************
;*ERRTOT - TOTALIZE MEMORY ERRORS
; **********************************************************************

ERRTOT:	MOVE	0,TOTPAT	;ADD ERROR TOTALS
	ADD	0,TOTPHY
	RTN
SUBTTL	MEMORY RELIABILITY, SPECIAL PARITY INTERRUPT ROUTINE

; **********************************************************************
;*PARERR - PARITY ERROR ROUTINE
; **********************************************************************

PARERR:	MOVEM	10,ACE10	;SAVE AC'S
	MOVEM	11,ACE11
	MOVEM	12,ACE12
	MOVEM	13,ACE13

	SKIPN	PARFST		;FIRST ERROR
	JRST	PARER1		;NO

	JSR	TTLPNT

	PNTMSG	[ASCIZ/
MEMORY PARITY ERROR
TN    PROG     PC    AS    PAT    ADDRESS        DATA       PARITY
/]

PARER1:	SWITCH
	TLNE	PALERS		;PRINT ALL ERRORS ?
	JRST	PARER2		;YES

	MOVE	PARCNT
	CAIL	^D10		;PRINTED ALLOWED ERRORS ?
	JRST	PARER4		;YES

PARER2:	MOVE	TSTN		;PRINT TEST NUMBER
	PNT1
	PSP
	PSP

	HRLZ	0,(P)		;PRINT LAST PUSHJ ENTRY
	HRR	0,ITRCH1	;AND PC OF INTERRUPTED
	SUB	0,[1,,1]	;LOCATION
	PNTHW
	PSP
	PSP

	SKIPLE	ADRSCM		;SEQUENTIAL ADDRESSING ?
	JRST	PFRPNT		;NO

	MOVEI	[ASCIZ/SEQ/]
	SKIPE	ADRSCM
	MOVEI	[ASCIZ/BLT/]
	PNTA

PARER3:	PSP
	PSP
	PSP

	MOVE	AC10,PATXSV	;GET SAVED PATTERN INDEX
	MOVEI	DPATPT(AC10)
	PNTA			;PRINT DATA PATTERN
	PSP
	PSP

	HRRZ	ADRCON
	MAPADR
	ERRHLT
	PNTADR			;PRINT PHYSICAL ADDRESS
	PSP
	PSP

	CAML	ADRCON,MAXMEM	;DOES CURRENT TEST ADR POINT TO MEMORY
	JRST	PARER4-1	;NO, OUTSIDE MEMORY
	MOVE	0,(ADRCON)	;GET CURRENT TEST ADR DATA
	PNTHW
	PSP
	PSP

	GO	PARCK		;CHECK PARITY
	PNTCI	"P"		;YES, PRINT 'P'
	PCRL

PARER4:	MOVE	10,CONSW
	TLNE	10,DING
	PBELL

	AOS	PARCNT		;INCREMENT PARITY COUNT
	AOS	TOTPAR		;INCREMENT PARITY TOTAL
	SETOM	MERFST		;SET FIRST ERROR FLAG
	SETZM	PARFST		;CLEAR FIRST PARITY FLAG

	HRRZ	0,ITRCH1	;GET INTERRUPT PC
	CAIG	0,17		;PARITY ERROR IN PROGRAM AREA
	JRST	PARER5		;NO

	HRRZ	(P)		;YES
	CAIG	0,17		;WAS PROGRAM IN AC'S ?
	JRST	PARER5		;YES

	PNTMSG	[ASCIZ/
**********
PARITY ERROR IN PROGRAM
PROGRAM OPERATION QUESTIONABLE FROM THIS POINT
**********
/]
	SETOM	PARFST		;SET FIRST PARITY FLAG

PARER5:	MOVE	AC10,ACE10	;RESTORE AC'S
	MOVE	AC11,ACE11
	MOVE	AC12,ACE12
	MOVE	AC13,ACE13

	GO	ERCHK		;CHK FOR ERROR LIMIT

	MOVE	0,$ACC0
	CONO	APR,LCPAER+LAPRP1
	JRST	10,@ITRCH1	;CONTINUE TEST

; **********************************************************************
;*PFRPNT - PARITY FAST RATE ADDRESSING PRINT
; **********************************************************************

PFRPNT:	PNTCI	"F"

	MOVE	AC10,ADRSCM	;GET FAST RATE BIT
	JFFO	AC10,.+1	;COMPUTE BIT POSITION
	MOVE	AC11
	PNTDEC			;PRINT IT
	JRST	PARER3

; **********************************************************************
;*ERROR TOTALS TABLE
; **********************************************************************

ADRLST:	BLOCK	2		;ADDRESS LIST

TOTPHY:	0			;PHYSICAL ADDRESS TEST TOTAL
TOTPAT:	0			;DATA PATERNS TEST TOTAL
TOTPAR:	0			;PARITY ERROR TOTAL

PCKDB:	BLOCK	^D36		;DATA BIT PICKUP TOTAL
DRPDB:	BLOCK	^D36		;DATA BIT DROPOUT TOTAL
PCKAB:	BLOCK	^D22		;ADDRESS BIT, DATA PICKUP, TOTAL
DRPAB:	BLOCK	^D22		;ADDRESS BIT, DATA DROPOUT, TOTAL
      