SUBTTL	DIAGNOSTIC SECTION FOUR

;COMPUTE MEMORY SIZE TO BE USED

MEMFD1:	SWITCH
	ANDI	0,777
	SKIPN	0		;MEMORY SIZE SPECIFIED ?
	JRST	MEMFD3		;NO, CHECK RELIAB & OPRSEL SWITCHES
MEMFD2:	LSH	0,9		;POSITION HIGH ORDER
	TRO	0,777		;SET LOW ORDER BITS
	AND	0,MEMSIZ+1	;AND WITH ACTUAL MEMORY
	HRRZM	0,MEMSIZ+1	;SAVE
	CAML	0,MEMLOW	;ENOUGH MEMORY FOR TEST ?
	JRST	MEMFD4		;YES
	MOVEI	[ASCIZ/
MEMORY SIZE SELECTED TOO SMALL/]
	PNTALF
	MOVEI	PGMNAM
	PNTALF
	ERRHLT
	JRST	START

MEMFD3:	MOVE	0,CONSW
	TLNE	RELIAB!OPRSEL	;IF EITHER RELIAB OR OPRSEL SWITCH SET
	JRST	MEMFD4		;USE ALL OF MEMORY
	MOVEI	77		;OTHERWISE LIMIT MEMORY TO 32K
	JRST	MEMFD2

MEMFD4:	MOVE	0,CONSW
	TLNE	0,CHAIN		;RUNNING IN CHAIN MODE ?
	JRST	PART4		;YES
	SKIPE	USER		;RUNNING IN USER MODE ?
	JRST	PART4		;YES
	SKIPE	MEMONC
	JRST	PART4
	PMSG	<TESTING >
	MOVE	MEMSIZ+1
	ADDI	0,1
	IDIVI	^D1024
	PNTDEC			;PRINT MEMORY SIZE BEING USED
	PMSG	<K^>
	SETOM	MEMONC
	JRST	PART4
;CONSTANTS

FLAGS:	XWD	AROV!CRY0!CRY1!FOV,0

;COMPUTE BUFFER SIZE TO BE USED

PART4:
MST1:	MOVE	1,MEMSIZ+1	;GET MEMORY SIZE
	MOVN	1,1		;MAKE (AC1) CONTAIN
	ADD	1,MEMLOW	; - HIGHEST MEM LOC + END OF PROG
	MOVS	1,1		;IN THE LEFT HALF
	HRR	1,MEMLOW	;END OF PROG IN RIGHT HALF
	MOVEM	1,BLOK#		;SAVE

MST2:	MOVE	1,MEMSIZ+1
	MOVS	2,1		;PUT HIGHEST MEMORY LOCATION
	HRR	2,1		;IN LEFT AND RIGHT HALF
	MOVEM	2,MODULO#	;OF MODULO
	MOVN	1,1		;MAKE C(AC1) CONTAIN
	ADD	1,MEMLOW	;-HIGHEST MEM LOC + END OF PROGRAM
	MOVS	1,1		;IN THE LEFT HALF
	HRR	1,MEMLOW	;END OF PROG IN RIGHT HALF
	MOVEM	1,WCBUF#	;SAVE
	SUB	1,[1,,0]
	MOVEM	1,BUFSIZ#
	JRST	MSADT		;GO PERFORM DIAGNOSTIC
	LALL
;FAST ADDRESS TEST TO CHECK MEMORY(S)

	AC=4
MSADT:	MOVEI	AC-1,.
	MOVEM	AC-1,TESTPC	;SETUP SUBTEST PC
	MOVEI	AC-1,<AC-1>&17	;INFORM ERROR ROUTINE WHICH AC IS
	MOVEM	AC-1,ERRLOP#	;USED FOR KEEPING PROG IN LOOP.
	SETZ	2,		;CLEAR AC2.
	MOVE	1,BLOK		;MOVE(-TOP+END) END INTO AC1.
MSADT2:	SKIPE	USER
	JRST	MSADT1
	CONO	APR,LDPAER!LAPRP1	 ;DISABLE PARITY
MSADT1:	MOVEM	1,(1)		;MOVE TO MEM.
	CAME	1,(1)		;DOES IT COMPARE?
	ERRM	1,1		;NO. PNT ERR MES.
	SKIPE	USER
	JRST	MSADT3
MSADT4:	CONSZ	APR,LPARER	;KL10 PARITY ERROR ?
	ER	1,[ASCII/PAR/]
	CONO	APR,LCPAER!LAPRP1
MSADT3:	JUMPL	AC-1,MSADT1(2)	;LOOP ON ERROR SWITCH.
	AOBJN	1,.+1		;FIX FOR GREATER THAN 128K MEM
	TLNE	1,770000
	JRST	MSADT1(2)	;ADD ONE AND TRY NEXT MEM LOC.
	XORI	2,1		;THIS MAKES C(AC2)=1 OR 0.
	SKIPE	2		;C(AC2)=0?... GONE THROUGH 2 PASSES.
	JRST	MSADT2		;NO..DO 2ND PASS...JUST COMPARE.
	SKIPE	USER
	JRST	TST1
	CONO	APR,LAPRAL!LAPRP1
;TEST MOVE, MOVEM, MOVES, HLLM, EXCH.  AFTER EXECUTING
;THESE 5 INSTRUCTIONS, THE C(AC) AND C(E) SHOULD STILL
;=RANDOM NUM.

	AC=10
TST1:	MSETUP
TST1A:	MRANDOM
TST1B:	MOVE	AC,(AC1)	;DO A MOVE...C(AC)+C(E) STAY SAME.
	MOVEM	AC,(AC1)	;DO A MOVEM...C(AC)+C(E) STAY SAME.
	MOVES	AC,(AC1)	;DO A MOVES...C(AC)+C(E) STAY SAME.
	HLLM	AC,(AC1)	;DO A HLLM...C(AC)+C(E) STAY SAME.
	EXCH	AC,(AC1)	;DO AN EXCH...C(AC)+C(E) STAY SAME.
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN.NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST1B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST1A		;INC. TO TEST NEXT LOC.

;TEST HLLS, HRRM, ANDM, SETAB.  AFTER
;EXECUTING THESE 4 INSTRUCTIONS, THE C(AC)+C(E)
;SHOULD STILL=RANDOM NUM.

	AC=1
TST2:	MSETUP
TST2A:	MRANDOM
TST2B:	HLLS	AC,(AC1)	;DO A HLLS INST...C(AC)+C(E) STAY SAME
	HRRM	AC,(AC1)	;DO A HRRM INST...C(AC)+C(E) STAY SAME
	ANDM	AC,(AC1)	;DO A HRRS INST...C(AC)+C(E) STAY SAME
	SETAB	AC,(AC1)	;DO A SETMM INST...C(AC)+C(E) STAY SAME.
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN NUM
	ERRM	RA,RA
	JUMPL	AC-1,TST2B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST2A		;INC TO TEST NEXT LOC.


;TEST SETMB, HRRS, IORB, SETAM, SETMM.  AFTER
;EXECUTING THESE 5 INSTRUCTIONS, THE C(AC)+C(E)
;SHOULD STILL=RANDOM NUMBER

	AC=2
TST3:	MSETUP
TST3A:	MRANDOM
TST3B:	SETMB	AC,(AC1)	;DO A SETMB. INST...C(AC)+C(E) STAY SAME
	HRRS	AC,(AC1)	;DO AN ANDM INST...C(AC)+C(E) STAY SAME
	IORB	AC,(AC1)	;DO AN ANDB INST...C(AC)+C(E) STAY SAME
	SETAM	AC,(AC1)	;DO A SETAM INST...C(AC)+C(E) STAY SAME
	SETMM	AC,(AC1)	;DO A SETAB INST...C(AC)+C(E) STAY SAME
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST3B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST3A		;INC TO TEST NEXT LOC.

;TEST IORM, ANDB, SETCMM, SETCMB.  AFTER
;EXECUTING THESE 4 INSTRUCTIONS, THE C(AC)+C(E)
;SHOULD STILL=RANDOM NUMBER.

	AC=3
TST4:	MSETUP
TST4A:	MRANDOM
				;IF ORIGIN C(AC)=0011,C(E)=0011
TST4B:	IORM	AC,(AC1)	;C(AC)=0011, C(E)=0011
	ANDB	AC,(AC1)	;C(AC)=0011, C(E)=0011
	SETCMM	AC,(AC1)	;C(AC)=0011, C(E)=1100
	SETCMB	AC,(AC1)	;C(AC)=0011, C(E)=0011
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST4B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST4A		;INC TO TEST NEXT LOC.

;TEST MOVSM, MOVSS, MOVNM, MOVNS. AFTER
;EXECUTING THESE 4 INSTRUCTIONS, THE C(AC)+C(E)
;SHOULD STILL=RANDOM NUMBER

	AC=4
TST5:	MSETUP
TST5A:	MRANDOM
				;IF C(AC)+C(E)=(0011)0101
TST5B:	MOVSM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0101)0011
	MOVSS	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	MOVNM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(1100)1011
	MOVNS	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST5B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST5A		;INC TO TEST NEXT LOC.

;TEST HRLM, HLRN, MOVSS, XORM, XORB.  AFTER
;EXECUTING THESE 5 INSTRUCTIONS, THE C(AC)+C(E)
;SHOULD STILL=RANDOM NUMBER.

	AC=5
TST6:	MSETUP
TST6A:	MRANDOM
				;IF C(AC)+C(E)=(0011)0101
TST6B:	HRLM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0101)0101
	HLRM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0101)0011
	MOVSS	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	XORM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0000)0000
	XORB	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST6B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST6A		;INC TO TEST NEXT LOC.

;TEST EQVM, ORCMM, ORCAM, EQVB. AFTER
;EXECUTING THESE 4 INSTRUCTIONS, THE C(AC)+
;C(E) SHOULD STILL=RANDOM NUMBER

	AC=6
TST7:	MSETUP
TST7A:	MRANDOM
				;IF C(AC)+C(E)=(0011)0101
TST7B:	EQVM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(1111)1111
	ORCMM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	ORCAM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(1111)1111
	EQVB	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM
	ERRM	RA,RA
	JUMPL	AC-1,TST7B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST7A		;INC TO TEST NEXT LOC.

;TEST ANDCAM, ANDCMM, ANDCBB, SETCAB.  AFTER
;EXECUTING THESE 4 INSTRUCTIONS, THE C(AC)+
;C(E) SHOULD STILL=RANDOM NUMBER.

	AC=12
TST10:	MSETUP
TST10A:	MRANDOM
				;IF C(AC)+C(E)=(0011)0101,
TST10B:	ANDCAM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0000)0000
	ANDCMM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	ANDCBB	AC,(AC1)	;C(AC)=(1100)1010, C(E)=(1100)1010
	SETCAB	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST10B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST10A		;INC TO TEST NEXT LOC.

;TEST SETCAM, ORCAB, ORCBM, AND CAB, AFTER
;EXECUTING THESE 4 INSTRUCTIONS, THE C(AC)+
;C(E) SHOULD STILL=RANDOM NUMBER.

	AC=12
TST11:	MSETUP
TST11A:	MRANDOM
				;IF C(AC)+C(E)=(0011)0101,
TST11B:	SETCAM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(1100)1010
	ORCAB	AC,(AC1)	;C(AC)=(1100)1010, C(E)=(1100)1010
	ORCBM	AC,(AC1)	;C(AC)=(1100)1010, C(E)=(0011)0101
	ANDCAB	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST11B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST11A		;INC TO TEST NEXT LOC.

;TEST SETZM, ANDCBM, ORCMB. AFTER
;EXECUTING THESE 3 INSTRUCTIONS, THE C(AC)
;+C(E) SHOULD=RANDOM NUMBER.

	AC=13
TST12:	MSETUP
TST12A:	MRANDOM
				;IF C(AC(+C(E)=(0011)0101
TST12B:	SETZM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0000)0000
	ANDCBM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(1100)1010
	ORCMB	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD STILL=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD STILL=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST12B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST12A		;INC TO TEST NEXT LOC.

;TEST HRLS, HLRS. CHECK FOR
;CORRECT DATA IN THE C(AC) AND C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=1
TST13:	MSETUP
TST13A:	MRANDOM
TST13B:	MOVSI	AC2,(RA)	;SIMULAT A
	IORI	AC2,(RA)	;HRLS INST.
	HRLS	AC,(AC1)	;DO A HRLS
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	MOVS	AC3,RA		;SIMULATE
	MOVSI	AC2,(AC3)	;A
	IORI	AC2,(AC3)	;HLRS INST.
	MOVE	AC,RA		;RESTORE C(AC).
	MOVEM	AC,(AC1)	;RESTORE C(E).
	HLRS	AC,(AC1)	;DO A HLRS INST.
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	JUMPL	AC-1,TST13B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST13A		;INC TO TEST NEXT LOC.

;TEST HRLZM, HLRZS, HLRZM, HRLZS. CHECK
;FOR CORRECT DATA IN THE C(AC)+C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=14
TST14:	MSETUP
TST14A:	MRANDOM
				;IF C(AC)+C(E)=(0011)0101
TST14B:	HRLZM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0101)000
	HLRZS	0,(AC1)		;C(AC)=(0011)0101,C(E)=(0000)0101
	HLLM	AC,(AC1)	;C(AC)=(0011)0101,C(E)=(0011)0101
	CAME	AC,RA		;C(AC)SHOULD=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD=RAN. NUM.
	ERRM	RA,RA
	HLRZM	AC,(AC1)	;C(AC)=(0011)0101,C(E)=(0000)0011
	HRLZS	0,(AC1)		;C(AC)=(0011)0101,C(E)=(0011)0000
	HRRM	AC,(AC1)	;C(AC)=(0011)0101,C(E)=)0011)0101
	CAME	AC,RA		;C(AC)SHOULD=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E)SHOULD=RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST14B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST14A		;INC TO TEST NEXT LOC.

;TEST HRLOM, HLROS, HLROM, HRLOS. CHECK FOR
;CORRECT DATA IN THE C(AC)+C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=15
TST15:	MSETUP
TST15A:	MRANDOM
				;IF C(AC)+C(E)=(0011)0101
TST15B:	HRLOM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0101)1111
	HLROS	0,(AC1)		;C(AC)=)0011)0101, C(E)=(1111)0101
	HLLM	AC,(AC1)	;C(E)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD=RAN. NUM.
	ERRM	RA,RA
	HLROM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(1111)0011
	HRLOS	0,(AC1)		;C(E)=(0011)1111
	HRRM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,RA		;C(AC) SHOULD=RAN. NUM.
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD = RAN. NUM.
	ERRM	RA,RA
	JUMPL	AC-1,TST15B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST15A		;INC TO TEST NEXT LOC.

;TEST HRLEM, HLRES, HLREM, HRLES. CHECK
;FOR CORRECT DATA IN THE C(AC)+C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=1
TST16:	MSETUP
TST16A:	MRANDOM
TST16B:	TRZ	AC,400000	;CLEAR BIT 18 IN AC.
	MOVE	AC2,AC		;SAVE FOR FUTURE COMPARE.
				;IF C(AC)+C(E)=(0011)0101
	HRLEM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	HLRES	0,(AC1)		;C(AC)=(0011)0101, C(E)=(0000)0101
	HLLM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0011)0101
	CAME	AC,AC2		;C(AC)SHOULD=ORIG C(AC).
	ERR	RA,AC2
	CAME	AC2,(AC1)	;C(E) SHOULD=ORIG C(AC).
	ERRM	RA,AC2
	TLZ	AC,400000	;CLEAR BIT 0.
	MOVE	AC2,AC		;SAVE FOR FUTURE COMPARE.
	HLREM	AC,(AC1)	;C(AC)=(0011)0101, C(E)=(0000)0011
	HRLES	0,(AC1)		;C(AC)=(0011)0101, C(E)=(0011)0000
	HRRM	AC,(AC1)	;C(AC) = (0011)0101, C(E) = (0011)0101.
	CAME	AC,AC2		;C(AC)SHOULD=ORIG C(AC).
	ERR	RA,AC2
	CAME	AC2,(AC1)	;C(E) SHOULD=ORIG C(AC).
	ERRM	RA,AC2
	JUMPL	AC-1,TST16B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST16A		;INC TO TEST NEXT LOC.

;TEST HRLEM, HLRES, HLREM, HRLES.   CHECK
;FOR CORRECT DATA IN AC AND C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=2
TST17:	MSETUP
TST17A:	MRANDOM
TST17B:	TRO	AC,400000	;SET BIT 18 IN AC.
	MOVE	AC2,AC		;SAVE C(AC) BOR FUTURE COMPARE
				;IF C(AC)+C(E)=(0011)1101
	HRLEM	AC,(AC1)	;C(AC)=(0011)1101, C(E)=(1101)1111
	HLRES	0,(AC1)		;C(AC)=(0011)1101, C(E)=(0011)1101
	HLLM	AC,(AC1)	;C(AC)=(0011)1101, C(E)=(0011)1101
	CAME	AC,AC2		;C(AC) SHOULD=ORIG C(AC).
	ERR	RA,AC2
	CAME	AC2,(AC1)	;C(E) SHOULD=ORIG C(AC)
	ERRM	RA,AC2
	TLO	AC,400000	;SET BIT 0 IN AC.
	MOVE	AC2,AC		;SAVE FOR FUTURE COMPARE
				;IF C(AC)+C(E)=(1010)1101
	HLREM	AC,(AC1)	;C(AC)=(1011)1101, C(E)=(1111)1011
	HRLES	0,(AC1)		;C(AC)=(1011)1101, C(E)=(1011)1111
	HRRM	AC,(AC1)	;C(AC)=(1011)1101, C(E)=(1011)1101
	CAME	AC,AC2		;C(AC) SHOULD=ORIG C(AC).
	ERR	RA,AC2
	CAME	AC2,(AC1)	;C(E) SHOULD = ORIG C(AC).
	ERRM	RA,AC2
	JUMPL	AC-1,TST17B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST17A		;INC TO TEST NEXT LOC.

;TEST HLLOM, HLLZS, HRROM, HRRZS.  CHECK FOR
;CORRECT DATA IN AC AND C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=1
TST20:	MSETUP
TST20A:	MRANDOM
TST20B:	MOVE	AC2,AC		;SIMULATE A
	TRO	AC2,-1		;HLLOM INST
	HLLOM	AC,(AC1)	;DO HLLOM.
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	TRZ	AC2,-1		;SIMULATE A HLLSZ INST.
	HLLZS	AC,(AC1)	;DO A HLLZS.
	CAME	AC,AC2		;C(AC) SHOULD=SIM ANS.
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	MOVE	AC,RA		;RESTOR C(AC)
	MOVE	AC2,RA		;SIMULATE A
	TLO	AC2,-1		;HRROM INST.
	HRROM	AC,(AC1)	;DO A HRROM.
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERR	RA,RA
	TLZ	AC2,-1		;SIMULATE A HRRZS INST.
	HRRZS	AC,(AC1)	;DO A HRRZS INST.
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	JUMPL	AC-1,TST20B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST20A		;INC TO TEST NEXT LOC.

;TEST HLLOS, HLLZM, HRROS, HRRZM.  CHECK FOR
;CORRECT DATA IN AC AND C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=2
TST21:	MSETUP
TST21A:	MRANDOM
TST21B:	MOVE	AC2,AC		;SIMULATE A
	TRO	AC2,-1		;HLLOS INST.
	HLLOS	AC,(AC1)	;DO A HLLOS.
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	MOVE	AC3,AC		;SAVE C(AC) IN CASE OF ERR.
	TRZ	AC2,-1		;SIMULATE A HLLZM INST.
	HLLZM	AC,(AC1)	;DO A HLLZM
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	AC3,AC3
	MOVE	AC,RA		;RESTORE C(AC).
	MOVEM	AC,(AC1)	;RESTORE C(E).
	MOVE	AC2,RA		;SIMULATE A
	TLO	AC2,-1		;HRROS INST.
	HRROS	AC,(AC1)	;DO A HRROS
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	MOVE	AC3,AC		;SAVE C(AC) IN CASE OF ERROR.
	TLZ	AC2,-1		;SIMULATE A HRRZM INST.
	HRRZM	AC,(AC1)	;DO A HRRZM.
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	AC3,AC3
	JUMPL	AC-1,TST21B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST21A		;INC TO TEST NEXT LOC.

;TEST HLLEM, HRRES.  CHECK C(AC)+C(E)
;FOR CORRECT DATA.
;C(AC) HAS SIGN BIT SET.

	AC=3
TST22:	MSETUP
TST22A:	MRANDOM
TST22B:	TLO	AC,400000	;SET SIGN BIT IN AC.
	MOVE	AC3,AC		;SAVE FOR FUTURE COMPARE.
	MOVE	AC2,AC		;SIMULATE A HLLEM
	TRO	AC2,-1		;WITH SIGN BIT SET.
	HLLEM	AC,(AC1)	;DO A HLLEM.
	CAME	AC,AC3		;C(AC) SHOULD=ORIG. C(AC).
	ERR	RA,AC3		;C(AC) GOT MODIFIED.
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,AC3
	SETO	AC4,		;SIMULATE HRRES WITH BIT 18 A ONE.
	HRRES	AC,(AC1)	;DO A HRRES.
	CAME	AC4,(AC1)	;C(E) SHOULD=-1.
	ERRM	AC2,AC3
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	AC2,AC3
	JUMPL	AC-1,TST22B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST22A		;INC TO TEST NEXT LOC.

;TEST HLLEM, HRRES.  CHECK C(AC)+C(E)
;FOR CORRECT DATA
;C(AC) HAS SIGN BIT CLEAR.

	AC=12
TST23:	MSETUP
TST23A:	MRANDOM
TST23B:	TLZ	AC,400000	;CLEAR SIGN BIT IN AC
	MOVE	AC3,AC		;SAVE FOR FUTURE COMPARE
	MOVE	AC2,AC		;SIMULATE A HLLEM
	TRZ	AC2,-1		;WITH SIGN BIT CLEAR.
	HLLEM	AC,(AC1)	;DO A HLLEM.
	CAME	AC,AC3		;C(AC) SHOULD=ORIG. C(AC)
	ERR	RA,AC3
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,AC3
	SETZ	AC4,		;SIMULATE HRRES WITH BIT 18 CLEAR.
	HRRES	AC,(AC1)	;DO A HRRES INST.
	CAME	AC4,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	AC2,AC3
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	AC2,AC3
	JUMPL	AC-1,TST23B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST23A		;INC TO TEST NEXT LOC.

;TEST HRREM, HLLES.  CHECK C(AC)+C(E)
;FOR CORRECT DATA.
;C(AC) HAS BIT 18 SET.

	AC=12
TST24:	MSETUP
TST24A:	MRANDOM
TST24B:	TRO	AC,400000	;SET BIT 18 IN AC.
	MOVE	AC3,AC		;SAVE C(AC) FOR FUTURE COMPARE
	MOVE	AC2,AC		;SIMULATE A HRREM
	TLO	AC2,-1		;WITH BIT 18 SET.
	HRREM	AC,(AC1)	;DO A HRREM
	CAME	AC,AC3		;C(AC) SHOULD=ORIG. C(AC)
	ERR	RA,AC3
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,AC3
	SETO	AC4,		;SIMULATE A HLLES WITH SIGN BIT SET.
	HLLES	AC,(AC1)	;DO A HLLES
	CAME	AC4,(AC1)	;C(E) SHOULD=-1.
	ERRM	AC2,AC3
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	AC2,AC3
	JUMPL	AC-1,TST24B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST24A		;INC TO TEST NEXT LOC.

;TEST HRREM, HLLES.  CHECK C(AC)+C(E)
;FOR CORRECT DATA.
;C(AC) HAS BIT 18 CLEAR.

	AC=3
TST25:	MSETUP
TST25A:	MRANDOM
TST25B:	TRZ	AC,400000	;CLEAR BIT 18 ON AC.
	MOVE	AC3,AC		;SAVE C(AC) FOR FUTURE COMPARE.
	MOVE	AC2,AC		;SIMULATE A HRREM
	TLZ	AC2,-1		;WITH BIT 18 CLEAR.
	HRREM	AC,(AC1)	;DO A HRREM
	CAME	AC,AC3		;C(AC) SHOULD=ORIG C(AC)
	ERR	RA,AC3
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,AC3
	SETZ	AC4,		;SIMULATE A HLLES WITH SIGN BIT CLEAR.
	HLLES	AC,(AC1)	;DO A HLLES
	CAME	AC4,(AC1)	;C(E) SHOULD=0
	ERRM	AC2,AC3
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	AC2,AC3
	JUMPL	AC-1,TST25B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST25A		;INC TO TEST NEXT LOC.

;TEST ORCBB, ANDCMB, SETOM, SETZB, SETOB.  CHECK
;FOR CORRECT DATA IN AC AND C(E).

	AC=4
TST26:	MSETUP
TST26A:	MRANDOM
TST26B:	SETCM	AC2,AC		;SIMULATE A ORCBB...1'S COMP.
	ORCBB	AC,(AC1)	;DO ORCBB
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS.
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	MOVEI	AC3,0		;SIMULATE ANDCMB...AND 1'S COMP
	ANDCMB	AC,(AC1)	;OF A NUMBER WITH THAT NUMBER
	CAME	AC,AC3		;SHOULD=0
	ERR	AC2,AC2
	CAME	AC3,(AC1)	;C(E) SHOULD=0
	ERRM	AC2,AC2
	MOVE	AC2,[-1]	;SIMULATE SETOM.
	SETOM	AC,(AC1)	;DO SETOM.
	CAME	AC,AC3		;C(AC)SHOULD STILL=0.
	ERR	AC3,AC3
	CAME	AC2,(AC1)	;C(E) SHOULD=-1
	ERRM	AC3,AC3
	SETZB	AC,(AC1)	;DO SETZB
	CAME	AC,AC3		;C(AC) SHOULD=0
	ERR	AC2,AC3
	CAME	AC3,(AC1)	;C(E) SHOULD=0
	ERRM	AC2,AC3
	SETOB	AC,(AC1)	;DO A SETOB.
	CAME	AC,AC2		;C(AC) SHOULD=-1
	ERR	AC3,AC3
	CAME	AC2,(AC1)	;C(E) SHOULD=-1
	ERRM	AC3,AC3
	JUMPL	AC-1,TST26B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST26A		;INC TO TEST NEXT LOC.

;TEST AOS, SOA, TDC, TDCA, TSC, TSCA.  CHECK
;FOR CORRECT DATA IN AC AND C(E)
;C(AC) AND C(E)=RAN. NUM.

	AC=5
TST27:	MSETUP
TST27A:	MRANDOM
TST27B:	AOS	AC,(AC1)	;ADD ONE TO AC+C(E) AND NO SKIP.
	SOSA	AC,(AC1)	;SUB ONE FROM AC+C(E) AND SKIP.
	ER	AC,[ASCII/AOS/]
	CAME	AC,(AC1)	;C(AC)SHOULD=C(E).
	ERR	RA,RA		;C(E) DID NOT GET STORED IN AC CORRECTLY
	CAME	AC,RA		;C(AC) SHOULD=ORIG. C(AC).
	ERR	RA,RA
	TDC	AC,(AC1)	;SHOULD NOT SKIP
	TDCA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII/TST/]
	CAME	AC,RA		;C(AC) SHOULD=ORIG C(AC).
	ERR	RA,RA
	TSC	AC,(AC1)	;SHOULD NOT SKIP.
	TSCA	AC,(AC1)	;SHOULD ALWAYS SKIP.
	ER	AC,[ASCII/TST/]
	CAME	AC,RA		;C(AC) SHOULD=ORIG C(AC).
	ERR	RA,RA
	JUMPL	AC-1,TST27B-4	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST27A		;INC TO TEST NEXT LOC.

;TEST MOVMM, MOVMS.  CHECK FOR
;CORRECT DATA IN AC AND C(E).
;C(AC)+C(E)=RAN. NUM.

	AC=3
TST30:	MSETUP
TST30A:	MRANDOM
TST30B:	SETCM	AC2,AC		;SIMULATE A MOVM
	ADDI	AC2,1		;WITH SIGN BIT SET.
	TLNN	AC,400000	;SKIP IF SIGN BIT SET.
	MOVE	AC2,AC		;SIM. MOVM WITH SIGN BIT CLEAR.
	MOVMM	AC,(AC1)	;DO A MOVMM
	CAME	AC,RA		;C(AC) SHOULD=ORIG. C(AC)
	ERR	RA,RA		;C(AC) GOT MODIFIED.
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	MOVEM	RA,(AC1)	;RESTORE C(E).
	MOVMS	AC,(AC1)	;DO A MOVMS
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	RA,RA
	CAME	AC2,(AC1)	;C(E) SHOULD=SIM. ANS.
	ERRM	RA,RA
	JUMPL	AC-1,TST30B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST30A		;INC TO TEST NEXT LOC.

;TEST ADDM, SUBB, ADDB, SUBM. CHECK FOR
;CORRECT DATA IN AC AND C(E)
;C(AC) AND C(E)=RAN. NUM.

	AC=1
TST31:	MSETUP
TST31A:	MRANDOM
TST31B:	ADDM	AC,(AC1)	;DO AN ADDM.
	MOVE	AC2,(AC1)	;PUT ANS INTO AC2
	MOVEM	AC,(AC1)	;AND RESTORE C(E)
	SUBB	AC2,(AC1)	;DO A SUBB.
	CAME	AC2,RA		;C(AC2) SHOULD=ORIG C(AC).
	ERR	RA,RA
	CAME	RA,(AC1)	;C(E) SHOULD=ORIG. C(E)
	ERRM	RA,RA
	ADDB	AC,(AC1)	;DO AN ADDB.
	CAME	AC,(AC1)	;C(AC) SHOULD=C(E).
	ERR	RA,RA
	MOVEM	RA,(AC1)	;RESTORE C(E).
	SUBM	AC,(AC1)	;DO A SUBM.
	CAME	RA,(AC1)	;C(E) SHOULD=ORIG. C(E)
	ERRM	RA,RA
	JUMPL	AC-1,TST31B-4	;LOOP ON ERROR SWITCH
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	TST31A		;INC TO TEST NEXT LOC.
;TEST JRST. PUT A JSP BACK TO THE PROGRAM
;IN EVERY LOCATION FROM THE END OF PROGRAM TO
;THE DESIGNATED END OF MEMORY. PUT A JRST
;BACK TO PROGRAM IN EACH LOC THAT THE JRST,
;IN THE PROGRAM, POINTS TO. THIS WAY IF
;THE JRST DOES NOT GO TO THE RIGHT LOC
;IN MEMORY, A JSP WILL STORE THE LOC
;IT DID GO TO.

	AC=1
JRST1:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC4,[JSP AC3,JRST5]	;JSP AC3, JRST5
	MOVEM	AC4,(AC)	;FROM END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JRST1A:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
	MOVE	AC2,[JRST JRST4]	;PUT A JRST JRST4 INTO
JRST2:	MOVEM	AC2,(AC1)	;CURRENT MEM LOC UNDER TEST.
JRST3:	JRST	(AC1)		;DO THE JRST OUT TO MEM.
	ER	,[ASCII/JRST/]	;PC GOT INC INSTEAD OF MEM ADDRESS.
JRST4:	JRST	.+3		;JRST FOUND A JRST AND CAME BACK OK
JRST5:	SOJ	AC3,		;JRST WENT TO WRONG LOC AND
	ERMM	AC3,(AC1)	;A JSP CAME BACK HERE.
	JUMPL	AC-1,JRST3	;LOOP ON ERROR SWITCH.
	MOVEM	AC4,(AC1)	;REPLACE CURRENT LOC WITH JSP.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JRST2		;INC TO TEST NEXT LOC.
	SOJG	AC-1,JRST1A	;ITERATION COUNTER.


;TEST JSP. PUT A JSP BACK TO PROGRAM IN EACH
;LOCATION FROM THE END OF PROGRAM TO THE DESIGNATED
;END OF MEMORY. IF THE JSP DOES NOT GO TO THE RIGHT
;LOC IN MEMORY, THE JSP BACK WILL STORE THE LOC IT
;DID GO TO. CHECK C(AC) FOR CORRECT FLAGS IN THE LEFT
;SIDE AND E+1 IN THE RIGHT.

	AC=2
JSP1:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC1,[JSP AC,JSP3]	;JSP AC,JSP3
	MOVEM	AC1,(AC)	;FROM END OF PROG.
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JSP1A:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
	MOVE	AC2,FLAGS	;MOVE ALL FLAGS BITS BUT USER MODE
	JRST	2,.+1(AC2)	;INTO AC2 AND SET THESE FLAGS.
JSP2:	HLLZS	AC2		;SIMULATE JSP...
	HRRI	AC2,1(AC1)	;(FLAGS, MEM LOC+1).
	SETOB	AC,RAN1		;MAKE C(AC)=-1.
	JSP	AC,(AC1)	;DO A JSP TO MEM.
JSP3:	TLZ	AC,USERF	;CLEAR USER MODE BIT IN AC IF ON.
	CAME	AC,AC2		;C(AC) SHOULD=SIM. ANS
	ERRI	RAN1,(AC1)	;
	JUMPL	AC-1,JSP2	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JSP2		;INC TO TEST NEXT LOC.
	SOJG	AC-1,JSP1A	;ITERATION COUNTER.

;TEST JSR.
;PUT A JSP BACK TO THE PROGRAM IN EVERY LOCATION
;FROM THE END OF THE PROGRAM TO THE DESIGNATED
;END OF MEMORY. IF THE JSR DOES NOT GO TO THE
;RIGHT LOC IN MEMORY, THE JSP WILL STORE THE LOC
;IT DID GO TO. ALSO CHECK FOR NO MODIFICATION OF AC.

	AC=3
JSRA:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC2,[JSP AC4,JSRD]	;JSP AC4, JSRD
	MOVEM	AC2,(AC)	;FROM END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JSPA1:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
	ADD	AC1,[XWD 1,0]	;ADD ONE TO LEFT...PREVENT NON EX MEM.
JSRB:	SETOB	AC,RAN1		;SET C(AC) TO ALL ONES.
JSRC:	JSR	AC,(AC1)	;DO THE JSR TO MEM.
JSRD:	CAME	AC,RAN1		;C(AC) SHOULD STILL= -1.
	ERR	AC2,RAN1	;C(AC)GOT MODIFIED
	HRRZS	AC4		;JSP STORED PC IN AC4.
	CAIE	AC4,2(AC1)	;C(AC4) SHOULD=MEM LOC+2.
	ERMM	AC4,2(AC1)	;JSR WENT TO WRONG LOC.
	JUMPL	AC-1,JSRB	;LOOP ON ERROR SWITCH.
	MOVEM	AC2,(AC1)	;RESTORE JSP IN CURRENT LOC.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JSRC		;INC TO TEST NEXT LOC.
	SOJG	AC-1,JSPA1	;ITERATION COUNTER.

;TEST JSR.
;CHECK FOR NO MODIFICATION OF AC AND JSR GOING
;TO THE CORRECT LOCATION IN MEMORY. PUT A
;JSR BACK TO JSR+1,IN PROG,IN EVERY LOCATION
;IN MEMORY FROM THE END OF THE PROGRAM TO THE
;DESIGNATED END OF MEMORY. IF THE JSR GOES TO
;THE WRONG LOC IN MEMORY, THE JSR IN MEM WILL
;STORE THE LOC IT DID GO TO +2 IN THE PROG.

	AC=4
JSR1:	SETUP1	 1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC4,[JSR JSR4]	;JSR JSR4
	MOVEM	AC4,(AC)	;FROM END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JSR1A:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
	ADD	AC1,[XWD 1,0]	;ADD ONE TO LEFT...PREVENT NONEX MEM.
	MOVE	AC2,FLAGS	;MOVE FLAGS, EXCEPT USER MODE, BITS
	JRST	2,.+1(AC2)	;INTO AC2 AND SET THESE FLAGS.
	JSP	AC3,.+1		;DO A JSP TO GET FLAGS
	TLNE	AC3,USERF	;USER MODE BIT ON?
	TLO	AC2,USERF	;YES. SET USER MODE BIT FOR COMPARE.
JSR2:	SETOB	AC,RAN1		;SET C(AC) TO ALL ONES.
JSR3:	HRRI	AC2,2(AC1)	;SETUP RIGHT SIDE OF  AC TO=PC+1... SIM. ANS.
	JSR	AC,(AC1)	;DO A JSR TO MEM.
JSR4:	0			;JSR IN MEM COMES HERE AND STORES (FLAGS, PC+2)
	CAME	AC,RAN1		;C(AC) SHOULD STILL= -1.
	ERR	AC4,RAN1	;C(AC) GOT MODIFIED.
	CAME	AC2,JSR4	;C(JSR4) SHOULD=SIM. ANS.
	ERRM	AC4,RAN1	;JSR WENT TO WRONG LOC OR FLAGS CHANGED.
	JUMPL	AC-1,JSR2	;LOOP ON ERROR SWITCH
	MOVEM	AC4,(AC1)	;RESTORE JSR IN MEM.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JSR3		;INC TO TEST NEXT LOC.
	SOJG	AC-1,JSR1A	;ITERATION COUNTER.

;TEST JSA.
;CHECK THAT THE JSA GOES TO THE CORRECT LOC
;IN MEM AND THAT THE C(AC)=(E,PC).
;PUT A JSP BACK TO THE PROGRAM IN EVERY LOCATION
;FROM THE END OF THE PROG TO THE END OF MEM.
;IF THE JSA GOES TO THE WRONG LOC, THE JSP WILL
;STORE THE LOC IT DID GO TO

	AC=5
JSAA:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC5,[JSP AC3,JSAD]	;JSP AC3, JSAD
	MOVEM	AC5,(AC)	;FROM END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JSA1A:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
	ADD	AC1,[XWD 1,0]	;ADD ONE TO LEFT...PREVENT NON EX MEM
JSAB:	RANDM1

	MOVSI	AC4,(AC1)	;SIMULATE THE
	HRRI	AC4,JSAD	;JSA INST.
JSAC:	JSA	AC,(AC1)	;DO THE JSA INST.
JSAD:	CAME	AC,AC4		;C(AC) SHOULD=SIM. ANS.
	EERRI	(AC1)
	HRRZS	AC3		;JSP IN MEM STORED PC+2
	CAIE	AC3,2(AC1)	;OF JSA DESTINATION IN AC3
	ERMM	AC3,2(AC1)	;JSA DID NOT GO TO CORRECT MEM LOC.
	JUMPL	AC-1,JSAC	;LOOP ON ERROR SWITCH
	MOVEM	AC5,(AC1)	;RESTORE JSP IN CURRENT LOC.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JSAB		;INC TO TEST NEXT LOC.
	SOJG	AC-1,JSA1A	;ITERATION COUNTER.

;TEST JSA.
;PUT A JSA BACK TO THE PROG IN EVERY LOCATION
;FROM THE END OF THE PROG TO THE DESIGNATED
;END OF MEMORY AFTER THE JSA TO MEM AND
;THE JSA BACK, THE CONTENTS OF THE DESTINATION
;OF THE JSA IN MEMORY SHOULD=ORIG C(AC) OF THE
;JSA IN THE PROG.  ALSO THE C(AC) OF THE JSA
;IN MEMORY SHOULD=(E OF JSA IN MEMORY, E+2 OF
;JSA IN PROG.)  ORIGINAL C(AC)= RAN. NUM.

	AC=6
JSA1:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC4,[JSA AC3,JSA4]	;JSA AC3, JSA4
	MOVEM	AC4,(AC)	;FROM END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JSAX:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
	ADD	AC1,[XWD 1,0]	;ADD ONE TO LEFT... PREVENT NON EX MOVEM
JSA2:	RANDM1
	MOVE	AC2,RAN		;SAVE C(AC) FOR FUTURE COMPARE.
JSA3:	MOVE	AC3,RAN		;PUT RAN NUM INTO AC OF JSA IN MEM.
	MOVSI	AC5,JSA4	;SIMULATE THE
	HRRI	AC5,2(AC1)	;JSA IN MEM.
	JSA	AC,(AC1)	;DO THE JSA TO MEM
JSA4:	0			;THE JSA IN MEM SHOULD POINT HERE.
	CAME	AC2,JSA4	;THE C(JSA4) SHOULD = RAN NUM.
	ERRM	AC4,AC2
	CAME	AC3,AC5		;THE MEM JSA AC SHOULD=SIM. ANS.
	ERR	AC4,AC2
	JUMPL	AC-1,JSA3	;LOOP ON ERROR SWITCH
	MOVEM	AC4,(AC1)	;RESTORE THE JSA IN MEM.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JSA2		;INC TO TEST NEXT LOC
	SOJG	AC-1,JSAX	;ITERATION COUNTER.

;TEST JRA
;PUT A JSP BACK TO THE PROG IN EVERY LOCATION
;FROM THE END OF PROG TO THE DESIGNATED
;END OF MEM.  IF THE JRA GOES TO THE WRONG LOC
;IN MEM, THE JSP WILL STORE THE LOC IT DID GO
;TO.  BEFORE THE JRA, THE C(AC)= (E,0). AFTER THE
;JRA, THE C(AC) SHOULD=C(E).

	AC=7
JRA1:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC2,[JSP AC3,JRA3]	;JSP AC3,JRA3
	MOVEM	AC2,(AC)	;FROM END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JRA1A:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
JRA2:	MOVSI	AC,(AC1)	;PUT E INTO LEFT SIDE OF AC.
	MOVE	AC4,AC		;SAVE C(AC) FOR PNT IN CASE OF ERR.
	JRA	AC,(AC1)	;DO THE JRA TO MEM
JRA3:	CAME	AC,AC2		;C(AC) SHOULD=ORIG C(E).
	ERR	AC2,AC4
	HRRZS	AC3		;JSP IN MEM STORED PC IN AC3
	CAIE	AC3,1(AC1)	;C(AC3) SHOULD = ADDRESS+1.
	ERMM	AC2,1(AC1)	;JRA WENT TO WRONG LOC.
	JUMPL	AC-1,JRA2	;LOOP ON ERROR SWITCH.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JRA2		;INC TO TEST NEXT LOC.
	SOJG	AC-1,JRA1A	;ITERATION COUNTER.

;TEST JRA, JSA.
;PUT A JRA BACK TO PROG IN EVERY LOC FROM
;THE END OF THE PROG TO THE DESIGNATED END
;OF MEM.  THE ORIGINAL C(AC)=RAN NUM. AFTER
;THE JSA THE C(AC) SHOULD=(E,PC) AND THE
;C(E) SHOULD=RAN. NUM. AFTER THE JRA THE
;C(AC) SHOULD=RAN. NUM. AGAIN. CHECK FOR RAN
;NUM IN AC AND C(E)

	AC=10
JRAA:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC2,[JRA AC,JRAD]	;JRA AC,JRAD
	MOVEM	AC2,(AC)	;FROM END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
JRAA1:	MOVE	AC1,WCBUF	;MOVE (-TOP+END,END) INTO AC1.
	ADD	AC1,[XWD 1,0]	;ADD ONE ON LEFT...PREVENT NON EX MEM
JRAB:	RANDM1
JRAC:	MOVE	AC,RAN		;RESTORE C(AC) IN CASE OF ERROR
	JSA	AC,(AC1)	;DO THE JSA TO MEM.
JRAD:	CAME	AC,RAN		;C(AC) SHOULD=ORIG. C(AC).
	ERR	AC2,RAN
	CAME	AC,(AC1)	;C(E) SHOULD=ORIG C(AC).
	ERR	AC2,RAN
	JUMPL	AC-1,JRAC	;LOOP ON ERROR SWITCH
	MOVEM	AC2,(AC1)	;RESTORE JRA IN MEM.
	AOBJN	AC1,.+1
	TLNE	AC1,770000
	JRST	JRAB		;INC TO TEST NEXT LOC.
	SOJG	AC-1,JRAA1	;ITERATION COUNTER.

;TEST SKIPA.
;PUT A SKIPA . IN EVERY OTHER LOCATION FROM THE END OF
;THE PROG TO THE END OF DESIGNATED MEMORY. PUT A JSP BACK TO PROG
;IN ALL OTHER LOCATIONS FROM THE END OF PROG TO END OF MEM
;IF THE SKIPA GOES TO THE WRONG LOCATION IN MEM, THE JSP
;BACK WILL STORE THE PC+1 OF WHERE THE SKIPA WENT TO
;THE AC OF THE SKIPA INSTRUCTION WILL CONTAIN THE
;SKIPA THAT FAILED.

	AC=11
SKPAA:	SETUP1	5,1
	HRRZ	AC3,MODULO	;PUT TOP OF DESIGNATED MEM INTO AC3.
	MOVE	AC2,[JSP AC4,SKPAA2];PUT A JSP BACK TO PROG INTO AC2.
	MOVE	AC1,[SKIPA AC5,0];PUT A SKIPA INST INTO AC1.
	HRRI	AC1,@MEMLOW
SKPAA1:	MOVEM	AC1,(AC1)	;STORE SKIPA IN MEM.
	AOJ	AC1,		;ADD ONE TO ADDRESS IN MEM.
	MOVEM	AC2,(AC1)	;STORE JSP INST.
	CAILE	AC3,2(AC1)	;ADDRESS > OR = TOP OF MEM?
	AOJA	AC1,SKPAA1	;NO. ADD ONE AND CONTINUE.
	MOVE	AC2,[JRST SKPAA3]	;PUT A JRST BACK INTO AC2.
	MOVEM	AC2,-1(AC3)	;STORE IN TOP -1.
	MOVEM	AC2,(AC3)	;STORE IN TOP.
	JRST	@MEMLOW		;GO DO SKIPA INSTRUCTIONS.
SKPAA2:	MOVEI	AC4,-1(AC4)	;PUT THE PC OF WHERE THE SKIPA WENT TO INTO AC4.
	ERMM	AC5,(AC3)	;C(AC5) = FAILING SKIPA INST.
SKPAA3:	SOJG	AC-1,SKPAA2-1	;ITERATION COUNTER.
	JUMPL	AC-1,SKPAA2-1	;LOOP ON ERROR SWITCH.
;TEST SKIPA.
;THIS TEST IS LIKE THE PREVIOUS ONE EXCEPT THAT THE LOCATIONS
;IN MEM CONTAINING THE SKIPA AND THE ONES CONTAINING THE JSP BACK
;HAVE BEEN EXCHANGED.

	AC=10
SKPB:	SETUP1	5,1
	HRRZ	AC3,MODULO	;PUT TOP OF MEM IN AC3.
	MOVE	AC2,[JSP AC4,SKPB2];PUT JSP BACK INTO AC2.
	MOVE	AC1,[SKIPA AC5,1];PUT SKIPA INST INTO AC1.
	ADDI	AC1,@MEMLOW
SKPB1:	MOVEM	AC1,(AC1)	;PUT SKIPA INST INTO MEM.
	AOJ	AC1,		;INC ADDRESS.
	MOVEM	AC2,(AC1)	;PUT JSP INST INTO MEM.
	CAILE	AC3,1(AC1)	;MEM FILLED?
	AOJA	AC1,SKPB1	;NO. CONTINUE TO FILL MEM.
	MOVE	AC2,[JRST SKPB3];PUT A JRST  INTO AC2.
	MOVEM	AC2,-1(AC3)	;PUT A JRST BACK IN TOP -1.
	MOVEM	AC2,(AC3)	;PUT A JRST BACK INTO TOP.
	MOVEI	AC,@MEMLOW
	JRST	1(AC)		;GO DO SKIPA INSTRUCTIONS.
SKPB2:	MOVEI	AC4,-1(AC4)	;PUT PC OF WHERE SKIPA INST WENT TO INTO AC4.
	ERMM	AC5,(AC3)	;C(AC5) = FAILING SKIPA INST.
SKPB3:	SOJG	AC-1,SKPB2-1	;ITERATION COUNTER.
	JUMPL	AC-1,SKPB2-1	;LOOP ON ERROR SWITCH.

;TEST DEFER.
;FILL BUFFER WITH RAN NUM THAT = ADDRESSES FROM THE END OF
;THE PROG TO THE END OF DESIGNATED MEMORY. PICK A RANDOM ADDRESS
;AND SET BIT 13 IN THAT LOC. NOW GET THE LOC THAT THAT POINTS
;TO AND SET BIT 13 IN IT. KEEP DOING THIS FOR 30 TIMES OR
;UNTIL A LOC POINTS TO A LOC THAT ALREADY HAS BIT 13 SET.
	COUNT=6
	FINAL=7
DFRTST:	MOVEI	16,.
	MOVEM	16,TESTPC	;SETUP SUBTEST PC
	MOVEI	16,16
	MOVEM	16,ERRLOP#	;WHICH AC IS USED FOR ITERATION.
	MOVEI	16,5		;ROUTINE WEIGHTING.
	HRRZ	5,MODULO	;PUT HIGHEST MEM LOC IN AC5.
	SETZM	DFRTFG#		;CLR "WHICH DEFER TEST " FLAG.
DFRT1:	MOVEI	1,@MEMLOW	;PUT ADDRESS OF END OF PROG INTO AC1.
	SETZM	COUNT#		;CLR  CNT OF # OF DEFERS.
DFRT2:	MOVE	10,RAN		;PRODUCE
	ADD	10,[142536475076];A
	ROT	10,1		;RANDOM
	EQVB	10,RAN		;NUMBER.
	AND	10,5		;AND WITH HIGHEST MEM LOC.
	CAIGE	10,@MEMLOW	;RAN NUM > OR = END OF PROG?
	JRST	DFRT2		;NO. GET ANOTHER NUM.
	CAILE	1,@5		;ADDRESS > HIGHEST MEM LOC?
	JRST	DFRT3		;YES. STOP FILLING MEM.
	MOVEM	10,(1)		;PUT RAN NUM INTO MEM.
	AOJA	1,DFRT2		;ADD 1 TO ADDRESS AND GET A NEW NUM.
DFRT3:	HRLI	10,20		;SET INDIRECT BIT.
	MOVEM	10,TABL(COUNT)	;PUT IN TABLE.
	MOVE	3,(10)		;GET CONTENTS OF ADDRESS.
	HRLI	3,20		;SET DEFER BIT.
	MOVE	2,COUNT		;PUT COUNT INTO AC2.
	CAMN	3,TABL(2)	;C(C(ADDRESS)) = ANY IN TABLE?
	JRST	DFRT4		;YES. STOP SETTING DEFER BIT.
	SOJGE	2,.-2		;SUB 1 AND TEST NEXT IN TABLE.
	MOVEM	3,(10)		;NUMBER OK, STORE DEFER BIT.
	MOVEI	10,(3)
	AOS	2,COUNT		;INC COUNT.
	CAIGE	2,30		;COUNT = 30?
	JRST	DFRT3		;NO. CONTINUE.
DFRT4:	HRRZ	7,(10)		;YES. STORE ADDRESS WHERE DEFER SHOULD STOP.
	MOVEI	2,@TABL		;DO DEFER INST.
	CAME	2,FINAL		;C(AC2) SHOULD = C(FINAL).
	GO	ERROUT		;DEFER STOPPED OR WENT TO WRONG LOC.
	SOJG	16,DFRT1	;ITERATION COUNT.
	JUMPL	16,DFRT3	;ERROR LOOP SWITCH.
;TEST DEFER.
;THIS TEST IS LIKE THE PREVIOUS ONE EXCEPT IT USES
;INDEX REGISTERS BESIDES THE INDIRECT. INDEX REGISTERS
;10 - 16 ARE SET TO A -1.THE FLOW FROM ONE LOC TO ANOTHER
;IS FROM ONE LOC TO THE NEXT LOC -1.

DFT:	MOVEI	7,.
	MOVEM	7,TESTPC	;SETUP SUBTEST PC
	MOVEI	7,7		;INFORM ERROR ROUTINE
	MOVEM	7,ERRLOP	;WHICH AC IS USED FOR ITERATION.
	MOVEI	7,5		;PUT ITERATION COUNT INTO AC7.
	MOVEM	7,TAMP#		;SAVE ITERATION COUNT IN TAMP.
	SETZM	TAMP3#		;CLR 
	SETOM	DFRTFG#		;SET "WHICH DEFER TEST" FLAG.
DFT1:	SETOB	10,11		;SET C(AC10-AC16) TO A -1.
	SETOB	12,13
	SETOB	14,15
	SETO	16,
	HRRZ	7,MODULO	;PUT HIGHEST MEM LOC INTO AC7.
	MOVEI	1,@MEMLOW	;PUT ADDRESS OF END OF PROG INTO AC1.
	SETZM	COUNT		;CLR INDIRECT BIT COUNTER.
DFT2:	MOVE	4,RAN		;PRODUCE
	ADD	4,[142536475076];A
	ROT	4,1		;RANDOM
	EQVB	4,RAN		;NUMBER.
	AND	4,7		;KEEP NUMBER WITHIN EX MEM.
	CAIG	4,@MEMLOW	;NUMBER > THAN END OF PROG?
	JRST	DFT2		;NO. GET ANOTHER NUMBER.
	CAILE	1,@7		;ADR OF WHERE NUM IS STORED > THAN MEM?
	JRST	DFT3		;YES. MEM HAS BEEN FILLED.
	MOVEM	4,(1)		;STORE THIS NUM IN MEM.
	AOJA	1,DFT2		;INC ADR.
DFT3:	MOVE	5,4		;GEN A
	ANDI	5,7		;NUM FROM 0-7.
	CAIN	5,7
	SUBI	5,1
	HRLI	4,30(5)		;SET INDIRECT BIT + INDEX FROM 10 TO 16.
	MOVEM	4,TABL(6)	;STORE IN TABLE.
	MOVE	3,-1(4)		;GET LOC -1.
	HRLI	3,30(5)		;SET INDIRECT BIT + INDEX.
	MOVE	2,COUNT		;PUT COUNT INTO AC2.
	MOVEM	3,TAMP1#	;SAVE C(AC3).
	MOVEM	4,TAMP2#	;SAVE C(AC4).
	HRRZ	4,3		;PUT CURRENT ADR INTO AC4.
	HRRZ	3,TABL(2)	;PUT ADR IN TABLE INTO AC3.
	CAIN	3,(4)		;ADR = ANY IN TABL?
	SETOM	TAMP3#		;YES. SET FLAG.
	SOJGE	2,.-3		;CONTINUE UNTIL CHECKED ALL OF TABLE.
	MOVE	3,TAMP1		;RESTORE AC3.
	MOVE	4,TAMP2		;RESTORE AC4.
	SKIPN	TAMP3		;ADR = ANY IN TABL?
	JRST	.+4		;NO.
	SETZM	TAMP3		;YES. CLR FLAG.
	MOVEI	7,(3)		;GET LAST ADR AND
	JRST	DFT4+1		;GO DO DEFER.
	MOVEM	3,-1(4)		;STORE INDIRECT AND INDEX.
	MOVEI	4,(3)		;GET NEXT ADR.
	AOS	2,COUNT		;INC COUNT.
	CAIGE	2,30		;30?
	JRST	DFT3		;NO. CONTINUE.
DFT4:	HRRZ	7,-1(4)		;GET ADR WHERE DEFER SHOULD STOP.
	MOVEI	2,@TABL		;DO DEFER INST.
	CAMN	2,7		;=?
	JRST	.+3		;YES.
	GO	ERROUT		;NO. GO PNT ERR MESS.
	JRST	DFT4+10		;JUMP AROUND LOADING ITR CTR.
	SOS	7,TAMP		;GET ITER COUNT AND SUB 1.
	JUMPG	7,DFT1		;CONTINUE IF > 0.
	JUMPL	7,DFT3		;ERROR LOOP IF < 0.


;TEST POP.
;CHECK FOR ABILITY OF POP TO MOVE A RANDOM NUMBER
;FROM THE C(C(AC)R) TO THE C(E).

	AC=11
TPOP:	SETUP1	1,1
TPOP1:	RANDM1
TPOP2:	MOVE	AC1,[XWD 1,AC]	;SETUP POINTER TO GET DATA FROM AC.
	POP	AC1,AC2		;DO POP INST.
	CAME	AC2,AC		;C(E) SHOULD=RAN. NUM.
	ERROR	AC2,AC
	LOOP	TPOP1,TPOP2

;TEST POP.
;CHECK POINTER DECREMENT.
;A RANDOM NUMBER WITH BOTH LEFT AND RIGHT SIDES
;LESS THAN MEMORY SIZE IS USED AS A POINTER WORD.  THE
;ONLY RESTRICTION ON THIS NUMBER IS THAT IT BE NON
;ZERO IN THE LEFT HALF...PREVENT PDL OVERFLOW.

	AC=12
TPOP3:	SETUP1	1,1
TPOP4:	RANDM1
TPOP5:	AND	AC,MODULO	;MAKE LEFT AND RHT=<MEM SIZ.
	TLNN	AC,-1		;IS LEFT SIDE=0?
	JRST	TPOP4		;YES.. REJECT..PREVENT PDL OV.
	MOVE	AC1,AC		;MOVE POINTER WORD INTO AC1.
	SUB	AC,[XWD 1,1]	;SIMULATE DECREMENTING POINTER.
	POP	AC1,AC2		;DO A POP INST.
	CAME	AC1,AC		;C(AC) SHOULD=SIM. ANS.
	ERROR	AC1,AC
	LOOP	TPOP4,TPOP5

;TEST PUSH.
;CHECK THE ABILITY OF PUSH TO MOVE A RANDOM
;NUMBER FROM THE C(E) TO THE C(C(AC)R).

	AC=13
TPUSH:	SETUP1	1,1
TPUSH1:	RANDM1
TPUSH2:	MOVEI	AC1,AC1	;MAKE THE C(AC)R = AC2.
	PUSH	AC1,AC		;DO PUSH...C(AC) TO C(AC2)
	CAME	AC2,AC		;C(AC2) SHOULD=RAN. NUM.
	ERROR	AC2,AC
	LOOP	TPUSH1,TPUSH2

;TEST PUSH
;CHECK POINTER INCREMENT.
;A RANDOM NUMBER WITH BOTH LEFT AND RIGHT SIDES
;LESS THAN MEMORY SIZE IS USED AS A POINTER WORD

	AC=14
TPUSH3:	SETUP1	1,1
TPUSH4:	RANDM1
TPUSH5:	AND	AC,MODULO	;MAKE LEFT+RHT=<MEM SIZE
	HRRZ	AC1,AC		;BUT > THAN END.
	CAME	AC1,AC		;BOTH HALVES EQUAL?..GEN NEW NUM.
	CAIG	AC1,@MEMLOW
	JRST	TPUSH4		;REJECT.
	HLL	AC1,AC
	HRR	AC,AC1
	SUB	AC1,[XWD 1,1]	;SIMULATE INCREMENTING POINTER
	PUSH	AC1,AC2		;DO A PUSH INST.
	CAME	AC1,AC		;C(AC) SHOULD=SIM. ANS.
	ERROR	AC1,AC
	LOOP	TPUSH4,TPUSH5

;POP TEST
;AN AREA OF CORE IS SET ASIDE AS A BUFFER. THE TOP(HIGH)
;LOCATIONS ARE CONSIDERED THE FROM AREA.  LOCATIONS BELOW THE "FROM"
;AREA ARE CONSIDERED THE "TO" AREA.  THE FROM AND TO LOCATIONS ARE
;CHOSEN FROM A RANDOM NUMBER GENERATORS.  THE TEST IS DESIGNED
;SUCH THAT A LARGE NUMBER OF POP INSTRUCTIONS MAY BE EXECUTED
;QUICKLY.  THE NUMBER OF ITERATIONS OF THE POP INSTRUCTION IS A FUNCTION
;OF THE FROM ADDRESS, AND TO ADDRESS.  THE NUMBER IS CHOSEN SUCH
;THAT THE FROM AND TO AREAS DO NOT OVERLAP.  THE POP INSTRUCTION TAKES
;DATA WORDS DECREMENTING THROUGH MEMORY TO THE TO AREA INCREMENTING
;THROUGH MEMORY.   IN ESSENCE EVERYTHING IS RANDOM.
;THIS TEST SHOULD NEVER SET THE PDL-OV FLAG.
;ERRORS ARE POSSIBLE FROM AN INCORRECT POINTER WORD OR DATA TRANSFERED
;INCORRECTLY, IN ANY CASE,  THE FIRST ERROR WILL BE PRINTED.
;THE LIST WILL RECYCLE WITH THE FAILED NUMBERS.
;IF THE PROBLEM IS TO DIFFICULT TO SCOPE SUGGEST MARGIN
;ON A SIMPLER POP TEST.

	AC=10
	POPOINT=12		;POP INST POINTER AC
	GDP=13			;GENERATE DATA POINTER
	CDP=14			;CHECK DATA POINTER
	POPE=15			;POP"E" POINTER TO CORE
POPT:	SETUP1	1,1
POPT1:	RANDM1
	AND	AC,MODULO	;CONFINE TEST TO MEM SIZE
	HRRZ	0,AC		;AC = HIGH,,LOW = FROM,,TO
	HLRZ	1,AC		;AC+1 = LOW,,HIGH = TO,,FROM
	CAML	0,1		;0 = + NUMBER OF WORDS BETWEEN TO AND FROM
	MOVS	AC,AC
	MOVS	AC+1,AC
	MOVEI	(AC+1)		;SUB "TO" AREA FROM  "FROM" AREA
	SUBI	(AC)		;THIS LEAVES POSITIVE DIFF IN C(0)
	SKIPA			;IF THE NUMBERS WILL OVERLAP OR
	ASH	0,-1		;DESTROY PROGRAM SCALE SIZE OF BLOCK
	SKIPN	1,0		;MOVE 0 TO 1. IF THE BLOCK SIZE
	JRST	POPT1		;IS ZERO THEN GET OTHER NUMBERS
	SUBI	1,(AC)		;DO NOT ALLOW TO AREA TO
	ADDI	1,@MEMLOW	;OVERLAY PROGRAM. LOC0 CONTAINS
	JUMPG	1,.-5		;NUMBER OF WORDS IN BLOCK
POPRET:	MOVM			;MAKE IT POSITIVE FOR ITERATION
	CAIN	0,1		;=1?
	JRST	POPT1		;YES. REJECT.
POPT2:	HRLZM	POPOINT		;MAKE POP POINTER WORD
	HRRI	POPOINT,(AC+1)	;(+WC, FROM LOC)
	MOVNS	GDP,0		;MAKE GEN DATA POINTER
	HRLS	CDP,GDP		;-WC+1,FROM-WC
	ADDI	GDP,(AC+1)	;MAKE CHECK DATA POINTER
	ADDI	CDP,(AC)	;-WC+1, TO -WC
	MOVEM	CDP,POPE	;MAKE A POINTER FOR POP (E)
	HRRM	GDP,POPT5
	JUMPL	AC-1,POPT4	;NO MORE RANDOM IF ERROR SET
POPT3:	RANDM1			;FILL THE FROM AREA
	MOVEM	AC,(GDP)	;WHEN EXIT GDP=0,FROM
	AOBJN	GDP,.+1
	TLNE	GDP,770000
	JRST	POPT3

POPT4:	POP	POPOINT,(POPE)	;TRANSFER N WORDS WITH THE
	AOBJN	POPE,.+1	;POP INSTRUCTION
	TLNE	POPE,770000
	JRST	POPT4

POPT5:	MOVEI	1,0		;FILLED BY DATA FROM+WC
	ADDI	1,1
	HRLI	1,1		;CHECK THE POP POINTER
	CAME	1,POPOINT
	ERROR	POPOINT,1	;POP POINTER FAIL
	HRRZI	1,(AC+1)	;CHECK THE DATA
	MOVE	AC,(1)		;IN THE TO AREA
	CAME	AC,(CDP)	;AGAINST THE FROM AREA
	ERROR	AC,(CDP)	;DATA FAIL
	SUBI	1,1
	AOBJN	CDP,.+1
	TLNE	CDP,770000
	JRST	.-6
	LOOP	POPT1,POPRET

;PUSH TEST
;A RANDOM SET OF ADDRESS ARE CHOSEN SUCH THAT A FROM AND TO
;AREA ARE FORMED.  THE "TO" AREA IS THE TOP OF CORE (HIGH ADDRESS)
;AND "FROM" AREA IS THE LOWER ADDRESSES.  A RANDOM NUMBER IS
;GENERATED IN THE FROM AREA.  IT IS TRANSFERED BY THE PUSH INST
;TOO THE TO AREA.  WORKS ARE STORED SEQUENTIALY INCREMENTING IN THE
;"TO" AREA.  THE WORDS ARE OBTAINED BY DECREMENTING THROUGH THE
;FROM AREA.  IN THE EVENT OF ERROR THE PUSH POINTER IS RESET
;AND THE FAILURES IS CYCLED

	AC=5
	PP=2
	CKPP=3

PUSHT:	SETUP1	1,1
PUSHT1:	RANDM1
PUSHT2:	AND	AC,MODULO
	MOVS	AC+1,AC
	CAMG	AC,AC+1		;C(AC)R IS SMALLER ADDR
	EXCH	AC,AC+1		;C(AC+1)R IS LARGER ADDRESS
	ANDI	AC,-1		;SMALLEST ADDRESS MUST
	CAIG	AC,@MEMLOW	;BE ABOVE PROGRAM OR REJECT
	JRST	PUSHT1		;THESE NUMBERS
	MOVEI	(AC+1)		;FIND THE DIFFERENCE BETWEEN
	SUB	MODULO		;THE HIGHEST ADDR IN THE
	HRRES	1,0		;"TO" AREA AND THE TOP OF MEMORY
	JUMPGE	1,PUSHT1	;IF NO ROOM AT TOP REJECT
	MOVMS	1,0		;MAKE DIFF A POSITIVE NUMBER
PUSHT3:	HRRM	AC,PUSHT5	;THE FROM AREA ADDRESS
	HRRZ	CKPP,AC+1	;A WORD TO CHECK POINTER INC
PUSHT4:	RANDM1
PUSHT5:	MOVEM	AC,0(1)		;STORE A RANDOM NUMBER IN
	MOVEM	CKPP,PP		;THE FROM AREA
	PUSH	PP,@.-2		;C(E) TO C(C(ACRT))
	ADD	CKPP,[XWD 1,1]	;INC THE CHECK POINTER
	CAME	PP,CKPP		;CHECK FOR PROPER INCREMENT
	ERROR	PP,CKPP		;ERROR
	CAME	AC,(CKPP)	;DATA TRANSFER INCORRECT
	ERROR	AC,(CKPP)	;ERROR
	JUMPGE	AC-1,.+3	;IF ERROR SWITCH IS SET
	SUB	CKPP,[XWD 1,1]	;BACK UP THE POINTER
	JRST	PUSHT5		;AND REPEAT THE SEQ
	SOJG	1,PUSHT4	;GO UNTIL TOP OF CORE
	LOOP	PUSHT1,PUSHT1	;ITERATE TEST

;TEST POPJ
;CHECK TO SEE THAT THE POPJ CAN LOAD THE PC WITH EVERY
;ADDRESS IN THE BUFFER AND THAT IT JUMPS TO THE RIGHT
;LOC IN THE BUFFER

	AC=5
POPJ1:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC4,[JSP AC3,POPJ4]	;JSP AC3, POPJ4
	MOVEM	AC4,(AC)	;FROM THE END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
POPJ1A:	MOVE	AC,WCBUF	;MOVE (-TOP+END,END) INTO AC.
	MOVE	AC5,[XWD 1,AC1]	;MAKE POINTER=(1,AC1)
	MOVE	AC2,[PUSHJ AC5,POPJ3]	;PUT A PUSHJ IN AC2.
POPJ2:	MOVSI	AC1,(AC)	;SETUP AC1 SO BOTH HALVES
	HRRI	AC1,(AC)	;HAVE CURRENT LOC UNDER TEST.
	MOVEM	AC2,(AC1)	;STORE PUSHJ INTO CURRENT LOC IN BUFFER.
	POPJ	AC5,0		;DO THE POPJ.
POPJ3:	CAME	AC5,[XWD 1,AC1]	;PUSHJ IN MEM BROUGHT IT BACK HERE
	ERROR	AC5,[XWD 1,AC1]	;POINTER DIDN'T GET DEC+INC PROPERLY
	JRST	.+2		;GO AROUND ERROR UUO
POPJ4:	ERROR	AC3,AC1		;POPJ WENT TO WRONG LOC.
	JUMPL	AC-1,POPJ2	;LOOP ON ERROR SWITCH
	MOVEM	AC4,(AC)	;PUT A JSP IN CURRENT LOC.
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	POPJ2		;INC TO TEST NEXT LOC.
	SOJG	AC-1,POPJ1A	;ITERATION COUNTER.

;TEST PUSHJ.
;CHECK TO SEE THAT THE PUSHJ CAN GO TO EVERY LOC IN
;THE BUFFER AREA

	AC=6
PUSHJ1:	SETUP1	1,1
	MOVE	AC,BUFSIZ	;PUT A
	MOVE	AC4,[JSP AC3,PUSHJ4]	;JSP AC3, PUSHJ4
	MOVEM	AC4,(AC)	;FROM TH END OF PROG
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	.-3
PUSHJA:	MOVE	AC,WCBUF	;MOVE (-TOP+END,END) INTO AC.
	MOVE	AC2,[POPJ AC1,0];MOVE A POPJ INTO AC2.
PUSHJ2:	MOVSI	AC1,(AC)	;MAKE BOTH HALVES OF POINTER
	HRRI	AC1,(AC)	;= CURRENT LOC UNDER TEST.

PUSHJ3:	MOVEM	AC2,(AC1)	;STORE POPJ IN CURRENT BUFF LOC.
	PUSHJ	AC1,(AC1)	;DO A PUSHJ
	JRST	.+2		;PUSHJ WENT TO RIGHT LOC.
PUSHJ4:	ERROR	AC3,AC1		;PUSHJ WENT TO WRONG LOC.
	JUMPL	AC-1,PUSHJ2	;LOOP ON ERROR SWITCH.
	MOVEM	AC4,(AC1)	;RESTORE JSP IN CURRENT LOC.
	AOBJN	AC,.+1
	TLNE	AC,770000
	JRST	PUSHJ3		;INC TO TEST NEXT LOC.
	SOJG	AC-1,PUSHJA	;ITERATION COUNTER.


	JRST	BEGEND		;REPEAT TEST
ERROUT:	MOVEM	0,%ERAC0	;SAVE AC0.
	MOVEM	1,%ERAC1	;SAVE AC1.
	MOVEM	2,%ERAC2	;SAVE AC2.
	AOS	ERRTLS
	AOS	MICNT		;INC ERR COUNT.
	SKIPN	KLFLG
	SKIPE	USER		;USER MODE ?
	JRST	.+2
	DATAO	PI,MICNT	;EXEC MODE. PUT ER CNT INTO MI.
	SETZM	PROCED		;CLR PROCEED FLAG.
	SKIPGE	@ERRLOP		;1ST TIME THROUGH ERR PNT?
	JRST	EROUT2		;NO.  SEE IF PRINT ALL
	PNTNM
	SWITCH			;GO READ THE DATA SWITCHES.
EROUT1:	TLNE	0,NOPNT		;NO PRINTOUT ?
	JRST	%ERMORE		;YES. DON'T PNT AND GO HALT.
	SETZM	MICNT		;CLR ERR CNT.
	PMSG	<PC =   >
	MOVE	0,(P)
	SOJ	0,
	PNT6
	SETZM	ASTF#		;CLR PNT * FLAG.
	PMSG	<^DEFER TEST FAILURE.^COR =  >
	MOVE	0,FINAL
	PNT6			;PNT C(GOOD).
	PMSG	<^ERR = >
	MOVE	0,2
	PNT6			;PNT C(BAD).
	PNTMSG	[ASCIZ/
THE FOLLOWING IS A LIST OF ALL THE
LOCATIONS WHERE THE INDIRECT BIT WAS SET.
/]
	SETZ	1,
ERRT1:	PCRL
	HRRZ	0,TABL(1)	;GET ADDRESS ON LIST.
	CAMN	0,2		;= FAILING ADDRESS?
	SETOM	ASTF		;YES. SET PNT * FLAG.
	PNT6			;PNT ADDRESS ON LIST.
	MOVEI	0,AST
	SKIPE	ASTF		;PNT * FLAG SET?
	PNTA
	SETZM	ASTF		;CLR PNT * FLAG.
	CAIGE	1,-1(COUNT)	;END OF LIST?
	AOJA	1,ERRT1		;NO.
	PCRL
	SETZM	COUNT		;CLR COUNT.
	SKIPE	DFRTFG		;1ST DEFER TEST?
	HRRZ	4,TABL		;NO. SECOND.
	SKIPN	DFRTFG		;1ST DEFER TEST?
	MOVE	10,TABL		;RESTORE NUMBER.
	JRST	%ERMORE		;GO RESTORE AC'S AND RETURN.

EROUT2:	SWITCH
	TLNN	PALERS		;PRINT ALL ERRORS ?
	JRST	%ERMORE		;NO
	JRST	EROUT1		;YES

TABL:	BLOCK 40
      