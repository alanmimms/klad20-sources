;[toed.xkl.com]DXX:<KLAD.SOURCES>SMMAG.MAC.2, 18-Apr-96 17:09:22, Edit by GORIN
;fixed test for KL10 in SELECT.  It used an indeterminate form of BLT

;*MAINDEC-10-SMMAG

DECVER=3
MCNVER=0

	XLIST
DEFINE	NAME	(MCNVER,DECVER),<

TITLE	SMMAG	DECSYSTEM 2020 MAGTAPE DIAGNOSTIC MONITOR, VERSION MCNVER'.'DECVER >
	LIST
	LALL

NAME	\MCNVER,\DECVER


;*THIS PROGRAM PROVIDES THE PROGRAM LOADING CAPABILITY FOR KS-10
;*DIAGNOSTICS.  PROVIDES FOR LOADING AND RUNNING SINGLE DIAGNOSTICS OR
;*CHAIN EXECUTION OF A SERIES OF DIAGNOSTICS.

;*THIS PROGRAM WILL EXECUTE KS-10 DIAGNOSTICS AND RELIABILITY
;*PROGRAMS THAT ARE CAPABLE OF BEING RUN UNATTENDED.
;*RUNS ON KS10 PROCESSORS

;*IT PROVIDES FOR CONTINUOUS TESTING FOR EQUIPMENT CHECKOUT
;*AND/OR FAST ITERATION OPERATION FOR MARGIN TESTING.

;*ALSO PROVIDES SPECIAL USER MODE OPERATION FOR KS10

;*COPYRIGHT 1978,1979
;*DIGITAL EQUIPMENT CORPORATION
;*MARLBORO, MASS. 01752

;*JOHN R. KIRCHOFF

	LOC	137
MCNVER,,DECVER

	NOSYM

;ASSEMBLE AS FOLLOWS:
;	SMMAG.MAC

INLEND=27770			;COMMAND LIST END ADDRESS
SUBTTL	PARAMETERS

;*ACCUMULATORS

A=	1
B=	2
C=	3
W=	4
Q=	5
M=	7

DPNTR=	5			;DISK CMD LIST INPUT POINTER
LET=	6			;LETTERS TYPIN FLAG
NAM=	7			;NAME GENERATION AC'S
NAM1=	10
NAM2=	11
DIGIT=	12			;DIGIT GENERATION AC'S
DIGITA=	13
DIGIT1=	14
DIGIT2=	15
IP=	16			;COMMAND INDEX POINTER
P=	17			;PUSHDOWN POINTER

;*COMMAND DEFINITIONS

JOBSA=	120			;JOB STARTING ADDRESS
JOBFF=	121			;JOB FIRST FREE ADDRESS
JOBREL=	44			;JOB HIGHEST RELATIVE ADDRESS
FSELNK=	27772			;FILE SELECT LINK
FRDLNK=	27773			;FILE READ LINK
LDLNK=	27774			;LOAD LINK
DDTLNK=	27775			;DDT LINK
MODLNK=	27776			;MODE CHECK LINK
SUBLNK=	27777			;SUBROUTINE LINK

CHNCMD=	476			;CHANNEL COMMAND LIST

OPDEF	GO	[PUSHJ	P,0]
OPDEF	RTN	[POPJ	P,]
OPDEF	PUT	[PUSH	P,0]
OPDEF	GET	[POP	P,0]
OPDEF	PNTMSG	[GO	$PSIX]
OPDEF	PNTAL	[GO	TOUT]
OPDEF	TTICHR	[GO	TTYIN]
OPDEF	TTIOCT	[GO	TTYOCT]
OPDEF	SWITCH	[GO	$SWITCH]

OPDEF	CTYINI	[JSR	$TYINI]	;CTY INITIALIZATION
OPDEF	CTYCLR	[JSR	$TYCLR]	;CTY CLEAR
OPDEF	CTYTYI	[JSR	$CYTYI]	;CTY INPUT
OPDEF	CTYTYO	[JSR	$CYTYO]	;CTY OUTPUT
OPDEF	KTYTYI	[JSR	$KYTYI]	;KLINIK INPUT
OPDEF	KTYTYO	[JSR	$KYTYO]	;KLINIK OUTPUT
OPDEF	BTYTYI	[JSR	$BYTYI]	;BOTH INPUT
OPDEF	BTYTYO	[JSR	$BYTYO]	;BOTH OUTPUT

;*DIAGNOSTIC SPECIAL ADDRESSES

SUBRTN=	1005			;"SUBRTN" IDENTIFICATION WORD
DIAGNOS=30000			;DIAGNOSTIC START ADDRESS
DIAGMN=	30002			;PROG START ADDRESS
RETURN=	30012			;RETURN ADR STORAGE
$EMODE=	30031			;EXEC ALLOWED
$UMODE=	30032			;USER ALLOWED
ITRCNT=	30024			;PROG ITERATIONS
MONCTL=	30043			;DIAG MON CONTROL FLAG
RANDBS=	30022			;PROG RANDOM BASE
MONFLG=	30042			;SPECIAL USER CONTROL FLAG
MONTEN=	30044			;LOADED BY DIAMON FLAG
MARGIN=	30055			;KI10 MARGIN WORD
SMDDT=	10000			;SMDDT PROGRAM START ADDRESS

.LOC=	20000			;STARTING ADDRESS

;*SPECIAL DIAGNOSTIC START ADDRESSES

SFSTRT=	30004			;SPECIAL FEATURE START
PFSTRT=	30005			;POWER FAIL RESTART
REENTR=	30006			;PROGRAM REENTER START
DDT=	30007			;DDT START
START1=	30013			;START 1
START2=	30014			;START 2
START3=	30015			;START 3
START4=	30016			;START 4
START5=	30017			;START 5
;*SM-10 EPT PARAMETERS

$STD=	440			;PDP-10 DIAGNOSTIC START ADDRESS
$DDT=	441			;PDP-10 DDT START ADDRESS
$STL=	442			;PDP-10 LOADER START ADDRESS
$STM=	443			;PDP-10 MONITOR START ADDRESS

$80STAT=31			;8080 STATUS WORD
$80MM=	1B13			;MAINTENANCE MODE BIT
$80CIW=	32			;8080 TO KS-10 INPUT WORD
$80COW=	33			;KS-10 TO 8080 OUTPUT WORD
$80KIW=	34			;8080 TO KS-10 INPUT WORD - KLINIK
$80KOW=	35			;KS-10 TO 8080 OUTPUT WORD - KLINIK
$80CHR=	1B27			;CHAR AVAIL BIT
$80INT=	012000			;INTERRUPT 8080

;*PROCESSOR CONTROL BITS

IOCLR=	200000			;APR, I/O CLEAR
PICLR=	10000			;PI, PI CLEAR
USERF=	10000			;USER MODE FLAG

TRPENB=	020000			;ENABLE TRAPS
USERF=	10000			;USER MODE FLAG
PAG=	010			;PAGING I/O DEVICE CODE
MUUO=	424			;MUUO STORAGE
MUUOPC=	425			;C(PC) OF MUUO STORAGE
UPMP=	17000			;USER PAGE MAP PAGE
LLDUSB=	140000			;LOAD SM10 USER BASE REGISTER

;*SWITCH ASSIGNMENTS, RH SW'S NOT USED BY CALLED PROG

LPTSW=	20000			;SW 4, PRINT ON LPT
ERSTOP=	2000			;SW 7, STOP ON ERROR
RELIAB=	400			;SW 9, RELIABILITY MODE
CHAIN=	4			;SW 15, INHIBIT PROGRAM TITLE PRINT

XPAND=	400000			;SW 18, EXPANDED CONTROL SEQUENCING

DEFINE	MSG	(ARG),<[SIXBIT\ARG'_\]>

DEFINE	PMSG	(ARG),<
	MOVEI	[SIXBIT\ARG'_\]
	PNTMSG>
;*IO INSTRUCTIONS

OPDEF	TIOE	[710B8]
OPDEF	TION	[711B8]
OPDEF	RDIO	[712B8]
OPDEF	WRIO	[713B8]
OPDEF	BSIO	[714B8]
OPDEF	BCIO	[715B8]
OPDEF	TIOEB	[720B8]
OPDEF	TIONB	[721B8]
OPDEF	RDIOB	[722B8]
OPDEF	WRIOB	[723B8]
OPDEF	BSIOB	[724B8]
OPDEF	BCIOB	[725B8]

;*UNIBUS BIT NUMBERS

EBIT0==1
EBIT1==2
EBIT2==4
EBIT3==10
EBIT4==20
EBIT5==40
EBIT6==100
EBIT7==200
EBIT8==400
EBIT9==1000
EBIT10==2000
EBIT11==4000
EBIT12==10000
EBIT13==20000
EBIT14==40000
EBIT15==100000
SUBTTL	CONTROL SECTION

	LOC	421
	JFCL			;ARITHMETIC TRAP NO-OP
	HALT	.		;PUSHDOWN TRAP ERROR
	HALT	.		;TRAP 3 TRAP ERROR

	LOC	430
	432
	433
	HALT	.		;MUUO NO TRAP ERROR
	HALT	.		;MMUO TRAP ERROR

	LOC	442
	JRST	START		;"STL" START ADDRESS

	LOC	502
	503
	HALT	.		;PAGE FAIL ERROR

	LOC	.LOC

;*START - STARTING ADDRESS AND CONTROL FLAGS

START:	JRST	SELECT
RESTRT:	JRST	RUN
TITLE:	JRST	WHAT
RERUN:	JRST	RERUN1
ONETIM:	JRST	ONETM1
ITERAT:	0
USER:	0
CONSW:	0			;USER MODE SWITCHES
SMFLG:	0
KAIFLG:	0
SUSERF:	0
PASS:	0
ONCE:	0
RANBAS:	0
TTYSPD:	0			;TTY BAUD RATE
	0
;*ONETM1 - STARTUP & PROCESSOR TYPE DETERMINATION

ONETM1:	MOVE	JOBREL		;SAVE "DIAMON" MAX SIZE
	MOVEM	SVJBREL#
	SETZM	ONCE
	SETZM	CONSW

;*SELECT - START/RESTART INITIALIZATION

SELECT:	SETZM	DSKFLG#
	SETZM	USER
	JSP	0,.+1
	TLNE	0,USERF
	SETOM	USER		;USER MODE
	SKIPE	USER
	JRST	.+4
	CONO	PI,PICLR
	CONO	APR,IOCLR
	CONO	PAG,0
	MOVE	P,[-40,,PLIST]
	SETZM	SMFLG
	SETZM	KAIFLG
	SETZ	1,		;source 0, destination 0
	BLT	1,0		;copy 1 word, from 0 to 0
	SKIPN	1,		;BLT Changes AC on SM10 (and KL10)
	HALT	.		;WRONG PROCESSOR
	SETOM	SMFLG
	GO	SMINT		;SM-10, INIT TTY
	SKIPE	USER
	GO	USRINT		;USER INITIALIZATION
	MOVE	1,PGNAME
	SKIPE	USER
	SETNAM	1,		;USER, SET NAME BACK
	SKIPE	ONCE
	JRST	SELX		;NOT FIRST TIME
	MOVEI	HEADER
	PNTAL			;PRINT HEADER
	GO	AUTOSL		;SELECT LOAD DEVICE
;*SELX - DIAMON LINKAGE SETUP

SELX:	MOVEI	30001		;SETUP $START AS
	MOVEM	27774		;LOAD LINK
	MOVEI	FSELECT		;SETUP FILE SELECT LINK
	MOVEM	FSELNK
	MOVEI	FREAD		;SETUP FILE READ LINK
	MOVEM	FRDLNK
	SETZM	PGMGO
	MOVE	[PGMGO,,PGMGO+1]
	BLT	CNSFLG
	MOVE	[SIXBIT/SUBRTN/]
	CAMN	SUBRTN		;IS "SUBRTN" LOADED ?
	JRST	SELX1		;YES

;*AUTOMATICALLY LOAD "SUBSM" AND "SMDDT"

	SKIPN	USER
	JRST	.+5		;EXEC
	MOVEI	IP,[SIXBIT/SUBUSR/
		    0]
	GO	DIAGLD-2	;USER, LOAD "SUBUSR"
	JRST	SELX1		;CAN'T FIND, ALREADY REPORTED
	JRST	.+4
	MOVEI	IP,[SIXBIT/SUBSM/
		    0]
	GO	DIAGLD-2	;EXEC, LOAD "SUBSM"
	JRST	SELX1		;CAN'T FIND, ALREADY REPORTED
	MOVEI	IP,[SIXBIT/SMDDT/
		    0]
	GO	DIAGLD-2	;LOAD DDT ALSO
	JRST	SELX1
	MOVEI	$DDT
	SKIPE	USER
	MOVEM	74		;SET USER DDT START ADDRESS
;*PROCESS OPERATOR COMMAND

SELX1:	SETOM	ONCE
	MOVE	P,[-40,,PLIST]
	MOVEI	IP,SELSTR
	GO	CRLF1		;TYPE A CARRIAGE AND LINE FEED
	MOVE	A,PGNAME	;GET PROGRAM NAME
	GO	SIXBP		;PRINT IT
	SETOM	ASKSW#
	MOVSI	ERSTOP
	MOVEM	CONSW		;SET TO STOP ON ERROR IF AUTO CMD MODE
	PMSG	< CMD - >
	GO	FLNAME		;GET COMMAND OR FILE NAME
	JFCL
	MOVEI	IP,SELSTR
	SETZM	1
	MOVE	(IP)

CMDLP:	SKIPN	CMDLST(1)	;CHECK FOR SPECIAL COMMANDS
	AOJA	1,CMDLP1	;NOT IN FIRST PART OF LIST
	CAMN	CMDLST(1)
	JRST	CMDEX		;FOUND
	AOJA	1,CMDLP

CMDEX:	MOVE	0,CMDADR(1)	;GET START ADDRESS
	JRST	@0		;GO TO COMMAND ROUTINE

CMDLP1:	SKIPN	CMDLST(1)	;SPECIAL START COMMANDS
	JRST	RUNPR2		;NOT FOUND, MUST BE PROGRAM NAME
	CAMN	CMDLST(1)
	JRST	CMDEX1		;FOUND
	AOJA	1,CMDLP1

CMDEX1:	MOVE	0,CMDADR(1)	;GET SPECIAL START ADDRESS
	HRRM	SADR		;SET FOR START
	JRST	SADRQ		;GO START
SUBTTL	RUNPRG - RETRIEVE AND RUN SINGLE PROGRAM

RUNPRG:	PMSG	<^FILE.EXT - >
	MOVEI	IP,INLIST
	GO	FLNAME		;GET FILE NAME
	JFCL

RUNPR1:	MOVEI	IP,INLIST
	HLRZ	(IP)
	CAIN	(SIXBIT/G/)
	JRST	SADRQ
	SKIPN	(IP)
	JRST	EX4		;NO PROGRAM TO RUN

	HLLZ	1(IP)		;GET EXT
	JUMPN	0,.+5		;EXT SUPPLIED
	SKIPN	DEVFLG		;DOING DEVICE COMMAND FILE ?
	JRST	.+3		;NO
	MOVSI	(SIXBIT/CMD/)	;YES, USE "CMD" AS DEFAULT EXT
	HLLM	1(IP)

	MOVEM	IP,SAVEIP
	SETOM	PGMGO		;SET LOAD & GO FLAG

	GO	DIAGLD		;GO GET PROGRAM
	JRST	.+2

	JRST	DEVCM1		;MUST BE DEVICE COMMAND LIST
	SKIPN	ALTMFLG		;ALTMODE SELECTION ?
	JRST	SELECT		;NO, ERROR
	SETZM	ALTMFLG
	JRST	RUNPRG		;YES, ASK FOR NEXT PROGRAM
RUNPR2:	MOVE	SELSTR
	MOVEM	INLIST
	MOVE	SELSTR+1
	MOVEM	INLIST+1
	SETZM	INLIST+3
	JRST	RUNPR1

TT2CHR:	TTICHR			;INPUT 1ST CHAR
	CAIN	12
	RTN			;ONLY A CR
	MOVEM	0,LET
	TTICHR			;INPUT 2ND CHAR, SHOULD BE CR
	CAIE	12
	JRST	SELECT		;WASN'T
	MOVE	0,LET		;GET 1ST CHAR BACK
	JRST	CPOPJ1		;SKIP RETURN

SELXR:	GO	DEVSEL		;SELECT DEVICE
	JRST	SELX
CMDLST:	SIXBIT/H/
	SIXBIT/I/
	SIXBIT/T/
	SIXBIT/D/
	SIXBIT/S/
	SIXBIT/F/
	SIXBIT/L/
	SIXBIT/G/
	SIXBIT/X/
	SIXBIT/R/
	SIXBIT/SMMON/
	SIXBIT/SMMAG/
	SIXBIT/SMAPT/
	0
	SIXBIT/STD/
	SIXBIT/STL/
	SIXBIT/STM/
	SIXBIT/DDT/
	SIXBIT/START/
	SIXBIT/SFSTRT/
	SIXBIT/PFSTRT/
	SIXBIT/REE/
	SIXBIT/START1/
	SIXBIT/START2/
	SIXBIT/START3/
	SIXBIT/START4/
	SIXBIT/START5/
	0
CMDADR:	CMDHLP
	STORED
	TTYCMD
	DEVCMD
	RUNPRG
	DIRECT
	LIST1
	SADRQ
	SAXPN
	SELXR
	SMMON
	SMMAG
	SMAPT
	0
	$STD
	$STL
	$STM
	$DDT
	DIAGNOS
	SFSTRT
	PFSTRT
	REENTR
	START1
	START2
	START3
	START4
	START5
;*WHAT - IDENTIFY LAST PROGRAM

WHAT:	MOVE	P,[-40,,PLIST]
	GO	CRLF1
	MOVE	IP,SAVEIP
	GO	NAMPNT		;PRINT TITLE OF LAST PROGRAM
	JRST	START

;*NAMPNT - PRINT FILE NAME AND EXTENSION

NAMPNT:	MOVE	A,(IP)
	GO	SIXBP
	MOVEI	"."
	GO	PRINT
	HLLZ	A,1(IP)
	GO	SIXBP
	GO	CRLF1
	RTN

;*SIXBP - SIX BIT PRINTER

SIXBP:	MOVEI	B,0		;SO DON'T SHIFT IN JUNK
	SETZM	F
	LSHC	F,6		;GET A SIXBIT CHAR
	ADDI	F,40		;MAKE IT ASCII
	GO	PRINT		;TYPE IT
	JUMPN	A,SIXBP		;IF ANY MORE, TYPE THEM
CPOPJ:	RTN

;*PNT16 - PRINT ASCII CHAR IN AC16

PNT16:	PUT	0
	MOVE	0,16
	GO	PRINT
	GET	0
	RTN

;*CMDHLP, PRINT HELP TEXT

CMDHLP:	SKIPE	HLPCLR#		;HAS HELP BEEN OVERWRITTEN ?
	JRST	.+4		;YES
	MOVEI	HELP		;PRINT HELP
	PNTAL
	JRST	START
	PMSG	<NO HELP>
	JRST	START
SUBTTL	COMMAND LIST PROCESSING

;*STORED - USE INTERNAL COMMAND LIST

STORED:	SETZM	LPTFLG
	GO	CXPND		;SETUP EXPANDED OPERATIONS
	JRST	EX

;*TTYCMD - TELETYPE INPUT COMMAND LIST

TTYCMD:	PMSG	<^NAME]PASSES]RH SWS]ITERATIONS^>
CMNCMD:	MOVEI	IP,INLIST
	GO	FLNAME
	JRST	.-1		;INPUT TILL ^Z
	JRST	STORED

;*DEVCMD - DEVICE COMMAND LIST

DEVCMD:	SETZM	ASKSW
	SETOM	DEVFLG		;SET DEVICE CMD LIST FLAG
	JRST	RUNPRG		;GET COMMAND FILE

DEVCM1:	SETZM	DEVFLG		;CLEAR DEVICE CMD LIST FLAG
	SETOM	DINFLG		;SET "READ" FOR DEVICE IN
	SETZM	PGMGO		;CLEAR FOR COMMAND OPERATION
	MOVE	DPNTR,[POINT 7,31000]
	JRST	CMNCMD		;GO RUN COMMAND LIST

DEVCM2:	MOVE	13,[POINT 7,31000]
	GO	LDACHR		;READ A CHAR
	JRST	.+3		;EOF
	IDPB	16,13
	JRST	.-3
	MOVEI	16,177		;FLAG END OF INPUT
	IDPB	16,13
CPOPJ1:	AOS	(P)		;DONE, RETURN TO "DEVCM1"
	RTN

DEVRD:	ILDB	0,DPNTR		;GET CHARS FROM 31000 UP
	JUMPE	0,.-1		;IGNORE NULLS
	CAIN	0,177
	JRST	CPOPJ1		;177 BYTE SIGNIFIES END
	JRST	READ1		;FOR "READ"
SUBTTL	FLNAME - FILE NAME AND CONTROL INFO INPUT

FLNAME:	SETZM	SCFLAG
	SETZM	SUSERF
	TLO	LET,400000	;SET LETTERS FLAG
	SETZ	NAM1,		;CLEAR CONTROLS
	SETZB	NAM,DIGIT
	MOVEI	NAM2,^D30	;SETUP CHAR POSITIONING

;*FLNMLP - INPUT AND PROCESS CHARACTERS

FLNMLP:	GO	READ
	CAIN	32
	JRST	CPOPJ1		;^Z, LOGICAL END OF INPUT
	CAIN	12
	JRST	CRRTN		;CR, (ACTUALLY LF) COMPLETES LINE
	SKIPE	SCFLAG
	JRST	FLNMLP		;<;> TYPED, IGNORE REST OF LINE
	CAIN	73
	JRST	SCSET		;<;>
	CAIN	177
	JRST	RBOUT		;RUBOUT
	CAIN	55		;MINUS IS SPECIAL USER MODE FLAG
	JRST	MINUS
	CAIN	11
	JRST	TTAB		;TAB IS FIELD SEPARATOR
	JUMPE	FLNMLP		;REJECT 0'S
	JUMPGE	LET,FLNAM2	;JUMP IF ASSEMBLE DIGITS

;*FLNAM1 - FILE NAME PROCESS

FLNAM1:	CAIN	56
	JRST	PERIOD		;DOT, NAME.EXT SEPARATOR
	SUBI	40		;CONVERT TO 6BIT
	JUMPL	RBOUT		;CNTL CHAR, TREAT AS RUBOUT
	JUMPE	RBOUT		;0 IS ERROR
	LSH	0,(NAM2)	;POSITION CHAR
	IOR	NAM,0		;MERGE INTO NAME
	SUBI	NAM2,6		;CHANGE POSITIONING FOR NEXT
	JRST	FLNMLP		;GET NEXT CHAR
;*PERIOD - STORE FILE NAME, GO PROCESS EXTENSION

PERIOD:	MOVEM	NAM,NAM1	;SAVE FILE NAME
	JRST	FLNAME+4	;PROCESS EXTENTION

;*FLNAM2 - PROCESS DIGITS

FLNAM2:	MOVE	DIGITA,0
	LSH	DIGITA,^D33
	LSHC	DIGIT,3		;ASSEMBLE DIGITS
	JRST	FLNMLP

;*TTAB - FIELD SEPARATOR, STORE PREVIOUS FIELD

TTAB:	MOVEM	DIGIT1,DIGIT2
	MOVEM	DIGIT,DIGIT1
	SETZB	LET,DIGIT
	JRST	FLNMLP-1

;*MINUS - SET SPECIAL USER MODE

MINUS:	SETOM	SUSERF		;MINUS, SET SPECIAL USER FLAG
	JRST	FLNAME+3

;*SCSET - SEMICOLON, REST IS COMMENT

SCSET:	SETOM	SCFLAG
	JRST	FLNMLP

;*ZEROAC - ZERO AC'S BEFORE STARTING PROGRAM

ZEROAC:	MOVSI	16,-16
	SETZM	0(16)
	AOBJN	16,.-1
	SETZM	16
	RTN

RBOUT:	PMSG	<XXX^>
	JRST	FLNAME
;*COMMAND LIST FORMAT
;*	NAME
;*	EXT,,ITERATIONS	(BIT 18 SET IF SPEC USER)
;*	PASSES,,SWITCHES

;*CRRTN - CR, STORE COMMAND LIST INFORMATION

CRRTN:	SETZM	SCFLAG
	SKIPN	NAM
	JUMPE	NAM1,FLNAME	;REPEAT IF JUST CR
	SKIPN	NAM1		;NAME ONLY ?
	EXCH	NAM,NAM1	;YES
	MOVEM	NAM1,(IP)	;STORE THE FILE NAME
	HLLZM	NAM,1(IP)	;AND EXTENSION
	TRZ	DIGIT,400000
	SKIPE	SUSERF
	TRO	DIGIT,400000	;SET SPEC USER BIT
	HRRM	DIGIT,1(IP)	;ITERATIONS (IF SPEC USER BIT 18 SET)
	HRL	DIGIT1,DIGIT2	;PASSES,,SWITCHES
	MOVEM	DIGIT1,2(IP)
	ADDI	IP,3		;INCREMENT POINTER
CRRTN1:	SETZM	(IP)		;CLEAR LAST WORD
	CAIL	IP,HELP		;OVERWRITTEN HELP MESSAGE
	SETOM	HLPCLR		;YES, NO MORE HELP AVAILABLE
	CAIGE	IP,INLEND
	RTN

FULL:	PMSG	<^?CMDLST TOO LONG>
	JRST	START

EXNOE:	PMSG	<^%USER ONLY>
	JRST	EXBAD

EXNOU:	PMSG	<^%EXEC ONLY>

EXBAD:	MOVEI	0,1		;SET CMD LIST PASS COUNT TO INHIBIT
	HRLM	0,2(IP)		;FURTHER REQUEST OF THIS PROGRAM
	PMSG	<^%UNCHAINABLE->
	GO	NAMPNT		;INCORRECT FORMAT
	JRST	RET
SUBTTL	EXECUTE THE INPUT COMMAND LIST

;*EX - INITIALIZATION

EX:	SETZM	PASS
	GO	CRLF1

	SKIPN	ASKSW
	GO	LHSWS		;GET LH CONTROL SWITCHES
	SETOM	ASKSW

EX5:	SETZM	RUNCTL
	MOVEI	IP,INLIST	;INIT LIST POINTER
	AOS	PASS

;*EX1 - START PASS

EX1:	MOVEM	IP,SAVEIP
	SETZM	SUSERF
	SKIPN	(IP)
	JRST	EX4		;NO PROGRAMS TO RUN

	HLRZ	1,2(IP)		;GET PASSES TO RUN
	JUMPE	1,.+3		;0, RUN ALWAYS
	CAMGE	1,PASS		;RUN FOR REQUESTED PASSES
	JRST	RET

	MOVE	1(IP)		;PROG RUN IN SPECIAL
	TRNE	400000
	SETOM	SUSERF		;USER MODE ?

;*EX2 - PRINT NAME AND LOAD PROGRAM

EX2:	SWITCH			;READ SWITCHES
	TLNN	0,CHAIN		;INHIBIT TITLE PRINT ?
	GO	NAMPNT

	GO	CKTTY		;DID EXEC USER TYPE ^C ?
	GO	DIAGLD-2	;GET THE PROGRAM
	JRST	RET		;PROGRAM NOT FOUND
	GO	CKTTY		;DID EXEC USER TYPE ^C ?

;*EX3 - SETUP PROGRAM OPERATION PARAMETERS

EX3:	SKIPE	CMDFLG
	JRST	DEVCM1		;DOING NEW CMD FILE

	MOVE	IP,SAVEIP
	HRRZ	1,1(IP)		;GET THE ITERATION COUNT
	TRZ	1,400000	;CLEAR SPEC USER, IF SET
	SWITCH			;READ SWITCHES
	TLNN	0,RELIAB	;RELIABILITY MODE ?
	LSH	1,-6		;NO, 100(8):1 REDUCTION
	SKIPN	1
	ADDI	1,1		;ALWAYS ALLOW 1 ITERATION
	MOVEM	1,ITERAT

	MOVN	PASS
	HRL	2(IP)		;SETUP MONITR CONTROL

	MOVE	1,30002
	CAME	1,[JRST	@27774]
	JRST	EXBAD		;INCORRECT FORMAT

	SKIPE	USER		;IN USER MODE ?
	JRST	EXUSR		;YES

EXEXEC:	SKIPE	$EMODE		;EXEC, THIS PROG RUN IN EXEC ?
	JRST	EXNEW		;YES
	JRST	EXNOE		;NO

EXUSR:	SKIPE	$UMODE		;USER, THIS PROGRAM RUN IN USER ?
	JRST	EXNEW		;YES
	JRST	EXNOU		;NO

EXNEW:	SETOM	RUNCTL
	MOVSM	MONCTL		;LH = -PASS COUNT, RH = RH SWITCHES

	MOVE	0,RANBAS	;GENERATE PROG RANDOM BASE NUMBER
	ADD	0,[165742335216]
	ROT	0,-1
	EQVB	0,RANBAS
	MOVEM	0,RANDBS	;PUT IN PROG DATA AREA

;*RERUN1 - DISPATCH TO EXPANDED SETUP

RERUN1:	JRST	XPNRUN

;*RUN - PROGRAM RUN, CLEAR PROCESSOR FOR NEXT

RUN:	SKIPE	USER
	JRST	.+3
	CONO	PI,PICLR
	CONO	APR,IOCLR
	MOVE	P,[-40,,PLIST]
	MOVE	IP,SAVEIP
	GO	SMINT		;CLEAR SM

;*RET - ANY MORE PROGRAMS ON COMMAND LIST

RET:	ADDI	IP,3		;INCREMENT POINTER TO NEXT COMMAND
	SKIPE	(IP)
	JRST	EX1		;RUN NEXT PROGRAM
	SKIPN	RUNCTL		;ANY PROGRAMS RUN THIS PASS ?
	JRST	EX4		;NO
	GO	CRLF1		;PRINT A CARRIAGE RETURN AND LINE FEED
	MOVE	A,PGNAME	;GET PROGRAM NAME
	GO	SIXBP		;PRINT IT
	PMSG	< PASS >
	MOVE	PASS		;PRINT PASS COUNTER
	GO	PNTDEC
	GO	CRLF1
	JRST	EX5

;*EX4 - ALL FINISHED

EX4:	PMSG	<^CMD'S REQUIRED>
	JRST	SELECT
SUBTTL	EXPANDED COMMAND FORMAT SETUP

;*CXPND - EXPANDED ALLOWED

CXPND:	SKIPE	USER
	RTN			;NO EXPANDED FEATURES IN USER MODE

CXPND1:	SWITCH
	TRNN	XPAND		;ALLOW EXPANDED FEATURES ?
	RTN			;NO

;*STRD3 - SPECIAL USER MODE

STRD3:	PMSG	<^Y OR A FOR SPECIAL USER MODE - >
	GO	TT2CHR
	JRST	STRD4		;CR, NO SPECIAL USER
	CAIN	"Y"
	SETOB	0,USRFLG	;IF Y SET FLAG
	CAIN	"A"		;A, USER AFTER 1ST PASS
	JRST	STRD3A
	JUMPGE	0,STRD3		;OTHER IS GOOF

STRD3A:	MOVEM	0,USRFLG	;USRFLG = +, SPECIAL USER AFTER PASS 1

STRD4:	RTN
SUBTTL	SPECIAL RUN SEQUENCING

;*XPNRUN - DETERMINE AND SETUP FOR SPECIAL OPERATIONS

XPNRUN:	MOVE	ITERAT
	MOVEM	USRITR#

XPNRN1:	SKIPE	USER
	JRST	XPNRN2		;USER MODE
	SKIPE	USRFLG
	JRST	USRRUN		;SPECIAL USER MODE OPERATION

XPNRN2:	MOVE	0,ITERAT
	MOVEM	0,ITRCNT
	MOVEI	USSR2
	MOVEM	RETURN

XPNRN3:	GO	ZEROAC
	SETZM	17
	JRST	DIAGMN		;GO TO PROGRAM

;*USRRUN - SPECIAL USER MODE RUN SEQUENCING

USRRUN:	SKIPN	SUSERF		;ALLOW SPECIAL USER ?
	JRST	XPNRN2		;NO, RUN IN EXEC
	MOVEI	1
	MOVEM	ITERAT		;RETURN TO DIAMON AFTER EACH PASS
	SKIPG	USRFLG		;USRFLG - ='S RUN ALL
	JRST	.+4		;PASSES
	MOVE	2,PASS		;USRFLG + AND PASS 1 ='S
	CAIN	2,1		;RUN IN EXEC MODE
	JRST	XPNRN2
	MOVE	ITERAT
	MOVEM	ITRCNT
	SETZM	MONFLG		;CLEAR MONFLG
	MOVSI	1,-400		;SETUP USER PAGE MAP
	MOVE	0,[557776,,557777]
;*SETUP PAGE MAP AND TRAPS

	ADD	0,[2,,2]
	MOVEM	0,UPMP(1)
	AOBJN	1,.-2
	MOVE	0,[UPMP+160,,UPMP+400]	;SET EPPM SAME AS USER 340-377
	BLT	0,UPMP+417
	MOVE	0,[JSR USRERR]
	MOVEM	0,UPMP+420
	MOVEM	0,UPMP+422
	MOVEM	0,UPMP+423
	MOVSI	0,(JFCL)
	MOVEM	0,UPMP+421
	MOVEI	0,MUUOER
	MOVEM	0,UPMP+430
	MOVEM	0,UPMP+431
	MOVEM	0,UPMP+432
	MOVEM	0,UPMP+433
	MOVEI	0,MUUOH		;SETUP FOR HANDLER
	MOVEM	0,UPMP+434
	MOVEM	0,UPMP+435
	MOVEM	0,UPMP+436
	MOVEM	0,UPMP+437
	GO	PAGSM		;SM10
	JRSTF	@.+1
	USERF,,.+1		;ENTER USER MODE
	JRST	1,.+1		;ENTRY
	MOVEI	USSR1
	MOVEM	RETURN
	JRST	XPNRN3		;GO TO PROGRAM

;*USSR1 - PROGRAM COMPLETION CONTROL

USSR1:	77B8			;MUUO 77, RETURN TO EXEC MODE
USSR2:	SKIPE	USER
	JRST	RESTRT		;USER MODE, COMPLETED
	JRST	USSR3
PAGSM:	MOVEI	0,USRERR+1
	MOVEM	0,UPMP+427
	CONO	PAG,TRPENB
	DATAO	PAG,[LLDUSB,,400000!<UPMP_-^D9>]
	RTN

USSR3:	CONO	PAG,TRPENB
	DATAO	PAG,[LLDUSB,,400000]

USSR4:	SKIPE	SUSERF		;RUNNING SPECIAL USER ?
	SOSN	USRITR		;YES, FINISHED USER ITERATIONS ?
	JRST	RESTRT		;FINISHED ALL ITERATIONS
	JRST	XPNRN1		;NOT FINISHED, CONTINUE

;*MUUOER & USRERR - USER ERROR REPORTING

MUUOER:	MOVEI	MSG	<^?MUUO ERROR^>
	JRST	.+3

USRERR:	0
	MOVEI	MSG	<^?USER TRAP ERROR^>
	PNTMSG
	JRST	START
SUBTTL	SPECIAL USER MODE I/O HANDLER

MUUOH:	MOVEM	0,ACS0#		;SAVE AC0 AND AC1
	MOVEM	1,ACS1#
	HLRZ	1,UPMP+MUUO	;GET MUUO INSTRUCTION FIELD
	LSH	1,-^D9
	CAIN	1,257
	JRST	EXC		;IF MAP, DO AS MUUO FOR SM10
	MOVE	1,UPMP+MUUO	;GET MUUO
	JUMPGE	1,JRSTX		;A JRST, JEN OR MUUO
EXC:	MOVE	1,ACS1		;RESTORE AC1
	XCT	UPMP+MUUO	;EXECUTE
	SKIPA
	AOS	UPMP+MUUOPC	;INC RETURN IF CONSO, CONSZ SKIP
EXC1:	MOVEM	1,ACS1		;RESAVE AC1
	JRST	EXC4
EXC5:	MOVE	1,UPMP+MUUOPC	;SETUP RETURN
	TLO	1,USERF
	HLLM	1,EXC2		;SETUP FLAGS
	HRRM	1,EXC3		;SETUP RETURN PC
	MOVE	1,ACS1		;RESTORE AC1
	JRSTF	@.+1		;RESTORE FLAGS, GO TO USER
EXC2:	0,,.+1
EXC3:	JRST	1,0		;ENTRY

EXC4:	CONI	PAG,1
	TRO	1,TRPENB
	CONO	PAG,(1)
	DATAO	PAG,[LLDUSB,,400000!<UPMP_-^D9>]
	JRST	EXC5
JRSTX:	TLNE	1,700000
	JRST	JRSTX1
	TLC	1,077000
	TLCE	1,077000
	JRST	MUUOER		;INCORRECT MUUO
	JRST	USSR2		;MUUO 77, RETURN TO DIAG MON
JRSTX1:	TLNE	1,200
	HALT	@UPMP+MUUOPC	;HALT, POINTING TO ACTUAL HALT
	JRST	10,.+1		;JEN, DISMISS INTERRUPT
	JRST	EXC1

;*SAXPN - STANDALONE EXPANDED RUNNING
;*	  SPECIAL USER AND/OR MARGINS

SAXPN:	SKIPE	USER
	JRST	SELECT		;ILLEGAL IN USER MODE
	SETOM	ITERAT		;RUN PROGRAM FOREVER
	SWITCH
	HRLI	-1
	MOVEM	MONCTL		;LH = -PASS CNT, RH = RH SWS

	GO	STRD3		;SETUP 	EXPANDED FEATURES

	SKIPE	USRFLG		;IF SPECIAL USER WAS SELECTED
	SETOM	SUSERF		;SET FLAG TO RUN THAT WAY

	JRST	XPNRUN		;GO RUN PROGRAM
SUBTTL	MESSAGE PRINTER

;*PNTMSG - PRINT SIXBIT MESSAGES

$PSIX:	PUT	2
	PUT	3
	PUT	4
	HRRZ	4,0		;MESSAGE ADDRESS

$PSIX1:	MOVEI	3,6		;6 CHARS PER 6BIT WORD
	MOVE	1,(4)		;GET FIRST/NEXT WORD OF MESSAGE

$PSIX2:	SETZ	2,
	ROTC	1,6		;C(AC2)= CHAR TO BE PRINTED
	CAIN	2,77
	JRST	$PSIX5		;"BACKARROW", DONE
	CAIN	2,76
	JRST	$PSIX4		;"UPARROW", CR/LF
	CAIN	2,75
	MOVEI	2,151		;"BRACKET", CHANGE TO TAB
	MOVEI	0,40(2)		;CHANGE TO ASCII
	GO	PRINT		;PRINT CHAR
$PSIX3:	SOJN	3,$PSIX2	;PRINTED ALL CHARS FROM THIS WORD ?
	AOJA	4,$PSIX1	;YES, DO NEXT WORD

$PSIX4:	MOVEI	15
	GO	PRINT		;PRINT CR
	MOVEI	12
	GO	PRINT		;PRINT LF
	JRST	$PSIX3

$PSIX5:	GET	4
	GET	3
	GET	2
	RTN

;*PNTAL - PRINT ASCII MESSAGES

TOUTA:	AOSA	.+2		;INCREMENT MSG ADDRESS
TOUT:	HRRM	0,.+1		;C(0) = ADR OF MSG
	MOVE	1,0		;GET CHARACTERS
	TRO	1,1		;SET FLAG BIT
	LSHC	0,7		;CHAR TO 0
	ANDI	177		;MASK
	SKIPN	0		;IF NULL, EXIT
	RTN
	GO	PRINT		;PRINT C(0)
	CAME	1,[400000,,0]
	JRST	TOUT+3		;GET NEXT CHAR IN WORD
	JRST	TOUTA		;GET NEXT WORD
;*PNTOCT - PRINT OCTAL NUMBERS

PNTOCT:	MOVEI	2,6		;OCTAL PRINT
	HRL	1,0
	MOVEI	0,6
	LSHC	0,3
	GO	PRINT
	SOJG	2,PNTOCT+2
	RTN

;*PNTDEC - PRINT DECIMAL NUMBERS

PNTDEC:	IDIVI	0,^D10		;DECIMAL PRINTER
	HRLM	1,(P)
	SKIPE	0
	GO	PNTDEC
	HLRZ	0,(P)
	ADDI	0,"0"
	JRST	PRINT

;*PRINT - PRINT AN ASCII CHARACTER

PRINT:	AOS	CHRCTR
	MOVEM	1,SAVAC1
	ANDI	177
	MOVEM	0,SAVAC0
	CAIE	11
	JRST	PRINT1		;NOT TAB
	SOS	CHRCTR
	MOVEI	40
	GO	PRINT1
	AOS	1,CHRCTR	;OUTPUT REQUIRED SPACE'S FOR TAB FUNCTION
	TRNE	1,7
	JRST	.-4
	JRST	PRINT2
PRINT1:	CAIN	0,12		;LF ?
	SETZM	CHRCTR		;YES, CLEAR CHAR COUNTER
	CAIN	0,14		;FORM FEED ?
	SETZM	CHRCTR		;YES, CLEAR CHAR COUNTER
	SKIPE	LPTFLG
	JRST	PNTLPT		;PRINT ON LINE PRINTER
	SKIPE	USER
	JRST	PRINT4
	SKIPN	CNTLOF		;CONTROL O'ED ?
	BTYTYO			;TYPE CHAR
	GO	TTYCHK		;CHECK FOR OPERATOR CONTROL
	CAIN	15
	JRST	FILLCR		;FILL CR
	CAIN	12
	JRST	FILLLF		;FILL LF
PRINT2:	MOVE	1,SAVAC1
	MOVE	0,SAVAC0
	RTN			;EXIT

PRINT4:	OUTCHR
	JRST	PRINT2

;*MISCELLANEOUS

CRLF1:	PMSG	<^>
	RTN

FILLCR:	SETZM	CNTLOF#		;CLEAR CONTROL O FLAG
	MOVE	1,FCRCNT	;GET CR FILL COUNT
	JRST	FILLX+2		;SEND EXTRA CR

FILLLF:	MOVE	1,FLFCNT	;GET LF FILL COUNT
FILLX:	SOJL	1,PRINT2
	MOVEI	0,0		;USE 000 AS FILLER
	BTYTYO
	JRST	FILLX
;*PNTLPT - LINE PRINTER DRIVER

PNTLPT:	MOVEI	1,^D<<1000*750>/7>
	ANDI	0,177
	LSH	0,1
;	GO	SMLPT
	GO	TTYCHK		;CHECK FOR ABORT
;	GO	SMLPTR		;WAIT APPROX 750 MS
	SOJG	1,.-3
	SKIPG	1		;DID LPT RESPOND ?
	GO	LPTOFL		;ASK OPERATOR TO REENABLE IT
	JRST	PRINT2

;*LPTOFL - LINE PRINTER OFF-LINE

LPTOFL:	PUT	0
	PUT	1
	PUT	SAVAC0
	PUT	SAVAC1
	PUT	CHRCTR
	SETZM	LPTFLG		;SEND MESSAGE TO TTY
	MOVE	1,[POINT 7,LOFMSG]
	ILDB	0,1
	JUMPE	0,.+3
	GO	PRINT
	JRST	.-3
	TTICHR			;WAIT FOR OPERATOR
	CAIE	12
	JRST	.-2
	SETOM	LPTFLG		;REENABLE LINE PRINTER
	GET	CHRCTR
	GET	SAVAC1
	GET	SAVAC0
	GET	1
	GET	0
	RTN
;*TTYCHK - TELETYPE CHECK ROUTINE

TTYCHK:	SKIPE	TTYCFLG#	;INPUT CHECKING ALLOWED ?
	RTN			;NO

	PUT	0
	BTYTYI			;ANY TYPEIN ?
	GET	0
	RTN			;NO

	CAIN	0,003
	JRST	SELECT		;^C, START OVER
	CAIN	0,004
	JRST	TTYIND		;^D, START DDT
	CAIN	0,017
	SETOM	CNTLOF		;^O, INHIBIT OUTPUT
	GET	0
	RTN

LOFMSG:	ASCIZ/
LPT OFF-LINE, TYPE CR WHEN READY - /
SUBTTL	TELETYPE  INPUT

;*TTICHR - INPUT A TELETYPE CHARACTER

TTYIN:	SETZM	CNTLOF
	SETOM	TTYCFLG		;PREVENT INPUT CHECKS ON ECHO
	SKIPE	USER
	JRST	TTYINU
	GO	SMTYI

;*TTYINX - CHECK FOR SPECIAL CHAR PROCESS

TTYINX:	ANDI	177		;CLEAR PARITY BIT
	CAIN	023
	JRST	TTYIN		;XOFF
	CAIN	021
	JRST	TTYIN		;XON
	CAIN	003
	JRST	SELECT		;^C, START OVER
	CAIE	004
	JRST	.+5

;*TTYIND - TRANSFER TO DDT

TTYIND:	MOVE	SMDDT+1		;GET DDT IDENTIFIER
	CAMN	[ASCII/DDT/]
	JRST	$DDT		;^D, START DDT
	JRST	SELECT		;NOT THERE, START OVER
	CAIN	177
	JRST	TTYEXT		;RUBOUT
	SKIPE	SCFLAG		;IN COMMENT ?
	JRST	TTYINA
	CAIN	40		;SPACE, CHANGE TO TAB
	MOVEI	11
;*TTYINA - COMPLETE CHARACTER PROCESS

TTYINA:	CAIN	33
	JRST	TTALTM		;ALTMODE
	CAIN	176
	JRST	TTALTM		;ALTMODE
	CAIN	175
	JRST	TTALTM		;ALTMODE
	SKIPN	USER
	GO	PRINT
	CAIL	140		;CONVERT TO UPPER CASE
	TRZ	40
	CAIE	15		;IF CR
	JRST	TTYEXT
	MOVEI	12		;PRINT AND EXIT WITH LF
	SETZM	CHRCTR
	JRST	TTYINA
TTYEXT:	SETZM	TTYCFLG
	RTN

;*TTYINU - USER MODE CHARACTER INPUT

TTYINU:	INCHWL
	CAIE	0,15
	JRST	TTYINX
	SETZM	CHRCTR
	INCHRW
	JRST	TTYINX

;*CHECK EXEC TTY FOR ^C ABORT

CKTTY:	SKIPE	USER
	RTN			;IN USER MODE
	BTYTYI			;ANY INPUT ?
	RTN			;NO
	CAM
	ANDI	177
	CAIN	003		;CONTROL C ?
	JRST	SELECT		;YES, ABORT
	RTN			;NO, CONTINUE
;*USER MODE LH SWITCHES FOR CHAIN OPERATION

LHSWS:	PMSG	<LH SWS - >
	TTIOCT
	JRST	LHSWS
	HRLZM	0,CONSW
	RTN

;*TTIOCT - TELETYPE OCTAL NUMBER INPUT

TTYOCT:	SETZB	DIGIT,DIGITA
TTYOC1:	TTICHR			;INPUT A CHAR
	CAIN	12		;CR(LF), DONE
	JRST	TTYOC2

	CAIL	"0"		;A VALID DIGIT ?
	CAILE	"7"
	JRST	TTYOC3		;NO

	MOVE	DIGITA,0
	LSH	DIGITA,^D33
	LSHC	DIGIT,3		;INSERT NEW OCTAL
	JRST	TTYOC1

TTYOC2:	MOVE	0,DIGIT		;PUT NUMBER IN AC0
	JRST	CPOPJ1

TTYOC3:	SKIPN	USER
	RTN
	CLRBFI			;CLEAR INPUT
	RTN
;*READ - COMMAND FILE READ PROCESS

READ:	SKIPE	DINFLG		;DEVICE COMMAND LIST
	JRST	DEVRD		;YES
	JRST	TTYIN		;TTY REQUESTED
READ1:	ANDI	177
	CAIN	177
	RTN			;RUBOUT
	SKIPE	SCFLAG		;IN COMMENT ?
	JRST	.+3		;YES
	CAIN	40		;SPACE, CHANGE TO TAB
	MOVEI	11
	SKIPE	TAPEPF		;PRINT TAPE ?
	GO	PRINT		;YES
	CAIL	140		;CONVERT TO UPPER CASE
	TRZ	40
	CAIN	12		;IF LF IGNORE
	JRST	READ
	CAIN	14		;IF FF IGNORE
	JRST	READ
	CAIN	15		;IF CR CHANGE TO LF
	MOVEI	12
	JRST	TTYEXT

;*TTALTM - ALTMODE PROCESS

TTALTM:	SETOM	ALTMFLG		;SET ALTMODE FLAG
	MOVEI	"$"		;PRINT $ CR/LF
	SKIPN	USER		;DON'T PRINT $ IF USER
	GO	PRINT
	GO	CRLF1
	MOVEI	12		;RETURN WITH LF
	RTN

PNTTAB:	MOVEI	"	"
	JRST	PRINT		;PRINT A TAB & RTN
SUBTTL	SPECIAL ROUTINES

;*SWITCH - READ CONSOLE SWITCHES

$SWITCH:
$SWU:	MOVE	0,CONSW		;GET STORED SWITCHES
	RTN

;*SMINT - SM10 INITIALIZATION

SMINT:	SKIPE	USER
	RTN

	MOVE	[540000,,540001]	;SET UP PAGE TABLES
	MOVSI	1,-160		;TO RESET CONDITION
	MOVEM	600(1)
	ADD	[2,,2]		;SO PAGING
	AOBJN	1,.-2		;CAN BE TURNED ON

	MOVSI	(JFCL)
	MOVEM	421		;NO-OP ARITMETIC TRAP

	CTYINI			;INITIALIZE CTY

	RTN

SMTYI:	BTYTYI			;GET INPUT CHAR
	JRST	.-1		;NO, WAIT FOR IT
	HALT	.
	JUMPE	0,SMTYI
	RTN
;*CTY CONTROL ROUTINES

$TYINI:	0
	SETZM	$80CIW		;CLEAR INPUT WORD
	SETZM	$80COW		;CLEAR OUTPUT WORD
	SETZM	$80KIW		;CLEAR INPUT WORD
	SETZM	$80KOW		;CLEAR OUTPUT WORD
	SETZM	MMFLAG#
	MOVE	0,$80STAT	;GET CONSOLE STATUS WORD
	TLNE	0,($80MM)	;MAINTENANCE MODE BIT SET ?
	SETOM	MMFLAG		;YES, SET TTY IN MAINT MODE
	JRST	@$TYINI

$TYCLR:	0
	JRST	@$TYCLR		;NOTHING REQUIRED

$CYTYI:	0
	MOVE	0,$80CIW	;GET INPUT WORD
	TRNN	0,$80CHR	;CHAR FLAG BIT SET ?
	JRST	@$CYTYI		;NO

	SETZM	$80CIW		;CLEAR INPUT WORD
	ANDI	0,177

	AOS	$CYTYI
	AOS	$CYTYI
	JRST	@$CYTYI		;DOUBLE SKIP RETURN, CHAR IN AC0

$KYTYI:	0
	MOVE	0,$80KIW	;GET INPUT WORD
	TRNN	0,$80CHR	;CHAR FLAG BIT SET ?
	JRST	@$KYTYI		;NO

	SETZM	$80KIW		;CLEAR INPUT WORD
	ANDI	0,177

	AOS	$KYTYI
	AOS	$KYTYI
	JRST	@$KYTYI		;DOUBLE SKIP RETURN, CHAR IN AC0

$BYTYI:	0
	CTYTYI			;ANY CTY INPUT ?
	JRST	.+5		;NO
	HALT	.
	AOS	$BYTYI
	AOS	$BYTYI
	JRST	@$BYTYI		;DOUBLE SKIP RETURN, CHAR IN AC0
	KTYTYI			;ANY KLINIK INPUT ?
	JRST	@$BYTYI		;NO
	HALT	.
	JRST	.-6

$COMTI:	0
	SKIPE	MMFLAG		;IN MAINTENANCE MODE ?
	JRST	.+7		;YES

	CTYTYI			;ANY CTY INPUT ?
	JRST	@$COMTI		;NO
	HALT	.
	AOS	$COMTI
	AOS	$COMTI
	JRST	@$COMTI		;DOUBLE SKIP RETURN, CHAR IN AC0

	KTYTYI			;ANY KLINIK INPUT ?
	JRST	@$COMTI		;NO
	HALT	.
	AOS	$COMTI
	AOS	$COMTI
	JRST	@$COMTI		;DOUBLE SKIP RETURN, CHAR IN AC0

$CYTYO:	0
	TRO	0,$80CHR	;SET FLAG BIT
	MOVEM	0,$80COW	;PUT IN COMM AREA
	CONI	APR,0		;GET PRESENT APR
	ANDI	7		;KEEP PI ASSIGNMENT
	TRO	$80INT		;SET INTERRUPT 8080
	CONO	APR,@0		;INTERRUPT 8080
	MOVE	0,$80COW	;GET OUTPUT WORD
	TRNE	0,$80CHR	;8080 SENT THIS CHAR ?
	JRST	.-2		;NO, WAIT
	JRST	@$CYTYO		;YES

$KYTYO:	0
	TRO	0,$80CHR	;SET FLAG BIT
	MOVEM	0,$80KOW	;PUT IN COMM AREA
	CONI	APR,0		;GET PRESENT APR
	ANDI	7		;KEEP PI ASSIGNMENT
	TRO	$80INT		;SET INTERRUPT 8080
	CONO	APR,@0		;INTERRUPT 8080
	MOVE	0,$80KOW	;GET OUTPUT WORD
	TRNE	0,$80CHR	;8080 SENT THIS CHAR ?
	JRST	.-2		;NO, WAIT
	JRST	@$KYTYO		;YES

$BYTYO:	0
	MOVEM	0,$BYTYC#	;SAVE OUTPUT CHAR
	CTYTYO			;OUTPUT CHAR TO CTY
	MOVE	0,$BYTYC	;GET OUTPUT CHAR
	SKIPE	MMFLAG		;IN MAINTENANCE MODE ?
	KTYTYO			;YES, OUTPUT CHAR TO KLINIK
	JRST	@$BYTYO

$COMTO:	0
	SKIPE	MMFLAG		;IN MAINTENANCE MODE ?
	JRST	.+3		;YES
	CTYTYO			;OUTPUT CHAR TO CTY
	JRST	@$COMTO
	KTYTYO			;OUTPUT CHAR TO KLINIK
	JRST	@$COMTO
;*AC USAGE

F=	0			;FLAGS

T1=	1			;TEMP
T2=	2
T3=	3
T4=	4

Q1=	5			;GENERALLY HOLDS A SINGLE CHAR
Q2=	6			;BYTE POINTER TO INPUT STRING
Q3=	7			;BYTE POINTER TO OUTPUT STRING

P1=	10			;PRESERVED
P2=	11
P3=	12			;A NUMBER
P4=	13			;DESTINATION POINTER (DISK ADR, BYTE POINTER)
P5=	14			;DISK ADR OR PARSER STATE

PNT=	15
PNT1=	16
SUBTTL	DEVICE SELECTION

OPDEF	TTSIXB	[PUSHJ P,TTYSXB]
OPDEF	TAPOP.	[CALLI 154]

;*AUTOSL - EXEC AUTOMATICALLY SELECT DEVICE

AUTOSL:	GO	DEVSXX		;INIT FLAGS
	SKIPN	USER
	JRST	AUTORH		;EXEC - AUTO SELECT DRIVE

;*DEVSEL - ASK WHICH DEVICE

DEVSEL:	GO	DEVSXX		;INIT FLAGS
	SKIPN	USER		;SKIP IF USER MODE
	JRST	EXECDV		;NO
	PMSG	<^DEV:(CR FOR DSK) - >
	TTSIXB			;INPUT DEVICE NAME
	JRST	.-3		;ASK AGAIN
	JUMPN	LET,USRMAG	;IF NAME TYPED, MUST BE A MAGTAPE
	SETZM	MAGDEV		;CLEAR MAGTAPE DEVICE FLAG
	MOVSI	'DSK'		;SET UP DEVICE AS DSK
	MOVEM	LDBLK+1		;PUT IN OPEN INFO BLOCK
	MOVE	[201,,LDBF1+1]	;SET UP DATA BUFFER
	MOVEM	LDBF+1		;IN A RING OF THREE BUFFERS
	HRRI	LDBF2+1
	MOVEM	LDBF1+1
	HRRI	LDBF+1
	MOVEM	LDBF2+1
	MOVEI	UREADB		;SET UP READ BLOCK DISPATCH
	MOVEM	READBL		;TO USER MODE READ ROUTINE
	RTN

DEVSXX:	SETOM	MAGDEV#		;SET MAGTAPE DEVICE FLAG
	MOVEI	-1		;SET MAGTAPE POSITION FLAG
	MOVEM	MAGONCE#	;TO TAPE POSITION UNKNOWN
	SETZM	TAB+1		;MARK DIRECTORY EMPTY
	RTN
;*USRMAG - SELECT USER MODE MAGTAPE DEVICE OR DISK

LDCHN=	16			;USER LOAD CHANNEL

USRMAG:	MOVEM	LET,LDBLK+1	;PUT NAME IN LDBLK
	OPEN	LDCHN,LDBLK	;OPEN DEVICE
	JRST	DEVSEL		;DEVICE NOT AVAILABLE
	MOVEI	LDCHN		;GET CHANNEL NUMBER
	MTCHR.			;READ CHARACTERISTICS OF DEVICE
	JRST	DEVSEL		;DEVICE NOT A MAGNETIC TAPE
	MOVEI	3		;GET CODE FOR 800 BPI
	MOVEM	TAPEDC		;STORE IT
	TRNE	1B31		;CHECK IF 7-TRACK
	JRST	DEN800		;7-TRACK, MUST BE 800 BPI
	MOVE	[XWD 2,[1002	;READ CONTROLLER TYPE CODE
			LDCHN ]]	;  FOR MAGTAPE
	TAPOP.			;OBTAIN THE CODE
	JRST	WHDEN		;ERROR, ASK ANYWAY
	JUMPL	WHDEN		;IF NEGATIVE, ASK FOR DENSITY
	CAIG	3		;IF TM10, DENSITY MUST BE 800
				;IF DX10, DON'T CARE ABOUT DENSITY
	JRST	DEN800		;DON'T ASK
WHDEN:	GO	ASKDEN		;ASK WHICH DENSITY
	AOS	TAPEDC		;SET DENSITY CODE TO 1600 BPI
DEN800:	RELEASE LDCHN,		;RELEASE THE CHANNEL
	MOVE	[MAGRCD+1,,LDBF+1]	;SET UP USER BUFFER
	MOVEM	LDBF+1		; A RING OF ONLY ONE BUFFER
	MOVE	[[EXP UREADB,UREVRS,UFORWD,UREW],,READBL]	;LOAD
	BLT	REW		;DISPATCH LOCATIONS FOR USER ROUTINES
	RTN			;RETURN

ASKDEN:	PMSG	<1600 BPI ? - >
	GO	TT2CHR		;LOOK FOR YES ANSWER
	JRST	.+3		;CARRIAGE RETURN ONLY, SAME AS YES
	CAIE	"Y"		;SKIP IF Y TYPED
	AOS	(P)		;CAUSE SKIP RETURN
	RTN
;*EXECDV - EXEC MODE DEVICE NUMBER INPUT

EXECDV:	PMSG	<^UBA # - >
	TTIOCT
	JRST	EXECDV
	CAIN	0,0
	JRST	EXEDV0		;0 = UBA 3, RH ADR 772440
	CAIN	0,1
	JRST	EXEDV1		;1 = UBA 1, RH ADR 772440
	CAIN	0,2
	JRST	EXEDV2		;2 = UBA 2, RH ADR 772440
	CAIN	0,3
	JRST	EXEDV3		;3 = UBA 3, RH ADR 772440

EXEDVX:	GO	EXEDXX		;SETUP INDIRECT POINTER TABLE
	JRST	RH11DV

EXEDXX:	MOVE	A,MTPNTR
	MOVEM	(A)		;SETUP INDIRECT POINTER TABLE
	ADDI	2
	AOBJN	A,.-2
	MOVEI	MTUBP0
	HRRM	UNBMP0		;SETUP INDIRECT UNIBUS MAP POINTER
	MOVEI	UNVBIT
	HRRM	$MSUVB		;SET PROPER UNIBUS VALID BIT
	RTN

MTPNTR:	-^D15,,MTCS1

EXEDV0:	MOVE	[3,,772440]
	JRST	EXEDVX
EXEDV1:	MOVE	[1,,772440]
	JRST	EXEDVX
EXEDV2:	MOVE	[2,,772440]
	JRST	EXEDVX
EXEDV3:	MOVE	[3,,772440]
	JRST	EXEDVX
;*TTSIXB - INPUT SIXBIT WORD

TTYSXB:	SETZ	LET,		;CLEAR LETTER AC
	TTICHR			;INPUT ONE CHARACTER
	CAIN	":"
	JRST	TTYSXB+1
	CAIN	12		;RETURN +2 IF CARRIAGE RETURN
	JRST	TTYSXX
	CAIL	"0"		;CHECK IF CHARACTER
	CAILE	"Z"		;  IS A LETTER OR DIGIT
	RTN			;NO
	CAIG	"9"		;KEEP CHECKING
	JRST	.+3
	CAIGE	"A"
	RTN
	TLNE	LET,770000	;SIX CHARACTERS ALREADY INPUT?
	RTN			;YES, GIVE ERROR RETURN
	SUBI	40		;CONVERT TO SIXBIT
	LSH	LET,6		;SHIFT PREVIOUS LETTERS
	ORM	LET		;OR WITH THIS LETTER
	JRST	TTYSXB+1	;GET NEXT
TTYSXX:	JUMPE	LET,CPOPJ1	;RETURN NOW IF NO LETTERS TYPED
	TLNE	LET,770000	;LEFT JUSTIFY INPUT LETTERS
	JRST	CPOPJ1		;RETURN +2
	LSH	LET,6		;SHIFT LEFT
	JRST	TTYSXX		;CHECK AGAIN


UNIT:	PMSG	<DRIVE & SLAVE ## - >
	TTIOCT			;GET UNIT NUMBER
	JRST	EXECDV		;ERROR
	RTN
;*LIST1 - LIST FILES

LIST1:	SETOM	LSTFLG
	JRST	RUNPRG

;*DIRECT - PRINT DIRECTORY

DIRECT:	SKIPN	MAGDEV		;ILLEGAL FOR DSK
	JRST	SELECT
	SETOM	PGMGO		;SET LOAD AND GO FLAG
	SWITCH
	TLNE	LPTSW
	SETOM	LPTFLG
	CTYCLR
	MOVEI	IP,[SIXBIT/SMTAPE/
		    SIXBIT/MTA/]	;SET UP DIRECTORY NAME
	SETOM	DIRFLG		;SET PRINTING DIRECTORY FLAG
	GO	DIAGLD		;SET UP THE FILE
	JRST	SELECT		;FILE NOT FOUND
DIRPNT:	GO	RWORD		;READ FIRST WORD OF FILE
	JRST	SELECT		;NO WORDS IN FILE
DIRLIN:	GO	CRLF1		;PRINT A CARRIAGE RETURN, LINE FEED
	MOVEI	M,4		;SET UP ENTRIES PER LINE COUNTER
	SKIPE	LPTFLG		;SKIP IF OUTPUTTING TO LINE PRINTER
	MOVEI	M,8		;YES, SET COUNT TO 8
DIRFIL:	GO	RWORD		;READ FILE NAME
	JRST	DIREND		;END OF FILE
	TLNN	W,770000	;CHECK IF A FILE NAME
	JRST	DIRRCD		;NO, MUST BE END OF RECORD
	MOVE	A,W		;MOVE WORD TO A
	GO	SIXBP		;PRINT IT
	GO	PNTTAB		;PRINT A TAB
	GO	RWORD		;READ EXTENSION
	JRST	DIREND		;END OF FILE
	HLLZ	A,W		;MOVE WORD TO A
	GO	SIXBP		;PRINT IT
	GO	RWORD		;READ NEXT WORD
	JRST	DIREND		;END OF FILE
	SOJLE	M,DIRLIN	;END OF LINE?
	GO	PNTTAB		;NO, PRINT A TAB
	JRST	DIRFIL		;PRINT NEXT FILE NAME
DIREND:	GO	CRLF1		;END THE LINE
	JRST	SELECT		;END OF DIRECTORY
DIRRCD:	TLNE	W,-1		;ABSOLUTE END OF DIRECTORY FILE?
	JRST	DIREND		;YES
	MOVEM	M,SAVEM#
	GO	RWORD		;NO, READ HEADER WORD FROM NEXT RECORD
	JRST	DIREND		;END OF FILE
	MOVE	M,SAVEM
	JRST	DIRFIL		;PRINT THIS FILE NAME
SUBTTL	PROGRAM FILE SELECTION

;*FSELECT - "SUBRTN" FILE SELECTION

FSELECT:SETOM	SPECIAL#	;SET SPECIAL MODE
	SETZM	NOCMNT
	MOVEM	0,IP		;SET POINTER TO FILE SPEC
	JRST	DIAGLD+2

;*DIAGLD - "DIAMON" FILE SELECTION

	SETOM	NOCMNT#		;INHIBIT COMMENT PRINTING
	JRST	.+2
DIAGLD:	SETZM	NOCMNT
	SETZM	SPECIAL		;SET NORMAL MODE
	SETZM	A10FLG#
	SETZM	LDEVICE#
	SETZM	CMDFLG#

	HLRZ	0,1(IP)
	CAIN	0,(SIXBIT/A10/)
	SETOM	A10FLG

DIAGLA:	SKIPE	USER		;SKIP IF EXEC MODE
	JRST	USERLD		;LOAD FROM DSK

	JRST	EXECLD		;LOAD EXEC

STOP:	RTN			;NO ACTION NEEDED TO STOP A MAGTAPE
;*RFILE - FILE FOUND AND SETUP

RFILE:	SETZM	Q		;CLEAR FILE READ WORD COUNTER
	MOVEI	M,5		;SET LDACHR BYTE COUNTER
	SETOM	FBSAV#		;SET 8 BIT READ FILE BYTE COUNTER
	MOVEM	M,SAVEM
	MOVEM	13,SAV13#
	MOVEM	14,SAV14#
	SKIPN	SPECIAL		;FILE FOUND
	JRST	RFILE1		;NORMAL OPERATION

;*FSELF - "SUBRTN" FILE FOUND RETURN

FSELF:	MOVEM	0,ACSAVE	;SAVE ACS
	MOVE	0,[1,,ACSAVE+1]
	BLT	ACSAVE+16
	MOVE	0,LDEVICE	;RETURN DEVICE TYPE
	AOS	(P)
	RTN			;SKIP RETURN TO "SUBRTN"

;*NFERR - FILE NOT FOUND

NFERR:	SKIPN	SPECIAL		;NOT FOUND
	JRST	NFERR1		;NORMAL OPERATION

;*FSELNF - "SUBRTN" FILE NOT FOUND

FSELNF:	MOVE	0,LDEVICE	;"FSELECT" - NOT FOUND
	RTN			;NON-SKIP, ERROR RETURN
SUBTTL	"SUBRTN" PROGRAM FILE READ

;*FREAD - DETERMINE READ TYPE

FREAD:	MOVEM	0,FRDTYP#
	MOVS	[1,,ACSAVE+1]
	BLT	16		;RESTORE "DIAMON" ACS
	MOVE	ACSAVE
	SKIPGE	FRDTYP
	JRST	FRD36		;READ 36 BIT WORDS
	SKIPE	FRDTYP
	JRST	FRD8		;READ 8 BIT WORDS

;*FREAD3 - CHARACTER READ

FREAD3:	GO	LDACHR		;LOAD AN ASCII CHARACTER
	JRST	FREAD2		;EOF

FREAD1:	MOVEM	0,ACSAVE	;RESAVE "DIAMON" ACS
	MOVE	0,[1,,ACSAVE+1]
	BLT	ACSAVE+16

	MOVE	0,16		;PUT ASCII BYTE IN AC0
	AOS	(P)
	RTN			;SKIP RETURN

;*FREAD2 - END OF FILE

FREAD2:	SETZM	0		;EOF CODE = 0
	RTN			;NON-SKIP RETURN

;*FRD36 - 36 BIT WORD READ

FRD36:	GO	RWORD		;READ 36 BIT WORDS
	JRST	FREAD2		;EOF
	MOVE	16,W		;PUT 36 BIT WORD IN AC16
	JRST	FREAD1		;REST AS ABOVE
;*LDACHR - ASCII CHARACTER PROCESS

LDACHR:	CAIE	M,5		;USED ALL OF THIS 36 BIT WORD ?
	JRST	LDACH1		;NOT YET
	SETZM	M		;YES, READ NEXT 36 BIT WORD
	EXCH	M,SAVEM
	EXCH	13,SAV13
	EXCH	14,SAV14
	GO	RWORD
	JRST	LDAEOF		;EOF
	EXCH	13,SAV13
	EXCH	14,SAV14
	EXCH	M,SAVEM

LDACH1:	LDB	16,[POINT 7,W,6
		POINT 7,W,13
		POINT 7,W,20
		POINT 7,W,27
		POINT 7,W,34](M)	;GET ASCII BYTE
	AOS	M		;COUNT IT
LDACH2:	JUMPE	16,LDACHR	;IF NULL, IGNORE
	AOS	(P)		;SKIP RETURN
	RTN

LDAEOF:	EXCH	M,SAVEM
	EXCH	13,SAV13
	EXCH	14,SAV14
	RTN

;*FRD8 - 8 BIT WORD READ

FRD8:	GO	G8BYT		;GET AN 8 BIT BYTE
	JRST	FREAD2		;EOF
	JRST	FREAD1		;8 BIT BYTE IN AC16

G8BYT:	AOS	M,FBSAV		;ADVANCE FILE BYTE
	ANDI	M,3		;(MOD 4)
	JUMPN	M,G8BY2		;NEED A NEW WORD ?

	GO	RWORD		;YES
	RTN			;EOF

G8BY1:	MOVEM	W,BYTSAV#	;SAVE WORD

G8BY2:	LDB	16,[POINT 8,BYTSAV,17
		    POINT 8,BYTSAV,9
		    POINT 8,BYTSAV,35
		    POINT 8,BYTSAV,27](M)
	JRST	CPOPJ1		;LOAD & SKIP RETURN WITH BYTE
SUBTTL	LDA10 - LOAD PDP-10 ASCIIZED ".A10" FILE

;*PDPROC - FORMAT CONTROL PROCESS

LDA10:
LDPROC:	SETZM	LDOCTF#
	SETZM	LDZBLK#

	GO	LDACHR		;GET FILE TYPE CHAR
	GO	LERR2		;EOF
	CAIN	16,";"
	JRST	LDCMNT		;LINE STARTS WITH ;, COMMENT

	SETZM	LDTBLK#
	CAIN	16,"A"		;A, PDP-10 SUPER A10 FILE
	JRST	.+6
	CAIN	16,"T"		;T, PDP-10 ".A10" FILE
	JRST	[SETOM	LDTBLK
		JRST	.+4]
	CAIE	16,"Z"		;Z, ".A10" CORE ZERO
	GO	LERR3
	SETOM	LDZBLK

	GO	LDACHR		;GET FORMAT CHAR
	GO	LERR2		;EOF

	CAIN	16," "		;SPACE, ASCIIZED
	JRST	.+4
	CAIE	16,"O"		;O, OCTAL
	GO	LERR4
	SETOM	LDOCTF

	MOVE	16,[LDCNT,,LDCNT+1]
	SETZM	LDCNT
	BLT	16,LDATAE	;CLEAR LOAD STORAGE

	MOVEI	13,LDCNT	;SETUP CONVERTED STORAGE POINTER
;*LDCNV - CONVERT ASCIIZED BACK INTO BITS

LDCNV:	SETZM	14		;CLEAR CONVERTED WORD FORMER

LDCNV1:	GO	LDACHR		;LOAD AN ASCII CHAR
	GO	LERR2		;EOF

	CAIN	16,15		;CR, IGNORE
	JRST	LDCNV1

	CAIN	16,12		;LF, END OF LINE
	JRST	LDEOL

	CAIN	16,54		;COMMA, FIELD SEPARATOR
	JRST	LDCMA

	SKIPE	LDOCTF
	JRST	LDCNV3		;LOADING OCTAL FORMAT

	CAIL	16,"5"		;5 TO : ?
	CAILE	16,":"
	JRST	.+6		;NO
	SUBI	16,"5"		;YES, INSERT SUPPRESSED ONES
	LSH	14,6
	TRO	14,77
	SOJGE	16,.-2
	JRST	LDCNV1

	CAIL	16,"0"		;0 TO 4 ?
	CAILE	16,"4"
	JRST	.+5		;NO
	ANDI	16,7		;YES, INSERT SUPPRESSED ZEROS
	LSH	14,6
	SOJGE	16,.-1
	JRST	LDCNV1

	LSH	14,6		;SHIFT WORD FORMER LEFT 6
	ANDI	16,77		;KEEP ASCIIZED OIT BITS

LDCNV2:	OR	14,16		;INSERT NEW OIT
	JRST	LDCNV1

LDCNV3:	LSH	14,3		;SHIFT WORD FORMER LEFT 3, OCTAL
	ANDI	16,7		;KEEP OCTAL OIT BITS
	JRST	LDCNV2

LDCMA:	MOVEM	14,(13)		;STORE CONVERTED WORD
	AOJA	13,LDCNV	;COUNT AND GO FOR NEXT WORD
;*LDEOL - END OF LINE, CHECKSUM LOAD LINE

LDEOL:	MOVEM	14,(13)		;STORE CHECKSUM

	SKIPE	LDOCTF
	JRST	LDTEN		;OCTAL, NO CHECKSUM

	MOVEI	13,LDCNT	;CHECKSUM LOAD STORAGE
	SETZM	14
	ADD	14,(13)
	CAIE	13,LDATAE
	AOJA	13,.-2

	TRNE	14,177777	;16 BIT CHECKSUM = 0 ?
	GO	LERR5		;NO, CHECKSUM ERROR

;*LDTEN - CREATE LOAD ADDRESS AND WORD COUNT

LDTEN:	LDB	13,[POINT 2,LDCNT,27]
	LSH	13,^D16
	OR	13,LDADR	;CREATE PDP-10 LOAD ADDRESS

	LDB	14,[POINT 8,LDCNT,35]	;WORD COUNT

	SKIPN	LDZBLK
	JRST	LDTEN1		;LOAD TEN DATA WORDS

;*LDTENZ - CLEAR TEN CORE, JOB START TO JOB FIRST FREE

LDTENZ:	JUMPE	14,LDPROC	;WC=0, NO ZEROING
	MOVEM	13,JOBSAW	;SETUP JOB START ADDRESS
	ADD	13,LDATA-1(14)
	SOJG	14,.-1		;ADD UP ZERO COUNT
	MOVEM	13,JOBFFW	;SETUP JOB FIRST FREE ADDRESS

	GO	CLRCOR		;CLEAR PDP-10 CORE
	JRST	LDPROC
;*LDTEN1 - TRANSFER TEN WORDS TO MEMORY

LDTEN1:	SKIPN	LDTBLK
	MOVE	13,LDADR
	JUMPE	14,LDDONE	;WC=0, TRANSFER BLOCK

	MOVEI	15,LDATA	;SETUP PICKUP POINTER
	SKIPE	LDDMON
	JRST	LDTEN3

LDTEN2:	MOVE	16,(15)		;GET 36 BIT WORD
	SKIPN	LDTBLK
	JRST	.+6
	MOVE	16,2(15)	;BITS 0 TO 7
	LSH	16,^D16
	OR	16,1(15)	;BITS 8 TO 23
	LSH	16,^D16
	OR	16,0(15)	;BITS 24 TO 35

	MOVEM	16,(13)		;STORE 36 BIT WORD IN MEMORY

	AOS	13		;INCREMENT PDP-10 ADDRESS
	ADDI	15,1		;BUMP PICKUP POINTER
	SKIPE	LDTBLK
	ADDI	15,2
	SUBI	14,1		;DECREMENT WORD COUNT
	SKIPE	LDTBLK
	SUBI	14,2
	JUMPG	14,LDTEN2	;DO TILL ALL WORDS USED
	JRST	LDPROC		;CONTINUE TILL TRANSFER BLOCK

;*LDDONE - COMPLETED, GO TO START ROUTINE

LDDONE:	MOVE	W,13		;SETUP START ADDRESS
	JRST	STARTQ		;GO TO START ROUTINE

;*LDCMNT - LOAD FILE COMMENT LINE

LDCMNT:	PUT	0
	GO	CMNPNT		;PRINT REST OF COMMENT LINE
	GET	0
	JRST	LDPROC

;*CMNPNT - PRINT COMMENT LINE

CMNPNT:	GO	LDACHR
	JRST	LERR2
	CAIN	16,12		;LINE FEED ?
	JRST	.+4		;YES
	SKIPN	NOCMNT
	GO	PNT16		;PRINT COMMENT LINE
	JRST	CMNPNT
	SKIPN	NOCMNT
	GO	PNT16
	RTN
SUBTTL	PROGRAM CORE AREA SETUP

;*PRGCOR - SETUP CORE ZEROING FOR ".SAV" FILES

PRGCOR:	SKIPE	A10FLG
	JRST	LDA10		;LOAD ".A10" FILE

	SETZM	Q
	GO	RWORD		;READ FIRST BLOCK/WORD
	GO	ERR2		;EOF, ILLEGAL

	MOVEM	W,SAVT0#
	MOVEM	Q,SAVT1#
	MOVEM	M,SAVT2#
	MOVEM	Q2,SAVT3#
	MOVEM	C,SAVT4#

	SKIPL	W
	GO	ERR6		;FIRST WORD NOT POINTER
	MOVEI	M,^D126(W)
	MOVEI	Q2,137		;FIRST POINTER LEGAL ?
	CAMGE	M,Q2
	GO	ERR6		;NO

	HRRZ	Q,SAVT1
	MOVEI	Q2,JOBSA
	GO	RMS1		;GET 'JOBSA'
	HRRZM	W,JOBSAW#
	SKIPN	Q,JOBSAW	
	GO	ERR7		;NO STARTING ADDRESS
	CAIN	Q,140
	GO	ERR7		;PROGRAMS CAN'T START AT 140

	HRRZ	Q,SAVT1
	MOVEI	Q2,JOBFF
	GO	RMS1		;GET 'JOBFF'
	MOVEM	W,JOBFFW#

	GO	CLRCOR		;CLEAR PROGRAM'S CORE AREA
	MOVE	W,SAVT0
	MOVE	Q,SAVT1
	MOVE	M,SAVT2
	MOVE	Q2,SAVT3
	MOVE	C,SAVT4
	JRST	RFILL3		;NOW GO LOAD PROGRAM

RMS2:	SUB	Q,C
	AOJ	Q,
RMS1:	MOVE	W,(Q)		;GET POINTER
	HRRZ	M,W		; X
	HLRO	C,W		; -N
	SUB	M,C		; X+N IN M
	CAMGE	M,Q2		;THIS POINTER TO REQ DATA ?
	JRST	RMS2		;NO, GET NEXT POINTER
	SUBI	Q2,(W)		;YES, HOW FAR FROM POINTER ?
	ADD	Q,Q2		;INCREMENT POINTER
	MOVE	W,(Q)		;GET REQ DATA
	RTN

;*CLRCOR - CLEAR CORE FOR DIAGNOSTIC SEGMENT
;*	   CLEARS CORE FROM 'JOBSA' TO 'JOBFF'

CLRCOR:	SKIPE	LDDMON
	JRST	CLRCR2
	SKIPN	USER		;USER MODE ?
	JRST	CLRCR1		;NO
	MOVE	JOBREL		;YES, PRESENT JOBREL LT DIAMON'S ?
	CAMG	SVJBREL
	JRST	.+4		;YES
	MOVE	SVJBREL		;NO, REDUCE CORE TO DIAMON'S
	CORE
	JRST	ERR10
	MOVE	JOBFFW		;THIS PRG NEED MORE THAN DIAMON'S ?
	CAMG	SVJBREL
	JRST	.+3		;NO
	CORE			;YES, EXPAND CORE FOR PROGRAM
	JRST	ERR10
CLRCR1:	MOVEM	Q,SAVQ#
	MOVE	Q,JOBSAW
	CAIL	Q,START		;DO NOT, REPEAT NOT, CLEAR "DIAMON" !
	CAIL	Q,DIAGNOS
	SETZM	(Q)
	CAMGE	Q,JOBFFW
	AOJA	Q,.-4
	MOVE	Q,SAVQ
	RTN
;*LSTPNT - LIST FILES (ASCIZ)

LSTPNT:	SETOM	SPECIAL
	PUSH	P,0
	SWITCH
	TLNE	LPTSW
	SETOM	LPTFLG
	CTYCLR
	POP	P,0
LSTPN1:	GO	LDACHR		;READ A CHAR
	JRST	START		;EOF
	GO	PNT16		;PRINT IT
	JRST	LSTPN1


;*RFILE1 - HERE WHEN FILE FOUND

RFILE1:	SKIPE	LSTFLG
	JRST	LSTPNT		;LISTING FILE
	SKIPE	DIRFLG		;PRINTING DIRECTORY?
	JRST	DIRPNT		;YES, PRINT DIR OF MAGTAPE

	SKIPN	CMDFLG
	SKIPE	DEVFLG		;READING CMD LIST FILE ?
	JRST	DEVCM2		;YES
	JRST	PRGCOR		;SETUP PROGRAM'S CORE AREA

RFILL1:	GO	RWORD		;READ POINTER OR TRANSFER WORD
	GO	ERR2		;EOF, ERROR

RFILL3:	SKIPL	M,W		;WHICH IS IT?
	JRST	STARTQ		;TRANSFER WORD

	SKIPE	LDDMON
	JRST	RFILL4

RFILL2: GO	RWORD		;READ DATA WORD
	GO	ERR2		;EOF, ERROR
	MOVEM	W,1(M)		;STORE IT IN CORE
	AOBJN	M,RFILL2	;COUNT THE CORE POINTER
	JRST	RFILL1		;IT RAN OUT, GET ANOTHER

;*RWORD - READ DATA WORD FROM FILE

RWORD:	SOSLE	LDBUF+2		;CHECK IF ANY WORDS IN BUFFER
	JRST	RWORD2		;YES, GET A WORD
	SKIPN	MAGDEV		;SKIP IF READING FROM MAGTAPE
	JRST	RWORD1		;NO, GO AND READ
	SKIPGE	MAGONCE		;SKIP IF TAPE NO INTO A RECORD
RWORD1:	GO	@READBL		;READ NEXT RECORD
	RTN			;EOF RETURN
RWORD2:	ILDB	W,LDBUF+1	;GET DATA WORD
	MOVE	Q,LDBUF+1	;GET POINTER
	JRST	CPOPJ1		;RETURN +2


;*STARTQ - HERE ON TRANSFER WORD

STARTQ:	SKIPE	LDDMON
	JRST	STARTM
	SKIPE	USER		;SKIP IF EXEC MODE
	RELEASE	LDCHN,		;RELEASE CHANNEL
	HRRM	W,SADR		;SAVE STARTING ADDRESS
	TRNN	W,-1		;ANY ADDRESS ?
	GO	ERR7		;NO, MUST NOT HAVE RIGHT FILE
	SETOM	MONTEN		;SET LOADED BY TEN FLAG
	MOVEI	START		;SETUP RETURN TO DIAMON
	MOVEM	RETURN
	HRRM	120		;SETUP JOB DATA AREA ALSO
	SKIPN	PGMGO		;LOAD & GO ?
	JRST	CPOPJ1		;NO, BACK TO MONITOR
	SKIPE	ALTMFLG
	RTN			;ALTMODE, RETURN TO LOADER

SADRQ:	CTYCLR
	MOVE	A,@SAVEIP
	SKIPE	USER
	SETNAM	A,		;USER, IDENTIFY PROGRAM RUNNING
	MOVE	SVJBREL		;SET JOBREL AS "DIAMON" RUN SIZE
	MOVEM	JOBREL
	GO	ZEROAC		;CLEAR AC'S
	SETZM	17
SADR:	JRST	0		;YES, GO
SUBTTL	USER MODE LOADER

;*USERLD - LOOKUP FILE ON THE USERS DISK

USERLD:	SETZM	LDBUF+1
	SETZM	LDBUF+2
	OPEN	LDCHN,LDBLK	;SETUP INPUT FILE
	GO	ERR8
	MOVE	[400000,,LDBF+1]
	MOVEM	LDBUF		;SETUP BUFFER POINTER
	SKIPE	MAGDEV		;SKIP IF READING FROM DSK
	JRST	UMAGLD		;NO, GO TO MAG LOADER
	MOVE	[201,,LDBF1+1]
	MOVEM	LDBF+1		;CLEAR BUFFER USE BITS
	MOVE	[201,,LDBF2+1]
	MOVEM	LDBF1+1
	MOVE	[201,,LDBF+1]
	MOVEM	LDBF2+1
	MOVEI	5		;SET UP DSK CODE
	MOVEM	LDEVICE		;FOR SUBRTN
	MOVE	(IP)
	MOVEM	LDNAME		;SETUP FILE NAME
	HLLZ	1(IP)
	JUMPE	USLD1		;IF NO EXT, TRY A10 & SAV

	GO	USLKUP		;LOOKUP FILE
	JRST	RFILE		;FOUND
	JRST	NFERR		;NOT FOUND

USLD1:	MOVSI	(SIXBIT/SAV/)
	GO	USLKUP		;LOOKUP "SAV"
	JRST	RFILE		;FOUND
	MOVSI	(SIXBIT/CMD/)
	GO	USLKUP		;LOOKUP "CMD"
	JRST	RFILE		;FOUND
	MOVSI	(SIXBIT/A10/)
	GO	USLKUP		;LOOKUP "A10"
	JRST	RFILE		;FOUND
	JRST	NFERR		;COUNDN'T FIND EITHER

USLKUP:	MOVEM	LDNAME+1
	LOOKUP	LDCHN,LDNAME
	JRST	CPOPJ1		;NOT FOUND
	HLRZ	LDNAME+1
	CAIN	(SIXBIT/CMD/)
	SETOM	CMDFLG		;LOADING "CMD" FILE
	CAIN	(SIXBIT/A10/)
	SETOM	A10FLG		;LOADING "A10" FILE
	RTN
;USER MODE TAPE MOTION ROUTINES

;READ A DATA BLOCK

UREADB:	IN	LDCHN,		;INPUT A WORD
	JRST	CPOPJ1		;RETURN +2
	STATZ	LDCHN,740000	;ERROR, SKIP IF ONLY EOF
	GO	ERR9		;NO, FATAL ERROR
RDEOF:	SETZM	MAGONCE		;SET TAPE AT START OF FILE
	RTN			;EOF RETURN

;MOVE TAPE REVERSE

UREVRS:	MTBSF.	LDCHN,		;MOVE TAPE BACKWARD OVER ONE FILE
	RTN

;MOVE TAPE FORWARD

UFORWD:	MTSKF.	LDCHN,		;MOVE TAPE FORWARD OVER FILE
	RTN

;REWIND THE TAPE

UREW:	MTREW.	LDCHN,		;REWIND THE TAPE
	RTN

;*USRINT - USER MODE INIT, SETUP MINIMUM OF 32K OF CORE

USRINT:	MOVEI	<^D32*^D1024>-1
	CAMG	SVJBREL		;DO WE HAVE 32K MINIMUM ?
	RTN			;YES
	CORE			;NO, EXPAND CORE TO 32K
	GO	ERR10
	MOVE	JOBREL
	MOVEM	SVJBREL		;SAVE MAX CORE NOW
	RTN
SUBTTL	MAGTAPE LOADER

UMAGLD:	MOVE	[XWD 3,TAPEDN]	;SET UP TO SELECT DENSITY
	TAPOP.			;SET DENSITY
	SETSTS	LDCHN,613	;NO TAPOP.S, SET STATUS BITS TO 800 BPI

MAGLD:	MOVEI	6		;SET MAGTAPE CODE TO 6
	MOVEM	LDEVICE		;PUT IN LDEVICE FOR SUBRTN
	SKIPLE	MAGONCE		;TAPE POSITION KNOWN?
	GO	@REW		;NO, REWIND
	SKIPGE	MAGONCE		;AT START OF FILE?
	GO	@FORWRD		;NO, MOVE TO START
	SETZM	MAGONCE		;CLEAR FLAG, POSITION KNOWN
	MOVEI	A,TAB+1		;SET UP ADDRESS OF DIRECTORY
	GO	LOOKUP		;LOOK FOR FILE NAME
	JRST	LDDIR		;NOT THERE, GO READ DIRECTORY FILE

FNFND:	MOVEI	-1		;SET TAPE POSITION FLAG
	MOVEM	MAGONCE		; TO POSITION UNKNOWN
	ADD	B,TAB		;COMPUTE FILE NUMBER
	MOVEM	B,PRGNBR#	;SAVE FILE NUMBER
	SUB	B,CURR#		;FIND NUMBER OF FILES TO SPACE
	JUMPL	B,BACKUP	;BACKSPACE TO SELECTED FILE
	JUMPLE	B,.+3		;GO AROUND IF AT FILE
	GO	@FORWRD		;SPACE FORWARD OVER UNWANTED FILES
	SOJG	B,.-1

TRANS:	MOVE	PRGNBR		;GET PROGRAM NUMBER
	ADDI	1		;SET UP FOR POSITION AFTER PROG READ
	MOVEM	CURR		;STORE TAPE POSITION IN CURR
	SETOM	MAGONCE		;SET IN FILE FLAG
	SETZM	LDBUF+2		;CLEAR CHARACTERS IN BUFFER COUNTER
	JRST	RFILE		;GO TO READ FILE

BACKUP:	GO	@REVERS		;BACKSPACE OVER UNWANTED FILES
	AOJLE	B,.-1
	GO	@FORWRD		;MOVE FORWARD OVER FILE MARK
	JRST	TRANS


EXECLD:	MOVSI	4400		;SET UP BYTE POINTER
	MOVEM	LDBUF+1		;IN BUFFER HEADER
	SETZM	LDBUF+2		;CLEAR WORD COUNT
	JRST	MAGLD
;LOOKUP FILE NAME IN DIRECTORY IN CORE
;ENTER WITH ADR OF DIRECTORY RECORD IN A

LOOKUP:	SETZ	B,		;CLEAR FILE COUNTER
LOOKU0:	MOVE	(A)		;GET A FILE NAME
	TLNN	770000		;CHECK IF END OF RECORD
	RTN			;YES, FILE NOT FOUND
	CAME	(IP)		;COMPARE FILE NAME
	JRST	LOOKU3		;NO MATCH, KEEP LOOKING
	HLRZ	1(IP)		;GET SPECIFIED EXTENSION
	HLRZ	C,1(A)		;GET EXTENSION FROM DIRECTORY
	JUMPN	LOOKU1		;JUMP IF EXTENSION SPECIFIED
	CAIN	C,'CMD'		;LOOK FOR CMD EXTENSION
	JRST	LOOKU2		;FOUND
	CAIN	C,'A10'		;LOOK FOR A10 EXTENSION
	JRST	LOOKU2		;FOUND
	MOVEI	'SAV'		;LOOK FOR SAV EXTENSION
LOOKU1:	CAME	C		;COMPARE WITH EXTENSION
	JRST	LOOKU3		;NO MATCH
LOOKU2:	CAIN	C,'CMD'		;IS EXTENSION CMD?
	SETOM	CMDFLG		;YES, SET FLAG
	CAIN	C,'A10'		;IS EXTENSION A10?
	SETOM	A10FLG		;YES, SET FLAG
	JRST	CPOPJ1		;SUCCESSFUL RETURN
LOOKU3:	ADDI	A,3		;MOVE TO NEXT NAME IN LIST
	AOJA	B,LOOKU0	;GO LOOK AT IT

LDDIR:	TLNE	-1		;CHECK IF ENTIRE DIRECTORY
	SKIPE	TAB		;  IS IN CORE
	SKIPA			;NO
	JRST	NFERR		;FILE NOT FOUND
	MOVEI	C,-1		;SET TAPE POSITION FLAG
	MOVEM	C,MAGONCE	;TO POSITION UNKNOWN
	SKIPE	CURR		;SKIP IF AT BOT
	GO	@REW		;NO, REWIND THE TAPE
	MOVEI	C,4		;SPACE FORWARD TO DIRECTORY FILE
	GO	@FORWRD		;  SMTAPE.MTA
	SOJG	C,.-1
	MOVEI	5		;SET CURRENT TAPE POSITION
	MOVEM	CURR		;TO FILE AFTER DIRECTORY
	SETOM	MAGONCE		;SET IN FILE FLAG
LDDIRB:	GO	@READBL		;READ A BLOCK OF DIRECTORY
	GO	ERR13		;ERROR
	MOVE	C,RBUF		;COMPUTE CHECKSUM OF DIRECTORY RECORD
	MOVEI	A,RBUF+1	;INDEX TO DATA WORDS
DIRCK:	ADD	C,(A)		;ADD ENTRIES OF CURRENT FILE
	ADD	C,1(A)
	ADD	C,2(A)
	ADDI	A,3		;INCREASE POINTER OVER ENTRY
	MOVE	B,(A)		;GET NEXT WORD
	TLNE	B,770000	;CHECK IF A FILE NAME
	JRST	DIRCK		;YES, ADD THIS ENTRY
	HLRZ	C		;GET LEFT HALF OF COMPUTED CHECKSUM
	ADDI	(C)		;ADD RIGHT HALF TO IT
	HRRZ			;STRIP TO 18 BITS
	CAIE	(B)		;COMPARE TO CHECKSUM FROM TAPE
	GO	ERR13		;CHECKSUM ERROR
	MOVEI	A,RBUF+1	;SET UP TO LOOK FOR FILE NAME
	GO	LOOKUP		;IN RECORD JUST READ
	JRST	LDDIRN		;NOT HERE, LOOK IN NEXT RECORD OF DIRECTORY
	MOVE	[RBUF,,TAB]	;TRANSFER THIS DIRECTORY
	BLT	TAB+MAGRCD-1	;INTO TAB
	JRST	DIAGLA		;GO POSITION TO FILE

LDDIRN:	TLNN	-1		;CHECK IF LAST RECORD OF DIRECTORY
	JRST	LDDIRB		;NO, READ NEXT DATA BLOCK
	JRST	NFERR		;YES, FILE NOT FOUND
SUBTTL	EXEC MAGTAPE LOAD ROUTINES

MSRH=	36		;RH-11 BASE ADDRESS
MSDRIVE=37		;DRIVE NUMBER
MSSLAVE=40		;SLAVE & FORMAT

MAGRCD=	^D512		;SIZE OF MAGTAPE RECORD IN WORDS
RETRY=	^D10		;RETRY COUNT

;*MAGTAPE CONTROL COMMANDS

MT.NOP=	01		;NO-OP
MT.RWO=	03		;REWIND OFF-LINE
MT.RW=	07		;REWIND
MT.DC=	11		;DRIVE CLEAR
MT.ERS=	25		;ERASE
MT.WTM=	27		;WRITE TAPE MARK
MT.SF=	31		;SPACE FORWARD
MT.SR=	33		;SPACE REVERSE
MT.WCF=	51		;WRITE CHECK FORWARD
MT.WCR=	57		;WRITE CHECK REVERSE
MT.WF=	61		;WRITE FORWARD
MT.RF=	71		;READ FORWARD
MT.RR=	77		;READ REVERSE

;*MAGTAPE CONTROL AND STATUS 1 BITS

MTSC=	100000		;SPECIAL CONDITION
MTTRE=	40000		;TRANSFER ERROR
MTMCPE=	20000		;MASSBUS CONTROL PARITY ERROR
MTDVA=	4000		;DRIVE AVAILABLE
MTPSEL=	2000		;PORT SELECT
MTRDY=	200		;READY
MTIE=	100		;INTERRUPT ENABLE

RH.PA=	23		;RP0X PACK ACK
RH.DC=	11		;RP0X DRIVE CLEAR
RH.RIP=	21		;RP0X READ-IN PRESET
;*MAGTAPE CONTROL AND STATUS REG 2 BITS

MTDLT=	100000		;DATA LATE
MTWCE=	40000		;WRITE CHECK ERROR
MTPE=	20000		;PARITY ERROR
MTNED=	10000		;NON-EXISTENT DRIVE
MTNEM=	4000		;NON-EXISTENT MEMORY
MTPGE=	2000		;PROGRAM ERROR
MTMXF=	1000		;MISSED TRANSFER
MTMDPE=	400		;MASSBUS DATA PARITY ERROR
MTOR=	200		;OUTPUT READY
MTIR=	100		;INPUT READY
MTCLR=	40		;CONTROLLER CLEAR
MTPAT=	20		;PARITY TEST
MTBAI=	10		;BUS ADR INCREMENT INHIBIT

;*MAGTAPE DRIVE STATUS REG BITS

MTATA=	100000		;ATTENTION
MTERR=	40000		;ERROR
MTPIP=	20000		;POSITIONING IN PROGRESS
MTMOL=	10000		;MEDIUM ON-LINE
MTWRL=	4000		;WRITE LOCKED
MTEOT=	2000		;END OF TAPE
MTDPR=	400		;DRIVE PRESENT
MTDRY=	200		;DRIVE READY
MTSSC=	100		;SLAVE STATUS CHANGE
MTPES=	40		;PHASE ENCODED
MTSDWN=	20		;SLOWING DOWN
MTIDB=	10		;IDENTIFICATION BURST
MTTM=	4		;TAPE MARK
MTBOT=	2		;BEGINNING OF TAPE
MTSLA=	1		;SLAVE ATTENTION

;*MAGTAPE ERROR REG BITS

MTCOR=	100000		;CORRECTABLE DATA ERROR
MTUNS=	40000		;UNSAFE
MTOPI=	20000		;OPERATION INCOMPLETE
MTDTE=	10000		;DRIVE TIMING ERROR
MTNEF=	4000		;NON-EXECUTABLE FUNCTION
MTCS=	2000		;CORRECTABLE SKEW
MTFCE=	1000		;FRAME COUNT ERROR
MTNSG=	400		;NON STANDARD GAP
MTPEF=	200		;PE FORMAT ERROR
MTINC=	100		;INCORRECTABLE DATA
MTDPAR=	40		;DATA BUS PARITY
MTFMT=	20		;FORMAT ERROR
MTCPAR=	10		;CONTROL BUS PARITY
MTRMR=	4		;REGISTER MODIFICATION REFUSED
MTILR=	2		;ILLEGAL REGISTER
MTILF=	1		;ILLEGAL FUNCTION
;*MAGTAPE TAPE CONTROL BITS

MTACCL=	100000		;ACCELERATION
MTFCS=	40000		;FRAME CONTROL STATUS
MTTCW=	20000		;TAPE CONTROL WRITE
MTEOA=	10000		;ENABLE ABORT ON DTATA TRANSFER ERROR

MT200=	0		;200 BPI
MT556=	400		;556 BPI
MT800=	1000		;800 BPI
MT1600=	2000		;1600 BPI

MTFMT1=	0		;FORMAT ?????

MTEVP=	10		;EVEN PARITY

;*UNIBUS DEFINITIONS

MTPGSZ=	^D512*2			;PAGE SIZE FOR MAGTAPE TRANSFER

MTUBP0=	763000			;ADDRESS OF UNIBUS MAP
UNVBIT=	40000			;VALID UNIBUS BIT
UNV36X=	10000			;36 BIT UNIBUS TRANSFER
UNVDPB=	20000			;DISABLE UNIBUS PARITY BITS
RH11DV:	GO	UNIT		;GET UNIT NUMBER
	CAILE	77		;CHECK IF LEGAL
	JRST	EXECDV		;NO, ERROR
	PUT	0
	ANDI	0,7
	MOVEM	0,MTSLAVE#	;SAVE SLAVE NUMBER
	GET	0
	LSH	-3
	ANDI	0,7
	MOVEM	0,MTDRIVE#	;SAVE DRIVE NUMBER

	MOVEI	B,MT800		;SET DENSITY CODE TO 800 BPI
	GO	ASKDEN		;ASK WHICH DENSITY
	MOVEI	B,MT1600	;MAKE IT 1600 BPI
	MOVEM	B,MTDENSITY#	;SAVE DENSITY

RH11DX:	MOVEI	MTFMT1
	MOVEM	MTFORMAT#	;SET MAGTAPE FORMAT

	MOVE	[[EXP MSREAD,MSREVS,MSFORW,MSREW],,READBL]
	BLT	REW		;SET UP DISPATCH LOCATIONS TO MS ROUTINES

	GO	MSRSET		;RESET THE CONTROLLER
	JRST	EXECDV		;NO DRIVE THERE, ERROR

	RTN

;*AUTORH - AUTO SELECT DRIVE

AUTORH:	MOVE	MSRH
	SKIPN
	JRST	DEVSEL		;NO RH-11 BASE ADDRESS
	GO	EXEDXX		;SETUP INDIRECT POINTER TABLE
	MOVE	MSDRIVE
	MOVEM	MTDRIVE		;SETUP DRIVE
	MOVE	MSSLAVE
	ANDI	7
	MOVEM	MTSLAVE		;SETUP SLAVE
	MOVE	MSSLAVE
	ANDI	177770
	MOVEM	MTDENSITY	;SETUP DENSITY
	JRST	RH11DX		;DO REST
;*MSRSET, MAGTAPE RESET & SELECTION

MSRSET:	MOVEI	T1,MTCLR
	WRIO	T1,@MTCS2	;CLEAR MAGTAPE

	MOVE	T1,MTDRIVE
	WRIO	T1,@MTCS2	;SELECT DRIVE

	RDIO	T1,@MTCS1	;IS DRIVE AVAILABLE
	TRNN	T1,MTDVA
	 JRST	RSET1		;NO

	MOVE	T1,MTSLAVE	;GET SLAVE NUMBER
	OR	T1,MTDENSITY	;SET DENSITY
	OR	T1,MTFORMAT	;SET FORMAT
	WRIO	T1,@MTTC	;SELECT DRIVE

	RDIO	T1,@MTDS	;READ DRIVE STATUS
	TRNE	T1,MTATA!MTERR
	 JRST	RSET2		;ERROR IN DRIVE

	TRC	T1,MTMOL!MTDPR!MTDRY
	TRCE	T1,MTMOL!MTDPR!MTDRY
	 JRST	RSET3		;ERROR IN DRIVE

	RDIO	T1,@MTDT	;READ DRIVE TYPE
	TRNN	T1,040000
	 JRST	RSET4		;NOT A TU16/TU45 MAGTAPE

	SETZ	T1,
	WRIO	T1,@MTFC	;CLEAR FRAME COUNTER

	JRST	CPOPJ1		;OK, SKIP RETURN
MSREAD:	MOVEI	T4,MT.RF	;MAGTAPE READ

	PUT	P2
	MOVEI	P2,RETRY	;RETRY COUNTER

MSRTRY:	GO	MSRSET		;RESET THE RH11
	 GO	ERR14		;DRIVE NOT THERE

	MOVEI	T1,RBUF		;SET BUFFER ADDRESS
	PUT	T1
	LSH	T1,-^D9
$MSUVB:	IORI	T1,UNVBIT
	WRIO	T1,@UNBMP0	;SET UNIBUS MAP

	GET	T1
	ANDI	T1,777
	LSH	T1,2		;CHANGE PAGE ADDRESS TO -11 ADR
	WRIO	T1,@MTBA	;SET UNIBUS ADDRESS

	MOVNI	T1,MTPGSZ
	WRIO	T1,@MTWC	;SET TRANSFER SIZE

	GO	DOIO		;DO I/O
	JUMPE	T1,EOFXIT	;END-OF-FILE
	JUMPG	T1,RWSXIT	;IF NO ERRORS, SUCCESS
	SOJG	P2,MSRTRX	;ERROR, GO RETRY
	JRST	RWFXIT		;FAILED

RWSXIT:	RDIO	T1,@MTBA	;GET COMPLETION ADDRESS
	ANDI	T1,7777
	ADDI	T1,2		;ROUND UP
	LSH	T1,-2		;CONVERT TO -10 ADDRESS
	MOVEM	T1,LDBUF+2	;USE FOR WORD COUNT
	MOVEI	T1,LDBF+2
	HRRM	T1,LDBUF+1	;SETUP BUFFER START ADDRESS

	AOS	-1(P)		;SKIP RETURN

RWFXIT:	CONI	PAG,P2		;FLUSH CACHE IF ON
	CONO	PAG,(P2)
	GET	P2
	RTN

EOFXIT:	SETZM	MAGONCE		;EOF, SET TAPE AT START OF FILE
	JRST	RWFXIT		;NON-SKIP RETURN
MSRTRX:	GO	MSRSET		;RESET
	 GO	ERR14

	MOVNI	T1,1
	WRIO	T1,@MTFC	;SET FRAME COUNT TO -1

	MOVEI	T1,MT.SR
	WRIO	T1,@MTCS1	;BACKSPACE THE TAPE

	GO	MSRDY		;WAIT TILL READY
	 GO	ERR11		;ERROR

	JRST	MSRTRY		;NOW TRY AGAIN

MSRDY:	RDIO	T1,@MTDS	;READ STATUS

	TRNN	T1,MTPIP	;LOOK FOR DRIVE READY
	TRNN	T1,MTDRY	; & POSITIONING NOT IN PROGRESS
	JRST	MSRDY

	TRNN	T1,MTERR	;ANY ERRORS ?
	AOS	(P)		;NO, SKIP RETURN
	RTN
						SALL
RSET1:	PMSG	<?NOT AVAIL>
	RTN
RSET2:	PMSG	<?ERROR IN DRIVE>
	RTN
RSET3:	PMSG	<?MOL ERROR>
	RTN
RSET4:	PMSG	<?NOT A TAPE>
	RTN
						LALL
;*DOIO, PERFORM MAGTAPE OPERATION

DOIO:	WRIO	T4,@MTCS1	;DO COMMAND

;*WAIT, WAIT FOR COMPLETION OR ERROR

WAIT:	MOVSI	T1,2		;SET DELAY COUNT

	MOVEI	T2,MTTRE!MTMCPE!MTRDY
	TION	T2,@MTCS1	;WAIT
	SOJG	T1,WAIT+1
	JUMPLE	T1,WAITF	;TIMEOUT RETURN

	RDIO	T2,@MTDS	;READ DRIVE STATUS
	TRNE	T2,MTTM		;TAPE MARK ? (EOF)
	JRST	WEOF		;YES, GIVE END-OF-FILE RETURN

	RDIO	T2,@MTER	;READ ERROR REGISTER
	TRNE	T2,177777-MTFCE
	JRST	WAITF		;ERROR OTHER THAN LENGTH ERROR
	RTN			;OK

WEOF:	SETZ	T1,		;EOF, SET T1=0 AS FLAG
	RTN

WAITF:	SETO	T1,		;ERROR, SET T1=-1 AS FLAG
	RTN
MSREVS:	GO	MSRSET		;RESET ERROR STATUS
	 GO	ERR14

	MOVEI	T1,MT.SR
	WRIO	T1,@MTCS1	;BACKSPACE THE TAPE

	GO	MSRDY		;WAIT TILL DONE
	JFCL
	TRNE	T1,MTTM		;IS TAPE MARK SET ?
	RTN			;YES, OK

	MOVEI	-1		;NO, SET POSITION UNKNOWN
	MOVEM	MAGONCE
	JRST	DIAGLD		;REWIND AND START OVER

MSFORW:	GO	MSRSET		;RESET ERROR STATUS
	 GO	ERR14

	MOVEI	T1,MT.SF
	WRIO	T1,@MTCS1	;FORWARD SPACE THE TAPE

	GO	MSRDY		;WAIT TILL DONE
	JFCL
	TRNN	T1,MTTM		;SKIP IF TAPE MARK SET
	GO	ERR12		;ERROR
	RTN

MSREW:	GO	MSRSET		;RESET ERROR STATUS
	 GO	ERR14

	MOVEI	T1,MT.RW
	WRIO	T1,@MTCS1	;REWIND

	GO	MSRDY		;WAIT TILL DONE
	JFCL
	SETZM	CURR		;MARK CURRENT FILE AT 0
	RTN
;*MT11CH, CHANNEL TABLE FOR MAGTAPE

MTCS1:	0			;STATUS 1
MTWC:	0			;WORD COUNT
MTBA:	0			;BUS ADDRESS
MTFC:	0			;FRAME COUNT
MTCS2:	0			;STATUS 2
MTDS:	0			;DRIVE STATUS
MTER:	0			;ERROR
MTAS:	0			;ATTENTION SUMMARY
MTCC:	0			;CHARACTER CHECK
MTDB:	0			;DATA BUFFER
MTMR:	0			;MAINTENANCE REG
MTDT:	0			;DRIVE TYPE
MTSN:	0			;SERIAL NUMBER
MTTC:	0			;TAPE CONTROL
UNBMP0:	0			;UNIBUS MAP ADDRESS
;*SMMON, SMMAG, SMAPT - LOAD DIAGNOSTIC MONITOR'S

SMMON:	MOVEI	IP,[SIXBIT/SMMON/
		    0]
	JRST	SMAPT+1

SMMAG:	MOVEI	IP,[SIXBIT/SMMAG/
		    0]
	JRST	SMAPT+1

SMAPT:	MOVEI	IP,[SIXBIT/SMAPT/
		    0]

	SETOM	LDDMON
	GO	DIAGLD-2
	JRST	SELX1
	HALT	.

CLRCR2:	SETZM	30000
	MOVE	[30000,,30001]
	BLT	37777
	RTN

STARTM:	SETZM	MSRH		;NO AUTO SELECT
	HRRZ	W,W
	MOVE	[30000,,20000]	;TRANSFER DIAG MON
	MOVE	1,[BLT	27767]	;TO CORRECT PLACE
	MOVE	2,[JRST	@W]	;START IT
	JRST	1

LDTEN3:	CAIGE	13,1000		;LOAD 0 TO 777 DIRECT
	JRST	LDTEN2
	CAIGE	13,20000
	GO	LDTEN4		;BAD DIAG MON ADDRESS
	ADDI	13,10000	;OFFSET LOAD
	JRST	LDTEN2

LDTEN4:	MOVE	A,[SIXBIT/BADADR/]
	JRST	ERROR

RFILL4:	HRRZ	0,M
	CAIGE	0,777		;LOAD 0 TO 777 DIRECT
	JRST	RFILL2
	CAIGE	0,17777
	GO	LDTEN4		;BAD DIAG MON ADDRESS
	ADDI	M,10000		;OFFSET LOAD
	JRST	RFILL2
;*ERROR - ERROR REPORTING

ERROR:	PUSH	P,1
	GO	CRLF1
	MOVEI	"?"
	GO	PRINT
	POP	P,1
	GO	SIXBP
	PMSG	< ERROR AT >
	GET	0
	SOS
	GO	PNTOCT		;PRINT PC OF ERROR
	MOVEI	" "
	GO	PRINT
	GO	NAMPNT
	MOVEI	-1		;SET MAGTAPE FLAG TO NOTE
	MOVEM	MAGONCE		;MAGTAPE POSITION IS UNKNOWN
	SKIPN	ONCE		;INITIAL LOAD ERROR ?
	JRST	SELX1		;YES
	SKIPE	PGMGO
	JRST	SELECT
	JRST	RUN

;*NFERR1 - PROGRAM NOT FOUND ERROR

NFERR1:	PMSG	<^?PROGRAM NOT FOUND - >
	GO	NAMPNT
	RTN
SUBTTL	ERROR REPORTER

;*ERROR REPORT MESSAGES

ERR2:
LERR2:	MOVE	A,[SIXBIT/ILLEOF/]
	JRST	ERROR
LERR3:	MOVE	A,[SIXBIT/FLTYPE/]
	JRST	ERROR
LERR4:	MOVE	A,[SIXBIT/FORMAT/]
	JRST	ERROR
LERR5:	MOVE	A,[SIXBIT/CKSUM/]
	JRST	ERROR

ERR6:	MOVE	A,[SIXBIT/1STPTR/]
	JRST	ERROR
ERR7:	MOVE	A,[SIXBIT/STADR/]
	JRST	ERROR
ERR8:	MOVE	A,[SIXBIT/OPEN/]
	JRST	ERROR
ERR9:	MOVE	A,[SIXBIT/READ/]
	JRST	ERROR
ERR10:	MOVE	A,[SIXBIT/CORE/]
	JRST	ERROR
ERR11:	MOVE	A,[SIXBIT/BKSPAC/]
	JRST	ERROR
ERR12:	MOVE	A,[SIXBIT/SKPFIL/]
	JRST	ERROR
ERR13:	MOVE	A,[SIXBIT/DIR RD/]
	JRST	ERROR
ERR14:	MOVE	A,[SIXBIT/DEVICE/]
	JRST	ERROR
ERR15:	MOVE	A,[SIXBIT/DENSET/]
	JRST	ERROR
SUBTTL	STORAGE ASSIGNMENTS
	LIT
	VAR
PGNAME:	SIXBIT /SMMAG/		;PROGRAM NAME
PLIST:	BLOCK	40		;PUSH LIST

PGMGO:	0			;LOAD & GO FLAG
TAPEPF:	0			;PRINT TAPE FLAG
DEVFLG:	0			;CMD LIST FROM DEVICE FLAG
DINFLG:	0			;DEVICE IN FLAG
LPTFLG:	0			;LINE PRINTER FLAG
LSTFLG:	0			;LISTING FLAG
DIRFLG:0			;DIRECTORY FLAG
ALTMFLG:0			;ALTMODE FLAG
CLKFLG:	0
USRFLG:	0
LDDMON:	0			;LOAD DIAG MONITOR
CNSFLG:	0
MGNONC:	0
MGNCNT:	0
MGNWRD:	0
MGNADR:	0
RACKF:	0

SCFLAG:	0			;PROCESSING COMMENT FLAG
SAVEIP:	0			;COMMAND LIST POINTER SAVE
RUNCTL:	0			;RUN CONTROL
CHRCTR:	0			;PRINT CHAR COUNTER
SAVAC0:	0			;AC SAVE
SAVAC1:	0			; "
FCRCNT:	0			;CR FILLER COUNT
FLFCNT:	0			;LF FILLER COUNT

READBL:	0			;DISPATCH TO READ A DATA RECORD FROM TAPE
REVERS:	0			;	"	MOVE TAPE REVERSE OVER FILE
FORWRD:	0			;	"	MOVE TAPE FORWARD OVER FILE
REW:	0			;	"	REWIND TAPE

TAPEDN:	2001			;TAPOP. CODE TO SET DENSITY
	LDCHN			;MAGTAPE CHANNEL NUMBER
TAPEDC:	4			;3 = 800 BPI, 4 = 1600 BPI
SELSTR:				;COMMAND SELECTION STORE
LDCNT:	0			;A10 LOAD COUNT
LDADR:	0			;A10 LOAD ADDRESS
LDATA:	BLOCK ^D34-16		;A10 DATA STORAGE
ACSAVE:	BLOCK	16
LDATAE:	0			;A10 END OF DATA STORAGE
	0

LDNAME:	SIXBIT/NAME/
	SIXBIT/EXT/
	0
	0

LDBLK:	13
	SIXBIT/DSK/
	LDBUF
LDBUF:	BLOCK	3

D$DIR:	BLOCK	8		;DIR NAME STRING STORAGE
D$FIL:	BLOCK	8		;FILE NAME      "
D$EXT:	BLOCK	8		;EXT		"
D$VER:	BLOCK	2		;VERSION	"
D$ISTR:	BLOCK	^D20		;INPUT		"

	LOC	25000-3
LDBF:	0
	201,,LDBF1+1
	0
RBUF:	BLOCK	200

LDBF1:	0
	201,,LDBF2+1
	0
	BLOCK	200

LDBF2:	0
	201,,LDBF+1
	0
	BLOCK	200

TAB=RBUF+MAGRCD
	LOC	TAB
	BLOCK	MAGRCD
	0

INLIST:	
SUBTTL	SPECIAL STARTUP MESSAGES AND INITIALIZATION

;*HEADER

DEFINE	PTITLE	(MCNVER,DECVER)	<
	ASCIZ	%
* SMMAG [DSQDE] - DECSYSTEM 2020 DIAGNOSTIC MAGTAPE MONITOR - VER MCNVER'.'DECVER *
%>

HEADER:	PTITLE	\MCNVER,\DECVER
;*HELP

HELP:	ASCIZ	%
NORMAL START = 20000
RESTART/ABORT = 20001
PRINT TEST TITLE = 20002
RESTART CURR TEST = 20003

DEVICES:  EXEC MODE;
  0 = UBA 3, RH ADR 772440
  1 = UBA 1, RH ADR 772440
  2 = UBA 2, RH ADR 772440
  3 = UBA 3, RH ADR 772440
ALL DEVICES THEN ASK FOR DRIVE & SLAVE ##
  A TWO DIGIT NUMBER IS USED (FIRST DIGIT SPECIFIES
  DRIVE # OF TM02, SECOND DIGIT SPECIFIES SLAVE # OF TRANSPORT)

DEVICES:  USER MODE;
MAGTAPE = PHYSICAL NAME OF UNIT   (EX. MTA0)
DISK = ONLY A CARRIAGE RETURN

COMMANDS;
STD=START DIAGNOSTIC
STM=REINITIALIZE START
STL=START LOADER
START=START DIAGNOSTIC
SFSTRT=SPECIAL FEATURE START
PFSTRT=POWER FAIL START
REE=REENTER
DDT=DDT
START1=SPECIAL START 1
START2=SPECIAL START 2
START3=SPECIAL START 3
START4=SPECIAL START 4
START5=SPECIAL START 5
SMMON=LOAD SMMON
SMMAG=LOAD SMMAG
SMAPT=LOAD SMAPT

R=RESELECT, X=XPN, I=INTERNAL, T=TTY, D=DEVICE,
S=SINGLE, F=DIR, L=LIST, G=GO
%

	END	JRST	ONETIM
