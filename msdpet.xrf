   1	%TITLE 'STIRS TESTS FOR M8620 (DPE) BOARD'
   2	
   3	MODULE MSDPET	(
   4			LANGUAGE(BLISS36)
   5			) =
   6	
   7	BEGIN
   8	
   9	!
  10	!			  COPYRIGHT (C) 1979 BY
  11	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.  
  12	!
  13	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
  14	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
  15	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY OTHER
  16	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
  17	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS HEREBY
  18	! TRANSFERRED.
  19	!
  20	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
  21	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
  22	! CORPORATION.
  23	!
  24	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
  25	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
  26	!
  27	
  28	!++
  29	! FACILITY:	DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
  30	!
  31	! ABSTRACT:
  32	!
  33	!	THIS MODULE CONTAIN THE TEST ROUTINES FOR THE KS10 STIMULUS/RESPONSE
  34	!	(STIRS) DIAGNOSTIC FOR THE M8620 (DPE) BOARD.  IT ALSO CONTAINS SEVERAL
  35	!	SUPPORTING SUBROUTINES.  THE TEST ROUTINES ARE EXECUTED UNDER CONTROL
  36	!	OF THE 'MSSTRC' MODULE.  THIS MODULE IS LINKED WITH THE 'MSSTRC' AND
  37	!	'MSDPED' MODULES TO PRODUCE THE 'MSDPE.EXE' FILE.
  38	!
  39	! ENVIRONMENT: 	RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
  40	!
  41	! AUTHOR: JEAN BASMAJI	, CREATION DATE: 23-MAY-79
  42	!
  43	! MODIFIED BY:
  44	!
  45	!	JEAN BASMAJI, 23-MAY-79; VERSION 0.1
  46	!--
  47	
  48	
  49	!  PROGRAM DESCRIPTION:
  50	!
  51	!
  52	!		MSDPE PROGRAM IS DESIGNED TO DETECT AND ISOLATE ANY
  53	!	FAULTS ON THE KS10'S M8620 BOARD (DPE).THIS PROGRAM IS LINKED
  54	!	WITH 'MSSTRC' CONTROL MODULE.  IT WILL RUN UNDER 'CSL'
  55	!	PROGRAM WHICH IN TURN IS RUNNING ON A TOPS20 HOST MACHINE.
  56	!	THIS PROGRAM ASSUMES THAT ALL PARTS OF THE KS10 ARE KNOWN 
  57	!	GOOD PARTS EXCEPT THE 'DPE' BOARD UNDER TEST.(FOR DETAILS 
  58	!	SEE DOCUMENTATION ON MSSTRC MODULE).
  59	!		 EACH TEST IN THIS PROGRAM WILL LOAD ITS OWN MICRO
  60	!	INSTRUCTIONS DESIGNED TO DETECT ANY ERROR IN THE LOGIC INVOLVED.
  61	!		THE MAJOR PARTS OF THIS PROGRAM WILL TEST ALL 10
  62	!	SLICES OF THE 2901'S INCLUDING THE SHIFT LOGIC, PI SYSTEM, P.C.
  63	!	FLAGS, RAMFILE (INCLUDING RAMFILE PARITY AND RAMFILE ADRS) AND
  64	!	DROM LOGIC.
  65	!		THE FAULT ISOLATION ANALYSIS DONE IN MSSTRC MODULE WILL
  66	!	INHIBIT RUNNING SOME TESTS, ALSO THIS MODULE WILL INHIBIT 
  67	!	RUNNING OTHER TESTS BY MANIPULATING ITS OWN FLAGS AS FOLLOWS:
  68	!	A)  SWITCH SETTING FLAGS:
  69	!		THIS MODULE WILL ASK FOR 2 SWITCH SETTINGS WHICH CONTROL
  70	!		DROM CONTENTS, RAMFILE AND RAMFILE PARITY TESTS.
  71	!		THOSE TESTS ARE INHIBITED AS A DEFAULT. THEY WILL BE RUN
  72	!		IF SPECIFIED TO DO SO DURING SWITCH SETTING.
  73	!		THOSE TESTS ARE INHIBITED BECAUSE THEY ARE TIME 
  74	!		CONSUMING. DROM CONTENTS (8 TESTS) APPRX. 10 MIN, AND
  75	!		THE RAMFILE TESTS (2 TESTS) APPRX. 15 MIN.
  76	!	B)  OTHER TEST FLAGS:
  77	!		THOSE FLAGS (DECLARED IN THIS MODULE AS OWN) WILL DIRECT
  78	!		THE ERROR ANALYSIS AS WELL AS SKIPPING SOME TESTS.
  79	!		EXAMPLE:
  80	!			IF RAMFILE ADRS OUTPUT PINS TESTS FAIL, 'ADRSFLG'
  81	!		FLAG IS SET TO INHIBIT RUNNING ALL SUBSEQUENT 
  82	!		RAMFILE ADRS TESTS SINCE OTHER FAILING RAMFLE ADRS TESTS 
  83	!		WILL NOT HELP US ANY MORE IN ISOLATING THE FAULT.
  84	!			'PIACTV_FLG' FLAG IS SET IN CERTAIN TESTS 
  85	!		IF AN ERROR OCCURS AND CHECKED LATER DURING THIS PROGRAM,
  86	!		IF CLEAR THE PROGRAM WILL CALL A 'NO ERROR' ROUTINE
  87	!		TO ELIMINATE THE PI ACTIVE LOGIC NETWORK FROM THE
  88	!		CUMULATIVE FAULTY NETWORK BITVECTOR.
  89	!
  90	!
  91	! TABLE OF CONTENTS:
  92	!
  93	
  94	FORWARD ROUTINE
  95		SPEC_DIALOGUE : NOVALUE,		!SPECIAL USER I/O (NOT USED)
  96		SPEC_ASK : NOVALUE,			!ASK FOR SPECIAL QUESTIONS
  97		SPEC_PRT,				!PRINT THE SPECIAL SPECS (SWITCHES)
  98		TEST_INIT : NOVALUE,			!INITIAL TESTING INITIALIZATION
  99		FUNC_LD : NOVALUE,			!LOADS THE CRAM WITH INSTRUCTIONS TO BE EXECUTED BY ALU FUNC TESTS
 100		VMA_LD : NOVALUE,			!CHECKS AND LOADES THE VMA WITH A 0
 101		TST1 : NOVALUE,				!DIAGNOSTIC ADDRESS DISPATCH
 102		TST2 : NOVALUE,				!OUTPUT ZERO FROM 2901'S
 103		TST3 : NOVALUE,				!LOAD THA VMA WITH A ZERO AND MEM WRITE
 104		TST4 : NOVALUE,				!ALU DEST 0,1,2 & 3
 105		TST5 : NOVALUE,				!WRITE ONES AND ZEROS TO ALU REGISTERS (36 BITS)
 106		TST6 : NOVALUE,				!CHECK THE B PORT IN THE 2901'S (36 BITS)
 107		TST7 : NOVALUE,				!CHECK Q REGISTER IN 2901'S (36 BITS)
 108		TST8 : NOVALUE,				!ALU RAM SHIFTER (36 BITS)
 109		TST9 : NOVALUE,				!CHECK THE 2 LSB OF THE ALU AND THE ALU REGISTERS
 110		TST10 : NOVALUE,			!CHECK THE 2 MSB OF THE ALU AND THE ALU REGISTERS
 111		TST11 : NOVALUE,			!Q SHIFTER (36 BITS)
 112		TST12 : NOVALUE,			!2 LSB OF THE Q REGISTER
 113		TST13 : NOVALUE,			!2 MSB OF THE Q REGISTER
 114		TST14 : NOVALUE,			!CHECK THE ALU (R OR S) FUNCTION
 115		TST15 : NOVALUE,			!CHECK THE ALU (R + S) FUNCTION
 116		TST16 : NOVALUE,			!CHECK THE ALU (S - R) FUNCTION
 117		TST17 : NOVALUE,			!CHECK THE ALU (R - S) FUNCTION
 118		TST18 : NOVALUE,			!CHECK THE ALU (R AND S) FUNCTION
 119		TST19 : NOVALUE,			!CHECK THE ALU (RNOT AND S) FUNCTION
 120		TST20 : NOVALUE,			!CHECK THE ALU (R XOR S) FUNCTION
 121		TST21 : NOVALUE,			!CHECK THE ALU (R XNOR S) FUNCTION
 122		TST22 : NOVALUE,			!CHECKS DP CRY1
 123		TST23 : NOVALUE,			!SKIP ON THE OUTPUT OF THE 2901'S
 124		TST24 : NOVALUE,			!DP CLKS
 125		TST25 : NOVALUE,			!LEFT SHIFT LOGIC ON DPE1
 126		TST26 : NOVALUE,			!RIGHT SHIFT LOGIC ON DPE1
 127		TST27 : NOVALUE,			!INHIBIT CRY INTO LEFT HALF
 128		TST28 : NOVALUE,			!SKIP ON ADL=0 & ADR=0
 129		TST29 : NOVALUE,			!CHECK ALL THE BYTE DISPATCH LOGIC
 130		TST30 : NOVALUE,			!DBUS SELECT 0 GROUNDED PINS
 131		TST31 : NOVALUE,			!DBUS SELECT 1
 132		TST32 : NOVALUE,			!10 BIT VMA COPY
 133		TST33 : NOVALUE,			!PART OF THE DISP MIX'S
 134		TST34 : NOVALUE,			!CHECK THE PI REQ LEVEL
 135		TST35 : NOVALUE,			!PI PRIORITY ENCODER, PI SOFT REQ.
 136		TST36 : NOVALUE,			!PI ACTIVE AND PI REQ
 137		TST37 : NOVALUE,			!PI ACTV AND 4 BIT TRNCVR LATCH ON DPEB
 138		TST38 : NOVALUE,			!PI COMPARE THEN INTERRUPT
 139		TST39 : NOVALUE,			!P.C. FLAGS
 140		TST40 : NOVALUE,			!JFCL LOGIC ON DPE9
 141		TST41 : NOVALUE,			!FPD,TRAP2 AND CRY FLAGS
 142		TST42 : NOVALUE,			!OV,TRAP1,FOV AND NO DIV FLAGS
 143		TST43 : NOVALUE,			!FXU,OV AND TRAP1 FLAGS
 144		TST44 : NOVALUE,			!OV AND TRAP1 FLAGS
 145		TST45 : NOVALUE,			!USER I/O FLAG
 146		TST46 : NOVALUE,			!TRAP DECODER ON DPE9
 147		TST47 : NOVALUE,			!INSTRUCTION REGISTER FF
 148		TST48 : NOVALUE,			!FPD,USER AND USER I/O FLAGS
 149		TST49 : NOVALUE,			!DBUS PARITY IMPLEMENTATION LOGIC
 150		TST50 : NOVALUE,			!DP PARITY IMPLEMENT RAM
 151		TST51 : NOVALUE,			!RAMFILE
 152		TST52 : NOVALUE,			!RAMFILE PARITY CHIPS
 153		TST53 : NOVALUE,			!RAMFILE ADRS OUTPUT PINS S1
 154		TST54 : NOVALUE,			!RAMFILE ADRS OUTPUT PINS S0
 155		TST55 : NOVALUE,			!RAMFILE ADRS SELECT 0
 156		TST56 : NOVALUE,			!RAMFILE ADRS SELECT 2
 157		TST57 : NOVALUE,			!RAMFILE ADRS SELECT 4
 158		TST58 : NOVALUE,			!RAMFILE ADRS SELECT 7 (VMA AC REF HI)
 159		TST59 : NOVALUE,			!RAMFILE ADRS SELECT 7 (VMA AC REF LO)
 160		TST60 : NOVALUE,			!RAMFILE ADRS SELECT 1
 161		TST61 : NOVALUE,			!SWEP CASH TO LOAD THE VMA
 162		TST62 : NOVALUE,			!RAMFILE WRITE ENABLE
 163		TST63 : NOVALUE,			!DROM ADDRESS INPUT PINS ZEROS
 164		TST64 : NOVALUE,			!DROM ADDRESS INPUT PINS ONES
 165		TST65 : NOVALUE,			!OUTPUT PINS OF DROM (A,B,J,AC DISP AND A=J)
 166		TST66 : NOVALUE,			!OUTPUT PINS OF DROM (A,B,J,AC DISP AND A=J)
 167		TST67 : NOVALUE,			!OUPUT PINS OF DROM (VMA EN)
 168		TST68 : NOVALUE,			!OUPUT PINS OF DROM (COND FUNC,READ AND WRT TEST)
 169		TST69 : NOVALUE,			!CONTENTS OF ALL DROM (ACDISP BIT AND J FIELD)
 170		TST70 : NOVALUE,			!CONTENTS OF ALL DROM (A=J BIT AND J FIELD)
 171		TST71 : NOVALUE,			!CONTENTS OF ALL DROM (TXXX BIT)
 172		TST72 : NOVALUE,			!CONTENTS OF ALL DROM (VMA EN BIT)
 173		TST73 : NOVALUE,			!CONTENTS OF ALL DROM (WRT TEST & READ BITS)
 174		TST74 : NOVALUE,			!CONTENTS OF ALL DROM (COND FUNC BIT)
 175		TST75 : NOVALUE,			!CONTENTS OF ALL DROM (DROM A)
 176		TST76 : NOVALUE;			!CONTENTS OF ALL DROM (DROM B)
 177	
 178	!
 179	! INCLUDE FILES:
 180	!
 181	
 182	REQUIRE 'REGBIT.R36';				!8080 I/O REGISTER BIT DEFINITIONS
 183	
 184	!
 185	!			  COPYRIGHT (c) 1977, 1978 BY
 186	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 187	!
 188	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 189	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 190	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 191	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 192	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 193	! TRANSFERRED.
 194	!
 195	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 196	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 197	! CORPORATION.
 198	!
 199	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 200	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 201	!
 202	
 203	!++
 204	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 205	!
 206	! ABSTRACT:
 207	!
 208	!	THIS FILE CONTAINS SYMBOLIC BIT DEFINITIONS FOR THE KS10 8080 I/O
 209	!	REGISTERS.  IT IS USED AS A 'REQUIRE' FILE FOR THE STIRS DIAGNOSTICS.
 210	!
 211	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 212	!
 213	! AUTHOR:  RICH MURATORI	, CREATION DATE:  3-JAN-79
 214	!
 215	! MODIFIED BY:
 216	!
 217	!  RICH MURATORI, 3-JAN-79 : VERSION 0.1
 218	!--
 219	
 220	LITERAL
 221	
 222	!WRITE REGISTER 100
 223	
 224		FORCE_PAR	= 1^1,		!FORCE PARITY RIGHT
 225		EN_1MS		= 1^2,		!1 MSEC ENABLE
 226		CACHE_ENB	= 1^3,		!CACHE ENABLE
 227		DP_PE_DET	= 1^4,		!DP PE DETECT
 228		CRM_PE_DET	= 1^5,		!CRM PE DETECT
 229		PE_DET_ENB	= 1^6,		!PE DETECT ENABLE
 230		RESET		= 1^7,		!RESET
 231	
 232	!WRITE REGISTER 102/103
 233	
 234		DATA35		= 1^0,		!KS10 BUS DATA BIT 35
 235		DATA34		= 1^1,		!KS10 BUS DATA BIT 34
 236		DATA33		= 1^2,		!KS10 BUS DATA BIT 33
 237		DATA32		= 1^3,		!KS10 BUS DATA BIT 32
 238		DATA31		= 1^4,		!KS10 BUS DATA BIT 31
 239		DATA30		= 1^5,		!KS10 BUS DATA BIT 30
 240		DATA29		= 1^6,		!KS10 BUS DATA BIT 29
 241		DATA28		= 1^7,		!KS10 BUS DATA BIT 28
 242	
 243	!WRITE REGISTER 104/105
 244	
 245		DATA27		= 1^0,		!KS10 BUS DATA BIT 27
 246		DATA26		= 1^1,		!KS10 BUS DATA BIT 26
 247		DATA25		= 1^2,		!KS10 BUS DATA BIT 25
 248		DATA24		= 1^3,		!KS10 BUS DATA BIT 24
 249		DATA23		= 1^4,		!KS10 BUS DATA BIT 23
 250		DATA22		= 1^5,		!KS10 BUS DATA BIT 22
 251		DATA21		= 1^6,		!KS10 BUS DATA BIT 21
 252		DATA20		= 1^7,		!KS10 BUS DATA BIT 20
 253	
 254	!WRITE REGISTER 106/107
 255	
 256		DATA19		= 1^0,		!KS10 BUS DATA BIT 19
 257		DATA18		= 1^1,		!KS10 BUS DATA BIT 18
 258		DATA17		= 1^2,		!KS10 BUS DATA BIT 17
 259		DATA16		= 1^3,		!KS10 BUS DATA BIT 16
 260		DATA15		= 1^4,		!KS10 BUS DATA BIT 15
 261		DATA14		= 1^5,		!KS10 BUS DATA BIT 14
 262		DATA13		= 1^6,		!KS10 BUS DATA BIT 13
 263		DATA12		= 1^7,		!KS10 BUS DATA BIT 12
 264	
 265	!WRITE REGISTER 110/111
 266	
 267		DATA11		= 1^0,		!KS10 BUS DATA BIT 11
 268		DATA10		= 1^1,		!KS10 BUS DATA BIT 10
 269		DATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 270		DATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 271		DATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 272		DATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 273		DATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 274		DATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 275	
 276	!WRITE REGISTER 112/113
 277	
 278		DATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 279		DATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 280		DATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 281		DATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 282	
 283	!WRITE REGISTER 114/115
 284	
 285		DATA_CYCLE	= 1^0,		!DATA CYCLE
 286		IO_DATA		= 1^1,		!I/O DATA CYCLE
 287		COM_ADR		= 1^2,		!COM/ADR CYCLE
 288		BAD_DATA	= 1^3,		!BAD DATA CYCLE
 289	
 290	!WRITE REGISTER 116
 291	
 292		CSL_INT		= 1^0,		!CSL INTERRUPT THE 10
 293	
 294	!WRITE REGISTER 204
 295	
 296		CRAM_RESET	= 1^0,		!CRAM RESET
 297		STK_RESET	= 1^1,		!STACK RESET
 298		DP_RESET	= 1^2,		!DP RESET
 299		SS_MODE		= 1^3,		!SINGLE STEP MODE
 300		CRAM_ADR_LD	= 1^4,		!CRAM ADR LOAD
 301		CRAM_WRT	= 1^5,		!CRAM WRITE
 302	
 303	!WRITE REGISTER 205
 304	
 305		DIAG1		= 1^0,		!DIAG FN BIT 1
 306		DIAG2		= 1^1,		!DIAG FN BIT 2
 307		DIAG4		= 1^2,		!DIAG FN BIT 4
 308		DIAG10		= 1^3,		!DIAG FN BIT 10
 309		TRAP_ENB	= 1^4,		!TRAP ENABLE
 310		CLR_INT		= 1^5,		!CLEAR 10 INTERRUPT
 311		MNT_CLK_ENB	= 1^6,		!MAINT CLK ENABLE
 312		MAINT_CLK	= 1^7,		!MAINT CLK PULSE
 313	
 314	!WRITE REGISTER 206
 315	
 316		CLK_RUN		= 1^0,		!CLOCK RUN
 317		SINGLE_CLK	= 1^1,		!SINGLE CLOCK
 318	
 319	!WRITE REGISTER 210
 320	
 321		CLOSE_LATCH	= 1^0,		!CLOSE LATCHS
 322		LATCH_DATA	= 1^1,		!LATCH DATA (1)
 323		CRA_R_CLK	= 1^2,		!CRA R CLK ENB (1)
 324		CRA_T_CLK	= 1^3,		!CRA T CLK ENB (1)
 325		XMIT_DATA	= 1^4,		!XMIT DATA (1)
 326		XMIT_ADR	= 1^5,		!XMIT ADR (1)
 327		BUS_REQ		= 1^6,		!BUS REQ
 328		MEM		= 1^7,		!MEM
 329	
 330	!WRITE REGISTER 212
 331	
 332		CONTINUE	= 1^0,		!CONTINUE
 333		EXECUTE		= 1^1,		!EXECUTE
 334		RUN		= 1^2,		!RUN
 335	
 336	
 337	
 338	!READ REGISTER 0
 339	
 340		RDATA35		= 1^0,		!KS10 BUS DATA BIT 35
 341		RDATA34		= 1^1,		!KS10 BUS DATA BIT 34
 342		RDATA33		= 1^2,		!KS10 BUS DATA BIT 33
 343		RDATA32		= 1^3,		!KS10 BUS DATA BIT 32
 344		RDATA31		= 1^4,		!KS10 BUS DATA BIT 31
 345		RDATA30		= 1^5,		!KS10 BUS DATA BIT 30
 346		RDATA29		= 1^6,		!KS10 BUS DATA BIT 29
 347		RDATA28		= 1^7,		!KS10 BUS DATA BIT 28
 348	
 349	!READ REGISTER 1
 350	
 351		RDATA27		= 1^0,		!KS10 BUS DATA BIT 27
 352		RDATA26		= 1^1,		!KS10 BUS DATA BIT 26
 353		RDATA25		= 1^2,		!KS10 BUS DATA BIT 25
 354		RDATA24		= 1^3,		!KS10 BUS DATA BIT 24
 355		RDATA23		= 1^4,		!KS10 BUS DATA BIT 23
 356		RDATA22		= 1^5,		!KS10 BUS DATA BIT 22
 357		RDATA21		= 1^6,		!KS10 BUS DATA BIT 21
 358		RDATA20		= 1^7,		!KS10 BUS DATA BIT 20
 359	
 360	!READ REGISTER 2
 361	
 362		RDATA19		= 1^0,		!KS10 BUS DATA BIT 19
 363		RDATA18		= 1^1,		!KS10 BUS DATA BIT 18
 364		RDATA17		= 1^2,		!KS10 BUS DATA BIT 17
 365		RDATA16		= 1^3,		!KS10 BUS DATA BIT 16
 366		RDATA15		= 1^4,		!KS10 BUS DATA BIT 15
 367		RDATA14		= 1^5,		!KS10 BUS DATA BIT 14
 368		RDATA13		= 1^6,		!KS10 BUS DATA BIT 13
 369		RDATA12		= 1^7,		!KS10 BUS DATA BIT 12
 370	
 371	!READ REGISTER 3
 372	
 373		RDATA11		= 1^0,		!KS10 BUS DATA BIT 11
 374		RDATA10		= 1^1,		!KS10 BUS DATA BIT 10
 375		RDATA9		= 1^2,		!KS10 BUS DATA BIT 9 
 376		RDATA8		= 1^3,		!KS10 BUS DATA BIT 8 
 377		RDATA7		= 1^4,		!KS10 BUS DATA BIT 7 
 378		RDATA6		= 1^5,		!KS10 BUS DATA BIT 6 
 379		RDATA5		= 1^6,		!KS10 BUS DATA BIT 5 
 380		RDATA4		= 1^7,		!KS10 BUS DATA BIT 4 
 381	
 382	!READ REGISTER 100
 383	
 384		ADPT2_PE	= 1^0,		!UNIBUS ADAPTER 2 PARITY ERR
 385		CRA_PE		= 1^1,		!CRA PARITY ERR
 386		DP_PE		= 1^2,		!DP PARITY ERR
 387		MEM_PE		= 1^3,		!MEM PARITY ERR
 388		CRAM_PE		= 1^4,		!CRAM PARITY ERR
 389		ADPT3_PE	= 1^6,		!UNIBUS ADAPTER 3 PARITY ERR
 390		REC_PE		= 1^7,		!RECEIVED PARITY ERR
 391	
 392	!READ REGISTER 101
 393	
 394		MMC_REF_ERR	= 1^0,		!MEM REFRESH ERR
 395		PI_REQ_7	= 1^1,		!PI REQ 7
 396		PI_REQ_6	= 1^2,		!PI REQ 6
 397		PI_REQ_5	= 1^3,		!PI REQ 5
 398		PI_REQ_4	= 1^4,		!PI REQ 4
 399		PI_REQ_3	= 1^5,		!PI REQ 3
 400		PI_REQ_2	= 1^6,		!PI REQ 2
 401		PI_REQ_1	= 1^7,		!PI REQ 1
 402	
 403	!READ REGISTER 102
 404	
 405		RDATA		= 1^0,		!DATA CYCLE
 406		RIO_DATA	= 1^1,		!I/O DATA CYCLE
 407		RCOM_ADR	= 1^2,		!COM/ADR CYCLE
 408		RBAD_DATA	= 1^3,		!BAD DATA CYCLE
 409		RIO_BUSY	= 1^4,		!I/O BUSY
 410		RMEM_BUSY	= 1^5,		!MEM BUSY
 411		RRESET		= 1^6,		!RESET
 412		RAC_LO		= 1^7,		!AC LO
 413	
 414	!READ REGISTER 103
 415	
 416		RDATA3		= 1^0,		!KS10 BUS DATA BIT 3 
 417		RDATA2		= 1^1,		!KS10 BUS DATA BIT 2 
 418		RDATA1		= 1^2,		!KS10 BUS DATA BIT 1 
 419		RDATA0		= 1^3,		!KS10 BUS DATA BIT 0 
 420		PAR_LEFT	= 1^4,		!PARITY LEFT
 421		PAR_RIGHT	= 1^5,		!PARITY RIGHT
 422		ADPT4_PE	= 1^6,		!UNIBUS ADAPTER 4 PARITY ERR
 423		ADPT1_PE	= 1^7,		!UNIBUS ADAPTER 1 PARITY ERR
 424	
 425	!READ REGISTER 300
 426	
 427		CONTINUE_H	= 1^0,		!CONTINUE
 428		EXECUTE_B	= 1^1,		!EXECUTE
 429		RUN_1		= 1^2,		!RUN
 430		HALT_LOOP	= 1^3,		!DPM HALT LOOP
 431		KLINIK_LEN	= 1^4,		!KLINIK LENGTH (SW)
 432		KLINIK_BIT	= 1^5,		!KLINIK BIT # (SW)
 433		CTY_CHAR_LEN	= 1^6,		!CTY CHARACTER LENGTH (SW)
 434		CTY_BIT		= 1^7,		!CTY BIT # (SW)
 435	
 436	!READ REGISTER 301
 437	
 438		DATA_ACK	= 1^0,		!DATA ACK
 439		BOOT		= 1^1,		!BOOT (SW)
 440		CONS_ENB	= 1^2,		!CONSOLE ENABLE (SW)
 441		PE_1		= 1^3,		!PE(1)
 442		BUSREQ		= 1^4,		!BUS REQUEST
 443		NEXM		= 1^6,		!NEXM
 444		TEN_INT		= 1^7,		!10 INTERRUPT
 445	
 446	!READ REGISTER 302
 447	
 448		KLINIK_CARR	= 1^0,		!KLINIK CARRIER
 449		TERM_CARR	= 1^1,		!TERMINAL CARRIER
 450		REM_DIAG_ENB	= 1^2,		!REMOTE DIAG ENB
 451		REM_DIAG_PRO	= 1^3,		!REMOTE DIAG PROT
 452	
 453	!READ REGISTER 303
 454	
 455		RAM_ERR		= 1^0,		!RAM ERROR
 456		DP_CLK_ENBL	= 1^1,		!DPE/M CLK ENABLE
 457		CR_CLK_ENB	= 1^2,		!CRA/M CLK ENABLE
 458		R_CLK_ENB0	= 1^3;		!R CLK ENB (0) H
 459	
 460	! END OF 'REGBIT.R36'
 461	REQUIRE 'KSU.R36';				!KS10 MICROCODE MACROS
 462	
 463	!
 464	!			  COPYRIGHT (c) 1977, 1978 BY
 465	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 466	!
 467	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 468	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
 469	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
 470	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
 471	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
 472	! TRANSFERRED.
 473	!
 474	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
 475	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
 476	! CORPORATION.
 477	!
 478	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
 479	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
 480	!
 481	
 482	
 483	!++
 484	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
 485	!
 486	! ABSTRACT:
 487	!
 488	!	 THESE MACROS ALLOW YOU TO WRITE MICROINSTRUCTIONS IN A SYMBOLIC FORM
 489	!	 (DIFFERENT THAN THE NORMAL MICRO CROSS ASSEMBLER) FOR USE AS LITERAL
 490	!	 VALUES WITHIN A BLISS-36 PROGRAM.   MACROS ARE NECESSARY (AS OPPOSED
 491	!	 TO ARITHMETIC EXPRESSIONS) TO HANDLE SOME FIELDS' DEFAULT VALUES IN
 492	!	 THE "RIGHT WAY"; THEY DEFAULT TO THE VALUE WHICH MAY HAVE BEEN SET IN
 493	!	 OTHER FIELDS.   ALSO, IT ALLEVIATES YOU FROM HAVING TO REMEMBER WHICH
 494	!	 OF THE 3 36-BIT PDP-10 WORDS THE FIELD GOES INTO.
 495	!
 496	! FUNCTIONAL DESCRIPTION:
 497	!
 498	!	 TO CREATE A MICROINSTRUCTION, CALL THE MACROS FOR THE FIELDS WHICH
 499	!	 YOU DESIRE TO SPECIFY EXPLICITLY.   SOME OF THEM REQUIRE ARGUMENTS;
 500	!	 SOME OF THEM CALL OTHERS WITH THE APPROPRIATE ARGUMENT.   THESE WILL
 501	!	 EXPAND TO THE NULL LEXEME (THAT IS, THEY GO AWAY).   FINALLY, THE
 502	!	 U MACRO IS CALLED.   IT HANDLES THE TRICKY DEFAULTS, EXPANDS TO 3
 503	!	 DECIMAL CONSTANTS SEPPARATED BY COMMAS, AND RESETS THE COMPILETIME
 504	!	 VARIABLES BACK TO THEIR INITIAL VALUES (MOSTLY, THE MICROINSTRUCTION
 505	!	 WITH ALL OF THE SIMPLE FIELDS WITH THEIR DEFAULT VALUES).   THE U
 506	!	 MACRO MAY BE CALLED AS THE ARGUMENT OF A PLIT.   IT MAY BE CALLED SEVERAL
 507	!	 TIMES WITH A COMMA BETWEEN EACH ONE (AND THE FIELD-SETTING MACROS
 508	!	 BEFORE EACH ONE) TO MAKE A PLIT WITH A BLOCK OF SEVERAL MICROINSTRUCTIONS
 509	!	 SINCE THE HOOKS INTO CSL WILL PERMIT LOADING SEVERAL MICROINSTRUCTIONS
 510	!	 INTO CONTIGUOUS CRAM LOCATIONS WITH ONE CALL.   MACROS MAY BE DEFINED
 511	!	 WHICH SET MANY OF THE FIELDS (JUST LIKE IN MICRO) BY HAVING IT CALL THE
 512	!	 DESIRED FIELD-SETTING MACROS.
 513	!
 514	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
 515	!
 516	! AUTHOR: ARON INSINGA, CREATION DATE: 22-AUG-78
 517	!
 518	! MODIFIED BY:
 519	!
 520	!	ARON INSINGA, 28-AUG-78: VERSION 0.1
 521	!--
 522	
 523	!
 524	! TABLE OF CONTENTS:
 525	!
 526	!	JUMP FIELD
 527	!	2901 ALU FUNCTION
 528	!	LEFT SOURCE
 529	!	RIGHT SOURCE
 530	!	DESTINATION (DP, Q, B)
 531	!	DATA PATH ADDRESS A
 532	!	DATA PATH ADDRESS B
 533	!	RAMFILE ADDRESS
 534	!	D-BUS SELECT
 535	!	DBM SELECT
 536	!	FICTICOUS PARITY-VALIDATE BIT
 537	!	CLOCK LEFT HALF OF THE MACHINE
 538	!	STORE PARITY FOR LEFT 2901'S
 539	!	CHECK LEFT HALF D-BUS PARITY
 540	!	CLOCK RIGHT HALF OF THE MACHINE
 541	!	STORE PARITY FOR RIGHT 2901'S
 542	!	CHECK RIGHT HALF D-BUS PARITY
 543	!	SPEC
 544	!	SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
 545	!	SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
 546	!	DISPATCH
 547	!	SKIP STUFF
 548	!	TIME FIELD
 549	!	RANDOM CONTROL BITS
 550	!	INJECT A CARRY
 551	!	LOAD SC FROM SCAD
 552	!	LOAD FE FROM SCAD
 553	!	WRITE THE RAM FILE
 554	!	START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
 555	!	THIS MICROINSTRUCTION IS DOING A DIVIDE
 556	!	MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
 557	!	FAST SHIFT
 558	!	CALL
 559	!	MAGIC NUMBER FIELD (#)
 560	!	SCAD (SHIFT-COUNT ADDER) FUNCTION
 561	!	SCAD A-INPUT MUX
 562	!	SCAD B-INPUT MUX
 563	!	SCAD NUMBER FIELD
 564	!	MICROINSTRUCTION BUILDER
 565	!
 566	!	MICROINSTRUCTION WITH DEFAULT FIELDS
 567	!	MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
 568	!	MICROINSTRUCTION BEING BUILT
 569	!
 570	
 571	!
 572	! MACROS:
 573	!
 574	
 575	    MACRO
 576	
 577		! JUMP FIELD
 578		U_J(O_CRAM_ADDR) =
 579		    %ASSIGN(U_0,U_0 OR ((%O %STRING(O_CRAM_ADDR))^24)) %,
 580	
 581		! 2901 ALU FUNCTION
 582		U_ALU(FUNC) =
 583		    %ASSIGN(U_0,(U_0 AND %O'777707777777') OR ((FUNC)^21)) %,
 584	
 585		U_ALU_ADD = U_ALU(0) %,
 586		U_ALU_SUB = U_ALU(1) %,
 587		U_ALU_RSUB = U_ALU(2) %,
 588		U_ALU_OR = U_ALU(3) %,
 589		U_ALU_AND = U_ALU(4) %,
 590		U_ALU_MASK = U_ALU(5) %,
 591		U_ALU_XOR = U_ALU(6) %,
 592		U_ALU_XNOR = U_ALU(7) %,
 593	
 594		! LEFT SOURCE
 595		U_LSRC(SRC) =
 596		    %ASSIGN(U_0,(U_0 AND %O'777770777777') OR ((SRC)^18)) %,
 597	
 598		U_LSRC_AQ = U_LSRC(0) %,
 599		U_LSRC_AB = U_LSRC(1) %,
 600		U_LSRC_0Q = U_LSRC(2) %,
 601		U_LSRC_0B = U_LSRC(3) %,
 602		U_LSRC_0A = U_LSRC(4) %,
 603		U_LSRC_DA = U_LSRC(5) %,
 604		U_LSRC_DQ = U_LSRC(6) %,
 605		U_LSRC_D0 = U_LSRC(7) %,
 606	
 607		! RIGHT SOURCE
 608		U_RSRC(SRC) =
 609		    %ASSIGN(U_0,(U_0 AND %O'777777077777') OR ((SRC)^15))
 610		    %ASSIGN(U_SET,U_SET OR U_SET_RSRC) %,
 611	
 612		U_RSRC_AQ = U_RSRC(0) %,
 613		U_RSRC_AB = U_RSRC(1) %,
 614		U_RSRC_0Q = U_RSRC(2) %,
 615		U_RSRC_0B = U_RSRC(3) %,
 616		U_RSRC_0A = U_RSRC(4) %,
 617		U_RSRC_DA = U_RSRC(5) %,
 618		U_RSRC_DQ = U_RSRC(6) %,
 619		U_RSRC_D0 = U_RSRC(7) %,
 620	
 621		! DESTINATION (DP, Q, B)
 622		U_DEST(DEST) =
 623		    %ASSIGN(U_0,(U_0 AND %O'777777707777') OR ((DEST)^12)) %,
 624	
 625		U_DEST_A = U_DEST(0) %,
 626		U_DEST_AD = U_DEST(1) %,
 627		U_DEST_Q_AD = U_DEST(2) %,
 628		U_DEST_PASS = U_DEST(3) %,
 629		U_DEST_Q_MUL2 = U_DEST(4) %,
 630		U_DEST_AD_MUL2 = U_DEST(5) %,
 631		U_DEST_Q_DIV2 = U_DEST(6) %,
 632		U_DEST_AD_DIV2 = U_DEST(7) %,
 633	
 634		! DATA PATH ADDRESS A
 635		U_A(DP) =
 636		    %ASSIGN(U_0,U_0 OR ((DP)^6)) %,
 637	
 638		U_A_MAG = U_A(0) %,
 639		U_A_PC = U_A(1) %,
 640		U_A_HR = U_A(2) %,
 641		U_A_AR = U_A(3) %,
 642		U_A_ARX = U_A(4) %,
 643		U_A_BR = U_A(5) %,
 644		U_A_BRX = U_A(6) %,
 645		U_A_ONE = U_A(7) %,
 646		U_A_EBR = U_A(8) %,
 647		U_A_UBR = U_A(9) %,
 648		U_A_MASK = U_A(10) %,
 649		U_A_FLG = U_A(11) %,
 650		U_A_PI = U_A(12) %,
 651		U_A_XWD1 = U_A(13) %,
 652		U_A_T0 = U_A(14) %,
 653		U_A_T1 = U_A(15) %,
 654	
 655		! DATA PATH ADDRESS B
 656		U_B(DP) =
 657		    %ASSIGN(U_0,U_0 OR (DP)) %,
 658	
 659		U_B_MAG = U_B(0) %,
 660		U_B_PC = U_B(1) %,
 661		U_B_HR = U_B(2) %,
 662		U_B_AR = U_B(3) %,
 663		U_B_ARX = U_B(4) %,
 664		U_B_BR = U_B(5) %,
 665		U_B_BRX = U_B(6) %,
 666		U_B_ONE = U_B(7) %,
 667		U_B_EBR = U_B(8) %,
 668		U_B_UBR = U_B(9) %,
 669		U_B_MASK = U_B(10) %,
 670		U_B_FLG = U_B(11) %,
 671		U_B_PI = U_B(12) %,
 672		U_B_XWD1 = U_B(13) %,
 673		U_B_T0 = U_B(14) %,
 674		U_B_T1 = U_B(15) %,
 675	
 676		! RAMFILE ADDRESS
 677		U_RAM(SEL) =
 678		    %ASSIGN(U_1,(U_1 AND %O'77777777777') OR ((SEL)^33)) %,
 679	
 680		U_RAM_AC = U_RAM(0) %,
 681		U_RAM_AC_FN = U_RAM(1) %,
 682		U_RAM_XR = U_RAM(2) %,
 683		U_RAM_VMA = U_RAM(4) %,
 684		U_RAM_RAM = U_RAM(6) %,
 685		U_RAM_N = U_RAM(7) %,
 686	
 687		! D-BUS SELECT
 688		U_DBUS(SEL) =
 689		    %ASSIGN(U_1,(U_1 AND %O'747777777777') OR ((SEL)^30)) %,
 690	
 691		U_DBUS_PC_FLAGS = U_DBUS(0) %,		! LEFT HALF
 692		U_DBUS_PI_NEW = U_DBUS(0) %,		! BITS 19:21
 693		U_DBUS_VMA = U_DBUS(0) %,		! BITS 27:35
 694		U_DBUS_DP = U_DBUS(1) %,
 695		U_DBUS_RAM = U_DBUS(2) %,
 696		U_DBUS_DBM = U_DBUS(3) %,
 697	
 698		! DBM SELECT
 699		U_DBM(SEL) =
 700		    %ASSIGN(U_1,(U_1 AND %O'770777777777') OR ((SEL)^27)) %,
 701	
 702		U_DBM_SCAD = U_DBM(0) %,		! LEFT HALF
 703		U_DBM_PF_DISP = U_DBM(0) %,		! BITS 18:21
 704		U_DBM_APR_FLAGS = U_DBM(0) %,		! BITS 22:35
 705		U_DBM_BYTES = U_DBM(1) %,
 706		U_DBM_EXP = U_DBM(2) %,			! LEFT HALF
 707		U_DBM_MSEC = U_DBM(2) %,		! RIGHT HALF
 708		U_DBM_DP = U_DBM(3) %,
 709		U_DBM_DP_SWAP = U_DBM(4) %,
 710		U_DBM_VMA = U_DBM(5) %,
 711		U_DBM_MEM = U_DBM(6) %,
 712		U_DBM_N = U_DBM(7) %,
 713	
 714		! FICTICOUS PARITY-VALIDATE BIT
 715		U_ALU_PARITY_OK =
 716		    %ASSIGN(U_3,U_3 OR (1^35)) %,
 717	
 718		! CLOCK LEFT HALF OF THE MACHINE
 719		U_NO_CLKL =
 720		    %ASSIGN(U_1,U_1 AND %O'777377777777') %,
 721	
 722		! STORE PARITY FOR LEFT 2901'S
 723		U_GENL =
 724		    %ASSIGN(U_1,U_1 OR (1^25))
 725		    %ASSIGN(U_SET,U_SET OR U_SET_GENL) %,
 726	
 727		! CHECK LEFT HALF D-BUS PARITY
 728		U_CHKL =
 729		    %ASSIGN(U_1,U_1 OR (1^24)) %,
 730	
 731		! CLOCK RIGHT HALF OF THE MACHINE
 732		U_NO_CLKR =
 733		    %ASSIGN(U_1,U_1 AND %O'777737777777') %,
 734	
 735		! STORE PARITY FOR RIGHT 2901'S
 736		U_GENR =
 737		    %ASSIGN(U_1,U_1 OR (1^22))
 738		    %ASSIGN(U_SET,U_SET OR U_SET_GENR) %,
 739	
 740		! CHECK RIGHT HALF D-BUS PARITY
 741		U_CHKR =
 742		    %ASSIGN(U_1,U_1 OR (1^21)) %,
 743	
 744		! SPEC
 745		U_SPEC(X) =
 746		    %ASSIGN(U_1,U_1 OR ((X)^15)) %,
 747	
 748		U_SPEC_N = U_SPEC(%O'10') %,
 749		U_SPEC_CLRCLK = U_SPEC(%O'11') %,
 750		U_SPEC_CLRIOLAT = U_SPEC(%O'12') %,
 751		U_SPEC_CLRIOBSY = U_SPEC(%O'13') %,
 752		U_SPEC_LDPAGE = U_SPEC(%O'14') %,
 753		U_SPEC_NICOND = U_SPEC(%O'15') %,
 754		U_SPEC_LDPXCT = U_SPEC(%O'16') %,
 755		U_SPEC_WAIT = U_SPEC(%O'17') %,
 756		U_SPEC_PREV = U_SPEC(%O'20') %,
 757		U_SPEC_LOADXR = U_SPEC(%O'21') %,
 758		U_SPEC_APRFLAGS = U_SPEC(%O'23') %,
 759		U_SPEC_CLRCSH = U_SPEC(%O'24') %,
 760		U_SPEC_APR_EN = U_SPEC(%O'25') %,
 761		U_SPEC_MEMCLR = U_SPEC(%O'27') %,
 762		U_SPEC_SWEEP = U_SPEC(%O'34') %,
 763		U_SPEC_PXCT_OFF = U_SPEC(%O'36') %,
 764		U_SPEC_INHCRY18 = U_SPEC(%O'40') %,
 765		U_SPEC_LOADIR = U_SPEC(%O'41') %,
 766		U_SPEC_LDPI = U_SPEC(%O'43') %,
 767		U_SPEC_ASHOV = U_SPEC(%O'44') %,
 768		U_SPEC_EXPTST = U_SPEC(%O'45') %,
 769		U_SPEC_FLAGS = U_SPEC(%O'46') %,
 770		U_SPEC_LDACBLK = U_SPEC(%O'47') %,
 771		U_SPEC_LDINST = U_SPEC(%O'61') %,
 772	
 773		! SPEC FIELD REDEFINED FOR 7-BIT BYTE STUFF
 774		U_BYTE(X) =
 775		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
 776	
 777		U_BYTE_1 = U_BYTE(1) %,
 778		U_BYTE_2 = U_BYTE(2) %,
 779		U_BYTE_3 = U_BYTE(3) %,
 780		U_BYTE_4 = U_BYTE(4) %,
 781		U_BYTE_5 = U_BYTE(5) %,
 782	
 783		! SPEC FIELD REDEFINED TO CONTROL SHIFT PATHS
 784		U_SHSTYLE(X) =
 785		    %ASSIGN(U_1,(U_1 AND %O'777777077777') OR ((X)^15)) %,
 786	
 787		U_SHSTYLE_NORM = U_SHSTYLE(0) %,
 788		U_SHSTYLE_ZERO = U_SHSTYLE(1) %,
 789		U_SHSTYLE_ONES = U_SHSTYLE(2) %,
 790		U_SHSTYLE_ROT = U_SHSTYLE(3) %,
 791		U_SHSTYLE_ASHC = U_SHSTYLE(4) %,
 792		U_SHSTYLE_LSHC = U_SHSTYLE(5) %,
 793		U_SHSTYLE_DIV = U_SHSTYLE(6) %,
 794		U_SHSTYLE_ROTC = U_SHSTYLE(7) %,
 795	
 796		! DISPATCH
 797		U_DISP(X) =
 798		    %ASSIGN(U_1,(U_1 AND %O'777777700777') OR ((X)^9)) %,
 799	
 800		U_DISP_CONSOLE = U_DISP(%O'00') %,
 801		U_DISP_DROM = U_DISP(%O'12') %,
 802		U_DISP_AREAD = U_DISP(%O'13') %,
 803		U_DISP_DP_LEFT = U_DISP(%O'31') %,
 804		U_DISP_NORM = U_DISP(%O'34') %,
 805		U_DISP_DP = U_DISP(%O'35') %,
 806		U_DISP_ADISP = U_DISP(%O'36') %,
 807		U_DISP_BDISP = U_DISP(%O'37') %,
 808		U_DISP_RETURN = U_DISP(%O'41') %,
 809		U_DISP_MUL = U_DISP(%O'62') %,
 810		U_DISP_PAGEFAIL = U_DISP(%O'63') %,
 811		U_DISP_NICOND = U_DISP(%O'64') %,
 812		U_DISP_BYTE = U_DISP(%O'65') %,
 813		U_DISP_EAMODE = U_DISP(%O'66') %,
 814		U_DISP_SCAD0 = U_DISP(%O'67') %,
 815	
 816		! SKIP STUFF
 817		U_SKIP(X) =
 818		    %ASSIGN(U_1,(U_1 AND %O'777777777007') OR ((X)^3)) %,
 819	
 820		U_SKIP_IOLGL = U_SKIP(%O'04') %,
 821		U_SKIP_LLE = U_SKIP(%O'12') %,
 822		U_SKIP_CRY0 = U_SKIP(%O'31') %,
 823		U_SKIP_ADLEQ0 = U_SKIP(%O'32') %,
 824		U_SKIP_ADREQ0 = U_SKIP(%O'33') %,
 825		U_SKIP_KERNEL = U_SKIP(%O'34') %,
 826		U_SKIP_FPD = U_SKIP(%O'35') %,
 827		U_SKIP_AC0 = U_SKIP(%O'36') %,
 828		U_SKIP_INT = U_SKIP(%O'37') %,
 829		U_SKIP_LE = U_SKIP(%O'42') %,
 830		U_SKIP_CRY2 = U_SKIP(%O'51') %,
 831		U_SKIP_DP0 = U_SKIP(%O'52') %,
 832		U_SKIP_DP18 = U_SKIP(%O'53') %,
 833		U_SKIP_IOT = U_SKIP(%O'54') %,
 834		U_SKIP_JFCL = U_SKIP(%O'55') %,
 835		U_SKIP_CRY1 = U_SKIP(%O'56') %,
 836		U_SKIP_TXXX = U_SKIP(%O'57') %,
 837		U_SKIP_TRAP_CYC = U_SKIP(%O'61') %,
 838		U_SKIP_ADEQ0 = U_SKIP(%O'62') %,
 839		U_SKIP_SC = U_SKIP(%O'63') %,
 840		U_SKIP_EXECUTE = U_SKIP(%O'64') %,
 841		U_SKIP_IO_BUSY = U_SKIP(%O'65') %,
 842		U_SKIP_CONTINUE = U_SKIP(%O'66') %,
 843		U_SKIP_1_MS = U_SKIP(%O'67') %,
 844	
 845		! TIME FIELD [O.E. "UT" = MDN.E. "OUT"]
 846		U_T(X) =
 847		    %ASSIGN(U_1,(U_1 AND %O'777777777774') OR (X)) %,
 848	
 849		! RANDOM CONTROL BITS
 850	
 851		! INJECT A CARRY
 852		U_CRY38 =
 853		    %ASSIGN(U_2,U_2 OR (1^35)) %,
 854	
 855		! LOAD SC FROM SCAD
 856		U_LOADSC =
 857		    %ASSIGN(U_2,U_2 OR (1^34)) %,
 858	
 859		! LOAD FE FROM SCAD
 860		U_LOADFE =
 861		    %ASSIGN(U_2,U_2 OR (1^33)) %,
 862	
 863		! WRITE THE RAM FILE
 864		U_FMWRITE =
 865		    %ASSIGN(U_2,U_2 OR (1^32)) %,
 866	
 867		! START/FINISH MEMORY/I/O CYCLE UNDER CONTROL OF NUMBER FIELD
 868		U_MEM =
 869		    %ASSIGN(U_2,U_2 OR (1^31)) %,
 870	
 871		! THIS MICROINSTRUCTION IS DOING A DIVIDE
 872		U_DIVIDE =
 873		    %ASSIGN(U_2,U_2 OR (1^30)) %,
 874	
 875		! MULTIPRECISION STEP IN DIVIDE, DEAD, DFSB (?)
 876		U_MULTI_PREC =
 877		    %ASSIGN(U_2,U_2 OR (1^29)) %,
 878	
 879		! FAST SHIFT
 880		U_MULTI_SHIFT =
 881		    %ASSIGN(U_2,U_2 OR (1^28)) %,
 882	
 883		! CALL
 884		U_CALL =
 885		    %ASSIGN(U_2,U_2 OR (1^27)) %,
 886	
 887		! MAGIC NUMBER FIELD (#)
 888		U_N(O_N) =
 889		    %ASSIGN(U_2,U_2 OR (%O %STRING(O_N))) %,
 890	
 891		! MAGIC NUMBER FIELD REDEFINED FOR SHIFT-COUNT ADDER (SCAD) CONTROL
 892	
 893		! SCAD FUNCTION
 894		U_SCAD(X) =
 895		    %ASSIGN(U_2,(U_2 AND %O'777777077777') OR ((X)^15)) %,
 896	
 897		U_SCAD_A_MUL2 = U_SCAD(0) %,
 898		U_SCAD_OR = U_SCAD(1) %,
 899		U_SCAD_SUBB = U_SCAD(2) %,
 900		U_SCAD_SUB = U_SCAD(3) %,
 901		U_SCAD_ADD = U_SCAD(4) %,
 902		U_SCAD_AND = U_SCAD(5) %,
 903		U_SCAD_A_DEC = U_SCAD(6) %,
 904		U_SCAD_A = U_SCAD(7) %,
 905	
 906		! SCAD A INPUT MUX
 907		U_SCADA(X) =
 908		    %ASSIGN(U_2,(U_2 AND %O'777777707777') OR ((X)^12)) %,
 909	
 910		U_SCADA_SC = U_SCADA(0) %,
 911		U_SCADA_SN = U_SCADA(1) %,
 912		U_SCADA_PTR44 = U_SCADA(2) %,
 913		U_SCADA_BYTE1 = U_SCADA(3) %,
 914		U_SCADA_BYTE2 = U_SCADA(4) %,
 915		U_SCADA_BYTE3 = U_SCADA(5) %,
 916		U_SCADA_BYTE4 = U_SCADA(6) %,
 917		U_SCADA_BYTE5 = U_SCADA(7) %,
 918	
 919		! SCAD B INPUT MUX
 920		U_SCADB(X) =
 921		    %ASSIGN(U_2,(U_2 AND %O'777777771777') OR ((X)^10)) %,
 922	
 923		U_SCADB_FE = U_SCADB(0) %,
 924		U_SCADB_EXP = U_SCADB(1) %,
 925		U_SCADB_SHIFT = U_SCADB(2) %,
 926		U_SCADB_SIZE = U_SCADB(3) %,
 927	
 928		! SCAD/SMALL NUMBER FIELD
 929		U_SN(O_SN) =
 930		    %ASSIGN(U_2,(U_2 AND %O'777777776000') OR (%O %STRING(O_SN))) %,
 931	
 932		! MICROINSTRUCTION BUILDER
 933		!	 HANDLE DEFAULTS FOR FIELDS WHICH DEFAULT TO OTHER FIELDS.
 934		!	 EXPAND OUT TO THE 3 WORDS (108 BIT FORMAT) WITH COMMAS.
 935		!	 RESET ALL THE COMPILETIME VARIABLES TO THEIR ORIGINAL VALUES.
 936		U =
 937		    
 938		! DEFAULT RSRC = LSRC
 939		    %IF (U_SET AND U_SET_RSRC) EQL 0
 940		    %THEN
 941			%ASSIGN(U_0,U_0 OR ((U_0^(-3)) AND %O'700000'))
 942		    %FI
 943	
 944		! DEFAULT GENL = ALU_PARITY_OK
 945		    %IF (U_SET AND U_SET_GENL) EQL 0
 946		    %THEN
 947			%ASSIGN(U_1,U_1 OR ((U_3^(-10)) AND %O'000200000000'))
 948		    %FI
 949	
 950		! DEFAULT GENR = ALU_PARITY_OK
 951		    %IF (U_SET AND U_SET_GENR) EQL 0
 952		    %THEN
 953			%ASSIGN(U_1,U_1 OR ((U_3^(-13)) AND %O'000020000000'))
 954		    %FI
 955	
 956		    U_0,U_1,U_2
 957	
 958		    %ASSIGN(U_0,U_0_DEFAULT)
 959		    %ASSIGN(U_1,U_1_DEFAULT)
 960		    %ASSIGN(U_2,U_2_DEFAULT)
 961		    %ASSIGN(U_3,U_3_DEFAULT)
 962		    %ASSIGN(U_SET,0) %;
 963	
 964	!
 965	! EQUATED SYMBOLS:
 966	!
 967	
 968	    LITERAL
 969	
 970		! MICROINSTRUCTION WITH DEFAULT FIELDS
 971		U_0_DEFAULT = %O'000044030000',
 972		U_1_DEFAULT = %O'417440070703',
 973		U_2_DEFAULT = %O'000000000000',
 974		U_3_DEFAULT = %O'000000000000',
 975	
 976		! MICROINSTRUCTION-FIELD-EXPLICITLY-SET BITS
 977		U_SET_RSRC = %O'1',
 978		U_SET_GENL = %O'2',
 979		U_SET_GENR = %O'4';
 980	
 981	    COMPILETIME
 982	
 983		! MICROINSTRUCTION BEING BUILT
 984		U_0 = U_0_DEFAULT,
 985		U_1 = U_1_DEFAULT,
 986		U_2 = U_2_DEFAULT,
 987		U_3 = U_3_DEFAULT,
 988		U_SET = 0;
 989	
 990	! END OF "KSU.R36"
 991	
 992	REQUIRE 'CSLMAC.R36';				!'CSL' INTERFACE MACROS
 993	
 994	!
 995	!			  COPYRIGHT (c) 1977, 1978 BY
 996	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
 997	!
 998	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
 999	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
1000	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
1001	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
1002	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
1003	! TRANSFERRED.
1004	!
1005	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
1006	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
1007	! CORPORATION.
1008	!
1009	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
1010	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
1011	!
1012	
1013	!++
1014	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
1015	!
1016	! ABSTRACT:
1017	!
1018	!	THIS FILE CONTAINS MACROS WHICH ARE USED TO COMMUNICATE WITH THE
1019	!	'CSL' PROGRAM.  THE MACROS EXPAND TO LUUO CALLS WHICH PERFORM TTY
1020	!	INPUT AND OUTPUT AND SEND ASCIZ COMMAND LINES TO THE 8080.
1021	!
1022	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
1023	!
1024	! AUTHOR:  RICH MURATORI	, CREATION DATE:  12-DEC-78
1025	!
1026	! MODIFIED BY:
1027	!
1028	!  RICH MURATORI, 12-DEC-78 : VERSION 0.1
1029	!--
1030	
1031	BUILTIN UUO;
1032	
1033	LITERAL
1034		ER_AC = 1,
1035		EI_AC = 2,
1036		EJ_AC = 3,
1037		EK_AC = 4,
1038		EB_AC = 5,
1039		EC_AC = 6,
1040		EM_AC = 7,
1041		PM_AC = 8,
1042		X1A_AC = 9,
1043		X1B_AC = 10;
1044	
1045	
1046	!MACROS TO DEFINE PRINTING CALLS MADE TO 'CSL' PROGRAM VIA UUO
1047	
1048	BIND CR_LF = UPLIT(%CHAR(13,10,0));
1049	
1050	MACRO
1051		PRINT_CRLF	= BEGIN
1052				  AC0 = CR_LF;
1053				  UUO(0,31,15,0);
1054				  END%,
1055		PNTSIX(MSGWORD)	= BEGIN
1056				  AC0 = MSGWORD;
1057				  UUO(0,31,0,2);
1058				  END%,
1059		PRINT_MSG(MSGADR)= BEGIN
1060				  AC0 = MSGADR;
1061				  UUO(0,31,15,0);
1062				  END%,
1063		PRINT_WORD(ADDR) = BEGIN
1064				   AC0 = ADDR;
1065				   UUO(0,31,0,0);
1066				   END%,
1067		PRINT_TXT(TEXT) = BEGIN
1068				  AC0 = UPLIT(%ASCIZ TEXT);
1069				  UUO(0,31,15,0);
1070				  END%,
1071		PTXT_CRLF(TEXT)	= BEGIN
1072				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
1073				  UUO(0,31,15,0);
1074				  END%,
1075		PRINT_DEC(NUM)	= BEGIN
1076				  AC0 = NUM;
1077				  UUO(0,31,13,0);
1078				  END%,
1079		PRT_CRLF_F	= BEGIN
1080				  AC0 = CR_LF;
1081				  UUO(0,31,15,1);
1082				  END%,
1083		PRT_MSG_F(MSGADR)= BEGIN
1084				  AC0 = MSGADR;
1085				  UUO(0,31,15,1);
1086				  END%,
1087		PRT_TXT_F(TEXT) = BEGIN
1088				  AC0 = UPLIT(%ASCIZ TEXT);
1089				  UUO(0,31,15,1);
1090				  END%,
1091		PTXT_CRLF_F(TEXT) = BEGIN
1092				  AC0 = UPLIT(%STRING(TEXT,%CHAR(13,10,0)));
1093				  UUO(0,31,15,1);
1094				  END%,
1095		PRT_DEC_F(NUM)	= BEGIN
1096				  AC0 = NUM;
1097				  UUO(0,31,13,1);
1098				  END%,
1099		PRINT_OCT_1(NUM)= BEGIN
1100				  AC0 = NUM;
1101				  UUO(0,31,1,0);
1102				  END%,
1103		PRINT_OCT_2(NUM)= BEGIN
1104				  AC0 = NUM;
1105				  UUO(0,31,2,0);
1106				  END%,
1107		PRINT_OCT_3(NUM)= BEGIN
1108				  AC0 = NUM;
1109				  UUO(0,31,3,0);
1110				  END%,
1111		PRINT_OCT_4(NUM)= BEGIN
1112				  AC0 = NUM;
1113				  UUO(0,31,4,0);
1114				  END%,
1115		PRINT_OCT_5(NUM)= BEGIN
1116				  AC0 = NUM;
1117				  UUO(0,31,5,0);
1118				  END%,
1119		PRINT_OCT_6(NUM)= BEGIN
1120				  AC0 = NUM;
1121				  UUO(0,31,6,0);
1122				  END%,
1123		PRINT_OCT_7(NUM)= BEGIN
1124				  AC0 = NUM;
1125				  UUO(0,31,7,0);
1126				  END%,
1127		PRINT_OCT_8(NUM)= BEGIN
1128				  AC0 = NUM;
1129				  UUO(0,31,8,0);
1130				  END%,
1131		PRINT_OCT_11(NUM)= BEGIN
1132				  AC0 = NUM;
1133				  UUO(0,31,11,0);
1134				  END%,
1135		PRINT_OCT_12(NUM)= BEGIN
1136				  AC0 = NUM;
1137				  UUO(0,31,12,0);
1138				  END%,
1139		POCT_SUP(NUM)	= BEGIN
1140				  AC0 = NUM;
1141				  UUO(0,31,14,3);
1142				  END%,
1143		PBELL		= UUO(0,31,1,7)%,
1144	
1145	!MACROS TO DEFINE UUO CALLS TO 'CSL' PROGRAM FOR TTY INPUT
1146	
1147		TT_ALTM = UUO(1,31,7,3)%,
1148		TTI_YES = UUO(1,31,1,3)%,
1149		TTI_CLR = UUO(0,31,10,3)%,
1150		TTI_DEC = UUO(1,31,4,3)%,
1151	
1152	!MACRO TO DEFINE END OF PROGRAM UUO
1153	
1154		EOP_UUO = UUO(0,31,14,4)%,
1155	
1156	!MACROS TO DEFINE UUO CALLS TO 'CSL' TO SEND CMD STRINGS WITH RESPONSE
1157	
1158		SEND_ER_LINE = UUO(0,1,ER_AC,0)%,
1159		SEND_EI_LINE = UUO(0,1,EI_AC,0)%,
1160		SEND_EJ_LINE = UUO(0,1,EJ_AC,0)%,
1161		SEND_EK_LINE = UUO(0,1,EK_AC,0)%,
1162		SEND_EB_LINE = UUO(0,1,EB_AC,0)%,
1163		SEND_EC_LINE = UUO(0,1,EC_AC,0)%,
1164		SEND_EM_LINE = UUO(0,1,EM_AC,0)%,
1165		SEND_PM_LINE = UUO(0,1,PM_AC,0)%,
1166		SEND_X1A_LINE = UUO(0,1,X1A_AC,0)%,
1167		SEND_X1B_LINE = UUO(0,1,X1B_AC,0)%,
1168	
1169	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD STRING
1170	
1171		SEND_CMD_LINE = UUO(0,1,0,0)%,
1172	
1173	!MACRO TO DEFINE UUO CALL TO 'CSL' PROGRAM TO SEND ASCIZ CMD LINE
1174	
1175		SEND_UUO_1 = UUO(0,1,1,0)%,
1176	
1177	!MACRO TO DEFINE ERROR MESSAGE CHECK CALL TO 'CSL'
1178	
1179		MSG_CHK_UUO = UUO(0,3,0,0)%,
1180	
1181	!MACRO TO DEFINE 'CSL' UUO TO PASS CONTROL-T INFO
1182	
1183		SEND_INFO = UUO(0,3,1,0)%,
1184	
1185	!MACROS TO DEFINE FILE HANDLING UUOS TO 'CSL' PROGRAM
1186	
1187		FSELECT(FILNAM_ADR)	= (AC0 = FILNAM_ADR;
1188					  UUO(1,31,5,4))%,
1189		FRDPAG	= UUO(1,31,8,4)%;
1190	
1191	!8080 ERROR MESSAGE FORMATS WHICH ARE CHECKED FOR.
1192	
1193	BIND
1194		HALTED = UPLIT(%ASCIZ '%HLTD'),
1195		MEM_REF_ERR = UPLIT(%ASCIZ '?MRE'),
1196		PAR_ERR = UPLIT(%ASCIZ '?PAR_ERR');
1197	
1198	! END OF 'CSL.MAC'
1199	REQUIRE 'STIRSD.R36';				!LINKAGE TO 'MSSTRC' DEFINITIONS
1200	
1201	!
1202	!			  COPYRIGHT (c) 1977, 1978 BY
1203	!	      DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASS.
1204	!
1205	! THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND  COPIED
1206	! ONLY  IN  ACCORDANCE  WITH  THE  TERMS  OF  SUCH  LICENSE AND WITH THE
1207	! INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR  ANY  OTHER
1208	! COPIES  THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY
1209	! OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE  IS  HEREBY
1210	! TRANSFERRED.
1211	!
1212	! THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE  WITHOUT  NOTICE
1213	! AND  SHOULD  NOT  BE  CONSTRUED  AS  A COMMITMENT BY DIGITAL EQUIPMENT
1214	! CORPORATION.
1215	!
1216	! DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE OR  RELIABILITY  OF  ITS
1217	! SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.
1218	!
1219	
1220	!++
1221	! FACILITY:  DECSYSTEM 2020 DIAGNOSTIC RELEASE TAPE 'DSTIR'
1222	!
1223	! ABSTRACT:
1224	!
1225	!	THESE ARE THE COMMON DECLARATIONS WHICH ARE USED BY THE TEST MODULES
1226	!	FOR THE DIFFERENT STIRS DIAGNOSTICS.
1227	!
1228	! ENVIRONMENT:  RUNS UNDER 'CSL' ON A TOPS-20 SYSTEM.
1229	!
1230	! AUTHOR: ARON INSINGA, CREATION DATE: 01-SEP-78
1231	!
1232	! MODIFIED BY:
1233	!
1234	!	ARON INSINGA, 23-MAY-79: VERSION 0.1
1235	!--
1236	
1237	!
1238	! MACROS:
1239	!
1240	
1241	    MACRO
1242		LOAD_U(CRAM_ADDR,SOURCE_ADDR) = LOADUC(%O %STRING(CRAM_ADDR),SOURCE_ADDR) %,
1243		LC(O_CRAM_ADDR) = LCA(%O %STRING(O_CRAM_ADDR)) %,
1244		SET_C(O_CRAM_ADDR) = SETNXT(%O %STRING(O_CRAM_ADDR)) %,
1245		STEP_U_NEXT(N) = (CP(N);EX_NXT) %,
1246		BEGIN_XLIST = BEGIN SWITCHES LIST(NOSOURCE); %,
1247		END_LIST = SWITCHES LIST(SOURCE); END %,
1248		DM(ADDR,DATA) = MEM_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
1249		EM(ADDR) = MEM_EXAMINE(%O %STRING(ADDR)) %,
1250		DI(ADDR,DATA) = IO_DEPOSIT(%O %STRING(ADDR),%O %STRING(DATA)) %,
1251		EI(ADDR) = IO_EXAMINE(%O %STRING(ADDR)) %,
1252		EX_NXT = EXNEXT() %,
1253		RD_0	= REG_EXAMINE(%O'0')%,
1254		RD_1	= REG_EXAMINE(%O'1')%,
1255		RD_2	= REG_EXAMINE(%O'2')%,
1256		RD_3	= REG_EXAMINE(%O'3')%,
1257		RD_100	= REG_EXAMINE(%O'100')%,
1258		RD_101	= REG_EXAMINE(%O'101')%,
1259		RD_102	= REG_EXAMINE(%O'102')%,
1260		RD_103	= REG_EXAMINE(%O'103')%,
1261		RD_300	= REG_EXAMINE(%O'300')%,
1262		RD_301	= REG_EXAMINE(%O'301')%,
1263		RD_303	= REG_EXAMINE(%O'303')%;
1264	
1265	!
1266	! EQUATED SYMBOLS:
1267	!
1268	
1269	    BUILTIN
1270		POINT,
1271		SCANI,
1272		REPLACEI;
1273	
1274	    EXTERNAL ROUTINE
1275		CONTROL: NOVALUE, 
1276		MEMSIZE,
1277		ERR: NOVALUE,
1278		ERRCA: NOVALUE,
1279		ERRCAS: NOVALUE,
1280		ERRS: NOVALUE,
1281		ERRM: NOVALUE,
1282		ERMCA: NOVALUE,
1283		ERMCAS: NOVALUE,
1284		ERMS: NOVALUE,
1285		NOERR: NOVALUE,
1286		FAILURE: NOVALUE,
1287		LOOP_CHK,
1288		FLP_CHK,
1289		CHK_ERR_MSG: NOVALUE,
1290		WAIT: NOVALUE,
1291		SEND_LINE,
1292		REPEAT: NOVALUE,
1293		PTSTNUM: NOVALUE,
1294		CP: NOVALUE,
1295		CP_NOSS: NOVALUE,
1296		SEND_NUL,
1297		SETNXT: NOVALUE,
1298		EXNEXT,
1299		WR_CRAM,
1300		X1,
1301		LOADUC: NOVALUE,
1302		MR: NOVALUE,
1303		PE: NOVALUE,
1304		CE: NOVALUE,
1305		CS: NOVALUE,
1306		CH: NOVALUE,
1307	        TP: NOVALUE,
1308	        TE: NOVALUE,
1309		EJ,
1310		SC_0: NOVALUE,
1311		EC,
1312		LCA: NOVALUE,
1313		DC_035: NOVALUE,
1314		MOD_FLD: NOVALUE,
1315		DM_CHK,
1316		MEM_DEPOSIT: NOVALUE,
1317		MEM_EXAMINE,
1318		EM_CHK,
1319		DN: NOVALUE,
1320		IO_DEPOSIT: NOVALUE,
1321		IO_EXAMINE,
1322		EI_CHK,
1323		REG_EXAMINE,
1324		WRT100: NOVALUE,
1325		WRT102: NOVALUE,
1326		WRT103: NOVALUE,
1327		WRT104: NOVALUE,
1328		WRT105: NOVALUE,
1329		WRT106: NOVALUE,
1330		WRT107: NOVALUE,
1331		WRT110: NOVALUE,
1332		WRT111: NOVALUE,
1333		WRT112: NOVALUE,
1334		WRT113: NOVALUE,
1335		WRT114: NOVALUE,
1336		WRT115: NOVALUE,
1337		WRT116: NOVALUE,
1338		WRT204: NOVALUE,
1339		WRT205: NOVALUE,
1340		WRT206: NOVALUE,
1341		WRT210: NOVALUE,
1342		WRT212: NOVALUE,
1343		SYNC_CLK: NOVALUE,
1344		TICK: NOVALUE;
1345	
1346	    EXTERNAL
1347		NO_SUBSET,
1348		LPONTST,
1349		TIMOUT,
1350		RPT_ERR_FLAG,
1351		ERRFLG;
1352	
1353	! END OF "STIRSD.R36"
1354	
1355	
1356	!
1357	! MACROS:
1358	!
1359	
1360	!
1361	! EQUATED SYMBOLS:
1362	!
1363	
1364	GLOBAL LITERAL
1365	    TEST_VERSION = 1,				!VERSION NUMBER FOR TEST MODULE
1366	    TEST_EDIT = 0;				!EDIT NUMBER FOR TEST MODULE
1367	
1368	
1369	GLOBAL BIND
1370	    MSGFIL = UPLIT (%SIXBIT'MSDPE', %SIXBIT'MSG'),
1371	    PRGNAM = UPLIT (%ASCIZ'KS10 STIMULUS-RESPONSE DIAGNOSTICS FOR THE M8620/DPE BOARD');
1372	
1373	!
1374	! OWN STORAGE:
1375	!
1376	
1377	OWN
1378		TEST53_FLG,
1379		TEST54_FLG,
1380		TEST55_FLG,
1381		TEST58_FLG,
1382		TEST59_FLG,
1383		PIBUS_FLG,
1384		PIACTV_FLG,
1385		PISOFT_FLG,
1386		DBMDBUS_FLG,
1387		ADRSFLG,
1388		LDVMA,					!FLAG TO LOAD THE VMA WITH 0
1389		PCDBUS_FLG,
1390		FUNCLD,					!FLAG TO LOAD INSTRUCTIONS FOR ALU FUNC TESTS
1391		RCVDATA,					!STORAGE FOR ALL RECIEVED DATA
1392		ER_TAB : VECTOR [10] INITIAL (0),		!STORAGE FOR ERRCAS ROUTINE PRINTOUT
1393		RAMFILE_FLAG : INITIAL (1),
1394		DROM_FLAG : INITIAL (1),
1395		TBL:VECTOR [512]				!STORAGE FOR CORRECT DROM CONTENTS (IN 36 BITS FORMAT)
1396		    INITIAL(					!INITIALIZE CORRECT DROM DATA
1397			    %O '000015562100',%O '000117402100',%O '000217402100',%O '000317402100',%O '000217412100',
1398			    %O '000517402100',%O '000617402100',%O '000717402100',%O '000117422100',%O '000417422100',
1399			    %O '000117432100',%O '000017432100',%O '000117442100',%O '000017442100',%O '000217442100',
1400			    %O '000317442100',%O '000017462100',%O '000017472100',%O '000017502100',%O '000017512100',
1401			    %O '000117512100',%O '000217512100',%O '000417512100',%O '001017512100',%O '000015572100',
1402			    %O '000115572100',%O '000215572100',%O '000315572100',%O '000415572100',%O '000515572100',
1403			    %O '000615572100',%O '000715572100',%O '000015562100',%O '000015562100',%O '000015562100',
1404			    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
1405			    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
1406			    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
1407			    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
1408			    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
1409			    %O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',%O '000015562100',
1410			    %O '000016612100',%O '000016622100',%O '000016632100',%O '000016642100',%O '000015513000',
1411			    %O '000016662100',%O '000016672100',%O '110016371100',%O '110016351100',%O '110516311100',
1412			    %O '110516361100',%O '020514571100',%O '020516151100',%O '020515661100',%O '020516271100',
1413			    %O '020515051100',%O '021514341100',%O '070116261100',%O '000014673100',%O '030015670100',
1414			    %O '010015650500',%O '071116261100',%O '001116161100',%O '000016602100',%O '000116602100',
1415			    %O '000116212100',%O '001516101100',%O '000016201500',%O '000016241100',%O '000016301500',
1416			    %O '000016341100',%O '070115771100',%O '000216602100',%O '070215771700',%O '070315771700',
1417			    %O '071115771100',%O '061115770100',%O '071215771700',%O '071315771700',%O '070115761100',
1418			    %O '000316602100',%O '070215761700',%O '070315761700',%O '071115761100',%O '061115760100',
1419			    %O '071215761700',%O '071315761700',%O '070115701100',%O '000416602100',%O '070215701700',
1420			    %O '070315701700',%O '071115701100',%O '061115700100',%O '071215701700',%O '071315701700',
1421			    %O '070115741100',%O '000516602100',%O '070215741700',%O '070315741700',%O '071115741100',
1422			    %O '061115740100',%O '071215741700',%O '071315741700',%O '101515151100',%O '001515153000',
1423			    %O '011614040700',%O '000415041700',%O '101514021100',%O '001514023000',%O '011614020700',
1424			    %O '000414021700',%O '101514051100',%O '001514053000',%O '011614050700',%O '000414051700',
1425			    %O '101514031100',%O '001515153000',%O '011614030700',%O '000414031700',%O '101516411100',
1426			    %O '001516413000',%O '001616411700',%O '001716411700',%O '100515711100',%O '000515713000',
1427			    %O '001615711700',%O '000615711700',%O '100516001100',%O '000516003000',%O '001616001700',
1428			    %O '000616001700',%O '100516011100',%O '000516013000',%O '001616011700',%O '000616011700',
1429			    %O '040016221000',%O '040016321000',%O '040016121000',%O '000014622100',%O '000014663000',
1430			    %O '050014701000',%O '050014641000',%O '000016652100',%O '001514061500',%O '000016402100',
1431			    %O '000515472100',%O '000115472100',%O '000015206000',%O '000015402100',%O '000015411100',
1432			    %O '121515530100',%O '000015442100',%O '000215433100',%O '000215452100',%O '000015462100',
1433			    %O '000015522100',%O '000015502100',%O '000015542100',%O '000015552100',%O '101515601100',
1434			    %O '001515603000',%O '001615601700',%O '001715601700',%O '101515611100',%O '001515613000',
1435			    %O '001615611700',%O '001715611700',%O '000014002100',%O '000114762100',%O '000214762100',
1436			    %O '000314762100',%O '000414762100',%O '000514762100',%O '000614762100',%O '000714762100',
1437			    %O '000014761100',%O '000114761100',%O '000214761100',%O '000314761100',%O '000414761100',
1438			    %O '000514761100',%O '000614761100',%O '000714761100',%O '000014002100',%O '000114402100',
1439			    %O '000214402100',%O '000314402100',%O '000415202100',%O '000514402100',%O '000614402100',
1440			    %O '000714402100',%O '000014771100',%O '000114771100',%O '000214771100',%O '000314771100',
1441			    %O '000414771100',%O '000514771100',%O '000614771100',%O '000714771100',%O '000016113000',
1442			    %O '000116112100',%O '000216112100',%O '000316112100',%O '000416112100',%O '000516112100',
1443			    %O '000616112100',%O '000716112100',%O '000014311500',%O '000114311500',%O '000214311500',
1444			    %O '000314311500',%O '000414311500',%O '000514311500',%O '000614311500',%O '000714311500',
1445			    %O '000015423000',%O '000115422100',%O '000215422100',%O '000315422100',%O '000415422100',
1446			    %O '000515422100',%O '000615422100',%O '000715422100',%O '000014371500',%O '000114371500',
1447			    %O '000214371500',%O '000314371500',%O '000414371500',%O '000514371500',%O '000614371500',
1448			    %O '000714371500',%O '001514413000',%O '001514413000',%O '001614412700',%O '001714412700',
1449			    %O '101514421100',%O '001514423000',%O '001614421700',%O '001714421700',%O '101514431100',
1450			    %O '001514433000',%O '001614431700',%O '001714431700',%O '101514041100',%O '001514043000',
1451			    %O '001614041700',%O '001714041700',%O '101514441100',%O '001514443000',%O '001614441700',
1452			    %O '001714441700',%O '000014001100',%O '000014002100',%O '011614040700',%O '011614040700',
1453			    %O '101514451100',%O '001514453000',%O '001614451700',%O '001714451700',%O '101514461100',
1454			    %O '001514463000',%O '001614461700',%O '001714461700',%O '101514471100',%O '001514473000',
1455			    %O '001614471700',%O '001714471700',%O '101514501100',%O '001514503000',%O '001614501700',
1456			    %O '001714501700',%O '001514513000',%O '001514513000',%O '001614512700',%O '001714512700',
1457			    %O '101514521100',%O '001514523000',%O '001614521700',%O '001714521700',%O '101514531100',
1458			    %O '001514533000',%O '001614531700',%O '001714531700',%O '101514541100',%O '001514543000',
1459			    %O '001614541700',%O '001714541700',%O '101514551100',%O '001514553000',%O '001614551700',
1460			    %O '001714551700',%O '001514563000',%O '001514563000',%O '001614562700',%O '001714562700',
1461			    %O '101514101100',%O '001514103000',%O '001614071700',%O '000414041700',%O '101514111100',
1462			    %O '001514113000',%O '001614131700',%O '000414141700',%O '101514321100',%O '001514323000',
1463			    %O '011614320700',%O '000414321700',%O '101514241100',%O '001514243000',%O '011614240700',
1464			    %O '000414241700',%O '101514331100',%O '001514333000',%O '011614330700',%O '000414331700',
1465			    %O '101514251100',%O '001514253000',%O '011614250700',%O '000414251700',%O '101514301100',
1466			    %O '001514303000',%O '011614300700',%O '000414301700',%O '101514221100',%O '001514223000',
1467			    %O '011614220700',%O '000414221700',%O '101514071100',%O '001514073000',%O '001614101700',
1468			    %O '000414041700',%O '101514121100',%O '001514123000',%O '001614151700',%O '000414161700',
1469			    %O '101514201100',%O '001514203000',%O '011614200700',%O '000414201700',%O '101514261100',
1470			    %O '001514263000',%O '011614260700',%O '000414261700',%O '101514211100',%O '001514213000',
1471			    %O '011614210700',%O '000414211700',%O '101514271100',%O '001514273000',%O '011614270700',
1472			    %O '000414271700',%O '101514171100',%O '001514173000',%O '011614170700',%O '000414171700',
1473			    %O '101514231100',%O '001514233000',%O '011614230700',%O '000414231700',%O '000014002100',
1474			    %O '000014002100',%O '000014752100',%O '000014742100',%O '000014732100',%O '000014722100',
1475			    %O '000414752100',%O '000414742100',%O '000014002100',%O '000014002100',%O '000014751100',
1476			    %O '000014741100',%O '000014731100',%O '000014721100',%O '000414751100',%O '000414741100',
1477			    %O '000514732100',%O '000514722100',%O '000114752100',%O '000114742100',%O '000114732100',
1478			    %O '000114722100',%O '000514752100',%O '000514742100',%O '000514731100',%O '000514721100',
1479			    %O '000114751100',%O '000114741100',%O '000114731100',%O '000114721100',%O '000514751100',
1480			    %O '000514741100',%O '000614732100',%O '000614722100',%O '000214752100',%O '000214742100',
1481			    %O '000214732100',%O '000214722100',%O '000614752100',%O '000614742100',%O '000614731100',
1482			    %O '000614721100',%O '000214751100',%O '000214741100',%O '000214731100',%O '000214721100',
1483			    %O '000614751100',%O '000614741100',%O '000714732100',%O '000714722100',%O '000314752100',
1484			    %O '000314742100',%O '000314732100',%O '000314722100',%O '000714752100',%O '000714742100',
1485			    %O '000714731100',%O '000714721100',%O '000314751100',%O '000314741100',%O '000314731100',
1486			    %O '000314721100',%O '000714751100',%O '000714741100',%O '120017004100',%O '120017204100',
1487			    %O '121617604700',%O '000316502100',%O '120017540100',%O '120017550100',%O '000616502100',
1488			    %O '000716502100',%O '121016140100',%O '121416140100',%O '121014600100',%O '121014610100',
1489			    %O '121016440100',%O '121416440100',%O '000616512100',%O '000716512100',%O '120016140100',
1490			    %O '120416140100',%O '120014600100',%O '120014610100',%O '120016440100',%O '120416440100',
1491			    %O '000616522100',%O '000716522100',%O '000016532100',%O '000116532100',%O '000216532100',
1492			    %O '000316532100',%O '000416532100',%O '000516532100',%O '000616532100',%O '000716532100',
1493			    %O '000016542100',%O '000116542100',%O '000216542100',%O '000316542100',%O '000416542100',
1494			    %O '000516542100',%O '000616542100',%O '000716542100',%O '000016552100',%O '000116552100',
1495			    %O '000216552100',%O '000316552100',%O '000416552100',%O '000516552100',%O '000616552100',
1496			    %O '000716552100',%O '000016562100',%O '000116562100',%O '000216562100',%O '000316562100',
1497			    %O '000416562100',%O '000516562100',%O '000616562100',%O '000716562100',%O '000016572100',
1498			    %O '000116572100',%O '000216572100',%O '000316572100',%O '000416572100',%O '000516572100',
1499			    %O '000616572100',%O '000716572100'  );
1500	
1501	!
1502	! EXTERNAL REFERENCES:
1503	!
1504	
1505	GLOBAL ROUTINE SPEC_DIALOGUE : NOVALUE =
1506	    BEGIN
1507	    0							!TO ILLUMINATE BLISS INFO COMMENT
1508	    END;
1509	
1510	GLOBAL ROUTINE SPEC_ASK : NOVALUE =
1511	    BEGIN
1512	
1513	    REGISTER
1514		AC0 = 0;
1515	
1516	    PRT_TXT_F ('DO YOU WISH TO INHIBIT TESTING OF DROM CONTENTS?');
1517	    DROM_FLAG = TTI_YES;
1518	    PRT_TXT_F ('DO YOU WISH TO INHIBIT RAMFILE TESTING?');
1519	    RAMFILE_FLAG = TTI_YES;
1520	    END;
1521	
1522	GLOBAL ROUTINE SPEC_PRT =
1523	    BEGIN
1524	
1525	    REGISTER
1526		AC0 = 0;
1527	
1528		IF .DROM_FLAG NEQ 0
1529			THEN PTXT_CRLF_F ('DROM CONTENTS TESTING INHIBITED');
1530		IF .RAMFILE_FLAG NEQ 0
1531			THEN PTXT_CRLF_F ('RAMFILE TESTING INHIBITED');
1532		IF (.DROM_FLAG OR .RAMFILE_FLAG) NEQ 0
1533			THEN RETURN 1;
1534	       0						!TO ILLUMINATE BLISS INFO COMMENT
1535	    END;
1536	
1537	GLOBAL ROUTINE TEST_INIT : NOVALUE =
1538	!THIS IS AN INITIALIZING ROUTINE THAT GETS EXECUTED EACH TIME STIRS
1539	!IS STARTED.IT WILL EXECUTE AN INSTRUCTION TO CLEAR PAGE FAIL CONDITION,
1540	!CLEAR VARIOUS FLAGS, DO A MASTER RESET, TURN OFF CRAM ERROR RECOVERY AND
1541	!DISABLE PARITY.
1542	    BEGIN
1543	
1544	    BIND
1545		POINTER = PLIT (U_J(1) U_SPEC_APR_EN U,
1546				U_J(2) U_SPEC_FLAGS U,
1547				U_J(3) U_SPEC_CLRCLK U,
1548				U_J(4) U_SPEC_LDPI U_ALU_XNOR U,
1549				U_J (4) U_SPEC_MEMCLR U);	!INSTRUCTION TO CLEAR PAGE FAIL STATE
1550	
1551	    MR ();					!DO A MASTER RESET
1552	    LOAD_U (0, POINTER);			!LOAD IT
1553	    SET_C(0);
1554	    CP_NOSS (10);				!DON'T SINGLE STEP THE NXT 5 CLOCKS
1555	    SC_0 ();					!TURN OFF CRAM ERROR RECOVERY
1556	    PE (0);					!DISABLE PARITY
1557	    RPT_ERR_FLAG = 1;				!SET THIS FLAG TO REPORT ANY 8080 ERRORS
1558	    NO_SUBSET = 1;
1559	    TEST53_FLG = 1;
1560	    TEST54_FLG = 1;
1561	    TEST55_FLG = 0;
1562	    TEST59_FLG = 0;
1563	    TEST58_FLG = 0;
1564	    PIBUS_FLG = 0;
1565	    PIACTV_FLG = 0;
1566	    PISOFT_FLG = 0;
1567	    ADRSFLG = 0;
1568	    DBMDBUS_FLG = 0;
1569	    PCDBUS_FLG = 0;
1570	    LDVMA = 0;					!CLEAR VMA LOAD WITH 0 FLAG
1571	    FUNCLD = 0;					!CLEAR FLAG TO LOAD INSTRUCTIONS FOR ALU FUNC TESTS
1572	    END;
1573	
1574	GLOBAL ROUTINE FUNC_LD : NOVALUE =
1575	!THIS ROUTINE WILL LOAD CRAM LOCATIONS 0,1,2,3,4,5 & 6 WITH INSTRUCTIONS
1576	!TO BE EXECUTED BY ALU FUNC TESTS.IT WILL ALSO EXECUTE INSTRUCTIONS TO
1577	!LOAD VMA AND REQUIRED DATA IN THE 2901'S REGISTERS Q & 0.IT WILL RELOAD
1578	!AND EXECUTE ONLY IF THE THE PROGRAM IS RESTARTED.
1579	!THE INSTRUCTIONS LOADED IN THE CRAM WILL DO THE FOLLOWING:
1580	!CRAM 0 /  LOAD THE VMA WITH ZERO, PUT 0 DATA IN THE Q REGISTER.
1581	!CRAM 1 /  FINISH LOAD VMA CYCLE.
1582	!CRAM 2 /  PUT -1 IN MAGIC # FIELD, PASS IT TO DBM, PASS IT TO DBUS MUX
1583	!	   AND FROM THERE LOAD IT INTO REGISTER 0 SHIFTED RIGHT.
1584	!CRAM 3 /  SHIFT THE -1 IN REGISTER 0 RIGHT AGAIN TO FILL ALL 40 BITS.
1585	!CRAM 4 /  DO THE FUNCTION AND PUT THE RESULT IN REGISTER 1 SHIFTED (RIGHT/LEFT).
1586	!CRAM 5 /  START A MEM WRITE CYCLE AND SHIFT REGISTER 1 (RIGHT/LEFT)AGAIN.
1587	!CRAM 6 /  FINISH THE MEM WRITE CYCLE OUTPUTING REGISTER 1 INTO PHYSICAL MEM.
1588	!NOTE:		(TST3 SHOULD PASS BEFOR THIS ROUTINE IS EXECUTED).
1589	
1590	    BEGIN
1591	
1592	    BIND
1593		POINTER = PLIT (U_J (1) U_DEST_Q_AD U_MEM U_N (1012) U,
1594				U_J(2) U_MEM U_N(2) U,
1595				U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD_DIV2 U_DBUS_DBM U_N(777777) U,
1596				U_J(4) U_ALU_OR U_DEST_AD_DIV2 U,
1597				U_J(5) U_ALU_OR U_B_PC U_DEST_AD_DIV2 U,
1598				U_J(6) U_ALU_OR U_LSRC_0B U_B_PC U_DEST_AD_DIV2  U_MEM U_N(11002) U,
1599				U_J(4) U_ALU_OR U_A_PC U_MEM U_N(2) U);
1600	
1601	    IF .FUNCLD EQL 0 THEN 			!HAVE THEY BEEN LOADED YET ?
1602		BEGIN
1603		LOAD_U (0, POINTER);			!NO THEN DO IT NOW
1604		SET_C (0);				!SET CRAM ADRS TO 0
1605		CP_NOSS (5);				!DON'T SINGLE STEP THE NXT 5 CLOCKS
1606							!PUT 0 IN THE Q REGISTER OF THE 2901'S
1607							!PUT ONES IN ALL 40 BITS IN REGISTER 1 OF THE 2901'S
1608		FUNCLD = -1;				!SET FLAG INSTRUCTIONS AND DATA HAVE BEEN LOADED
1609		END;
1610	
1611	    END;
1612	
1613	GLOBAL ROUTINE VMA_LD : NOVALUE =
1614	!THIS ROUTINE WILL EXECUTE 2 INSTRUCTION IN CRAM 0 & 1 TO LOAD THE VMA
1615	!WITH A ZERO.IT WILL NOT EXECUTE IF THE VMA HAS ALREADY BEEN LOADED
1616	    BEGIN
1617	
1618	    BIND
1619		POINTER = PLIT (U_J (1) U_MEM U_N (1012) U,
1620				U_MEM U_N(2) U);
1621	
1622	    IF .LDVMA EQL 0 THEN 			!HAS VMA BEEN LOADED ?
1623		BEGIN					!NO THEN DO IT NOW
1624		LOAD_U (0, POINTER);			!PUT INSTRUCTIONS TO LOAD THE VMA WITH 0
1625		SET_C (0);				!SET CRAM ADRS TO 0
1626		CP_NOSS (2);				!DON'T SINGLE STEP THE NXT 2 CLOCKS
1627		LDVMA = -1;				!SET FLAG VMA IS LOADED
1628		END;
1629	    END;
1630	
1631	GLOBAL ROUTINE TST1: NOVALUE =
1632	
1633	!THIS TEST CHECKS THAT WE CAN LOAD ADDRESSES USING DIAGNOSTIC FUNCTION
1634	!IN ORDER TO LOAD THE CRAM WITH MICROCODE
1635	!DISP & SKIP SEL BOTH = 0 (GRUOND INPUTS) ON DPEA.IT TRIES TO SET ADDRESS 0
1636	!IF THIS TEST FAILS THAT MEANS NO MICROCODE CAN BE LOADED AND NO TESTS CAN RUN
1637	
1638		BEGIN
1639		LABEL BLOCK1;
1640		DO (0) WHILE
1641	BLOCK1:		BEGIN
1642			SET_C(0);				!SET CRAM ADRS TO 0
1643			RCVDATA = EX_NXT;			!GET NXT CRAM ADRS
1644		INCR I FROM 0 TO 3 DO
1645			BEGIN
1646			IF (.RCVDATA AND 1^.I) NEQ 0		!IS IT 0
1647				THEN ERRCAS((1+.I),1,0,.RCVDATA,4,0);!NO
1648			END;
1649		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
1650			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
1651		0						!TO ILIMINATE INFO COMMENT
1652	
1653		END;
1654	!*MESSAGE 1
1655	!*	DIAGNOSTIC DIPATCH TEST
1656	!*STIMULUS:
1657	!*	TRIED TO LOAD ADDRESS 000, USING DIAG ADDRESS DISPATCH
1658	!*	TEST FAILED, ABORT PROGRAM 
1659	!*	CANT LOAD ANY MICROCODE
1660	!*	ABORT....ABORT....ABORT....
1661	!*RESPONSE:
1662	!]ERROR 1
1663	!]MSKIP MDISP NTWK
1664	!]ERROR 2
1665	!]MDISP NTWK
1666	!]ERROR 3
1667	!]MDISP NTWK
1668	!]ERROR 4
1669	!]MDISP NTWK
1670		END;
1671	
1672	GLOBAL ROUTINE TST2: NOVALUE =
1673	
1674	!THIS TEST CHECKS THAT WE CAN OUTPUT A 0 FROM THE 2901'S.
1675	!IT OUTPUTS A ZERO FROM THE 2901'S INTO THE DP, THEN SKIP TO NXT CRAM 
1676	!ADRS IF OUTPUT ON DP IS 0. THE CURRENT J FIELD IS 0
1677	
1678		BEGIN
1679		LABEL BLOCK1;
1680		BIND
1681		POINTER = PLIT (U_SKIP_ADEQ0 U);
1682		LOAD_U(0,POINTER);
1683		SET_C(0);					!SET CRAM ADRS TO 0
1684		DO (0) WHILE
1685	BLOCK1:	BEGIN
1686		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
1687		IF .RCVDATA NEQ 1	 			!CHECK DATA
1688			THEN ERR(1);				!NO
1689		IF LOOP_CHK(1) THEN				!IS LOOP ON ERRO SET
1690			LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
1691		0						!TO ILLUMINATE BLISS INFO COMMENT
1692	
1693		END;
1694	!*MESSAGE 1
1695	!*	2901'S TEST
1696	!*STIMULUS:
1697	!*	OUTPUT A 0 ONTO DP FROM THE 2901'S
1698	!*	SKIP IF DP EQL TO 0
1699	!*	J = 0
1700	!*RESPONSE:
1701	!*	DP WAS NOT A 0
1702	!]ERROR 1
1703	!]ADEQ0 M2901S NTWK
1704		END;
1705	
1706	GLOBAL ROUTINE TST3: NOVALUE =
1707	
1708	!THIS TEST CHECKS THAT WE CAN LOAD THE VMA WITH A ZERO.
1709	!IT OUTPUTS A ZERO FROM THE 2901'S INTO THE DP, LOAD THE VMA WITH DATA 
1710	!PATH CONTENTS, AND WRITE THE SAME CONTENTS INTO PHYSICAL MEMORY.
1711	!IT SHOULD WRITE A ZERO INTO MEM LOCATION ZERO.
1712	
1713		BEGIN
1714		LABEL BLOCK1;
1715		BIND
1716		POINTER = PLIT (U_J(1) U_MEM U_N(11012) U,
1717				U_J(0) U_MEM U_N(2) U);
1718		LOAD_U(0,POINTER);
1719		SET_C(0);					!SET CRAM ADRS TO 0
1720		DM(0,%O'-1');					!LOAD A -1 INTO MEM 0
1721		DO (0) WHILE
1722	BLOCK1:	BEGIN
1723		CP(4);						!GIVE 4 CLOCKS
1724		RCVDATA = EM(0);				!GET DATA FROM MEM
1725		IF .RCVDATA NEQ 0
1726			THEN ERRCA(1,0,.RCVDATA,12)		!NO
1727			ELSE LDVMA = -1;			!SET FLAG VMA IS LOADED WITH ZERO
1728	!*MESSAGE 1
1729	!*STIMULUS:
1730	!*	LOAD THE VMA AND WRITE TO MEM WITH THE 
1731	!*	SAME DATA (DP = 0 FROM A PORT)
1732	!*RESPONSE:
1733	!*	READ DATA FROM MEMORY
1734	!]ERROR 1
1735	!]M2901S MEMVMA NTWK
1736		IF LOOP_CHK(1) THEN				!IS LOOP ON ERRO SET
1737			LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
1738		0						!TO ILLUMINATE BLISS INFO COMMENT
1739	
1740		END;
1741		END;
1742	
1743	GLOBAL ROUTINE TST4: NOVALUE =
1744	
1745	!THIS TEST CHECKS THE ALU DEST FUNCTION (DEST = 0,1,2 & 3).
1746	!WE REPEAT EXECUTING 5 INSTRUCTIONS THAT WILL DO THE FOLOWING:
1747	!A)  CLEAR THE 2901'S REGISTER 0 AND Q.
1748	!B)  WRITE INTO THE 2901'S SELECTING A DEST (0,1,2 & 3).
1749	!C)  READ REGISTER 0 THEN THE Q AND VERIFY THE CONTENTS IF CHANGED OR NOT.
1750	!ALL DATA IS READ AND VERIFIED FROM MEM 0.THE 5 INSTUCTIONS RESIDE IN 
1751	!CRAM 1,2,3,4 & 5 .CRAM CONTENTS WILL DO THE FOLLOWING:
1752	!CRAM 1/ OUTPUT A ZERO FROM THE AD AND LOAD IT INTO REGISTER 0.
1753	!CRAM 2/ OUTPUT A ZERO FROM THE AD AND LOAD IT INTO THE Q REGISTER.
1754	!CRAM 3/ OUPUT A -1 FROM THE 2901'S AND LOAD IT INTO THE 2901'S SELECTED
1755	!	 REGISTER (0,Q OR NIETHER) BY SETTING DEST (0,1,2 OR 3).
1756	!CRAM 4/ START A MEMOY WRITE CYCLE.LOAD THE VMA WITH A 0
1757	!CRAM 5/ FINISH THE CYCLE BY WRITING INTO PHYSICAL MEM 0 THE CONTENTS 
1758	!	 OF THE SELETED REGISTER (0 OR Q).
1759	!ALL DATA IS VERIFIED AND ERRORS ARE REPORTED.
1760	!DEST & OUTPUT SOURCE IS CHANGED BY MODIFYING FIELDS IN THE CRAM.
1761	
1762		BEGIN
1763		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
1764		      BLOCK6,BLOCK7,BLOCK8;
1765		BIND
1766		POINTER = PLIT (U_J(2) U_DEST_AD U,
1767				U_J(3) U_DEST_Q_AD U,
1768				U_J(4) U_ALU_XNOR U_DEST_A U,
1769				U_J(5) U_MEM U_N(11012) U,
1770				U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
1771		LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS
1772		SET_C(1);					!SET CRAM ADRS TO 1
1773		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
1774		ER_TAB[1] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
1775		ER_TAB[2] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
1776		DO (0) WHILE
1777	BLOCK1:	BEGIN
1778		DM(0,0);					!CLEAR MEM
1779		CP(5);						!GIVE 5 CLOCKS
1780		RCVDATA = EM(0);				!GET DATA
1781		IF .RCVDATA NEQ %O'-1'			!CHECK DATA
1782			THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
1783		IF LOOP_CHK(1) THEN				!IS LOOP ON ERRO SET
1784			LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
1785		0						!TO ILLUMINATE BLISS INFO COMMENT
1786	
1787		END;
1788		LC(5);						!LOAD CRAM ADRS 5
1789		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO PUPUT Q
1790		SET_C(1);					!SET CRAM ADRS TO 1
1791		ER_TAB[1] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
1792		ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));
1793		DO (0) WHILE
1794	BLOCK2:	BEGIN
1795		CP(5);						!GIVE 5 CLOCKS
1796		RCVDATA = EM(0);				!GET DATA
1797		IF .RCVDATA NEQ 0 				!CHECK DATA
1798			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
1799		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
1800			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
1801		0						!TO ILLUMINATE BLISS INFO COMMENT
1802	
1803		END;
1804		LC(3);						!LOAD CRAM ADRS 3
1805		MOD_FLD(7,%O'7100');				!CHANGE DEST TO 1
1806		ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
1807		SET_C(1);					!SET CRAM ADRS TO 1
1808		DO (0) WHILE
1809	BLOCK3:	BEGIN
1810		DM(0,%O'-1');					!SET MEM
1811		CP(5);						!GIVE 5 CLOCKS
1812		RCVDATA = EM(0);				!GET DATA
1813		IF .RCVDATA NEQ 0 				!CHECK DATA
1814			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
1815		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
1816			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
1817		0						!TO ILLUMINATE BLISS INFO COMMENT
1818	
1819		END;
1820		LC(5);						!LOAD CRAM ADRS 5
1821		MOD_FLD(5,%O'3337');				!CHANGE LSRC TO OUPUT B
1822		SET_C(1);					!SET CRAM ADRS TO 1
1823		ER_TAB[1] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
1824		ER_TAB[2] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
1825		DO (0) WHILE
1826	BLOCK4:	BEGIN
1827		CP(5);						!GIVE 5 CLOCKS
1828		RCVDATA = EM(0);				!GET DATA
1829		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
1830			THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
1831		IF LOOP_CHK(4) THEN				!IS LOOP ON ERROR SET
1832			LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
1833		0						!TO ILLUMINATE BLISS INFO COMMENT
1834	
1835		END;
1836		LC(3);						!LOAD CRAM ADRS 3
1837		ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
1838		MOD_FLD(7,%O'7200');				!MODIFY DEST TO 2
1839		SET_C(1);					!SET CRAM ADRS TO 2
1840		DO (0) WHILE
1841	BLOCK5:	BEGIN
1842		CP(5);						!GIVE 5 CLOCKS
1843		RCVDATA = EM(0);				!GET DATA
1844		IF .RCVDATA NEQ 0 				!CHECK DATA
1845			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
1846		IF LOOP_CHK(5) THEN				!IS LOOP ON ERROR SET
1847			LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
1848		0						!TO ILLUMINATE BLISS INFO COMMENT
1849	
1850		END;
1851		LC(5);						!LOAD CRAM ADRS 5
1852		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUTPUT Q
1853		SET_C(1);					!SET CRAM ADRS TO 1
1854		ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
1855		ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD CHANGE'));
1856		DO (0) WHILE
1857	BLOCK6:	BEGIN
1858		CP(5);						!GIVE 5 CLOCKS
1859		RCVDATA = EM(0);				!GET DATA
1860		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
1861			THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
1862		IF LOOP_CHK(6) THEN				!IS LOOP ON ERROR SET
1863			LEAVE BLOCK6 WITH 1;			!LEAVE BLOCK TO LOOP
1864		0						!TO ILLUMINATE BLISS INFO COMMENT
1865	
1866		END;
1867		LC(3);						!LOAD CRAM ADRS 3
1868		MOD_FLD(7,%O'7300');				!MODIFY DEST TO 3
1869		ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
1870		ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));
1871		SET_C(1);					!SET CRAM ADRS TO 2
1872		DO (0) WHILE
1873	BLOCK7:	BEGIN
1874		CP(5);						!GIVE 5 CLOCKS
1875		RCVDATA = EM(0);				!GET DATA
1876		IF .RCVDATA NEQ 0				!CHECK DATA
1877			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
1878		IF LOOP_CHK(7) THEN				!IS LOOP ON ERROR SET
1879			LEAVE BLOCK7 WITH 1;			!LEAVE BLOCK TO LOOP
1880		0						!TO ILLUMINATE BLISS INFO COMMENT
1881	
1882		END;
1883		LC(5);						!LOAD CRAM ADRS 5
1884		MOD_FLD(5,%O'3337');				!CHANGE LSRC TO OUTPUT B
1885		SET_C(1);					!SET CRAM ADRS TO 1
1886		ER_TAB[2] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE 0 REGISTER SHOULD NOT CHANGE'));
1887		ER_TAB[1] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
1888		DO (0) WHILE
1889	BLOCK8:	BEGIN
1890		DM(0,%O'-1');					!SET MEM
1891		CP(5);						!GIVE 5 CLOCKS
1892		RCVDATA = EM(0);				!GET DATA
1893		IF .RCVDATA NEQ 0				!CHECK DATA
1894			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);		!NO
1895		IF LOOP_CHK(8) THEN				!IS LOOP ON ERROR SET
1896			LEAVE BLOCK8 WITH 1;			!LEAVE BLOCK TO LOOP
1897		0						!TO ILLUMINATE BLISS INFO COMMENT
1898	
1899		END;
1900	!*MESSAGE 1
1901	!*	2901'S TEST
1902	!*STIMULUS:
1903	!*	WRITE ZERO INTO THE 2901'S Q REGISTER
1904	!*	WRITE (-1) INTO THE 2901'S REGISTER 0 SELECTING DEST = \O0
1905	!*	THEN OUTPUT THE CONTENTS OF REGISTER \S1 INTO MEM 0.\S2
1906	!*RESPONSE:
1907	!*	EXAMINE THE DATA FROM MEM 0
1908	!]ERROR 1
1909	!]M2901S DPCLKS MEMVMA NTWK
1910		END;
1911	
1912	GLOBAL ROUTINE TST5: NOVALUE =
1913	
1914	!THIS TEST CHECKS THAT THE REGISTERS IN THE 2901'S CAN BE ZEROS AND ONES
1915	!(ONLY 36 BITS ARE CHECKED HERE).
1916	!ALL REGISTERS OF THE 2901'S ARE CHECKED THROUGH A DO 17 LOOP. AT
1917	!EACH PASS THROUGH THE LOOP 2 SEQUENCES OF DATA ARE WRITTEN INTO THE 
1918	!SELECTED REGISTER.AFTER EACH WRITE THE DATA THEN IS PASSED OUT FROM 
1919	!THE REGISTER AND INTO PHYSICAL MEMORY.THE DATA IS READ AND VERIFEID 
1920	!FROM MEMORY.THREE INSTRUCTIONS ARE EXECUTED FOR EACH DATA PASS FROM 
1921	!CRAM 1,2 & 3.ALL EXPECTED DATA IS READ FROM MEM 0.
1922	!THE THREE INSTRUCTIONS DO THE FOLLOWING:
1923	!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
1924	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
1925	!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER .
1926	!CRAM 2/ START A PHYSICAL MEMORY WRITE CYCLE. LOAD THE VMA WITH A 0
1927	!CRAM 3/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
1928	!	 THE A PORT, WRITE THE DP INTO PHYSICAL MEM.
1929	
1930		BEGIN
1931		LABEL BLOCK1,
1932		BLOCK2;
1933		BIND
1934		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
1935				U_J(3) U_MEM U_N(11012) U,
1936				U_J(1) U_ALU_OR U_LSRC_0A U_DEST_A U_MEM U_N(2) U);
1937		LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
1938		DM(0,0);					!CLEAR MEM
1939	    INCR I FROM 0 TO %O'17' DO
1940		BEGIN
1941		LC(3);						!SET CRAM ADRS TO 3
1942		MOD_FLD(6,(.I OR %O'2060') OR .I^6);		!MODIFY THE SELETED REGISTER (DP A&B ADRS)
1943		LC(1);						!LOAD CRAM ADRS 1
1944		MOD_FLD(3,%O'5252');				!MODIFY THE DATA
1945		MOD_FLD(4,%O'52');				!HERE TOO
1946		MOD_FLD(6,.I OR %O'6060');			!MODIFY THE SELETED REGISTER (DP B ADRS)
1947		ER_TAB[0] = .I;					!SET UP FOR ERROR PRINTOUT
1948		ER_TAB[1] = %O'525252525252';			!SET UP FOR ERROR PRINTOUT
1949		DO (0) WHILE
1950	BLOCK1:	
1951		BEGIN
1952		CP(3);						!GIVE 3 CLOCKS
1953		RCVDATA = EM(0);				!GET DATA FROM MEM
1954		IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
1955			THEN BEGIN
1956				ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);	!NO
1957				DBMDBUS_FLG = 1;
1958			     END;
1959		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
1960			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
1961		0						!TO ILLUMINATE BLISS INFO COMMENT
1962	
1963		END;
1964		MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
1965		MOD_FLD(4,%O'25');				!HERE TOO
1966		ER_TAB[1] = %O'252525252525';			!SET UP FOR ERROR PRINTOUT
1967		DO (0) WHILE
1968	BLOCK2:	
1969		BEGIN
1970		CP(3);						!GIVE 3 CLOCKS
1971		RCVDATA = EM(0);				!GET DATA FROM MEM
1972		IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
1973			THEN BEGIN
1974				ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB); !NO
1975				DBMDBUS_FLG = 1;
1976			     END
1977			ELSE IF .DBMDBUS_FLG EQL 0
1978					THEN NOERR(1);
1979		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
1980			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
1981		0						!TO ILLUMINATE BLISS INFO COMMENT
1982	
1983		END;
1984		END;
1985	!*MESSAGE 1
1986	!*	2901'S TEST
1987	!*STIMULUS:
1988	!*	LOAD THE 2901'S REGISTER \O0 WITH \U1
1989	!*	FROM THE MAGIC # FIELD VIA DBUS
1990	!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT A
1991	!*RESPONSE:
1992	!*	READ THE DATA FROM MEMORY
1993	!]ERROR 1
1994	!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA NTWK
1995	!]NO ERROR 1
1996	!]DBMDBUS NTWK
1997		END;
1998	
1999	GLOBAL ROUTINE TST6: NOVALUE =
2000	
2001	!THIS TEST CKECKS OUT PORT B IN THE 2901'S (ONLY 36 BITS).
2002	!WE PASS 2 DATA WORDS ONE AT A TIME TO REGISTER 0,THEN PASS IT OUT 
2003	!INTO MEM ZERO THROUGH PORT B.WE EXECUTE THREE INSTRUCTIONS EACH TIME
2004	!THE THREE INSTRUCTIONS RESIDE IN CRAM 1,2 & 3.ALL EXPECTED DATA IS READ
2005	!FROM MEM 0.THE THREE INSTRUCTIONS DO THE FOLLOWING:
2006	!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2007	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2008	!	 CONTENTS OF THE DATA BUS INTO REGISTER 0 .
2009	!CRAM 2/ START A PHYSICAL MEMORY WRITE CYCLE. LOAD THE VMA WITH A 0
2010	!CRAM 3/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
2011	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2012	
2013		BEGIN
2014		LABEL BLOCK1,
2015		BLOCK2;
2016		BIND
2017		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(525252) U,
2018				U_J(3) U_MEM U_N(11012) U,
2019				U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
2020		LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
2021		SET_C(1);					!SET CRAM ADRS TO 1
2022		ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
2023		DO (0) WHILE
2024	BLOCK1:	
2025		BEGIN
2026		CP(3);						!GIVE 3 CLOCKS
2027		RCVDATA = EM(0);				!GET DATA FROM MEM
2028		IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
2029			THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
2030		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
2031			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
2032		0						!TO ILLUMINATE BLISS INFO COMMENT
2033	
2034		END;
2035		LC(1);						!LOAD CRAM ADRS 2
2036		MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
2037		MOD_FLD(4,%O'25');				!HERE TOO
2038		ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
2039		DO (0) WHILE
2040	BLOCK2:	
2041		BEGIN
2042		CP(3);						!GIVE 3 CLOCKS
2043		RCVDATA = EM(0);				!GET DATA FROM MEM
2044		IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
2045			THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
2046		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
2047			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
2048		0						!TO ILLUMINATE BLISS INFO COMMENT
2049	
2050		END;
2051	!*MESSAGE 1
2052	!*	2901'S TEST
2053	!*STIMULUS:
2054	!*	LOAD THE 2901'S REGISTER 0 WITH \U0
2055	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2056	!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
2057	!*RESPONSE:
2058	!*	READ THE DATA FROM MEMORY
2059	!]ERROR 1
2060	!]MEMVMA M2901S DPCLKS DBMDBUS DBUSSEL NTWK
2061		END;
2062	
2063	GLOBAL ROUTINE TST7: NOVALUE =
2064	
2065	!THIS TEST CKECKS OUT THE Q REGISTER IN THE 2901'S (ONLY 36 BITS).
2066	!WE PASS 2 DATA WORDS ONE AT A TIME TO THE Q REGISTER,THEN PASS IT OUT 
2067	!INTO MEM ZERO THROUGH PORT B.WE EXECUTE THREE INSTRUCTIONS EACH TIME
2068	!THE THREE INSTRUCTIONS RESIDE IN CRAM 1,2 & 3.ALL EXPECTED DATA IS READ
2069	!FROM MEM 0.THE THREE INSTRUCTIONS DO THE FOLLOWING:
2070	!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2071	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2072	!	 CONTENTS OF THE DATA BUS INTO THE Q REGISTER.
2073	!CRAM 2/ START A PHYSICAL MEMORY WRITE CYCLE.LOAD THE VMA WITH A 0
2074	!CRAM 3/ OUTPUT THE CONTENTS OF THE THE Q REGISTER INTO THE DP THROUGH
2075	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2076	
2077		BEGIN
2078		LABEL BLOCK1,
2079		BLOCK2;
2080		BIND
2081		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(525252) U,
2082				U_J(3) U_MEM U_N(11012) U,
2083				U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
2084		LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS
2085	
2086		SET_C(1);					!SET CRAM ADRS TO 1
2087		ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
2088		DO (0) WHILE
2089	BLOCK1:	
2090		BEGIN
2091		CP(3);						!GIVE 3 CLOCKS
2092		RCVDATA = EM(0);				!GET DATA FROM MEM
2093		IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
2094			THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
2095		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
2096			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
2097		0						!TO ILLUMINATE BLISS INFO COMMENT
2098	
2099		END;
2100		MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
2101		MOD_FLD(4,%O'25');				!HERE TOO
2102		ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
2103		DO (0) WHILE
2104	BLOCK2:	
2105		BEGIN
2106		CP(3);						!GIVE 3 CLOCKS
2107		RCVDATA = EM(0);				!GET DATA FROM MEM
2108		IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
2109			THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
2110		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
2111			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
2112		0						!TO ILLUMINATE BLISS INFO COMMENT
2113	
2114		END;
2115	!*MESSAGE 1
2116	!*	2901'S TEST
2117	!*STIMULUS:
2118	!*	LOAD THE 2901'S Q REGISTER WITH \U0
2119	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2120	!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
2121	!*RESPONSE:
2122	!*	READ THE DATA FROM MEM 0
2123	!]ERROR 1
2124	!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA NTWK
2125		END;
2126	
2127	GLOBAL ROUTINE TST8: NOVALUE =
2128	
2129	!THIS TEST CKECKS OUT THE RAM SHIFTER IN THE 2901'S (ONLY 36 BITS).
2130	!WE PASS 2 DATA WORDS ONE AT A TIME TO REGISTER 0 SHIFTED LEFT,THEN 
2131	!PASS IT OUT INTO MEM ZERO THROUGH PORT B.FINALLY WE PASS THE SAME TWO 
2132	!DATA WORDS SHITED RIGHT. WE EXECUTE THREE INSTRUCTIONS FOR EACH DATA
2133	!SHIFT PASS THE THREE INSTRUCTIONS RESIDE IN CRAM 2,3 & 4.ALL EXPECTED 
2134	!DATA IS READ FROM MEM 0.THE THREE INSTRUCTIONS DO THE FOLLOWING:
2135	!CRAM 2/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2136	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2137	!	 CONTENTS OF THE DATA BUS SHIFTED (LEFT/RIGHT) INTO REGISTER 0 .
2138	!CRAM 3/ START A PHYSICAL MEMORY WRITE CYCLE. LOAD THE VMA WITH A 0.
2139	!CRAM 4/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
2140	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2141	
2142		BEGIN
2143		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
2144		      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
2145		BIND
2146		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(252525) U,
2147				U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD_MUL2 U_DBUS_DBM U_N(252525) U,
2148				U_J(4) U_MEM U_N(11012) U,
2149				U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
2150		LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS
2151		ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
2152		ER_TAB[1] = 5;					!FOR ERROR PRINTOUT
2153		ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
2154		ER_TAB[3] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));
2155	
2156		SET_C(1);					!SET CRAM ADRS TO 1
2157		DO (0) WHILE
2158	BLOCK1:	
2159		BEGIN
2160		CP(4);						!GIVE 4 CLOCKS
2161		RCVDATA = EM(0);				!GET DATA FROM MEM
2162		IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
2163			THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
2164		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
2165			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
2166		0						!TO ILLUMINATE BLISS INFO COMMENT
2167	
2168		END;
2169		LC(4);						!LOAD CRAM ADRS 4
2170		MOD_FLD(5,%O'3337');				!MODIFY TO OUPUT B
2171		MOD_FLD(0,3);					!MODIFY J FIELD
2172		ER_TAB[3] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
2173		ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
2174		SET_C(2);					!SET CRAM ADRS TO 2
2175		DO (0) WHILE
2176	BLOCK2:	BEGIN
2177		CP(3);						!GIVE 3 CLOCKS
2178		RCVDATA = EM(0);				!GET DATA
2179		IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
2180			THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
2181		IF LOOP_CHK(2)
2182			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
2183		0						!TO ILLUMINATE BLISS INFO COMMENT
2184	
2185		END;
2186		MOD_FLD(3,%O'5252');				!MODIFY DATA IN # FIELD
2187		MOD_FLD(4,%O'52');				!HERE TOO
2188		ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
2189		DO (0) WHILE
2190	BLOCK3:	
2191		BEGIN
2192		CP(3);						!GIVE 3 CLOCKS
2193		RCVDATA = EM(0);				!GET DATA FROM MEM
2194		IF .RCVDATA NEQ %O'252525252524'		!CHECK DATA
2195			THEN ERRCAS(1,1,%O'252525252524',.RCVDATA,12,ER_TAB);!NO
2196		IF LOOP_CHK(3) THEN				!IS LOOP ON ERROR SET
2197			LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
2198		0						!TO ILLUMINATE BLISS INFO COMMENT
2199	
2200		END;
2201		DM(0,0);					!CLEAR MEMORY
2202		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TYPE
2203		LC(4);						!LOAD CRAM ADRS 5
2204		MOD_FLD(5,%O'3227');				!OUTPUT Q
2205		MOD_FLD(0,2);					!MODIFY J FIELD
2206		ER_TAB[1] = 7;					!FOR ERROR PRINTOUT
2207		ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
2208		ER_TAB[3] = UPLIT (%STRING(%CHAR(13,10),'	THE CONTENTS OF THE Q REGISTER SHOULD NOT CHANGE'));
2209		SET_C(1);					!SET CRAM ADRS TO 1
2210		DO (0) WHILE
2211	BLOCK4:	
2212		BEGIN
2213		CP(4);						!GIVE 4 CLOCKS
2214		RCVDATA = EM(0);				!GET DATA FROM MEM
2215		IF .RCVDATA NEQ %O'252525252525'		!CHECK DATA
2216			THEN ERRCAS(1,1,%O'252525252525',.RCVDATA,12,ER_TAB);!NO
2217		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
2218			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
2219		0						!TO ILLUMINATE BLISS INFO COMMENT
2220	
2221		END;
2222		LC(4);						!LOAD CRAM ADRS 4
2223		MOD_FLD(5,%O'3337');				!MODIFY TO OUTPUT B
2224		MOD_FLD(0,3);					!MODIFY J FIELD
2225		ER_TAB[3] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
2226		ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
2227		SET_C(2);					!SET CRAM ADRS TO 3
2228		DO (0) WHILE
2229	BLOCK5:	BEGIN
2230		CP(3);						!GIVE 2 CLOCKS
2231		RCVDATA = EM(0);				!GET DATA
2232		IF .RCVDATA NEQ %O'652525252525'		!CHECK DATA
2233			THEN ERRCAS(1,1,%O'652525252525',.RCVDATA,12,ER_TAB);!NO
2234		IF LOOP_CHK(5)
2235			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
2236		0						!TO ILLUMINATE BLISS INFO COMMENT
2237	
2238		END;
2239		MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
2240		MOD_FLD(4,%O'25');				!HERE TOO
2241		ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
2242		DO (0) WHILE
2243	BLOCK6:	
2244		BEGIN
2245		CP(3);						!GIVE 3 CLOCKS
2246		RCVDATA = EM(0);				!GET DATA FROM MEM
2247		IF .RCVDATA NEQ %O'125252525252'		!CHECK DATA
2248			THEN ERRCAS(1,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
2249		IF LOOP_CHK(6) THEN				!IS LOOP ON ERROR SET
2250			LEAVE BLOCK6 WITH 1;			!LEAVE BLOCK TO LOOP
2251		0						!TO ILLUMINATE BLISS INFO COMMENT
2252	
2253		END;
2254		MOD_FLD(3,0);					!MODIFY DATA 
2255		MOD_FLD(4,0);					!TO ZERO
2256		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
2257		DO (0) WHILE
2258	BLOCK7:	BEGIN
2259		CP(3);						!GIVE 3 CLOCKS
2260		RCVDATA = EM(0);				!GET DATA
2261		IF .RCVDATA NEQ 0				!CHECK DATA
2262			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
2263		IF LOOP_CHK(7)
2264			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
2265		0						!TO ILLUMINATE BLISS INFO COMMENT
2266	
2267		END;
2268		MOD_FLD(3,%O'7777');				!MODIFY DATA 
2269		MOD_FLD(4,%O'77');				!TO 777777
2270		ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
2271		DO (0) WHILE
2272	BLOCK8:	BEGIN
2273		CP(3);						!GIVE 3 CLOCKS
2274		RCVDATA = EM(0);				!GET DATA
2275		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
2276			THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
2277		IF LOOP_CHK(8)
2278			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
2279		0						!TO ILLUMINATE BLISS INFO COMMENT
2280	
2281		END;
2282		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TYPE TO LEFT
2283		ER_TAB[1] = 5;					!FOR ERROR PRINTOUT
2284		DO (0) WHILE
2285	BLOCK9:	
2286		BEGIN
2287		CP(3);						!GIVE 3 CLOCKS
2288		RCVDATA = EM(0);				!GET DATA
2289		IF .RCVDATA NEQ %O'777777777776'		!CHECK DATA
2290			THEN ERRCAS(1,1,%O'777777777776',.RCVDATA,12,ER_TAB);!NO
2291		IF LOOP_CHK(9)
2292			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
2293		0						!TO ILLUMINATE BLISS INFO COMMENT
2294	
2295		END;
2296		MOD_FLD(3,0);					!MODIFY DATA
2297		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
2298		MOD_FLD(4,0);					!TO 0
2299		DO (0) WHILE
2300	BLOCK10:BEGIN
2301		CP(3);						!GIVE 3 CLOCKS
2302		RCVDATA = EM(0);				!GET DATA
2303		IF .RCVDATA NEQ 0
2304			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
2305		IF LOOP_CHK(10)
2306			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
2307		0						!TO ILLUMINATE BLISS INFO COMMENT
2308	
2309		END;
2310	!*MESSAGE 1
2311	!*	2901'S TEST
2312	!*STIMULUS:
2313	!*	LOAD THE Q REGISTER WITH 252525252525
2314	!*	WRITE A \U0 INTO THE 2901'S SELECTING DEST = \O1
2315	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2316	!*	THEN OUTPUT THE CONTENTS OF REGISTER \S2 INTO MEM 0.\S3
2317	!*RESPONSE:
2318	!*	EXAMINE THE DATA FROM MEM 0
2319	!]ERROR 1
2320	!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA SHIFT NTWK
2321		END;
2322	
2323	GLOBAL ROUTINE TST9: NOVALUE =
2324	
2325	!THIS TEST CKECKS OUT THE 2 LSB BITS AND 2 INPUT AND OUTPUT PINS ON 
2326	!THE LEFT END OF THE 2901'S AND ALL THE 2901'S RAM REGISTERS.
2327	!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
2328	!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT LEFT 3
2329	!	    SHIFT RIGHT 3.
2330	!	2 - WRITE 300000300000 INTO THE SELECTED REGISTER THEN SHIFT LEFT 3, SHIFT RIGHT 3.
2331	!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
2332	!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
2333	!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2334	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2335	!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
2336	!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
2337	!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
2338	!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
2339	!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
2340	!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
2341	!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
2342	!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
2343	!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
2344	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2345	
2346		BEGIN
2347		LABEL BLOCK1,BLOCK2;
2348		BIND
2349		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
2350				U_J(3) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
2351				U_J(4) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
2352				U_J(5) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
2353				U_J(6) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
2354				U_J(7) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
2355				U_J(10) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
2356				U_J(11) U_MEM U_N(11012) U,
2357				U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
2358		LOAD_U(1,POINTER);				!LOAD 9 INSTRUCTIONS
2359	    INCR I FROM 0 TO %O'17' DO
2360		BEGIN
2361		ER_TAB[0] = .I;					!SET UP FOR ERROR PRINTPUT
2362		ER_TAB[1] = 0;					!SET UP FOR ERROR PRINTPUT
2363		LC(11);						!LOAD CRAM ADRS 11
2364		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2365		LC(7);						!LOAD CRM ADRS 7
2366		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2367		LC(6);						!LOAD CRAM ADRS 6
2368		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2369		LC(5);						!LOAD CRAM ADRS 5
2370		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2371		LC(4);						!LOAD CRAM ADRS 4
2372		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2373		LC(3);						!LOAD CRAM ADRS 3
2374		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2375		LC(2);						!LOAD CRAM ADRS 2
2376		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2377		LC(1);						!LOAD CRAM ADRS 1
2378		MOD_FLD(6,%O'6060' OR .I);			!MODIFY B FIELD
2379		MOD_FLD(4,0);					!MODIFY DATA TO 0
2380		DO (0) WHILE
2381	BLOCK1:	
2382		BEGIN
2383		CP(9);						!GIVE 9 CLOCKS
2384		RCVDATA = EM(0);				!GET DATA FROM MEM
2385		IF .RCVDATA NEQ 0				!CHECK DATA
2386			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
2387		IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
2388			LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
2389		0						!TO ILLUMINATE BLISS INFO COMMENT
2390	
2391		END;
2392		MOD_FLD(4,%O'30');				!MODIFY DATA 300000300000
2393		ER_TAB[1] = %O'300000300000';			!SET UP FOR ERROR PRINTPUT
2394		DO (0) WHILE
2395	BLOCK2:	
2396		BEGIN
2397		CP(9);						!GIVE 9 CLOCKS
2398		RCVDATA = EM(0);				!GET DATA FROM MEM
2399		IF .RCVDATA NEQ %O'700000300000'		!CHECK DATA
2400			THEN ERRCAS(1,1,%O'700000300000',.RCVDATA,12,ER_TAB);   !NO
2401		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
2402			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
2403		0						!TO ILLUMINATE BLISS INFO COMMENT
2404	
2405		END;
2406		END;
2407	!*MESSAGE 1
2408	!*	2901'S TEST
2409	!*STIMULUS:
2410	!*	LOAD 2901'S REGISTER \O0 WITH \U1
2411	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2412	!*	SHIFT LEFT 3, SHIFT RIGHT 3
2413	!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
2414	!*RESPONSE:
2415	!*	READ THE DATA FROM MEM 0
2416	!]ERROR 1
2417	!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA SHIFT NTWK
2418		END;
2419	
2420	GLOBAL ROUTINE TST10: NOVALUE =
2421	
2422	!THIS TEST CKECKS OUT THE 2 MSB BITS AND 2 INPUT AND OUTPUT PINS ON 
2423	!THE RIGHT END OF THE 2901'S AND ALL THE 2901'S RAM REGISTERS.
2424	!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
2425	!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT RIGHT 3
2426	!	    SHIFT LEFT 3.
2427	!	2 - WRITE 6000006 INTO THE SELECTED REGISTER THEN  SHIFT RIGHT 3, SHIFT LEFT 3.
2428	!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
2429	!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
2430	!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2431	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2432	!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
2433	!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
2434	!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
2435	!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
2436	!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
2437	!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
2438	!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
2439	!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
2440	!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
2441	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2442	
2443		BEGIN
2444		LABEL BLOCK1,BLOCK2;
2445		BIND
2446		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
2447				U_J(3) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
2448				U_J(4) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
2449				U_J(5) U_ALU_OR U_LSRC_0B U_DEST_AD_DIV2 U,
2450				U_J(6) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
2451				U_J(7) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
2452				U_J(10) U_ALU_OR U_LSRC_0B U_DEST_AD_MUL2 U,
2453				U_J(11) U_MEM U_N(11012) U,
2454				U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
2455		LOAD_U(1,POINTER);				!LOAD 11 INSTRUCTIONS
2456	    INCR I FROM 0 TO %O'17' DO
2457		BEGIN
2458		ER_TAB[0] = .I;					!SET UP FOR ERROR PRINTPUT
2459		ER_TAB[1] = 0;					!SET UP FOR ERROR PRINTPUT
2460		LC(11);						!LOAD CRAM ADRS 11
2461		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2462		LC(7);						!LOAD CRM ADRS 7
2463		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2464		LC(6);						!LOAD CRAM ADRS 6
2465		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2466		LC(5);						!LOAD CRAM ADRS 5
2467		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2468		LC(4);						!LOAD CRAM ADRS 4
2469		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2470		LC(3);						!LOAD CRAM ADRS 3
2471		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2472		LC(2);						!LOAD CRAM ADRS 2
2473		MOD_FLD(6,%O'2060' OR .I);			!MODIFY B FIELD
2474		LC(1);						!LOAD CRAM ADRS 1
2475		MOD_FLD(6,%O'6060' OR .I);			!MODIFY B FIELD
2476		MOD_FLD(3,0);					!MODIFY DATA TO 0
2477		DO (0) WHILE
2478	BLOCK1:	
2479		BEGIN
2480		CP(9);						!GIVE 9 CLOCKS
2481		RCVDATA = EM(0);				!GET DATA FROM MEM
2482		IF .RCVDATA NEQ 0				!CHECK DATA
2483			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
2484		IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
2485			LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
2486		0						!TO ILLUMINATE BLISS INFO COMMENT
2487	
2488		END;
2489		MOD_FLD(3,6);					!MODIFY DATA 6000006
2490		ER_TAB[1] = %O'6000006';			!SET UP FOR ERROR PRINTPUT
2491		DO (0) WHILE
2492	BLOCK2:	
2493		BEGIN
2494		CP(9);						!GIVE 9 CLOCKS
2495		RCVDATA = EM(0);				!GET DATA FROM MEM
2496		IF .RCVDATA NEQ %O'6000006'			!CHECK DATA
2497			THEN ERRCAS(1,1,%O'6000006',.RCVDATA,12,ER_TAB);   !NO
2498		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
2499			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
2500		0						!TO ILLUMINATE BLISS INFO COMMENT
2501	
2502		END;
2503		END;
2504	!*MESSAGE 1
2505	!*	2901'S TEST
2506	!*STIMULUS:
2507	!*	LOAD 2901'S REGISTER \O0 WITH \U1
2508	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2509	!*	SHIFT RIGHT 3, SHIFT LEFT 3
2510	!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
2511	!*RESPONSE:
2512	!*	READ THE DATA FROM MEM 0
2513	!]ERROR 1
2514	!]DBMDBUS DBUSSEL M2901S DPCLKS SHIFT MEMVMA NTWK
2515		END;
2516	
2517	GLOBAL ROUTINE TST11: NOVALUE =
2518	
2519	!THIS TEST CKECKS OUT THE Q SHIFTER IN THE 2901'S (ONLY 36 BITS).
2520	!WE PASS 2 DATA WORDS ONE AT A TIME TO THE Q REGISTER,THEN THE DATA 
2521	!IS  SHIFTED LEFT AND BACK INTO THE Q REGISTER,FINALLY PASS THE DATA
2522	!OUT INTO MEM ZERO THROUGH PORT B.WE PASS THE SAME TWO DATA WORDS SHITED
2523	!RIGHT GOING THROUGH THE SAME SEQUENCE OF EXECUTION. WE EXECUTE FOUR
2524	!INSTRUCTIONS FOR EACH DATA SHIFT PASS THE FOUR INSTRUCTIONS RESIDE IN 
2525	!CRAM 2,3,4 & 5.ALL EXPECTED  DATA IS READ FROM MEM 0.
2526	!THE THREE INSTRUCTIONS DO THE FOLLOWING:
2527	!CRAM 2/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2528	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2529	!	 CONTENTS OF THE DATA BUS INTO THE Q REGISTER
2530	!CRAM 3/ SHIFT THE Q REGISTER (LEFT/RIGHT).
2531	!CRAM 4/ START A PHYSICAL MEMORY WRITE CYCLE.
2532	!CRAM 5/ OUTPUT THE CONTENTS OF THE Q REGISTER INTO THE DP THROUGH
2533	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2534		BEGIN
2535		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
2536		      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
2537		BIND
2538		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(252525) U,
2539				U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(252525) U,
2540				U_J(4) U_ALU_OR U_DEST_Q_MUL2 U,
2541				U_J(5) U_MEM U_N(11012) U,
2542				U_J(1) U_ALU_OR U_LSRC_0B U_MEM U_N(2) U);
2543		LOAD_U(1,POINTER);				!LOAD 5 INSTRUCTIONS
2544	
2545		SET_C(1);					!SET CRAM ADRS TO 1
2546		ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
2547		ER_TAB[1] = 4;					!FOR ERROR PRINTOUT
2548		ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
2549		DO (0) WHILE
2550	BLOCK1:	
2551		BEGIN
2552		CP(5);						!GIVE 5 CLOCKS
2553		RCVDATA = EM(0);				!GET DATA FROM MEM
2554		IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
2555			THEN ERRCAS(2,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
2556		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
2557			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
2558		0						!TO ILLUMINATE BLISS INFO COMMENT
2559	
2560		END;
2561		LC(5);						!LOAD CRAM ADRS 5
2562		MOD_FLD(5,%O'3227');				!MODIFY TO OUPUT Q
2563		MOD_FLD(0,3);					!MODIFY J FIELD
2564		SET_C(2);					!SET CRAM ADRS TO 2
2565		ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
2566		DO (0) WHILE
2567	BLOCK2:	BEGIN
2568		CP(4);						!GIVE 4 CLOCKS
2569		RCVDATA = EM(0);				!GET DATA
2570		IF .RCVDATA NEQ %O'525252525252'		!CHECK DATA
2571			THEN ERRCAS(2,1,%O'525252525252',.RCVDATA,12,ER_TAB);!NO
2572		IF LOOP_CHK(2)
2573			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
2574		0						!TO ILLUMINATE BLISS INFO COMMENT
2575	
2576		END;
2577		MOD_FLD(3,%O'5252');				!MODIFY DATA IN # FIELD
2578		MOD_FLD(4,%O'52');				!HERE TOO
2579		ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
2580		DO (0) WHILE
2581	BLOCK3:	
2582		BEGIN
2583		CP(4);						!GIVE 4 CLOCKS
2584		RCVDATA = EM(0);				!GET DATA FROM MEM
2585		IF .RCVDATA NEQ %O'252525252524'		!CHECK DATA
2586			THEN ERRCAS(2,1,%O'252525252524',.RCVDATA,12,ER_TAB);!NO
2587		IF LOOP_CHK(3) THEN				!IS LOOP ON ERROR SET
2588			LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
2589		0						!TO ILLUMINATE BLISS INFO COMMENT
2590	
2591		END;
2592		DM(0,0);					!CLEAR MEMORY
2593		LC(3);						!LOAD CRAM ADRS 3
2594		MOD_FLD(7,%O'4600');				!MODIFY SHIFT TYPE
2595		LC(5);						!LOAD CRAM ADRS 5
2596		MOD_FLD(5,%O'3337');				!OUTPUT B
2597		MOD_FLD(0,2);					!MODIFY J FIELD
2598		ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
2599		ER_TAB[1] = 6;					!FOR ERROR PRINTOUT
2600		ER_TAB[2] = UPLIT (%ASCIZ'0');			!FOR ERROR PRINTOUT
2601		SET_C(1);					!SET CRAM ADRS TO 1
2602		DO (0) WHILE
2603	BLOCK4:	
2604		BEGIN
2605		CP(5);						!GIVE 5 CLOCKS
2606		RCVDATA = EM(0);				!GET DATA FROM MEM
2607		IF .RCVDATA NEQ %O'125252525252'		!CHECK DATA
2608			THEN ERRCAS(2,1,%O'125252525252',.RCVDATA,12,ER_TAB);	!NO
2609		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
2610			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
2611		0						!TO ILLUMINATE BLISS INFO COMMENT
2612	
2613		END;
2614		LC(5);						!LOAD CRAM ADRS 5
2615		MOD_FLD(5,%O'3227');				!MODIFY TO OUTPUT Q
2616		MOD_FLD(0,3);					!MODIFY J FIELD
2617		ER_TAB[0] = %O'525252525252';			!FOR ERROR PRINTOUT
2618		ER_TAB[2] = UPLIT (%ASCIZ'Q');			!FOR ERROR PRINTOUT
2619		SET_C(2);					!SET CRAM ADRS TO 2
2620		DO (0) WHILE
2621	BLOCK5:	BEGIN
2622		CP(4);						!GIVE 4 CLOCKS
2623		RCVDATA = EM(0);				!GET DATA
2624		IF .RCVDATA NEQ %O'652525252525'		!CHECK DATA
2625			THEN ERRCAS(2,1,%O'652525252525',.RCVDATA,12,ER_TAB);!NO
2626		IF LOOP_CHK(5)
2627			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
2628		0						!TO ILLUMINATE BLISS INFO COMMENT
2629	
2630		END;
2631		MOD_FLD(3,%O'2525');				!MODIFY DATA IN # FIELD
2632		MOD_FLD(4,%O'25');				!HERE TOO
2633		ER_TAB[0] = %O'252525252525';			!FOR ERROR PRINTOUT
2634		DO (0) WHILE
2635	BLOCK6:	
2636		BEGIN
2637		CP(4);						!GIVE 4 CLOCKS
2638		RCVDATA = EM(0);				!GET DATA FROM MEM
2639		IF .RCVDATA NEQ %O'125252525252'		!CHECK DATA
2640			THEN ERRCAS(2,1,%O'125252525252',.RCVDATA,12,ER_TAB);!NO
2641		IF LOOP_CHK(6)
2642			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
2643		0						!TO ILLUMINATE BLISS INFO COMMENT
2644	
2645		END;
2646		MOD_FLD(3,0);					!MODIFY DATA 
2647		MOD_FLD(4,0);					!TO ZERO
2648		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
2649		DO (0) WHILE
2650	BLOCK7:	BEGIN
2651		CP(4);						!GIVE 4 CLOCKS
2652		RCVDATA = EM(0);				!GET DATA
2653		IF .RCVDATA NEQ 0				!CHECK DATA
2654			THEN ERRCAS(2,1,0,.RCVDATA,12,ER_TAB);	!NO
2655		IF LOOP_CHK(7)
2656			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
2657		0						!TO ILLUMINATE BLISS INFO COMMENT
2658	
2659		END;
2660		MOD_FLD(3,%O'7777');				!MODIFY DATA 
2661		MOD_FLD(4,%O'77');				!TO 777777
2662		ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
2663		DO (0) WHILE
2664	BLOCK8:	BEGIN
2665		CP(4);						!GIVE 4 CLOCKS
2666		RCVDATA = EM(0);				!GET DATA
2667		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
2668			THEN ERRCAS(2,1,%O'-1',.RCVDATA,12,ER_TAB);	!NO
2669		IF LOOP_CHK(8)
2670			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
2671		0						!TO ILLUMINATE BLISS INFO COMMENT
2672	
2673		END;
2674		LC(3);						!LOAD CRAM ADRS 3
2675		MOD_FLD(7,%O'4400');				!MODIFY SHIFT TYPE TO LEFT
2676		SET_C(2);					!SET CRAM ADRS TO 2
2677		ER_TAB[1] = 4;					!FOR ERROR PRINTOUT
2678		DO (0) WHILE
2679	BLOCK9:BEGIN
2680		CP(4);						!GIVE 3 CLOCKS
2681		RCVDATA = EM(0);				!GET DATA
2682		IF .RCVDATA NEQ %O'777777777776'		!CHECK DATA
2683			THEN ERRCAS(2,1,%O'777777777776',.RCVDATA,12,ER_TAB);	!NO
2684		IF LOOP_CHK(9)
2685			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
2686		0						!TO ILLUMINATE BLISS INFO COMMENT
2687	
2688		END;
2689		MOD_FLD(3,0);					!MODIFY DATA
2690		MOD_FLD(4,0);					!TO 0
2691		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
2692		DO (0) WHILE
2693	BLOCK10:BEGIN
2694		CP(4);						!GIVE 4 CLOCKS
2695		RCVDATA = EM(0);				!GET DATA
2696		IF .RCVDATA NEQ 0				!CHECK DATA
2697			THEN ERRCAS(2,1,0,.RCVDATA,12,ER_TAB);	!NO
2698		IF LOOP_CHK(10)
2699			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
2700		0						!TO ILLUMINATE BLISS INFO COMMENT
2701	
2702		END;
2703	!*MESSAGE 1
2704	!*	2901'S TEST
2705	!*STIMULUS:
2706	!*	WRITE A \U0 INTO THE 2901'S REGISTER \S2 SELECTING DEST = \O1
2707	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2708	!*	THEN OUTPUT THE CONTENTS OF REGISTER \S2 INTO MEM 0.
2709	!*RESPONSE:
2710	!*	EXAMINE THE DATA FROM MEM 0
2711	!]ERROR 1
2712	!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA NTWK
2713	!]ERROR 2
2714	!]DBMDBUS DBUSSEL M2901S DPCLKS MEMVMA SHIFT NTWK
2715		END;
2716	
2717	GLOBAL ROUTINE TST12: NOVALUE =
2718	
2719	!THIS TEST CKECKS OUT THE 2 LSB BITS OF THE Q REGISTER.
2720	!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
2721	!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT LEFT 3
2722	!	    SHIFT RIGHT 3.
2723	!	2 - WRITE 300000300000 INTO THE SELECTED REGISTER THEN SHIFT LEFT 3, SHIFT RIGHT 3.
2724	!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
2725	!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
2726	!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2727	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2728	!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
2729	!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
2730	!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
2731	!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT)
2732	!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
2733	!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
2734	!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT).
2735	!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
2736	!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
2737	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2738	
2739		BEGIN
2740		LABEL BLOCK1,BLOCK2;
2741		BIND
2742		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U,
2743				U_J(3) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
2744				U_J(4) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
2745				U_J(5) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
2746				U_J(6) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
2747				U_J(7) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
2748				U_J(10) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
2749				U_J(11) U_MEM U_N(11012) U,
2750				U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
2751		LOAD_U(1,POINTER);				!LOAD 11 INSTRUCTIONS
2752		SET_C(1);					!SET CRAM ADRS TO 1
2753		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
2754		DO (0) WHILE
2755	BLOCK1:	
2756		BEGIN
2757		CP(9);						!GIVE 9 CLOCKS
2758		RCVDATA = EM(0);				!GET DATA FROM MEM
2759		IF .RCVDATA NEQ 0				!CHECK DATA
2760			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
2761		IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
2762		LEAVE BLOCK1 WITH 1;				!LEAVE BLOCK TO LOOP
2763		0						!TO ILLUMINATE BLISS INFO COMMENT
2764	
2765		END;
2766		MOD_FLD(4,%O'30');				!MODIFY DATA 300000300000
2767		ER_TAB[0] = %O'300000300000';			!FOR ERROR PRINTOUT
2768		DO (0) WHILE
2769	BLOCK2:	
2770		BEGIN
2771		CP(9);						!GIVE 9 CLOCKS
2772		RCVDATA = EM(0);				!GET DATA FROM MEM
2773		IF .RCVDATA NEQ %O'300000300000'			!CHECK DATA
2774			THEN ERRCAS(1,1,%O'300000300000',.RCVDATA,12,ER_TAB);   !NO
2775		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
2776			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
2777		0						!TO ILLUMINATE BLISS INFO COMMENT
2778	
2779		END;
2780	!*MESSAGE 1
2781	!*	2901'S TEST
2782	!*STIMULUS:
2783	!*	LOAD 2901'S Q REGISTER WITH \U0
2784	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2785	!*	SHIFT LEFT 3, SHIFT RIGHT 3
2786	!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
2787	!*RESPONSE:
2788	!*	READ THE DATA FROM MEM 0
2789	!]ERROR 1
2790	!]DBMDBUS DBUSSEL M2901S DPCLKS SHIFT MEMVMA NTWK
2791		END;
2792	
2793	
2794	GLOBAL ROUTINE TST13: NOVALUE =
2795	
2796	!THIS TEST CKECKS OUT THE 2 MSB BITS OF THE Q REGISTER.
2797	!WE ENTER A LOOP 17 WHICH DOES THE FOLLOWING FOR EACH LOOP PASS:
2798	!	1 - WRITE A ZERO INTO THE SELECTED REGISTER THEN SHIFT RIGHT 3
2799	!	    SHIFT LEFT 3.
2800	!	2 - WRITE 6000006 INTO THE SELECTED REGISTER THEN  SHIFT RIGHT 3, SHIFT LEFT 3.
2801	!INSTRUCTIONS EXECUTED RESIDE IN CRAM 1,2,3,4,5,6,7,10 & 11.ALL EXPECTED 
2802	!DATA IS READ FROM MEM 0.INSTRUCTIONS EXECUTED DO THE FOLLOWING:
2803	!CRAM 1/ PUT THE DATA IN THE MAGIC # FIELD, PASS THE # FIELD TO THE DBM
2804	!	 MUX,PASS THE OUTPUT OF THE DBM MUX INTO THE DBUS MUX, WRITE THE
2805	!	 CONTENTS OF THE DATA BUS INTO THE SELECTED REGISTER  .
2806	!CRAM 2/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
2807	!CRAM 3/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
2808	!CRAM 4/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (RIGHT)
2809	!CRAM 5/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
2810	!CRAM 6/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
2811	!CRAM 7/ SHIFT THE CONTENTS OF THE SELECTED REGISTER (LEFT).
2812	!CRAM 10/ START A PHYSICAL MEMORY WRITE CYCLE.
2813	!CRAM 11/ OUTPUT THE CONTENTS OF THE SELECTED REGISTER INTO THE DP THROUGH
2814	!	 THE B PORT, WRITE THE DP INTO PHYSICAL MEM.
2815	
2816		BEGIN
2817		LABEL BLOCK1,BLOCK2;
2818		BIND
2819		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U,
2820				U_J(3) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
2821				U_J(4) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
2822				U_J(5) U_ALU_OR U_LSRC_0Q U_DEST_Q_DIV2 U,
2823				U_J(6) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
2824				U_J(7) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
2825				U_J(10) U_ALU_OR U_LSRC_0Q U_DEST_Q_MUL2 U,
2826				U_J(11) U_MEM U_N(11012) U,
2827				U_J(1) U_ALU_OR U_LSRC_0Q U_MEM U_N(2) U);
2828		LOAD_U(1,POINTER);				!LOAD 9 INSTRUCTIONS
2829		SET_C(1);					!SET CRAM ADRS TO 1
2830		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
2831		DO (0) WHILE
2832	BLOCK1:	
2833		BEGIN
2834		CP(9);						!GIVE 9 CLOCKS
2835		RCVDATA = EM(0);				!GET DATA FROM MEM
2836		IF .RCVDATA NEQ 0				!CHECK DATA
2837			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
2838		IF LOOP_CHK(1) THEN				!IS LOOP ON ERROR SET
2839		LEAVE BLOCK1 WITH 1;				!LEAVE BLOCK TO LOOP
2840		0						!TO ILLUMINATE BLISS INFO COMMENT
2841	
2842		END;
2843		MOD_FLD(3,6);					!MODIFY DATA 6000006
2844		ER_TAB[0] = %O'6000006';			!FOR ERROR PRINTOUT
2845		DO (0) WHILE
2846	BLOCK2:	
2847		BEGIN
2848		CP(9);						!GIVE 9 CLOCKS
2849		RCVDATA = EM(0);				!GET DATA FROM MEM
2850		IF .RCVDATA NEQ %O'6000006'			!CHECK DATA
2851			THEN ERRCAS(1,1,%O'6000006',.RCVDATA,12,ER_TAB);!NO
2852		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET
2853			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
2854		0						!TO ILLUMINATE BLISS INFO COMMENT
2855	
2856		END;
2857	!*MESSAGE 1
2858	!*	2901'S TEST
2859	!*STIMULUS:
2860	!*	LOAD 2901'S Q REGISTER WITH \U0
2861	!*	FROM THE MAGIC # FIELD VIA DBUS & DBM
2862	!*	SHIFT RIGHT 3, SHIFT LEFT 3
2863	!*	THEN WRITE IT OUT TO MEM 0 THROUGH PORT B
2864	!*RESPONSE:
2865	!*	READ THE DATA FROM MEM 0
2866	!]ERROR 1
2867	!]DBMDBUS DBUSSEL M2901S DPCLKS SHIFT MEMVMA NTWK
2868		END;
2869	
2870	GLOBAL ROUTINE TST14: NOVALUE =
2871	
2872	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  OR  S ) .
2873	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
2874	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
2875	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
2876	!GLOBAL ROUTINE FUNC_LD).
2877	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
2878	!THREE DATA SETS ARE TESTED FOR THE OR FUNCTION :
2879	!	0   OR   -1
2880	!	-1  OR    0
2881	!	0   OR    0
2882	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
2883	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
2884	
2885		BEGIN
2886		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
2887		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
2888		LC(5);						!LOAD CRAM ADRS 5
2889		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
2890		LC(4);						!LOAD CRAM ADRS 4
2891		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO 0A AND FUNCTION TO OR
2892		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
2893		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
2894		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
2895		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
2896		DO (0) WHILE
2897	BLOCK1:	BEGIN
2898		DM(0,0);					!CLEAR MEM
2899		CP(3);						!GIVE 3 CLOCKS
2900		RCVDATA = EM(0);				!GET DATA
2901		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
2902		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
2903			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
2904		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
2905			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
2906		0						!TO ILLUMINATE BLISS INFO COMMENT
2907	
2908		END;
2909		LC(5);						!LOAD CRAM ADRS 5
2910		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
2911		LC(4);						!LOAD CRAM ADRS 4
2912		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
2913		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
2914		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
2915		DO (0) WHILE
2916	BLOCK2:	BEGIN
2917		DM(0,0);					!CLEAR MEM
2918		CP(3);						!GIVE 3 CLOCKS
2919		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
2920		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
2921			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
2922		IF LOOP_CHK(2)
2923			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
2924		0						!TO ILLUMINATE BLISS INFO COMMENT
2925	
2926		END;
2927		MOD_FLD(5,%O'3007');				!MODIFY LSRC TO AQ
2928		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
2929		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
2930		DO (0) WHILE
2931	BLOCK3:	BEGIN
2932		DM(0,0);					!CLEAR MEM
2933		CP(3);						!GIVE 3 CLOCKS
2934		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
2935		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
2936			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
2937		IF LOOP_CHK(3)
2938			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
2939		0						!TO ILLUMINATE BLISS INFO COMMENT
2940	
2941		END;
2942		LC(5);						!LOAD CRAM ADRS 5
2943		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
2944		LC(4);						!LOAD CRAM ADRS 4
2945		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
2946		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
2947		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
2948		DO (0) WHILE
2949	BLOCK4:	BEGIN
2950		DM(0,0);					!CLEAR MEM
2951		CP(3);						!GIVE 3 CLOCKS
2952		RCVDATA = EM(0);				!GET DATA
2953		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
2954		IF .RCVDATA NEQ %O'7777776'			!CHECK DADA ?
2955			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
2956		IF LOOP_CHK(4)
2957			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
2958		0						!TO ILLUMINATE BLISS INFO COMMENT
2959	
2960		END;
2961		MOD_FLD(5,%O'3227');				!MODIFY THE LSRC TO 0Q
2962		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
2963		DO (0) WHILE
2964	BLOCK5:	BEGIN
2965		DM(0,%O'-1');					!SET MEM TO -1
2966		CP(3);						!GIVE 3 CLOCKS
2967		RCVDATA = EM(0);				!GET DATA
2968		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
2969		IF .RCVDATA NEQ 0				!CHECK DATA ?
2970			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
2971		IF LOOP_CHK(5)
2972			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
2973		0						!TO ILLUMINATE BLISS INFO COMMENT
2974	
2975		END;
2976		LC(5);						!LOAD CRAM ADRS 5
2977		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
2978		LC(4);						!LOAD CRAM ADRS 4
2979		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
2980		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
2981		DO (0) WHILE
2982	BLOCK6:	BEGIN
2983		DM(0,%O'-1');					!CLEAR MEM
2984		CP(3);						!GIVE 3 CLOCKS
2985		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
2986		IF .RCVDATA NEQ 0				!CHECK DATA ?
2987			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
2988		IF LOOP_CHK(6)
2989			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
2990		0						!TO ILLUMINATE BLISS INFO COMMENT
2991	
2992		END;
2993	!*MESSAGE 1
2994	!*	ALU FUNC (R OR S) :
2995	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
2996	!*	MAGIC # FIELD VIA DBUS & DBM
2997	!*	FOR THE \S2 20 BITS OF THE 2901'S
2998	!*	\S0    OR    \S1
2999	!*	THEN WRITE THE DATA OUT TO MEM 0
3000	!*RESPONSE:
3001	!*	EXAMINE DATA FROM MEM 0
3002	!]ERROR 1
3003	!]M2901S DPCLKS SHIFT DBMDBUS DBUSSEL MEMVMA NTWK
3004		END;
3005	
3006	GLOBAL ROUTINE TST15: NOVALUE =
3007	
3008	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  +  S ) .
3009	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
3010	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
3011	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
3012	!GLOBAL ROUTINE FUNC_LD).
3013	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
3014	!FOUR DATA SETS ARE TESTED FOR THE ( + ) FUNCTION :
3015	!	0   +   -1
3016	!      -1   +    0
3017	!	0   +    0
3018	!      -1   +   -1
3019	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
3020	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
3021	
3022		BEGIN
3023		OWN TEST_FLG;
3024		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
3025		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
3026		TEST_FLG = 0;
3027		LC(5);						!LOAD CRAM ADRS 5
3028		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3029		LC(4);						!LOAD CRAM ADRS 4
3030		MOD_FLD(5,%O'447');				!MODIFY LSRC TO 0A AND FUNCTION TO ( + )
3031		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3032		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3033		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3034		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3035		DO (0) WHILE
3036	BLOCK1:	BEGIN
3037		DM(0,0);					!CLEAR MEM
3038		CP(3);						!GIVE 3 CLOCKS
3039		RCVDATA = EM(0);				!GET DATA
3040		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
3041		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
3042			THEN BEGIN
3043				ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
3044				TEST_FLG = 1;
3045			     END;
3046		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
3047			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
3048		0						!TO ILLUMINATE BLISS INFO COMMENT
3049	
3050		END;
3051		LC(5);						!LOAD CRAM ADRS 5
3052		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3053		LC(4);						!LOAD CRAM ADRS 4
3054		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3055		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3056		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3057		DO (0) WHILE
3058	BLOCK2:	BEGIN
3059		DM(0,0);					!CLEAR MEM
3060		CP(3);						!GIVE 3 CLOCKS
3061		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3062		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
3063			THEN BEGIN
3064				ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);!NO
3065				TEST_FLG = 1;
3066			     END;
3067		IF LOOP_CHK(2)
3068			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
3069		0						!TO ILLUMINATE BLISS INFO COMMENT
3070	
3071		END;
3072		MOD_FLD(5,7);					!MODIFY LSRC TO AQ
3073		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3074		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3075		DO (0) WHILE
3076	BLOCK3:	BEGIN
3077		DM(0,0);					!CLEAR MEM
3078		CP(3);						!GIVE 3 CLOCKS
3079		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3080		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
3081			THEN BEGIN
3082				ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);!NO
3083				TEST_FLG = 1;
3084			     END;
3085		IF LOOP_CHK(3)
3086			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
3087		0						!TO ILLUMINATE BLISS INFO COMMENT
3088	
3089		END;
3090		LC(5);						!LOAD CRAM ADRS 5
3091		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3092		LC(4);						!LOAD CRAM ADRS 4
3093		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3094		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3095		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3096		DO (0) WHILE
3097	BLOCK4:	BEGIN
3098		DM(0,0);					!CLEAR MEM
3099		CP(3);						!GIVE 3 CLOCKS
3100		RCVDATA = EM(0);				!GET DATA
3101		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3102		IF .RCVDATA NEQ %O'7777776'			!CHECK DADA ?
3103			THEN BEGIN
3104				ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);!NO
3105				TEST_FLG = 1;
3106			     END;
3107		IF LOOP_CHK(4)
3108			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
3109		0						!TO ILLUMINATE BLISS INFO COMMENT
3110	
3111		END;
3112		MOD_FLD(5,%O'227');				!MODIFY THE LSRC TO 0Q
3113		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3114	BLOCK5:	BEGIN
3115		DM(0,%O'-1');					!SET MEM TO -1
3116		CP(3);						!GIVE 3 CLOCKS
3117		RCVDATA = EM(0);				!GET DATA
3118		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3119		IF .RCVDATA NEQ 0				!CHECK DATA ?
3120			THEN BEGIN
3121				ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3122				TEST_FLG = 1;
3123			     END;
3124		IF LOOP_CHK(5)
3125			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
3126		0						!TO ILLUMINATE BLISS INFO COMMENT
3127	
3128		END;
3129		LC(5);						!LOAD CRAM ADRS 5
3130		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3131		LC(4);						!LOAD CRAM ADRS 4
3132		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3133		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3134		DO (0) WHILE
3135	BLOCK6:	BEGIN
3136		DM(0,%O'-1');					!SET MEM TO -1
3137		CP(3);						!GIVE 3 CLOCKS
3138		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3139		IF .RCVDATA NEQ 0				!CHECK DATA ?
3140			THEN BEGIN
3141				ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3142				TEST_FLG = 1;
3143			     END;
3144		IF LOOP_CHK(6)
3145			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
3146		0						!TO ILLUMINATE BLISS INFO COMMENT
3147	
3148		END;
3149		LC(5);						!LOAD CRAM ADRS 5
3150		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3151		LC(4);						!LOAD CRAM ADRS 4
3152		MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
3153		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3154		CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
3155		MOD_FLD(5,%O'117');				!MODIFY FUNC TO ( + )
3156		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3157		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3158		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3159		DO (0) WHILE
3160	BLOCK7:	BEGIN
3161		DM(0,0);					!CLEAR MEM
3162		CP(3);						!GIVE 3 CLOCKS
3163		RCVDATA = EM(0);				!GET DATA
3164		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3165		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
3166			THEN BEGIN
3167				ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);!NO
3168				TEST_FLG = 1;
3169			    END;
3170		IF LOOP_CHK(7)
3171			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
3172		0						!TO ILLUMINATE BLISS INFO COMMENT
3173	
3174		END;
3175		LC(5);						!LOAD CRAM ADRS 5
3176		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3177		LC(4);						!LOAD CRAM ADRS 4
3178		MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
3179		CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
3180		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3181		MOD_FLD(5,%O'117');				!MODIFY FUNC TO ( + )
3182		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3183		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3184		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3185		DO (0) WHILE
3186	BLOCK8:	BEGIN
3187		DM(0,0);					!CLEAR MEM
3188		CP(3);						!GIVE 3 CLOCKS
3189		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3190		IF .RCVDATA NEQ %O'3777776'			!CHECK DATA ?
3191			THEN ERRCAS(1,1,%O'3777776',.RCVDATA,7,ER_TAB);	!NO
3192		IF LOOP_CHK(8)
3193			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
3194		0						!TO ILLUMINATE BLISS INFO COMMENT
3195	
3196		END;
3197	!*MESSAGE 1
3198	!*	ALU FUNC (R + S) :
3199	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
3200	!*	MAGIC # FIELD VIA DBUS & DBM
3201	!*	FOR THE \S2 20 BITS OF THE 2901'S
3202	!*	\S0    +    \S1
3203	!*	THEN WRITE THE DATA OUT TO MEM 0
3204	!*RESPONSE:
3205	!*	EXAMINE DATA FROM MEM 0
3206	!]ERROR 1
3207	!]M2901S DPCLKS SHIFT DBMDBUS DBUSSEL MEMVMA M2902S SPEC18CRY NTWK
3208		END;
3209	
3210	GLOBAL ROUTINE TST16: NOVALUE =
3211	
3212	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( S  -  R ) .
3213	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
3214	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
3215	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
3216	!GLOBAL ROUTINE FUNC_LD).
3217	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
3218	!TWO DATA SETS ARE TESTED FOR THE (S - R) FUNCTION :
3219	!	0   -   -1
3220	!	-1  -    0
3221	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
3222	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
3223	
3224		BEGIN
3225		OWN TEST_FLG;
3226		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4;
3227		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
3228		LC(5);						!LOAD CRAM ADRS 5
3229		TEST_FLG = 0;
3230		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3231		LC(4);						!LOAD CRAM ADRS 4
3232		MOD_FLD(5,%O'1447');				!MODIFY LSRC TO 0A AND FUNCTION TO S-R
3233		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3234		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3235		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3236		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3237		DO (0) WHILE
3238	BLOCK1:	BEGIN
3239		DM(0,0);					!CLEAR MEM
3240		CP(3);						!GIVE 3 CLOCKS
3241		RCVDATA = EM(0);				!GET DATA
3242		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
3243		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
3244			THEN BEGIN
3245				ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
3246				TEST_FLG = 1;
3247			     END;
3248		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
3249			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
3250		0						!TO ILLUMINATE BLISS INFO COMMENT
3251	
3252		END;
3253		LC(5);						!LOAD CRAM ADRS 5
3254		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3255		LC(4);						!LOAD CRAM ADRS 4
3256		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3257		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3258		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3259		DO (0) WHILE
3260	BLOCK2:	BEGIN
3261		DM(0,0);					!CLEAR MEM
3262		CP(3);						!GIVE 3 CLOCKS
3263		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3264		IF .RCVDATA NEQ %O'3777776'			!CHECK DATA
3265			THEN BEGIN
3266				ERRCAS(1,1,%O'3777776',.RCVDATA,7,ER_TAB);	!NO
3267				TEST_FLG = 1;
3268			     END;
3269		IF LOOP_CHK(2)
3270			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
3271		0						!TO ILLUMINATE BLISS INFO COMMENT
3272	
3273		END;
3274		MOD_FLD(5,%O'1007');				!MODIFY LSRC TO AQ
3275		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3276		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3277		DO (0) WHILE
3278	BLOCK3:	BEGIN
3279		DM(0,%O'-1');					!SET MEM TO -1
3280		CP(3);						!GIVE 3 CLOCKS
3281		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3282		IF .RCVDATA NEQ 0				!CHECK DATA ?
3283			THEN BEGIN
3284				ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3285				TEST_FLG = 1;
3286			     END;
3287		IF LOOP_CHK(3)
3288			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
3289		0						!TO ILLUMINATE BLISS INFO COMMENT
3290	
3291		END;
3292		LC(5);						!LOAD CRAM ADRS 5
3293		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3294		LC(4);						!LOAD CRAM ADRS 4
3295		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3296		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3297		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3298		DO (0) WHILE
3299	BLOCK4:	BEGIN
3300		DM(0,%O'-1');					!SET MEM TO -1
3301		CP(3);						!GIVE 3 CLOCKS
3302		RCVDATA = EM(0);				!GET DATA
3303		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3304		IF .RCVDATA NEQ 0				!CHECK DADA ?
3305			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3306		IF LOOP_CHK(4)
3307			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
3308		0						!TO ILLUMINATE BLISS INFO COMMENT
3309	
3310		END;
3311	!*MESSAGE 1
3312	!*	ALU FUNC (S - R) :
3313	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
3314	!*	MAGIC # FIELD VIA DBUS & DBM
3315	!*	FOR THE \S2 20 BITS OF THE 2901'S
3316	!*	\S0    -    \S1
3317	!*	THEN WRITE OUT TO MEM 0
3318	!*RESPONSE:
3319	!*	EXAMINE DATA FROM MEM 0
3320	!]ERROR 1
3321	!]M2901S DPCLKS SHIFT DBMDBUS DBUSSEL MEMVMA M2902S SPEC18CRY NTWK
3322		END;
3323	
3324	GLOBAL ROUTINE TST17: NOVALUE =
3325	
3326	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  -  S ) .
3327	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
3328	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
3329	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
3330	!GLOBAL ROUTINE FUNC_LD).
3331	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
3332	!TWO DATA SETS ARE TESTED FOR THE (R - S) FUNCTION :
3333	!	0   -    0
3334	!      -1   -   -1
3335	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
3336	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
3337	
3338		BEGIN
3339		OWN TEST_FLG;
3340		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4;
3341		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
3342		TEST_FLG = 0;
3343		LC(5);						!LOAD CRAM ADRS 5
3344		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3345		LC(4);						!LOAD CRAM ADRS 4
3346		MOD_FLD(5,%O'2227');				!MODIFY LSRC TO 0A AND FUNC TO R-S
3347		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3348		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3349		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3350		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3351		DO (0) WHILE
3352	BLOCK1:	BEGIN
3353		DM(0,0);					!CLEAR MEM
3354		CP(3);						!GIVE 3 CLOCKS
3355		RCVDATA = EM(0);				!GET DATA
3356		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3357		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
3358			THEN BEGIN
3359				ERRCAS(1,1,%O'777776',.RCVDATA,7,ER_TAB);	!NO
3360				TEST_FLG = 1;
3361			     END;
3362		IF LOOP_CHK(1)
3363			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
3364		0						!TO ILLUMINATE BLISS INFO COMMENT
3365	
3366		END;
3367		LC(5);						!LOAD CRAM ADRS 5
3368		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3369		LC(4);						!LOAD CRAM ADRS 4
3370		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3371		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3372		DO (0) WHILE
3373	BLOCK2:	BEGIN
3374		DM(0,0);					!CLEAR MEM
3375		CP(3);						!GIVE 3 CLOCKS
3376		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3377		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
3378			THEN BEGIN
3379				ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
3380				TEST_FLG = 1;
3381			     END;
3382		IF LOOP_CHK(2)
3383			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
3384		0						!TO ILLUMINATE BLISS INFO COMMENT
3385	
3386		END;
3387		LC(5);						!LOAD CRAM ADRS 5
3388		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3389		LC(4);						!LOAD CRAM ADRS 4
3390		MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
3391		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3392		CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
3393		MOD_FLD(5,%O'2117');				!MODIFY FUNC TO (R-S)
3394		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3395		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3396		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3397		DO (0) WHILE
3398	BLOCK3:	BEGIN
3399		DM(0,0);					!CLEAR MEM
3400		CP(3);						!GIVE 3 CLOCKS
3401		RCVDATA = EM(0);				!GET DATA
3402		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3403		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
3404			THEN BEGIN
3405				ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
3406				TEST_FLG = 1;
3407			     END;
3408		IF LOOP_CHK(3)
3409			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
3410		0						!TO ILLUMINATE BLISS INFO COMMENT
3411	
3412		END;
3413		LC(5);						!LOAD CRAM ADRS 5
3414		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3415		LC(4);						!LOAD CRAM ADRS 4
3416		MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
3417		CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
3418		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3419		MOD_FLD(5,%O'2117');				!MODIFY FUNC TO (S - R)
3420		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3421		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3422		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3423		DO (0) WHILE
3424	BLOCK4:	BEGIN
3425		DM(0,0);					!CLEAR MEM
3426		CP(3);						!GIVE 3 CLOCKS
3427		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3428		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
3429			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
3430		IF LOOP_CHK(4)
3431			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
3432		0						!TO ILLUMINATE BLISS INFO COMMENT
3433	
3434		END;
3435	!*MESSAGE 1
3436	!*	ALU FUNC (R - S) :
3437	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
3438	!*	MAGIC # FIELD VIA DBUS & DBM
3439	!*	FOR THE \S2 20 BITS OF THE 2901'S
3440	!*	\S0    -    \S1
3441	!*	THEN WRITE THE DATA OUT TO MEM 0
3442	!*RESPONSE:
3443	!*	EXAMINE DATA FROM MEM 0
3444	!]ERROR 1
3445	!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA M2902S SPEC18CRY NTWK
3446		END;
3447	
3448	GLOBAL ROUTINE TST18: NOVALUE =
3449	
3450	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  AND  S ) .
3451	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
3452	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
3453	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
3454	!GLOBAL ROUTINE FUNC_LD).
3455	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
3456	!THREE DATA SETS ARE TESTED FOR THE (AND) FUNCTION :
3457	!	0   AND   -1
3458	!	-1  AND    0
3459	!	-1  AND   -1
3460	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
3461	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
3462	
3463		BEGIN
3464		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
3465		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
3466		LC(5);						!LOAD CRAM ADRS 5
3467		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3468		LC(4);						!LOAD CRAM ADRS 4
3469		MOD_FLD(5,%O'4447');				!MODIFY LSRC TO 0A AND FUNC TO (AND)
3470		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3471		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3472		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3473		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3474		DO (0) WHILE
3475	BLOCK1:	BEGIN
3476		DM(0,%O'-1');					!SET MEM TO -1
3477		CP(3);						!GIVE 3 CLOCKS
3478		RCVDATA = EM(0);				!GET DATA
3479		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
3480		IF .RCVDATA NEQ 0				!CHECK DATA
3481			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3482		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
3483			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
3484		0						!TO ILLUMINATE BLISS INFO COMMENT
3485	
3486		END;
3487		LC(5);						!LOAD CRAM ADRS 5
3488		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3489		LC(4);						!LOAD CRAM ADRS 4
3490		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3491		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3492		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3493		DO (0) WHILE
3494	BLOCK2:	BEGIN
3495		DM(0,%O'-1');					!SET MEM TO -1
3496		CP(3);						!GIVE 3 CLOCKS
3497		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3498		IF .RCVDATA NEQ 0				!CHECK DATA
3499			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3500		IF LOOP_CHK(2)
3501			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
3502		0						!TO ILLUMINATE BLISS INFO COMMENT
3503	
3504		END;
3505		MOD_FLD(5,%O'4007');				!MODIFY LSRC TO AQ
3506		ER_TAB[0] = UPLIT (%ASCIZ'37777777');		!FOR ERROR PRINTOUT
3507		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3508		DO (0) WHILE
3509	BLOCK3:	BEGIN
3510		DM(0,%O'-1');					!SET MEM TO -1
3511		CP(3);						!GIVE 3 CLOCKS
3512		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3513		IF .RCVDATA NEQ 0				!CHECK DATA ?
3514			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3515		IF LOOP_CHK(3)
3516			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
3517		0						!TO ILLUMINATE BLISS INFO COMMENT
3518	
3519		END;
3520		LC(5);						!LOAD CRAM ADRS 5
3521		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3522		LC(4);						!LOAD CRAM ADRS 4
3523		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3524		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3525		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3526		DO (0) WHILE
3527	BLOCK4:	BEGIN
3528		DM(0,%O'-1');					!SET MEM TO -1
3529		CP(3);						!GIVE 3 CLOCKS
3530		RCVDATA = EM(0);				!GET DATA
3531		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3532		IF .RCVDATA NEQ 0				!CHECK DADA ?
3533			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3534		IF LOOP_CHK(4)
3535			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
3536		0						!TO ILLUMINATE BLISS INFO COMMENT
3537	
3538		END;
3539		LC(5);						!LOAD CRAM ADRS 5
3540		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3541		LC(4);						!LOAD CRAM ADRS 4
3542		MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
3543		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3544		CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
3545		MOD_FLD(5,%O'4117');				!MODIFY FUNC TO (R - S)
3546		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3547		DO (0) WHILE
3548	BLOCK5:	BEGIN
3549		DM(0,0);					!CLEAR MEM
3550		CP(3);						!GIVE 3 CLOCKS
3551		RCVDATA = EM(0);				!GET DATA
3552		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3553		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
3554			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
3555		IF LOOP_CHK(5)
3556			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
3557		0						!TO ILLUMINATE BLISS INFO COMMENT
3558	
3559		END;
3560		LC(5);						!LOAD CRAM ADRS 5
3561		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3562		LC(4);						!LOAD CRAM ADRS 4
3563		MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
3564		CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
3565		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3566		MOD_FLD(5,%O'4117');				!MODIFY FUNC TO ( AND )
3567		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3568		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3569		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3570		DO (0) WHILE
3571	BLOCK6:	BEGIN
3572		DM(0,0);					!CLEAR MEM
3573		CP(3);						!GIVE 3 CLOCKS
3574		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3575		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
3576			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
3577		IF LOOP_CHK(6)
3578			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
3579		0						!TO ILLUMINATE BLISS INFO COMMENT
3580	
3581		END;
3582	!*MESSAGE 1
3583	!*	ALU FUNC (R AND S) :
3584	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
3585	!*	MAGIC # FIELD VIA DBUS & DBM
3586	!*	FOR THE \S2 20 BITS OF THE 2901'S
3587	!*	\S0    AND    \S1
3588	!*	THEN WRITE THE DATA OUT TO MEM 0
3589	!*RESPONSE:
3590	!*	EXAMINE DATA FROM MEM 0
3591	!]ERROR 1
3592	!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
3593		END;
3594	
3595	GLOBAL ROUTINE TST19: NOVALUE =
3596	!					    _
3597	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  AND  S ) .
3598	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
3599	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
3600	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
3601	!GLOBAL ROUTINE FUNC_LD).
3602	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
3603	!THREE DATA SETS ARE TESTED FOR THE (NOT R  AND  S) FUNCTION :
3604	! NOT  0   AND    -1
3605	! NOT  0   AND    0
3606	! NOT -1   AND   -1
3607	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
3608	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
3609	
3610		BEGIN
3611		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
3612		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
3613		LC(5);						!LOAD CRAM ADRS 5
3614		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3615		LC(4);						!LOAD CRAM ADRS 4
3616		MOD_FLD(5,%O'5447');				!MODIFY LSRC TO 0A AND FUNC TO 5
3617		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3618		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3619		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3620		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3621		DO (0) WHILE
3622	BLOCK1:	BEGIN
3623		DM(0,0);					!CLEAR MEM
3624		CP(3);						!GIVE 3 CLOCKS
3625		RCVDATA = EM(0);				!GET DATA
3626		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
3627		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
3628			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
3629		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
3630			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
3631		0						!TO ILLUMINATE BLISS INFO COMMENT
3632	
3633		END;
3634		LC(5);						!LOAD CRAM ADRS 5
3635		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3636		LC(4);						!LOAD CRAM ADRS 4
3637		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3638		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3639		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3640		DO (0) WHILE
3641	BLOCK2:	BEGIN
3642		DM(0,0);					!CLEAR MEM
3643		CP(3);						!GIVE 3 CLOCKS
3644		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3645		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
3646			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
3647		IF LOOP_CHK(2)
3648			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
3649		0						!TO ILLUMINATE BLISS INFO COMMENT
3650	
3651		END;
3652		MOD_FLD(5,%O'5227');				!MODIFY THE LSRC TO 0Q
3653		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3654		DO (0) WHILE
3655	BLOCK3:	BEGIN
3656		DM(0,%O'-1');					!SET MEM TO -1
3657		CP(3);						!GIVE 3 CLOCKS
3658		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3659		IF .RCVDATA NEQ 0				!CHECK DATA ?
3660			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3661		IF LOOP_CHK(3)
3662			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
3663		0						!TO ILLUMINATE BLISS INFO COMMENT
3664	
3665		END;
3666		LC(5);						!LOAD CRAM ADRS 4
3667		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3668		LC(4);						!LOAD CRAM ADRS 4
3669		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3670		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3671		DO (0) WHILE
3672	BLOCK4:	BEGIN
3673		DM(0,%O'-1');					!SET MEM TO -1
3674		CP(3);						!GIVE 3 CLOCKS
3675		RCVDATA = EM(0);				!GET DATA
3676		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3677		IF .RCVDATA NEQ 0				!CHECK DATA ?
3678			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3679		IF LOOP_CHK(4)
3680			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
3681		0						!TO ILLUMINATE BLISS INFO COMMENT
3682	
3683		END;
3684		MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
3685		CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
3686		MOD_FLD(5,%O'5117');				!MODIFY FUNC TO 5
3687		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3688		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3689		DO (0) WHILE
3690	BLOCK5:	BEGIN
3691		DM(0,%O'-1');					!SET MEM TO -1
3692		CP(3);						!GIVE 3 CLOCKS
3693		RCVDATA = EM(0);				!GET DATA
3694		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3695		IF .RCVDATA NEQ 0				!CHECK DATA ?
3696			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3697		IF LOOP_CHK(5)
3698			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
3699		0						!TO ILLUMINATE BLISS INFO COMMENT
3700	
3701		END;
3702		LC(5);						!LOAD CRAM ADRS 5
3703		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3704		LC(4);						!LOAD CRAM ADRS 4
3705		MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
3706		CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
3707		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3708		MOD_FLD(5,%O'5117');				!MODIFY FUNC TO ( 5 )
3709		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3710		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3711		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3712		DO (0) WHILE
3713	BLOCK6:	BEGIN
3714		DM(0,%O'-1');					!SET MEM TO -1
3715		CP(3);						!GIVE 3 CLOCKS
3716		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3717		IF .RCVDATA NEQ 0				!CHECK DATA ?
3718			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3719		IF LOOP_CHK(6)
3720			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
3721		0						!TO ILLUMINATE BLISS INFO COMMENT
3722	
3723		END;
3724	!*MESSAGE 1
3725	!*	2901'S FUNC TEST
3726	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
3727	!*	MAGIC # FIELD VIA DBUS & DBM
3728	!*		  _
3729	!*	ALU FUNC (R AND S) :
3730	!*	FOR THE \S2 20 BITS OF THE 2901'S
3731	!*	_______
3732	!*	\S0    AND    \S1
3733	!*	THEN WRITE THE DATA OUT TO MEM 0
3734	!*RESPONSE:
3735	!*	EXAMINE DATA FROM MEM 0
3736	!]ERROR 1
3737	!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
3738		END;
3739	
3740	GLOBAL ROUTINE TST20: NOVALUE =
3741	
3742	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  XOR  S ) .
3743	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
3744	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
3745	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
3746	!GLOBAL ROUTINE FUNC_LD).
3747	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
3748	!FOUR DATA SETS ARE TESTED FOR THE ( XOR ) FUNCTION :
3749	!	0   XOR   -1
3750	!      -1   XOR    0
3751	!	0   XOR    0
3752	!      -1   XOR   -1
3753	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
3754	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
3755	
3756		BEGIN
3757		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
3758		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
3759		LC(5);						!LOAD CRAM ADRS 5
3760		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3761		LC(4);						!LOAD CRAM ADRS 4
3762		MOD_FLD(5,%O'6447');				!MODIFY LSRC TO 0A AND FUNCTION TO ( XOR )
3763		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3764		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3765		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3766		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3767		DO (0) WHILE
3768	BLOCK1:	BEGIN
3769		DM(0,0);					!CLEAR MEM
3770		CP(3);						!GIVE 3 CLOCKS
3771		RCVDATA = EM(0);				!GET DATA
3772		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
3773		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA
3774			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
3775		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
3776			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
3777		0						!TO ILLUMINATE BLISS INFO COMMENT
3778	
3779		END;
3780		LC(5);						!LOAD CRAM ADRS 5
3781		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3782		LC(4);						!LOAD CRAM ADRS 4
3783		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3784		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3785		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3786		DO (0) WHILE
3787	BLOCK2:	BEGIN
3788		DM(0,0);					!CLEAR MEM
3789		CP(3);						!GIVE 3 CLOCKS
3790		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3791		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA
3792			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
3793		IF LOOP_CHK(2)
3794			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
3795		0						!TO ILLUMINATE BLISS INFO COMMENT
3796	
3797		END;
3798		MOD_FLD(5,%O'6007');				!MODIFY LSRC TO AQ
3799		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3800		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3801		DO (0) WHILE
3802	BLOCK3:	BEGIN
3803		DM(0,0);					!CLEAR MEM
3804		CP(3);						!GIVE 3 CLOCKS
3805		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3806		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
3807			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
3808		IF LOOP_CHK(3)
3809			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
3810		0						!TO ILLUMINATE BLISS INFO COMMENT
3811	
3812		END;
3813		LC(5);						!LOAD CRAM ADRS 5
3814		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3815		LC(4);						!LOAD CRAM ADRS 4
3816		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3817		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3818		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3819		DO (0) WHILE
3820	BLOCK4:	BEGIN
3821		DM(0,0);					!CLEAR MEM
3822		CP(3);						!GIVE 3 CLOCKS
3823		RCVDATA = EM(0);				!GET DATA
3824		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3825		IF .RCVDATA NEQ %O'7777776'			!CHECK DADA ?
3826			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
3827		IF LOOP_CHK(4)
3828			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
3829		0						!TO ILLUMINATE BLISS INFO COMMENT
3830	
3831		END;
3832		MOD_FLD(5,%O'6227');				!MODIFY THE LSRC TO 0Q
3833		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3834		DO (0) WHILE
3835	BLOCK5:	BEGIN
3836		DM(0,%O'-1');					!SET MEM TO -1
3837		CP(3);						!GIVE 3 CLOCKS
3838		RCVDATA = EM(0);				!GET DATA
3839		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3840		IF .RCVDATA NEQ 0				!CHECK DATA ?
3841			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
3842		IF LOOP_CHK(5)
3843			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
3844		0						!TO ILLUMINATE BLISS INFO COMMENT
3845	
3846		END;
3847		LC(5);						!LOAD CRAM ADRS 5
3848		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3849		LC(4);						!LOAD CRAM ADRS 4
3850		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3851		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3852		DO (0) WHILE
3853	BLOCK6:	BEGIN
3854		DM(0,%O'-1');					!SET MEM TO -1
3855		CP(3);						!GIVE 3 CLOCKS
3856		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3857		IF .RCVDATA NEQ 0				!CHECK DATA ?
3858			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
3859		IF LOOP_CHK(6)
3860			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
3861		0						!TO ILLUMINATE BLISS INFO COMMENT
3862	
3863		END;
3864		LC(5);						!LOAD CRAM ADRS 5
3865		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3866		LC(4);						!LOAD CRAM ADRS 4
3867		MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
3868		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3869		CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
3870		MOD_FLD(5,%O'6117');				!MODIFY FUNC TO ( XOR )
3871		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3872		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3873		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3874		DO (0) WHILE
3875	BLOCK7:	BEGIN
3876		DM(0,0);					!CLEAR MEM
3877		CP(3);						!GIVE 3 CLOCKS
3878		RCVDATA = EM(0);				!GET DATA
3879		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
3880		IF .RCVDATA NEQ 0				!CHECK DATA ?
3881			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
3882		IF LOOP_CHK(7)
3883			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
3884		0						!TO ILLUMINATE BLISS INFO COMMENT
3885	
3886		END;
3887		LC(5);						!LOAD CRAM ADRS 5
3888		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3889		LC(4);						!LOAD CRAM ADRS 4
3890		MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
3891		CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
3892		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
3893		MOD_FLD(5,%O'6117');				!MODIFY FUNC TO ( XOR )
3894		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3895		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3896		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3897		DO (0) WHILE
3898	BLOCK8:	BEGIN
3899		DM(0,0);					!CLEAR MEM
3900		CP(3);						!GIVE 3 CLOCKS
3901		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3902		IF .RCVDATA NEQ 0				!CHECK DATA ?
3903			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
3904		IF LOOP_CHK(8)
3905			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
3906		0						!TO ILLUMINATE BLISS INFO COMMENT
3907	
3908		END;
3909	!*MESSAGE 1
3910	!*	ALU FUNC (R XOR S) :
3911	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
3912	!*	MAGIC # FIELD VIA DBUS & DBM
3913	!*	FOR THE \S2 20 BITS OF THE 2901'S
3914	!*	\S0    XOR    \S1
3915	!*	THEN WRITE THE DATA OUT TO MEM 0
3916	!*RESPONSE:
3917	!*	EXAMINE DATA FROM MEM 0
3918	!]ERROR 1
3919	!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
3920		END;
3921	
3922	GLOBAL ROUTINE TST21: NOVALUE=
3923	
3924	!THIS TEST CHECKS THE 2901'S ALU FUNCTION ( R  XNOR  S ) .
3925	!FIRST WE CALL A ROUTINE FUNC_LD THAT LOADS THE VMA WITH 0, A ZERO IN 
3926	!THE Q REGISTER AND 40 BITS OF ONES IN THE 2901'S REGISTER 0.IT ALSO 
3927	!LOADS THE REQUIRED INSTRUCTIONS TO BE EXECUTED FOR THIS TEST (SEE
3928	!GLOBAL ROUTINE FUNC_LD).
3929	!ALU FUNCTION IS TESTED ON ALL 40 BITS (20 BITS AT A TIME).
3930	!FOUR DATA SETS ARE TESTED FOR THE ( XNOR ) FUNCTION :
3931	!	0   XNOR   -1
3932	!      -1   XNOR    0
3933	!	0   XNOR    0
3934	!      -1   XNOR   -1
3935	!FOR EACH DATA SET WE SHIFT THE RESULTANT DATA TWICE (RIGHT/LEFT), STORE 
3936	!IT IN REGISTER 1, WRITE TO MEM 0 AND CHECK THE SELECTED 20 BITS 
3937	
3938		BEGIN
3939		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
3940		FUNC_LD();					!GO LOAD VMA AND REQUIRED DATA
3941		LC(5);						!LOAD CRAM ADRS 5
3942		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3943		LC(4);						!LOAD CRAM ADRS 4
3944		MOD_FLD(5,%O'7447');				!MODIFY LSRC TO 0A AND FUNCTION TO ( XNOR )
3945		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3946		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3947		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
3948		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
3949		DO (0) WHILE
3950	BLOCK1:	BEGIN
3951		DM(0,%O'-1');					!SET MEM TO -1
3952		CP(3);						!GIVE 3 CLOCKS
3953		RCVDATA = EM(0);				!GET DATA
3954		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS OF RECIEVED DATA
3955		IF .RCVDATA NEQ 0				!CHECK DATA
3956			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);	!NO
3957		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
3958			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
3959		0						!TO ILLUMINATE BLISS INFO COMMENT
3960	
3961		END;
3962		LC(5);						!LOAD CRAM ADRS 5
3963		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3964		LC(4);						!LOAD CRAM ADRS 4
3965		MOD_FLD(7,%O'4500');				!MODIFY THE SHIFT TO LEFT
3966		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3967		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
3968		DO (0) WHILE
3969	BLOCK2:	BEGIN
3970		DM(0,%O'-1');					!SET MEM TO -1
3971		CP(3);						!GIVE 3 CLOCKS
3972		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3973		IF .RCVDATA NEQ 0				!CHECK DATA
3974			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
3975		IF LOOP_CHK(2)
3976			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
3977		0						!TO ILLUMINATE BLISS INFO COMMENT
3978	
3979		END;
3980		MOD_FLD(5,%O'7007');				!MODIFY LSRC TO AQ
3981		ER_TAB[1] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
3982		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
3983		DO (0) WHILE
3984	BLOCK3:	BEGIN
3985		DM(0,%O'-1');					!SET MEM TO -1
3986		CP(3);						!GIVE 3 CLOCKS
3987		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
3988		IF .RCVDATA NEQ 0				!CHECK DATA ?
3989			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
3990		IF LOOP_CHK(3)
3991			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
3992		0						!TO ILLUMINATE BLISS INFO COMMENT
3993	
3994		END;
3995		LC(5);						!LOAD CRAM ADRS 5
3996		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3997		LC(4);						!LOAD CRAM ADRS 4
3998		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
3999		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
4000		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
4001		DO (0) WHILE
4002	BLOCK4:	BEGIN
4003		DM(0,%O'-1');					!SET MEM TO -1
4004		CP(3);						!GIVE 3 CLOCKS
4005		RCVDATA = EM(0);				!GET DATA
4006		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
4007		IF .RCVDATA NEQ 0				!CHECK DADA ?
4008			THEN ERRCAS(1,1,0,.RCVDATA,7,ER_TAB);		!NO
4009		IF LOOP_CHK(4)
4010			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
4011		0						!TO ILLUMINATE BLISS INFO COMMENT
4012	
4013		END;
4014		MOD_FLD(5,%O'7227');				!MODIFY THE LSRC TO 0Q
4015		ER_TAB[0] = UPLIT (%ASCIZ'0000000');		!FOR ERROR PRINTOUT
4016		DO (0) WHILE
4017	BLOCK5:	BEGIN
4018		DM(0,0);					!CLEAR MEM
4019		CP(3);						!GIVE 3 CLOCKS
4020		RCVDATA = EM(0);				!GET DATA
4021		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
4022		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
4023			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
4024		IF LOOP_CHK(5)
4025			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
4026		0						!TO ILLUMINATE BLISS INFO COMMENT
4027	
4028		END;
4029		LC(5);						!LOAD CRAM ADRS 5
4030		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
4031		LC(4);						!LOAD CRAM ADRS 4
4032		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
4033		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
4034		DO (0) WHILE
4035	BLOCK6:	BEGIN
4036		DM(0,0);					!CLEAR MEM
4037		CP(3);						!GIVE 3 CLOCKS
4038		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
4039		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
4040			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
4041		IF LOOP_CHK(6)
4042			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
4043		0						!TO ILLUMINATE BLISS INFO COMMENT
4044	
4045		END;
4046		LC(5);						!LOAD CRAM ADRS 5
4047		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
4048		LC(4);						!LOAD CRAM ADRS 4
4049		MOD_FLD(5,%O'3117');				!MODIFY THE LSRC TO AB AND FUNC TO OR
4050		MOD_FLD(7,%O'4700');				!MODIFY SHIFT TO RIGHT
4051		CP_NOSS(2);					!PUT ANOTHER COPY OF -1 IN REGISTER 1
4052		MOD_FLD(5,%O'7117');				!MODIFY FUNC TO ( XNOR )
4053		ER_TAB[0] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
4054		ER_TAB[1] = UPLIT (%ASCIZ'7777776');		!FOR ERROR PRINTOUT
4055		ER_TAB[2] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
4056		DO (0) WHILE
4057	BLOCK7:	BEGIN
4058		DM(0,0);					!CLEAR MEM
4059		CP(3);						!GIVE 3 CLOCKS
4060		RCVDATA = EM(0);				!GET DATA
4061		RCVDATA = .RCVDATA<16,20>^1;			!SET UP ONLY THE LEFT 20 BITS
4062		IF .RCVDATA NEQ %O'7777776'			!CHECK DATA ?
4063			THEN ERRCAS(1,1,%O'7777776',.RCVDATA,7,ER_TAB);	!NO
4064		IF LOOP_CHK(7)
4065			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
4066		0						!TO ILLUMINATE BLISS INFO COMMENT
4067	
4068		END;
4069		LC(5);						!LOAD CRAM ADRS 5
4070		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
4071		LC(4);						!LOAD CRAM ADRS 4
4072		MOD_FLD(5,%O'3117');				!MODIFY FUNC TO OR
4073		CP_NOSS(2);					!PUT A NEW COPY OF -1 IN REGISTER 0
4074		MOD_FLD(7,%O'4500');				!MODIFY SHIFT TO LEFT
4075		MOD_FLD(5,%O'7117');				!MODIFY FUNC TO ( XNOR )
4076		ER_TAB[0] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
4077		ER_TAB[1] = UPLIT (%ASCIZ'3777777');		!FOR ERROR PRINTOUT
4078		ER_TAB[2] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
4079		DO (0) WHILE
4080	BLOCK8:	BEGIN
4081		DM(0,0);					!CLEAR MEM
4082		CP(3);						!GIVE 3 CLOCKS
4083		RCVDATA = EM(0) AND %O'3777777';		!GET DATA SETTING UP ONLY THE RIGHT 20 BITS
4084		IF .RCVDATA NEQ %O'3777777'			!CHECK DATA ?
4085			THEN ERRCAS(1,1,%O'3777777',.RCVDATA,7,ER_TAB);	!NO
4086		IF LOOP_CHK(8)
4087			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
4088		0						!TO ILLUMINATE BLISS INFO COMMENT
4089	
4090		END;
4091	!*MESSAGE 1
4092	!*	ALU FUNC (R XNOR S) :
4093	!*	PASS A 0 AND -1 INTO THE 2901'S FROM THE 
4094	!*	MAGIC # FIELD VIA DBUS & DBM
4095	!*	FOR THE \S2 20 BITS OF THE 2901'S
4096	!*	\S0    XNOR    \S1
4097	!*	THEN WRITE THE DATA OUT TO MEM 0
4098	!*RESPONSE:
4099	!*	EXAMINE DATA FROM MEM 0
4100	!]ERROR 1
4101	!]M2901S DPCLKS DBMDBUS DBUSSEL SHIFT MEMVMA NTWK
4102		END;
4103	
4104	GLOBAL ROUTINE TST22: NOVALUE =
4105	
4106	!THIS TEST CHECKS DPE9 DP CRY1 (DPE9) AND SKIP ON CRY1(SKIP = 56) (DPEA).
4107	!DIFFERENT DATA SET TO OUPUT THE 2901'S WHICH WILL SET OR CLEAR DPE9 DP CRY1
4108	!A SKIP ON DP CRY1 IS EXECUTED AND THE RESULT IS VERIFIED BY READING THE 
4109	!NXT CRAM ADRS.THE INSTRUCTIONS RESIDE IN CRAM 2,3 & 4.THEY DO THE FOLLOWING:
4110	!CRAM 2/ PASS A DATA INTO THE Q REGISTER OF THE 2901'S VIA DBUS WHICH 
4111	!	 GETS LOADED FROM THE MAGIC # FIELD VIA DBM.
4112	!CRAM 3/ PASS A SECOND DATA INTO REGISTER 0 USING THE SAME PATH AS IN CRAM 2.
4113	!CRAM 3/ ADD THE TWO DATA WORDS IN REGISTER 0 & Q OF THE 2901'S AND 
4114	!	 SKIP ON DPE9 DP CRY1.
4115	!THE ORED J FIELD WITH THE SKIP BIT IS ALWAYS 4.
4116	
4117		BEGIN
4118		LABEL BLOCK1,BLOCK2,BLOCK3;
4119		OWN DPCRY1_FLG;
4120		BIND
4121		POINTER = PLIT (U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(600000) U,
4122				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_Q_MUL2 U_DBUS_DBM U_N(400000) U,
4123				U_J(4) U_ALU_ADD U_LSRC_AQ U_SKIP_CRY1 U);
4124		LOAD_U(2,POINTER);				!LOAD 3 INSTRUCTIONS
4125		DPCRY1_FLG = 0;
4126		ER_TAB[0] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
4127		ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
4128		DO (0) WHILE
4129	BLOCK1:	BEGIN
4130		SET_C(2);					!SET CRAM ADRS TO 2
4131		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
4132		IF .RCVDATA NEQ 5				!CHECK DATA
4133			THEN BEGIN
4134				ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);		!NO
4135				DPCRY1_FLG = 1;
4136			     END;
4137		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
4138			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
4139		0						!TO ILLUMINATE BLISS INFO COMMENT
4140	
4141		END;
4142		MOD_FLD(4,%O'40');				!CHANGE DATA
4143		ER_TAB[1] = UPLIT (%ASCIZ'LO');			!FRO ERROR PRINTOUT
4144		DO (0) WHILE
4145	BLOCK2:	BEGIN
4146		SET_C(2);					!SET CRAM ADRS TO 2
4147		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
4148		IF .RCVDATA NEQ 4				!CHECK DATA
4149			THEN BEGIN
4150				ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);		!NO
4151				DPCRY1_FLG = 1;
4152			     END;
4153		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
4154			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
4155		0						!TO ILLUMINATE BLISS INFO COMMENT
4156	
4157		END;
4158		MOD_FLD(4,0);					!CHANGE DATA
4159		LC(3);						!LOAD CRAM ADRS 3
4160		MOD_FLD(4,0);					!CHANGE DATA
4161		ER_TAB[0] = UPLIT (%ASCIZ'LO');			!FRO ERROR PRINTOUT
4162		DO (0) WHILE
4163	BLOCK3:	BEGIN
4164		SET_C(2);					!SET CRAM ADRS TO 2
4165		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
4166		IF .RCVDATA NEQ 4				!CHECK DATA
4167			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB)		!NO
4168			ELSE IF .DPCRY1_FLG EQL 0
4169				THEN NOERR(1);
4170		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
4171			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
4172		0						!TO ILLUMINATE BLISS INFO COMMENT
4173	
4174		END;
4175	!*MESSAGE 1
4176	!*	DP CRY1 FLAG TEST
4177	!*STIMULUS:
4178	!*	DPE1 DP SIGN IS \S0
4179	!*	DPE2 DP 00 IS \S1
4180	!*	DPE2 CARRY OUT IS \S0
4181	!*	DPE9 DP CRY1 SHOULD BE \S1
4182	!*	WE DO A SKIP IF DP CRY1 IS HI
4183	!*RESPONSE:
4184	!*	GET NXT CRAM ADRS
4185	!]ERROR 1
4186	!]M2901S M2902S SHIFT DBMDBUS DBUSSEL SKIP DPCRY1 NTWK
4187	!]NO ERROR 1
4188	!]DPCRY1 NTWK
4189		END;
4190	
4191	GLOBAL ROUTINE TST23: NOVALUE =
4192	
4193	!THIS TEST CHECKS SKIP MIX'S ON 2901'S OUTPUT IN DPEA.
4194	!THIS TEST WILL EXECUTE 1 INSTRUCTION IN CRAM 1 THAT WILL DO THE FOLLOWING:
4195	!CRAM 1/ OUT A DATA WORD FROM 2901'S (PASS TO DP VIA DBUS & DBM) 
4196	!	 THEN SKIP ON DP OUTPUT (SKIP=31,51,52,53)
4197	!AFTER EACH TIME THE INSTRUCTION IS EXECUTED SOME FIELDS ARE MODIFIED 
4198	!TO DO THE NXT SKIP SELECT OR MODIFY DATA WORD
4199	!DATA IS VERIFIED BY READIG THE NXT CRAM ADRS 
4200	
4201		BEGIN
4202		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
4203		      BLOCK5,BLOCK6,BLOCK7,BLOCK8;
4204		BIND
4205		POINTER = PLIT (U_ALU_ADD U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SKIP_CRY0 U);
4206		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
4207		DO (0) WHILE
4208	BLOCK1:	BEGIN
4209		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4210		IF .RCVDATA NEQ 0				!CHECK DATA
4211			THEN ERRCA(1,0,.RCVDATA,4);		!NO
4212	!*MESSAGE 1
4213	!*STIMULUS:
4214	!*	OUTPUT A 0 ON DP(DPE2 CARRY OUT IS LO)
4215	!*	SKIP IF DPE2 CARRY OUT IS SET (SKIP = 31)
4216	!*RESPONSE:
4217	!*	EXAMINE NXT CRAM ADRS
4218	!]ERROR 1
4219	!]M2902S SKIP NTWK
4220		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
4221			THEN 
4222			BEGIN
4223			    SET_C(1);				!SET CRAM ADRS TO 1
4224			    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
4225			END;
4226		0						!TO ILLUMINATE BLISS INFO COMMENT
4227	
4228		END;
4229		MOD_FLD(1,%O'6507');				!MODIFY TO SKIP ON DPE2 CARRY 02
4230		DO (0) WHILE
4231	BLOCK2:	BEGIN
4232		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4233		IF .RCVDATA NEQ 0				!CHECK DATA
4234			THEN ERRCA(2,0,.RCVDATA,4);		!NO
4235	!*MESSAGE 2
4236	!*STIMULUS:
4237	!*	OUTPUT A 0 ON DP(DPE2 CARRY 02 IS LO)
4238	!*	SKIP IF DPE2 CARRY 02 IS SET (SKIP = 51)
4239	!*RESPONSE:
4240	!*	EXAMINE NXT CRAM ADRS
4241	!]ERROR 2
4242	!]M2902S SKIP NTWK
4243		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
4244			THEN 
4245			BEGIN
4246			    SET_C(1);				!SET CRAM ADRS TO 1
4247			    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
4248			END;
4249		0						!TO ILLUMINATE BLISS INFO COMMENT
4250	
4251		END;
4252		MOD_FLD(5,%O'3777');				!MODIFY ALU FUNC TO OR
4253		MOD_FLD(2,2);					!SKIP ON ADL SIGN
4254		DO (0) WHILE
4255	BLOCK3:	BEGIN
4256		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4257		IF .RCVDATA NEQ 0				!CHECK DATA
4258			THEN ERRCA(3,0,.RCVDATA,4);		!NO
4259	!*MESSAGE 3
4260	!*STIMULUS:
4261	!*	OUTPUT A 0 FROM 2901'S
4262	!*	SKIP IF ADL SIGN (SKIP = 52)
4263	!*RESPONSE:
4264	!*	EXAMINE NXT CRAM ADRS
4265	!]ERROR 3
4266	!]SKIP NTWK
4267		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
4268			THEN 
4269			BEGIN
4270			    SET_C(1);				!SET CRAM ADRS TO 1
4271			    LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
4272			END;
4273		0						!TO ILLUMINATE BLISS INFO COMMENT
4274	
4275		END;
4276		MOD_FLD(2,3);					!MODIFY TO SKIP ON ADR SIGN
4277		DO (0) WHILE
4278	BLOCK4:	BEGIN
4279		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4280		IF .RCVDATA NEQ 0				!CHECK DATA
4281			THEN ERRCA(4,0,.RCVDATA,4);		!NO
4282	!*MESSAGE 4
4283	!*STIMULUS:
4284	!*	OUTPUT A 0 FROM 2901'S
4285	!*	SKIP IF ADR SIGN (SKIP = 53)
4286	!*RESPONSE:
4287	!*	EXAMINE NXT CRAM ADRS
4288	!]ERROR 4
4289	!]SKIP NTWK
4290		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
4291			THEN 
4292			BEGIN
4293			    SET_C(1);				!SET CRAM ADRS TO 1
4294			    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
4295			END;
4296		0						!TO ILLUMINATE BLISS INFO COMMENT
4297	
4298		END;
4299		MOD_FLD(3,%O'7777');				!MODIFY DATA 
4300		MOD_FLD(4,%O'77');				!TO -1
4301		DO (0) WHILE
4302	BLOCK5:	BEGIN
4303		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4304		IF .RCVDATA NEQ 1				!CHECK DATA
4305			THEN ERRCA(5,1,.RCVDATA,4);		!NO
4306	!*MESSAGE 5
4307	!*STIMULUS:
4308	!*	OUTPUT A -1 FROM 2901'S
4309	!*	SKIP IF ADR SIGN (SKIP = 53)
4310	!*RESPONSE:
4311	!*	EXAMINE NXT CRAM ADRS
4312	!]ERROR 5
4313	!]SKIP NTWK
4314		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
4315			THEN 
4316			BEGIN
4317			    SET_C(1);				!SET CRAM ADRS TO 1
4318			    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
4319			END;
4320		0						!TO ILLUMINATE BLISS INFO COMMENT
4321	
4322		END;
4323		MOD_FLD(2,2);					!MODIFY TO SKIP ON ADL SIGN
4324		DO (0) WHILE
4325	BLOCK6:	BEGIN
4326		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4327		IF .RCVDATA NEQ 1				!CHECK DATA
4328			THEN ERRCA(6,1,.RCVDATA,4);		!NO
4329	!*MESSAGE 6
4330	!*STIMULUS:
4331	!*	OUTPUT A -1 FROM 2901'S
4332	!*	SKIP IF ADL SIGN (SKIP = 52)
4333	!*RESPONSE:
4334	!*	EXAMINE NXT CRAM ADRS
4335	!]ERROR 6
4336	!]SKIP NTWK
4337		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
4338			THEN 
4339			BEGIN
4340			    SET_C(1);				!SET CRAM ADRS TO 1
4341			    LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
4342			END;
4343		0						!TO ILLUMINATE BLISS INFO COMMENT
4344	
4345		END;
4346		MOD_FLD(2,1);					!MODIFY TO SKIP ON CARRY 02
4347		DO (0) WHILE
4348	BLOCK7:	BEGIN
4349		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4350		IF .RCVDATA NEQ 1				!CHECK DATA
4351			THEN ERRCA(7,1,.RCVDATA,4);		!NO
4352	!*MESSAGE 7
4353	!*STIMULUS:
4354	!*	PASS -1 2901'S AND OUTPUT ON DP(DPE2 CARRY 02 IS HI)
4355	!*	SKIP ON DPE2 CARRY 02
4356	!*RESPONSE:
4357	!*	EXAMINE NXT CRAM ADRS
4358	!]ERROR 7
4359	!]M2902S SKIP NTWK
4360		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
4361			THEN 
4362			BEGIN
4363			    SET_C(1);				!SET CRAM ADRS TO 1
4364			    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
4365			END;
4366		0						!TO ILLUMINATE BLISS INFO COMMENT
4367	
4368		END;
4369		MOD_FLD(1,%O'6307');				!MODIFY TO SKIP ON DPE2 CARRY OUT
4370		DO (0) WHILE
4371	BLOCK8:BEGIN
4372		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
4373		IF .RCVDATA NEQ 1				!CHECK DATA
4374			THEN ERRCA(8,1,.RCVDATA,4);		!NO
4375	!*MESSAGE 8
4376	!*STIMULUS:
4377	!*	PASS -1 FROM 2901'S AND OUTPUT ON DP(DPE2 CARRY OUT IS HI)
4378	!*	SKIP ON DPE2 CARRY OUT
4379	!*RESPONSE:
4380	!*	EXAMINE NXT CRAM ADRS
4381	!]ERROR 8
4382	!]M2902S SKIP NTWK
4383		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
4384			THEN 
4385			BEGIN
4386			    SET_C(1);				!SET CRAM ADRS TO 1
4387			    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
4388			END;
4389		0						!TO ILLUMINATE BLISS INFO COMMENT
4390	
4391		END;
4392		END;
4393	
4394	GLOBAL ROUTINE TST24: NOVALUE =
4395	
4396	!THIS TEST CHECKS THE DP HOLD L/R IN THE 2901'S (DP CLOCKS).
4397	!WE LOAD A 0 INTO REGISTER 0 WE WRITE THE DATA OUT TO PHYSICAL MEM AND 
4398	!VERIFY IT.NOW WE PUSH A -1 WITH DP HOLD L/R CLEARED.THIS SHOULD DISABLE 
4399	!WRITING THE 0 INTO REGISTER 0.
4400	!WE EXAMINE MEMORY AGAIN AND VERIFY THAT THE 2901'S DID NOT GET LOADED !WITH THE 0.
4401	
4402		BEGIN
4403		OWN DPFLG;
4404		LABEL BLOCK1,BLOCK2;
4405		BIND
4406		POINTER = PLIT(U_J(2) U_DEST_AD U,
4407			       U_J(3) U_MEM U_N(11012) U,
4408			       U_J(1) U_ALU_OR U_MEM U_N(2) U);
4409	
4410		LOAD_U(1,POINTER);
4411		DPFLG = 0;
4412		SET_C(1);					!SET CRAM ADRS TO 1
4413		DO (0) WHILE
4414	BLOCK1:	BEGIN
4415		DM(0,%O'-1');
4416		CP(3);						!GIVE 3 CLOCKS
4417		RCVDATA = EM(0);				!GET DATA
4418		IF .RCVDATA NEQ 0				!CHECK DATA
4419			THEN BEGIN
4420				ERRCA(1,0,.RCVDATA,12);	!NO
4421				DPFLG = 1;
4422			     END;
4423	!*MESSAGE 1
4424	!*	DP CLKS TEST
4425	!*STIMULUS:
4426	!*	PUT 0 IN REGISTER 0
4427	!*	THEN WRITE IT OUT TO MEM
4428	!*RESPONSE:
4429	!*	EXAMINE DATA FROM MEM
4430		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
4431			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
4432		0						!TO ILLUMINATE BLISS INFO COMMENT
4433	
4434		END;
4435		MOD_FLD(6,%O'2000');				!CLEAR DP HOLD L/R
4436		MOD_FLD(5,%O'7447');
4437		DO (0) WHILE
4438	BLOCK2:	BEGIN
4439		DM(0,%O'-1');
4440		CP(3);						!GIVE 3 CLOCKS
4441		RCVDATA = EM(0);				!GET DATA
4442		IF .RCVDATA NEQ 0 				!CHECK DATA
4443			THEN ERRCA(1,0,.RCVDATA,12)	!NO
4444			ELSE IF .DPFLG EQL 0
4445					THEN NOERR(1);
4446	!*MESSAGE 2
4447	!*	DP CLKS TEST
4448	!*STIMULUS:
4449	!*	PUT A 0 IN REGISTER 0
4450	!*	TRY TO WRITE A -1 INTO REGISTER 0
4451	!*	WITH DP HOLD L/R CLEARED 
4452	!*	(IT SHOULDN'T WRITE)
4453	!*	THEN WRITE IT OUT TO MEM 0
4454	!*RESPONSE:
4455	!*	EXAMINE DATA FROM MEM 0
4456	!]ERROR 1
4457	!]DPCLKS M2901S MEMVMA NTWK
4458	!]NO ERROR 1
4459	!]DPCLKS NTWK
4460		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
4461			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
4462		0						!TO ILLUMINATE BLISS INFO COMMENT
4463	
4464		END;
4465		END;
4466	
4467	GLOBAL ROUTINE TST25: NOVALUE =
4468	
4469	!THIS TEST CHECKS THE LEFT SHIFT LOGIC MIX ON DPE1 (E704,E705,E706,E702).
4470	!FIRST WE CALL VMA_LD ROUTINE TO MAKE SURE THE VMA IS LOADED WITH 0.
4471	!THEN ALL 10 INSTRUCTIONS NEEDED TO PERFORM THIS TEST ARE LOADED INTO 
4472	!THE CRAM SEQUENTIALY STARTING WITH CRAM LOCATION 1.
4473	!NEXT ALL 8 SHSTYLE SELECTS (NORM,LSHC,ZERO,ONES,ROT,ASHC,ROTC & DIV)
4474	!ARE TESTED ON DPE1.AFTER EACH SHSTYLE SELECT TEST, FIELDS ARE MODIFIED 
4475	!IN CRAM TO SET UP THE REQUIRED INSTRUCTIONS TO BE EXECUTED AND DATA TO 
4476	!BE SHIFTED FOR THE NEXT SHSTYLE TEST.DATA IS ALWAYS PASSED TO AND 
4477	!VERIFIED FROM PHYSICAL MEM 0.
4478	
4479		BEGIN
4480		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
4481		      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,
4482		      BLOCK11,BLOCK12,BLOCK13,BLOCK14,BLOCK15,BLOCK16;
4483		BIND
4484		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(20000) U,
4485				U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(20000) U,
4486				U_J(4) U_ALU_OR U_DEST_Q_MUL2 U,
4487				U_J(5) U_ALU_OR U_DEST_Q_MUL2 U_MULTI_PREC U,
4488				U_J(6) U_ALU_OR U_DEST_Q_MUL2 U_MULTI_PREC U,
4489				U_J(7) U_ALU_OR U_DEST_Q_MUL2 U_MULTI_PREC U,
4490				U_J(10) U_ALU_OR U_DEST_Q_MUL2 U_NO_CLKL U,
4491				U_J(11) U_ALU_OR U_DEST_Q_MUL2 U_NO_CLKL U,
4492				U_J(12) U_ALU_OR U_DEST_Q_MUL2 U_NO_CLKL U_MEM U_N(11002) U,
4493				U_J(1) U_ALU_OR U_MEM U_N(2) U,
4494				U_J(7) U_ALU_OR U_LSRC_AB U_SHSTYLE_DIV U_DEST_Q_MUL2 U_DIVIDE U);
4495		VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
4496		LOAD_U(1,POINTER);				!LOAD 12 INSTRUCTIONS
4497		SET_C(1);					!SET CRAM ADRS TO 1
4498		DO (0) WHILE
4499	BLOCK1:	BEGIN
4500		CP(10);						!GIVE 12 OCTAL CLOCKS
4501		RCVDATA = EM(0);
4502		IF .RCVDATA NEQ %O'400000000002'		!CHECK DATA
4503			THEN ERRCA(1,%O'400000000002',.RCVDATA,12)	!NO
4504			ELSE NOERR (1);
4505	!*MESSAGE 1
4506	!*	SHIFT TEST
4507	!*STIMULUS:
4508	!*	DID A LEFT SHIFT  7 TO REGISTER 0 
4509	!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
4510	!*	INITIAL DATA = 20000,,20000
4511	!*	THE FOLLOWING WAS CLOCKED :
4512	!*	SHIFT BOTH HALFS LEFT 1
4513	!*	SHIFT BOTH HALFS LEFT 3 WITH MULTI PRECISION SET
4514	!*	SHIFT RIGHT HALF LEFT 3
4515	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
4516	!*RESPONSE:
4517	!*	EXAMINE DATA FROM MEM
4518	!]ERROR 1
4519	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
4520		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
4521			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
4522		0						!TO ILLUMINATE BLISS INFO COMMENT
4523	
4524		END;
4525		LC(12);						!LOAD CRAM ADRS 12
4526		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
4527		SET_C(1);					!SET CRAM ADRS TO 1
4528		DO (0) WHILE
4529	BLOCK2:	BEGIN
4530		CP(10);						!GIVE 12 OCTAL CLOCKS
4531		RCVDATA = EM(0);				!GET DATA
4532		IF .RCVDATA NEQ %O'400000000000'			!CHECK DATA
4533			THEN ERRCA(2,%O'400000000000',.RCVDATA,12)	!NO
4534			ELSE NOERR(1);
4535	!*MESSAGE 2
4536	!*STIMULUS:
4537	!*	DID A LEFT SHIFT  7 TO THE Q REGISTER 
4538	!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
4539	!*	INITIAL DATA = 20000,,20000
4540	!*	THE FOLLOWING WAS CLOCKED :
4541	!*	SHIFT BOTH HALFS LEFT 1
4542	!*	SHIFT BOTH HALFS LEFT 3 WITH MULTI PRECISION SET
4543	!*	SHIFT RIGHT HALF LEFT 3
4544	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4545	!*RESPONSE:
4546	!*	EXAMINE DATA FROM MEM
4547	!]ERROR 2
4548	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
4549		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
4550			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
4551		0						!TO ILLUMINATE BLISS INFO COMMENT
4552	
4553		END;
4554		LC(3);						!LOAD CRAM ADRS 3
4555		MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
4556		LC(4);						!LOAD CRAM ADRS 4
4557		MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
4558		LC(5);						!LOAD CRAM ADRS 5
4559		MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
4560		LC(6);						!LOAD CRAM ADRS 6
4561		MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
4562		LC(7);						!LOAD CRAM ADRS 7
4563		MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
4564		LC(10);						!LOAD CRAM ADRS 10
4565		MOD_FLD(2,%O'50');				!MODIFY SPEC SELECT TO 5
4566		LC(11);						!LOAD CRAM ADRS 11
4567		MOD_FLD(2,%O'1050');				!MODIFY SPEC SELECT TO 5
4568		SET_C(1);					!SET CRAM ADRS TO 1
4569		DO (0) WHILE
4570	BLOCK3:	BEGIN
4571		DM(0,0);					!CLEAR MEM
4572		CP(10);						!GIVE  0LCLOCKS
4573		RCVDATA = EM(0);				!GET DATA
4574		IF .RCVDATA NEQ %O'400000000000'			!CHECK DATA
4575			THEN ERRCA(3,%O'400000000000',.RCVDATA,12);	!NO
4576	!*MESSAGE 3
4577	!*STIMULUS:
4578	!*	DID A LEFT SHIFT  7 TO THE Q REGISTER 
4579	!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
4580	!*	INITIAL DATA = 20000,,20000
4581	!*	THE FOLLOWING WAS CLOCKED :
4582	!*	SHIFT BOTH HALFS LEFT 4
4583	!*	SHIFT RIGHT HALF LEFT 3
4584	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4585	!*RESPONSE:
4586	!*	EXAMINE DATA FROM MEM
4587	!]ERROR 3
4588	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4589		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
4590			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
4591		0						!TO ILLUMINATE BLISS INFO COMMENT
4592	
4593		END;
4594		LC(12);						!LOAD CRAM ADRS 12
4595		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUTPUT REGISTER 0
4596		SET_C(1);					!SET CRAM ADRS TO 1
4597		DO (0) WHILE
4598	BLOCK4:	BEGIN
4599		CP(10);						!GIVE 12 OCTAL CLOCKS
4600		RCVDATA = EM(0);				!GET DATA
4601		IF .RCVDATA NEQ %O'400000000004'			!CHECK DATA
4602			THEN ERRCA(4,%O'400000000004',.RCVDATA,12);	!NO
4603	!*MESSAGE 4
4604	!*STIMULUS:
4605	!*	DID A LEFT SHIFT  7 TO REGISTER 0
4606	!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
4607	!*	INITIAL DATA = 20000,,20000
4608	!*	THE FOLLOWING WAS CLOCKED :
4609	!*	SHIFT BOTH HALFS LEFT 4
4610	!*	SHIFT RIGHT HALF LEFT 3
4611	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
4612	!*RESPONSE:
4613	!*	EXAMINE DATA FROM MEM
4614	!]ERROR 4
4615	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4616		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
4617			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
4618		0						!TO ILLUMINATE BLISS INFO COMMENT
4619	
4620		END;
4621		LC(3);						!LOAD CRAM ADRS 3
4622		MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
4623		LC(4);						!LOAD CRAM ADRS 4
4624		MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
4625		LC(5);						!LOAD CRAM ADRS 5
4626		MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
4627		LC(6);						!LOAD CRAM ADRS 6
4628		MOD_FLD(2,%O'10');				!MODIFY SHDTYLE TO ZERO
4629		MOD_FLD(0,%O'11');				!MODIFY J FIELD
4630		LC(11);						!LOAD CRAM ADRS 11
4631		MOD_FLD(2,%O'1010');				!MODIFY SHDTYLE TO ZERO
4632		MOD_FLD(6,%O'2060');				!CLOCK BOTH HALFS
4633		LC(2);						!LOAD CRAM ADRS 2
4634		MOD_FLD(4,1);					!MODIFY DATA TO 10000010000
4635		LC(1);						!LOAD CRAM ADRS 1
4636		MOD_FLD(4,%O'20');				!MODIFY DATA TO 200000200000
4637		DO (0) WHILE
4638	BLOCK5:	BEGIN
4639		CP(8);						!GIVE 10 OCTAL CLOCKS
4640		RCVDATA = EM(0);				!GET DATA
4641		IF .RCVDATA NEQ %O'400010000000'		!CHECK DATA
4642			THEN ERRCA(5,%O'400010000000',.RCVDATA,12);	!NO
4643	!*MESSAGE 5
4644	!*STIMULUS:
4645	!*	DID A LEFT SHIFT  5 TO REGISTER 0
4646	!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
4647	!*	INITIAL DATA = 200000,,200000
4648	!*	THE FOLLOWING WAS CLOCKED :
4649	!*	SHIFT BOTH HALFS LEFT 5
4650	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
4651	!*RESPONSE:
4652	!*	EXAMINE DATA FROM MEM
4653	!]ERROR 5
4654	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4655		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
4656			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
4657		0						!TO ILLUMINATE BLISS INFO COMMENT
4658	
4659		END;
4660		LC(12);						!LOAD CRAM ADRS 12
4661		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUTPUT Q
4662		SET_C(1);					!SET CRAM ADRS TO 1
4663		DO (0) WHILE
4664	BLOCK6:	BEGIN
4665		CP(8);						!GIVE 10 CLOCKS
4666		RCVDATA = EM(0);				!GET DATA
4667		IF .RCVDATA NEQ %O'400000400000'		!CHECK DATA
4668			THEN ERRCA(6,%O'400000400000',.RCVDATA,12);	!NO
4669	!*MESSAGE 6
4670	!*STIMULUS:
4671	!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
4672	!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
4673	!*	INITIAL DATA = 10000,,10000
4674	!*	THE FOLLOWING WAS CLOCKED :
4675	!*	SHIFT BOTH HALFS LEFT 5
4676	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4677	!*RESPONSE:
4678	!*	EXAMINE DATA FROM MEM
4679	!]ERROR 6
4680	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4681		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
4682			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
4683		0						!TO ILLUMINATE BLISS INFO COMMENT
4684	
4685		END;
4686		LC(3);						!LOAD CRAM ADRS 3
4687		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
4688		LC(4);						!LOAD CRAM ADRS 4
4689		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
4690		LC(5);						!LOAD CRAM ADRS 5
4691		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
4692		LC(6);						!LOAD CRAM ADRS 6
4693		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
4694		LC(11);						!LOAD CRAM ADRS 11
4695		MOD_FLD(2,%O'1020');				!MODIFY SHSTYLE TO ONES
4696		SET_C(1);					!SET CRAM ADRS TO 1
4697		DO (0) WHILE
4698	BLOCK7:	BEGIN
4699		CP(8);						!GIVE 10 OCTAL CLOCKS
4700		RCVDATA = EM(0);				!GET DATA
4701		IF .RCVDATA NEQ %O'400000400007'		!CHECK DATA
4702			THEN ERRCA(7,%O'400000400007',.RCVDATA,12);	!NO
4703	!*MESSAGE 7
4704	!*STIMULUS:
4705	!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
4706	!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
4707	!*	INITIAL DATA = 10000,,10000
4708	!*	THE FOLLOWING WAS CLOCKED :
4709	!*	SHIFT BOTH HALFS LEFT 5
4710	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4711	!*RESPONSE:
4712	!*	EXAMINE DATA FROM MEM
4713	!]ERROR 7
4714	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4715		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
4716			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
4717		0						!TO ILLUMINATE BLISS INFO COMMENT
4718	
4719		END;
4720		LC(12);						!LOAD CRAM ADRS 12
4721		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUTPUT REGISTER 0
4722		SET_C(1);					!SET CRAM ADRS TO 1
4723		DO (0) WHILE
4724	BLOCK8:	BEGIN
4725		CP(8);						!GIVE 10 OCTALC LOCKS
4726		RCVDATA = EM(0);				!GET DATA
4727		IF .RCVDATA NEQ %O'400010000007'		!CHECK DATA
4728			THEN ERRCA(8,%O'400010000007',.RCVDATA,12);	!NO
4729	!*MESSAGE 8
4730	!*STIMULUS:
4731	!*	DID A LEFT SHIFT  5 TO REGISTER 0
4732	!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
4733	!*	INITIAL DATA = 200000,,200000
4734	!*	THE FOLLOWING WAS CLOCKED :
4735	!*	SHIFT BOTH HALFS LEFT 5
4736	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
4737	!*RESPONSE:
4738	!*	EXAMINE DATA FROM MEM
4739	!]ERROR 8
4740	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4741		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
4742			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
4743		0						!TO ILLUMINATE BLISS INFO COMMENT
4744	
4745		END;
4746		LC(3);						!LOAD CRAM ADRS 3
4747		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
4748		LC(4);						!LOAD CRAM ADRS 4
4749		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
4750		LC(5);						!LOAD CRAM ADRS 5
4751		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
4752		LC(6);						!LOAD CRAM ADRS 6
4753		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
4754		LC(11);						!LOAD CRAM ADRS 11
4755		MOD_FLD(2,%O'1030');				!MODIFY SHSTYLE TO ROT
4756		LC(2);						!LOAD CRAM ADRS 2
4757		MOD_FLD(4,4);					!CHANGE DATA IN Q TO 40000040000
4758		SET_C(1);					!SET CRAM ADRS TO 1
4759		MOD_FLD(4,%O'24');				!CHANGE DATA IN REGISTER 0 TO 240000240000
4760		DO (0) WHILE
4761	BLOCK9:	BEGIN
4762		CP(8);						!GIVE 10 OCTAL CLOCKS
4763		RCVDATA = EM(0);				!GET DATA
4764		IF .RCVDATA NEQ %O'400012000002'		!CHECK DATA
4765			THEN ERRCA(9,%O'400012000002',.RCVDATA,12);	!NO
4766	!*MESSAGE 9
4767	!*STIMULUS:
4768	!*	DID A LEFT SHIFT  5 TO REGISTER 0
4769	!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
4770	!*	INITIAL DATA = 240000,,240000
4771	!*	THE FOLLOWING WAS CLOCKED :
4772	!*	SHIFT BOTH HALFS LEFT 5
4773	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
4774	!*RESPONSE:
4775	!*	EXAMINE DATA FROM MEM
4776	!]ERROR 9
4777	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4778		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
4779			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
4780		0						!TO ILLUMINATE BLISS INFO COMMENT
4781	
4782		END;
4783		LC(12);						!SET CRAM ADRS TO 12
4784		MOD_FLD(5,%O'3227');				!OUPUT Q
4785		SET_C(1);
4786		DO (0) WHILE
4787	BLOCK10:BEGIN
4788		CP(8);						!GIVE 10 OCTAL CLOCKS
4789		RCVDATA = EM(0);				!GET DATA
4790		IF .RCVDATA NEQ %O'2000002'			!CHECK DATA
4791			THEN ERRCA(10,%O'2000002',.RCVDATA,12)	!NO
4792			ELSE NOERR(1);
4793	!*MESSAGE 10
4794	!*STIMULUS:
4795	!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
4796	!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
4797	!*	INITIAL DATA = 40000,,40000
4798	!*	THE FOLLOWING WAS CLOCKED :
4799	!*	SHIFT BOTH HALFS LEFT 5
4800	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4801	!*RESPONSE:
4802	!*	EXAMINE DATA FROM PHYSICAL MEM 0
4803	!]ERROR 10
4804	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4805		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
4806			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
4807		0						!TO ILLUMINATE BLISS INFO COMMENT
4808	
4809		END;
4810		LC(3);						!LOAD CRAM ADRS 3
4811		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
4812		LC(4);						!LOAD CRAM ADRS 4
4813		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
4814		LC(5);						!LOAD CRAM ADRS 5
4815		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
4816		LC(6);						!LOAD CRAM ADRS 6
4817		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
4818		LC(11);						!LOAD CRAM ADRS 11
4819		MOD_FLD(2,%O'1040');				!MODIFY SHSTYLE TO ASHC
4820		SET_C(1);					!SET CRAM ADRS TO 1
4821		DO (0) WHILE
4822	BLOCK11:BEGIN
4823		CP(8);						!GIVE 10 OCTAL CLOCKS
4824		RCVDATA = EM(0);				!GET DATA
4825		IF .RCVDATA NEQ %O'2000000'			!CHECK DATA
4826			THEN ERRCA(11,%O'2000000',.RCVDATA,12);	!NO
4827	!*MESSAGE 11
4828	!*STIMULUS:
4829	!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
4830	!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
4831	!*	INITIAL DATA = 40000,,40000
4832	!*	THE FOLLOWING WAS CLOCKED :
4833	!*	SHIFT BOTH HALFS LEFT 5
4834	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4835	!*RESPONSE:
4836	!*	EXAMINE DATA FROM PHYSICAL MEM 0
4837	!]ERROR 11
4838	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4839		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
4840			THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
4841		0						!TO ILLUMINATE BLISS INFO COMMENT
4842	
4843		END;
4844		LC(12);						!LOAD CRAM ADRS 12
4845		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
4846		SET_C(1);					!SET CRAM ADRS TO 1
4847		DO (0) WHILE
4848	BLOCK12:BEGIN
4849		CP(8);						!GIVE 10 OCTAL CLOCKS
4850		RCVDATA = EM(0);				!GET DATA
4851		IF .RCVDATA NEQ %O'400012000002'		!CHECK DATA
4852			THEN ERRCA(12,%O'400012000002',.RCVDATA,12);	!NO
4853	!*MESSAGE 12
4854	!*STIMULUS:
4855	!*	DID A LEFT SHIFT  5 TO REGISTER 0
4856	!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
4857	!*	INITIAL DATA IN Q = 40000,,40000
4858	!*	INITIAL DATA IN REGISTER 0 = 240000,,240000
4859	!*	THE FOLLOWING WAS CLOCKED :
4860	!*	SHIFT BOTH HALFS LEFT 5
4861	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
4862	!*RESPONSE:
4863	!*	EXAMINE DATA FROM PHYSICAL MEM 0
4864	!]ERROR 12
4865	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4866		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
4867			THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
4868		0						!TO ILLUMINATE BLISS INFO COMMENT
4869	
4870		END;
4871		LC(3);						!LOAD CRAM ADRS 3
4872		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
4873		LC(4);						!LOAD CRAM ADRS 4
4874		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
4875		LC(5);						!LOAD CRAM ADRS 5
4876		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
4877		LC(6);						!LOAD CRAM ADRS 6
4878		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
4879		LC(11);						!LOAD CRAM ADRS 11
4880		MOD_FLD(2,%O'1070');				!MODIFY SHSTYLE TO ROTC
4881		SET_C(1);					!SET CRAM ADRS TO 1
4882		DM(0,0);					!CLEAR MEM
4883		DO (0) WHILE
4884	BLOCK13:BEGIN
4885		CP(8);						!GIVE 10 OCTAL CLOCKS
4886		RCVDATA = EM(0);				!GET DATA
4887		IF .RCVDATA NEQ %O'400012000002'		!CHECK DATA
4888			THEN ERRCA(13,%O'400012000002',.RCVDATA,12);	!NO
4889	!*MESSAGE 13
4890	!*STIMULUS:
4891	!*	DID A LEFT SHIFT  5 TO REGISTER 0
4892	!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
4893	!*	INITIAL DATA IN Q = 40000,,40000
4894	!*	INITIAL DATA IN REGISTER 0 = 240000,,240000
4895	!*	THE FOLLOWING WAS CLOCKED :
4896	!*	SHIFT BOTH HALFS LEFT 5
4897	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
4898	!*RESPONSE:
4899	!*	EXAMINE DATA FROM PHYSICAL MEM 0
4900	!]ERROR 13
4901	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4902		IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
4903			THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
4904		0						!TO ILLUMINATE BLISS INFO COMMENT
4905	
4906		END;
4907		LC(12);						!LOAD CRAM ADRS 12
4908		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUTPUT Q REGISTER
4909		SET_C(1);					!SET CRAM ADRS TO 1
4910		DO (0) WHILE
4911	BLOCK14:	BEGIN
4912		CP(8);						!GIVE 10 OCTAL CLOCKS
4913		RCVDATA = EM(0);				!GET DATA
4914		IF .RCVDATA NEQ %O'2000002'			!CHECK DATA
4915			THEN ERRCA(14,%O'2000002',.RCVDATA,12);	!NO
4916	!*MESSAGE 14
4917	!*STIMULUS:
4918	!*	DID A LEFT SHIFT  5 TO THE Q REGISTER 
4919	!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
4920	!*	INITIAL DATA IN Q = 40000,,40000
4921	!*	INITIAL DATA IN REGISTER 0 = 240000,,240000
4922	!*	THE FOLLOWING WAS CLOCKED :
4923	!*	SHIFT BOTH HALFS LEFT 5
4924	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4925	!*RESPONSE:
4926	!*	EXAMINE DATA FROM PHYSICAL MEM 0
4927	!]ERROR 14
4928	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
4929		IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
4930			THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
4931		0						!TO ILLUMINATE BLISS INFO COMMENT
4932	
4933		END;
4934		LC(3);						!LOAD CRAM ADRS 3
4935		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
4936		LC(4);						!LOAD CRAM ADRS 4
4937		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
4938		LC(5);						!LOAD CRAM ADRS 5
4939		MOD_FLD(4,%O'200');				!SET DIVIDE BIT
4940		MOD_FLD(5,%O'3117');				!MODIFY LSRC TO AB
4941		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
4942		LC(6);						!LOAD CRAM ADRS 6
4943		MOD_FLD(4,%O'200');				!SET DIVIDE BIT
4944		MOD_FLD(0,%O'13');				!GO TO 13
4945		MOD_FLD(5,%O'3117');				!MODIFY LSRC TO AB
4946		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
4947		LC(7);						!LOAD CRAM ADRS 7
4948		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
4949		LC(10);						!LOAD CRAM ADRS 10
4950		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
4951		LC(11);						!LOAD CRAM ADRS 11
4952		MOD_FLD(6,%O'2020');				!MODIFY NO CLKL
4953		MOD_FLD(2,%O'1060');				!MODIFY SHSTYLE TO SPECIAL DIVIDE
4954		LC(2);						!LOAD CRAM ADRS 2
4955		MOD_FLD(4,1);					!MODIFY DATA TO 10000010000
4956		LC(1);						!LOAD CRAM ADRS 1
4957		MOD_FLD(4,%O'21');				!MODIFY DATA TO 210000210000
4958		DO (0) WHILE
4959	BLOCK15:BEGIN
4960		CP(11);						!GIVE 13 OCTAL CLOCKS
4961		RCVDATA = EM(0);				!GET DATA
4962		IF .RCVDATA NEQ %O'400000000016'		!CHECK DATA
4963			THEN ERRCA(15,%O'400000000016',.RCVDATA,12);	!NO
4964	!*MESSAGE 15
4965	!*STIMULUS:
4966	!*	DID A LEFT SHIFT  8 TO THE Q REGISTER 
4967	!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
4968	!*	INITIAL DATA IN Q = 10000,,10000
4969	!*	INITIAL DATA IN REGISTER 0 = 210000,,210000
4970	!*	THE FOLLOWING WAS CLOCKED :
4971	!*	SHIFT BOTH HALFS LEFT 8
4972	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
4973	!*RESPONSE:
4974	!*	EXAMINE DATA FROM PHYSICAL MEM 0
4975	!]ERROR 15
4976	!]M2902S M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
4977		IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
4978			THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
4979		0						!TO ILLUMINATE BLISS INFO COMMENT
4980	
4981		END;
4982		LC(12);						!LOAD CRAM ADRS 12
4983		MOD_FLD(5,%O'3447');				!MODIFY LS5C TO OUPUT REGISTER 0
4984		SET_C(1);					!SET CRAM ADRS TO 1
4985		DO (0) WHILE
4986	BLOCK16:BEGIN
4987		CP(11);						!GIVE 13 OCTAL CLOCKS
4988		RCVDATA = EM(0);				!GET DATA
4989		IF .RCVDATA NEQ %O'400010000004'		!CHECK DATA
4990			THEN ERRCA(16,%O'400010000004',.RCVDATA,12);	!NO
4991	!*MESSAGE 16
4992	!*STIMULUS:
4993	!*	DID A LEFT SHIFT  8 TO REGISTER 0
4994	!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
4995	!*	INITIAL DATA IN Q = 10000,,10000
4996	!*	INITIAL DATA IN REGISTER 0 = 210000,,210000
4997	!*	THE FOLLOWING WAS CLOCKED :
4998	!*	SHIFT BOTH HALFS LEFT 8
4999	!*	THEN OUTPUT THE DATA FROM REGISTER R 0 TO MEM
5000	!*RESPONSE:
5001	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5002	!]ERROR 16
5003	!]M2902S M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA DPSCFLG HCLK NTWK
5004	!]NO ERROR 1
5005	!]HCLK NTWK
5006		IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
5007			THEN LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
5008		0						!TO ILLUMINATE BLISS INFO COMMENT
5009	
5010		END;
5011		END;
5012	
5013	GLOBAL ROUTINE TST26: NOVALUE =
5014	
5015	!THIS TEST CHECKS THE RIGHT SHIFT LOGIC MIX ON DPE1.
5016	!FIRST WE CALL VMA_LD ROUTINE TO MAKE SURE THE VMA IS LOADED WITH 0.
5017	!THEN ALL 12 INSTRUCTIONS NEEDED TO PERFORM THIS TEST ARE LOADED INTO 
5018	!THE CRAM SEQUENTIALY STARTING WITH CRAM LOCATION 1.
5019	!NEXT ALL 8 SHSTYLE SELECTS (NORM,ONES,ROT,ASHC,LSHC,DIV,ROTC & ZERO)
5020	!ARE TESTED ON DPE1.AFTER EACH SHSTYLE SELECT TEST, FIELDS ARE MODIFIED 
5021	!IN CRAM TO SET UP THE REQUIRED INSTRUCTIONS TO BE EXECUTED AND DATA TO 
5022	!BE SHIFTED FOR THE NEXT SHSTYLE TEST.DATA IS ALWAYS PASSED TO AND 
5023	!VERIFIED FROM PHYSICAL MEM 0.
5024	
5025		BEGIN
5026		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
5027		      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,
5028		      BLOCK11,BLOCK12,BLOCK13,BLOCK14,BLOCK15,BLOCK16;
5029		BIND
5030		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_PC U_DBUS_DBM U_N(200002) U,
5031				U_J(3) U_ALU_OR U_A_PC U_B_PC U_DEST_AD_MUL2 U_NO_CLKR U,
5032				U_J(3) U_ALU_OR U_A_PC U_B_PC U_DEST_AD_MUL2 U_NO_CLKR U,
5033				U_J(5) U_ALU_OR U_A_PC U_DEST_AD U,
5034				U_J(6) U_ALU_OR U_A_PC U_DEST_Q_AD U,
5035				U_J(7) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
5036				U_J(10) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
5037				U_J(11) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
5038				U_J(12) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U,
5039				U_J(13) U_ALU_OR U_DEST_Q_DIV2 U_SHSTYLE_NORM U_MEM U_N(11002) U,
5040				U_J(4) U_ALU_OR U_MEM U_N(2) U);
5041		VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
5042		LOAD_U(1,POINTER);				!LOAD 4 INSTRUCTIONS
5043		SET_C(1);					!SET CRAM ADRS TO 1
5044		CP(4);						!PUT DATA IN PC REGISTER
5045		SET_C(4);					!SET CRAM ADRS TO 4
5046		DO (0) WHILE
5047	BLOCK1:	BEGIN
5048		CP(8);						!GIVE 10 OCTAL CLOCKS
5049		RCVDATA = EM(0);				!GET DATA
5050		IF .RCVDATA NEQ %O'20000204000'			!CHECK DATA
5051			THEN ERRCA(1,%O'20000204000',.RCVDATA,12);	!NO
5052	!*MESSAGE 1
5053	!*	SHIFT TEST
5054	!*STIMULUS:
5055	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5056	!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
5057	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5058	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5059	!*	THE FOLLOWING WAS CLOCKED :
5060	!*	SHIFT BOTH HALFS RIGHT 5
5061	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5062	!*RESPONSE:
5063	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5064	!]ERROR 1
5065	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5066		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
5067			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
5068		0						!TO ILLUMINATE BLISS INFO COMMENT
5069	
5070		END;
5071		DM(0,0);					!CLEAR MEM
5072		LC(13);						!LOAD CRAM ADR 13
5073		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
5074		SET_C(4);					!SET CRAM ADRS TO 4
5075		DO (0) WHILE
5076	BLOCK2:	BEGIN
5077		CP(8);						!GIVE 10 OCTAL CLOCKS
5078		RCVDATA = EM(0);				!GET DATA
5079		IF .RCVDATA NEQ %O'20000204000'			!CHECK DATA
5080			THEN ERRCA(2,%O'20000204000',.RCVDATA,12);	!NO
5081	!*MESSAGE 2
5082	!*STIMULUS:
5083	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5084	!*	WITH SPEC SELECT = 0 (SHSTYLE NORM)
5085	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5086	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5087	!*	THE FOLLOWING WAS CLOCKED :
5088	!*	SHIFT BOTH HALFS RIGHT 5
5089	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5090	!*RESPONSE:
5091	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5092	!]ERROR 2
5093	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5094		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
5095			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
5096		0						!TO ILLUMINATE BLISS INFO COMMENT
5097	
5098		END;
5099		LC(6);						!LOAD CRAM ADRS 6
5100		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
5101		LC(7);						!LOAD CRAM ADRS 7
5102		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
5103		LC(10);						!LOAD CRAM ADRS 10
5104		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
5105		LC(11);						!LOAD CRAM ADRS 11
5106		MOD_FLD(2,%O'20');				!MODIFY SHSTYLE TO ONES
5107		LC(12);						!LOAD CRAM ADRS 12
5108		MOD_FLD(2,%O'1020');				!MODIFY SHSTYLE TO ONES
5109		SET_C(4);					!SET CRAM ADRS TO 1
5110		DO (0) WHILE
5111	BLOCK3:	BEGIN
5112		CP(8);						!GIVE 10 OCTAL CLOCKS
5113		RCVDATA = EM(0);				!GET DATA
5114		IF .RCVDATA NEQ %O'174000204000'		!CHECK DATA
5115			THEN ERRCA(3,%O'174000204000',.RCVDATA,12);	!NO
5116	!*MESSAGE 3
5117	!*STIMULUS:
5118	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5119	!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
5120	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5121	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5122	!*	THE FOLLOWING WAS CLOCKED :
5123	!*	SHIFT BOTH HALFS RIGHT 5
5124	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5125	!*RESPONSE:
5126	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5127	!]ERROR 3
5128	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5129		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
5130			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
5131		0						!TO ILLUMINATE BLISS INFO COMMENT
5132	
5133		END;
5134		DM(0,0);					!CLEAR MEM
5135		LC(13);						!LOAD CRAM ADRS 13
5136		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
5137		SET_C(4);					!SET CRAM ADRS TO 4
5138		DO (0) WHILE
5139	BLOCK4:	BEGIN
5140		CP(8);						!GIVE 10 OCTAL CLOCKS
5141		RCVDATA = EM(0);				!GET DATA
5142		IF .RCVDATA NEQ %O'174000204000'		!CHECK DATA
5143			THEN ERRCA(4,%O'174000204000',.RCVDATA,12);	!NO
5144	!*MESSAGE 4
5145	!*STIMULUS:
5146	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5147	!*	WITH SPEC SELECT = 2 (SHSTYLE ONES)
5148	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5149	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5150	!*	THE FOLLOWING WAS CLOCKED :
5151	!*	SHIFT BOTH HALFS RIGHT 5
5152	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5153	!*RESPONSE:
5154	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5155	!]ERROR 4
5156	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5157		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
5158			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
5159		0						!TO ILLUMINATE BLISS INFO COMMENT
5160	
5161		END;
5162		LC(6);						!LOAD CRAM ADRS 6
5163		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
5164		LC(7);						!LOAD CRAM ADRS 7
5165		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
5166		LC(10);						!LOAD CRAM ADRS 10
5167		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
5168		LC(11);						!LOAD CRAM ADRS 11
5169		MOD_FLD(2,%O'30');				!MODIFY SHSTYLE TO ROT
5170		LC(12);						!LOAD CRAM ADRS 12
5171		MOD_FLD(2,%O'1030');				!MODIFY SHSTYLE TO ROT
5172		SET_C(4);					!SET CRAM ADRS TO 4
5173		DO (0) WHILE
5174	BLOCK5:	BEGIN
5175		CP(8);						!GIVE 10 OCTAL CLOCKS
5176		RCVDATA = EM(0);				!CHECK DATA
5177		IF .RCVDATA NEQ %O'40000204000'		!CHECK DATA
5178			THEN ERRCA(5,%O'40000204000',.RCVDATA,12);	!NO
5179	!*MESSAGE 5
5180	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5181	!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
5182	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5183	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5184	!*	THE FOLLOWING WAS CLOCKED :
5185	!*	SHIFT BOTH HALFS RIGHT 5
5186	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5187	!*RESPONSE:
5188	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5189	!]ERROR 5
5190	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5191		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
5192			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
5193		0						!TO ILLUMINATE BLISS INFO COMMENT
5194	
5195		END;
5196		DM(0,0);					!CLEAR MEM
5197		LC(13);						!LOAD CRAM ADRS  13
5198		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
5199		SET_C(4);					!SET CRAM ADRS TO 4
5200		DO (0) WHILE
5201	BLOCK6:	BEGIN
5202		CP(8);						!GIVE 10 OCTAL CLOCKS
5203		RCVDATA = EM(0);				!GET DATA
5204		IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
5205			THEN ERRCA(6,%O'40000204000',.RCVDATA,12);	!NO
5206	!*MESSAGE 6
5207	!*STIMULUS:
5208	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5209	!*	WITH SPEC SELECT = 3 (SHSTYLE ROT)
5210	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5211	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5212	!*	THE FOLLOWING WAS CLOCKED :
5213	!*	SHIFT BOTH HALFS RIGHT 5
5214	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5215	!*RESPONSE:
5216	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5217	!]ERROR 6
5218	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5219		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
5220			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
5221		0						!TO ILLUMINATE BLISS INFO COMMENT
5222	
5223		END;
5224		DM(0,0);					!CLEAR MEM
5225		LC(6);						!LOAD CRAM ADRS 6
5226		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
5227		LC(7);						!LOAD CRAM ADRS 7
5228		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
5229		LC(10);						!LOAD CRAM ADRS 10
5230		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
5231		LC(11);						!LOAD CRAM ADRS 11
5232		MOD_FLD(2,%O'40');				!MODIFY SHSTYLE TO ASHC
5233		LC(12);						!LOAD CRAM ADRS 12
5234		MOD_FLD(2,%O'1040');				!MODIFY SHSTYLE TO ASHC
5235		SET_C(4);					!SET CRAM ADRS TO 4
5236		DO (0) WHILE
5237	BLOCK7:	BEGIN
5238		CP(8);						!GIVE 10 OCTAL CLOCKS
5239		RCVDATA = EM(0);				!GET DATA
5240		IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
5241			THEN ERRCA(7,%O'40000204000',.RCVDATA,12);	!NO
5242	!*MESSAGE 7
5243	!*STIMULUS:
5244	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5245	!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
5246	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5247	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5248	!*	THE FOLLOWING WAS CLOCKED :
5249	!*	SHIFT BOTH HALFS RIGHT 5
5250	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5251	!*RESPONSE:
5252	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5253	!]ERROR 7
5254	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5255		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
5256			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
5257		0						!TO ILLUMINATE BLISS INFO COMMENT
5258	
5259		END;
5260		LC(13);						!LOAD CRAM ADRS 14
5261		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUTPUT REGISTER 0
5262		SET_C(4);					!SET CRAM ADRS TO 4
5263		DO (0) WHILE
5264	BLOCK8:	BEGIN
5265		CP(8);						!GIVE 10 OCTAL CLOCKS
5266		RCVDATA = EM(0);				!GET DATA
5267		IF .RCVDATA NEQ %O'20000204000'			!CHECK DATA
5268			THEN ERRCA(8,%O'20000204000',.RCVDATA,12);	!NO
5269	!*MESSAGE 8
5270	!*STIMULUS:
5271	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5272	!*	WITH SPEC SELECT = 4 (SHSTYLE ASHC)
5273	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5274	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5275	!*	THE FOLLOWING WAS CLOCKED :
5276	!*	SHIFT BOTH HALFS RIGHT 5
5277	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5278	!*RESPONSE:
5279	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5280	!]ERROR 8
5281	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5282		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
5283			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
5284		0						!TO ILLUMINATE BLISS INFO COMMENT
5285	
5286		END;
5287		LC(6);						!LOAD CRAM ADRS 6
5288		MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
5289		LC(7);						!LOAD CRAM ADRS 7
5290		MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
5291		LC(10);						!LOAD CRAM ADRS 10
5292		MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
5293		LC(11);						!LOAD CRAM ADRS 11
5294		MOD_FLD(2,%O'50');				!MODIFY SHSTYLE TO LSHC
5295		LC(12);						!LOAD CRAM ADRS 12
5296		MOD_FLD(2,%O'1050');				!MODIFY SHSTYLE TO LSHC
5297		SET_C(4);					!SET CRAM ADRS TO 4
5298		DO (0) WHILE
5299	BLOCK9:	BEGIN
5300		CP(8);						!GIVE 10 OCTAL CLOCKS
5301		RCVDATA = EM(0);				!GET DATA
5302		IF .RCVDATA NEQ %O'204000'			!CHECK DATA
5303			THEN ERRCA(9,%O'204000',.RCVDATA,12);	!NO
5304	!*MESSAGE 9
5305	!*STIMULUS:
5306	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5307	!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
5308	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5309	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5310	!*	THE FOLLOWING WAS CLOCKED :
5311	!*	SHIFT BOTH HALFS RIGHT 5
5312	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5313	!*RESPONSE:
5314	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5315	!]ERROR 9
5316	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5317		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
5318			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
5319		0						!TO ILLUMINATE BLISS INFO COMMENT
5320	
5321		END;
5322		LC(13);						!SET CRAM ADRS TO 13
5323		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
5324		SET_C(4);					!SET CRAM ADRS TO 4
5325		DO (0) WHILE
5326	BLOCK10:BEGIN
5327		CP(8);						!GIVE 10OCTAL CLOCKS
5328		RCVDATA = EM(0);				!GET DATA
5329		IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
5330			THEN ERRCA(10,%O'40000204000',.RCVDATA,12);	!NO
5331	!*MESSAGE 10
5332	!*	STIMULUS :
5333	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5334	!*	WITH SPEC SELECT = 5 (SHSTYLE LSHC)
5335	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5336	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5337	!*	THE FOLLOWING WAS CLOCKED :
5338	!*	SHIFT BOTH HALFS RIGHT 5
5339	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5340	!*RESPONSE:
5341	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5342	!]ERROR 10
5343	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5344		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
5345			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
5346		0						!TO ILLUMINATE BLISS INFO COMMENT
5347	
5348		END;
5349		DM(0,0);					!CLEAR MEM
5350		LC(6);						!LOAD CRAM ADRS 6
5351		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
5352		LC(7);						!LOAD CRAM ADRS 7
5353		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
5354		LC(10);						!LOAD CRAM ADRS 10
5355		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
5356		LC(11);						!LOAD CRAM ADRS 11
5357		MOD_FLD(2,%O'60');				!MODIFY SHSTYLE TO DIV
5358		LC(12);						!LOAD CRAM ADRS 12
5359		MOD_FLD(2,%O'1060');				!MODIFY SHSTYLE TO DIV
5360		SET_C(4);					!SET CRAM ADRS TO 4
5361		DO (0) WHILE
5362	BLOCK11:BEGIN
5363		CP(8);						!GIVE 10 OCTAL CLOCKS
5364		RCVDATA = EM(0);				!GET DATA
5365		IF .RCVDATA NEQ %O'40000204000'		!CHECK DATA
5366			THEN ERRCA(11,%O'40000204000',.RCVDATA,12);	!NO
5367	!*MESSAGE 11
5368	!*STIMULUS:
5369	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5370	!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
5371	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5372	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5373	!*	THE FOLLOWING WAS CLOCKED :
5374	!*	SHIFT BOTH HALFS RIGHT 5
5375	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5376	!*RESPONSE:
5377	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5378	!]ERROR 11
5379	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5380		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
5381			THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
5382		0						!TO ILLUMINATE BLISS INFO COMMENT
5383	
5384		END;
5385		LC(13);						!LOAD CRAM ADRS 13
5386		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
5387		SET_C(4);					!SET CRAM ADRS TO 4
5388		DO (0) WHILE
5389	BLOCK12:BEGIN
5390		CP(8);						!GIVE 10 OCTAL CLOCKS
5391		RCVDATA = EM(0);				!GET DATA
5392		IF .RCVDATA NEQ %O'174000204000'		!CHECK DATA
5393			THEN ERRCA(12,%O'174000204000',.RCVDATA,12);	!NO
5394	!*MESSAGE 12
5395	!*STIMULUS:
5396	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5397	!*	WITH SPEC SELECT = 6 (SHSTYLE DIV)
5398	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5399	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5400	!*	THE FOLLOWING WAS CLOCKED :
5401	!*	SHIFT BOTH HALFS RIGHT 5
5402	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5403	!*RESPONSE:
5404	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5405	!]ERROR 12
5406	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5407		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
5408			THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
5409		0						!TO ILLUMINATE BLISS INFO COMMENT
5410	
5411		END;
5412		DM(0,0);					!CLEAR MEM
5413		LC(6);						!LOAD CRAM ADRS 6
5414		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
5415		LC(7);						!LOAD CRAM ADRS 7
5416		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
5417		LC(10);						!LOAD CRAM ADRS 10
5418		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
5419		LC(11);						!LOAD CRAM ADRS 11
5420		MOD_FLD(2,%O'70');				!MODIFY SHSTYLE TO ROTC
5421		LC(12);						!LOAD CRAM ADRS 12
5422		MOD_FLD(2,%O'1070');				!MODIFY SHSTYLE TO ROTC
5423		SET_C(4);					!SET CRAM ADRS TO 4
5424		DO (0) WHILE
5425	BLOCK13:BEGIN
5426		CP(8);						!GIVE 10 OCTAL CLOCKS
5427		RCVDATA = EM(0);				!GET DATA
5428		IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
5429			THEN ERRCA(13,%O'40000204000',.RCVDATA,12);	!NO
5430	!*MESSAGE 13
5431	!*STIMULUS:
5432	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5433	!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
5434	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5435	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5436	!*	THE FOLLOWING WAS CLOCKED :
5437	!*	SHIFT BOTH HALFS RIGHT 5
5438	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5439	!*RESPONSE:
5440	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5441	!]ERROR 13
5442	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5443		IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
5444			THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
5445		0						!TO ILLUMINATE BLISS INFO COMMENT
5446	
5447		END;
5448		DM(0,0);					!CLEAR MEM
5449		LC(13);						!LOAD CRAM ADRS 13
5450		MOD_FLD(5,%O'3227');				!MODIFY LSRC TO OUPUT Q
5451		SET_C(4);					!SET CRAM ADRS TO 4
5452		DO (0) WHILE
5453	BLOCK14:BEGIN
5454		CP(8);						!GIVE 10 OCTAL CLOCKS
5455		RCVDATA = EM(0);				!GET DATA
5456		IF .RCVDATA NEQ %O'40000204000'			!CHECK DATA
5457			THEN ERRCA(14,%O'40000204000',.RCVDATA,12);	!NO
5458	!*MESSAGE 14
5459	!*STIMULUS:
5460	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5461	!*	WITH SPEC SELECT = 7 (SHSTYLE ROTC)
5462	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5463	!*	(Y1 = DPE1 DP SIGN SMEAR, IS ALSO SET IN BOTH REGISTERS)
5464	!*	THE FOLLOWING WAS CLOCKED :
5465	!*	SHIFT BOTH HALFS RIGHT 5
5466	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5467	!*RESPONSE:
5468	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5469	!]ERROR 14
5470	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5471		IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
5472			THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
5473		0						!TO ILLUMINATE BLISS INFO COMMENT
5474	
5475		END;
5476		LC(6);						!LOAD CRAM ADRS 6
5477		MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
5478		LC(7);						!LOAD CRAM ADRS 7
5479		MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
5480		LC(10);						!LOAD CRAM ADRS 10
5481		MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
5482		LC(11);						!LOAD CRAM ADRS 11
5483		MOD_FLD(2,%O'10');				!MODIFY SHSTYLE TO ZERO
5484		LC(12);						!LOAD CRAM ADRS 12
5485		MOD_FLD(2,%O'1010');				!MODIFY SHSTYLE TO ZERO
5486		LC(1);						!LOAD CRAM ADRS 1
5487		MOD_FLD(4,%O'40');				!MODIFY DATA TO 400000400000
5488		CP(4);						!PUT DATA IN PC REGISTER
5489		SET_C(4);					!SET CRAM ADRS TO 4
5490		DO (0) WHILE
5491	BLOCK15:BEGIN
5492		CP(8);						!GIVE 10 OCTAL CLOCKS
5493		RCVDATA = EM(0);				!GET DATA
5494		IF .RCVDATA NEQ %O'270000'			!CHECK DATA
5495			THEN ERRCA(15,%O'270000',.RCVDATA,12);	!NO
5496	!*MESSAGE 15
5497	!*STIMULUS:
5498	!*	DID A RIGHT SHIFT 5 TO THE Q REGISTER 
5499	!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
5500	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5501	!*	(Y0 = DPE1 DP SIGN H, IS ALSO SET IN BOTH REGISTERS)
5502	!*	THE FOLLOWING WAS CLOCKED :
5503	!*	SHIFT BOTH HALFS RIGHT 5
5504	!*	THEN OUTPUT THE DATA FROM THE Q REGISTER TO MEM
5505	!*RESPONSE:
5506	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5507	!]ERROR 15
5508	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5509		IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
5510			THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
5511		0						!TO ILLUMINATE BLISS INFO COMMENT
5512	
5513		END;
5514		LC(13);						!LOAD CRAM ADRS 13
5515		MOD_FLD(5,%O'3447');				!MODIFY LSRC TO OUPUT REGISTER 0
5516		SET_C(4);					!SET CRAM ADRS TO 4
5517		DO (0) WHILE
5518	BLOCK16:BEGIN
5519		CP(8);						!GIVE 10 OCTAL CLOCKS
5520		RCVDATA = EM(0);				!GET DATA
5521		IF .RCVDATA NEQ %O'600000270000'		!CHECK DATA
5522			THEN ERRCA(16,%O'600000270000',.RCVDATA,12);	!NO
5523	!*MESSAGE 16
5524	!*STIMULUS:
5525	!*	DID A RIGHT SHIFT 5 TO REGISTER 0
5526	!*	WITH SPEC SELECT = 1 (SHSTYLE ZERO)
5527	!*	INITIAL DATA IN REGISTERS Q & 0  = 10,,200002
5528	!*	(Y0 = DPE1 DP SIGN H, IS ALSO SET IN BOTH REGISTERS)
5529	!*	THE FOLLOWING WAS CLOCKED :
5530	!*	SHIFT BOTH HALFS RIGHT 5
5531	!*	THEN OUTPUT THE DATA FROM REGISTER 0 TO MEM
5532	!*RESPONSE:
5533	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5534	!]ERROR 16
5535	!]M2901S DBMDBUS DBUSSEL DPCLKS SHIFT MEMVMA NTWK
5536		IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
5537			THEN LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
5538		0						!TO ILLUMINATE BLISS INFO COMMENT
5539	
5540		END;
5541		END;
5542	
5543	GLOBAL ROUTINE TST27: NOVALUE =
5544	
5545	!THIS A TEST FOR THE INHIBIT CARRY INTO LEFT HALF.
5546	!ALL 7 INSTRUCTIONS REQUIRED TO PERFORM THIS TEST ARE LOADED
5547	!SEQUENTIALLY INTO THE CRAM STARTING WITH CRAM LOCATION 1.
5548	!ALL 7 INSTRUCTIONS ARE EXECUTED TWICE.THE INSTUCTIONS DO THE FOLLOWING:
5549	!CRAM 1/ PUT A 0 IN BOTH HALFS OF REGISTER 0
5550	!CRAM 2/ PUT 700000 IN RIGHT HALF OF REGISTER 0
5551	!CRAM 3/ ADD THE CONTENTS OF REGISTER 0 TO ITSELF
5552	!CRAM 4/ ADD THE CONTENTS OF REGISTER 0 TO ITSELF
5553	!CRAM 5/ ADD THE CONTENTS OF REGISTER 0 TO ITSELF
5554	!CRAM 6/ START A MEM WRITE CYCLE
5555	!CRAM 7/ FINISH MEM WRITE CYCLE BY OUTPUTTING THE CONTENTS OF REGISTER 0 TO MEM.
5556	!THE SECOND TIME THE INSTRUCTIONS ARE EXECUTED CRAM 4 IS MODIFIED TO 
5557	!CONTAIN SPEC SELECT = 40 (INHIBIT CARRY INTO LEFT HALF).ALL DATA IS PASSED
5558	!TO AND VERIFIED FROM PHYSICAL MEM 0.
5559	
5560		BEGIN
5561		OWN TEST_FLG;
5562		LABEL BLOCK1,BLOCK2;
5563		BIND
5564		POINTER = PLIT (U_J(2) U_DEST_AD U,
5565				U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(700000) U_NO_CLKL U,
5566				U_J(4) U_ALU_ADD U_LSRC_AB U_DEST_AD U,
5567				U_J(5) U_ALU_ADD U_LSRC_AB U_DEST_AD U,
5568				U_J(6) U_ALU_ADD U_LSRC_AB U_DEST_AD U,
5569				U_J(7) U_MEM U_N(11012) U,
5570				U_J(1) U_ALU_OR U_MEM U_N(2) U);
5571	
5572		LOAD_U(1,POINTER);				!LOAD 7 INSTRUCTIONS
5573		TEST_FLG = 0;
5574		SET_C(1);					!SET CRAM ADRS TO 1
5575		DO (0) WHILE
5576	BLOCK1:	BEGIN
5577		CP(7);						!GIVE 7 CLOCKS
5578		RCVDATA = EM(0);				!GET DATA
5579		IF .RCVDATA NEQ %O'7000000'			!CHECK DATA
5580			THEN BEGIN
5581				ERRCA(1,%O'7000000',.RCVDATA,12);!NO
5582				TEST_FLG = 1;
5583			     END;
5584	!*MESSAGE 1
5585	!*	DP CRY TEST
5586	!*STIMULUS:
5587	!*	PUT 700000 IN REGISTER 0
5588	!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF 3 TIMES
5589	!*	FINALLY OUTPUT THE CONTENTS OF REGISTER 0 TO MEM
5590	!*RESPONSE:
5591	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5592	!]ERROR 1
5593	!]M2902S SPEC18CRY NTWK
5594		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
5595			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
5596		0						!TO ILLUMINATE BLISS INFO COMMENT
5597	
5598		END;
5599		LC(4);						!LOAD CRAM ADRS 4
5600		MOD_FLD(1,%O'6747');				!MODIFY SPEC TO INHIBIT CARY
5601		SET_C(1);					!SET CRAM ADRS TO 1
5602		DO (0) WHILE
5603	BLOCK2:	BEGIN
5604		CP(7);						!GIVE 7 CLOCKS
5605		RCVDATA = EM(0);				!GET DATA
5606		IF .RCVDATA NEQ %O'5000000'			!CHECK DATA
5607			THEN ERRCA(2,%O'5000000',.RCVDATA,12)!NO
5608			ELSE IF .TEST_FLG EQL 0
5609				THEN NOERR(1);
5610	!*MESSAGE 2
5611	!*STIMULUS:
5612	!*	PUT 700000 IN REGISTER 0
5613	!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF ONCE
5614	!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF AGAIN WITH SPEC FIELD = 40 (CARRY INHIBIT)
5615	!*	THEN ADD THE CONTENTS OF REGISTER 0 TO ITSELF A THIRD TIME
5616	!*	FINALLY OUTPUT THE CONTENTS OF REGISTER 0 TO MEM
5617	!*RESPONSE:
5618	!*	EXAMINE DATA FROM PHYSICAL MEM 0
5619	!]ERROR 2
5620	!]M2902S SPEC18CRY NTWK
5621	!]NO ERROR 1
5622	!]SPEC18CRY NTWK
5623		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
5624			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
5625		0						!TO ILLUMINATE BLISS INFO COMMENT
5626	
5627		END;
5628		END;
5629	
5630	GLOBAL ROUTINE TST28: NOVALUE =
5631	
5632	!THIS TEST CHECKS ADL=0 & ADR=0 OUTPUTS OF THE 2901'S AS WELL AS THE 
5633	!SKIP SELECTS ON THOSE BITS.
5634	!THIS TEST WILL EXECUTE 1 INSTRUCTION IN CRAM 1. THE J FIELD OF THIS
5635	!INSTRUCTION IS 0. IF THE INSTRUCTION SKIPS THE NXT CRAM ADRS BECOMES A 1
5636	!AFTER EACH TIME THE INSTRUCTION IS EXECUTED SKIP SELECT IS MODIFIED 
5637	!TO SELECT A DIFFERENT SET OF CONDITIONS FOR THE SKIP SELCT.
5638	!THE NXT CRAM ADRS IS ALWAYS CHECKED AND VERIFIED.
5639	
5640		BEGIN
5641		OWN TEST_FLG;
5642		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
5643		BIND
5644		POINTER = PLIT (U_ALU_XOR U_LSRC_AB U_SKIP_ADREQ0 U);
5645	
5646		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
5647		ER_TAB[0] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
5648		ER_TAB[1] = UPLIT (%ASCIZ'ADR');		!FOR ERROR PRINTOUT
5649		ER_TAB[2] = 0;					!FOR ERROR PRINTOUT
5650		TEST_FLG = 0;
5651		DO (0) WHILE
5652	BLOCK1:	BEGIN
5653		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5654		IF .RCVDATA NEQ 1				!CHECK DATA
5655			THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
5656		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
5657			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
5658		0						!TO ILLUMINATE BLISS INFO COMMENT
5659	
5660		END;
5661		MOD_FLD(2,2);					!MODIFY TO SKIP ON ADL=0
5662		ER_TAB[1] = UPLIT (%ASCIZ'ADL');		!FOR ERROR PRINTOUT
5663		DO (0) WHILE
5664	BLOCK2:	BEGIN
5665		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5666		IF .RCVDATA NEQ 1				!CHECK DATA
5667			THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
5668		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
5669			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
5670		0						!TO ILLUMINATE BLISS INFO COMMENT
5671	
5672		END;
5673		MOD_FLD(1,%O'6607');				!MODIFY TO SKIP ON ADEQ0
5674		ER_TAB[1] = UPLIT(%ASCIZ'ADEQ0 ');		!FOR ERROR
5675		DO (0) WHILE
5676	BLOCK3:	BEGIN
5677		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GT NXT ADRS
5678		IF .RCVDATA NEQ 1
5679			THEN BEGIN
5680				ERRCAS(2,1,1,.RCVDATA,4,ER_TAB);
5681				TEST_FLG = 1;
5682			    END;
5683		IF LOOP_CHK(3)
5684			THEN LEAVE BLOCK3 WITH 1;
5685		0						!TO ILLUMINATE BLISS INFO COMMENT
5686	
5687		END;
5688		MOD_FLD(5,%O'7117');				!CHANGE DATA TO A -1
5689		ER_TAB[0] = UPLIT (%ASCIZ'NOT ');		!FOR ERROR PRINTOUT
5690		ER_TAB[2] = -1;					!FOR ERROR PRINTOUT
5691		DO (0) WHILE
5692	BLOCK4:	BEGIN
5693		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5694		IF .RCVDATA NEQ 0				!CHECK DATA
5695			THEN ERRCAS(2,1,0,.RCVDATA,4,ER_TAB)	!NO
5696			ELSE IF .TEST_FLG EQL 0
5697				THEN NOERR(1);
5698		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
5699			THEN 
5700			BEGIN
5701			    SET_C(0);				!SET CRAM ADRS TO 0
5702			    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
5703			END;
5704		0						!TO ILLUMINATE BLISS INFO COMMENT
5705	
5706		END;
5707		MOD_FLD(1,%O'6307');				!MODIFY TO SKIP ON ADL
5708		ER_TAB[1] = UPLIT (%ASCIZ'ADL');		!FOR ERROR PRINTOUT
5709		DO (0) WHILE
5710	BLOCK5:	BEGIN
5711		RCVDATA = STEP_U_NEXT(1);			!GIVE CLK & GET NXT CRAM ADRS
5712		IF .RCVDATA NEQ 0				!CHECK DATA
5713			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5714		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
5715			THEN 
5716			BEGIN
5717			    SET_C(0);				!SET CRAM ADRS TO 0
5718			    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
5719			END;
5720		0						!TO ILLUMINATE BLISS INFO COMMENT
5721	
5722		END;
5723		MOD_FLD(2,3);					!SKIP ON ADR
5724		ER_TAB[1] = UPLIT(%ASCIZ'ADR ');		!FOR ERROR
5725		DO (0) WHILE
5726	BLOCK6:	BEGIN
5727		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK
5728		IF .RCVDATA NEQ 0
5729			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);
5730		IF LOOP_CHK(6)
5731			THEN BEGIN
5732				SET_C(0);
5733				LEAVE BLOCK6 WITH 1;
5734			     END;
5735		0						!TO ILLUMINATE BLISS INFO COMMENT
5736	
5737		END;
5738	!*MESSAGE 1
5739	!*	DP TEST
5740	!*STIMULUS:
5741	!*	OUTPUT \O2 FROM BOTH HALF OF THE 2901'S
5742	!*	THEN SKIP IF \S1 = 0
5743	!*	THE CURRENT J FIELD IS 0
5744	!*	IT SHOULD \S0SKIP
5745	!*RESPONSE:
5746	!*	EXAMINE NXT CRAM ADRS
5747	!]NO ERROR 1
5748	!]ADEQ0 NTWK
5749	!]ERROR 1
5750	!]SKIP NTWK
5751	!]ERROR 2
5752	!]ADEQ0 NTWK
5753		END;
5754		
5755	GLOBAL ROUTINE TST29: NOVALUE =
5756	
5757	!THIS TEST CHECKS ALL THE BYTE DISPATCH LOGIC ON DPE3.
5758	!THIS TEST WILL SIMPLY PASS A DATA WORD FROM THE MAGIC # FIELD ONTO
5759	!BOTH HALFS OF DP VIA DBUS. AND DO A BYTE DISPATCH.
5760	!AFTER THIS EXECUTION WHICH RESIDES IN CRAM 0 WITH THE ORED J FIELD = 0
5761	!WE EXAMINE THE NXT CRAM ADRS AND VERIFY IT.
5762	!AFTER EACH EXECUTION THE # FIELD IS MODIFIED IN THE CRAM TO SET UP THE
5763	!DATA WORD TO BE PUSHED ONTO DP.
5764	
5765		BEGIN
5766		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,
5767		      BLOCK7,BLOCK8,BLOCK9,BLOCK10,BLOCK11,BLOCK12,
5768		      BLOCK13,BLOCK14,BLOCK15,BLOCK16,BLOCK17,BLOCK18,BLOCK19;
5769		BIND
5770		POINTER = PLIT (U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DISP_BYTE U_N(27000) U);
5771	
5772		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
5773		ER_TAB[0] = %O'27000';				!FOR ERROR PRINTOUT
5774		DO (0) WHILE
5775	BLOCK1:	BEGIN
5776		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5777		IF .RCVDATA NEQ 0				!CHECK DATA
5778			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5779		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
5780			THEN 
5781			BEGIN
5782			    SET_C(0);				!SET CRAM ADRS TO 1
5783			    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
5784			END;
5785		0						!TO ILLUMINATE BLISS INFO COMMENT
5786	
5787		END;
5788		MOD_FLD(4,2);					!MODIFY DP TO 37000
5789		ER_TAB[0] = %O'37000';				!FOR ERROR PRINTOUT
5790		DO (0) WHILE
5791	BLOCK2:	BEGIN
5792		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5793		IF .RCVDATA NEQ 0				!CHECK DATA
5794			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5795		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
5796			THEN 
5797			BEGIN
5798			    SET_C(0);				!SET CRAM ADRS TO 1
5799			    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
5800			END;
5801		0						!TO ILLUMINATE BLISS INFO COMMENT
5802	
5803		END;
5804		MOD_FLD(4,4);					!DP GETS 47000
5805		ER_TAB[0] = %O'47000';				!FOR ERROR PRINTOUT
5806		DO (0) WHILE
5807	BLOCK3:	BEGIN
5808		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5809		IF .RCVDATA NEQ 0				!CHECK DATA
5810			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5811		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
5812			THEN 
5813			BEGIN
5814			    SET_C(0);				!SET CRAM ADRS TO 1
5815			    LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
5816			END;
5817		0						!TO ILLUMINATE BLISS INFO COMMENT
5818	
5819		END;
5820		MOD_FLD(4,7);					!DP GETS 77000
5821		ER_TAB[0] = %O'77000';				!FOR ERROR PRINTOUT
5822		DO (0) WHILE
5823	BLOCK4:	BEGIN
5824		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5825		IF .RCVDATA NEQ 0				!CHECK DATA
5826			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5827		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
5828			THEN 
5829			BEGIN
5830			    SET_C(0);				!SET CRAM ADRS TO 1
5831			    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
5832			END;
5833		0						!TO ILLUMINATE BLISS INFO COMMENT
5834	
5835		END;
5836		MOD_FLD(4,0);					!DP GETS 7000
5837		ER_TAB[0] = %O'7000';				!FOR ERROR PRINTOUT
5838		DO (0) WHILE
5839	BLOCK5:	BEGIN
5840		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5841		IF .RCVDATA NEQ 0				!CHECK DATA
5842			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5843		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
5844			THEN 
5845			BEGIN
5846			    SET_C(0);				!SET CRAM ADRS TO 1
5847			    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
5848			END;
5849		0						!TO ILLUMINATE BLISS INFO COMMENT
5850	
5851		END;
5852		MOD_FLD(4,5);					!DP GETS 57000
5853		ER_TAB[0] = %O'57000';				!FOR ERROR PRINTOUT
5854		DO (0) WHILE
5855	BLOCK6:	BEGIN
5856		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5857		IF .RCVDATA NEQ 0				!CHECK DATA
5858			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5859		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
5860			THEN 
5861			BEGIN
5862			    SET_C(0);				!SET CRAM ADRS TO 1
5863			    LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
5864			END;
5865		0						!TO ILLUMINATE BLISS INFO COMMENT
5866	
5867		END;
5868		MOD_FLD(4,6);					!DP GETS 67000
5869		ER_TAB[0] = %O'67000';				!FOR ERROR PRINTOUT
5870		DO (0) WHILE
5871	BLOCK7:	BEGIN
5872		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5873		IF .RCVDATA NEQ 0				!CHECK DATA
5874			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5875		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
5876			THEN 
5877			BEGIN
5878			    SET_C(0);				!SET CRAM ADRS TO 1
5879			    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
5880			END;
5881		0						!TO ILLUMINATE BLISS INFO COMMENT
5882	
5883		END;
5884		MOD_FLD(4,1);					!DP GETS 17000
5885		ER_TAB[0] = %O'17000';				!FOR ERROR PRINTOUT
5886		DO (0) WHILE
5887	BLOCK8:	BEGIN
5888		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5889		IF .RCVDATA NEQ 0				!CHECK DATA
5890			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5891		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
5892			THEN 
5893			BEGIN
5894			    SET_C(0);				!SET CRAM ADRS TO 1
5895			    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
5896			END;
5897		0						!TO ILLUMINATE BLISS INFO COMMENT
5898	
5899		END;
5900		MOD_FLD(3,%O'300');				!DP GETS 10300
5901		ER_TAB[0] = %O'10300';				!FOR ERROR PRINTOUT
5902		DO (0) WHILE
5903	BLOCK9:	BEGIN
5904		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5905		IF .RCVDATA NEQ 0				!CHECK DATA
5906			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5907		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
5908			THEN 
5909			BEGIN
5910			    SET_C(0);				!SET CRAM ADRS TO 1
5911			    LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
5912			END;
5913		0						!TO ILLUMINATE BLISS INFO COMMENT
5914	
5915		END;
5916		MOD_FLD(3,%O'500');				!DP GETS 10500
5917		ER_TAB[0] = %O'10500';				!FOR ERROR PRINTOUT
5918		DO (0) WHILE
5919	BLOCK10:BEGIN
5920		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5921		IF .RCVDATA NEQ 0				!CHECK DATA
5922			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5923		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
5924			THEN 
5925			BEGIN
5926			    SET_C(0);				!SET CRAM ADRS TO 1
5927			    LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
5928			END;
5929		0						!TO ILLUMINATE BLISS INFO COMMENT
5930	
5931		END;
5932		MOD_FLD(3,%O'600');				!DP GETS 10600
5933		ER_TAB[0] = %O'10600';				!FOR ERROR PRINTOUT
5934		DO (0) WHILE
5935	BLOCK11:BEGIN
5936		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5937		IF .RCVDATA NEQ 0				!CHECK DATA
5938			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5939		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
5940			THEN 
5941			BEGIN
5942			    SET_C(0);				!SET CRAM ADRS TO 1
5943			    LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
5944			END;
5945		0						!TO ILLUMINATE BLISS INFO COMMENT
5946	
5947		END;
5948		MOD_FLD(3,%O'700');				!DP GETS 10700
5949		ER_TAB[0] = %O'10700';				!FOR ERROR PRINTOUT
5950		DO (0) WHILE
5951	BLOCK12:BEGIN
5952		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5953		IF .RCVDATA NEQ 7				!CHECK DATA
5954			THEN ERRCAS(1,1,7,.RCVDATA,4,ER_TAB);	!NO
5955		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
5956			THEN 
5957			BEGIN
5958			    SET_C(0);				!SET CRAM ADRS TO 1
5959			    LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
5960			END;
5961		0						!TO ILLUMINATE BLISS INFO COMMENT
5962	
5963		END;
5964		MOD_FLD(3,%O'4700');				!DP GETS 14700
5965		ER_TAB[0] = %O'14700';				!FOR ERROR PRINTOUT
5966		DO (0) WHILE
5967	BLOCK13:BEGIN
5968		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5969		IF .RCVDATA NEQ 0				!CHECK DATA
5970			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5971		IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
5972			THEN 
5973			BEGIN
5974			    SET_C(0);				!SET CRAM ADRS TO 1
5975			    LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
5976			END;
5977		0						!TO ILLUMINATE BLISS INFO COMMENT
5978	
5979		END;
5980		MOD_FLD(3,%O'2700');				!DP GETS 12700
5981		ER_TAB[0] = %O'12700';				!FOR ERROR PRINTOUT
5982		DO (0) WHILE
5983	BLOCK14:BEGIN
5984		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
5985		IF .RCVDATA NEQ 0				!CHECK DATA
5986			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
5987		IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
5988			THEN 
5989			BEGIN
5990			    SET_C(0);				!SET CRAM ADRS TO 1
5991			    LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
5992			END;
5993		0						!TO ILLUMINATE BLISS INFO COMMENT
5994	
5995		END;
5996		MOD_FLD(3,%O'1700');				!DP GETS 11700
5997		ER_TAB[0] = %O'11700';				!FOR ERROR PRINTOUT
5998		DO (0) WHILE
5999	BLOCK15:BEGIN
6000		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
6001		IF .RCVDATA NEQ 0				!CHECK DATA
6002			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
6003		IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
6004			THEN 
6005			BEGIN
6006			    SET_C(0);				!SET CRAM ADRS TO 1
6007			    LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
6008			END;
6009		0						!TO ILLUMINATE BLISS INFO COMMENT
6010	
6011		END;
6012		MOD_FLD(3,%O'700');				!DP GETS
6013		MOD_FLD(4,%O'10');				!100700
6014		ER_TAB[0] = %O'100700';			!FOR ERROR PRINTOUT
6015		DO (0) WHILE
6016	BLOCK16:BEGIN
6017		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
6018		IF .RCVDATA NEQ 5				!CHECK DATA
6019			THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
6020		IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
6021			THEN 
6022			BEGIN
6023			    SET_C(0);				!SET CRAM ADRS TO 1
6024			    LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
6025			END;
6026		0						!TO ILLUMINATE BLISS INFO COMMENT
6027	
6028		END;
6029		MOD_FLD(4,%O'17');				!DP GETS 170700
6030		ER_TAB[0] = %O'170700';			!FOR ERROR PRINTOUT
6031		DO (0) WHILE
6032	BLOCK17:BEGIN
6033		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
6034		IF .RCVDATA NEQ 4				!CHECK DATA
6035			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
6036		IF LOOP_CHK(17)					!IS LOOP ON ERROR SET ?
6037			THEN 
6038			BEGIN
6039			    SET_C(0);				!SET CRAM ADRS TO 1
6040			    LEAVE BLOCK17 WITH 1;		!LEAVE BLOCK TO LOOP
6041			END;
6042		0						!TO ILLUMINATE BLISS INFO COMMENT
6043	
6044		END;
6045		MOD_FLD(4,%O'26');				!DP GETS 260700
6046		ER_TAB[0] = %O'260700';			!FOR ERROR PRINTOUT
6047		DO (0) WHILE
6048	BLOCK18:BEGIN
6049		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
6050		IF .RCVDATA NEQ 2				!CHECK DATA
6051			THEN ERRCAS(1,1,2,.RCVDATA,4,ER_TAB);	!NO
6052		IF LOOP_CHK(18)					!IS LOOP ON ERROR SET ?
6053			THEN 
6054			BEGIN
6055			    SET_C(0);				!SET CRAM ADRS TO 1
6056			    LEAVE BLOCK18 WITH 1;		!LEAVE BLOCK TO LOOP
6057			END;
6058		0						!TO ILLUMINATE BLISS INFO COMMENT
6059	
6060		END;
6061		MOD_FLD(4,%O'35');				!DP GETS 350700
6062		ER_TAB[0] = %O'350700';			!FOR ERROR PRINTOUT
6063		DO (0) WHILE
6064	BLOCK19:BEGIN
6065		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK & GET NXT CRAM ADRS
6066		IF .RCVDATA NEQ 1				!CHECK DATA
6067			THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
6068		IF LOOP_CHK(19)					!IS LOOP ON ERROR SET ?
6069			THEN 
6070			BEGIN
6071			    SET_C(0);				!SET CRAM ADRS TO 1
6072			    LEAVE BLOCK19 WITH 1;		!LEAVE BLOCK TO LOOP
6073			END;
6074		0						!TO ILLUMINATE BLISS INFO COMMENT
6075	
6076		END;
6077	!*MESSAGE 1
6078	!*	BYTE DISP LOGIC TEST (DPE3)
6079	!*STIMULUS:
6080	!*	PASS A DATA WORD FROM THE MAGIC # FIELD (\O0)
6081	!*	TO BOTH HALFS OF DP VIA DBUS.
6082	!*	DO A BYTE DISPATCH
6083	!*	EXAMINE NXT CRAM ADRS
6084	!*RESPONSE:
6085	!]ERROR 1
6086	!]BITE NTWK
6087		END;
6088	
6089	GLOBAL ROUTINE TST30: NOVALUE =
6090	
6091	!THIS TEST CHECKS ALL THE DBUS MIX'S FOR DBUS SELCT = 0 GROUNDED PINS
6092	!BITS (7,8,13,14,15,16,17 & 18) AS WELL AS THE DBUS PARITY INPUT FOR SELECT 0.
6093	!WE EXECUTE 2 INSTRUCTIONS IN CRAM 1 & 2 DOING THE FOLLOWING:
6094	!CRAM 1/START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A ZERO
6095	!CRAM 2/ FINISH THE MEM CYCLE AND OUTPUT THE DBUS (DBUS SELECT = 0) INTO
6096	!	 MEM VIA THE 2901'S.
6097	!THE DATA IS THEN READ FROM MEM AND ALL THE BITS IN SUBJECT ARE TESTED !FOR LO.ANY DISCREPANCY WILL YIELD AN ERROR.
6098	!CRAM 3/ SELECT DBUS INPUT 0 (PC,FLGS,PI NEW) AND CHKL/R HALFS OF DBUS.
6099	!	 (WE SHOULD NEVER GET A PARITY ERROR).
6100		BEGIN
6101		LABEL BLOCK1,BLOCK2,BLOCK3;
6102		BIND
6103		POINTER = PLIT (U_J(2) U_MEM U_N(11012) U,
6104				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U,
6105				U_J(3) U_DBUS_PC_FLAGS U_CHKL U);
6106	
6107		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
6108		SET_C(1);					!SET CRAM ADRS TO 1
6109		DO (0) WHILE
6110	BLOCK1:	BEGIN
6111		CP(2);						!GIVE 2 CLOCKS
6112		RCVDATA = EM(0);				!GET DATA FROM MEM
6113		RCVDATA = .RCVDATA AND %O'3037400000';		!CLEAN UNWANTED BITS
6114		IF .RCVDATA NEQ 0				!CHECK DATA
6115			THEN BEGIN
6116				ERRCA(1,0,.RCVDATA,12);		!NO
6117				PCDBUS_FLG = 1;
6118			     END
6119			ELSE IF .DBMDBUS_FLG EQL 0
6120			THEN NOERR(1);
6121		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
6122			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
6123		0						!TO ILLUMINATE BLISS INFO COMMENT
6124	
6125		END;
6126	!*MESSAGE 1
6127	!*	DBUS TEST
6128	!*STIMULUS:
6129	!*	DBUS SELECT 0 GROUND PINS (DPE3 & 4)
6130	!*	START A MEM CYCLE & LOAD THE VMA WITH 0
6131	!*	FINISH MEM CYCLE AND OUTPUT DATA FROM DBUS (DBUS SELECT = 0)
6132	!*	INTO MEM VIA DP
6133	!*	ALL TESTED PINS SHOULD BE LO
6134	!*RESPONSE:
6135	!*	EXAMINE DATA FROM MEM 0
6136	!]ERROR 1
6137	!]PCDBUS DBUSSEL NTWK
6138	!]NO ERROR 1
6139	!]DBUSSEL NTWK
6140		SET_C(3);					!SET CRAM ADRS TO 3
6141		ER_TAB[0] = UPLIT(%ASCIZ'LEFT');		!FOR ERROR
6142		DO (0) WHILE
6143	BLOCK2:	BEGIN
6144		CP(3);						!GIVE 3 CLOCKS
6145		RCVDATA = RD_100;				!GET THE DATA
6146		IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
6147			THEN ERRCAS(2,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
6148		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
6149			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
6150		0						!TO ILLUMINATE BLISS INFO COMMENT
6151	
6152			END;
6153		MOD_FLD(7,%O'4304');				!MODIFY TO CHKR
6154		ER_TAB[0] = UPLIT(%ASCIZ'RIGHT');		!FOR ERROR
6155		DO (0) WHILE
6156	BLOCK3:	BEGIN
6157		CP(3);						!GIVE 3 CLOCKS
6158		RCVDATA = RD_100;				!GET THE DATA
6159		IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
6160			THEN ERRCAS(3,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
6161		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
6162			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
6163		0						!TO ILLUMINATE BLISS INFO COMMENT
6164	
6165		END;
6166	!*MESSAGE 2
6167	!*STIMULUS:
6168	!*	DBUS PARITY SELECT 0
6169	!*	CHECK \S0 HALF OF DBUS PAR WITH DBUS SELECT = 0
6170	!*	READ BACK REGISTER 101 AND CHK PARITY BIT
6171	!*	DBUS SELECT 0 PARITY INPUTS SHOULD BE GROUNDED
6172	!*	PARITY ERROR SHOULD NEVER OCCUR
6173	!*RESPONSE:
6174	!]ERROR 2
6175	!]PE DBUSSEL DBUSPL NTWK
6176	!]ERROR 3
6177	!]PE DBUSSEL DBUSPR NTWK
6178		END;
6179	
6180	GLOBAL ROUTINE TST31: NOVALUE =
6181	
6182	!THIS TEST CHECKS ALL THE DBUS MIX'S FOR SLECT = 1 (DP).
6183	!WE EXECUTE 4 INSTRUCTIONS WITH 2 DATA SETS 0'S AND 1'S.
6184	!THE INSTRUCTIONS WILL DO THE FOLLOWING:
6185	!CRAM 1/ PASS THE DATA WORD INTO REGISTER 0 OF THE 2901'S VIA DBUS,DBM & MAGIG # FIELD
6186	!CRAM 2/ OUTPUT REGISTER 0 ONTO DP THEN WRITE BACK TO REGISTER 1 VIA 
6187	!	 DBUS (DBUS SELECT = 1).
6188	!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A ZERO
6189	!CRAM 4/ FINISH THE MEM CYCLE AND OUTPUT REGISTER 1 INTO MEMORY.
6190	!THE DATA IS THEN READ AND VERIFIED FROM MEM.
6191	
6192		BEGIN
6193		LABEL BLOCK1,BLOCK2;
6194		OWN DPDBUS_FLG;
6195		BIND
6196		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
6197				U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_A U_B_PC U,
6198				U_J(4) U_MEM U_N(11012) U,
6199				U_J(1) U_ALU_OR U_A_PC U_MEM U_N(2) U);
6200	
6201		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
6202		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
6203		SET_C(1);					!SET CRAM ADRS TO 1
6204		DPDBUS_FLG = 0;
6205		DO (0) WHILE
6206	BLOCK1:	BEGIN
6207		CP(4);						!GIVE 4 CLOCKS
6208		RCVDATA = EM(0);				!GET DATA FROM MEM
6209		IF .RCVDATA NEQ 0				!CHECK DATA
6210			THEN BEGIN
6211				ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
6212				DPDBUS_FLG = 1;
6213			     END;
6214		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
6215			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
6216		0						!TO ILLUMINATE BLISS INFO COMMENT
6217	
6218		END;
6219		MOD_FLD(3,%O'7777');				!CHANGE DATA
6220		MOD_FLD(4,%O'77');				!TO -1
6221		ER_TAB[0] = %O'-1';					!FOR ERROR PRINTOUT
6222		DO (0) WHILE
6223	BLOCK2:	BEGIN
6224		CP(4);						!GIVE 4 CLOCKS
6225		RCVDATA = EM(0);				!GET DATA FROM MEM
6226		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
6227			THEN ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB)	!NO
6228			ELSE IF .DPDBUS_FLG EQL 0
6229				THEN NOERR(1);
6230		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
6231			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
6232		0						!TO ILLUMINATE BLISS INFO COMMENT
6233	
6234		END;
6235	!*MESSAGE 1
6236	!*	DBUS TEST
6237	!*STIMULUS:
6238	!*	DBUS MIX'S SELECT 1 (DPE3 & 4)
6239	!*	LOAD THE 2901'S REGISTER 0 WITH A \O0
6240	!*	OUTPUT REGISTER 0 ONTO DP AND WRITE IT BACK TO 
6241	!*	REGISTER 1 FROM DBUS (DBUS SELECT = 1)
6242	!*	START AND FINISH A MEM CYCLE OUTPUTING THE CONTENTS 
6243	!*	OF REGISTER 1 INTO PHYSICAL MEM 0
6244	!*RESPONSE:
6245	!*	EXAMINE DATA FROM MEM 0
6246	!]ERROR 1
6247	!]DBMDBUS DPDBUS DBUSSEL NTWK
6248	!]NO ERROR 1
6249	!]DPDBUS NTWK
6250		END;
6251	
6252	GLOBAL ROUTINE TST32: NOVALUE =
6253	
6254	!THIS TEST CHECKS THE 10 BIT VMA COPY FLOPS ON DPE5.
6255	!THIS TEST WILL EXECUTE 3 INSTRUCTIONS FOR EACH DATA SET TESTED (0'S & 1'S).
6256	!THE INSTRUCTIONS WILL DO THE FOLLOWING:
6257	!CRAM 1/ PASS THE DATA SET INTO REGISTER 0 OF THE 2901'S VIA DBUS,DBM 
6258	!	 AND THE MAGUC # FIELD.
6259	!CRAM 2/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP, START A PHYSICAL MEM
6260	!	 WRITE CYCLE AND LOAD THE VMA FROM DP (INCLUDING 10 BIT COPY ON DPE5).
6261	!CRAM 3/ FINISH THE MEM CYCLE AND OUTPUT THE CONTENTS OF THE DBUS INTO 
6262	!	 PHYSICAL LOCATION OF MEMORY SPECIFIED BY THE VMA, DBUS SELECT = 0
6263	!	 (DBUS INCLUDES THE 10 BIT VMA COPY).
6264	!DATA IS THEN READ AND VERIFIED FROM MEM THE 10 BIT VMA COPY SHOULD BE !ON BITS 26 - 35.
6265	
6266		BEGIN
6267		OWN TEST_FLG;
6268		LABEL BLOCK1,BLOCK2;
6269		BIND
6270		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
6271				U_J(3) U_ALU_OR U_MEM U_N(11012) U,
6272				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);
6273	
6274		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
6275		TEST_FLG = 0;
6276		SET_C(1);					!SET CRAM ADRS TO 1
6277		ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
6278		ER_TAB[1] = 0;					!FOR ERROR PRINTOUT
6279		DO (0) WHILE
6280	BLOCK1:	BEGIN
6281		DM(0,%O'-1');					!SET MEM 0 TO ONES
6282		CP(3);						!GIVE 3 CLOCKS
6283		RCVDATA = EM(0);				!GET DATA
6284		RCVDATA = .RCVDATA AND %O'1777';		!CLEAN UNWANTED BITS
6285		IF .RCVDATA NEQ 0				!CHECK DATA
6286			THEN BEGIN 
6287				ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
6288				PCDBUS_FLG = 1;
6289				TEST_FLG = 1;
6290			     END;
6291		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
6292			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
6293		0						!TO ILLUMINATE BLISS INFO COMMENT
6294	
6295		END;
6296		MOD_FLD(3,%O'1777');				!SET DATA TO 1777
6297		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
6298		ER_TAB[1] = %O'1777';				!FOR ERROR PRINTOUT
6299		DO (0) WHILE
6300	BLOCK2:	BEGIN
6301		DM(1777,0);					!CLEAR MEM LOCATION 1777
6302		CP(3);						!GIVE 3 CLOCKS
6303		RCVDATA = EM(1777);				!GET DATA FROM MEM
6304		RCVDATA = .RCVDATA AND %O'1777';		!CLEAN UNWANTED BITS
6305		IF .RCVDATA NEQ %O'1777'			!CHECK DATA
6306			THEN BEGIN
6307				ERRCAS(1,1,%O'1777',.RCVDATA,12,ER_TAB);	!NO
6308				PCDBUS_FLG = 1;
6309			     END
6310			ELSE IF .TEST_FLG EQL 0
6311				THEN NOERR(1);
6312		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
6313			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
6314		0						!TO ILLUMINATE BLISS INFO COMMENT
6315	
6316		END;
6317		LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
6318	!*MESSAGE 1
6319	!*	10 BIT VMA COPY TEST
6320	!*STIMULUS:
6321	!*	10 BIT VMA COPY TEST (DPE5)
6322	!*	DEPOSIT \O0 IN MEM \O1
6323	!*	START A MEM CYCLE AND LOAD THE VMA WITH A \O1
6324	!*	FINISH MEM CYCLE AND OUTPUT DBUS TO MEM VIA DP (DBUS SELECT = 0)
6325	!*	DBUS SHOULD INCLUDE 10 BIT VMA COPY (26-35)
6326	!*RESPONSE:
6327	!]ERROR 1
6328	!]TBVMACPY PCDBUS BCLK CCLK NTWK
6329	!]NO ERROR 1
6330	!]TBVMACPY BCLK CCLK NTWK
6331		END;
6332	
6333	GLOBAL ROUTINE TST33: NOVALUE =
6334	
6335	!THIS TEST CHECKS THE DISP MIX ON DPEA,(COMBINED WITH DROM TESTS ).
6336	!THIS TEST CHECKS DISP = 31,34,35.
6337	!FOR EACH OF THE THREE DISP TYPES IT DOES THE FOLLOWING:
6338	!  PASS A DATA FROM THE MAGIC # FIELD INTO DBM,THEN PASS IT TO 
6339	!  DBUS AND FROM THERE PASS THROUGH THE 2901'S INTO DP.DISP IS EXECUTED
6340	!  DEPENDING ON DP CONTENTS.WE PASS 2 DATA WORDS INTO DP FOR EACH DISP TYPE,
6341	!  0'S & 1'S.AFTER EACH DATA PASS THEN DISP THE NEXT CRAM ADRS IS READ AND VERIFIED.
6342	
6343		BEGIN
6344		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
6345		BIND
6346		POINTER = PLIT (U_J(0) U_ALU_OR U_LSRC_D0 U_DISP_DP U_DBUS_DBM U_N(777777) U);
6347		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
6348		ER_TAB[0] = %O'-1';				!FOR ERROR PRINTOUT
6349		ER_TAB[1] = %O'35';				!FOR ERROR PRINTOUT
6350		DO (0) WHILE
6351	BLOCK1:	BEGIN
6352		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
6353		IF .RCVDATA NEQ %O'17'				!CHECK IT
6354			THEN ERRCAS(1,1,%O'17',.RCVDATA,4,ER_TAB);	!NO
6355		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
6356		THEN
6357		    BEGIN
6358		    SET_C(1);					!SET CRAM ADRS TO 1
6359		    LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
6360		    END;
6361		0						!TO ILLUMINATE BLISS INFO COMMENT
6362	
6363		END;
6364		MOD_FLD(2,%O'400');				!MODIFY DISP TO TO NORM
6365		ER_TAB[1] = %O'34';				!FOR ERROR PRINTOUT
6366		DO (0) WHILE
6367	BLOCK2:	BEGIN
6368		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
6369		IF (.RCVDATA AND %O'10') EQL %O'10'
6370			THEN ERRCAS(2,1,7,.RCVDATA,4,ER_TAB)	!NO
6371			ELSE IF (.RCVDATA AND 7) NEQ 7		!CHECK DATA
6372				THEN ERRCAS(1,1,7,.RCVDATA,4,ER_TAB);	!NO
6373		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
6374		THEN
6375		    BEGIN
6376		    SET_C(1);					!SET CRAM ADRS TO 1
6377		    LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
6378		    END;
6379		0						!TO ILLUMINATE BLISS INFO COMMENT
6380	
6381		END;
6382		MOD_FLD(2,%O'100');				!MODIFY DISP TO DP LEFT (DP 18-21)
6383		ER_TAB[1] = %O'31';				!FOR ERROR PRINTOUT
6384		DO (0) WHILE
6385	BLOCK3:	BEGIN
6386		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
6387		IF .RCVDATA NEQ %O'17'				!CHECK DATA
6388			THEN ERRCAS(1,1,%O'17',.RCVDATA,4,ER_TAB);!NO
6389		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
6390		THEN
6391		    BEGIN
6392		    SET_C(1);					!SET CRAM ADRS TO 1
6393		    LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
6394		    END;
6395		0						!TO ILLUMINATE BLISS INFO COMMENT
6396	
6397		END;
6398		MOD_FLD(3,0);					!CHANGE THE # FIELD
6399		MOD_FLD(4,0);					!TO ZERO
6400		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
6401		DO (0) WHILE
6402	BLOCK4:	BEGIN
6403		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
6404		IF .RCVDATA NEQ 0				!CHECK DATA
6405			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
6406		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
6407		THEN
6408		    BEGIN
6409		    SET_C(1);					!SET CRAM ADRS TO 1
6410		    LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
6411		    END;
6412		0						!TO ILLUMINATE BLISS INFO COMMENT
6413	
6414		END;
6415		MOD_FLD(2,%O'400');				!CHAGE DISP TO NORMAL
6416		ER_TAB[1] = %O'34';				!FOR ERROR PRINTOUT
6417		DO (0) WHILE
6418	BLOCK5:	BEGIN
6419		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
6420		IF (.RCVDATA AND %O'10') EQL 0
6421			THEN ERRCAS(2,1,%O'10',.RCVDATA,4,ER_TAB)!NO
6422			ELSE IF (.RCVDATA AND 7) NEQ 0		!CHECK IT
6423				THEN ERRCAS(1,1,%O'10',.RCVDATA,4,ER_TAB);!NO
6424		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
6425		THEN
6426		    BEGIN
6427		    SET_C(1);					!SET CRAM ADRS TO 1
6428		    LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
6429		    END;
6430		0						!TO ILLUMINATE BLISS INFO COMMENT
6431	
6432		END;
6433		MOD_FLD(2,%O'500');				!MODIFY DISP TO DP (DP 32-35)
6434		ER_TAB[1] = %O'35';				!FOR ERROR PRINTOUT
6435		DO (0) WHILE
6436	BLOCK6:	BEGIN
6437		RCVDATA = STEP_U_NEXT(1);			!GIVE 1 CLK AND GET NXT CRAM ADRS
6438		IF .RCVDATA NEQ 0				!CHECK DATA
6439			THEN ERRCAS(1,1,0,.RCVDATA,4,ER_TAB);	!NO
6440		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
6441		THEN
6442		    BEGIN
6443		    SET_C(1);					!SET CRAM ADRS TO 1
6444		    LEAVE BLOCK6 WITH 1;			!LEAVE BLOCK TO LOOP
6445		    END;
6446		0						!TO ILLUMINATE BLISS INFO COMMENT
6447	
6448		END;
6449	!*MESSAGE 1
6450	!*	DISP ON OUTPUT OF DP
6451	!*STIMULUS:
6452	!*	DID A DISP = \O1
6453	!*	DP = \U0, CRAM J = 0
6454	!*	WE GET NXT CRAM ADRS 
6455	!*RESPONSE:
6456	!]ERROR 1
6457	!]DISP NTWK
6458	!]ERROR 2
6459	!]ADEQ0 DISP NTWK
6460		END;
6461	
6462	GLOBAL ROUTINE TST34: NOVALUE =
6463	
6464	!THIS TEST CHECKS THE PI REQ LEVELS.
6465	!ONE INSTRUCTION IS EXECUTED TWICE FOR EACH PI LEVEL.AFTER EACH EXECUTION
6466	!FIELDS ARE MODIFIED TO TEST THE NEXT PI LEVEL.THE INSTRUCTION RESIDE 
6467	!IN CRAM 1, AND WILL DO THE FOLLOWIN:
6468	!CRAM 1/ SET APR ENABLES, WHICH SETS APR INT REQ.AT THIS TIME DP SHOULD 
6469	!	 CONTAIN PI LEVEL REQUEST(DP33,34,35)AND APR ENABLES (DP 32)
6470	!	 WE GET THE DATA NEEDED ON THE DP THROUGH THE FOLLOWING PATH:
6471	!		PASS THE DATA FROM THE MAGIG # FIELD INTO DBM.
6472	!		PASS DATA FROM DBM INTO DBUS.
6473	!		PASS DATA FROM DBUS THROUGH THE 2901'S INTO DP.
6474	!	(THIS INSTRUCTION IN CRAM 2 IS EXECUTED TWICE).
6475	!	AFTER THIS EXECUTION THE PI LEVEL REQUESTED SHOULD BE SET.WE 
6476	!	READ AND VERIFY THE PENDING PI REQUEST BY READING REGISTER 101.
6477	
6478		BEGIN
6479		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
6480		      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
6481		BIND
6482		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_SPEC_APR_EN U_DBUS_DBM U_N(10) U);
6483		LOAD_U(1,POINTER);				!LOAD 2 INSTRUCTIONS
6484		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
6485		ER_TAB[1] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
6486		ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
6487		DO (0) WHILE
6488	BLOCK1:	BEGIN
6489		CP(2);						!GIVE 2 CLOCKS
6490		RCVDATA = RD_101;				!GET PI REQ
6491		IF .RCVDATA NEQ 0				!CHECK DATA
6492			THEN BEGIN
6493				ERRCAS(1,1,0,.RCVDATA,3,ER_TAB);	!NO
6494				PIBUS_FLG = 1;
6495			     END;
6496		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
6497			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
6498		0						!TO ILLUMINATE BLISS INFO COMMENT
6499	
6500		END;
6501		MOD_FLD(3,%O'11');				!SET PI REQ 1
6502		ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
6503		DO (0) WHILE
6504	BLOCK2:	BEGIN
6505		CP(2);						!GIVE 2 CLOCKS
6506		RCVDATA = RD_101;				!GET DATA
6507		IF .RCVDATA NEQ %O'200'				!CHECK DATA
6508			THEN BEGIN
6509				ERRCAS(1,1,%O'200',.RCVDATA,3,ER_TAB);!NO
6510				PIBUS_FLG = 1;
6511			     END;
6512		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
6513			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
6514		0						!TO ILLUMINATE BLISS INFO COMMENT
6515	
6516		END;
6517		MOD_FLD(3,%O'12');				!SET PI REQ 2
6518		ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
6519		DO (0) WHILE
6520	BLOCK3:	BEGIN
6521		CP(2);						!GIVE 2 CLOCKS
6522		RCVDATA = RD_101;				!GET PI LEVEL FROM REG 101
6523		IF .RCVDATA NEQ %O'100'				!CHECK DATA
6524			THEN BEGIN
6525				ERRCAS(1,1,%O'100',.RCVDATA,3,ER_TAB);!NO
6526				PIBUS_FLG = 1;
6527			     END;
6528		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
6529			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
6530		0						!TO ILLUMINATE BLISS INFO COMMENT
6531	
6532		END;
6533		MOD_FLD(3,%O'13');				!SET PI REQ 3
6534		ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
6535		DO (0) WHILE
6536	BLOCK4:	BEGIN
6537		CP(2);						!GIVE 2 CLOCKS
6538		RCVDATA = RD_101;				!GET PI REQ FROM REG 101
6539		IF .RCVDATA NEQ %O'40'				!CHECK DATA
6540			THEN BEGIN
6541				ERRCAS(1,1,%O'40',.RCVDATA,3,ER_TAB);!NO
6542				PIBUS_FLG = 1;
6543			     END;
6544		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
6545			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
6546		0						!TO ILLUMINATE BLISS INFO COMMENT
6547	
6548		END;
6549		MOD_FLD(3,%O'14');				!SET PI LEVEL 4
6550		ER_TAB[0] = 4;					!FOR ERROR PRINTOUT
6551		DO (0) WHILE
6552	BLOCK5:	BEGIN
6553		CP(2);						!GIVE 2 CLOCKS
6554		RCVDATA = RD_101;				!GET PI REQ FROM REG 101
6555		IF .RCVDATA NEQ %O'20'				!CHECK DATA
6556			THEN BEGIN
6557				ERRCAS(1,1,%O'20',.RCVDATA,3,ER_TAB);!NO
6558				PIBUS_FLG = 1;
6559			     END;
6560		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
6561			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
6562		0						!TO ILLUMINATE BLISS INFO COMMENT
6563	
6564		END;
6565		MOD_FLD(3,%O'15');				!SET PI LEVEL 5
6566		ER_TAB[0] = 5;					!FOR ERROR PRINTOUT
6567		DO (0) WHILE
6568	BLOCK6:	BEGIN
6569		CP(2);						!GIVE 2 CLOCKS
6570		RCVDATA = RD_101;				!GET PI REQ FROM REG 101
6571		IF .RCVDATA NEQ %O'10'				!CHECK DATA
6572			THEN BEGIN
6573				ERRCAS(1,1,%O'10',.RCVDATA,3,ER_TAB);!NO
6574				PIBUS_FLG = 1;
6575			     END;
6576		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
6577			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
6578		0						!TO ILLUMINATE BLISS INFO COMMENT
6579	
6580		END;
6581		MOD_FLD(3,%O'16');				!SET PI LEVEL 6
6582		ER_TAB[0] = 6;					!FOR ERROR PRINTOUT
6583		DO (0) WHILE
6584	BLOCK7:	BEGIN
6585		CP(2);						!GIVE 2 CLOCKS
6586		RCVDATA = RD_101;				!GET PI REQ FROM REG 101
6587		IF .RCVDATA NEQ 4				!CHECK DATA
6588			THEN BEGIN
6589				ERRCAS(1,1,4,.RCVDATA,3,ER_TAB);	!NO
6590				PIBUS_FLG = 1;
6591			     END;
6592		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
6593			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
6594		0						!TO ILLUMINATE BLISS INFO COMMENT
6595	
6596		END;
6597		MOD_FLD(3,%O'17');				!SET PI LEVEL 7
6598		ER_TAB[0] = 7;					!FOR ERROR PRINTOUT
6599		DO (0) WHILE
6600	BLOCK8:	BEGIN
6601		CP(2);						!GIVE 2 CLOCKS
6602		RCVDATA = RD_101;				!GET PI REQ FROM REG 101
6603		IF .RCVDATA NEQ 2				!CHECK DATA
6604			THEN BEGIN
6605				ERRCAS(1,1,2,.RCVDATA,3,ER_TAB);	!NO
6606				PIBUS_FLG = 1;
6607			     END;
6608		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
6609			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
6610		0						!TO ILLUMINATE BLISS INFO COMMENT
6611	
6612		END;
6613		MOD_FLD(3,7);					!SET PI LEVEL 7
6614		ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
6615		DO (0) WHILE
6616	BLOCK9:	BEGIN
6617		CP(2);						!GIVE 2 CLOCKS
6618		RCVDATA = RD_101;				!GET PI REQ FROM REG 101
6619		IF .RCVDATA NEQ 0				!CHECK DATA
6620			THEN BEGIN
6621				ERRCAS(1,1,0,.RCVDATA,3,ER_TAB);	!NO
6622				PIBUS_FLG = 1;
6623			     END;
6624		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
6625			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
6626		0						!TO ILLUMINATE BLISS INFO COMMENT
6627	
6628		END;
6629		MOD_FLD(3,%O'17');				!SET PI LEVEL 7
6630		MOD_FLD(1,%O'6707');				!CLEAR
6631		MOD_FLD(2,0);					!APR EN
6632		ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
6633		ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
6634		DO (0) WHILE
6635	BLOCK10:BEGIN
6636		CP(2);						!GIVE 2 CLOCKS
6637		RCVDATA = RD_101;				!GET PI REQ FROM REG 101
6638		IF .RCVDATA NEQ 0				!CHECK DATA
6639			THEN ERRCAS(1,1,0,.RCVDATA,3,ER_TAB)	!NO
6640			ELSE IF .PIBUS_FLG EQL 0
6641				THEN NOERR(1);
6642		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
6643			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
6644		0						!TO ILLUMINATE BLISS INFO COMMENT
6645	
6646		END;
6647	!*MESSAGE 1
6648	!*	BUS PI TEST
6649	!*STIMULUS:
6650	!*	DP 33 - 35 = \O0
6651	!*	DPE5 SPEC/APR EN IS \S1
6652	!*	DPMB APR INT REQ IS \S2
6653	!*	READ THE 8080'S REGISTER 101
6654	!*	(BITS 7-1 CONTAIN BUS PI LEVEL 1-7)
6655	!*RESPONCE:
6656	!]ERROR 1
6657	!]CCLK SPECAPR PIBUS NTWK
6658	!]NO ERROR 1
6659	!]CCLK PIBUS NTWK
6660		END;
6661	
6662	GLOBAL ROUTINE TST35: NOVALUE =
6663	
6664	!THIS TEST CHECKS THE PRIORITY INTERRUPT ENCODER ON DPEB, ALL PI 
6665	!SOFT REQUEST LEVELS AND OR GATES.
6666	!THIS TEST IS VERIFIED BY EXECUTING 3 INSTRUCTIONS IN CRAM 1,2 & 3.
6667	!ALL LEVELS OF PI SOFT REQUESTS ARE SELECTED TO INPUT THE ENCODER THROUGH 
6668	!THE OR GATES AFTER WHICH WE WILL GET A PI NEW AT THE OUTPUT OF THE ENCODER.
6669	!ALL OTHER INPUTS TO THE OR GATES ARE ALWAYS HI.WE VERIFY THE OUTPUT OF 
6670	!THE ENCODER (PI NEW) BY PASSING IT THROUGH THE DBUS MUX (DBUS SELECT = 0)
6671	!AND WRITING IT IN THE 2901'S.FROM THERE THE DATA IS WRITTEN OUT TO 
6672	!PHYSICAL MEMORY, READ AND VERIFIED.THIS TEST WILL CALL A ROUTINE VMA_LD 
6673	!WHICH WILL LOAD THE VMA WITH A 0.THE INSTRUCTIONS IN THE CRAM WILL
6674	!DO THE FOLLOWING:
6675	!CRAM 1/ PASS THE REQUIRED DATA TO SELECT PI LEVEL FROM THE MAGIC 
6676	!	 # FIELD INTO DBM.PASS THE DATA FROM DBM INTO DBUS.FINALLY PUT 
6677	!	 THE DATA ON DP PASSING IT FROM DBUS THROUGH THE 2901'S.AND 
6678	!	 LOAD PI SYSTEM AT THE SAME TIME(SPEC SELECT 43).
6679	!CRAM 2/ START A MEM WRITE CYCLE.LOAD THE PI SYSTEM (SPEC SELECT 43).
6680	!	 SELECT DBUS TO GET PI NEW.WRITE THE CONTENTS OF THE DBUS IN 
6681	!	 REGISTER 0 OF THE 2901'S.
6682	!CRAM 3/ FINISH MEM WRITE CYCLE BY OUTPUTING THE CONTENTS OF REGISTER 0 
6683	!	 INTO MEMORY LOCATION SPECIFIED BY THE VMA (VMA = 0).
6684	
6685		BEGIN
6686		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
6687		      BLOCK6,BLOCK7,BLOCK8,BLOCK9;
6688		BIND
6689		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_N(777777) U_SPEC_LDPI U,
6690				U_J(3) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_PI_NEW U_MEM U_N(11002) U_SPEC_LDPI U,
6691				U_J(1) U_ALU_OR U_MEM U_N(2) U);
6692	
6693		VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
6694		LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
6695		SET_C(1);					!SET CRAM ADRS TO 1
6696		ER_TAB[0] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
6697		ER_TAB[1] = %O'777777';				!FOR ERROR PRINTOUT
6698		DO (0) WHILE
6699	BLOCK1:	BEGIN
6700		CP(3);						!GIVE 3 CLOCKS
6701		RCVDATA = EM(0);				!GET DATA
6702		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6703		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6704			THEN BEGIN
6705				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
6706				PISOFT_FLG = 1;
6707			     END;
6708		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
6709			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
6710		0						!TO ILLUMINATE BLISS INFO COMMENT
6711	
6712		END;
6713		MOD_FLD(3,%O'7577');				!MODIFY PI SOFT REQ LEVEL TO 7
6714		ER_TAB[0] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
6715		ER_TAB[1] = %O'777577';				!FOR ERROR PRINTOUT
6716		DO (0) WHILE
6717	BLOCK2:	BEGIN
6718		CP(3);						!GIVE 3 CLOCKS
6719		RCVDATA = EM(0);				!GET DATA
6720		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6721		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6722			THEN BEGIN
6723				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
6724				PISOFT_FLG = 1;
6725			     END;
6726		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
6727			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
6728		0						!TO ILLUMINATE BLISS INFO COMMENT
6729	
6730		END;
6731		MOD_FLD(3,%O'7400');				!MODIFY PI SOFT REQ TO BE 1
6732		ER_TAB[1] = %O'777400';				!FOR ERROR PRINTOUT
6733		DO (0) WHILE
6734	BLOCK3:	BEGIN
6735		CP(3);						!GIVE 3 CLOCKS
6736		RCVDATA = EM(0);				!GET DATA
6737		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6738		IF .RCVDATA NEQ %O'40000'			!CHECK DATA
6739			THEN BEGIN
6740				ERRCAS(1,1,%O'40000',.RCVDATA,12,ER_TAB);	!NO
6741				PISOFT_FLG = 1;
6742			     END;
6743		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
6744			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
6745		0						!TO ILLUMINATE BLISS INFO COMMENT
6746	
6747		END;
6748		MOD_FLD(3,%O'7500');				!FORCE SOFT PI REQ LEVEL OF 2
6749		ER_TAB[1] = %O'777500';				!FOR ERROR PRINTOUT
6750		DO (0) WHILE
6751	BLOCK4:	BEGIN
6752		CP(3);						!GIVE 3 CLOCKS
6753		RCVDATA = EM(0);				!GET DATA
6754		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6755		IF .RCVDATA NEQ %O'100000'			!CHECK DATA
6756			THEN BEGIN
6757				ERRCAS(1,1,%O'100000',.RCVDATA,12,ER_TAB);	!NO
6758				PISOFT_FLG = 1;
6759			     END;
6760		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
6761			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
6762		0						!TO ILLUMINATE BLISS INFO COMMENT
6763	
6764		END;
6765		MOD_FLD(3,%O'7540');				!MODIFY TO PI LEVEL OF 3
6766		ER_TAB[1] = %O'777540';				!FOR ERROR PRINTOUT
6767		DO (0) WHILE
6768	BLOCK5:	BEGIN
6769		CP(3);						!GIVE 3 CLOCKS
6770		RCVDATA = EM(0);				!GET DATA
6771		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6772		IF .RCVDATA NEQ %O'140000'			!CHECK DATA
6773			THEN BEGIN
6774				ERRCAS(1,1,%O'140000',.RCVDATA,12,ER_TAB);	!NO
6775				PISOFT_FLG = 1;
6776				PCDBUS_FLG = 1;
6777			     END;
6778		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
6779			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
6780		0						!TO ILLUMINATE BLISS INFO COMMENT
6781	
6782		END;
6783		MOD_FLD(3,%O'7560');				!MODIFY PI LEVEL TO 4
6784		ER_TAB[1] = %O'777560';				!FOR ERROR PRINTOUT
6785		DO (0) WHILE
6786	BLOCK6:	BEGIN
6787		CP(3);						!GIVE 3 CLOCKS
6788		RCVDATA = EM(0);				!GET DATA
6789		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6790		IF .RCVDATA NEQ %O'200000'			!CHECK DATA
6791			THEN BEGIN
6792				ERRCAS(1,1,%O'200000',.RCVDATA,12,ER_TAB);	!NO
6793				PISOFT_FLG = 1;
6794				PCDBUS_FLG = 1;
6795			     END;
6796		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
6797			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
6798		0						!TO ILLUMINATE BLISS INFO COMMENT
6799	
6800		END;
6801		MOD_FLD(3,%O'7570');				!MODIFY PI TO 5
6802		ER_TAB[1] = %O'777570';				!FOR ERROR PRINTOUT
6803		DO (0) WHILE
6804	BLOCK7:	BEGIN
6805		CP(3);						!GIVE 3 CLOCKS
6806		RCVDATA = EM(0);				!GET DATA
6807		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6808		IF .RCVDATA NEQ %O'240000'			!CHECK DATA
6809			THEN BEGIN
6810				ERRCAS(1,1,%O'240000',.RCVDATA,12,ER_TAB);	!NO
6811				PISOFT_FLG = 1;
6812			     END;
6813		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
6814			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
6815		0						!TO ILLUMINATE BLISS INFO COMMENT
6816	
6817		END;
6818		MOD_FLD(3,%O'7574');				!MODIFY PI TO 6
6819		ER_TAB[1] = %O'777574';				!FOR ERROR PRINTOUT
6820		DO (0) WHILE
6821	BLOCK8:	BEGIN
6822		CP(3);						!GIVE 3 CLOCKS
6823		RCVDATA = EM(0);				!GET DATA
6824		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6825		IF .RCVDATA NEQ %O'300000'				!CHECK DATA
6826			THEN BEGIN
6827				ERRCAS(1,1,%O'300000',.RCVDATA,12,ER_TAB);	!NO
6828				PISOFT_FLG = 1;
6829			     END;
6830		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
6831			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
6832		0						!TO ILLUMINATE BLISS INFO COMMENT
6833	
6834		END;
6835		MOD_FLD(3,%O'7576');				!MODIFY PI TO 7
6836		ER_TAB[1] = %O'777576';				!FOR ERROR PRINTOUT
6837		DO (0) WHILE
6838	BLOCK9:	BEGIN
6839		CP(3);						!GIVE 3 CLOCKS
6840		RCVDATA = EM(0);				!GET DATA
6841		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6842		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6843			THEN ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB)	!NO
6844			ELSE IF .PISOFT_FLG EQL 0
6845				THEN NOERR(1);
6846		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
6847			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
6848		0						!TO ILLUMINATE BLISS INFO COMMENT
6849	
6850		END;
6851	!*MESSAGE 1
6852	!*	PI SOFT TEST
6853	!*STIMULUS:
6854	!*	DPEB PI ON IS \S0
6855	!*	BOTH HALFS OF DP CONTAIN \O1
6856	!*	LOAD PI SYSTEM, THEN READ PI NEW THROUGH THE DBUS OUT TO MEM
6857	!*RESPONSE:
6858	!*	EXAMINE THE CONTENTS OF THE DBUS (BITS 19-21 CONTAIN PI NEW)
6859	!]ERROR 1
6860	!]CCLK BCLK PCDBUS PINEW PISOFT SPECPI ORPI NTWK
6861	!]NO ERROR 1
6862	!]PISOFT BCLK CCLK NTWK
6863		END;
6864	
6865	GLOBAL ROUTINE TST36: NOVALUE =
6866	
6867	!THIS TEST CHECKS PI ACTIVE AND PI REQ FLOPS ON DPEB AS WELL 
6868	!AS THE AND GATES .
6869	!THIS TEST IS VERIFIED BY EXECUTING 6 INSTRUCTIONS IN CRAM 1,2,2,3,4,5 & 6.
6870	!ALL POSSIBLE COMBINATIONS OF PI ACTIVE AND BUS PI REQUESTS ARE TESTED
6871	!TO VERIFY THE AND GATES.AT THE OUPUT OF THE AND GATES ALL OTHER INPUTS 
6872	!TO THE OR GATES ARE ALWAYS HI.WE VERIFY THE OUTPUT OF THE ENCODER 
6873	!(PI NEW) BY PASSING IT THROUGH THE DBUS MUX (DBUS SELECT = 0)
6874	!AND WRITING IT IN THE 2901'S.FROM THERE THE DATA IS WRITTEN OUT TO 
6875	!PHYSICAL MEMORY, READ AND VERIFIED.THIS TEST WILL CALL A ROUTINE VMA_LD 
6876	!WHICH WILL LOAD THE VMA WITH A 0.THE INSTRUCTIONS IN THE CRAM WILL
6877	!DO THE FOLLOWING:
6878	!CRAM 1 & 2/ THE TWO INSTRUCTIONS WILL SET UP THE REQUIRED BUS PI 
6879	!	     REQUEST (SEE TEST BUS PI REQUEST).
6880	!CRAM 3/ THIS INSTRUCTION WILL SET UP THE REQUIRED DATA TO SELECT PI ACTIVE.
6881	!CRAM 4/ OUPUT THE REQUIRED DATA ONTO THE DP. LOAD THE PI.
6882	!CRAM 5/ START A MEM WRITE CYCLE.LOAD THE PI SYSTEM (SPEC SELECT 43).
6883	!	 SELECT DBUS TO GET PI NEW.WRITE THE CONTENTS OF THE DBUS IN 
6884	!	 REGISTER 0 OF THE 2901'S.
6885	!CRAM 3/ FINISH MEM WRITE CYCLE BY OUTPUTING THE CONTENTS OF REGISTER 0 
6886	!	 INTO MEMORY LOCATION SPECIFIED BY THE VMA (VMA = 0).
6887		BEGIN
6888		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
6889		      BLOCK5,BLOCK6,BLOCK7,BLOCK8,
6890		      BLOCK9,BLOCK10,BLOCK11,BLOCK12,
6891		      BLOCK13,BLOCK14,BLOCK15;
6892		BIND
6893		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_SPEC_APR_EN U_DBUS_DBM U_N(10) U,
6894				U_J(3) U_ALU_OR U_LSRC_D0 U_SPEC_APR_EN U_DBUS_DBM U_N(10) U,
6895				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U,
6896				U_J(5) U_ALU_OR U_LSRC_D0 U_RSRC_0A U_DBUS_DBM U_N(777777) U_SPEC_LDPI U,
6897				U_J(6) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_PI_NEW U_MEM U_N(11002) U_SPEC_LDPI U,
6898				U_J(1) U_ALU_OR U_MEM U_N(2) U);
6899		VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
6900		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
6901		SET_C(1);					!SET CRAM ADRS TO 1
6902		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
6903		ER_TAB[1] = UPLIT (%ASCIZ'777777');		!FOR ERROR PRINTOUT
6904		DO (0) WHILE
6905	BLOCK1:	BEGIN
6906		CP(6);						!GIVE 6 CLOCKS
6907		RCVDATA = EM(0);				!GET DATA
6908		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6909		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6910			THEN BEGIN
6911				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
6912				PIACTV_FLG = 1;
6913			     END;
6914		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
6915			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
6916		0						!TO ILLUMINATE BLISS INFO COMMENT
6917	
6918		END;
6919		LC(3);						!LOAD CRAM ADRS 3
6920		MOD_FLD(3,%O'177');				!MODIFY PI ACTIVE TO NONE
6921		LC(2);						!LOAD CRAM ADRS 2
6922		MOD_FLD(3,%O'11');				!REQUEST BUS PI LEVEL 1
6923		SET_C(1);					!SET CRAM ADRS TO 1
6924		ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
6925		ER_TAB[1] = UPLIT (%ASCIZ'177,,777777');	!FOR ERROR PRINTOUT
6926		DO (0) WHILE
6927	BLOCK2:	BEGIN
6928		CP(6);						!GIVE 6 CLOCKS
6929		RCVDATA = EM(0);				!GET DATA
6930		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6931		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6932			THEN BEGIN
6933				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
6934				PIACTV_FLG = 1;
6935			     END;
6936		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
6937			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
6938		0						!TO ILLUMINATE BLISS INFO COMMENT
6939	
6940		END;
6941		LC(2);						!LOAD CRAM ADRS 2
6942		MOD_FLD(3,%O'12');				!REQUEST PI LEVEL 2
6943		SET_C(1);					!SET CRAM ADRS TO 1
6944		ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
6945		DO (0) WHILE
6946	BLOCK3:	BEGIN
6947		CP(6);						!GIVE 6 CLOCKS
6948		RCVDATA = EM(0);				!GET DATA
6949		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6950		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6951			THEN BEGIN
6952				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
6953				PIACTV_FLG = 1;
6954			     END;
6955		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
6956			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
6957		0						!TO ILLUMINATE BLISS INFO COMMENT
6958	
6959		END;
6960		LC(2);						!LOAD CRAM ADRS 2
6961		MOD_FLD(3,%O'13');				!REQUEST PI LEVEL 3
6962		ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
6963		SET_C(1);					!SET CRAM ADRS TO 1
6964		DO (0) WHILE
6965	BLOCK4:	BEGIN
6966		CP(6);						!GIVE 6 CLOCKS
6967		RCVDATA = EM(0);				!GET DATA
6968		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6969		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6970			THEN BEGIN
6971				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
6972				PIACTV_FLG = 1;
6973			     END;
6974		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
6975			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
6976		0						!TO ILLUMINATE BLISS INFO COMMENT
6977	
6978		END;
6979		LC(2);						!LOAD CRAM ADRS 2
6980		MOD_FLD(3,%O'14');				!REQUEST PI LEVEL 4
6981		SET_C(1);					!SET CRAM ADRS TO 1
6982		ER_TAB[0] = 4;					!FOR ERROR PRINTOUT
6983		DO (0) WHILE
6984	BLOCK5:	BEGIN
6985		CP(6);						!GIVE 6 CLOCKS
6986		RCVDATA = EM(0);				!GET DATA
6987		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
6988		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
6989			THEN BEGIN
6990				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
6991				PIACTV_FLG = 1;
6992			     END;
6993		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
6994			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
6995		0						!TO ILLUMINATE BLISS INFO COMMENT
6996	
6997		END;
6998		LC(2);						!LOAD CRAM ADRS 2
6999		MOD_FLD(3,%O'15');				!REQUEST PI LEVEL 5
7000		SET_C(1);					!SET CRAM ADRS TO 1
7001		ER_TAB[0] = 5;					!FOR ERROR PRINTOUT
7002		DO (0) WHILE
7003	BLOCK6:	BEGIN
7004		CP(6);						!GIVE 6 CLOCKS
7005		RCVDATA = EM(0);				!GET DATA
7006		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7007		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
7008			THEN BEGIN
7009				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
7010				PIACTV_FLG = 1;
7011			     END;
7012		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
7013			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
7014		0						!TO ILLUMINATE BLISS INFO COMMENT
7015	
7016		END;
7017		LC(2);						!LOAD CRAM ADRS 2
7018		MOD_FLD(3,%O'16');				!REQUEST PI LEVEL 6
7019		SET_C(1);					!SET CRAM ADRS TO 1
7020		ER_TAB[0] = 6;					!FOR ERROR PRINTOUT
7021		DO (0) WHILE
7022	BLOCK7:	BEGIN
7023		CP(6);						!GIVE 6 CLOCKS
7024		RCVDATA = EM(0);				!GET DATA
7025		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7026		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
7027			THEN BEGIN
7028				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
7029				PIACTV_FLG = 1;
7030			     END;
7031		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
7032			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
7033		0						!TO ILLUMINATE BLISS INFO COMMENT
7034	
7035		END;
7036		LC(2);						!LOAD CRAM ADRS 2
7037		MOD_FLD(3,%O'17');				!REQUEST PI LEVEL 7
7038		SET_C(1);					!SET CRAM ADRS TO 1
7039		ER_TAB[0] = 7;					!FOR ERROR PRINTOUT
7040		DO (0) WHILE
7041	BLOCK8:	BEGIN
7042		CP(6);						!GIVE 6 CLOCKS
7043		RCVDATA = EM(0);				!GET DATA
7044		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7045		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
7046			THEN BEGIN
7047				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
7048				PIACTV_FLG = 1;
7049			     END;
7050		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
7051			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
7052		0						!TO ILLUMINATE BLISS INFO COMMENT
7053	
7054		END;
7055		LC(3);						!LOAD CRAM ADRS 3
7056		MOD_FLD(3,0);					!MODIFY PI ACTIVE TO 7
7057		ER_TAB[1] = UPLIT (%ASCIZ'777777');		!FOR ERROR PRINTOUT
7058		SET_C(1);					!SET CRAM ADRS TO 1
7059	BLOCK9:	BEGIN
7060		CP(6);						!GIVE 6 CLOCKS
7061		RCVDATA = EM(0);				!GET DATA
7062		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7063		IF .RCVDATA NEQ %O'340000'			!CHECK DATA
7064			THEN BEGIN
7065				ERRCAS(1,1,%O'340000',.RCVDATA,12,ER_TAB);	!NO
7066				PIACTV_FLG = 1;
7067			     END;
7068		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
7069			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
7070		0						!TO ILLUMINATE BLISS INFO COMMENT
7071	
7072		END;
7073		LC(2);						!LOAD CRAM ADRS 2
7074		MOD_FLD(3,%O'16');				!REQUEST PI LEVEL 6
7075		LC(1);						!LOAD CRAM ADRS 1
7076		MOD_FLD(3,%O'16');				!REQUEST PI LEVEL 6
7077		ER_TAB[0] = 6;					!FOR ERROR PRINTOUT
7078		DO (0) WHILE
7079	BLOCK10:BEGIN
7080		CP(6);						!GIVE 6 CLOCKS
7081		RCVDATA = EM(0);				!GET DATA
7082		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7083		IF .RCVDATA NEQ %O'300000'			!CHECK DATA
7084			THEN BEGIN
7085				ERRCAS(1,1,%O'300000',.RCVDATA,12,ER_TAB);!NO
7086				PIACTV_FLG = 1;
7087			     END;
7088		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
7089			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
7090		0						!TO ILLUMINATE BLISS INFO COMMENT
7091	
7092		END;
7093		LC(2);						!LOAD CRAM ADRS 2
7094		MOD_FLD(3,%O'15');				!REQUEST PI LEVEL 5
7095		SET_C(1);					!SET CRAM ADRS TO 1
7096		ER_TAB[0] = 5;					!FOR ERROR PRINTOUT
7097		DO (0) WHILE
7098	BLOCK11:BEGIN
7099		CP(6);						!GIVE 6 CLOCKS
7100		RCVDATA = EM(0);				!GET DATA
7101		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7102		IF .RCVDATA NEQ %O'240000'			!CHECK DATA
7103			THEN BEGIN
7104				ERRCAS(1,1,%O'240000',.RCVDATA,12,ER_TAB);!NO
7105				PIACTV_FLG = 1;
7106			     END;
7107		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
7108			THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
7109		0						!TO ILLUMINATE BLISS INFO COMMENT
7110	
7111		END;
7112		LC(2);						!LOAD CRAM ADRS 2
7113		MOD_FLD(3,%O'14');				!MODIFY REQUEST TO PI LEVEL 4
7114		ER_TAB[0] = 4;					!FOR ERROR PRINTOUT
7115		SET_C(1);					!SET CRAM ADRS TO 1
7116		DO (0) WHILE
7117	BLOCK12:BEGIN
7118		CP(6);						!GIVE 6 CLOCKS
7119		RCVDATA = EM(0);				!GET DATA
7120		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7121		IF .RCVDATA NEQ %O'200000'			!CHECK DATA
7122			THEN BEGIN
7123				ERRCAS(1,1,%O'200000',.RCVDATA,12,ER_TAB);!NO
7124				PIACTV_FLG = 1;
7125			     END;
7126		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
7127			THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
7128		0						!TO ILLUMINATE BLISS INFO COMMENT
7129	
7130		END;
7131		LC(2);						!LOAD CRAM ADRS 2
7132		MOD_FLD(3,%O'13');				!MODIFY REQUEST TO PI LEVEL 3
7133		ER_TAB[0] = 3;					!FOR ERROR PRINTOUT
7134		SET_C(1);					!SET CRAM ADRS TO 1
7135		DO (0) WHILE
7136	BLOCK13:BEGIN
7137		CP(6);						!GIVE 6 CLOCKS
7138		RCVDATA = EM(0);				!GET DATA
7139		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7140		IF .RCVDATA NEQ %O'140000'			!CHECK DATA
7141			THEN BEGIN
7142				ERRCAS(1,1,%O'140000',.RCVDATA,12,ER_TAB);!NO
7143				PIACTV_FLG = 1;
7144			     END;
7145		IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
7146			THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
7147		0						!TO ILLUMINATE BLISS INFO COMMENT
7148	
7149		END;
7150		LC(2);						!LOAD CRAM ADRS 2
7151		MOD_FLD(3,%O'12');				!MODIFY REQUEST TO PI LEVEL 2
7152		ER_TAB[0] = 2;					!FOR ERROR PRINTOUT
7153		SET_C(1);					!SET CRAM ADRS TO 1
7154		DO (0) WHILE
7155	BLOCK14:BEGIN
7156		CP(6);						!GIVE 6 CLOCKS
7157		RCVDATA = EM(0);				!GET DATA
7158		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7159		IF .RCVDATA NEQ %O'100000'			!CHECK DATA
7160			THEN BEGIN
7161				ERRCAS(1,1,%O'100000',.RCVDATA,12,ER_TAB);!NO
7162				PIACTV_FLG = 1;
7163			     END;
7164		IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
7165			THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
7166		0						!TO ILLUMINATE BLISS INFO COMMENT
7167	
7168		END;
7169		LC(2);						!LOAD CRAM ADRS 2
7170		MOD_FLD(3,%O'11');				!MODIFY REQUEST TO PI LEVEL 1
7171		SET_C(1);					!SET CRAM ADRS TO 1
7172		ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
7173		DO (0) WHILE
7174	BLOCK15:BEGIN
7175		CP(6);						!GIVE 6 CLOCKS
7176		RCVDATA = EM(0);				!GET DATA
7177		RCVDATA = .RCVDATA AND %O'340000';		!CLEAN UNWANTED BITS
7178		IF .RCVDATA NEQ %O'40000'			!CHECK DATA
7179			THEN ERRCAS(1,1,%O'40000',.RCVDATA,12,ER_TAB)	!NO
7180			ELSE IF .PIACTV_FLG EQL 0
7181				THEN NOERR(1);
7182		IF (.PIACTV_FLG OR .PISOFT_FLG) EQL 0
7183				THEN NOERR(2);
7184	
7185		IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
7186			THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
7187		0						!TO ILLUMINATE BLISS INFO COMMENT
7188	
7189		END;
7190	!*MESSAGE 1
7191	!*	PI ACTIVE TEST
7192	!*STIMULUS:
7193	!*	FORCE BUS PI LEVEL TO \O0
7194	!*	LOAD THE PI SYSTEM WITH DP = \S1
7195	!*	READ BACK PI NEW OUT TO MEM THROUGH THE DBUS
7196	!*	EXAMINE MEM (BITS 19 - 21 COJNTAIN PI NEW)
7197	!*RESPONCE:
7198	!]ERROR 1
7199	!]PINEW BCLK CCLK PCDBUS ORPI ANDPI PIACTV PISOFT PIREQ PIBUS SPECPI SPECAPR NTWK
7200	!]NO ERROR 1
7201	!]PIACTV ANDPI NTWK
7202	!]NO ERROR 2
7203	!]PIACTV ORPI ANDPI PISOFT CCLK BCLK NTWK
7204		END;
7205	
7206	GLOBAL ROUTINE TST37: NOVALUE =
7207	
7208	!THIS TEST CHECKS THE PI CURRENT FLOP AND ENCODER ,AS WELL AS THE 4 BIT 
7209	!TRANS LATCH ON DPEB.
7210	!SINCE THE TRANS LATCH IS ALWAYS CLOCKED THE DATA WE WILL BE LOOKING 
7211	!FOR HAS TO BE STOPED IN THE LATCH AT THE CORRECT TIME.THERFOR TO VERIFY
7212	!THIS TEST WE STOP THE WHOLE MACHINE AND SINGLE STEP THE MAIN CLOCK ON 
7213	!CSL THROUGH SETTING AND CLEARING THE CLOCK BIT IN REGISTER 205 ON THE BUS.
7214	!TO DO SO WE ALWAYS CALL A ROUTINE SYNC_CLK WHICH STOPS THE CLOCK AND 
7215	!SYNCS THE MACHINE.
7216	!THE OUTPUT OF THE TRNSVR LATCH IS READ AND VERIFIED BY READING BUS 
7217	!REGISTER 2 AT THE CORRECT INSTANT.4 INSTRUCTIONS ARE EXECUTED IN THIS
7218	!TEST IN CRAM 0,1,2 & 3.THEY DO THE FOLLOWING:
7219	!CRAM 0/ PUT THE REQUIRED MEM CONTROL BITS IN REGISTER 0 OF THE 2901'S.
7220	!CRAM 1/ OUPUT THOSE BITS FROM REGISTER 0 ONTO DP EXECUTING A MEM CYCLE 
7221	!	 THAT TAKES THE MEM CYCLE CONTROL BITS FROM DP LEFT.
7222	!CRAM 2/ ABORT ALL MEM CYCLES.
7223	!CRAM 3/ LOAD THE PI FLOP WITH THE REQUIRED DATA FROM DP TO SET UP 
7224	!	 DIFFERENT PI CURRENT LEVELS(THIS INSTRUCTION IS EXECUTED TWICE 
7225	!	 EACH TIME).
7226	!THE MR IS REQUIRED AFTER EACH TIME WE STOP THE CLOCK TO RESTART IT IN
7227	!IN ORDER TO BE ABLE TO MODIFY FIELDS OF THE CRAM.
7228	
7229		BEGIN
7230		OWN TEST_FLG;
7231		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
7232		      BLOCK5,BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10;
7233		BIND
7234		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(241300) U_NO_CLKR U,
7235				U_J(0) U_ALU_OR U_MEM U_N(36) U,
7236				U_J(3) U_DEST_AD U_SPEC_MEMCLR U,
7237				U_J(3) U_ALU_OR U_LSRC_0A U_RSRC_D0 U_SPEC_LDPI U_DBUS_DBM U_N(77400) U);
7238	
7239		LOAD_U(0,POINTER);				!LOAD 4 INSTRUCTIONS
7240		ER_TAB[0] = %O'77400';				!FOR ERROR PRINTOUT
7241		ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR PRINTOUT
7242		ER_TAB[2] = UPLIT(%ASCIZ'LO');			!FOR ERROR PRINTOUT
7243		TEST_FLG = 0;
7244		DO (0) WHILE
7245	BLOCK1:	BEGIN
7246		MR();						!DO A MASTER RESET
7247		SET_C(2);					!SET CRAM ADRS TO 2
7248		CP(3);						!GIVE 3 CLOCKS
7249		SET_C(0);					!SET CRAM ADRS TO 0
7250		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7251		WRT204(1);					!WE NEED THIS
7252		WRT204(0);					!TO RESET CRAM LATCH
7253		WRT206(1);					!SET CLK RUN
7254		TICK(56);					!ALOW 14 T CLOCKS
7255		RCVDATA = RD_2;					!READ REGISTER 2
7256		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7257		IF .RCVDATA NEQ %O'74'				!CHECK DATA
7258			THEN BEGIN
7259				ERRCAS(1,1,%O'74',.RCVDATA,3,ER_TAB);	!NO
7260				TEST_FLG = 1;
7261			     END;
7262		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
7263			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
7264		0						!TO ILLUMINATE BLISS INFO COMMENT
7265	
7266		END;
7267		MR();						!DO A MASTER RESET
7268		LC(3);						!LOAD CRAM ADRS 3
7269		MOD_FLD(3,%O'7000');				!MODIFY PI CURRENT TO 7
7270		ER_TAB[0] = %O'77000';				!FOR ERROR PRINTOUT
7271		DO (0) WHILE
7272	BLOCK2:	BEGIN
7273		MR();						!DO A MASTER RESET
7274		SET_C(2);					!SET CRAM ADRS TO 2
7275		CP(3);						!GIVE 3 CLOCKS
7276		SET_C(0);					!SET CRAM ADRS TO 0
7277		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7278		WRT204(1);					!WE NEED THIS
7279		WRT204(0);					!TO RESET CRAM LATCH
7280		WRT206(1);					!SET CLK RUN
7281		TICK(56);					!ALOW 14 T CLOCKS
7282		RCVDATA = RD_2;					!READ REGISTER 2
7283		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7284		IF .RCVDATA NEQ %O'74'				!CHECK DATA
7285			THEN BEGIN
7286				ERRCAS(1,1,%O'74',.RCVDATA,3,ER_TAB);	!NO
7287				TEST_FLG = 1;
7288			     END;
7289		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
7290			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
7291		0						!TO ILLUMINATE BLISS INFO COMMENT
7292	
7293		END;
7294		MR();						!DO A MASTER RESET
7295		LC(3);						!LOAD CRAM ADRS 3
7296		MOD_FLD(3,%O'6000');				!MODIFY PI CURRENT TO 6
7297		ER_TAB[0] = %O'76000';				!FOR ERROR PRINTOUT
7298		DO (0) WHILE
7299	BLOCK3:	BEGIN
7300		MR();						!DO A MASTER RESET
7301		SET_C(2);					!SET CRAM ADRS TO 2
7302		CP(3);						!GIVE 3 CLOCKS
7303		SET_C(0);					!SET CRAM ADRS TO 0
7304		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7305		WRT204(1);					!WE NEED THIS
7306		WRT204(0);					!TO RESET CRAM LATCH
7307		WRT206(1);					!SET CLK RUN
7308		TICK(56);					!ALOW 14 T CLOCKS
7309		RCVDATA = RD_2;					!READ REGISTER 2
7310		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7311		IF .RCVDATA NEQ %O'30'				!CHECK DATA
7312			THEN BEGIN
7313				ERRCAS(1,1,%O'30',.RCVDATA,3,ER_TAB);	!NO
7314				TEST_FLG = 1;
7315			     END;
7316		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
7317			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
7318		0						!TO ILLUMINATE BLISS INFO COMMENT
7319	
7320		END;
7321		MR();						!DO A MASTER RESET
7322		LC(3);						!LOAD CRAM ADRS 3
7323		MOD_FLD(3,%O'4000');				!MODIFY PI CURRENT T0 5
7324		ER_TAB[0] = %O'74000';				!FOR ERROR PRINTOUT
7325		DO (0) WHILE
7326	BLOCK4:	BEGIN
7327		MR();						!DO A MASTER RESET
7328		SET_C(2);					!SET CRAM ADRS TO 2
7329		CP(3);						!GIVE 3 CLOCKS
7330		SET_C(0);					!SET CRAM ADRS TO 0
7331		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7332		WRT204(1);					!WE NEED THIS
7333		WRT204(0);					!TO RESET CRAM LATCH
7334		WRT206(1);					!SET CLK RUN
7335		TICK(56);					!ALOW 14 T CLOCKS
7336		RCVDATA = RD_2;					!READ REGISTER 2
7337		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7338		IF .RCVDATA NEQ %O'24'				!CHECK DATA
7339			THEN BEGIN
7340				ERRCAS(1,1,%O'24',.RCVDATA,3,ER_TAB);	!NO
7341				TEST_FLG = 1;
7342			     END;
7343		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
7344			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
7345		0						!TO ILLUMINATE BLISS INFO COMMENT
7346	
7347		END;
7348		MR();						!MASTER RESET
7349		LC(3);						!LOAD CRAM ADRS 3
7350		MOD_FLD(3,0);					!MODIFY PI CURRENT TO 4
7351		ER_TAB[0] = %O'70000';				!FOR ERROR PRINTOUT
7352		DO (0) WHILE
7353	BLOCK5:	BEGIN
7354		MR();						!DO A MASTER RESET
7355		SET_C(2);					!SET CRAM ADRS TO 2
7356		CP(3);						!GIVE 3 CLOCKS
7357		SET_C(0);					!SET CRAM ADRS TO 0
7358		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7359		WRT204(1);					!WE NEED THIS
7360		WRT204(0);					!TO RESET CRAM LATCH
7361		WRT206(1);					!SET CLK RUN
7362		TICK(56);					!ALOW 14 T CLOCKS
7363		RCVDATA = RD_2;					!READ REGISTER 2
7364		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7365		IF .RCVDATA NEQ %O'60'				!CHECK DATA
7366			THEN BEGIN
7367				ERRCAS(1,1,%O'60',.RCVDATA,3,ER_TAB);	!NO
7368				TEST_FLG = 1;
7369			     END;
7370		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
7371			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
7372		0						!TO ILLUMINATE BLISS INFO COMMENT
7373	
7374		END;
7375		MR();						!MASTER RESET
7376		LC(3);						!LOAD CRAM ADRS 3
7377		MOD_FLD(4,6);					!MODIFY PI CURRENT TO 3
7378		ER_TAB[0] = %O'60000';				!FOR ERROR PRINTOUT
7379		DO (0) WHILE
7380	BLOCK6:	BEGIN
7381		MR();						!DO A MASTER RESET
7382		SET_C(2);					!SET CRAM ADRS TO 2
7383		CP(3);						!GIVE 3 CLOCKS
7384		SET_C(0);					!SET CRAM ADRS TO 0
7385		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7386		WRT204(1);					!WE NEED THIS
7387		WRT204(0);					!TO RESET CRAM LATCH
7388		WRT206(1);					!SET CLK RUN
7389		TICK(56);					!ALOW 14 T CLOCKS
7390		RCVDATA = RD_2;					!READ REGISTER 2
7391		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7392		IF .RCVDATA NEQ %O'14'				!CHECK DATA
7393			THEN BEGIN
7394				ERRCAS(1,1,%O'14',.RCVDATA,3,ER_TAB);	!NO
7395				TEST_FLG = 1;
7396			     END;
7397		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
7398			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
7399		0						!TO ILLUMINATE BLISS INFO COMMENT
7400	
7401		END;
7402		MR();						!MASTER RESET
7403		LC(3);						!LOAD CRAM ADRS 3
7404		MOD_FLD(4,4);					!MODIFY PI CURRENT TO 2
7405		ER_TAB[0] = %O'40000';				!FOR ERROR PRINTOUT
7406		DO (0) WHILE
7407	BLOCK7:	BEGIN
7408		MR();						!DO A MASTER RESET
7409		SET_C(2);					!SET CRAM ADRS TO 2
7410		CP(3);						!GIVE 3 CLOCKS
7411		SET_C(0);					!SET CRAM ADRS TO 0
7412		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7413		WRT204(1);					!WE NEED THIS
7414		WRT204(0);					!TO RESET CRAM LATCH
7415		WRT206(1);					!SET CLK RUN
7416		TICK(56);					!ALOW 14 T CLOCKS
7417		RCVDATA = RD_2;					!READ REGISTER 2
7418		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7419		IF .RCVDATA NEQ %O'50'				!CHECK DATA
7420			THEN BEGIN
7421				ERRCAS(1,1,%O'50',.RCVDATA,3,ER_TAB);	!NO
7422				TEST_FLG = 1;
7423			     END;
7424		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
7425			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
7426		0						!TO ILLUMINATE BLISS INFO COMMENT
7427	
7428		END;
7429		MR();						!MASTER RESET
7430		LC(3);						!LOAD CRAM ADRS 3
7431		MOD_FLD(4,0);					!MODIFY PI CURRENT TO 1
7432		ER_TAB[0] = 0;				!FOR ERROR PRINTOUT
7433		DO (0) WHILE
7434	BLOCK8:	BEGIN
7435		MR();						!DO A MASTER RESET
7436		SET_C(2);					!SET CRAM ADRS TO 2
7437		CP(3);						!GIVE 3 CLOCKS
7438		SET_C(0);					!SET CRAM ADRS TO 0
7439		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7440		WRT204(1);					!WE NEED THIS
7441		WRT204(0);					!TO RESET CRAM LATCH
7442		WRT206(1);					!SET CLK RUN
7443		TICK(56);					!ALOW 14 T CLOCKS
7444		RCVDATA = RD_2;					!READ REGISTER 2
7445		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7446		IF .RCVDATA NEQ %O'44'				!CHECK DATA
7447			THEN BEGIN
7448				ERRCAS(1,1,%O'44',.RCVDATA,3,ER_TAB);	!NO
7449				TEST_FLG = 1;
7450			     END;
7451		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
7452			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
7453		0						!TO ILLUMINATE BLISS INFO COMMENT
7454	
7455		END;
7456		MR();						!MASTER RESET
7457		LC(0);						!LOAD CRAM ADRS 0
7458		MOD_FLD(3,%O'1200');				!DISABLE XMIT
7459		ER_TAB[1] = UPLIT(%ASCIZ'HI');			!FOR ERROR PRINTOUT
7460		DO (0) WHILE
7461	BLOCK9:	BEGIN
7462		MR();						!DO A MASTER RESET
7463		SET_C(2);					!SET CRAM ADRS TO 2
7464		CP(3);						!GIVE 3 CLOCKS
7465		SET_C(0);					!SET CRAM ADRS TO 0
7466		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7467		WRT204(1);					!WE NEED THIS
7468		WRT204(0);					!TO RESET CRAM LATCH
7469		WRT206(1);					!SET CLK RUN
7470		TICK(56);					!ALOW 14 T CLOCKS
7471		RCVDATA = RD_2;					!READ REGISTER 2
7472		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7473		IF .RCVDATA NEQ 0				!CHECK DATA
7474			THEN BEGIN
7475				IF .TEST_FLG EQL 0
7476				     THEN FAILURE(2);
7477				ERRCAS(1,1,0,.RCVDATA,3,ER_TAB);	!NO
7478				TEST_FLG = 1;
7479			     END;
7480		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
7481			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
7482		0						!TO ILLUMINATE BLISS INFO COMMENT
7483	
7484		END;
7485		MR();						!MASTER RESET
7486		LC(0);						!LOAD CRAM ADRS 0
7487		MOD_FLD(3,%O'1300');				!ENABLE XMIT
7488		LC(3);						!LOAD CRAM ADRS 3
7489		MOD_FLD(4,7);					!MODIFY PI CURRENT TO 4
7490		MOD_FLD(1,%O'6707');				!CLEAR PI 
7491		MOD_FLD(2,0);					!LOAD
7492		ER_TAB[0] = %O'70000';				!FOR ERROR PRINTOUT
7493		ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR PRINTOUT
7494		ER_TAB[2] = UPLIT(%ASCIZ'HI');			!FOR ERROR PRINTOUT
7495		DO (0) WHILE
7496	BLOCK10:BEGIN
7497		MR();						!DO A MASTER RESET
7498		SET_C(2);					!SET CRAM ADRS TO 2
7499		CP(3);						!GIVE 3 CLOCKS
7500		SET_C(0);					!SET CRAM ADRS TO 0
7501		SYNC_CLK();					!STOP THE CLOCK AND SYNC
7502		WRT204(1);					!WE NEED THIS
7503		WRT204(0);					!TO RESET CRAM LATCH
7504		WRT206(1);					!SET CLK RUN
7505		TICK(56);					!ALOW 14 T CLOCKS
7506		RCVDATA = RD_2;					!READ REGISTER 2
7507		RCVDATA = .RCVDATA AND %O'74';			!CLEAN UNWANTED BITS
7508		IF .RCVDATA NEQ %O'44'				!CHECK DATA
7509			THEN ERRCAS(1,1,%O'44',.RCVDATA,3,ER_TAB)	!NO
7510			ELSE IF .TEST_FLG EQL 0
7511				THEN NOERR(1);
7512		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
7513			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
7514		0						!TO ILLUMINATE BLISS INFO COMMENT
7515	
7516		END;
7517		MR();						!START THE CLOCK AGAIN
7518		LDVMA = 0;					!CLEAR THIS FLAG
7519	!*MESSAGE 1
7520	!*	PI CURRENT TEST
7521	!*STIMULUS:
7522	!*	DPMC PI XMIT IS \S1
7523	!*	LOAD THE PI SYSTEM \S2
7524	!*	WITH RIGHT HALF OF DP = \O0
7525	!*	SINGLE STEP THE MAIN CLOCK
7526	!*	EXAMINE THE 8080'S REGISTER 2
7527	!*	BITS (14 - 17) CONTAIN THE TRNCVR OUTPUT
7528	!*RESPONSE:
7529	!]ERROR 1
7530	!]BCLK SPECPI PICURNT TRNCVR NTWK
7531	!]ERROR 2
7532	!]TRNCVR NTWK
7533	!]NO ERROR 1
7534	!]SPECPI TRNCVR BCLK NTWK
7535		END;
7536	
7537	GLOBAL ROUTINE TST38: NOVALUE =
7538	
7539	!THIS TEST CHECKS THE PI LEVEL COMPARE THEN INTERRUPT ON DPEB.
7540	!THREE INSTRUCTIONS ARE EXECUTED TO PERFORM THIS TEST.AFTER EACH EXECUTION
7541	!FIELDS ARE MODIFIED TO SET UP DIFFERENT PI LEVELS TO INPUT TO THE CHIP
7542	!PI INTERRUPT HI OR LO IS DETECTED THROUGH THE SKIP LOGIC (SKIP = 37)
7543	!WHICH WILL SKIP TO THE NXT CRAM ADRS IF PI INTERRUPT WAS HI.
7544	!NXT CRAM ADRS IS READ AND VERIFIED.THE INSTRUCTIONS IN THE CRAM WILL
7545	!DO THE FOLLOWING:
7546	!CRAM 2/ CLEAR PI STATUS BY LOADING ZEROS IN ALL THE PI FLOPS.
7547	!CRAM 3/ PUT THE REQUIRED BITS TO SET UP A PI SOFT REQ LEVEL IN LEFT 
7548	!	 HALF OF REGISTER 0.
7549	!CRAM 4/ PUT THE REQUIRED BITS TO SET UP A CURRENT PI LEVEL IN THE RIGHT 
7550	!	 HALF OF THE DATA PATH.PU THE LEFT HALF OF REGISTER 0 ON THE 
7551	!	 LEFT HALF OF THE DATA PATH.LOAD THE SYSTEM.SKIP TO THE NXT 
7552	!	 INSTRUCTION IF PI INTERRUPT EN IS SET.
7553	!	(THIS INSTRUCTION NEEDS TO BE EXECUTED 3 TIMES).
7554	
7555		BEGIN
7556		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
7557		      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,BLOCK11,BLOCK12;
7558		BIND
7559		POINTER = PLIT (U_J(3) U_SPEC_LDPI U,
7560				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(177) U,
7561				U_J(4) U_ALU_OR U_LSRC_0A U_RSRC_D0 U_SKIP_INT U_SPEC_LDPI U_DBUS_DBM U_N(177) U);
7562	
7563		LOAD_U(2,POINTER);				!LOAD INSTRUCTIONS
7564		ER_TAB[0] = UPLIT (%ASCIZ'177,,177');		!FOR ERROR PRINTOUT
7565		DO (0) WHILE
7566	BLOCK1:	BEGIN
7567		SET_C(2);					!SET CRAM ADRS TO 2
7568		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7569		IF .RCVDATA NEQ 4				!CHECK DATA
7570			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
7571		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
7572			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
7573		0						!TO ILLUMINATE BLISS INFO COMMENT
7574	
7575		END;
7576		LC(3);						!LOAD CRAM ADRS 3
7577		MOD_FLD(3,%O'160');				!MODIFY PI SOFT REQ TO 4
7578		ER_TAB[0] = UPLIT (%ASCIZ'160,,177');		!FOR ERROR PRINTOUT
7579		DO (0) WHILE
7580	BLOCK2:	BEGIN
7581		SET_C(2);					!SET CRAM ADRS TO 2
7582		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7583		IF .RCVDATA NEQ 4				!CHECK DATA
7584			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
7585		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
7586			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
7587		0						!TO ILLUMINATE BLISS INFO COMMENT
7588	
7589		END;
7590		LC(3);						!LOAD CRAM ADRS 3
7591		MOD_FLD(3,%O'100');				!MODIFY PI SOFT REQ TO LEVEL 2
7592		ER_TAB[0] = UPLIT (%ASCIZ'100,,177');		!FOR ERROR PRINTOUT
7593		DO (0) WHILE
7594	BLOCK3:	BEGIN
7595		SET_C(2);					!SET CRAM ADRS TO 2
7596		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7597		IF .RCVDATA NEQ 4				!CHECK DATA
7598			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
7599		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
7600			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
7601		0						!TO ILLUMINATE BLISS INFO COMMENT
7602	
7603		END;
7604		LC(3);						!LOAD CRAM ADRS 3
7605		MOD_FLD(3,0);					!MODIFY PI FOFT REQ TO LEVEL 1
7606		ER_TAB[0] = UPLIT (%ASCIZ'177');		!FOR ERROR PRINTOUT
7607		DO (0) WHILE
7608	BLOCK4:	BEGIN
7609		SET_C(2);					!SET CRAM ADRS TO 2
7610		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7611		IF .RCVDATA NEQ 4				!CHECK DATA
7612			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
7613		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
7614			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
7615		0						!TO ILLUMINATE BLISS INFO COMMENT
7616	
7617		END;
7618		LC(4);						!LOAD CRAM ADRS 4
7619		MOD_FLD(4,7);					!MODIFY PI CURRENT TO 4
7620		ER_TAB[0] = UPLIT (%ASCIZ'70177');		!FOR ERROR PRINTOUT
7621		DO (0) WHILE
7622	BLOCK5:	BEGIN
7623		SET_C(2);					!SET CRAM ADRS TO 2
7624		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7625		IF .RCVDATA NEQ 5				!CHECK DATA
7626			THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
7627		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
7628			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
7629		0						!TO ILLUMINATE BLISS INFO COMMENT
7630	
7631		END;
7632		LC(4);						!LOAD CRAM ADRS 4
7633		MOD_FLD(3,%O'7577');				!MODIFY PI CURRENT TO 7
7634		ER_TAB[0] = UPLIT (%ASCIZ'77577');		!FOR ERROR PRINTOUT
7635		DO (0) WHILE
7636	BLOCK6:	BEGIN
7637		SET_C(2);					!SET CRAM ADRS TO 2
7638		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7639		IF .RCVDATA NEQ 5				!CHECK DATA
7640			THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
7641		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
7642			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
7643		0						!TO ILLUMINATE BLISS INFO COMMENT
7644	
7645		END;
7646		LC(3);						!LOAD CRAM ADRS 3
7647		MOD_FLD(3,%O'177');				!MODIFY PI SOFT REQ TO 7
7648		ER_TAB[0] = UPLIT (%ASCIZ'177,,77577');		!FOR ERROR PRINTOUT
7649		DO (0) WHILE
7650	BLOCK7:	BEGIN
7651		SET_C(2);					!SET CRAM ADRS TO 2
7652		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7653		IF .RCVDATA NEQ 4				!CHECK DATA
7654			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
7655		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
7656			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
7657		0						!TO ILLUMINATE BLISS INFO COMMENT
7658	
7659		END;
7660		LC(3);						!LOAD CRAM ADRS 3
7661		MOD_FLD(3,%O'140');				!MODIFY PI SOFT REQ TO 3
7662		LC(4);						!LOAD CRAM ADRS 4
7663		MOD_FLD(3,%O'4177');				!MODIFY PI CURRENT TO LEVEL 5
7664		ER_TAB[0] = UPLIT (%ASCIZ'140,,74177');		!FOR ERROR PRINTOUT
7665		DO (0) WHILE
7666	BLOCK8:	BEGIN
7667		SET_C(2);					!SET CRAM ADRS TO 2
7668		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7669		IF .RCVDATA NEQ 5				!CHECK DATA
7670			THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
7671		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
7672			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
7673		0						!TO ILLUMINATE BLISS INFO COMMENT
7674	
7675		END;
7676		LC(3);						!LOAD CRAM ADRS 3
7677		MOD_FLD(3,%O'176');				!MODIFY PI SOFT REQ TO 7
7678		LC(4);						!LOAD CRAM ADRS 4
7679		MOD_FLD(3,%O'6177');				!MODIFY PI CURRENT LEVEL TO 6
7680		ER_TAB[0] = UPLIT (%ASCIZ'176,,76177');		!FOR ERROR PRINTOUT
7681		DO (0) WHILE
7682	BLOCK9:	BEGIN
7683		SET_C(2);					!SET CRAM ADRS TO 2
7684		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7685		IF .RCVDATA NEQ 4				!CHECK DATA
7686			THEN ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
7687		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
7688			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
7689		0						!TO ILLUMINATE BLISS INFO COMMENT
7690	
7691		END;
7692		LC(3);						!LOAD CRAM ADRS 3
7693		MOD_FLD(3,%O'170');				!MODIFY PI SOFT REQ TO 5
7694		ER_TAB[0] = UPLIT (%ASCIZ'170,,76177');		!FOR ERROR PRINTOUT
7695		DO (0) WHILE
7696	BLOCK10:BEGIN
7697		SET_C(2);					!SET CRAM ADRS TO 2
7698		RCVDATA = STEP_U_NEXT(5);			!5 CLOCKS & GET NXT CRAM ADRS
7699		IF .RCVDATA NEQ 5				!CHECK DATA
7700			THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
7701		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
7702			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
7703		0						!TO ILLUMINATE BLISS INFO COMMENT
7704	
7705		END;
7706		LC(3);						!LOAD CRAM ADRS 3
7707		MOD_FLD(3,%O'176');				!MODIFY PI SOFT TO 7
7708		LC(4);						!LOAD CRAM ADRS 4
7709		MOD_FLD(3,%O'7577');				!MODIFY PI CURNT TO NONE
7710		ER_TAB[0] = UPLIT(%ASCIZ'176,,77577');		!FOR ERROR
7711		DO (0) WHILE
7712	BLOCK11:BEGIN
7713		SET_C(2);					!SET CRAM ADRS TO 2
7714		RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLK & GET NXT CRAM ADRS
7715		IF .RCVDATA NEQ 5				!CHECK DATA
7716			THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
7717		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
7718			THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
7719		0						!TO ILLUMINATE BLISS INFO COMMENT
7720	
7721		END;
7722		LC(3);						!LOAD CRAM ADRS 3
7723		MOD_FLD(3,%O'160');				!MODIFY PI SOFT TO 4
7724		LC(4);						!LOAD CRAM ADRS 4
7725		MOD_FLD(3,%O'4177');				!MODIFY PI CURNT TO 5
7726		ER_TAB[0] = UPLIT(%ASCIZ'160,,74177');		!FOR ERROR PRINTOUT
7727		DO (0) WHILE
7728	BLOCK12:BEGIN
7729		SET_C(2);					!SET CRAM ADRS TO 2
7730		RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLK & GET NXT CRAM ADRS
7731		IF .RCVDATA NEQ 5				!CHECK DATA
7732			THEN ERRCAS(1,1,5,.RCVDATA,4,ER_TAB);	!NO
7733		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
7734			THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
7735		0						!TO ILLUMINATE BLISS INFO COMMENT
7736	
7737		END;
7738	!*MESSAGE 1
7739	!*	PI COMPARE TEST
7740	!*STIMULUS:
7741	!*	LOAD THE PI SYSTEM WITH DP = \S0
7742	!*	SKIP ON DPEB INTERRUPT REQ (J = 4)
7743	!*RESPONSE:
7744	!*	EXAMINE NXT CRAM ADRS
7745	!]ERROR 1
7746	!]BCLK CCLK SKIP PINEW PIENC PICURNT PISOFT PIACTV ORPI ANDPI SPECPI NTWK
7747		END;
7748	
7749	GLOBAL ROUTINE TST39: NOVALUE =
7750	
7751	!THIS TEST CHECKS P.C. FLAGS ON DPE9 .
7752	!IT STARTS BY LOADING THE FLAGS INTO THE FLOPS FROM THE DATA PATH AND 
7753	!AFTER VERIFYING THAT THEY DID GET LOADED WE LOOP THE FLAGS BACK INTO 
7754	!THE FLOPS (MIX SELECT = 0) AND VERIFY THE RESULT.
7755	!THIS TEST VERIFIES ALL INPUTS TO THE MIX'S AS WELL AS ALL THE OUPUTS OF 
7756	!THE FLAG FLOPS .SOME OF THE OR & AND GATES ARE TESTED ALSO.
7757	!ALL FLOP OUTPUTS ARE VERIFIED BY WRITTING THE FLAGS INTO REGISTER 0
7758	!OF THE 2901'S VIA DBUS (DBUS SELECT = 0).THEN WRITTING THE CONTENTS OF 
7759	!REGISTER 0 INTO PHYSICAL MEM.
7760	!THIS TEST REQUIRES EXECUTING 5 MICROINSTRUCTIONS IN CRAM 1,2,3,4 & 5:
7761	!CRAM 1/ PUT THE REQUIRED DATA TO SET THE FLAGS IN REGISTER 0
7762	!	 OF THE 2901'S.
7763	!CRAM 2/ CLEAR USER FLAG AND INITIALIZE.
7764	!CRAM 3/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE FLAGS FROM DP
7765	!CRAM 4/ START A PHYSICAL MEM WRITE CYCLE AND PUT THE FLAGS IN REGISTER 0
7766	!	 VIA DBUS.
7767	!CRAM 5/ FINISH MEM CYCLE AND OUPUT THE CONTENTS OF REGISTER 0 INTO MEMORY.
7768	!WE EXAMINE AND VERIFY THE DATA FROM PHYSICAL MEM 0.
7769	!THIS TEST WILL CALL VMA_LD ROUTINE WHICH LOADS THE VMA WITH A 0.
7770	
7771		BEGIN
7772		OWN TEST_FLG1,TEST_FLG;
7773		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
7774		BIND
7775		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD_MUL2 U_DBUS_DBM U_NO_CLKR U,
7776				U_J(3) U_DEST_AD U_SPEC_FLAGS U_NO_CLKL U,
7777				U_J(4) U_ALU_OR U_SPEC_FLAGS U_N(4) U,
7778				U_J(5) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_PC_FLAGS U_MEM U_N(11002) U,
7779				U_J(1) U_ALU_OR U_MEM U_N(2) U);
7780		VMA_LD();					!CHECK AND LOAD THE VMA WITH 0
7781		LOAD_U(1,POINTER);				!LOAD 4 INSTRUCTIONS
7782		TEST_FLG = 0;
7783		SET_C(1);					!SET CRAM ADRS TO 1
7784		DO (0) WHILE
7785	BLOCK1:	BEGIN
7786		TEST_FLG = 0;
7787		DM(0,%O'-1');					!SET MEM TO -1
7788		CP(5);						!GIVE 5 CLOCKS
7789		RCVDATA = EM(0);				!GET DATA
7790		RCVDATA = .RCVDATA AND %O'774740000000';		!CLEAR UNWANTED BITS
7791		IF .RCVDATA NEQ 0				!CHECK DATA
7792			THEN BEGIN
7793				ERMCA(1,0,.RCVDATA,12);	!NO
7794				PCDBUS_FLG = 1;
7795				TEST_FLG1 = 1;
7796				TEST_FLG = 1;
7797			     END;
7798		IF (.RCVDATA AND %O'400000000000') NEQ 0
7799			THEN FAILURE(1);
7800		IF (.RCVDATA AND %O'200000000000') NEQ 0
7801			THEN FAILURE(2);
7802		IF (.RCVDATA AND %O'100000000000') NEQ 0
7803			THEN FAILURE(3);
7804		IF (.RCVDATA AND %O'40000000000') NEQ 0
7805			THEN FAILURE(4);
7806		IF (.RCVDATA AND %O'20000000000') NEQ 0
7807			THEN FAILURE(5);
7808		IF (.RCVDATA AND %O'10000000000') NEQ 0
7809			THEN FAILURE(6);
7810		IF (.RCVDATA AND %O'4000000000') NEQ 0
7811			THEN FAILURE(7);
7812		IF (.RCVDATA AND %O'400000000') NEQ 0
7813			THEN FAILURE(8);
7814		IF (.RCVDATA AND %O'200000000') NEQ 0
7815			THEN FAILURE(9);
7816		IF (.RCVDATA AND %O'100000000') NEQ 0
7817			THEN FAILURE(10);
7818		IF (.RCVDATA AND %O'40000000') NEQ 0
7819			THEN FAILURE(11);
7820	
7821	!*MESSAGE 1
7822	!*STIMULUS:
7823	!*	P.C. FLAGS TEST
7824	!*	LOAD THE FLAGS FROM DP (DP LEFT = 0)
7825	!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
7826	!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
7827	!*RESPONSE:
7828	!*	EXAMINE DATA FROM PHYSICAL MEM 0
7829	
7830		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
7831			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
7832		0						!TO ILLUMINATE BLISS INFO COMMENT
7833	
7834		END;
7835		LC(3);						!LOAD CRAM ADRS 3
7836		MOD_FLD(3,0);					!CLEAR LOAD FLAGS
7837		MOD_FLD(4,1);					!SET HOLD USER
7838		MOD_FLD(5,%O'7447');
7839		IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
7840		DO (0) WHILE					!NO WE DIDN'T
7841	BLOCK2:	BEGIN
7842		DM(0,%O'-1');					!SET MEM TO -1
7843		CP(3);						!GIVE 3 CLOCKS
7844		RCVDATA = EM(0);				!GET DATA
7845		RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
7846		IF .RCVDATA NEQ 0				!CHECK DATA
7847			THEN BEGIN
7848				TEST_FLG1 = 1;
7849				ERMCA(2,0,.RCVDATA,12);		!NO
7850				TEST_FLG = 1;
7851			     END;
7852		IF (.RCVDATA AND %O'400000000000') NEQ 0
7853			THEN FAILURE(12);
7854		IF (.RCVDATA AND %O'200000000000') NEQ 0
7855			THEN FAILURE(13);
7856		IF (.RCVDATA AND %O'100000000000') NEQ 0
7857			THEN FAILURE(13);
7858		IF (.RCVDATA AND %O'40000000000') NEQ 0
7859			THEN FAILURE(12);
7860		IF (.RCVDATA AND %O'20000000000') NEQ 0
7861			THEN FAILURE(13);
7862		IF (.RCVDATA AND %O'10000000000') NEQ 0
7863			THEN FAILURE(14);
7864		IF (.RCVDATA AND %O'4000000000') NEQ 0
7865			THEN FAILURE(15);
7866		IF (.RCVDATA AND %O'400000000') NEQ 0
7867			THEN FAILURE(16);
7868		IF (.RCVDATA AND %O'200000000') NEQ 0
7869			THEN FAILURE(17);
7870		IF (.RCVDATA AND %O'100000000') NEQ 0
7871			THEN FAILURE(12);
7872		IF (.RCVDATA AND %O'40000000') NEQ 0
7873			THEN FAILURE(12);
7874	
7875	!*MESSAGE 2
7876	!*STIMULUS:
7877	!*	P.C. FLAGS TEST
7878	!*	LOAD THE FLAGS FROM DP (DP LEFT = 0)
7879	!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
7880	!*	HOLD USER IS SET (DBM 05)
7881	!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
7882	!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
7883	!*RESPONSE:
7884	!*	EXAMINE DATA FROM MEM 0
7885		SET_C(3);					!SET CRAM ADRS TO 3
7886		IF LOOP_CHK(2) THEN				!IS LOOP ON ERROR SET ?
7887			LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
7888		0						!TO ILLUMINATE BLISS INFO COMMENT
7889	
7890		END;
7891		LC(3);						!LOAD  CRAM ADRS 3
7892		MOD_FLD(5,%O'3447');
7893		MOD_FLD(4,0);					!CLEAR HOLD USER
7894		LC(1);						!LOAD CRAM ADRS 1
7895		MOD_FLD(3,%O'6360');				!SET FLAG 
7896		MOD_FLD(4,%O'37');				!BITS IN DP
7897		IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
7898		DO (0) WHILE
7899	BLOCK3:	BEGIN
7900		TEST_FLG = 0;
7901		DM(0,%O'-1');					!SET MEM TO -1
7902		CP(5);						!GIVE 5 CLOCKS
7903		RCVDATA = EM(0);				!GET DATA FROM MEM
7904		RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
7905		IF .RCVDATA NEQ 0				!CHECK DATA
7906			THEN BEGIN
7907				ERMCA(3,0,.RCVDATA,12);		!NO
7908				TEST_FLG1 = 1;
7909			     END;
7910	
7911		IF (.RCVDATA AND %O'400000000000') NEQ 0
7912			THEN FAILURE(18);
7913		IF (.RCVDATA AND %O'200000000000') NEQ 0
7914			THEN FAILURE(19);
7915		IF (.RCVDATA AND %O'100000000000') NEQ 0
7916			THEN FAILURE(20);
7917		IF (.RCVDATA AND %O'40000000000') NEQ 0
7918			THEN FAILURE(21);
7919		IF (.RCVDATA AND %O'20000000000') NEQ 0
7920			THEN FAILURE(22);
7921		IF (.RCVDATA AND %O'10000000000') NEQ 0
7922			THEN FAILURE(14);
7923		IF (.RCVDATA AND %O'4000000000') NEQ 0
7924			THEN FAILURE(23);
7925		IF (.RCVDATA AND %O'400000000') NEQ 0
7926			THEN FAILURE(16);
7927		IF (.RCVDATA AND %O'200000000') NEQ 0
7928			THEN FAILURE(24);
7929		IF (.RCVDATA AND %O'100000000') NEQ 0
7930			THEN FAILURE(21);
7931		IF (.RCVDATA AND %O'40000000') NEQ 0
7932			THEN FAILURE(21);
7933	
7934	!*MESSAGE 3
7935	!*STIMULUS:
7936	!*	P.C. FLAGS TEST
7937	!*	LOAD THE FLAGS WITH 0
7938	!*	LOAD THE FLAGS WITH DP LEFT = 774740
7939	!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
7940	!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
7941	!*	(BIT 15 IS CLEAR ON DBM FLAGS SHOULD NOT LOAD FROM DP)
7942	!*RESPONSE:
7943	!*	EXAMINE DATA FROM PHYSICAL MEM 0
7944		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
7945			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
7946		0						!TO ILLUMINATE BLISS INFO COMMENT
7947	
7948		END;
7949		LC(3);						!LOAD CRAM ADRS 3
7950		MOD_FLD(3,4);					!SET LOAD FLAGS FROM DP
7951		SET_C(1);					!SET CRAM ADRS TO 1
7952		DO (0) WHILE
7953	BLOCK4:	BEGIN
7954		TEST_FLG = 0;
7955		DM(0,%O'-1');					!SET MEM TO -1
7956		CP(5);						!GIVE 5 CLOCKS
7957		RCVDATA = EM(0);				!GET DATA FROM MEM
7958		RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
7959		IF .RCVDATA NEQ %O'774740000000'		!CHECK DATA
7960			THEN BEGIN
7961				ERMCA(4,%O'774740000000',.RCVDATA,12);!NO
7962				TEST_FLG1 = 1;
7963				TEST_FLG = 1;
7964			     END
7965			ELSE IF .PCDBUS_FLG EQL 0
7966				THEN NOERR(1);
7967	
7968		IF (.RCVDATA AND %O'400000000000') EQL 0
7969			THEN FAILURE(25);
7970		IF (.RCVDATA AND %O'200000000000') EQL 0
7971			THEN FAILURE(26);
7972		IF (.RCVDATA AND %O'100000000000') EQL 0
7973			THEN FAILURE(27);
7974		IF (.RCVDATA AND %O'40000000000') EQL 0
7975			THEN FAILURE(28);
7976		IF (.RCVDATA AND %O'20000000000') EQL 0
7977			THEN FAILURE(5);
7978		IF (.RCVDATA AND %O'10000000000') EQL 0
7979			THEN FAILURE(6);
7980		IF (.RCVDATA AND %O'4000000000') EQL 0
7981			THEN FAILURE(29);
7982		IF (.RCVDATA AND %O'400000000') EQL 0
7983			THEN FAILURE(8);
7984		IF (.RCVDATA AND %O'200000000') EQL 0
7985			THEN FAILURE(30);
7986		IF (.RCVDATA AND %O'100000000') EQL 0
7987			THEN FAILURE(10);
7988		IF (.RCVDATA AND %O'40000000') EQL 0
7989			THEN FAILURE(11);
7990	
7991	!*MESSAGE 4
7992	!*STIMULUS:
7993	!*	P.C. FLAGS TEST
7994	!*	LOAD THE FLAGS FROM DP (DP LEFT = 774740)
7995	!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
7996	!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
7997	!*RESPONSE:
7998	!*	EXAMINE DATA FROM PHYSICAL MEM 0
7999		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
8000			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
8001		0						!TO ILLUMINATE BLISS INFO COMMENT
8002	
8003		END;
8004		LC(3);						!LOAD CRAM ADRS 3
8005		MOD_FLD(3,0);					!CLEAR LOAD FLAG 
8006		MOD_FLD(4,1);					!SET HOLD USER
8007		MOD_FLD(5,%O'4447');
8008		IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
8009		DO (0) WHILE					!NO WE DIDN'T
8010	BLOCK5:	BEGIN
8011		TEST_FLG = 0;
8012		DM(0,%O'-1');					!SET MEM TO -1
8013		CP(3);						!GIVE 3 CLOCKS
8014		RCVDATA = EM(0);				!GET DATA FROM MEM
8015		RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
8016		IF .RCVDATA NEQ %O'774140000000'		!CHECK DATA
8017			THEN BEGIN
8018				ERMCA(5,%O'774140000000',.RCVDATA,12);!NO
8019				TEST_FLG1 = 1;
8020				TEST_FLG = 1;
8021			     END;
8022		IF (.RCVDATA AND %O'400000000000') EQL 0
8023			THEN FAILURE(12);
8024		IF (.RCVDATA AND %O'200000000000') EQL 0
8025			THEN FAILURE(13);
8026		IF (.RCVDATA AND %O'100000000000') EQL 0
8027			THEN FAILURE(13);
8028		IF (.RCVDATA AND %O'40000000000') EQL 0
8029			THEN FAILURE(12);
8030		IF (.RCVDATA AND %O'20000000000') EQL 0
8031			THEN FAILURE(13);
8032		IF (.RCVDATA AND %O'10000000000') EQL 0
8033			THEN FAILURE(14);
8034		IF (.RCVDATA AND %O'4000000000') EQL 0
8035			THEN FAILURE(31);
8036		IF (.RCVDATA AND %O'400000000') NEQ 0
8037			THEN FAILURE(16);
8038		IF (.RCVDATA AND %O'200000000') NEQ 0
8039			THEN FAILURE(9);
8040		IF (.RCVDATA AND %O'100000000') EQL 0
8041			THEN FAILURE(12);
8042		IF (.RCVDATA AND %O'40000000') EQL 0
8043			THEN FAILURE(12);
8044	
8045	!*MESSAGE 5
8046	!*STIMULUS:
8047	!*	P.C. FLAGS TEST
8048	!*	LOAD THE FLAGS FROM DP (DP LEFT = 774740)
8049	!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
8050	!*	HOLD USER FLAG IS SET (DBM 05)
8051	!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
8052	!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
8053	!*RESPONSE:
8054	!*	EXAMINE DATA FROM PHYSICAL MEM 0
8055		SET_C(3);					!SET CRAM ADRS TO 3
8056		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
8057			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
8058		0						!TO ILLUMINATE BLISS INFO COMMENT
8059	
8060		END;
8061		MOD_FLD(4,0);					!CLEAR HOLD USER
8062		IF .TEST_FLG EQL 0 THEN				!DID WE GET AN ERROR
8063		DO (0) WHILE					!NO WE DIDN'T
8064	BLOCK6:	BEGIN
8065		TEST_FLG = 0;
8066		DM(0,%O'-1');					!SET MEM TO -1
8067		SET_C(2);					!SET CRAM ADRS TO 2
8068		CP(4);						!GIVE 4 CLOCKS
8069		RCVDATA = EM(0);				!GET DATA FROM MEM
8070		RCVDATA = .RCVDATA AND %O'774740000000';	!CLEAR UNWANTED BITS
8071		IF .RCVDATA NEQ %O'764140000000'		!CHECK DATA
8072			THEN ERMCA(6,%O'764140000000',.RCVDATA,12)!NO
8073			ELSE IF .TEST_FLG1 EQL 0
8074				THEN NOERR(2);
8075	
8076		IF (.RCVDATA AND %O'400000000000') EQL 0
8077			THEN FAILURE(12);
8078		IF (.RCVDATA AND %O'200000000000') EQL 0
8079			THEN FAILURE(13);
8080		IF (.RCVDATA AND %O'100000000000') EQL 0
8081			THEN FAILURE(13);
8082		IF (.RCVDATA AND %O'40000000000') EQL 0
8083			THEN FAILURE(12);
8084		IF (.RCVDATA AND %O'20000000000') EQL 0
8085			THEN FAILURE(13);
8086		IF (.RCVDATA AND %O'10000000000') NEQ 0
8087			THEN FAILURE(14);
8088		IF (.RCVDATA AND %O'4000000000') EQL 0
8089			THEN FAILURE(31);
8090		IF (.RCVDATA AND %O'400000000') NEQ 0
8091			THEN FAILURE(16);
8092		IF (.RCVDATA AND %O'200000000') NEQ 0
8093			THEN FAILURE(9);
8094		IF (.RCVDATA AND %O'100000000') EQL 0
8095			THEN FAILURE(12);
8096		IF (.RCVDATA AND %O'40000000') EQL 0
8097			THEN FAILURE(12);
8098	
8099	!*MESSAGE 6
8100	!*STIMULUS:
8101	!*	P.C. FLAGS TEST
8102	!*	LOAD THE FLAGS FROM DP (DP LEFT = 774740)
8103	!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
8104	!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
8105	!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
8106	!*RESPONSE:
8107	!*	EXAMINE DATA FROM PHYSICAL MEM 0
8108		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
8109			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
8110		0						!TO ILLUMINATE BLISS INFO COMMENT
8111	
8112		END;
8113	!]NO ERROR 1
8114	!]PCDBUS NTWK
8115	!]NO ERROR 2
8116	!]SPECPC FCLK NTWK
8117	!]ERROR 1
8118	!]PCDBUS A B C D E H G I SPECPC FCLK NTWK
8119	!]ERROR 2
8120	!]PCDBUS J K L G SPECPC FCLK NTWK
8121	!]ERROR 3
8122	!]PCDBUS FCLK J L M G SPECPC NTWK
8123	!]ERROR 4
8124	!]PCDBUS FCLK A G I B D N H SPECPC NTWK
8125	!]ERROR 5
8126	!]PCDBUS FCLK J O P L G SPECPC NTWK
8127	!]ERROR 6
8128	!]PCDBUS FCLK Q G R SPECPC NTWK
8129	!]ERROR 7
8130	!]PCDBUS FCLK SPECPC Q S G NTWK
8131	!]ERROR 8
8132	!]PCDBUS FCLK SPECPC Q V NTWK
8133	!]ERROR 9
8134	!]PCDBUS FCLK SPECPC A I G B C D U NTWK
8135	!]ERROR 10
8136	!]PCDBUS FCLK SPECPC A I G W H NTWK
8137	!]ERROR 11
8138	!]PCDBUS FCLK SPECPC Q X H G NTWK
8139	!]ERROR 12
8140	!]G H NTWK
8141	!]ERROR 13
8142	!]G L NTWK
8143	!]ERROR 14
8144	!]R G NTWK
8145	!]ERROR 15
8146	!]S NTWK
8147	!]ERROR 16
8148	!]V NTWK
8149	!]ERROR 17
8150	!]U G NTWK
8151	!]ERROR 18
8152	!]C H G NTWK
8153	!]ERROR 19
8154	!]L G NTWK
8155	!]ERROR 20
8156	!]M L G NTWK
8157	!]ERROR 21
8158	!]H G NTWK
8159	!]ERROR 22
8160	!]L G NTWK
8161	!]ERROR 23
8162	!]S G NTWK
8163	!]ERROR 24
8164	!]C U G NTWK
8165	!]ERROR 25
8166	!]PCDBUS FCLK SPECPC A B E F H G I NTWK
8167	!]ERROR 26
8168	!]PCDBUS FCLK SPECPC J K L F G NTWK
8169	!]ERROR 27
8170	!]PCDBUS FCLK J M F L G NTWK
8171	!]ERROR 28
8172	!]PCDBUS FCLK SPECPC A I G B N F H NTWK
8173	!]ERROR 29
8174	!]PCDBUS FCLK SPECPC Q S G NTWK
8175	!]ERROR 30
8176	!]PCDBUS FCLK SPECPC A I G U NTWK
8177	!]ERROR 31
8178	!]PCDBUS FCLK Z S NTWK
8179		END;
8180	
8181	GLOBAL ROUTINE TST40: NOVALUE =
8182	
8183	!THIS TEST CHECKS ALL THE JFCL LOGIC ON DPE9 .
8184	!THIS TEST FLOATS A ZERO ON ALL THE AND GATES INPUTS AND VERIFIES THE 
8185	!OUTPUT BY SKIP ON JFCL.IT EXECUTES 3 INSTRUCTIONS IN CRAM 1,2 & 3:
8186	!CRAM 1/ PUT THE REQUIRED DATA TO SET OR CLEAR THE FLAGS AND SET OR 
8187	!	 CLEAR DPEA AC'S ON DP AS WELL AS REGISTER 0.AND LOAD THE FLAGS 
8188	!	 FROM DP.
8189	!CRAM 2/ LOAD THE IR FROM REGISTER 0 OF THE 2901'S.
8190	!CRAM 3/ ENABLE OR DISABLE THE JFCL AND SKIP IN JFCL IS SET (THE ORED J FIELD = 4).
8191	!WE READ THE NXT CRAM ADRS AND VERIFY IT.
8192	
8193		BEGIN
8194		OWN TEST_FLG;
8195		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
8196		      BLOCK5,BLOCK6,BLOCK7,BLOCK8,
8197		      BLOCK9,BLOCK10,BLOCK11,BLOCK12,
8198		      BLOCK13,BLOCK14,BLOCK15,BLOCK16,BLOCK17;
8199		BIND
8200		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SPEC_FLAGS U_N(400004) U,
8201				U_J(3) U_ALU_OR U_SPEC_LOADIR U,
8202				U_J(4) U_SKIP_JFCL U_SPEC_FLAGS U_N(10) U,
8203				U_J(5) U_MEM U_N(11012) U,
8204				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);
8205		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
8206		ER_TAB[0] = UPLIT (%ASCIZ'OV FLAG IS HI');	!FOR ERROR PRINTOUT
8207		ER_TAB[1] = UPLIT (%ASCIZ'AC 09 IS LO');	!FOR ERROR PRINTOUT
8208		ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
8209		DO (0) WHILE
8210	BLOCK1:	BEGIN
8211		SET_C(1);					!SET CRAM ADRS TO 1
8212		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8213		IF .RCVDATA NEQ 4				!CHECK DATA
8214			THEN BEGIN
8215				ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
8216				TEST_FLG = 1;
8217			     END;
8218		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
8219			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
8220		0						!TO ILLUMINATE BLISS INFO COMMENT
8221	
8222		END;
8223		MOD_FLD(4,0);					!CLEAR OV FLAG
8224		MOD_FLD(3,%O'404');				!SET DPEA 09
8225		ER_TAB[0] = UPLIT (%ASCIZ'OV FLAG IS LO');	!FOR ERROR PRINTOUT
8226		ER_TAB[1] = UPLIT (%ASCIZ'AC 09 IS HI');	!FOR ERROR PRINTOUT
8227		DO (0) WHILE
8228	BLOCK2:	BEGIN
8229		SET_C(1);					!SET CRAM ADRS TO 1
8230		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8231		IF .RCVDATA NEQ 4				!CHECK DATA
8232			THEN BEGIN
8233				ERRCAS(2,1,4,.RCVDATA,4,ER_TAB);	!NO
8234				TEST_FLG = 1;
8235			     END;
8236		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
8237			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
8238		0						!TO ILLUMINATE BLISS INFO COMMENT
8239	
8240		END;
8241		MOD_FLD(4,%O'40');				!SET OV
8242		LC(3);						!LOAD CRAM ADRS 3
8243		MOD_FLD(3,0);					!CLEAR JFCL EN
8244		ER_TAB[0] = UPLIT (%ASCIZ'OV FLAG IS HI');	!FOR ERROR PRINTOUT
8245		ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
8246		DO (0) WHILE
8247	BLOCK3:	BEGIN
8248		SET_C(1);					!SET CRAM ADRS TO 1
8249		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8250		IF .RCVDATA NEQ 4				!CHECK DATA
8251			THEN BEGIN
8252				ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
8253				TEST_FLG = 1;
8254			     END;
8255		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
8256			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
8257		0						!TO ILLUMINATE BLISS INFO COMMENT
8258	
8259		END;
8260		LC(3);						!LOAD CRAM ADRS 3
8261		MOD_FLD(3,%O'10');				!SET JFCL EN
8262		ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
8263		DO (0) WHILE
8264	BLOCK4:	BEGIN
8265		SET_C(1);					!SET CRAM ADRS TO 1
8266		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8267		IF .RCVDATA NEQ 5				!CHECK DATA
8268			THEN BEGIN
8269				ERRCAS(4,1,5,.RCVDATA,4,ER_TAB);	!NO
8270				TEST_FLG = 1;
8271			     END;
8272		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
8273			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
8274		0						!TO ILLUMINATE BLISS INFO COMMENT
8275	
8276		END;
8277		MOD_FLD(4,0);					!CLEAR FLAGS
8278		MOD_FLD(3,%O'204');				!SET DPEA AC 10
8279		ER_TAB[0] = UPLIT (%ASCIZ'CRY0 FLAG IS LO');	!FOR ERROR PRINTOUT
8280		ER_TAB[1] = UPLIT (%ASCIZ'AC 10 IS HI');	!FOR ERROR PRINTOUT
8281		DO (0) WHILE
8282	BLOCK5:	BEGIN
8283		SET_C(1);					!SET CRAM ADRS TO 1
8284		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8285		IF .RCVDATA NEQ 4				!CHECK DATA
8286			THEN BEGIN
8287				ERRCAS(5,1,4,.RCVDATA,4,ER_TAB);	!NO
8288				TEST_FLG = 1;
8289			     END;
8290		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
8291			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
8292		0						!TO ILLUMINATE BLISS INFO COMMENT
8293	
8294		END;
8295		MOD_FLD(4,%O'20');				!SET CRY0 FLAG
8296		MOD_FLD(3,4);					!CLEAR DPEA AC 10
8297		ER_TAB[0] = UPLIT (%ASCIZ'CRY0 FLAG IS HI');	!FOR ERROR PRINTOUT
8298		ER_TAB[1] = UPLIT (%ASCIZ'AC 10 IS LO');	!FOR ERROR PRINTOUT
8299		DO (0) WHILE
8300	BLOCK6:	BEGIN
8301		SET_C(1);					!SET CRAM ADRS TO 1
8302		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8303		IF .RCVDATA NEQ 4				!CHECK DATA
8304			THEN BEGIN
8305				ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
8306				TEST_FLG = 1;
8307			     END;
8308		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
8309			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
8310		0						!TO ILLUMINATE BLISS INFO COMMENT
8311	
8312		END;
8313		MOD_FLD(3,%O'204');				!SET DPEA AC 10
8314		LC(3);						!LOAD CRAM ADRS 3
8315		MOD_FLD(3,0);					!CLEAR JFCL EN
8316		ER_TAB[1] = UPLIT (%ASCIZ'AC 10 IS HI');	!FOR ERROR PRINTOUT
8317		ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
8318		DO (0) WHILE
8319	BLOCK7:	BEGIN
8320		SET_C(1);					!SET CRAM ADRS TO 1
8321		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8322		IF .RCVDATA NEQ 4				!CHECK DATA
8323			THEN BEGIN
8324				ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
8325				TEST_FLG = 1;
8326			     END;
8327		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
8328			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
8329		0						!TO ILLUMINATE BLISS INFO COMMENT
8330	
8331		END;
8332		LC(3);						!LOAD CRAM ADRS 3
8333		MOD_FLD(3,%O'10');				!SET JFCL EN
8334		ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
8335		DO (0) WHILE
8336	BLOCK8:	BEGIN
8337		SET_C(1);					!SET CRAM ADRS TO 1
8338		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8339		IF .RCVDATA NEQ 5				!CHECK DATA
8340			THEN BEGIN
8341				ERRCAS(6,1,5,.RCVDATA,4,ER_TAB);	!NO
8342				TEST_FLG = 1;
8343			     END;
8344		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
8345			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
8346		0						!TO ILLUMINATE BLISS INFO COMMENT
8347	
8348		END;
8349		MOD_FLD(4,0);					!CLEAR FLAGS
8350		MOD_FLD(3,%O'104');				!SET DPEA AC 11
8351		ER_TAB[0] = UPLIT (%ASCIZ'CRY1 FLAG IS LO');	!FOR ERROR PRINTOUT
8352		ER_TAB[1] = UPLIT (%ASCIZ'AC 11 IS HI');	!FOR ERROR PRINTOUT
8353		DO (0) WHILE
8354	BLOCK9:	BEGIN
8355		SET_C(1);					!SET CRAM ADRS TO 1
8356		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8357		IF .RCVDATA NEQ 4				!CHECK DATA
8358			THEN BEGIN
8359				ERRCAS(7,1,4,.RCVDATA,4,ER_TAB);	!NO
8360				TEST_FLG = 1;
8361			     END;
8362		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
8363			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
8364		0						!TO ILLUMINATE BLISS INFO COMMENT
8365	
8366		END;
8367		MOD_FLD(4,%O'10');				!SET CRY1 FLAG
8368		MOD_FLD(3,4);					!CLEAR DPEA AC 11
8369		ER_TAB[0] = UPLIT (%ASCIZ'CRY1 FLAG IS HI');	!FOR ERROR PRINTOUT
8370		ER_TAB[1] = UPLIT (%ASCIZ'AC 11 IS LO');	!FOR ERROR PRINTOUT
8371		DO (0) WHILE
8372	BLOCK10:BEGIN
8373		SET_C(1);					!SET CRAM ADRS TO 1
8374		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8375		IF .RCVDATA NEQ 4				!CHECK DATA
8376			THEN BEGIN
8377				ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
8378				TEST_FLG = 1;
8379			     END;
8380		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
8381			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
8382		0						!TO ILLUMINATE BLISS INFO COMMENT
8383	
8384		END;
8385		MOD_FLD(3,%O'104');				!SET DPEA AC 11
8386		LC(3);						!LOAD CRAM ADRS 3
8387		TEST_FLG = 0;
8388		MOD_FLD(3,0);					!CLEAR JFCL EN
8389		ER_TAB[1] = UPLIT (%ASCIZ'AC 11 IS HI');	!FOR ERROR PRINTOUT
8390		ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
8391		DO (0) WHILE
8392	BLOCK11:BEGIN
8393		SET_C(1);					!SET CRAM ADRS TO 1
8394		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8395		IF .RCVDATA NEQ 4				!CHECK DATA
8396			THEN BEGIN
8397				ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
8398				TEST_FLG = 1;
8399			     END;
8400		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
8401			THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
8402		0						!TO ILLUMINATE BLISS INFO COMMENT
8403	
8404		END;
8405		LC(3);						!LOAD CRAM ADRS 3
8406		MOD_FLD(3,%O'10');				!SET JFCL EN
8407		ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
8408		DO (0) WHILE
8409	BLOCK12:BEGIN
8410		SET_C(1);					!SET CRAM ADRS TO 1
8411		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8412		IF .RCVDATA NEQ 5				!CHECK DATA
8413			THEN BEGIN
8414				ERRCAS(8,1,5,.RCVDATA,4,ER_TAB);	!NO
8415				TEST_FLG = 1;
8416			     END;
8417		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
8418			THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
8419		0						!TO ILLUMINATE BLISS INFO COMMENT
8420	
8421		END;
8422		MOD_FLD(4,0);					!CLEAR FLAGS
8423		MOD_FLD(3,%O'44');				!SET DPEA AC 12
8424		ER_TAB[0] = UPLIT (%ASCIZ'FOV FLAG IS LO');	!FOR ERROR PRINTOUT
8425		ER_TAB[1] = UPLIT (%ASCIZ'AC 12 IS HI');	!FOR ERROR PRINTOUT
8426		DO (0) WHILE
8427	BLOCK13:BEGIN
8428		SET_C(1);					!SET CRAM ADRS TO 1
8429		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8430		IF .RCVDATA NEQ 4				!CHECK DATA
8431			THEN BEGIN
8432				ERRCAS(9,1,4,.RCVDATA,4,ER_TAB);	!NO
8433				TEST_FLG = 1;
8434			     END;
8435		IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
8436			THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
8437		0						!TO ILLUMINATE BLISS INFO COMMENT
8438	
8439		END;
8440		MOD_FLD(4,4);					!SET FOV FLAG
8441		MOD_FLD(3,4);					!CLEAR DPEA AC 12
8442		ER_TAB[0] = UPLIT (%ASCIZ'FOV FLAG IS HI');	!FOR ERROR PRINTOUT
8443		ER_TAB[1] = UPLIT (%ASCIZ'AC 12 IS LO');	!FOR ERROR PRINTOUT
8444		DO (0) WHILE
8445	BLOCK14:BEGIN
8446		SET_C(1);					!SET CRAM ADRS TO 1
8447		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8448		IF .RCVDATA NEQ 4				!CHECK DATA
8449			THEN BEGIN
8450				ERRCAS(1,1,4,.RCVDATA,4,ER_TAB);	!NO
8451				TEST_FLG = 1;
8452			     END;
8453		IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
8454			THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
8455		0						!TO ILLUMINATE BLISS INFO COMMENT
8456	
8457		END;
8458		MOD_FLD(3,%O'44');				!SET DPEA AC 12
8459		LC(3);						!LOAD CRAM ADRS 3
8460		MOD_FLD(3,0);					!CLEAR JFCL EN
8461		ER_TAB[1] = UPLIT (%ASCIZ'AC 12 IS HI');	!FOR ERROR PRINTOUT
8462		ER_TAB[2] = UPLIT (%ASCIZ'LO');			!FOR ERROR PRINTOUT
8463		DO (0) WHILE
8464	BLOCK15:BEGIN
8465		SET_C(1);					!SET CRAM ADRS TO 1
8466		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8467		IF .RCVDATA NEQ 4				!CHECK DATA
8468			THEN BEGIN
8469				ERRCAS(3,1,4,.RCVDATA,4,ER_TAB);	!NO
8470				TEST_FLG = 1;
8471			     END;
8472		IF LOOP_CHK(15)					!IS LOOP ON ERROR SET ?
8473			THEN LEAVE BLOCK15 WITH 1;		!LEAVE BLOCK TO LOOP
8474		0						!TO ILLUMINATE BLISS INFO COMMENT
8475	
8476		END;
8477		LC(3);						!LOAD CRAM ADRS 3
8478		MOD_FLD(3,%O'10');				!SET JFCL EN
8479		ER_TAB[2] = UPLIT (%ASCIZ'HI');			!FOR ERROR PRINTOUT
8480		DO (0) WHILE
8481	BLOCK16:BEGIN
8482		SET_C(1);					!SET CRAM ADRS TO 1
8483		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLK AND GET NXT CRAM ADRS
8484		IF .RCVDATA NEQ 5				!CHECK DATA
8485			THEN BEGIN
8486				ERRCAS(10,1,5,.RCVDATA,4,ER_TAB);	!NO
8487				TEST_FLG = 1;
8488			     END;
8489		IF LOOP_CHK(16)					!IS LOOP ON ERROR SET ?
8490			THEN LEAVE BLOCK16 WITH 1;		!LEAVE BLOCK TO LOOP
8491		0						!TO ILLUMINATE BLISS INFO COMMENT
8492	
8493		END;
8494		LC(3);						!LOAD CRAM ADRS 3
8495		MOD_FLD(1,%O'6747');				!CHANGE TO NO SKIP
8496		LC(1);						!LOAD CRAM ADRS 3
8497		MOD_FLD(4,%O'74');				!SET 4 FLAGS
8498		MOD_FLD(3,%O'744');				!SET ALL DPEA AC'S
8499		DO (0) WHILE
8500	BLOCK17:BEGIN
8501		DM(0,%O'-1');					!SET MEM TO -1
8502		CP(5);						!GIVE 5 CLOCKS
8503		RCVDATA = EM(0);				!GET DATA
8504		RCVDATA = .RCVDATA AND %O'740000000000';	!CLEAR UNWANTED BITS
8505		IF .RCVDATA NEQ 0				!CHECK DATA
8506			THEN ERMCA(2,0,.RCVDATA,12)	!NO
8507			ELSE IF .TEST_FLG EQL 0
8508				THEN NOERR(1);
8509	
8510		IF (.RCVDATA AND %O'400000000000') NEQ 0
8511			THEN FAILURE(11);
8512		IF (.RCVDATA AND %O'200000000000') NEQ 0
8513			THEN FAILURE(12);
8514		IF (.RCVDATA AND %O'100000000000') NEQ 0
8515			THEN FAILURE(13);
8516		IF (.RCVDATA AND %O'40000000000') NEQ 0
8517			THEN FAILURE(14);
8518		IF LOOP_CHK(17)					!IS LOOP ON ERROR SET ?
8519			THEN LEAVE BLOCK17 WITH 1;		!LEAVE BLOCK TO LOOP
8520		0						!TO ILLUMINATE BLISS INFO COMMENT
8521	
8522		END;
8523	!*MESSAGE 1
8524	!*	JFCL LOGIC TEST (P.C. FLAGS)
8525	!*STIMULUS:
8526	!*	DPE9 \S0
8527	!*	DPEA \S1
8528	!*	DPE9 JFCL EN IS \S2
8529	!*	ALL OTHER AC & FLAG INPUTS TO THE JFCL GATES ARE LO
8530	!*	SKIP IF JFCL (CURRENT J FIELD IS 4)
8531	!*RESPONSE:
8532	!*	EXAMINE NXT CRAM ADRS
8533	!]NO ERROR 1
8534	!]FCLK SPECIR SPECPC NTWK
8535	!]ERROR 1
8536	!]SKIP SPECPC F IR SPECIR FCLK NTWK
8537	!]ERROR 2
8538	!]SKIP SPECPC FCLK A B C D E F G H I NTWK
8539	!]ERROR 3
8540	!]SKIP G F NTWK
8541	!]ERROR 4
8542	!]SKIP SPECPC IR SPECIR FCLK F A B E H G I NTWK
8543	!]ERROR 5
8544	!]SKIP SPECPC FCLK F J K L G NTWK
8545	!]ERROR 6
8546	!]SKIP SPECPC FCLK IR SPECIR J K F L G NTWK
8547	!]ERROR 7
8548	!]SKIP SPECPC FCLK F J M L G NTWK
8549	!]ERROR 8
8550	!]SKIP FCLK K IR SPECIR SPECPC F L G J M NTWK
8551	!]ERROR 9
8552	!]SKIP SPECPC FCLK A B I G D N H F NTWK
8553	!]ERROR 10
8554	!]SKIP FCLK SPECPC IR SPECIR A I G B N F H NTWK
8555	!*MESSAGE 2
8556	!*STIMULUS:
8557	!*	JFCL LOGIC TEST (P.C. FLAGS)
8558	!*	DPE9 OV,CRY0,CRY1 & FOV FLAGS ARE HI
8559	!*	DPEA AC 9,10,11 & 12 ARE HI
8560	!*	DPE9 JFCL EN IS HI
8561	!*	LOOP FLAGS BACK INTO THE FLOPS (MIX SELECT = 0)
8562	!*	READ THE FLAGS INTO REGISTER 0 OF THE 2901'S
8563	!*	OUTPUT REGISTER 0 INTO PHYSICAL MEM 0
8564	!*RESPONSE:
8565	!*	EXAMINE DATA FROM MEM 0
8566	!]ERROR 11
8567	!]PCDBUS IR SPECIR SPECPC FCLK F A B C D E I G NTWK
8568	!]ERROR 12
8569	!]PCDBUS IR SPECIR SPECPC FCLK F J K G NTWK
8570	!]ERROR 13
8571	!]PCDBUS IR SPECIR SPECPC FCLK F J M G NTWK
8572	!]ERROR 14
8573	!]PCDBUS IR SPECIR SPECPC FCLK F A B G D N NTWK
8574		END;
8575	
8576	GLOBAL ROUTINE TST41: NOVALUE =
8577	
8578	!THIS TEST CHECKS THE DPE9 CARRY FLAG AND GATES .ALSO FPD & TRAP 2
8579	!FLAGS SET AND CLEAR CONTROLLED BY THE MAGIC # FIELD.
8580	!AT FIRST WE CALL A ROUTINE THAT WILL CHECK AND LOAD THE VMA WITH A 0.
8581	!THEN 4 INSTRUCTIONS ARE EXECUTED TO SET OR CLEAR THE RELATED FLAGS
8582	!(CRY0,CRY1,TRAP 2 & FPD).AFTER EACH EXECUTION FIELDS ARE MODIFIED 
8583	!TO SET A DIFFERENT SET OF DATA.
8584	!THE FLAGS ARE VERIFIED BY WRITING THEM INTO THE 2901'S REGISTER 0 VIA 
8585	!DBUS (DBUS SELECT = 0).THEN THE DATA IS PASSED OUT TO MEM READ AND VERIFIED.
8586	!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
8587	!CRAM 1/ LOAD ALL DPEA AC'S WITH ONES,AND PUT PART OF THE DATA IN 
8588	!	 REGISTER 0 (2901'S).
8589	!	 LOADING THE AC'S ON DPEA WITH ONES WILL ENABLE THE JFCL'S.THIS
8590	!	 WAY WE MAKE SURE THE FLAG INPUTS ARE NOT LOOPING FROM THE 
8591	!	 PREVIOUS FLAG OUTPUTS.
8592	!CRAM 2/ ADD THE SECOND DATA TO THE CONTENTS OF REGISTER 0(THIS WILL SET
8593	!	 OR CLEAR DPE2 CARRY OUT) .LOAD THE FLAGS.
8594	!CRAM 3/ START A MEM CYCLE AND PUT THE FLAGS IN THE 2901'S VIA DBUS
8595	!	 (DBUS SELECT = 0).
8596	!CRAM 4/ FINISH THE MEM CYCLE AND OUTPUT THE FLAGS PREVIOUSLY LOADED
8597	!	 IN THE 2901'S OUT TO MEMORY.
8598	!THE DATA IS THEN READ AND VERIFIED FROM MEMORY.
8599	
8600		BEGIN
8601		OWN TEST_FLG;
8602		LABEL BLOCK1,BLOCK2,BLOCK3;
8603		BIND
8604		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SPEC_LOADIR U_N(600740) U_NO_CLKR U,
8605				U_J(3) U_ALU_ADD U_LSRC_DA U_DBUS_DBM U_SPEC_FLAGS U_N(622011) U,
8606				U_J(4) U_MEM U_N(11012) U,
8607				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);
8608	
8609		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
8610		SET_C(1);					!SET CRAM ADRS TO 1
8611		TEST_FLG = 0;
8612		DO (0) WHILE
8613	BLOCK1:	BEGIN
8614		CP(4);						!GIVE 4 CLOCKS
8615		RCVDATA = EM(0);				!GET DATA FROM MEM
8616		RCVDATA = .RCVDATA AND %O'320400000000';	!CLEAN UNWANTED BITS
8617		IF .RCVDATA NEQ %O'320400000000'		!CHECK DATA
8618			THEN BEGIN
8619				ERMCA(1,%O'320400000000',.RCVDATA,12);!NO
8620				TEST_FLG = 1;
8621			     END;
8622	
8623		IF (.RCVDATA AND %O'200000000000') EQL 0
8624			THEN FAILURE(1);
8625		IF (.RCVDATA AND %O'100000000000') EQL 0
8626			THEN FAILURE(2);
8627		IF (.RCVDATA AND %O'20000000000') EQL 0
8628			THEN FAILURE(3);
8629		IF (.RCVDATA AND %O'400000000') EQL 0
8630			THEN FAILURE(4);
8631	
8632	!*MESSAGE 1
8633	!*STIMULUS:
8634	!*	P.C. FLAGS TEST
8635	!*	DBM 03 IS CLEAR
8636	!*	DBM 04 & 07 ARE SET
8637	!*	DPE2 CARRY OUT IS SET
8638	!*	DPE9 DP CRY1 IS SET 
8639	!*	DPE9 CARRY FLAGS IS SET
8640	!*	OUTPUT THE FLAGS INTO MEMORY VIA DBUS & DP
8641	!*RESPONSE:
8642	!*	EXAMINE DATA FROM PHYSICAL MEM 0
8643	!]ERROR 1
8644	!]PCDBUS FCLK SPECPC J K G NTWK
8645	!]ERROR 2
8646	!]PCDBUS FCLK SPECPC G J M NTWK
8647	!]ERROR 3
8648	!]PCDBUS FCLK SPECPC J P O NTWK
8649	!]ERROR 4
8650	!]PCDBUS SPECPC FCLK V Q NTWK
8651		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
8652			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
8653		0						!TO ILLUMINATE BLISS INFO COMMENT
8654	
8655		END;
8656		LC(2);						!LOAD CRAM ADRS 2
8657		MOD_FLD(3,%O'11');				!CLEAR DBM 02 & 07
8658		MOD_FLD(4,%O'66');				!SET DBM 3 & 4
8659		LC(1);						!LOAD CRAM ADRS 1
8660		MOD_FLD(4,0);					!CLEAR CARRY AND DP CRY1
8661		DO (0) WHILE
8662	BLOCK2:	BEGIN
8663		CP(4);						!GIVE 4 CLOCKS
8664		RCVDATA = EM(0);				!GET DATA FROM MEM
8665		RCVDATA = .RCVDATA AND %O'320400000000';	!CLEAN UNWANTED BITS
8666		IF .RCVDATA NEQ 0				!CHECK DATA
8667			THEN BEGIN
8668				ERMCA(2,0,.RCVDATA,12);		!NO
8669				TEST_FLG = 1;
8670			    END;
8671	
8672		IF (.RCVDATA AND %O'200000000000') NEQ 0
8673			THEN FAILURE(5);
8674		IF (.RCVDATA AND %O'100000000000') NEQ 0
8675			THEN FAILURE(6);
8676		IF (.RCVDATA AND %O'20000000000') NEQ 0
8677			THEN FAILURE(7);
8678		IF (.RCVDATA AND %O'400000000') NEQ 0
8679			THEN FAILURE(8);
8680	!*MESSAGE 2
8681	!*STIMULUS:
8682	!*	P.C. FLAGS TEST
8683	!*	DBM 03 & 04 ARE SET
8684	!*	DBM 07 IS CLEAR
8685	!*	DPE2 CARRY OUT IS CLEAR
8686	!*	DPE9 DP CRY1 IS CLEAR 
8687	!*	DPE9 CARRY FLAGS IS SET
8688	!*	OUTPUT THE FLAGS INTO MEMORY VIA DBUS & DP
8689	!*RESPONSE:
8690	!*	EXAMINE DATA FROM MEM 0
8691	!]ERROR 5
8692	!]PCDBUS FCLK SPECPC IR SPECIR G J K L NTWK
8693	!]ERROR 6
8694	!]PCDBUS SPECPC IR SPECIR G FCLK J M L NTWK
8695	!]ERROR 7
8696	!]PCDBUS FCLK SPECPC IR SPECIR O J NTWK
8697	!]ERROR 8
8698	!]PCDBUS FCLK SPECPC IR SPECIR Q V NTWK
8699		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
8700			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
8701		0						!TO ILLUMINATE BLISS INFO COMMENT
8702	
8703		END;
8704		LC(2);						!LOAD CRAM ADRS 2
8705		MOD_FLD(3,%O'10');				!CLEAR CARRY FLAGS
8706		MOD_FLD(4,%O'60');				!CLEAR DBM 3 & 4
8707		LC(1);						!LOAD CRAM ADRS 1
8708		MOD_FLD(4,%O'60');				!SET CARRY AND DP CRY1
8709		DO (0) WHILE
8710	BLOCK3:	BEGIN
8711		CP(4);						!GIVE 4 CLOCKS
8712		RCVDATA = EM(0);				!GET DATA FROM MEM
8713		RCVDATA = .RCVDATA AND %O'320400000000';	!CLEAN UNWANTED BITS
8714		IF .RCVDATA NEQ 0				!CHECK DATA
8715			THEN ERMCA(3,0,.RCVDATA,12)		!NO
8716			ELSE IF .TEST_FLG EQL 0
8717				THEN NOERR(1);
8718	
8719		IF (.RCVDATA AND %O'200000000000') NEQ 0
8720			THEN FAILURE(9);
8721		IF (.RCVDATA AND %O'100000000000') NEQ 0
8722			THEN FAILURE(10);
8723		IF (.RCVDATA AND %O'20000000000') NEQ 0
8724			THEN FAILURE(11);
8725		IF (.RCVDATA AND %O'400000000') NEQ 0
8726			THEN FAILURE(12);
8727	!*MESSAGE 3
8728	!*STIMULUS:
8729	!*	P.C. FLAGS TEST
8730	!*	DBM 03,04 & 07 ARE CLEAR
8731	!*	DPE2 CARRY OUT IS SET
8732	!*	DPE9 DP CRY1 IS SET 
8733	!*	DPE9 CARRY FLAGS IS CLEAR
8734	!*	OUTPUT THE FLAGS INTO MEMORY VIA DBUS & DP
8735	!*RESPONSE:
8736	!*	EXAMINE DATA FROM MEM 0
8737	!]NO ERROR 1
8738	!]FCLK SPECPC SPECIR NTWK
8739	!]ERROR 9
8740	!]PCDBUS FCLK SPECPC IR SPECIR G J K L NTWK
8741	!]ERROR 10
8742	!]PCDBUS SPECPC IR SPECIR FCLK G J M L NTWK
8743	!]ERROR 11
8744	!]PCDBUS FCLK SPECPC IR SPECIR G P J O L NTWK
8745	!]ERROR 12
8746	!]PCDBUS SPECPC IR SPECIR FCLK Q V NTWK
8747		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
8748			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
8749		0						!TO ILLUMINATE BLISS INFO COMMENT
8750	
8751		END;
8752		END;
8753	
8754	GLOBAL ROUTINE TST42: NOVALUE =
8755	
8756	!THIS TEST CHECKS LOADING SOME OF THE FLAGS ON DPE9 FROM THE MAGIC # FIELD.
8757	!THE FLAGS IN SUBJECT ARE OV, TRAP 1,FOV & NO DIV.
8758	!THIS TEST WILL EXECUTE 5 INSTRUCTIONS FOR EACH LOGICAL CONDITION THAT INVOLVE
8759	!THE AND GATES UNDER TEST. 3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0
8760	!AFTER EACH TEST FIELDS ARE MODIFIED TO SET UP DATA FOR THE NXT CONDITION
8761	!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
8762	!CRAM 1/ LOAD THE IR ONE'S . THIS WILL SET UP ALL THE AC'S ON DPEA TO 
8763	!	 BE HI. WITH JFCL EN THIS PROCESS WILL PREVENT THE FLAGS TO INPUT
8764	!	 FROM THE PREVIOUS FLAGS CONTENTS WHEN THE FLAGS ARE LOADED.
8765	!CRAM 2/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
8766	!CRAM 3/ LOAD THE FLAGS IN SUBJECT FROM # FIELD WITH JFCL ENABLED.
8767	!	 (OV, TRAP 1, FOV, NO DIV).
8768	!CRAM 4/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
8769	!CRAM 5/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
8770	!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
8771	!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
8772	!AND VERIFY THE DATA
8773	
8774		BEGIN
8775		OWN TEST_FLG;
8776		LABEL BLOCK1,BLOCK2,BLOCK3;
8777		BIND
8778		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777777) U,
8779				U_J(2) U_N(4) U_SPEC_FLAGS U,
8780				U_J(3) U_N(701010) U_SPEC_FLAGS U,
8781				U_J(4) U_MEM U_N(11012) U,
8782				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);
8783	
8784		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
8785		SET_C(0);					!SET CRAM ADRS TO 0
8786		TEST_FLG = 0;
8787		CP_NOSS(1);					!CLK 1'ST INSTRUCTION TO LOAD THE IR WITH ONES
8788		DO (0) WHILE
8789	BLOCK1:	BEGIN
8790		CP(4);						!GIVE 4 CLOCKS
8791		RCVDATA = EM(0);				!GET DATA FROM MEM
8792		RCVDATA = .RCVDATA AND %O'440240000000';	!CLEAN UNWANTED BITS
8793		IF .RCVDATA NEQ %O'440240000000'		!CHECK DATA
8794			THEN BEGIN
8795				ERMCA(1,%O'440240000000',.RCVDATA,12);!NO
8796				TEST_FLG = 1;
8797			     END;
8798	
8799		IF (.RCVDATA AND %O'400000000000') EQL 0
8800			THEN FAILURE(1);
8801		IF (.RCVDATA AND %O'40000000000') EQL 0
8802			THEN FAILURE(2);
8803		IF (.RCVDATA AND %O'200000000') EQL 0
8804			THEN FAILURE(3);
8805		IF (.RCVDATA AND %O'40000000') EQL 0
8806			THEN FAILURE(4);
8807	!*MESSAGE 1
8808	!*STIMULUS:
8809	!*	P.C. FLAGS TEST
8810	!*	LOAD OV,TRAP 1,FOV & NO DIV FLAGS FROM DBM
8811	!*	DBM BITS 00,01,02 & 08 ARE HI
8812	!*	DPE9 SPEC/PC FLAGS IS HI
8813	!*	WRITE P.C. FLAGS OUT TO MEM VIA DBUS & DP (DBUS SELECT = 0)
8814	!*RESPONSE:
8815	!*	EXAMINE DATA FROM MEM 0
8816	!]ERROR 1
8817	!]PCDBUS FCLK SPECPC A I G B E NTWK
8818	!]ERROR 2
8819	!]PCDBUS SPECPC FCLK A I G B N NTWK
8820	!]ERROR 3
8821	!]PCDBUS SPECPC FCLK A I G B U NTWK
8822	!]ERROR 4
8823	!]PCDBUS SPECPC FCLK Q X NTWK
8824		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
8825			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
8826		0						!TO ILLUMINATE BLISS INFO COMMENT
8827	
8828		END;
8829		LC(2);						!LOAD CRAM ADRS 2
8830		MOD_FLD(3,%O'10');				!CLEAR DBM BITS
8831		MOD_FLD(4,0);					!00,01 & 08
8832		SET_C(1);					!SET CRAM ADRS TO 1
8833		DO (0) WHILE
8834	BLOCK2:	BEGIN
8835		CP(4);						!GIVE 4 CLOCKS
8836		RCVDATA = EM(0);				!GET DATA FROM MEM
8837		RCVDATA = .RCVDATA AND %O'440240000000';	!CLEAN UNWANTED BITS
8838		IF .RCVDATA NEQ 0				!CHECK DATA
8839			THEN BEGIN
8840				ERMCA(2,0,.RCVDATA,12);		!NO
8841				TEST_FLG = 1;
8842			     END;
8843	
8844		IF (.RCVDATA AND %O'400000000000') NEQ 0
8845			THEN FAILURE(5);
8846		IF (.RCVDATA AND %O'40000000000') NEQ 0
8847			THEN FAILURE(6);
8848		IF (.RCVDATA AND %O'200000000') NEQ 0
8849			THEN FAILURE(7);
8850		IF (.RCVDATA AND %O'40000000') NEQ 0
8851			THEN FAILURE(8);
8852	!*MESSAGE 2
8853	!*STIMULUS:
8854	!*	P.C. FLAGS TEST
8855	!*	LOAD OV,TRAP 1,FOV & NO DIV FLAGS FROM DBM
8856	!*	DBM BITS 00,01,02 & 08 ARE LO
8857	!*	DPE9 SPEC/PC FLAGS IS HI
8858	!*	WRITE P.C. FLAGS OUT TO MEM VIA DBUS & DP (DBUS SELECT = 0)
8859	!*RESPONSE:
8860	!*	EXAMINE DATA FROM MEM 0
8861	!]ERROR 5
8862	!]PCDBUS FCLK SPECPC IR SPECIR I A B C D E G NTWK
8863	!]ERROR 6
8864	!]PCDBUS FCLK SPECPC IR SPECIR A B D N I G NTWK
8865	!]ERROR 7
8866	!]PCDBUS FCLK SPECPC I G A B C D U NTWK
8867	!]ERROR 8
8868	!]PCDBUS FCLK SPECPC Q X H G NTWK
8869		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
8870			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
8871		0						!TO ILLUMINATE BLISS INFO COMMENT
8872	
8873		END;
8874		LC(2);						!LOAD CRAM ADRS 2
8875		MOD_FLD(3,%O'1010');				!SET DBM BITS
8876		MOD_FLD(4,%O'60');				!00,01 & 08
8877		MOD_FLD(1,%O'6747');				!CLEAR SEPC/PC FLAGS
8878		MOD_FLD(2,%O'40');
8879		SET_C(1);					!SET CRAM ADRS TO 1
8880		DO (0) WHILE
8881	BLOCK3:	BEGIN
8882		CP(4);						!GIVE 4 CLOCKS
8883		RCVDATA = EM(0);				!GET DATA FROM MEM
8884		RCVDATA = .RCVDATA AND %O'440200000000';	!CLEAN UNWANTED BITS
8885		IF .RCVDATA NEQ 0				!CHECK DATA
8886			THEN ERMCA(3,0,.RCVDATA,12)		!NO
8887			ELSE IF .TEST_FLG EQL 0
8888				THEN NOERR(1);
8889	
8890		IF (.RCVDATA AND %O'400000000000') NEQ 0
8891			THEN FAILURE(9);
8892		IF (.RCVDATA AND %O'40000000000') NEQ 0
8893			THEN FAILURE(10);
8894		IF (.RCVDATA AND %O'200000000') NEQ 0
8895			THEN FAILURE(11);
8896	!*MESSAGE 3
8897	!*STIMULUS:
8898	!*	P.C. FLAGS TEST
8899	!*	LOAD OV,TRAP 1 & FOV FLAGS FROM DBM
8900	!*	DBM BITS 00,01 & 08 ARE HI
8901	!*	DPE9 SPEC/PC FLAGS IS LO
8902	!*	WRITE P.C. FLAGS OUT TO MEM VIA DBUS & DP (DBUS SELECT = 0)
8903	!*RESPONSE:
8904	!*	EXAMINE DATA FROM MEM 0
8905	!]NO ERROR 1
8906	!]FCLK SPECPC SPECIR NTWK
8907	!]ERROR 9
8908	!]PCDBUS FCLK SPECPC IR SPECIR A B C D E I G NTWK
8909	!]ERROR 10
8910	!]PCDBUS FCLK SPECPC SPECIR IR A B D N I G NTWK
8911	!]ERROR 11
8912	!]PCDBUS FCLK SPECPC I G A B C D U NTWK
8913		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
8914			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
8915		0						!TO ILLUMINATE BLISS INFO COMMENT
8916	
8917		END;
8918		END;
8919	
8920	GLOBAL ROUTINE TST43: NOVALUE =
8921	
8922	!THIS TEST CHECKS LOADING OV,TRAP 1 & FXU FLAGS FROM THE OUTPUT OF SCAD 00 & 01
8923	!SELECTING SPEC / EXP TEST.
8924	!THIS TEST WILL EXECUTE 4 INSTRUCTIONS FOR EACH LOGICAL CONDITION THAT INVOLVE
8925	!THE GATES UNDER TEST. 3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0
8926	!AFTER EACH TEST FIELDS ARE MODIFIED TO SET UP DATA FOR THE NXT CONDITION
8927	!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
8928	!CRAM 1/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
8929	!CRAM 2/ LOAD THE FLAGS UNDER TEST FROM OUTPUT OF THE SCAD. DO A SPEC / EXP TEST
8930	!	 AND OUTPUT REQUIRED DATA FORM THE SCAD CONTROLLED BY THE MAGIC # FIELD.
8931	!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
8932	!CRAM 4/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
8933	!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
8934	!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
8935	!AND VERIFY THE DATA
8936	
8937		BEGIN
8938		OWN TEST_FLG;
8939		LABEL BLOCK1,BLOCK2,BLOCK3;
8940		BIND
8941		POINTER = PLIT (U_J(2) U_SPEC_FLAGS U_N(4) U,
8942				U_J(3) U_SPEC_EXPTST U_N(710000) U,
8943				U_J(4) U_MEM U_N(11012) U,
8944				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);
8945	
8946		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
8947		SET_C(1);					!SET CRAM ADRS TO 1
8948		TEST_FLG = 0;
8949		DO (0) WHILE
8950	BLOCK1:	BEGIN
8951		CP(4);						!GIVE 4 CLOCKS
8952		RCVDATA = EM(0);				!GET DATA FROM MEM
8953		RCVDATA = .RCVDATA AND %O'440300000000';	!CLEAN UNWANTED BITS
8954		IF .RCVDATA NEQ 0				!CHECK DATA
8955			THEN BEGIN
8956				ERMCA(1,0,.RCVDATA,12);		!NO
8957				TEST_FLG = 1;
8958			     END;
8959	
8960		IF(.RCVDATA AND %O'400000000000') NEQ 0
8961			THEN FAILURE(1);
8962		IF(.RCVDATA AND %O'40000000000') NEQ 0
8963			THEN FAILURE(2);
8964		IF(.RCVDATA AND %O'200000000') NEQ 0
8965			THEN FAILURE(3);
8966		IF(.RCVDATA AND %O'100000000') NEQ 0
8967			THEN FAILURE(4);
8968	!*MESSAGE 1
8969	!*STIMULUS:
8970	!*	P.C. FLAGS TEST
8971	!*	LOADS FLAGS FROM OUTPUT OF SCAD (00,01)
8972	!*	SCAD(00,01) BITS ARE LO
8973	!*	DPE9 SPEC/EXP TEST IS HI
8974	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
8975	!*RESPONSE:
8976	!*	EXAMINE DATA FROM MEM 0
8977	!]ERROR 1
8978	!]PCDBUS SPECPC SPECEXP FCLK A I Z B C D E H G NTWK
8979	!]ERROR 2
8980	!]PCDBUS FCLK SPECPC SPECEXP A I Z B D N H G NTWK
8981	!]ERROR 3
8982	!]PCDBUS FCLK SPECPC SPECEXP A I Z G B C D U NTWK
8983	!]ERROR 4
8984	!]PCDBUS FCLK SPECPC SPECEXP A I Z G W H NTWK
8985		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
8986			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
8987		0						!TO ILLUMINATE BLISS INFO COMMENT
8988	
8989		END;
8990		LC(2);						!LOAD CRAM ADRS 2
8991		MOD_FLD(3,%O'1400');				!SET SACD 00
8992		SET_C(1);					!SET CRAM ADRS TO 1
8993		DO (0) WHILE
8994	BLOCK2:	BEGIN
8995		CP(4);						!GIVE 4 CLOCKS
8996		RCVDATA = EM(0);				!GET DATA FROM MEM
8997		RCVDATA = .RCVDATA AND %O'440300000000';	!CLEAN UNWANTED BITS
8998		IF .RCVDATA NEQ %O'440300000000'		!CHECK DATA
8999			THEN BEGIN
9000				ERMCA(2,%O'440300000000',.RCVDATA,12);!NO
9001				TEST_FLG = 1;
9002			    END;
9003	
9004		IF(.RCVDATA AND %O'440200000000') EQL 0
9005			THEN FAILURE(5);
9006		IF(.RCVDATA AND %O'100000000') EQL 0
9007			THEN FAILURE(6);
9008	!*MESSAGE 2
9009	!*STIMULUS:
9010	!*	P.C. FLAGS TEST
9011	!*	LOADS FLAGS FROM OUTPUT OF SCAD (00,01)
9012	!*	SCAD 00 & 01 BITS ARE HI
9013	!*	DPE9 SPEC/EXP TEST IS HI
9014	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9015	!*RESPONSE:
9016	!*	EXAMINE DATA FROM MEM 0
9017	!]ERROR 5
9018	!]PCDBUS FCLK SPECPC SPECEXP A I Z B D NTWK
9019	!]ERROR 6
9020	!]PCDBUS FCLK SPECPC SPECEXP A I Z B W NTWK
9021		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
9022			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
9023		0						!TO ILLUMINATE BLISS INFO COMMENT
9024	
9025		END;
9026		LC(2);						!LOAD CRAM ADRS 2
9027		MOD_FLD(3,%O'1400');				!SET SCAD 00 & 01
9028		MOD_FLD(1,%O'6747');				!CLEAR DPE9 SPEC/EXP TEST
9029		MOD_FLD(2,%O'40');
9030		SET_C(1);					!SET CRAM ADRS TO 1
9031		DO (0) WHILE
9032	BLOCK3:	BEGIN
9033		CP(4);						!GIVE 4 CLOCKS
9034		RCVDATA = EM(0);				!GET DATA FROM MEM
9035		RCVDATA = .RCVDATA AND %O'440300000000';	!CLEAN UNWANTED BITS
9036		IF .RCVDATA NEQ 0				!CHECK DATA
9037			THEN ERMCA(3,0,.RCVDATA,12)		!NO
9038			ELSE IF .TEST_FLG EQL 0
9039				THEN NOERR(1);
9040		IF(.RCVDATA AND %O'400000000000') NEQ 0
9041			THEN FAILURE(7);
9042		IF(.RCVDATA AND %O'40000000000') NEQ 0
9043			THEN FAILURE(8);
9044		IF(.RCVDATA AND %O'200000000') NEQ 0
9045			THEN FAILURE(9);
9046		IF(.RCVDATA AND %O'100000000') NEQ 0
9047			THEN FAILURE(10);
9048	!*MESSAGE 3
9049	!*STIMULUS:
9050	!*	P.C. FLAGS TEST
9051	!*	LOADS FLAGS FROM OUTPUT OF SCAD (00,01)
9052	!*	SCAD(00,01) BITS ARE HI
9053	!*	DPE9 SPEC/EXP TEST IS LO
9054	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9055	!*RESPONSE:
9056	!*	EXAMINE DATA FROM MEM 0
9057	!]NO ERROR 1
9058	!]FCLK SPECPC SPECEXP NTWK
9059	!]ERROR 7
9060	!]PCDBUS SPECPC SPECEXP FCLK A I Z G B C D E H NTWK
9061	!]ERROR 8
9062	!]PCDBUS FCLK SPECPC SPECEXP A B D N H G I Z NTWK
9063	!]ERROR 9
9064	!]PCDBUS FCLK SPECPC SPECEXP I Z G A B C D U NTWK
9065	!]ERROR 10
9066	!]PCDBUS FCLK SPECPC SPECEXP A I Z G W H NTWK
9067		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
9068			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
9069		0						!TO ILLUMINATE BLISS INFO COMMENT
9070	
9071		END;
9072		END;
9073	
9074	GLOBAL ROUTINE TST44: NOVALUE =
9075	
9076	!THIS TEST CHECKS LOADING OV & TRAP 1 FLAGS FROM THE OUTPUT OF 2901'S DP 00 & 01
9077	!AND DP OVERFLOW SELECTING SPEC / ASH TEST.
9078	!THIS TEST WILL EXECUTE 5 INSTRUCTIONS FOR EACH LOGICAL CONDITION THAT INVOLVE
9079	!THE GATES UNDER TEST. 3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0
9080	!FOR THE AND GATES AND 00,01,10 FOR THE OR GATES.
9081	!AFTER EACH TEST FIELDS ARE MODIFIED TO SET UP DATA FOR THE NXT CONDITION
9082	!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
9083	!CRAM 1/ PUT THE REQUIRED DATA FOR THE DP IN THE 2901'S VIA DBUS,DMB & MAGIC # FIELD.
9084	!CRAM 2/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
9085	!CRAM 3/ LOAD THE FLAGS UNDER TEST FROM OUTPUT OF THE 2901'S. DO A SPEC / ASH TEST
9086	!AND THE OUTPUT THE DATA PREVIOUSLY LOADED IN THE 2901'S ONTO DP.
9087	!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
9088	!CRAM 4/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
9089	!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
9090	!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
9091	!AND VERIFY THE DATA
9092	
9093		BEGIN
9094		OWN TEST_FLG;
9095		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
9096		      BLOCK5,BLOCK6,BLOCK7,BLOCK8;
9097		BIND
9098		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DEST_AD_MUL2 U_DBUS_DBM U,
9099				U_J(3) U_SPEC_FLAGS U_N(4) U,
9100				U_J(4) U_ALU_OR U_SPEC_ASHOV U,
9101				U_J(5) U_MEM U_N(11012) U,
9102				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U);
9103	
9104		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
9105		TEST_FLG = 0;
9106		SET_C(1);					!SET CRAM ADRS TO 1
9107		DO (0) WHILE
9108	BLOCK1:	BEGIN
9109		CP(5);						!GIVE 5 CLOCKS
9110		RCVDATA = EM(0);				!GET DATA FROM MEM
9111		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9112		IF .RCVDATA NEQ 0				!CHECK DATA
9113			THEN BEGIN
9114				ERMCA(1,0,.RCVDATA,12);		!NO
9115				TEST_FLG = 1;
9116			     END;
9117		IF (.RCVDATA AND %O'400000000000') NEQ 0
9118			THEN FAILURE(1);
9119		IF (.RCVDATA AND %O'200000000') NEQ 0
9120			THEN FAILURE(2);
9121	!*MESSAGE 1
9122	!*STIMULUS:
9123	!*	P.C. FLAGS TEST
9124	!*	LOAD OV & TRAP 1 FROM DP ASH TEST
9125	!*	DP (01,02) BITS ARE LO
9126	!*	DPE9 SPEC/ASH TEST IS HI
9127	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9128	!*RESPONSE:
9129	!*	EXAMINE DATA FROM MEM 0
9130	!]ERROR 1
9131	!]PCDBUS FCLK SPECPC SPECASH Y G I Z A B C D E H NTWK
9132	!]ERROR 2
9133	!]PCDBUS FCLK SPECPC SPECASH I Z Y A B C D U G NTWK
9134		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
9135			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
9136		0						!TO ILLUMINATE BLISS INFO COMMENT
9137	
9138		END;
9139		MOD_FLD(4,%O'14');				!SET DP 01 & 02
9140		DO (0) WHILE
9141	BLOCK2:	BEGIN
9142		CP(5);						!GIVE 5 CLOCKS
9143		RCVDATA = EM(0);				!GET DATA FROM MEM
9144		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9145		IF .RCVDATA NEQ 0				!CHECK DATA
9146			THEN BEGIN
9147				ERMCA(2,0,.RCVDATA,12);		!NO
9148				TEST_FLG = 1;
9149			     END;
9150		IF (.RCVDATA AND %O'400000000000') NEQ 0
9151			THEN FAILURE(3);
9152		IF (.RCVDATA AND %O'200000000') NEQ 0
9153			THEN FAILURE(4);
9154	!*MESSAGE 2
9155	!*STIMULUS:
9156	!*	P.C. FLAGS TEST
9157	!*	LOAD OV & TRAP 1 FROM DP ASH TEST
9158	!*	DP (01,02) BITS ARE HI
9159	!*	DPE9 SPEC/ASH TEST IS HI
9160	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9161	!*RESPONSE:
9162	!*	EXAMINE DATA FROM MEM 0
9163	!]ERROR 3
9164	!]PCDBUS FCLK SPECPC SPECASH A B C D E I Z G Y H NTWK
9165	!]ERROR 4
9166	!]PCDBUS FCLK SPECPC SPECASH I Z Y G A B C D U NTWK
9167		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
9168			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
9169		0						!TO ILLUMINATE BLISS INFO COMMENT
9170	
9171		END;
9172		MOD_FLD(4,%O'10');				!SET DP 01
9173		DO (0) WHILE
9174	BLOCK3:	BEGIN
9175		CP(5);						!GIVE 5 CLOCKS
9176		RCVDATA = EM(0);				!GET DATA FROM MEM
9177		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9178		IF .RCVDATA NEQ %O'400200000000'		!CHECK DATA
9179			THEN BEGIN
9180				ERRCAS(5,3,%O'400200000000',.RCVDATA,12,0);!NO
9181				TEST_FLG = 1;
9182			     END;
9183	!*MESSAGE 3
9184	!*STIMULUS:
9185	!*	P.C. FLAGS TEST
9186	!*	LOAD OV & TRAP 1 FROM DP ASH TEST
9187	!*	DP 01 IS HI
9188	!*	DP 02 IS LO
9189	!*	DPE9 SPEC/ASH TEST IS HI
9190	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9191	!*RESPONSE:
9192	!*	EXAMINE DATA FROM MEM 0
9193	!]ERROR 5
9194	!]PCDBUS FCLK SPECPC SPECASH I Z A B C Y NTWK
9195		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
9196			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
9197		0						!TO ILLUMINATE BLISS INFO COMMENT
9198	
9199		END;
9200		MOD_FLD(4,4);					!SET DP 02
9201		DO (0) WHILE
9202	BLOCK4:	BEGIN
9203		CP(5);						!GIVE 5 CLOCKS
9204		RCVDATA = EM(0);				!GET DATA FROM MEM
9205		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9206		IF .RCVDATA NEQ %O'400200000000'		!CHECK DATA
9207			THEN BEGIN
9208				ERRCAS(6,4,%O'400200000000',.RCVDATA,12,0);!NO
9209				TEST_FLG = 1;
9210			     END;
9211	!*MESSAGE 4
9212	!*STIMULUS:
9213	!*	P.C. FLAGS TEST
9214	!*	LOAD OV & TRAP 1 FROM DP ASH TEST
9215	!*	DP 01 IS LO
9216	!*	DP 02 IS HI
9217	!*	DPE9 SPEC/ASH TEST IS HI
9218	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9219	!*RESPONSE:
9220	!*	EXAMINE DATA FROM MEM 0
9221	!]ERROR 6
9222	!]PCDBUS FCLK SPECPC SPECASH I Z A B C Y NTWK
9223		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
9224			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
9225		0						!TO ILLUMINATE BLISS INFO COMMENT
9226	
9227		END;
9228		LC(3);						!LOAD CRAM ADRS 3
9229		MOD_FLD(1,%O'6747');				!CLEAR SPEC/ASH TEST
9230		MOD_FLD(2,%O'60');
9231		LC(1);						!LOAD CRAM ADRS 1
9232		MOD_FLD(4,%O'14');				!SET DP 01 & 02
9233		DO (0) WHILE
9234	BLOCK5:	BEGIN
9235		CP(5);						!GIVE 5 CLOCKS
9236		RCVDATA = EM(0);				!GET DATA FROM MEM
9237		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9238		IF .RCVDATA NEQ 0				!CHECK DATA
9239			THEN BEGIN
9240				ERMCA(5,0,.RCVDATA,12);		!NO
9241				TEST_FLG = 1;
9242			     END;
9243		IF (.RCVDATA AND %O'400000000000') NEQ 0
9244			THEN FAILURE(7);
9245		IF (.RCVDATA AND %O'200000000') NEQ 0
9246			THEN FAILURE(8);
9247	!*MESSAGE 5
9248	!*STIMULUS:
9249	!*	P.C. FLAGS TEST
9250	!*	LOAD OV & TRAP 1 FROM DP ASH TEST
9251	!*	DP 01 & 02 ARE HI
9252	!*	DPE9 SPEC/ASH TEST IS LO
9253	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9254	!*RESPONSE:
9255	!*	EXAMINE DATA FROM MEM 0
9256	!]ERROR 7
9257	!]PCDBUS FCLK SPECPC SPECASH I G Z A B C D E H NTWK
9258	!]ERROR 8
9259	!]PCDBUS FCLK SPECPC SPECASH G A B I Z C D U NTWK
9260		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
9261			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
9262		0						!TO ILLUMINATE BLISS INFO COMMENT
9263	
9264		END;
9265		MOD_FLD(4,%O'20');				!SET DP 00
9266		DO (0) WHILE
9267	BLOCK6:	BEGIN
9268		CP(5);						!GIVE 5 CLOCKS
9269		RCVDATA = EM(0);				!GET DATA FROM MEM
9270		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9271		IF .RCVDATA NEQ 0				!CHECK DATA
9272			THEN BEGIN
9273				ERMCA(6,0,.RCVDATA,12);		!NO
9274				TEST_FLG = 1;
9275			     END;
9276		IF (.RCVDATA AND %O'400000000000') NEQ 0
9277			THEN FAILURE(9);
9278		IF (.RCVDATA AND %O'200000000') NEQ 0
9279			THEN FAILURE(10);
9280	!*MESSAGE 6
9281	!*STIMULUS:
9282	!*	P.C. FLAGS TEST
9283	!*	LOAD OV & TRAP 1 FROM DP OVERFLOW
9284	!*	DPE9 DP OVERFLOW IS HI
9285	!*	DPE9 CARRY FLAGS IS LO
9286	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9287	!*RESPONSE:
9288	!*	EXAMINE DATA FROM MEM 0
9289	!]ERROR 9
9290	!]PCDBUS FCLK SPECPC SPECASH G A B C I Z D E H NTWK
9291	!]ERROR 10
9292	!]PCDBUS FCLK SPECPC SPECASH G A B C D U I Z NTWK
9293		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
9294			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
9295		0						!TO ILLUMINATE BLISS INFO COMMENT
9296	
9297		END;
9298		LC(3);						!LOAD CRAM ADRS 3
9299		MOD_FLD(3,1);					!SET DPE9 CARRY FLAGS
9300		SET_C(1);					!SET CRAM ADTS TO 1
9301		DO (0) WHILE
9302	BLOCK7:	BEGIN
9303		CP(5);						!GIVE 5 CLOCKS
9304		RCVDATA = EM(0);				!GET DATA FROM MEM
9305		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9306		IF .RCVDATA NEQ %O'400200000000'		!CHECK DATA
9307			THEN BEGIN
9308				ERRCAS(11,7,%O'400200000000',.RCVDATA,12,0);!NO
9309				TEST_FLG = 1;
9310			     END;
9311	!*MESSAGE 7
9312	!*STIMULUS:
9313	!*	P.C. FLAGS TEST
9314	!*	LOAD OV & TRAP 1 FROM DP OVERFLOW
9315	!*	DPE9 DP OVERFLOW IS HI
9316	!*	DPE9 CARRY FLAGS IS HI
9317	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9318	!*RESPONSE:
9319	!*	EXAMINE DATA FROM MEM 0
9320	!]ERROR 11
9321	!]PCDBUS FCLK SPECPC SPECASH Y I G Z A B C NTWK
9322		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
9323			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
9324		0						!TO ILLUMINATE BLISS INFO COMMENT
9325	
9326		END;
9327		MOD_FLD(4,0);					!CLEAR DP OVERFLOW
9328		DO (0) WHILE
9329	BLOCK8:	BEGIN
9330		CP(5);						!GIVE 5 CLOCKS
9331		RCVDATA = EM(0);				!GET DATA FROM MEM
9332		RCVDATA = .RCVDATA AND %O'400200000000';	!CLEAN UNWANTED BITS
9333		IF .RCVDATA NEQ 0				!CHECK DATA
9334			THEN ERMCA(8,0,.RCVDATA,12)		!NO
9335			ELSE IF .TEST_FLG EQL 0
9336				THEN NOERR(1);
9337		IF (.RCVDATA AND %O'400000000000') NEQ 0
9338			THEN FAILURE(12);
9339		IF (.RCVDATA AND %O'200000000') NEQ 0
9340			THEN FAILURE(13);
9341	!*MESSAGE 8
9342	!*STIMULUS:
9343	!*	P.C. FLAGS TEST
9344	!*	LOAD OV & TRAP 1 FROM DP OVERFLOW
9345	!*	DPE9 DP OVERFLOW IS LO
9346	!*	DPE9 CARRY FLAGS IS HI
9347	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9348	!*RESPONSE:
9349	!*	EXAMINE DATA FROM MEM 0
9350	!]NO ERROR 1
9351	!]FCLK SPECPC SPECASH NTWK
9352	!]ERROR 12
9353	!]PCDBUS FCLK SPECPC SPECASH Y G I Z A B C D E H NTWK
9354	!]ERROR 13
9355	!]PCDBUS FCLK SPECPC SPECASH A B I Z C D Y U NTWK
9356		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
9357			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
9358		0						!TO ILLUMINATE BLISS INFO COMMENT
9359	
9360		END;
9361		END;
9362	
9363	GLOBAL ROUTINE TST45: NOVALUE =
9364	
9365	!THIS TEST CHECKS MOST OF THE LOGIC GATES INPUT TO USER I/O FLAG.
9366	!THIS TEST WILL EXECUTE 4 INSTRUCTIONS FOR SOME PARTS AND 5 FOR OTHERS 
9367	!FOR EACH LOGICAL CONDITION THAT INVOLVE THE GATES UNDER TEST.
9368	!3 LOGIC CONDITIONS ARE TESTED 1 & 1, 0 & 1,1 & 0 FOR THE AND GATES 
9369	!AND 00,01,10 FOR THE OR GATES AFTER EACH TEST FIELDS ARE MODIFIED 
9370	!TO SET UP DATA FOR THE NXT CONDITION
9371	!CRAM 1/ LOAD THE FLAGS FROM DATA DP WITH DP = 0 (CLEAR ALL FLAGS).
9372	!CRAM 2/ LOAD THE FLAGS IN SUBJECT FROM # FIELD OR DP WITH THE REQUIRED 
9373	!	 DATA SET UP IN BOTH FIELDS
9374	!CRAM 3/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0
9375	!CRAM 4/ FINISH THE MEM CYCLE AND OUPUT THE CONTENTS OF THE DBUS INTO 
9376	!	 MEMPRY VIA DP. DBUS SELECT = 0 (PC FLAGS 00 - 17).
9377	!CRAM 5/ LOAD THE FLAGS AGIAN.
9378	!	 (THIS INSTRUCTION IN IS INCLUDED IN THE SECOND PART OF THIS TEST
9379	!	 AFTER VERIFYING THAT I/O FLAG WAS LOADED. THIS INSTRUCTION WILL VERIFY
9380	!	 THAT I/O FLAG CAN BE LOADED FORM ITS PREVIOUS CONTENTS CONDITIONALLY).
9381	!AFTER THE EXECUTION OF THOSE INSTRUCTIONS WE EXAMINE PHYSICAL MEM 0 
9382	!AND VERIFY THE DATA
9383	!(NOTE:	CAN'T TEST PIN 5 ON E106 FOR STUCK HI)
9384	
9385		BEGIN
9386		OWN TEST_FLG;
9387		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,
9388		      BLOCK6,BLOCK7,BLOCK8,BLOCK9,BLOCK10,
9389		      BLOCK11,BLOCK12,BLOCK13,BLOCK14;
9390		BIND
9391		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4) U,
9392				U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4004) U,
9393				U_J(4) U_MEM U_N(11012) U,
9394				U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_PC_FLAGS U_MEM U_N(2) U,
9395				U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4) U);
9396	
9397		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
9398		SET_C(1);					!SET CRAM ADRS TO 1
9399		TEST_FLG = 0;
9400		DO (0) WHILE
9401	BLOCK1:	BEGIN
9402		CP(4);						!GIVE 4 CLOCKS
9403		RCVDATA = EM(0);				!GET DATA FROM MEM
9404		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9405		IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
9406			THEN BEGIN
9407				ERRCA(1,%O'4000000000',.RCVDATA,12);!NO
9408				TEST_FLG = 1;
9409			     END;
9410	!*MESSAGE 1
9411	!*STIMULUS:
9412	!*	P.C. FLAGS TEST (USER I/O FLAG)
9413	!*	-DPE9 USER FLAG H IS SET
9414	!*	DPE1 DP 06 IS SET
9415	!*	DPE9 LOAD FLAGS H IS SET
9416	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9417	!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
9418	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9419	!*RESPONSE:
9420	!*	EXAMINE DATA FROM MEM 0
9421	!]ERROR 1
9422	!]PCDBUS FCLK SPECPC Q R G S NTWK
9423		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
9424			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
9425		0						!TO ILLUMINATE BLISS INFO COMMENT
9426	
9427		END;
9428		LC(2);						!LOAD CRAM ADRS 2
9429		MOD_FLD(3,%O'4000');				!CLEAR DPE9 LOAD FLAGS H
9430		SET_C(1);					!SET CRAM ADRS TO 1
9431		DO (0) WHILE
9432	BLOCK2:	BEGIN
9433		CP(4);						!GIVE 4 CLOCKS
9434		RCVDATA = EM(0);				!GET DATA FROM MEM
9435		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9436		IF .RCVDATA NEQ 0				!CHECK DATA
9437			THEN BEGIN
9438				ERRCA(2,0,.RCVDATA,12);		!NO
9439				TEST_FLG = 1;
9440			     END;
9441	!*MESSAGE 2
9442	!*STIMULUS:
9443	!*	P.C. FLAGS TEST (USER I/O FLAG)
9444	!*	-DPE9 USER FLAG H IS SET
9445	!*	DPE1 DP 06 IS SET
9446	!*	DPE9 LOAD FLAGS H IS CLEAR
9447	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9448	!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
9449	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9450	!*RESPONSE:
9451	!*	EXAMINE DATA FROM MEM 0
9452	!]ERROR 2
9453	!]PCDBUS FCLK SPECPC Q R G S NTWK
9454		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
9455			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
9456		0						!TO ILLUMINATE BLISS INFO COMMENT
9457	
9458		END;
9459		LC(2);						!LOAD CRAM ADRS 2
9460		MOD_FLD(3,4);					!CLEAR DPE1 DP 06
9461		SET_C(1);					!SET CRAM ADRS TO 1
9462		DO (0) WHILE
9463	BLOCK3:	BEGIN
9464		CP(4);						!GIVE 4 CLOCKS
9465		RCVDATA = EM(0);				!GET DATA FROM MEM
9466		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9467		IF .RCVDATA NEQ 0				!CHECK DATA
9468			THEN BEGIN
9469				ERRCA(3,0,.RCVDATA,12);		!NO
9470				TEST_FLG = 1;
9471			     END;
9472	!*MESSAGE 3
9473	!*STIMULUS:
9474	!*	P.C. FLAGS TEST (USER I/O FLAG)
9475	!*	-DPE9 USER FLAG H IS SET
9476	!*	DPE1 DP 06 IS CLEAR
9477	!*	DPE9 LOAD FLAGS H IS SET
9478	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9479	!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
9480	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9481	!*RESPONSE:
9482	!*	EXAMINE DATA FROM MEM 0
9483	!]ERROR 3
9484	!]PCDBUS FCLK SPECPC Q G S NTWK
9485		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
9486			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
9487		0						!TO ILLUMINATE BLISS INFO COMMENT
9488	
9489		END;
9490		LC(2);						!LOAD CRAM ADRS 2
9491		MOD_FLD(3,%O'4004');				!SET BOTH DP 06 & LOAD FLAGS
9492		LC(1);						!LOAD CRAM ADRS 1
9493		MOD_FLD(4,1);					!SET USER FLAG
9494		DO (0) WHILE
9495	BLOCK4:	BEGIN
9496		CP(4);						!GIVE 4 CLOCKS
9497		RCVDATA = EM(0);				!GET DATA FROM MEM
9498		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9499		IF .RCVDATA NEQ 0				!CHECK DATA
9500			THEN BEGIN
9501				ERRCA(4,0,.RCVDATA,12);		!NO
9502				TEST_FLG = 1;
9503			     END;
9504	!*MESSAGE 4
9505	!*STIMULUS:
9506	!*	P.C. FLAGS TEST (USER I/O FLAG)
9507	!*	-DPE9 USER FLAG H IS CLEAR
9508	!*	DPE1 DP 06 IS SET
9509	!*	DPE9 LOAD FLAGS H IS SET
9510	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9511	!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
9512	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9513	!*RESPONSE:
9514	!*	EXAMINE DATA FROM MEM 0
9515	!]ERROR 4
9516	!]PCDBUS FCLK SPECPC R Q G S NTWK
9517		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
9518			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
9519		0						!TO ILLUMINATE BLISS INFO COMMENT
9520	
9521		END;
9522		LC(2);						!LOAD CRAM ADRS 2
9523		MOD_FLD(3,%O'400');				!SET DBM 09
9524		SET_C(1);					!SET CRAM ADRS TO 1
9525		DO (0) WHILE
9526	BLOCK5:	BEGIN
9527		CP(4);						!GIVE 4 CLOCKS
9528		RCVDATA = EM(0);				!GET DATA FROM MEM
9529		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9530		IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
9531			THEN BEGIN
9532				ERRCA(5,%O'4000000000',.RCVDATA,12);!NO
9533				TEST_FLG = 1;
9534			     END;
9535	!*MESSAGE 5
9536	!*STIMULUS:
9537	!*	P.C. FLAGS TEST (USER I/O FLAG)
9538	!*	DPE9 USER FLAG H IS SET
9539	!*	DPE1 DP 09 IS SET
9540	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9541	!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
9542	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9543	!*RESPONSE:
9544	!*	EXAMINE DATA FROM MEM 0
9545	!]ERROR 5
9546	!]PCDBUS FCLK SPECPC R Q S G NTWK
9547		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
9548			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
9549		0						!TO ILLUMINATE BLISS INFO COMMENT
9550	
9551		END;
9552		LC(2);						!LOAD CRAM ADRS 2
9553		MOD_FLD(3,0);					!CLEAR DPE 09
9554		SET_C(1);					!SET CRAM ADRS TO 1
9555		DO (0) WHILE
9556	BLOCK6:	BEGIN
9557		CP(4);						!GIVE 4 CLOCKS
9558		RCVDATA = EM(0);				!GET DATA FROM MEM
9559		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9560		IF .RCVDATA NEQ 0				!CHECK DATA
9561			THEN BEGIN
9562				ERRCA(6,0,.RCVDATA,12);		!NO
9563				TEST_FLG = 1;
9564			     END;
9565	!*MESSAGE 6
9566	!*STIMULUS:
9567	!*	P.C. FLAGS TEST (USER I/O FLAG)
9568	!*	DPE9 USER FLAG H IS SET
9569	!*	DPE1 DP 09 IS CLEAR
9570	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9571	!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
9572	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9573	!*RESPONSE:
9574	!*	EXAMINE DATA FROM MEM 0
9575	!]ERROR 6
9576	!]PCDBUS FCLK SPECPC Q G S NTWK
9577		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
9578			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
9579		0						!TO ILLUMINATE BLISS INFO COMMENT
9580	
9581		END;
9582		LC(2);						!LOAD CRAM ADRS 2
9583		MOD_FLD(3,%O'400');				!SET DPE 09
9584		LC(1);						!LOAD CRAM ADRS 1
9585		MOD_FLD(4,0);					!CLEAR USER FLAG
9586		DO (0) WHILE
9587	BLOCK7:	BEGIN
9588		CP(4);						!GIVE 4 CLOCKS
9589		RCVDATA = EM(0);				!GET DATA FROM MEM
9590		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9591		IF .RCVDATA NEQ 0				!CHECK DATA
9592			THEN BEGIN
9593				ERRCA(7,0,.RCVDATA,12);		!NO
9594				TEST_FLG = 1;
9595			     END;
9596	!*MESSAGE 7
9597	!*STIMULUS:
9598	!*	P.C. FLAGS TEST (USER I/O FLAG)
9599	!*	DPE9 USER FLAG H IS CLEAR
9600	!*	DPE1 DP 09 IS SET
9601	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9602	!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
9603	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9604	!*RESPONSE:
9605	!*	EXAMINE DATA FROM MEM 0
9606	!]ERROR 7
9607	!]PCDBUS FCLK SPECPC Q G R S NTWK
9608		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
9609			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
9610		0						!TO ILLUMINATE BLISS INFO COMMENT
9611	
9612		END;
9613		LC(2);						!LOAD CRAM ADRS 2
9614		MOD_FLD(0,5);					!MODIFY J FIELD TO INCLUDE ANOTHER INSTRUCTION
9615		LC(1);						!LOAD CRAM ADRS 1
9616		MOD_FLD(4,1);					!SET USER FLAG
9617		DO (0) WHILE
9618	BLOCK8:	BEGIN
9619		CP(5);						!GIVE 5 CLOCKS
9620		RCVDATA = EM(0);				!GET DATA FROM MEM
9621		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9622		IF .RCVDATA NEQ 0				!CHECK DATA
9623			THEN BEGIN
9624				ERRCA(8,0,.RCVDATA,12);		!NO
9625				TEST_FLG = 1;
9626			     END;
9627	!*MESSAGE 8
9628	!*STIMULUS:
9629	!*	P.C. FLAGS TEST (USER I/O FLAG)
9630	!*	DPE9 USER FLAG H IS SET
9631	!*	DPE1 DP 09 IS SET
9632	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9633	!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
9634	!*	WE LOAD THE FLAGS AGAIN WITH -DPE9 LOAD FLAGS H CLEAR
9635	!*	THIS SHOULD CLEAR USER I/O FLAG
9636	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9637	!*RESPONSE:
9638	!*	EXAMINE DATA FROM MEM 0
9639	!]ERROR 8
9640	!]PCDBUS FCLK SPECPC Q G S Z NTWK
9641		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
9642			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
9643		0						!TO ILLUMINATE BLISS INFO COMMENT
9644	
9645		END;
9646		LC(5);						!LOAD CRAM ADRS 5
9647		MOD_FLD(3,0);					!SET -DPE9 LOAD FLAGS H
9648		SET_C(1);					!SET CRAM ADRS TO 1
9649		DO (0) WHILE
9650	BLOCK9:	BEGIN
9651		CP(5);						!GIVE 5 CLOCKS
9652		RCVDATA = EM(0);				!GET DATA FROM MEM
9653		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9654		IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
9655			THEN BEGIN
9656				ERRCA(9,%O'4000000000',.RCVDATA,12);!NO
9657				TEST_FLG = 1;
9658			     END;
9659	!*MESSAGE 9
9660	!*STIMULUS:
9661	!*	P.C. FLAGS TEST (USER I/O FLAG)
9662	!*	DPE9 USER FLAG H IS SET
9663	!*	DPE1 DP 09 IS SET
9664	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9665	!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
9666	!*	WE LOAD THE FLAGS AGAIN WITH -DPE9 LOAD FLAGS H SET
9667	!*	THIS SHOULD SET AGAIN  USER I/O FLAG
9668	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9669	!*RESPONSE:
9670	!*	EXAMINE DATA FROM MEM 0
9671	!]ERROR 9
9672	!]PCDBUS G FCLK SPECPC Q S Z NTWK
9673		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
9674			THEN LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
9675		0						!TO ILLUMINATE BLISS INFO COMMENT
9676	
9677		END;
9678		LC(2);						!LOAD CRAM ADRS 2
9679		MOD_FLD(3,0);					!CLEAR DPE 09
9680		SET_C(1);					!SET CRAM ADRS TO 1
9681		DO (0) WHILE
9682	BLOCK10:BEGIN
9683		CP(5);						!GIVE 5 CLOCKS
9684		RCVDATA = EM(0);				!GET DATA FROM MEM
9685		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9686		IF .RCVDATA NEQ 0				!CHECK DATA
9687			THEN BEGIN
9688				ERRCA(10,0,.RCVDATA,12);		!NO
9689				TEST_FLG = 1;
9690			     END;
9691	!*MESSAGE 10
9692	!*STIMULUS:
9693	!*	P.C. FLAGS TEST (USER I/O FLAG)
9694	!*	DPE9 USER FLAG H IS SET
9695	!*	DPE1 DP 09 IS CLEAR
9696	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9697	!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
9698	!*	WE LOAD THE FLAGS AGAIN WITH -DPE9 LOAD FLAGS H SET
9699	!*	THIS SHOULD CLEAR AGAIN USER I/O FLAG
9700	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9701	!*RESPONSE:
9702	!*	EXAMINE DATA FROM MEM 0
9703	!]ERROR 10
9704	!]PCDBUS FCLK SPECPC Q G S NTWK
9705		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
9706			THEN LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
9707		0						!TO ILLUMINATE BLISS INFO COMMENT
9708	
9709		END;
9710		LC(2);						!LOAD CRAM ADRS 2
9711		MOD_FLD(4,1);					!SET DBM 05
9712		MOD_FLD(3,%O'400');				!SET DBM 09
9713		LC(5);						!LOAD CRAM ADRS 5
9714		MOD_FLD(4,1);					!SET DBM 05
9715		MOD_FLD(3,%O'4004');				!SET LOAD FLAGS & DP 06
9716		SET_C(1);					!SET CRAM ADRS TO 1
9717		DO (0) WHILE
9718	BLOCK11:BEGIN
9719		CP(5);						!GIVE 5 CLOCKS
9720		RCVDATA = EM(0);				!GET DATA FROM MEM
9721		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9722		IF .RCVDATA NEQ %O'4000000000'			!CHECK DATA
9723			THEN BEGIN
9724				ERRCA(11,%O'4000000000',.RCVDATA,12);!NO
9725				TEST_FLG = 1;
9726			     END;
9727	!*MESSAGE 11
9728	!*STIMULUS:
9729	!*	P.C. FLAGS TEST (USER I/O FLAG)
9730	!*	DPE9 USER FLAG H IS SET
9731	!*	DPE1 DP 09 IS SET
9732	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9733	!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
9734	!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H,DP 06 & DBM 05 SET
9735	!*	THIS SHOULD SET AGAIN USER I/O FLAG
9736	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9737	!*RESPONSE:
9738	!*	EXAMINE DATA FROM MEM 0
9739	!]ERROR 11
9740	!]PCDBUS FCLK SPECPC Q R S G T NTWK
9741	
9742		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
9743			THEN LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
9744		0						!TO ILLUMINATE BLISS INFO COMMENT
9745	
9746		END;
9747		LC(5);						!LOAD CRAM ADRS 5
9748		MOD_FLD(4,0);					!CLEAR DBM 05
9749		SET_C(1);					!SET CRAM ADRS TO 1
9750		DO (0) WHILE
9751	BLOCK12:BEGIN
9752		CP(5);						!GIVE 5 CLOCKS
9753		RCVDATA = EM(0);				!GET DATA FROM MEM
9754		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9755		IF .RCVDATA NEQ 0				!CHECK DATA
9756			THEN BEGIN
9757				ERRCA(12,0,.RCVDATA,12);		!NO
9758				TEST_FLG = 1;
9759			     END;
9760	!*MESSAGE 12
9761	!*STIMULUS:
9762	!*	P.C. FLAGS TEST (USER I/O FLAG)
9763	!*	DPE9 USER FLAG H IS SET
9764	!*	DPE1 DP 09 IS SET
9765	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9766	!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
9767	!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H & DP 06 ARE SET, DBM 05 IS CLEAR
9768	!*	THIS SHOULD CLEAR USER I/O FLAG
9769	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9770	!*RESPONSE:
9771	!*	EXAMINE DATA FROM MEM 0
9772	!]ERROR 12
9773	!]PCDBUS FCLK SPECPC Q R G S T NTWK
9774		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
9775			THEN LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
9776		0						!TO ILLUMINATE BLISS INFO COMMENT
9777	
9778		END;
9779		LC(5);						!LOAD CRAM ADRS 5
9780		MOD_FLD(4,1);					!SET DBM 05
9781		LC(2);						!SET CRAM ADRS 2
9782		MOD_FLD(3,0);					!CLEAR DBM 09
9783		SET_C(1);					!SET CRAM ADRS TO 1
9784		DO (0) WHILE
9785	BLOCK13:BEGIN
9786		CP(5);						!GIVE 5 CLOCKS
9787		RCVDATA = EM(0);				!GET DATA FROM MEM
9788		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9789		IF .RCVDATA NEQ 0				!CHECK DATA
9790			THEN BEGIN
9791				ERRCA(13,0,.RCVDATA,12);		!NO
9792				TEST_FLG = 1;
9793			     END;
9794	!*MESSAGE 13
9795	!*STIMULUS:
9796	!*	P.C. FLAGS TEST (USER I/O FLAG)
9797	!*	DPE9 USER FLAG H IS SET
9798	!*	DPE1 DP 09 IS CLEAR
9799	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9800	!*	USER I/O FLAG SHOULD CLEAR WHEN FLAGS ARE LOADED
9801	!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H,DP 06 & DBM 05 SET
9802	!*	THIS SHOULD CLEAR AGAIN USER I/O FLAG
9803	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9804	!*RESPONSE:
9805	!*	EXAMINE DATA FROM MEM 0
9806	!]ERROR 13
9807	!]PCDBUS FCLK SPECPC Q G S T NTWK
9808		IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
9809			THEN LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
9810		0						!TO ILLUMINATE BLISS INFO COMMENT
9811	
9812		END;
9813		LC(2);						!LOAD CRAM ADRS 2
9814		MOD_FLD(3,%O'400');				!SET DBM 09
9815		LC(5);						!LOAD CRAM ADRS 5
9816		MOD_FLD(3,4);					!CLEAR DP 06
9817		SET_C(1);					!SET CRAM ADRS TO 1
9818		DO (0) WHILE
9819	BLOCK14:BEGIN
9820		CP(5);						!GIVE 5 CLOCKS
9821		RCVDATA = EM(0);				!GET DATA FROM MEM
9822		RCVDATA = .RCVDATA AND %O'4000000000';		!CLEAN UNWANTED BITS
9823		IF .RCVDATA NEQ 0				!CHECK DATA
9824			THEN ERRCA(14,0,.RCVDATA,12)		!NO
9825			ELSE IF .TEST_FLG EQL 0
9826				THEN NOERR(1);
9827	!*MESSAGE 14
9828	!*STIMULUS:
9829	!*	P.C. FLAGS TEST (USER I/O FLAG)
9830	!*	DPE9 USER FLAG H IS SET
9831	!*	DPE1 DP 09 IS SET
9832	!*	ALL OTHER FLAGS AND FLAG INPUTS ARE CLEAR
9833	!*	USER I/O FLAG SHOULD SET WHEN FLAGS ARE LOADED
9834	!*	WE LOAD THE FLAGS AGAIN WITH DPE9 LOAD FLAGS H & DBM 05 ARE SET, DP 06 IS CLEAR
9835	!*	THIS SHOULD CLEAR USER I/O FLAG
9836	!*	WRITE THE FLAGS OUT TO MEM 0 VIA DBUS & DP (DBUS SELECT = 0)
9837	!*RESPONSE:
9838	!*	EXAMINE DATA FROM MEM 0
9839	!]NO ERROR 1
9840	!]FCLK SPECPC NTWK
9841	!]ERROR 14
9842	!]PCDBUS FCLK SPECPC Q G S NTWK
9843		IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
9844			THEN LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
9845		0						!TO IILLUMINATE  BLISS INFO 
9846		END;
9847		END;
9848	
9849	GLOBAL ROUTINE TST46: NOVALUE =
9850	
9851	!THIS TEST CHECKS ALL THE INPUT AND OUTPUT PINS FOR TRAP DECODER ON DPE9 .
9852	!FIRST WE ENABLE TRAPS THROUGH THE 8080. THIS WILL SET PIN 3 ON DECODER.
9853	!THIS TEST WILL EXECUTE 3 INSTRUCTIONS IN CRAM 1,2 & 3:
9854	!CRAM 1/ LOAD THE TRAP FLAGS FROM THE MAGIC # FIELD.
9855	!CRAM 2/ DO A SPEC /APR EN WITH BIT 22 HI ON DP. THIS WILL SET DPEB TRAP EN .
9856	!CRAM 3/ DO A NICOND DISP.
9857	!THE EXECUTION OF THESE INSTRUCTIONS WILL DETECT THE OUTPUT OF THE DECODER
9858	!WHICH SETS CRA2 NICOND 09,10 & 11.
9859	!THE NXT CRAM ADRS IS READ AND VERIFIED.
9860	
9861		BEGIN
9862		OWN TEST_FLG;
9863		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5;
9864		BIND
9865		POINTER = PLIT (U_J(2) U_SPEC_FLAGS U,
9866				U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_APR_EN U_N(20000) U,
9867				U_J(0) U_DISP_NICOND U);
9868	
9869		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
9870		TEST_FLG = 0;
9871		TP(1);						!SET TRAP ENABLES
9872		DO (0) WHILE
9873	BLOCK1:	BEGIN
9874		SET_C(1);					!SET CRAM ADRS TO 1
9875		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
9876		RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
9877		IF .RCVDATA NEQ 5				!CHECK DATA
9878			THEN BEGIN
9879				ERRCA(1,5,.RCVDATA,4);	!NO
9880				TEST_FLG = 1;
9881			     END;
9882	!*MESSAGE 1
9883	!*STIMULUS:
9884	!*	SET DPEB TRAP EN
9885	!*	SET CSL4 TRAP EN
9886	!*	DPE9 TRAP 1 FLAG IS CLEAR
9887	!*	DPE9 TRAP 2 FLAG IS CLEAR
9888	!*	WE DO A NICOND DISP
9889	!*	CURRENT J FIELD = 0
9890	!*RESPONSE:
9891	!*	EXAMINE NXT CRAM ADRS
9892		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
9893		THEN
9894		    LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
9895		0						!TO ILLUMINATE BLISS INFO COMMENT
9896	
9897		END;
9898		MOD_FLD(3,%O'1000');				!SET TRAP 1 FLAG
9899		DO (0) WHILE
9900	BLOCK2:	BEGIN
9901		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
9902		RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
9903		IF .RCVDATA NEQ 3				!CHECK DATA
9904			THEN BEGIN
9905				ERRCA(2,3,.RCVDATA,4);	!NO
9906				TEST_FLG = 1;
9907			     END;
9908	!*MESSAGE 2
9909	!*STIMULUS:
9910	!*	SET DPEB TRAP EN
9911	!*	SET CSL4 TRAP EN
9912	!*	DPE9 TRAP 1 FLAG IS SET
9913	!*	DPE9 TRAP 2 FLAG IS CLEAR
9914	!*	WE DO A NICOND DISP
9915	!*	CURRENT J FIELD = 0
9916	!*RESPONSE:
9917	!*	EXAMINE NXT CRAM ADRS
9918		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
9919		THEN
9920		    BEGIN
9921		    SET_C(1);					!SET CRAM ADRS TO 1
9922		    LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
9923		END;
9924		0						!TO ILLUMINATE BLISS INFO COMMENT
9925	
9926		END;
9927		MOD_FLD(3,%O'2000');				!SET TRAP 2 FLAG
9928		DO (0) WHILE
9929	BLOCK3:	BEGIN
9930		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
9931		RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
9932		IF .RCVDATA NEQ 2				!CHECK DATA
9933			THEN BEGIN
9934				ERRCAS(1,3,2,.RCVDATA,4,0);	!NO
9935				TEST_FLG = 1;
9936			     END;
9937	!*MESSAGE 3
9938	!*STIMULUS:
9939	!*	SET DPEB TRAP EN
9940	!*	SET CSL4 TRAP EN
9941	!*	DPE9 TRAP 1 FLAG IS CLEAR
9942	!*	DPE9 TRAP 2 FLAG IS SET
9943	!*	WE DO A NICOND DISP
9944	!*	CURRENT J FIELD = 0
9945	!*RESPONSE:
9946	!*	EXAMINE NXT CRAM ADRS
9947		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
9948		THEN
9949		    BEGIN
9950		    SET_C(1);					!SET CRAM ADRS TO 1
9951		    LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
9952		    END;
9953		0						!TO ILLUMINATE BLISS INFO COMMENT
9954	
9955		END;
9956		MOD_FLD(3,%O'3000');				!SET TRAPS 1 & 2
9957		DO (0) WHILE
9958	BLOCK4:	BEGIN
9959		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
9960		RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
9961		IF .RCVDATA NEQ 1				!CHECK DATA
9962			THEN BEGIN
9963				ERRCAS(2,4,1,.RCVDATA,4,0);	!NO
9964				TEST_FLG = 1;
9965			     END;
9966	!*MESSAGE 4
9967	!*STIMULUS:
9968	!*	SET DPEB TRAP EN
9969	!*	SET CSL4 TRAP EN
9970	!*	DPE9 TRAP 1 FLAG IS SET
9971	!*	DPE9 TRAP 2 FLAG IS SET
9972	!*	WE DO A NICOND DISP
9973	!*	CURRENT J FIELD = 0
9974	!*RESPONSE:
9975	!*	EXAMINE NXT CRAM ADRS
9976		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
9977		THEN
9978		    BEGIN
9979		    SET_C(1);					!SET CRAM ADRS TO 1
9980		    LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
9981		    END;
9982		0						!TO ILLUMINATE BLISS INFO COMMENT
9983	
9984		END;
9985		LC(2);						!LOAD CRAM ADRS 2
9986		MOD_FLD(4,0);					!CLEAR DPEB TRAP EN
9987		SET_C(1);					!SET CRAM ADRS TO 1
9988	BLOCK5:	BEGIN
9989		RCVDATA = STEP_U_NEXT(3);			!GIVE 3 CLKS & GET NXT CRAM ADRS
9990		RCVDATA = .RCVDATA AND 7;			!CLEAN UNWANTED BITS
9991		IF .RCVDATA NEQ 5				!CHECK DATA
9992			THEN ERRCAS(2,5,5,.RCVDATA,4,0)		!NO
9993			ELSE IF .TEST_FLG EQL 0
9994				THEN NOERR(1);
9995	!*MESSAGE 5
9996	!*STIMULUS:
9997	!*	CLEAR DPEB TRAP EN
9998	!*	SET CSL4 TRAP EN
9999	!*	DPE9 TRAP 1 FLAG IS SET
10000	!*	DPE9 TRAP 2 FLAG IS SET
10001	!*	WE DO A NICOND DISP
10002	!*	CURRENT J FIELD = 0
10003	!*RESPONSE:
10004	!*	EXAMINE NXT CRAM ADRS
10005		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
10006		THEN
10007		    BEGIN
10008		    SET_C(1);					!SET CRAM ADRS TO 1
10009		    LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
10010		    END;
10011		0						!TO ILLUMINATE BLISS INFO COMMENT
10012	
10013		END;
10014	!]ERROR 1
10015	!]PIBUS SPECPC SPECAPR TRAP Q FCLK V A B I G C D U NTWK
10016	!]ERROR 2
10017	!]PIBUS SPECPC SPECAPR TRAP FCLK NTWK
10018	!]NO ERROR 1
10019	!]TRAP FCLK CCLK SPECPC SPECAPR NTWK
10020		TP(0);						!CLEAR TRAP ENABLES
10021		END;
10022	
10023	GLOBAL ROUTINE TST47: NOVALUE =
10024	
10025	!THIS TEST CHECKS ALL GATES AND FLOPS RELATED TO AC=0, XR=0, INDIRECT BIT & JRST,0 ON DPEA
10026	!THIS TEST WILL EXECUTE 2 INSTRUCTIONS IN CRAM 1 & 2 THAT WILL DO THE FOLLOWING:
10027	!CRAM 1/ LOAD THE INSTRUCTION REGISTER WITH A DATA WORD FROM THE MAGIC 
10028	!	 # FIELD VIA DBUS & DP
10029	!CRAM 2/ DO A DISP ON JRST,0, INDIRECT & XR=0 (DISP = 66)
10030	!	 DO A SKIP ON AC=0 (SKIP = 36)
10031	!AFTER EACH EXECUTIONS FEILDS ARE MODIFIED IN CRAM 1 TO SET UP THE DATA
10032	!WORD TO BE LOADED IN THE INSTRUCTION REGISTER FOR THE NXT EXECUTION.
10033	!OUTPUT IS VERIFIED BY EXEMINING THE NXT CRAM ADRS.
10034	
10035		BEGIN
10036		OWN TEST_FLG;
10037		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,
10038		      BLOCK8,BLOCK9,BLOCK10,BLOCK11,BLOCK12,BLOCK13,BLOCK14;
10039		BIND
10040		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDINST U_N(254204) U,
10041			U_DISP_EAMODE U_SKIP_AC0 U);
10042	
10043		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
10044		TEST_FLG = 0;
10045		SET_C(1);					!SET CRAM ADRS TO 1
10046		ER_TAB[0] = UPLIT(%ASCIZ'HI');			!FOR ERROR
10047		ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR
10048		ER_TAB[2] = UPLIT(%ASCIZ'LO');			!FOR ERROR
10049		ER_TAB[3] = UPLIT(%ASCIZ'LO');			!FOR ERROR
10050		ER_TAB[4] = %O'254204';				!FOR ERROR
10051		DO (0) WHILE
10052	BLOCK1:	BEGIN
10053		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10054		IF .RCVDATA NEQ %O'10'				!CHECK DATA
10055			THEN BEGIN
10056				ERMCAS(1,%O'10',.RCVDATA,4,ER_TAB);	!NO
10057				TEST_FLG = 1;
10058			     END;
10059		IF (.RCVDATA AND 1) NEQ 0
10060			THEN FAILURE(1);
10061		IF (.RCVDATA AND 2) NEQ 0
10062			THEN FAILURE(2);
10063		IF (.RCVDATA AND 4) NEQ 0
10064			THEN FAILURE(3);
10065		IF (.RCVDATA AND %O'10') EQL 0
10066			THEN FAILURE(4);
10067		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
10068			THEN 
10069			BEGIN
10070			    SET_C(1);				!SET CRAM ADRS TO 1
10071			    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
10072			END;
10073		0						!TO ILLUMINATE BLISS INFO COMMENT
10074	
10075		END;
10076		MOD_FLD(3,%O'4430');				!CHANGE DATA TO 254430
10077		ER_TAB[1] = UPLIT(%ASCIZ'HI');			!FOR ERROR
10078		ER_TAB[4] = %O'254430';				!FOR ERROR
10079		DO (0) WHILE
10080	BLOCK2:	BEGIN
10081		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10082		IF .RCVDATA NEQ %O'14'				!CHECK DATA
10083			THEN BEGIN
10084				ERMCAS(1,%O'14',.RCVDATA,4,ER_TAB);	!NO
10085				TEST_FLG = 1;
10086			     END;
10087		IF (.RCVDATA AND 1) NEQ 0
10088			THEN FAILURE(1);
10089		IF (.RCVDATA AND 2) NEQ 0
10090			THEN FAILURE(2);
10091		IF (.RCVDATA AND 4) EQL 0
10092			THEN FAILURE(3);
10093		IF (.RCVDATA AND %O'10') EQL 0
10094			THEN FAILURE(4);
10095		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
10096			THEN 
10097			BEGIN
10098			    SET_C(1);				!SET CRAM ADRS TO 1
10099			    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
10100			END;
10101		0						!TO ILLUMINATE BLISS INFO COMMENT
10102	
10103		END;
10104		MOD_FLD(3,%O'4102');				!CHANGE DATA TO 254102
10105		ER_TAB[1] = UPLIT(%ASCIZ'LO');			!FOR ERROR
10106		ER_TAB[4] = %O'254102';				!FOR ERROR
10107		DO (0) WHILE
10108	BLOCK3:	BEGIN
10109		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10110		IF .RCVDATA NEQ %O'10'				!CHECK DATA
10111			THEN BEGIN
10112				ERMCAS(1,%O'10',.RCVDATA,4,ER_TAB);	!NO
10113				TEST_FLG = 1;
10114			     END;
10115		IF (.RCVDATA AND 1) NEQ 0
10116			THEN FAILURE(1);
10117		IF (.RCVDATA AND 2) NEQ 0
10118			THEN FAILURE(2);
10119		IF (.RCVDATA AND 4) NEQ 0
10120			THEN FAILURE(3);
10121		IF (.RCVDATA AND %O'10') EQL 0
10122			THEN FAILURE(4);
10123		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
10124			THEN 
10125			BEGIN
10126			    SET_C(1);				!SET CRAM ADRS TO 1
10127			    LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
10128			END;
10129		0						!TO ILLUMINATE BLISS INFO COMMENT
10130	
10131		END;
10132		MOD_FLD(3,%O'4041');				!CHANGE DATA TO 254041
10133		ER_TAB[4] = %O'254041';				!FOR ERROR
10134		DO (0) WHILE
10135	BLOCK4:	BEGIN
10136		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10137		IF .RCVDATA NEQ %O'10'				!CHECK DATA
10138			THEN BEGIN
10139				ERMCAS(1,%O'10',.RCVDATA,4,ER_TAB);	!NO
10140				TEST_FLG = 1;
10141			     END;
10142		IF (.RCVDATA AND 1) NEQ 0
10143			THEN FAILURE(1);
10144		IF (.RCVDATA AND 2) NEQ 0
10145			THEN FAILURE(2);
10146		IF (.RCVDATA AND 4) NEQ 0
10147			THEN FAILURE(3);
10148		IF (.RCVDATA AND %O'10') EQL 0
10149			THEN FAILURE(4);
10150		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
10151			THEN 
10152			BEGIN
10153			    SET_C(1);				!SET CRAM ADRS TO 1
10154			    LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
10155			END;
10156		0						!TO ILLUMINATE BLISS INFO COMMENT
10157	
10158		END;
10159		MOD_FLD(3,%O'4000');				!CHAGE DATA TO 254000
10160		ER_TAB[0] = UPLIT(%ASCIZ'LO');			!FOR ERROR
10161		ER_TAB[2] = UPLIT(%ASCIZ'HI');			!FOR ERROR
10162		ER_TAB[3] = UPLIT(%ASCIZ'HI');			!FOR ERROR
10163		ER_TAB[4] = %O'254000';				!FOR ERROR
10164		DO (0) WHILE
10165	BLOCK5:	BEGIN
10166		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10167		IF .RCVDATA NEQ 3				!CHECK DATA
10168			THEN BEGIN
10169				ERMCAS(1,3,.RCVDATA,4,ER_TAB);		!NO
10170				TEST_FLG = 1;
10171			     END;
10172		IF (.RCVDATA AND 1) EQL 0
10173			THEN FAILURE(1);
10174		IF (.RCVDATA AND 2) EQL 0
10175			THEN FAILURE(2);
10176		IF (.RCVDATA AND 4) NEQ 0
10177			THEN FAILURE(3);
10178		IF (.RCVDATA AND %O'10') NEQ 0
10179			THEN FAILURE(4);
10180		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
10181			THEN 
10182			BEGIN
10183			    SET_C(1);				!SET CRAM ADRS TO 1
10184			    LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
10185			END;
10186		0						!TO ILLUMINATE BLISS INFO COMMENT
10187	
10188		END;
10189		MOD_FLD(4,%O'65');				!MODIFY DATA TO 654000
10190		ER_TAB[0] = UPLIT(%ASCIZ'HI');			!FOR ERROR
10191		ER_TAB[4] = %O'654000';				!FOR ERROR
10192		DO (0) WHILE
10193	BLOCK6:	BEGIN
10194		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10195		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10196			THEN BEGIN
10197				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10198				TEST_FLG = 1;
10199			     END;
10200		IF (.RCVDATA AND 1) EQL 0
10201			THEN FAILURE(1);
10202		IF (.RCVDATA AND 2) EQL 0
10203			THEN FAILURE(2);
10204		IF (.RCVDATA AND 4) NEQ 0
10205			THEN FAILURE(3);
10206		IF (.RCVDATA AND %O'10') EQL 0
10207			THEN FAILURE(5);
10208		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
10209			THEN 
10210			BEGIN
10211			    SET_C(1);				!SET CRAM ADRS TO 1
10212			    LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
10213			END;
10214		0						!TO ILLUMINATE BLISS INFO COMMENT
10215	
10216		END;
10217		MOD_FLD(4,5);					!CHANGE DATA TO 54000
10218		ER_TAB[4] = %O'54000';				!FOR ERROR
10219		DO (0) WHILE
10220	BLOCK7:	BEGIN
10221		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10222		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10223			THEN BEGIN
10224				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10225				TEST_FLG = 1;
10226			     END;
10227		IF (.RCVDATA AND 1) EQL 0
10228			THEN FAILURE(1);
10229		IF (.RCVDATA AND 2) EQL 0
10230			THEN FAILURE(2);
10231		IF (.RCVDATA AND 4) NEQ 0
10232			THEN FAILURE(3);
10233		IF (.RCVDATA AND %O'10') EQL 0
10234			THEN FAILURE(5);
10235		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
10236			THEN 
10237			BEGIN
10238			    SET_C(1);				!SET CRAM ADRS TO 1
10239			    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
10240			END;
10241		0						!TO ILLUMINATE BLISS INFO COMMENT
10242	
10243		END;
10244		MOD_FLD(4,%O'21');				!CHANGE DATA TO 214000
10245		ER_TAB[4] = %O'214000';				!FOR ERROR
10246		DO (0) WHILE
10247	BLOCK8:	BEGIN
10248		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10249		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10250			THEN BEGIN
10251				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10252				TEST_FLG = 1;
10253			     END;
10254		IF (.RCVDATA AND 1) EQL 0
10255			THEN FAILURE(1);
10256		IF (.RCVDATA AND 2) EQL 0
10257			THEN FAILURE(2);
10258		IF (.RCVDATA AND 4) NEQ 0
10259			THEN FAILURE(3);
10260		IF (.RCVDATA AND %O'10') EQL 0
10261			THEN FAILURE(5);
10262		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
10263			THEN 
10264			BEGIN
10265			    SET_C(1);				!SET CRAM ADRS TO 1
10266			    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
10267			END;
10268		0						!TO ILLUMINATE BLISS INFO COMMENT
10269	
10270		END;
10271		MOD_FLD(4,%O'24');				!CHANGE DATA TO 244000
10272		ER_TAB[4] = %O'244000';				!FOR ERROR
10273		DO (0) WHILE
10274	BLOCK9:	BEGIN
10275		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10276		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10277			THEN BEGIN
10278				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10279				TEST_FLG = 1;
10280			     END;
10281		IF (.RCVDATA AND 1) EQL 0
10282			THEN FAILURE(1);
10283		IF (.RCVDATA AND 2) EQL 0
10284			THEN FAILURE(2);
10285		IF (.RCVDATA AND 4) NEQ 0
10286			THEN FAILURE(3);
10287		IF (.RCVDATA AND %O'10') EQL 0
10288			THEN FAILURE(5);
10289		IF LOOP_CHK(9)					!IS LOOP ON ERROR SET ?
10290			THEN 
10291			BEGIN
10292			    SET_C(1);				!SET CRAM ADRS TO 1
10293			    LEAVE BLOCK9 WITH 1;		!LEAVE BLOCK TO LOOP
10294			END;
10295		0						!TO ILLUMINATE BLISS INFO COMMENT
10296	
10297		END;
10298		MOD_FLD(4,%O'27');				!CHANGE DATA TO 274000
10299		ER_TAB[4] = %O'274000';				!FOR ERROR
10300		DO (0) WHILE
10301	BLOCK10:BEGIN
10302		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10303		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10304			THEN BEGIN
10305				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10306				TEST_FLG = 1;
10307			     END;
10308		IF (.RCVDATA AND 1) EQL 0
10309			THEN FAILURE(1);
10310		IF (.RCVDATA AND 2) EQL 0
10311			THEN FAILURE(2);
10312		IF (.RCVDATA AND 4) NEQ 0
10313			THEN FAILURE(3);
10314		IF (.RCVDATA AND %O'10') EQL 0
10315			THEN FAILURE(5);
10316		IF LOOP_CHK(10)					!IS LOOP ON ERROR SET ?
10317			THEN 
10318			BEGIN
10319			    SET_C(1);				!SET CRAM ADRS TO 1
10320			    LEAVE BLOCK10 WITH 1;		!LEAVE BLOCK TO LOOP
10321			END;
10322		0						!TO ILLUMINATE BLISS INFO COMMENT
10323	
10324		END;
10325		MOD_FLD(4,%O'35');				!CHANGE DATA TO 354000
10326		ER_TAB[4] = %O'354000';				!FOR ERROR
10327		DO (0) WHILE
10328	BLOCK11:BEGIN
10329		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10330		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10331			THEN BEGIN
10332				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10333				TEST_FLG = 1;
10334			     END;
10335		IF (.RCVDATA AND 1) EQL 0
10336			THEN FAILURE(1);
10337		IF (.RCVDATA AND 2) EQL 0
10338			THEN FAILURE(2);
10339		IF (.RCVDATA AND 4) NEQ 0
10340			THEN FAILURE(3);
10341		IF (.RCVDATA AND %O'10') EQL 0
10342			THEN FAILURE(5);
10343		IF LOOP_CHK(11)					!IS LOOP ON ERROR SET ?
10344			THEN 
10345			BEGIN
10346			    SET_C(1);				!SET CRAM ADRS TO 1
10347			    LEAVE BLOCK11 WITH 1;		!LEAVE BLOCK TO LOOP
10348			END;
10349		0						!TO ILLUMINATE BLISS INFO COMMENT
10350	
10351		END;
10352		MOD_FLD(3,0);
10353		MOD_FLD(4,%O'25');				!CHANGE DATA TO 25000
10354		ER_TAB[4] = %O'25000';				!FOR ERROR
10355		DO (0) WHILE
10356	BLOCK12:BEGIN
10357		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10358		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10359			THEN BEGIN
10360				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10361				TEST_FLG = 1;
10362			     END;
10363		IF (.RCVDATA AND 1) EQL 0
10364			THEN FAILURE(1);
10365		IF (.RCVDATA AND 2) EQL 0
10366			THEN FAILURE(2);
10367		IF (.RCVDATA AND 4) NEQ 0
10368			THEN FAILURE(3);
10369		IF (.RCVDATA AND %O'10') EQL 0
10370			THEN FAILURE(5);
10371		IF LOOP_CHK(12)					!IS LOOP ON ERROR SET ?
10372			THEN 
10373			BEGIN
10374			    SET_C(1);				!SET CRAM ADRS TO 1
10375			    LEAVE BLOCK12 WITH 1;		!LEAVE BLOCK TO LOOP
10376			END;
10377		0						!TO ILLUMINATE BLISS INFO COMMENT
10378	
10379		END;
10380		MOD_FLD(3,%O'6000');				!CHANGE DATA TO 256000
10381		ER_TAB[4] = %O'256000';				!FOR ERROR
10382		DO (0) WHILE
10383	BLOCK13:BEGIN
10384		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10385		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10386			THEN BEGIN
10387				ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB);	!NO
10388				TEST_FLG = 1;
10389			     END;
10390		IF (.RCVDATA AND 1) EQL 0
10391			THEN FAILURE(1);
10392		IF (.RCVDATA AND 2) EQL 0
10393			THEN FAILURE(2);
10394		IF (.RCVDATA AND 4) NEQ 0
10395			THEN FAILURE(3);
10396		IF (.RCVDATA AND %O'10') EQL 0
10397			THEN FAILURE(5);
10398		IF LOOP_CHK(13)					!IS LOOP ON ERROR SET ?
10399			THEN 
10400			BEGIN
10401			    SET_C(1);				!SET CRAM ADRS TO 1
10402			    LEAVE BLOCK13 WITH 1;		!LEAVE BLOCK TO LOOP
10403			END;
10404		0						!TO ILLUMINATE BLISS INFO COMMENT
10405	
10406		END;
10407		MOD_FLD(3,%O'5000');				!CHANGE DATA TO 255000
10408		ER_TAB[4] = %O'255000';				!FOR ERROR
10409		DO (0) WHILE
10410	BLOCK14:BEGIN
10411		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10412		IF .RCVDATA NEQ %O'13'				!CHECK DATA
10413			THEN ERMCAS(1,%O'13',.RCVDATA,4,ER_TAB)	!NO
10414			ELSE IF .TEST_FLG EQL 0
10415				THEN NOERR(1);
10416		IF (.RCVDATA AND 1) EQL 0
10417			THEN FAILURE(1);
10418		IF (.RCVDATA AND 2) EQL 0
10419			THEN FAILURE(2);
10420		IF (.RCVDATA AND 4) NEQ 0
10421			THEN FAILURE(3);
10422		IF (.RCVDATA AND %O'10') EQL 0
10423			THEN FAILURE(5);
10424		IF LOOP_CHK(14)					!IS LOOP ON ERROR SET ?
10425			THEN 
10426			BEGIN
10427			    SET_C(1);				!SET CRAM ADRS TO 1
10428			    LEAVE BLOCK14 WITH 1;		!LEAVE BLOCK TO LOOP
10429			END;
10430		0						!TO ILLUMINATE BLISS INFO COMMENT
10431	
10432		END;
10433	!*MESSAGE 1
10434	!*STIMULUS:
10435	!*	LOAD INSTRUCTION REGISTER WITH A \O4
10436	!*	EXECUTE THE FOLOWING:
10437	!*		SKIP ON AC0 (SKIP = 36)
10438	!*		DISP ON XR=0, JRST,0 & INDIRECT BIT (DISP = 66)
10439	!*	THEN EXAMINE NXT CRAM ADRS. IT SHOULD BE:
10440	!*	NXT ADRS = CRAM J + JRST,0 + INDIRECT BIT + XR=0 + AC=0
10441	!*		 =  0000  +   \S0   +      \S1      +  \S2  +  \S3  
10442	!*RESPONSE:
10443	!]NO ERROR 1
10444	!]FCLK SPECIR SPECXR AC0 XR0 IR JRST0 NTWK
10445	!]ERROR 1
10446	!]FCLK SPECIR AC0 IR SKIP NTWK
10447	!]ERROR 2
10448	!]FCLK SPECXR XR0 XR NTWK
10449	!]ERROR 3
10450	!]FCLK SPECXR XR NTWK
10451	!]ERROR 4
10452	!]FCLK AC0 JRST0 IR SPECIR NTWK
10453	!]ERROR 5
10454	!]FCLK IR JRST0 SPECIR NTWK
10455		END;
10456	
10457	GLOBAL ROUTINE TST48: NOVALUE =
10458	
10459	!THIS TEST CHECKS THE SKIP MIX'S ON FPD, USER & USER I/O FLAGS.
10460	!THIS TEST WILL EXEUTE 2 INSTRUCTIONS IN CRAM 1 & 2 THAT WILL DO THE FOLLOWING:
10461	!CRAM 1/ LOAD THE FLAGS FROM DP
10462	!CRAM 2/ SKIP IF FLAG IS SET (THE CURRENT J FIELD IS 0000)
10463	!AFTER EACH EXECUTION FIELDS ARE MODIFIED TO TEST SKIP ON NXT FLAG 
10464	!ALSO AFTER EACH EXECUTION RESULT IS VERIFIED BY EXAMINNING THE NXT 
10465	!CRAM ADRS (THE ORED J FIELD IS ALWAYS 0000).
10466	
10467		BEGIN
10468		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6;
10469		BIND
10470		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_FLAGS U_N(4) U,
10471				U_SKIP_FPD U);
10472		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
10473		DO (0) WHILE
10474	BLOCK1:	BEGIN
10475		SET_C(1);					!SET CRAM ADRS TO 1
10476		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10477		IF .RCVDATA NEQ 0				!CHECK DATA
10478			THEN ERRCA(1,0,.RCVDATA,4);		!NO
10479	!*MESSAGE 1
10480	!*STIMULUS:
10481	!*	LOAD FPD FLAG WITH A 0 FROM DP
10482	!*	SKIP IF FPD FLAG IS SET
10483	!*RESPONSE:
10484	!*	EXAMINE NXT CRAM ADRS
10485	!]ERROR 1
10486	!]SKIP NTWK
10487		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
10488			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
10489		0						!TO ILLUMINATE BLISS INFO COMMENT
10490	
10491		END;
10492		LC(2);						!LOAD CRAM ADRS 2
10493		MOD_FLD(2,4);					!CHANGE TO SKIP ON USER FLAG
10494		DO (0) WHILE
10495	BLOCK2:	BEGIN
10496		SET_C(1);					!SET CRAM ADRS TO 1
10497		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10498		IF .RCVDATA NEQ 1				!CHECK DATA
10499			THEN ERRCA(2,1,.RCVDATA,4);		!NO
10500	!*MESSAGE 2
10501	!*STIMULUS:
10502	!*	LOAD USER FLAG WITH A 0 FROM DP
10503	!*	SKIP IF USER FLAG IS CLEAR
10504	!*RESPONSE:
10505	!*	EXAMINE NXT CRAM ADRS
10506	!]ERROR 2
10507	!]SKIP NTWK
10508		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
10509			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
10510		0						!TO ILLUMINATE BLISS INFO COMMENT
10511	
10512		END;
10513		LC(2);						!LOAD CRAM ADRS 2
10514		MOD_FLD(1,%O'6507');
10515		DO (0) WHILE
10516	BLOCK3:	BEGIN
10517		SET_C(1);					!SET CRAM ADRS TO 1
10518		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLKS & GET NXT CRAM ADRS
10519		IF .RCVDATA NEQ 0				!CHECK DATA
10520			THEN ERRCA(3,0,.RCVDATA,4);		!NO
10521	!*MESSAGE 3
10522	!*STIMULUS:
10523	!*	LOAD USER I/O FLAG WITH A 0 FROM DP CONDITIONALLY
10524	!*	SKIP IF USER I/O FLAG IS SET
10525	!*RESPONSE:
10526	!*	EXAMINE NXT CRAM ADRS
10527	!]ERROR 3
10528	!]SKIP NTWK
10529		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
10530			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
10531		0						!TO ILLUMINATE BLISS INFO COMMENT
10532	
10533		END;
10534		MOD_FLD(4,3);					!MODIFY TO SET
10535		MOD_FLD(3,%O'404');				!USER, USER I/O & FPD FLAGS
10536		LC(2);						!LOAD CRAM ADRS 2
10537		MOD_FLD(1,%O'6307');				!MODIFY TO SKIP ON USER FLAG
10538		DO (0) WHILE
10539	BLOCK4:	BEGIN
10540		SET_C(1);					!SET CRAM ADRS TO 1
10541		RCVDATA = STEP_U_NEXT(2);			!GIVE 2CLKS & GET NXT CRAM ADRS
10542		IF .RCVDATA NEQ 0				!CHECK DATA
10543			THEN ERRCA(4,0,.RCVDATA,4);		!NO
10544	!*MESSAGE 4
10545	!*STIMULUS:
10546	!*	LOAD USER FLAG WITH A 1 FROM DP
10547	!*	SKIP IF USER FLAG IS CLEAR
10548	!*RESPONSE:
10549	!*	EXAMINE NXT CRAM ADRS
10550	!]ERROR 4
10551	!]SKIP NTWK
10552		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
10553			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
10554		0						!TO ILLUMINATE BLISS INFO COMMENT
10555	
10556		END;
10557		LC(2);						!LOAD CRAM ADRS 2
10558		MOD_FLD(1,%O'6507');				!MODIFY TO SKIP ON I/O FLAG
10559		DO (0) WHILE
10560	BLOCK5:	BEGIN
10561		SET_C(1);					!SET CRAM ADRS TO 1
10562		RCVDATA = STEP_U_NEXT(2);			!GIVE 2CLKS & GET NXT CRAM ADRS
10563		IF .RCVDATA NEQ 1				!CHECK DATA
10564			THEN ERRCA(5,1,.RCVDATA,4);		!NO
10565	!*MESSAGE 5
10566	!*STIMULUS:
10567	!*	LOAD USER I/O FLAG WITH A 1 FROM DP CONDITIONALLY
10568	!*	SKIP IF USER I/O FLAG IS SET
10569	!*RESPONSE:
10570	!*	EXAMINE NXT CRAM ADRS
10571	!]ERROR 5
10572	!]SKIP NTWK
10573		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
10574			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
10575		0						!TO ILLUMINATE BLISS INFO COMMENT
10576	
10577		END;
10578		LC(2);						!LOAD CRAM ADRS 2
10579		MOD_FLD(1,%O'6307');
10580		MOD_FLD(2,5);					!MODIFY TO SKIP ON FPD FLAG
10581		DO (0) WHILE
10582	BLOCK6:	BEGIN
10583		SET_C(1);					!SET CRAM ADRS TO 1
10584		RCVDATA = STEP_U_NEXT(2);			!GIVE 2CLKS & GET NXT CRAM ADRS
10585		IF .RCVDATA NEQ 1				!CHECK DATA
10586			THEN ERRCA(6,1,.RCVDATA,4);		!NO
10587	!*MESSAGE 6
10588	!*STIMULUS:
10589	!*	LOAD FPD FLAG WITH A 2 FROM DP
10590	!*	SKIP IF FPD FLAG IS SET
10591	!*RESPONSE:
10592	!*	EXAMINE NXT CRAM ADRS
10593	!]ERROR 6
10594	!]SKIP NTWK
10595		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
10596			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
10597		0						!TO ILLUMINATE BLISS INFO COMMENT
10598	
10599		END;
10600		END;
10601	
10602	GLOBAL ROUTINE TST49: NOVALUE =
10603	
10604	!THIS TEST CHECKS ALL THE DBUS PARITY IMPLEMENTATION LOGIC ON DPPE3 & 4.
10605	!THIS TEST WILL OUTPUT A SEQUENCE OF SELECTED DATA WORDS ON THE DBUS
10606	!VIA THE MAGIC # FIELD & DBM.IT WILL READ FROM MEMORY A 0 OR A 1,,1 TO 
10607	!SET OR CLEAR THE MEMORY BUS PARITY BITS.IT WILL ALSO CHCK THE LEFT & 
10608	!RIGHT HALFS OF THE DBUS SEPERATLY. THE OUTPUT IS VERIFIED BY READING THE 8080'S
10609	!REGISTER 100 WHERE BIT 2 (DP PARITY L) INDICATES THE PARITY CONDITION.
10610	!THE EXECUTED INSTRUCTIONS RESIDE IN CRAM 0,1 & 2 :
10611	!CRAM 0/ START A PHYSICAL MEM READ CYCLE & LOAD THE VMA WITH A 0.
10612	!CRAM 1/ FINISH THE CYCLE AND READ FROM PHYSICAL MEM 0.
10613	!(PRIOR TO EXECUTING THOSE 2 INSTRUCTIONS, A 0 DATA IS WRITTEN INTO PHYSICAL
10614	!MEM 0 TO CLEAR BOTH HALFS OF MEMORY BUS PARITY, AND A 1,,1 TO SET THEM).
10615	!CRAM 2/ INPUT A DATA WORD FROM THE MAGIC # FIELD AND OUTPUT IT ON THE
10616	!	 DBUS VIA DBM. CHCK LEFT, RIGHT, BOTH OR NEITHER HALFS OF THE DBUS.
10617	!	 (EACH CONDITION IS TESTED SEPERATLY BY MODIFYING THE PROPER 
10618	!	 FIELD IN THE CRAM).
10619	!THEN WE READ REGISTER 100 AND VERIFY DP PARITY BIT.
10620	
10621		BEGIN
10622		OWN FLD,TEST_FLG,TESTR_FLG,TESTL_FLG,
10623		PEDATA:VECTOR[8] INITIAL(%O'666375',%O'220220',%O'444102',%O'11011',
10624					 %O'102444',%O'733733',%O'375666',%O'557557');
10625		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
10626		BIND
10627		POINTER = PLIT (U_J(1) U_MEM U_DBUS_DBM U_N(41012) U,
10628				U_J(2) U_DBUS_DBM U_MEM U_N(2) U,
10629				U_J(2) U_DBUS_DBM U);
10630	
10631		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
10632		TEST_FLG = 0;
10633		TESTL_FLG = 0;
10634		TESTR_FLG = 0;
10635		SET_C(0);					!SET CRAM ADRS TO 0
10636		DM(0,0);					!CLEAR THIS LOCATION
10637		CP_NOSS(2);					!CLK THOSE 2 TO CLEAR MB PARITY
10638		MR();						!DO A MASTER RESET
10639		SET_C(2);					!SET CRAM ADRS TO 2
10640		INCR I FROM 0 TO 7 DO
10641		BEGIN
10642		MOD_FLD(7,%O'4304');				!MODIFY TO CHCK RIGHT HALF OF DBUS
10643		ER_TAB[1] = UPLIT (%ASCIZ'RIGHT');		!THIS FOR ERROR PRINTOUT
10644		ER_TAB[0] = .PEDATA[.I];			!SET UP FOR ERROR PRINTOUT
10645		FLD = .PEDATA[.I];				!GET THE CORRECT
10646		MOD_FLD(3,.FLD);				!FIELDS & MODIFY
10647		MOD_FLD(4,.FLD<12,6>);				!DATA IN THE MAGIC # FIELD
10648		DO (0) WHILE
10649	BLOCK1:	BEGIN
10650		CP(2);						!GIVE 2 CLKS
10651		RCVDATA = RD_100;				!READ REGISTER 100
10652		IF (.RCVDATA AND DP_PE) NEQ .I<0,1>^2		!CHK DATA
10653			THEN BEGIN
10654				ERRCAS(1,1,%O'353' OR (.RCVDATA AND %O'20') OR .I<0,1>^2,.RCVDATA,3,ER_TAB);	!NO
10655				TESTR_FLG = 1;
10656			     END;
10657		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
10658			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
10659		0						!TO ILLUMINATE BLISS INFO COMMENT
10660	
10661		END;
10662		MOD_FLD(7,%O'4310');				!MODIFY TO CHCK LEFT HALF OF DBUS
10663		ER_TAB[1] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
10664		DO (0) WHILE
10665	BLOCK2:	BEGIN
10666		CP(2);						!GIVE 2 CLKS
10667		RCVDATA = RD_100;				!GET DATA FROM REGISTER 100
10668		IF (.RCVDATA AND DP_PE) NEQ .I<0,1>^2		!CHECK DATA
10669			THEN BEGIN
10670				ERRCAS(2,1,%O'353' OR (.RCVDATA AND %O'20') OR .I<0,1>^2,.RCVDATA,3,ER_TAB);!NO
10671				TESTL_FLG = 1;
10672			     END;
10673		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
10674			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
10675		0						!TO ILLUMINATE BLISS INFO COMMENT
10676	
10677		END;
10678		END;
10679	!*MESSAGE 1
10680	!*	PARITY LOGIC TEST ON DPE3,4
10681	!*STIMULUS:
10682	!*	OUTPUT A \O0 ON THE \S1 HALF OF THE DBUS
10683	!*	CHECK \S1 HALF OF DBUS PARITY
10684	!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
10685	!*	IT SHOULD BE SET FOR CORRECT EVEN PARITY OUTPUT
10686	!*	AND CLEAR FOR CORRECT ODD PARITY OUTPUT
10687	!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH LO
10688	!*RESPONSE:
10689		DM(0,1000001);					!DEPOSIT A 1 IN MEMORY
10690		DO (0) WHILE
10691	BLOCK3:	BEGIN
10692		SET_C(0);					!SET CRAM ADRS TO 0
10693		CP(4);						!GIVE 4 CLOCKS
10694		RCVDATA = RD_100;				!GET DATA
10695		IF (.RCVDATA AND DP_PE) NEQ 0			!CHECK DATA
10696			THEN BEGIN
10697				ERRCAS(2,2,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10698				TESTL_FLG = 1;
10699			     END;
10700		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
10701			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
10702		0						!TO ILLUMINATE BLISS INFO COMMENT
10703	
10704		END;
10705		LC(2);						!LOAD CRAM ADRS 2
10706		MOD_FLD(7,%O'4304');				!MODIFY TO CHCK RIGHT HALF
10707		ER_TAB[1] = UPLIT (%ASCIZ'RIGHT');		!FOR ERROR PRINTOUT
10708		DO (0) WHILE
10709	BLOCK4:	BEGIN
10710		SET_C(0);					!SET CRAM ADRS TO 0
10711		CP(4);						!GIVE 4 CLOCKS
10712		RCVDATA = RD_100;				!GET DATA
10713		IF (.RCVDATA AND DP_PE) NEQ 0			!CHECK DATA
10714			THEN BEGIN
10715				ERRCAS(1,2,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10716				TESTR_FLG = 1;
10717			     END;
10718		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
10719			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
10720		0						!TO ILLUMINATE BLISS INFO COMMENT
10721	
10722			END;
10723		LC(2);						!LOAD CRAM ADRS 2
10724		MOD_FLD(3,1);					!MODIFY DBUS DATA
10725		MOD_FLD(4,0);					!TO 1
10726		ER_TAB[0] = 1;					!FOR ERROR PRINTOUT
10727		DO (0) WHILE
10728	BLOCK5:	BEGIN
10729		SET_C(0);					!SET CRAM ADRS TO 0
10730		CP(4);						!GIVE 4 CLOCKS
10731		RCVDATA = RD_100;				!GET DATA
10732		IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
10733			THEN BEGIN
10734				ERRCAS(1,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10735				TESTR_FLG = 1;
10736			     END;
10737		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
10738			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
10739		0						!TO ILLUMINATE BLISS INFO COMMENT
10740	
10741		END;
10742		LC(2);						!LOAD CRAM ADRS 2
10743		MOD_FLD(7,%O'4310');				!MODIFY TO CHCK LEFT HALF
10744		ER_TAB[1] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
10745		DO (0) WHILE
10746	BLOCK6:	BEGIN
10747		SET_C(0);					!SET CRAM ADRS TO 0
10748		CP(4);						!GIVE 4 CLOCKS
10749		RCVDATA = RD_100;				!GET DATA
10750		IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
10751			THEN BEGIN
10752				ERRCAS(2,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10753				TESTL_FLG = 1;
10754			     END;
10755		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
10756			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
10757		0						!TO ILLUMINATE BLISS INFO COMMENT
10758	
10759		END;
10760	!*MESSAGE 2
10761	!*	PARITY LOGIC TEST ON DPE3,4
10762	!*STIMULUS:
10763	!*	OUTPUT A \O0 ON THE \S1 HALF OF THE DBUS
10764	!*	CHECK \S1 HALF OF DBUS PARITY
10765	!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
10766	!*	IT SHOULD BE CLEAR FOR CORRECT EVEN PARITY OUTPUT
10767	!*	AND SET FOR CORRECT ODD PARITY OUTPUT
10768	!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH HI
10769	!*RESPONSE:
10770		LC(2);						!LOAD CRAM ADRS 2
10771		MOD_FLD(3,0);					!MODIFY DBUS DATA TO 0
10772		MOD_FLD(7,%O'4314');				!MODIFY TO CHCK BOTH HALFS
10773		DO (0) WHILE
10774	BLOCK7:	BEGIN
10775		SET_C(0);					!SET CRAM ADRS TO 0
10776		CP(4);						!GIVE 4 CLKS
10777		MR();						!CLEAR THE BAD PARITY CONDITION
10778		RCVDATA = RD_100;				!GET DATA
10779		IF .RCVDATA NEQ %O'377'				!CHECK DATA
10780			THEN BEGIN
10781				ERRCAS(3,3,%O'377',.RCVDATA,3,ER_TAB);	!NO
10782				TEST_FLG = 1;
10783			     END;
10784		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
10785			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
10786		0						!TO ILLUMINATE BLISS INFO COMMENT
10787	
10788			END;
10789	!*MESSAGE 3
10790	!*	PARITY LOGIC TEST ON DPE3,4
10791	!*STIMULUS:
10792	!*	OUTPUT A \O0 ON BOTH HALFS OF THE DBUS
10793	!*	CHCK BOTH HALFS OF DBUS PARITY
10794	!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH HI
10795	!*	THIS WILL CAUSE A DP PARITY ERROR
10796	!*	NOW WE DO A MASTER RESET THIS SHOULD CLEAR THE CONDITION
10797	!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
10798	!*RESPONSE:
10799		LC(2);						!LOAD CRAM ADRS 2
10800		MOD_FLD(7,%O'4300');				!MODIFY NOT TO CHK DBUS PARITY
10801		DO (0) WHILE
10802	BLOCK8:	BEGIN
10803		SET_C(0);					!SET CRAM ADRS TO 0
10804		CP(4);						!GIVE 4 CLOCKS
10805		RCVDATA = RD_100;				!GET DATA
10806		IF (.RCVDATA AND DP_PE) NEQ DP_PE		!CHECK DATA
10807			THEN BEGIN
10808				ERRCAS(3,4,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10809				TEST_FLG = 1;
10810			     END;
10811		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
10812			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
10813		0						!TO ILLUMINATE BLISS INFO COMMENT
10814	
10815			END;
10816		IF .TESTR_FLG EQL 0
10817			THEN NOERR(1);
10818		IF .TESTL_FLG EQL 0
10819			THEN NOERR(2);
10820		IF (.TEST_FLG OR .TESTL_FLG OR .TESTR_FLG) EQL 0
10821			THEN NOERR(3);
10822	!*MESSAGE 4
10823	!*	OUTPUT A \O0 ON BOTH HALFS OF THE DBUS
10824	!*	DON'T CHCK  EITHER HALF OF DBUS PARITY
10825	!*	DPE3 & 4 DBUS PAR PROPEGATED FROM MEMORY BUS PARITY ARE BOTH HI
10826	!*	READ 8080 REGISTER 100 AND VERIFY DP PARITY BIT
10827	!*RESPONSE:
10828	!]NO ERROR 1
10829	!]DBUSPER NTWK
10830	!]NO ERROR 2
10831	!]DBUSPEL NTWK
10832	!]NO ERROR 3
10833	!]DBUSPER DBUSPEL PE BCLK NTWK
10834	!]ERROR 1
10835	!]BCLK DBUSPR DBUSPER PE NTWK
10836	!]ERROR 2
10837	!]BCLK DBUSPL DBUSPEL PE NTWK
10838	!]ERROR 3
10839	!]BCLK PE NTWK
10840		END;
10841	
10842	GLOBAL ROUTINE TST50: NOVALUE =
10843	
10844	!THIS TEST CHECKS THE DP PARITY IMPLEMENT RAM ON DPE4.
10845	!THIS TEST WILL EXECUTE 2 INSTRUCTIONS IN CRAM 1 & 2 :
10846	!CRAM 1/ WRITE INTO THE 2901'S A DATA WORD PASSED THROUGH FROM THE MAGIC
10847	!	 # FIELD VIA DBUS AND DBM. GENERATE  AND STOR L/R OF THE DP PARITY.
10848	!CRAM 2/ PASS A 0 FROM THE 2901'S INTO DBUS AND CHECK L/R OF THE DBUS 
10849	!	 PARITY.(THIS INSTRUCTION IS EXECUTED TWICE IN ORDER TO ALLOW 
10850	!	 THE PARITY ERROR TO PROPEGATE THROUGH TO THE 8080'S REGISTER 100).
10851	!AFTER EXECUTING THOSE 2 INSTRUCTION WE EXAMINE REGISTER 100 AND VERIFY
10852	!THE DP PARITY BIT SET OR CLEAR.
10853	!ALSO AFTER EACH EXECUTION WE MODIFY FIELDS IN BOTH MICROWORDS TO 
10854	!SELECT A DIFFERENT DATA WORD FOR ODD AND EVEN PARITY, SELECT THE NEXT 
10855	!DP B ADRS, ENABLE OR DISABLE THE PARITY CHECKS ON THE DP AS WELL AS THE
10856	!DBUS FOR TESTING EACH HALF SEPERATLY.
10857	
10858		BEGIN
10859		OWN PEFLG,TEST_FLG;
10860		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4,
10861		      BLOCK5,BLOCK6,BLOCK7,BLOCK8;
10862		BIND
10863		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_GENR U_GENL U_N(1) U,
10864				U_J(2) U_CHKL U);
10865	
10866		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
10867		PEFLG = 0;					!CLEAR THIS FLAG
10868		TEST_FLG = 0;
10869		MR();						!CLEAR PARITY REGISTER
10870		ER_TAB[0] = UPLIT (%ASCIZ'LEFT');		!FOR ERROR PRINTOUT
10871		INCR I FROM 0 TO 15 DO
10872		    BEGIN
10873			ER_TAB[1] = .I;				!FOR ERROR PRINTOUT
10874			LC(2);					!LOAD CRAM ADRS 2
10875			MOD_FLD(6,%O'2000' OR .I);		!MODIFY B FIELD
10876			LC(1);					!SET CRAM ADRS TO 1
10877			MOD_FLD(4,%O'1400');			!ENABLE DP PARITY
10878			MOD_FLD(6,%O'6000' OR .I);		!MODIFY B FIELD
10879			DO (0) WHILE
10880	BLOCK1:		    BEGIN
10881				CP(3);				!GIVE 3 CLOCKS
10882				RCVDATA = RD_100;		!READ REGISTER 100
10883				IF (.RCVDATA AND DP_PE) NEQ 0	!CHECK DATA
10884				    THEN BEGIN
10885						ERRCAS(2,1,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10886						TEST_FLG = 1;
10887					  END;
10888				IF LOOP_CHK(1)			!IS LOOP ON ERROR SET ?
10889				THEN 
10890				    BEGIN
10891				    SET_C(1);			!SET CRAM ADRS TO 1
10892				    LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
10893				    END;
10894				0				!TO ILLUMINATE BLISS INFO COMMENT
10895			    END;
10896			MOD_FLD(3,0);				!CHANGE DATA TO 0
10897			DO (0) WHILE
10898	BLOCK2:		    BEGIN
10899				CP(3);				!GIVE 3 CLOCKS
10900				RCVDATA = RD_100;		!READ REGISTER 100
10901				IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
10902				    THEN BEGIN
10903						ERRCAS(2,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10904						TEST_FLG = 1;
10905					  END;
10906				IF LOOP_CHK(2)			!IS LOOP ON ERROR SET ?
10907				THEN
10908				    BEGIN
10909				    SET_C(1);			!SET CRAM ADRS TO 1
10910				    LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
10911				    END;
10912				0				!TO ILLUMINATE BLISS INFO COMMENT
10913			    END;
10914			LC(2);					!LOAD CRAM ADRS 2
10915			MOD_FLD(7,%O'4304');			!MODIFY TO CHK RIGHT HALF OF DBUS
10916			ER_TAB[0] = UPLIT (%ASCIZ'RIGHT');	!FOR ERROR PRINTOUT
10917			DO (0) WHILE
10918	BLOCK3:		    BEGIN
10919				SET_C(1);			!SET CRAM ADRS TO 1
10920				CP(3);				!GIVE 3 CLOCKS
10921				RCVDATA = RD_100;		!READ REGISTER 100
10922				IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
10923				    THEN BEGIN
10924						ERRCAS(1,2,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10925						TEST_FLG = 1;
10926					  END;
10927				IF LOOP_CHK(3)			!IS LOOP ON ERROR SET ?
10928				    THEN LEAVE BLOCK3 WITH 1;	!LEAVE BLOCK TO LOOP
10929		0						!TO ILLUMINATE BLISS INFO COMMENT
10930	
10931			    END;
10932			MOD_FLD(3,1);				!CHANGE DATA TO ODD PAR
10933			DO (0) WHILE
10934	BLOCK4:		    BEGIN
10935				CP(3);				!GIVE 3 CLOCKS
10936				RCVDATA = RD_100;		!READ REGISTER 100
10937				IF (.RCVDATA AND DP_PE) NEQ 0	!CHECK DATA
10938				    THEN BEGIN
10939						ERRCAS(1,1,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10940						TEST_FLG = 1;
10941					  END;
10942				IF LOOP_CHK(4)			!IS LOOP ON ERROR SET ?
10943				THEN
10944				    BEGIN
10945				    SET_C(1);			!SET CRAM ADRS TO 1
10946				    LEAVE BLOCK4 WITH 1;	!LEAVE BLOCK TO LOOP
10947				    END;
10948				0				!TO ILLUMINATE BLISS INFO COMMENT
10949			    END;
10950			MOD_FLD(4,0);				!DISABLE BOTH HALFS OF DP PARITY
10951			DO (0) WHILE
10952	BLOCK5:		    BEGIN
10953				CP(3);				!GIVE 3 CLOCKS
10954				RCVDATA = RD_100;		!READ REGISTER 100
10955				IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
10956				    THEN BEGIN
10957						ERRCAS(3,3,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10958						TEST_FLG = 1;
10959					  END;
10960				IF LOOP_CHK(5)			!IS LOOP ON ERROR SET ?
10961				THEN
10962				    BEGIN
10963				    SET_C(1);			!SET CRAM ADRS TO 1
10964				    LEAVE BLOCK5 WITH 1;	!LEAVE BLOCK TO LOOP
10965				    END;
10966				0				!TO ILLUMINATE BLISS INFO COMMENT
10967			    END;
10968			LC(2);					!LOAD CRAM ADRS 2
10969			MOD_FLD(7,%O'4310');			!MODIFY TO CHK LEFT HALF OF DBUS
10970			ER_TAB[0] = UPLIT (%ASCIZ'LEFT');	!FOR ERROR PRINTOUT
10971			DO (0) WHILE
10972	BLOCK6:		    BEGIN
10973				SET_C(1);			!SET CRAM ADRS TO 1
10974				CP(3);				!GIVE 3 CLOCKS
10975				RCVDATA = RD_100;		!READ REGISTER 100
10976				IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
10977				    THEN BEGIN
10978						ERRCAS(4,3,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
10979						TEST_FLG = 1;
10980					  END;
10981				IF LOOP_CHK(6)			!IS LOOP ON ERROR SET ?
10982				    THEN LEAVE BLOCK6 WITH 1;	!LEAVE BLOCK TO LOOP
10983		0						!TO ILLUMINATE BLISS INFO COMMENT
10984	
10985			    END;
10986		    END;
10987		IF .TEST_FLG EQL 0
10988			THEN NOERR(1);
10989	!*MESSAGE 1
10990	!*	DP PARITY TEST
10991	!*STIMULUS:
10992	!*	WRITE INTO THE 2901'S SELECTING DEST = 1, WITH PARITY ODD 
10993	!*	HI FOR BOTH HALFS. ENABLE BOTH HALFS OF DP PARITY.DP B ADRS = \O1
10994	!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALF
10995	!*	OF DBUS PARITY.THIS WILL FORCE A BAD PARITY ON \S0 HALF.
10996	!*	EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
10997	!*RESPONSE:
10998	!*	EXAMINE NXT CRAM ADRS
10999	
11000	!*MESSAGE 2
11001	!*	DP PARITY TEST
11002	!*STIMULUS:
11003	!*	WRITE INTO THE 2901'S SELECTING DEST = 1, WITH PARITY ODD 
11004	!*	LO FOR BOTH HALFS. ENABLE BOTH HALFS OF DP PARITY.DP B ADRS = \O1
11005	!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALF
11006	!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
11007	!*RESPONSE:
11008	!*	EXAMINE NXT CRAM ADRS
11009	
11010	!*MESSAGE 3
11011	!*	DP PARITY TEST
11012	!*STIMULUS:
11013	!*	WRITE INTO THE 2901'S SELECTING DEST = 1, WITH PARITY ODD 
11014	!*	HI FOR BOTH HALFS. DISABLE BOTH HALFS OF DP PARITY.DP B ADRS = \O1
11015	!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALF
11016	!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
11017	!*RESPONSE:
11018	!*	EXAMINE NXT CRAM ADRS
11019	!]NO ERROR 1
11020	!]DPPE NTWK
11021	!]ERROR 1
11022	!]DPDBUS BCLK PE DBUSPER DBUSPR PWRITE DPPE NTWK
11023	!]ERROR 2
11024	!]DPDBUS BCLK PE DBUSPEL DBUSPL PWRITE DPPE NTWK
11025	!]ERROR 3
11026	!]DPDBUS DPPE PE DBUSPR BCLK PWRITE NTWK
11027	!]ERROR 4
11028	!]DPDBUS DPPE PE DBUSPL BCLK PWRITE NTWK
11029		LC(2);						!LOAD CRAM ADRS 2
11030		MOD_FLD(7,%O'4314');				!MODIFY TO CHK BOTH HALFS OF DBUS
11031		ER_TAB[0] = UPLIT (%ASCIZ'BOTH');		!FOR ERROR PRINTOUT
11032		LC(1);						!LOAD CRAM ADRS 1
11033		MOD_FLD(7,%O'4700');				!USE DEST = 7
11034		MOD_FLD(4,%O'1400');				!ENABLE BOTH HALFS OF DP PARITY
11035		DO (0) WHILE
11036	BLOCK7:	    BEGIN
11037			CP(3);					!GIVE 3 CLOCKS
11038			RCVDATA = RD_100;			!READ REGISTER 100
11039			IF (.RCVDATA AND DP_PE) NEQ 0		!CHECK DATA
11040			    THEN BEGIN
11041					ERRCAS(5,4,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
11042					PEFLG = 1;
11043				 END;
11044			IF LOOP_CHK(7)				!IS LOOP ON ERROR SET ?
11045			THEN
11046			    BEGIN
11047			    SET_C(1);				!SET CRAM ADRS TO 1
11048			    LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
11049			    END;
11050			0					!TO ILLUMINATE BLISS INFO COMMENT
11051		    END;
11052	!*MESSAGE 4
11053	!*	DP PARITY TEST
11054	!*STIMULUS:
11055	!*	WRITE INTO THE 2901'S SELECTING DEST = 7, WITH PARITY ODD 
11056	!*	HI FOR BOTH HALFS. ENABLE BOTH HALFS OF DP PARITY.
11057	!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALFS
11058	!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
11059	!*RESPONSE:
11060	!*	EXAMINE NXT CRAM ADRS
11061	!]ERROR 5
11062	!]PWRITE PE BCLK DPPE NTWK
11063		MOD_FLD(7,%O'4300');				!SELECT DEST 3
11064		MOD_FLD(3,0);					!ODD PAR IS LO
11065		IF .PEFLG EQL 0 THEN
11066		DO (0) WHILE
11067	BLOCK8:	    BEGIN
11068			CP(3);					!GIVE 3 CLOCKS
11069			RCVDATA = RD_100;			!READ REGISTER 100
11070			IF (.RCVDATA AND DP_PE) NEQ 0		!CHECK DATA
11071			    THEN ERRCAS(6,5,%O'353' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB)	!NO
11072			    ELSE IF .TEST_FLG EQL 0
11073				THEN NOERR(2);
11074			IF LOOP_CHK(8)				!IS LOOP ON ERROR SET ?
11075			THEN
11076			    BEGIN
11077			    SET_C(1);				!SET CRAM ADRS TO 1
11078			    LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
11079			    END;
11080			0					!TO ILLUMINATE BLISS INFO COMMENT
11081		    END;
11082	!*MESSAGE 5
11083	!*	DP PARITY TEST
11084	!*STIMULUS:
11085	!*	WRITE INTO THE 2901'S SELECTING DEST = 3, WITH PARITY ODD 
11086	!*	HI FOR BOTH HALFS.DPE5 WRITE PARITY SHOULD BE HI. PARITY SHOULD 
11087	!*	NOT CHANGE IN THE RAM.
11088	!*	THEN OUTPUT 0 ON DP, PASS IT THROUGH THE DBUS CHK \S0 HALFS
11089	!*	OF DBUS PARITY.EXAMINE THE 8080 REGISTER 100 AND VERIFY DP PARITY BIT.
11090	!*RESPONSE:
11091	!*	EXAMINE NXT CRAM ADRS
11092	!]NO ERROR 2
11093	!]PWRITE NTWK
11094	!]ERROR 6
11095	!]PWRITE NTWK
11096		END;
11097	
11098	GLOBAL ROUTINE TST51: NOVALUE =
11099	
11100	!THIS TEST CHECKS THE RAMFILE ON DPE7 & 8.(EXCEPT RAMFILE PARITY CHIPS).
11101	!IT SELECTS THE RAMFILE ADRS FROM THE VMA WHICH GETS LOADED FROM THE 
11102	!Q REGISTER OF THE 2901'S. THE Q REGISTER IS INCREMENTED BY 1 EACH TIME 
11103	!WE GO THROUGH THE LOOP TO SELECT THE NXT RAMFILE ADRS.
11104	!THE DATA IS WRITTEN INTO THE RAMFILE FROM THE MAGIC # FIELD VIA DBM & DBUS.
11105	!THE DATA IS VERIFIED BY PASSING THE CONTENTS OF THE RAMFILE ADRS POINTED
11106	!TO BY THE VMA THROUGH THE 2901'S AND SKIP IF THE OUTPUT OF THE 2901'S 
11107	!CONTAINS THE CORRECT DATA.
11108	!WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP TO THE CORRECT LOCATION.
11109	!IN CASE OF AN ERROR THE CRAM ADRS IS RESET TO LOCATION 1 AND FEILDS 
11110	!ARE MODIFIED IN ORDER TO WRITE THE CONTENTS OF THE RAMFILE OUT TO THE 
11111	!MEMORY LOCATION POINTED TO BY THE VMA WHICH IS THE SAME AS RAMFILE ADRS 
11112	!UNDER TEST. WE EXAMINE THE CORRESPONDING MEM LOCATION AND PASS IT AS 
11113	!AN ACTUAL DATA FRO THE ERROR PRINTOUT.
11114	!NOTE:	(THIS TEST WILL TAKE APRX. 5 MIN TO PASS. IT WILL NOT ALOW 
11115	!	SINGLE STEP EXCEPT IN CASE OF AN ERROR).
11116	
11117		BEGIN
11118		OWN RAMFLG,TEST_FLG;
11119		LABEL BLOCK1,BLOCK2;
11120		BIND
11121		POINTER = PLIT (U_J(1) U_ALU_ADD U_LSRC_DQ U_DBUS_DBM U_DEST_Q_AD U_SPEC_MEMCLR U_N(1) U,
11122				U_J(2) U_ALU_OR U_LSRC_0Q U_MEM U_N(11012) U,
11123				U_J(3) U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U,
11124				U_J(4) U_ALU_OR U_LSRC_D0 U_RAM_RAM U_DBUS_RAM U_SKIP_ADEQ0 U_MEM U_N(11002) U,
11125				U_J(1) U_ALU_OR U_LSRC_D0 U_RAM_RAM U_DBUS_RAM U_MEM U_N(2) U,
11126				U_J(6) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U_N(777777) U,
11127				U_J(4) U_ALU_XOR U_LSRC_DA U_A_T1 U_RAM_RAM U_DBUS_RAM U_SKIP_ADEQ0 U_MEM U_N(11002) U,
11128				U_J(7) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(777777) U);
11129		IF .RAMFILE_FLAG NEQ 0
11130			THEN RETURN;
11131		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11132		SET_C(7);					!SET CRAM ADRS TO 7
11133		TEST_FLG = 0;
11134		RAMFLG = 0;
11135		CP_NOSS(2);					!GIVE 2 CLKS TO LOAD THE ADRS COUNTER INTO THE Q REGISTER
11136		INCR I FROM 0 TO 1023 DO			!0 TO 1777 OCTAL
11137		    BEGIN
11138			ER_TAB[0]  = .I;			!FOR ERROR PRINTOUT
11139			SET_C(0);				!SET CRAM ADRS TO 0
11140			CP_NOSS(4);				!DON'T SINGLE STEP THE NXT 4 CLKS
11141			RCVDATA = EX_NXT;			!GET THE NXT CRAM ADRS
11142			IF .RCVDATA NEQ 5			!IS IT = TO 5 ?
11143			THEN 					!NO, THEN WE HAVE AN ERROR
11144			    BEGIN
11145				SET_C(1);			!SET CRAM ADRS TO 1
11146				DO (0) WHILE
11147	BLOCK1:			    BEGIN
11148					ER_TAB[1] = 0;		!FOR ERROR PRINTOUT
11149					CP(4);			!GIVE 4 CLOCKS
11150					TEST_FLG = 1;
11151					RCVDATA = MEM_EXAMINE(.I);	!GET DATA FROM MEM
11152					ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);   !CALL THE ERROR ROUTINE
11153					RAMFLG = 1;
11154					IF LOOP_CHK(1)		!IS LOOP ON ERROR SET ?
11155					    THEN LEAVE BLOCK1 WITH 1	!LEAVE BLOCK TO LOOP
11156					ELSE
11157					   MOD_FLD(0,5);		!MODIFY J FIELD TO GO TO 5
11158				    0
11159				    END;
11160			    END;
11161			IF .RAMFLG EQL 0 			!DID WE JUST GET AN ERROR ?
11162			    THEN CP_NOSS(2)			!NO, PROCEED NORMALLY
11163			ELSE
11164			    CP_NOSS(3);				!YES, THEN GIVE 3 CLKS
11165			RCVDATA = EX_NXT;			!GET NXT CRAM ADRS
11166			IF .RAMFLG NEQ 0 			!AGAIN, DID WE JUST GET AN ERROR
11167			    THEN MOD_FLD(0,2);			!YES, THEN REMODIFY THIS FIELD
11168			IF .RCVDATA NEQ 5			!IS THE NXT CRAM ADRS CORCT
11169			THEN					!NO, WE HAVE AN ERROR
11170			    BEGIN
11171				LC(1);				!LOAD CRAM ADRS 1
11172				MOD_FLD(0,5);			!MODIFY J FIELD
11173				DO (0) WHILE
11174	BLOCK2:			    BEGIN
11175					ER_TAB[1] = %O'-1';	!FOR ERROR PRINTOUT
11176					TEST_FLG = 1;
11177					CP(4);			!GIVE 4 CLKS
11178					RCVDATA = MEM_EXAMINE(.I);	!GET DATA FROM MEMORY
11179					ERRCAS(1,1,%O'-1',.RCVDATA,12,ER_TAB);!CALL ERROR ROUTINE
11180					IF LOOP_CHK(2)		!IS LOOP ON ERROR SET ?
11181					    THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
11182				    0
11183				    END;
11184				MOD_FLD(0,2);			!REMODIFY THIS FIELD BEFOR WE EXIT THE ERROR PROCESS
11185			    END;
11186			RAMFLG = 0;				!CLEAR THE ERROR FLAG WE ARE LOOPING TO A NEW ADRS
11187		    END;
11188		IF .TEST_FLG EQL 0
11189			THEN NOERR (1);
11190		LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
11191	!*MESSAGE 1
11192	!*STIMULUS:
11193	!*	LOAD THE VMA WITH RAMFILE ADRS \O0 FROM THE 2901'S Q REGISTER
11194	!*	WRITE A \O1 INTO RAMFILE ADRS SELECTED BY THE VMA
11195	!*	START A PHYSICAL MEM WRITE CYCLE
11196	!*	OUTPUT THE CONTENTS OF THE RAMFILE INTO MEM
11197	!*	(BOTH RAMFILE AND PHYSICAL MEM ADRS'S ARE SELECTED BY THE VMA = \O0)
11198	!*	EXAMINE THE SELECTED MEM LOCATION \O0 AND VERIFY DATA
11199	!*RESPONSE:
11200	!]ERROR 1
11201	!]ADEQ0 RAMDBUS RAMWRITE RAM BCLK NTWK
11202	!]NO ERROR 1
11203	!]RAMWRITE BCLK RAMDBUS RAM NTWK
11204		END;
11205	
11206	GLOBAL ROUTINE TST52: NOVALUE =
11207	
11208	!THIS TEST CHECKS THE TWO RAMFILE PARITY CHIPS .
11209	!THIS TEST WILL EXECUTE INSTRUCTIONS THAT WILL WRITE INTO THE RAMFILE
11210	!A DATA WORD GENERATING ODD PARITY HI/LO TO BE STORED IN THE RAMFILE.
11211	!THEN IT READS BACK THE RAMFILE INTO THE DBUS AND CHECK BOTHE HALFS 
11212	!FOR PARITY. IF THE PARITY CHIPS ARE IN FAULT A PARITY ERROR WILL EXIST 
11213	!IN THE 8080'S REGISTER 100. WE EXAMINE THAT REGISTER AND VERIFY IT.
11214	!THE RAMFILE ADRS IS SUPPLIED BY THE VMA WHICH GETS LOADED FROM THE Q
11215	!REGISTER OF THE 2901'S.
11216	!THE INSTRUCTIONS IN THE CRAM WILL DO THE FOLLOWING:
11217	!CRAM 0/ INCRAMENT THE Q REGISTER.
11218	!CRAM 1/ OUPTUT THE Q REGISTER ONTO DP AND LOAD THE VMA FROM DP.
11219	!CRAM 2/ PASS A 0 FROM THE MAGIC # FIELD INTO THE DBUS AND WRITE IT 
11220	!	 IN THE RAMFILE ADRS SELECTED BY THE VMA.
11221	!CRAM 3/ READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY THE VMA 
11222	!	 INTO THE DBUS AND CHECK BOTH HALFS OF THE DBUS FOR PARITY.
11223	!	 (THIS INSTRUCTION IS EXECUTED TWICE).
11224	!CRAM 4/ OUPTUT THE Q REGISTER ONTO DP AND LOAD THE VMA FROM DP.
11225	!CRAM 5/ PASS A 1 FROM THE MAGIC # FIELD INTO THE DBUS AND WRITE IT 
11226	!	 IN THE RAMFILE ADRS SELECTED BY THE VMA.
11227	!CRAM 6/ READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY THE VMA 
11228	!	 INTO THE DBUS AND CHECK BOTH HALFS OF THE DBUS FOR PARITY.
11229	!	 (THIS INSTRUCTION IS EXECUTED TWICE).
11230	!AFTER THE EXECUTION OF EACH 3 INSTRUCTIONS (1,2&3) (4,5&6) WE EXAMINE
11231	!REGITER 100 AND VERIFY DP PARITY BIT.
11232	!NOTE:	(THIS TEST WILL TAKE APRX. 5 MIN TO PASS).
11233	
11234		BEGIN
11235		OWN TEST_FLG;
11236		LABEL BLOCK1,BLOCK2;
11237		BIND
11238		POINTER = PLIT (U_J(1) U_ALU_ADD U_LSRC_DQ U_DBUS_DBM U_DEST_Q_AD U_SPEC_MEMCLR U_N(1) U,
11239				U_J(2) U_ALU_OR U_LSRC_0Q U_MEM U_N(11012) U,
11240				U_J(3) U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U,
11241				U_J(3) U_RAM_RAM U_DBUS_RAM U_CHKL U_CHKR U,
11242				U_J(5) U_ALU_OR U_LSRC_0Q U_MEM U_N(11012) U,
11243				U_J(6) U_RAM_RAM U_DBUS_DBM U_SPEC_MEMCLR U_FMWRITE U_N(1) U,
11244				U_J(6) U_RAM_RAM U_DBUS_RAM U_CHKL U_CHKR U,
11245				U_J(7) U_ALU_OR U_LSRC_D0 U_DEST_Q_AD U_DBUS_DBM U_N(777777) U);
11246	
11247		IF .RAMFILE_FLAG NEQ 0
11248			THEN RETURN;
11249	
11250		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11251		SET_C(7);					!SET CRAM ADRS TO 7
11252		CP_NOSS(2);					!LOAD THE ADRS COUNTER IN THE Q REGISTER
11253		TEST_FLG = 0;
11254		INCR I FROM 0 TO 1023 DO
11255		    BEGIN
11256			ER_TAB[0] = .I;				!FOR ERROR PRINTOUT
11257			ER_TAB[1] = UPLIT (%ASCIZ'LO');		!FOR ERROR PRINTOUT
11258			SET_C(0);				!SET CRAM ADRS TO 0
11259			CP_NOSS(1);				!INCREMENT COUNTER
11260			DO (0) WHILE
11261	BLOCK1:		    BEGIN
11262				CP(4);				!GIVE 4 CLOCKS
11263				RCVDATA = RD_100;		!GET THE DATA
11264				IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
11265				    THEN BEGIN
11266						ERRCAS(1,1,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
11267						TEST_FLG = 1;
11268					 END;
11269				IF LOOP_CHK(1)			!IS LOOP ON ERROR SET ?
11270				THEN 
11271				    BEGIN
11272					SET_C(1);		!SET CRAM ADRS TO 1
11273					LEAVE BLOCK1 WITH 1;	!LEAVE BLOCK TO LOOP
11274				    END;
11275				0				!TO ILLUMINATE BLISS INFO COMMENT
11276			    END;
11277			ER_TAB[1] = UPLIT (%ASCIZ'HI');		!FOR ERROR PRINTOUT
11278			DO (0) WHILE
11279	BLOCK2:		    BEGIN
11280				SET_C(4);			!SET CRAM ADRS TO 4
11281				CP(4);				!GIVE 4 CLOCKS
11282				RCVDATA = RD_100;		!GET DATA
11283				IF (.RCVDATA AND DP_PE) NEQ DP_PE	!CHECK DATA
11284				    THEN BEGIN
11285						ERRCAS(1,1,%O'357' OR (.RCVDATA AND %O'20'),.RCVDATA,3,ER_TAB);	!NO
11286						TEST_FLG = 1;
11287					  END;
11288				IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
11289				    THEN LEAVE BLOCK2 WITH 1;	!LEAVE BLOCK TO LOOP
11290		0						!TO ILLUMINATE BLISS INFO COMMENT
11291	
11292			    END;
11293		    END;
11294		IF .TEST_FLG EQL 0
11295			THEN NOERR(1);
11296	!*MESSAGE 1
11297	!*	RAMFILE PARITY TEST
11298	!*STIMULUS:
11299	!*	LOAD THE VMA WITH RAMFILE ADRS \O0 FROM THE 2901'S Q REGISTER
11300	!*	WRITE INTO THE RAMFILE ADRS POINTED TO BY THE VMA
11301	!*	A DATA WORD TO GENERATE BOTH HALFS OF PARITY \S1 .
11302	!*	OUTPUT THE CONTENTS OF THE RAMFILE THROUGH THE DBUS
11303	!*	AND CHECK BOTH HALFS OF THE DBUS PARITY.
11304	!*	EXAMINE THE 8080'S REGISTER 100 AND VERIFY DP PPARITY BIT.
11305	!*RESPONSE:
11306	!]ERROR 1
11307	!]RAM RAMDBUS RAMPAR RAMADRS RAMSEL RAMWRITE DBUSPEL DBUSPER DBUSPL DBUSPR PE BCLK NTWK
11308	!]NO ERROR 1
11309	!]BCLK RAMWRITE RAMPAR NTWK
11310		LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
11311		END;
11312	
11313	GLOBAL ROUTINE TST53: NOVALUE =
11314	
11315	!THIS TEST CHECKS THE OUTPUT OF THE RAMFILE ADRS LOGIC FOR STUCK HI.
11316	!THIS TEST WILL DO THE FOLLOWING:
11317	!	1) WRITE A ZERO INTO RAMFILE LOCATION 1777.
11318	!	2) WRITE A -1 INTO RAMFILE LOCATION (FLOAT A 0 ACROSS 1777).
11319	!	3) READ BACK RAMFILE LOCATION 1777 AND VERIFY THAT IT DID NOT CHANGE
11320	!THIS TEST WILL EXECUTE THE FOLLOWING INSTRUCTIONS:
11321	!CRAM 0/ PUT THE (1777 WITH A ZERO FLOATING ACROSS) IN 2901'S.
11322	!CRAM 1/ LOAD THE VMA WITH A 1777
11323	!CRAM 2/ WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA.
11324	!CRAM 3/ LOAD THE VMA WITH THE TESTED BIT DATA FROM THE 2901'S
11325	!CRAM 4/ WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA.
11326	!CRAM 5/ LOAD THE VMA WITH A 1777.
11327	!CRAM 6/ READ THE RAMFILE LOCATION POINTED TO BY THE VMA AND SKIP IF 
11328	!	 ITS 0 (THE CURRENT J FIELD IS 0).
11329	!WE READ THE NEXT CRAM ADRS AND VERIFY THAT IT DID SKIP TO CRAM 1 IF
11330	!NO ERROR. AFTER EACH EXECUTION, THE # FIELD IS MODIFIED IN CRAM 0 TO 
11331	!SET UP THE DATA FOR THE NXT RAMFILE ADRS BIT.
11332	
11333		BEGIN
11334		LABEL BLOCK1;
11335		BIND
11336		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_B_PC U,
11337				U_J(2) U_ALU_OR U_A_HR U_MEM U_N(11012) U,
11338				U_J(3) U_SPEC_MEMCLR U_DEST_AD U_RAM_RAM U_FMWRITE U,
11339				U_J(4) U_ALU_OR U_A_PC U_MEM U_N(11012) U,
11340				U_J(5) U_SPEC_MEMCLR U_ALU_XNOR U_RAM_RAM U_FMWRITE U,
11341				U_J(6) U_ALU_OR U_A_HR U_MEM U_N(11012) U,
11342				U_ALU_OR U_LSRC_D0 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U,
11343				U_J(7) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_NO_CLKL U_N(1777) U);
11344	
11345		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11346		SET_C(7);					!SET CRAM ADRS TO 7
11347		CP_NOSS(2);					!GIVE 2 CLKS
11348		SET_C(0);					!SET CRAM ADRS TO 0
11349		INCR I FROM 0 TO 9 DO
11350		BEGIN
11351			MOD_FLD(3,%O'1777' XOR (1^.I));		!MODIFY THIS FIELD
11352		ER_TAB[0] = %O'1777' XOR (1^.I);		!FOR ERROR PRINTOUT
11353		ER_TAB[1] = 9-.I;					!HERE TOO
11354		DO (0) WHILE
11355	BLOCK1:	BEGIN
11356		RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLK & GET NXT CRAM ADRS
11357		IF .RCVDATA NEQ 1				!CHECK DATA
11358			THEN BEGIN
11359				ERRS(1,1,ER_TAB);		!NO
11360				ADRSFLG = 1;
11361			     END
11362			ELSE TEST53_FLG = 0;
11363		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11364			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
11365		0						!TO ILLUMINATE BLISS INFO COMMENT
11366	
11367			END;
11368	
11369		    END;
11370	!*MESSAGE 1
11371	!*	RAMFILE ADRS TEST
11372	!*STIMULUS:
11373	!*	LOAD THE VMA WITH A 1777
11374	!*	WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA
11375	!*	LOAD THE VMA WITH A \O0
11376	!*	WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA
11377	!*	LOAD THE VMA BACK WITH A 1777
11378	!*	READ THE CONTENTS OF THE RAMFILE POINTED TO BY THE VMA 
11379	!*	AND VERIFY THAT IT DID NOT CHANGE
11380	!*RESPONSE:
11381	!*	RAMFILE CONTENTS DID CHANGE
11382	!*	BIT 0\D1 OF RAMFILE ADRS IS STUCK HI
11383	!]ERROR 1
11384	!]ADEQ0 RAM RAMADRS RAMSEL RAMDBUS TBVMACPY RAMWRITE BCLK NTWK
11385		END;
11386	
11387	GLOBAL ROUTINE TST54: NOVALUE =
11388	
11389	!THIS TEST CHECKS THE OUTPUT OF THE RAMFILE ADRS LOGIC FOR STUCK LO.
11390	!THIS TEST WILL DO THE FOLLOWING:
11391	!	1) WRITE A ZERO INTO RAMFILE LOCATION 0.
11392	!	2) WRITE A -1 INTO RAMFILE LOCATION (FLOAT A 1).
11393	!	3) READ BACK RAMFILE LOCATION 0 AND VERIFY THAT IT DID NOT CHANGE
11394	!THIS TEST WILL EXECUTE THE FOLLOWING INSTRUCTIONS:
11395	!CRAM 0/ PUT THE (A 1 FLOATING CROSS THE RAMFILE ADRS) IN 2901'S.
11396	!CRAM 1/ LOAD THE VMA WITH A 0
11397	!CRAM 2/ WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA.
11398	!CRAM 3/ LOAD THE VMA WITH THE TESTED BIT DATA FROM THE 2901'S
11399	!CRAM 4/ WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA.
11400	!CRAM 5/ LOAD THE VMA WITH A 0.
11401	!CRAM 6/ READ THE RAMFILE LOCATION POINTED TO BY THE VMA AND SKIP IF 
11402	!	 ITS 0 (THE CURRENT J FIELD IS 0).
11403	!WE READ THE NEXT CRAM ADRS AND VERIFY THAT IT DID SKIP TO CRAM 1 IF
11404	!NO ERROR. AFTER EACH EXECUTION, THE # FIELD IS MODIFIED IN CRAM 0 TO 
11405	!SET UP THE DATA FOR THE NXT RAMFILE ADRS BIT.
11406	
11407		BEGIN
11408		LABEL BLOCK1;
11409		BIND
11410		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_B_PC U,
11411				U_J(2) U_DEST_AD U_MEM U_N(11012) U,
11412				U_J(3) U_SPEC_MEMCLR U_RAM_RAM U_FMWRITE U,
11413				U_J(4) U_ALU_OR U_A_PC U_MEM U_N(11012) U,
11414				U_J(5) U_SPEC_MEMCLR U_ALU_XNOR U_RAM_RAM U_FMWRITE U,
11415				U_J(6) U_MEM U_N(11012) U,
11416				U_ALU_OR U_LSRC_D0 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
11417	
11418		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11419		SET_C(0);					!SET CRAM ADRS TO 0
11420		INCR I FROM 0 TO 9 DO
11421		BEGIN
11422			MOD_FLD(3,1^.I);			!MODIFY THIS FIELD
11423		ER_TAB[0] = (1^.I);				!FOR ERROR PRINTOUT
11424		ER_TAB[1] = 9-.I;					!HERE TOO
11425		DO (0) WHILE
11426	BLOCK1:	BEGIN
11427		RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLK & GET NXT CRAM ADRS
11428		IF .RCVDATA NEQ 1				!CHECK DATA
11429			THEN BEGIN
11430				ERRS(1,1,ER_TAB);		!NO
11431				ADRSFLG = 1;
11432			     END
11433			ELSE TEST54_FLG = 0;
11434		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11435			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
11436		0						!TO ILLUMINATE BLISS INFO COMMENT
11437	
11438			END;
11439	
11440		    END;
11441	!*MESSAGE 1
11442	!*	RAMFILE ADRS TEST
11443	!*STIMULUS:
11444	!*	LOAD THE VMA WITH A ZERO
11445	!*	WRITE A ZERO INTO RAMFILE LOCATION POINTED TO BY THE VMA
11446	!*	LOAD THE VMA WITH A \O0
11447	!*	WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY THE VMA
11448	!*	LOAD THE VMA BACK WITH A ZERO
11449	!*	READ THE CONTENTS OF THE RAMFILE POINTED TO BY THE VMA 
11450	!*	AND VERIFY THAT IT DID NOT CHANGE
11451	!*RESPONSE:
11452	!*	RAMFILE CONTENTS DID CHANGE
11453	!*	BIT 0\D1 OF RAMFILE ADRS IS STUCK LO
11454	!]ERROR 1
11455	!]ADEQ0 RAM RAMADRS RAMSEL RAMDBUS TBVMACPY RAMWRITE BCLK NTWK
11456		END;
11457	
11458	GLOBAL ROUTINE TST55: NOVALUE =
11459	
11460	!THIS TEST CHECKS THE RAMFILE ADRS SELECT 0 .
11461	!THIS TEST WILL DO THE FOLLOWING:
11462	!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
11463	!	   (RAMFILE SELECT = 6).
11464	!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY DPE5 CURRENT
11465	!	   AC BLOCKS AND DPEA AC (RAMFILE ADRS SELECT = 0).
11466	!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
11467	!	   THE VMA (RAMFILE SELECT = 6) AND VERIFY IT DID CHANGE TO -1.
11468	!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 6:
11469	!CRAM 0/ LOAD THE CURRENT BLOCK FROM THE MAGIC # FIELD VIA DBUS & DP
11470	!CRAM 1/ LOAD THE IR (DPEA AC) FROM THE MAGIC # FIELD VIA DBUS & DP
11471	!CRAM 2/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
11472	!	 0 OF THE 2901'S.
11473	!CRAM 3/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
11474	!CRAM 4/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
11475	!CRAM 5/ WRITE A -1 INTO THE SAME LOCATION BUT ADDRESSED FROM DPE5 CURRENT
11476	!	 BLOCK AND DPEA AC.(RAMFILE SELECT = 0).
11477	!CRAM 6/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
11478	!	 (RAMFILE SELECT = 6) INTO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
11479	!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
11480	!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
11481	!THOSE INSTRUCTIONS ARE EXECUTED TWICE FOR 2 ADRS SELECT INPUTS 0'S AND 1'S.
11482	!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
11483	!THE NXT ADRS INPUTS.
11484	
11485		BEGIN
11486		LABEL BLOCK1,BLOCK2;
11487		BIND
11488		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDACBLK U_N(7000) U,
11489				U_J(2) U_DBUS_DBM U_SPEC_LOADIR U_N(1777) U,
11490				U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(177)U,
11491				U_J(4) U_ALU_OR U_MEM U_N(11012) U,
11492				U_J(5) U_RAM_RAM U_SPEC_MEMCLR U_FMWRITE U,
11493				U_J(6) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_RAM_AC U_FMWRITE U_N(777777) U,
11494				U_ALU_XOR U_LSRC_DA U_A_T1 U_RAM_RAM U_DBUS_RAM U_SKIP_ADEQ0 U);
11495	
11496		IF .ADRSFLG NEQ 0
11497			THEN RETURN;
11498		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11499		SET_C(0);					!SET CRAM ADRS TO 0
11500		ER_TAB[0] = UPLIT (%ASCIZ'ONES');		!FOR ERROR PRINTOUT
11501		ER_TAB[1] = %O'177';				!FOR ERROR PRINTOUT
11502		DO (0) WHILE
11503	BLOCK1:	BEGIN
11504		RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLKS & GET NXT CRAM ADRS
11505		IF .RCVDATA NEQ 1				!CHECK DATA
11506			THEN BEGIN
11507				ERRS(1,1,ER_TAB);			!NO
11508				TEST55_FLG = 1;
11509			     END;
11510		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11511			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
11512		0						!TO ILLUMINATE BLISS INFO COMMENT
11513	
11514		END;
11515		LC(2);						!LOAD CRAM ADRS 2
11516		MOD_FLD(3,0);					!CHANGE # FIELD TO 0
11517		LC(1);						!LOAD CRAM ADRS 1
11518		MOD_FLD(3,0);					!CHANGE # FIELD TO 0
11519		LC(0);						!LOAD CRAM ADRS TO 0
11520		MOD_FLD(3,0);					!CHANGE # FIELD TO 0
11521		ER_TAB[0] = UPLIT (%ASCIZ'ZEROS');		!FOR ERROR PRINTOUT
11522		ER_TAB[1] = 0;					!HERE TOO
11523		DO (0) WHILE
11524	BLOCK2:	BEGIN
11525		RCVDATA = STEP_U_NEXT(7);			!GIVE 7 CLKS & GET NXT CRAM ADRS
11526		IF .RCVDATA NEQ 1				!CHECK DATA
11527			THEN BEGIN
11528				ERRS(1,1,ER_TAB);			!NO
11529				TEST55_FLG = 1;
11530			     END;
11531		IF .TEST55_FLG EQL 0
11532			THEN NOERR(1);
11533		IF (.TEST55_FLG OR .TEST53_FLG) EQL 0
11534			THEN NOERR(2)
11535			ELSE IF (.TEST55_FLG OR .TEST54_FLG) EQL 0
11536				THEN NOERR(2);
11537		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11538			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
11539		0						!TO ILLUMINATE BLISS INFO COMMENT
11540	
11541		END;
11542	!*MESSAGE 1
11543	!*	RAMFILE ADRS TEST (RAMFILE SELECT = 0)
11544	!*STIMULUS:
11545	!*	LOAD DPE5 CURRENT AC BLOCK WITH \S0.
11546	!*	LOAD DPEA AC WITH \S0.
11547	!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O1.
11548	!*	CLEAR RAMFILE LOCATION POINTED TO BY THE VMA (SELECT = 6).
11549	!*	WRITE A -1 INTO RAMFILE LOCATION POINTED TO BY 
11550	!*	DPEA AC & DPE5 AC CURRENT BLOCK (RAMFILE SELECT = 0).
11551	!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
11552	!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
11553	!]NO ERROR 1
11554	!]HCLK FCLK SPECAC SPECIR NTWK
11555	!]NO ERROR 2
11556	!]RAMDBUS NTWK
11557	!]ERROR 1
11558	!]RAM RAMADRS RAMSEL BCLK HCLK TBVMACPY SPECAC SPECIR ADEQ0 IR FCLK ACBLK RAMDBUS RAMWRITE NTWK
11559		LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
11560		END;
11561		
11562	GLOBAL ROUTINE TST56: NOVALUE =
11563	
11564	!THIS TEST CHECKS THE RAMFILE ADRS SELECT 2 .
11565	!THIS TEST WILL DO THE FOLLOWING:
11566	!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
11567	!	   (RAMFILE SELECT = 6).
11568	!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY DPE5 CURRENT OR
11569	!	   PREVIOUS AC BLOCKS, AND XR (RAMFILE ADRS SELECT = 2).
11570	!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
11571	!	   THE VMA AND VERIFY IT DID CHANGE TO -1.
11572	!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 7:
11573	!CRAM 0/ TURN ON PXCT AND PXCT 09 ON DPMA.
11574	!CRAM 1/ LOAD THE XR ON DPEA FROM THE MAGIC # FIELD VIA DBUS & DP.
11575	!CRAM 2/ LOAD THE PREVIOUS AND CURRENT BLOCK FROM THE MAGIC # FIELD VIA DBUS & DP
11576	!CRAM 3/ PASS AN ADRS (0,177 OR 160) FROM THE # FIELD VIA DBUS INTO REGITER
11577	!	 0 OF THE 2901'S.
11578	!CRAM 4/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
11579	!CRAM 5/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
11580	!CRAM 6/ WRITE A -1 INTO THE SAME LOCATION BUT ADDRESSED FROM XR
11581	!	   AND XR PREVIOUS (RAMFILE SELECT = 2).
11582	!CRAM 7/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
11583	!	 (RAMFILE SELECT = 6) TO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
11584	!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
11585	!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
11586	!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
11587	!THE NXT ADRS INPUTS.
11588	
11589		BEGIN
11590		OWN TEST_FLG;
11591		LABEL BLOCK1,BLOCK2,BLOCK3;
11592		BIND
11593		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDPXCT U_N(400) U,
11594				U_J(2) U_SPEC_LOADXR U_DBUS_DBM U_N(117) U,
11595				U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDACBLK U_N(7700) U,
11596				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(177) U,
11597				U_J(5) U_ALU_OR U_MEM U_N(11012) U,
11598				U_J(6) U_SPEC_MEMCLR U_RAM_RAM U_FMWRITE U,
11599				U_J(7) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_RAM_XR U_FMWRITE U_N(777777) U,
11600				U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
11601	
11602		IF .ADRSFLG NEQ 0
11603			THEN RETURN;
11604		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11605		SET_C(0);					!SET CRAM ADRS TO 0
11606		ER_TAB[0] = UPLIT (%ASCIZ'ONES');		!FRO ERROR PRINTOUT
11607		ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
11608		ER_TAB[2] = %O'177';				!FRO ERROR PRINTOUT
11609		TEST_FLG = 0;
11610		DO (0) WHILE
11611	BLOCK1:	BEGIN
11612		RCVDATA = STEP_U_NEXT(8);			!GIVE 10 CLKS & GET NXT CRAM ADRS
11613		IF .RCVDATA NEQ 1				!CHECK DATA
11614			THEN BEGIN
11615				ERRS(1,1,ER_TAB);			!NO
11616				TEST_FLG = 1;
11617			     END;
11618		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11619			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
11620		0						!TO ILLUMINATE BLISS INFO COMMENT
11621	
11622		END;
11623		LC(3);						!LOAD CRAM ADRS 3
11624		MOD_FLD(3,0);					!CHANGE THE VMA TO 0
11625		LC(2);						!LOAD CRAM ADRS  2
11626		MOD_FLD(3,%O'7000');				!CLEAR PREVIOUS BLOCK
11627		LC(1);						!LOAD CRAM ADRS 1
11628		MOD_FLD(3,%O'100');				!CLEAR THE XR
11629		SET_C(0);					!SET CRAM ADRS TO 0
11630		ER_TAB[0] = UPLIT (%ASCIZ'ZEROS');		!FRO ERROR PRINTOUT
11631		ER_TAB[1] = UPLIT (%ASCIZ'HI');			!FRO ERROR PRINTOUT
11632		ER_TAB[2] = 0;					!FRO ERROR PRINTOUT
11633		DO (0) WHILE
11634	BLOCK2:	BEGIN
11635		RCVDATA = STEP_U_NEXT(8);			!GIVE 10 CLKS & GET NXT CRAM ADRS
11636		IF .RCVDATA NEQ 1				!CHECK DATA
11637			THEN BEGIN
11638				ERRS(1,1,ER_TAB);			!NO
11639				TEST_FLG = 1;
11640			     END;
11641		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
11642			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
11643		0						!TO ILLUMINATE BLISS INFO COMMENT
11644	
11645		END;
11646		LC(3);						!LOAD CRAM ADRS 3
11647		MOD_FLD(3,%O'160');				!CHANGE THE VMA TO 160
11648		LC(0);						!LOAD CRAM ADRS 0
11649		MOD_FLD(3,0);					!LOAD PXCT WITH 0
11650		ER_TAB[0] = UPLIT (%ASCIZ'LO');			!FRO ERROR PRINTOUT
11651		ER_TAB[2] = %O'160';				!FRO ERROR PRINTOUT
11652		DO (0) WHILE
11653	BLOCK3:	BEGIN
11654		RCVDATA = STEP_U_NEXT(8);			!GIVE 10 CLKS & GET NXT CRAM ADRS
11655		IF .RCVDATA NEQ 1				!CHECK DATA
11656			THEN ERRS(1,1,ER_TAB)			!NO
11657			ELSE BEGIN
11658				IF .TEST_FLG EQL 0
11659					THEN NOERR(1);
11660				IF (.TEST_FLG OR .TEST55_FLG) EQL 0
11661					THEN NOERR(2);
11662				IF (.TEST_FLG OR .TEST53_FLG) EQL 0
11663					THEN NOERR(3)
11664					ELSE IF (.TEST_FLG OR .TEST54_FLG) EQL 0
11665						THEN NOERR(3);
11666			     END;
11667		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
11668			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
11669		0						!TO ILLUMINATE BLISS INFO COMMENT
11670	
11671		END;
11672	!*MESSAGE 1
11673	!*	RAMFILE ADRS TEST (RAMFILE SELECT 2)
11674	!*STIMULUS:
11675	!*	TURN PXCT ON AND LOAD PXCT 09 WITH \S1
11676	!*	LOAD THE XR REGISTER WITH ALL \S0 AND LOAD XR PREVIOUS WITH \S1
11677	!*	LOAD AC PREVIOUS BLK WITH ALL \S0 AND CURRENT BLOCK WITH ALL ONES
11678	!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O2.
11679	!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA(SELECT = 6).
11680	!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 2 (XR & XR BLOCK)
11681	!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
11682	!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
11683	!]NO ERROR 1
11684	!]BCLK HCLK SPECAC SPECXR NTWK
11685	!]NO ERROR 2
11686	!]ACBLK BCLK HCLK SPECAC SPECXR NTWK
11687	!]NO ERROR 3
11688	!]RAMDBUS NTWK
11689	!]ERROR 1
11690	!]ADEQ0 RAM XR HCLK SPECAC SPECXR ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
11691		LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
11692		END;
11693	
11694	GLOBAL ROUTINE TST57: NOVALUE =
11695	
11696	!THIS TEST CHECKS THE RAMFILE ADRS SELECT 4 .
11697	!THIS TEST WILL DO THE FOLLOWING:
11698	!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
11699	!	   (RAMFILE SELECT = 6).
11700	!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE 
11701	!	   THE VMA, PREVIOUS BLOCK AND VMA AC REF (RAMFILE SELECT = 4).
11702	!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
11703	!	   THE VMA (RAMFILE SELECT = 6) AND VERIFY IT DID CHANGE TO -1.
11704	!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
11705	!CRAM 0/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
11706	!	   0 OF THE 2901'S.
11707	!CRAM 1/ LOAD THE AC PREVIOUS AND CURRENT BLOCKS WITH A 0.
11708	!CRAM 2/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
11709	!CRAM 3/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
11710	!CRAM 4/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
11711	!	 ADRS SELECT = 4.
11712	!CRAM 5/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
11713	!	 (RAMFILE SELECT = 6) INTO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
11714	!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
11715	!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
11716	!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
11717	!THE NXT ADRS INPUTS.
11718	
11719		BEGIN
11720		OWN TEST_FLG;
11721		LABEL BLOCK1,BLOCK2,BLOCK3;
11722		BIND
11723		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(1777) U,
11724				U_J(2) U_SPEC_LDACBLK U,
11725				U_J(3) U_ALU_OR U_MEM U_N(11012) U,
11726				U_J(4) U_RAM_RAM U_FMWRITE U,
11727				U_J(5) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_RAM_VMA U_FMWRITE U_N(777777) U,
11728				U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
11729	
11730	
11731		IF .ADRSFLG NEQ 0
11732			THEN RETURN;
11733		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11734		SET_C(0);					!SET CRAM ADRS TO 0
11735		ER_TAB[0] = %O'1777';				!FOR ERROR PRINTOUT
11736		ER_TAB[1] = UPLIT (%ASCIZ' ');			!FOR ERROR PRINTOUT
11737		TEST_FLG = 0;
11738		DO (0) WHILE
11739	BLOCK1:	BEGIN
11740		RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
11741		IF .RCVDATA NEQ 1				!CHECK DATA
11742			THEN BEGIN
11743				ERRS(1,1,ER_TAB);			!NO
11744				TEST_FLG = 1;
11745			     END;
11746		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11747			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
11748		0						!TO ILLUMINATE BLISS INFO COMMENT
11749	
11750		END;
11751		MOD_FLD(3,%O'1000');				!MODIFY THE # FIELD
11752		ER_TAB[0] = %O'1000';				!FOR ERROR PRINTOUT
11753		DO (0) WHILE
11754	BLOCK2:	BEGIN
11755		RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
11756		IF .RCVDATA NEQ 1				!CHECK DATA
11757			THEN BEGIN
11758				TEST_FLG = 1;
11759				ERRS(1,1,ER_TAB);			!NO
11760			     END;
11761		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
11762			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
11763		0						!TO ILLUMINATE BLISS INFO COMMENT
11764	
11765		END;
11766		LC(2);						!LOAD CRAM ADRS 2
11767		MOD_FLD(3,%O'12');				!SET NOT PHYSICAL
11768		MOD_FLD(2,%O'1727');				!SET PREVIOUS
11769		LC(0);						!SET CRAM ADRS TO 0
11770		MOD_FLD(3,0);					!LOAD THE VMA WITH A 0
11771		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
11772		ER_TAB[1] = UPLIT (%STRING(%CHAR(13,10),'	SET DPM4 VMA AC REF & VMA PREVIOUS.'));
11773		DO (0) WHILE
11774	BLOCK3:	BEGIN
11775		RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
11776		IF .RCVDATA NEQ 1				!CHECK DATA
11777			THEN ERRS(1,1,ER_TAB)			!NO
11778			ELSE BEGIN
11779				IF .TEST_FLG EQL 0
11780					THEN NOERR(1);
11781				IF (.TEST_FLG OR .TEST53_FLG) EQL 0
11782					THEN NOERR(2)
11783					ELSE IF (.TEST_FLG OR .TEST54_FLG) EQL 0
11784						THEN NOERR(2);
11785			     END;
11786		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
11787			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
11788		0						!TO ILLUMINATE BLISS INFO COMMENT
11789	
11790		END;
11791	!*MESSAGE 1
11792	!*	RAMFILE ADRS TEST (RAMFILE SELECT 4)
11793	!*STIMULUS:
11794	!*	LOAD AC PREVIOUS AND CURRENT TO 0.\S1
11795	!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O0.
11796	!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (SELECT = 6)
11797	!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 4 
11798	!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
11799	!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
11800	!]NO ERROR 1
11801	!]CCLK BCLK HCLK SPECAC NTWK
11802	!]NO ERROR 2
11803	!]RAMDBUS NTWK
11804	!]ERROR 1
11805	!]CCLK RAM HCLK SPECAC ADEQ0 ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
11806		END;
11807		
11808	GLOBAL ROUTINE TST58: NOVALUE =
11809	
11810	!THIS TEST CHECKS THE RAMFILE ADRS SELECT 7 .(DPM4 VMA AC REF HI)
11811	!THIS TEST WILL DO THE FOLLOWING:
11812	!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
11813	!	   (RAMFILE SELECT = 6).
11814	!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE 
11815	!	   MAGIC # FIELD VIA DBM (RAMFILE SELECT = 7).
11816	!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
11817	!	   THE VMA AND VERIFY IT DID CHANGE TO -1.
11818	!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
11819	!CRAM 0/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
11820	!	   0 OF THE 2901'S.
11821	!CRAM 1/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
11822	!CRAM 2/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
11823	!CRAM 3/ LOAD THE VMA WITH A 0 TO SET VMA AC REF.
11824	!CRAM 4/ PUT A -1 IN REGISTER 0 OF THE 2901'S VIA # FIELD.
11825	!CRAM 5/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
11826	!	 ADRS SELECT IS FROM # FIELD.
11827	!CRAM 6/ LOAD THE VMA FROM REGISTER 0 AGAIN.
11828	!CRAM 7/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
11829	!	 (RAMFILE SELECT = 6) TO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
11830	!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
11831	!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
11832	!THOSE INSTRUCTIONS ARE EXECUTED TWICE FOR 2 ADRS SELECT INPUTS 0'S AND 1'S.
11833	!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
11834	!THE NXT ADRS INPUTS.
11835	
11836		BEGIN
11837		LABEL BLOCK1,BLOCK2;
11838		BIND
11839		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(1777) U,
11840				U_J(2) U_ALU_OR U_MEM U_N(11012) U,
11841				U_J(3) U_SPEC_MEMCLR U_FMWRITE U_RAM_RAM U,
11842				U_J(4) U_MEM U_N(10012) U,
11843				U_J(5) U_SPEC_MEMCLR U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_N(777777) U,
11844				U_J(6) U_ALU_OR U_LSRC_0B U_B_T1 U_RAM_N U_FMWRITE U_N(1777) U,
11845				U_J(7) U_ALU_OR U_MEM U_N(11012) U,
11846				U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
11847	
11848		IF .ADRSFLG NEQ 0
11849			THEN RETURN;
11850		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11851		SET_C(0);					!SET CRAM ADRS TO 0
11852		ER_TAB[0] = %O'1777';				!FROR ERROR PRINTOUT
11853		DO (0) WHILE
11854	BLOCK1:	BEGIN
11855		RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
11856		IF .RCVDATA NEQ 1				!CHECK DATA
11857			THEN BEGIN
11858				ERRS(1,1,ER_TAB);			!NO
11859				TEST58_FLG = 1;
11860			     END;
11861		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11862			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
11863		0						!TO ILLUMINATE BLISS INFO COMMENT
11864	
11865		END;
11866		LC(5);						!LOAD CRAM ADRS 4
11867		MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
11868		LC(0);						!LOAD CRAM ADRS 0
11869		MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
11870		ER_TAB[0] = 0;					!FROR ERROR PRINTOUT
11871		DO (0) WHILE
11872	BLOCK2:	BEGIN
11873		RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
11874		IF .RCVDATA NEQ 1				!CHECK DATA
11875			THEN BEGIN
11876				ERRS(1,1,ER_TAB);			!NO
11877				TEST58_FLG = 1;
11878			     END;
11879		IF (.TEST58_FLG OR .TEST53_FLG) EQL 0
11880			THEN NOERR(1)
11881			ELSE IF (.TEST58_FLG OR .TEST54_FLG) EQL 0
11882				THEN NOERR(1);
11883		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
11884			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
11885		0						!TO ILLUMINATE BLISS INFO COMMENT
11886	
11887		END;
11888	!*MESSAGE 1
11889	!*	RAMFILE ADRS TEST (RAMFILE SELECT 7)
11890	!*STIMULUS:
11891	!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O0.
11892	!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA(SELECT = 6).
11893	!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 7 WITH DPM4 VMA AC REF HI
11894	!*	( # FIELD = \O0 FOR BOTH HALFS OF THE DBM).
11895	!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
11896	!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
11897	!]NO ERROR 1
11898	!]RAMDBUS NTWK
11899	!]ERROR 1
11900	!]ADEQ0 CCLK RAM RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
11901		LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
11902		END;
11903	
11904	GLOBAL ROUTINE TST59: NOVALUE =
11905	
11906	!THIS TEST CHECKS THE RAMFILE ADRS SELECT 7 .(DPM4 VMA AC REF LO).
11907	!THIS TEST WILL DO THE FOLLOWING:
11908	!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
11909	!	   (RAMFILE SELECT = 6).
11910	!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE 
11911	!	   MAGIC # FIELD VIA DBM (RAMFILE SELECT = 7).
11912	!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
11913	!	   THE VMA AND VERIFY IT DID CHANGE TO -1.
11914	!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
11915	!CRAM 0/ PASS AN ADRS (0 OR 177) FROM THE # FIELD VIA DBUS INTO REGITER
11916	!	   0 OF THE 2901'S.
11917	!CRAM 1/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
11918	!CRAM 2/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
11919	!CRAM 3/ PUT A -1 IN REGISTER 0 OF THE 2901'S VIA # FIELD.
11920	!CRAM 4/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
11921	!	 ADRS SELECT IS FROM # FIELD.
11922	!CRAM 5/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
11923	!	 (RAMFILE SELECT = 6) TO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
11924	!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
11925	!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
11926	!THOSE INSTRUCTIONS ARE EXECUTED TWICE FOR 2 ADRS SELECT INPUTS 0'S AND 1'S.
11927	!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
11928	!THE NXT ADRS INPUTS.
11929	
11930		BEGIN
11931		LABEL BLOCK1,BLOCK2;
11932		BIND
11933		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(1777) U,
11934				U_J(2) U_ALU_OR U_MEM U_N(11012) U,
11935				U_J(3) U_SPEC_MEMCLR U_FMWRITE U_RAM_RAM U,
11936				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_B_T1 U_DBUS_DBM U_N(777777) U,
11937				U_J(5) U_ALU_OR U_LSRC_0B U_B_T1 U_RAM_N U_FMWRITE U_N(1777) U,
11938				U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
11939	
11940		IF .ADRSFLG NEQ 0
11941			THEN RETURN;
11942		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
11943		SET_C(0);					!SET CRAM ADRS TO 0
11944		ER_TAB[0] = %O'1777';				!FROR ERROR PRINTOUT
11945		DO (0) WHILE
11946	BLOCK1:	BEGIN
11947		RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
11948		IF .RCVDATA NEQ 1				!CHECK DATA
11949			THEN BEGIN
11950				ERRS(1,1,ER_TAB);			!NO
11951				TEST59_FLG = 1;
11952			     END;
11953		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
11954			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
11955		0						!TO ILLUMINATE BLISS INFO COMMENT
11956	
11957		END;
11958		LC(4);						!LOAD CRAM ADRS 4
11959		MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
11960		LC(0);						!LOAD CRAM ADRS 0
11961		MOD_FLD(3,0);					!CHANGE THE # FIELD TO 0
11962		ER_TAB[0] = 0;					!FROR ERROR PRINTOUT
11963		DO (0) WHILE
11964	BLOCK2:	BEGIN
11965		RCVDATA = STEP_U_NEXT(6);			!GIVE 6 CLKS & GET NXT CRAM ADRS
11966		IF .RCVDATA NEQ 1				!CHECK DATA
11967			THEN BEGIN
11968				ERRS(1,1,ER_TAB);			!NO
11969				TEST59_FLG = 1;
11970			     END;
11971		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
11972			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
11973		0						!TO ILLUMINATE BLISS INFO COMMENT
11974	
11975		END;
11976		IF (.TEST55_FLG OR .TEST58_FLG OR .TEST59_FLG) EQL 0
11977			THEN NOERR(1);
11978		IF (.TEST59_FLG OR .TEST53_FLG) EQL 0
11979			THEN NOERR(2)
11980			ELSE IF (.TEST59_FLG OR .TEST54_FLG) EQL 0
11981				THEN NOERR(2);
11982	!*MESSAGE 1
11983	!*	RAMFILE ADRS TEST (RAMFILE SELECT 7) WITH VMA AC REF LO
11984	!*STIMULUS:
11985	!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O0.
11986	!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA(SELECT = 6).
11987	!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 7 
11988	!*	( # FIELD = \O0 FOR BOTH HALFS OF THE DBM).
11989	!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
11990	!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
11991	!]ERROR 1
11992	!]ADEQ0 RAM ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
11993	!]NO ERROR 1
11994	!]RAMSEL NTWK
11995	!]NO ERROR 2
11996	!]RAMDBUS NTWK
11997		LDVMA = 0;					!CLEAR THIS FLAG VMA HAS BEEN CHANGED
11998		END;
11999	
12000	GLOBAL ROUTINE TST60: NOVALUE =
12001	
12002	!THIS TEST CHECKS THE RAMFILE ADRS SELECT 1 .
12003	!THIS TEST WILL DO THE FOLLOWING:
12004	!	1) SELECT A RAMFILE ADRS FROM THE VMA AND CLEAR THAT LOCATION.
12005	!	   (RAMFILE SELECT = 6).
12006	!	2) WRITE A -1 INTO THE SAME LOCATION ADRS SELECTED BY THE THE VMA.
12007	!	   CURRENT AC BLOCK, DPEA AC + DBM (14,15,16 & 17) (RAMFILE SELECT = 4).
12008	!	3) READ BACK THE CONTENTS OF THE RAMFILE ADRS POINTED TO BY 
12009	!	   THE VMA (RAMFILE SELECT = 6) AND VERIFY IT DID CHANGE TO -1.
12010	!THIS LOGIC SEQUENCE OF TESTING IS EXECUTED IN CRAM 0 - 5:
12011	!CRAM 0/ LOAD DPEA AC (0 OR 17).
12012	!CRAM 1/ PASS AN ADRS (0 OR 176 OR 177) FROM THE # FIELD VIA DBUS 
12013	!	 INTO REGITER 0 OF THE 2901'S.
12014	!CRAM 2/ LOAD THE AC CURRENT BLOCKS WITH A 0 OR 7 .
12015	!CRAM 3/ OUTPUT THE CONTENTS OF REGISTER 0 ONTO DP AND LOAD THE VMA.
12016	!CRAM 4/ CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (RAMFILE SELECT = 6).
12017	!CRAM 5/ OUTPUT THE -1 FROM YHE 2901'S AND WRITE IT INTO THE RAMFILE 
12018	!	 ADRS SELECT = 4.
12019	!CRAM 6/ READ BACK THE CONTENTS OF RAMFILE LOCATION POINTED TO BY THE VMA
12020	!	 (RAMFILE SELECT = 6) INTO THE 2901'S XOR IT WITH -1 AND SKIP IF THE OUTPUT IS 0.
12021	!	(THE ORED J FIELD IS 0, IT SHOULD SKIP TO 1 IF NO ERROR).
12022	!NOW WE EXAMINE THE NXT CRAM ADRS AND VERIFY THE SKIP.
12023	!AFTER THE FIRST EXECUTION WE MODIFY FIELDS IN THE CRAM TO SET UP FOR 
12024	!THE NXT ADRS INPUTS.
12025	
12026		BEGIN
12027		OWN TEST_FLG;
12028		LABEL BLOCK1,BLOCK2,BLOCK3,BLOCK4;
12029		BIND
12030		POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U_N(740) U,
12031				U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_N(176) U,
12032				U_J(3) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LDACBLK U_N(7000) U,
12033				U_J(4) U_ALU_OR U_MEM U_N(11012) U,
12034				U_J(5) U_RAM_RAM U_FMWRITE U,
12035				U_J(6) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_DEST_AD U_B_T1 U_N(777777) U,
12036				U_J(7) U_ALU_OR U_A_T1 U_RAM_AC_FN U_FMWRITE U_N(1457) U,
12037				U_ALU_XOR U_LSRC_DA U_A_T1 U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
12038	
12039		IF .ADRSFLG NEQ 0
12040			THEN RETURN;
12041		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
12042		SET_C(0);					!SET CRAM ADRS TO 0
12043		ER_TAB[0] = 7;					!FOR ERROR PRINTOUT
12044		ER_TAB[1] = %O'176';				!FOR ERROR PRINTOUT
12045		ER_TAB[2] = %O'17';				!FOR ERROR PRINTOUT
12046		ER_TAB[3] = %O'1457';				!FOR ERROR PRINTOUT
12047		DO (0) WHILE
12048	BLOCK1:	BEGIN
12049		RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
12050		IF .RCVDATA NEQ 1				!CHECK DATA
12051			THEN BEGIN
12052				TEST_FLG = 1;
12053				ERRS(1,1,ER_TAB);			!NO
12054			     END;
12055		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
12056			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
12057		0						!TO ILLUMINATE BLISS INFO COMMENT
12058	
12059		END;
12060		LC(1);						!LOAD CRAM ADRS 1
12061		MOD_FLD(3,%O'177');				!VMA GETS 177
12062		ER_TAB[1] = %O'177';				!FOR ERROR PRINTOUT
12063		LC(0);						!LOAD CRAM ADRS 0
12064		MOD_FLD(3,0);					!DPEA AC GETS 0
12065		ER_TAB[2] = 0;					!FOR ERROR PRINTOUT
12066		DO (0) WHILE
12067	BLOCK2:	BEGIN
12068		RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
12069		IF .RCVDATA NEQ 1				!CHECK DATA
12070			THEN BEGIN
12071				ERRS(1,1,ER_TAB);			!NO
12072				TEST_FLG = 1;
12073			     END;
12074		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
12075			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
12076		0						!TO ILLUMINATE BLISS INFO COMMENT
12077	
12078		END;
12079		LC(6);						!LOAD CRAM ADRS 6
12080		MOD_FLD(3,%O'1440');				!AD A 0 TO THE AC
12081		ER_TAB[3] = %O'1440';				!FOR ERROR PRINTOUT
12082		LC(0);						!LOAD CRAM ADRS 0
12083		MOD_FLD(3,%O'740');				!DPEA AC GETS A 17
12084		ER_TAB[2] = %O'17';				!FOR ERROR PRINTOUT
12085		DO (0) WHILE
12086	BLOCK3:	BEGIN
12087		RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
12088		IF .RCVDATA NEQ 1				!CHECK DATA
12089			THEN BEGIN
12090				ERRS(1,1,ER_TAB);			!NO
12091				TEST_FLG = 1;
12092			     END;
12093		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET ?
12094			THEN LEAVE BLOCK3 WITH 1;		!LEAVE BLOCK TO LOOP
12095		0						!TO ILLUMINATE BLISS INFO COMMENT
12096	
12097		END;
12098		LC(1);						!LOAX CRAM ADRS 1
12099		MOD_FLD(3,0);					!VMA GETS A 0
12100		ER_TAB[1] = 0;					!FOR ERROR PRINTOUT
12101		LC(2);						!LOAD CRAM ADRS 2
12102		MOD_FLD(3,0);					!CURRENT GEST A 0
12103		ER_TAB[0] = 0;					!FOR ERROR PRINTOUT
12104		LC(0);						!LOAD CRAM ADRS 0
12105		MOD_FLD(3,0);					!DPEA AC GETS A 0
12106		ER_TAB[2] = 0;					!FOR ERROR PRINTOUT
12107		DO (0) WHILE
12108	BLOCK4:	BEGIN
12109		RCVDATA = STEP_U_NEXT(8);			!GIVE 8 CLKS & GET NXT CRAM ADRS
12110		IF .RCVDATA NEQ 1				!CHECK DATA
12111			THEN ERRS(1,1,ER_TAB)			!NO
12112			ELSE BEGIN
12113				IF .TEST_FLG EQL 0
12114					THEN NOERR(1);
12115				IF (.TEST_FLG OR .TEST53_FLG) EQL 0
12116					THEN NOERR(2)
12117					ELSE IF (.TEST_FLG OR .TEST54_FLG) EQL 0
12118						THEN NOERR(2);
12119			     END;
12120		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET ?
12121			THEN LEAVE BLOCK4 WITH 1;		!LEAVE BLOCK TO LOOP
12122		0						!TO ILLUMINATE BLISS INFO COMMENT
12123	
12124		END;
12125	!*MESSAGE 1
12126	!*	RAMFILE ADRS TEST (RAMFILE SELECT 1)
12127	!*STIMULUS:
12128	!*	LOAD DPEA AC WITH \O2
12129	!*	LOAD AC CURRENT BLOCK TO \O0
12130	!*	LOAD THE 10 BIT VMA COPY ON DPE5 WITH \O1.
12131	!*	CLEAR THE RAMFILE LOCATION POINTED TO BY THE VMA (SELECT = 6)
12132	!*	WRITE A -1 INTO RAMFILE LOCATION SELECTING 1, DBM = \O3 
12133	!*	READ BACK THE CONTENTS OF THE RAMFILE LOCATION POINTED TO BY
12134	!*	THE VMA (SELECT = 6) AND VERIFY THAT IT CHANGED TO A -1.
12135	!]NO ERROR 1
12136	!]FCLK BCLK ACALU SPECIR SPECAC FCLK NTWK
12137	!]NO ERROR 2
12138	!]RAMDBUS NTWK
12139	!]ERROR 1
12140	!]ADEQ0 IR FCLK RAM HCLK SPECIR SPECAC ACALU ACBLK RAMWRITE RAMADRS RAMSEL BCLK TBVMACPY RAMDBUS NTWK
12141		END;
12142		
12143	GLOBAL ROUTINE TST61: NOVALUE =
12144	
12145	!THIS TEST CHECKS SWEEP CASH TO LOAD THE VMA ON DPE5.
12146	!THIS TEST WILL DO THE FOLOWING:
12147	!DEPOSITE A -1 IN MEMORY LOCATION 0 AND EXECUTE THE FOLLOWING:
12148	!CRAM 1/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH 11012
12149	!CRAM 2/ SET CASH SWEEP (SPEC = 24) WITH 0 ON DP AND PHYSICAL SET IN # DFIELD.
12150	!	 (THIS SHOULD LOAD THE VMA WITH A 0).
12151	!CRAM 3/ FINISH THE MEM CYCLE WITH 0 ON DP.
12152	!	 (THIS SHOULD OUTPUT A 0 TO MEM).
12153	!NOW WE EXAMINE MEM LOCATION 0 AND VERIFY THAT IT DID CHANGE TO A 0
12154	
12155		BEGIN
12156		LABEL BLOCK1;
12157		BIND
12158		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
12159				U_J(3) U_SPEC_SWEEP U_N(1000) U,
12160				U_J(1) U_MEM U_N(2) U);
12161	
12162		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
12163		SET_C(1);					!SET CRAM ADRS TO 1
12164		DM(0,%O'-1');					!PUT A -1 IN MEM 0
12165		DO (0) WHILE
12166	BLOCK1:	BEGIN
12167		CP(3);						!GIVE 3 CLKS
12168		RCVDATA = EM(0);				!EXAMINE MEMORY
12169		IF .RCVDATA EQL 0				!CHECK DATA
12170			THEN NOERR(1)				!YES
12171			ELSE ERR(1);				!NO
12172		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
12173			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
12174		0						!TO ILLUMINATE BLISS INFO COMMENT
12175	
12176		END;
12177	!*MESSAGE 1
12178	!*	SET SWEEP TEST
12179	!*STIMULUS:
12180	!*	DEPOSITE A -1 IN MEM LOCATION 0
12181	!*	START A MEM CYCLE AND LOAD THE VMA WITH 11012
12182	!*	SWEEP THE CASH (SPEC = 24) WITH A ZERO ON DP 
12183	!*	(SHOULD LOAD THE VMA WITH A 0)
12184	!*	FINISH THE MEM WRITE CYCLE
12185	!*	EXAMINE MEM LOCATION 0 AND VERIFY IT CHANGED TO 0
12186	!]ERROR 1
12187	!]SPECSWEEP SWPVMA NTWK
12188	!]NO ERROR 1
12189	!]SPECSWEEP SWPVMA NTWK
12190		END;
12191		
12192	GLOBAL ROUTINE TST62: NOVALUE =
12193	
12194	!THIS TEST CHECKS THE RAMFILE WRITE EN FROM DPM4
12195	!THIS TEST WILL DO THE FOLLOWING:
12196	!CRAM 0/ LOAD THE VMA WITH A ZERO WITH NOT PHYSICAL
12197	!CRAM 1/ WRITE A 0 INTO RAMFILE LOCATION 0. (WRITE ENABLE FROM CRAM)
12198	!CRAM 2/ START A MEM WRITE CYCLE.
12199	!CRAM 3/ WRITE A 2 INTO RAMFILE LOCATION 0. (WRITE ENABLE FROM DPM4)
12200	!CRAM 4/ READ BACK THE CONTENTS OF RAMFILE LOCATION 0 AND VERIFY IT 
12201	!	 DID CHANGE TO A 2.
12202	
12203		BEGIN
12204		OWN TEST_FLG;
12205		LABEL BLOCK1,BLOCK2;
12206		BIND
12207		POINTER = PLIT (U_J(1) U_SPEC_SWEEP U_DEST_AD U,
12208				U_J(2) U_FMWRITE U_RAM_RAM U,
12209				U_J(3) U_MEM U_N(10002) U,
12210				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_RAM_RAM U_N(2) U_MEM U,
12211				U_ALU_XOR U_LSRC_DA U_DBUS_RAM U_RAM_RAM U_SKIP_ADEQ0 U);
12212				
12213		LOAD_U(0,POINTER);				!LOAD INSTRUCTIONS
12214		SET_C(0);					!SET CRAM ADRS TO 0
12215		TEST_FLG = 0;
12216		ER_TAB[0] = UPLIT(%ASCIZ'HI');			!FOR ERROR
12217		ER_TAB[1] = UPLIT(%ASCIZ' NOT ');		!FOR ERROR
12218		DO (0) WHILE
12219	BLOCK1:	BEGIN
12220		RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLKS & GET NXT CRAM ADRS
12221		IF .RCVDATA NEQ 1				!CHECK DATA
12222			THEN BEGIN
12223				ERRS(1,1,ER_TAB);		!NO
12224				TEST_FLG = 0;
12225			     END;
12226		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
12227			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
12228		0						!TO ILLUMINATE BLISS INFO COMMENT
12229	
12230		END;
12231		LC(2);						!LOAD CRAM ADRS 2
12232		MOD_FLD(4,0);					!CLEAR THIS FIELD
12233		ER_TAB[0] = UPLIT(%ASCIZ'LO');			!FOR ERROR
12234		ER_TAB[1] = UPLIT(%ASCIZ' ');		!FOR ERROR
12235		DO (0) WHILE
12236	BLOCK2:	BEGIN
12237		SET_C(0);					!SET CRAM ADRS TO 0
12238		RCVDATA = STEP_U_NEXT(5);			!GIVE 5 CLKS & GET NXT CRAM ADRS
12239		IF .RCVDATA NEQ 0				!CHECK DATA
12240			THEN ERRS(1,1,ER_TAB)			!NO
12241			ELSE IF .TEST_FLG EQL 0
12242				THEN NOERR(1);
12243		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
12244			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
12245		0						!TO ILLUMINATE BLISS INFO COMMENT
12246	
12247		END;
12248	!*MESSAGE 1
12249	!*	RAMFILE WRITE ENABLE TEST
12250	!*STIMULUS:
12251	!*	LOAD THE VMA WITH 0 AND NO PHYSICAL (SET VMA AC REF)
12252	!*	WRITE A 0 INTO RAMFILE LOCATION POINTED TO BY THE VMA 
12253	!*	(WRITE BIT FROM THE CRAM)
12254	!*	WRITE A 2 INTO THE SAME LOCATION 
12255	!*	(ENABLE WRITE FROM DPM4 RAMFILE WRITE) = \S0
12256	!*	EXAMINE THAT RAMFILE LOCATION AND VERIFY IF IT CHANGED
12257	!*RESPONSE:
12258	!*	RAMFILE CONTENTS DID\S1CHANGE
12259	!]ERROR 1
12260	!]ADEQ0 SPECSWEEP SWPVMA RAMADRS RAMWRITE RAM RAMDBUS NTWK
12261	!]NO ERROR 1
12262	!]ADEQ0 RAMWRITE NTWK
12263		END;
12264	
12265	GLOBAL ROUTINE TST63: NOVALUE =
12266	!THIS TEST VERIFIES THAT THE ADDRESSING(INPUT) PINS ON THE DROM CHIPS 
12267	!CAN BE 000.ALSO COMBINED WITH OTHER TESTS IT CHECKS THE OUTPUT OF THE 
12268	!DROM CHIPS.THE ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION THAT WILL
12269	!USE THE FOLOWING PATH:
12270	!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
12271	!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
12272	!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
12273	!	NUMBER IS LOADED WITH THE DROM ADDRESS.
12274	!ADDRESSING TO ALL 3 DROM CHIPS IS VERIFIED THROUGH CHECKING ALL THE
12275	!CONTENTS OF ADDRESS 000 OF EACH CHIP .
12276	
12277	    BEGIN
12278	    LABEL
12279		BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
12280		BIND
12281		POINTER = PLIT(U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_N(17) U_DBUS_DBM U_SPEC_LDINST U,
12282				  U_ALU_OR U_DISP_DROM U);	!GET 2 INSTRUCTIONS	
12283		BIND
12284		POINTER1 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
12285				U_J(3) U_SPEC_MEMCLR U,
12286				U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
12287				U_J(5) U_MEM U_N(11042) U,
12288				U_J(6) U_SPEC_MEMCLR U,
12289				U_J(7) U_MEM U_N(11002) U,
12290				U_J(1) U_MEM U_N(2) U);
12291		BIND
12292		POINTER2 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
12293				U_J(3) U_MEM U_N(11001) U,
12294				U_J(1) U_MEM U_N(1) U);
12295		BIND
12296		POINTER3 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
12297				U_J(3) U_MEM U_N(42) U,
12298				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
12299				U_J(5) U_MEM U_N(11012) U,
12300				U_J(1) U_ALU_OR U_MEM U_N(2) U);
12301		LOAD_U(0,POINTER);				!LOAD THEM
12302	    DO (0) WHILE 
12303	BLOCK1 :
12304		BEGIN
12305		SET_C(0);					!SET CRAM ADDRESS TO 0
12306		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS AND GET NXT ADRS
12307		IF .RCVDATA NEQ %O'1556'			!CHECK DATA
12308		THEN ERRCA(1,%O'1556',.RCVDATA,4);		!NO
12309	!*MESSAGE 1
12310	!*STIMULUS:
12311	!*	DID A DROM DISPATCH AT DROM LOCATION 000
12312	!*	DROM 000 CONTAINS / 0000,1556,2100
12313	!*	AC DISP BIT IS LO
12314	!*RESPONSE:
12315	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12316	!*	NXT ADRS = 1400 + DROM J + CRAM J
12317	!*	         = 1400 +  156   +  0000  = 1556
12318	!]ERROR 1
12319	!]ACDISP IR FCLK SPECIR DRMJ DRMCNTRL DISP NTWK
12320		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
12321		THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
12322		0						!TO ILLUMINATE BLISS INFO COMMENT
12323	
12324		END;
12325		LC(1);						!LOAD CRAM ADRS 1
12326		MOD_FLD(2,%O'300');				!MODIFY DSIPATCH TYPE IN INSTRUCTION TO AREAD
12327	    DO (0) WHILE 
12328	BLOCK2:
12329		BEGIN
12330		SET_C(0);					!SET CRAM ADRS TO 0
12331		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12332		IF .RCVDATA NEQ %O'1556'			!CHECK DATA
12333		THEN ERRCA(2,%O'1556',.RCVDATA,4);		!NO
12334	!*MESSAGE 2
12335	!*STIMULUS:
12336	!*	DID AN AREAD DISPATCH AT DROM LOCATION 000
12337	!*	DROM 000 CONTAINS / 0000,1556,2100
12338	!*	DROM A=J BIT IS HI, ACDISP BIT IS LO
12339	!*RESPONSE:
12340	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12341	!*	NXT ADRS = 1400 + DROM J + CRAM J
12342	!*	         = 1400 +  156   +  0000  = 1556
12343	!]ERROR 2
12344	!]IR SPECIR FCLK DRMCNTRL DRMJ AEQLJ DISP ACDISP NTWK
12345		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
12346		THEN LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
12347		0						!TO ILLUMINATE BLISS INFO COMMENT
12348	
12349		END;
12350		LC(1);						!LOAD CRAM ADRS 0
12351		MOD_FLD(1,%O'703');				!MODIFY DSIPATCH TYPE
12352		MOD_FLD(2,%O'600');				!IN INSTRUCTION TO ADISP
12353	    DO (0) WHILE 
12354	BLOCK3:
12355		BEGIN
12356		SET_C(0);					!SET CRAM ADRS TO 0
12357		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12358		IF .RCVDATA NEQ 0				!CHECK DATA
12359		THEN ERRCA(3,0,.RCVDATA,4);			!NO
12360	!*MESSAGE 3
12361	!*STIMULUS:
12362	!*	DID AN ADISP AT DROM LOCATION 000
12363	!*	DROM 000 CONTAINS / 0000,1556,2100
12364	!*RESPONSE:
12365	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12366	!*	NXT ADRS = DROM A + CRAM J (0-7)
12367	!*	         =  00    + 	 000     = 0000
12368	!]ERROR 3
12369	!]IR FCLK SPECIR DRMAB DISP NTWK
12370		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
12371		THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
12372		0						!TO ILLUMINATE BLISS INFO COMMENT
12373	
12374		END;
12375		LC(1);						!LOAD CRAM ADRS 1
12376		MOD_FLD(2,%O'700');				!MODIFY DSIPATCH TYPETO BDISP
12377	    DO (0) WHILE 
12378	BLOCK4:
12379		BEGIN
12380		SET_C(0);					!SET CRAM ADRS TO 0
12381		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12382		IF .RCVDATA NEQ 0				!CHECK DATA
12383		THEN ERRCA(4,0,.RCVDATA,4);			!NO
12384	!*MESSAGE 4
12385	!*STIMULUS:
12386	!*	DID A BDISP AT DROM LOCATION 000
12387	!*	DROM 000 CONTAINS / 0000,1556,2100
12388	!*RESPONSE:
12389	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12390	!*	NXT ADRS = DROM B + CRAM J (0-7)
12391	!*		 =   00   +    000	 =0000
12392	!]ERROR 4
12393	!]IR FCLK SPECIR DRMAB DISP NTWK
12394		IF LOOP_CHK(4)					!IS LOOP ON ERRO SET
12395		THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
12396		0						!TO ILLUMINATE BLISS INFO COMMENT
12397	
12398		END;
12399		LC(1);						!LOAD CRAM ADRS 1
12400		MOD_FLD(1,%O'6507');				!MODIFY TO SKIP 
12401		MOD_FLD(2,7);					!ON TXXX
12402		DO (0) WHILE
12403	BLOCK5:	BEGIN
12404		SET_C(0);					!SET CRAM ADRS TO 0
12405		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12406		IF .RCVDATA NEQ 0				!CHECK DATA
12407			THEN ERRCA(5,0,.RCVDATA,4);		!NO
12408	!*MESSAGE 5
12409	!*STIMULUS:
12410	!*	D A SKIP ON TXXX (SKIP = 57) FOR DROM LOCATION 000
12411	!*	DROM 000 SHOULD CONTAIN TXXX LO
12412	!*	WE GET NXT CRAM ADRS = CRAM J = 0
12413	!*RESPONSE:
12414	!]ERROR 5
12415	!]IR FCLK SPECIR DRMCNTRL TXXX ADEQ0 SKIP NTWK
12416		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
12417			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
12418		0						!TO ILLUMINATE BLISS INFO COMMENT
12419	
12420		END;
12421		LOAD_U(1,POINTER1);				!LOAD INSTRUCTIONS TO VERIFY VMA EN BIT
12422		SET_C(1);					!SET CRAM ADRS TO 1
12423		DO (0) WHILE
12424	BLOCK6:	BEGIN
12425		DM(0,%O'-1');					!SET MEM TO 1'S
12426		CP(7);						!GIVE 7 CLOCKS
12427		RCVDATA = EM(0);				!GET DATA FROM MEM
12428		IF .RCVDATA NEQ 0				!CHECK DATA
12429			THEN ERRCA(6,0,.RCVDATA,12);	!NO
12430	!*MESSAGE 6
12431	!*STIMULUS:
12432	!*	DEPOSITE -1 IN PHYSICAL MEM 0
12433	!*	LOAD THE VMA WITH 11012
12434	!*	LOAD THE IR WITH DROM ADDRESS /000
12435	!*	DROM CONTAINS /0000,1556,2100
12436	!*	VMA EN BIT IS HI
12437	!*	LOAD THE VMA WITH 0 IF DROM ASKS
12438	!*	WRITE A ZERO TO PHYSICAL MEM
12439	!*RESPONSE:
12440	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
12441	!]ERROR 6
12442	!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
12443		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
12444			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
12445		0						!TO ILLUMINATE BLISS INFO COMMENT
12446	
12447		END;
12448		LDVMA = 0;					!CLEAR FLAG VMA COULD HAVE CHANGED
12449		VMA_LD();					!LOAD THE VMA WITH A ZERO
12450		LOAD_U(1,POINTER2);				!LOAD INSTUCTIONS TO VERIFY COND FUNC BIT
12451		SET_C(1);					!SET CRAM ADRS TO 1
12452		DO (0) WHILE
12453	BLOCK7:	BEGIN
12454		DM(0,%O'-1');					!SET MEM TO ALL ONES
12455		CP(3);						!GIVE 3 CLOCKS
12456		RCVDATA = EM(0);				!GET DATA
12457		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
12458			THEN ERRCA(7,%O'-1',.RCVDATA,12);	!NO
12459	!*MESSAGE 7
12460	!*STIMULUS:
12461	!*	LOAD THE VMA WITH A ZERO
12462	!*	DEPOSITE -1 IN PHYSICAL MEM 0
12463	!*	LOAD THE IR WITH DROM ADDRESS /000
12464	!*	DROM CONTAINS /0000,1556,2100
12465	!*	COND FUNC BIT IS LO
12466	!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
12467	!*RESPONSE:
12468	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
12469	!]ERROR 7
12470	!]IR FCLK SPECIR DRMCNTRL NTWK
12471		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
12472			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
12473		0						!TO ILLUMINATE BLISS INFO COMMENT
12474	
12475		END;
12476		LOAD_U(1,POINTER3);				!LOAD INSTUCTIONS TO VERIFY RED & WRT TEST BITS
12477		SET_C(1);					!SET CRAM ADRS TO 1
12478		DO (0) WHILE
12479	BLOCK8:	BEGIN
12480		CP(5);						!GIVE 5 CLOCKS
12481		RCVDATA = EM(0);				!GET DATA FROM MEM
12482		RCVDATA = .RCVDATA AND %O'60000000000';		!CLEAN UNWANTED BITS
12483		IF .RCVDATA NEQ 0				!CHECK DATA
12484			THEN ERRCA(8,0,.RCVDATA,12);		!NO
12485	!*MESSAGE 8
12486	!*STIMULUS:
12487	!*	LOAD THE IR WITH DROM ADDRESS /000
12488	!*	DROM CONTAINS /0000,1556,2100
12489	!*	READ AND WRT TEST BITS ARE LO
12490	!*	START A MEM CYCLE DO AN AREAD IF DROM ASKS
12491	!*	ABORT MEM CYCLE, AND STOR THE VMA FLAGS IN 2901'S VIA DBM & DBUS
12492	!*	START A MEM CYCLE
12493	!*	FINISH MEM CYCLE AND OUTPUT THE VMA FLAGS TO MEM
12494	!*	(BITS 3 & 4 CONTAIN DROM BITS READ AND WRT TEST)
12495	!*RESPONSE:
12496	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
12497	!]ERROR 8
12498	!]IR FCLK SPECIR DRMCNTRL NTWK
12499		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
12500			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
12501		0						!TO ILLUMINATE BLISS INFO COMMENT
12502	
12503		END;
12504		END;
12505	
12506	GLOBAL ROUTINE TST64: NOVALUE =
12507	!THIS TEST VERIFIES THAT THE ADDRESSING(INPUT) PINS ON THE DROM CHIPS 
12508	!CAN BE 777.ALSO COMBINED WITH OTHER TESTS IT CHECKS THE OUTPUT PINS 
12509	!OF THE DROM CHIPS.THE ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION 
12510	!THAT WILL USE THE FOLOWING PATH:
12511	!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
12512	!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
12513	!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
12514	!	NUMBER IS LOADED WITH THE DROM ADDRESS.
12515	!ADDRESSING TO ALL 3 DROM CHIPS IS VERIFIED THROUGH CHECKING ALL THE
12516	!CONTENTS OF ADDRESS 777 OF EACH CHIP .
12517	
12518	    BEGIN
12519	    LABEL
12520		BLOCK1,BLOCK2,BLOCK3,BLOCK4,BLOCK5,BLOCK6,BLOCK7,BLOCK8;
12521		BIND
12522		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_N(777017)U_SPEC_LDINST U,
12523				    U_ALU_OR U_DISP_DROM U);	!GET 2 WORDS
12524		BIND
12525		POINTER1 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
12526				U_J(3) U_SPEC_MEMCLR U,
12527				U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777000) U,
12528				U_J(5) U_MEM U_N(11042) U,
12529				U_J(6) U_SPEC_MEMCLR U,
12530				U_J(7) U_MEM U_N(11002) U,
12531				U_J(1) U_MEM U_N(2) U);
12532		BIND
12533		POINTER2 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777000) U,
12534				U_J(3) U_MEM U_N(11001) U,
12535				U_J(1) U_MEM U_N(1) U);
12536		BIND
12537		POINTER3 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(777000) U,
12538				U_J(3) U_MEM U_N(42) U,
12539				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
12540				U_J(5) U_MEM U_N(11012) U,
12541				U_J(1) U_ALU_OR U_MEM U_N(2) U);
12542		LOAD_U(0,POINTER);				!LOAD THE INSTRUCTIONS
12543	    DO (0) WHILE 
12544	BLOCK1 :
12545		BEGIN
12546		SET_C(0);					!SET CRAM ADRS TO 0
12547		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12548		IF .RCVDATA NEQ %O'1657'			!CHECK DATA
12549		THEN ERRCA(1,%O'1657',.RCVDATA,4);		!NO
12550	!*MESSAGE 1
12551	!*STIMULUS:
12552	!*	DID A DROM DISP AT DROM LOCATION 777
12553	!*	DROM 777 CONTAINS / 0007,1657,2100
12554	!*	AC DISP BIT IS LO
12555	!*RESPONSE:
12556	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12557	!*	NXT ADRS = 1400 + DROM J + CRAM J
12558	!*	         = 1400 +  257   +  0000  = 1657
12559	!]ERROR 1
12560	!]IR FCLK SPECIR ACDISP DRMCNTRL DISP DRMJ NTWK
12561		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
12562		THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
12563		0						!TO ILLUMINATE BLISS INFO COMMENT
12564	
12565		END;
12566		LC(1);						!LOAD CRAM ADRS 1
12567		MOD_FLD(2,%O'300');				!MODIFY DISP TO AREAD
12568	    DO (0) WHILE 
12569	BLOCK2 :
12570		BEGIN
12571		SET_C(0);					!SET CRAM ADRS TO 0
12572		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT INSTRUCTION ADRS
12573		IF .RCVDATA NEQ %O'1657'			!CHECK DATA
12574		THEN ERRCA(2,%O'1657',.RCVDATA,4);		!NO
12575	!*MESSAGE 2
12576	!*STIMULUS:
12577	!*	DID AN AREAD DISP AT DROM LOCATION 777
12578	!*	DROM 777 CONTAINS / 0007,1657,2100
12579	!*	A = J BIT IS HI, AC DISP BIT IS LO
12580	!*RESPONSE:
12581	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12582	!*	NXT ADRS = 1400 + DROM J + CRAM J
12583	!*	         = 1400 +  257   +  0000  = 1657
12584	!]ERROR 2
12585	!]IR FCLK SPECIR DISP ACDISP AEQLJ DRMJ DRMCNTRL NTWK
12586		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
12587		THEN LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
12588		0						!TO ILLUMINATE BLISS INFO COMMENT
12589	
12590		END;
12591		LC(1);						!SET CRAM ADRS TO 1
12592		MOD_FLD(1,%O'703');				!MODIFY DISP TYPE
12593		MOD_FLD(2,%O'600');				!TO ADISP
12594	    DO (0) WHILE 
12595	BLOCK3 :
12596		BEGIN
12597		SET_C(0);					!SET CRAM ADRS TO 0
12598		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GAT NXT CRAM ADRS
12599		IF .RCVDATA NEQ 0				!CHECK DATA
12600		THEN ERRCA(3,0,.RCVDATA,4);			!NO
12601	!*MESSAGE 3
12602	!*STIMULUS:
12603	!*	DID AN ADISP AT DROM LOCATION 777
12604	!*	DROM 777 CONTAINS / 0007,1657,2100
12605	!*RESPONSE:
12606	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12607	!*	NXT ADRS = DROM A + CRAM J (0-7)
12608	!*	         =  00    + 	 000     = 0000
12609	!]ERROR 3
12610	!]IR FCLK SPECIR DRMAB DISP NTWK
12611		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
12612		THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
12613		0						!TO ILLUMINATE BLISS INFO COMMENT
12614	
12615		END;
12616		LC(1);						!LOAD CRAM ADRS 1
12617		MOD_FLD(2,%O'700');				!MODIFY DISP TYPE TO BDISP
12618	    DO (0) WHILE 
12619	BLOCK4 :
12620		BEGIN
12621		SET_C(0);					!SET CRAM ADRS TO 0
12622		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12623		IF .RCVDATA NEQ 7				!CHECK DATA
12624		THEN ERRCA(4,7,.RCVDATA,4);			!NO
12625	!*MESSAGE 4
12626	!*STIMULUS:
12627	!*	DID A BDISP AT DROM LOCATION 777
12628	!*	DROM 777 CONTAINS / 0007,1657,2100
12629	!*RESPONSE:
12630	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12631	!*	NXT ADRS = DROM  + CRAM J (0-7)
12632	!*	         =  07    + 	 000     = 007
12633	!]ERROR 4
12634	!]IR FCLK SPECIR DRMAB DISP NTWK
12635		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
12636		THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
12637		0						!TO ILLUMINATE BLISS INFO COMMENT
12638	
12639		END;
12640		LC(1);						!LOAD CRAM ADRS 1
12641		MOD_FLD(1,%O'6507');				!MODIFY TO SKIP
12642		MOD_FLD(2,7);					!ON TXXX
12643		DO (0) WHILE
12644	BLOCK5:	BEGIN
12645		SET_C(0);					!SET CRAM ADRS TO 0
12646		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12647		IF .RCVDATA NEQ 1				!CHECK DATA
12648			THEN ERRCA(5,1,.RCVDATA,4);		!NO
12649	!*MESSAGE 5
12650	!*STIMULUS:
12651	!*	DID A SKIP ON TXXX (SKIP = 57) AT DROM LOCATION 777
12652	!*	DROM 777 SHOULD CONTAIN TXXX HI
12653	!*	WE GET NXT CRAM ADRS = CRAM J + 1 = 1
12654	!*RESPONSE:
12655	!*	EXAMINE DATA FROM PHYSICAL MEM 0
12656	!]ERROR 5
12657	!]IR SPECIR FCLK DRMCNTRL TXXX ADEQ0 SKIP NTWK
12658		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET ?
12659			THEN LEAVE BLOCK5 WITH 1;		!LEAVE BLOCK TO LOOP
12660		0						!TO ILLUMINATE BLISS INFO COMMENT
12661	
12662		END;
12663		LOAD_U(1,POINTER1);				!LOAD INSTRUCTIONS TO VERIFY VMA EN BIT
12664		SET_C(1);					!SET CRAM ADRS TO 1
12665		DO (0) WHILE
12666	BLOCK6:	BEGIN
12667		DM(0,%O'-1');					!SET MEM TO 1'S
12668		CP(7);						!GIVE 7 CLOCKS
12669		RCVDATA = EM(0);				!GET DATA FROM MEM
12670		IF .RCVDATA NEQ 0				!CHECK DATA
12671			THEN ERRCA(6,0,.RCVDATA,12);	!NO
12672	!*MESSAGE 6
12673	!*STIMULUS:
12674	!*	DEPOSITE -1 IN PHYSICAL MEM 0
12675	!*	LOAD THE VMA WITH 11012
12676	!*	LOAD THE IR WITH DROM ADDRESS /777
12677	!*	DROM CONTAINS /0007,1657,2100
12678	!*	VMA EN BIT IS HI
12679	!*	LOAD THE VMA WITH 0 IF DROM ASKS
12680	!*	WRITE A ZERO TO PHYSICAL MEM
12681	!*RESPONSE:
12682	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
12683	!]ERROR 6
12684	!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
12685		IF LOOP_CHK(6)					!IS LOOP ON ERROR SET ?
12686			THEN LEAVE BLOCK6 WITH 1;		!LEAVE BLOCK TO LOOP
12687		0						!TO ILLUMINATE BLISS INFO COMMENT
12688	
12689		END;
12690		LDVMA = 0;					!CLEAR FLAG IT COULD HAVE CHANGED
12691		VMA_LD();					!LOAD THE VMA WITH A ZERO
12692		LOAD_U(1,POINTER2);				!LOAD INSTUCTIONS TO VERIFY COND FUNC BIT
12693		SET_C(1);					!SET CRAM ADRS TO 1
12694		DO (0) WHILE
12695	BLOCK7:	BEGIN
12696		DM(0,%O'-1');					!SET MEM TO ALL ONES
12697		CP(3);						!GIVE 3 CLOCKS
12698		RCVDATA = EM(0);				!GET DATA
12699		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
12700			THEN ERRCA(7,%O'-1',.RCVDATA,12);	!NO
12701	!*MESSAGE 7
12702	!*STIMULUS:
12703	!*	LOAD THE VMA WITH A ZERO
12704	!*	DEPOSITE -1 IN PHYSICAL MEM 0
12705	!*	LOAD THE IR WITH DROM ADDRESS /777
12706	!*	DROM CONTAINS /0007,1657,2100
12707	!*	COND FUNC BIT IS LO
12708	!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
12709	!*RESPONSE:
12710	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
12711	!]ERROR 7
12712	!]IR FCLK SPECIR DRMCNTRL NTWK
12713		IF LOOP_CHK(7)					!IS LOOP ON ERROR SET ?
12714			THEN LEAVE BLOCK7 WITH 1;		!LEAVE BLOCK TO LOOP
12715		0						!TO ILLUMINATE BLISS INFO COMMENT
12716	
12717		END;
12718		LOAD_U(1,POINTER3);				!LOAD INSTUCTIONS TO VERIFY RED & WRT TEST BITS
12719		SET_C(1);					!SET CRAM ADRS TO 1
12720		DO (0) WHILE
12721	BLOCK8:	BEGIN
12722		CP(5);						!GIVE 5 CLOCKS
12723		RCVDATA = EM(0);				!GET DATA FROM MEM
12724		RCVDATA = .RCVDATA AND %O'60000000000';		!CLEAN UNWANTED BITS
12725		IF .RCVDATA NEQ 0				!CHECK DATA
12726			THEN ERRCA(8,0,.RCVDATA,12);		!NO
12727	!*MESSAGE 8
12728	!*STIMULUS:
12729	!*	LOAD THE IR WITH DROM ADDRESS /777
12730	!*	DROM CONTAINS /0007,1657,2100
12731	!*	READ AND WRT TEST BITS ARE LO
12732	!*	START A MEM CYCLE DO AN AREAD IF DROM ASKS
12733	!*	ABORT MEM CYCLE, AND STOR THE VMA FLAGS IN 2901'S VIA DBM & DBUS
12734	!*	START A MEM CYCLE
12735	!*	FINISH MEM CYCLE AND OUTPUT THE VMA FLAGS TO MEM
12736	!*	(BITS 3 & 4 CONTAIN DROM BITS READ AND WRT TEST)
12737	!*RESPONSE:
12738	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
12739	!]ERROR 8
12740	!]IR FCLK SPECIR DRMCNTRL NTWK
12741		IF LOOP_CHK(8)					!IS LOOP ON ERROR SET ?
12742			THEN LEAVE BLOCK8 WITH 1;		!LEAVE BLOCK TO LOOP
12743		0						!TO ILLUMINATE BLISS INFO COMMENT
12744	
12745		END;
12746		END;
12747	
12748	GLOBAL ROUTINE TST65: NOVALUE =
12749	!THIS TEST COMBINED WITH OTHER TESTS VERIFIES THE OUTPUT PINS OF 
12750	!THE DROM.SELECTING A DROM LOCATION (126), THE ADDRESS(126) IS
12751	!LOADED BY EXECUTING AN INSTRUCTION THAT WILL USE THE FOLOWING PATH:
12752	!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
12753	!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
12754	!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
12755	!	NUMBER IS LOADED WITH THE DROM ADDRESS.
12756	!THE OUTPUT OF THE DROM (A,B,J,AC DISP,A=J)PINS  IS VERIFIED BY 
12757	!EXECUTING 4 DISPATCH TYPES, AND CHECKING THE NEXT CRAM ADDRESS.
12758	!INSTRUCTIONS ARE EXECUTED AT CRAM LOCATIONS 0 & 1. THE ORED J FIELD 
12759	!IS ALWAYS ZERO.
12760	    BEGIN
12761	    LABEL
12762		BLOCK1,
12763		BLOCK2,
12764		BLOCK3,
12765		BLOCK4;
12766		BIND
12767		   POINTER = PLIT(U_J(1) U_N(126000) U_DBUS_DBM U_SPEC_LOADIR U,
12768			    	 U_DISP_DROM U);		!GET 2 WORDS
12769		LOAD_U(0,POINTER);				!LOAD THEM
12770	    DO (0) WHILE 
12771	BLOCK1 :
12772		BEGIN
12773		SET_C(0);					!SET CRAM ADRS TO 0
12774		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12775		IF .RCVDATA NEQ %O'1626'			!CHECK DATA
12776		THEN ERRCA(1,%O'1626',.RCVDATA,4);		!NO
12777	!*MESSAGE 1
12778	!*STIMULUS:
12779	!*	DID A DROM DISPATCH AT DROM LOCATION 126
12780	!*	DROM 126 CONTAINS / 0711,1626,1100
12781	!*	AC DISP BIT IS LO
12782	!*RESPONSE:
12783	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12784	!*	NXT ADRS = 1400 + DROM J + CRAM J
12785	!*	         = 1400 +  226   +  0000  = 1626
12786	!]ERROR 1
12787	!]IR FCLK SPECIR DRMCNTRL ACDISP DRMJ DISP NTWK
12788		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
12789		THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
12790		0						!TO ILLUMINATE BLISS INFO COMMENT
12791	
12792		END;
12793		LC(1);						!LOAD CRAM ADRS 1
12794		MOD_FLD(2,%O'300');				!MODIFY DISP TYPE TO AREAD
12795	    DO (0) WHILE 
12796	BLOCK2 :
12797		BEGIN
12798		SET_C(0);					!SET CRAM ADRS TO 0
12799		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12800		IF .RCVDATA NEQ %O'47'				!CHECK DATA
12801		THEN ERRCA(2,%O'47',.RCVDATA,4);		!NO
12802	!*MESSAGE 2
12803	!*STIMULUS:
12804	!*	DID AN AREAD DISPATCH AT DROM LOCATION 126
12805	!*	DROM 126 CONTAINS / 0711,1626,1100
12806	!*	DROM A=J BIT IS LO ACDICP BIT IS LO
12807	!*RESPONSE:
12808	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12809	!*	NXT ADRS = 40  +  DROM A
12810	!*	         = 40  +  07     = 47
12811	!]ERROR 2
12812	!]IR FCLK SPECIR DRMCNTRL AEQLJ DRMAB DISP NTWK
12813		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
12814		THEN LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
12815		0						!TO ILLUMINATE BLISS INFO COMMENT
12816	
12817		END;
12818		LC(1);						!SET CRAM ADRS TO 1
12819		MOD_FLD(1,%O'703');				!MODIFY DISP TYPE 
12820		MOD_FLD(2,%O'600');				!TO ADISP
12821	    DO (0) WHILE 
12822	BLOCK3 :
12823		BEGIN
12824		SET_C(0);					!SET CRAM ADRS TO 0
12825		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12826		IF .RCVDATA NEQ 7				!CHECK DATA
12827		THEN ERRCA(3,7,.RCVDATA,4);			!NO
12828	!*MESSAGE 3
12829	!*STIMULUS:
12830	!*	DID AN ADISP AT DROM LOCATION 126
12831	!*	DROM 126 CONTAINS / 0711,1626,1100
12832	!*RESPONSE:
12833	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12834	!*	NXT ADRS = DROM A + CRAM J (0-7)
12835	!*	         =  07    + 	 000     = 0007
12836	!]ERROR 3
12837	!]IR FCLK SPECIR DISP DRMAB NTWK
12838		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
12839		THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
12840		0						!TO ILLUMINATE BLISS INFO COMMENT
12841	
12842		END;
12843		LC(1);						!LOAD CRAM ADRS 1
12844		MOD_FLD(2,%O'700');				!MODIFY DISP TYPE TO BDISP
12845	    DO (0) WHILE 
12846	BLOCK4 :
12847		BEGIN
12848		SET_C(0);					!SET CRAM ADRS TO 0
12849		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12850		IF .RCVDATA NEQ %O'11'				!CHECK DATA
12851		THEN ERRCA(4,%O'11',.RCVDATA,4);		!NO
12852	!*MESSAGE 4
12853	!*STIMULUS:
12854	!*	DID A BDISP AT DROM LOCATION 126
12855	!*	DROM 126 CONTAINS / 0711,1626,1100
12856	!*RESPONSE:
12857	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12858	!*	NXT ADRS = DROM B + CRAM J (0-7)
12859	!*		 =   11   +    000	 = 0011
12860	!]ERROR 4
12861	!]IR FCLK SPECIR DISP DRMAB NTWK
12862		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
12863		THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
12864		0						!TO ILLUMINATE BLISS INFO COMMENT
12865	
12866		END;
12867		END;
12868	
12869	GLOBAL ROUTINE TST66: NOVALUE =
12870	!THIS TEST COMBINED WITH OTHER TESTS VERIFIES THE OUTPUT PINS OF 
12871	!THE DROM.SELECTING A DROM LOCATION (701), THE ADDRESS(701) IS
12872	!LOADED BY EXECUTING AN INSTRUCTION THAT WILL USE THE FOLOWING PATH:
12873	!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
12874	!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
12875	!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
12876	!	NUMBER IS LOADED WITH THE DROM ADDRESS.
12877	!THE OUTPUT OF THE DROM (A,B,J,AC DISP,A=J)PINS  IS VERIFIED BY 
12878	!EXECUTING 4 DISPATCH TYPES, AND CHECKING THE NEXT CRAM ADDRESS.
12879	!INSTRUCTIONS ARE EXECUTED AT CRAM LOCATIONS 0 & 1. THE ORED J FIELD 
12880	!IS ALWAYS ZERO.
12881	    BEGIN
12882	    LABEL
12883		BLOCK1,
12884		BLOCK2,
12885		BLOCK3,
12886		BLOCK4,
12887		BLOCK5;
12888		BIND
12889		   POINTER = PLIT (U_J(1) U_N(701000) U_DBUS_DBM U_SPEC_LOADIR U,
12890				   U_DISP_DROM U);		!GET 2 WORDS
12891		LOAD_U(0,POINTER);				!LOAD THEM
12892	    DO (0) WHILE 
12893	BLOCK1 :
12894		BEGIN
12895		SET_C(0);					!SET CRAM ADRS TO 0
12896		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12897		IF .RCVDATA NEQ %O'1720'			!CHECK DATA
12898		THEN ERRCA(1,%O'1720',.RCVDATA,4);		!NO
12899	!*MESSAGE 1
12900	!*STIMULUS:
12901	!*	DID A DROM DISPATCH AT DROM LOCATION 701
12902	!*	DROM 701 CONTAINS / 1200,1720,4100
12903	!*	AC DISP BIT IS HI AC FIELD LOADED IS ZERO
12904	!*RESPONSE:
12905	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12906	!*	NXT ADRS = 1400 + DROM J + AC FIELD
12907	!*	         = 1400 +  320   +  0000  = 1720
12908	!]ERROR 1
12909	!]IR FCLK SPECIR DRMCNTRL ACDISP DISP DRMJ NTWK
12910		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET
12911		THEN LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
12912		0						!TO ILLUMINATE BLISS INFO COMMENT
12913	
12914		END;
12915		LC(0);						!LOAD CRAM ADRS 0
12916		MOD_FLD(3,%O'1740');				!MODIFY AC FIELD IN INSTRUCTION TO 17
12917	    DO (0) WHILE 
12918	BLOCK2 :
12919		BEGIN
12920		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12921		IF .RCVDATA NEQ %O'1737'			!CHECK DATA
12922		THEN ERRCA(2,%O'1737',.RCVDATA,4);		!NO
12923	!*MESSAGE 2
12924	!*STIMULUS:
12925	!*	DID A DROM DISPATCH DROM LOCATION
12926	!*	CONTAINS AC DISP BIT HI
12927	!*	AC FIELD IS 17
12928	!*RESPONSE:
12929	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12930	!*	NXT ADRS = 1400 + DROM J + AC FIELD
12931	!*		 =1400  +  320   +  17	      = 1737
12932	!]ERROR 2
12933	!]IR FCLK SPECIR ACDISP DRMCNTRL DISP DRMJ NTWK
12934		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET
12935		THEN 
12936		BEGIN
12937		    SET_C(0);					!SET CRAM ADRS TO 0
12938		    LEAVE BLOCK2 WITH 1;			!LEAVE BLOCK TO LOOP
12939		END;
12940		0						!TO ILLUMINATE BLISS INFO COMMENT
12941	
12942		END;
12943		LC(1);						!LOAD CRAM ADRS 1
12944		MOD_FLD(2,%O'300');				!MODIFY DISP TYPE TO AREAD
12945	    DO (0) WHILE 
12946	BLOCK3 :
12947		BEGIN
12948		SET_C(0);					!SET CRAM ADRS TO 0
12949		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS AND GET NXT CRAM ADRS
12950		IF .RCVDATA NEQ %O'52'				!CHECK DATA
12951		THEN ERRCA(3,%O'52',.RCVDATA,4);		!NO
12952	!*MESSAGE 3
12953	!*STIMULUS:
12954	!*	DID AN AREAD DISPATCH AT DROM LOCATION 701
12955	!*	DROM 701 CONTAINS / 1200,1720,4100
12956	!*	DROM A=J BIT IS LO
12957	!*RESPONSE:
12958	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12959	!*	NXT ADRS = 40  +  DROM A
12960	!*	         = 40  +  12     = 52
12961	!]ERROR 3
12962	!]IR FCLK SPECIR DRMCNTRL DISP DRMAB AEQLJ NTWK
12963		IF LOOP_CHK(3)					!IS LOOP ON ERROR SET
12964		THEN LEAVE BLOCK3 WITH 1;			!LEAVE BLOCK TO LOOP
12965		0						!TO ILLUMINATE BLISS INFO COMMENT
12966	
12967		END;
12968		LC(1);						!LOAD CRAM ADRS 1
12969		MOD_FLD(1,%O'703');				!MODIFY DISP TYPE 
12970		MOD_FLD(2,%O'600');				!TO ADISP
12971	    DO (0) WHILE 
12972	BLOCK4 :
12973		BEGIN
12974		SET_C(0);					!SET CRAM ADRS TO 0
12975		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
12976		IF .RCVDATA NEQ %O'12'				!CHECK DATA ?
12977		THEN ERRCA(4,%O'12',.RCVDATA,4);		!NO
12978	!*MESSAGE 4
12979	!*STIMULUS:
12980	!*	DID AN ADISP AT DROM LOCATION 701
12981	!*	DROM 701 CONTAINS / 1200,1720,4100
12982	!*RESPONSE:
12983	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
12984	!*	NXT ADRS = DROM A + CRAM J (0-7)
12985	!*	         =  12    + 	 000     = 0012
12986	!]ERROR 4
12987	!]IR FCLK SPECIR DRMAB DISP NTWK
12988		IF LOOP_CHK(4)					!IS LOOP ON ERROR SET
12989		THEN LEAVE BLOCK4 WITH 1;			!LEAVE BLOCK TO LOOP
12990		0						!TO ILLUMINATE BLISS INFO COMMENT
12991	
12992		END;
12993		LC(1);						!LOAD CRAM ADRS 1
12994		MOD_FLD(2,%O'700');				!MODIFY DISP TO BDISP
12995	    DO (0) WHILE 
12996	BLOCK5 :
12997		BEGIN
12998		SET_C(0);					!SET CRAM ADRS TO 0
12999		RCVDATA = STEP_U_NEXT(2);			!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
13000		IF .RCVDATA NEQ 0				!CHECK DATA
13001		THEN ERRCA(5,0,.RCVDATA,4);			!NO
13002	!*MESSAGE 5
13003	!*STIMULUS:
13004	!*	DID A BDISP AT DROM LOCATION 701
13005	!*	DROM 701 CONTAINS / 1200,1720,4100
13006	!*RESPONSE:
13007	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13008	!*	NXT ADRS = DROM B + CRAM J (0-7)
13009	!*		 =   00   +    000	 =0000
13010	!]ERROR 5
13011	!]IR SPECIR FCLK DISP DRMAB NTWK
13012		IF LOOP_CHK(5)					!IS LOOP ON ERROR SET
13013		THEN LEAVE BLOCK5 WITH 1;			!LEAVE BLOCK TO LOOP
13014		0						!TO ILLUMINATE BLISS INFO COMMENT
13015	
13016		END;
13017		END;
13018	
13019	GLOBAL ROUTINE TST67: NOVALUE =
13020	
13021	!THIS TEST CHECKS (VMA EN BIT LO)CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
13022	!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.AND EXECUTE THE FOLLOWING:
13023	!	1)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
13024	!	2)  LOAD THE VMA WITH ADDRESS 11012.
13025	!	3)  LOAD THE IR WITH DROM ADDRESS 240.
13026	!	4)  LOAD THE VMA WITH A ZERO IF DROM ASKS (VMA EN IS LO).
13027	!	5)  WRITE A ZERO TO PHYSICAL MEM.
13028	!	6)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
13029	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
13030	!USES THE FOLOWING PATH:
13031	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13032	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13033	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13034	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13035	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-7.
13036	!CRAM 1/ START A MEM CYCLE AND LOAD THE VMA WITH 11012.
13037	!CRAM 2/ ABORT THE MEM CYCLE.
13038	!CRAM 3/ LOAD THE IR WITH DROM ADDRESS.
13039	!CRAM 4/ START A MEM CYCLE AND LOAD THE VMA WITH 0 IF DROM ASKS.
13040	!CRAM 5/ ABORT THE MEM CYCLE.
13041	!CRAM 6/ START A PHYSICAL MEM WRITE CYCLE.
13042	!CRAM 7/ FINISH THE MEM WRITE CYCLE.
13043	
13044		BEGIN
13045		LABEL BLOCK1;
13046		BIND
13047		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
13048				U_J(3) U_SPEC_MEMCLR U,
13049				U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(240000) U,
13050				U_J(5) U_MEM U_N(11042) U,
13051				U_J(6) U_SPEC_MEMCLR U,
13052				U_J(7) U_MEM U_N(11002) U,
13053				U_J(1) U_MEM U_N(2) U);
13054		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
13055		SET_C(1);					!SET CRAM ADRS TO 1
13056		DO (0) WHILE
13057	BLOCK1:	BEGIN
13058		DM(0,%O'-1');					!SET MEM
13059		CP(7);						!GIVE 7 CLOCKS
13060		RCVDATA = EM(0);				!GET DATA
13061		IF .RCVDATA NEQ %O'-1'				!CHECK DATA
13062			THEN ERRCA(1,%O'-1',.RCVDATA,12);	!NO
13063	!*MESSAGE 1
13064	!*STIMULUS:
13065	!*	DEPOSITE -1 IN PHYSICAL MEM 0
13066	!*	LOAD THE VMA WITH 11012
13067	!*	LOAD THE IR WITH DROM ADDRESS /240
13068	!*	DROM CONTAINS /0400,1622,1000
13069	!*	VMA EN BIT IS LO
13070	!*	LOAD THE VMA WITH 0 IF DROM ASKS
13071	!*	WRITE A ZERO TO PHYSICAL MEM
13072	!*RESPONSE:
13073	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
13074	!]ERROR 1
13075	!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
13076		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
13077			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13078		0						!TO ILLUMINATE BLISS INFO COMMENT
13079	
13080		END;
13081		LDVMA = 0;					!CLEAR THE FLAG VMA HAS CHANGED
13082		END;
13083	
13084	GLOBAL ROUTINE TST68: NOVALUE =
13085	
13086	!THIS TEST CHECKS (COND FUNC, READ & WRT TEST BITS HI)CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
13087	!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.AND EXECUTE THE FOLLOWING
13088	!FOR THE COND FUNC BIT:
13089	!	1)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
13090	!	2)  LOAD THE IR WITH DROM ADDRESS 277.
13091	!	3)  START A PHYSICAL MEM WRITE CYCLE IF DROM ASKS (IF FUNC COND IS HI).
13092	!	4)  FINISH THE MEM CYCLE IF DROM ASKS BY OUTPUTING A ZERO.
13093	!	5)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
13094	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
13095	!USES THE FOLOWING PATH:
13096	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13097	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13098	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13099	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13100	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-3.
13101	!CRAM 1/ LOAD THE IR WITH DROM ADDRESS.
13102	!CRAM 2/ START A MEM  PHYSICAL WRITE CYCLE IF DROM ASKS.
13103	!CRAM 3/ FINISH THE MEM WRITE CYCLE IF DROM ASKS AND OUTPUT A ZERO.
13104	!THIS TEST CALLS A ROUTINE VMA_LD WHICH CHECKS AND LOADS THE VMA WITH A ZERO
13105	!WE EXECUTE DIFFERENT INSTRUCTIONS FOR THE READ & WRT TEST BITS.
13106	
13107		BEGIN
13108		LABEL BLOCK1,BLOCK2;
13109		BIND
13110		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(277000) U,
13111				U_J(3) U_MEM U_N(11011) U,
13112				U_J(1) U_MEM U_N(1) U);
13113		BIND
13114		POINTER1 = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U_N(277000) U,
13115				U_J(3) U_MEM U_N(42) U,
13116				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
13117				U_J(5) U_MEM U_N(11012) U,
13118				U_J(1) U_ALU_OR U_MEM U_N(2) U);
13119		VMA_LD();					!CHECK AND LOAD THE VMA WITH A ZERO
13120		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
13121		SET_C(1);					!SET CRAM ADRS TO 1
13122		DO (0) WHILE
13123	BLOCK1:	BEGIN
13124		DM(0,%O'-1');					!SET MEM TO 1'S
13125		CP(3);						!GIVE 3 CLOCKS
13126		RCVDATA = EM(0);				!GET DATA
13127		IF .RCVDATA NEQ 0				!CHECK DATA
13128			THEN ERRCA(1,0,.RCVDATA,12);		!NO
13129	!*MESSAGE 1
13130	!*STIMULUS:
13131	!*	LOAD THE VMA WITH A ZERO
13132	!*	DEPOSITE -1 IN PHYSICAL MEM 0
13133	!*	LOAD THE IR WITH DROM ADDRESS /277
13134	!*	DROM CONTAINS /0017,1561,1700
13135	!*	COND FUNC BIT IS HI
13136	!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
13137	!*RESPONSE:
13138	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
13139	!]ERROR 1
13140	!]IR SPECIR FCLK DRMCNTRL MEMVMA NTWK
13141		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
13142			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13143		0						!TO ILLUMINATE BLISS INFO COMMENT
13144	
13145		END;
13146		LOAD_U(1,POINTER1);				!LOAD INSTUCTIONS TO VERIFY RED & WRT TEST BITS
13147		SET_C(1);					!SET CRAM ADRS TO 1
13148		DO (0) WHILE
13149	BLOCK2:	BEGIN
13150		CP(5);						!GIVE 5 CLOCKS
13151		RCVDATA = EM(0);				!GET DATA FROM MEM
13152		RCVDATA = .RCVDATA AND %O'60000000000';		!CLEAN UNWANTED BITS
13153		IF .RCVDATA NEQ %O'60000000000'			!CHECK DATA
13154			THEN ERRCA(2,%O'60000000000',.RCVDATA,12);	!NO
13155	!*MESSAGE 2
13156	!*STIMULUS:
13157	!*	LOAD THE IR WITH DROM ADDRESS /277
13158	!*	DROM CONTAINS /0017,1561,1700
13159	!*	READ AND WRT TEST BITS ARE HI
13160	!*	START A MEM CYCLE DO AN AREAD IF DROM ASKS
13161	!*	ABORT MEM CYCLE, AND STOR THE VMA FLAGS IN 2901'S VIA DBM & DBUS
13162	!*	START A MEM CYCLE
13163	!*	FINISH MEM CYCLE AND OUTPUT THE VMA FLAGS TO MEM
13164	!*	(BITS 3 & 4 CONTAIN DROM BITS READ AND WRT TEST)
13165	!*RESPONSE:
13166	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
13167	!]ERROR 2
13168	!]IR FCLK SPECIR DRMCNTRL NTWK
13169		IF LOOP_CHK(2)					!IS LOOP ON ERROR SET ?
13170			THEN LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
13171		0						!TO ILLUMINATE BLISS INFO COMMENT
13172	
13173		END;
13174		END;
13175	
13176	GLOBAL ROUTINE TST69: NOVALUE =
13177	
13178	!THIS TEST CHECKS (ACDISP & J FIELD) CONTENTS IN ALL DROM LOCATIONS.
13179	!IT ALSO CHECKS THE INSTRUCTION REGISTER(IR & AC)FLOPS INPUT AND OUTPUT
13180	!PINS.THIS TEST IS A LOOP OF 512,IT WILL PICK UP CORRECT DROM CONTENTS 
13181	!DATA FROM DATA TABLE (TBL), CHECK ACDISP BIT AND EXECUTE A DROM DISP
13182	!(DISP 12) DOING THE FOLLOWING:
13183	!	1)  IF ACDISP BIT IS LO IT WILL EXECUTE A DROM DIPATCH
13184	!	    AND CHECK THE NEXT ADDRESS = 1400 + DROM J + CRAM J.
13185	!	2)  IF ACDISP BIT IS HI EXECUTE A DROM DISP WITH AC FIELD 00
13186	!	    AND CHECK NXT ADDRESS = 1400 + DROM J + AC FIELD.
13187	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM ADRS 0
13188	!THAT USES THE FOLOWING PATH:
13189	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13190	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13191	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13192	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13193	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
13194	!ALWAYS 0000.EXECUTING THE DISP MODE IS AN INSTRUCTION LOADED IN CRAM 
13195	!ADRS 1.ANY DISCREPANCY IN NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.
13196	
13197	    BEGIN
13198	    LOCAL
13199		J,
13200		ACDISP,
13201		DROM_WRD,
13202		FLD3,
13203		FLD4;
13204	    LABEL
13205		BLOCK1,
13206		BLOCK2;
13207	    BIND
13208		POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
13209				 U_DISP_DROM U);		!GET 2 WORDS
13210	
13211	    IF .DROM_FLAG NEQ 0 
13212	    THEN
13213		RETURN;
13214	    LOAD_U(0, POINTER);					!LOAD THEM
13215	    INCR I FROM 0 TO %O'77' DO
13216		BEGIN
13217		    LC(0);					!LOAD CRAM ADRS 0
13218		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13219		    MOD_FLD(4,.FLD4);				!MODIFY 2 HI OCTAL DIGITS OF DROM ADRS IN MAGIC #
13220		    INCR K FROM 0 TO %O'7' DO
13221			BEGIN
13222			DROM_WRD = .TBL[.I^3+.K];		!GET DROM WORD FROM TABLE
13223			ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
13224			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13225			J = .DROM_WRD<12, 12>;			!GET THE J FIELD
13226			FLD3 = .K<0, 3> ^ 9;			!GET LOW OCTAL DIGIT FOR DROM ADRS
13227			MOD_FLD(3,.FLD3);			!MODIFY LOW DIGIT OF DROM ADRS IN MAGIG #
13228			ACDISP = .DROM_WRD<11, 1>;		!GET ACDISP BIT
13229			IF .ACDISP EQL 0 THEN			!CHECK AC DISP BIT ?
13230			DO (0)	WHILE 				!AC DISP BIT IS LO
13231	BLOCK1 :
13232			BEGIN
13233			RCVDATA = STEP_U_NEXT(2);		!2 CLOCKS & GET NXT CRAM ADRS
13234			IF .RCVDATA NEQ .J			!CHECK IT?
13235			THEN ERRCAS(1,1,.J,.RCVDATA,4,ER_TAB);	!NO
13236	!*MESSAGE 1
13237	!*STIMULUS:
13238	!*	DID A DROM DISPATCH AT DROM LOCATION /\O0
13239	!*	DROM CONTAINS /\U1
13240	!*	AC DISP BIT LO.
13241	!*RESPONSE:
13242	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13243	!*	NXT ADRS = 1400 + DROM J + CRAM J
13244			IF LOOP_CHK(1)				!IS LOOP ON ERROR SET?
13245			THEN 					!YES
13246			BEGIN
13247				SET_C(0);			!SET CRAM ADRS TO 0
13248				LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13249			END;
13250			0					!TO ILLUMINATE BLISS INFO COMMENT
13251			END					!END OF BLOCK1
13252	
13253		    ELSE					!AC DISP BIT IS HI
13254			DO (0) WHILE
13255	BLOCK2:
13256			BEGIN
13257			RCVDATA = STEP_U_NEXT(2);		!2 CLOCKS & GET NXT CRAM ADRS
13258			IF .RCVDATA NEQ .J			!CHECK IT ?
13259			THEN ERRCAS(1,2,.J,.RCVDATA,4,ER_TAB);	!NO
13260	!*MESSAGE 2
13261	!*STIMULUS:
13262	!*	DID A DROM DISPATCH AT DROM LOCATION /\O0
13263	!*	DROM CONTAINS /\U1
13264	!*	AC DISP BIT HI
13265	!*	AC FIELD IS 00
13266	!*RESPONSE:
13267	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13268	!*	NXT ADRS = 1400 + DROM J + AC FIELD
13269	!]ERROR 1
13270	!]IR FCLK SPECIR ACDISP DRMJ DRMCNTRL DISP NTWK
13271			IF LOOP_CHK(2)				!IS LOOP ON ERROR SET ?
13272			THEN 
13273			BEGIN
13274				SET_C(0);			!SET CRAM ADRS TO 0
13275				LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
13276			END;
13277			0					!TO ILLUMINATE BLISS INFO COMMENT
13278		      END;
13279		    END;
13280		 END;
13281		END;
13282	
13283	
13284	
13285	GLOBAL ROUTINE TST70: NOVALUE =
13286	
13287	!THIS TEST CHECKS (A = J & J FIELD)CONTENTS OF DROM.IT ALSO CHECKS
13288	!THE INSTRUCTION REGISTER(IR)FLOPS INPUT AND OUTPUT PINS, AND THE DROM
13289	!A FIELD WHERE A = J BIT IS LO.THIS TEST IS A LOOP OF 512,IT WILL PICK
13290	!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK A = J BIT
13291	!AND EXECUTE AN AREAD DISP (DISP 13) DOING THE FOLLOWING:
13292	!	1)  IF A = J BIT IS HI IT WILL EXECUTE AN AREAD DIPATCH
13293	!	    AND CHECK THE NEXT ADDRESS = 1400 + DROM J + CRAM J.
13294	!	2)  IF A = J BIT IS LO IT WILL EXECUTE AN AREAD DISPATCH
13295	!	    AND CHECK NXT ADDRESS = 40 + DROM A
13296	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 0 THAT
13297	!USES THE FOLOWING PATH:
13298	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13299	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13300	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13301	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13302	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
13303	!ALWAYS 0000.THE EXECUTED DISP TYPE IS AN INSTRUCTION IN CRAM 1.ANY
13304	!DISCREPANCY IN NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.
13305	
13306	    BEGIN
13307	    LOCAL
13308		A,
13309		J,
13310		AEQLJ,
13311		DROM_WRD,
13312		FLD3,
13313		FLD4;
13314	    LABEL
13315		BLOCK1,
13316		BLOCK2;
13317	    BIND
13318		POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
13319				 U_DISP_AREAD U);		!GET TWO WORDS
13320	
13321	    IF .DROM_FLAG NEQ 0 
13322	    THEN
13323		RETURN;
13324	
13325	    LOAD_U(0, POINTER);					!LOAD THEM
13326		    LC(0);					!LOAD CRAM ADRS 0
13327	    INCR I FROM 0 TO %O'77' DO
13328		BEGIN
13329		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13330		    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
13331		    INCR K FROM 0 TO %O'7' DO
13332			BEGIN
13333			DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
13334			ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
13335			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13336			J = .DROM_WRD<12, 12>;			!GET THE J FIELD
13337			FLD3 = .K<0, 3> ^ 9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
13338			MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
13339			AEQLJ = .DROM_WRD<10,1>;		!GET A = J BIT
13340			IF .AEQLJ NEQ 0 THEN			!IS A = J BIT HI ?
13341	    	DO (0)	WHILE 
13342	BLOCK1 :						!YES A = J BIT IS HI
13343			BEGIN
13344			RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS & GET NXT CRAM ADRS
13345			IF .RCVDATA NEQ .J			!IS NXT CRAM ADRS CORRECT
13346			THEN ERRCAS(1,1,.J,.RCVDATA,4,ER_TAB);	!NO
13347	!*MESSAGE 1
13348	!*STIMULUS:
13349	!*	DID AN AREAD DISPATCH AT DROM LOCATION /\O0
13350	!*	DROM CONTAINS /\U1
13351	!*	A = J BIT HI
13352	!*RESPONSE:
13353	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13354	!*	NXT ADRS = 1400 + DROM J + CRAM J
13355	!]ERROR 1
13356	!]IR SPECIR FCLK ACDISP DISP AEQLJ DRMCNTRL DRMJ NTWK
13357			IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
13358			BEGIN
13359				SET_C(0);			!SET CRAM ADRS TO 0
13360				LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13361			END;
13362			0					!TO ILLUMINATE BLISS INFO COMMENT
13363			END
13364		    ELSE					!NO A = J BIT IS LO
13365	     DO (0) WHILE
13366	BLOCK2:
13367			BEGIN
13368			RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
13369			A = .DROM_WRD<30,6>;			!GET THE A FIELD
13370			ER_TAB[2] = .A;				!STOR A FIELD FOR ERROR PRINTOUT
13371			J = .A OR %O'40';			!GET EXPECTED DATA
13372			IF .RCVDATA NEQ .J			!CHECK DATA ?
13373			THEN ERRCAS(2,2,.J,.RCVDATA,4,ER_TAB);	!NO
13374	!*MESSAGE 2
13375	!*STIMULUS:
13376	!*	DID AN AREAD DISPATCH AT DROM LOCATION /\O0
13377	!*	DROM CONTAINS /\U1
13378	!*	A = J BIT IS LO
13379	!*	DROM A CONTAINS /\O2
13380	!*RESPONSE:
13381	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13382	!*	NXT ADRS = 40 + DROM A 
13383	!]ERROR 2
13384	!]IR FCLK SPECIR AEQLJ DRMCNTRL DRMAB NTWK
13385			IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
13386			THEN 
13387			BEGIN
13388				SET_C(0);			!SET CRAM ADRS TO 0
13389				LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
13390			END;
13391			0					!TO ILLUMINATE BLISS INFO COMMENT
13392			END;
13393		    END;
13394		END;
13395		END;
13396	
13397	
13398	GLOBAL ROUTINE TST71: NOVALUE =
13399	
13400	!THIS TEST CHECKS (TXXX BIT )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
13401	!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
13402	!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK TXXX BIT
13403	!AND EXECUTE A TXXX SKIP (SKIP 57) DOING THE FOLLOWING:
13404	!	1)  IF TXXX BIT IS HI IT WILL EXECUTE A SKIP
13405	!	    AND CHECK THE NEXT ADDRESS = CRAM J + 1
13406	!	2)  IF TXXX BIT IS LO IT WILL EXECUTE A SKIP
13407	!	    AND CHECK NXT ADDRESS = CRAM J + 0 
13408	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 0 THAT
13409	!USES THE FOLOWING PATH:
13410	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13411	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13412	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13413	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13414	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
13415	!ALWAYS 0000.THE EXECUTED SKIP INSTRUCTION IN CRAM 1.ANY DISCREPANCY IN 
13416	!NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.
13417	
13418	    BEGIN
13419	    LOCAL
13420		TXXX,
13421		DROM_WRD,
13422		FLD3,
13423		FLD4;
13424	    LABEL
13425		BLOCK1,
13426		BLOCK2;
13427	    BIND
13428		POINTER = PLIT (U_J(1) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_SPEC_LDINST U,
13429				U_ALU_OR U_SKIP_TXXX U);	!GET 2 WORDS
13430	
13431	    IF .DROM_FLAG NEQ 0 
13432	    THEN
13433		RETURN;
13434	
13435		LOAD_U(0, POINTER);				!LOAD THEM
13436		LC(0);						!LOAD CRAM ADRS 0
13437	    INCR I FROM 0 TO %O'77' DO
13438		BEGIN
13439		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13440		    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
13441		    INCR K FROM 0 TO %O'7' DO
13442			BEGIN
13443			DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
13444			ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
13445			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13446			FLD3 = (.K<0, 3>^9) OR %O'17';		!GET THE LO OCTAL DIGIT OF THE DROM ADRS
13447			MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
13448			TXXX = .DROM_WRD<26,1>;			!GET TXXX BIT (COPY BIT 9 B FIELD)
13449			IF .TXXX NEQ 0 THEN			!IS TXXX BIT HI ?
13450	    	DO (0)	WHILE 
13451	BLOCK1 :						!YES TXXX BIT IS HI
13452			BEGIN
13453			RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS & GET NXT CRAM ADRS
13454			IF .RCVDATA NEQ 1			!IS NXT CRAM ADRS CORRECT
13455			THEN ERRCAS(1,1,1,.RCVDATA,4,ER_TAB);	!NO
13456	!*MESSAGE 1
13457	!*STIMULUS:
13458	!*	DID SKIP ON TXXX AT DROM LOCATION /\O0
13459	!*	DROM CONTAINS /\U1
13460	!*	TXXX BIT HI
13461	!*RESPONSE:
13462	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13463	!*	NXT ADRS = CRAM J + 1
13464			IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
13465			BEGIN
13466			    SET_C(0);				!SET CRAM ADRS TO 0
13467			    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13468			END;
13469			0					!TO ILLUMINATE BLISS INFO COMMENT
13470			END
13471		    ELSE					!NO TXXX BIT IS LO
13472	     DO (0) WHILE
13473	BLOCK2:
13474			BEGIN
13475			RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS THEN GET NXT CRAM ADRS
13476			IF .RCVDATA NEQ 0			!CHECK DATA ?
13477			THEN ERRCAS(1,2,0,.RCVDATA,4,ER_TAB);	!NO
13478	!*MESSAGE 2
13479	!*STIMULUS:
13480	!*	DID SKIP ON TXXX AT DROM LOCATION /\O0
13481	!*	DROM CONTAINS /\U1
13482	!*	TXXX BIT IS LO
13483	!*RESPONSE:
13484	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13485	!*	NXT ADRS = CRAM J + 0
13486	!]ERROR 1
13487	!]IR FCLK SPECIR TXXX DRMCNTRL SKIP ADEQ0 NTWK
13488			IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
13489			THEN 
13490			BEGIN
13491	
13492			    SET_C(0);				!SET CRAM ADRS TO 0
13493			    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
13494			END;
13495			0					!TO ILLUMINATE BLISS INFO COMMENT
13496			END;
13497		    END;
13498		END;
13499		END;
13500	
13501	
13502	GLOBAL ROUTINE TST72: NOVALUE =
13503	
13504	!THIS TEST CHECKS (VMA EN BIT )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
13505	!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
13506	!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK VMA EN BIT
13507	!AND EXECUTE THE FOLLOWING:
13508	!	1)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
13509	!	2)  LOAD THE VMA WITH ADDRESS 11012.
13510	!	3)  LOAD THE IR WITH A DROM ADDRESS.
13511	!	4)  LOAD THE VMA WITH A ZERO IF DROM ASKS (IF VMA EN IS HI).
13512	!	5)  WRITE A ZERO TO PHYSICAL MEM.
13513	!	6)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
13514	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
13515	!USES THE FOLOWING PATH:
13516	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13517	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13518	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13519	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13520	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-7.
13521	!CRAM 1/ START A MEM CYCLE AND LOAD THE VMA WITH 11012.
13522	!CRAM 2/ ABORT THE MEM CYCLE.
13523	!CRAM 3/ LOAD THE IR WITH DROM ADDRESS.
13524	!CRAM 4/ START A MEM CYCLE AND LOAD THE VMA WITH 0 IF DROM ASKS.
13525	!CRAM 5/ ABORT THE MEM CYCLE.
13526	!CRAM 6/ START A PHYSICAL MEM WRITE CYCLE.
13527	!CRAM 7/ FINISH THE MEM WRITE CYCLE.
13528	
13529		BEGIN
13530	    LOCAL
13531		VMAEN,
13532		DROM_WRD,
13533		FLD3,
13534		FLD4;
13535		LABEL BLOCK1,BLOCK2;
13536		BIND
13537		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_MEM U_N(11012) U,
13538				U_J(3) U_SPEC_MEMCLR U,
13539				U_J(4) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
13540				U_J(5) U_MEM U_N(11042) U,
13541				U_J(6) U_SPEC_MEMCLR U,
13542				U_J(7) U_MEM U_N(11002) U,
13543				U_J(1) U_MEM U_N(2) U);
13544	
13545	    IF .DROM_FLAG NEQ 0 
13546	    THEN
13547		RETURN;
13548	
13549		LOAD_U(1,POINTER);				!LOAD 7 INSTRUCTIONS
13550	    INCR I FROM 0 TO %O'77' DO
13551		BEGIN
13552		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13553		    LC(3);					!LOAD CRAM ADRS 3
13554		    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
13555		    INCR K FROM 0 TO %O'7' DO
13556			BEGIN
13557			DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
13558			ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
13559			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13560			FLD3 = .K<0, 3>^9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
13561			LC(3);					!LOAD CRAM ADRS 3
13562			MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
13563			VMAEN = .DROM_WRD<6,1>;			!GET VMA EN BIT 
13564			SET_C(1);				!SET CRAM ADRS TO 1
13565			IF .VMAEN NEQ 0 THEN			!IS VMA EN BIT HI ?
13566	    	DO (0)	WHILE 
13567	BLOCK1 :						!YES VMA EN BIT IS HI
13568			BEGIN
13569			DM(0,%O'-1');				!SET MEM TO ONES
13570			CP(7);					!GIVE 7 CLOCKS
13571			RCVDATA = EM(0);			!GET DATA
13572			IF .RCVDATA NEQ 0			!CHECK DATA
13573			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
13574	!*MESSAGE 1
13575	!*STIMULUS:
13576	!*	DEPOSITE -1 IN PHYSICAL MEM 0
13577	!*	LOAD THE VMA WITH 11012
13578	!*	LOAD THE IR WITH DROM ADDRESS /\O0
13579	!*	DROM CONTAINS /\U1
13580	!*	VMA EN BIT IS HI
13581	!*	LOAD THE VMA WITH 0 IF DROM ASKS
13582	!*	WRITE A ZERO TO PHYSICAL MEM
13583	!*RESPONSE:
13584	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
13585			IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
13586			LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
13587		0						!TO ILLUMINATE BLISS INFO COMMENT
13588	
13589			END
13590		    ELSE					!NO VMA EN BIT IS LO
13591	     DO (0) WHILE
13592	BLOCK2:
13593			BEGIN
13594			DM(0,%O'-1');				!SET MEM TO ONES
13595			CP(7);					!GIVE 7 CLOCKS
13596			RCVDATA = EM(0);			!GET DATA
13597			IF .RCVDATA NEQ %O'-1'			!CHECK DATA ?
13598			THEN ERRCAS(1,2,%O'-1',.RCVDATA,12,ER_TAB);!NO
13599	!*MESSAGE 2
13600	!*STIMULUS:
13601	!*	DEPOSITE -1 IN PHYSICAL MEM 0
13602	!*	LOAD THE VMA WITH 11012
13603	!*	LOAD THE IR WITH DROM ADDRESS /\O0
13604	!*	DROM CONTAINS /\U1
13605	!*	VMA EN BIT IS LO
13606	!*	LOAD THE VMA WITH 0 IF DROM ASKS
13607	!*	WRITE A ZERO TO PHYSICAL MEM
13608	!*RESPONSE:
13609	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
13610	!]ERROR 1
13611	!]IR FCLK SPECIR DRMCNTRL MEMVMA NTWK
13612			IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
13613			THEN 
13614			    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
13615		0						!TO ILLUMINATE BLISS INFO COMMENT
13616	
13617			END;
13618		    END;
13619		END;
13620		LDVMA = 0;					!CLEAR FLAG VMA HAS CHANGED
13621		END;
13622	
13623	GLOBAL ROUTINE TST73: NOVALUE =
13624	
13625	!THIS TEST CHECKS (WRT TEST & READ BITS )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
13626	!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
13627	!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK COND FUNC BIT
13628	!AND EXECUTE THE FOLLOWING:
13629	!	1)  LOAD THE IR WITH A DROM ADDRESS.
13630	!	2)  START A MEM CYCLE WITH # BIT 12 SET.
13631	!	3)  ABORT THE CYCLE AND LOAD THE VMA FLAGS INTO REGISTER 0 OF
13632	!	    OF THE 2901'S VIA DBM & DBUS.
13633	!	4)  START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0.
13634	!	5)  FINISH THE MEM CYCLE BY OUPUTING THE CONTENTS OF REGISTER 0 INTO MEM.
13635	!	6)  READ PHYSICAL MEM 0 AND AND VERIFY BITS 3 & 4.
13636	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
13637	!USES THE FOLOWING PATH:
13638	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13639	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13640	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13641	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13642	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-3.
13643	!CRAM 1/ LOAD THE IR WITH DROM ADDRESS.
13644	!CRAM 2/ START A MEM CYCLE WITH BIT 12 OF # FIELD SET.
13645	!CRAM 3/ ABORT MEM CYCLE AND SELECT DBM = 5 TO LOAD THE VMA FLAGS.
13646	!	 THEN PASS THE DBM INTO REGISTER 0 OF THE 2901'S VIA DBUS.
13647	!	 (BITS 3 & 4 WILL CONTAIN READ & WRT_TST BITS)
13648	!CRAM 4/ START A PHYSICAL MEM WRITE CYCLE AND LOAD THE VMA WITH A 0.
13649	!CRAM 5/ FINISH THE MEM WRITE CYCLE AND OUTPUT THE CONTENTS OF REGISTER 0 TO MEM
13650	
13651		BEGIN
13652	    LOCAL
13653		WRTTST,READ,RCVREAD,RCVWRTST,DROM_WRD,FLD3,FLD4;
13654		LABEL BLOCK1;
13655		BIND
13656		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
13657				U_J(3) U_MEM U_N(42) U,
13658				U_J(4) U_ALU_OR U_LSRC_D0 U_DEST_AD U_DBUS_DBM U_DBM_VMA U_SPEC_MEMCLR U,
13659				U_J(5) U_MEM U_N(11012) U,
13660				U_J(1) U_ALU_OR U_MEM U_N(2) U);
13661	
13662	    IF .DROM_FLAG NEQ 0 
13663	    THEN
13664		RETURN;
13665	
13666		LOAD_U(1,POINTER);				!LOAD INSTRUCTIONS
13667	        LC(1);						!LOAD CRAM ADRS 1
13668	    INCR I FROM 0 TO %O'77' DO
13669		BEGIN
13670		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13671		    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
13672		    INCR K FROM 0 TO %O'7' DO
13673			BEGIN
13674			DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
13675			ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
13676			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13677			FLD3 = .K<0, 3>^9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
13678			MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
13679			WRTTST =  .DROM_WRD<8,1>;		!GET WRTTST BIT FROM TABLE
13680			READ = .DROM_WRD<9,1>;			!GET READ BIT FROM TABLE
13681			IF .WRTTST EQL 0 
13682			THEN
13683			    ER_TAB[2] = UPLIT (%ASCIZ'LO')
13684			ELSE
13685			    ER_TAB[2] = UPLIT (%ASCIZ'HI');
13686			IF .READ EQL 0
13687			THEN
13688			    ER_TAB[4] = UPLIT (%ASCIZ'LO')
13689			ELSE
13690			    ER_TAB[4] = UPLIT (%ASCIZ'HI');
13691		DO (0) WHILE
13692	BLOCK1:	BEGIN
13693		CP(5);						!GIVE 5 CLOCKS
13694		RCVDATA = EM(0);				!GET DATA
13695		RCVWRTST = .RCVDATA<31,1>;
13696		RCVREAD = .RCVDATA<32,1>;
13697		IF .RCVWRTST EQL 0
13698		THEN
13699		    ER_TAB[3] = UPLIT (%ASCIZ'LO')
13700		ELSE
13701		    ER_TAB[3] = UPLIT (%ASCIZ'HI');
13702		IF .RCVREAD EQL 0
13703		THEN
13704		    ER_TAB[5] = UPLIT (%ASCIZ'LO')
13705		ELSE
13706		    ER_TAB[5] = UPLIT (%ASCIZ'HI');
13707	
13708		IF (.RCVWRTST NEQ .WRTTST) OR (.RCVREAD NEQ .READ)    !CHECK DATA
13709			THEN ERRS(1,1,ER_TAB);			!NO
13710	!*MESSAGE 1
13711	!*STIMULUS:
13712	!*	LOAD THE IR WITH DROM ADDRESS /\O0
13713	!*	DROM CONTAINS /\U1
13714	!*	WRT TEST BIT FOUND WAS \S3, IT SHOULD BE \S2
13715	!*	READ BIT FOUND WAS \S5, IT SHOULD BE \S4
13716	!]ERROR 1
13717	!]IR FCLK SPECIR DRMCNTRL NTWK
13718		IF LOOP_CHK(1)					!IS LOOP ON ERROR SET ?
13719			THEN LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13720		0						!TO ILLUMINATE BLISS INFO COMMENT
13721	
13722			END;
13723		     END;
13724		   END;
13725		END;
13726	
13727	
13728	GLOBAL ROUTINE TST74: NOVALUE =
13729	
13730	!THIS TEST CHECKS (COND FUNC BIT )CONTENTS OF DROM.IT ALSO CHECKS THE INSTRUCTION
13731	!REGISTER(IR)FLOPS INPUT AND OUTPUT PINS,THIS TEST IS A LOOP OF 512,IT WILL PICK
13732	!UP CORRECT DROM CONTENTS DATA FROM DATA TABLE (TBL), CHECK COND FUNC BIT
13733	!AND EXECUTE THE FOLLOWING:
13734	!	1)  LOAD THE VMA WITH ADDRESS 11012.
13735	!	2)  DEPOSITE A (-1) IN PHYSICAL MEM 0.
13736	!	3)  LOAD THE IR WITH A DROM ADDRESS.
13737	!	4)  START A PHYSICAL MEM WRITE CYCLE IF DROM ASKS (IF FUNC COND IS HI).
13738	!	5)  FINISH THE MEM CYCLE BY IF DROM ASKS BY OUTPUTING A ZERO.
13739	!	6)  READ PHYSICAL MEM 0 AND SEE IF IT CHANGED.
13740	!THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION IN CRAM 3 THAT
13741	!USES THE FOLOWING PATH:
13742	!	    LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13743	!	    SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13744	!	    MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13745	!	    NUMBER IS LOADED WITH THE DROM ADDRESS.
13746	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 1-3.
13747	!CRAM 1/ LOAD THE IR WITH DROM ADDRESS.
13748	!CRAM 2/ START A MEM  PHYSICAL WRITE CYCLE IF DROM ASKS.
13749	!CRAM 3/ FINISH THE MEM WRITE CYCLE IF DROM ASKS AND OUTPUT A ZERO.
13750	!THIS TEST CALLS A ROUTINE VMA_LD WHICH CHECKS AND LOADS THE VMA WITH A ZERO
13751	
13752		BEGIN
13753	    LOCAL
13754		CONDFUNC,
13755		DROM_WRD,
13756		FLD3,
13757		FLD4;
13758		LABEL BLOCK1,BLOCK2;
13759		BIND
13760		POINTER = PLIT (U_J(2) U_ALU_OR U_LSRC_D0 U_DBUS_DBM U_SPEC_LOADIR U,
13761				U_J(3) U_MEM U_N(11001) U,
13762				U_J(1) U_MEM U_N(1) U);
13763	
13764	    IF .DROM_FLAG NEQ 0 
13765	    THEN
13766		RETURN;
13767	
13768		VMA_LD();					!CHECK AND LOAD THE VMA WITH A ZERO
13769		LOAD_U(1,POINTER);				!LOAD 3 INSTRUCTIONS
13770	        LC(1);						!LOAD CRAM ADRS 1
13771	    INCR I FROM 0 TO %O'77' DO
13772		BEGIN
13773		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13774		    MOD_FLD(4,.FLD4);				!MODIFY THE 2 HI OCTAL DIGITS IN DROM ADRS
13775		    INCR K FROM 0 TO %O'7' DO
13776			BEGIN
13777			DROM_WRD = .TBL[.I^3+.K];		!GET THE DROM CONTENTS FROM TABLE
13778			ER_TAB[0] = (.I^3 + .K);		!SET UP FOR ERROR PRINTOUT
13779			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13780			FLD3 = .K<0, 3>^9;			!GET THE LO OCTAL DIGIT OF THE DROM ADRS
13781			MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
13782			CONDFUNC = .DROM_WRD<7,1>;		!GET COND FUNC BIT 
13783			IF .CONDFUNC NEQ 0 THEN			!IS COND FUNC BIT HI ?
13784	    	DO (0)	WHILE 
13785	BLOCK1 :						!YES COND FUNC BIT IS HI
13786			BEGIN
13787			DM(0,%O'-1');				!SET MEM TO ONES
13788			CP(3);					!GIVE 3 CLOCKS
13789			RCVDATA = EM(0);			!GET DATA
13790			IF .RCVDATA NEQ 0			!CHECK DATA
13791			THEN ERRCAS(1,1,0,.RCVDATA,12,ER_TAB);	!NO
13792	!*MESSAGE 1
13793	!*STIMULUS:
13794	!*	LOAD THE VMA WITH A ZERO
13795	!*	DEPOSITE -1 IN PHYSICAL MEM 0
13796	!*	LOAD THE IR WITH DROM ADDRESS /\O0
13797	!*	DROM CONTAINS /\U1
13798	!*	COND FUNC BIT IS HI
13799	!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
13800	!*RESPONSE:
13801	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
13802			IF LOOP_CHK(1) THEN			!IS LOOP ON ERROR SET
13803			LEAVE BLOCK1 WITH 1;			!LEAVE BLOCK TO LOOP
13804		0						!TO ILLUMINATE BLISS INFO COMMENT
13805	
13806			END
13807		    ELSE					!NO VMA EN BIT IS LO
13808	     DO (0) WHILE
13809	BLOCK2:
13810			BEGIN
13811			DM(0,%O'-1');				!SET MEM TO ONES
13812			CP(3);					!GIVE 3 CLOCKS
13813			RCVDATA = EM(0);			!GET DATA
13814			IF .RCVDATA NEQ %O'-1'			!CHECK DATA ?
13815			THEN ERRCAS(1,2,%O'-1',.RCVDATA,12,ER_TAB);!NO
13816	!*MESSAGE 2
13817	!*STIMULUS:
13818	!*	LOAD THE VMA WITH A ZERO
13819	!*	DEPOSITE -1 IN PHYSICAL MEM 0
13820	!*	LOAD THE IR WITH DROM ADDRESS /\O0
13821	!*	DROM CONTAINS /\U1
13822	!*	COND FUNC BIT IS LO
13823	!*	START AND FINISH A PHYSICAL MEM WRITE CYCLE DROM ASKS (OUTPUT A ZERO)
13824	!*RESPONSE:
13825	!*	EXAMINE PHYSICAL MEM 0 AND SEE IF IT CHANGED
13826	!]ERROR 1
13827	!]IR FCLK SPECIR DRMCNTRL NTWK
13828			IF LOOP_CHK(2)				!IS LOOP ON ERROR SET
13829			THEN 
13830			    LEAVE BLOCK2 WITH 1;		!LEAVE BLOCK TO LOOP
13831		0						!TO ILLUMINATE BLISS INFO COMMENT
13832	
13833			END;
13834		    END;
13835		END;
13836		END;
13837	
13838	
13839	GLOBAL ROUTINE TST75: NOVALUE =
13840	
13841	!THIS TEST CHECKS (DROM A )CONTENTS OF ALL DROM LOCATIONS.IT ALSO CHECKS
13842	!THE INSTRUCTION REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.THIS TEST IS A
13843	!LOOP OF 512,IT WILL PICK UP CORRECT DROM CONTENTS DATA FROM DATA TABLE
13844	!(TBL), AND EXECUTE AN ADISP (DISP 36) AND CHECK NXT ADDRESS =
13845	!CRAM J + DROM A.THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION
13846	!IN CRAM 0 THAT USES THE FOLOWING PATH:
13847	!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13848	!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13849	!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13850	!	NUMBER IS LOADED WITH THE DROM ADDRESS.
13851	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
13852	! ALWAYS 0000.EXECUTING THE DISP TYPE IS AN INSTRUCTION IN CRAM 1.ANY
13853	!DISCREPANCY IN NEXT CRAM ADDRESS WILL YIELD AN ERROR PRINTOUT.
13854	
13855	    BEGIN
13856	    LOCAL
13857		A,
13858		DROM_WRD,
13859		FLD3,
13860		FLD4;
13861	    LABEL
13862		BLOCK1;
13863	    BIND
13864		POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
13865				 U_DISP_ADISP U);		!GET 2 WORDS
13866	
13867	    IF .DROM_FLAG NEQ 0 
13868	    THEN
13869		RETURN;
13870	
13871	    LOAD_U(0, POINTER);					!LOAD THEM 
13872	    LC(0);						!LOAD CRAM ADRS 0
13873	    INCR I FROM 0 TO %O'77' DO
13874		BEGIN
13875		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13876		    MOD_FLD(4,.FLD4);				!MODIFY THOSE 2 DIGITS IN INSTRUCTION
13877		    INCR K FROM 0 TO %O'7' DO
13878			BEGIN
13879			DROM_WRD = .TBL[.I^3+.K];		!GET DROM WORD FROM TABLE
13880			FLD3 = .K<0, 3> ^ 9;			!GET LO OCTAL DIGIT OF DROM ADRS
13881			MOD_FLD(3,.FLD3);			!MODIFY THAT DIGIT
13882			A = .DROM_WRD<30,6>;			!GET THE A FIELD
13883			ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
13884			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13885			ER_TAB[2] = .A;				!STOR A FIELD FOR ERROR PRINTOUT
13886			DO (0)	WHILE 
13887	BLOCK1 :
13888			BEGIN
13889			RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS AND GET NXT CRAM ADRS	
13890			IF .RCVDATA NEQ .A			!CHECK DATA
13891			THEN ERRCAS(1,1,.A,.RCVDATA,4,ER_TAB);	!NO
13892	!*MESSAGE 1
13893	!*STIMULUS:
13894	!*	DID AN ADISP AT DROM LOCATION /\O0
13895	!*	DROM CONTAINS /\U1
13896	!*	DROM A CONTAINS /\O2
13897	!*RESPONSE:
13898	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13899	!*	NXT ADRS = DROM A + CRAM J
13900	!]ERROR 1
13901	!]IR FCLK SPECIR DRMAB DISP NTWK
13902			IF LOOP_CHK(1)				!IS LOOP ON ERROR SET
13903			THEN 
13904			BEGIN
13905			    SET_C(0);				!SET CRAM ADRS TO 0
13906			    LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13907			END;
13908			0					!TO ILLUMINATE BLISS INFO COMMENT
13909			END;
13910			END;
13911		    END;
13912		END;
13913	
13914	
13915	GLOBAL ROUTINE TST76: NOVALUE =
13916	
13917	!THIS TEST CHECKS (DROM B )CONTENTS OF ALL DROM LOCATIONS.IT ALSO CHECKS
13918	!THE INSTRUCTION REGISTER(IR)FLOPS INPUT AND OUTPUT PINS.THIS TEST IS A
13919	!LOOP OF 512,IT WILL PICK UP CORRECT DROM CONTENTS DATA FROM DATA TABLE
13920	!(TBL), AND EXECUTE A BDISP (DISP 37) AND CHECK NXT ADDRESS =
13921	!CRAM J + DROM B.THE DROM ADDRESS IS LOADED BY EXECUTING AN INSTRUCTION
13922	!IN CRAM 0 THAT USES THE FOLOWING PATH:
13923	!	LOAD THE IR REGISTER FROM DBUS MUX,DBUS MUX
13924	!	SELECTS DBM AS AN INPUT,DBM MUX SELECTS THE
13925	!	MAGIC NUMBER FIELD FOR INPUT AND THE MAGIC
13926	!	NUMBER IS LOADED WITH THE DROM ADDRESS.
13927	!THE INSTRUCTIONS EXECUTED ARE ALWAYS IN CRAM 0 & 1.THE ORED CRAM J IS
13928	!ALWAYS 0000.THE DISP TYPE IS EXECUTED IN CRAM 1.ANY DISCREPANCY IN 
13929	!NEXT ADDRESS WILL YIELD AN ERROR PRINTOUT.
13930	
13931	    BEGIN
13932	    LOCAL
13933		B,
13934		DROM_WRD,
13935		FLD3,
13936		FLD4;
13937	    LABEL
13938		BLOCK1;
13939	    BIND
13940		POINTER = PLIT (U_J(1) U_DBUS_DBM U_SPEC_LOADIR U,
13941				 U_DISP_BDISP U);		!GET 2 WORDS
13942	
13943	    IF .DROM_FLAG NEQ 0 
13944	    THEN
13945		RETURN;
13946	
13947	    LOAD_U(0, POINTER);					!LOAD THEM
13948	    LC(0);						!LOAD CRAM ADDRESS 0
13949	    INCR I FROM 0 TO %O'77' DO
13950		BEGIN
13951		    FLD4 = .I;					!GET 2 HI OCTAL DIGITS OF DROM ADRS
13952		    MOD_FLD(4,.FLD4);				!MODIFY THOSE DIGITS IN INSTRUCTION
13953		    INCR K FROM 0 TO %O'7' DO
13954			BEGIN
13955			DROM_WRD = .TBL[.I^3+.K];		!GET DROM WORD FROM TABLE
13956			FLD3 = .K<0, 3> ^ 9;			!GET LO OCTAL DIGIT OF DROM ADRS
13957			MOD_FLD(3,.FLD3);			!MODIFY IT IN INSTRUCTION
13958			B = .DROM_WRD<24,6>;			!GET THE B FIELD
13959			ER_TAB[0]=(.I^3+.K);			!LOAD DROM ADRS FOR ERROR PRINTOUT
13960			ER_TAB[1]=.DROM_WRD;			!HERE TOO FOR CONTENTS
13961			ER_TAB[2] = .B;				!STOR A FIELD FOR ERROR PRINTOUT
13962			DO (0)	WHILE 
13963	BLOCK1 :
13964			BEGIN
13965			RCVDATA = STEP_U_NEXT(2);		!GIVE 2 CLOCKS AND GET NXT CRAM ADRS
13966			IF .RCVDATA NEQ .B			!CHECK THE DATA
13967			THEN ERRCAS(1,1,.B,.RCVDATA,4,ER_TAB);	!NO
13968	!*MESSAGE 1
13969	!*STIMULUS:
13970	!*	DID A BDISP AT DROM LOCATION /\O0
13971	!*	DROM CONTAINS /\U1
13972	!*	B FEILD IS /\O2
13973	!*RESPONSE:
13974	!*	WE READ NEXT CRAM ADDRESS WHICH SHOULD BE
13975	!*	NXT ADRS = DROM B + CRAM J
13976	!]ERROR 1
13977	!]IR FCLK SPECIR DRMAB DISP NTWK
13978			IF LOOP_CHK(1)				!IS LOOP ON ERROR SET
13979			THEN 
13980			BEGIN
13981				SET_C(0);			!SET CRAM ADRS TO 0
13982				LEAVE BLOCK1 WITH 1;		!LEAVE BLOCK TO LOOP
13983			END;
13984			0					!TO ILLUMINATE BLISS INFO COMMENT
13985			END;
13986			END;
13987		    END;
13988		END;
13989	
13990	END
13991	ELUDOM
13992	

A				13308	13369#	13370	13371	13857	13882#	13885	13890	13891
AC0				1052+#	1056+#	1060+#	1064+#	1068+#	1072+#	1076+#	1080+#	1084+#	1088+#	1092+#	1096+#
				1100+#	1104+#	1108+#	1112+#	1116+#	1120+#	1124+#	1128+#	1132+#	1136+#	1140+#	1187+#
				1514#	1526#
ACDISP				13200	13228#	13229
ADDR				1063+	1064+	1248+	1249+	1250+	1251+
ADPT1_PE			 423+#
ADPT2_PE			 384+#
ADPT3_PE			 389+#
ADPT4_PE			 422+#
ADRSFLG				1387	1567#	11360#	11431#	11496	11602	11731	11848	11940	12039
AEQLJ				13310	13339#	13340
B				13933	13958#	13961	13966	13967
BAD_DATA			 288+#
BEGIN_XLIST			1246+#
BLISS36				   4
BLOCK1				1639	1641	1650	1679	1685	1690	1714	1722	1737	1763	1777	1784
				1931	1950	1960	2014	2024	2031	2078	2089	2096	2143	2158	2165
				2347	2381	2388	2444	2478	2485	2535	2550	2557	2740	2755	2762
				2817	2832	2839	2886	2897	2905	3024	3036	3047	3226	3238	3249
				3340	3352	3363	3464	3475	3483	3611	3622	3630	3757	3768	3776
				3939	3950	3958	4118	4129	4138	4202	4208	4224	4404	4414	4431
				4480	4499	4521	5026	5047	5067	5562	5576	5595	5642	5652	5657
				5766	5775	5783	6101	6110	6122	6193	6206	6215	6268	6280	6292
				6344	6351	6359	6479	6488	6497	6686	6699	6709	6888	6905	6915
				7231	7245	7263	7556	7566	7572	7773	7785	7831	8195	8210	8219
				8602	8613	8652	8776	8789	8825	8939	8950	8986	9095	9108	9135
				9387	9401	9424	9863	9873	9894	10037	10052	10071	10468	10474	10488
				10625	10649	10658	10860	10880	10892	11119	11147	11155	11236	11261	11273
				11334	11355	11364	11408	11426	11435	11486	11503	11511	11591	11611	11619
				11721	11739	11747	11837	11854	11862	11931	11946	11954	12028	12048	12056
				12156	12166	12173	12205	12219	12227	12279	12303	12321	12520	12544	12562
				12762	12771	12789	12883	12893	12911	13045	13057	13077	13108	13123	13142
				13205	13231	13248	13315	13342	13360	13425	13451	13467	13535	13567	13586
				13654	13692	13719	13758	13785	13803	13862	13887	13906	13938	13963	13982
BLOCK10				2144	2300	2306	2536	2693	2699	4481	4787	4806	5027	5326	5345
				5767	5919	5927	6480	6635	6643	6890	7079	7089	7232	7496	7513
				7557	7696	7702	8197	8372	8381	9388	9682	9706	10038	10301	10320
BLOCK11				4482	4822	4840	5028	5362	5381	5767	5935	5943	6890	7098	7108
				7557	7712	7718	8197	8392	8401	9389	9718	9743	10038	10328	10347
BLOCK12				4482	4848	4867	5028	5389	5408	5767	5951	5959	6890	7117	7127
				7557	7728	7734	8197	8409	8418	9389	9751	9775	10038	10356	10375
BLOCK13				4482	4884	4903	5028	5425	5444	5768	5967	5975	6891	7136	7146
				8198	8427	8436	9389	9785	9809	10038	10383	10402
BLOCK14				4482	4911	4930	5028	5453	5472	5768	5983	5991	6891	7155	7165
				8198	8445	8454	9389	9819	9844	10038	10410	10428
BLOCK15				4482	4959	4978	5028	5491	5510	5768	5999	6007	6891	7174	7186
				8198	8464	8473
BLOCK16				4482	4986	5007	5028	5518	5537	5768	6016	6024	8198	8481	8490
BLOCK17				5768	6032	6040	8198	8500	8519
BLOCK18				5768	6048	6056
BLOCK19				5768	6064	6072
BLOCK2				1763	1794	1800	1932	1968	1980	2015	2040	2047	2079	2104	2111
				2143	2176	2182	2347	2395	2402	2444	2492	2499	2535	2567	2573
				2740	2769	2776	2817	2846	2853	2886	2916	2923	3024	3058	3068
				3226	3260	3270	3340	3373	3383	3464	3494	3501	3611	3641	3648
				3757	3787	3794	3939	3969	3976	4118	4145	4154	4202	4231	4247
				4404	4438	4461	4480	4529	4550	5026	5076	5095	5562	5603	5624
				5642	5664	5669	5766	5791	5799	6101	6143	6149	6193	6223	6231
				6268	6300	6313	6344	6367	6377	6479	6504	6513	6686	6717	6727
				6888	6927	6937	7231	7272	7290	7556	7580	7586	7773	7841	7887
				8195	8228	8237	8602	8662	8700	8776	8834	8870	8939	8994	9022
				9095	9141	9168	9387	9432	9455	9863	9900	9922	10037	10080	10099
				10468	10495	10509	10625	10665	10674	10860	10898	10910	11119	11174	11181
				11236	11279	11289	11486	11524	11538	11591	11634	11642	11721	11754	11762
				11837	11872	11884	11931	11964	11972	12028	12067	12075	12205	12236	12244
				12279	12328	12346	12520	12569	12587	12763	12796	12814	12884	12918	12938
				13108	13149	13170	13206	13255	13275	13316	13366	13389	13426	13473	13493
				13535	13592	13614	13758	13809	13830
BLOCK3				1763	1809	1816	2143	2190	2197	2535	2581	2588	2886	2931	2938
				3024	3076	3086	3226	3278	3288	3340	3398	3409	3464	3509	3516
				3611	3655	3662	3757	3802	3809	3939	3984	3991	4118	4163	4171
				4202	4255	4271	4480	4570	4590	5026	5111	5130	5642	5676	5684
				5766	5807	5815	6101	6156	6162	6344	6385	6393	6479	6520	6529
				6686	6734	6744	6888	6946	6956	7231	7299	7317	7556	7594	7600
				7773	7899	7945	8195	8247	8256	8602	8710	8748	8776	8881	8914
				8939	9032	9068	9095	9174	9196	9387	9463	9486	9863	9929	9951
				10037	10108	10127	10468	10516	10530	10625	10691	10701	10860	10918	10928
				11591	11653	11668	11721	11774	11787	12028	12086	12094	12279	12354	12371
				12520	12595	12612	12764	12822	12839	12885	12946	12964
BLOCK4				1763	1826	1832	2143	2211	2218	2535	2603	2610	2886	2949	2957
				3024	3097	3108	3226	3299	3307	3340	3424	3431	3464	3527	3535
				3611	3672	3680	3757	3820	3828	3939	4002	4010	4202	4278	4294
				4480	4598	4617	5026	5139	5158	5642	5692	5702	5766	5823	5831
				6344	6402	6410	6479	6536	6545	6686	6751	6761	6888	6965	6975
				7231	7326	7344	7556	7608	7614	7773	7953	8000	8195	8264	8273
				9095	9202	9224	9387	9495	9518	9863	9958	9980	10037	10135	10154
				10468	10539	10553	10625	10709	10719	10860	10934	10946	12028	12108	12121
				12279	12378	12395	12520	12619	12636	12765	12846	12863	12886	12972	12989
BLOCK5				1763	1841	1847	2143	2229	2235	2535	2621	2627	2886	2964	2972
				3024	3114	3125	3464	3548	3556	3611	3690	3698	3757	3835	3843
				3939	4017	4025	4203	4302	4318	4480	4638	4656	5026	5174	5192
				5642	5710	5718	5766	5839	5847	6344	6418	6428	6479	6552	6561
				6686	6768	6779	6889	6984	6994	7232	7353	7371	7556	7622	7628
				7773	8010	8057	8196	8282	8291	9096	9234	9261	9387	9526	9548
				9863	9988	10009	10037	10165	10184	10468	10560	10574	10625	10728	10738
				10861	10952	10964	12279	12403	12417	12520	12644	12659	12887	12996	13013
BLOCK6				1764	1857	1863	2144	2243	2250	2536	2635	2642	2886	2982	2989
				3024	3135	3145	3464	3571	3578	3611	3713	3720	3757	3853	3860
				3939	4035	4042	4203	4325	4341	4481	4664	4682	5027	5201	5220
				5642	5726	5733	5766	5855	5863	6344	6436	6444	6480	6568	6577
				6687	6786	6797	6889	7003	7013	7232	7380	7398	7557	7636	7642
				7773	8064	8109	8196	8300	8309	9096	9267	9294	9388	9556	9578
				10037	10193	10212	10468	10582	10596	10625	10746	10756	10861	10972	10982
				12279	12424	12444	12520	12666	12686
BLOCK7				1764	1873	1879	2144	2258	2264	2536	2650	2656	3024	3160	3171
				3757	3875	3883	3939	4057	4065	4203	4348	4364	4481	4698	4716
				5027	5237	5256	5767	5871	5879	6480	6584	6593	6687	6804	6814
				6889	7022	7032	7232	7407	7425	7557	7650	7656	8196	8319	8328
				9096	9302	9323	9388	9587	9609	10037	10220	10239	10625	10774	10785
				10861	11036	11048	12279	12453	12472	12520	12695	12714
BLOCK8				1764	1889	1896	2144	2272	2278	2536	2664	2670	3024	3186	3193
				3757	3898	3905	3939	4080	4087	4203	4371	4387	4481	4724	4742
				5027	5264	5283	5767	5887	5895	6480	6600	6609	6687	6821	6831
				6889	7041	7051	7232	7434	7452	7557	7666	7672	8196	8336	8345
				9096	9329	9357	9388	9618	9642	10038	10247	10266	10625	10802	10812
				10861	11067	11078	12279	12479	12500	12520	12721	12742
BLOCK9				2144	2285	2292	2536	2679	2685	4481	4761	4779	5027	5299	5318
				5767	5903	5911	6480	6616	6625	6687	6838	6847	6890	7059	7069
				7232	7461	7481	7557	7682	7688	8197	8354	8363	9388	9650	9674
				10038	10274	10293
BOOT				 439+#
BUSREQ				 442+#
BUS_REQ				 327+#
CACHE_ENB			 226+#
CE				1304+
CH				1306+
CHK_ERR_MSG			1289+
CLK_RUN				 316+#
CLOSE_LATCH			 321+#
CLR_INT				 310+#
COM_ADR				 287+#
CONDFUNC			13754	13782#	13783
CONS_ENB			 440+#
CONTINUE			 332+#
CONTINUE_H			 427+#
CONTROL				1275+*
CP				1245+	1294+	1723	1779	1795	1811	1827	1842	1858	1874	1891	1952
				1970	2026	2042	2091	2106	2160	2177	2192	2213	2230	2245	2259
				2273	2287	2301	2383	2397	2480	2494	2552	2568	2583	2605	2622
				2637	2651	2665	2680	2694	2757	2771	2834	2848	2899	2918	2933
				2951	2966	2984	3038	3060	3078	3099	3116	3137	3162	3188	3240
				3262	3280	3301	3354	3375	3400	3426	3477	3496	3511	3529	3550
				3573	3624	3643	3657	3674	3692	3715	3770	3789	3804	3822	3837
				3855	3877	3900	3952	3971	3986	4004	4019	4037	4059	4082	4416
				4440	4500	4530	4572	4599	4639	4665	4699	4725	4762	4788	4823
				4849	4885	4912	4960	4987	5044	5048	5077	5112	5140	5175	5202
				5238	5265	5300	5327	5363	5390	5426	5454	5488	5492	5519	5577
				5604	6111	6144	6157	6207	6224	6282	6302	6489	6505	6521	6537
				6553	6569	6585	6601	6617	6636	6700	6718	6735	6752	6769	6787
				6805	6822	6839	6906	6928	6947	6966	6985	7004	7023	7042	7060
				7080	7099	7118	7137	7156	7175	7248	7275	7302	7329	7356	7383
				7410	7437	7464	7499	7788	7843	7902	7956	8013	8068	8502	8614
				8663	8711	8790	8835	8882	8951	8995	9033	9109	9142	9175	9203
				9235	9268	9303	9330	9402	9433	9464	9496	9527	9557	9588	9619
				9651	9683	9719	9752	9786	9820	10650	10666	10693	10711	10730	10748
				10776	10804	10881	10899	10920	10935	10953	10974	11037	11068	11149	11177
				11262	11281	12167	12426	12455	12480	12668	12697	12722	13059	13125	13150
				13570	13595	13693	13788	13812
CP_NOSS				1295+	1554	1605	1626	3154	3179	3392	3417	3544	3564	3685	3706
				3869	3891	4051	4073	8787	10637	11135	11140	11162	11164	11252	11259
				11347
CRAM_ADDR			1242+
CRAM_ADR_LD			 300+#
CRAM_PE				 388+#
CRAM_RESET			 296+#
CRAM_WRT			 301+#
CRA_PE				 385+#
CRA_R_CLK			 323+#
CRA_T_CLK			 324+#
CRM_PE_DET			 228+#
CR_CLK_ENB			 457+#
CR_LF				1048+#	1052+	1080+
CS				1305+
CSL_INT				 292+#
CTY_BIT				 434+#
CTY_CHAR_LEN			 433+#
DATA				1248+	1250+
DATA0				 281+#
DATA1				 280+#
DATA10				 268+#
DATA11				 267+#
DATA12				 263+#
DATA13				 262+#
DATA14				 261+#
DATA15				 260+#
DATA16				 259+#
DATA17				 258+#
DATA18				 257+#
DATA19				 256+#
DATA2				 279+#
DATA20				 252+#
DATA21				 251+#
DATA22				 250+#
DATA23				 249+#
DATA24				 248+#
DATA25				 247+#
DATA26				 246+#
DATA27				 245+#
DATA28				 241+#
DATA29				 240+#
DATA3				 278+#
DATA30				 239+#
DATA31				 238+#
DATA32				 237+#
DATA33				 236+#
DATA34				 235+#
DATA35				 234+#
DATA4				 274+#
DATA5				 273+#
DATA6				 272+#
DATA7				 271+#
DATA8				 270+#
DATA9				 269+#
DATA_ACK			 438+#
DATA_CYCLE			 285+#
DBMDBUS_FLG			1386	1568#	1957#	1975#	1977	6119
DC_035				1313+
DEST				 622+	 623+
DI				1250+#
DIAG1				 305+#
DIAG10				 308+#
DIAG2				 306+#
DIAG4				 307+#
DM				1248+#	1720	1778	1810	1890	1938	2201	2592	2898	2917	2932	2950
				2965	2983	3037	3059	3077	3098	3115	3136	3161	3187	3239	3261
				3279	3300	3353	3374	3399	3425	3476	3495	3510	3528	3549	3572
				3623	3642	3656	3673	3691	3714	3769	3788	3803	3821	3836	3854
				3876	3899	3951	3970	3985	4003	4018	4036	4058	4081	4415	4439
				4571	4882	5071	5134	5196	5224	5349	5412	5448	6281	6301	7787
				7842	7901	7955	8012	8066	8501	10636	10689	12164	12425	12454	12667
				12696	13058	13124	13569	13594	13787	13811
DM_CHK				1315+
DN				1319+
DP				 635+	 636+	 656+	 657+
DPCRY1_FLG			4119	4125#	4135#	4151#	4168
DPDBUS_FLG			6194	6204#	6212#	6228
DPFLG				4403	4411#	4421#	4444
DP_CLK_ENBL			 456+#
DP_PE_DET			 227+#
DP_PE				 386+#	6146	6159	10652	10668	10695	10713	10732	10750	10806	10883	10901
				10922	10937	10955	10976	11039	11070	11264	11283
DP_RESET			 298+#
DROM_FLAG			1394	1517#	1528	1532	13211	13321	13431	13545	13662	13764	13867	13943
DROM_WRD			13201	13222#	13224	13225	13228	13311	13333#	13335	13336	13339	13369	13421
				13443#	13445	13448	13532	13557#	13559	13563	13653	13674#	13676	13679#	13680
				13755	13777#	13779	13782	13858	13879#	13882	13884	13934	13955#	13958	13960
EB_AC				1038+#	1162+
EC				1311+
EC_AC				1039+#	1163+
EI				1251+#
EI_AC				1035+#	1159+
EI_CHK				1322+
EJ				1309+
EJ_AC				1036+#	1160+
EK_AC				1037+#	1161+
EM				1249+#	1724	1780	1796	1812	1828	1843	1859	1875	1892	1953	1971
				2027	2043	2092	2107	2161	2178	2193	2214	2231	2246	2260	2274
				2288	2302	2384	2398	2481	2495	2553	2569	2584	2606	2623	2638
				2652	2666	2681	2695	2758	2772	2835	2849	2900	2919	2934	2952
				2967	2985	3039	3061	3079	3100	3117	3138	3163	3189	3241	3263
				3281	3302	3355	3376	3401	3427	3478	3497	3512	3530	3551	3574
				3625	3644	3658	3675	3693	3716	3771	3790	3805	3823	3838	3856
				3878	3901	3953	3972	3987	4005	4020	4038	4060	4083	4417	4441
				4501	4531	4573	4600	4640	4666	4700	4726	4763	4789	4824	4850
				4886	4913	4961	4988	5049	5078	5113	5141	5176	5203	5239	5266
				5301	5328	5364	5391	5427	5455	5493	5520	5578	5605	6112	6208
				6225	6283	6303	6701	6719	6736	6753	6770	6788	6806	6823	6840
				6907	6929	6948	6967	6986	7005	7024	7043	7061	7081	7100	7119
				7138	7157	7176	7789	7844	7903	7957	8014	8069	8503	8615	8664
				8712	8791	8836	8883	8952	8996	9034	9110	9143	9176	9204	9236
				9269	9304	9331	9403	9434	9465	9497	9528	9558	9589	9620	9652
				9684	9720	9753	9787	9821	12168	12427	12456	12481	12669	12698	12723
				13060	13126	13151	13571	13596	13694	13789	13813
EM_AC				1040+#	1164+
EM_CHK				1318+
END_LIST			1247+#
EN_1MS				 225+#
EOP_UUO				1154+#
ERMCAS				1283+	10056	10084	10112	10139	10169	10197	10224	10251	10278	10305	10332
				10360	10387	10413
ERMCA				1282+	7793	7849	7907	7961	8018	8072	8506	8619	8668	8715	8795
				8840	8886	8956	9000	9037	9114	9147	9240	9273	9334
ERMS				1284+
ERR				1277+	1688	12171
ERRCAS				1279+	1647	1782	1798	1814	1830	1845	1861	1877	1894	1956	1974
				2029	2045	2094	2109	2163	2180	2195	2216	2233	2248	2262	2276
				2290	2304	2386	2400	2483	2497	2555	2571	2586	2608	2625	2640
				2654	2668	2683	2697	2760	2774	2837	2851	2903	2921	2936	2955
				2970	2987	3043	3064	3082	3104	3121	3141	3167	3191	3245	3266
				3284	3305	3359	3379	3405	3429	3481	3499	3514	3533	3554	3576
				3628	3646	3660	3678	3696	3718	3774	3792	3807	3826	3841	3858
				3881	3903	3956	3974	3989	4008	4023	4040	4063	4085	4134	4150
				4167	5655	5667	5680	5695	5713	5729	5778	5794	5810	5826	5842
				5858	5874	5890	5906	5922	5938	5954	5970	5986	6002	6019	6035
				6051	6067	6147	6160	6211	6227	6287	6307	6354	6370	6372	6388
				6405	6421	6423	6439	6493	6509	6525	6541	6557	6573	6589	6605
				6621	6639	6705	6723	6740	6757	6774	6792	6810	6827	6843	6911
				6933	6952	6971	6990	7009	7028	7047	7065	7085	7104	7123	7142
				7161	7179	7259	7286	7313	7340	7367	7394	7421	7448	7477	7509
				7570	7584	7598	7612	7626	7640	7654	7670	7686	7700	7716	7732
				8215	8233	8252	8269	8287	8305	8324	8341	8359	8377	8397	8414
				8432	8450	8469	8486	9180	9208	9308	9934	9963	9992	10654	10670
				10697	10715	10734	10752	10781	10808	10885	10903	10924	10939	10957	10978
				11041	11071	11152	11179	11266	11285	13235	13259	13346	13373	13455	13477
				13573	13598	13791	13815	13891	13967
ERRCA				1278+	1726	4211	4234	4258	4281	4305	4328	4351	4374	4420	4443
				4503	4533	4575	4602	4642	4668	4702	4728	4765	4791	4826	4852
				4888	4915	4963	4990	5051	5080	5115	5143	5178	5205	5241	5268
				5303	5330	5366	5393	5429	5457	5495	5522	5581	5607	6116	9407
				9438	9469	9501	9532	9562	9593	9624	9656	9688	9724	9757	9791
				9824	9879	9905	10478	10499	10520	10543	10564	10586	12308	12333	12359
				12383	12407	12429	12458	12484	12549	12574	12600	12624	12648	12671	12700
				12726	12776	12801	12827	12851	12898	12922	12951	12977	13001	13062	13128
				13154
ERRFLG				1351+
ERRM				1281+
ER_AC				1034+#	1158+
ER_TAB				1392	1773#	1774#	1775#	1782	1791#	1792#	1798	1806#	1814	1823#	1824#
				1830	1837#	1845	1854#	1855#	1861	1869#	1870#	1877	1886#	1887#	1894
				1947#	1948#	1956	1966#	1974	2022#	2029	2038#	2045	2087#	2094	2102#
				2109	2151#	2152#	2153#	2154#	2163	2172#	2173#	2180	2188#	2195	2206#
				2207#	2208#	2216	2225#	2226#	2233	2241#	2248	2256#	2262	2270#	2276
				2283#	2290	2297#	2304	2361#	2362#	2386	2393#	2400	2458#	2459#	2483
				2490#	2497	2546#	2547#	2548#	2555	2565#	2571	2579#	2586	2598#	2599#
				2600#	2608	2617#	2618#	2625	2633#	2640	2648#	2654	2662#	2668	2677#
				2683	2691#	2697	2753#	2760	2767#	2774	2830#	2837	2844#	2851	2893#
				2894#	2895#	2903	2913#	2914#	2921	2928#	2929#	2936	2946#	2947#	2955
				2962#	2970	2980#	2987	3032#	3033#	3034#	3043	3055#	3056#	3064	3073#
				3074#	3082	3094#	3095#	3104	3113#	3121	3133#	3141	3156#	3157#	3158#
				3167	3182#	3183#	3184#	3191	3234#	3235#	3236#	3245	3257#	3258#	3266
				3275#	3276#	3284	3296#	3297#	3305	3348#	3349#	3350#	3359	3371#	3379
				3394#	3395#	3396#	3405	3420#	3421#	3422#	3429	3471#	3472#	3473#	3481
				3491#	3492#	3499	3506#	3507#	3514	3524#	3525#	3533	3546#	3554	3567#
				3568#	3569#	3576	3618#	3619#	3620#	3628	3638#	3639#	3646	3653#	3660
				3670#	3678	3687#	3688#	3696	3709#	3710#	3711#	3718	3764#	3765#	3766#
				3774	3784#	3785#	3792	3799#	3800#	3807	3817#	3818#	3826	3833#	3841
				3851#	3858	3871#	3872#	3873#	3881	3894#	3895#	3896#	3903	3946#	3947#
				3948#	3956	3966#	3967#	3974	3981#	3982#	3989	3999#	4000#	4008	4015#
				4023	4033#	4040	4053#	4054#	4055#	4063	4076#	4077#	4078#	4085	4126#
				4127#	4134	4143#	4150	4161#	4167	5647#	5648#	5649#	5655	5662#	5667
				5674#	5680	5689#	5690#	5695	5708#	5713	5724#	5729	5773#	5778	5789#
				5794	5805#	5810	5821#	5826	5837#	5842	5853#	5858	5869#	5874	5885#
				5890	5901#	5906	5917#	5922	5933#	5938	5949#	5954	5965#	5970	5981#
				5986	5997#	6002	6014#	6019	6030#	6035	6046#	6051	6062#	6067	6141#
				6147	6154#	6160	6202#	6211	6221#	6227	6277#	6278#	6287	6297#	6298#
				6307	6348#	6349#	6354	6365#	6370	6372	6383#	6388	6400#	6405	6416#
				6421	6423	6434#	6439	6484#	6485#	6486#	6493	6502#	6509	6518#	6525
				6534#	6541	6550#	6557	6566#	6573	6582#	6589	6598#	6605	6614#	6621
				6632#	6633#	6639	6696#	6697#	6705	6714#	6715#	6723	6732#	6740	6749#
				6757	6766#	6774	6784#	6792	6802#	6810	6819#	6827	6836#	6843	6902#
				6903#	6911	6924#	6925#	6933	6944#	6952	6962#	6971	6982#	6990	7001#
				7009	7020#	7028	7039#	7047	7057#	7065	7077#	7085	7096#	7104	7114#
				7123	7133#	7142	7152#	7161	7172#	7179	7240#	7241#	7242#	7259	7270#
				7286	7297#	7313	7324#	7340	7351#	7367	7378#	7394	7405#	7421	7432#
				7448	7459#	7477	7492#	7493#	7494#	7509	7564#	7570	7578#	7584	7592#
				7598	7606#	7612	7620#	7626	7634#	7640	7648#	7654	7664#	7670	7680#
				7686	7694#	7700	7710#	7716	7726#	7732	8206#	8207#	8208#	8215	8225#
				8226#	8233	8244#	8245#	8252	8262#	8269	8279#	8280#	8287	8297#	8298#
				8305	8316#	8317#	8324	8334#	8341	8351#	8352#	8359	8369#	8370#	8377
				8389#	8390#	8397	8407#	8414	8424#	8425#	8432	8442#	8443#	8450	8461#
				8462#	8469	8479#	8486	10046#	10047#	10048#	10049#	10050#	10056	10077#	10078#
				10084	10105#	10106#	10112	10133#	10139	10160#	10161#	10162#	10163#	10169	10190#
				10191#	10197	10218#	10224	10245#	10251	10272#	10278	10299#	10305	10326#	10332
				10354#	10360	10381#	10387	10408#	10413	10643#	10644#	10654	10663#	10670	10697
				10707#	10715	10726#	10734	10744#	10752	10781	10808	10870#	10873#	10885	10903
				10916#	10924	10939	10957	10970#	10978	11031#	11041	11071	11138#	11148#	11152
				11175#	11179	11256#	11257#	11266	11277#	11285	11352#	11353#	11359	11423#	11424#
				11430	11500#	11501#	11507	11521#	11522#	11528	11606#	11607#	11608#	11615	11630#
				11631#	11632#	11638	11650#	11651#	11656	11735#	11736#	11743	11752#	11759	11771#
				11772#	11777	11852#	11858	11870#	11876	11944#	11950	11962#	11968	12043#	12044#
				12045#	12046#	12053	12062#	12065#	12071	12081#	12084#	12090	12100#	12103#	12106#
				12111	12216#	12217#	12223	12233#	12234#	12240	13223#	13224#	13235	13259	13334#
				13335#	13346	13370#	13373	13444#	13445#	13455	13477	13558#	13559#	13573	13598
				13675#	13676#	13683#	13685#	13688#	13690#	13699#	13701#	13704#	13706#	13709	13778#
				13779#	13791	13815	13883#	13884#	13885#	13891	13959#	13960#	13961#	13967
EXECUTE_B			 428+#
EXNEXT				1252+	1298+
EX_NXT				1245+	1252+#	1643	11141	11165
FAILURE				1286+	7476	7799	7801	7803	7805	7807	7809	7811	7813	7815	7817
				7819	7853	7855	7857	7859	7861	7863	7865	7867	7869	7871	7873
				7912	7914	7916	7918	7920	7922	7924	7926	7928	7930	7932	7969
				7971	7973	7975	7977	7979	7981	7983	7985	7987	7989	8023	8025
				8027	8029	8031	8033	8035	8037	8039	8041	8043	8077	8079	8081
				8083	8085	8087	8089	8091	8093	8095	8097	8511	8513	8515	8517
				8624	8626	8628	8630	8673	8675	8677	8679	8720	8722	8724	8726
				8800	8802	8804	8806	8845	8847	8849	8851	8891	8893	8895	8961
				8963	8965	8967	9005	9007	9041	9043	9045	9047	9118	9120	9151
				9153	9244	9246	9277	9279	9338	9340	10060	10062	10064	10066	10088
				10090	10092	10094	10116	10118	10120	10122	10143	10145	10147	10149	10173
				10175	10177	10179	10201	10203	10205	10207	10228	10230	10232	10234	10255
				10257	10259	10261	10282	10284	10286	10288	10309	10311	10313	10315	10336
				10338	10340	10342	10364	10366	10368	10370	10391	10393	10395	10397	10417
				10419	10421	10423
FILNAM_ADR			1187+
FLD				10622	10645#	10646	10647
FLD3				13202	13226#	13227	13312	13337#	13338	13422	13446#	13447	13533	13560#	13562
				13653	13677#	13678	13756	13780#	13781	13859	13880#	13881	13935	13956#	13957
FLD4				13203	13218#	13219	13313	13329#	13330	13423	13439#	13440	13534	13552#	13554
				13653	13670#	13671	13757	13773#	13774	13860	13875#	13876	13936	13951#	13952
FLP_CHK				1288+
FORCE_PAR			 224+#
FRDPAG				1189+#
FSELECT				1187+#
FUNC				 582+	 583+
FUNCLD				1390	1571#	1601	1608#
FUNC_LD				  99	1574*	2887	3025	3227	3341	3465	3612	3758	3940
HALTED				1194+#
HALT_LOOP			 430+#
I				1644	1646	1647	1939	1942	1946	1947	2359	2361	2364	2366	2368
				2370	2372	2374	2376	2378	2456	2458	2461	2463	2465	2467	2469
				2471	2473	2475	10640	10644	10645	10652	10654	10668	10670	10871	10873
				10875	10878	11136	11138	11151	11178	11254	11256	11349	11351	11352	11353
				11420	11422	11423	11424	13215	13218	13222	13223	13327	13329	13333	13334
				13437	13439	13443	13444	13550	13552	13557	13558	13668	13670	13674	13675
				13771	13773	13777	13778	13873	13875	13879	13883	13949	13951	13955	13959
IO_DATA				 286+#
IO_DEPOSIT			1250+	1320+
IO_EXAMINE			1251+	1321+
J				13199	13225#	13234	13235	13258	13259	13309	13336#	13345	13346	13371#	13372
				13373
K				13220	13222	13223	13226	13331	13333	13334	13337	13441	13443	13444	13446
				13555	13557	13558	13560	13672	13674	13675	13677	13775	13777	13778	13780
				13877	13879	13880	13883	13953	13955	13956	13959
KLINIK_BIT			 432+#
KLINIK_CARR			 448+#
KLINIK_LEN			 431+#
LANGUAGE			   4
LATCH_DATA			 322+#
LC				1243+#	1788	1804	1820	1836	1851	1867	1883	1941	1943	2035	2169
				2203	2222	2363	2365	2367	2369	2371	2373	2375	2377	2460	2462
				2464	2466	2468	2470	2472	2474	2561	2593	2595	2614	2674	2888
				2890	2909	2911	2942	2944	2976	2978	3027	3029	3051	3053	3090
				3092	3129	3131	3149	3151	3175	3177	3228	3231	3253	3255	3292
				3294	3343	3345	3367	3369	3387	3389	3413	3415	3466	3468	3487
				3489	3520	3522	3539	3541	3560	3562	3613	3615	3634	3636	3666
				3668	3702	3704	3759	3761	3780	3782	3813	3815	3847	3849	3864
				3866	3887	3889	3941	3943	3962	3964	3995	3997	4029	4031	4046
				4048	4069	4071	4159	4525	4554	4556	4558	4560	4562	4564	4566
				4594	4621	4623	4625	4627	4630	4633	4635	4660	4686	4688	4690
				4692	4694	4720	4746	4748	4750	4752	4754	4756	4783	4810	4812
				4814	4816	4818	4844	4871	4873	4875	4877	4879	4907	4934	4936
				4938	4942	4947	4949	4951	4954	4956	4982	5072	5099	5101	5103
				5105	5107	5135	5162	5164	5166	5168	5170	5197	5225	5227	5229
				5231	5233	5260	5287	5289	5291	5293	5295	5322	5350	5352	5354
				5356	5358	5385	5413	5415	5417	5419	5421	5449	5476	5478	5480
				5482	5484	5486	5514	5599	6919	6921	6941	6960	6979	6998	7017
				7036	7055	7073	7075	7093	7112	7131	7150	7169	7268	7295	7322
				7349	7376	7403	7430	7457	7486	7488	7576	7590	7604	7618	7632
				7646	7660	7662	7676	7678	7692	7706	7708	7722	7724	7835	7891
				7894	7949	8004	8242	8260	8314	8332	8386	8405	8459	8477	8494
				8496	8656	8659	8704	8707	8829	8874	8990	9026	9228	9231	9298
				9428	9459	9490	9492	9522	9552	9582	9584	9613	9615	9646	9678
				9710	9713	9747	9779	9781	9813	9815	9985	10492	10513	10536	10557
				10578	10705	10723	10742	10770	10799	10874	10876	10914	10968	11029	11032
				11171	11515	11517	11519	11623	11625	11627	11646	11648	11766	11769	11866
				11868	11958	11960	12060	12063	12079	12082	12098	12101	12104	12231	12325
				12350	12375	12399	12566	12591	12616	12640	12793	12818	12843	12915	12943
				12968	12993	13217	13326	13436	13553	13561	13667	13770	13872	13948
LCA				1243+	1312+
LDVMA				1388	1570#	1622	1627#	1727#	6317#	7518#	11190#	11310#	11559#	11691#	11901#
				11997#	12448#	12690#	13081#	13620#
LOADUC				1242+	1301+
LOAD_U				1242+#	1552	1603	1624	1682	1718	1771	1937	2020	2084	2150	2358
				2455	2543	2751	2828	4124	4206	4410	4496	5042	5572	5646	5772
				6107	6201	6274	6347	6483	6694	6900	7239	7563	7781	8205	8609
				8784	8946	9104	9397	9869	10043	10472	10631	10866	11131	11250	11345
				11418	11498	11604	11733	11850	11942	12041	12162	12213	12301	12421	12450
				12476	12542	12663	12692	12718	12769	12891	13054	13120	13146	13214	13325
				13435	13549	13666	13769	13871	13947
LOOP_CHK			1287+	1649	1689	1736	1783	1799	1815	1831	1846	1862	1878	1895
				1959	1979	2030	2046	2095	2110	2164	2181	2196	2217	2234	2249
				2263	2277	2291	2305	2387	2401	2484	2498	2556	2572	2587	2609
				2626	2641	2655	2669	2684	2698	2761	2775	2838	2852	2904	2922
				2937	2956	2971	2988	3046	3067	3085	3107	3124	3144	3170	3192
				3248	3269	3287	3306	3362	3382	3408	3430	3482	3500	3515	3534
				3555	3577	3629	3647	3661	3679	3697	3719	3775	3793	3808	3827
				3842	3859	3882	3904	3957	3975	3990	4009	4024	4041	4064	4086
				4137	4153	4170	4220	4243	4267	4290	4314	4337	4360	4383	4430
				4460	4520	4549	4589	4616	4655	4681	4715	4741	4778	4805	4839
				4866	4902	4929	4977	5006	5066	5094	5129	5157	5191	5219	5255
				5282	5317	5344	5380	5407	5443	5471	5509	5536	5594	5623	5656
				5668	5683	5698	5714	5730	5779	5795	5811	5827	5843	5859	5875
				5891	5907	5923	5939	5955	5971	5987	6003	6020	6036	6052	6068
				6121	6148	6161	6214	6230	6291	6312	6355	6373	6389	6406	6424
				6440	6496	6512	6528	6544	6560	6576	6592	6608	6624	6642	6708
				6726	6743	6760	6778	6796	6813	6830	6846	6914	6936	6955	6974
				6993	7012	7031	7050	7068	7088	7107	7126	7145	7164	7185	7262
				7289	7316	7343	7370	7397	7424	7451	7480	7512	7571	7585	7599
				7613	7627	7641	7655	7671	7687	7701	7717	7733	7830	7886	7944
				7999	8056	8108	8218	8236	8255	8272	8290	8308	8327	8344	8362
				8380	8400	8417	8435	8453	8472	8489	8518	8651	8699	8747	8824
				8869	8913	8985	9021	9067	9134	9167	9195	9223	9260	9293	9322
				9356	9423	9454	9485	9517	9547	9577	9608	9641	9673	9705	9742
				9774	9808	9843	9892	9918	9947	9976	10005	10067	10095	10123	10150
				10180	10208	10235	10262	10289	10316	10343	10371	10398	10424	10487	10508
				10529	10552	10573	10595	10657	10673	10700	10718	10737	10755	10784	10811
				10888	10906	10927	10942	10960	10981	11044	11074	11154	11180	11269	11288
				11363	11434	11510	11537	11618	11641	11667	11746	11761	11786	11861	11883
				11953	11971	12055	12074	12093	12120	12172	12226	12243	12320	12345	12370
				12394	12416	12443	12471	12499	12561	12586	12611	12635	12658	12685	12713
				12741	12788	12813	12838	12862	12910	12934	12963	12988	13012	13076	13141
				13169	13244	13271	13357	13385	13464	13488	13585	13612	13718	13802	13828
				13902	13978
LPONTST				1348+
MAINT_CLK			 312+#
MEM				 328+#
MEMSIZE				1276+
MEM_DEPOSIT			1248+	1316+
MEM_EXAMINE			1249+	1317+	11151	11178
MEM_PE				 387+#
MEM_REF_ERR			1195+#
MMC_REF_ERR			 394+#
MNT_CLK_ENB			 311+#
MOD_FLD				1314+	1789	1805	1821	1838	1852	1868	1884	1942	1944	1945	1946
				1964	1965	2036	2037	2100	2101	2170	2171	2186	2187	2202	2204
				2205	2223	2224	2239	2240	2254	2255	2268	2269	2282	2296	2298
				2364	2366	2368	2370	2372	2374	2376	2378	2379	2392	2461	2463
				2465	2467	2469	2471	2473	2475	2476	2489	2562	2563	2577	2578
				2594	2596	2597	2615	2616	2631	2632	2646	2647	2660	2661	2675
				2689	2690	2766	2843	2889	2891	2892	2910	2912	2927	2943	2945
				2961	2977	2979	3028	3030	3031	3052	3054	3072	3091	3093	3112
				3130	3132	3150	3152	3153	3155	3176	3178	3180	3181	3230	3232
				3233	3254	3256	3274	3293	3295	3344	3346	3347	3368	3370	3388
				3390	3391	3393	3414	3416	3418	3419	3467	3469	3470	3488	3490
				3505	3521	3523	3540	3542	3543	3545	3561	3563	3565	3566	3614
				3616	3617	3635	3637	3652	3667	3669	3684	3686	3703	3705	3707
				3708	3760	3762	3763	3781	3783	3798	3814	3816	3832	3848	3850
				3865	3867	3868	3870	3888	3890	3892	3893	3942	3944	3945	3963
				3965	3980	3996	3998	4014	4030	4032	4047	4049	4050	4052	4070
				4072	4074	4075	4142	4158	4160	4229	4252	4253	4276	4299	4300
				4323	4346	4369	4435	4436	4526	4555	4557	4559	4561	4563	4565
				4567	4595	4622	4624	4626	4628	4629	4631	4632	4634	4636	4661
				4687	4689	4691	4693	4695	4721	4747	4749	4751	4753	4755	4757
				4759	4784	4811	4813	4815	4817	4819	4845	4872	4874	4876	4878
				4880	4908	4935	4937	4939	4940	4941	4943	4944	4945	4946	4948
				4950	4952	4953	4955	4957	4983	5073	5100	5102	5104	5106	5108
				5136	5163	5165	5167	5169	5171	5198	5226	5228	5230	5232	5234
				5261	5288	5290	5292	5294	5296	5323	5351	5353	5355	5357	5359
				5386	5414	5416	5418	5420	5422	5450	5477	5479	5481	5483	5485
				5487	5515	5600	5661	5673	5688	5707	5723	5788	5804	5820	5836
				5852	5868	5884	5900	5916	5932	5948	5964	5980	5996	6012	6013
				6029	6045	6061	6153	6219	6220	6296	6364	6382	6398	6399	6415
				6433	6501	6517	6533	6549	6565	6581	6597	6613	6629	6630	6631
				6713	6731	6748	6765	6783	6801	6818	6835	6920	6922	6942	6961
				6980	6999	7018	7037	7056	7074	7076	7094	7113	7132	7151	7170
				7269	7296	7323	7350	7377	7404	7431	7458	7487	7489	7490	7491
				7577	7591	7605	7619	7633	7647	7661	7663	7677	7679	7693	7707
				7709	7723	7725	7836	7837	7838	7892	7893	7895	7896	7950	8005
				8006	8007	8061	8223	8224	8241	8243	8261	8277	8278	8295	8296
				8313	8315	8333	8349	8350	8367	8368	8385	8388	8406	8422	8423
				8440	8441	8458	8460	8478	8495	8497	8498	8657	8658	8660	8705
				8706	8708	8830	8831	8875	8876	8877	8878	8991	9027	9028	9029
				9139	9172	9200	9229	9230	9232	9265	9299	9327	9429	9460	9491
				9493	9523	9553	9583	9585	9614	9616	9647	9679	9711	9712	9714
				9715	9748	9780	9782	9814	9816	9898	9927	9956	9986	10076	10104
				10132	10159	10189	10217	10244	10271	10298	10325	10352	10353	10380	10407
				10493	10514	10534	10535	10537	10558	10579	10580	10642	10646	10647	10662
				10706	10724	10725	10743	10771	10772	10800	10875	10877	10878	10896	10915
				10932	10950	10969	11030	11033	11034	11063	11064	11157	11167	11172	11184
				11351	11422	11516	11518	11520	11624	11626	11628	11647	11649	11751	11767
				11768	11770	11867	11869	11959	11961	12061	12064	12080	12083	12099	12102
				12105	12232	12326	12351	12352	12376	12400	12401	12567	12592	12593	12617
				12641	12642	12794	12819	12820	12844	12916	12944	12969	12970	12994	13219
				13227	13330	13338	13440	13447	13554	13562	13671	13678	13774	13781	13876
				13881	13952	13957
MR				1302+	1551	7246	7267	7273	7294	7300	7321	7327	7348	7354	7375
				7381	7402	7408	7429	7435	7456	7462	7485	7497	7517	10638	10777
				10869
MSDPET				   3#
MSGADR				1059+	1060+	1083+	1084+
MSGFIL				1370#
MSGWORD				1055+	1056+
MSG_CHK_UUO			1179+#
N				1245+
NEXM				 443+#
NOERR				1285+	1978	4169	4445	4504	4534	4792	5609	5697	6120	6229	6311
				6641	6845	7181	7183	7511	7966	8074	8508	8717	8888	9039	9336
				9826	9994	10415	10817	10819	10821	10988	11073	11189	11295	11532	11534
				11536	11659	11661	11663	11665	11780	11782	11784	11880	11882	11977	11979
				11981	12114	12116	12118	12170	12242
NO_SUBSET			1347+	1558#
NUM				1075+	1076+	1095+	1096+	1099+	1100+	1103+	1104+	1107+	1108+	1111+	1112+
				1115+	1116+	1119+	1120+	1123+	1124+	1127+	1128+	1131+	1132+	1135+	1136+
				1139+	1140+
O_CRAM_ADDR			 578+	 579+	1243+	1244+
O_N				 888+	 889+
O_SN				 929+	 930+
PAR_ERR				1196+#
PAR_LEFT			 420+#
PAR_RIGHT			 421+#
PBELL				1143+#
PCDBUS_FLG			1389	1569#	6117#	6288#	6308#	6776#	6794#	7794#	7965
PE				1303+	1556
PEDATA				10623	10644	10645
PEFLG				10859	10867#	11042#	11065
PE_1				 441+#
PE_DET_ENB			 229+#
PIACTV_FLG			1384	1565#	6912#	6934#	6953#	6972#	6991#	7010#	7029#	7048#	7066#	7086#
				7105#	7124#	7143#	7162#	7180	7182
PIBUS_FLG			1383	1564#	6494#	6510#	6526#	6542#	6558#	6574#	6590#	6606#	6622#	6640
PISOFT_FLG			1385	1566#	6706#	6724#	6741#	6758#	6775#	6793#	6811#	6828#	6844	7182
PI_REQ_1			 401+#
PI_REQ_2			 400+#
PI_REQ_3			 399+#
PI_REQ_4			 398+#
PI_REQ_5			 397+#
PI_REQ_6			 396+#
PI_REQ_7			 395+#
PM_AC				1041+#	1165+
PNTSIX				1055+#
POCT_SUP			1139+#
POINTER				1545#	1552	1593#	1603	1619#	1624	1681#	1682	1716#	1718	1766#	1771
				1934#	1937	2017#	2020	2081#	2084	2146#	2150	2349#	2358	2446#	2455
				2538#	2543	2742#	2751	2819#	2828	4121#	4124	4205#	4206	4406#	4410
				4484#	4496	5030#	5042	5564#	5572	5644#	5646	5770#	5772	6103#	6107
				6196#	6201	6270#	6274	6346#	6347	6482#	6483	6689#	6694	6893#	6900
				7234#	7239	7559#	7563	7775#	7781	8200#	8205	8604#	8609	8778#	8784
				8941#	8946	9098#	9104	9391#	9397	9865#	9869	10040#	10043	10470#	10472
				10627#	10631	10863#	10866	11121#	11131	11238#	11250	11336#	11345	11410#	11418
				11488#	11498	11593#	11604	11723#	11733	11839#	11850	11933#	11942	12030#	12041
				12158#	12162	12207#	12213	12281#	12301	12522#	12542	12767#	12769	12889#	12891
				13047#	13054	13110#	13120	13208#	13214	13318#	13325	13428#	13435	13537#	13549
				13656#	13666	13760#	13769	13864#	13871	13940#	13947
POINTER1			12284#	12421	12525#	12663	13114#	13146
POINTER2			12292#	12450	12533#	12692
POINTER3			12296#	12476	12537#	12718
POINT				1270+
PRGNAM				1371#
PRINT_CRLF			1051+#
PRINT_DEC			1075+#
PRINT_MSG			1059+#
PRINT_OCT_1			1099+#
PRINT_OCT_11			1131+#
PRINT_OCT_12			1135+#
PRINT_OCT_2			1103+#
PRINT_OCT_3			1107+#
PRINT_OCT_4			1111+#
PRINT_OCT_5			1115+#
PRINT_OCT_6			1119+#
PRINT_OCT_7			1123+#
PRINT_OCT_8			1127+#
PRINT_TXT			1067+#
PRINT_WORD			1063+#
PRT_CRLF_F			1079+#
PRT_DEC_F			1095+#
PRT_MSG_F			1083+#
PRT_TXT_F			1087+#	1516	1518
PTSTNUM				1293+
PTXT_CRLF			1071+#
PTXT_CRLF_F			1091+#	1529	1531
RAC_LO				 412+#
RAMFILE_FLAG			1393	1519#	1530	1532	11129	11247
RAMFLG				11118	11134#	11153#	11161	11166	11186#
RAM_ERR				 455+#
RBAD_DATA			 408+#
RCOM_ADR			 407+#
RCVDATA				1391	1643#	1646	1647	1686#	1687	1724#	1725	1726	1780#	1781	1782
				1796#	1797	1798	1812#	1813	1814	1828#	1829	1830	1843#	1844	1845
				1859#	1860	1861	1875#	1876	1877	1892#	1893	1894	1953#	1954	1956
				1971#	1972	1974	2027#	2028	2029	2043#	2044	2045	2092#	2093	2094
				2107#	2108	2109	2161#	2162	2163	2178#	2179	2180	2193#	2194	2195
				2214#	2215	2216	2231#	2232	2233	2246#	2247	2248	2260#	2261	2262
				2274#	2275	2276	2288#	2289	2290	2302#	2303	2304	2384#	2385	2386
				2398#	2399	2400	2481#	2482	2483	2495#	2496	2497	2553#	2554	2555
				2569#	2570	2571	2584#	2585	2586	2606#	2607	2608	2623#	2624	2625
				2638#	2639	2640	2652#	2653	2654	2666#	2667	2668	2681#	2682	2683
				2695#	2696	2697	2758#	2759	2760	2772#	2773	2774	2835#	2836	2837
				2849#	2850	2851	2900#	2901#	2902	2903	2919#	2920	2921	2934#	2935
				2936	2952#	2953#	2954	2955	2967#	2968#	2969	2970	2985#	2986	2987
				3039#	3040#	3041	3043	3061#	3062	3064	3079#	3080	3082	3100#	3101#
				3102	3104	3117#	3118#	3119	3121	3138#	3139	3141	3163#	3164#	3165
				3167	3189#	3190	3191	3241#	3242#	3243	3245	3263#	3264	3266	3281#
				3282	3284	3302#	3303#	3304	3305	3355#	3356#	3357	3359	3376#	3377
				3379	3401#	3402#	3403	3405	3427#	3428	3429	3478#	3479#	3480	3481
				3497#	3498	3499	3512#	3513	3514	3530#	3531#	3532	3533	3551#	3552#
				3553	3554	3574#	3575	3576	3625#	3626#	3627	3628	3644#	3645	3646
				3658#	3659	3660	3675#	3676#	3677	3678	3693#	3694#	3695	3696	3716#
				3717	3718	3771#	3772#	3773	3774	3790#	3791	3792	3805#	3806	3807
				3823#	3824#	3825	3826	3838#	3839#	3840	3841	3856#	3857	3858	3878#
				3879#	3880	3881	3901#	3902	3903	3953#	3954#	3955	3956	3972#	3973
				3974	3987#	3988	3989	4005#	4006#	4007	4008	4020#	4021#	4022	4023
				4038#	4039	4040	4060#	4061#	4062	4063	4083#	4084	4085	4131#	4132
				4134	4147#	4148	4150	4165#	4166	4167	4209#	4210	4211	4232#	4233
				4234	4256#	4257	4258	4279#	4280	4281	4303#	4304	4305	4326#	4327
				4328	4349#	4350	4351	4372#	4373	4374	4417#	4418	4420	4441#	4442
				4443	4501#	4502	4503	4531#	4532	4533	4573#	4574	4575	4600#	4601
				4602	4640#	4641	4642	4666#	4667	4668	4700#	4701	4702	4726#	4727
				4728	4763#	4764	4765	4789#	4790	4791	4824#	4825	4826	4850#	4851
				4852	4886#	4887	4888	4913#	4914	4915	4961#	4962	4963	4988#	4989
				4990	5049#	5050	5051	5078#	5079	5080	5113#	5114	5115	5141#	5142
				5143	5176#	5177	5178	5203#	5204	5205	5239#	5240	5241	5266#	5267
				5268	5301#	5302	5303	5328#	5329	5330	5364#	5365	5366	5391#	5392
				5393	5427#	5428	5429	5455#	5456	5457	5493#	5494	5495	5520#	5521
				5522	5578#	5579	5581	5605#	5606	5607	5653#	5654	5655	5665#	5666
				5667	5677#	5678	5680	5693#	5694	5695	5711#	5712	5713	5727#	5728
				5729	5776#	5777	5778	5792#	5793	5794	5808#	5809	5810	5824#	5825
				5826	5840#	5841	5842	5856#	5857	5858	5872#	5873	5874	5888#	5889
				5890	5904#	5905	5906	5920#	5921	5922	5936#	5937	5938	5952#	5953
				5954	5968#	5969	5970	5984#	5985	5986	6000#	6001	6002	6017#	6018
				6019	6033#	6034	6035	6049#	6050	6051	6065#	6066	6067	6112#	6113#
				6114	6116	6145#	6146	6147	6158#	6159	6160	6208#	6209	6211	6225#
				6226	6227	6283#	6284#	6285	6287	6303#	6304#	6305	6307	6352#	6353
				6354	6368#	6369	6370	6371	6372	6386#	6387	6388	6403#	6404	6405
				6419#	6420	6421	6422	6423	6437#	6438	6439	6490#	6491	6493	6506#
				6507	6509	6522#	6523	6525	6538#	6539	6541	6554#	6555	6557	6570#
				6571	6573	6586#	6587	6589	6602#	6603	6605	6618#	6619	6621	6637#
				6638	6639	6701#	6702#	6703	6705	6719#	6720#	6721	6723	6736#	6737#
				6738	6740	6753#	6754#	6755	6757	6770#	6771#	6772	6774	6788#	6789#
				6790	6792	6806#	6807#	6808	6810	6823#	6824#	6825	6827	6840#	6841#
				6842	6843	6907#	6908#	6909	6911	6929#	6930#	6931	6933	6948#	6949#
				6950	6952	6967#	6968#	6969	6971	6986#	6987#	6988	6990	7005#	7006#
				7007	7009	7024#	7025#	7026	7028	7043#	7044#	7045	7047	7061#	7062#
				7063	7065	7081#	7082#	7083	7085	7100#	7101#	7102	7104	7119#	7120#
				7121	7123	7138#	7139#	7140	7142	7157#	7158#	7159	7161	7176#	7177#
				7178	7179	7255#	7256#	7257	7259	7282#	7283#	7284	7286	7309#	7310#
				7311	7313	7336#	7337#	7338	7340	7363#	7364#	7365	7367	7390#	7391#
				7392	7394	7417#	7418#	7419	7421	7444#	7445#	7446	7448	7471#	7472#
				7473	7477	7506#	7507#	7508	7509	7568#	7569	7570	7582#	7583	7584
				7596#	7597	7598	7610#	7611	7612	7624#	7625	7626	7638#	7639	7640
				7652#	7653	7654	7668#	7669	7670	7684#	7685	7686	7698#	7699	7700
				7714#	7715	7716	7730#	7731	7732	7789#	7790#	7791	7793	7798	7800
				7802	7804	7806	7808	7810	7812	7814	7816	7818	7844#	7845#	7846
				7849	7852	7854	7856	7858	7860	7862	7864	7866	7868	7870	7872
				7903#	7904#	7905	7907	7911	7913	7915	7917	7919	7921	7923	7925
				7927	7929	7931	7957#	7958#	7959	7961	7968	7970	7972	7974	7976
				7978	7980	7982	7984	7986	7988	8014#	8015#	8016	8018	8022	8024
				8026	8028	8030	8032	8034	8036	8038	8040	8042	8069#	8070#	8071
				8072	8076	8078	8080	8082	8084	8086	8088	8090	8092	8094	8096
				8212#	8213	8215	8230#	8231	8233	8249#	8250	8252	8266#	8267	8269
				8284#	8285	8287	8302#	8303	8305	8321#	8322	8324	8338#	8339	8341
				8356#	8357	8359	8374#	8375	8377	8394#	8395	8397	8411#	8412	8414
				8429#	8430	8432	8447#	8448	8450	8466#	8467	8469	8483#	8484	8486
				8503#	8504#	8505	8506	8510	8512	8514	8516	8615#	8616#	8617	8619
				8623	8625	8627	8629	8664#	8665#	8666	8668	8672	8674	8676	8678
				8712#	8713#	8714	8715	8719	8721	8723	8725	8791#	8792#	8793	8795
				8799	8801	8803	8805	8836#	8837#	8838	8840	8844	8846	8848	8850
				8883#	8884#	8885	8886	8890	8892	8894	8952#	8953#	8954	8956	8960
				8962	8964	8966	8996#	8997#	8998	9000	9004	9006	9034#	9035#	9036
				9037	9040	9042	9044	9046	9110#	9111#	9112	9114	9117	9119	9143#
				9144#	9145	9147	9150	9152	9176#	9177#	9178	9180	9204#	9205#	9206
				9208	9236#	9237#	9238	9240	9243	9245	9269#	9270#	9271	9273	9276
				9278	9304#	9305#	9306	9308	9331#	9332#	9333	9334	9337	9339	9403#
				9404#	9405	9407	9434#	9435#	9436	9438	9465#	9466#	9467	9469	9497#
				9498#	9499	9501	9528#	9529#	9530	9532	9558#	9559#	9560	9562	9589#
				9590#	9591	9593	9620#	9621#	9622	9624	9652#	9653#	9654	9656	9684#
				9685#	9686	9688	9720#	9721#	9722	9724	9753#	9754#	9755	9757	9787#
				9788#	9789	9791	9821#	9822#	9823	9824	9875#	9876#	9877	9879	9901#
				9902#	9903	9905	9930#	9931#	9932	9934	9959#	9960#	9961	9963	9989#
				9990#	9991	9992	10053#	10054	10056	10059	10061	10063	10065	10081#	10082
				10084	10087	10089	10091	10093	10109#	10110	10112	10115	10117	10119	10121
				10136#	10137	10139	10142	10144	10146	10148	10166#	10167	10169	10172	10174
				10176	10178	10194#	10195	10197	10200	10202	10204	10206	10221#	10222	10224
				10227	10229	10231	10233	10248#	10249	10251	10254	10256	10258	10260	10275#
				10276	10278	10281	10283	10285	10287	10302#	10303	10305	10308	10310	10312
				10314	10329#	10330	10332	10335	10337	10339	10341	10357#	10358	10360	10363
				10365	10367	10369	10384#	10385	10387	10390	10392	10394	10396	10411#	10412
				10413	10416	10418	10420	10422	10476#	10477	10478	10497#	10498	10499	10518#
				10519	10520	10541#	10542	10543	10562#	10563	10564	10584#	10585	10586	10651#
				10652	10654	10667#	10668	10670	10694#	10695	10697	10712#	10713	10715	10731#
				10732	10734	10749#	10750	10752	10778#	10779	10781	10805#	10806	10808	10882#
				10883	10885	10900#	10901	10903	10921#	10922	10924	10936#	10937	10939	10954#
				10955	10957	10975#	10976	10978	11038#	11039	11041	11069#	11070	11071	11141#
				11142	11151#	11152	11165#	11168	11178#	11179	11263#	11264	11266	11282#	11283
				11285	11356#	11357	11427#	11428	11504#	11505	11525#	11526	11612#	11613	11635#
				11636	11654#	11655	11740#	11741	11755#	11756	11775#	11776	11855#	11856	11873#
				11874	11947#	11948	11965#	11966	12049#	12050	12068#	12069	12087#	12088	12109#
				12110	12168#	12169	12220#	12221	12238#	12239	12306#	12307	12308	12331#	12332
				12333	12357#	12358	12359	12381#	12382	12383	12405#	12406	12407	12427#	12428
				12429	12456#	12457	12458	12481#	12482#	12483	12484	12547#	12548	12549	12572#
				12573	12574	12598#	12599	12600	12622#	12623	12624	12646#	12647	12648	12669#
				12670	12671	12698#	12699	12700	12723#	12724#	12725	12726	12774#	12775	12776
				12799#	12800	12801	12825#	12826	12827	12849#	12850	12851	12896#	12897	12898
				12920#	12921	12922	12949#	12950	12951	12975#	12976	12977	12999#	13000	13001
				13060#	13061	13062	13126#	13127	13128	13151#	13152#	13153	13154	13233#	13234
				13235	13257#	13258	13259	13344#	13345	13346	13368#	13372	13373	13453#	13454
				13455	13475#	13476	13477	13571#	13572	13573	13596#	13597	13598	13694#	13695
				13696	13789#	13790	13791	13813#	13814	13815	13889#	13890	13891	13965#	13966
				13967
RCVREAD				13653	13696#	13702	13708
RCVWRTST			13653	13695#	13697	13708
RDATA				 405+#
RDATA0				 419+#
RDATA1				 418+#
RDATA10				 374+#
RDATA11				 373+#
RDATA12				 369+#
RDATA13				 368+#
RDATA14				 367+#
RDATA15				 366+#
RDATA16				 365+#
RDATA17				 364+#
RDATA18				 363+#
RDATA19				 362+#
RDATA2				 417+#
RDATA20				 358+#
RDATA21				 357+#
RDATA22				 356+#
RDATA23				 355+#
RDATA24				 354+#
RDATA25				 353+#
RDATA26				 352+#
RDATA27				 351+#
RDATA28				 347+#
RDATA29				 346+#
RDATA3				 416+#
RDATA30				 345+#
RDATA31				 344+#
RDATA32				 343+#
RDATA33				 342+#
RDATA34				 341+#
RDATA35				 340+#
RDATA4				 380+#
RDATA5				 379+#
RDATA6				 378+#
RDATA7				 377+#
RDATA8				 376+#
RDATA9				 375+#
RD_0				1253+#
RD_1				1254+#
RD_100				1257+#	6145	6158	10651	10667	10694	10712	10731	10749	10778	10805	10882
				10900	10921	10936	10954	10975	11038	11069	11263	11282
RD_101				1258+#	6490	6506	6522	6538	6554	6570	6586	6602	6618	6637
RD_102				1259+#
RD_103				1260+#
RD_2				1255+#	7255	7282	7309	7336	7363	7390	7417	7444	7471	7506
RD_3				1256+#
RD_300				1261+#
RD_301				1262+#
RD_303				1263+#
REC_PE				 390+#
REG_EXAMINE			1253+	1254+	1255+	1256+	1257+	1258+	1259+	1260+	1261+	1262+	1263+	1323+
REM_DIAG_ENB			 450+#
REM_DIAG_PRO			 451+#
REPEAT				1292+
REPLACEI			1272+
RESET				 230+#
RIO_BUSY			 409+#
RIO_DATA			 406+#
RMEM_BUSY			 410+#
RPT_ERR_FLAG			1350+	1557#
RRESET				 411+#
RUN				 334+#
RUN_1				 429+#
R_CLK_ENB0			 458+#
SCANI				1271+
SC_0				1310+	1555
SEL				 677+	 678+	 688+	 689+	 699+	 700+
SEND_CMD_LINE			1171+#
SEND_EB_LINE			1162+#
SEND_EC_LINE			1163+#
SEND_EI_LINE			1159+#
SEND_EJ_LINE			1160+#
SEND_EK_LINE			1161+#
SEND_EM_LINE			1164+#
SEND_ER_LINE			1158+#
SEND_INFO			1183+#
SEND_LINE			1291+
SEND_NUL			1296+
SEND_PM_LINE			1165+#
SEND_UUO_1			1175+#
SEND_X1A_LINE			1166+#
SEND_X1B_LINE			1167+#
SETNXT				1244+	1297+
SET_C				1244+#	1553	1604	1625	1642	1683	1719	1772	1790	1807	1822	1839
				1853	1871	1885	2021	2086	2156	2174	2209	2227	2545	2564	2601
				2619	2676	2752	2829	4130	4146	4164	4223	4246	4270	4293	4317
				4340	4363	4386	4412	4497	4527	4568	4596	4662	4696	4722	4758
				4785	4820	4846	4881	4909	4984	5043	5045	5074	5109	5137	5172
				5199	5235	5262	5297	5324	5360	5387	5423	5451	5489	5516	5574
				5601	5701	5717	5732	5782	5798	5814	5830	5846	5862	5878	5894
				5910	5926	5942	5958	5974	5990	6006	6023	6039	6055	6071	6108
				6140	6203	6276	6358	6376	6392	6409	6427	6443	6695	6901	6923
				6943	6963	6981	7000	7019	7038	7058	7095	7115	7134	7153	7171
				7247	7249	7274	7276	7301	7303	7328	7330	7355	7357	7382	7384
				7409	7411	7436	7438	7463	7465	7498	7500	7567	7581	7595	7609
				7623	7637	7651	7667	7683	7697	7713	7729	7783	7885	7951	8055
				8067	8211	8229	8248	8265	8283	8301	8320	8337	8355	8373	8393
				8410	8428	8446	8465	8482	8610	8785	8832	8879	8947	8992	9030
				9106	9300	9398	9430	9461	9524	9554	9648	9680	9716	9749	9783
				9817	9874	9921	9950	9979	9987	10008	10045	10070	10098	10126	10153
				10183	10211	10238	10265	10292	10319	10346	10374	10401	10427	10475	10496
				10517	10540	10561	10583	10635	10639	10692	10710	10729	10747	10775	10803
				10891	10909	10919	10945	10963	10973	11047	11077	11132	11139	11145	11251
				11258	11272	11280	11346	11348	11419	11499	11605	11629	11734	11851	11943
				12042	12163	12214	12237	12305	12330	12356	12380	12404	12422	12451	12477
				12546	12571	12597	12621	12645	12664	12693	12719	12773	12798	12824	12848
				12895	12937	12948	12974	12998	13055	13121	13147	13247	13274	13359	13388
				13466	13492	13564	13905	13981
SINGLE_CLK			 317+#
SOURCE_ADDR			1242+
SPEC_ASK			  96	1510*
SPEC_DIALOGUE			  95	1505*
SPEC_PRT			  97	1522*
SRC				 595+	 596+	 608+	 609+
SS_MODE				 299+#
STEP_U_NEXT			1245+#	1686	4131	4147	4165	4209	4232	4256	4279	4303	4326	4349
				4372	5653	5665	5677	5693	5711	5727	5776	5792	5808	5824	5840
				5856	5872	5888	5904	5920	5936	5952	5968	5984	6000	6017	6033
				6049	6065	6352	6368	6386	6403	6419	6437	7568	7582	7596	7610
				7624	7638	7652	7668	7684	7698	7714	7730	8212	8230	8249	8266
				8284	8302	8321	8338	8356	8374	8394	8411	8429	8447	8466	8483
				9875	9901	9930	9959	9989	10053	10081	10109	10136	10166	10194	10221
				10248	10275	10302	10329	10357	10384	10411	10476	10497	10518	10541	10562
				10584	11356	11427	11504	11525	11612	11635	11654	11740	11755	11775	11855
				11873	11947	11965	12049	12068	12087	12109	12220	12238	12306	12331	12357
				12381	12405	12547	12572	12598	12622	12646	12774	12799	12825	12849	12896
				12920	12949	12975	12999	13233	13257	13344	13368	13453	13475	13889	13965
STK_RESET			 297+#
SYNC_CLK			1343+	7250	7277	7304	7331	7358	7385	7412	7439	7466	7501
TBL				1395	13222	13333	13443	13557	13674	13777	13879	13955
TE				1308+
TEN_INT				 444+#
TERM_CARR			 449+#
TEST53_FLG			1378	1559#	11362#	11533	11662	11781	11879	11978	12115
TEST54_FLG			1379	1560#	11433#	11535	11664	11783	11881	11980	12117
TEST55_FLG			1380	1561#	11508#	11529#	11531	11533	11535	11660	11976
TEST58_FLG			1381	1563#	11859#	11877#	11879	11881	11976
TEST59_FLG			1382	1562#	11951#	11969#	11976	11978	11980
TESTL_FLG			10622	10633#	10671#	10698#	10753#	10818	10820
TESTR_FLG			10622	10634#	10655#	10716#	10735#	10816	10820
TEST_EDIT			1366#
TEST_FLG			3023	3026#	3044#	3065#	3083#	3105#	3122#	3142#	3168#	3225	3229#	3246#
				3267#	3285#	3339	3342#	3360#	3380#	3406#	5561	5573#	5582#	5608	5641
				5650#	5681#	5696	6267	6275#	6289#	6310	7230	7243#	7260#	7287#	7314#
				7341#	7368#	7395#	7422#	7449#	7475	7478#	7510	7772	7782#	7786#	7796#
				7839	7850#	7897	7900#	7954#	7963#	8008	8011#	8020#	8062	8065#	8194
				8216#	8234#	8253#	8270#	8288#	8306#	8325#	8342#	8360#	8378#	8387#	8398#
				8415#	8433#	8451#	8470#	8487#	8507	8601	8611#	8620#	8669#	8716	8775
				8786#	8796#	8841#	8887	8938	8948#	8957#	9001#	9038	9094	9105#	9115#
				9148#	9181#	9209#	9241#	9274#	9309#	9335	9386	9399#	9408#	9439#	9470#
				9502#	9533#	9563#	9594#	9625#	9657#	9689#	9725#	9758#	9792#	9825	9862
				9870#	9880#	9906#	9935#	9964#	9993	10036	10044#	10057#	10085#	10113#	10140#
				10170#	10198#	10225#	10252#	10279#	10306#	10333#	10361#	10388#	10414	10622	10632#
				10782#	10809#	10820	10859	10868#	10886#	10904#	10925#	10940#	10958#	10979#	10987
				11072	11118	11133#	11150#	11176#	11188	11235	11253#	11267#	11286#	11294	11590
				11609#	11616#	11639#	11658	11660	11662	11664	11720	11737#	11744#	11758#	11779
				11781	11783	12027	12052#	12072#	12091#	12113	12115	12117	12204	12215#	12224#
				12241
TEST_FLG1			7772	7795#	7848#	7908#	7962#	8019#	8073
TEST_INIT			  98	1537*
TEST_VERSION			1365#
TEXT				1067+	1068+	1071+	1072+	1087+	1088+	1091+	1092+
TICK				1344+	7254	7281	7308	7335	7362	7389	7416	7443	7470	7505
TIMOUT				1349+
TP				1307+	9871	10020
TRAP_ENB			 309+#
TST1				 101	1631*
TST10				 110	2420*
TST11				 111	2517*
TST12				 112	2717*
TST13				 113	2794*
TST14				 114	2870*
TST15				 115	3006*
TST16				 116	3210*
TST17				 117	3324*
TST18				 118	3448*
TST19				 119	3595*
TST2				 102	1672*
TST20				 120	3740*
TST21				 121	3922*
TST22				 122	4104*
TST23				 123	4191*
TST24				 124	4394*
TST25				 125	4467*
TST26				 126	5013*
TST27				 127	5543*
TST28				 128	5630*
TST29				 129	5755*
TST3				 103	1706*
TST30				 130	6089*
TST31				 131	6180*
TST32				 132	6252*
TST33				 133	6333*
TST34				 134	6462*
TST35				 135	6662*
TST36				 136	6865*
TST37				 137	7206*
TST38				 138	7537*
TST39				 139	7749*
TST4				 104	1743*
TST40				 140	8181*
TST41				 141	8576*
TST42				 142	8754*
TST43				 143	8920*
TST44				 144	9074*
TST45				 145	9363*
TST46				 146	9849*
TST47				 147	10023*
TST48				 148	10457*
TST49				 149	10602*
TST5				 105	1912*
TST50				 150	10842*
TST51				 151	11098*
TST52				 152	11206*
TST53				 153	11313*
TST54				 154	11387*
TST55				 155	11458*
TST56				 156	11562*
TST57				 157	11694*
TST58				 158	11808*
TST59				 159	11904*
TST6				 106	1999*
TST60				 160	12000*
TST61				 161	12143*
TST62				 162	12192*
TST63				 163	12265*
TST64				 164	12506*
TST65				 165	12748*
TST66				 166	12869*
TST67				 167	13019*
TST68				 168	13084*
TST69				 169	13176*
TST7				 107	2063*
TST70				 170	13285*
TST71				 171	13398*
TST72				 172	13502*
TST73				 173	13623*
TST74				 174	13728*
TST75				 175	13839*
TST76				 176	13915*
TST8				 108	2127*
TST9				 109	2323*
TTI_CLR				1149+#
TTI_DEC				1150+#
TTI_YES				1148+#	1517	1519
TT_ALTM				1147+#
TXXX				13420	13448#	13449
U				 936+#	1545	1546	1547	1548	1549	1593	1594	1595	1596	1597	1598
				1599	1619	1620	1681	1716	1717	1766	1767	1768	1769	1770	1934
				1935	1936	2017	2018	2019	2081	2082	2083	2146	2147	2148	2149
				2349	2350	2351	2352	2353	2354	2355	2356	2357	2446	2447	2448
				2449	2450	2451	2452	2453	2454	2538	2539	2540	2541	2542	2742
				2743	2744	2745	2746	2747	2748	2749	2750	2819	2820	2821	2822
				2823	2824	2825	2826	2827	4121	4122	4123	4205	4406	4407	4408
				4484	4485	4486	4487	4488	4489	4490	4491	4492	4493	4494	5030
				5031	5032	5033	5034	5035	5036	5037	5038	5039	5040	5564	5565
				5566	5567	5568	5569	5570	5644	5770	6103	6104	6105	6196	6197
				6198	6199	6270	6271	6272	6346	6482	6689	6690	6691	6893	6894
				6895	6896	6897	6898	7234	7235	7236	7237	7559	7560	7561	7775
				7776	7777	7778	7779	8200	8201	8202	8203	8204	8604	8605	8606
				8607	8778	8779	8780	8781	8782	8941	8942	8943	8944	9098	9099
				9100	9101	9102	9391	9392	9393	9394	9395	9865	9866	9867	10040
				10041	10470	10471	10627	10628	10629	10863	10864	11121	11122	11123	11124
				11125	11126	11127	11128	11238	11239	11240	11241	11242	11243	11244	11245
				11336	11337	11338	11339	11340	11341	11342	11343	11410	11411	11412	11413
				11414	11415	11416	11488	11489	11490	11491	11492	11493	11494	11593	11594
				11595	11596	11597	11598	11599	11600	11723	11724	11725	11726	11727	11728
				11839	11840	11841	11842	11843	11844	11845	11846	11933	11934	11935	11936
				11937	11938	12030	12031	12032	12033	12034	12035	12036	12037	12158	12159
				12160	12207	12208	12209	12210	12211	12281	12282	12284	12285	12286	12287
				12288	12289	12290	12292	12293	12294	12296	12297	12298	12299	12300	12522
				12523	12525	12526	12527	12528	12529	12530	12531	12533	12534	12535	12537
				12538	12539	12540	12541	12767	12768	12889	12890	13047	13048	13049	13050
				13051	13052	13053	13110	13111	13112	13114	13115	13116	13117	13118	13208
				13209	13318	13319	13428	13429	13537	13538	13539	13540	13541	13542	13543
				13656	13657	13658	13659	13660	13760	13761	13762	13864	13865	13940	13941
UUO				1031+	1053+	1057+	1061+	1065+	1069+	1073+	1077+	1081+	1085+	1089+	1093+
				1097+	1101+	1105+	1109+	1113+	1117+	1121+	1125+	1129+	1133+	1137+	1141+
				1143+	1147+	1148+	1149+	1150+	1154+	1158+	1159+	1160+	1161+	1162+	1163+
				1164+	1165+	1166+	1167+	1171+	1175+	1179+	1183+	1188+	1189+
U_0				 579+	 583+	 596+	 609+	 623+	 636+	 657+	 941+	 956+	 958+	 984+#
U_0_DEFAULT			 958+	 971+#	 984+
U_1				 678+	 689+	 700+	 720+	 724+	 729+	 733+	 737+	 742+	 746+	 775+	 785+
				 798+	 818+	 847+	 947+	 953+	 956+	 959+	 985+#
U_1_DEFAULT			 959+	 972+#	 985+
U_2				 853+	 857+	 861+	 865+	 869+	 873+	 877+	 881+	 885+	 889+	 895+	 908+
				 921+	 930+	 956+	 960+	 986+#
U_2_DEFAULT			 960+	 973+#	 986+
U_3				 716+	 947+	 953+	 961+	 987+#
U_3_DEFAULT			 961+	 974+#	 987+
U_A				 635+#	 638+	 639+	 640+	 641+	 642+	 643+	 644+	 645+	 646+	 647+	 648+
				 649+	 650+	 651+	 652+	 653+
U_ALU_ADD			 585+#	4123	4205	5566	5567	5568	8605	11121	11238
U_ALU_AND			 589+#
U_ALU_MASK			 590+#
U_ALU_OR			 588+#	1595	1596	1597	1598	1599	1770	1934	1936	2017	2019	2081
				2083	2146	2147	2149	2349	2350	2351	2352	2353	2354	2355	2357
				2446	2447	2448	2449	2450	2451	2452	2454	2538	2539	2540	2542
				2742	2743	2744	2745	2746	2747	2748	2750	2819	2820	2821	2822
				2823	2824	2825	2827	4121	4122	4408	4484	4485	4486	4487	4488
				4489	4490	4491	4492	4493	4494	5030	5031	5032	5033	5034	5035
				5036	5037	5038	5039	5040	5565	5570	5770	6104	6196	6197	6199
				6270	6271	6272	6346	6482	6689	6690	6691	6893	6894	6895	6896
				6897	6898	7234	7235	7237	7560	7561	7775	7777	7778	7779	8200
				8201	8204	8604	8607	8778	8782	8944	9098	9100	9102	9391	9392
				9394	9395	9866	10040	10470	10863	11122	11124	11125	11126	11128	11239
				11242	11245	11336	11337	11339	11341	11342	11343	11410	11413	11416	11488
				11490	11491	11493	11593	11595	11596	11597	11599	11723	11725	11727	11839
				11840	11843	11844	11845	11933	11934	11936	11937	12031	12032	12033	12035
				12036	12158	12210	12281	12282	12284	12286	12292	12296	12298	12300	12522
				12523	12525	12527	12533	12537	12539	12541	13047	13049	13110	13114	13116
				13118	13428	13429	13537	13539	13656	13658	13660	13760
U_ALU_PARITY_OK			 715+#
U_ALU_RSUB			 587+#
U_ALU_SUB			 586+#
U_ALU_XNOR			 592+#	1548	1768	11340	11414
U_ALU_XOR			 591+#	5644	11127	11494	11600	11728	11846	11938	12037	12211
U_ALU				 582+#	 585+	 586+	 587+	 588+	 589+	 590+	 591+	 592+
U_A_AR				 641+#
U_A_ARX				 642+#
U_A_BR				 643+#
U_A_BRX				 644+#
U_A_EBR				 646+#
U_A_FLG				 649+#
U_A_HR				 640+#	11337	11341
U_A_MAG				 638+#
U_A_MASK			 648+#
U_A_ONE				 645+#
U_A_PC				 639+#	1599	5031	5032	5033	5034	6199	11339	11413
U_A_PI				 650+#
U_A_T0				 652+#
U_A_T1				 653+#	11127	11494	11600	11728	11846	11938	12036	12037
U_A_UBR				 647+#
U_A_XWD1			 651+#
U_B				 656+#	 659+	 660+	 661+	 662+	 663+	 664+	 665+	 666+	 667+	 668+	 669+
				 670+	 671+	 672+	 673+	 674+
U_BYTE				 774+#	 777+	 778+	 779+	 780+	 781+
U_BYTE_1			 777+#
U_BYTE_2			 778+#
U_BYTE_3			 779+#
U_BYTE_4			 780+#
U_BYTE_5			 781+#
U_B_AR				 662+#
U_B_ARX				 663+#
U_B_BR				 664+#
U_B_BRX				 665+#
U_B_EBR				 667+#
U_B_FLG				 670+#
U_B_HR				 661+#
U_B_MAG				 659+#
U_B_MASK			 669+#
U_B_ONE				 666+#
U_B_PC				 660+#	1597	1598	5030	5031	5032	6197	11336	11410
U_B_PI				 671+#
U_B_T0				 673+#
U_B_T1				 674+#	11126	11493	11599	11727	11843	11844	11936	11937	12035
U_B_UBR				 668+#
U_B_XWD1			 672+#
U_CALL				 884+#
U_CHKL				 728+#	6105	10864	11241	11244
U_CHKR				 741+#	11241	11244
U_CRY38				 852+#
U_DBM_APR_FLAGS			 704+#
U_DBM_BYTES			 705+#
U_DBM_DP			 708+#
U_DBM_DP_SWAP			 709+#
U_DBM_EXP			 706+#
U_DBM_MEM			 711+#
U_DBM_MSEC			 707+#
U_DBM_N				 712+#
U_DBM_PF_DISP			 703+#
U_DBM_SCAD			 702+#
U_DBM_VMA			 710+#	12298	12539	13116	13658
U_DBM				 699+#	 702+	 703+	 704+	 705+	 706+	 707+	 708+	 709+	 710+	 711+	 712+
U_DBUS				 688+#	 691+	 692+	 693+	 694+	 695+	 696+
U_DBUS_DBM			 696+#	1595	1934	2017	2081	2146	2147	2349	2446	2538	2539	2742
				2819	4121	4122	4205	4484	4485	5030	5565	5770	6196	6270	6346
				6482	6689	6893	6894	6895	6896	7234	7237	7560	7561	7775	8200
				8604	8605	8778	9098	9391	9392	9395	9866	10040	10470	10627	10628
				10629	10863	11121	11123	11126	11128	11238	11240	11243	11245	11336	11343
				11410	11488	11489	11490	11493	11593	11594	11595	11596	11599	11723	11727
				11839	11843	11933	11936	12030	12031	12032	12035	12158	12210	12281	12284
				12286	12292	12296	12298	12522	12525	12527	12533	12537	12539	12767	12889
				13047	13049	13110	13114	13116	13208	13318	13428	13537	13539	13656	13658
				13760	13864	13940
U_DBUS_DP			 694+#
U_DBUS_PC_FLAGS			 691+#	6104	6105	6272	7778	8204	8607	8782	8944	9102	9394
U_DBUS_PI_NEW			 692+#	6690	6897
U_DBUS_RAM			 695+#	11124	11125	11127	11241	11244	11342	11416	11494	11600	11728	11846
				11938	12037	12211
U_DBUS_VMA			 693+#
U_DEST				 622+#	 625+	 626+	 627+	 628+	 629+	 630+	 631+	 632+
U_DEST_A			 625+#	1768	1936	6197
U_DEST_AD			 626+#	1766	1934	2017	2349	2446	2538	4205	4406	4484	5030	5033
				5564	5565	5566	5567	5568	6196	6270	6690	6895	6897	7234	7236
				7560	7776	7778	8200	8604	10863	11126	11336	11338	11410	11411	11490
				11493	11596	11599	11723	11727	11839	11843	11933	11936	12031	12035	12207
				12210	12281	12298	12522	12539	13116	13428	13658
U_DEST_AD_DIV2			 632+#	1595	1596	1597	1598	2353	2354	2355	2447	2448	2449
U_DEST_AD_MUL2			 630+#	2147	2350	2351	2352	2450	2451	2452	5031	5032	7775	9098
U_DEST_PASS			 628+#
U_DEST_Q_AD			 627+#	1593	1767	2081	2146	2539	2742	2819	4121	4485	5034	11121
				11128	11238	11245
U_DEST_Q_DIV2			 631+#	2746	2747	2748	2820	2821	2822	5035	5036	5037	5038	5039
U_DEST_Q_MUL2			 629+#	2540	2743	2744	2745	2823	2824	2825	4122	4486	4487	4488
				4489	4490	4491	4492	4494
U_DISP				 797+#	 800+	 801+	 802+	 803+	 804+	 805+	 806+	 807+	 808+	 809+	 810+
				 811+	 812+	 813+	 814+
U_DISP_ADISP			 806+#	13865
U_DISP_AREAD			 802+#	13319
U_DISP_BDISP			 807+#	13941
U_DISP_BYTE			 812+#	5770
U_DISP_CONSOLE			 800+#
U_DISP_DP			 805+#	6346
U_DISP_DP_LEFT			 803+#
U_DISP_DROM			 801+#	12282	12523	12768	12890	13209
U_DISP_EAMODE			 813+#	10041
U_DISP_MUL			 809+#
U_DISP_NICOND			 811+#	9867
U_DISP_NORM			 804+#
U_DISP_PAGEFAIL			 810+#
U_DISP_RETURN			 808+#
U_DISP_SCAD0			 814+#
U_DIVIDE			 872+#	4494
U_FMWRITE			 864+#	11123	11126	11240	11243	11338	11340	11412	11414	11492	11493	11598
				11599	11726	11727	11841	11844	11935	11937	12034	12036	12208
U_GENL				 723+#	10863
U_GENR				 736+#	10863
U_J				 578+#	1545	1546	1547	1548	1549	1593	1594	1595	1596	1597	1598
				1599	1619	1716	1717	1766	1767	1768	1769	1770	1934	1935	1936
				2017	2018	2019	2081	2082	2083	2146	2147	2148	2149	2349	2350
				2351	2352	2353	2354	2355	2356	2357	2446	2447	2448	2449	2450
				2451	2452	2453	2454	2538	2539	2540	2541	2542	2742	2743	2744
				2745	2746	2747	2748	2749	2750	2819	2820	2821	2822	2823	2824
				2825	2826	2827	4121	4122	4123	4406	4407	4408	4484	4485	4486
				4487	4488	4489	4490	4491	4492	4493	4494	5030	5031	5032	5033
				5034	5035	5036	5037	5038	5039	5040	5564	5565	5566	5567	5568
				5569	5570	6103	6104	6105	6196	6197	6198	6199	6270	6271	6272
				6346	6482	6689	6690	6691	6893	6894	6895	6896	6897	6898	7234
				7235	7236	7237	7559	7560	7561	7775	7776	7777	7778	7779	8200
				8201	8202	8203	8204	8604	8605	8606	8607	8778	8779	8780	8781
				8782	8941	8942	8943	8944	9098	9099	9100	9101	9102	9391	9392
				9393	9394	9395	9865	9866	9867	10040	10470	10627	10628	10629	10863
				10864	11121	11122	11123	11124	11125	11126	11127	11128	11238	11239	11240
				11241	11242	11243	11244	11245	11336	11337	11338	11339	11340	11341	11343
				11410	11411	11412	11413	11414	11415	11488	11489	11490	11491	11492	11493
				11593	11594	11595	11596	11597	11598	11599	11723	11724	11725	11726	11727
				11839	11840	11841	11842	11843	11844	11845	11933	11934	11935	11936	11937
				12030	12031	12032	12033	12034	12035	12036	12158	12159	12160	12207	12208
				12209	12210	12281	12284	12285	12286	12287	12288	12289	12290	12292	12293
				12294	12296	12297	12298	12299	12300	12522	12525	12526	12527	12528	12529
				12530	12531	12533	12534	12535	12537	12538	12539	12540	12541	12767	12889
				13047	13048	13049	13050	13051	13052	13053	13110	13111	13112	13114	13115
				13116	13117	13118	13208	13318	13428	13537	13538	13539	13540	13541	13542
				13543	13656	13657	13658	13659	13660	13760	13761	13762	13864	13940
U_LOADFE			 860+#
U_LOADSC			 856+#
U_LSRC				 595+#	 598+	 599+	 600+	 601+	 602+	 603+	 604+	 605+
U_LSRC_0A			 602+#	1936	7237	7561
U_LSRC_0B			 601+#	1598	1770	2019	2350	2351	2352	2353	2354	2355	2357	2447
				2448	2449	2450	2451	2452	2454	2542	11844	11937
U_LSRC_0Q			 600+#	2083	2149	2743	2744	2745	2746	2747	2748	2750	2820	2821
				2822	2823	2824	2825	2827	11122	11239	11242
U_LSRC_AB			 599+#	4494	5566	5567	5568	5644
U_LSRC_AQ			 598+#	4123
U_LSRC_D0			 605+#	1595	1934	2017	2081	2146	2147	2349	2446	2538	2539	2742
				2819	4121	4122	4205	4484	4485	5030	5565	5770	6104	6196	6197
				6270	6272	6346	6482	6689	6690	6893	6894	6895	6896	6897	7234
				7560	7775	7778	8200	8204	8604	8607	8778	8782	8944	9098	9102
				9391	9392	9394	9395	9866	10040	10470	10863	11124	11125	11126	11128
				11245	11336	11342	11343	11410	11416	11488	11490	11493	11593	11595	11596
				11599	11723	11727	11839	11843	11933	11936	12031	12032	12035	12158	12210
				12281	12284	12286	12292	12296	12298	12522	12525	12527	12533	12537	12539
				13047	13049	13110	13114	13116	13428	13537	13539	13656	13658	13760
U_LSRC_DA			 603+#	8605	11127	11494	11600	11728	11846	11938	12037	12211
U_LSRC_DQ			 604+#	11121	11238
U_MEM				 868+#	1593	1594	1598	1599	1619	1620	1716	1717	1769	1770	1935
				1936	2018	2019	2082	2083	2148	2149	2356	2357	2453	2454	2541
				2542	2749	2750	2826	2827	4407	4408	4492	4493	5039	5040	5569
				5570	6103	6104	6198	6199	6271	6272	6690	6691	6897	6898	7235
				7778	7779	8203	8204	8606	8607	8781	8782	8943	8944	9101	9102
				9393	9394	10627	10628	11122	11124	11125	11127	11239	11242	11337	11339
				11341	11411	11413	11415	11491	11597	11725	11840	11842	11845	11934	12033
				12158	12160	12209	12210	12284	12287	12289	12290	12293	12294	12297	12299
				12300	12525	12528	12530	12531	12534	12535	12538	12540	12541	13047	13050
				13052	13053	13111	13112	13115	13117	13118	13537	13540	13542	13543	13657
				13659	13660	13761	13762
U_MULTI_PREC			 876+#	4487	4488	4489
U_MULTI_SHIFT			 880+#
U_N				 888+#	1593	1594	1595	1598	1599	1619	1620	1716	1717	1769	1770
				1935	1936	2017	2018	2019	2081	2082	2083	2146	2147	2148	2149
				2356	2357	2453	2454	2538	2539	2541	2542	2749	2750	2826	2827
				4121	4122	4407	4408	4484	4485	4492	4493	5030	5039	5040	5565
				5569	5570	5770	6103	6104	6198	6199	6271	6272	6346	6482	6689
				6690	6691	6893	6894	6896	6897	6898	7234	7235	7237	7560	7561
				7777	7778	7779	8200	8202	8203	8204	8604	8605	8606	8607	8778
				8779	8780	8781	8782	8941	8942	8943	8944	9099	9101	9102	9391
				9392	9393	9394	9395	9866	10040	10470	10627	10628	10863	11121	11122
				11124	11125	11126	11127	11128	11238	11239	11242	11243	11245	11337	11339
				11341	11343	11411	11413	11415	11488	11489	11490	11491	11493	11593	11594
				11595	11596	11597	11599	11723	11725	11727	11839	11840	11842	11843	11844
				11845	11933	11934	11936	11937	12030	12031	12032	12033	12035	12036	12158
				12159	12160	12209	12210	12281	12284	12287	12289	12290	12293	12294	12297
				12299	12300	12522	12525	12527	12528	12530	12531	12533	12534	12535	12537
				12538	12540	12541	12767	12889	13047	13049	13050	13052	13053	13110	13111
				13112	13114	13115	13117	13118	13537	13540	13542	13543	13657	13659	13660
				13761	13762
U_NO_CLKL			 719+#	4490	4491	4492	5565	7776	11343
U_NO_CLKR			 732+#	5031	5032	7234	7775	8604
U_RAM_AC			 680+#	11493
U_RAM_AC_FN			 681+#	12036
U_RAM_N				 685+#	11844	11937
U_RAM_RAM			 684+#	11123	11124	11125	11126	11127	11240	11241	11243	11244	11338	11340
				11342	11412	11414	11416	11492	11494	11598	11600	11726	11728	11841	11846
				11935	11938	12034	12037	12208	12210	12211
U_RAM_VMA			 683+#	11727
U_RAM_XR			 682+#	11599
U_RAM				 677+#	 680+	 681+	 682+	 683+	 684+	 685+
U_RSRC				 608+#	 612+	 613+	 614+	 615+	 616+	 617+	 618+	 619+
U_RSRC_0A			 616+#	6896
U_RSRC_0B			 615+#
U_RSRC_0Q			 614+#
U_RSRC_AB			 613+#
U_RSRC_AQ			 612+#
U_RSRC_D0			 619+#	7237	7561
U_RSRC_DA			 617+#
U_RSRC_DQ			 618+#
U_SCAD				 894+#	 897+	 898+	 899+	 900+	 901+	 902+	 903+	 904+
U_SCADA				 907+#	 910+	 911+	 912+	 913+	 914+	 915+	 916+	 917+
U_SCADA_BYTE1			 913+#
U_SCADA_BYTE2			 914+#
U_SCADA_BYTE3			 915+#
U_SCADA_BYTE4			 916+#
U_SCADA_BYTE5			 917+#
U_SCADA_PTR44			 912+#
U_SCADA_SC			 910+#
U_SCADA_SN			 911+#
U_SCADB				 920+#	 923+	 924+	 925+	 926+
U_SCADB_EXP			 924+#
U_SCADB_FE			 923+#
U_SCADB_SHIFT			 925+#
U_SCADB_SIZE			 926+#
U_SCAD_A			 904+#
U_SCAD_ADD			 901+#
U_SCAD_AND			 902+#
U_SCAD_A_DEC			 903+#
U_SCAD_A_MUL2			 897+#
U_SCAD_OR			 898+#
U_SCAD_SUBB			 899+#
U_SCAD_SUB			 900+#
U_SET_GENL			 725+	 945+	 978+#
U_SET_GENR			 738+	 951+	 979+#
U_SET_RSRC			 610+	 939+	 977+#
U_SET				 610+	 725+	 738+	 939+	 945+	 951+	 962+	 988+#
U_SHSTYLE			 784+#	 787+	 788+	 789+	 790+	 791+	 792+	 793+	 794+
U_SHSTYLE_ASHC			 791+#
U_SHSTYLE_DIV			 793+#	4494
U_SHSTYLE_LSHC			 792+#
U_SHSTYLE_NORM			 787+#	5035	5036	5037	5038	5039
U_SHSTYLE_ONES			 789+#
U_SHSTYLE_ROT			 790+#
U_SHSTYLE_ROTC			 794+#
U_SHSTYLE_ZERO			 788+#
U_SKIP				 817+#	 820+	 821+	 822+	 823+	 824+	 825+	 826+	 827+	 828+	 829+	 830+
				 831+	 832+	 833+	 834+	 835+	 836+	 837+	 838+	 839+	 840+	 841+	 842+
				 843+
U_SKIP_1_MS			 843+#
U_SKIP_AC0			 827+#	10041
U_SKIP_ADEQ0			 838+#	1681	11124	11127	11342	11416	11494	11600	11728	11846	11938	12037
				12211
U_SKIP_ADLEQ0			 823+#
U_SKIP_ADREQ0			 824+#	5644
U_SKIP_CONTINUE			 842+#
U_SKIP_CRY0			 822+#	4205
U_SKIP_CRY1			 835+#	4123
U_SKIP_CRY2			 830+#
U_SKIP_DP0			 831+#
U_SKIP_DP18			 832+#
U_SKIP_EXECUTE			 840+#
U_SKIP_FPD			 826+#	10471
U_SKIP_INT			 828+#	7561
U_SKIP_IOLGL			 820+#
U_SKIP_IOT			 833+#
U_SKIP_IO_BUSY			 841+#
U_SKIP_JFCL			 834+#	8202
U_SKIP_KERNEL			 825+#
U_SKIP_LE			 829+#
U_SKIP_LLE			 821+#
U_SKIP_SC			 839+#
U_SKIP_TRAP_CYC			 837+#
U_SKIP_TXXX			 836+#	13429
U_SN				 929+#
U_SPEC				 745+#	 748+	 749+	 750+	 751+	 752+	 753+	 754+	 755+	 756+	 757+	 758+
				 759+	 760+	 761+	 762+	 763+	 764+	 765+	 766+	 767+	 768+	 769+	 770+
				 771+
U_SPEC_APRFLAGS			 758+#
U_SPEC_APR_EN			 760+#	1545	6482	6893	6894	9866
U_SPEC_ASHOV			 767+#	9100
U_SPEC_CLRCLK			 749+#	1547
U_SPEC_CLRCSH			 759+#
U_SPEC_CLRIOBSY			 751+#
U_SPEC_CLRIOLAT			 750+#
U_SPEC_EXPTST			 768+#	8942
U_SPEC_FLAGS			 769+#	1546	7776	7777	8200	8202	8605	8779	8780	8941	9099	9391
				9392	9395	9865	10470
U_SPEC_INHCRY18			 764+#
U_SPEC_LDACBLK			 770+#	11488	11595	11724	12032
U_SPEC_LDINST			 771+#	10040	12281	12522	13428
U_SPEC_LDPAGE			 752+#
U_SPEC_LDPI			 766+#	1548	6689	6690	6896	6897	7237	7559	7561
U_SPEC_LDPXCT			 754+#	11593
U_SPEC_LOADIR			 765+#	8201	8604	8778	11489	12030	12286	12292	12296	12527	12533	12537
				12767	12889	13049	13110	13114	13208	13318	13539	13656	13760	13864	13940
U_SPEC_LOADXR			 757+#	11594
U_SPEC_MEMCLR			 761+#	1549	7236	11121	11123	11126	11238	11240	11243	11338	11340	11412
				11414	11492	11598	11841	11843	11935	12285	12288	12298	12526	12529	12539
				13048	13051	13116	13538	13541	13658
U_SPEC_N			 748+#
U_SPEC_NICOND			 753+#
U_SPEC_PREV			 756+#
U_SPEC_PXCT_OFF			 763+#
U_SPEC_SWEEP			 762+#	12159	12207
U_SPEC_WAIT			 755+#
U_T				 846+#
VMAEN				13531	13563#	13565
VMA_LD				 100	1613*	4495	5041	6693	6899	7780	12449	12691	13119	13768
WAIT				1290+
WRT100				1324+
WRT102				1325+
WRT103				1326+
WRT104				1327+
WRT105				1328+
WRT106				1329+
WRT107				1330+
WRT110				1331+
WRT111				1332+
WRT112				1333+
WRT113				1334+
WRT114				1335+
WRT115				1336+
WRT116				1337+
WRT204				1338+	7251	7252	7278	7279	7305	7306	7332	7333	7359	7360	7386
				7387	7413	7414	7440	7441	7467	7468	7502	7503
WRT205				1339+
WRT206				1340+	7253	7280	7307	7334	7361	7388	7415	7442	7469	7504
WRT210				1341+
WRT212				1342+
WRTTST				13653	13679#	13681	13708
WR_CRAM				1299+
X				 745+	 746+	 774+	 775+	 784+	 785+	 797+	 798+	 817+	 818+	 846+	 847+
				 894+	 895+	 907+	 908+	 920+	 921+
X1				1300+
X1A_AC				1042+#	1166+
X1B_AC				1043+#	1167+
XMIT_ADR			 326+#
XMIT_DATA			 325+#


TIME: 42 SEC.
CORE: 23K
 